record_number,buggy_code,fixed_code
93001,"/** 
 * Creates a new   {@link Range} with the specified exclusive end and the current start. 
 */
public R endOpen(String end){
  return newInstanceSafe(startBound,start,BoundType.OPEN,wrap(end));
}","/** 
 * Creates a new   {@link Range} with the specified exclusive end and the current start. 
 */
public R endOpen(String end){
  return endOpen(wrap(end));
}"
93002,"/** 
 * Creates a new   {@link Range} with the specified inclusive start and the specified exclusiveend.
 */
public R of(String startClosed,String endOpen){
  return newInstanceSafe(BoundType.CLOSED,wrap(startClosed),BoundType.OPEN,wrap(endOpen));
}","/** 
 * Creates a new   {@link Range} with the specified inclusive start and the specified exclusiveend.
 */
public R of(String startClosed,String endOpen){
  return of(wrap(startClosed),wrap(endOpen));
}"
93003,"/** 
 * Creates a new   {@link Range} with an unbounded start and the current end. 
 */
public R startUnbounded(){
  return newInstanceSafe(BoundType.UNBOUNDED,null,endBound,end);
}","/** 
 * Creates a new   {@link Range} with an unbounded start and the current end. 
 */
public R startUnbounded(){
  this.start=null;
  this.startBound=BoundType.UNBOUNDED;
  return thisT();
}"
93004,"/** 
 * Creates a new   {@link Range} with the specified exclusive start and the current end. 
 */
public R startOpen(String start){
  return newInstanceSafe(BoundType.OPEN,wrap(start),endBound,end);
}","/** 
 * Creates a new   {@link Range} with the specified exclusive start and the current end. 
 */
public R startOpen(String start){
  return startOpen(wrap(start));
}"
93005,"/** 
 * Creates a new   {@link Range} with the current start and an unbounded end. 
 */
public R endUnbounded(){
  return newInstanceSafe(startBound,start,BoundType.UNBOUNDED,null);
}","/** 
 * Creates a new   {@link Range} with the current start and an unbounded end. 
 */
public R endUnbounded(){
  this.end=null;
  this.endBound=BoundType.UNBOUNDED;
  return thisT();
}"
93006,"@Override public TableResult getNextPage(){
  return new TableResult(schema,totalRows,pageNoSchema.getNextPage());
}","@Override public TableResult getNextPage(){
  if (pageNoSchema.hasNextPage()) {
    return new TableResult(schema,totalRows,pageNoSchema.getNextPage());
  }
  return null;
}"
93007,"TableResult(final Schema schema,long totalRows,Page<FieldValueList> pageNoSchema){
  this.schema=schema;
  this.totalRows=totalRows;
  this.pageNoSchema=checkNotNull(pageNoSchema);
}","TableResult(Schema schema,long totalRows,Page<FieldValueList> pageNoSchema){
  this.schema=schema;
  this.totalRows=totalRows;
  this.pageNoSchema=checkNotNull(pageNoSchema);
}"
93008,"private Iterable<FieldValueList> addSchema(Iterable<FieldValueList> iter){
  if (schema == null) {
    return iter;
  }
  return Iterables.transform(pageNoSchema.getValues(),new Function<FieldValueList,FieldValueList>(){
    @Override public FieldValueList apply(    FieldValueList list){
      return list.withSchema(schema.getFields());
    }
  }
);
}","private Iterable<FieldValueList> addSchema(Iterable<FieldValueList> iter){
  if (schema == null) {
    return iter;
  }
  return Iterables.transform(iter,new Function<FieldValueList,FieldValueList>(){
    @Override public FieldValueList apply(    FieldValueList list){
      return list.withSchema(schema.getFields());
    }
  }
);
}"
93009,"@Override public ManagedChannel newChannel(String host,int port){
  NettyChannelBuilder builder=NettyChannelBuilder.forAddress(host,port).sslContext(newSslContext()).intercept(interceptors).maxMessageSize(MAX_MESSAGE_SIZE);
  if (userAgent != null) {
    builder.userAgent(userAgent);
  }
  return builder.build();
}","@Override public ManagedChannel newChannel(String host,int port){
  NettyChannelBuilder builder=NettyChannelBuilder.forAddress(host,port).sslContext(newSslContext()).intercept(interceptors).maxHeaderListSize(MAX_HEADER_LIST_SIZE).maxMessageSize(MAX_MESSAGE_SIZE);
  if (userAgent != null) {
    builder.userAgent(userAgent);
  }
  return builder.build();
}"
93010,"/** 
 * Downloads this blob to the given file path.
 * @param path destination
 * @throws StorageException upon failure
 */
public void downloadTo(Path path) throws StorageException {
  try (OutputStream outputStream=Files.newOutputStream(path);ReadChannel reader=reader()){
    WritableByteChannel channel=Channels.newChannel(outputStream);
    ByteBuffer bytes=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
    while (reader.read(bytes) > 0) {
      bytes.flip();
      channel.write(bytes);
      bytes.clear();
    }
  }
 catch (  IOException e) {
    throw new StorageException(e);
  }
}","/** 
 * Downloads this blob to the given file path. This method is replaced with   {@link #downloadTo(Path,BlobSourceOption)}, but is kept here for binary compatibility with the older versions of the client library.
 * @param path destination
 * @throws StorageException upon failure
 */
public void downloadTo(Path path){
  downloadTo(path,new BlobSourceOption[0]);
}"
93011,"private Storage.BlobGetOption toGetOption(BlobInfo blobInfo){
switch (getRpcOption()) {
case IF_GENERATION_MATCH:
    return Storage.BlobGetOption.generationMatch(blobInfo.getGeneration());
case IF_GENERATION_NOT_MATCH:
  return Storage.BlobGetOption.generationNotMatch(blobInfo.getGeneration());
case IF_METAGENERATION_MATCH:
return Storage.BlobGetOption.metagenerationMatch(blobInfo.getMetageneration());
case IF_METAGENERATION_NOT_MATCH:
return Storage.BlobGetOption.metagenerationNotMatch(blobInfo.getMetageneration());
default :
throw new AssertionError(""String_Node_Str"");
}
}","private Storage.BlobGetOption toGetOption(BlobInfo blobInfo){
switch (getRpcOption()) {
case IF_GENERATION_MATCH:
    return Storage.BlobGetOption.generationMatch(blobInfo.getGeneration());
case IF_GENERATION_NOT_MATCH:
  return Storage.BlobGetOption.generationNotMatch(blobInfo.getGeneration());
case IF_METAGENERATION_MATCH:
return Storage.BlobGetOption.metagenerationMatch(blobInfo.getMetageneration());
case IF_METAGENERATION_NOT_MATCH:
return Storage.BlobGetOption.metagenerationNotMatch(blobInfo.getMetageneration());
case USER_PROJECT:
return Storage.BlobGetOption.userProject((String)getValue());
default :
throw new AssertionError(""String_Node_Str"");
}
}"
93012,"@Test public void testBuilder(){
  initializeExpectedBucket(4);
  expect(storage.getOptions()).andReturn(mockOptions).times(4);
  replay(storage);
  Bucket.Builder builder=new Bucket.Builder(new Bucket(storage,new BucketInfo.BuilderImpl(BUCKET_INFO)));
  Bucket bucket=builder.setAcl(ACLS).setEtag(ETAG).setGeneratedId(GENERATED_ID).setMetageneration(META_GENERATION).setOwner(OWNER).setSelfLink(SELF_LINK).setCors(CORS).setCreateTime(CREATE_TIME).setDefaultAcl(DEFAULT_ACL).setDeleteRules(DELETE_RULES).setIndexPage(INDEX_PAGE).setNotFoundPage(NOT_FOUND_PAGE).setLocation(LOCATION).setStorageClass(STORAGE_CLASS).setVersioningEnabled(VERSIONING_ENABLED).setLabels(BUCKET_LABELS).setRequesterPays(REQUESTER_PAYS).build();
  assertEquals(""String_Node_Str"",bucket.getName());
  assertEquals(ACLS,bucket.getAcl());
  assertEquals(ETAG,bucket.getEtag());
  assertEquals(GENERATED_ID,bucket.getGeneratedId());
  assertEquals(META_GENERATION,bucket.getMetageneration());
  assertEquals(OWNER,bucket.getOwner());
  assertEquals(SELF_LINK,bucket.getSelfLink());
  assertEquals(CREATE_TIME,bucket.getCreateTime());
  assertEquals(CORS,bucket.getCors());
  assertEquals(DEFAULT_ACL,bucket.getDefaultAcl());
  assertEquals(DELETE_RULES,bucket.getDeleteRules());
  assertEquals(INDEX_PAGE,bucket.getIndexPage());
  assertEquals(NOT_FOUND_PAGE,bucket.getNotFoundPage());
  assertEquals(LOCATION,bucket.getLocation());
  assertEquals(STORAGE_CLASS,bucket.getStorageClass());
  assertEquals(VERSIONING_ENABLED,bucket.versioningEnabled());
  assertEquals(BUCKET_LABELS,bucket.getLabels());
  assertEquals(VERSIONING_ENABLED,bucket.requesterPays());
  assertEquals(storage.getOptions(),bucket.getStorage().getOptions());
}","@Test public void testBuilder(){
  initializeExpectedBucket(4);
  expect(storage.getOptions()).andReturn(mockOptions).times(4);
  replay(storage);
  Bucket.Builder builder=new Bucket.Builder(new Bucket(storage,new BucketInfo.BuilderImpl(BUCKET_INFO)));
  Bucket bucket=builder.setAcl(ACLS).setEtag(ETAG).setGeneratedId(GENERATED_ID).setMetageneration(META_GENERATION).setOwner(OWNER).setSelfLink(SELF_LINK).setCors(CORS).setCreateTime(CREATE_TIME).setDefaultAcl(DEFAULT_ACL).setDeleteRules(DELETE_RULES).setIndexPage(INDEX_PAGE).setNotFoundPage(NOT_FOUND_PAGE).setLocation(LOCATION).setStorageClass(STORAGE_CLASS).setVersioningEnabled(VERSIONING_ENABLED).setLabels(BUCKET_LABELS).setRequesterPays(REQUESTER_PAYS).build();
  assertEquals(""String_Node_Str"",bucket.getName());
  assertEquals(ACLS,bucket.getAcl());
  assertEquals(ETAG,bucket.getEtag());
  assertEquals(GENERATED_ID,bucket.getGeneratedId());
  assertEquals(META_GENERATION,bucket.getMetageneration());
  assertEquals(OWNER,bucket.getOwner());
  assertEquals(SELF_LINK,bucket.getSelfLink());
  assertEquals(CREATE_TIME,bucket.getCreateTime());
  assertEquals(CORS,bucket.getCors());
  assertEquals(DEFAULT_ACL,bucket.getDefaultAcl());
  assertEquals(DELETE_RULES,bucket.getDeleteRules());
  assertEquals(INDEX_PAGE,bucket.getIndexPage());
  assertEquals(NOT_FOUND_PAGE,bucket.getNotFoundPage());
  assertEquals(LOCATION,bucket.getLocation());
  assertEquals(STORAGE_CLASS,bucket.getStorageClass());
  assertEquals(VERSIONING_ENABLED,bucket.versioningEnabled());
  assertEquals(BUCKET_LABELS,bucket.getLabels());
  assertEquals(REQUESTER_PAYS,bucket.requesterPays());
  assertEquals(storage.getOptions(),bucket.getStorage().getOptions());
}"
93013,"@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  BigQueryOptions.newBuilder().setTransportOptions(new TransportOptions(){
  }
);
}","@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  BigQueryOptions.newBuilder().setTransportOptions(EasyMock.createMock(TransportOptions.class));
}"
93014,"@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  ComputeOptions.newBuilder().setTransportOptions(new TransportOptions(){
  }
);
}","@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  ComputeOptions.newBuilder().setTransportOptions(EasyMock.createMock(TransportOptions.class));
}"
93015,"String getXGoogApiClientHeader(ServiceOptions<?,?> serviceOptions){
  return String.format(""String_Node_Str"",getJavaVersion(),ServiceOptions.getGoogApiClientLibName(),serviceOptions.getLibraryVersion());
}","/** 
 * Returns a string value for x-goog-api-client HTTP header. The header is used to report version of the client and its protocol-specific dependencies. For internal use.
 * @param libraryVersion version of the google-cloud-java library
 * @return value of x-goog-api-client HTTP header, which should be provided with each request
 */
String getXGoogApiClientHeader(String libraryVersion){
  return String.format(Locale.US,""String_Node_Str"",firstNonNull(Runtime.class.getPackage().getImplementationVersion(),""String_Node_Str""),ServiceOptions.getGoogApiClientLibName(),libraryVersion);
}"
93016,"@Override public void initialize(HttpRequest httpRequest) throws IOException {
  if (delegate != null) {
    delegate.initialize(httpRequest);
  }
  if (connectTimeout >= 0) {
    httpRequest.setConnectTimeout(connectTimeout);
  }
  if (readTimeout >= 0) {
    httpRequest.setReadTimeout(readTimeout);
  }
  HttpHeaders headers=httpRequest.getHeaders();
  headers.set(""String_Node_Str"",getXGoogApiClientHeader(serviceOptions));
}","@Override public void initialize(HttpRequest httpRequest) throws IOException {
  if (delegate != null) {
    delegate.initialize(httpRequest);
  }
  if (connectTimeout >= 0) {
    httpRequest.setConnectTimeout(connectTimeout);
  }
  if (readTimeout >= 0) {
    httpRequest.setReadTimeout(readTimeout);
  }
  HttpHeaders headers=httpRequest.getHeaders();
  headers.set(""String_Node_Str"",getXGoogApiClientHeader(serviceOptions.getLibraryVersion()));
}"
93017,"/** 
 * Returns a request initializer responsible for initializing requests according to service options.
 */
public HttpRequestInitializer getHttpRequestInitializer(final ServiceOptions<?,?> serviceOptions){
  Credentials scopedCredentials=serviceOptions.getScopedCredentials();
  final HttpRequestInitializer delegate=scopedCredentials != null && scopedCredentials != NoCredentials.getInstance() ? new HttpCredentialsAdapter(scopedCredentials) : null;
  return new HttpRequestInitializer(){
    @Override public void initialize(    HttpRequest httpRequest) throws IOException {
      if (delegate != null) {
        delegate.initialize(httpRequest);
      }
      if (connectTimeout >= 0) {
        httpRequest.setConnectTimeout(connectTimeout);
      }
      if (readTimeout >= 0) {
        httpRequest.setReadTimeout(readTimeout);
      }
      HttpHeaders headers=httpRequest.getHeaders();
      headers.set(""String_Node_Str"",getXGoogApiClientHeader(serviceOptions));
    }
  }
;
}","/** 
 * Returns a request initializer responsible for initializing requests according to service options.
 */
public HttpRequestInitializer getHttpRequestInitializer(final ServiceOptions<?,?> serviceOptions){
  Credentials scopedCredentials=serviceOptions.getScopedCredentials();
  final HttpRequestInitializer delegate=scopedCredentials != null && scopedCredentials != NoCredentials.getInstance() ? new HttpCredentialsAdapter(scopedCredentials) : null;
  return new HttpRequestInitializer(){
    @Override public void initialize(    HttpRequest httpRequest) throws IOException {
      if (delegate != null) {
        delegate.initialize(httpRequest);
      }
      if (connectTimeout >= 0) {
        httpRequest.setConnectTimeout(connectTimeout);
      }
      if (readTimeout >= 0) {
        httpRequest.setReadTimeout(readTimeout);
      }
      HttpHeaders headers=httpRequest.getHeaders();
      headers.set(""String_Node_Str"",getXGoogApiClientHeader(serviceOptions.getLibraryVersion()));
    }
  }
;
}"
93018,"@Test public void testHeader(){
  String expectedHeaderPattern=""String_Node_Str"";
  final ServiceOptions mockOptions=EasyMock.createMock(ServiceOptions.class);
  EasyMock.expect(mockOptions.getLibraryVersion()).andReturn(""String_Node_Str"");
  EasyMock.replay(mockOptions);
  assertTrue(Pattern.compile(expectedHeaderPattern).matcher(OPTIONS.getXGoogApiClientHeader(mockOptions)).find());
}","@Test public void testHeader(){
  String expectedHeaderPattern=""String_Node_Str"";
  assertTrue(Pattern.compile(expectedHeaderPattern).matcher(OPTIONS.getXGoogApiClientHeader(""String_Node_Str"")).find());
}"
93019,"@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  DatastoreOptions.newBuilder().setTransportOptions(new TransportOptions(){
  }
);
}","@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  DatastoreOptions.newBuilder().setTransportOptions(EasyMock.createMock(TransportOptions.class));
}"
93020,"@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  DnsOptions.newBuilder().setTransportOptions(new TransportOptions(){
  }
);
}","@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  DnsOptions.newBuilder().setTransportOptions(EasyMock.createMock(TransportOptions.class));
}"
93021,"@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  LoggingOptions.newBuilder().setTransportOptions(new TransportOptions(){
  }
);
}","@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  LoggingOptions.newBuilder().setTransportOptions(EasyMock.createMock(TransportOptions.class));
}"
93022,"@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  ResourceManagerOptions.newBuilder().setTransportOptions(new TransportOptions(){
  }
);
}","@Test public void testInvalidTransport(){
  thrown.expect(IllegalArgumentException.class);
  ResourceManagerOptions.newBuilder().setTransportOptions(EasyMock.createMock(TransportOptions.class));
}"
93023,"@Test public void testLoggingHandler() throws InterruptedException {
  String logName=formatForTest(""String_Node_Str"");
  LoggingOptions options=logging().getOptions();
  LoggingHandler handler=new LoggingHandler(logName,options);
  handler.setLevel(Level.INFO);
  Logger logger=Logger.getLogger(getClass().getName());
  logger.addHandler(handler);
  logger.setLevel(Level.INFO);
  logger.info(""String_Node_Str"");
  Iterator<LogEntry> iterator=logging().listLogEntries(EntryListOption.filter(""String_Node_Str"" + logName)).iterateAll().iterator();
  while (!iterator.hasNext()) {
    Thread.sleep(500L);
    iterator=logging().listLogEntries(EntryListOption.filter(""String_Node_Str"" + logName)).iterateAll().iterator();
  }
  assertTrue(iterator.hasNext());
  LogEntry entry=iterator.next();
  assertTrue(entry.getPayload() instanceof StringPayload);
  assertTrue(entry.<StringPayload>getPayload().getData().contains(""String_Node_Str""));
  assertEquals(logName,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",String.valueOf(Level.INFO.intValue())),entry.getLabels());
  assertEquals(""String_Node_Str"",entry.getResource().getType());
  assertEquals(ImmutableMap.of(""String_Node_Str"",options.getProjectId()),entry.getResource().getLabels());
  assertNull(entry.getHttpRequest());
  assertEquals(Severity.INFO,entry.getSeverity());
  assertNull(entry.getOperation());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  assertFalse(iterator.hasNext());
  logger.removeHandler(handler);
  logging().deleteLog(logName);
}","@Test public void testLoggingHandler() throws InterruptedException {
  String logId=formatForTest(""String_Node_Str"");
  LoggingOptions options=logging().getOptions();
  LogName logName=LogName.create(options.getProjectId(),logId);
  LoggingHandler handler=new LoggingHandler(logId,options);
  handler.setLevel(Level.INFO);
  Logger logger=Logger.getLogger(getClass().getName());
  logger.addHandler(handler);
  logger.setLevel(Level.INFO);
  logger.info(""String_Node_Str"");
  String filter=createEqualityFilter(""String_Node_Str"",logName);
  Iterator<LogEntry> iterator=logging().listLogEntries(EntryListOption.filter(filter)).iterateAll().iterator();
  while (!iterator.hasNext()) {
    Thread.sleep(500L);
    iterator=logging().listLogEntries(EntryListOption.filter(filter)).iterateAll().iterator();
  }
  assertTrue(iterator.hasNext());
  LogEntry entry=iterator.next();
  assertTrue(entry.getPayload() instanceof StringPayload);
  assertTrue(entry.<StringPayload>getPayload().getData().contains(""String_Node_Str""));
  assertEquals(logId,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",String.valueOf(Level.INFO.intValue())),entry.getLabels());
  assertEquals(""String_Node_Str"",entry.getResource().getType());
  assertEquals(ImmutableMap.of(""String_Node_Str"",options.getProjectId()),entry.getResource().getLabels());
  assertNull(entry.getHttpRequest());
  assertEquals(Severity.INFO,entry.getSeverity());
  assertNull(entry.getOperation());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  assertFalse(iterator.hasNext());
  logger.removeHandler(handler);
  logging().deleteLog(logId);
}"
93024,"@Test public void testSyncLoggingHandler() throws InterruptedException {
  String logName=formatForTest(""String_Node_Str"");
  LoggingOptions options=logging().getOptions();
  MonitoredResource resource=MonitoredResource.of(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",options.getProjectId(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  LoggingHandler handler=new LoggingHandler(logName,options,resource);
  handler.setLevel(Level.WARNING);
  handler.setSynchronicity(Synchronicity.SYNC);
  Logger logger=Logger.getLogger(getClass().getName());
  logger.addHandler(handler);
  logger.setLevel(Level.WARNING);
  logger.warning(""String_Node_Str"");
  Iterator<LogEntry> iterator=logging().listLogEntries(EntryListOption.filter(""String_Node_Str"" + logName)).iterateAll().iterator();
  while (!iterator.hasNext()) {
    Thread.sleep(500L);
    iterator=logging().listLogEntries(EntryListOption.filter(""String_Node_Str"" + logName)).iterateAll().iterator();
  }
  assertTrue(iterator.hasNext());
  LogEntry entry=iterator.next();
  assertTrue(entry.getPayload() instanceof StringPayload);
  assertTrue(entry.<StringPayload>getPayload().getData().contains(""String_Node_Str""));
  assertEquals(logName,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",String.valueOf(Level.WARNING.intValue())),entry.getLabels());
  assertEquals(resource,entry.getResource());
  assertNull(entry.getHttpRequest());
  assertEquals(Severity.WARNING,entry.getSeverity());
  assertNull(entry.getOperation());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  assertFalse(iterator.hasNext());
  logger.removeHandler(handler);
  logging().deleteLog(logName);
}","@Test public void testSyncLoggingHandler() throws InterruptedException {
  String logId=formatForTest(""String_Node_Str"");
  LoggingOptions options=logging().getOptions();
  LogName logName=LogName.create(options.getProjectId(),logId);
  MonitoredResource resource=MonitoredResource.of(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",options.getProjectId(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  LoggingHandler handler=new LoggingHandler(logId,options,resource);
  handler.setLevel(Level.WARNING);
  handler.setSynchronicity(Synchronicity.SYNC);
  Logger logger=Logger.getLogger(getClass().getName());
  logger.addHandler(handler);
  logger.setLevel(Level.WARNING);
  logger.warning(""String_Node_Str"");
  String filter=createEqualityFilter(""String_Node_Str"",logName);
  Iterator<LogEntry> iterator=logging().listLogEntries(EntryListOption.filter(filter)).iterateAll().iterator();
  while (!iterator.hasNext()) {
    Thread.sleep(500L);
    iterator=logging().listLogEntries(EntryListOption.filter(filter)).iterateAll().iterator();
  }
  assertTrue(iterator.hasNext());
  LogEntry entry=iterator.next();
  assertTrue(entry.getPayload() instanceof StringPayload);
  assertTrue(entry.<StringPayload>getPayload().getData().contains(""String_Node_Str""));
  assertEquals(logId,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",String.valueOf(Level.WARNING.intValue())),entry.getLabels());
  assertEquals(resource,entry.getResource());
  assertNull(entry.getHttpRequest());
  assertEquals(Severity.WARNING,entry.getSeverity());
  assertNull(entry.getOperation());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  assertFalse(iterator.hasNext());
  logger.removeHandler(handler);
  logging().deleteLog(logId);
}"
93025,"@Test public void testWriteAndListLogEntries() throws InterruptedException {
  String logName=formatForTest(""String_Node_Str"");
  String filter=""String_Node_Str"" + logging().getOptions().getProjectId() + ""String_Node_Str""+ logName;
  StringPayload firstPayload=StringPayload.of(""String_Node_Str"");
  LogEntry firstEntry=LogEntry.newBuilder(firstPayload).addLabel(""String_Node_Str"",""String_Node_Str"").setLogName(logName).setHttpRequest(HttpRequest.newBuilder().setStatus(500).build()).setResource(MonitoredResource.newBuilder(""String_Node_Str"").build()).build();
  JsonPayload secondPayload=JsonPayload.of(ImmutableMap.<String,Object>of(""String_Node_Str"",""String_Node_Str""));
  LogEntry secondEntry=LogEntry.newBuilder(secondPayload).addLabel(""String_Node_Str"",""String_Node_Str"").setLogName(logName).setOperation(Operation.of(""String_Node_Str"",""String_Node_Str"")).setResource(MonitoredResource.newBuilder(""String_Node_Str"").build()).build();
  logging().write(ImmutableList.of(firstEntry));
  logging().write(ImmutableList.of(secondEntry));
  EntryListOption[] options={EntryListOption.filter(filter),EntryListOption.pageSize(1)};
  Page<LogEntry> page=logging().listLogEntries(options);
  while (Iterators.size(page.iterateAll().iterator()) < 2) {
    Thread.sleep(500);
    page=logging().listLogEntries(options);
  }
  Iterator<LogEntry> iterator=page.iterateAll().iterator();
  assertTrue(iterator.hasNext());
  LogEntry entry=iterator.next();
  assertEquals(firstPayload,entry.getPayload());
  assertEquals(logName,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""),entry.getLabels());
  assertEquals(""String_Node_Str"",entry.getResource().getType());
  assertEquals(HttpRequest.newBuilder().setStatus(500).build(),entry.getHttpRequest());
  assertEquals(Severity.DEFAULT,entry.getSeverity());
  assertNull(entry.getOperation());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  assertTrue(iterator.hasNext());
  entry=iterator.next();
  assertEquals(secondPayload,entry.getPayload());
  assertEquals(logName,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""),entry.getLabels());
  assertEquals(""String_Node_Str"",entry.getResource().getType());
  assertEquals(Operation.of(""String_Node_Str"",""String_Node_Str""),entry.getOperation());
  assertEquals(Severity.DEFAULT,entry.getSeverity());
  assertNull(entry.getHttpRequest());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  options=new EntryListOption[]{EntryListOption.filter(filter),EntryListOption.sortOrder(SortingField.TIMESTAMP,SortingOrder.DESCENDING)};
  page=logging().listLogEntries(options);
  while (Iterators.size(page.iterateAll().iterator()) < 2) {
    Thread.sleep(500);
    page=logging().listLogEntries(options);
  }
  iterator=page.iterateAll().iterator();
  Long lastTimestamp=iterator.next().getTimestamp();
  while (iterator.hasNext()) {
    assertTrue(iterator.next().getTimestamp() <= lastTimestamp);
  }
  assertTrue(logging().deleteLog(logName));
}","@Test public void testWriteAndListLogEntries() throws InterruptedException {
  String logId=formatForTest(""String_Node_Str"");
  LoggingOptions loggingOptions=logging().getOptions();
  LogName logName=LogName.create(loggingOptions.getProjectId(),logId);
  StringPayload firstPayload=StringPayload.of(""String_Node_Str"");
  LogEntry firstEntry=LogEntry.newBuilder(firstPayload).addLabel(""String_Node_Str"",""String_Node_Str"").setLogName(logId).setHttpRequest(HttpRequest.newBuilder().setStatus(500).build()).setResource(MonitoredResource.newBuilder(""String_Node_Str"").build()).build();
  JsonPayload secondPayload=JsonPayload.of(ImmutableMap.<String,Object>of(""String_Node_Str"",""String_Node_Str""));
  LogEntry secondEntry=LogEntry.newBuilder(secondPayload).addLabel(""String_Node_Str"",""String_Node_Str"").setLogName(logId).setOperation(Operation.of(""String_Node_Str"",""String_Node_Str"")).setResource(MonitoredResource.newBuilder(""String_Node_Str"").build()).build();
  logging().write(ImmutableList.of(firstEntry));
  logging().write(ImmutableList.of(secondEntry));
  String filter=createEqualityFilter(""String_Node_Str"",logName);
  EntryListOption[] options={EntryListOption.filter(filter),EntryListOption.pageSize(1)};
  Page<LogEntry> page=logging().listLogEntries(options);
  while (Iterators.size(page.iterateAll().iterator()) < 2) {
    Thread.sleep(500);
    page=logging().listLogEntries(options);
  }
  Iterator<LogEntry> iterator=page.iterateAll().iterator();
  assertTrue(iterator.hasNext());
  LogEntry entry=iterator.next();
  assertEquals(firstPayload,entry.getPayload());
  assertEquals(logId,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""),entry.getLabels());
  assertEquals(""String_Node_Str"",entry.getResource().getType());
  assertEquals(HttpRequest.newBuilder().setStatus(500).build(),entry.getHttpRequest());
  assertEquals(Severity.DEFAULT,entry.getSeverity());
  assertNull(entry.getOperation());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  assertTrue(iterator.hasNext());
  entry=iterator.next();
  assertEquals(secondPayload,entry.getPayload());
  assertEquals(logId,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""),entry.getLabels());
  assertEquals(""String_Node_Str"",entry.getResource().getType());
  assertEquals(Operation.of(""String_Node_Str"",""String_Node_Str""),entry.getOperation());
  assertEquals(Severity.DEFAULT,entry.getSeverity());
  assertNull(entry.getHttpRequest());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  options=new EntryListOption[]{EntryListOption.filter(filter),EntryListOption.sortOrder(SortingField.TIMESTAMP,SortingOrder.DESCENDING)};
  page=logging().listLogEntries(options);
  while (Iterators.size(page.iterateAll().iterator()) < 2) {
    Thread.sleep(500);
    page=logging().listLogEntries(options);
  }
  iterator=page.iterateAll().iterator();
  Long lastTimestamp=iterator.next().getTimestamp();
  while (iterator.hasNext()) {
    assertTrue(iterator.next().getTimestamp() <= lastTimestamp);
  }
  assertTrue(logging().deleteLog(logId));
}"
93026,"@Test public void testDeleteNonExistingLogAsync() throws ExecutionException, InterruptedException {
  String logName=formatForTest(""String_Node_Str"");
  assertFalse(logging().deleteLogAsync(logName).get());
}","@Test public void testDeleteNonExistingLogAsync() throws ExecutionException, InterruptedException {
  String logId=formatForTest(""String_Node_Str"");
  assertFalse(logging().deleteLogAsync(logId).get());
}"
93027,"@Test public void testWriteAndListLogEntriesAsync() throws InterruptedException, ExecutionException {
  String logName=formatForTest(""String_Node_Str"");
  String filter=""String_Node_Str"" + logging().getOptions().getProjectId() + ""String_Node_Str""+ logName;
  StringPayload firstPayload=StringPayload.of(""String_Node_Str"");
  LogEntry firstEntry=LogEntry.newBuilder(firstPayload).setSeverity(Severity.ALERT).build();
  ProtoPayload secondPayload=ProtoPayload.of(Any.pack(StringValue.newBuilder().setValue(""String_Node_Str"").build()));
  LogEntry secondEntry=LogEntry.newBuilder(secondPayload).setSeverity(Severity.DEBUG).build();
  logging().write(ImmutableList.of(firstEntry,secondEntry),WriteOption.labels(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")),WriteOption.resource(MonitoredResource.newBuilder(""String_Node_Str"").build()),WriteOption.logName(logName));
  logging().flush();
  EntryListOption[] options={EntryListOption.filter(filter),EntryListOption.pageSize(1)};
  AsyncPage<LogEntry> page=logging().listLogEntriesAsync(options).get();
  while (Iterators.size(page.iterateAll().iterator()) < 2) {
    Thread.sleep(500);
    page=logging().listLogEntriesAsync(options).get();
  }
  Iterator<LogEntry> iterator=page.iterateAll().iterator();
  assertTrue(iterator.hasNext());
  LogEntry entry=iterator.next();
  assertEquals(firstPayload,entry.getPayload());
  assertEquals(logName,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""),entry.getLabels());
  assertEquals(""String_Node_Str"",entry.getResource().getType());
  assertNull(entry.getHttpRequest());
  assertEquals(Severity.ALERT,entry.getSeverity());
  assertNull(entry.getOperation());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  assertTrue(iterator.hasNext());
  entry=iterator.next();
  assertEquals(secondPayload,entry.getPayload());
  assertEquals(logName,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""),entry.getLabels());
  assertEquals(""String_Node_Str"",entry.getResource().getType());
  assertNull(entry.getOperation());
  assertEquals(Severity.DEBUG,entry.getSeverity());
  assertNull(entry.getHttpRequest());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  assertTrue(logging().deleteLogAsync(logName).get());
}","@Test public void testWriteAndListLogEntriesAsync() throws InterruptedException, ExecutionException {
  String logId=formatForTest(""String_Node_Str"");
  LoggingOptions loggingOptions=logging().getOptions();
  LogName logName=LogName.create(loggingOptions.getProjectId(),logId);
  StringPayload firstPayload=StringPayload.of(""String_Node_Str"");
  LogEntry firstEntry=LogEntry.newBuilder(firstPayload).setSeverity(Severity.ALERT).build();
  ProtoPayload secondPayload=ProtoPayload.of(Any.pack(StringValue.newBuilder().setValue(""String_Node_Str"").build()));
  LogEntry secondEntry=LogEntry.newBuilder(secondPayload).setSeverity(Severity.DEBUG).build();
  logging().write(ImmutableList.of(firstEntry,secondEntry),WriteOption.labels(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")),WriteOption.resource(MonitoredResource.newBuilder(""String_Node_Str"").build()),WriteOption.logName(logId));
  logging().flush();
  String filter=createEqualityFilter(""String_Node_Str"",logName);
  EntryListOption[] options={EntryListOption.filter(filter),EntryListOption.pageSize(1)};
  AsyncPage<LogEntry> page=logging().listLogEntriesAsync(options).get();
  while (Iterators.size(page.iterateAll().iterator()) < 2) {
    Thread.sleep(500);
    page=logging().listLogEntriesAsync(options).get();
  }
  Iterator<LogEntry> iterator=page.iterateAll().iterator();
  assertTrue(iterator.hasNext());
  LogEntry entry=iterator.next();
  assertEquals(firstPayload,entry.getPayload());
  assertEquals(logId,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""),entry.getLabels());
  assertEquals(""String_Node_Str"",entry.getResource().getType());
  assertNull(entry.getHttpRequest());
  assertEquals(Severity.ALERT,entry.getSeverity());
  assertNull(entry.getOperation());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  assertTrue(iterator.hasNext());
  entry=iterator.next();
  assertEquals(secondPayload,entry.getPayload());
  assertEquals(logId,entry.getLogName());
  assertEquals(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""),entry.getLabels());
  assertEquals(""String_Node_Str"",entry.getResource().getType());
  assertNull(entry.getOperation());
  assertEquals(Severity.DEBUG,entry.getSeverity());
  assertNull(entry.getHttpRequest());
  assertNotNull(entry.getInsertId());
  assertNotNull(entry.getTimestamp());
  assertTrue(logging().deleteLogAsync(logId).get());
}"
93028,"@Test public void testDeleteNonExistingLog(){
  String logName=formatForTest(""String_Node_Str"");
  assertFalse(logging().deleteLog(logName));
}","@Test public void testDeleteNonExistingLog(){
  String logId=formatForTest(""String_Node_Str"");
  assertFalse(logging().deleteLog(logId));
}"
93029,"private void setupNextAckDeadlineExtensionAlarm(Instant expiration){
  Instant possibleNextAlarmTime=expiration.minus(ackExpirationPadding);
  alarmsLock.lock();
  try {
    if (nextAckDeadlineExtensionAlarmTime.isAfter(possibleNextAlarmTime)) {
      logger.log(Level.FINER,""String_Node_Str"",new Object[]{possibleNextAlarmTime,nextAckDeadlineExtensionAlarmTime});
      if (ackDeadlineExtensionAlarm != null) {
        logger.log(Level.FINER,""String_Node_Str"");
        ackDeadlineExtensionAlarm.cancel(false);
      }
      nextAckDeadlineExtensionAlarmTime=possibleNextAlarmTime;
      ackDeadlineExtensionAlarm=executor.schedule(new AckDeadlineAlarm(),nextAckDeadlineExtensionAlarmTime.getMillis() - clock.millisTime(),TimeUnit.MILLISECONDS);
    }
  }
  finally {
    alarmsLock.unlock();
  }
}","private void setupNextAckDeadlineExtensionAlarm(Instant expiration){
  Instant possibleNextAlarmTime=expiration.minus(ackExpirationPadding);
  alarmsLock.lock();
  try {
    if (nextAckDeadlineExtensionAlarmTime.isAfter(possibleNextAlarmTime)) {
      logger.log(Level.FINER,""String_Node_Str"",new Object[]{possibleNextAlarmTime,nextAckDeadlineExtensionAlarmTime});
      if (ackDeadlineExtensionAlarm != null) {
        logger.log(Level.FINER,""String_Node_Str"");
        ackDeadlineExtensionAlarm.cancel(false);
      }
      nextAckDeadlineExtensionAlarmTime=possibleNextAlarmTime;
      ackDeadlineExtensionAlarm=alarmsExecutor.schedule(new AckDeadlineAlarm(),nextAckDeadlineExtensionAlarmTime.getMillis() - clock.millisTime(),TimeUnit.MILLISECONDS);
    }
  }
  finally {
    alarmsLock.unlock();
  }
}"
93030,"@Override public void onFailure(Throwable t){
  logger.log(Level.WARNING,""String_Node_Str"" + ackId + ""String_Node_Str"",t);
  acked.getAndSet(true);
synchronized (pendingNacks) {
    pendingNacks.add(ackId);
  }
  setupPendingAcksAlarm();
  flowController.release(1,outstandingBytes);
  messagesWaiter.incrementPendingMessages(-1);
}","@Override public void onFailure(Throwable t){
  logger.log(Level.WARNING,""String_Node_Str"" + ackId + ""String_Node_Str"",t);
  acked.getAndSet(true);
synchronized (pendingNacks) {
    pendingNacks.add(ackId);
  }
  setupPendingAcksAlarm();
  flowController.release(1,outstandingBytes);
  messagesWaiter.incrementPendingMessages(-1);
  processOutstandingBatches();
}"
93031,"private void setupPendingAcksAlarm(){
  alarmsLock.lock();
  try {
    if (pendingAcksAlarm == null) {
      pendingAcksAlarm=executor.schedule(new Runnable(){
        @Override public void run(){
          alarmsLock.lock();
          try {
            pendingAcksAlarm=null;
          }
  finally {
            alarmsLock.unlock();
          }
          processOutstandingAckOperations();
        }
      }
,PENDING_ACKS_SEND_DELAY.getMillis(),TimeUnit.MILLISECONDS);
    }
  }
  finally {
    alarmsLock.unlock();
  }
}","private void setupPendingAcksAlarm(){
  alarmsLock.lock();
  try {
    if (pendingAcksAlarm == null) {
      pendingAcksAlarm=alarmsExecutor.schedule(new Runnable(){
        @Override public void run(){
          alarmsLock.lock();
          try {
            pendingAcksAlarm=null;
          }
  finally {
            alarmsLock.unlock();
          }
          processOutstandingAckOperations();
        }
      }
,PENDING_ACKS_SEND_DELAY.getMillis(),TimeUnit.MILLISECONDS);
    }
  }
  finally {
    alarmsLock.unlock();
  }
}"
93032,"MessageDispatcher(MessageReceiver receiver,AckProcessor ackProcessor,Duration ackExpirationPadding,Duration maxAckExtensionPeriod,Distribution ackLatencyDistribution,FlowController flowController,ScheduledExecutorService executor,ApiClock clock){
  this.executor=executor;
  this.ackExpirationPadding=ackExpirationPadding;
  this.maxAckExtensionPeriod=maxAckExtensionPeriod;
  this.receiver=receiver;
  this.ackProcessor=ackProcessor;
  this.flowController=flowController;
  outstandingAckHandlers=new PriorityQueue<>();
  pendingAcks=new HashSet<>();
  pendingNacks=new HashSet<>();
  this.ackLatencyDistribution=ackLatencyDistribution;
  alarmsLock=new ReentrantLock();
  nextAckDeadlineExtensionAlarmTime=new Instant(Long.MAX_VALUE);
  messagesWaiter=new MessageWaiter();
  this.clock=clock;
}","MessageDispatcher(MessageReceiver receiver,AckProcessor ackProcessor,Duration ackExpirationPadding,Duration maxAckExtensionPeriod,Distribution ackLatencyDistribution,FlowController flowController,ScheduledExecutorService executor,@Nullable ScheduledExecutorService alarmsExecutor,ApiClock clock){
  this.executor=executor;
  this.alarmsExecutor=alarmsExecutor == null ? SHARED_ALARMS_EXECUTOR : alarmsExecutor;
  this.ackExpirationPadding=ackExpirationPadding;
  this.maxAckExtensionPeriod=maxAckExtensionPeriod;
  this.receiver=receiver;
  this.ackProcessor=ackProcessor;
  this.flowController=flowController;
  outstandingMessageBatches=new LinkedList<>();
  outstandingAckHandlers=new PriorityQueue<>();
  pendingAcks=new HashSet<>();
  pendingNacks=new HashSet<>();
  this.ackLatencyDistribution=ackLatencyDistribution;
  alarmsLock=new ReentrantLock();
  nextAckDeadlineExtensionAlarmTime=new Instant(Long.MAX_VALUE);
  messagesWaiter=new MessageWaiter();
  this.clock=clock;
}"
93033,"public void processReceivedMessages(List<com.google.pubsub.v1.ReceivedMessage> responseMessages){
  int receivedMessagesCount=responseMessages.size();
  if (receivedMessagesCount == 0) {
    return;
  }
  Instant now=new Instant(clock.millisTime());
  int totalByteCount=0;
  final ArrayList<AckHandler> ackHandlers=new ArrayList<>(responseMessages.size());
  for (  ReceivedMessage pubsubMessage : responseMessages) {
    int messageSize=pubsubMessage.getMessage().getSerializedSize();
    totalByteCount+=messageSize;
    ackHandlers.add(new AckHandler(pubsubMessage.getAckId(),messageSize));
  }
  Instant expiration=now.plus(messageDeadlineSeconds * 1000);
  logger.log(Level.FINER,""String_Node_Str"",new Object[]{responseMessages.size(),now});
  messagesWaiter.incrementPendingMessages(responseMessages.size());
  Iterator<AckHandler> acksIterator=ackHandlers.iterator();
  for (  ReceivedMessage userMessage : responseMessages) {
    final PubsubMessage message=userMessage.getMessage();
    final AckHandler ackHandler=acksIterator.next();
    final SettableFuture<AckReply> response=SettableFuture.create();
    final AckReplyConsumer consumer=new AckReplyConsumer(){
      @Override public void ack(){
        response.set(AckReply.ACK);
      }
      @Override public void nack(){
        response.set(AckReply.NACK);
      }
    }
;
    Futures.addCallback(response,ackHandler);
    executor.submit(new Runnable(){
      @Override public void run(){
        try {
          receiver.receiveMessage(message,consumer);
        }
 catch (        Exception e) {
          response.setException(e);
        }
      }
    }
);
  }
synchronized (outstandingAckHandlers) {
    outstandingAckHandlers.add(new ExtensionJob(new Instant(clock.millisTime()),expiration,INITIAL_ACK_DEADLINE_EXTENSION_SECONDS,ackHandlers));
  }
  setupNextAckDeadlineExtensionAlarm(expiration);
  try {
    flowController.reserve(receivedMessagesCount,totalByteCount);
  }
 catch (  FlowController.FlowControlException unexpectedException) {
    throw new IllegalStateException(""String_Node_Str"",unexpectedException);
  }
}","public void processReceivedMessages(List<ReceivedMessage> messages,Runnable doneCallback){
  if (messages.isEmpty()) {
    doneCallback.run();
    return;
  }
  messagesWaiter.incrementPendingMessages(messages.size());
  OutstandingMessagesBatch outstandingBatch=new OutstandingMessagesBatch(doneCallback);
  final ArrayList<AckHandler> ackHandlers=new ArrayList<>(messages.size());
  for (  ReceivedMessage message : messages) {
    AckHandler ackHandler=new AckHandler(message.getAckId(),message.getMessage().getSerializedSize());
    ackHandlers.add(ackHandler);
    outstandingBatch.addMessage(message,ackHandler);
  }
  Instant expiration=new Instant(clock.millisTime()).plus(messageDeadlineSeconds * 1000);
synchronized (outstandingAckHandlers) {
    outstandingAckHandlers.add(new ExtensionJob(new Instant(clock.millisTime()),expiration,INITIAL_ACK_DEADLINE_EXTENSION_SECONDS,ackHandlers));
  }
  setupNextAckDeadlineExtensionAlarm(expiration);
synchronized (outstandingMessageBatches) {
    outstandingMessageBatches.add(outstandingBatch);
  }
  processOutstandingBatches();
}"
93034,"@Override public void onSuccess(AckReply reply){
  acked.getAndSet(true);
switch (reply) {
case ACK:
synchronized (pendingAcks) {
      pendingAcks.add(ackId);
    }
  setupPendingAcksAlarm();
flowController.release(1,outstandingBytes);
ackLatencyDistribution.record(Ints.saturatedCast((long)Math.ceil((clock.millisTime() - receivedTime.getMillis()) / 1000D)));
messagesWaiter.incrementPendingMessages(-1);
return;
case NACK:
synchronized (pendingNacks) {
pendingNacks.add(ackId);
}
setupPendingAcksAlarm();
flowController.release(1,outstandingBytes);
messagesWaiter.incrementPendingMessages(-1);
return;
default :
throw new IllegalArgumentException(String.format(""String_Node_Str"",reply));
}
}","@Override public void onSuccess(AckReply reply){
  acked.getAndSet(true);
switch (reply) {
case ACK:
synchronized (pendingAcks) {
      pendingAcks.add(ackId);
    }
  ackLatencyDistribution.record(Ints.saturatedCast((long)Math.ceil((clock.millisTime() - receivedTime.getMillis()) / 1000D)));
break;
case NACK:
synchronized (pendingNacks) {
pendingNacks.add(ackId);
}
break;
default :
throw new IllegalArgumentException(String.format(""String_Node_Str"",reply));
}
setupPendingAcksAlarm();
flowController.release(1,outstandingBytes);
messagesWaiter.incrementPendingMessages(-1);
processOutstandingBatches();
}"
93035,"private void pullMessages(final Duration backoff){
  ListenableFuture<PullResponse> pullResult=stub.withDeadlineAfter(DEFAULT_TIMEOUT.getMillis(),TimeUnit.MILLISECONDS).pull(PullRequest.newBuilder().setSubscription(subscription).setMaxMessages(DEFAULT_MAX_MESSAGES).setReturnImmediately(true).build());
  Futures.addCallback(pullResult,new FutureCallback<PullResponse>(){
    @Override public void onSuccess(    PullResponse pullResponse){
      messageDispatcher.processReceivedMessages(pullResponse.getReceivedMessagesList());
      if (pullResponse.getReceivedMessagesCount() == 0) {
        executor.schedule(new Runnable(){
          @Override public void run(){
            Duration newBackoff=backoff.multipliedBy(2);
            if (newBackoff.isLongerThan(MAX_BACKOFF)) {
              newBackoff=MAX_BACKOFF;
            }
            pullMessages(newBackoff);
          }
        }
,backoff.getMillis(),TimeUnit.MILLISECONDS);
        return;
      }
      pullMessages(INITIAL_BACKOFF);
    }
    @Override public void onFailure(    Throwable cause){
      if (!isAlive()) {
        logger.log(Level.FINE,""String_Node_Str"",cause);
        return;
      }
      if (StatusUtil.isRetryable(cause)) {
        logger.log(Level.SEVERE,""String_Node_Str"",cause);
        executor.schedule(new Runnable(){
          @Override public void run(){
            Duration newBackoff=backoff.multipliedBy(2);
            if (newBackoff.isLongerThan(MAX_BACKOFF)) {
              newBackoff=MAX_BACKOFF;
            }
            pullMessages(newBackoff);
          }
        }
,backoff.getMillis(),TimeUnit.MILLISECONDS);
      }
 else {
        messageDispatcher.stop();
        notifyFailed(cause);
      }
    }
  }
);
}","private void pullMessages(final Duration backoff){
  ListenableFuture<PullResponse> pullResult=stub.withDeadlineAfter(DEFAULT_TIMEOUT.getMillis(),TimeUnit.MILLISECONDS).pull(PullRequest.newBuilder().setSubscription(subscription).setMaxMessages(maxDesiredPulledMessages).setReturnImmediately(true).build());
  Futures.addCallback(pullResult,new FutureCallback<PullResponse>(){
    @Override public void onSuccess(    PullResponse pullResponse){
      if (pullResponse.getReceivedMessagesCount() == 0) {
        executor.schedule(new Runnable(){
          @Override public void run(){
            Duration newBackoff=backoff.multipliedBy(2);
            if (newBackoff.isLongerThan(MAX_BACKOFF)) {
              newBackoff=MAX_BACKOFF;
            }
            pullMessages(newBackoff);
          }
        }
,backoff.getMillis(),TimeUnit.MILLISECONDS);
        return;
      }
      messageDispatcher.processReceivedMessages(pullResponse.getReceivedMessagesList(),new Runnable(){
        @Override public void run(){
          pullMessages(INITIAL_BACKOFF);
        }
      }
);
    }
    @Override public void onFailure(    Throwable cause){
      if (!isAlive()) {
        logger.log(Level.FINE,""String_Node_Str"",cause);
        return;
      }
      if (StatusUtil.isRetryable(cause)) {
        logger.log(Level.SEVERE,""String_Node_Str"",cause);
        executor.schedule(new Runnable(){
          @Override public void run(){
            Duration newBackoff=backoff.multipliedBy(2);
            if (newBackoff.isLongerThan(MAX_BACKOFF)) {
              newBackoff=MAX_BACKOFF;
            }
            pullMessages(newBackoff);
          }
        }
,backoff.getMillis(),TimeUnit.MILLISECONDS);
      }
 else {
        messageDispatcher.stop();
        notifyFailed(cause);
      }
    }
  }
,executor);
}"
93036,"public PollingSubscriberConnection(String subscription,MessageReceiver receiver,Duration ackExpirationPadding,Duration maxAckExtensionPeriod,Distribution ackLatencyDistribution,Channel channel,FlowController flowController,ScheduledExecutorService executor,ApiClock clock){
  this.subscription=subscription;
  this.executor=executor;
  stub=SubscriberGrpc.newFutureStub(channel);
  messageDispatcher=new MessageDispatcher(receiver,this,ackExpirationPadding,maxAckExtensionPeriod,ackLatencyDistribution,flowController,executor,clock);
  messageDispatcher.setMessageDeadlineSeconds(Subscriber.MIN_ACK_DEADLINE_SECONDS);
}","public PollingSubscriberConnection(String subscription,MessageReceiver receiver,Duration ackExpirationPadding,Duration maxAckExtensionPeriod,Distribution ackLatencyDistribution,Channel channel,FlowController flowController,@Nullable Integer maxDesiredPulledMessages,ScheduledExecutorService executor,@Nullable ScheduledExecutorService alarmsExecutor,ApiClock clock){
  this.subscription=subscription;
  this.executor=executor;
  stub=SubscriberGrpc.newFutureStub(channel);
  messageDispatcher=new MessageDispatcher(receiver,this,ackExpirationPadding,maxAckExtensionPeriod,ackLatencyDistribution,flowController,executor,alarmsExecutor,clock);
  messageDispatcher.setMessageDeadlineSeconds(Subscriber.MIN_ACK_DEADLINE_SECONDS);
  this.maxDesiredPulledMessages=maxDesiredPulledMessages != null ? maxDesiredPulledMessages : DEFAULT_MAX_MESSAGES;
}"
93037,"private void initialize(){
  ListenableFuture<Subscription> subscriptionInfo=stub.withDeadlineAfter(DEFAULT_TIMEOUT.getMillis(),TimeUnit.MILLISECONDS).getSubscription(GetSubscriptionRequest.newBuilder().setSubscription(subscription).build());
  Futures.addCallback(subscriptionInfo,new FutureCallback<Subscription>(){
    @Override public void onSuccess(    Subscription result){
      messageDispatcher.setMessageDeadlineSeconds(result.getAckDeadlineSeconds());
      pullMessages(INITIAL_BACKOFF);
    }
    @Override public void onFailure(    Throwable cause){
      notifyFailed(cause);
    }
  }
);
}","private void initialize(){
  ListenableFuture<Subscription> subscriptionInfo=stub.withDeadlineAfter(DEFAULT_TIMEOUT.getMillis(),TimeUnit.MILLISECONDS).getSubscription(GetSubscriptionRequest.newBuilder().setSubscription(subscription).build());
  Futures.addCallback(subscriptionInfo,new FutureCallback<Subscription>(){
    @Override public void onSuccess(    Subscription result){
      messageDispatcher.setMessageDeadlineSeconds(result.getAckDeadlineSeconds());
      pullMessages(INITIAL_BACKOFF);
    }
    @Override public void onFailure(    Throwable cause){
      notifyFailed(cause);
    }
  }
,executor);
}"
93038,"@Override public void onSuccess(PullResponse pullResponse){
  messageDispatcher.processReceivedMessages(pullResponse.getReceivedMessagesList());
  if (pullResponse.getReceivedMessagesCount() == 0) {
    executor.schedule(new Runnable(){
      @Override public void run(){
        Duration newBackoff=backoff.multipliedBy(2);
        if (newBackoff.isLongerThan(MAX_BACKOFF)) {
          newBackoff=MAX_BACKOFF;
        }
        pullMessages(newBackoff);
      }
    }
,backoff.getMillis(),TimeUnit.MILLISECONDS);
    return;
  }
  pullMessages(INITIAL_BACKOFF);
}","@Override public void onSuccess(PullResponse pullResponse){
  if (pullResponse.getReceivedMessagesCount() == 0) {
    executor.schedule(new Runnable(){
      @Override public void run(){
        Duration newBackoff=backoff.multipliedBy(2);
        if (newBackoff.isLongerThan(MAX_BACKOFF)) {
          newBackoff=MAX_BACKOFF;
        }
        pullMessages(newBackoff);
      }
    }
,backoff.getMillis(),TimeUnit.MILLISECONDS);
    return;
  }
  messageDispatcher.processReceivedMessages(pullResponse.getReceivedMessagesList(),new Runnable(){
    @Override public void run(){
      pullMessages(INITIAL_BACKOFF);
    }
  }
);
}"
93039,"@Test public void testBuilderNoCredentials(){
  assertEquals(NoCredentials.getInstance(),OPTIONS_NO_CREDENTIALS.getCredentials());
  assertSame(TEST_CLOCK,OPTIONS_NO_CREDENTIALS.getClock());
  assertEquals(""String_Node_Str"",OPTIONS_NO_CREDENTIALS.getHost());
  assertEquals(""String_Node_Str"",OPTIONS_NO_CREDENTIALS.getProjectId());
  assertSame(ServiceOptions.getNoRetrySettings(),OPTIONS_NO_CREDENTIALS.getRetrySettings());
}","@Test public void testBuilderNoCredentials(){
  assertEquals(NoCredentials.getInstance(),OPTIONS_NO_CREDENTIALS.getCredentials());
  assertTrue(NoCredentials.getInstance().equals(OPTIONS_NO_CREDENTIALS.getCredentials()));
  assertFalse(NoCredentials.getInstance().equals(OPTIONS.getCredentials()));
  assertFalse(NoCredentials.getInstance().equals(null));
  assertSame(TEST_CLOCK,OPTIONS_NO_CREDENTIALS.getClock());
  assertEquals(""String_Node_Str"",OPTIONS_NO_CREDENTIALS.getHost());
  assertEquals(""String_Node_Str"",OPTIONS_NO_CREDENTIALS.getProjectId());
  assertSame(ServiceOptions.getNoRetrySettings(),OPTIONS_NO_CREDENTIALS.getRetrySettings());
}"
93040,"public GrpcLoggingRpc(LoggingOptions options) throws IOException {
  GrpcTransportOptions transportOptions=(GrpcTransportOptions)options.getTransportOptions();
  executorFactory=transportOptions.getExecutorFactory();
  executor=executorFactory.get();
  try {
    ExecutorProvider executorProvider=FixedExecutorProvider.create(executor);
    ChannelProvider channelProvider;
    if (options.getHost().contains(""String_Node_Str"") || options.getCredentials().equals(NoCredentials.getInstance())) {
      ManagedChannel managedChannel=ManagedChannelBuilder.forTarget(options.getHost()).usePlaintext(true).executor(executor).build();
      channelProvider=FixedChannelProvider.create(managedChannel);
    }
 else {
      channelProvider=GrpcTransportOptions.setUpChannelProvider(LoggingSettings.defaultChannelProviderBuilder(),options);
    }
    providerManager=ProviderManager.newBuilder().setChannelProvider(channelProvider).setExecutorProvider(executorProvider).build();
    UnaryCallSettings.Builder callSettingsBuilder=transportOptions.getApiCallSettings(options.getRetrySettings());
    ConfigSettings.Builder confBuilder=ConfigSettings.defaultBuilder().setExecutorProvider(providerManager).setChannelProvider(providerManager).applyToAllUnaryMethods(callSettingsBuilder);
    LoggingSettings.Builder logBuilder=LoggingSettings.defaultBuilder().setExecutorProvider(providerManager).setChannelProvider(providerManager).applyToAllUnaryMethods(callSettingsBuilder);
    MetricsSettings.Builder metricsBuilder=MetricsSettings.defaultBuilder().setExecutorProvider(providerManager).setChannelProvider(providerManager).applyToAllUnaryMethods(callSettingsBuilder);
    configClient=ConfigClient.create(confBuilder.build());
    loggingClient=LoggingClient.create(logBuilder.build());
    metricsClient=MetricsClient.create(metricsBuilder.build());
  }
 catch (  Exception ex) {
    throw new IOException(ex);
  }
}","public GrpcLoggingRpc(LoggingOptions options) throws IOException {
  GrpcTransportOptions transportOptions=(GrpcTransportOptions)options.getTransportOptions();
  executorFactory=transportOptions.getExecutorFactory();
  executor=executorFactory.get();
  try {
    ExecutorProvider executorProvider=FixedExecutorProvider.create(executor);
    ChannelProvider channelProvider;
    if (options.getHost().contains(""String_Node_Str"") || NoCredentials.getInstance().equals(options.getCredentials())) {
      ManagedChannel managedChannel=ManagedChannelBuilder.forTarget(options.getHost()).usePlaintext(true).executor(executor).build();
      channelProvider=FixedChannelProvider.create(managedChannel);
    }
 else {
      channelProvider=GrpcTransportOptions.setUpChannelProvider(LoggingSettings.defaultChannelProviderBuilder(),options);
    }
    providerManager=ProviderManager.newBuilder().setChannelProvider(channelProvider).setExecutorProvider(executorProvider).build();
    UnaryCallSettings.Builder callSettingsBuilder=transportOptions.getApiCallSettings(options.getRetrySettings());
    ConfigSettings.Builder confBuilder=ConfigSettings.defaultBuilder().setExecutorProvider(providerManager).setChannelProvider(providerManager).applyToAllUnaryMethods(callSettingsBuilder);
    LoggingSettings.Builder logBuilder=LoggingSettings.defaultBuilder().setExecutorProvider(providerManager).setChannelProvider(providerManager).applyToAllUnaryMethods(callSettingsBuilder);
    MetricsSettings.Builder metricsBuilder=MetricsSettings.defaultBuilder().setExecutorProvider(providerManager).setChannelProvider(providerManager).applyToAllUnaryMethods(callSettingsBuilder);
    configClient=ConfigClient.create(confBuilder.build());
    loggingClient=LoggingClient.create(logBuilder.build());
    metricsClient=MetricsClient.create(metricsBuilder.build());
  }
 catch (  Exception ex) {
    throw new IOException(ex);
  }
}"
93041,"/** 
 * Deletes the topic with the given name. Returns `NOT_FOUND` if the topic does not exist. After a topic is deleted, a new topic may be created with the same name; this is an entirely new topic with none of the old configuration or subscriptions. Existing subscriptions to this topic are not deleted, but their `topic` field is set to `_deleted-topic_`. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public void deleteTopic(DeleteTopicRequest request){
  deleteTopicCallable().call(request);
}","/** 
 * Deletes the topic with the given name. Generates `NOT_FOUND` if the topic does not exist. After a topic is deleted, a new topic may be created with the same name; this is an entirely new topic with none of the old configuration or subscriptions. Existing subscriptions to this topic are not deleted, but their `topic` field is set to `_deleted-topic_`. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public void deleteTopic(DeleteTopicRequest request){
  deleteTopicCallable().call(request);
}"
93042,"/** 
 * Deletes the topic with the given name. Returns `NOT_FOUND` if the topic does not exist. After a topic is deleted, a new topic may be created with the same name; this is an entirely new topic with none of the old configuration or subscriptions. Existing subscriptions to this topic are not deleted, but their `topic` field is set to `_deleted-topic_`. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<DeleteTopicRequest,Empty> deleteTopicCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.DELETE_TOPIC);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.DELETE_TOPIC);
  return DELETE_TOPIC.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}","/** 
 * Deletes the topic with the given name. Generates `NOT_FOUND` if the topic does not exist. After a topic is deleted, a new topic may be created with the same name; this is an entirely new topic with none of the old configuration or subscriptions. Existing subscriptions to this topic are not deleted, but their `topic` field is set to `_deleted-topic_`. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<DeleteTopicRequest,Empty> deleteTopicCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.DELETE_TOPIC);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.DELETE_TOPIC);
  return DELETE_TOPIC.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}"
93043,"/** 
 * Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic does not exist. The message payload must not be empty; it must contain either a non-empty data field, or at least one attribute. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<PublishRequest,PublishResponse> publishCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.PUBLISH);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.PUBLISH);
  return PUBLISH.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}","/** 
 * Adds one or more messages to the topic. Generates `NOT_FOUND` if the topic does not exist. The message payload must not be empty; it must contain either a non-empty data field, or at least one attribute. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<PublishRequest,PublishResponse> publishCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.PUBLISH);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.PUBLISH);
  return PUBLISH.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}"
93044,"/** 
 * Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic does not exist. The message payload must not be empty; it must contain either a non-empty data field, or at least one attribute. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public PublishResponse publish(PublishRequest request){
  return publishCallable().call(request);
}","/** 
 * Adds one or more messages to the topic. Generates `NOT_FOUND` if the topic does not exist. The message payload must not be empty; it must contain either a non-empty data field, or at least one attribute. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public PublishResponse publish(PublishRequest request){
  return publishCallable().call(request);
}"
93045,"/** 
 * Deletes an existing subscription. All pending messages in the subscription are immediately dropped. Calls to `Pull` after deletion will return `NOT_FOUND`. After a subscription is deleted, a new one may be created with the same name, but the new one has no association with the old subscription, or its topic unless the same topic is specified. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public void deleteSubscription(DeleteSubscriptionRequest request){
  deleteSubscriptionCallable().call(request);
}","/** 
 * Deletes an existing subscription. All pending messages in the subscription are immediately dropped. Calls to `Pull` after deletion will generate `NOT_FOUND`. After a subscription is deleted, a new one may be created with the same name, but the new one has no association with the old subscription, or its topic unless the same topic is specified. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public void deleteSubscription(DeleteSubscriptionRequest request){
  deleteSubscriptionCallable().call(request);
}"
93046,"/** 
 * Lists matching subscriptions. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public Iterable<Subscription> listSubscriptions(ListSubscriptionsRequest request){
  return listSubscriptionsStreamingCallable().call(request);
}","/** 
 * Lists matching subscriptions. If the topic of a subscription has been deleted, the subscription itself is not deleted, but the value of the `topic` field is set to `_deleted-topic_`. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public Iterable<Subscription> listSubscriptions(ListSubscriptionsRequest request){
  return listSubscriptionsStreamingCallable().call(request);
}"
93047,"/** 
 * Gets the configuration details of a subscription. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public Subscription getSubscription(GetSubscriptionRequest request){
  return getSubscriptionCallable().call(request);
}","/** 
 * Gets the configuration details of a subscription. If the topic of a subscription has been deleted, the subscription itself is not deleted, but the value of the `topic` field is set to `_deleted-topic_`. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public Subscription getSubscription(GetSubscriptionRequest request){
  return getSubscriptionCallable().call(request);
}"
93048,"/** 
 * Creates a subscription to a given topic for a given subscriber. If the subscription already exists, returns `ALREADY_EXISTS`. If the corresponding topic doesn't exist, returns `NOT_FOUND`. If the name is not provided in the request, the server will assign a random name for this subscription on the same project as the topic. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<Subscription,Subscription> createSubscriptionCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.CREATE_SUBSCRIPTION);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.CREATE_SUBSCRIPTION);
  return CREATE_SUBSCRIPTION.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}","/** 
 * Creates a subscription to a given topic for a given subscriber. If the subscription already exists, generates `ALREADY_EXISTS`. If the corresponding topic doesn't exist, generates `NOT_FOUND`. If the name is not provided in the request, the server will assign a random name for this subscription on the same project as the topic. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<Subscription,Subscription> createSubscriptionCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.CREATE_SUBSCRIPTION);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.CREATE_SUBSCRIPTION);
  return CREATE_SUBSCRIPTION.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}"
93049,"/** 
 * Lists matching subscriptions. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<ListSubscriptionsRequest,Iterable<Subscription>> listSubscriptionsStreamingCallable(){
  return listSubscriptionsCallable().pageStreaming(LIST_SUBSCRIPTIONS_PAGE_DESC);
}","/** 
 * Lists matching subscriptions. If the topic of a subscription has been deleted, the subscription itself is not deleted, but the value of the `topic` field is set to `_deleted-topic_`. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<ListSubscriptionsRequest,Iterable<Subscription>> listSubscriptionsStreamingCallable(){
  return listSubscriptionsCallable().pageStreaming(LIST_SUBSCRIPTIONS_PAGE_DESC);
}"
93050,"/** 
 * Gets the configuration details of a subscription. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<GetSubscriptionRequest,Subscription> getSubscriptionCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.GET_SUBSCRIPTION);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.GET_SUBSCRIPTION);
  return GET_SUBSCRIPTION.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}","/** 
 * Gets the configuration details of a subscription. If the topic of a subscription has been deleted, the subscription itself is not deleted, but the value of the `topic` field is set to `_deleted-topic_`. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<GetSubscriptionRequest,Subscription> getSubscriptionCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.GET_SUBSCRIPTION);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.GET_SUBSCRIPTION);
  return GET_SUBSCRIPTION.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}"
93051,"/** 
 * Deletes an existing subscription. All pending messages in the subscription are immediately dropped. Calls to `Pull` after deletion will return `NOT_FOUND`. After a subscription is deleted, a new one may be created with the same name, but the new one has no association with the old subscription, or its topic unless the same topic is specified. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<DeleteSubscriptionRequest,Empty> deleteSubscriptionCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.DELETE_SUBSCRIPTION);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.DELETE_SUBSCRIPTION);
  return DELETE_SUBSCRIPTION.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}","/** 
 * Deletes an existing subscription. All pending messages in the subscription are immediately dropped. Calls to `Pull` after deletion will generate `NOT_FOUND`. After a subscription is deleted, a new one may be created with the same name, but the new one has no association with the old subscription, or its topic unless the same topic is specified. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<DeleteSubscriptionRequest,Empty> deleteSubscriptionCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.DELETE_SUBSCRIPTION);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.DELETE_SUBSCRIPTION);
  return DELETE_SUBSCRIPTION.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}"
93052,"/** 
 * Creates a subscription to a given topic for a given subscriber. If the subscription already exists, returns `ALREADY_EXISTS`. If the corresponding topic doesn't exist, returns `NOT_FOUND`. If the name is not provided in the request, the server will assign a random name for this subscription on the same project as the topic. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public Subscription createSubscription(Subscription request){
  return createSubscriptionCallable().call(request);
}","/** 
 * Creates a subscription to a given topic for a given subscriber. If the subscription already exists, generates `ALREADY_EXISTS`. If the corresponding topic doesn't exist, generates `NOT_FOUND`. If the name is not provided in the request, the server will assign a random name for this subscription on the same project as the topic. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public Subscription createSubscription(Subscription request){
  return createSubscriptionCallable().call(request);
}"
93053,"/** 
 * Pulls messages from the server. Returns an empty list if there are no messages available in the backlog. The server may return `UNAVAILABLE` if there are too many concurrent pull requests pending for the given subscription. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public PullResponse pull(PullRequest request){
  return pullCallable().call(request);
}","/** 
 * Pulls messages from the server. Returns an empty list if there are no messages available in the backlog. The server may generate `UNAVAILABLE` if there are too many concurrent pull requests pending for the given subscription. <!-- manual edit --> <!-- end manual edit -->
 * @param request The request object containing all of the parameters for the API call.
 */
public PullResponse pull(PullRequest request){
  return pullCallable().call(request);
}"
93054,"/** 
 * Pulls messages from the server. Returns an empty list if there are no messages available in the backlog. The server may return `UNAVAILABLE` if there are too many concurrent pull requests pending for the given subscription. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<PullRequest,PullResponse> pullCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.PULL);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.PULL);
  return PULL.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}","/** 
 * Pulls messages from the server. Returns an empty list if there are no messages available in the backlog. The server may generate `UNAVAILABLE` if there are too many concurrent pull requests pending for the given subscription. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<PullRequest,PullResponse> pullCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.PULL);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.PULL);
  return PULL.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}"
93055,"/** 
 * Lists matching subscriptions. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<ListSubscriptionsRequest,ListSubscriptionsResponse> listSubscriptionsCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.LIST_SUBSCRIPTIONS);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.LIST_SUBSCRIPTIONS);
  return LIST_SUBSCRIPTIONS.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}","/** 
 * Lists matching subscriptions. If the topic of a subscription has been deleted, the subscription itself is not deleted, but the value of the `topic` field is set to `_deleted-topic_`. <!-- manual edit --> <!-- end manual edit -->
 */
public ApiCallable<ListSubscriptionsRequest,ListSubscriptionsResponse> listSubscriptionsCallable(){
  ImmutableSet<Status.Code> retryableCodes=retryCodesConfig.get(MethodIdentifier.LIST_SUBSCRIPTIONS);
  RetryParams retryParams=retryParamsConfig.get(MethodIdentifier.LIST_SUBSCRIPTIONS);
  return LIST_SUBSCRIPTIONS.retryableOn(retryableCodes).retrying(retryParams,settings.getExecutor()).bind(channel);
}"
93056,"@Override public byte[] load(StorageObject from,Map<Option,?> options){
  try {
    Storage.Objects.Get getRequest=storage.objects().get(from.getBucket(),from.getName()).setGeneration(from.getGeneration()).setIfMetagenerationMatch(IF_METAGENERATION_MATCH.getLong(options)).setIfMetagenerationNotMatch(IF_METAGENERATION_NOT_MATCH.getLong(options)).setIfGenerationMatch(IF_GENERATION_MATCH.getLong(options)).setIfGenerationNotMatch(IF_GENERATION_NOT_MATCH.getLong(options));
    ByteArrayOutputStream out=new ByteArrayOutputStream();
    getRequest.getMediaHttpDownloader().setDirectDownloadEnabled(true);
    getRequest.executeMediaAndDownloadTo(out);
    return out.toByteArray();
  }
 catch (  IOException ex) {
    throw translate(ex);
  }
}","@Override public byte[] load(StorageObject from,Map<Option,?> options){
  try {
    Storage.Objects.Get getRequest=storage.objects().get(from.getBucket(),from.getName()).setGeneration(from.getGeneration()).setIfMetagenerationMatch(IF_METAGENERATION_MATCH.getLong(options)).setIfMetagenerationNotMatch(IF_METAGENERATION_NOT_MATCH.getLong(options)).setIfGenerationMatch(IF_GENERATION_MATCH.getLong(options)).setIfGenerationNotMatch(IF_GENERATION_NOT_MATCH.getLong(options));
    ByteArrayOutputStream out=new ByteArrayOutputStream();
    getRequest.executeMedia().download(out);
    return out.toByteArray();
  }
 catch (  IOException ex) {
    throw translate(ex);
  }
}"
93057,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  this.compute=options.service();
}","private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
  input.defaultReadObject();
  this.compute=options.service();
}"
93058,"/** 
 * Lists all snapshots.
 * @throws ComputeException upon failure
 */
Page<Snapshot> listSnapshots(SnapshotListOption... options);","/** 
 * Lists snapshots.
 * @throws ComputeException upon failure
 */
Page<Snapshot> listSnapshots(SnapshotListOption... options);"
93059,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  this.compute=options.service();
}","private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
  input.defaultReadObject();
  this.compute=options.service();
}"
93060,"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  this.compute=options.service();
}","private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
  input.defaultReadObject();
  this.compute=options.service();
}"
93061,"/** 
 * Returns an option to specify the maximum number of snapshots returned per page.
 */
public static SnapshotListOption pageSize(long pageSize){
  return new SnapshotListOption(ComputeRpc.Option.MAX_RESULTS,pageSize);
}","/** 
 * Returns an option to specify the maximum number of snapshots returned per page.  {@code pageSize} must be between 0 and 500 (inclusive). If not specified 500 is used.
 */
public static SnapshotListOption pageSize(long pageSize){
  return new SnapshotListOption(ComputeRpc.Option.MAX_RESULTS,pageSize);
}"
93062,"MachineTypeFilter(MachineTypeField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}","private MachineTypeFilter(MachineTypeField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}"
93063,"RegionFilter(RegionField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}","private RegionFilter(RegionField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}"
93064,"OperationFilter(OperationField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}","private OperationFilter(OperationField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}"
93065,"DiskTypeFilter(DiskTypeField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}","private DiskTypeFilter(DiskTypeField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}"
93066,"SnapshotFilter(SnapshotField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}","private SnapshotFilter(SnapshotField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}"
93067,"/** 
 * Returns an option to specify the snapshot's fields to be returned by the RPC call. If this option is not provided, all snapshot's fields are returned.   {@code SnapshotListOption.fields}can be used to specify only the fields of interest.   {@link Snapshot#snapshotId()} is alwaysreturned, even if not specified.
 */
public static SnapshotListOption fields(SnapshotField... fields){
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"").append(SnapshotField.selector(fields)).append(""String_Node_Str"");
  return new SnapshotListOption(ComputeRpc.Option.FIELDS,builder.toString());
}","/** 
 * Returns an option to specify the snapshot's fields to be returned by the RPC call. If this option is not provided, all the snapshot's fields are returned.  {@code SnapshotListOption.fields} can be used to specify only the fields of interest.{@link Snapshot#snapshotId()} is always returned, even if not specified.
 */
public static SnapshotListOption fields(SnapshotField... fields){
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"").append(SnapshotField.selector(fields)).append(""String_Node_Str"");
  return new SnapshotListOption(ComputeRpc.Option.FIELDS,builder.toString());
}"
93068,"AddressFilter(AddressField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}","private AddressFilter(AddressField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}"
93069,"ZoneFilter(ZoneField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}","private ZoneFilter(ZoneField field,ComparisonOperator operator,Object value){
  super(field.selector(),operator,value);
}"
93070,"/** 
 * Returns an equality filter for the given field and long value.
 */
public static SnapshotFilter equals(SnapshotField field,long value){
  return new SnapshotFilter(checkNotNull(field),ComparisonOperator.EQ,value);
}","/** 
 * Returns an equals filter for the given field and long value.
 */
public static SnapshotFilter equals(SnapshotField field,long value){
  return new SnapshotFilter(checkNotNull(field),ComparisonOperator.EQ,value);
}"
93071,"@Override public Operation deleteSnapshot(final String snapshot,OperationOption... options){
  return deleteSnapshot(SnapshotId.of(snapshot));
}","@Override public Operation deleteSnapshot(final String snapshot,OperationOption... options){
  final Map<ComputeRpc.Option,?> optionsMap=optionMap(options);
  try {
    com.google.api.services.compute.model.Operation answer=runWithRetries(new Callable<com.google.api.services.compute.model.Operation>(){
      @Override public com.google.api.services.compute.model.Operation call(){
        return computeRpc.deleteSnapshot(snapshot,optionsMap);
      }
    }
,options().retryParams(),EXCEPTION_HANDLER);
    return answer == null ? null : Operation.fromPb(this,answer);
  }
 catch (  RetryHelper.RetryHelperException e) {
    throw ComputeException.translateAndThrow(e);
  }
}"
93072,"@Override public Operation create(SnapshotInfo snapshot,final OperationOption... options){
  final SnapshotInfo completeSnapshot=snapshot.setProjectId(options().projectId());
  final Map<ComputeRpc.Option,?> optionsMap=optionMap(options);
  try {
    com.google.api.services.compute.model.Operation answer=runWithRetries(new Callable<com.google.api.services.compute.model.Operation>(){
      @Override public com.google.api.services.compute.model.Operation call(){
        return computeRpc.createSnapshot(completeSnapshot.sourceDisk().zone(),completeSnapshot.sourceDisk().disk(),completeSnapshot.snapshotId().snapshot(),completeSnapshot.description(),optionsMap);
      }
    }
,options().retryParams(),EXCEPTION_HANDLER);
    return answer == null ? null : Operation.fromPb(this,answer);
  }
 catch (  RetryHelper.RetryHelperException e) {
    throw ComputeException.translateAndThrow(e);
  }
}","@Override public Operation create(SnapshotInfo snapshot,OperationOption... options){
  final SnapshotInfo completeSnapshot=snapshot.setProjectId(options().projectId());
  final Map<ComputeRpc.Option,?> optionsMap=optionMap(options);
  try {
    com.google.api.services.compute.model.Operation answer=runWithRetries(new Callable<com.google.api.services.compute.model.Operation>(){
      @Override public com.google.api.services.compute.model.Operation call(){
        return computeRpc.createSnapshot(completeSnapshot.sourceDisk().zone(),completeSnapshot.sourceDisk().disk(),completeSnapshot.snapshotId().snapshot(),completeSnapshot.description(),optionsMap);
      }
    }
,options().retryParams(),EXCEPTION_HANDLER);
    return answer == null ? null : Operation.fromPb(this,answer);
  }
 catch (  RetryHelper.RetryHelperException e) {
    throw ComputeException.translateAndThrow(e);
  }
}"
93073,"@Override public com.google.api.services.compute.model.Operation call(){
  return computeRpc.deleteSnapshot(snapshot.snapshot(),optionsMap);
}","@Override public com.google.api.services.compute.model.Operation call(){
  return computeRpc.deleteSnapshot(snapshot,optionsMap);
}"
93074,"/** 
 * Deletes this snapshot.
 * @return a global operation if delete request was successfully sent, {@code null} if thesnapshot was not found
 * @throws ComputeException upon failure
 */
public Operation delete(Compute.OperationOption... options){
  return compute.deleteSnapshot(snapshotId(),options);
}","/** 
 * Deletes this snapshot.
 * @return a global operation if delete request was successfully sent, {@code null} if thesnapshot was not found
 * @throws ComputeException upon failure
 */
public Operation delete(OperationOption... options){
  return compute.deleteSnapshot(snapshotId(),options);
}"
93075,"/** 
 * Fetches current snapshot's latest information. Returns   {@code null} if the snapshot does notexist.
 * @param options snapshot options
 * @return a {@code Snapshot} object with latest information or {@code null} if not found
 * @throws ComputeException upon failure
 */
public Snapshot reload(Compute.SnapshotOption... options){
  return compute.getSnapshot(snapshotId().snapshot(),options);
}","/** 
 * Fetches current snapshot's latest information. Returns   {@code null} if the snapshot does notexist.
 * @param options snapshot options
 * @return a {@code Snapshot} object with latest information or {@code null} if not found
 * @throws ComputeException upon failure
 */
public Snapshot reload(SnapshotOption... options){
  return compute.getSnapshot(snapshotId().snapshot(),options);
}"
93076,"/** 
 * Checks if this snapshot exists.
 * @return {@code true} if this snapshot exists, {@code false} otherwise
 * @throws ComputeException upon failure
 */
public boolean exists(){
  return reload(Compute.SnapshotOption.fields()) != null;
}","/** 
 * Checks if this snapshot exists.
 * @return {@code true} if this snapshot exists, {@code false} otherwise
 * @throws ComputeException upon failure
 */
public boolean exists(){
  return reload(SnapshotOption.fields()) != null;
}"
93077,"/** 
 * Defines an inequality filter.
 */
ListFilter(String field,ComparisonOperator operator,Object value){
  this.field=field;
  this.operator=operator;
  this.value=value;
}","/** 
 * Defines a not-equals filter.
 */
ListFilter(String field,ComparisonOperator operator,Object value){
  this.field=field;
  this.operator=operator;
  this.value=value;
}"
93078,"/** 
 * Returns an option to specify the operation's fields to be returned by the RPC call. If this option is not provided all operation's fields are returned.  {@code OperationListOption.fields} can be used to specify only the fields of interest.{@link Operation#operationId()} is always returned, even if not specified.
 */
public static OperationListOption fields(OperationField... fields){
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"").append(OperationField.selector(fields)).append(""String_Node_Str"");
  return new OperationListOption(ComputeRpc.Option.FIELDS,builder.toString());
}","/** 
 * Returns an option to specify the operation's fields to be returned by the RPC call. If this option is not provided, all operation's fields are returned.  {@code OperationListOption.fields} can be used to specify only the fields of interest.{@link Operation#operationId()} is always returned, even if not specified.
 */
public static OperationListOption fields(OperationField... fields){
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"").append(OperationField.selector(fields)).append(""String_Node_Str"");
  return new OperationListOption(ComputeRpc.Option.FIELDS,builder.toString());
}"
93079,"/** 
 * Returns an option to specify a filter to the operations being listed.
 */
public static OperationListOption filter(OperationFilter filter){
  return new OperationListOption(ComputeRpc.Option.FILTER,filter.toPb());
}","/** 
 * Returns an option to specify a filter on the operations being listed.
 */
public static OperationListOption filter(OperationFilter filter){
  return new OperationListOption(ComputeRpc.Option.FILTER,filter.toPb());
}"
93080,"/** 
 * Returns an inequality filter for the given field and integer value.
 */
public static OperationFilter notEquals(OperationField field,int value){
  return new OperationFilter(checkNotNull(field),ComparisonOperator.NE,value);
}","/** 
 * Returns a not-equals filter for the given field and integer value.
 */
public static OperationFilter notEquals(OperationField field,int value){
  return new OperationFilter(checkNotNull(field),ComparisonOperator.NE,value);
}"
93081,"/** 
 * Returns the operation's identity. This method returns an   {@link GlobalOperationId} for globaloperations, returns a  {@link RegionOperationId} for region operations and returns a{@link ZoneOperationId} for zone operations.
 * @see <a href=""https://www.ietf.org/rfc/rfc1035.txt"">RFC1035</a>
 */
@SuppressWarnings(""String_Node_Str"") public <T extends OperationId>T operationId(){
  return (T)operationId;
}","/** 
 * Returns the operation's identity. This method returns an   {@link GlobalOperationId} for globaloperations, a  {@link RegionOperationId} for region operations and a {@link ZoneOperationId} forzone operations.
 * @see <a href=""https://www.ietf.org/rfc/rfc1035.txt"">RFC1035</a>
 */
@SuppressWarnings(""String_Node_Str"") public <T extends OperationId>T operationId(){
  return (T)operationId;
}"
93082,"/** 
 * Checks if this operation has completed its execution, either failing or succeeding. If the operation does not exist this method returns   {@code false}. To correctly wait for operation's completion check that the operation exists first, using   {@link #exists()}: <pre>   {@code}if (operation.exists())  while(!operation.isDone()) { Thread.sleep(1000L); } }}</pre>
 * @return {@code true} if this operation is in {@link Operation.Status#DONE} state, {@code false}if the state is not   {@link Operation.Status#DONE} or the operation does not exist
 * @throws ComputeException upon failure
 */
public boolean isDone() throws ComputeException {
  Operation operation=compute.get(operationId,Compute.OperationOption.fields(Compute.OperationField.STATUS));
  return operation != null && operation.status() == Status.DONE;
}","/** 
 * Checks if this operation has completed its execution, either failing or succeeding. If the operation does not exist this method returns   {@code false}. To correctly wait for operation's completion, check that the operation exists first using   {@link #exists()}: <pre>   {@code}if (operation.exists())  while(!operation.isDone()) { Thread.sleep(1000L); } }}</pre>
 * @return {@code true} if this operation is in {@link Operation.Status#DONE} state, {@code false}if the state is not   {@link Operation.Status#DONE} or the operation does not exist
 * @throws ComputeException upon failure
 */
public boolean isDone() throws ComputeException {
  Operation operation=compute.get(operationId,Compute.OperationOption.fields(Compute.OperationField.STATUS));
  return operation != null && operation.status() == Status.DONE;
}"
93083,"/** 
 * Creates an object.
 */
public Operation build(){
  return new Operation(this);
}","Operation build(){
  return new Operation(this);
}"
93084,"/** 
 * Returns a fully qualified URL to the entity.
 */
String selfLink();","/** 
 * Returns a fully qualified URL to the operation.
 */
String selfLink();"
93085,"@Override public boolean equals(Object obj){
  return obj instanceof RegionOperationId && baseEquals((RegionOperationId)obj);
}","@Override public boolean equals(Object obj){
  return obj instanceof RegionOperationId && baseEquals((RegionOperationId)obj) && Objects.equals(operation,((RegionOperationId)obj).operation);
}"
93086,"@Test public void testChunkSize() throws IOException {
  channel.chunkSize(42);
  assertEquals(MIN_CHUNK_SIZE,channel.chunkSize());
  channel.chunkSize(2 * MIN_CHUNK_SIZE);
  assertEquals(2 * MIN_CHUNK_SIZE,channel.chunkSize());
  channel.chunkSize(512 * 1025);
  assertEquals(2 * MIN_CHUNK_SIZE,channel.chunkSize());
}","@Test public void testChunkSize(){
  channel.chunkSize(42);
  assertEquals(MIN_CHUNK_SIZE,channel.chunkSize());
  channel.chunkSize(2 * MIN_CHUNK_SIZE);
  assertEquals(2 * MIN_CHUNK_SIZE,channel.chunkSize());
  channel.chunkSize(512 * 1025);
  assertEquals(2 * MIN_CHUNK_SIZE,channel.chunkSize());
}"
93087,"@Test public void testConstructor() throws IOException {
  assertEquals(null,channel.options());
  assertEquals(ENTITY,channel.entity());
  assertEquals(0,channel.position());
  assertEquals(UPLOAD_ID,channel.uploadId());
  assertEquals(0,channel.limit());
  assertTrue(channel.isOpen());
  assertArrayEquals(new byte[0],channel.buffer());
  assertEquals(DEFAULT_CHUNK_SIZE,channel.chunkSize());
}","@Test public void testConstructor(){
  assertEquals(null,channel.options());
  assertEquals(ENTITY,channel.entity());
  assertEquals(0,channel.position());
  assertEquals(UPLOAD_ID,channel.uploadId());
  assertEquals(0,channel.limit());
  assertTrue(channel.isOpen());
  assertArrayEquals(new byte[0],channel.buffer());
  assertEquals(DEFAULT_CHUNK_SIZE,channel.chunkSize());
}"
93088,"@Test public void testWriteChannelState() throws IOException, ClassNotFoundException {
  BigQueryOptions options=BigQueryOptions.builder().projectId(""String_Node_Str"").retryParams(RetryParams.defaultInstance()).build();
  @SuppressWarnings(""String_Node_Str"") TableDataWriteChannel writer=new TableDataWriteChannel(options,LOAD_CONFIGURATION,""String_Node_Str"");
  RestorableState<WriteChannel> state=writer.capture();
  RestorableState<WriteChannel> deserializedState=serializeAndDeserialize(state);
  assertEquals(state,deserializedState);
  assertEquals(state.hashCode(),deserializedState.hashCode());
  assertEquals(state.toString(),deserializedState.toString());
}","@Test public void testWriteChannelState() throws IOException, ClassNotFoundException {
  BigQueryOptions options=BigQueryOptions.builder().projectId(""String_Node_Str"").build();
  @SuppressWarnings(""String_Node_Str"") TableDataWriteChannel writer=new TableDataWriteChannel(options,LOAD_CONFIGURATION,""String_Node_Str"");
  assertRestorable(writer);
}"
93089,"@Override public Serializable[] serializableObjects(){
  BigQueryOptions options=BigQueryOptions.builder().projectId(""String_Node_Str"").authCredentials(AuthCredentials.createForAppEngine()).build();
  BigQueryOptions otherOptions=options.toBuilder().projectId(""String_Node_Str"").retryParams(RetryParams.defaultInstance()).authCredentials(null).build();
  return new Serializable[]{DOMAIN_ACCESS,GROUP_ACCESS,USER_ACCESS,VIEW_ACCESS,DATASET_ID,DATASET_INFO,TABLE_ID,CSV_OPTIONS,STREAMING_BUFFER,TABLE_DEFINITION,EXTERNAL_TABLE_DEFINITION,VIEW_DEFINITION,TABLE_SCHEMA,TABLE_INFO,VIEW_INFO,EXTERNAL_TABLE_INFO,INLINE_FUNCTION,URI_FUNCTION,JOB_STATISTICS,EXTRACT_STATISTICS,LOAD_STATISTICS,QUERY_STATISTICS,BIGQUERY_ERROR,JOB_STATUS,JOB_ID,COPY_JOB_CONFIGURATION,EXTRACT_JOB_CONFIGURATION,LOAD_CONFIGURATION,LOAD_JOB_CONFIGURATION,QUERY_JOB_CONFIGURATION,JOB_INFO,INSERT_ALL_REQUEST,INSERT_ALL_RESPONSE,FIELD_VALUE,QUERY_REQUEST,QUERY_RESPONSE,BigQuery.DatasetOption.fields(),BigQuery.DatasetDeleteOption.deleteContents(),BigQuery.DatasetListOption.all(),BigQuery.TableOption.fields(),BigQuery.TableListOption.pageSize(42L),BigQuery.JobOption.fields(),BigQuery.JobListOption.allUsers(),DATASET,TABLE,JOB,options,otherOptions};
}","@Override public Serializable[] serializableObjects(){
  BigQueryOptions options=BigQueryOptions.builder().projectId(""String_Node_Str"").authCredentials(AuthCredentials.createForAppEngine()).build();
  BigQueryOptions otherOptions=options.toBuilder().projectId(""String_Node_Str"").authCredentials(null).build();
  return new Serializable[]{DOMAIN_ACCESS,GROUP_ACCESS,USER_ACCESS,VIEW_ACCESS,DATASET_ID,DATASET_INFO,TABLE_ID,CSV_OPTIONS,STREAMING_BUFFER,TABLE_DEFINITION,EXTERNAL_TABLE_DEFINITION,VIEW_DEFINITION,TABLE_SCHEMA,TABLE_INFO,VIEW_INFO,EXTERNAL_TABLE_INFO,INLINE_FUNCTION,URI_FUNCTION,JOB_STATISTICS,EXTRACT_STATISTICS,LOAD_STATISTICS,QUERY_STATISTICS,BIGQUERY_ERROR,JOB_STATUS,JOB_ID,COPY_JOB_CONFIGURATION,EXTRACT_JOB_CONFIGURATION,LOAD_CONFIGURATION,LOAD_JOB_CONFIGURATION,QUERY_JOB_CONFIGURATION,JOB_INFO,INSERT_ALL_REQUEST,INSERT_ALL_RESPONSE,FIELD_VALUE,QUERY_REQUEST,QUERY_RESPONSE,BigQuery.DatasetOption.fields(),BigQuery.DatasetDeleteOption.deleteContents(),BigQuery.DatasetListOption.all(),BigQuery.TableOption.fields(),BigQuery.TableListOption.pageSize(42L),BigQuery.JobOption.fields(),BigQuery.JobListOption.allUsers(),DATASET,TABLE,JOB,options,otherOptions};
}"
93090,"@Override public boolean equals(Object obj){
  return obj instanceof ApplicationDefaultAuthCredentialsState;
}","@Override public boolean equals(Object obj){
  return obj instanceof NoAuthCredentialsState;
}"
93091,"@Override public int hashCode(){
  return exception.hashCode();
}","@Override public int hashCode(){
  return Objects.hash(interceptors,retriableExceptions,nonRetriableExceptions,retryInfo);
}"
93092,"@Override public boolean equals(Object obj){
  if (obj == this) {
    return true;
  }
  if (!(obj instanceof RetryInfo)) {
    return false;
  }
  return ((RetryInfo)obj).exception.equals(exception);
}","@Override public boolean equals(Object obj){
  if (obj == this) {
    return true;
  }
  if (!(obj instanceof ExceptionHandler)) {
    return false;
  }
  ExceptionHandler other=(ExceptionHandler)obj;
  return Objects.equals(interceptors,other.interceptors) && Objects.equals(retriableExceptions,other.retriableExceptions) && Objects.equals(nonRetriableExceptions,other.nonRetriableExceptions)&& Objects.equals(retryInfo,other.retryInfo);
}"
93093,public abstract Serializable[] serializableObjects();,"/** 
 * Returns all objects for which correct serialization must be tested.
 */
public abstract Serializable[] serializableObjects();"
93094,"@Override public Serializable[] serializableObjects(){
  return new Serializable[]{PAGE,RETRY_PARAMS};
}","@Override public Serializable[] serializableObjects(){
  return new Serializable[]{EXCEPTION_HANDLER,IDENTITY,PAGE,RETRY_PARAMS};
}"
93095,"@Override public java.io.Serializable[] serializableObjects(){
  DatastoreOptions options=DatastoreOptions.builder().authCredentials(AuthCredentials.createForAppEngine()).normalizeDataset(false).projectId(""String_Node_Str"").build();
  DatastoreOptions otherOptions=options.toBuilder().namespace(""String_Node_Str"").retryParams(RetryParams.defaultInstance()).authCredentials(null).force(true).build();
  return new java.io.Serializable[]{KEY1,KEY2,INCOMPLETE_KEY1,INCOMPLETE_KEY2,ENTITY1,ENTITY2,ENTITY3,EMBEDDED_ENTITY,PROJECTION_ENTITY,DATE_TIME1,BLOB1,CURSOR1,GQL1,GQL2,QUERY1,QUERY2,QUERY3,NULL_VALUE,KEY_VALUE,STRING_VALUE,EMBEDDED_ENTITY_VALUE1,EMBEDDED_ENTITY_VALUE2,EMBEDDED_ENTITY_VALUE3,LIST_VALUE,LONG_VALUE,DOUBLE_VALUE,BOOLEAN_VALUE,DATE_AND_TIME_VALUE,BLOB_VALUE,RAW_VALUE,options,otherOptions};
}","@Override public java.io.Serializable[] serializableObjects(){
  DatastoreOptions options=DatastoreOptions.builder().authCredentials(AuthCredentials.createForAppEngine()).normalizeDataset(false).projectId(""String_Node_Str"").build();
  DatastoreOptions otherOptions=options.toBuilder().namespace(""String_Node_Str"").authCredentials(null).force(true).build();
  return new java.io.Serializable[]{KEY1,KEY2,INCOMPLETE_KEY1,INCOMPLETE_KEY2,ENTITY1,ENTITY2,ENTITY3,EMBEDDED_ENTITY,PROJECTION_ENTITY,DATE_TIME1,BLOB1,CURSOR1,GQL1,GQL2,QUERY1,QUERY2,QUERY3,NULL_VALUE,KEY_VALUE,STRING_VALUE,EMBEDDED_ENTITY_VALUE1,EMBEDDED_ENTITY_VALUE2,EMBEDDED_ENTITY_VALUE3,LIST_VALUE,LONG_VALUE,DOUBLE_VALUE,BOOLEAN_VALUE,DATE_AND_TIME_VALUE,BLOB_VALUE,RAW_VALUE,options,otherOptions};
}"
93096,"@Override public Serializable[] serializableObjects(){
  ResourceManagerOptions options=ResourceManagerOptions.builder().build();
  ResourceManagerOptions otherOptions=options.toBuilder().projectId(""String_Node_Str"").retryParams(RetryParams.defaultInstance()).build();
  return new Serializable[]{PARTIAL_PROJECT_INFO,FULL_PROJECT_INFO,PROJECT,PAGE_RESULT,PROJECT_GET_OPTION,PROJECT_LIST_OPTION,POLICY,options,otherOptions};
}","@Override public Serializable[] serializableObjects(){
  ResourceManagerOptions options=ResourceManagerOptions.builder().build();
  ResourceManagerOptions otherOptions=options.toBuilder().projectId(""String_Node_Str"").build();
  return new Serializable[]{PARTIAL_PROJECT_INFO,FULL_PROJECT_INFO,PROJECT,PAGE_RESULT,PROJECT_GET_OPTION,PROJECT_LIST_OPTION,POLICY,options,otherOptions};
}"
93097,"@Test public void testWriteChannelState() throws IOException, ClassNotFoundException {
  StorageOptions options=StorageOptions.builder().projectId(""String_Node_Str"").retryParams(RetryParams.defaultInstance()).build();
  @SuppressWarnings(""String_Node_Str"") BlobWriteChannel writer=new BlobWriteChannel(options,BlobInfo.builder(BlobId.of(""String_Node_Str"",""String_Node_Str"")).build(),""String_Node_Str"");
  RestorableState<WriteChannel> state=writer.capture();
  RestorableState<WriteChannel> deserializedState=serializeAndDeserialize(state);
  assertEquals(state,deserializedState);
  assertEquals(state.hashCode(),deserializedState.hashCode());
  assertEquals(state.toString(),deserializedState.toString());
}","@Test public void testWriteChannelState() throws IOException, ClassNotFoundException {
  StorageOptions options=StorageOptions.builder().projectId(""String_Node_Str"").build();
  @SuppressWarnings(""String_Node_Str"") BlobWriteChannel writer=new BlobWriteChannel(options,BlobInfo.builder(BlobId.of(""String_Node_Str"",""String_Node_Str"")).build(),""String_Node_Str"");
  assertRestorable(writer);
}"
93098,"@Override public Serializable[] serializableObjects(){
  StorageOptions options=StorageOptions.builder().projectId(""String_Node_Str"").authCredentials(AuthCredentials.createForAppEngine()).build();
  StorageOptions otherOptions=options.toBuilder().projectId(""String_Node_Str"").retryParams(RetryParams.defaultInstance()).authCredentials(null).build();
  return new Serializable[]{ACL_DOMAIN,ACL_GROUP,ACL_PROJECT_,ACL_USER,ACL_RAW,ACL,BLOB_INFO,BLOB,BUCKET_INFO,BUCKET,ORIGIN,CORS,BATCH_REQUEST,BATCH_RESPONSE,PAGE_RESULT,BLOB_LIST_OPTIONS,BLOB_SOURCE_OPTIONS,BLOB_TARGET_OPTIONS,BUCKET_LIST_OPTIONS,BUCKET_SOURCE_OPTIONS,BUCKET_TARGET_OPTIONS,options,otherOptions};
}","@Override public Serializable[] serializableObjects(){
  StorageOptions options=StorageOptions.builder().projectId(""String_Node_Str"").authCredentials(AuthCredentials.createForAppEngine()).build();
  StorageOptions otherOptions=options.toBuilder().projectId(""String_Node_Str"").authCredentials(null).build();
  return new Serializable[]{ACL_DOMAIN,ACL_GROUP,ACL_PROJECT_,ACL_USER,ACL_RAW,ACL,BLOB_INFO,BLOB,BUCKET_INFO,BUCKET,ORIGIN,CORS,BATCH_REQUEST,BATCH_RESPONSE,PAGE_RESULT,BLOB_LIST_OPTIONS,BLOB_SOURCE_OPTIONS,BLOB_TARGET_OPTIONS,BUCKET_LIST_OPTIONS,BUCKET_SOURCE_OPTIONS,BUCKET_TARGET_OPTIONS,options,otherOptions};
}"
93099,"@Test public void testReadChannelState() throws IOException, ClassNotFoundException {
  StorageOptions options=StorageOptions.builder().projectId(""String_Node_Str"").retryParams(RetryParams.defaultInstance()).build();
  ReadChannel reader=new BlobReadChannel(options,BlobId.of(""String_Node_Str"",""String_Node_Str""),EMPTY_RPC_OPTIONS);
  RestorableState<ReadChannel> state=reader.capture();
  RestorableState<ReadChannel> deserializedState=serializeAndDeserialize(state);
  assertEquals(state,deserializedState);
  assertEquals(state.hashCode(),deserializedState.hashCode());
  assertEquals(state.toString(),deserializedState.toString());
  reader.close();
}","@Test public void testReadChannelState() throws IOException, ClassNotFoundException {
  StorageOptions options=StorageOptions.builder().projectId(""String_Node_Str"").build();
  ReadChannel reader=new BlobReadChannel(options,BlobId.of(""String_Node_Str"",""String_Node_Str""),EMPTY_RPC_OPTIONS);
  assertRestorable(reader);
}"
93100,"protected static String message(IOException exception){
  if (exception instanceof GoogleJsonResponseException) {
    return ((GoogleJsonResponseException)exception).getDetails().getMessage();
  }
  return exception.getMessage();
}","protected static String message(IOException exception){
  if (exception instanceof GoogleJsonResponseException) {
    GoogleJsonError details=((GoogleJsonResponseException)exception).getDetails();
    if (details != null) {
      return details.getMessage();
    }
  }
  return exception.getMessage();
}"
93101,"@Override public Tuple<String,byte[]> read(StorageObject from,Map<Option,?> options,long position,int bytes){
  try {
    Get req=storage.objects().get(from.getBucket(),from.getName()).setGeneration(from.getGeneration()).setIfMetagenerationMatch(IF_METAGENERATION_MATCH.getLong(options)).setIfMetagenerationNotMatch(IF_METAGENERATION_NOT_MATCH.getLong(options)).setIfGenerationMatch(IF_GENERATION_MATCH.getLong(options)).setIfGenerationNotMatch(IF_GENERATION_NOT_MATCH.getLong(options));
    StringBuilder range=new StringBuilder();
    range.append(""String_Node_Str"").append(position).append(""String_Node_Str"").append(position + bytes - 1);
    req.getRequestHeaders().setRange(range.toString());
    ByteArrayOutputStream output=new ByteArrayOutputStream();
    req.executeMedia().download(output);
    String etag=req.getLastResponseHeaders().getETag();
    return Tuple.of(etag,output.toByteArray());
  }
 catch (  IOException ex) {
    throw translate(ex);
  }
}","@Override public Tuple<String,byte[]> read(StorageObject from,Map<Option,?> options,long position,int bytes){
  try {
    Get req=storage.objects().get(from.getBucket(),from.getName()).setGeneration(from.getGeneration()).setIfMetagenerationMatch(IF_METAGENERATION_MATCH.getLong(options)).setIfMetagenerationNotMatch(IF_METAGENERATION_NOT_MATCH.getLong(options)).setIfGenerationMatch(IF_GENERATION_MATCH.getLong(options)).setIfGenerationNotMatch(IF_GENERATION_NOT_MATCH.getLong(options));
    StringBuilder range=new StringBuilder();
    range.append(""String_Node_Str"").append(position).append(""String_Node_Str"").append(position + bytes - 1);
    req.getRequestHeaders().setRange(range.toString());
    ByteArrayOutputStream output=new ByteArrayOutputStream();
    req.executeMedia().download(output);
    String etag=req.getLastResponseHeaders().getETag();
    return Tuple.of(etag,output.toByteArray());
  }
 catch (  IOException ex) {
    StorageException serviceException=translate(ex);
    if (serviceException.code() == SC_REQUESTED_RANGE_NOT_SATISFIABLE) {
      return Tuple.of(null,new byte[0]);
    }
    throw serviceException;
  }
}"
93102,"@Override public int read(ByteBuffer byteBuffer) throws IOException {
  validateOpen();
  if (buffer == null) {
    if (endOfStream) {
      return -1;
    }
    final int toRead=Math.max(byteBuffer.remaining(),chunkSize);
    try {
      Tuple<String,byte[]> result=runWithRetries(new Callable<Tuple<String,byte[]>>(){
        @Override public Tuple<String,byte[]> call(){
          return storageRpc.read(storageObject,requestOptions,position,toRead);
        }
      }
,serviceOptions.retryParams(),StorageImpl.EXCEPTION_HANDLER);
      if (lastEtag != null && !Objects.equals(result.x(),lastEtag)) {
        StringBuilder messageBuilder=new StringBuilder();
        messageBuilder.append(""String_Node_Str"").append(blob).append(""String_Node_Str"");
        throw new StorageException(0,messageBuilder.toString());
      }
      lastEtag=result.x();
      buffer=result.y();
    }
 catch (    RetryHelper.RetryHelperException e) {
      throw StorageException.translateAndThrow(e);
    }
    if (toRead > buffer.length) {
      endOfStream=true;
      if (buffer.length == 0) {
        buffer=null;
        return -1;
      }
    }
  }
  int toWrite=Math.min(buffer.length - bufferPos,byteBuffer.remaining());
  byteBuffer.put(buffer,bufferPos,toWrite);
  bufferPos+=toWrite;
  if (bufferPos >= buffer.length) {
    position+=buffer.length;
    buffer=null;
    bufferPos=0;
  }
  return toWrite;
}","@Override public int read(ByteBuffer byteBuffer) throws IOException {
  validateOpen();
  if (buffer == null) {
    if (endOfStream) {
      return -1;
    }
    final int toRead=Math.max(byteBuffer.remaining(),chunkSize);
    try {
      Tuple<String,byte[]> result=runWithRetries(new Callable<Tuple<String,byte[]>>(){
        @Override public Tuple<String,byte[]> call(){
          return storageRpc.read(storageObject,requestOptions,position,toRead);
        }
      }
,serviceOptions.retryParams(),StorageImpl.EXCEPTION_HANDLER);
      if (result.y().length > 0 && lastEtag != null && !Objects.equals(result.x(),lastEtag)) {
        StringBuilder messageBuilder=new StringBuilder();
        messageBuilder.append(""String_Node_Str"").append(blob).append(""String_Node_Str"");
        throw new StorageException(0,messageBuilder.toString());
      }
      lastEtag=result.x();
      buffer=result.y();
    }
 catch (    RetryHelper.RetryHelperException e) {
      throw StorageException.translateAndThrow(e);
    }
    if (toRead > buffer.length) {
      endOfStream=true;
      if (buffer.length == 0) {
        buffer=null;
        return -1;
      }
    }
  }
  int toWrite=Math.min(buffer.length - bufferPos,byteBuffer.remaining());
  byteBuffer.put(buffer,bufferPos,toWrite);
  bufferPos+=toWrite;
  if (bufferPos >= buffer.length) {
    position+=buffer.length;
    buffer=null;
    bufferPos=0;
  }
  return toWrite;
}"
93103,"@Test public void testReadAndWriteChannelsWithDifferentFileSize() throws IOException {
  String blobNamePrefix=""String_Node_Str"";
  int[] blobSizes={0,700,1024 * 256,2 * 1024 * 1024,4 * 1024 * 1024,4 * 1024 * 1024 + 1};
  Random rnd=new Random();
  for (  int blobSize : blobSizes) {
    String blobName=blobNamePrefix + blobSize;
    BlobInfo blob=BlobInfo.builder(BUCKET,blobName).build();
    byte[] bytes=new byte[blobSize];
    rnd.nextBytes(bytes);
    try (WriteChannel writer=storage.writer(blob)){
      writer.write(ByteBuffer.wrap(BLOB_BYTE_CONTENT));
    }
     ByteBuffer readBytes;
    try (ReadChannel reader=storage.reader(blob.blobId())){
      readBytes=ByteBuffer.allocate(BLOB_BYTE_CONTENT.length);
      reader.read(readBytes);
    }
     assertArrayEquals(BLOB_BYTE_CONTENT,readBytes.array());
    assertTrue(storage.delete(BUCKET,blobName));
  }
}","@Test public void testReadAndWriteChannelsWithDifferentFileSize() throws IOException {
  String blobNamePrefix=""String_Node_Str"";
  int[] blobSizes={0,700,1024 * 256,2 * 1024 * 1024,4 * 1024 * 1024,4 * 1024 * 1024 + 1};
  Random rnd=new Random();
  for (  int blobSize : blobSizes) {
    String blobName=blobNamePrefix + blobSize;
    BlobInfo blob=BlobInfo.builder(BUCKET,blobName).build();
    byte[] bytes=new byte[blobSize];
    rnd.nextBytes(bytes);
    try (WriteChannel writer=storage.writer(blob)){
      writer.write(ByteBuffer.wrap(bytes));
    }
     ByteArrayOutputStream output=new ByteArrayOutputStream();
    try (ReadChannel reader=storage.reader(blob.blobId())){
      ByteBuffer buffer=ByteBuffer.allocate(64 * 1024);
      while (reader.read(buffer) > 0) {
        buffer.flip();
        output.write(buffer.array(),0,buffer.limit());
        buffer.clear();
      }
    }
     assertArrayEquals(bytes,output.toByteArray());
    assertTrue(storage.delete(BUCKET,blobName));
  }
}"
93104,"public B setNull(String name){
  properties.put(name,of());
  return self();
}","/** 
 * Sets a property of type   {@code NullValue}.
 * @param name name of the property
 */
public B setNull(String name){
  properties.put(name,of());
  return self();
}"
93105,"public B set(String name,Blob first,Blob second,Blob... others){
  List<BlobValue> values=new LinkedList<>();
  values.add(of(first));
  values.add(of(second));
  for (  Blob other : others) {
    values.add(of(other));
  }
  properties.put(name,of(values));
  return self();
}","/** 
 * Sets a list property containing elements of type   {@link BlobValue}.
 * @param name name of the property
 * @param first the first {@link Blob} in the list
 * @param second the second {@link Blob} in the list
 * @param others other {@link Blob}s in the list
 */
public B set(String name,Blob first,Blob second,Blob... others){
  List<BlobValue> values=new LinkedList<>();
  values.add(of(first));
  values.add(of(second));
  for (  Blob other : others) {
    values.add(of(other));
  }
  properties.put(name,of(values));
  return self();
}"
93106,"/** 
 * Returns the key's parent.
 */
@Override public Key parent(){
  List<PathElement> ancestors=ancestors();
  if (!ancestors.isEmpty()) {
    PathElement parent=ancestors.get(ancestors.size() - 1);
    Key.Builder keyBuilder;
    if (parent.hasName()) {
      keyBuilder=Key.builder(projectId(),parent.kind(),parent.name());
    }
 else {
      keyBuilder=Key.builder(projectId(),parent.kind(),parent.id());
    }
    return keyBuilder.ancestors(ancestors.subList(0,ancestors.size() - 1)).build();
  }
  return null;
}","/** 
 * Returns the key's parent.
 */
@Override public Key parent(){
  List<PathElement> ancestors=ancestors();
  if (ancestors.isEmpty()) {
    return null;
  }
  PathElement parent=ancestors.get(ancestors.size() - 1);
  Key.Builder keyBuilder;
  if (parent.hasName()) {
    keyBuilder=Key.builder(projectId(),parent.kind(),parent.name());
  }
 else {
    keyBuilder=Key.builder(projectId(),parent.kind(),parent.id());
  }
  String namespace=namespace();
  if (namespace != null) {
    keyBuilder.namespace(namespace);
  }
  return keyBuilder.ancestors(ancestors.subList(0,ancestors.size() - 1)).build();
}"
93107,"public static ListValue of(Value<?> first,Value<?> second,Value<?>... other){
  return new ListValue(first,second,other);
}","static ListValue of(Value<?> first,Value<?> second,Value<?>... other){
  return new ListValue(first,second,other);
}"
93108,"public Builder addValue(Value<?> first,Value<?> second,Value<?>... other){
  addValue(first);
  addValue(second);
  for (  Value<?> value : other) {
    addValue(value);
  }
  return this;
}","public Builder addValue(Value<?> first,Value<?>... other){
  addValue(first);
  for (  Value<?> value : other) {
    addValue(value);
  }
  return this;
}"
93109,"public static void main(String... args) throws IOException, InterruptedException {
  Map<String,String> parsedArgs=parseArgs(args);
  String action=parsedArgs.get(""String_Node_Str"");
  int port=(parsedArgs.get(""String_Node_Str"") == null) ? DEFAULT_PORT : Integer.parseInt(parsedArgs.get(""String_Node_Str""));
  double consistency=parsedArgs.get(""String_Node_Str"") == null ? DEFAULT_CONSISTENCY : Double.parseDouble(parsedArgs.get(""String_Node_Str""));
switch (action) {
case ""String_Node_Str"":
    if (!isActive(DEFAULT_PROJECT_ID,port)) {
      LocalGcdHelper helper=start(DEFAULT_PROJECT_ID,port,consistency);
      try (FileWriter writer=new FileWriter(""String_Node_Str"")){
        writer.write(helper.gcdPath.toAbsolutePath().toString() + System.lineSeparator());
        writer.write(Integer.toString(port));
      }
     }
  return;
case ""String_Node_Str"":
File file=new File(""String_Node_Str"");
String path=null;
boolean fileExists=file.exists();
if (fileExists) {
try (BufferedReader reader=new BufferedReader(new FileReader(file))){
path=reader.readLine();
port=Integer.parseInt(reader.readLine());
}
 }
sendQuitRequest(port);
if (fileExists) {
deleteRecurse(Paths.get(path));
file.delete();
}
return;
default :
break;
}
}","public static void main(String... args) throws IOException, InterruptedException {
  Map<String,String> parsedArgs=parseArgs(args);
  String action=parsedArgs.get(""String_Node_Str"");
  int port=(parsedArgs.get(""String_Node_Str"") == null) ? DEFAULT_PORT : Integer.parseInt(parsedArgs.get(""String_Node_Str""));
switch (action) {
case ""String_Node_Str"":
    if (!isActive(DEFAULT_PROJECT_ID,port)) {
      double consistency=parsedArgs.get(""String_Node_Str"") == null ? DEFAULT_CONSISTENCY : Double.parseDouble(parsedArgs.get(""String_Node_Str""));
      LocalGcdHelper helper=start(DEFAULT_PROJECT_ID,port,consistency);
      try (FileWriter writer=new FileWriter(""String_Node_Str"")){
        writer.write(helper.gcdPath.toAbsolutePath().toString() + System.lineSeparator());
        writer.write(Integer.toString(port));
      }
     }
  return;
case ""String_Node_Str"":
File file=new File(""String_Node_Str"");
String path=null;
boolean fileExists=file.exists();
if (fileExists) {
try (BufferedReader reader=new BufferedReader(new FileReader(file))){
path=reader.readLine();
port=Integer.parseInt(reader.readLine());
}
 }
sendQuitRequest(port);
if (fileExists) {
deleteRecurse(Paths.get(path));
file.delete();
}
return;
default :
break;
}
}"
93110,"@Test public void testBuilders() throws Exception {
  assertEquals(""String_Node_Str"",pk1.projectId());
  assertEquals(""String_Node_Str"",pk1.kind());
  assertTrue(pk1.ancestors().isEmpty());
  assertEquals(""String_Node_Str"",pk2.projectId());
  assertEquals(""String_Node_Str"",pk2.kind());
  assertEquals(parent.path(),pk2.ancestors());
  assertEquals(pk2,IncompleteKey.builder(pk2).build());
  IncompleteKey pk3=IncompleteKey.builder(pk2).kind(""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",pk3.projectId());
  assertEquals(""String_Node_Str"",pk3.kind());
  assertEquals(parent.path(),pk3.ancestors());
}","@Test public void testBuilders() throws Exception {
  assertEquals(""String_Node_Str"",pk1.projectId());
  assertEquals(""String_Node_Str"",pk1.kind());
  assertTrue(pk1.ancestors().isEmpty());
  assertEquals(""String_Node_Str"",pk2.projectId());
  assertEquals(""String_Node_Str"",pk2.kind());
  assertEquals(parent1.path(),pk2.ancestors());
  assertEquals(pk2,IncompleteKey.builder(pk2).build());
  IncompleteKey pk3=IncompleteKey.builder(pk2).kind(""String_Node_Str"").build();
  assertEquals(""String_Node_Str"",pk3.projectId());
  assertEquals(""String_Node_Str"",pk3.kind());
  assertEquals(parent1.path(),pk3.ancestors());
}"
93111,"@Before public void setUp(){
  pk1=IncompleteKey.builder(""String_Node_Str"",""String_Node_Str"").build();
  parent=Key.builder(""String_Node_Str"",""String_Node_Str"",10).build();
  pk2=IncompleteKey.builder(parent,""String_Node_Str"").build();
}","@Before public void setUp(){
  pk1=IncompleteKey.builder(""String_Node_Str"",""String_Node_Str"").build();
  parent1=Key.builder(""String_Node_Str"",""String_Node_Str"",10).namespace(""String_Node_Str"").build();
  pk2=IncompleteKey.builder(parent1,""String_Node_Str"").build();
}"
93112,"@Test public void testParent(){
  assertNull(pk1.parent());
  assertEquals(parent,pk2.parent());
}","@Test public void testParent(){
  assertNull(pk1.parent());
  assertEquals(parent1,pk2.parent());
  Key parent2=Key.builder(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").namespace(""String_Node_Str"").build();
  IncompleteKey pk3=IncompleteKey.builder(parent2,""String_Node_Str"").build();
  assertEquals(parent2,pk3.parent());
}"
93113,"/** 
 * Adds a row to be inserted without an associated id. <p>Example usage of adding a row without an associated id: <pre>     {@code InsertAllRequest.Builder builder = InsertAllRequest.builder(tableId); List<Long> repeatedFieldValue = Arrays.asList(1L, 2L); Map<String, Object> recordContent = new HashMap<String, Object>(); recordContent.put(""subfieldName1"", ""value""); recordContent.put(""subfieldName2"", repeatedFieldValue); Map<String, Object> rowContent = new HashMap<String, Object>(); rowContent.put(""fieldName1"", true); rowContent.put(""fieldName2"", recordContent); builder.addRow(rowContent);}</pre>
 */
public Builder addRow(Map<String,Object> content){
  addRow(new RowToInsert(null,content));
  return this;
}","/** 
 * Adds a row to be inserted without an associated id. <p>Example usage of adding a row without an associated id: <pre>   {@code InsertAllRequest.Builder builder = InsertAllRequest.builder(tableId); List<Long> repeatedFieldValue = Arrays.asList(1L, 2L); Map<String, Object> recordContent = new HashMap<String, Object>(); recordContent.put(""subfieldName1"", ""value""); recordContent.put(""subfieldName2"", repeatedFieldValue); Map<String, Object> rowContent = new HashMap<String, Object>(); rowContent.put(""fieldName1"", true); rowContent.put(""fieldName2"", recordContent); builder.addRow(rowContent);}</pre>
 */
public Builder addRow(Map<String,Object> content){
  addRow(new RowToInsert(null,content));
  return this;
}"
93114,"@AfterClass public static void afterClass() throws ExecutionException, InterruptedException {
  if (bigquery != null) {
    RemoteBigQueryHelper.forceDelete(bigquery,DATASET);
  }
  if (storage != null && !RemoteGcsHelper.forceDelete(storage,BUCKET,10,TimeUnit.SECONDS)) {
    if (LOG.isLoggable(Level.WARNING)) {
      LOG.log(Level.WARNING,""String_Node_Str"",BUCKET);
    }
  }
}","@AfterClass public static void afterClass() throws ExecutionException, InterruptedException {
  if (bigquery != null) {
    RemoteBigQueryHelper.forceDelete(bigquery,DATASET);
  }
  if (storage != null && !RemoteGcsHelper.forceDelete(storage,BUCKET,10,TimeUnit.SECONDS) && LOG.isLoggable(Level.WARNING)) {
    LOG.log(Level.WARNING,""String_Node_Str"",BUCKET);
  }
}"
93115,"/** 
 * Updates the blob's information. Bucket or blob's name cannot be changed by this method. If you want to rename the blob or move it to a different bucket use the   {@link #copyTo} and{@link #delete} operations. A new {@code Blob} object is returned. By default no checks aremade on the metadata generation of the current blob. If you want to update the information only if the current blob metadata are at their latest version use the  {@code metagenerationMatch}option:   {@code newBlob.update(BlobTargetOption.metagenerationMatch())}. <p>Original metadata are merged with metadata in the provided in this   {@code blob}. To replace metadata instead you first have to unset them. Unsetting metadata can be done by setting this  {@code blob}'s metadata to   {@code null}. </p> <p>Example usage of replacing blob's metadata: <pre>      {@code blob.toBuilder().metadata(null).build().update();}{@code blob.toBuilder().metadata(newMetadata).build().update();}</pre>
 * @param options update options
 * @return a {@code Blob} object with updated information
 * @throws StorageException upon failure
 */
public Blob update(BlobTargetOption... options){
  return storage.update(this,options);
}","/** 
 * Updates the blob's information. Bucket or blob's name cannot be changed by this method. If you want to rename the blob or move it to a different bucket use the   {@link #copyTo} and{@link #delete} operations. A new {@code Blob} object is returned. By default no checks aremade on the metadata generation of the current blob. If you want to update the information only if the current blob metadata are at their latest version use the  {@code metagenerationMatch}option:   {@code newBlob.update(BlobTargetOption.metagenerationMatch())}. <p>Original metadata are merged with metadata in the provided in this   {@code blob}. To replace metadata instead you first have to unset them. Unsetting metadata can be done by setting this  {@code blob}'s metadata to   {@code null}. </p> <p>Example usage of replacing blob's metadata: <pre>   {@code blob.toBuilder().metadata(null).build().update();}{@code blob.toBuilder().metadata(newMetadata).build().update();}</pre>
 * @param options update options
 * @return a {@code Blob} object with updated information
 * @throws StorageException upon failure
 */
public Blob update(BlobTargetOption... options){
  return storage.update(this,options);
}"
93116,"/** 
 * Generates a signed URL for a blob. If you have a blob that you want to allow access to for a fixed amount of time, you can use this method to generate a URL that is only valid within a certain time period. This is particularly useful if you don't want publicly accessible blobs, but don't want to require users to explicitly log in. <p>Example usage of creating a signed URL that is valid for 2 weeks: <pre>     {@code service.signUrl(BlobInfo.builder(""bucket"", ""name"").build(), 14, TimeUnit.DAYS);}</pre>
 * @param blobInfo the blob associated with the signed URL
 * @param duration time until the signed URL expires, expressed in {@code unit}. The finest granularity supported is 1 second, finer granularities will be truncated
 * @param unit time unit of the {@code duration} parameter
 * @param options optional URL signing options
 * @see <a href=""https://cloud.google.com/storage/docs/access-control#Signed-URLs"">Signed-URLs</a>
 */
URL signUrl(BlobInfo blobInfo,long duration,TimeUnit unit,SignUrlOption... options);","/** 
 * Generates a signed URL for a blob. If you have a blob that you want to allow access to for a fixed amount of time, you can use this method to generate a URL that is only valid within a certain time period. This is particularly useful if you don't want publicly accessible blobs, but don't want to require users to explicitly log in. <p>Example usage of creating a signed URL that is valid for 2 weeks: <pre>   {@code service.signUrl(BlobInfo.builder(""bucket"", ""name"").build(), 14, TimeUnit.DAYS);}</pre>
 * @param blobInfo the blob associated with the signed URL
 * @param duration time until the signed URL expires, expressed in {@code unit}. The finest granularity supported is 1 second, finer granularities will be truncated
 * @param unit time unit of the {@code duration} parameter
 * @param options optional URL signing options
 * @see <a href=""https://cloud.google.com/storage/docs/access-control#Signed-URLs"">Signed-URLs</a>
 */
URL signUrl(BlobInfo blobInfo,long duration,TimeUnit unit,SignUrlOption... options);"
93117,"/** 
 * Sends a copy request. Returns a   {@link CopyWriter} object for the provided{@code CopyRequest}. If source and destination objects share the same location and storage class the source blob is copied with one request and   {@link CopyWriter#result()} immediatelyreturns, regardless of the  {@link CopyRequest#megabytesCopiedPerChunk} parameter.If source and destination have different location or storage class  {@link CopyWriter#result()}might issue multiple RPC calls depending on blob's size. <p>Example usage of copy: <pre>      {@code BlobInfo blob = service.copy(copyRequest).result();}</pre> To explicitly issue chunk copy requests use   {@link CopyWriter#copyChunk()} instead:<pre>      {@code CopyWriter copyWriter = service.copy(copyRequest);}while (!copyWriter.isDone())  copyWriter.copyChunk(); } BlobInfo blob = copyWriter.result(); } </pre>
 * @return a {@link CopyWriter} object that can be used to get information on the newly createdblob or to complete the copy if more than one RPC request is needed
 * @throws StorageException upon failure
 * @see <a href=""https://cloud.google.com/storage/docs/json_api/v1/objects/rewrite"">Rewrite</a>
 */
CopyWriter copy(CopyRequest copyRequest);","/** 
 * Sends a copy request. Returns a   {@link CopyWriter} object for the provided{@code CopyRequest}. If source and destination objects share the same location and storage class the source blob is copied with one request and   {@link CopyWriter#result()} immediatelyreturns, regardless of the  {@link CopyRequest#megabytesCopiedPerChunk} parameter.If source and destination have different location or storage class  {@link CopyWriter#result()}might issue multiple RPC calls depending on blob's size. <p>Example usage of copy: <pre>   {@code BlobInfo blob = service.copy(copyRequest).result();}</pre> To explicitly issue chunk copy requests use   {@link CopyWriter#copyChunk()} instead:<pre>  {@code CopyWriter copyWriter = service.copy(copyRequest);}while (!copyWriter.isDone())  copyWriter.copyChunk(); } BlobInfo blob = copyWriter.result(); } </pre>
 * @return a {@link CopyWriter} object that can be used to get information on the newly createdblob or to complete the copy if more than one RPC request is needed
 * @throws StorageException upon failure
 * @see <a href=""https://cloud.google.com/storage/docs/json_api/v1/objects/rewrite"">Rewrite</a>
 */
CopyWriter copy(CopyRequest copyRequest);"
93118,"@Test public void testDeleteBlobsFail(){
  String sourceBlobName1=""String_Node_Str"";
  String sourceBlobName2=""String_Node_Str"";
  BlobInfo sourceBlob1=BlobInfo.builder(BUCKET,sourceBlobName1).build();
  BlobInfo sourceBlob2=BlobInfo.builder(BUCKET,sourceBlobName2).build();
  assertNotNull(storage.create(sourceBlob1));
  List<Boolean> deleteStatus=storage.delete(sourceBlob1.blobId(),sourceBlob2.blobId());
  assertTrue(deleteStatus.get(0));
  assertTrue(!deleteStatus.get(1));
}","@Test public void testDeleteBlobsFail(){
  String sourceBlobName1=""String_Node_Str"";
  String sourceBlobName2=""String_Node_Str"";
  BlobInfo sourceBlob1=BlobInfo.builder(BUCKET,sourceBlobName1).build();
  BlobInfo sourceBlob2=BlobInfo.builder(BUCKET,sourceBlobName2).build();
  assertNotNull(storage.create(sourceBlob1));
  List<Boolean> deleteStatus=storage.delete(sourceBlob1.blobId(),sourceBlob2.blobId());
  assertTrue(deleteStatus.get(0));
  assertFalse(deleteStatus.get(1));
}"
93119,"@Test public void testDeleteNonExistingBlob(){
  String blobName=""String_Node_Str"";
  assertTrue(!storage.delete(BUCKET,blobName));
}","@Test public void testDeleteNonExistingBlob(){
  String blobName=""String_Node_Str"";
  assertFalse(storage.delete(BUCKET,blobName));
}"
93120,"@Test public void testDeleteBlobNonExistingGeneration(){
  String blobName=""String_Node_Str"";
  BlobInfo blob=BlobInfo.builder(BUCKET,blobName).build();
  assertNotNull(storage.create(blob));
  assertTrue(!storage.delete(BlobId.of(BUCKET,blobName,-1L)));
}","@Test public void testDeleteBlobNonExistingGeneration(){
  String blobName=""String_Node_Str"";
  BlobInfo blob=BlobInfo.builder(BUCKET,blobName).build();
  assertNotNull(storage.create(blob));
  assertFalse(storage.delete(BlobId.of(BUCKET,blobName,-1L)));
}"
93121,"@AfterClass public static void afterClass() throws ExecutionException, InterruptedException {
  if (storage != null && !RemoteGcsHelper.forceDelete(storage,BUCKET,5,TimeUnit.SECONDS)) {
    if (log.isLoggable(Level.WARNING)) {
      log.log(Level.WARNING,""String_Node_Str"",BUCKET);
    }
  }
}","@AfterClass public static void afterClass() throws ExecutionException, InterruptedException {
  if (storage != null && !RemoteGcsHelper.forceDelete(storage,BUCKET,5,TimeUnit.SECONDS) && log.isLoggable(Level.WARNING)) {
    log.log(Level.WARNING,""String_Node_Str"",BUCKET);
  }
}"
93122,"/** 
 * Adds a row to be inserted without an associated id. <p>Example usage of adding a row without an associated id: <pre>      {@code InsertAllRequest.Builder builder = InsertAllRequest.builder(tableId); List<Long> repeatedFieldValue = Arrays.asList(1L, 2L); Map<String, Object> recordContent = new HashMap<String, Object>(); recordContent.put(""subfieldName1"", ""value""); recordContent.put(""subfieldName2"", repeatedFieldValue); Map<String, Object> rowContent = new HashMap<String, Object>(); rowContent.put(""fieldName1"", true); rowContent.put(""fieldName2"", recordContent); builder.addRow(rowContent);}</pre>
 */
public Builder addRow(Map<String,Object> content){
  addRow(new RowToInsert(null,content));
  return this;
}","/** 
 * Adds a row to be inserted without an associated id. <p>Example usage of adding a row without an associated id: <pre>     {@code InsertAllRequest.Builder builder = InsertAllRequest.builder(tableId); List<Long> repeatedFieldValue = Arrays.asList(1L, 2L); Map<String, Object> recordContent = new HashMap<String, Object>(); recordContent.put(""subfieldName1"", ""value""); recordContent.put(""subfieldName2"", repeatedFieldValue); Map<String, Object> rowContent = new HashMap<String, Object>(); rowContent.put(""fieldName1"", true); rowContent.put(""fieldName2"", recordContent); builder.addRow(rowContent);}</pre>
 */
public Builder addRow(Map<String,Object> content){
  addRow(new RowToInsert(null,content));
  return this;
}"
93123,"/** 
 * Sends a copy request. Returns a   {@link CopyWriter} object for the provided{@code CopyRequest}. If source and destination objects share the same location and storage class the source blob is copied with one request and   {@link CopyWriter#result()} immediatelyreturns, regardless of the  {@link CopyRequest#megabytesCopiedPerChunk} parameter.If source and destination have different location or storage class  {@link CopyWriter#result()}might issue multiple RPC calls depending on blob's size. <p>Example usage of copy: <pre>      {@code BlobInfo blob = service.copy(copyRequest).result();}</pre> To explicitly issue chunk copy requests use   {@link CopyWriter#copyChunk()} instead:<pre>     {@code CopyWriter copyWriter = service.copy(copyRequest);}while (!copyWriter.isDone())  copyWriter.copyChunk(); } BlobInfo blob = copyWriter.result(); } </pre>
 * @return a {@link CopyWriter} object that can be used to get information on the newly createdblob or to complete the copy if more than one RPC request is needed
 * @throws StorageException upon failure
 * @see <a href=""https://cloud.google.com/storage/docs/json_api/v1/objects/rewrite"">Rewrite</a>
 */
CopyWriter copy(CopyRequest copyRequest);","/** 
 * Sends a copy request. Returns a   {@link CopyWriter} object for the provided{@code CopyRequest}. If source and destination objects share the same location and storage class the source blob is copied with one request and   {@link CopyWriter#result()} immediatelyreturns, regardless of the  {@link CopyRequest#megabytesCopiedPerChunk} parameter.If source and destination have different location or storage class  {@link CopyWriter#result()}might issue multiple RPC calls depending on blob's size. <p>Example usage of copy: <pre>      {@code BlobInfo blob = service.copy(copyRequest).result();}</pre> To explicitly issue chunk copy requests use   {@link CopyWriter#copyChunk()} instead:<pre>      {@code CopyWriter copyWriter = service.copy(copyRequest);}while (!copyWriter.isDone())  copyWriter.copyChunk(); } BlobInfo blob = copyWriter.result(); } </pre>
 * @return a {@link CopyWriter} object that can be used to get information on the newly createdblob or to complete the copy if more than one RPC request is needed
 * @throws StorageException upon failure
 * @see <a href=""https://cloud.google.com/storage/docs/json_api/v1/objects/rewrite"">Rewrite</a>
 */
CopyWriter copy(CopyRequest copyRequest);"
93124,"protected static com.google.protobuf.Timestamp microsecondsToTimestampPb(long microseconds){
  long seconds=microseconds / 1000000;
  int nanos=(int)(microseconds % 1000000) * 1000;
  return com.google.protobuf.Timestamp.newBuilder().setSeconds(seconds).setNanos(nanos).build();
}","static com.google.protobuf.Timestamp microsecondsToTimestampPb(long microseconds){
  long seconds=microseconds / 1000000;
  int nanos=(int)(microseconds % 1000000) * 1000;
  return com.google.protobuf.Timestamp.newBuilder().setSeconds(seconds).setNanos(nanos).build();
}"
93125,"protected static long timestampPbToMicroseconds(com.google.protobuf.Timestamp timestampPb){
  return timestampPb.getSeconds() * 1000000 + timestampPb.getNanos() / 1000;
}","static long timestampPbToMicroseconds(com.google.protobuf.Timestamp timestampPb){
  return timestampPb.getSeconds() * 1000000 + timestampPb.getNanos() / 1000;
}"
93126,"@Override protected T computeNext(){
  while (!entityResultPbIter.hasNext() && !lastBatch) {
    query=query.nextQuery(runQueryResponsePb);
    sendRequest();
  }
  if (!entityResultPbIter.hasNext()) {
    return endOfData();
  }
  com.google.datastore.v1beta3.EntityResult entityResultPb=entityResultPbIter.next();
  cursor=entityResultPb.getCursor();
  @SuppressWarnings(""String_Node_Str"") T result=(T)actualResultType.convert(entityResultPb.getEntity());
  return result;
}","@Override protected T computeNext(){
  while (!entityResultPbIter.hasNext() && !lastBatch) {
    query=query.nextQuery(runQueryResponsePb);
    sendRequest();
  }
  if (!entityResultPbIter.hasNext()) {
    cursor=runQueryResponsePb.getBatch().getEndCursor();
    return endOfData();
  }
  com.google.datastore.v1beta3.EntityResult entityResultPb=entityResultPbIter.next();
  cursor=entityResultPb.getCursor();
  @SuppressWarnings(""String_Node_Str"") T result=(T)actualResultType.convert(entityResultPb.getEntity());
  return result;
}"
93127,"@Test public void testTranslateAndThrow() throws Exception {
  DatastoreException cause=new DatastoreException(503,""String_Node_Str"",""String_Node_Str"");
  RetryHelper.RetryHelperException exceptionMock=createMock(RetryHelper.RetryHelperException.class);
  expect(exceptionMock.getCause()).andReturn(cause).times(2);
  replay(exceptionMock);
  try {
    DatastoreException.translateAndThrow(exceptionMock);
  }
 catch (  BaseServiceException ex) {
    assertEquals(503,ex.code());
    assertEquals(""String_Node_Str"",ex.getMessage());
    assertTrue(ex.retryable());
    assertTrue(ex.idempotent());
  }
 finally {
    verify(exceptionMock);
  }
}","@Test public void testTranslateAndThrow() throws Exception {
  DatastoreException cause=new DatastoreException(14,""String_Node_Str"",""String_Node_Str"");
  RetryHelper.RetryHelperException exceptionMock=createMock(RetryHelper.RetryHelperException.class);
  expect(exceptionMock.getCause()).andReturn(cause).times(2);
  replay(exceptionMock);
  try {
    DatastoreException.translateAndThrow(exceptionMock);
  }
 catch (  BaseServiceException ex) {
    assertEquals(14,ex.code());
    assertEquals(""String_Node_Str"",ex.getMessage());
    assertTrue(ex.retryable());
    assertTrue(ex.idempotent());
  }
 finally {
    verify(exceptionMock);
  }
}"
93128,"@Test public void testDatastoreException() throws Exception {
  DatastoreException exception=new DatastoreException(409,""String_Node_Str"",""String_Node_Str"");
  assertEquals(409,exception.code());
  assertEquals(""String_Node_Str"",exception.reason());
  assertEquals(""String_Node_Str"",exception.getMessage());
  assertTrue(exception.retryable());
  assertTrue(exception.idempotent());
  exception=new DatastoreException(403,""String_Node_Str"",""String_Node_Str"");
  assertEquals(403,exception.code());
  assertEquals(""String_Node_Str"",exception.reason());
  assertEquals(""String_Node_Str"",exception.getMessage());
  assertTrue(exception.retryable());
  assertTrue(exception.idempotent());
  exception=new DatastoreException(503,""String_Node_Str"",""String_Node_Str"");
  assertEquals(503,exception.code());
  assertEquals(""String_Node_Str"",exception.reason());
  assertEquals(""String_Node_Str"",exception.getMessage());
  assertTrue(exception.retryable());
  assertTrue(exception.idempotent());
  exception=new DatastoreException(500,""String_Node_Str"",""String_Node_Str"");
  assertEquals(500,exception.code());
  assertEquals(""String_Node_Str"",exception.reason());
  assertEquals(""String_Node_Str"",exception.getMessage());
  assertFalse(exception.retryable());
  assertTrue(exception.idempotent());
  IOException cause=new SocketTimeoutException();
  exception=new DatastoreException(cause);
  assertNull(exception.reason());
  assertNull(exception.getMessage());
  assertTrue(exception.retryable());
  assertTrue(exception.idempotent());
}","@Test public void testDatastoreException() throws Exception {
  DatastoreException exception=new DatastoreException(10,""String_Node_Str"",""String_Node_Str"");
  assertEquals(10,exception.code());
  assertEquals(""String_Node_Str"",exception.reason());
  assertEquals(""String_Node_Str"",exception.getMessage());
  assertTrue(exception.retryable());
  assertTrue(exception.idempotent());
  exception=new DatastoreException(4,""String_Node_Str"",""String_Node_Str"");
  assertEquals(4,exception.code());
  assertEquals(""String_Node_Str"",exception.reason());
  assertEquals(""String_Node_Str"",exception.getMessage());
  assertTrue(exception.retryable());
  assertTrue(exception.idempotent());
  exception=new DatastoreException(14,""String_Node_Str"",""String_Node_Str"");
  assertEquals(14,exception.code());
  assertEquals(""String_Node_Str"",exception.reason());
  assertEquals(""String_Node_Str"",exception.getMessage());
  assertTrue(exception.retryable());
  assertTrue(exception.idempotent());
  exception=new DatastoreException(2,""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,exception.code());
  assertEquals(""String_Node_Str"",exception.reason());
  assertEquals(""String_Node_Str"",exception.getMessage());
  assertFalse(exception.retryable());
  assertTrue(exception.idempotent());
  IOException cause=new SocketTimeoutException();
  exception=new DatastoreException(cause);
  assertNull(exception.reason());
  assertNull(exception.getMessage());
  assertTrue(exception.retryable());
  assertTrue(exception.idempotent());
}"
93129,"@Test public void testRetryableException() throws Exception {
  com.google.datastore.v1beta3.LookupRequest requestPb=com.google.datastore.v1beta3.LookupRequest.newBuilder().addKeys(KEY1.toPb()).build();
  com.google.datastore.v1beta3.LookupResponse responsePb=com.google.datastore.v1beta3.LookupResponse.newBuilder().addFound(com.google.datastore.v1beta3.EntityResult.newBuilder().setEntity(ENTITY1.toPb())).build();
  DatastoreRpcFactory rpcFactoryMock=EasyMock.createStrictMock(DatastoreRpcFactory.class);
  DatastoreRpc rpcMock=EasyMock.createStrictMock(DatastoreRpc.class);
  EasyMock.expect(rpcFactoryMock.create(EasyMock.anyObject(DatastoreOptions.class))).andReturn(rpcMock);
  EasyMock.expect(rpcMock.lookup(requestPb)).andThrow(new DatastoreException(503,""String_Node_Str"",""String_Node_Str"",null)).andReturn(responsePb);
  EasyMock.replay(rpcFactoryMock,rpcMock);
  DatastoreOptions options=this.options.toBuilder().retryParams(RetryParams.defaultInstance()).serviceRpcFactory(rpcFactoryMock).build();
  Datastore datastore=options.service();
  Entity entity=datastore.get(KEY1);
  assertEquals(ENTITY1,entity);
  EasyMock.verify(rpcFactoryMock,rpcMock);
}","@Test public void testRetryableException() throws Exception {
  com.google.datastore.v1beta3.LookupRequest requestPb=com.google.datastore.v1beta3.LookupRequest.newBuilder().addKeys(KEY1.toPb()).build();
  com.google.datastore.v1beta3.LookupResponse responsePb=com.google.datastore.v1beta3.LookupResponse.newBuilder().addFound(com.google.datastore.v1beta3.EntityResult.newBuilder().setEntity(ENTITY1.toPb())).build();
  DatastoreRpcFactory rpcFactoryMock=EasyMock.createStrictMock(DatastoreRpcFactory.class);
  DatastoreRpc rpcMock=EasyMock.createStrictMock(DatastoreRpc.class);
  EasyMock.expect(rpcFactoryMock.create(EasyMock.anyObject(DatastoreOptions.class))).andReturn(rpcMock);
  EasyMock.expect(rpcMock.lookup(requestPb)).andThrow(new DatastoreException(14,""String_Node_Str"",""String_Node_Str"",null)).andReturn(responsePb);
  EasyMock.replay(rpcFactoryMock,rpcMock);
  DatastoreOptions options=this.options.toBuilder().retryParams(RetryParams.defaultInstance()).serviceRpcFactory(rpcFactoryMock).build();
  Datastore datastore=options.service();
  Entity entity=datastore.get(KEY1);
  assertEquals(ENTITY1,entity);
  EasyMock.verify(rpcFactoryMock,rpcMock);
}"
93130,"private Builder(com.google.api.services.bigquery.model.JobConfiguration configurationPb){
  super(Type.COPY);
  JobConfigurationTableCopy copyConfigurationPb=configurationPb.getCopy();
  this.destinationTable=TableId.fromPb(copyConfigurationPb.getDestinationTable());
  if (copyConfigurationPb.getSourceTables() != null) {
    this.sourceTables=Lists.transform(copyConfigurationPb.getSourceTables(),TableId.FROM_PB_FUNCTION);
  }
 else {
    this.sourceTables=ImmutableList.of(TableId.fromPb(copyConfigurationPb.getSourceTable()));
  }
  if (copyConfigurationPb.getCreateDisposition() != null) {
    this.createDisposition=JobInfo.CreateDisposition.valueOf(copyConfigurationPb.getCreateDisposition());
  }
  if (copyConfigurationPb.getWriteDisposition() != null) {
    this.writeDisposition=JobInfo.WriteDisposition.valueOf(copyConfigurationPb.getWriteDisposition());
  }
}","private Builder(com.google.api.services.bigquery.model.JobConfiguration configurationPb){
  this();
  JobConfigurationTableCopy copyConfigurationPb=configurationPb.getCopy();
  this.destinationTable=TableId.fromPb(copyConfigurationPb.getDestinationTable());
  if (copyConfigurationPb.getSourceTables() != null) {
    this.sourceTables=Lists.transform(copyConfigurationPb.getSourceTables(),TableId.FROM_PB_FUNCTION);
  }
 else {
    this.sourceTables=ImmutableList.of(TableId.fromPb(copyConfigurationPb.getSourceTable()));
  }
  if (copyConfigurationPb.getCreateDisposition() != null) {
    this.createDisposition=JobInfo.CreateDisposition.valueOf(copyConfigurationPb.getCreateDisposition());
  }
  if (copyConfigurationPb.getWriteDisposition() != null) {
    this.writeDisposition=JobInfo.WriteDisposition.valueOf(copyConfigurationPb.getWriteDisposition());
  }
}"
93131,"@Override protected ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",sourceTables).add(""String_Node_Str"",destinationTable).add(""String_Node_Str"",createDisposition).add(""String_Node_Str"",writeDisposition);
}","@Override ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",sourceTables).add(""String_Node_Str"",destinationTable).add(""String_Node_Str"",createDisposition).add(""String_Node_Str"",writeDisposition);
}"
93132,"private Builder(com.google.api.services.bigquery.model.JobConfiguration configurationPb){
  super(Type.EXTRACT);
  JobConfigurationExtract extractConfigurationPb=configurationPb.getExtract();
  this.sourceTable=TableId.fromPb(extractConfigurationPb.getSourceTable());
  this.destinationUris=extractConfigurationPb.getDestinationUris();
  this.printHeader=extractConfigurationPb.getPrintHeader();
  this.fieldDelimiter=extractConfigurationPb.getFieldDelimiter();
  this.format=extractConfigurationPb.getDestinationFormat();
  this.compression=extractConfigurationPb.getCompression();
}","private Builder(com.google.api.services.bigquery.model.JobConfiguration configurationPb){
  this();
  JobConfigurationExtract extractConfigurationPb=configurationPb.getExtract();
  this.sourceTable=TableId.fromPb(extractConfigurationPb.getSourceTable());
  this.destinationUris=extractConfigurationPb.getDestinationUris();
  this.printHeader=extractConfigurationPb.getPrintHeader();
  this.fieldDelimiter=extractConfigurationPb.getFieldDelimiter();
  this.format=extractConfigurationPb.getDestinationFormat();
  this.compression=extractConfigurationPb.getCompression();
}"
93133,"@Override protected ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",sourceTable).add(""String_Node_Str"",destinationUris).add(""String_Node_Str"",format).add(""String_Node_Str"",printHeader).add(""String_Node_Str"",fieldDelimiter).add(""String_Node_Str"",compression);
}","@Override ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",sourceTable).add(""String_Node_Str"",destinationUris).add(""String_Node_Str"",format).add(""String_Node_Str"",printHeader).add(""String_Node_Str"",fieldDelimiter).add(""String_Node_Str"",compression);
}"
93134,"protected final int baseHashCode(){
  return Objects.hash(type);
}","final int baseHashCode(){
  return Objects.hash(type);
}"
93135,"protected final boolean baseEquals(JobConfiguration jobConfiguration){
  return Objects.equals(toPb(),jobConfiguration.toPb());
}","final boolean baseEquals(JobConfiguration jobConfiguration){
  return Objects.equals(toPb(),jobConfiguration.toPb());
}"
93136,"protected Builder(Type type){
  this.type=checkNotNull(type);
}","Builder(Type type){
  this.type=checkNotNull(type);
}"
93137,"protected ToStringHelper toStringHelper(){
  return MoreObjects.toStringHelper(this).add(""String_Node_Str"",type);
}","ToStringHelper toStringHelper(){
  return MoreObjects.toStringHelper(this).add(""String_Node_Str"",type);
}"
93138,"@SuppressWarnings(""String_Node_Str"") protected B self(){
  return (B)this;
}","@SuppressWarnings(""String_Node_Str"") B self(){
  return (B)this;
}"
93139,"protected JobConfiguration(Builder builder){
  this.type=builder.type;
}","JobConfiguration(Builder builder){
  this.type=builder.type;
}"
93140,"JobInfo setProjectId(String projectId){
  return toBuilder().configuration(this.configuration().setProjectId(projectId)).build();
}","JobInfo setProjectId(String projectId){
  return toBuilder().configuration(configuration.setProjectId(projectId)).build();
}"
93141,"private Builder(com.google.api.services.bigquery.model.JobConfiguration configurationPb){
  super(Type.LOAD);
  JobConfigurationLoad loadConfigurationPb=configurationPb.getLoad();
  this.destinationTable=TableId.fromPb(loadConfigurationPb.getDestinationTable());
  if (loadConfigurationPb.getCreateDisposition() != null) {
    this.createDisposition=JobInfo.CreateDisposition.valueOf(loadConfigurationPb.getCreateDisposition());
  }
  if (loadConfigurationPb.getWriteDisposition() != null) {
    this.writeDisposition=JobInfo.WriteDisposition.valueOf(loadConfigurationPb.getWriteDisposition());
  }
  if (loadConfigurationPb.getSourceFormat() != null) {
    this.formatOptions=FormatOptions.of(loadConfigurationPb.getSourceFormat());
  }
  if (loadConfigurationPb.getAllowJaggedRows() != null || loadConfigurationPb.getAllowQuotedNewlines() != null || loadConfigurationPb.getEncoding() != null || loadConfigurationPb.getFieldDelimiter() != null || loadConfigurationPb.getQuote() != null || loadConfigurationPb.getSkipLeadingRows() != null) {
    CsvOptions.Builder builder=CsvOptions.builder().allowJaggedRows(loadConfigurationPb.getAllowJaggedRows()).allowQuotedNewLines(loadConfigurationPb.getAllowQuotedNewlines()).encoding(loadConfigurationPb.getEncoding()).fieldDelimiter(loadConfigurationPb.getFieldDelimiter()).quote(loadConfigurationPb.getQuote()).skipLeadingRows(loadConfigurationPb.getSkipLeadingRows());
    this.formatOptions=builder.build();
  }
  this.maxBadRecords=loadConfigurationPb.getMaxBadRecords();
  if (loadConfigurationPb.getSchema() != null) {
    this.schema=Schema.fromPb(loadConfigurationPb.getSchema());
  }
  this.ignoreUnknownValues=loadConfigurationPb.getIgnoreUnknownValues();
  this.projectionFields=loadConfigurationPb.getProjectionFields();
  if (loadConfigurationPb.getSourceUris() != null) {
    this.sourceUris=ImmutableList.copyOf(configurationPb.getLoad().getSourceUris());
  }
}","private Builder(com.google.api.services.bigquery.model.JobConfiguration configurationPb){
  this();
  JobConfigurationLoad loadConfigurationPb=configurationPb.getLoad();
  this.destinationTable=TableId.fromPb(loadConfigurationPb.getDestinationTable());
  if (loadConfigurationPb.getCreateDisposition() != null) {
    this.createDisposition=JobInfo.CreateDisposition.valueOf(loadConfigurationPb.getCreateDisposition());
  }
  if (loadConfigurationPb.getWriteDisposition() != null) {
    this.writeDisposition=JobInfo.WriteDisposition.valueOf(loadConfigurationPb.getWriteDisposition());
  }
  if (loadConfigurationPb.getSourceFormat() != null) {
    this.formatOptions=FormatOptions.of(loadConfigurationPb.getSourceFormat());
  }
  if (loadConfigurationPb.getAllowJaggedRows() != null || loadConfigurationPb.getAllowQuotedNewlines() != null || loadConfigurationPb.getEncoding() != null || loadConfigurationPb.getFieldDelimiter() != null || loadConfigurationPb.getQuote() != null || loadConfigurationPb.getSkipLeadingRows() != null) {
    CsvOptions.Builder builder=CsvOptions.builder().allowJaggedRows(loadConfigurationPb.getAllowJaggedRows()).allowQuotedNewLines(loadConfigurationPb.getAllowQuotedNewlines()).encoding(loadConfigurationPb.getEncoding()).fieldDelimiter(loadConfigurationPb.getFieldDelimiter()).quote(loadConfigurationPb.getQuote()).skipLeadingRows(loadConfigurationPb.getSkipLeadingRows());
    this.formatOptions=builder.build();
  }
  this.maxBadRecords=loadConfigurationPb.getMaxBadRecords();
  if (loadConfigurationPb.getSchema() != null) {
    this.schema=Schema.fromPb(loadConfigurationPb.getSchema());
  }
  this.ignoreUnknownValues=loadConfigurationPb.getIgnoreUnknownValues();
  this.projectionFields=loadConfigurationPb.getProjectionFields();
  if (loadConfigurationPb.getSourceUris() != null) {
    this.sourceUris=ImmutableList.copyOf(configurationPb.getLoad().getSourceUris());
  }
}"
93142,"@Override protected ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",destinationTable).add(""String_Node_Str"",createDisposition).add(""String_Node_Str"",writeDisposition).add(""String_Node_Str"",formatOptions).add(""String_Node_Str"",maxBadRecords).add(""String_Node_Str"",schema).add(""String_Node_Str"",ignoreUnknownValues).add(""String_Node_Str"",projectionFields).add(""String_Node_Str"",sourceUris);
}","@Override ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",destinationTable).add(""String_Node_Str"",createDisposition).add(""String_Node_Str"",writeDisposition).add(""String_Node_Str"",formatOptions).add(""String_Node_Str"",maxBadRecords).add(""String_Node_Str"",schema).add(""String_Node_Str"",ignoreUnknownValues).add(""String_Node_Str"",projectionFields).add(""String_Node_Str"",sourceUris);
}"
93143,"private Builder(com.google.api.services.bigquery.model.JobConfiguration configurationPb){
  super(Type.QUERY);
  JobConfigurationQuery queryConfigurationPb=configurationPb.getQuery();
  this.query=queryConfigurationPb.getQuery();
  allowLargeResults=queryConfigurationPb.getAllowLargeResults();
  useQueryCache=queryConfigurationPb.getUseQueryCache();
  flattenResults=queryConfigurationPb.getFlattenResults();
  dryRun=configurationPb.getDryRun();
  if (queryConfigurationPb.getDestinationTable() != null) {
    destinationTable=TableId.fromPb(queryConfigurationPb.getDestinationTable());
  }
  if (queryConfigurationPb.getDefaultDataset() != null) {
    defaultDataset=DatasetId.fromPb(queryConfigurationPb.getDefaultDataset());
  }
  if (queryConfigurationPb.getPriority() != null) {
    priority=Priority.valueOf(queryConfigurationPb.getPriority());
  }
  if (queryConfigurationPb.getTableDefinitions() != null) {
    tableDefinitions=Maps.transformValues(queryConfigurationPb.getTableDefinitions(),ExternalDataConfiguration.FROM_PB_FUNCTION);
  }
  if (queryConfigurationPb.getUserDefinedFunctionResources() != null) {
    userDefinedFunctions=Lists.transform(queryConfigurationPb.getUserDefinedFunctionResources(),UserDefinedFunction.FROM_PB_FUNCTION);
  }
  if (queryConfigurationPb.getCreateDisposition() != null) {
    createDisposition=CreateDisposition.valueOf(queryConfigurationPb.getCreateDisposition());
  }
  if (queryConfigurationPb.getWriteDisposition() != null) {
    writeDisposition=WriteDisposition.valueOf(queryConfigurationPb.getWriteDisposition());
  }
}","private Builder(com.google.api.services.bigquery.model.JobConfiguration configurationPb){
  this();
  JobConfigurationQuery queryConfigurationPb=configurationPb.getQuery();
  this.query=queryConfigurationPb.getQuery();
  allowLargeResults=queryConfigurationPb.getAllowLargeResults();
  useQueryCache=queryConfigurationPb.getUseQueryCache();
  flattenResults=queryConfigurationPb.getFlattenResults();
  dryRun=configurationPb.getDryRun();
  if (queryConfigurationPb.getDestinationTable() != null) {
    destinationTable=TableId.fromPb(queryConfigurationPb.getDestinationTable());
  }
  if (queryConfigurationPb.getDefaultDataset() != null) {
    defaultDataset=DatasetId.fromPb(queryConfigurationPb.getDefaultDataset());
  }
  if (queryConfigurationPb.getPriority() != null) {
    priority=Priority.valueOf(queryConfigurationPb.getPriority());
  }
  if (queryConfigurationPb.getTableDefinitions() != null) {
    tableDefinitions=Maps.transformValues(queryConfigurationPb.getTableDefinitions(),ExternalDataConfiguration.FROM_PB_FUNCTION);
  }
  if (queryConfigurationPb.getUserDefinedFunctionResources() != null) {
    userDefinedFunctions=Lists.transform(queryConfigurationPb.getUserDefinedFunctionResources(),UserDefinedFunction.FROM_PB_FUNCTION);
  }
  if (queryConfigurationPb.getCreateDisposition() != null) {
    createDisposition=CreateDisposition.valueOf(queryConfigurationPb.getCreateDisposition());
  }
  if (queryConfigurationPb.getWriteDisposition() != null) {
    writeDisposition=WriteDisposition.valueOf(queryConfigurationPb.getWriteDisposition());
  }
}"
93144,"@Override protected ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",query).add(""String_Node_Str"",destinationTable).add(""String_Node_Str"",defaultDataset).add(""String_Node_Str"",allowLargeResults).add(""String_Node_Str"",flattenResults).add(""String_Node_Str"",priority).add(""String_Node_Str"",tableDefinitions).add(""String_Node_Str"",useQueryCache).add(""String_Node_Str"",userDefinedFunctions).add(""String_Node_Str"",createDisposition).add(""String_Node_Str"",writeDisposition).add(""String_Node_Str"",dryRun);
}","@Override ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",query).add(""String_Node_Str"",destinationTable).add(""String_Node_Str"",defaultDataset).add(""String_Node_Str"",allowLargeResults).add(""String_Node_Str"",flattenResults).add(""String_Node_Str"",priority).add(""String_Node_Str"",tableDefinitions).add(""String_Node_Str"",useQueryCache).add(""String_Node_Str"",userDefinedFunctions).add(""String_Node_Str"",createDisposition).add(""String_Node_Str"",writeDisposition).add(""String_Node_Str"",dryRun);
}"
93145,"protected Builder(com.google.api.services.bigquery.model.JobConfiguration configurationPb){
  JobConfigurationLoad loadConfigurationPb=configurationPb.getLoad();
  this.destinationTable=TableId.fromPb(loadConfigurationPb.getDestinationTable());
  if (loadConfigurationPb.getCreateDisposition() != null) {
    this.createDisposition=CreateDisposition.valueOf(loadConfigurationPb.getCreateDisposition());
  }
  if (loadConfigurationPb.getWriteDisposition() != null) {
    this.writeDisposition=WriteDisposition.valueOf(loadConfigurationPb.getWriteDisposition());
  }
  if (loadConfigurationPb.getSourceFormat() != null) {
    this.formatOptions=FormatOptions.of(loadConfigurationPb.getSourceFormat());
  }
  if (loadConfigurationPb.getAllowJaggedRows() != null || loadConfigurationPb.getAllowQuotedNewlines() != null || loadConfigurationPb.getEncoding() != null || loadConfigurationPb.getFieldDelimiter() != null || loadConfigurationPb.getQuote() != null || loadConfigurationPb.getSkipLeadingRows() != null) {
    CsvOptions.Builder builder=CsvOptions.builder().allowJaggedRows(loadConfigurationPb.getAllowJaggedRows()).allowQuotedNewLines(loadConfigurationPb.getAllowQuotedNewlines()).encoding(loadConfigurationPb.getEncoding()).fieldDelimiter(loadConfigurationPb.getFieldDelimiter()).quote(loadConfigurationPb.getQuote()).skipLeadingRows(loadConfigurationPb.getSkipLeadingRows());
    this.formatOptions=builder.build();
  }
  this.maxBadRecords=loadConfigurationPb.getMaxBadRecords();
  if (loadConfigurationPb.getSchema() != null) {
    this.schema=Schema.fromPb(loadConfigurationPb.getSchema());
  }
  this.ignoreUnknownValues=loadConfigurationPb.getIgnoreUnknownValues();
  this.projectionFields=loadConfigurationPb.getProjectionFields();
}","private Builder(com.google.api.services.bigquery.model.JobConfiguration configurationPb){
  JobConfigurationLoad loadConfigurationPb=configurationPb.getLoad();
  this.destinationTable=TableId.fromPb(loadConfigurationPb.getDestinationTable());
  if (loadConfigurationPb.getCreateDisposition() != null) {
    this.createDisposition=CreateDisposition.valueOf(loadConfigurationPb.getCreateDisposition());
  }
  if (loadConfigurationPb.getWriteDisposition() != null) {
    this.writeDisposition=WriteDisposition.valueOf(loadConfigurationPb.getWriteDisposition());
  }
  if (loadConfigurationPb.getSourceFormat() != null) {
    this.formatOptions=FormatOptions.of(loadConfigurationPb.getSourceFormat());
  }
  if (loadConfigurationPb.getAllowJaggedRows() != null || loadConfigurationPb.getAllowQuotedNewlines() != null || loadConfigurationPb.getEncoding() != null || loadConfigurationPb.getFieldDelimiter() != null || loadConfigurationPb.getQuote() != null || loadConfigurationPb.getSkipLeadingRows() != null) {
    CsvOptions.Builder builder=CsvOptions.builder().allowJaggedRows(loadConfigurationPb.getAllowJaggedRows()).allowQuotedNewLines(loadConfigurationPb.getAllowQuotedNewlines()).encoding(loadConfigurationPb.getEncoding()).fieldDelimiter(loadConfigurationPb.getFieldDelimiter()).quote(loadConfigurationPb.getQuote()).skipLeadingRows(loadConfigurationPb.getSkipLeadingRows());
    this.formatOptions=builder.build();
  }
  this.maxBadRecords=loadConfigurationPb.getMaxBadRecords();
  if (loadConfigurationPb.getSchema() != null) {
    this.schema=Schema.fromPb(loadConfigurationPb.getSchema());
  }
  this.ignoreUnknownValues=loadConfigurationPb.getIgnoreUnknownValues();
  this.projectionFields=loadConfigurationPb.getProjectionFields();
}"
93146,"@Test public void testSetProjectId(){
  CopyJobConfiguration copyConfiguration=COPY_JOB.setProjectId(""String_Node_Str"").configuration();
  assertEquals(""String_Node_Str"",copyConfiguration.destinationTable().project());
  for (  TableId sourceTable : copyConfiguration.sourceTables()) {
    assertEquals(""String_Node_Str"",sourceTable.project());
  }
  ExtractJobConfiguration extractConfiguration=EXTRACT_JOB.setProjectId(""String_Node_Str"").configuration();
  assertEquals(""String_Node_Str"",extractConfiguration.sourceTable().project());
  LoadConfiguration loadConfiguration=LOAD_JOB.setProjectId(""String_Node_Str"").configuration();
  assertEquals(""String_Node_Str"",loadConfiguration.destinationTable().project());
  QueryJobConfiguration queryConfiguration=QUERY_JOB.setProjectId(""String_Node_Str"").configuration();
  assertEquals(""String_Node_Str"",queryConfiguration.defaultDataset().project());
  assertEquals(""String_Node_Str"",queryConfiguration.destinationTable().project());
}","@Test public void testSetProjectId(){
  CopyJobConfiguration copyConfiguration=COPY_JOB.setProjectId(""String_Node_Str"").configuration();
  assertEquals(""String_Node_Str"",copyConfiguration.destinationTable().project());
  for (  TableId sourceTable : copyConfiguration.sourceTables()) {
    assertEquals(""String_Node_Str"",sourceTable.project());
  }
  ExtractJobConfiguration extractConfiguration=EXTRACT_JOB.setProjectId(""String_Node_Str"").configuration();
  assertEquals(""String_Node_Str"",extractConfiguration.sourceTable().project());
  LoadJobConfiguration loadConfiguration=LOAD_JOB.setProjectId(""String_Node_Str"").configuration();
  assertEquals(""String_Node_Str"",loadConfiguration.destinationTable().project());
  QueryJobConfiguration queryConfiguration=QUERY_JOB.setProjectId(""String_Node_Str"").configuration();
  assertEquals(""String_Node_Str"",queryConfiguration.defaultDataset().project());
  assertEquals(""String_Node_Str"",queryConfiguration.destinationTable().project());
}"
93147,"/** 
 * Create a   {@code Cursor} given its URL safe encoded form.
 */
public static Cursor fromUrlSafe(String urlSafe){
  try {
    String utf8Str=URLDecoder.decode(urlSafe,UTF_8.name());
    DatastoreV1.Value.Builder builder=DatastoreV1.Value.newBuilder();
    TextFormat.merge(utf8Str,builder);
    return fromPb(builder.build());
  }
 catch (  UnsupportedEncodingException|ParseException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}","/** 
 * Create a   {@code Cursor} given its URL safe encoded form.
 */
public static Cursor fromUrlSafe(String urlSafe){
  try {
    return Cursor.copyFrom(BaseEncoding.base64Url().decode(urlSafe));
  }
 catch (  IllegalArgumentException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}"
93148,"/** 
 * Returns the cursor in an encoded form that can be used as part of a URL.
 */
public String toUrlSafe(){
  try {
    return URLEncoder.encode(TextFormat.printToString(toPb()),UTF_8.name());
  }
 catch (  UnsupportedEncodingException e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}","/** 
 * Returns the cursor in an encoded form that can be used as part of a URL.
 */
public String toUrlSafe(){
  return BaseEncoding.base64Url().encode(byteString.toByteArray());
}"
93149,"@Override public Tuple<String,Iterable<Project>> list(Map<Option,?> options) throws ResourceManagerException {
  try {
    ListProjectsResponse response=resourceManager.projects().list().setFilter(FIELDS.getString(options)).setFilter(FILTER.getString(options)).setPageSize(PAGE_SIZE.getInt(options)).setPageToken(PAGE_TOKEN.getString(options)).execute();
    return Tuple.<String,Iterable<Project>>of(response.getNextPageToken(),response.getProjects());
  }
 catch (  IOException ex) {
    throw translate(ex);
  }
}","@Override public Tuple<String,Iterable<Project>> list(Map<Option,?> options) throws ResourceManagerException {
  try {
    ListProjectsResponse response=resourceManager.projects().list().setFields(FIELDS.getString(options)).setFilter(FILTER.getString(options)).setPageSize(PAGE_SIZE.getInt(options)).setPageToken(PAGE_TOKEN.getString(options)).execute();
    return Tuple.<String,Iterable<Project>>of(response.getNextPageToken(),response.getProjects());
  }
 catch (  IOException ex) {
    throw translate(ex);
  }
}"
93150,"@Override public Iterable<T> values(){
  return results == null ? Collections.EMPTY_LIST : results;
}","@SuppressWarnings(""String_Node_Str"") @Override public Iterable<T> values(){
  return results == null ? Collections.EMPTY_LIST : results;
}"
93151,"public ServiceRpcT rpc(){
  if (rpc == null) {
    rpc=serviceRpcFactory.create((OptionsT)this);
  }
  return rpc;
}","@SuppressWarnings(""String_Node_Str"") public ServiceRpcT rpc(){
  if (rpc == null) {
    rpc=serviceRpcFactory.create((OptionsT)this);
  }
  return rpc;
}"
93152,"private static <T>T newInstance(String className) throws IOException, ClassNotFoundException {
  try {
    return (T)Class.forName(className).newInstance();
  }
 catch (  InstantiationException|IllegalAccessException e) {
    throw new IOException(e);
  }
}","@SuppressWarnings(""String_Node_Str"") private static <T>T newInstance(String className) throws IOException, ClassNotFoundException {
  try {
    return (T)Class.forName(className).newInstance();
  }
 catch (  InstantiationException|IllegalAccessException e) {
    throw new IOException(e);
  }
}"
93153,"public ServiceT service(){
  if (service == null) {
    service=serviceFactory.create((OptionsT)this);
  }
  return service;
}","@SuppressWarnings(""String_Node_Str"") public ServiceT service(){
  if (service == null) {
    service=serviceFactory.create((OptionsT)this);
  }
  return service;
}"
93154,"@Override public Builder toBuilder(){
  return new Builder(this);
}","@SuppressWarnings(""String_Node_Str"") @Override public Builder toBuilder(){
  return new Builder(this);
}"
93155,"@Override protected DatastoreRpcFactory defaultRpcFactory(){
  return DefaultDatastoreRpcFactory.INSTANCE;
}","@SuppressWarnings(""String_Node_Str"") @Override protected DatastoreRpcFactory defaultRpcFactory(){
  return DefaultDatastoreRpcFactory.INSTANCE;
}"
93156,"@Override protected DatastoreFactory defaultServiceFactory(){
  return DefaultDatastoreFactory.INSTANCE;
}","@SuppressWarnings(""String_Node_Str"") @Override protected DatastoreFactory defaultServiceFactory(){
  return DefaultDatastoreFactory.INSTANCE;
}"
93157,"@Before public void setUp() throws IOException, InterruptedException {
  datastoreRpcFactory=EasyMock.createMock(DatastoreRpcFactory.class);
  datastoreRpc=EasyMock.createMock(DatastoreRpc.class);
  options=DatastoreOptions.builder().normalizeDataset(false).serviceRpcFactory(datastoreRpcFactory).projectId(PROJECT_ID).host(""String_Node_Str"" + PORT);
  EasyMock.expect(datastoreRpcFactory.create(EasyMock.anyObject(DatastoreOptions.class))).andReturn(datastoreRpc).anyTimes();
  EasyMock.replay(datastoreRpcFactory,datastoreRpc);
}","@Before public void setUp(){
  datastoreRpcFactory=EasyMock.createMock(DatastoreRpcFactory.class);
  datastoreRpc=EasyMock.createMock(DatastoreRpc.class);
  options=DatastoreOptions.builder().normalizeDataset(false).serviceRpcFactory(datastoreRpcFactory).projectId(PROJECT_ID).host(""String_Node_Str"" + PORT);
  EasyMock.expect(datastoreRpcFactory.create(EasyMock.anyObject(DatastoreOptions.class))).andReturn(datastoreRpc).anyTimes();
  EasyMock.replay(datastoreRpcFactory,datastoreRpc);
}"
93158,"@Before public void setUp() throws IOException, InterruptedException {
  options=DatastoreOptions.builder().projectId(PROJECT_ID).host(""String_Node_Str"" + PORT).build();
  datastore=options.service();
  StructuredQuery<Key> query=Query.keyQueryBuilder().build();
  QueryResults<Key> result=datastore.run(query);
  datastore.delete(Iterators.toArray(result,Key.class));
  datastore.add(ENTITY1,ENTITY2);
}","@Before public void setUp(){
  options=DatastoreOptions.builder().projectId(PROJECT_ID).host(""String_Node_Str"" + PORT).build();
  datastore=options.service();
  StructuredQuery<Key> query=Query.keyQueryBuilder().build();
  QueryResults<Key> result=datastore.run(query);
  datastore.delete(Iterators.toArray(result,Key.class));
  datastore.add(ENTITY1,ENTITY2);
}"
93159,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testToBuilder() throws Exception {
  Set<String> content=Collections.singleton(""String_Node_Str"");
  ValueBuilder builder=new TestBuilder();
  builder.meaning(1).set(content).indexed(true);
  Value<?> value=builder.build();
  builder=value.toBuilder();
  assertEquals(Integer.valueOf(1),value.meaning());
  assertTrue(value.hasIndexed());
  assertTrue(value.indexed());
  assertEquals(ValueType.LIST,value.type());
  assertEquals(content,value.get());
  assertEquals(value,builder.build());
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testToBuilder() throws Exception {
  Set<String> content=Collections.singleton(""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") ValueBuilder builder=new TestBuilder();
  builder.meaning(1).set(content).indexed(true);
  Value<?> value=builder.build();
  builder=value.toBuilder();
  assertEquals(Integer.valueOf(1),value.meaning());
  assertTrue(value.hasIndexed());
  assertTrue(value.indexed());
  assertEquals(ValueType.LIST,value.type());
  assertEquals(content,value.get());
  assertEquals(value,builder.build());
}"
93160,"@Override public Value<Set> build(){
  return new Value(this){
    @Override public TestBuilder toBuilder(){
      return new TestBuilder().mergeFrom(this);
    }
  }
;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public Value<Set> build(){
  return new Value(this){
    @Override public TestBuilder toBuilder(){
      return new TestBuilder().mergeFrom(this);
    }
  }
;
}"
93161,"@Override public Builder toBuilder(){
  return new Builder(this);
}","@SuppressWarnings(""String_Node_Str"") @Override public Builder toBuilder(){
  return new Builder(this);
}"
93162,"@Override protected StorageRpcFactory defaultRpcFactory(){
  return DefaultStorageRpcFactory.INSTANCE;
}","@SuppressWarnings(""String_Node_Str"") @Override protected StorageRpcFactory defaultRpcFactory(){
  return DefaultStorageRpcFactory.INSTANCE;
}"
93163,"@Override protected StorageFactory defaultServiceFactory(){
  return DefaultStorageFactory.INSTANCE;
}","@SuppressWarnings(""String_Node_Str"") @Override protected StorageFactory defaultServiceFactory(){
  return DefaultStorageFactory.INSTANCE;
}"
93164,"@Test public void testSaveAndRestore() throws IOException, ClassNotFoundException {
  byte[] firstResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  byte[] secondResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  ByteBuffer firstReadBuffer=ByteBuffer.allocate(42);
  ByteBuffer secondReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  expect(storageRpcMock.read(BLOB_ID.toPb(),EMPTY_RPC_OPTIONS,0,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",firstResult));
  expect(storageRpcMock.read(BLOB_ID.toPb(),EMPTY_RPC_OPTIONS,42,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",secondResult));
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  reader.read(firstReadBuffer);
  RestorableState<BlobReadChannel> readerState=reader.capture();
  BlobReadChannel restoredReader=readerState.restore();
  restoredReader.read(secondReadBuffer);
  assertArrayEquals(Arrays.copyOf(firstResult,firstReadBuffer.capacity()),firstReadBuffer.array());
  assertArrayEquals(secondResult,secondReadBuffer.array());
}","@Test public void testSaveAndRestore() throws IOException {
  byte[] firstResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  byte[] secondResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  ByteBuffer firstReadBuffer=ByteBuffer.allocate(42);
  ByteBuffer secondReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  expect(storageRpcMock.read(BLOB_ID.toPb(),EMPTY_RPC_OPTIONS,0,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",firstResult));
  expect(storageRpcMock.read(BLOB_ID.toPb(),EMPTY_RPC_OPTIONS,42,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",secondResult));
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  reader.read(firstReadBuffer);
  RestorableState<BlobReadChannel> readerState=reader.capture();
  BlobReadChannel restoredReader=readerState.restore();
  restoredReader.read(secondReadBuffer);
  assertArrayEquals(Arrays.copyOf(firstResult,firstReadBuffer.capacity()),firstReadBuffer.array());
  assertArrayEquals(secondResult,secondReadBuffer.array());
}"
93165,"@Test public void testStateEquals(){
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  BlobReadChannel secondReader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  RestorableState<BlobReadChannel> state=reader.capture();
  RestorableState<BlobReadChannel> secondState=secondReader.capture();
  assertEquals(state,secondState);
  assertEquals(state.hashCode(),secondState.hashCode());
  assertEquals(state.toString(),secondState.toString());
}","@Test public void testStateEquals(){
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  @SuppressWarnings(""String_Node_Str"") BlobReadChannel secondReader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  RestorableState<BlobReadChannel> state=reader.capture();
  RestorableState<BlobReadChannel> secondState=secondReader.capture();
  assertEquals(state,secondState);
  assertEquals(state.hashCode(),secondState.hashCode());
  assertEquals(state.toString(),secondState.toString());
}"
93166,"@Before public void setUp() throws IOException, InterruptedException {
  rpcFactoryMock=createMock(StorageRpcFactory.class);
  storageRpcMock=createMock(StorageRpc.class);
  expect(rpcFactoryMock.create(anyObject(StorageOptions.class))).andReturn(storageRpcMock);
  replay(rpcFactoryMock);
  options=StorageOptions.builder().projectId(""String_Node_Str"").serviceRpcFactory(rpcFactoryMock).build();
}","@Before public void setUp(){
  rpcFactoryMock=createMock(StorageRpcFactory.class);
  storageRpcMock=createMock(StorageRpc.class);
  expect(rpcFactoryMock.create(anyObject(StorageOptions.class))).andReturn(storageRpcMock);
  replay(rpcFactoryMock);
  options=StorageOptions.builder().projectId(""String_Node_Str"").serviceRpcFactory(rpcFactoryMock).build();
}"
93167,"@Test public void testReadGenerationChanged() throws IOException {
  BlobId blobId=BlobId.of(BUCKET_NAME,BLOB_NAME);
  reader=new BlobReadChannelImpl(options,blobId,EMPTY_RPC_OPTIONS);
  byte[] firstResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  byte[] secondResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  ByteBuffer firstReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  ByteBuffer secondReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  expect(storageRpcMock.read(blobId.toPb(),EMPTY_RPC_OPTIONS,0,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",firstResult));
  expect(storageRpcMock.read(blobId.toPb(),EMPTY_RPC_OPTIONS,DEFAULT_CHUNK_SIZE,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",firstResult));
  replay(storageRpcMock);
  reader.read(firstReadBuffer);
  try {
    reader.read(secondReadBuffer);
    fail(""String_Node_Str"");
  }
 catch (  StorageException ex) {
    StringBuilder messageBuilder=new StringBuilder();
    messageBuilder.append(""String_Node_Str"").append(blobId).append(""String_Node_Str"");
    assertEquals(messageBuilder.toString(),ex.getMessage());
  }
}","@Test public void testReadGenerationChanged() throws IOException {
  BlobId blobId=BlobId.of(BUCKET_NAME,BLOB_NAME);
  reader=new BlobReadChannelImpl(options,blobId,EMPTY_RPC_OPTIONS);
  byte[] firstResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  byte[] secondResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  ByteBuffer firstReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  ByteBuffer secondReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  expect(storageRpcMock.read(blobId.toPb(),EMPTY_RPC_OPTIONS,0,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",firstResult));
  expect(storageRpcMock.read(blobId.toPb(),EMPTY_RPC_OPTIONS,DEFAULT_CHUNK_SIZE,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",secondResult));
  replay(storageRpcMock);
  reader.read(firstReadBuffer);
  try {
    reader.read(secondReadBuffer);
    fail(""String_Node_Str"");
  }
 catch (  StorageException ex) {
    StringBuilder messageBuilder=new StringBuilder();
    messageBuilder.append(""String_Node_Str"").append(blobId).append(""String_Node_Str"");
    assertEquals(messageBuilder.toString(),ex.getMessage());
  }
}"
93168,"@Test public void testClose() throws IOException {
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  assertTrue(reader.isOpen());
  reader.close();
  assertTrue(!reader.isOpen());
}","@Test public void testClose(){
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  assertTrue(reader.isOpen());
  reader.close();
  assertTrue(!reader.isOpen());
}"
93169,"@Test public void testCopyToBlobId() throws Exception {
  BlobId targetId=BlobId.of(""String_Node_Str"",""String_Node_Str"");
  CopyWriter copyWriter=createMock(CopyWriter.class);
  BlobInfo target=BLOB_INFO.builder(targetId).build();
  Capture<CopyRequest> capturedCopyRequest=Capture.newInstance();
  expect(storage.copy(capture(capturedCopyRequest))).andReturn(copyWriter);
  replay(storage);
  CopyWriter returnedCopyWriter=blob.copyTo(targetId);
  assertEquals(copyWriter,returnedCopyWriter);
  assertEquals(capturedCopyRequest.getValue().source(),blob.id());
  assertEquals(capturedCopyRequest.getValue().target(),target);
  assertTrue(capturedCopyRequest.getValue().sourceOptions().isEmpty());
  assertTrue(capturedCopyRequest.getValue().targetOptions().isEmpty());
}","@Test public void testCopyToBlobId() throws Exception {
  BlobId targetId=BlobId.of(""String_Node_Str"",""String_Node_Str"");
  CopyWriter copyWriter=createMock(CopyWriter.class);
  BlobInfo target=BlobInfo.builder(targetId).build();
  Capture<CopyRequest> capturedCopyRequest=Capture.newInstance();
  expect(storage.copy(capture(capturedCopyRequest))).andReturn(copyWriter);
  replay(storage);
  CopyWriter returnedCopyWriter=blob.copyTo(targetId);
  assertEquals(copyWriter,returnedCopyWriter);
  assertEquals(capturedCopyRequest.getValue().source(),blob.id());
  assertEquals(capturedCopyRequest.getValue().target(),target);
  assertTrue(capturedCopyRequest.getValue().sourceOptions().isEmpty());
  assertTrue(capturedCopyRequest.getValue().targetOptions().isEmpty());
}"
93170,"@Test public void testStateEquals(){
  expect(storageRpcMock.open(BLOB_INFO.toPb(),EMPTY_RPC_OPTIONS)).andReturn(UPLOAD_ID).times(2);
  replay(storageRpcMock);
  writer=new BlobWriteChannelImpl(options,BLOB_INFO,EMPTY_RPC_OPTIONS);
  BlobWriteChannel writer2=new BlobWriteChannelImpl(options,BLOB_INFO,EMPTY_RPC_OPTIONS);
  RestorableState<BlobWriteChannel> state=writer.capture();
  RestorableState<BlobWriteChannel> state2=writer2.capture();
  assertEquals(state,state2);
  assertEquals(state.hashCode(),state2.hashCode());
  assertEquals(state.toString(),state2.toString());
}","@Test public void testStateEquals(){
  expect(storageRpcMock.open(BLOB_INFO.toPb(),EMPTY_RPC_OPTIONS)).andReturn(UPLOAD_ID).times(2);
  replay(storageRpcMock);
  writer=new BlobWriteChannelImpl(options,BLOB_INFO,EMPTY_RPC_OPTIONS);
  @SuppressWarnings(""String_Node_Str"") BlobWriteChannel writer2=new BlobWriteChannelImpl(options,BLOB_INFO,EMPTY_RPC_OPTIONS);
  RestorableState<BlobWriteChannel> state=writer.capture();
  RestorableState<BlobWriteChannel> state2=writer2.capture();
  assertEquals(state,state2);
  assertEquals(state.hashCode(),state2.hashCode());
  assertEquals(state.toString(),state2.toString());
}"
93171,"@Before public void setUp() throws IOException, InterruptedException {
  rpcFactoryMock=createMock(StorageRpcFactory.class);
  storageRpcMock=createMock(StorageRpc.class);
  expect(rpcFactoryMock.create(anyObject(StorageOptions.class))).andReturn(storageRpcMock);
  replay(rpcFactoryMock);
  options=StorageOptions.builder().projectId(""String_Node_Str"").serviceRpcFactory(rpcFactoryMock).build();
}","@Before public void setUp(){
  rpcFactoryMock=createMock(StorageRpcFactory.class);
  storageRpcMock=createMock(StorageRpc.class);
  expect(rpcFactoryMock.create(anyObject(StorageOptions.class))).andReturn(storageRpcMock);
  replay(rpcFactoryMock);
  options=StorageOptions.builder().projectId(""String_Node_Str"").serviceRpcFactory(rpcFactoryMock).build();
}"
93172,"@Test public void testGetAll() throws Exception {
  Capture<BatchRequest> capturedBatchRequest=Capture.newInstance();
  List<Result<BlobInfo>> batchResultList=new LinkedList<>();
  for (  BlobInfo info : BLOB_INFO_RESULTS) {
    batchResultList.add(new Result<>(info));
  }
  BatchResponse response=new BatchResponse(Collections.EMPTY_LIST,Collections.EMPTY_LIST,batchResultList);
  expect(storage.apply(capture(capturedBatchRequest))).andReturn(response);
  replay(storage);
  List<Blob> blobs=bucket.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Set<BlobId> blobInfoSet=capturedBatchRequest.getValue().toGet().keySet();
  assertEquals(batchResultList.size(),blobInfoSet.size());
  for (  BlobInfo info : BLOB_INFO_RESULTS) {
    assertTrue(blobInfoSet.contains(info.blobId()));
  }
  Iterator<Blob> blobIterator=blobs.iterator();
  Iterator<Result<BlobInfo>> batchResultIterator=response.gets().iterator();
  while (batchResultIterator.hasNext() && blobIterator.hasNext()) {
    assertEquals(batchResultIterator.next().get(),blobIterator.next().info());
  }
  assertFalse(batchResultIterator.hasNext());
  assertFalse(blobIterator.hasNext());
}","@Test public void testGetAll() throws Exception {
  Capture<BatchRequest> capturedBatchRequest=Capture.newInstance();
  List<Result<BlobInfo>> batchResultList=new LinkedList<>();
  for (  BlobInfo info : BLOB_INFO_RESULTS) {
    batchResultList.add(new Result<>(info));
  }
  BatchResponse response=new BatchResponse(Collections.<Result<Boolean>>emptyList(),Collections.<Result<BlobInfo>>emptyList(),batchResultList);
  expect(storage.apply(capture(capturedBatchRequest))).andReturn(response);
  replay(storage);
  List<Blob> blobs=bucket.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Set<BlobId> blobInfoSet=capturedBatchRequest.getValue().toGet().keySet();
  assertEquals(batchResultList.size(),blobInfoSet.size());
  for (  BlobInfo info : BLOB_INFO_RESULTS) {
    assertTrue(blobInfoSet.contains(info.blobId()));
  }
  Iterator<Blob> blobIterator=blobs.iterator();
  Iterator<Result<BlobInfo>> batchResultIterator=response.gets().iterator();
  while (batchResultIterator.hasNext() && blobIterator.hasNext()) {
    assertEquals(batchResultIterator.next().get(),blobIterator.next().info());
  }
  assertFalse(batchResultIterator.hasNext());
  assertFalse(blobIterator.hasNext());
}"
93173,"protected MoreObjects.ToStringHelper toStringHelper(){
  return MoreObjects.toStringHelper(this).add(""String_Node_Str"",tableId).add(""String_Node_Str"",type).add(""String_Node_Str"",schema).add(""String_Node_Str"",etag).add(""String_Node_Str"",id).add(""String_Node_Str"",selfLink).add(""String_Node_Str"",friendlyName).add(""String_Node_Str"",description).add(""String_Node_Str"",numBytes).add(""String_Node_Str"",numRows).add(""String_Node_Str"",expirationTime).add(""String_Node_Str"",creationTime).add(""String_Node_Str"",lastModifiedTime);
}","ToStringHelper toStringHelper(){
  return MoreObjects.toStringHelper(this).add(""String_Node_Str"",tableId).add(""String_Node_Str"",type).add(""String_Node_Str"",schema).add(""String_Node_Str"",etag).add(""String_Node_Str"",id).add(""String_Node_Str"",selfLink).add(""String_Node_Str"",friendlyName).add(""String_Node_Str"",description).add(""String_Node_Str"",numBytes).add(""String_Node_Str"",numRows).add(""String_Node_Str"",expirationTime).add(""String_Node_Str"",creationTime).add(""String_Node_Str"",lastModifiedTime);
}"
93174,"public Builder toBuilder(){
  return new Builder().allowJaggedRows(allowJaggedRows).allowQuotedNewLines(allowQuotedNewLines).encoding(encoding).fieldDelimiter(fieldDelimiter).quote(quote).skipLeadingRows(skipLeadingRows);
}","/** 
 * Returns a builder for the   {@code CsvOptions} object.
 */
public Builder toBuilder(){
  return new Builder().allowJaggedRows(allowJaggedRows).allowQuotedNewLines(allowQuotedNewLines).encoding(encoding).fieldDelimiter(fieldDelimiter).quote(quote).skipLeadingRows(skipLeadingRows);
}"
93175,"public static DatasetId fromPb(DatasetReference datasetRef){
  return new DatasetId(datasetRef.getProjectId(),datasetRef.getDatasetId());
}","static DatasetId fromPb(DatasetReference datasetRef){
  return new DatasetId(datasetRef.getProjectId(),datasetRef.getDatasetId());
}"
93176,"/** 
 * Returns project's user-defined id
 */
public String project(){
  return project;
}","/** 
 * Returns project's user-defined id.
 */
public String project(){
  return project;
}"
93177,"public DatasetReference toPb(){
  return new DatasetReference().setProjectId(project).setDatasetId(dataset);
}","DatasetReference toPb(){
  return new DatasetReference().setProjectId(project).setDatasetId(dataset);
}"
93178,"@Override public Acl apply(Dataset.Access f){
  return Acl.fromPb(f);
}","@Override public Acl apply(Dataset.Access accessPb){
  return Acl.fromPb(accessPb);
}"
93179,"static DatasetInfo fromPb(Dataset datasetPb){
  Builder builder=builder(datasetPb.getDatasetReference().getProjectId(),datasetPb.getDatasetReference().getDatasetId());
  if (datasetPb.getAccess() != null) {
    builder.acl(Lists.transform(datasetPb.getAccess(),new Function<Dataset.Access,Acl>(){
      @Override public Acl apply(      Dataset.Access f){
        return Acl.fromPb(f);
      }
    }
));
  }
  if (datasetPb.getCreationTime() != null) {
    builder.creationTime(datasetPb.getCreationTime());
  }
  if (datasetPb.getDefaultTableExpirationMs() != null) {
    builder.defaultTableLifetime(datasetPb.getDefaultTableExpirationMs());
  }
  if (datasetPb.getDescription() != null) {
    builder.description(datasetPb.getDescription());
  }
  if (datasetPb.getEtag() != null) {
    builder.etag(datasetPb.getEtag());
  }
  if (datasetPb.getFriendlyName() != null) {
    builder.friendlyName(datasetPb.getFriendlyName());
  }
  if (datasetPb.getId() != null) {
    builder.id(datasetPb.getId());
  }
  if (datasetPb.getLastModifiedTime() != null) {
    builder.lastModified(datasetPb.getLastModifiedTime());
  }
  if (datasetPb.getLocation() != null) {
    builder.location(datasetPb.getLocation());
  }
  if (datasetPb.getSelfLink() != null) {
    builder.selfLink(datasetPb.getSelfLink());
  }
  return builder.build();
}","static DatasetInfo fromPb(Dataset datasetPb){
  Builder builder=builder(datasetPb.getDatasetReference().getProjectId(),datasetPb.getDatasetReference().getDatasetId());
  if (datasetPb.getAccess() != null) {
    builder.acl(Lists.transform(datasetPb.getAccess(),new Function<Dataset.Access,Acl>(){
      @Override public Acl apply(      Dataset.Access accessPb){
        return Acl.fromPb(accessPb);
      }
    }
));
  }
  if (datasetPb.getCreationTime() != null) {
    builder.creationTime(datasetPb.getCreationTime());
  }
  if (datasetPb.getDefaultTableExpirationMs() != null) {
    builder.defaultTableLifetime(datasetPb.getDefaultTableExpirationMs());
  }
  if (datasetPb.getDescription() != null) {
    builder.description(datasetPb.getDescription());
  }
  if (datasetPb.getEtag() != null) {
    builder.etag(datasetPb.getEtag());
  }
  if (datasetPb.getFriendlyName() != null) {
    builder.friendlyName(datasetPb.getFriendlyName());
  }
  if (datasetPb.getId() != null) {
    builder.id(datasetPb.getId());
  }
  if (datasetPb.getLastModifiedTime() != null) {
    builder.lastModified(datasetPb.getLastModifiedTime());
  }
  if (datasetPb.getLocation() != null) {
    builder.location(datasetPb.getLocation());
  }
  if (datasetPb.getSelfLink() != null) {
    builder.selfLink(datasetPb.getSelfLink());
  }
  return builder.build();
}"
93180,"@Override protected MoreObjects.ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",configuration).add(""String_Node_Str"",streamingBuffer);
}","@Override ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",configuration).add(""String_Node_Str"",streamingBuffer);
}"
93181,"private JobId(String project,String dataset){
  this.project=project;
  this.job=dataset;
}","private JobId(String project,String job){
  this.project=project;
  this.job=job;
}"
93182,"/** 
 * Returns project's user-defined id
 */
public String project(){
  return project;
}","/** 
 * Returns project's user-defined id.
 */
public String project(){
  return project;
}"
93183,"/** 
 * Creates BigQuery table given its type
 * @param tableId table id
 * @param schema the schema of the table
 */
public static BaseTableInfo of(TableId tableId,Schema schema){
  return builder(tableId,schema).build();
}","/** 
 * Creates BigQuery table given its type.
 * @param tableId table id
 * @param schema the schema of the table
 */
public static BaseTableInfo of(TableId tableId,Schema schema){
  return builder(tableId,schema).build();
}"
93184,"@Override protected MoreObjects.ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",location).add(""String_Node_Str"",streamingBuffer);
}","@Override ToStringHelper toStringHelper(){
  return super.toStringHelper().add(""String_Node_Str"",location).add(""String_Node_Str"",streamingBuffer);
}"
93185,"public static UserDefinedFunction fromPb(com.google.api.services.bigquery.model.UserDefinedFunctionResource pb){
  if (pb.getInlineCode() != null) {
    return new InlineFunction(pb.getInlineCode());
  }
  if (pb.getResourceUri() != null) {
    return new UriFunction(pb.getResourceUri());
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","static UserDefinedFunction fromPb(com.google.api.services.bigquery.model.UserDefinedFunctionResource pb){
  if (pb.getInlineCode() != null) {
    return new InlineFunction(pb.getInlineCode());
  }
  if (pb.getResourceUri() != null) {
    return new UriFunction(pb.getResourceUri());
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}"
93186,"@Override public Iterable<T> values(){
  return results == null ? Collections.EMPTY_LIST : results;
}","@Override public Iterable<T> values(){
  return results == null ? Collections.<T>emptyList() : results;
}"
93187,"public ServiceRpcT rpc(){
  if (rpc == null) {
    rpc=serviceRpcFactory.create((OptionsT)this);
  }
  return rpc;
}","@SuppressWarnings(""String_Node_Str"") public ServiceRpcT rpc(){
  if (rpc == null) {
    rpc=serviceRpcFactory.create((OptionsT)this);
  }
  return rpc;
}"
93188,"private static <T>T newInstance(String className) throws IOException, ClassNotFoundException {
  try {
    return (T)Class.forName(className).newInstance();
  }
 catch (  InstantiationException|IllegalAccessException e) {
    throw new IOException(e);
  }
}","@SuppressWarnings(""String_Node_Str"") private static <T>T newInstance(String className) throws IOException, ClassNotFoundException {
  try {
    return (T)Class.forName(className).newInstance();
  }
 catch (  InstantiationException|IllegalAccessException e) {
    throw new IOException(e);
  }
}"
93189,"public ServiceT service(){
  if (service == null) {
    service=serviceFactory.create((OptionsT)this);
  }
  return service;
}","@SuppressWarnings(""String_Node_Str"") public ServiceT service(){
  if (service == null) {
    service=serviceFactory.create((OptionsT)this);
  }
  return service;
}"
93190,"@Override public Builder toBuilder(){
  return new Builder(this);
}","@SuppressWarnings(""String_Node_Str"") @Override public Builder toBuilder(){
  return new Builder(this);
}"
93191,"@Override protected DatastoreRpcFactory defaultRpcFactory(){
  return DefaultDatastoreRpcFactory.INSTANCE;
}","@SuppressWarnings(""String_Node_Str"") @Override protected DatastoreRpcFactory defaultRpcFactory(){
  return DefaultDatastoreRpcFactory.INSTANCE;
}"
93192,"@Override protected DatastoreFactory defaultServiceFactory(){
  return DefaultDatastoreFactory.INSTANCE;
}","@SuppressWarnings(""String_Node_Str"") @Override protected DatastoreFactory defaultServiceFactory(){
  return DefaultDatastoreFactory.INSTANCE;
}"
93193,"@Before public void setUp() throws IOException, InterruptedException {
  datastoreRpcFactory=EasyMock.createMock(DatastoreRpcFactory.class);
  datastoreRpc=EasyMock.createMock(DatastoreRpc.class);
  options=DatastoreOptions.builder().normalizeDataset(false).serviceRpcFactory(datastoreRpcFactory).projectId(PROJECT_ID).host(""String_Node_Str"" + PORT);
  EasyMock.expect(datastoreRpcFactory.create(EasyMock.anyObject(DatastoreOptions.class))).andReturn(datastoreRpc).anyTimes();
  EasyMock.replay(datastoreRpcFactory,datastoreRpc);
}","@Before public void setUp(){
  datastoreRpcFactory=EasyMock.createMock(DatastoreRpcFactory.class);
  datastoreRpc=EasyMock.createMock(DatastoreRpc.class);
  options=DatastoreOptions.builder().normalizeDataset(false).serviceRpcFactory(datastoreRpcFactory).projectId(PROJECT_ID).host(""String_Node_Str"" + PORT);
  EasyMock.expect(datastoreRpcFactory.create(EasyMock.anyObject(DatastoreOptions.class))).andReturn(datastoreRpc).anyTimes();
  EasyMock.replay(datastoreRpcFactory,datastoreRpc);
}"
93194,"@Before public void setUp() throws IOException, InterruptedException {
  options=DatastoreOptions.builder().projectId(PROJECT_ID).host(""String_Node_Str"" + PORT).build();
  datastore=options.service();
  StructuredQuery<Key> query=Query.keyQueryBuilder().build();
  QueryResults<Key> result=datastore.run(query);
  datastore.delete(Iterators.toArray(result,Key.class));
  datastore.add(ENTITY1,ENTITY2);
}","@Before public void setUp(){
  options=DatastoreOptions.builder().projectId(PROJECT_ID).host(""String_Node_Str"" + PORT).build();
  datastore=options.service();
  StructuredQuery<Key> query=Query.keyQueryBuilder().build();
  QueryResults<Key> result=datastore.run(query);
  datastore.delete(Iterators.toArray(result,Key.class));
  datastore.add(ENTITY1,ENTITY2);
}"
93195,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testToBuilder() throws Exception {
  Set<String> content=Collections.singleton(""String_Node_Str"");
  ValueBuilder builder=new TestBuilder();
  builder.meaning(1).set(content).indexed(true);
  Value<?> value=builder.build();
  builder=value.toBuilder();
  assertEquals(Integer.valueOf(1),value.meaning());
  assertTrue(value.hasIndexed());
  assertTrue(value.indexed());
  assertEquals(ValueType.LIST,value.type());
  assertEquals(content,value.get());
  assertEquals(value,builder.build());
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testToBuilder() throws Exception {
  Set<String> content=Collections.singleton(""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") ValueBuilder builder=new TestBuilder();
  builder.meaning(1).set(content).indexed(true);
  Value<?> value=builder.build();
  builder=value.toBuilder();
  assertEquals(Integer.valueOf(1),value.meaning());
  assertTrue(value.hasIndexed());
  assertTrue(value.indexed());
  assertEquals(ValueType.LIST,value.type());
  assertEquals(content,value.get());
  assertEquals(value,builder.build());
}"
93196,"@Override public Value<Set> build(){
  return new Value(this){
    @Override public TestBuilder toBuilder(){
      return new TestBuilder().mergeFrom(this);
    }
  }
;
}","@SuppressWarnings({""String_Node_Str""}) @Override public Value<Set> build(){
  return new Value(this){
    @Override public TestBuilder toBuilder(){
      return new TestBuilder().mergeFrom(this);
    }
  }
;
}"
93197,"@Override public Builder toBuilder(){
  return new Builder(this);
}","@SuppressWarnings(""String_Node_Str"") @Override public Builder toBuilder(){
  return new Builder(this);
}"
93198,"@Override protected StorageRpcFactory defaultRpcFactory(){
  return DefaultStorageRpcFactory.INSTANCE;
}","@SuppressWarnings(""String_Node_Str"") @Override protected StorageRpcFactory defaultRpcFactory(){
  return DefaultStorageRpcFactory.INSTANCE;
}"
93199,"@Override protected StorageFactory defaultServiceFactory(){
  return DefaultStorageFactory.INSTANCE;
}","@SuppressWarnings(""String_Node_Str"") @Override protected StorageFactory defaultServiceFactory(){
  return DefaultStorageFactory.INSTANCE;
}"
93200,"@Test public void testSaveAndRestore() throws IOException, ClassNotFoundException {
  byte[] firstResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  byte[] secondResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  ByteBuffer firstReadBuffer=ByteBuffer.allocate(42);
  ByteBuffer secondReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  expect(storageRpcMock.read(BLOB_ID.toPb(),EMPTY_RPC_OPTIONS,0,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",firstResult));
  expect(storageRpcMock.read(BLOB_ID.toPb(),EMPTY_RPC_OPTIONS,42,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",secondResult));
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  reader.read(firstReadBuffer);
  RestorableState<BlobReadChannel> readerState=reader.capture();
  BlobReadChannel restoredReader=readerState.restore();
  restoredReader.read(secondReadBuffer);
  assertArrayEquals(Arrays.copyOf(firstResult,firstReadBuffer.capacity()),firstReadBuffer.array());
  assertArrayEquals(secondResult,secondReadBuffer.array());
}","@Test public void testSaveAndRestore() throws IOException {
  byte[] firstResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  byte[] secondResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  ByteBuffer firstReadBuffer=ByteBuffer.allocate(42);
  ByteBuffer secondReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  expect(storageRpcMock.read(BLOB_ID.toPb(),EMPTY_RPC_OPTIONS,0,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",firstResult));
  expect(storageRpcMock.read(BLOB_ID.toPb(),EMPTY_RPC_OPTIONS,42,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",secondResult));
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  reader.read(firstReadBuffer);
  RestorableState<BlobReadChannel> readerState=reader.capture();
  BlobReadChannel restoredReader=readerState.restore();
  restoredReader.read(secondReadBuffer);
  assertArrayEquals(Arrays.copyOf(firstResult,firstReadBuffer.capacity()),firstReadBuffer.array());
  assertArrayEquals(secondResult,secondReadBuffer.array());
}"
93201,"@Test public void testStateEquals(){
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  BlobReadChannel secondReader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  RestorableState<BlobReadChannel> state=reader.capture();
  RestorableState<BlobReadChannel> secondState=secondReader.capture();
  assertEquals(state,secondState);
  assertEquals(state.hashCode(),secondState.hashCode());
  assertEquals(state.toString(),secondState.toString());
}","@Test public void testStateEquals(){
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  @SuppressWarnings(""String_Node_Str"") BlobReadChannel secondReader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  RestorableState<BlobReadChannel> state=reader.capture();
  RestorableState<BlobReadChannel> secondState=secondReader.capture();
  assertEquals(state,secondState);
  assertEquals(state.hashCode(),secondState.hashCode());
  assertEquals(state.toString(),secondState.toString());
}"
93202,"@Before public void setUp() throws IOException, InterruptedException {
  rpcFactoryMock=createMock(StorageRpcFactory.class);
  storageRpcMock=createMock(StorageRpc.class);
  expect(rpcFactoryMock.create(anyObject(StorageOptions.class))).andReturn(storageRpcMock);
  replay(rpcFactoryMock);
  options=StorageOptions.builder().projectId(""String_Node_Str"").serviceRpcFactory(rpcFactoryMock).build();
}","@Before public void setUp(){
  rpcFactoryMock=createMock(StorageRpcFactory.class);
  storageRpcMock=createMock(StorageRpc.class);
  expect(rpcFactoryMock.create(anyObject(StorageOptions.class))).andReturn(storageRpcMock);
  replay(rpcFactoryMock);
  options=StorageOptions.builder().projectId(""String_Node_Str"").serviceRpcFactory(rpcFactoryMock).build();
}"
93203,"@Test public void testReadGenerationChanged() throws IOException {
  BlobId blobId=BlobId.of(BUCKET_NAME,BLOB_NAME);
  reader=new BlobReadChannelImpl(options,blobId,EMPTY_RPC_OPTIONS);
  byte[] firstResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  byte[] secondResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  ByteBuffer firstReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  ByteBuffer secondReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  expect(storageRpcMock.read(blobId.toPb(),EMPTY_RPC_OPTIONS,0,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",firstResult));
  expect(storageRpcMock.read(blobId.toPb(),EMPTY_RPC_OPTIONS,DEFAULT_CHUNK_SIZE,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",firstResult));
  replay(storageRpcMock);
  reader.read(firstReadBuffer);
  try {
    reader.read(secondReadBuffer);
    fail(""String_Node_Str"");
  }
 catch (  StorageException ex) {
    StringBuilder messageBuilder=new StringBuilder();
    messageBuilder.append(""String_Node_Str"").append(blobId).append(""String_Node_Str"");
    assertEquals(messageBuilder.toString(),ex.getMessage());
  }
}","@Test public void testReadGenerationChanged() throws IOException {
  BlobId blobId=BlobId.of(BUCKET_NAME,BLOB_NAME);
  reader=new BlobReadChannelImpl(options,blobId,EMPTY_RPC_OPTIONS);
  byte[] firstResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  byte[] secondResult=randomByteArray(DEFAULT_CHUNK_SIZE);
  ByteBuffer firstReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  ByteBuffer secondReadBuffer=ByteBuffer.allocate(DEFAULT_CHUNK_SIZE);
  expect(storageRpcMock.read(blobId.toPb(),EMPTY_RPC_OPTIONS,0,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",firstResult));
  expect(storageRpcMock.read(blobId.toPb(),EMPTY_RPC_OPTIONS,DEFAULT_CHUNK_SIZE,DEFAULT_CHUNK_SIZE)).andReturn(StorageRpc.Tuple.of(""String_Node_Str"",secondResult));
  replay(storageRpcMock);
  reader.read(firstReadBuffer);
  try {
    reader.read(secondReadBuffer);
    fail(""String_Node_Str"");
  }
 catch (  StorageException ex) {
    StringBuilder messageBuilder=new StringBuilder();
    messageBuilder.append(""String_Node_Str"").append(blobId).append(""String_Node_Str"");
    assertEquals(messageBuilder.toString(),ex.getMessage());
  }
}"
93204,"@Test public void testClose() throws IOException {
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  assertTrue(reader.isOpen());
  reader.close();
  assertTrue(!reader.isOpen());
}","@Test public void testClose(){
  replay(storageRpcMock);
  reader=new BlobReadChannelImpl(options,BLOB_ID,EMPTY_RPC_OPTIONS);
  assertTrue(reader.isOpen());
  reader.close();
  assertTrue(!reader.isOpen());
}"
93205,"@Test public void testCopyToBlobId() throws Exception {
  BlobId targetId=BlobId.of(""String_Node_Str"",""String_Node_Str"");
  CopyWriter copyWriter=createMock(CopyWriter.class);
  BlobInfo target=BLOB_INFO.builder(targetId).build();
  Capture<CopyRequest> capturedCopyRequest=Capture.newInstance();
  expect(storage.copy(capture(capturedCopyRequest))).andReturn(copyWriter);
  replay(storage);
  CopyWriter returnedCopyWriter=blob.copyTo(targetId);
  assertEquals(copyWriter,returnedCopyWriter);
  assertEquals(capturedCopyRequest.getValue().source(),blob.id());
  assertEquals(capturedCopyRequest.getValue().target(),target);
  assertTrue(capturedCopyRequest.getValue().sourceOptions().isEmpty());
  assertTrue(capturedCopyRequest.getValue().targetOptions().isEmpty());
}","@Test public void testCopyToBlobId() throws Exception {
  BlobId targetId=BlobId.of(""String_Node_Str"",""String_Node_Str"");
  CopyWriter copyWriter=createMock(CopyWriter.class);
  BlobInfo target=BlobInfo.builder(targetId).build();
  Capture<CopyRequest> capturedCopyRequest=Capture.newInstance();
  expect(storage.copy(capture(capturedCopyRequest))).andReturn(copyWriter);
  replay(storage);
  CopyWriter returnedCopyWriter=blob.copyTo(targetId);
  assertEquals(copyWriter,returnedCopyWriter);
  assertEquals(capturedCopyRequest.getValue().source(),blob.id());
  assertEquals(capturedCopyRequest.getValue().target(),target);
  assertTrue(capturedCopyRequest.getValue().sourceOptions().isEmpty());
  assertTrue(capturedCopyRequest.getValue().targetOptions().isEmpty());
}"
93206,"@Test public void testStateEquals(){
  expect(storageRpcMock.open(BLOB_INFO.toPb(),EMPTY_RPC_OPTIONS)).andReturn(UPLOAD_ID).times(2);
  replay(storageRpcMock);
  writer=new BlobWriteChannelImpl(options,BLOB_INFO,EMPTY_RPC_OPTIONS);
  BlobWriteChannel writer2=new BlobWriteChannelImpl(options,BLOB_INFO,EMPTY_RPC_OPTIONS);
  RestorableState<BlobWriteChannel> state=writer.capture();
  RestorableState<BlobWriteChannel> state2=writer2.capture();
  assertEquals(state,state2);
  assertEquals(state.hashCode(),state2.hashCode());
  assertEquals(state.toString(),state2.toString());
}","@Test public void testStateEquals(){
  expect(storageRpcMock.open(BLOB_INFO.toPb(),EMPTY_RPC_OPTIONS)).andReturn(UPLOAD_ID).times(2);
  replay(storageRpcMock);
  writer=new BlobWriteChannelImpl(options,BLOB_INFO,EMPTY_RPC_OPTIONS);
  @SuppressWarnings(""String_Node_Str"") BlobWriteChannel writer2=new BlobWriteChannelImpl(options,BLOB_INFO,EMPTY_RPC_OPTIONS);
  RestorableState<BlobWriteChannel> state=writer.capture();
  RestorableState<BlobWriteChannel> state2=writer2.capture();
  assertEquals(state,state2);
  assertEquals(state.hashCode(),state2.hashCode());
  assertEquals(state.toString(),state2.toString());
}"
93207,"@Before public void setUp() throws IOException, InterruptedException {
  rpcFactoryMock=createMock(StorageRpcFactory.class);
  storageRpcMock=createMock(StorageRpc.class);
  expect(rpcFactoryMock.create(anyObject(StorageOptions.class))).andReturn(storageRpcMock);
  replay(rpcFactoryMock);
  options=StorageOptions.builder().projectId(""String_Node_Str"").serviceRpcFactory(rpcFactoryMock).build();
}","@Before public void setUp(){
  rpcFactoryMock=createMock(StorageRpcFactory.class);
  storageRpcMock=createMock(StorageRpc.class);
  expect(rpcFactoryMock.create(anyObject(StorageOptions.class))).andReturn(storageRpcMock);
  replay(rpcFactoryMock);
  options=StorageOptions.builder().projectId(""String_Node_Str"").serviceRpcFactory(rpcFactoryMock).build();
}"
93208,"@Test public void testGetAll() throws Exception {
  Capture<BatchRequest> capturedBatchRequest=Capture.newInstance();
  List<Result<BlobInfo>> batchResultList=new LinkedList<>();
  for (  BlobInfo info : BLOB_INFO_RESULTS) {
    batchResultList.add(new Result<>(info));
  }
  BatchResponse response=new BatchResponse(Collections.EMPTY_LIST,Collections.EMPTY_LIST,batchResultList);
  expect(storage.apply(capture(capturedBatchRequest))).andReturn(response);
  replay(storage);
  List<Blob> blobs=bucket.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Set<BlobId> blobInfoSet=capturedBatchRequest.getValue().toGet().keySet();
  assertEquals(batchResultList.size(),blobInfoSet.size());
  for (  BlobInfo info : BLOB_INFO_RESULTS) {
    assertTrue(blobInfoSet.contains(info.blobId()));
  }
  Iterator<Blob> blobIterator=blobs.iterator();
  Iterator<Result<BlobInfo>> batchResultIterator=response.gets().iterator();
  while (batchResultIterator.hasNext() && blobIterator.hasNext()) {
    assertEquals(batchResultIterator.next().get(),blobIterator.next().info());
  }
  assertFalse(batchResultIterator.hasNext());
  assertFalse(blobIterator.hasNext());
}","@Test public void testGetAll() throws Exception {
  Capture<BatchRequest> capturedBatchRequest=Capture.newInstance();
  List<Result<BlobInfo>> batchResultList=new LinkedList<>();
  for (  BlobInfo info : BLOB_INFO_RESULTS) {
    batchResultList.add(new Result<>(info));
  }
  BatchResponse response=new BatchResponse(Collections.<Result<Boolean>>emptyList(),Collections.<Result<BlobInfo>>emptyList(),batchResultList);
  expect(storage.apply(capture(capturedBatchRequest))).andReturn(response);
  replay(storage);
  List<Blob> blobs=bucket.get(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Set<BlobId> blobInfoSet=capturedBatchRequest.getValue().toGet().keySet();
  assertEquals(batchResultList.size(),blobInfoSet.size());
  for (  BlobInfo info : BLOB_INFO_RESULTS) {
    assertTrue(blobInfoSet.contains(info.blobId()));
  }
  Iterator<Blob> blobIterator=blobs.iterator();
  Iterator<Result<BlobInfo>> batchResultIterator=response.gets().iterator();
  while (batchResultIterator.hasNext() && blobIterator.hasNext()) {
    assertEquals(batchResultIterator.next().get(),blobIterator.next().info());
  }
  assertFalse(batchResultIterator.hasNext());
  assertFalse(blobIterator.hasNext());
}"
93209,"/** 
 * Sends a job cancel request. This call will return immediately. The client will need to poll for the job status using either   {@link #getJob(JobId,JobOption)} or{@link #getJob(String,JobOption)}) to see if the cancel operation completed successfully.
 * @return {@code true} if cancel was requested successfully, {@code false} if the job was notfound
 * @throws BigQueryException upon failure
 */
boolean cancel(JobId tableId) throws BigQueryException ;","/** 
 * Sends a job cancel request. This call will return immediately. The job status can then be checked using either   {@link #getJob(JobId,JobOption)} or{@link #getJob(String,JobOption)}).
 * @return {@code true} if cancel was requested successfully, {@code false} if the job was notfound
 * @throws BigQueryException upon failure
 */
boolean cancel(JobId tableId) throws BigQueryException ;"
93210,"/** 
 * Returns an option that sets the zero-based index of the row from which to start listing query results.
 */
public static QueryResultsOption startIndex(Long startIndex){
  return new QueryResultsOption(BigQueryRpc.Option.START_INDEX,startIndex);
}","/** 
 * Returns an option that sets the zero-based index of the row from which to start getting query results.
 */
public static QueryResultsOption startIndex(long startIndex){
  checkArgument(startIndex >= 0);
  return new QueryResultsOption(BigQueryRpc.Option.START_INDEX,startIndex);
}"
93211,"/** 
 * Returns an option to list only jobs that match the provided filters.
 */
public static JobListOption stateFilter(JobStatus.State... stateFilters){
  List<String> stringFilters=Lists.transform(ImmutableList.copyOf(stateFilters),new Function<JobStatus.State,String>(){
    @Override public String apply(    JobStatus.State state){
      return state.toString().toLowerCase();
    }
  }
);
  return new JobListOption(BigQueryRpc.Option.STATE_FILTER,stringFilters);
}","/** 
 * Returns an option to list only jobs that match the provided state filters.
 */
public static JobListOption stateFilter(JobStatus.State... stateFilters){
  List<String> stringFilters=Lists.transform(ImmutableList.copyOf(stateFilters),new Function<JobStatus.State,String>(){
    @Override public String apply(    JobStatus.State state){
      return state.name().toLowerCase();
    }
  }
);
  return new JobListOption(BigQueryRpc.Option.STATE_FILTER,stringFilters);
}"
93212,"/** 
 * Returns an option to specify the maximum number of rows to be returned.
 */
public static QueryResultsOption maxResults(long maxResults){
  return new QueryResultsOption(BigQueryRpc.Option.MAX_RESULTS,maxResults);
}","/** 
 * Returns an option to specify the maximum number of rows to be returned.
 */
public static QueryResultsOption maxResults(long maxResults){
  checkArgument(maxResults >= 0);
  return new QueryResultsOption(BigQueryRpc.Option.MAX_RESULTS,maxResults);
}"
93213,"static String selector(JobField... fields){
  HashSet<String> fieldStrings=Sets.newHashSetWithExpectedSize(fields.length + 2);
  fieldStrings.add(JOB_REFERENCE.selector());
  fieldStrings.add(CONFIGURATION.selector());
  for (  JobField field : fields) {
    fieldStrings.add(field.selector());
  }
  return com.google.common.base.Joiner.on(',').join(fieldStrings);
}","static String selector(JobField... fields){
  Set<String> fieldStrings=Sets.newHashSetWithExpectedSize(fields.length + 2);
  fieldStrings.add(JOB_REFERENCE.selector());
  fieldStrings.add(CONFIGURATION.selector());
  for (  JobField field : fields) {
    fieldStrings.add(field.selector());
  }
  return Joiner.on(',').join(fieldStrings);
}"
93214,"/** 
 * Returns an option to specify the page token from which to start listing query results.
 */
public static QueryResultsOption startPageToken(String pageToken){
  return new QueryResultsOption(BigQueryRpc.Option.PAGE_TOKEN,pageToken);
}","/** 
 * Returns an option to specify the page token from which to start getting query results.
 */
public static QueryResultsOption startPageToken(String pageToken){
  return new QueryResultsOption(BigQueryRpc.Option.PAGE_TOKEN,pageToken);
}"
93215,"/** 
 * Returns results of the query associated to the provided job.
 * @throws BigQueryException upon failure
 */
QueryResponse getQueryResults(JobId job,QueryResultsOption... options) throws BigQueryException ;","/** 
 * Returns results of the query associated with the provided job.
 * @throws BigQueryException upon failure
 */
QueryResponse getQueryResults(JobId job,QueryResultsOption... options) throws BigQueryException ;"
93216,"/** 
 * Lists the dataset's tables.
 * @throws BigQueryException upon failure
 */
Page<JobInfo> listJobs(JobListOption... options) throws BigQueryException ;","/** 
 * Lists the jobs.
 * @throws BigQueryException upon failure
 */
Page<JobInfo> listJobs(JobListOption... options) throws BigQueryException ;"
93217,"@Override public String apply(JobStatus.State state){
  return state.toString().toLowerCase();
}","@Override public String apply(JobStatus.State state){
  return state.name().toLowerCase();
}"
93218,"/** 
 * Returns an option that sets how long to wait for the query to complete, in milliseconds, before returning. Default is 10 seconds. If the timeout passes before the job completes,  {@link QueryResponse#jobComplete()} will be {@code false}.
 */
public static QueryResultsOption maxWaitTime(Long maxWaitTime){
  return new QueryResultsOption(BigQueryRpc.Option.TIMEOUT,maxWaitTime);
}","/** 
 * Returns an option that sets how long to wait for the query to complete, in milliseconds, before returning. Default is 10 seconds. If the timeout passes before the job completes,  {@link QueryResponse#jobComplete()} will be {@code false}.
 */
public static QueryResultsOption maxWaitTime(long maxWaitTime){
  checkArgument(maxWaitTime >= 0);
  return new QueryResultsOption(BigQueryRpc.Option.TIMEOUT,maxWaitTime);
}"
93219,"/** 
 * Runs the query associated to the request.
 * @throws BigQueryException upon failure
 */
QueryResponse query(QueryRequest request) throws BigQueryException ;","/** 
 * Runs the query associated with the request.
 * @throws BigQueryException upon failure
 */
QueryResponse query(QueryRequest request) throws BigQueryException ;"
93220,"/** 
 * Lists the project's datasets. This method returns partial information on each dataset (  {@link DatasetInfo#datasetId()} ()}, {@link DatasetInfo#friendlyName()} and{@link DatasetInfo#id()}). To get complete information use either  {@link #getDataset(String,DatasetOption)} or{@link #getDataset(DatasetId,DatasetOption)}.
 * @throws BigQueryException upon failure
 */
Page<DatasetInfo> listDatasets(DatasetListOption... options) throws BigQueryException ;","/** 
 * Lists the project's datasets. This method returns partial information on each dataset (  {@link DatasetInfo#datasetId()},   {@link DatasetInfo#friendlyName()} and{@link DatasetInfo#id()}). To get complete information use either  {@link #getDataset(String,DatasetOption)} or{@link #getDataset(DatasetId,DatasetOption)}.
 * @throws BigQueryException upon failure
 */
Page<DatasetInfo> listDatasets(DatasetListOption... options) throws BigQueryException ;"
93221,"/** 
 * Returns an option to specify the job's fields to be returned by the RPC call. If this option is not provided all job's fields are returned.   {@code JobOption.fields}) can be used to specify only the fields of interest.   {@link JobInfo#jobId()} as well as type-specificconfiguration (e.g.  {@link QueryJobInfo#query()} for Query Jobs) are always returned, even ifnot specified.
 */
public static JobOption fields(JobField... fields){
  return new JobOption(BigQueryRpc.Option.FIELDS,JobField.selector(fields));
}","/** 
 * Returns an option to specify the job's fields to be returned by the RPC call. If this option is not provided all job's fields are returned.   {@code JobOption.fields()} can be used tospecify only the fields of interest.  {@link JobInfo#jobId()} as well as type-specificconfiguration (e.g.  {@link QueryJobInfo#query()} for Query Jobs) are always returned, even ifnot specified.
 */
public static JobOption fields(JobField... fields){
  return new JobOption(BigQueryRpc.Option.FIELDS,JobField.selector(fields));
}"
93222,"@Override public InsertAllResponse insertAll(InsertAllRequest request) throws BigQueryException {
  final TableId tableId=request.table();
  final TableDataInsertAllRequest requestPb=new TableDataInsertAllRequest();
  requestPb.setIgnoreUnknownValues(request.ignoreUnknownValues());
  requestPb.setSkipInvalidRows(request.skipInvalidRows());
  List<Rows> rowsPb=Lists.transform(request.rows(),new Function<RowToInsert,Rows>(){
    @Override public Rows apply(    RowToInsert rowToInsert){
      return new Rows().setInsertId(rowToInsert.id()).setJson(rowToInsert.content());
    }
  }
);
  requestPb.setRows(rowsPb);
  try {
    return InsertAllResponse.fromPb(runWithRetries(new Callable<TableDataInsertAllResponse>(){
      @Override public TableDataInsertAllResponse call(){
        return bigQueryRpc.insertAll(tableId.dataset(),tableId.table(),requestPb);
      }
    }
,options().retryParams(),EXCEPTION_HANDLER));
  }
 catch (  RetryHelper.RetryHelperException e) {
    throw BigQueryException.translateAndThrow(e);
  }
}","@Override public InsertAllResponse insertAll(InsertAllRequest request) throws BigQueryException {
  final TableId tableId=request.table();
  final TableDataInsertAllRequest requestPb=new TableDataInsertAllRequest();
  requestPb.setIgnoreUnknownValues(request.ignoreUnknownValues());
  requestPb.setSkipInvalidRows(request.skipInvalidRows());
  List<Rows> rowsPb=Lists.transform(request.rows(),new Function<RowToInsert,Rows>(){
    @Override public Rows apply(    RowToInsert rowToInsert){
      return new Rows().setInsertId(rowToInsert.id()).setJson(rowToInsert.content());
    }
  }
);
  requestPb.setRows(rowsPb);
  return InsertAllResponse.fromPb(bigQueryRpc.insertAll(tableId.dataset(),tableId.table(),requestPb));
}"
93223,"/** 
 * Returns this field's value as a list of   {@link FieldValue}. This method should only be used if the corresponding field has   {@link Field.Mode#REPEATED} mode (i.e. {@link #attribute()} is{@link Attribute#REPEATED}).
 * @throws ClassCastException if the field has not {@link Field.Mode#REPEATED} mode
 */
@SuppressWarnings(""String_Node_Str"") public List<FieldValue> repeatedValue(){
  return (List<FieldValue>)value;
}","/** 
 * Returns this field's value as a list of   {@link FieldValue}. This method should only be used if the corresponding field has   {@link Field.Mode#REPEATED} mode (i.e. {@link #attribute()} is{@link Attribute#REPEATED}).
 * @throws ClassCastException if the field has not {@link Field.Mode#REPEATED} mode
 * @throws NullPointerException if {@link #isNull()} returns {@code true}
 */
@SuppressWarnings(""String_Node_Str"") public List<FieldValue> repeatedValue(){
  checkNotNull(value);
  return (List<FieldValue>)value;
}"
93224,"/** 
 * Returns this field's value as a   {@link String}. This method should only be used if the corresponding field has primitive type (  {@link Field.Type#bool()},   {@link Field.Type#string()},  {@link Field.Type#floatingPoint()},   {@link Field.Type#integer()},  {@link Field.Type#timestamp()}).
 * @throws ClassCastException if the field is not a primitive type
 */
@SuppressWarnings(""String_Node_Str"") public String stringValue(){
  return (String)value;
}","/** 
 * Returns this field's value as a   {@link String}. This method should only be used if the corresponding field has primitive type (  {@link Field.Type#bool()},   {@link Field.Type#string()},  {@link Field.Type#floatingPoint()},   {@link Field.Type#integer()},  {@link Field.Type#timestamp()}).
 * @throws ClassCastException if the field is not a primitive type
 * @throws NullPointerException if {@link #isNull()} returns {@code true}
 */
@SuppressWarnings(""String_Node_Str"") public String stringValue(){
  checkNotNull(value);
  return (String)value;
}"
93225,"/** 
 * Returns this field's value as a   {@link Boolean}. This method should only be used if the corresponding field has   {@link Field.Type#bool()} type.
 * @throws ClassCastException if the field is not a primitive type
 * @throws IllegalStateException if the field's value could not be converted to {@link Boolean}
 * @throws NullPointerException if {@link #isNull()} returns {@code true}
 */
@SuppressWarnings(""String_Node_Str"") public boolean booleanValue(){
  String stringValue=stringValue();
  checkNotNull(stringValue);
  checkState(stringValue.equalsIgnoreCase(""String_Node_Str"") || stringValue.equalsIgnoreCase(""String_Node_Str""),""String_Node_Str"");
  return Boolean.parseBoolean(stringValue);
}","/** 
 * Returns this field's value as a   {@link Boolean}. This method should only be used if the corresponding field has   {@link Field.Type#bool()} type.
 * @throws ClassCastException if the field is not a primitive type
 * @throws IllegalStateException if the field's value could not be converted to {@link Boolean}
 * @throws NullPointerException if {@link #isNull()} returns {@code true}
 */
@SuppressWarnings(""String_Node_Str"") public boolean booleanValue(){
  String stringValue=stringValue();
  checkState(stringValue.equalsIgnoreCase(""String_Node_Str"") || stringValue.equalsIgnoreCase(""String_Node_Str""),""String_Node_Str"");
  return Boolean.parseBoolean(stringValue);
}"
93226,"/** 
 * Returns this field's value as an   {@link Object}.
 */
public Object value(){
  return value;
}","/** 
 * Returns this field's value as an   {@link Object}. If   {@link #isNull()} is {@code true} thismethod returns  {@code null}.
 */
public Object value(){
  return value;
}"
93227,"/** 
 * Returns this field's value as a list of   {@link FieldValue}. This method should only be used if the corresponding field has   {@link Field.Type#record(Field)} type (i.e. {@link #attribute()}is   {@link Attribute#RECORD}).
 * @throws ClassCastException if the field is not a {@link Field.Type#record(Field)} type
 */
@SuppressWarnings(""String_Node_Str"") public List<FieldValue> recordValue(){
  return (List<FieldValue>)value;
}","/** 
 * Returns this field's value as a list of   {@link FieldValue}. This method should only be used if the corresponding field has   {@link Field.Type#record(Field)} type (i.e. {@link #attribute()}is   {@link Attribute#RECORD}).
 * @throws ClassCastException if the field is not a {@link Field.Type#record(Field)} type
 * @throws NullPointerException if {@link #isNull()} returns {@code true}
 */
@SuppressWarnings(""String_Node_Str"") public List<FieldValue> recordValue(){
  checkNotNull(value);
  return (List<FieldValue>)value;
}"
93228,"/** 
 * Adds a row to be inserted without an associated id. <p> Example usage of adding a row without an associated id: <pre>      {@code InsertAllRequest.Builder builder = InsertAllRequest.builder(tableId); List<Long> repeatedFieldValue = Arrays.asList(1L, 2L); Map<String, Object> recordContent = new HashMap<String, Object>(); recordContent.put(""subfieldName1"", ""value""); recordContent.put(""subfieldName2"", repeatedFieldValue); Map<String, Object> rowContent = new HashMap<String, Object>(); rowContent.put(""fieldName1"", true); rowContent.put(""fieldName2"", recordContent); builder.addRow(rowContent);}</pre>
 */
public Builder addRow(Map<String,Object> content){
  addRow(new RowToInsert(null,content));
  return this;
}","/** 
 * Adds a row to be inserted without an associated id. <p>Example usage of adding a row without an associated id: <pre>      {@code InsertAllRequest.Builder builder = InsertAllRequest.builder(tableId); List<Long> repeatedFieldValue = Arrays.asList(1L, 2L); Map<String, Object> recordContent = new HashMap<String, Object>(); recordContent.put(""subfieldName1"", ""value""); recordContent.put(""subfieldName2"", repeatedFieldValue); Map<String, Object> rowContent = new HashMap<String, Object>(); rowContent.put(""fieldName1"", true); rowContent.put(""fieldName2"", recordContent); builder.addRow(rowContent);}</pre>
 */
public Builder addRow(Map<String,Object> content){
  addRow(new RowToInsert(null,content));
  return this;
}"
93229,"@Override public Tuple<String,Iterable<Table>> listTables(String datasetId,Map<Option,?> options) throws BigQueryException {
  try {
    TableList tableList=bigquery.tables().list(this.options.projectId(),datasetId).setQuotaUser(QUOTA_USER.getString(options)).setUserIp(USER_IP.getString(options)).setMaxResults(MAX_RESULTS.getLong(options)).setPageToken(PAGE_TOKEN.getString(options)).execute();
    return Tuple.of(tableList.getNextPageToken(),Iterables.transform(tableList.getTables(),new Function<TableList.Tables,Table>(){
      @Override public Table apply(      TableList.Tables f){
        return new Table().setFriendlyName(f.getFriendlyName()).setId(f.getId()).setKind(f.getKind()).setTableReference(f.getTableReference()).setType(f.getType());
      }
    }
));
  }
 catch (  IOException ex) {
    throw translate(ex);
  }
}","@Override public Tuple<String,Iterable<Table>> listTables(String datasetId,Map<Option,?> options) throws BigQueryException {
  try {
    TableList tableList=bigquery.tables().list(this.options.projectId(),datasetId).setQuotaUser(QUOTA_USER.getString(options)).setUserIp(USER_IP.getString(options)).setMaxResults(MAX_RESULTS.getLong(options)).setPageToken(PAGE_TOKEN.getString(options)).execute();
    Iterable<TableList.Tables> tables=tableList.getTables();
    return Tuple.of(tableList.getNextPageToken(),Iterables.transform(tables != null ? tables : ImmutableList.<TableList.Tables>of(),new Function<TableList.Tables,Table>(){
      @Override public Table apply(      TableList.Tables f){
        return new Table().setFriendlyName(f.getFriendlyName()).setId(f.getId()).setKind(f.getKind()).setTableReference(f.getTableReference()).setType(f.getType());
      }
    }
));
  }
 catch (  IOException ex) {
    throw translate(ex);
  }
}"
93230,"@Override public Tuple<String,Iterable<Job>> listJobs(Map<Option,?> options) throws BigQueryException {
  try {
    JobList jobsList=bigquery.jobs().list(this.options.projectId()).setAllUsers(Option.ALL_USERS.getBoolean(options)).setFields(Option.FIELDS.getString(options)).setStateFilter(Option.STATE_FILTER.<List<String>>get(options)).setMaxResults(MAX_RESULTS.getLong(options)).setPageToken(PAGE_TOKEN.getString(options)).setProjection(DEFAULT_PROJECTION).execute();
    return Tuple.of(jobsList.getNextPageToken(),Iterables.transform(jobsList.getJobs(),new Function<JobList.Jobs,Job>(){
      @Override public Job apply(      JobList.Jobs f){
        return new Job().setConfiguration(f.getConfiguration()).setId(f.getId()).setJobReference(f.getJobReference()).setKind(f.getKind()).setStatistics(f.getStatistics()).setStatus(f.getStatus()).setUserEmail(f.getUserEmail());
      }
    }
));
  }
 catch (  IOException ex) {
    throw translate(ex);
  }
}","@Override public Tuple<String,Iterable<Job>> listJobs(Map<Option,?> options) throws BigQueryException {
  try {
    JobList jobsList=bigquery.jobs().list(this.options.projectId()).setAllUsers(Option.ALL_USERS.getBoolean(options)).setFields(Option.FIELDS.getString(options)).setStateFilter(Option.STATE_FILTER.<List<String>>get(options)).setMaxResults(MAX_RESULTS.getLong(options)).setPageToken(PAGE_TOKEN.getString(options)).setProjection(DEFAULT_PROJECTION).execute();
    Iterable<JobList.Jobs> jobs=jobsList.getJobs();
    return Tuple.of(jobsList.getNextPageToken(),Iterables.transform(jobs != null ? jobs : ImmutableList.<JobList.Jobs>of(),new Function<JobList.Jobs,Job>(){
      @Override public Job apply(      JobList.Jobs f){
        JobStatus statusPb=f.getStatus() != null ? f.getStatus() : new JobStatus();
        if (statusPb.getState() == null) {
          statusPb.setState(f.getState());
        }
        if (statusPb.getErrorResult() == null) {
          statusPb.setErrorResult(f.getErrorResult());
        }
        return new Job().setConfiguration(f.getConfiguration()).setId(f.getId()).setJobReference(f.getJobReference()).setKind(f.getKind()).setStatistics(f.getStatistics()).setStatus(f.getStatus()).setUserEmail(f.getUserEmail());
      }
    }
));
  }
 catch (  IOException ex) {
    throw translate(ex);
  }
}"
93231,"@Override public Job apply(JobList.Jobs f){
  return new Job().setConfiguration(f.getConfiguration()).setId(f.getId()).setJobReference(f.getJobReference()).setKind(f.getKind()).setStatistics(f.getStatistics()).setStatus(f.getStatus()).setUserEmail(f.getUserEmail());
}","@Override public Job apply(JobList.Jobs f){
  JobStatus statusPb=f.getStatus() != null ? f.getStatus() : new JobStatus();
  if (statusPb.getState() == null) {
    statusPb.setState(f.getState());
  }
  if (statusPb.getErrorResult() == null) {
    statusPb.setErrorResult(f.getErrorResult());
  }
  return new Job().setConfiguration(f.getConfiguration()).setId(f.getId()).setJobReference(f.getJobReference()).setKind(f.getKind()).setStatistics(f.getStatistics()).setStatus(f.getStatus()).setUserEmail(f.getUserEmail());
}"
93232,"private static boolean isLocalHost(String host){
  if (host != null) {
    try {
      String normalizedHost=host;
      if (!includesScheme(normalizedHost)) {
        normalizedHost=""String_Node_Str"" + normalizedHost;
      }
      InetAddress hostAddr=InetAddress.getByName(new URL(normalizedHost).getHost());
      return hostAddr.isAnyLocalAddress() || hostAddr.isLoopbackAddress();
    }
 catch (    UnknownHostException|MalformedURLException e) {
    }
  }
  return false;
}","private static boolean isLocalHost(String host){
  if (host != null) {
    try {
      String normalizedHost=host;
      if (!includesScheme(normalizedHost)) {
        normalizedHost=""String_Node_Str"" + normalizedHost;
      }
      InetAddress hostAddr=InetAddress.getByName(new URL(normalizedHost).getHost());
      return hostAddr.isAnyLocalAddress() || hostAddr.isLoopbackAddress();
    }
 catch (    Exception e) {
    }
  }
  return false;
}"
93233,"/** 
 * Returns the totalRetryPeriodMillis. Default value is   {@value #DEFAULT_TOTAL_RETRY_PERIOD_MILLIS}.
 */
public long getTotalRetryPeriodMillis(){
  return totalRetryPeriodMillis;
}","/** 
 * Returns the totalRetryPeriodMillis. Default value is  {@value #DEFAULT_TOTAL_RETRY_PERIOD_MILLIS}.
 */
public long getTotalRetryPeriodMillis(){
  return totalRetryPeriodMillis;
}"
93234,"private Storage.Objects.Delete deleteRequest(StorageObject blob,Map<Option,?> options) throws IOException {
  return storage.objects().delete(blob.getBucket(),blob.getName()).setIfMetagenerationMatch(IF_METAGENERATION_MATCH.getLong(options)).setIfMetagenerationNotMatch(IF_METAGENERATION_NOT_MATCH.getLong(options)).setIfGenerationMatch(IF_GENERATION_MATCH.getLong(options)).setIfGenerationMatch(100L).setIfGenerationNotMatch(IF_GENERATION_NOT_MATCH.getLong(options));
}","private Storage.Objects.Delete deleteRequest(StorageObject blob,Map<Option,?> options) throws IOException {
  return storage.objects().delete(blob.getBucket(),blob.getName()).setIfMetagenerationMatch(IF_METAGENERATION_MATCH.getLong(options)).setIfMetagenerationNotMatch(IF_METAGENERATION_NOT_MATCH.getLong(options)).setIfGenerationMatch(IF_GENERATION_MATCH.getLong(options)).setIfGenerationNotMatch(IF_GENERATION_NOT_MATCH.getLong(options));
}"
93235,"private Storage.Objects.Delete deleteRequest(StorageObject blob,Map<Option,?> options) throws IOException {
  return storage.objects().delete(blob.getBucket(),blob.getName()).setIfMetagenerationMatch(IF_METAGENERATION_MATCH.getLong(options)).setIfMetagenerationNotMatch(IF_METAGENERATION_NOT_MATCH.getLong(options)).setIfGenerationMatch(IF_GENERATION_MATCH.getLong(options)).setIfGenerationMatch(100L).setIfGenerationNotMatch(IF_GENERATION_NOT_MATCH.getLong(options));
}","private Storage.Objects.Delete deleteRequest(StorageObject blob,Map<Option,?> options) throws IOException {
  return storage.objects().delete(blob.getBucket(),blob.getName()).setIfMetagenerationMatch(IF_METAGENERATION_MATCH.getLong(options)).setIfMetagenerationNotMatch(IF_METAGENERATION_NOT_MATCH.getLong(options)).setIfGenerationMatch(IF_GENERATION_MATCH.getLong(options)).setIfGenerationNotMatch(IF_GENERATION_NOT_MATCH.getLong(options));
}"
93236,"@Override public Batch.Response submit(){
  validateActive();
  List<com.google.datastore.v1beta3.Mutation> mutationsPb=toMutationPbList();
  com.google.datastore.v1beta3.CommitRequest.Builder requestPb=com.google.datastore.v1beta3.CommitRequest.newBuilder();
  requestPb.setMode(com.google.datastore.v1beta3.CommitRequest.Mode.NON_TRANSACTIONAL);
  requestPb.addAllMutations(mutationsPb);
  com.google.datastore.v1beta3.CommitResponse responsePb=datastore.commit(requestPb.build());
  deactivate();
  return new ResponseImpl(responsePb,numAutoAllocatedIds());
}","@Override public Batch.Response submit(){
  validateActive();
  List<com.google.datastore.v1beta3.Mutation> mutationsPb=toMutationPbList();
  com.google.datastore.v1beta3.CommitRequest.Builder requestPb=com.google.datastore.v1beta3.CommitRequest.newBuilder();
  requestPb.setMode(com.google.datastore.v1beta3.CommitRequest.Mode.NON_TRANSACTIONAL);
  requestPb.addAllMutations(mutationsPb);
  com.google.datastore.v1beta3.CommitResponse responsePb=datastore.commit(requestPb.build());
  deactivate();
  return new ResponseImpl(responsePb,toAddAutoId().size());
}"
93237,"@Override public List<Key> generatedKeys(){
  Iterator<com.google.datastore.v1beta3.MutationResult> results=response.getMutationResultsList().iterator();
  List<Key> generated=new LinkedList<Key>();
  for (int i=0; i < numAutoAllocatedIds; i++) {
    generated.add(Key.fromPb(results.next().getKey()));
  }
  return generated;
}","@Override public List<Key> generatedKeys(){
  Iterator<com.google.datastore.v1beta3.MutationResult> results=response.getMutationResultsList().iterator();
  List<Key> generated=new ArrayList<>(numAutoAllocatedIds);
  for (int i=0; i < numAutoAllocatedIds; i++) {
    generated.add(Key.fromPb(results.next().getKey()));
  }
  return generated;
}"
93238,"@SuppressWarnings(""String_Node_Str"") @Override public List<Entity> add(FullEntity<?>... entities){
  if (entities.length == 0) {
    return Collections.emptyList();
  }
  List<com.google.datastore.v1beta3.Mutation> mutationsPb=new ArrayList<>();
  Map<Key,Entity> completeEntities=new LinkedHashMap<>();
  for (  FullEntity<?> entity : entities) {
    Entity completeEntity=null;
    if (entity.key() instanceof Key) {
      completeEntity=Entity.convert((FullEntity<Key>)entity);
    }
    if (completeEntity != null) {
      if (completeEntities.put(completeEntity.key(),completeEntity) != null) {
        throw DatastoreException.throwInvalidRequest(""String_Node_Str"",entity.key());
      }
      mutationsPb.add(com.google.datastore.v1beta3.Mutation.newBuilder().setInsert(completeEntity.toPb()).build());
    }
 else {
      Preconditions.checkArgument(entity.hasKey(),""String_Node_Str"",entity);
      mutationsPb.add(com.google.datastore.v1beta3.Mutation.newBuilder().setInsert(entity.toPb()).build());
    }
  }
  com.google.datastore.v1beta3.CommitResponse commitResponse=commitMutation(mutationsPb);
  Iterator<com.google.datastore.v1beta3.MutationResult> mutationResults=commitResponse.getMutationResultsList().iterator();
  ImmutableList.Builder<Entity> responseBuilder=ImmutableList.builder();
  for (  FullEntity<?> entity : entities) {
    Entity completeEntity=completeEntities.get(entity.key());
    if (completeEntity != null) {
      responseBuilder.add(completeEntity);
      mutationResults.next();
    }
 else {
      responseBuilder.add(Entity.builder(Key.fromPb(mutationResults.next().getKey()),entity).build());
    }
  }
  return responseBuilder.build();
}","@SuppressWarnings(""String_Node_Str"") @Override public List<Entity> add(FullEntity<?>... entities){
  if (entities.length == 0) {
    return Collections.emptyList();
  }
  List<com.google.datastore.v1beta3.Mutation> mutationsPb=new ArrayList<>();
  Set<Entity> completeEntities=new LinkedHashSet<>();
  for (  FullEntity<?> entity : entities) {
    Entity completeEntity=null;
    if (entity.key() instanceof Key) {
      completeEntity=Entity.convert((FullEntity<Key>)entity);
    }
    if (completeEntity != null) {
      if (completeEntities.contains(completeEntity)) {
        throw DatastoreException.throwInvalidRequest(""String_Node_Str"",entity.key());
      }
      completeEntities.add(completeEntity);
    }
 else {
      Preconditions.checkArgument(entity.hasKey(),""String_Node_Str"",entity);
    }
    mutationsPb.add(com.google.datastore.v1beta3.Mutation.newBuilder().setInsert(entity.toPb()).build());
  }
  com.google.datastore.v1beta3.CommitResponse commitResponse=commitMutation(mutationsPb);
  Iterator<com.google.datastore.v1beta3.MutationResult> mutationResults=commitResponse.getMutationResultsList().iterator();
  Iterator<Entity> completeEntitiesIt=completeEntities.iterator();
  ImmutableList.Builder<Entity> responseBuilder=ImmutableList.builder();
  for (  FullEntity<?> entity : entities) {
    if (completeEntities.contains(entity)) {
      responseBuilder.add(completeEntitiesIt.next());
      mutationResults.next();
    }
 else {
      responseBuilder.add(Entity.builder(Key.fromPb(mutationResults.next().getKey()),entity).build());
    }
  }
  return responseBuilder.build();
}"
93239,"@Override public Transaction.Response commit(){
  validateActive();
  List<com.google.datastore.v1beta3.Mutation> mutationsPb=toMutationPbList();
  com.google.datastore.v1beta3.CommitRequest.Builder requestPb=com.google.datastore.v1beta3.CommitRequest.newBuilder();
  requestPb.setMode(com.google.datastore.v1beta3.CommitRequest.Mode.TRANSACTIONAL);
  requestPb.setTransaction(transaction);
  requestPb.addAllMutations(mutationsPb);
  com.google.datastore.v1beta3.CommitResponse responsePb=datastore.commit(requestPb.build());
  deactivate();
  return new ResponseImpl(responsePb,numAutoAllocatedIds());
}","@Override public Transaction.Response commit(){
  validateActive();
  List<com.google.datastore.v1beta3.Mutation> mutationsPb=toMutationPbList();
  com.google.datastore.v1beta3.CommitRequest.Builder requestPb=com.google.datastore.v1beta3.CommitRequest.newBuilder();
  requestPb.setMode(com.google.datastore.v1beta3.CommitRequest.Mode.TRANSACTIONAL);
  requestPb.setTransaction(transaction);
  requestPb.addAllMutations(mutationsPb);
  com.google.datastore.v1beta3.CommitResponse responsePb=datastore.commit(requestPb.build());
  deactivate();
  return new ResponseImpl(responsePb,toAddAutoId().size());
}"
93240,"@Override public List<Key> generatedKeys(){
  Iterator<com.google.datastore.v1beta3.MutationResult> results=response.getMutationResultsList().iterator();
  List<Key> generated=new LinkedList<Key>();
  for (int i=0; i < numAutoAllocatedIds; i++) {
    generated.add(Key.fromPb(results.next().getKey()));
  }
  return generated;
}","@Override public List<Key> generatedKeys(){
  Iterator<com.google.datastore.v1beta3.MutationResult> results=response.getMutationResultsList().iterator();
  List<Key> generated=new ArrayList<>(numAutoAllocatedIds);
  for (int i=0; i < numAutoAllocatedIds; i++) {
    generated.add(Key.fromPb(results.next().getKey()));
  }
  return generated;
}"
93241,"public DefaultDatastoreRpc(DatastoreOptions options){
  if (options.host().contains(""String_Node_Str"")) {
    client=com.google.datastore.v1beta3.client.DatastoreFactory.get().create(new com.google.datastore.v1beta3.client.DatastoreOptions.Builder().projectId(options.projectId()).localHost(options.host()).initializer(options.httpRequestInitializer()).build());
  }
 else {
    client=com.google.datastore.v1beta3.client.DatastoreFactory.get().create(new com.google.datastore.v1beta3.client.DatastoreOptions.Builder().projectId(options.projectId()).initializer(options.httpRequestInitializer()).build());
  }
}","public DefaultDatastoreRpc(DatastoreOptions options){
  com.google.datastore.v1beta3.client.DatastoreOptions.Builder clientBuilder=new com.google.datastore.v1beta3.client.DatastoreOptions.Builder().projectId(options.projectId()).initializer(options.httpRequestInitializer());
  if (options.host() != null) {
    try {
      String normalizedHost=options.host();
      if (!normalizedHost.startsWith(""String_Node_Str"")) {
        normalizedHost=""String_Node_Str"" + normalizedHost;
      }
      InetAddress hostAddr=InetAddress.getByName(new URL(normalizedHost).getHost());
      if (hostAddr.isAnyLocalAddress() || hostAddr.isLoopbackAddress()) {
        clientBuilder=clientBuilder.localHost(options.host());
      }
    }
 catch (    UnknownHostException|MalformedURLException e) {
    }
  }
  client=com.google.datastore.v1beta3.client.DatastoreFactory.get().create(clientBuilder.build());
}"
93242,"BasePageFetcher(StorageOptions serviceOptions,String cursor,Map<StorageRpc.Option,?> optionMap){
  this.serviceOptions=serviceOptions;
  ImmutableMap.Builder<StorageRpc.Option,Object> builder=ImmutableMap.builder();
  builder.put(StorageRpc.Option.PAGE_TOKEN,cursor);
  for (  Map.Entry<StorageRpc.Option,?> option : optionMap.entrySet()) {
    if (option.getKey() != StorageRpc.Option.PAGE_TOKEN) {
      builder.put(option.getKey(),option.getValue());
    }
  }
  this.requestOptions=builder.build();
}","BasePageFetcher(StorageOptions serviceOptions,String cursor,Map<StorageRpc.Option,?> optionMap){
  this.serviceOptions=serviceOptions;
  ImmutableMap.Builder<StorageRpc.Option,Object> builder=ImmutableMap.builder();
  if (cursor != null) {
    builder.put(StorageRpc.Option.PAGE_TOKEN,cursor);
  }
  for (  Map.Entry<StorageRpc.Option,?> option : optionMap.entrySet()) {
    if (option.getKey() != StorageRpc.Option.PAGE_TOKEN) {
      builder.put(option.getKey(),option.getValue());
    }
  }
  this.requestOptions=builder.build();
}"
93243,"@Override public O options(){
  return options;
}","@Override public OptionsT options(){
  return options;
}"
93244,"protected BaseService(O options){
  this.options=options;
}","protected BaseService(OptionsT options){
  this.options=options;
}"
93245,"private Builder(){
  super(Type.BLOB);
}","private Builder(){
  super(ValueType.BLOB);
}"
93246,"private Builder(){
  super(Type.BOOLEAN);
}","private Builder(){
  super(ValueType.BOOLEAN);
}"
93247,"private Builder(){
  super(Type.DATE_TIME);
}","private Builder(){
  super(ValueType.DATE_TIME);
}"
93248,"public Builder(){
  super(Type.DOUBLE);
}","public Builder(){
  super(ValueType.DOUBLE);
}"
93249,"private Builder(){
  super(Type.ENTITY);
}","private Builder(){
  super(ValueType.ENTITY);
}"
93250,"public Builder(){
  super(Type.KEY);
}","public Builder(){
  super(ValueType.KEY);
}"
93251,"private Builder(){
  super(Type.LIST);
}","private Builder(){
  super(ValueType.LIST);
}"
93252,"private Builder(){
  super(Type.LONG);
}","private Builder(){
  super(ValueType.LONG);
}"
93253,"private Builder(){
  super(Type.NULL);
}","private Builder(){
  super(ValueType.NULL);
}"
93254,"private Builder(){
  super(Type.RAW_VALUE);
}","private Builder(){
  super(ValueType.RAW_VALUE);
}"
93255,"private Builder(){
  super(Type.STRING);
}","private Builder(){
  super(ValueType.STRING);
}"
93256,"public abstract Builder<?,?,?> toBuilder();","public abstract ValueBuilder<?,?,?> toBuilder();"
93257,"public final Type type(){
  return type;
}","public final ValueType type(){
  return valueType;
}"
93258,"@Override public int hashCode(){
  return Objects.hash(type,indexed,meaning,value);
}","@Override public int hashCode(){
  return Objects.hash(valueType,indexed,meaning,value);
}"
93259,"BaseBuilder(Type type){
  this.type=type;
}","BaseBuilder(ValueType valueType){
  this.valueType=valueType;
}"
93260,"@Override @SuppressWarnings(""String_Node_Str"") public boolean equals(Object obj){
  if (obj == this) {
    return true;
  }
  if (!getClass().isInstance(obj)) {
    return false;
  }
  Value<V> other=(Value<V>)obj;
  return Objects.equals(type,other.type) && Objects.equals(indexed,other.indexed) && Objects.equals(meaning,other.meaning)&& Objects.equals(value,other.value);
}","@Override @SuppressWarnings(""String_Node_Str"") public boolean equals(Object obj){
  if (obj == this) {
    return true;
  }
  if (!getClass().isInstance(obj)) {
    return false;
  }
  Value<V> other=(Value<V>)obj;
  return Objects.equals(valueType,other.valueType) && Objects.equals(indexed,other.indexed) && Objects.equals(meaning,other.meaning)&& Objects.equals(value,other.value);
}"
93261,"<P extends Value<V>,B extends BaseBuilder<V,P,B>>void Value(Builder<V,P,B> builder){
  type=builder.getType();
  indexed=builder.getIndexed();
  meaning=builder.getMeaning();
  value=builder.get();
}","<P extends Value<V>,B extends BaseBuilder<V,P,B>>Value(ValueBuilder<V,P,B> builder){
  valueType=builder.getValueType();
  indexed=builder.getIndexed();
  meaning=builder.getMeaning();
  value=builder.get();
}"
93262,"@Override public void setVisibility(int visibility){
  super.setVisibility(visibility);
  if (visibility == View.VISIBLE) {
    resetAnimation();
  }
 else   if (visibility == View.GONE || visibility == View.INVISIBLE) {
    stopAnimation();
  }
}","@Override public void setVisibility(int visibility){
  int currentVisibility=getVisibility();
  super.setVisibility(visibility);
  if (visibility != currentVisibility) {
    if (visibility == View.VISIBLE) {
      resetAnimation();
    }
 else     if (visibility == View.GONE || visibility == View.INVISIBLE) {
      stopAnimation();
    }
  }
}"
93263,"public void setStackMargin(int margin){
  mCardAnimator.setStackMargin(margin);
  mCardAnimator.initLayout();
}","public void setStackMargin(int margin){
  mStackMargin=margin;
  mCardAnimator.setStackMargin(mStackMargin);
  mCardAnimator.initLayout();
}"
93264,"private void applyParallax(){
  int[] location=new int[2];
  getLocationOnScreen(location);
  if (scrollSpaceY != 0) {
    float locationY=(float)location[1];
    float locationUsableY=locationY + heightImageView / 2;
    float scrollDeltaY=locationUsableY / screenHeight;
    float interpolatedScrollDeltaY=interpolator.getInterpolation(scrollDeltaY);
    if (reverseY)     setMyScrollY((int)(Math.min(Math.max((0.5f - interpolatedScrollDeltaY),-0.5f),0.5f) * -scrollSpaceY));
 else     setMyScrollY((int)(Math.min(Math.max((0.5f - interpolatedScrollDeltaY),-0.5f),0.5f) * scrollSpaceY));
  }
  if (scrollSpaceX != 0) {
    float locationX=(float)location[0];
    float locationUsableX=locationX + widthImageView / 2;
    float scrollDeltaX=locationUsableX / screenWidth;
    float interpolatedScrollDeltaX=interpolator.getInterpolation(scrollDeltaX);
    if (reverseX) {
      setMyScrollX((int)(Math.min(Math.max((0.5f - interpolatedScrollDeltaX),-0.5f),0.5f) * -scrollSpaceX));
    }
 else {
      setMyScrollX((int)(Math.min(Math.max((0.5f - interpolatedScrollDeltaX),-0.5f),0.5f) * scrollSpaceX));
    }
  }
}","private void applyParallax(){
  int[] location=new int[2];
  getLocationOnScreen(location);
  if (scrollSpaceY != 0) {
    float locationY=(float)location[1];
    float locationUsableY=locationY + heightImageView / 2;
    float scrollDeltaY=locationUsableY / screenHeight;
    float interpolatedScrollDeltaY=interpolator.getInterpolation(scrollDeltaY);
    if (reverseY)     setMyScrollY((int)(Math.min(Math.max((0.5f - interpolatedScrollDeltaY),-0.5f),0.5f) * -scrollSpaceY));
 else     setMyScrollY((int)(Math.min(Math.max((0.5f - interpolatedScrollDeltaY),-0.5f),0.5f) * scrollSpaceY));
  }
 else {
    setMyScrollY(0);
  }
  if (scrollSpaceX != 0) {
    float locationX=(float)location[0];
    float locationUsableX=locationX + widthImageView / 2;
    float scrollDeltaX=locationUsableX / screenWidth;
    float interpolatedScrollDeltaX=interpolator.getInterpolation(scrollDeltaX);
    if (reverseX) {
      setMyScrollX((int)(Math.min(Math.max((0.5f - interpolatedScrollDeltaX),-0.5f),0.5f) * -scrollSpaceX));
    }
 else {
      setMyScrollX((int)(Math.min(Math.max((0.5f - interpolatedScrollDeltaX),-0.5f),0.5f) * scrollSpaceX));
    }
  }
 else {
    setMyScrollX(0);
  }
}"
93265,"public void actionPerformed(AnActionEvent e){
  project=CommonDataKeys.PROJECT.getData(e.getDataContext());
  if (project == null) {
    return;
  }
  clickedFile=CommonDataKeys.VIRTUAL_FILE.getData(e.getDataContext());
  Log.i(""String_Node_Str"" + clickedFile.getPath());
  if (PropertiesComponent.getInstance().isValueSet(StorageDataKey.SettingLanguageEngine)) {
    defaultTranslationEngine=TranslationEngineType.fromName(PropertiesComponent.getInstance().getValue(StorageDataKey.SettingLanguageEngine));
  }
  try {
    androidStringsInStringFile=AndroidString.getAndroidStringsList(clickedFile.contentsToByteArray());
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  if (androidStringsInStringFile == null || androidStringsInStringFile.isEmpty()) {
    showErrorDialog(project,""String_Node_Str"");
    return;
  }
  MultiSelectDialog multiSelectDialog=new MultiSelectDialog(project,String.format(LOCALIZATION_MSG,defaultTranslationEngine.getDisplayName()),LOCALIZATION_TITLE,OVERRIDE_EXITS_STRINGS,PropertiesComponent.getInstance(project).getBoolean(StorageDataKey.OverrideCheckBoxStatus,false),defaultTranslationEngine,false);
  multiSelectDialog.setOnOKClickedListener(this);
  multiSelectDialog.show();
}","public void actionPerformed(AnActionEvent e){
  project=CommonDataKeys.PROJECT.getData(e.getDataContext());
  if (project == null) {
    return;
  }
  clickedFile=CommonDataKeys.VIRTUAL_FILE.getData(e.getDataContext());
  Log.i(""String_Node_Str"" + clickedFile.getPath());
  if (PropertiesComponent.getInstance().isValueSet(StorageDataKey.SettingLanguageEngine)) {
    defaultTranslationEngine=TranslationEngineType.fromName(PropertiesComponent.getInstance().getValue(StorageDataKey.SettingLanguageEngine));
  }
  try {
    androidStringsInStringFile=AndroidString.getAndroidStringsList(clickedFile.contentsToByteArray());
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  for (int i=0; i < androidStringsInStringFile.size(); i++) {
    Log.i(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ androidStringsInStringFile.get(i).toString());
  }
  if (androidStringsInStringFile == null || androidStringsInStringFile.isEmpty()) {
    showErrorDialog(project,""String_Node_Str"");
    return;
  }
  MultiSelectDialog multiSelectDialog=new MultiSelectDialog(project,String.format(LOCALIZATION_MSG,defaultTranslationEngine.getDisplayName()),LOCALIZATION_TITLE,OVERRIDE_EXITS_STRINGS,PropertiesComponent.getInstance(project).getBoolean(StorageDataKey.OverrideCheckBoxStatus,false),defaultTranslationEngine,false);
  multiSelectDialog.setOnOKClickedListener(this);
  multiSelectDialog.show();
}"
93266,"public static InputStream doHttpPost(String url,String xmlBody,Header[] headers){
  try {
    HttpClient httpClient=new DefaultHttpClient();
    HttpPost httpPost=new HttpPost(url);
    httpPost.setHeaders(headers);
    httpPost.setEntity(new StringEntity(xmlBody,""String_Node_Str""));
    HttpResponse resp=httpClient.execute(httpPost);
    return resp.getEntity().getContent();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","public static String doHttpPost(String url,String xmlBody,Header[] headers){
  try {
    HttpClient httpClient=new DefaultHttpClient();
    HttpPost httpPost=new HttpPost(url);
    httpPost.setHeaders(headers);
    httpPost.setEntity(new StringEntity(xmlBody,""String_Node_Str""));
    HttpResponse resp=httpClient.execute(httpPost);
    return StreamUtil.readText(resp.getEntity().getContent(),""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}"
93267,"public static List<TranslateArrayResponse> parseTranslateArrayResponse(InputStream xml){
  List<TranslateArrayResponse> result=new ArrayList<TranslateArrayResponse>();
  try {
    XMLInputFactory inputFactory=XMLInputFactory.newInstance();
    XMLEventReader eventReader=inputFactory.createXMLEventReader(xml);
    TranslateArrayResponse translateArrayResponse=null;
    while (eventReader.hasNext()) {
      XMLEvent event=eventReader.nextEvent();
      if (event.isStartElement()) {
        StartElement startElement=event.asStartElement();
        if (startElement.getName().getLocalPart().equals(TranslateArrayResponse)) {
          translateArrayResponse=new TranslateArrayResponse();
        }
        if (event.isStartElement()) {
          if (event.asStartElement().getName().getLocalPart().equals(From)) {
            event=eventReader.nextEvent();
            translateArrayResponse.setFrom(event.asCharacters().getData());
            continue;
          }
        }
        if (event.asStartElement().getName().getLocalPart().equals(TranslatedText)) {
          event=eventReader.nextEvent();
          translateArrayResponse.setTranslatedText(event.asCharacters().getData());
          continue;
        }
      }
      if (event.isEndElement()) {
        EndElement endElement=event.asEndElement();
        if (endElement.getName().getLocalPart().equals(TranslateArrayResponse)) {
          result.add(translateArrayResponse);
        }
      }
    }
  }
 catch (  XMLStreamException e) {
    e.printStackTrace();
  }
  return result;
}","public static List<TranslateArrayResponse> parseTranslateArrayResponse(String xml){
  InputStream stream=new ByteArrayInputStream(xml.getBytes(Charset.forName(""String_Node_Str"")));
  List<TranslateArrayResponse> result=new ArrayList<TranslateArrayResponse>();
  try {
    XMLInputFactory inputFactory=XMLInputFactory.newInstance();
    XMLEventReader eventReader=inputFactory.createXMLEventReader(stream);
    TranslateArrayResponse translateArrayResponse=null;
    while (eventReader.hasNext()) {
      XMLEvent event=eventReader.nextEvent();
      if (event.isStartElement()) {
        StartElement startElement=event.asStartElement();
        if (startElement.getName().getLocalPart().equals(TranslateArrayResponse)) {
          translateArrayResponse=new TranslateArrayResponse();
        }
        if (event.isStartElement()) {
          if (event.asStartElement().getName().getLocalPart().equals(From)) {
            event=eventReader.nextEvent();
            translateArrayResponse.setFrom(event.asCharacters().getData());
            continue;
          }
        }
        if (event.asStartElement().getName().getLocalPart().equals(TranslatedText)) {
          event=eventReader.nextEvent();
          translateArrayResponse.setTranslatedText(event.asCharacters().getData());
          continue;
        }
      }
      if (event.isEndElement()) {
        EndElement endElement=event.asEndElement();
        if (endElement.getName().getLocalPart().equals(TranslateArrayResponse)) {
          result.add(translateArrayResponse);
        }
      }
    }
  }
 catch (  XMLStreamException e) {
    e.printStackTrace();
  }
  return result;
}"
93268,"public static List<String> getTranslatedStringArrays(String accessToken,List<String> querys,SupportedLanguages from,SupportedLanguages to){
  String xmlBodyTop=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String xmlBodyMid=""String_Node_Str"";
  String xmlBodyBot=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String xmlBodyStrings=""String_Node_Str"";
  for (  String query : querys) {
    xmlBodyStrings+=String.format(xmlBodyMid,query);
  }
  String xmlBody=String.format(xmlBodyTop,from.getLanguageCode()) + xmlBodyStrings + String.format(xmlBodyBot,to.getLanguageCode());
  Header[] headers=new Header[]{new BasicHeader(""String_Node_Str"",""String_Node_Str"" + accessToken),new BasicHeader(""String_Node_Str"",""String_Node_Str"")};
  InputStream postResult=HttpUtils.doHttpPost(TRANSLATE_URL,xmlBody,headers);
  List<TranslateArrayResponse> translateArrayResponses=BingResultParser.parseTranslateArrayResponse(postResult);
  List<String> result=new ArrayList<String>();
  for (  TranslateArrayResponse translateArrayResponse : translateArrayResponses) {
    result.add(translateArrayResponse.getTranslatedText());
  }
  return result;
}","public static List<String> getTranslatedStringArrays(String accessToken,List<String> querys,SupportedLanguages from,SupportedLanguages to){
  String xmlBodyTop=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String xmlBodyMid=""String_Node_Str"";
  String xmlBodyBot=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  for (int i=0; i < querys.size(); i++) {
    Log.i(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ querys.get(i));
  }
  String xmlBodyStrings=""String_Node_Str"";
  for (  String query : querys) {
    xmlBodyStrings+=String.format(xmlBodyMid,query);
  }
  String xmlBody=String.format(xmlBodyTop,from.getLanguageCode()) + xmlBodyStrings + String.format(xmlBodyBot,to.getLanguageCode());
  Header[] headers=new Header[]{new BasicHeader(""String_Node_Str"",""String_Node_Str"" + accessToken),new BasicHeader(""String_Node_Str"",""String_Node_Str"")};
  Log.i(""String_Node_Str"" + xmlBody);
  String postResult=HttpUtils.doHttpPost(TRANSLATE_URL,xmlBody,headers);
  Log.i(""String_Node_Str"" + postResult);
  List<TranslateArrayResponse> translateArrayResponses=BingResultParser.parseTranslateArrayResponse(postResult);
  List<String> result=new ArrayList<String>();
  for (  TranslateArrayResponse translateArrayResponse : translateArrayResponses) {
    result.add(translateArrayResponse.getTranslatedText());
  }
  return result;
}"
93269,"public AndroidString(AndroidString androidString){
  this.key=androidString.getKey();
  this.value=androidString.getValue();
}","public AndroidString(){
}"
93270,"public static List<AndroidString> getAndroidStringsList(byte[] xmlContentByte){
  try {
    String fileContent=new String(xmlContentByte,""String_Node_Str"");
    if (!fileContent.contains(KEY_STRING))     return null;
    String[] tokens=fileContent.split(SPLIT_KEY);
    List<AndroidString> result=new ArrayList<AndroidString>();
    for (int i=0; i < tokens.length; i++) {
      if (tokens[i].contains(KEY_STRING)) {
        int keyStartIndex=tokens[i].indexOf(KEY_START) + KEY_START.length();
        int keyEndIndex=tokens[i].indexOf(KEY_END);
        int valueEndIndex=tokens[i].indexOf(VALUE_END);
        if (keyStartIndex >= tokens[i].length() || keyEndIndex >= tokens[i].length() || (keyEndIndex + KEY_END.length()) >= tokens[i].length() || valueEndIndex >= tokens[i].length()) {
          continue;
        }
        String key=tokens[i].substring(keyStartIndex,keyEndIndex);
        String value=tokens[i].substring(keyEndIndex + KEY_END.length(),valueEndIndex);
        result.add(new AndroidString(key,value));
      }
    }
    return result;
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  return null;
}","public static List<AndroidString> getAndroidStringsList(byte[] xmlContentByte){
  try {
    String fileContent=new String(xmlContentByte,""String_Node_Str"");
    if (!fileContent.contains(KEY_STRING))     return null;
    String[] tokens=fileContent.split(SPLIT_KEY);
    List<AndroidString> result=new ArrayList<AndroidString>();
    for (int i=0; i < tokens.length; i++) {
      if (tokens[i].contains(KEY_STRING)) {
        int keyStartIndex=tokens[i].indexOf(KEY_START) + KEY_START.length();
        int keyEndIndex=tokens[i].indexOf(KEY_END);
        int valueEndIndex=tokens[i].indexOf(VALUE_END);
        if (keyStartIndex >= tokens[i].length() || keyEndIndex >= tokens[i].length() || (keyEndIndex + KEY_END.length()) >= tokens[i].length() || valueEndIndex >= tokens[i].length()) {
          continue;
        }
        String key=tokens[i].substring(keyStartIndex,keyEndIndex).trim();
        String value=tokens[i].substring(keyEndIndex + KEY_END.length(),valueEndIndex).trim();
        result.add(new AndroidString(key,value));
      }
    }
    return result;
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  return null;
}"
93271,"private static List<AndroidString> getTargetAndroidStrings(List<AndroidString> sourceAndroidStrings,List<AndroidString> translatedAndroidStrings,String fileName,boolean override){
  VirtualFile existenceFile=LocalFileSystem.getInstance().findFileByPath(fileName);
  List<AndroidString> existenceAndroidStrings=null;
  if (existenceFile != null && !override) {
    try {
      existenceAndroidStrings=AndroidString.getAndroidStringsList(existenceFile.contentsToByteArray());
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 else {
    existenceAndroidStrings=new ArrayList<AndroidString>();
  }
  Log.i(""String_Node_Str"" + sourceAndroidStrings,""String_Node_Str"" + translatedAndroidStrings,""String_Node_Str"" + existenceAndroidStrings);
  List<AndroidString> targetAndroidStrings=new ArrayList<AndroidString>(sourceAndroidStrings);
  for (  AndroidString androidString : targetAndroidStrings) {
    Log.i(""String_Node_Str"" + sourceAndroidStrings);
    if (!override) {
      String existenceValue=getAndroidStringValueInList(existenceAndroidStrings,androidString.getKey());
      if (existenceValue != null) {
        androidString.setValue(existenceValue);
      }
    }
    String translatedValue=getAndroidStringValueInList(translatedAndroidStrings,androidString.getKey());
    if (translatedValue != null) {
      androidString.setValue(translatedValue);
    }
    Log.i(""String_Node_Str"" + sourceAndroidStrings);
  }
  Log.i(""String_Node_Str"" + sourceAndroidStrings,""String_Node_Str"" + targetAndroidStrings);
  return targetAndroidStrings;
}","private static List<AndroidString> getTargetAndroidStrings(List<AndroidString> sourceAndroidStrings,List<AndroidString> translatedAndroidStrings,String fileName,boolean override){
  VirtualFile existenceFile=LocalFileSystem.getInstance().findFileByPath(fileName);
  List<AndroidString> existenceAndroidStrings=null;
  if (existenceFile != null && !override) {
    try {
      existenceAndroidStrings=AndroidString.getAndroidStringsList(existenceFile.contentsToByteArray());
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 else {
    existenceAndroidStrings=new ArrayList<AndroidString>();
  }
  Log.i(""String_Node_Str"" + sourceAndroidStrings,""String_Node_Str"" + translatedAndroidStrings,""String_Node_Str"" + existenceAndroidStrings);
  List<AndroidString> targetAndroidStrings=new ArrayList<AndroidString>();
  for (int i=0; i < sourceAndroidStrings.size(); i++) {
    AndroidString string=sourceAndroidStrings.get(i);
    AndroidString resultString=new AndroidString(string);
    if (!override) {
      String existenceValue=getAndroidStringValueInList(existenceAndroidStrings,resultString.getKey());
      if (existenceValue != null) {
        resultString.setValue(existenceValue);
      }
    }
    String translatedValue=getAndroidStringValueInList(translatedAndroidStrings,resultString.getKey());
    if (translatedValue != null) {
      resultString.setValue(translatedValue);
    }
    targetAndroidStrings.add(resultString);
  }
  Log.i(""String_Node_Str"" + sourceAndroidStrings);
  return targetAndroidStrings;
}"
93272,"public AndroidString(String key,String value){
  this.key=key;
  this.value=value;
}","public AndroidString(AndroidString androidString){
  this.key=androidString.getKey();
  this.value=androidString.getValue();
}"
93273,"/** 
 * @param querys
 * @param targetLanguageCode
 * @param sourceLanguageCode
 * @return
 */
public static List<String> getTranslationJSON(@NotNull List<String> querys,@NotNull SupportedLanguages targetLanguageCode,@NotNull SupportedLanguages sourceLanguageCode){
  if (querys.isEmpty())   return null;
  String query=""String_Node_Str"";
  for (int i=0; i < querys.size(); i++) {
    query+=(""String_Node_Str"" + URLEncoder.encode(querys.get(i)));
    if (i != querys.size() - 1) {
      query+=""String_Node_Str"";
    }
  }
  String url=null;
  try {
    url=String.format(BASE_TRANSLATION_URL,query,targetLanguageCode.getLanguageCode(),sourceLanguageCode.getLanguageCode(),PropertiesComponent.getInstance().getValue(StorageDataKey.GoogleApiKeyStored),""String_Node_Str"");
  }
 catch (  IllegalFormatException e) {
    e.printStackTrace();
  }
  if (url == null)   return null;
  String getResult=HttpUtils.doHttpGet(url);
  Log.i(""String_Node_Str"" + getResult);
  JsonObject jsonObject=new JsonParser().parse(getResult).getAsJsonObject();
  if (jsonObject.get(""String_Node_Str"") != null) {
    JsonObject error=jsonObject.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonArray().get(0).getAsJsonObject();
    if (error == null)     return null;
    if (error.get(""String_Node_Str"").getAsString().equals(""String_Node_Str""))     return new ArrayList<String>();
    return null;
  }
 else {
    JsonObject data=jsonObject.get(""String_Node_Str"").getAsJsonObject();
    JsonArray translations=data.get(""String_Node_Str"").getAsJsonArray();
    if (translations != null) {
      List<String> result=new ArrayList<String>();
      for (int i=0; i < translations.size(); i++) {
        result.add(translations.get(i).getAsJsonObject().get(""String_Node_Str"").getAsString());
      }
      return result;
    }
  }
  return null;
}","/** 
 * @param querys
 * @param targetLanguageCode
 * @param sourceLanguageCode
 * @return
 */
public static List<String> getTranslationJSON(@NotNull List<String> querys,@NotNull SupportedLanguages targetLanguageCode,@NotNull SupportedLanguages sourceLanguageCode){
  if (querys.isEmpty())   return null;
  String query=""String_Node_Str"";
  for (int i=0; i < querys.size(); i++) {
    query+=(""String_Node_Str"" + URLEncoder.encode(querys.get(i)));
    if (i != querys.size() - 1) {
      query+=""String_Node_Str"";
    }
  }
  String url=null;
  try {
    url=String.format(BASE_TRANSLATION_URL,query,targetLanguageCode.getLanguageCode(),sourceLanguageCode.getLanguageCode(),PropertiesComponent.getInstance().getValue(StorageDataKey.GoogleApiKeyStored),""String_Node_Str"");
  }
 catch (  IllegalFormatException e) {
    e.printStackTrace();
  }
  if (url == null)   return null;
  String getResult=HttpUtils.doHttpGet(url);
  JsonObject jsonObject=new JsonParser().parse(getResult).getAsJsonObject();
  if (jsonObject.get(""String_Node_Str"") != null) {
    JsonObject error=jsonObject.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonArray().get(0).getAsJsonObject();
    if (error == null)     return null;
    if (error.get(""String_Node_Str"").getAsString().equals(""String_Node_Str""))     return new ArrayList<String>();
    return null;
  }
 else {
    JsonObject data=jsonObject.get(""String_Node_Str"").getAsJsonObject();
    JsonArray translations=data.get(""String_Node_Str"").getAsJsonArray();
    if (translations != null) {
      List<String> result=new ArrayList<String>();
      for (int i=0; i < translations.size(); i++) {
        result.add(translations.get(i).getAsJsonObject().get(""String_Node_Str"").getAsString());
      }
      return result;
    }
  }
  return null;
}"
93274,"public static void i(String... params){
  if (params == null)   return;
  String out=""String_Node_Str"";
  for (int i=0; i < params.length; i++) {
    out+=params[i] + ""String_Node_Str"";
  }
  System.out.println(out);
}","public static void i(Object... params){
  if (params == null)   return;
  String out=""String_Node_Str"";
  for (int i=0; i < params.length; i++) {
    out+=params[i].toString() + ""String_Node_Str"";
  }
  System.out.println(out);
}"
93275,"private List<AndroidString> getTranslationEngineResult(@NotNull List<AndroidString> needToTranslatedString,@NotNull SupportedLanguages targetLanguageCode,@NotNull SupportedLanguages sourceLanguageCode,TranslationEngineType translationEngineType){
  List<String> querys=AndroidString.getAndroidStringValues(needToTranslatedString);
  List<String> result=null;
switch (translationEngineType) {
case Bing:
    String accessToken=BingTranslationApi.getAccessToken();
  if (accessToken == null) {
    errorMsg=BingIdInvalid;
    return null;
  }
result=BingTranslationApi.getTranslatedStringArrays(accessToken,querys,sourceLanguageCode,targetLanguageCode);
if ((result == null || result.isEmpty()) && !querys.isEmpty()) {
errorMsg=BingQuotaExceeded;
return null;
}
break;
case Google:
result=GoogleTranslationApi.getTranslationJSON(querys,targetLanguageCode,sourceLanguageCode);
if (result == null) {
errorMsg=GoogleErrorUnknown;
return null;
}
 else if (result.isEmpty() && !querys.isEmpty()) {
errorMsg=GoogleDailyLimitError;
return null;
}
break;
}
List<AndroidString> translatedAndroidStrings=new ArrayList<AndroidString>();
for (int i=0; i < needToTranslatedString.size(); i++) {
translatedAndroidStrings.add(new AndroidString(needToTranslatedString.get(i).getKey(),result.get(i)));
}
return translatedAndroidStrings;
}","private List<AndroidString> getTranslationEngineResult(@NotNull List<AndroidString> needToTranslatedString,@NotNull SupportedLanguages targetLanguageCode,@NotNull SupportedLanguages sourceLanguageCode,TranslationEngineType translationEngineType){
  List<String> querys=AndroidString.getAndroidStringValues(needToTranslatedString);
  List<String> result=null;
switch (translationEngineType) {
case Bing:
    String accessToken=BingTranslationApi.getAccessToken();
  if (accessToken == null) {
    errorMsg=BingIdInvalid;
    return null;
  }
result=BingTranslationApi.getTranslatedStringArrays2(accessToken,querys,sourceLanguageCode,targetLanguageCode);
if ((result == null || result.isEmpty()) && !querys.isEmpty()) {
errorMsg=BingQuotaExceeded;
return null;
}
break;
case Google:
result=GoogleTranslationApi.getTranslationJSON(querys,targetLanguageCode,sourceLanguageCode);
if (result == null) {
errorMsg=GoogleErrorUnknown;
return null;
}
 else if (result.isEmpty() && !querys.isEmpty()) {
errorMsg=GoogleDailyLimitError;
return null;
}
break;
}
List<AndroidString> translatedAndroidStrings=new ArrayList<AndroidString>();
for (int i=0; i < needToTranslatedString.size(); i++) {
translatedAndroidStrings.add(new AndroidString(needToTranslatedString.get(i).getKey(),result.get(i)));
}
return translatedAndroidStrings;
}"
93276,"private List<List<AndroidString>> splitAndroidString(List<AndroidString> origin,TranslationEngineType engineType){
  List<List<AndroidString>> splited=new ArrayList<List<AndroidString>>();
  int splitFragment=100;
switch (engineType) {
case Bing:
    splitFragment=100;
  break;
case Google:
splitFragment=50;
break;
}
if (origin.size() <= splitFragment) {
splited.add(origin);
}
 else {
int count=(origin.size() % splitFragment == 0) ? (origin.size() / splitFragment) : (origin.size() / splitFragment + 1);
for (int i=1; i <= count; i++) {
int end=i * splitFragment;
if (end > origin.size()) {
end=origin.size();
}
splited.add(origin.subList((i - 1) * splitFragment,end));
}
}
return splited;
}","private List<List<AndroidString>> splitAndroidString(List<AndroidString> origin,TranslationEngineType engineType){
  List<List<AndroidString>> splited=new ArrayList<List<AndroidString>>();
  int splitFragment=50;
switch (engineType) {
case Bing:
    splitFragment=50;
  break;
case Google:
splitFragment=50;
break;
}
if (origin.size() <= splitFragment) {
splited.add(origin);
}
 else {
int count=(origin.size() % splitFragment == 0) ? (origin.size() / splitFragment) : (origin.size() / splitFragment + 1);
for (int i=1; i <= count; i++) {
int end=i * splitFragment;
if (end > origin.size()) {
end=origin.size();
}
splited.add(origin.subList((i - 1) * splitFragment,end));
}
}
return splited;
}"
93277,"public static String doHttpGet(String url){
  try {
    HttpClient httpClient=new DefaultHttpClient();
    HttpGet httpGet=new HttpGet(url);
    HttpResponse resp=httpClient.execute(httpGet);
    return StreamUtil.readText(resp.getEntity().getContent(),""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","public static String doHttpGet(String url,Header[] headers){
  try {
    HttpClient httpClient=new DefaultHttpClient();
    HttpGet httpGet=new HttpGet(url);
    httpGet.setHeaders(headers);
    HttpResponse resp=httpClient.execute(httpGet);
    return StreamUtil.readText(resp.getEntity().getContent(),""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}"
93278,"public static List<String> getTranslatedStringArrays(String accessToken,List<String> querys,SupportedLanguages from,SupportedLanguages to){
  String xmlBodyTop=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String xmlBodyMid=""String_Node_Str"";
  String xmlBodyBot=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String xmlBodyStrings=""String_Node_Str"";
  for (  String query : querys) {
    xmlBodyStrings+=String.format(xmlBodyMid,query);
  }
  String xmlBody=String.format(xmlBodyTop,from.getLanguageCode()) + xmlBodyStrings + String.format(xmlBodyBot,to.getLanguageCode());
  Header[] headers=new Header[]{new BasicHeader(""String_Node_Str"",""String_Node_Str"" + accessToken),new BasicHeader(""String_Node_Str"",""String_Node_Str"")};
  Log.i(""String_Node_Str"" + accessToken);
  Log.i(""String_Node_Str"" + xmlBody);
  String postResult=HttpUtils.doHttpPost(TRANSLATE_URL,xmlBody,headers);
  Log.i(""String_Node_Str"" + postResult);
  List<TranslateArrayResponse> translateArrayResponses=BingResultParser.parseTranslateArrayResponse(postResult);
  List<String> result=new ArrayList<String>();
  for (  TranslateArrayResponse translateArrayResponse : translateArrayResponses) {
    result.add(translateArrayResponse.getTranslatedText());
  }
  return result;
}","/** 
 * @deprecated using @getTranslatedStringArrays2 now
 */
public static List<String> getTranslatedStringArrays(String accessToken,List<String> querys,SupportedLanguages from,SupportedLanguages to){
  String xmlBodyTop=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String xmlBodyMid=""String_Node_Str"";
  String xmlBodyBot=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  String xmlBodyStrings=""String_Node_Str"";
  for (  String query : querys) {
    xmlBodyStrings+=String.format(xmlBodyMid,query);
  }
  String xmlBody=String.format(xmlBodyTop,from.getLanguageCode()) + xmlBodyStrings + String.format(xmlBodyBot,to.getLanguageCode());
  Header[] headers=new Header[]{new BasicHeader(""String_Node_Str"",""String_Node_Str"" + accessToken),new BasicHeader(""String_Node_Str"",""String_Node_Str"")};
  Log.i(""String_Node_Str"" + accessToken);
  Log.i(""String_Node_Str"" + xmlBody);
  String postResult=HttpUtils.doHttpPost(TRANSLATE_URL,xmlBody,headers);
  Log.i(""String_Node_Str"" + postResult);
  List<TranslateArrayResponse> translateArrayResponses=BingResultParser.parseTranslateArrayResponse(postResult);
  List<String> result=new ArrayList<String>();
  for (  TranslateArrayResponse translateArrayResponse : translateArrayResponses) {
    result.add(translateArrayResponse.getTranslatedText());
  }
  return result;
}"
93279,"private static List<AndroidString> getTargetAndroidStrings(List<AndroidString> sourceAndroidStrings,List<AndroidString> translatedAndroidStrings,String fileName,boolean override){
  VirtualFile existenceFile=LocalFileSystem.getInstance().findFileByPath(fileName);
  List<AndroidString> existenceAndroidStrings=null;
  if (existenceFile != null && !override) {
    try {
      existenceAndroidStrings=AndroidString.getAndroidStringsList(existenceFile.contentsToByteArray());
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 else {
    existenceAndroidStrings=new ArrayList<AndroidString>();
  }
  Log.i(""String_Node_Str"" + sourceAndroidStrings,""String_Node_Str"" + translatedAndroidStrings,""String_Node_Str"" + existenceAndroidStrings);
  List<AndroidString> targetAndroidStrings=new ArrayList<AndroidString>(sourceAndroidStrings);
  for (  AndroidString androidString : targetAndroidStrings) {
    if (!override) {
      String existenceValue=getAndroidStringValueInList(existenceAndroidStrings,androidString.getKey());
      if (existenceValue != null) {
        androidString.setValue(existenceValue);
      }
    }
    String translatedValue=getAndroidStringValueInList(translatedAndroidStrings,androidString.getKey());
    if (translatedValue != null) {
      androidString.setValue(translatedValue);
    }
  }
  Log.i(""String_Node_Str"" + targetAndroidStrings);
  return targetAndroidStrings;
}","private static List<AndroidString> getTargetAndroidStrings(List<AndroidString> sourceAndroidStrings,List<AndroidString> translatedAndroidStrings,String fileName,boolean override){
  VirtualFile existenceFile=LocalFileSystem.getInstance().findFileByPath(fileName);
  List<AndroidString> existenceAndroidStrings=null;
  if (existenceFile != null && !override) {
    try {
      existenceAndroidStrings=AndroidString.getAndroidStringsList(existenceFile.contentsToByteArray());
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 else {
    existenceAndroidStrings=new ArrayList<AndroidString>();
  }
  Log.i(""String_Node_Str"" + sourceAndroidStrings,""String_Node_Str"" + translatedAndroidStrings,""String_Node_Str"" + existenceAndroidStrings);
  List<AndroidString> targetAndroidStrings=new ArrayList<AndroidString>(sourceAndroidStrings);
  for (  AndroidString androidString : targetAndroidStrings) {
    Log.i(""String_Node_Str"" + sourceAndroidStrings);
    if (!override) {
      String existenceValue=getAndroidStringValueInList(existenceAndroidStrings,androidString.getKey());
      if (existenceValue != null) {
        androidString.setValue(existenceValue);
      }
    }
    String translatedValue=getAndroidStringValueInList(translatedAndroidStrings,androidString.getKey());
    if (translatedValue != null) {
      androidString.setValue(translatedValue);
    }
    Log.i(""String_Node_Str"" + sourceAndroidStrings);
  }
  Log.i(""String_Node_Str"" + sourceAndroidStrings,""String_Node_Str"" + targetAndroidStrings);
  return targetAndroidStrings;
}"
93280,"private List<AndroidString> filterAndroidString(List<AndroidString> origin,SupportedLanguages language,boolean override){
  List<AndroidString> result=new ArrayList<AndroidString>();
  VirtualFile targetStringFile=LocalFileSystem.getInstance().findFileByPath(getValueResourcePath(language));
  List<AndroidString> targetAndroidStrings=new ArrayList<AndroidString>();
  if (targetStringFile != null) {
    try {
      targetAndroidStrings=AndroidString.getAndroidStringsList(targetStringFile.contentsToByteArray());
    }
 catch (    IOException e1) {
      e1.printStackTrace();
    }
  }
  for (  AndroidString androidString : origin) {
    if (androidString.getKey().startsWith(Key.NO_NEED_TRANSLATION_ANDROID_STRING_PREFIX))     continue;
    if (!override && !targetAndroidStrings.isEmpty()) {
      if (isAndroidStringListContainsKey(targetAndroidStrings,androidString.getKey())) {
        continue;
      }
    }
    result.add(androidString);
  }
  return result;
}","private List<AndroidString> filterAndroidString(List<AndroidString> origin,SupportedLanguages language,boolean override){
  List<AndroidString> result=new ArrayList<AndroidString>();
  VirtualFile targetStringFile=LocalFileSystem.getInstance().findFileByPath(getValueResourcePath(language));
  List<AndroidString> targetAndroidStrings=new ArrayList<AndroidString>();
  if (targetStringFile != null) {
    try {
      targetAndroidStrings=AndroidString.getAndroidStringsList(targetStringFile.contentsToByteArray());
    }
 catch (    IOException e1) {
      e1.printStackTrace();
    }
  }
  String rulesString=PropertiesComponent.getInstance().getValue(StorageDataKey.SettingFilterRules);
  List<FilterRule> filterRules=new ArrayList<FilterRule>();
  if (rulesString == null) {
    filterRules.add(FilterRule.DefaultFilterRule);
  }
 else {
    filterRules=SerializeUtil.deserializeFilterRuleList(rulesString);
  }
  for (  AndroidString androidString : origin) {
    if (FilterRule.inFilterRule(androidString.getKey(),filterRules))     continue;
    if (!override && !targetAndroidStrings.isEmpty()) {
      if (isAndroidStringListContainsKey(targetAndroidStrings,androidString.getKey())) {
        continue;
      }
    }
    result.add(androidString);
  }
  return result;
}"
93281,"/** 
 * Finds the segments of a line along which a name can be drawn and then adds WayTextContainers to the list of drawable items.
 * @param upperLeft     the tile in the upper left corner of the drawing pane
 * @param lowerRight    the tile in the lower right corner of the drawing pane
 * @param text          the text to draw
 * @param priority      priority of the text
 * @param dy            if 0, then a line  parallel to the coordinates will be calculated first
 * @param fill          fill paint for text
 * @param stroke        stroke paint for text
 * @param coordinates   the list of way coordinates
 * @param currentLabels the list of labels to which a new WayTextContainer will be added
 */
static void renderText(Tile upperLeft,Tile lowerRight,String text,Display display,int priority,float dy,Paint fill,Paint stroke,boolean repeat,float repeatGap,float repeatStart,boolean rotate,Point[][] coordinates,List<MapElementContainer> currentLabels){
  int wayNameWidth=(stroke == null) ? fill.getTextWidth(text) + (int)repeatStart : stroke.getTextWidth(text) + (int)repeatStart;
  double textHeight=(stroke == null) ? fill.getTextHeight(text) : stroke.getTextHeight(text);
  final Rectangle tileBoundary=Tile.getBoundaryAbsolute(upperLeft,lowerRight);
  int skipPixels=0;
  Point[] c;
  if (dy == 0f) {
    c=coordinates[0];
  }
 else {
    c=RendererUtils.parallelPath(coordinates[0],dy);
  }
  for (int i=1; i < c.length; ++i) {
    LineSegment currentSegment=new LineSegment(c[i - 1],c[i]);
    double currentLength=currentSegment.length();
    skipPixels-=currentLength;
    if (skipPixels > 0) {
      continue;
    }
    if (currentLength < wayNameWidth) {
      continue;
    }
    LineSegment drawableSegment=currentSegment.clipToRectangle(tileBoundary);
    if (drawableSegment == null) {
      continue;
    }
    double segmentLengthInPixel=drawableSegment.length();
    if (segmentLengthInPixel < wayNameWidth) {
      continue;
    }
    double offset=(segmentLengthInPixel - wayNameWidth) / 2d;
    LineSegment actuallyUsedSegment=drawableSegment.subSegment(offset,wayNameWidth - repeatStart);
    if (actuallyUsedSegment.start.x <= actuallyUsedSegment.end.x) {
      currentLabels.add(new WayTextContainer(actuallyUsedSegment.start,actuallyUsedSegment.end,display,priority,text,fill,stroke,textHeight));
    }
 else {
      currentLabels.add(new WayTextContainer(actuallyUsedSegment.end,actuallyUsedSegment.start,display,priority,text,fill,stroke,textHeight));
    }
    if (!repeat) {
      break;
    }
    skipPixels=(int)repeatGap;
  }
}","/** 
 * Finds the segments of a line along which a name can be drawn and then adds WayTextContainers to the list of drawable items.
 * @param upperLeft     the tile in the upper left corner of the drawing pane
 * @param lowerRight    the tile in the lower right corner of the drawing pane
 * @param text          the text to draw
 * @param priority      priority of the text
 * @param dy            if 0, then a line  parallel to the coordinates will be calculated first
 * @param fill          fill paint for text
 * @param stroke        stroke paint for text
 * @param coordinates   the list of way coordinates
 * @param currentLabels the list of labels to which a new WayTextContainer will be added
 */
static void renderText(Tile upperLeft,Tile lowerRight,String text,Display display,int priority,float dy,Paint fill,Paint stroke,boolean repeat,float repeatGap,float repeatStart,boolean rotate,Point[][] coordinates,List<MapElementContainer> currentLabels){
  int wayNameWidth=(stroke == null) ? fill.getTextWidth(text) + (int)repeatStart : stroke.getTextWidth(text) + (int)repeatStart;
  double textHeight=(stroke == null) ? fill.getTextHeight(text) : stroke.getTextHeight(text);
  final Rectangle tileBoundary=Tile.getBoundaryAbsolute(upperLeft,lowerRight);
  int skipPixels=0;
  Point[] c;
  if (dy == 0f) {
    c=coordinates[0];
  }
 else {
    c=RendererUtils.parallelPath(coordinates[0],dy);
  }
  for (int i=1; i < c.length; ++i) {
    LineSegment currentSegment=new LineSegment(c[i - 1],c[i]);
    double currentLength=currentSegment.length();
    skipPixels-=currentLength;
    if (skipPixels > 0) {
      continue;
    }
    if (currentLength < wayNameWidth) {
      continue;
    }
    LineSegment drawableSegment=currentSegment.clipToRectangle(tileBoundary);
    if (drawableSegment == null) {
      continue;
    }
    double segmentLengthInPixel=drawableSegment.length();
    if (segmentLengthInPixel < wayNameWidth) {
      continue;
    }
    double offset=(segmentLengthInPixel - wayNameWidth) / 2d;
    LineSegment actuallyUsedSegment=drawableSegment.subSegment(offset + repeatStart / 2,wayNameWidth - repeatStart);
    if (actuallyUsedSegment.start.x <= actuallyUsedSegment.end.x) {
      currentLabels.add(new WayTextContainer(actuallyUsedSegment.start,actuallyUsedSegment.end,display,priority,text,fill,stroke,textHeight));
    }
 else {
      currentLabels.add(new WayTextContainer(actuallyUsedSegment.end,actuallyUsedSegment.start,display,priority,text,fill,stroke,textHeight));
    }
    if (!repeat) {
      break;
    }
    skipPixels=(int)repeatGap;
  }
}"
93282,"/** 
 * Computes a Point along the line segment with a given distance to the start Point.
 * @param distance distance from start point
 * @return point at given distance from start point
 */
public Point pointAlongLineSegment(double distance){
  if (start.x == end.x) {
    return new Point(start.x,start.y + distance);
  }
 else {
    double slope=(end.y - start.y) / (end.x - start.x);
    double dx=Math.sqrt((distance * distance) / (1 + (slope * slope)));
    if (end.x < start.x) {
      dx*=-1;
    }
    return new Point(start.x + dx,start.y + slope * dx);
  }
}","/** 
 * Computes a Point along the line segment with a given distance to the start Point.
 * @param distance distance from start point
 * @return point at given distance from start point
 */
public Point pointAlongLineSegment(double distance){
  if (start.x == end.x) {
    if (start.y > end.y) {
      return new Point(end.x,end.y + distance);
    }
 else {
      return new Point(start.x,start.y + distance);
    }
  }
 else {
    double slope=(end.y - start.y) / (end.x - start.x);
    double dx=Math.sqrt((distance * distance) / (1 + (slope * slope)));
    if (end.x < start.x) {
      dx*=-1;
    }
    return new Point(start.x + dx,start.y + slope * dx);
  }
}"
93283,"@Test public void getBoundingBoxTest(){
  Tile tile1=new Tile(0,0,(byte)0,TILE_SIZE);
  Assert.assertTrue(tile1.getBoundingBox().equals(new BoundingBox(MercatorProjection.LATITUDE_MIN,-180,MercatorProjection.LATITUDE_MAX,180)));
  Tile tile2=new Tile(0,0,(byte)1,TILE_SIZE);
  Assert.assertEquals(tile1.getBoundingBox().maxLatitude,tile2.getBoundingBox().maxLatitude,0.0001);
  Assert.assertEquals(tile1.getBoundingBox().minLongitude,tile2.getBoundingBox().minLongitude,0.0001);
  Tile tile3=new Tile(1,1,(byte)1,TILE_SIZE);
  Assert.assertEquals(tile1.getBoundingBox().minLatitude,tile3.getBoundingBox().minLatitude,0.0001);
  Assert.assertNotEquals(tile1.getBoundingBox().minLongitude,tile3.getBoundingBox().minLongitude,0.0001);
  Assert.assertEquals(tile3.getBoundingBox().minLongitude,0,0.0001);
  Assert.assertEquals(tile3.getBoundingBox().maxLongitude,180,0.0001);
  Tile tile4=new Tile(0,0,(byte)12,TILE_SIZE);
  Assert.assertEquals(tile1.getBoundingBox().maxLatitude,tile4.getBoundingBox().maxLatitude,0.0001);
  Assert.assertEquals(tile1.getBoundingBox().minLongitude,tile4.getBoundingBox().minLongitude,0.0001);
  Tile tile5=new Tile(0,0,(byte)24,TILE_SIZE);
  Assert.assertEquals(tile1.getBoundingBox().maxLatitude,tile5.getBoundingBox().maxLatitude,0.0001);
  Assert.assertEquals(tile1.getBoundingBox().minLongitude,tile5.getBoundingBox().minLongitude,0.0001);
}","@Test public void getBoundingBoxTest(){
  for (byte zoom=(byte)0; zoom < 25; zoom++) {
    Tile tile1=new Tile(0,0,zoom,TILE_SIZE);
    if (zoom == 0) {
      Assert.assertTrue(tile1.getBoundingBox().equals(new BoundingBox(MercatorProjection.LATITUDE_MIN,-180,MercatorProjection.LATITUDE_MAX,180)));
    }
    Tile tile2=new Tile(0,0,zoom,TILE_SIZE);
    Assert.assertEquals(tile1.getBoundingBox().maxLatitude,tile2.getBoundingBox().maxLatitude,0.0001);
    Assert.assertEquals(tile1.getBoundingBox().minLongitude,tile2.getBoundingBox().minLongitude,0.0001);
    if (zoom >= 1) {
      Tile tile3=new Tile(1,1,zoom,TILE_SIZE);
      Assert.assertEquals(tile1.getBelow().getBoundingBox().minLatitude,tile3.getBoundingBox().minLatitude,0.0001);
      Assert.assertEquals(tile1.getRight().getBoundingBox().minLongitude,tile3.getBoundingBox().minLongitude,0.0001);
      if (zoom == 1) {
        Assert.assertEquals(tile3.getBoundingBox().minLongitude,0,0.0001);
        Assert.assertEquals(tile3.getBoundingBox().maxLongitude,180,0.0001);
      }
      Assert.assertEquals(tile3.getBoundingBox(),Tile.getBoundingBox(tile3,tile3));
    }
    Tile tile4=new Tile(0,0,zoom,TILE_SIZE);
    Assert.assertEquals(tile1.getBoundingBox().maxLatitude,tile4.getBoundingBox().maxLatitude,0.0001);
    Assert.assertEquals(tile1.getBoundingBox().minLongitude,tile4.getBoundingBox().minLongitude,0.0001);
    Tile tile5=new Tile(0,0,zoom,TILE_SIZE);
    Assert.assertEquals(tile1.getBoundingBox().maxLatitude,tile5.getBoundingBox().maxLatitude,0.0001);
    Assert.assertEquals(tile1.getBoundingBox().minLongitude,tile5.getBoundingBox().minLongitude,0.0001);
    Assert.assertEquals(tile1.getBoundingBox(),Tile.getBoundingBox(tile1,tile1));
    Assert.assertEquals(tile2.getBoundingBox(),Tile.getBoundingBox(tile2,tile2));
    Assert.assertEquals(tile4.getBoundingBox(),Tile.getBoundingBox(tile4,tile4));
    Assert.assertEquals(tile4.getBoundingBox(),Tile.getBoundingBox(tile5,tile5));
  }
}"
93284,"/** 
 * @return All child categories of the category or null if this category has no children.
 */
Collection<PoiCategory> getChildren();","/** 
 * @return All child categories of the category.
 */
Collection<PoiCategory> getChildren();"
93285,"public static String getSQLSelectString(PoiCategoryFilter filter){
  return SELECT_STATEMENT + getSQLWhereClauseString(filter) + ' '+ ""String_Node_Str"";
}","/** 
 * Gets the SQL query that looks up POI entries.
 * @param filter The filter object for determining all wanted categories.
 * @return The SQL query.
 */
public static String getSQLSelectString(PoiCategoryFilter filter){
  return SELECT_STATEMENT + getSQLWhereClauseString(filter) + ""String_Node_Str"";
}"
93286,"/** 
 * Gets the WHERE clause for the SQL query that looks up POI entries.
 * @param filter The filter object for determining all wanted categories.
 * @return A string like <code>WHERE id BETWEEN 2 AND 5 OR BETWEEN 10 AND 12</code>.
 */
private static String getSQLWhereClauseString(PoiCategoryFilter filter){
  int[] intervals=getCategoryIDIntervals(filter);
  if (intervals.length == 0) {
    return ""String_Node_Str"";
  }
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  for (int i=0; i < intervals.length; i+=2) {
    sb.append(""String_Node_Str"").append(intervals[i]).append(""String_Node_Str"").append(intervals[i + 1]);
    if (i != intervals.length - 2) {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(')');
  return sb.toString();
}","/** 
 * Gets the WHERE clause for the SQL query that looks up POI entries.
 * @param filter The filter object for determining all wanted categories.
 * @return The WHERE clause.
 */
private static String getSQLWhereClauseString(PoiCategoryFilter filter){
  Collection<PoiCategory> superCategories=filter.getAcceptedSuperCategories();
  if (superCategories.isEmpty()) {
    return ""String_Node_Str"";
  }
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  for (Iterator<PoiCategory> superCatIter=superCategories.iterator(); superCatIter.hasNext(); ) {
    PoiCategory superCat=superCatIter.next();
    Collection<PoiCategory> categories=superCat.deepChildren();
    categories.add(superCat);
    sb.append(""String_Node_Str"");
    for (Iterator<PoiCategory> catIter=categories.iterator(); catIter.hasNext(); ) {
      PoiCategory cat=catIter.next();
      sb.append(cat.getID());
      if (catIter.hasNext()) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(""String_Node_Str"");
    if (superCatIter.hasNext()) {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
93287,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
 else   if (!(obj instanceof Way)) {
    return false;
  }
  Way other=(Way)obj;
  if (this.layer != other.layer) {
    return false;
  }
 else   if (!this.tags.equals(other.tags)) {
    return false;
  }
 else   if (this.labelPosition == null && other.labelPosition != null) {
    return false;
  }
 else   if (this.labelPosition != null && this.labelPosition.equals(other.labelPosition)) {
    return false;
  }
 else   if (this.latLongs.length != other.latLongs.length) {
    return false;
  }
 else {
    for (int i=0; i < this.latLongs.length; i++) {
      if (this.latLongs[i].length != other.latLongs[i].length) {
        return false;
      }
 else {
        for (int j=0; j < this.latLongs[i].length; j++) {
          if (!latLongs[i][j].equals(other.latLongs[i][j])) {
            return false;
          }
        }
      }
    }
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
 else   if (!(obj instanceof Way)) {
    return false;
  }
  Way other=(Way)obj;
  if (this.layer != other.layer) {
    return false;
  }
 else   if (!this.tags.equals(other.tags)) {
    return false;
  }
 else   if (this.labelPosition == null && other.labelPosition != null) {
    return false;
  }
 else   if (this.labelPosition != null && !this.labelPosition.equals(other.labelPosition)) {
    return false;
  }
 else   if (this.latLongs.length != other.latLongs.length) {
    return false;
  }
 else {
    for (int i=0; i < this.latLongs.length; i++) {
      if (this.latLongs[i].length != other.latLongs[i].length) {
        return false;
      }
 else {
        for (int j=0; j < this.latLongs[i].length; j++) {
          if (!latLongs[i][j].equals(other.latLongs[i][j])) {
            return false;
          }
        }
      }
    }
  }
  return true;
}"
93288,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + layer;
  result=prime * result + tags.hashCode();
  result=prime * result + latLongs.hashCode();
  if (labelPosition != null) {
    result=prime * result + labelPosition.hashCode();
  }
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + layer;
  result=prime * result + tags.hashCode();
  result=prime * result + Arrays.deepHashCode(latLongs);
  if (labelPosition != null) {
    result=prime * result + labelPosition.hashCode();
  }
  return result;
}"
93289,"private static BoundingBox addLayers(MapView mapView,List<File> mapFiles,TileCache tileCache){
  Layers layers=mapView.getLayerManager().getLayers();
  BoundingBox result=null;
  for (  File mapFile : mapFiles) {
    TileRendererLayer tileRendererLayer=createTileRendererLayer(tileCache,mapView.getModel().mapViewPosition,true,true,mapFile);
    BoundingBox boundingBox=tileRendererLayer.getMapDataStore().boundingBox();
    result=result == null ? boundingBox : result.extend(boundingBox);
    layers.add(tileRendererLayer);
  }
  if (SHOW_DEBUG_LAYERS) {
    layers.add(new TileGridLayer(GRAPHIC_FACTORY,mapView.getModel().displayModel));
    layers.add(new TileCoordinatesLayer(GRAPHIC_FACTORY,mapView.getModel().displayModel));
  }
  return result;
}","private static BoundingBox addLayers(MapView mapView,List<File> mapFiles,TileCache[] tileCaches){
  Layers layers=mapView.getLayerManager().getLayers();
  BoundingBox result=null;
  for (int i=0; i < mapFiles.size(); i++) {
    File mapFile=mapFiles.get(i);
    tileCaches[i]=createTileCache(i);
    TileRendererLayer tileRendererLayer=createTileRendererLayer(tileCaches[i],mapView.getModel().mapViewPosition,true,true,mapFile);
    BoundingBox boundingBox=tileRendererLayer.getMapDataStore().boundingBox();
    result=result == null ? boundingBox : result.extend(boundingBox);
    layers.add(tileRendererLayer);
  }
  if (SHOW_DEBUG_LAYERS) {
    layers.add(new TileGridLayer(GRAPHIC_FACTORY,mapView.getModel().displayModel));
    layers.add(new TileCoordinatesLayer(GRAPHIC_FACTORY,mapView.getModel().displayModel));
  }
  return result;
}"
93290,"private static TileCache createTileCache(){
  TileCache firstLevelTileCache=new InMemoryTileCache(128);
  File cacheDirectory=new File(System.getProperty(""String_Node_Str""),""String_Node_Str"");
  TileCache secondLevelTileCache=new FileSystemTileCache(1024,cacheDirectory,GRAPHIC_FACTORY);
  return new TwoLevelTileCache(firstLevelTileCache,secondLevelTileCache);
}","private static TileCache createTileCache(int index){
  TileCache firstLevelTileCache=new InMemoryTileCache(128);
  File cacheDirectory=new File(System.getProperty(""String_Node_Str""),""String_Node_Str"" + index);
  TileCache secondLevelTileCache=new FileSystemTileCache(1024,cacheDirectory,GRAPHIC_FACTORY);
  return new TwoLevelTileCache(firstLevelTileCache,secondLevelTileCache);
}"
93291,"/** 
 * Starts the   {@code MapViewer}.
 * @param args command line args: expects the map files as multiple parameters.
 */
public static void main(String[] args){
  List<File> mapFiles=getMapFiles(args);
  MapView mapView=createMapView();
  TileCache tileCache=createTileCache();
  final BoundingBox boundingBox=addLayers(mapView,mapFiles,tileCache);
  PreferencesFacade preferencesFacade=new JavaUtilPreferences(Preferences.userNodeForPackage(MapViewer.class));
  final Model model=mapView.getModel();
  model.init(preferencesFacade);
  MainFrame mainFrame=new MainFrame();
  mainFrame.add(mapView);
  mainFrame.addWindowListener(new WindowCloseDialog(mainFrame,mapView,preferencesFacade,tileCache));
  mainFrame.setVisible(true);
  mainFrame.addWindowListener(new WindowAdapter(){
    @Override public void windowOpened(    WindowEvent e){
      byte zoomLevel=LatLongUtils.zoomForBounds(model.mapViewDimension.getDimension(),boundingBox,model.displayModel.getTileSize());
      model.mapViewPosition.setMapPosition(new MapPosition(boundingBox.getCenterPoint(),zoomLevel));
    }
  }
);
}","/** 
 * Starts the   {@code MapViewer}.
 * @param args command line args: expects the map files as multiple parameters.
 */
public static void main(String[] args){
  List<File> mapFiles=getMapFiles(args);
  MapView mapView=createMapView();
  TileCache[] tileCaches=new TileCache[mapFiles.size()];
  final BoundingBox boundingBox=addLayers(mapView,mapFiles,tileCaches);
  PreferencesFacade preferencesFacade=new JavaUtilPreferences(Preferences.userNodeForPackage(MapViewer.class));
  final Model model=mapView.getModel();
  model.init(preferencesFacade);
  MainFrame mainFrame=new MainFrame();
  mainFrame.add(mapView);
  mainFrame.addWindowListener(new WindowCloseDialog(mainFrame,mapView,preferencesFacade,tileCaches));
  mainFrame.setVisible(true);
  mainFrame.addWindowListener(new WindowAdapter(){
    @Override public void windowOpened(    WindowEvent e){
      byte zoomLevel=LatLongUtils.zoomForBounds(model.mapViewDimension.getDimension(),boundingBox,model.displayModel.getTileSize());
      model.mapViewPosition.setMapPosition(new MapPosition(boundingBox.getCenterPoint(),zoomLevel));
    }
  }
);
}"
93292,"@Override public void windowClosing(WindowEvent windowEvent){
  int result=JOptionPane.showConfirmDialog(this.jFrame,MESSAGE,TITLE,JOptionPane.YES_NO_OPTION);
  if (result == JOptionPane.YES_OPTION) {
    this.mapView.getModel().save(this.preferencesFacade);
    this.tileCache.destroy();
    this.mapView.destroy();
    this.jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
  }
}","@Override public void windowClosing(WindowEvent windowEvent){
  int result=JOptionPane.showConfirmDialog(this.jFrame,MESSAGE,TITLE,JOptionPane.YES_NO_OPTION);
  if (result == JOptionPane.YES_OPTION) {
    this.mapView.getModel().save(this.preferencesFacade);
    for (    TileCache tileCache : tileCaches) {
      tileCache.destroy();
    }
    this.mapView.destroy();
    this.jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
  }
}"
93293,"public WindowCloseDialog(JFrame jFrame,MapView mapView,PreferencesFacade preferencesFacade,TileCache tileCache){
  super();
  this.jFrame=jFrame;
  this.mapView=mapView;
  this.preferencesFacade=preferencesFacade;
  this.tileCache=tileCache;
  jFrame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
}","public WindowCloseDialog(JFrame jFrame,MapView mapView,PreferencesFacade preferencesFacade,TileCache[] tileCaches){
  super();
  this.jFrame=jFrame;
  this.mapView=mapView;
  this.preferencesFacade=preferencesFacade;
  this.tileCaches=tileCaches;
  jFrame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
}"
93294,"private static android.graphics.Bitmap getTileBitmapFromReusableSet(int tileSize,boolean isTransparent){
  int hash=composeHash(tileSize,isTransparent);
  Set<SoftReference<Bitmap>> subSet=reusableTileBitmaps.get(hash);
  if (subSet == null) {
    return null;
  }
  android.graphics.Bitmap bitmap=null;
synchronized (subSet) {
    final Iterator<SoftReference<android.graphics.Bitmap>> iterator=subSet.iterator();
    android.graphics.Bitmap candidate;
    while (iterator.hasNext()) {
      candidate=iterator.next().get();
      if (null != candidate && candidate.isMutable()) {
        bitmap=candidate;
        if (isTransparent) {
          bitmap.eraseColor(android.graphics.Color.TRANSPARENT);
        }
        iterator.remove();
        break;
      }
 else {
        iterator.remove();
      }
    }
  }
  return bitmap;
}","private static android.graphics.Bitmap getTileBitmapFromReusableSet(int tileSize,boolean isTransparent){
  int hash=composeHash(tileSize,isTransparent);
synchronized (reusableTileBitmaps) {
    Set<SoftReference<Bitmap>> subSet=reusableTileBitmaps.get(hash);
    if (subSet == null) {
      return null;
    }
    android.graphics.Bitmap bitmap=null;
    final Iterator<SoftReference<android.graphics.Bitmap>> iterator=subSet.iterator();
    android.graphics.Bitmap candidate;
    while (iterator.hasNext()) {
      candidate=iterator.next().get();
      if (null != candidate && candidate.isMutable()) {
        bitmap=candidate;
        if (isTransparent) {
          bitmap.eraseColor(android.graphics.Color.TRANSPARENT);
        }
        iterator.remove();
        break;
      }
 else {
        iterator.remove();
      }
    }
    return bitmap;
  }
}"
93295,"@Override protected void destroyBitmap(){
  if (this.bitmap != null) {
    if (AndroidUtil.HONEYCOMB_PLUS) {
      final int tileSize=this.getHeight();
synchronized (reusableTileBitmaps) {
        int hash=composeHash(tileSize,this.bitmap.hasAlpha());
        if (!reusableTileBitmaps.containsKey(hash)) {
          reusableTileBitmaps.put(hash,new HashSet<SoftReference<Bitmap>>());
        }
        Set<SoftReference<Bitmap>> sizeSpecificSet=reusableTileBitmaps.get(hash);
synchronized (sizeSpecificSet) {
          sizeSpecificSet.add(new SoftReference<Bitmap>(this.bitmap));
        }
      }
    }
 else {
      this.bitmap.recycle();
    }
    this.bitmap=null;
  }
}","@Override protected void destroyBitmap(){
  if (this.bitmap != null) {
    if (AndroidUtil.HONEYCOMB_PLUS) {
      final int tileSize=this.getHeight();
synchronized (reusableTileBitmaps) {
        int hash=composeHash(tileSize,this.bitmap.hasAlpha());
        if (!reusableTileBitmaps.containsKey(hash)) {
          reusableTileBitmaps.put(hash,new HashSet<SoftReference<Bitmap>>());
        }
        Set<SoftReference<Bitmap>> sizeSpecificSet=reusableTileBitmaps.get(hash);
        sizeSpecificSet.add(new SoftReference<Bitmap>(this.bitmap));
      }
    }
 else {
      this.bitmap.recycle();
    }
    this.bitmap=null;
  }
}"
93296,"public synchronized void add(T job){
  if (!this.assignedJobs.contains(job)) {
    QueueItem<T> queueItem=new QueueItem<T>(job);
    if (!this.queueItems.contains(queueItem)) {
      this.queueItems.add(queueItem);
      this.scheduleNeeded=true;
    }
  }
}","public synchronized void add(T job){
  if (!this.assignedJobs.contains(job)) {
    QueueItem<T> queueItem=new QueueItem<T>(job);
    if (!this.queueItems.contains(queueItem)) {
      this.queueItems.add(queueItem);
      this.scheduleNeeded=true;
      this.notifyWorkers();
    }
  }
}"
93297,"/** 
 * Returns the most important entry from this queue. The method blocks while this queue is empty or while there are already a certain number of jobs assigned.
 * @param maxAssigned the maximum number of jobs that should be assigned at any one point. If thereare already so many jobs assigned, the queue will block. This is to ensure that the scheduling will continue to work.
 */
public synchronized T get(int maxAssigned) throws InterruptedException {
  while (this.queueItems.isEmpty() || this.assignedJobs.size() >= maxAssigned) {
    this.wait();
  }
  if (this.scheduleNeeded) {
    this.scheduleNeeded=false;
    schedule(displayModel.getTileSize());
  }
  T job=this.queueItems.remove(0).object;
  this.assignedJobs.add(job);
  return job;
}","/** 
 * Returns the most important entry from this queue. The method blocks while this queue is empty or while there are already a certain number of jobs assigned.
 * @param maxAssigned the maximum number of jobs that should be assigned at any one point. If thereare already so many jobs assigned, the queue will block. This is to ensure that the scheduling will continue to work.
 */
public synchronized T get(int maxAssigned) throws InterruptedException {
  while (this.queueItems.isEmpty() || this.assignedJobs.size() >= maxAssigned) {
    this.wait(200);
  }
  if (this.scheduleNeeded) {
    this.scheduleNeeded=false;
    schedule(displayModel.getTileSize());
  }
  T job=this.queueItems.remove(0).object;
  this.assignedJobs.add(job);
  return job;
}"
93298,"/** 
 * Determines whether a File instance refers to a valid cache directory. <p> This method checks that   {@code file} refers to a directory to which the current process has read and writeaccess. If the directory does not exist, it will be created.
 * @param file The File instance to examine. This can be null, which will cause the method to return  {@code false}.
 */
private static boolean isValidCacheDirectory(File file){
  if ((file == null) || (!file.exists() && !file.mkdirs()) || !file.isDirectory()|| !file.canRead()|| !file.canWrite()) {
    return false;
  }
  return true;
}","/** 
 * Determines whether a File instance refers to a valid cache directory. <p> This method checks that   {@code file} refers to a directory to which the current process has read and writeaccess. If the directory does not exist, it will be created.
 * @param file The File instance to examine. This can be null, which will cause the method to return  {@code false}.
 */
private static boolean isValidCacheDirectory(File file){
  return !((file == null) || (!file.exists() && !file.mkdirs()) || !file.isDirectory()|| !file.canRead()|| !file.canWrite());
}"
93299,"protected File findFile(Job key){
  File l1=new File(this.rootDirectory,Byte.toString(key.tile.zoomLevel));
  if (l1 == null || !l1.isDirectory() || !l1.canRead()) {
    LOGGER.info(""String_Node_Str"" + l1.getAbsolutePath());
    return null;
  }
  File l2=new File(l1,Long.toString(key.tile.tileX));
  if (l2 == null || !l2.isDirectory() || !l2.canRead()) {
    LOGGER.info(""String_Node_Str"" + l2.getAbsolutePath());
    return null;
  }
  File l3=new File(l2,Long.toString(key.tile.tileY) + this.suffix);
  if (l3 == null || !l3.isFile() || !l3.canRead()) {
    LOGGER.info(""String_Node_Str"" + l3.getAbsolutePath());
    return null;
  }
  LOGGER.info(""String_Node_Str"" + l3.getAbsolutePath());
  return l3;
}","File findFile(Job key){
  File l1=new File(this.rootDirectory,Byte.toString(key.tile.zoomLevel));
  if (!l1.isDirectory() || !l1.canRead()) {
    LOGGER.info(""String_Node_Str"" + l1.getAbsolutePath());
    return null;
  }
  File l2=new File(l1,Long.toString(key.tile.tileX));
  if (!l2.isDirectory() || !l2.canRead()) {
    LOGGER.info(""String_Node_Str"" + l2.getAbsolutePath());
    return null;
  }
  File l3=new File(l2,Long.toString(key.tile.tileY) + this.suffix);
  if (!l3.isFile() || !l3.canRead()) {
    LOGGER.info(""String_Node_Str"" + l3.getAbsolutePath());
    return null;
  }
  LOGGER.info(""String_Node_Str"" + l3.getAbsolutePath());
  return l3;
}"
93300,"@Override public boolean containsKey(Job key){
  if (this.firstLevelTileCache.containsKey(key)) {
    return true;
  }
  return this.secondLevelTileCache.containsKey(key);
}","@Override public boolean containsKey(Job key){
  return this.firstLevelTileCache.containsKey(key) || this.secondLevelTileCache.containsKey(key);
}"
93301,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
 else   if (!super.equals(obj)) {
    return false;
  }
 else   if (!(obj instanceof DownloadJob)) {
    return false;
  }
  DownloadJob other=(DownloadJob)obj;
  if (!this.tileSource.equals(other.tileSource)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
 else   if (!super.equals(obj)) {
    return false;
  }
 else   if (!(obj instanceof DownloadJob)) {
    return false;
  }
  DownloadJob other=(DownloadJob)obj;
  return this.tileSource.equals(other.tileSource);
}"
93302,"@Override public synchronized void setDisplayModel(DisplayModel displayModel){
  super.setDisplayModel(displayModel);
  int numberOfDownloadThreads=Math.min(tileSource.getParallelRequestsLimit(),DOWNLOAD_THREADS_MAX);
  if (this.displayModel != null) {
    this.tileDownloadThreads=new TileDownloadThread[numberOfDownloadThreads];
    for (int i=0; i < numberOfDownloadThreads; ++i) {
      this.tileDownloadThreads[i]=new TileDownloadThread(this.tileCache,this.jobQueue,this,this.graphicFactory,this.displayModel);
    }
  }
 else {
    if (this.tileDownloadThreads != null) {
      for (int i=0; i < tileDownloadThreads.length; ++i) {
        this.tileDownloadThreads[i].interrupt();
      }
    }
  }
}","@Override public synchronized void setDisplayModel(DisplayModel displayModel){
  super.setDisplayModel(displayModel);
  int numberOfDownloadThreads=Math.min(tileSource.getParallelRequestsLimit(),DOWNLOAD_THREADS_MAX);
  if (this.displayModel != null) {
    this.tileDownloadThreads=new TileDownloadThread[numberOfDownloadThreads];
    for (int i=0; i < numberOfDownloadThreads; ++i) {
      this.tileDownloadThreads[i]=new TileDownloadThread(this.tileCache,this.jobQueue,this,this.graphicFactory,this.displayModel);
    }
  }
 else {
    if (this.tileDownloadThreads != null) {
      for (      final TileDownloadThread tileDownloadThread : tileDownloadThreads) {
        tileDownloadThread.interrupt();
      }
    }
  }
}"
93303,"/** 
 * Whether the tile is stale and should be refreshed. <p> This method is called from   {@link #draw(BoundingBox,byte,Canvas,Point)} to determine whether the tile needs tobe refreshed. <p> A tile is considered stale if one or more of the following two conditions apply: <ul> <li>The  {@code bitmap}'s   {@link org.mapsforge.core.graphics.TileBitmap#isExpired()} method returns {@code True}.</li> <li>The layer has a time-to-live (TTL) set (  {@link #getCacheTimeToLive()} returns a nonzero value) and the sum ofthe  {@code bitmap}'s   {@link org.mapsforge.core.graphics.TileBitmap#getTimestamp()} and TTL is less than currenttime (as returned by  {@link java.lang.System#currentTimeMillis()}).</li> </ul> <p> When a tile has become stale, the layer will first display the tile referenced by   {@code bitmap} and attempt toobtain a fresh copy in the background. When a fresh copy becomes available, the layer will replace it and update the cache. If a fresh copy cannot be obtained (e.g. because the tile is obtained from an online source which cannot be reached), the stale tile will continue to be used until another {@code #draw(BoundingBox, byte, Canvas, Point)} operation requests it again.
 * @param tile A tile. This parameter is not used for a  {@code TileDownloadLayer} and can be null.
 * @param bitmap The bitmap for  {@code tile} currently held in the layer's cache.
 */
@Override protected boolean isTileStale(Tile tile,TileBitmap bitmap){
  if (bitmap.isExpired())   return true;
  if (cacheTimeToLive == 0)   return false;
  return ((bitmap.getTimestamp() + cacheTimeToLive) < System.currentTimeMillis());
}","/** 
 * Whether the tile is stale and should be refreshed. <p> This method is called from   {@link #draw(BoundingBox,byte,Canvas,Point)} to determine whether the tile needs tobe refreshed. <p> A tile is considered stale if one or more of the following two conditions apply: <ul> <li>The  {@code bitmap}'s   {@link org.mapsforge.core.graphics.TileBitmap#isExpired()} method returns {@code True}.</li> <li>The layer has a time-to-live (TTL) set (  {@link #getCacheTimeToLive()} returns a nonzero value) and the sum ofthe  {@code bitmap}'s   {@link org.mapsforge.core.graphics.TileBitmap#getTimestamp()} and TTL is less than currenttime (as returned by  {@link java.lang.System#currentTimeMillis()}).</li> </ul> <p> When a tile has become stale, the layer will first display the tile referenced by   {@code bitmap} and attempt toobtain a fresh copy in the background. When a fresh copy becomes available, the layer will replace it and update the cache. If a fresh copy cannot be obtained (e.g. because the tile is obtained from an online source which cannot be reached), the stale tile will continue to be used until another {@code #draw(BoundingBox, byte, Canvas, Point)} operation requests it again.
 * @param tile A tile. This parameter is not used for a  {@code TileDownloadLayer} and can be null.
 * @param bitmap The bitmap for  {@code tile} currently held in the layer's cache.
 */
@Override protected boolean isTileStale(Tile tile,TileBitmap bitmap){
  if (bitmap.isExpired())   return true;
  return cacheTimeToLive != 0 && ((bitmap.getTimestamp() + cacheTimeToLive) < System.currentTimeMillis());
}"
93304,"@Override public URL getTileUrl(Tile tile) throws MalformedURLException {
  StringBuilder stringBuilder=new StringBuilder(32);
  stringBuilder.append(""String_Node_Str"");
  stringBuilder.append(tile.zoomLevel);
  stringBuilder.append('/');
  stringBuilder.append(tile.tileX);
  stringBuilder.append('/');
  stringBuilder.append(tile.tileY);
  stringBuilder.append(""String_Node_Str"");
  return new URL(PROTOCOL,getHostName(),this.port,stringBuilder.toString());
}","@Override public URL getTileUrl(Tile tile) throws MalformedURLException {
  return new URL(PROTOCOL,getHostName(),this.port,""String_Node_Str"" + tile.zoomLevel + '/'+ tile.tileX+ '/'+ tile.tileY+ ""String_Node_Str"");
}"
93305,"@Override public URL getTileUrl(Tile tile) throws MalformedURLException {
  StringBuilder stringBuilder=new StringBuilder(32);
  stringBuilder.append('/');
  stringBuilder.append(tile.zoomLevel);
  stringBuilder.append('/');
  stringBuilder.append(tile.tileX);
  stringBuilder.append('/');
  stringBuilder.append(tile.tileY);
  stringBuilder.append(""String_Node_Str"");
  return new URL(PROTOCOL,getHostName(),this.port,stringBuilder.toString());
}","@Override public URL getTileUrl(Tile tile) throws MalformedURLException {
  return new URL(PROTOCOL,getHostName(),this.port,""String_Node_Str"" + tile.zoomLevel + '/'+ tile.tileX+ '/'+ tile.tileY+ ""String_Node_Str"");
}"
93306,"/** 
 * Returns a version number, which changes every time an update is made to the LabelStore.
 * @return
 */
abstract int getVersion();","/** 
 * Returns a version number, which changes every time an update is made to the LabelStore.
 * @return the version number
 */
abstract int getVersion();"
93307,"/** 
 * Returns if a tile is in the current tile set and no data is stored for this tile.
 * @param tile the tile
 * @return
 */
public synchronized boolean requiresTile(Tile tile){
  return this.lastVisibleTileSet.contains(tile) && !this.containsKey(tile);
}","/** 
 * Returns if a tile is in the current tile set and no data is stored for this tile.
 * @param tile the tile
 * @return true if the tile is in the current tile set, but no data is stored for it.
 */
public synchronized boolean requiresTile(Tile tile){
  return this.lastVisibleTileSet.contains(tile) && !this.containsKey(tile);
}"
93308,"public static String composeKey(String z,String x,String y){
  return new StringBuilder().append(z).append(File.separatorChar).append(x).append(File.separatorChar).append(y).toString();
}","public static String composeKey(String z,String x,String y){
  return z + File.separatorChar + x+ File.separatorChar+ y;
}"
93309,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
 else   if (!(obj instanceof Job)) {
    return false;
  }
  Job other=(Job)obj;
  if (this.hasAlpha != other.hasAlpha) {
    return false;
  }
  return this.tile.equals(other.tile);
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
 else   if (!(obj instanceof Job)) {
    return false;
  }
  Job other=(Job)obj;
  return this.hasAlpha == other.hasAlpha && this.tile.equals(other.tile);
}"
93310,"private void drawShapePaintContainer(ShapePaintContainer shapePaintContainer,Tile tile){
  ShapeType shapeType=shapePaintContainer.shapeContainer.getShapeType();
switch (shapeType) {
case CIRCLE:
    drawCircleContainer(shapePaintContainer);
  return;
case POLYLINE:
PolylineContainer polylineContainer=(PolylineContainer)shapePaintContainer.shapeContainer;
drawPath(shapePaintContainer,polylineContainer.getCoordinatesRelativeToTile(),shapePaintContainer.dy);
return;
}
}","private void drawShapePaintContainer(ShapePaintContainer shapePaintContainer){
  ShapeType shapeType=shapePaintContainer.shapeContainer.getShapeType();
switch (shapeType) {
case CIRCLE:
    drawCircleContainer(shapePaintContainer);
  return;
case POLYLINE:
PolylineContainer polylineContainer=(PolylineContainer)shapePaintContainer.shapeContainer;
drawPath(shapePaintContainer,polylineContainer.getCoordinatesRelativeToTile(),shapePaintContainer.dy);
return;
}
}"
93311,"void drawWays(List<List<List<ShapePaintContainer>>> drawWays,Tile tile){
  int levelsPerLayer=drawWays.get(0).size();
  for (int layer=0, layers=drawWays.size(); layer < layers; ++layer) {
    List<List<ShapePaintContainer>> shapePaintContainers=drawWays.get(layer);
    for (int level=0; level < levelsPerLayer; ++level) {
      List<ShapePaintContainer> wayList=shapePaintContainers.get(level);
      for (int index=wayList.size() - 1; index >= 0; --index) {
        drawShapePaintContainer(wayList.get(index),tile);
      }
    }
  }
}","void drawWays(List<List<List<ShapePaintContainer>>> drawWays,Tile tile){
  int levelsPerLayer=drawWays.get(0).size();
  for (int layer=0, layers=drawWays.size(); layer < layers; ++layer) {
    List<List<ShapePaintContainer>> shapePaintContainers=drawWays.get(layer);
    for (int level=0; level < levelsPerLayer; ++level) {
      List<ShapePaintContainer> wayList=shapePaintContainers.get(level);
      for (int index=wayList.size() - 1; index >= 0; --index) {
        drawShapePaintContainer(wayList.get(index));
      }
    }
  }
}"
93312,"protected boolean renderBitmap(RenderContext renderContext){
  return !renderContext.renderTheme.hasMapBackgroundOutside() || this.mapDatabase.supportsTile(renderContext.rendererJob.tile);
}","boolean renderBitmap(RenderContext renderContext){
  return !renderContext.renderTheme.hasMapBackgroundOutside() || this.mapDatabase.supportsTile(renderContext.rendererJob.tile);
}"
93313,"/** 
 * Calculates the center of the minimum bounding rectangle for the given coordinates.
 * @param coordinates the coordinates for which calculation should be done.
 * @return the center coordinates of the minimum bounding rectangle.
 */
static LatLong calculateCenterOfBoundingBox(LatLong[] coordinates){
  double pointXMin=coordinates[0].longitude;
  double pointXMax=coordinates[0].longitude;
  double pointYMin=coordinates[0].latitude;
  double pointYMax=coordinates[0].latitude;
  for (int i=1; i < coordinates.length; ++i) {
    LatLong immutablePoint=coordinates[i];
    if (immutablePoint.longitude < pointXMin) {
      pointXMin=immutablePoint.longitude;
    }
 else     if (immutablePoint.longitude > pointXMax) {
      pointXMax=immutablePoint.longitude;
    }
    if (immutablePoint.latitude < pointYMin) {
      pointYMin=immutablePoint.latitude;
    }
 else     if (immutablePoint.latitude > pointYMax) {
      pointYMax=immutablePoint.latitude;
    }
  }
  return new LatLong((pointXMin + pointXMax) / 2,(pointYMax + pointYMin) / 2,true);
}","/** 
 * Calculates the center of the minimum bounding rectangle for the given coordinates.
 * @param coordinates the coordinates for which calculation should be done.
 * @return the center coordinates of the minimum bounding rectangle.
 */
static Point calculateCenterOfBoundingBox(Point[] coordinates){
  double pointXMin=coordinates[0].x;
  double pointXMax=coordinates[0].x;
  double pointYMin=coordinates[0].y;
  double pointYMax=coordinates[0].y;
  for (  Point immutablePoint : coordinates) {
    if (immutablePoint.x < pointXMin) {
      pointXMin=immutablePoint.x;
    }
 else     if (immutablePoint.x > pointXMax) {
      pointXMax=immutablePoint.x;
    }
    if (immutablePoint.y < pointYMin) {
      pointYMin=immutablePoint.y;
    }
 else     if (immutablePoint.y > pointYMax) {
      pointYMax=immutablePoint.y;
    }
  }
  return new Point((pointXMin + pointXMax) / 2,(pointYMax + pointYMin) / 2);
}"
93314,"/** 
 * Heuristic to determine from attributes if a way is likely to be an area. Determining what is an area is neigh impossible in OSM, this method inspects tag elements to give a likely answer. See http://wiki.openstreetmap.org/wiki/The_Future_of_Areas and http://wiki.openstreetmap.org/wiki/Way
 * @param way the way (which is assumed to be closed and have enough nodes to be an area)
 * @return true if tags indicate this is an area, otherwise false.
 */
public static boolean isArea(Way way){
  boolean result=true;
  if (way.getTags() != null) {
    for (    Tag tag : way.getTags()) {
      String key=tag.getKey().toLowerCase(Locale.ENGLISH);
      String value=tag.getValue().toLowerCase(Locale.ENGLISH);
      if (""String_Node_Str"".equals(key)) {
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return true;
        }
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return false;
        }
      }
      if (""String_Node_Str"".equals(key) || ""String_Node_Str"".equals(key) || ""String_Node_Str"".equals(key)) {
        result=false;
      }
    }
  }
  return result;
}","/** 
 * Heuristic to determine from attributes if a way is likely to be an area. Precondition for this call is that the first and last node of a way are the same, so that this method should only return false if it is known that the feature should not be an area even if the geometry is a polygon.  Determining what is an area is neigh impossible in OSM, this method inspects tag elements to give a likely answer. See http://wiki.openstreetmap.org/wiki/The_Future_of_Areas and http://wiki.openstreetmap.org/wiki/Way
 * @param way the way (which is assumed to be closed and have enough nodes to be an area)
 * @return true if tags indicate this is an area, otherwise false.
 */
public static boolean isArea(Way way){
  boolean result=true;
  if (way.getTags() != null) {
    for (    Tag tag : way.getTags()) {
      String key=tag.getKey().toLowerCase(Locale.ENGLISH);
      String value=tag.getValue().toLowerCase(Locale.ENGLISH);
      if (""String_Node_Str"".equals(key)) {
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return true;
        }
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return false;
        }
      }
      if (""String_Node_Str"".equals(key) || ""String_Node_Str"".equals(key)) {
        result=false;
      }
      if (""String_Node_Str"".equals(key)) {
        if (""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)) {
          return false;
        }
        return true;
      }
    }
  }
  return result;
}"
93315,"/** 
 * Creates a new TDWay from an osmosis way entity using the given NodeResolver.
 * @param way the way
 * @param resolver the resolver
 * @param preferredLanguage the preferred language or null if no preference
 * @return a new TDWay if it is valid, null otherwise
 */
public static TDWay fromWay(Way way,NodeResolver resolver,String preferredLanguage){
  if (way == null)   return null;
  SpecialTagExtractionResult ster=OSMUtils.extractSpecialFields(way,preferredLanguage);
  short[] knownWayTags=OSMUtils.extractKnownWayTags(way);
  if (way.getWayNodes().size() >= 2) {
    boolean validWay=true;
    TDNode[] waynodes=new TDNode[way.getWayNodes().size()];
    int i=0;
    for (    WayNode waynode : way.getWayNodes()) {
      waynodes[i]=resolver.getNode(waynode.getNodeId());
      if (waynodes[i] == null) {
        validWay=false;
        LOGGER.finer(""String_Node_Str"" + waynode.getNodeId() + ""String_Node_Str""+ way.getId());
      }
      i++;
    }
    if (validWay) {
      byte shape=LINE;
      if (waynodes[0].getId() == waynodes[waynodes.length - 1].getId()) {
        if (waynodes.length >= GeoUtils.MIN_NODES_POLYGON && OSMUtils.isArea(way)) {
          shape=SIMPLE_POLYGON;
        }
 else {
          LOGGER.finer(""String_Node_Str"" + way.getId());
          return null;
        }
      }
      return new TDWay(way.getId(),ster.getLayer(),ster.getName(),ster.getHousenumber(),ster.getRef(),knownWayTags,shape,waynodes);
    }
  }
  return null;
}","/** 
 * Creates a new TDWay from an osmosis way entity using the given NodeResolver.
 * @param way the way
 * @param resolver the resolver
 * @param preferredLanguage the preferred language or null if no preference
 * @return a new TDWay if it is valid, null otherwise
 */
public static TDWay fromWay(Way way,NodeResolver resolver,String preferredLanguage){
  if (way == null)   return null;
  SpecialTagExtractionResult ster=OSMUtils.extractSpecialFields(way,preferredLanguage);
  short[] knownWayTags=OSMUtils.extractKnownWayTags(way);
  if (way.getWayNodes().size() >= 2) {
    boolean validWay=true;
    TDNode[] waynodes=new TDNode[way.getWayNodes().size()];
    int i=0;
    for (    WayNode waynode : way.getWayNodes()) {
      waynodes[i]=resolver.getNode(waynode.getNodeId());
      if (waynodes[i] == null) {
        validWay=false;
        LOGGER.finer(""String_Node_Str"" + waynode.getNodeId() + ""String_Node_Str""+ way.getId());
      }
      i++;
    }
    if (validWay) {
      byte shape=LINE;
      if (waynodes[0].getId() == waynodes[waynodes.length - 1].getId()) {
        if (waynodes.length >= GeoUtils.MIN_NODES_POLYGON) {
          if (OSMUtils.isArea(way)) {
            shape=SIMPLE_POLYGON;
          }
        }
 else {
          LOGGER.finer(""String_Node_Str"" + way.getId());
          return null;
        }
      }
      return new TDWay(way.getId(),ster.getLayer(),ster.getName(),ster.getHousenumber(),ster.getRef(),knownWayTags,shape,waynodes);
    }
  }
  return null;
}"
93316,"/** 
 * Heuristic to determine from attributes if a way is likely to be an area. Precondition for this call is that the first and last node of a way are the same, so that this method should only return false if it is known that the feature should not be an area even if the geometry is a polygon.  Determining what is an area is neigh impossible in OSM, this method inspects tag elements to give a likely answer. See http://wiki.openstreetmap.org/wiki/The_Future_of_Areas and http://wiki.openstreetmap.org/wiki/Way
 * @param way the way (which is assumed to be closed and have enough nodes to be an area)
 * @return true if tags indicate this is an area, otherwise false.
 */
public static boolean isArea(Way way){
  boolean result=true;
  if (way.getTags() != null) {
    for (    Tag tag : way.getTags()) {
      String key=tag.getKey().toLowerCase(Locale.ENGLISH);
      String value=tag.getValue().toLowerCase(Locale.ENGLISH);
      if (""String_Node_Str"".equals(key)) {
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return true;
        }
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return false;
        }
      }
      if (""String_Node_Str"".equals(key) || ""String_Node_Str"".equals(key)) {
        result=false;
      }
      if (""String_Node_Str"".equals(key)) {
        if (""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)) {
          return false;
        }
        return true;
      }
    }
  }
  return result;
}","/** 
 * Heuristic to determine from attributes if a way is likely to be an area. Precondition for this call is that the first and last node of a way are the same, so that this method should only return false if it is known that the feature should not be an area even if the geometry is a polygon. Determining what is an area is neigh impossible in OSM, this method inspects tag elements to give a likely answer. See http://wiki.openstreetmap.org/wiki/The_Future_of_Areas and http://wiki.openstreetmap.org/wiki/Way
 * @param way the way (which is assumed to be closed and have enough nodes to be an area)
 * @return true if tags indicate this is an area, otherwise false.
 */
public static boolean isArea(Way way){
  boolean result=true;
  if (way.getTags() != null) {
    for (    Tag tag : way.getTags()) {
      String key=tag.getKey().toLowerCase(Locale.ENGLISH);
      String value=tag.getValue().toLowerCase(Locale.ENGLISH);
      if (""String_Node_Str"".equals(key)) {
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return true;
        }
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return false;
        }
      }
      if (""String_Node_Str"".equals(key) || ""String_Node_Str"".equals(key)) {
        result=false;
      }
      if (""String_Node_Str"".equals(key)) {
        if (""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)) {
          result=false;
        }
      }
    }
  }
  return result;
}"
93317,"/** 
 * Heuristic to determine from attributes if a way is likely to be an area. Determining what is an area is neigh impossible in OSM, this method inspects tag elements to give a likely answer. See http://wiki.openstreetmap.org/wiki/The_Future_of_Areas and http://wiki.openstreetmap.org/wiki/Way
 * @param way the way (which is assumed to be closed and have enough nodes to be an area)
 * @return true if tags indicate this is an area, otherwise false.
 */
public static boolean isArea(Way way){
  boolean result=true;
  if (way.getTags() != null) {
    for (    Tag tag : way.getTags()) {
      String key=tag.getKey().toLowerCase(Locale.ENGLISH);
      String value=tag.getValue().toLowerCase(Locale.ENGLISH);
      if (""String_Node_Str"".equals(key)) {
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return true;
        }
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return false;
        }
      }
      if (""String_Node_Str"".equals(key) || ""String_Node_Str"".equals(key) || ""String_Node_Str"".equals(key)) {
        result=false;
      }
    }
  }
  return result;
}","/** 
 * Heuristic to determine from attributes if a way is likely to be an area. Precondition for this call is that the first and last node of a way are the same, so that this method should only return false if it is known that the feature should not be an area even if the geometry is a polygon.  Determining what is an area is neigh impossible in OSM, this method inspects tag elements to give a likely answer. See http://wiki.openstreetmap.org/wiki/The_Future_of_Areas and http://wiki.openstreetmap.org/wiki/Way
 * @param way the way (which is assumed to be closed and have enough nodes to be an area)
 * @return true if tags indicate this is an area, otherwise false.
 */
public static boolean isArea(Way way){
  boolean result=true;
  if (way.getTags() != null) {
    for (    Tag tag : way.getTags()) {
      String key=tag.getKey().toLowerCase(Locale.ENGLISH);
      String value=tag.getValue().toLowerCase(Locale.ENGLISH);
      if (""String_Node_Str"".equals(key)) {
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return true;
        }
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return false;
        }
      }
      if (""String_Node_Str"".equals(key) || ""String_Node_Str"".equals(key)) {
        result=false;
      }
      if (""String_Node_Str"".equals(key)) {
        if (""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)) {
          return false;
        }
        return true;
      }
    }
  }
  return result;
}"
93318,"/** 
 * Creates a new TDWay from an osmosis way entity using the given NodeResolver.
 * @param way the way
 * @param resolver the resolver
 * @param preferredLanguage the preferred language or null if no preference
 * @return a new TDWay if it is valid, null otherwise
 */
public static TDWay fromWay(Way way,NodeResolver resolver,String preferredLanguage){
  if (way == null)   return null;
  SpecialTagExtractionResult ster=OSMUtils.extractSpecialFields(way,preferredLanguage);
  short[] knownWayTags=OSMUtils.extractKnownWayTags(way);
  if (way.getWayNodes().size() >= 2) {
    boolean validWay=true;
    TDNode[] waynodes=new TDNode[way.getWayNodes().size()];
    int i=0;
    for (    WayNode waynode : way.getWayNodes()) {
      waynodes[i]=resolver.getNode(waynode.getNodeId());
      if (waynodes[i] == null) {
        validWay=false;
        LOGGER.finer(""String_Node_Str"" + waynode.getNodeId() + ""String_Node_Str""+ way.getId());
      }
      i++;
    }
    if (validWay) {
      byte shape=LINE;
      if (waynodes[0].getId() == waynodes[waynodes.length - 1].getId()) {
        if (waynodes.length >= GeoUtils.MIN_NODES_POLYGON && OSMUtils.isArea(way)) {
          shape=SIMPLE_POLYGON;
        }
 else {
          LOGGER.finer(""String_Node_Str"" + way.getId());
          return null;
        }
      }
      return new TDWay(way.getId(),ster.getLayer(),ster.getName(),ster.getHousenumber(),ster.getRef(),knownWayTags,shape,waynodes);
    }
  }
  return null;
}","/** 
 * Creates a new TDWay from an osmosis way entity using the given NodeResolver.
 * @param way the way
 * @param resolver the resolver
 * @param preferredLanguage the preferred language or null if no preference
 * @return a new TDWay if it is valid, null otherwise
 */
public static TDWay fromWay(Way way,NodeResolver resolver,String preferredLanguage){
  if (way == null)   return null;
  SpecialTagExtractionResult ster=OSMUtils.extractSpecialFields(way,preferredLanguage);
  short[] knownWayTags=OSMUtils.extractKnownWayTags(way);
  if (way.getWayNodes().size() >= 2) {
    boolean validWay=true;
    TDNode[] waynodes=new TDNode[way.getWayNodes().size()];
    int i=0;
    for (    WayNode waynode : way.getWayNodes()) {
      waynodes[i]=resolver.getNode(waynode.getNodeId());
      if (waynodes[i] == null) {
        validWay=false;
        LOGGER.finer(""String_Node_Str"" + waynode.getNodeId() + ""String_Node_Str""+ way.getId());
      }
      i++;
    }
    if (validWay) {
      byte shape=LINE;
      if (waynodes[0].getId() == waynodes[waynodes.length - 1].getId()) {
        if (waynodes.length >= GeoUtils.MIN_NODES_POLYGON) {
          if (OSMUtils.isArea(way)) {
            shape=SIMPLE_POLYGON;
          }
        }
 else {
          LOGGER.finer(""String_Node_Str"" + way.getId());
          return null;
        }
      }
      return new TDWay(way.getId(),ster.getLayer(),ster.getName(),ster.getHousenumber(),ster.getRef(),knownWayTags,shape,waynodes);
    }
  }
  return null;
}"
93319,"/** 
 * Heuristic to determine from attributes if a way is likely to be an area. Precondition for this call is that the first and last node of a way are the same, so that this method should only return false if it is known that the feature should not be an area even if the geometry is a polygon.  Determining what is an area is neigh impossible in OSM, this method inspects tag elements to give a likely answer. See http://wiki.openstreetmap.org/wiki/The_Future_of_Areas and http://wiki.openstreetmap.org/wiki/Way
 * @param way the way (which is assumed to be closed and have enough nodes to be an area)
 * @return true if tags indicate this is an area, otherwise false.
 */
public static boolean isArea(Way way){
  boolean result=true;
  if (way.getTags() != null) {
    for (    Tag tag : way.getTags()) {
      String key=tag.getKey().toLowerCase(Locale.ENGLISH);
      String value=tag.getValue().toLowerCase(Locale.ENGLISH);
      if (""String_Node_Str"".equals(key)) {
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return true;
        }
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return false;
        }
      }
      if (""String_Node_Str"".equals(key) || ""String_Node_Str"".equals(key)) {
        result=false;
      }
      if (""String_Node_Str"".equals(key)) {
        if (""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)) {
          return false;
        }
        return true;
      }
    }
  }
  return result;
}","/** 
 * Heuristic to determine from attributes if a way is likely to be an area. Precondition for this call is that the first and last node of a way are the same, so that this method should only return false if it is known that the feature should not be an area even if the geometry is a polygon. Determining what is an area is neigh impossible in OSM, this method inspects tag elements to give a likely answer. See http://wiki.openstreetmap.org/wiki/The_Future_of_Areas and http://wiki.openstreetmap.org/wiki/Way
 * @param way the way (which is assumed to be closed and have enough nodes to be an area)
 * @return true if tags indicate this is an area, otherwise false.
 */
public static boolean isArea(Way way){
  boolean result=true;
  if (way.getTags() != null) {
    for (    Tag tag : way.getTags()) {
      String key=tag.getKey().toLowerCase(Locale.ENGLISH);
      String value=tag.getValue().toLowerCase(Locale.ENGLISH);
      if (""String_Node_Str"".equals(key)) {
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return true;
        }
        if ((""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value) || (""String_Node_Str"").equals(value)) {
          return false;
        }
      }
      if (""String_Node_Str"".equals(key) || ""String_Node_Str"".equals(key)) {
        result=false;
      }
      if (""String_Node_Str"".equals(key)) {
        if (""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)|| ""String_Node_Str"".equals(value)) {
          result=false;
        }
      }
    }
  }
  return result;
}"
93320,"/** 
 * Intersection of this LineSegment with the Rectangle as another LineSegment. Algorithm is Cohen-Sutherland, see https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm .
 * @param r the rectangle to clip to.
 * @return the LineSegment that falls into the Rectangle, null if there is no intersection.
 */
public LineSegment clipToRectangle(Rectangle r){
  Point a=this.start;
  Point b=this.end;
  int codeStart=code(r,a);
  int codeEnd=code(r,b);
  while (true) {
    if (0 == (codeStart | codeEnd)) {
      return new LineSegment(a,b);
    }
 else     if (0 != (codeStart & codeEnd)) {
      return null;
    }
 else {
      double newX;
      double newY;
      int outsideCode=(0 != codeStart) ? codeStart : codeEnd;
      if (0 != (outsideCode & TOP)) {
        newX=a.x + (b.x - a.x) * (r.top - a.y) / (b.y - a.y);
        newY=r.top;
      }
 else       if (0 != (outsideCode & BOTTOM)) {
        newX=a.x + (b.x - a.x) * (r.bottom - a.y) / (b.y - a.y);
        newY=r.bottom;
      }
 else       if (0 != (outsideCode & RIGHT)) {
        newY=a.y + (b.y - a.y) * (r.right - a.x) / (b.x - a.x);
        newX=r.right;
      }
 else       if (0 != (outsideCode & LEFT)) {
        newY=a.y + (b.y - a.y) * (r.left - a.x) / (b.x - a.x);
        newX=r.left;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (outsideCode == codeStart) {
        a=new Point(newX,newY);
        codeStart=code(r,a);
      }
 else {
        b=new Point(newX,newY);
        codeEnd=code(r,b);
      }
    }
  }
}","/** 
 * Intersection of this LineSegment with the Rectangle as another LineSegment. Algorithm is Cohen-Sutherland, see https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm .
 * @param r the rectangle to clip to.
 * @return the LineSegment that falls into the Rectangle, null if there is no intersection.
 */
public LineSegment clipToRectangle(Rectangle r){
  Point a=this.start;
  Point b=this.end;
  int codeStart=code(r,a);
  int codeEnd=code(r,b);
  while (true) {
    if (0 == (codeStart | codeEnd)) {
      return new LineSegment(a,b);
    }
 else     if (0 != (codeStart & codeEnd)) {
      return null;
    }
 else {
      double newX;
      double newY;
      int outsideCode=(0 != codeStart) ? codeStart : codeEnd;
      if (0 != (outsideCode & TOP)) {
        newX=a.x + (b.x - a.x) * (r.top - a.y) / (b.y - a.y);
        newY=r.top;
      }
 else       if (0 != (outsideCode & BOTTOM)) {
        newX=a.x + (b.x - a.x) * (r.bottom - a.y) / (b.y - a.y);
        newY=r.bottom;
      }
 else       if (0 != (outsideCode & RIGHT)) {
        newY=a.y + (b.y - a.y) * (r.right - a.x) / (b.x - a.x);
        newX=r.right;
      }
 else       if (0 != (outsideCode & LEFT)) {
        newY=a.y + (b.y - a.y) * (r.left - a.x) / (b.x - a.x);
        newX=r.left;
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
      if (outsideCode == codeStart) {
        a=new Point(newX,newY);
        codeStart=code(r,a);
      }
 else {
        b=new Point(newX,newY);
        codeEnd=code(r,b);
      }
    }
  }
}"
93321,"AndroidPointTextContainer(Point xy,int priority,String text,Paint paintFront,Paint paintBack,SymbolContainer symbolContainer,Position position,int maxTextWidth){
  super(xy,priority,text,paintFront,paintBack,symbolContainer,position,maxTextWidth);
  if (this.textWidth > this.maxTextWidth) {
    TextPaint frontTextPaint=new TextPaint(AndroidGraphicFactory.getPaint(this.paintFront));
    TextPaint backTextPaint=null;
    if (this.paintBack != null) {
      backTextPaint=new TextPaint(AndroidGraphicFactory.getPaint(this.paintBack));
    }
    Layout.Alignment alignment=Layout.Alignment.ALIGN_CENTER;
    if (Position.LEFT == this.position || Position.BELOW_LEFT == this.position || Position.ABOVE_LEFT == this.position) {
      alignment=Layout.Alignment.ALIGN_OPPOSITE;
    }
 else     if (Position.RIGHT == this.position || Position.BELOW_RIGHT == this.position || Position.ABOVE_RIGHT == this.position) {
      alignment=Layout.Alignment.ALIGN_NORMAL;
    }
    frontTextPaint.setTextAlign(android.graphics.Paint.Align.LEFT);
    backTextPaint.setTextAlign(android.graphics.Paint.Align.LEFT);
    frontLayout=new StaticLayout(this.text,frontTextPaint,this.maxTextWidth,alignment,1,0,false);
    backLayout=null;
    if (this.paintBack != null) {
      backLayout=new StaticLayout(this.text,backTextPaint,this.maxTextWidth,alignment,1,0,false);
    }
    this.boxWidth=frontLayout.getWidth();
    this.boxHeight=frontLayout.getHeight();
  }
 else {
    this.boxWidth=textWidth;
    this.boxHeight=textHeight;
  }
switch (this.position) {
case CENTER:
    boundary=new Rectangle(-boxWidth / 2f,-boxHeight / 2f,boxWidth / 2f,boxHeight / 2f);
  break;
case BELOW:
boundary=new Rectangle(-boxWidth / 2f,0,boxWidth / 2f,boxHeight);
break;
case BELOW_LEFT:
boundary=new Rectangle(-boxWidth,0,0,boxHeight);
break;
case BELOW_RIGHT:
boundary=new Rectangle(0,0,boxWidth,boxHeight);
break;
case ABOVE:
boundary=new Rectangle(-boxWidth / 2f,-boxHeight,boxWidth / 2f,0);
break;
case ABOVE_LEFT:
boundary=new Rectangle(-boxWidth,-boxHeight,0,0);
break;
case ABOVE_RIGHT:
boundary=new Rectangle(0,-boxHeight,boxWidth,0);
break;
case LEFT:
boundary=new Rectangle(-boxWidth,-boxHeight / 2f,0,boxHeight / 2f);
break;
case RIGHT:
boundary=new Rectangle(0,-boxHeight / 2f,boxWidth,boxHeight / 2f);
break;
}
switch (this.position) {
case CENTER:
debugBoundary=new Rectangle(-textWidth / 2f,-textHeight / 2f,textWidth / 2f,textHeight / 2f);
break;
case BELOW:
debugBoundary=new Rectangle(-textWidth / 2f,0,textWidth / 2f,textHeight);
break;
case BELOW_LEFT:
debugBoundary=new Rectangle(-textWidth,0,0,textHeight);
break;
case BELOW_RIGHT:
debugBoundary=new Rectangle(0,0,textWidth,textHeight);
break;
case ABOVE:
debugBoundary=new Rectangle(-textWidth / 2f,-textHeight,textWidth / 2f,0);
break;
case ABOVE_LEFT:
debugBoundary=new Rectangle(-textWidth,-textHeight,0,0);
break;
case ABOVE_RIGHT:
debugBoundary=new Rectangle(0,-textHeight,textWidth,0);
break;
case LEFT:
debugBoundary=new Rectangle(-textWidth,-textHeight / 2f,0,textHeight / 2f);
break;
case RIGHT:
debugBoundary=new Rectangle(0,-textHeight / 2f,textWidth,textHeight / 2f);
break;
}
}","AndroidPointTextContainer(Point xy,int priority,String text,Paint paintFront,Paint paintBack,SymbolContainer symbolContainer,Position position,int maxTextWidth){
  super(xy,priority,text,paintFront,paintBack,symbolContainer,position,maxTextWidth);
  if (this.textWidth > this.maxTextWidth) {
    TextPaint frontTextPaint=new TextPaint(AndroidGraphicFactory.getPaint(this.paintFront));
    TextPaint backTextPaint=null;
    if (this.paintBack != null) {
      backTextPaint=new TextPaint(AndroidGraphicFactory.getPaint(this.paintBack));
    }
    Layout.Alignment alignment=Layout.Alignment.ALIGN_CENTER;
    if (Position.LEFT == this.position || Position.BELOW_LEFT == this.position || Position.ABOVE_LEFT == this.position) {
      alignment=Layout.Alignment.ALIGN_OPPOSITE;
    }
 else     if (Position.RIGHT == this.position || Position.BELOW_RIGHT == this.position || Position.ABOVE_RIGHT == this.position) {
      alignment=Layout.Alignment.ALIGN_NORMAL;
    }
    frontTextPaint.setTextAlign(android.graphics.Paint.Align.LEFT);
    backTextPaint.setTextAlign(android.graphics.Paint.Align.LEFT);
    frontLayout=new StaticLayout(this.text,frontTextPaint,this.maxTextWidth,alignment,1,0,false);
    backLayout=null;
    if (this.paintBack != null) {
      backLayout=new StaticLayout(this.text,backTextPaint,this.maxTextWidth,alignment,1,0,false);
    }
    this.boxWidth=frontLayout.getWidth();
    this.boxHeight=frontLayout.getHeight();
  }
 else {
    this.boxWidth=textWidth;
    this.boxHeight=textHeight;
  }
switch (this.position) {
case CENTER:
    boundary=new Rectangle(-boxWidth / 2f,-boxHeight / 2f,boxWidth / 2f,boxHeight / 2f);
  break;
case BELOW:
boundary=new Rectangle(-boxWidth / 2f,0,boxWidth / 2f,boxHeight);
break;
case BELOW_LEFT:
boundary=new Rectangle(-boxWidth,0,0,boxHeight);
break;
case BELOW_RIGHT:
boundary=new Rectangle(0,0,boxWidth,boxHeight);
break;
case ABOVE:
boundary=new Rectangle(-boxWidth / 2f,-boxHeight,boxWidth / 2f,0);
break;
case ABOVE_LEFT:
boundary=new Rectangle(-boxWidth,-boxHeight,0,0);
break;
case ABOVE_RIGHT:
boundary=new Rectangle(0,-boxHeight,boxWidth,0);
break;
case LEFT:
boundary=new Rectangle(-boxWidth,-boxHeight / 2f,0,boxHeight / 2f);
break;
case RIGHT:
boundary=new Rectangle(0,-boxHeight / 2f,boxWidth,boxHeight / 2f);
break;
}
}"
93322,"private List<Way> processWays(QueryParameters queryParameters,int numberOfWays,BoundingBox boundingBox,boolean filterRequired){
  List<Way> ways=new ArrayList<Way>();
  Tag[] wayTags=this.mapFileHeader.getMapFileInfo().wayTags;
  BoundingBox wayFilterBbox=boundingBox.extend(wayFilterDistance);
  for (int elementCounter=numberOfWays; elementCounter != 0; --elementCounter) {
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      this.signatureWay=this.readBuffer.readUTF8EncodedString(SIGNATURE_LENGTH_WAY);
      if (!this.signatureWay.startsWith(""String_Node_Str"")) {
        LOGGER.warning(""String_Node_Str"" + this.signatureWay);
        LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
        return null;
      }
    }
    int wayDataSize=this.readBuffer.readUnsignedInt();
    if (wayDataSize < 0) {
      LOGGER.warning(""String_Node_Str"" + wayDataSize);
      if (this.mapFileHeader.getMapFileInfo().debugFile) {
        LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
      }
      return null;
    }
    if (queryParameters.useTileBitmask) {
      int tileBitmask=this.readBuffer.readShort();
      if ((queryParameters.queryTileBitmask & tileBitmask) == 0) {
        this.readBuffer.skipBytes(wayDataSize - 2);
        continue;
      }
    }
 else {
      this.readBuffer.skipBytes(2);
    }
    byte specialByte=this.readBuffer.readByte();
    byte layer=(byte)((specialByte & WAY_LAYER_BITMASK) >>> WAY_LAYER_SHIFT);
    byte numberOfTags=(byte)(specialByte & WAY_NUMBER_OF_TAGS_BITMASK);
    List<Tag> tags=new ArrayList<Tag>();
    for (byte tagIndex=numberOfTags; tagIndex != 0; --tagIndex) {
      int tagId=this.readBuffer.readUnsignedInt();
      if (tagId < 0 || tagId >= wayTags.length) {
        LOGGER.warning(""String_Node_Str"" + tagId);
        logDebugSignatures();
        return null;
      }
      tags.add(wayTags[tagId]);
    }
    byte featureByte=this.readBuffer.readByte();
    boolean featureName=(featureByte & WAY_FEATURE_NAME) != 0;
    boolean featureHouseNumber=(featureByte & WAY_FEATURE_HOUSE_NUMBER) != 0;
    boolean featureRef=(featureByte & WAY_FEATURE_REF) != 0;
    boolean featureLabelPosition=(featureByte & WAY_FEATURE_LABEL_POSITION) != 0;
    boolean featureWayDataBlocksByte=(featureByte & WAY_FEATURE_DATA_BLOCKS_BYTE) != 0;
    boolean featureWayDoubleDeltaEncoding=(featureByte & WAY_FEATURE_DOUBLE_DELTA_ENCODING) != 0;
    if (featureName) {
      tags.add(new Tag(TAG_KEY_NAME,this.readBuffer.readUTF8EncodedString()));
    }
    if (featureHouseNumber) {
      tags.add(new Tag(TAG_KEY_HOUSE_NUMBER,this.readBuffer.readUTF8EncodedString()));
    }
    if (featureRef) {
      tags.add(new Tag(TAG_KEY_REF,this.readBuffer.readUTF8EncodedString()));
    }
    LatLong labelPosition=readOptionalLabelPosition(featureLabelPosition);
    int wayDataBlocks=readOptionalWayDataBlocksByte(featureWayDataBlocksByte);
    if (wayDataBlocks < 1) {
      LOGGER.warning(""String_Node_Str"" + wayDataBlocks);
      logDebugSignatures();
      return null;
    }
    for (int wayDataBlock=0; wayDataBlock < wayDataBlocks; ++wayDataBlock) {
      LatLong[][] wayNodes=processWayDataBlock(featureWayDoubleDeltaEncoding);
      if (wayNodes != null) {
        if (filterRequired && wayFilterEnabled) {
          if (!wayFilterBbox.intersectsArea(wayNodes)) {
            continue;
          }
        }
        ways.add(new Way(layer,tags,wayNodes,labelPosition));
      }
    }
  }
  return ways;
}","private List<Way> processWays(QueryParameters queryParameters,int numberOfWays,BoundingBox boundingBox,boolean filterRequired){
  List<Way> ways=new ArrayList<Way>();
  Tag[] wayTags=this.mapFileHeader.getMapFileInfo().wayTags;
  BoundingBox wayFilterBbox=boundingBox.extend(wayFilterDistance);
  for (int elementCounter=numberOfWays; elementCounter != 0; --elementCounter) {
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      this.signatureWay=this.readBuffer.readUTF8EncodedString(SIGNATURE_LENGTH_WAY);
      if (!this.signatureWay.startsWith(""String_Node_Str"")) {
        LOGGER.warning(""String_Node_Str"" + this.signatureWay);
        LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
        return null;
      }
    }
    int wayDataSize=this.readBuffer.readUnsignedInt();
    if (wayDataSize < 0) {
      LOGGER.warning(""String_Node_Str"" + wayDataSize);
      if (this.mapFileHeader.getMapFileInfo().debugFile) {
        LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
      }
      return null;
    }
    if (queryParameters.useTileBitmask) {
      int tileBitmask=this.readBuffer.readShort();
      if ((queryParameters.queryTileBitmask & tileBitmask) == 0) {
        this.readBuffer.skipBytes(wayDataSize - 2);
        continue;
      }
    }
 else {
      this.readBuffer.skipBytes(2);
    }
    byte specialByte=this.readBuffer.readByte();
    byte layer=(byte)((specialByte & WAY_LAYER_BITMASK) >>> WAY_LAYER_SHIFT);
    byte numberOfTags=(byte)(specialByte & WAY_NUMBER_OF_TAGS_BITMASK);
    List<Tag> tags=new ArrayList<Tag>();
    for (byte tagIndex=numberOfTags; tagIndex != 0; --tagIndex) {
      int tagId=this.readBuffer.readUnsignedInt();
      if (tagId < 0 || tagId >= wayTags.length) {
        LOGGER.warning(""String_Node_Str"" + tagId);
        logDebugSignatures();
        return null;
      }
      tags.add(wayTags[tagId]);
    }
    byte featureByte=this.readBuffer.readByte();
    boolean featureName=(featureByte & WAY_FEATURE_NAME) != 0;
    boolean featureHouseNumber=(featureByte & WAY_FEATURE_HOUSE_NUMBER) != 0;
    boolean featureRef=(featureByte & WAY_FEATURE_REF) != 0;
    boolean featureLabelPosition=(featureByte & WAY_FEATURE_LABEL_POSITION) != 0;
    boolean featureWayDataBlocksByte=(featureByte & WAY_FEATURE_DATA_BLOCKS_BYTE) != 0;
    boolean featureWayDoubleDeltaEncoding=(featureByte & WAY_FEATURE_DOUBLE_DELTA_ENCODING) != 0;
    if (featureName) {
      tags.add(new Tag(TAG_KEY_NAME,this.readBuffer.readUTF8EncodedString()));
    }
    if (featureHouseNumber) {
      tags.add(new Tag(TAG_KEY_HOUSE_NUMBER,this.readBuffer.readUTF8EncodedString()));
    }
    if (featureRef) {
      tags.add(new Tag(TAG_KEY_REF,this.readBuffer.readUTF8EncodedString()));
    }
    LatLong labelPosition=readOptionalLabelPosition(featureLabelPosition);
    int wayDataBlocks=readOptionalWayDataBlocksByte(featureWayDataBlocksByte);
    if (wayDataBlocks < 1) {
      LOGGER.warning(""String_Node_Str"" + wayDataBlocks);
      logDebugSignatures();
      return null;
    }
    for (int wayDataBlock=0; wayDataBlock < wayDataBlocks; ++wayDataBlock) {
      LatLong[][] wayNodes=processWayDataBlock(featureWayDoubleDeltaEncoding);
      if (wayNodes != null) {
        if (filterRequired && wayFilterEnabled && !wayFilterBbox.intersectsArea(wayNodes)) {
          continue;
        }
        ways.add(new Way(layer,tags,wayNodes,labelPosition));
      }
    }
  }
  return ways;
}"
93323,"/** 
 * Intersection of this LineSegment with the Rectangle as another LineSegment. Algorithm is Cohen-Sutherland, see https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm .
 * @param r the rectangle to clip to.
 * @return the LineSegment that falls into the Rectangle, null if there is no intersection.
 */
public LineSegment clipToRectangle(Rectangle r){
  Point a=this.start;
  Point b=this.end;
  int codeStart=code(r,a);
  int codeEnd=code(r,b);
  while (true) {
    if (0 == (codeStart | codeEnd)) {
      return new LineSegment(a,b);
    }
 else     if (0 != (codeStart & codeEnd)) {
      return null;
    }
 else {
      double newX;
      double newY;
      int outsideCode=(0 != codeStart) ? codeStart : codeEnd;
      if (0 != (outsideCode & TOP)) {
        newX=a.x + (b.x - a.x) * (r.top - a.y) / (b.y - a.y);
        newY=r.top;
      }
 else       if (0 != (outsideCode & BOTTOM)) {
        newX=a.x + (b.x - a.x) * (r.bottom - a.y) / (b.y - a.y);
        newY=r.bottom;
      }
 else       if (0 != (outsideCode & RIGHT)) {
        newY=a.y + (b.y - a.y) * (r.right - a.x) / (b.x - a.x);
        newX=r.right;
      }
 else       if (0 != (outsideCode & LEFT)) {
        newY=a.y + (b.y - a.y) * (r.left - a.x) / (b.x - a.x);
        newX=r.left;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (outsideCode == codeStart) {
        a=new Point(newX,newY);
        codeStart=code(r,a);
      }
 else {
        b=new Point(newX,newY);
        codeEnd=code(r,b);
      }
    }
  }
}","/** 
 * Intersection of this LineSegment with the Rectangle as another LineSegment. Algorithm is Cohen-Sutherland, see https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm .
 * @param r the rectangle to clip to.
 * @return the LineSegment that falls into the Rectangle, null if there is no intersection.
 */
public LineSegment clipToRectangle(Rectangle r){
  Point a=this.start;
  Point b=this.end;
  int codeStart=code(r,a);
  int codeEnd=code(r,b);
  while (true) {
    if (0 == (codeStart | codeEnd)) {
      return new LineSegment(a,b);
    }
 else     if (0 != (codeStart & codeEnd)) {
      return null;
    }
 else {
      double newX;
      double newY;
      int outsideCode=(0 != codeStart) ? codeStart : codeEnd;
      if (0 != (outsideCode & TOP)) {
        newX=a.x + (b.x - a.x) * (r.top - a.y) / (b.y - a.y);
        newY=r.top;
      }
 else       if (0 != (outsideCode & BOTTOM)) {
        newX=a.x + (b.x - a.x) * (r.bottom - a.y) / (b.y - a.y);
        newY=r.bottom;
      }
 else       if (0 != (outsideCode & RIGHT)) {
        newY=a.y + (b.y - a.y) * (r.right - a.x) / (b.x - a.x);
        newX=r.right;
      }
 else       if (0 != (outsideCode & LEFT)) {
        newY=a.y + (b.y - a.y) * (r.left - a.x) / (b.x - a.x);
        newX=r.left;
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
      if (outsideCode == codeStart) {
        a=new Point(newX,newY);
        codeStart=code(r,a);
      }
 else {
        b=new Point(newX,newY);
        codeEnd=code(r,b);
      }
    }
  }
}"
93324,"AndroidPointTextContainer(Point xy,int priority,String text,Paint paintFront,Paint paintBack,SymbolContainer symbolContainer,Position position,int maxTextWidth){
  super(xy,priority,text,paintFront,paintBack,symbolContainer,position,maxTextWidth);
  if (this.textWidth > this.maxTextWidth) {
    TextPaint frontTextPaint=new TextPaint(AndroidGraphicFactory.getPaint(this.paintFront));
    TextPaint backTextPaint=null;
    if (this.paintBack != null) {
      backTextPaint=new TextPaint(AndroidGraphicFactory.getPaint(this.paintBack));
    }
    Layout.Alignment alignment=Layout.Alignment.ALIGN_CENTER;
    if (Position.LEFT == this.position || Position.BELOW_LEFT == this.position || Position.ABOVE_LEFT == this.position) {
      alignment=Layout.Alignment.ALIGN_OPPOSITE;
    }
 else     if (Position.RIGHT == this.position || Position.BELOW_RIGHT == this.position || Position.ABOVE_RIGHT == this.position) {
      alignment=Layout.Alignment.ALIGN_NORMAL;
    }
    frontTextPaint.setTextAlign(android.graphics.Paint.Align.LEFT);
    backTextPaint.setTextAlign(android.graphics.Paint.Align.LEFT);
    frontLayout=new StaticLayout(this.text,frontTextPaint,this.maxTextWidth,alignment,1,0,false);
    backLayout=null;
    if (this.paintBack != null) {
      backLayout=new StaticLayout(this.text,backTextPaint,this.maxTextWidth,alignment,1,0,false);
    }
    this.boxWidth=frontLayout.getWidth();
    this.boxHeight=frontLayout.getHeight();
  }
 else {
    this.boxWidth=textWidth;
    this.boxHeight=textHeight;
  }
switch (this.position) {
case CENTER:
    boundary=new Rectangle(-boxWidth / 2f,-boxHeight / 2f,boxWidth / 2f,boxHeight / 2f);
  break;
case BELOW:
boundary=new Rectangle(-boxWidth / 2f,0,boxWidth / 2f,boxHeight);
break;
case BELOW_LEFT:
boundary=new Rectangle(-boxWidth,0,0,boxHeight);
break;
case BELOW_RIGHT:
boundary=new Rectangle(0,0,boxWidth,boxHeight);
break;
case ABOVE:
boundary=new Rectangle(-boxWidth / 2f,-boxHeight,boxWidth / 2f,0);
break;
case ABOVE_LEFT:
boundary=new Rectangle(-boxWidth,-boxHeight,0,0);
break;
case ABOVE_RIGHT:
boundary=new Rectangle(0,-boxHeight,boxWidth,0);
break;
case LEFT:
boundary=new Rectangle(-boxWidth,-boxHeight / 2f,0,boxHeight / 2f);
break;
case RIGHT:
boundary=new Rectangle(0,-boxHeight / 2f,boxWidth,boxHeight / 2f);
break;
}
switch (this.position) {
case CENTER:
debugBoundary=new Rectangle(-textWidth / 2f,-textHeight / 2f,textWidth / 2f,textHeight / 2f);
break;
case BELOW:
debugBoundary=new Rectangle(-textWidth / 2f,0,textWidth / 2f,textHeight);
break;
case BELOW_LEFT:
debugBoundary=new Rectangle(-textWidth,0,0,textHeight);
break;
case BELOW_RIGHT:
debugBoundary=new Rectangle(0,0,textWidth,textHeight);
break;
case ABOVE:
debugBoundary=new Rectangle(-textWidth / 2f,-textHeight,textWidth / 2f,0);
break;
case ABOVE_LEFT:
debugBoundary=new Rectangle(-textWidth,-textHeight,0,0);
break;
case ABOVE_RIGHT:
debugBoundary=new Rectangle(0,-textHeight,textWidth,0);
break;
case LEFT:
debugBoundary=new Rectangle(-textWidth,-textHeight / 2f,0,textHeight / 2f);
break;
case RIGHT:
debugBoundary=new Rectangle(0,-textHeight / 2f,textWidth,textHeight / 2f);
break;
}
}","AndroidPointTextContainer(Point xy,int priority,String text,Paint paintFront,Paint paintBack,SymbolContainer symbolContainer,Position position,int maxTextWidth){
  super(xy,priority,text,paintFront,paintBack,symbolContainer,position,maxTextWidth);
  if (this.textWidth > this.maxTextWidth) {
    TextPaint frontTextPaint=new TextPaint(AndroidGraphicFactory.getPaint(this.paintFront));
    TextPaint backTextPaint=null;
    if (this.paintBack != null) {
      backTextPaint=new TextPaint(AndroidGraphicFactory.getPaint(this.paintBack));
    }
    Layout.Alignment alignment=Layout.Alignment.ALIGN_CENTER;
    if (Position.LEFT == this.position || Position.BELOW_LEFT == this.position || Position.ABOVE_LEFT == this.position) {
      alignment=Layout.Alignment.ALIGN_OPPOSITE;
    }
 else     if (Position.RIGHT == this.position || Position.BELOW_RIGHT == this.position || Position.ABOVE_RIGHT == this.position) {
      alignment=Layout.Alignment.ALIGN_NORMAL;
    }
    frontTextPaint.setTextAlign(android.graphics.Paint.Align.LEFT);
    backTextPaint.setTextAlign(android.graphics.Paint.Align.LEFT);
    frontLayout=new StaticLayout(this.text,frontTextPaint,this.maxTextWidth,alignment,1,0,false);
    backLayout=null;
    if (this.paintBack != null) {
      backLayout=new StaticLayout(this.text,backTextPaint,this.maxTextWidth,alignment,1,0,false);
    }
    this.boxWidth=frontLayout.getWidth();
    this.boxHeight=frontLayout.getHeight();
  }
 else {
    this.boxWidth=textWidth;
    this.boxHeight=textHeight;
  }
switch (this.position) {
case CENTER:
    boundary=new Rectangle(-boxWidth / 2f,-boxHeight / 2f,boxWidth / 2f,boxHeight / 2f);
  break;
case BELOW:
boundary=new Rectangle(-boxWidth / 2f,0,boxWidth / 2f,boxHeight);
break;
case BELOW_LEFT:
boundary=new Rectangle(-boxWidth,0,0,boxHeight);
break;
case BELOW_RIGHT:
boundary=new Rectangle(0,0,boxWidth,boxHeight);
break;
case ABOVE:
boundary=new Rectangle(-boxWidth / 2f,-boxHeight,boxWidth / 2f,0);
break;
case ABOVE_LEFT:
boundary=new Rectangle(-boxWidth,-boxHeight,0,0);
break;
case ABOVE_RIGHT:
boundary=new Rectangle(0,-boxHeight,boxWidth,0);
break;
case LEFT:
boundary=new Rectangle(-boxWidth,-boxHeight / 2f,0,boxHeight / 2f);
break;
case RIGHT:
boundary=new Rectangle(0,-boxHeight / 2f,boxWidth,boxHeight / 2f);
break;
}
}"
93325,"private List<Way> processWays(QueryParameters queryParameters,int numberOfWays,BoundingBox boundingBox,boolean filterRequired){
  List<Way> ways=new ArrayList<Way>();
  Tag[] wayTags=this.mapFileHeader.getMapFileInfo().wayTags;
  BoundingBox wayFilterBbox=boundingBox.extend(wayFilterDistance);
  for (int elementCounter=numberOfWays; elementCounter != 0; --elementCounter) {
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      this.signatureWay=this.readBuffer.readUTF8EncodedString(SIGNATURE_LENGTH_WAY);
      if (!this.signatureWay.startsWith(""String_Node_Str"")) {
        LOGGER.warning(""String_Node_Str"" + this.signatureWay);
        LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
        return null;
      }
    }
    int wayDataSize=this.readBuffer.readUnsignedInt();
    if (wayDataSize < 0) {
      LOGGER.warning(""String_Node_Str"" + wayDataSize);
      if (this.mapFileHeader.getMapFileInfo().debugFile) {
        LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
      }
      return null;
    }
    if (queryParameters.useTileBitmask) {
      int tileBitmask=this.readBuffer.readShort();
      if ((queryParameters.queryTileBitmask & tileBitmask) == 0) {
        this.readBuffer.skipBytes(wayDataSize - 2);
        continue;
      }
    }
 else {
      this.readBuffer.skipBytes(2);
    }
    byte specialByte=this.readBuffer.readByte();
    byte layer=(byte)((specialByte & WAY_LAYER_BITMASK) >>> WAY_LAYER_SHIFT);
    byte numberOfTags=(byte)(specialByte & WAY_NUMBER_OF_TAGS_BITMASK);
    List<Tag> tags=new ArrayList<Tag>();
    for (byte tagIndex=numberOfTags; tagIndex != 0; --tagIndex) {
      int tagId=this.readBuffer.readUnsignedInt();
      if (tagId < 0 || tagId >= wayTags.length) {
        LOGGER.warning(""String_Node_Str"" + tagId);
        logDebugSignatures();
        return null;
      }
      tags.add(wayTags[tagId]);
    }
    byte featureByte=this.readBuffer.readByte();
    boolean featureName=(featureByte & WAY_FEATURE_NAME) != 0;
    boolean featureHouseNumber=(featureByte & WAY_FEATURE_HOUSE_NUMBER) != 0;
    boolean featureRef=(featureByte & WAY_FEATURE_REF) != 0;
    boolean featureLabelPosition=(featureByte & WAY_FEATURE_LABEL_POSITION) != 0;
    boolean featureWayDataBlocksByte=(featureByte & WAY_FEATURE_DATA_BLOCKS_BYTE) != 0;
    boolean featureWayDoubleDeltaEncoding=(featureByte & WAY_FEATURE_DOUBLE_DELTA_ENCODING) != 0;
    if (featureName) {
      tags.add(new Tag(TAG_KEY_NAME,this.readBuffer.readUTF8EncodedString()));
    }
    if (featureHouseNumber) {
      tags.add(new Tag(TAG_KEY_HOUSE_NUMBER,this.readBuffer.readUTF8EncodedString()));
    }
    if (featureRef) {
      tags.add(new Tag(TAG_KEY_REF,this.readBuffer.readUTF8EncodedString()));
    }
    LatLong labelPosition=readOptionalLabelPosition(featureLabelPosition);
    int wayDataBlocks=readOptionalWayDataBlocksByte(featureWayDataBlocksByte);
    if (wayDataBlocks < 1) {
      LOGGER.warning(""String_Node_Str"" + wayDataBlocks);
      logDebugSignatures();
      return null;
    }
    for (int wayDataBlock=0; wayDataBlock < wayDataBlocks; ++wayDataBlock) {
      LatLong[][] wayNodes=processWayDataBlock(featureWayDoubleDeltaEncoding);
      if (wayNodes != null) {
        if (filterRequired && wayFilterEnabled) {
          if (!wayFilterBbox.intersectsArea(wayNodes)) {
            continue;
          }
        }
        ways.add(new Way(layer,tags,wayNodes,labelPosition));
      }
    }
  }
  return ways;
}","private List<Way> processWays(QueryParameters queryParameters,int numberOfWays,BoundingBox boundingBox,boolean filterRequired){
  List<Way> ways=new ArrayList<Way>();
  Tag[] wayTags=this.mapFileHeader.getMapFileInfo().wayTags;
  BoundingBox wayFilterBbox=boundingBox.extend(wayFilterDistance);
  for (int elementCounter=numberOfWays; elementCounter != 0; --elementCounter) {
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      this.signatureWay=this.readBuffer.readUTF8EncodedString(SIGNATURE_LENGTH_WAY);
      if (!this.signatureWay.startsWith(""String_Node_Str"")) {
        LOGGER.warning(""String_Node_Str"" + this.signatureWay);
        LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
        return null;
      }
    }
    int wayDataSize=this.readBuffer.readUnsignedInt();
    if (wayDataSize < 0) {
      LOGGER.warning(""String_Node_Str"" + wayDataSize);
      if (this.mapFileHeader.getMapFileInfo().debugFile) {
        LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
      }
      return null;
    }
    if (queryParameters.useTileBitmask) {
      int tileBitmask=this.readBuffer.readShort();
      if ((queryParameters.queryTileBitmask & tileBitmask) == 0) {
        this.readBuffer.skipBytes(wayDataSize - 2);
        continue;
      }
    }
 else {
      this.readBuffer.skipBytes(2);
    }
    byte specialByte=this.readBuffer.readByte();
    byte layer=(byte)((specialByte & WAY_LAYER_BITMASK) >>> WAY_LAYER_SHIFT);
    byte numberOfTags=(byte)(specialByte & WAY_NUMBER_OF_TAGS_BITMASK);
    List<Tag> tags=new ArrayList<Tag>();
    for (byte tagIndex=numberOfTags; tagIndex != 0; --tagIndex) {
      int tagId=this.readBuffer.readUnsignedInt();
      if (tagId < 0 || tagId >= wayTags.length) {
        LOGGER.warning(""String_Node_Str"" + tagId);
        logDebugSignatures();
        return null;
      }
      tags.add(wayTags[tagId]);
    }
    byte featureByte=this.readBuffer.readByte();
    boolean featureName=(featureByte & WAY_FEATURE_NAME) != 0;
    boolean featureHouseNumber=(featureByte & WAY_FEATURE_HOUSE_NUMBER) != 0;
    boolean featureRef=(featureByte & WAY_FEATURE_REF) != 0;
    boolean featureLabelPosition=(featureByte & WAY_FEATURE_LABEL_POSITION) != 0;
    boolean featureWayDataBlocksByte=(featureByte & WAY_FEATURE_DATA_BLOCKS_BYTE) != 0;
    boolean featureWayDoubleDeltaEncoding=(featureByte & WAY_FEATURE_DOUBLE_DELTA_ENCODING) != 0;
    if (featureName) {
      tags.add(new Tag(TAG_KEY_NAME,this.readBuffer.readUTF8EncodedString()));
    }
    if (featureHouseNumber) {
      tags.add(new Tag(TAG_KEY_HOUSE_NUMBER,this.readBuffer.readUTF8EncodedString()));
    }
    if (featureRef) {
      tags.add(new Tag(TAG_KEY_REF,this.readBuffer.readUTF8EncodedString()));
    }
    LatLong labelPosition=readOptionalLabelPosition(featureLabelPosition);
    int wayDataBlocks=readOptionalWayDataBlocksByte(featureWayDataBlocksByte);
    if (wayDataBlocks < 1) {
      LOGGER.warning(""String_Node_Str"" + wayDataBlocks);
      logDebugSignatures();
      return null;
    }
    for (int wayDataBlock=0; wayDataBlock < wayDataBlocks; ++wayDataBlock) {
      LatLong[][] wayNodes=processWayDataBlock(featureWayDoubleDeltaEncoding);
      if (wayNodes != null) {
        if (filterRequired && wayFilterEnabled && !wayFilterBbox.intersectsArea(wayNodes)) {
          continue;
        }
        ways.add(new Way(layer,tags,wayNodes,labelPosition));
      }
    }
  }
  return ways;
}"
93326,"private static android.graphics.Bitmap getTileBitmapFromReusableSet(int tileSize,boolean isTransparent){
  int hash=composeHash(tileSize,isTransparent);
  Set<SoftReference<Bitmap>> subSet=reusableTileBitmaps.get(hash);
  if (subSet == null) {
    return null;
  }
  android.graphics.Bitmap bitmap=null;
synchronized (subSet) {
    final Iterator<SoftReference<android.graphics.Bitmap>> iterator=subSet.iterator();
    android.graphics.Bitmap candidate;
    while (iterator.hasNext()) {
      candidate=iterator.next().get();
      if (null != candidate && candidate.isMutable()) {
        bitmap=candidate;
        iterator.remove();
        break;
      }
 else {
        iterator.remove();
      }
    }
  }
  return bitmap;
}","private static android.graphics.Bitmap getTileBitmapFromReusableSet(int tileSize,boolean isTransparent){
  int hash=composeHash(tileSize,isTransparent);
  Set<SoftReference<Bitmap>> subSet=reusableTileBitmaps.get(hash);
  if (subSet == null) {
    return null;
  }
  android.graphics.Bitmap bitmap=null;
synchronized (subSet) {
    final Iterator<SoftReference<android.graphics.Bitmap>> iterator=subSet.iterator();
    android.graphics.Bitmap candidate;
    while (iterator.hasNext()) {
      candidate=iterator.next().get();
      if (null != candidate && candidate.isMutable()) {
        bitmap=candidate;
        if (isTransparent) {
          bitmap.eraseColor(android.graphics.Color.TRANSPARENT);
        }
        iterator.remove();
        break;
      }
 else {
        iterator.remove();
      }
    }
  }
  return bitmap;
}"
93327,"/** 
 * Called when a job needs to be executed.
 * @param rendererJob the job that should be executed.
 */
public TileBitmap executeJob(RendererJob rendererJob){
  final int tileSize=rendererJob.tile.tileSize;
  final byte zoomLevel=rendererJob.tile.zoomLevel;
  this.currentLabels=new LinkedList<MapElementContainer>();
  this.currentWayLabels=new HashSet<MapElementContainer>();
  XmlRenderTheme jobTheme=rendererJob.xmlRenderTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    this.renderTheme=getRenderTheme(jobTheme,rendererJob.displayModel);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return null;
    }
    this.ways=createWayLists();
    this.previousJobTheme=jobTheme;
  }
  setScaleStrokeWidth(zoomLevel);
  this.renderTheme.scaleTextSize(rendererJob.textScale);
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(rendererJob.tile);
    processReadMapData(ways,mapReadResult,rendererJob.tile);
  }
  TileBitmap bitmap=null;
  if (!rendererJob.labelsOnly) {
    bitmap=this.graphicFactory.createTileBitmap(tileSize,rendererJob.hasAlpha);
    this.canvasRasterer.setCanvasBitmap(bitmap);
    if (rendererJob.displayModel.getBackgroundColor() != this.renderTheme.getMapBackground()) {
      this.canvasRasterer.fill(rendererJob.hasAlpha ? 0 : this.renderTheme.getMapBackground());
    }
    this.canvasRasterer.drawWays(ways,rendererJob.tile);
  }
  if (renderLabels) {
    Set<MapElementContainer> labelsToDraw=new HashSet<MapElementContainer>();
    Set<Tile> neighbours=rendererJob.tile.getNeighbours();
    Iterator<Tile> tileIterator=neighbours.iterator();
    Set<MapElementContainer> undrawableElements=new HashSet<MapElementContainer>();
    while (tileIterator.hasNext()) {
      Tile neighbour=tileIterator.next();
      if (tileCache.containsKey(rendererJob.otherTile(neighbour))) {
        labelsToDraw.addAll(tileDependencies.getOverlappingElements(neighbour,rendererJob.tile));
        for (        MapElementContainer current : currentLabels) {
          if (current.intersects(neighbour.getBoundaryAbsolute())) {
            undrawableElements.add(current);
          }
        }
        tileIterator.remove();
      }
 else {
        tileDependencies.removeTileData(neighbour);
      }
    }
    currentLabels.removeAll(undrawableElements);
    List<MapElementContainer> currentElementsOrdered=LayerUtil.collisionFreeOrdered(currentLabels);
    Iterator<MapElementContainer> currentMapElementsIterator=currentElementsOrdered.iterator();
    while (currentMapElementsIterator.hasNext()) {
      MapElementContainer current=currentMapElementsIterator.next();
      for (      MapElementContainer label : labelsToDraw) {
        if (label.clashesWith(current)) {
          currentMapElementsIterator.remove();
          break;
        }
      }
    }
    labelsToDraw.addAll(currentElementsOrdered);
    for (    Tile tile : neighbours) {
      tileDependencies.removeTileData(rendererJob.tile,tile);
      for (      MapElementContainer element : labelsToDraw) {
        if (element.intersects(tile.getBoundaryAbsolute())) {
          tileDependencies.addOverlappingElement(rendererJob.tile,tile,element);
        }
      }
    }
    this.canvasRasterer.drawMapElements(currentWayLabels,rendererJob.tile);
    this.canvasRasterer.drawMapElements(labelsToDraw,rendererJob.tile);
  }
 else {
    this.labelStore.storeMapItems(rendererJob.tile,this.currentLabels);
  }
  for (int i=this.ways.size() - 1; i >= 0; --i) {
    List<List<ShapePaintContainer>> innerWayList=this.ways.get(i);
    for (int j=innerWayList.size() - 1; j >= 0; --j) {
      innerWayList.get(j).clear();
    }
  }
  return bitmap;
}","/** 
 * Called when a job needs to be executed.
 * @param rendererJob the job that should be executed.
 */
public TileBitmap executeJob(RendererJob rendererJob){
  final int tileSize=rendererJob.tile.tileSize;
  final byte zoomLevel=rendererJob.tile.zoomLevel;
  this.currentLabels=new LinkedList<MapElementContainer>();
  this.currentWayLabels=new HashSet<MapElementContainer>();
  XmlRenderTheme jobTheme=rendererJob.xmlRenderTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    this.renderTheme=getRenderTheme(jobTheme,rendererJob.displayModel);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return null;
    }
    this.ways=createWayLists();
    this.previousJobTheme=jobTheme;
  }
  setScaleStrokeWidth(zoomLevel);
  this.renderTheme.scaleTextSize(rendererJob.textScale);
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(rendererJob.tile);
    processReadMapData(ways,mapReadResult,rendererJob.tile);
  }
  TileBitmap bitmap=null;
  if (!rendererJob.labelsOnly) {
    bitmap=this.graphicFactory.createTileBitmap(tileSize,rendererJob.hasAlpha);
    this.canvasRasterer.setCanvasBitmap(bitmap);
    if (!rendererJob.hasAlpha && rendererJob.displayModel.getBackgroundColor() != this.renderTheme.getMapBackground()) {
      this.canvasRasterer.fill(this.renderTheme.getMapBackground());
    }
    this.canvasRasterer.drawWays(ways,rendererJob.tile);
  }
  if (renderLabels) {
    Set<MapElementContainer> labelsToDraw=new HashSet<MapElementContainer>();
    Set<Tile> neighbours=rendererJob.tile.getNeighbours();
    Iterator<Tile> tileIterator=neighbours.iterator();
    Set<MapElementContainer> undrawableElements=new HashSet<MapElementContainer>();
    while (tileIterator.hasNext()) {
      Tile neighbour=tileIterator.next();
      if (tileCache.containsKey(rendererJob.otherTile(neighbour))) {
        labelsToDraw.addAll(tileDependencies.getOverlappingElements(neighbour,rendererJob.tile));
        for (        MapElementContainer current : currentLabels) {
          if (current.intersects(neighbour.getBoundaryAbsolute())) {
            undrawableElements.add(current);
          }
        }
        tileIterator.remove();
      }
 else {
        tileDependencies.removeTileData(neighbour);
      }
    }
    currentLabels.removeAll(undrawableElements);
    List<MapElementContainer> currentElementsOrdered=LayerUtil.collisionFreeOrdered(currentLabels);
    Iterator<MapElementContainer> currentMapElementsIterator=currentElementsOrdered.iterator();
    while (currentMapElementsIterator.hasNext()) {
      MapElementContainer current=currentMapElementsIterator.next();
      for (      MapElementContainer label : labelsToDraw) {
        if (label.clashesWith(current)) {
          currentMapElementsIterator.remove();
          break;
        }
      }
    }
    labelsToDraw.addAll(currentElementsOrdered);
    for (    Tile tile : neighbours) {
      tileDependencies.removeTileData(rendererJob.tile,tile);
      for (      MapElementContainer element : labelsToDraw) {
        if (element.intersects(tile.getBoundaryAbsolute())) {
          tileDependencies.addOverlappingElement(rendererJob.tile,tile,element);
        }
      }
    }
    this.canvasRasterer.drawMapElements(currentWayLabels,rendererJob.tile);
    this.canvasRasterer.drawMapElements(labelsToDraw,rendererJob.tile);
  }
 else {
    this.labelStore.storeMapItems(rendererJob.tile,this.currentLabels);
  }
  for (int i=this.ways.size() - 1; i >= 0; --i) {
    List<List<ShapePaintContainer>> innerWayList=this.ways.get(i);
    for (int j=innerWayList.size() - 1; j >= 0; --j) {
      innerWayList.get(j).clear();
    }
  }
  return bitmap;
}"
93328,"@Override protected void onDestroy(){
  super.onDestroy();
  destroyTileCaches();
  destroyMapViewPositions();
  destroyMapViews();
  this.sharedPreferences.unregisterOnSharedPreferenceChangeListener(this);
  org.mapsforge.map.android.graphics.AndroidResourceBitmap.clearResourceBitmaps();
}","@Override protected void onDestroy(){
  super.onDestroy();
  destroyControls();
  destroyTileCaches();
  destroyMapViewPositions();
  destroyMapViews();
  this.sharedPreferences.unregisterOnSharedPreferenceChangeListener(this);
  org.mapsforge.map.android.graphics.AndroidResourceBitmap.clearResourceBitmaps();
}"
93329,"@Override protected void createLayers(){
  tileRendererLayer=Utils.createTileRendererLayer(this.tileCaches.get(0),this.mapViewPositions.get(0),getMapFile(),getRenderTheme(),false,true);
  this.layerManagers.get(0).getLayers().add(tileRendererLayer);
  this.changerThread=new ChangerThread();
  this.changerThread.start();
}","@Override protected void createLayers(){
  tileRendererLayer=Utils.createTileRendererLayer(this.tileCaches.get(0),this.mapViewPositions.get(0),getMapFile(),getRenderTheme(),false,true);
  this.layerManagers.get(0).getLayers().add(tileRendererLayer);
}"
93330,"@Override protected void doWork() throws InterruptedException {
  TileSizeChanger.this.changeTileSize();
  sleep(ROTATION_TIME);
}","@Override protected void doWork() throws InterruptedException {
  sleep(ROTATION_TIME);
  TileSizeChanger.this.changeTileSize();
}"
93331,"void changeTileSize(){
  Integer[] tileSizes={256,120,0,120};
  if (tileSizes.length > 0) {
    int tileSize=tileSizes[iteration % tileSizes.length];
    this.mapViews.get(0).getModel().displayModel.setFixedTileSize(tileSize);
    iteration+=1;
    destroyTileCaches();
    createTileCaches();
    this.mapViews.get(0).getMapScaleBar().redrawScaleBar();
    layerManagers.get(0).redrawLayers();
  }
}","void changeTileSize(){
  Integer[] tileSizes={256,120,0,120};
  if (tileSizes.length > 0) {
    iteration+=1;
    destroyLayers();
    destroyTileCaches();
    int tileSize=tileSizes[iteration % tileSizes.length];
    this.mapViews.get(0).getModel().displayModel.setFixedTileSize(tileSize);
    createTileCaches();
    createLayers();
    this.mapViews.get(0).getMapScaleBar().redrawScaleBar();
    layerManagers.get(0).redrawLayers();
  }
}"
93332,"synchronized void onSizeChanged(){
  this.destroy();
  this.mapViewCanvas=new Canvas();
  this.width=this.mapView.getWidth();
  this.height=this.mapView.getHeight();
  this.mapViewBitmap1=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  this.mapViewBitmap2=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  clear();
  this.mapViewCanvas.setBitmap(this.mapViewBitmap1);
}","synchronized void onSizeChanged(){
  this.width=this.mapView.getWidth();
  this.height=this.mapView.getHeight();
  this.mapViewBitmap1=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  this.mapViewBitmap2=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  clear();
  this.mapViewCanvas.setBitmap(this.mapViewBitmap1);
}"
93333,"synchronized void destroy(){
  if (this.mapViewBitmap1 != null) {
    this.mapViewBitmap1.recycle();
  }
  if (this.mapViewBitmap2 != null) {
    this.mapViewBitmap2.recycle();
  }
  this.mapViewCanvas=null;
}","synchronized void destroy(){
  if (this.mapViewBitmap1 != null) {
    this.mapViewBitmap1.recycle();
  }
  if (this.mapViewBitmap2 != null) {
    this.mapViewBitmap2.recycle();
  }
}"
93334,"void destroy(){
  this.overlayController.interrupt();
  this.mapMover.interrupt();
  this.mapWorker.interrupt();
  this.zoomAnimator.interrupt();
  try {
    this.mapWorker.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  this.frameBuffer.destroy();
  this.mapScaleBar.destroy();
  this.inMemoryTileCache.destroy();
  this.fileSystemTileCache.destroy();
  this.databaseRenderer.destroy();
  this.mapDatabase.closeFile();
}","void destroy(){
  this.overlayController.interrupt();
  this.mapMover.interrupt();
  this.mapWorker.interrupt();
  this.zoomAnimator.interrupt();
  try {
    this.mapWorker.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  this.frameBuffer.destroy();
  this.mapScaleBar.destroy();
  this.inMemoryTileCache.destroy();
  this.fileSystemTileCache.destroy();
  this.mapDatabase.closeFile();
}"
93335,"/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}","/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}"
93336,"private boolean checkSize(){
  this.sizeChange.writeLock().lock();
  try {
    if (this.changeSizeNeeded) {
      return changeSize();
    }
    return true;
  }
  finally {
    this.sizeChange.writeLock().unlock();
  }
}","private boolean checkSize(){
  if (this.changeSizeNeeded) {
    return changeSize();
  }
  return true;
}"
93337,"private void recycleBitmaps(){
  if (this.bitmap1 != null) {
    this.bitmap1.recycle();
    this.bitmap1=null;
  }
  if (this.bitmap2 != null) {
    this.bitmap2.recycle();
    this.bitmap2=null;
  }
  this.overlayCanvas=null;
}","private void recycleBitmaps(){
  recycleBitmap(this.bitmap1);
  recycleBitmap(this.bitmap2);
}"
93338,"@Override protected void afterRun(){
  this.recycleBitmaps();
}","@Override protected void afterRun(){
  recycleBitmaps();
}"
93339,"private void redraw(){
  if (this.overlayCanvas == null) {
    this.overlayCanvas=new Canvas();
  }
  this.bitmap2.eraseColor(Color.TRANSPARENT);
  this.overlayCanvas.setBitmap(this.bitmap2);
  MapPosition mapPositionBefore=this.mapView.getMapViewPosition().getMapPosition();
  BoundingBox boundingBox=this.mapView.getMapViewPosition().getBoundingBox();
  List<Overlay> overlays=this.mapView.getOverlays();
synchronized (overlays) {
    for (    Overlay overlay : overlays) {
      overlay.draw(boundingBox,mapPositionBefore.zoomLevel,this.overlayCanvas);
    }
  }
  MapPosition mapPositionAfter=this.mapView.getMapViewPosition().getMapPosition();
synchronized (this.matrix) {
    adjustMatrix(mapPositionBefore,mapPositionAfter);
    swapBitmaps();
  }
  this.mapView.postInvalidate();
}","private void redraw(){
  this.bitmap2.eraseColor(Color.TRANSPARENT);
  this.overlayCanvas.setBitmap(this.bitmap2);
  MapPosition mapPositionBefore=this.mapView.getMapViewPosition().getMapPosition();
  BoundingBox boundingBox=this.mapView.getMapViewPosition().getBoundingBox();
  List<Overlay> overlays=this.mapView.getOverlays();
synchronized (overlays) {
    for (    Overlay overlay : overlays) {
      overlay.draw(boundingBox,mapPositionBefore.zoomLevel,this.overlayCanvas);
    }
  }
  MapPosition mapPositionAfter=this.mapView.getMapViewPosition().getMapPosition();
synchronized (this.matrix) {
    adjustMatrix(mapPositionBefore,mapPositionAfter);
    swapBitmaps();
  }
  this.mapView.postInvalidate();
}"
93340,"public OverlayController(MapView mapView){
  super();
  this.mapView=mapView;
  this.matrix=new Matrix();
  this.changeSizeNeeded=true;
}","public OverlayController(MapView mapView){
  super();
  this.mapView=mapView;
  this.matrix=new Matrix();
  this.overlayCanvas=new Canvas();
  this.changeSizeNeeded=true;
}"
93341,"private boolean changeSize(){
  int newWidth=this.mapView.getWidth();
  int newHeight=this.mapView.getHeight();
  if (newWidth > 0 && newHeight > 0) {
    if (this.width == newWidth && this.height == newHeight) {
      this.changeSizeNeeded=false;
      this.redrawNeeded=false;
      return false;
    }
    recycleBitmaps();
    this.width=newWidth;
    this.height=newHeight;
    this.bitmap1=Bitmap.createBitmap(newWidth,newHeight,Bitmap.Config.ARGB_8888);
    this.bitmap2=Bitmap.createBitmap(newWidth,newHeight,Bitmap.Config.ARGB_8888);
    this.changeSizeNeeded=false;
    this.redrawNeeded=true;
    return true;
  }
  return false;
}","private boolean changeSize(){
  recycleBitmaps();
  int width=this.mapView.getWidth();
  int height=this.mapView.getHeight();
  if (width > 0 && height > 0) {
    this.bitmap1=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    this.bitmap2=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    this.changeSizeNeeded=false;
    this.redrawNeeded=true;
    return true;
  }
  return false;
}"
93342,"private void checkRedraw(){
  this.sizeChange.readLock().lock();
  try {
    if (this.redrawNeeded) {
      this.redrawNeeded=false;
      redraw();
    }
  }
  finally {
    this.sizeChange.readLock().unlock();
  }
}","private void checkRedraw(){
  if (this.redrawNeeded) {
    this.redrawNeeded=false;
    redraw();
  }
}"
93343,"@Override public void setBitmapShader(org.mapsforge.map.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  this.bitmap=bitmap;
  android.graphics.Bitmap androidBitmap=android.graphics.Bitmap.createBitmap(bitmap.getPixels(),bitmap.getWidth(),bitmap.getHeight(),Config.ARGB_8888);
  Shader shader=new BitmapShader(androidBitmap,TileMode.REPEAT,TileMode.REPEAT);
  this.paint.setShader(shader);
}","@Override public void setBitmapShader(org.mapsforge.map.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  android.graphics.Bitmap androidBitmap=android.graphics.Bitmap.createBitmap(bitmap.getPixels(),bitmap.getWidth(),bitmap.getHeight(),Config.ARGB_8888);
  Shader shader=new BitmapShader(androidBitmap,TileMode.REPEAT,TileMode.REPEAT);
  this.paint.setShader(shader);
}"
93344,"@Override public void destroy(){
  this.fill.destroy();
  this.stroke.destroy();
}","@Override public void destroy(){
}"
93345,"@Override public void destroy(){
  this.stroke.destroy();
}","@Override public void destroy(){
}"
93346,"/** 
 * @param solo
 * @return true if the current activity uses fragments in one screen
 */
static public boolean usesFragments(Solo solo){
  if (solo.getCurrentActivity().findViewById(R.id.item_detail_container) != null) {
    return true;
  }
  return false;
}","/** 
 * @param solo
 * @return true if the current activity uses fragments in one screen
 */
public static boolean usesFragments(Solo solo){
  if (solo.getCurrentActivity().findViewById(R.id.item_detail_container) != null) {
    return true;
  }
  return false;
}"
93347,"public static void testZoomChanges(Solo solo,int iterations) throws Exception {
  MapView mapView=(MapView)solo.getView(R.id.mapView);
  MapViewPosition mapViewPosition=mapView.getModel().mapViewPosition;
  for (int i=0; i < iterations; i++) {
    byte startZoomLevel=mapViewPosition.getZoomLevel();
    mapViewPosition.zoom((byte)-1);
    solo.sleep(delay);
    mapViewPosition.zoom((byte)-6);
    solo.sleep(delay);
    mapViewPosition.zoom((byte)1);
    solo.sleep(delay);
    mapViewPosition.zoom((byte)1);
    solo.sleep(delay);
    mapViewPosition.zoom((byte)-2);
    solo.sleep(delay);
    solo.setActivityOrientation(Solo.LANDSCAPE);
    mapViewPosition.zoom((byte)2);
    solo.sleep(delay);
    mapViewPosition.zoom((byte)-3);
    solo.sleep(delay);
    mapViewPosition.zoom((byte)3);
    solo.drag(210,430,170,220,2);
    solo.sleep(delay);
    solo.drag(212,44,170,220,2);
    solo.sleep(delay);
    solo.drag(237,49,170,220,22);
    solo.sleep(delay);
    solo.drag(10,40,170,220,2);
    solo.sleep(delay);
    solo.drag(22,14,170,220,17);
    solo.sleep(delay);
    solo.drag(27,49,170,220,22);
    solo.sleep(delay);
    solo.drag(20,120,170,220,2);
    solo.sleep(delay);
    mapViewPosition.zoom((byte)-1);
    solo.setActivityOrientation(Solo.PORTRAIT);
    solo.sleep(delay);
    mapViewPosition.zoom((byte)6);
    solo.sleep(delay);
    mapViewPosition.zoom((byte)1);
    solo.sleep(delay);
    mapViewPosition.zoom((byte)-1);
    solo.sleep(delay);
    assert(mapViewPosition.getZoomLevel() == startZoomLevel);
    solo.assertMemoryNotLow();
  }
}","public static void testZoomChanges(Solo solo,int iterations) throws Exception {
}"
93348,"protected final android.graphics.Bitmap getBitmapFromReusableSet(int width,int height,Config config){
  android.graphics.Bitmap bitmap=null;
  if (reusableBitmaps != null && !reusableBitmaps.isEmpty()) {
synchronized (reusableBitmaps) {
      final Iterator<SoftReference<android.graphics.Bitmap>> iterator=reusableBitmaps.iterator();
      android.graphics.Bitmap candidate;
      while (iterator.hasNext()) {
        candidate=iterator.next().get();
        if (null != candidate && candidate.isMutable()) {
          if (canUseBitmap(candidate,width,height,config)) {
            bitmap=candidate;
            iterator.remove();
            break;
          }
        }
 else {
          iterator.remove();
        }
      }
    }
  }
  return bitmap;
}","protected final android.graphics.Bitmap getBitmapFromReusableSet(int width,int height,Config config){
  android.graphics.Bitmap result=null;
  if (reusableBitmaps != null && !reusableBitmaps.isEmpty()) {
synchronized (reusableBitmaps) {
      final Iterator<SoftReference<android.graphics.Bitmap>> iterator=reusableBitmaps.iterator();
      android.graphics.Bitmap candidate;
      while (iterator.hasNext()) {
        candidate=iterator.next().get();
        if (null != candidate && candidate.isMutable()) {
          if (canUseBitmap(candidate,width,height,config)) {
            result=candidate;
            iterator.remove();
            break;
          }
        }
 else {
          iterator.remove();
        }
      }
    }
  }
  return result;
}"
93349,"/** 
 * return the byte usage per pixel of a bitmap based on its configuration.
 */
static public int getBytesPerPixel(Config config){
  if (config == Config.ARGB_8888) {
    return 4;
  }
 else   if (config == Config.RGB_565) {
    return 2;
  }
 else   if (config == Config.ARGB_4444) {
    return 2;
  }
 else   if (config == Config.ALPHA_8) {
    return 1;
  }
  return 1;
}","/** 
 * return the byte usage per pixel of a bitmap based on its configuration.
 */
public static int getBytesPerPixel(Config config){
  if (config == Config.ARGB_8888) {
    return 4;
  }
 else   if (config == Config.RGB_565) {
    return 2;
  }
 else   if (config == Config.ARGB_4444) {
    return 2;
  }
 else   if (config == Config.ALPHA_8) {
    return 1;
  }
  return 1;
}"
93350,"private void setTileSize(){
  if (this.fixedTileSize == 0) {
    float temp=(DEFAULT_TILE_SIZE * deviceScaleFactor * userScaleFactor);
    this.tileSize=Math.max(tileSizeMultiple,(int)(Math.round(temp / this.tileSizeMultiple) * this.tileSizeMultiple));
  }
 else {
    this.tileSize=this.fixedTileSize;
  }
  this.setMaxTextWidth();
}","private void setTileSize(){
  if (this.fixedTileSize == 0) {
    float temp=DEFAULT_TILE_SIZE * deviceScaleFactor * userScaleFactor;
    this.tileSize=Math.max(tileSizeMultiple,(int)(Math.round(temp / this.tileSizeMultiple) * this.tileSizeMultiple));
  }
 else {
    this.tileSize=this.fixedTileSize;
  }
  this.setMaxTextWidth();
}"
93351,"protected ResourceScaling fromValue(String value){
  if (value.equals(SIZE))   return ResourceScaling.SIZE;
  if (value.equals(TILE))   return ResourceScaling.TILE;
  return ResourceScaling.DEFAULT;
}","protected ResourceScaling fromValue(String value){
  if (value.equals(SIZE)) {
    return ResourceScaling.SIZE;
  }
  if (value.equals(TILE)) {
    return ResourceScaling.TILE;
  }
  return ResourceScaling.DEFAULT;
}"
93352,"@Override public void endElement(String uri,String localName,String qName){
  this.elementStack.pop();
  if (ELEMENT_NAME_RULE.equals(qName)) {
    this.ruleStack.pop();
    if (this.ruleStack.empty()) {
      if (isVisible((this.currentRule))) {
        this.renderTheme.addRule(this.currentRule);
      }
    }
 else {
      this.currentRule=this.ruleStack.peek();
    }
  }
 else   if (""String_Node_Str"".equals(qName)) {
    if (null != this.xmlRenderTheme.getMenuCallback()) {
      this.categories=this.xmlRenderTheme.getMenuCallback().getCategories(this.renderThemeStyleMenu);
    }
    return;
  }
}","@Override public void endElement(String uri,String localName,String qName){
  this.elementStack.pop();
  if (ELEMENT_NAME_RULE.equals(qName)) {
    this.ruleStack.pop();
    if (this.ruleStack.empty()) {
      if (isVisible(this.currentRule)) {
        this.renderTheme.addRule(this.currentRule);
      }
    }
 else {
      this.currentRule=this.ruleStack.peek();
    }
  }
 else   if (""String_Node_Str"".equals(qName)) {
    if (null != this.xmlRenderTheme.getMenuCallback()) {
      this.categories=this.xmlRenderTheme.getMenuCallback().getCategories(this.renderThemeStyleMenu);
    }
    return;
  }
}"
93353,"@Override public synchronized void destroy(){
  if (this.bitmapGet != null) {
    this.bitmapGet.recycle();
  }
  if (this.capacity == 0) {
    return;
  }
  if (!this.persistent || !serializeMap(this.cacheDirectory,this.map)) {
    for (    File file : this.map.values()) {
      if (!file.delete()) {
        file.deleteOnExit();
      }
    }
    this.map.clear();
    if (this.cacheDirectory != null) {
      File[] filesToDelete=this.cacheDirectory.listFiles(ImageFileNameFilter.INSTANCE);
      if (filesToDelete != null) {
        for (        File file : filesToDelete) {
          if (!file.delete()) {
            file.deleteOnExit();
          }
        }
      }
      if (!this.cacheDirectory.delete()) {
        this.cacheDirectory.deleteOnExit();
      }
    }
  }
}","@Override public synchronized void destroy(){
  if (!this.persistent || !serializeMap(this.cacheDirectory,this.map)) {
    for (    File file : this.map.values()) {
      if (!file.delete()) {
        file.deleteOnExit();
      }
    }
    this.map.clear();
    File[] filesToDelete=this.cacheDirectory.listFiles(ImageFileNameFilter.INSTANCE);
    if (filesToDelete != null) {
      for (      File file : filesToDelete) {
        if (!file.delete()) {
          file.deleteOnExit();
        }
      }
    }
    if (!this.cacheDirectory.delete()) {
      this.cacheDirectory.deleteOnExit();
    }
  }
}"
93354,"@Override public synchronized void put(MapGeneratorJob mapGeneratorJob,Bitmap bitmap){
  if (this.capacity == 0) {
    return;
  }
  FileOutputStream fileOutputStream=null;
  try {
    File outputFile;
    do {
      ++this.cacheId;
      outputFile=new File(this.cacheDirectory,this.cacheId + IMAGE_FILE_NAME_EXTENSION);
    }
 while (outputFile.exists());
    this.byteBuffer.rewind();
    bitmap.copyPixelsToBuffer(this.byteBuffer);
    byte[] array=this.byteBuffer.array();
    fileOutputStream=new FileOutputStream(outputFile);
    fileOutputStream.write(array,0,array.length);
    this.map.put(mapGeneratorJob,outputFile);
  }
 catch (  IOException e) {
    LOGGER.log(Level.SEVERE,""String_Node_Str"",e);
    this.capacity=0;
  }
 finally {
    try {
      if (fileOutputStream != null) {
        fileOutputStream.close();
      }
    }
 catch (    IOException e) {
      LOGGER.log(Level.SEVERE,null,e);
    }
  }
}","@Override public synchronized void put(MapGeneratorJob mapGeneratorJob,Bitmap bitmap){
  if (this.capacity == 0) {
    return;
  }
  FileOutputStream fileOutputStream=null;
  try {
    File outputFile;
    do {
      ++this.cacheId;
      outputFile=new File(this.cacheDirectory,this.cacheId + IMAGE_FILE_NAME_EXTENSION);
    }
 while (outputFile.exists());
    this.byteBuffer.rewind();
    bitmap.copyPixelsToBuffer(this.byteBuffer);
    byte[] array=this.byteBuffer.array();
    fileOutputStream=new FileOutputStream(outputFile);
    fileOutputStream.write(array,0,array.length);
    this.map.put(mapGeneratorJob,outputFile);
  }
 catch (  IOException e) {
    LOGGER.log(Level.SEVERE,null,e);
  }
 finally {
    try {
      if (fileOutputStream != null) {
        fileOutputStream.close();
      }
    }
 catch (    IOException e) {
      LOGGER.log(Level.SEVERE,null,e);
    }
  }
}"
93355,"/** 
 * @param capacity the maximum number of entries in this cache.
 * @param mapViewId the ID of the MapView to separate caches for different MapViews.
 * @throws IllegalArgumentException if the capacity is negative.
 */
public FileSystemTileCache(int capacity,int mapViewId){
  this.mapViewId=mapViewId;
  this.capacity=checkCapacity(capacity);
  if (this.capacity > 0 && this.cacheDirectory != null) {
    Map<MapGeneratorJob,File> deserializedMap=deserializeMap(this.cacheDirectory);
    if (deserializedMap == null) {
      this.map=createMap(this.capacity);
    }
 else {
      this.map=deserializedMap;
    }
    this.byteBuffer=ByteBuffer.allocate(TILE_SIZE_IN_BYTES);
    this.bitmapGet=Bitmap.createBitmap(Tile.TILE_SIZE,Tile.TILE_SIZE,Config.RGB_565);
  }
 else {
    this.byteBuffer=null;
    this.bitmapGet=null;
    this.map=createMap(0);
  }
}","/** 
 * @param capacity the maximum number of entries in this cache.
 * @param mapViewId the ID of the MapView to separate caches for different MapViews.
 * @throws IllegalArgumentException if the capacity is negative.
 */
public FileSystemTileCache(int capacity,int mapViewId){
  this.capacity=getCapacity(capacity);
  String externalStorageDirectory=Environment.getExternalStorageDirectory().getAbsolutePath();
  String cacheDirectoryPath=externalStorageDirectory + CACHE_DIRECTORY + mapViewId;
  this.cacheDirectory=createDirectory(cacheDirectoryPath);
  Map<MapGeneratorJob,File> deserializedMap=deserializeMap(this.cacheDirectory);
  if (deserializedMap == null) {
    this.map=createMap(this.capacity);
  }
 else {
    this.map=deserializedMap;
  }
  this.byteBuffer=ByteBuffer.allocate(TILE_SIZE_IN_BYTES);
  this.bitmapGet=Bitmap.createBitmap(Tile.TILE_SIZE,Tile.TILE_SIZE,Config.RGB_565);
}"
93356,"@Override public synchronized void setCapacity(int capacity){
  if (this.capacity == capacity) {
    return;
  }
  this.capacity=checkCapacity(capacity);
  if (this.capacity != 0) {
    Map<MapGeneratorJob,File> newMap=createMap(this.capacity);
    if (this.map != null) {
      newMap.putAll(this.map);
    }
    this.map=newMap;
  }
}","@Override public synchronized void setCapacity(int capacity){
  if (this.capacity == capacity) {
    return;
  }
  this.capacity=getCapacity(capacity);
  Map<MapGeneratorJob,File> newMap=createMap(this.capacity);
  newMap.putAll(this.map);
  this.map=newMap;
}"
93357,"/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
    this.previousTextScale=-1;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}","/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}"
93358,"/** 
 * Gets the center point of the dimension.
 * @return the center point
 */
public Point getCenter(){
  return new Point(this.width / 2,this.height / 2);
}","/** 
 * Gets the center point of the dimension.
 * @return the center point
 */
public Point getCenter(){
  return new Point((float)this.width / 2,(float)this.height / 2);
}"
93359,"/** 
 * Calculates the zoom level that allows to display the   {@link BoundingBox} on aview with the  {@link Dimension} and tile size.
 * @param dimension the {@link Dimension} of the view
 * @param boundingBox the {@link BoundingBox} to display
 * @param tileSize the size of the tiles
 * @return the zoom level that allows to display the {@link BoundingBox} on aview with the  {@link Dimension} and tile size
 */
public static byte zoomForBounds(Dimension dimension,BoundingBox boundingBox,int tileSize){
  double dxMax=MercatorProjection.longitudeToPixelX(boundingBox.maxLongitude,(byte)0,tileSize) / tileSize;
  double dxMin=MercatorProjection.longitudeToPixelX(boundingBox.minLongitude,(byte)0,tileSize) / tileSize;
  double zoomX=Math.floor(-Math.log(3.8) * Math.log(Math.abs(dxMax - dxMin)) + dimension.width / tileSize);
  double dyMax=MercatorProjection.latitudeToPixelY(boundingBox.maxLatitude,(byte)0,tileSize) / tileSize;
  double dyMin=MercatorProjection.latitudeToPixelY(boundingBox.minLatitude,(byte)0,tileSize) / tileSize;
  double zoomY=Math.floor(-Math.log(3.8) * Math.log(Math.abs(dyMax - dyMin)) + dimension.height / tileSize);
  return (byte)Double.valueOf(Math.min(zoomX,zoomY)).intValue();
}","/** 
 * Calculates the zoom level that allows to display the   {@link BoundingBox} on aview with the  {@link Dimension} and tile size.
 * @param dimension the {@link Dimension} of the view
 * @param boundingBox the {@link BoundingBox} to display
 * @param tileSize the size of the tiles
 * @return the zoom level that allows to display the {@link BoundingBox} on aview with the  {@link Dimension} and tile size
 */
public static byte zoomForBounds(Dimension dimension,BoundingBox boundingBox,int tileSize){
  double dxMax=MercatorProjection.longitudeToPixelX(boundingBox.maxLongitude,(byte)0,tileSize) / tileSize;
  double dxMin=MercatorProjection.longitudeToPixelX(boundingBox.minLongitude,(byte)0,tileSize) / tileSize;
  double zoomX=Math.floor(-Math.log(3.8) * Math.log(Math.abs(dxMax - dxMin)) + (float)dimension.width / tileSize);
  double dyMax=MercatorProjection.latitudeToPixelY(boundingBox.maxLatitude,(byte)0,tileSize) / tileSize;
  double dyMin=MercatorProjection.latitudeToPixelY(boundingBox.minLatitude,(byte)0,tileSize) / tileSize;
  double zoomY=Math.floor(-Math.log(3.8) * Math.log(Math.abs(dyMax - dyMin)) + (float)dimension.height / tileSize);
  return (byte)Math.min(zoomX,zoomY);
}"
93360,"/** 
 * Get LatLong form Pixels.
 * @Author Stephan Brandt <stephan@contagt.com>
 */
public static LatLong fromPixels(double pixelX,double pixelY,byte zoomLevel,int tileSize){
  return new LatLong(pixelYToLatitude(pixelY,zoomLevel,tileSize),pixelXToLongitude(pixelX,zoomLevel,tileSize));
}","/** 
 * Get LatLong form Pixels.
 * @author Stephan Brandt <stephan@contagt.com>
 */
public static LatLong fromPixels(double pixelX,double pixelY,byte zoomLevel,int tileSize){
  return new LatLong(pixelYToLatitude(pixelY,zoomLevel,tileSize),pixelXToLongitude(pixelX,zoomLevel,tileSize));
}"
93361,"@Test public void latitudeToPixelYTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double pixelY=MercatorProjection.latitudeToPixelY(MercatorProjection.LATITUDE_MAX,zoomLevel,tileSize);
      Assert.assertEquals(0,pixelY,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      pixelY=MercatorProjection.latitudeToPixelY(0,zoomLevel,tileSize);
      Assert.assertEquals(mapSize / 2,pixelY,0);
      pixelY=MercatorProjection.latitudeToPixelY(MercatorProjection.LATITUDE_MIN,zoomLevel,tileSize);
      Assert.assertEquals(mapSize,pixelY,0);
    }
  }
}","@Test public void latitudeToPixelYTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double pixelY=MercatorProjection.latitudeToPixelY(MercatorProjection.LATITUDE_MAX,zoomLevel,tileSize);
      Assert.assertEquals(0,pixelY,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      pixelY=MercatorProjection.latitudeToPixelY(0,zoomLevel,tileSize);
      Assert.assertEquals((float)mapSize / 2,pixelY,0);
      pixelY=MercatorProjection.latitudeToPixelY(MercatorProjection.LATITUDE_MIN,zoomLevel,tileSize);
      Assert.assertEquals(mapSize,pixelY,0);
    }
  }
}"
93362,"@Test public void pixelXToLongitudeTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double longitude=MercatorProjection.pixelXToLongitude(0,zoomLevel,tileSize);
      Assert.assertEquals(LatLongUtils.LONGITUDE_MIN,longitude,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      longitude=MercatorProjection.pixelXToLongitude(mapSize / 2,zoomLevel,tileSize);
      Assert.assertEquals(0,longitude,0);
      longitude=MercatorProjection.pixelXToLongitude(mapSize,zoomLevel,tileSize);
      Assert.assertEquals(LatLongUtils.LONGITUDE_MAX,longitude,0);
    }
    verifyInvalidPixelXToLongitude(-1,(byte)0,tileSize);
    verifyInvalidPixelXToLongitude(tileSize + 1,(byte)0,tileSize);
  }
}","@Test public void pixelXToLongitudeTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double longitude=MercatorProjection.pixelXToLongitude(0,zoomLevel,tileSize);
      Assert.assertEquals(LatLongUtils.LONGITUDE_MIN,longitude,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      longitude=MercatorProjection.pixelXToLongitude((float)mapSize / 2,zoomLevel,tileSize);
      Assert.assertEquals(0,longitude,0);
      longitude=MercatorProjection.pixelXToLongitude(mapSize,zoomLevel,tileSize);
      Assert.assertEquals(LatLongUtils.LONGITUDE_MAX,longitude,0);
    }
    verifyInvalidPixelXToLongitude(-1,(byte)0,tileSize);
    verifyInvalidPixelXToLongitude(tileSize + 1,(byte)0,tileSize);
  }
}"
93363,"@Test public void longitudeToPixelXTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double pixelX=MercatorProjection.longitudeToPixelX(LatLongUtils.LONGITUDE_MIN,zoomLevel,tileSize);
      Assert.assertEquals(0,pixelX,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      pixelX=MercatorProjection.longitudeToPixelX(0,zoomLevel,tileSize);
      Assert.assertEquals(mapSize / 2,pixelX,0);
      pixelX=MercatorProjection.longitudeToPixelX(LatLongUtils.LONGITUDE_MAX,zoomLevel,tileSize);
      Assert.assertEquals(mapSize,pixelX,0);
    }
  }
}","@Test public void longitudeToPixelXTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double pixelX=MercatorProjection.longitudeToPixelX(LatLongUtils.LONGITUDE_MIN,zoomLevel,tileSize);
      Assert.assertEquals(0,pixelX,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      pixelX=MercatorProjection.longitudeToPixelX(0,zoomLevel,tileSize);
      Assert.assertEquals((float)mapSize / 2,pixelX,0);
      pixelX=MercatorProjection.longitudeToPixelX(LatLongUtils.LONGITUDE_MAX,zoomLevel,tileSize);
      Assert.assertEquals(mapSize,pixelX,0);
    }
  }
}"
93364,"@Test public void pixelYToLatitudeTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double latitude=MercatorProjection.pixelYToLatitude(0,zoomLevel,tileSize);
      Assert.assertEquals(MercatorProjection.LATITUDE_MAX,latitude,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      latitude=MercatorProjection.pixelYToLatitude(mapSize / 2,zoomLevel,tileSize);
      Assert.assertEquals(0,latitude,0);
      latitude=MercatorProjection.pixelYToLatitude(mapSize,zoomLevel,tileSize);
      Assert.assertEquals(MercatorProjection.LATITUDE_MIN,latitude,0);
    }
    verifyInvalidPixelYToLatitude(-1,(byte)0,tileSize);
    verifyInvalidPixelYToLatitude(tileSize + 1,(byte)0,tileSize);
  }
}","@Test public void pixelYToLatitudeTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double latitude=MercatorProjection.pixelYToLatitude(0,zoomLevel,tileSize);
      Assert.assertEquals(MercatorProjection.LATITUDE_MAX,latitude,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      latitude=MercatorProjection.pixelYToLatitude((float)mapSize / 2,zoomLevel,tileSize);
      Assert.assertEquals(0,latitude,0);
      latitude=MercatorProjection.pixelYToLatitude(mapSize,zoomLevel,tileSize);
      Assert.assertEquals(MercatorProjection.LATITUDE_MIN,latitude,0);
    }
    verifyInvalidPixelYToLatitude(-1,(byte)0,tileSize);
    verifyInvalidPixelYToLatitude(tileSize + 1,(byte)0,tileSize);
  }
}"
93365,"@Override public void setBitmapShader(org.mapsforge.core.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
  }
  this.paint.setColor(AndroidGraphicFactory.getColor(Color.WHITE));
  this.paint.setShader(new BitmapShader(AndroidGraphicFactory.getBitmap(bitmap),TileMode.REPEAT,TileMode.REPEAT));
}","@Override public void setBitmapShader(org.mapsforge.core.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  if (!AndroidGraphicFactory.keepResourceBitmaps && Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    bitmap.incrementRefCount();
  }
  this.paint.setColor(AndroidGraphicFactory.getColor(Color.WHITE));
  this.paint.setShader(new BitmapShader(AndroidGraphicFactory.getBitmap(bitmap),TileMode.REPEAT,TileMode.REPEAT));
}"
93366,"/** 
 * Sets the maximum zoom level of the map. <p> The maximum possible zoom level of the MapView depends also on the current   {@link DatabaseRenderer}. For example, downloading map tiles may only be possible up to a certain zoom level. Setting a higher maximum zoom level has no effect in this case.
 * @param zoomLevelMax the maximum zoom level.
 * @throws IllegalArgumentException if the maximum zoom level is smaller than the current minimum zoom level.
 */
public void setZoomLevelMax(byte zoomLevelMax){
  if (zoomLevelMax < this.zoomLevelMin) {
    throw new IllegalArgumentException();
  }
  this.zoomLevelMax=zoomLevelMax;
}","/** 
 * Sets the maximum zoom level of the map. <p> The maximum possible zoom level of the MapView depends also on other elements. For example, downloading map tiles may only be possible up to a certain zoom level. Setting a higher maximum zoom level has no effect in this case.
 * @param zoomLevelMax the maximum zoom level.
 * @throws IllegalArgumentException if the maximum zoom level is smaller than the current minimum zoom level.
 */
public void setZoomLevelMax(byte zoomLevelMax){
  if (zoomLevelMax < this.zoomLevelMin) {
    throw new IllegalArgumentException();
  }
  this.zoomLevelMax=zoomLevelMax;
}"
93367,"private PoiWayBundle processBlock(QueryParameters queryParameters,SubFileParameter subFileParameter){
  if (!processBlockSignature()) {
    return null;
  }
  int[][] zoomTable=readZoomTable(subFileParameter);
  if (zoomTable == null) {
    return null;
  }
  int zoomTableRow=queryParameters.queryZoomLevel - subFileParameter.zoomLevelMin;
  int poisOnQueryZoomLevel=zoomTable[zoomTableRow][0];
  int waysOnQueryZoomLevel=zoomTable[zoomTableRow][1];
  int firstWayOffset=this.readBuffer.readUnsignedInt();
  if (firstWayOffset < 0) {
    LOGGER.warning(INVALID_FIRST_WAY_OFFSET + firstWayOffset);
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  firstWayOffset+=this.readBuffer.getBufferPosition();
  if (firstWayOffset > this.readBuffer.getBufferSize()) {
    LOGGER.warning(INVALID_FIRST_WAY_OFFSET + firstWayOffset);
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  List<PointOfInterest> pois=processPOIs(poisOnQueryZoomLevel);
  if (pois == null) {
    return null;
  }
  if (this.readBuffer.getBufferPosition() > firstWayOffset) {
    LOGGER.warning(""String_Node_Str"" + this.readBuffer.getBufferPosition());
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  this.readBuffer.setBufferPosition(firstWayOffset);
  List<Way> ways=processWays(queryParameters,waysOnQueryZoomLevel);
  if (ways == null) {
    return null;
  }
  return new PoiWayBundle(pois,ways);
}","private PoiWayBundle processBlock(QueryParameters queryParameters,SubFileParameter subFileParameter){
  if (!processBlockSignature()) {
    return null;
  }
  int[][] zoomTable=readZoomTable(subFileParameter);
  int zoomTableRow=queryParameters.queryZoomLevel - subFileParameter.zoomLevelMin;
  int poisOnQueryZoomLevel=zoomTable[zoomTableRow][0];
  int waysOnQueryZoomLevel=zoomTable[zoomTableRow][1];
  int firstWayOffset=this.readBuffer.readUnsignedInt();
  if (firstWayOffset < 0) {
    LOGGER.warning(INVALID_FIRST_WAY_OFFSET + firstWayOffset);
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  firstWayOffset+=this.readBuffer.getBufferPosition();
  if (firstWayOffset > this.readBuffer.getBufferSize()) {
    LOGGER.warning(INVALID_FIRST_WAY_OFFSET + firstWayOffset);
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  List<PointOfInterest> pois=processPOIs(poisOnQueryZoomLevel);
  if (pois == null) {
    return null;
  }
  if (this.readBuffer.getBufferPosition() > firstWayOffset) {
    LOGGER.warning(""String_Node_Str"" + this.readBuffer.getBufferPosition());
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  this.readBuffer.setBufferPosition(firstWayOffset);
  List<Way> ways=processWays(queryParameters,waysOnQueryZoomLevel);
  if (ways == null) {
    return null;
  }
  return new PoiWayBundle(pois,ways);
}"
93368,"private static Dimension calculateFrameBufferDimension(Dimension mapViewDimension,double overdrawFactor){
  int width=(int)(mapViewDimension.width * overdrawFactor);
  int height=(int)(mapViewDimension.height * overdrawFactor);
  if (useSquareFrameBuffer) {
    float aspectRatio=mapViewDimension.width / mapViewDimension.height;
    if (aspectRatio < maxAspectRatio && aspectRatio > maxAspectRatio / 1) {
      width=Math.max(width,height);
      height=width;
    }
  }
  return new Dimension(width,height);
}","private static Dimension calculateFrameBufferDimension(Dimension mapViewDimension,double overdrawFactor){
  int width=(int)(mapViewDimension.width * overdrawFactor);
  int height=(int)(mapViewDimension.height * overdrawFactor);
  if (useSquareFrameBuffer) {
    float aspectRatio=((float)mapViewDimension.width) / mapViewDimension.height;
    if (aspectRatio < maxAspectRatio && aspectRatio > maxAspectRatio / 1) {
      width=Math.max(width,height);
      height=width;
    }
  }
  return new Dimension(width,height);
}"
93369,"public TileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,TileSource tileSource,GraphicFactory graphicFactory){
  super(tileCache,mapViewPosition,graphicFactory.createMatrix(),tileSource.hasAlpha());
  if (tileSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.tileCache=tileCache;
  this.tileSource=tileSource;
  this.graphicFactory=graphicFactory;
}","public TileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,TileSource tileSource,GraphicFactory graphicFactory){
  super(tileCache,mapViewPosition,graphicFactory.createMatrix(),tileSource.hasAlpha());
  this.tileCache=tileCache;
  this.tileSource=tileSource;
  this.graphicFactory=graphicFactory;
}"
93370,"@Override public void onDestroy(){
  if (this.bitmap != null) {
    this.bitmap.decrementRefCount();
  }
}","@Override public synchronized void onDestroy(){
  if (this.bitmap != null) {
    this.bitmap.decrementRefCount();
  }
}"
93371,"public boolean contains(Point center,Point point){
  Rectangle r=new Rectangle(center.x - bitmap.getWidth() / 2 + this.horizontalOffset,center.y - bitmap.getHeight() / 2 + this.verticalOffset,center.x + bitmap.getWidth() / 2 + this.horizontalOffset,center.y + bitmap.getHeight() / 2 + this.verticalOffset);
  return r.contains(point);
}","public synchronized boolean contains(Point center,Point point){
  Rectangle r=new Rectangle(center.x - (float)bitmap.getWidth() / 2 + this.horizontalOffset,center.y - (float)bitmap.getHeight() / 2 + this.verticalOffset,center.x + (float)bitmap.getWidth() / 2 + this.horizontalOffset,center.y + (float)bitmap.getHeight() / 2 + this.verticalOffset);
  return r.contains(point);
}"
93372,"/** 
 * This method uses an adapted greedy strategy for the fixed four position model, above, under left and right form the point of interest. It uses no priority search tree, because it will not function with symbols only with points. Instead it uses two minimum heaps. They work similar to a sweep line algorithm but have not a O(n log n +k) runtime. To find the rectangle that has the top edge, I use also a minimum Heap. The rectangles are sorted by their y coordinates.
 * @param labels label positions and text
 * @param symbols symbol positions
 * @param areaLabels area label positions and text
 * @return list of labels without overlaps with symbols and other labels by the four fixed position greedy strategy
 */
private List<PointTextContainer> processFourPointGreedy(List<PointTextContainer> labels,List<SymbolContainer> symbols,List<PointTextContainer> areaLabels,int tileSize){
  List<PointTextContainer> resolutionSet=new ArrayList<PointTextContainer>();
  ReferencePosition[] refPos=new ReferencePosition[(labels.size()) * 4];
  PriorityQueue<ReferencePosition> priorUp=new PriorityQueue<ReferencePosition>(labels.size() * 4 * 2 + labels.size() / 10 * 2,ReferencePositionYComparator.INSTANCE);
  PriorityQueue<ReferencePosition> priorDown=new PriorityQueue<ReferencePosition>(labels.size() * 4 * 2 + labels.size() / 10 * 2,ReferencePositionHeightComparator.INSTANCE);
  PointTextContainer tmp;
  int dis=START_DISTANCE_TO_SYMBOLS;
  for (int z=0; z < labels.size(); z++) {
    if (labels.get(z) != null) {
      if (labels.get(z).symbol != null) {
        tmp=labels.get(z);
        refPos[z * 4]=new ReferencePosition(tmp.x - tmp.boundary.getWidth() / 2,tmp.y - tmp.symbol.symbol.getHeight() / 2 - dis,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 1]=new ReferencePosition(tmp.x - tmp.boundary.getWidth() / 2,tmp.y + tmp.symbol.symbol.getHeight() / 2 + tmp.boundary.getHeight() + dis,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 2]=new ReferencePosition(tmp.x - tmp.symbol.symbol.getWidth() / 2 - tmp.boundary.getWidth() - dis,tmp.y + tmp.boundary.getHeight() / 2,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 3]=new ReferencePosition(tmp.x + tmp.symbol.symbol.getWidth() / 2 + dis,tmp.y + tmp.boundary.getHeight() / 2 - 0.1f,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
      }
 else {
        refPos[z * 4]=new ReferencePosition(labels.get(z).x - ((labels.get(z).boundary.getWidth()) / 2),labels.get(z).y,z,labels.get(z).boundary.getWidth(),labels.get(z).boundary.getHeight());
        refPos[z * 4 + 1]=null;
        refPos[z * 4 + 2]=null;
        refPos[z * 4 + 3]=null;
      }
    }
  }
  removeNonValidateReferencePosition(refPos,symbols,areaLabels,tileSize);
  for (int i=0; i < refPos.length; i++) {
    this.referencePosition=refPos[i];
    if (this.referencePosition != null) {
      priorUp.add(this.referencePosition);
      priorDown.add(this.referencePosition);
    }
  }
  while (priorUp.size() != 0) {
    this.referencePosition=priorUp.remove();
    this.label=labels.get(this.referencePosition.nodeNumber);
    resolutionSet.add(new PointTextContainer(this.label.text,this.referencePosition.x,this.referencePosition.y,this.label.paintFront,this.label.paintBack,this.label.symbol));
    if (priorUp.size() == 0) {
      return resolutionSet;
    }
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 0]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 1]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 2]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 3]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 0]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 1]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 2]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 3]);
    LinkedList<ReferencePosition> linkedRef=new LinkedList<ReferencePosition>();
    while (priorDown.size() != 0) {
      if (priorDown.peek().x < this.referencePosition.x + this.referencePosition.width) {
        linkedRef.add(priorDown.remove());
      }
 else {
        break;
      }
    }
    for (int i=0; i < linkedRef.size(); i++) {
      if ((linkedRef.get(i).x <= this.referencePosition.x + this.referencePosition.width) && (linkedRef.get(i).y >= this.referencePosition.y - linkedRef.get(i).height) && (linkedRef.get(i).y <= this.referencePosition.y + linkedRef.get(i).height)) {
        priorUp.remove(linkedRef.get(i));
        linkedRef.remove(i);
        i--;
      }
    }
    priorDown.addAll(linkedRef);
  }
  return resolutionSet;
}","/** 
 * This method uses an adapted greedy strategy for the fixed four position model, above, under left and right form the point of interest. It uses no priority search tree, because it will not function with symbols only with points. Instead it uses two minimum heaps. They work similar to a sweep line algorithm but have not a O(n log n +k) runtime. To find the rectangle that has the top edge, I use also a minimum Heap. The rectangles are sorted by their y coordinates.
 * @param labels label positions and text
 * @param symbols symbol positions
 * @param areaLabels area label positions and text
 * @return list of labels without overlaps with symbols and other labels by the four fixed position greedy strategy
 */
private List<PointTextContainer> processFourPointGreedy(List<PointTextContainer> labels,List<SymbolContainer> symbols,List<PointTextContainer> areaLabels,int tileSize){
  List<PointTextContainer> resolutionSet=new ArrayList<PointTextContainer>();
  ReferencePosition[] refPos=new ReferencePosition[(labels.size()) * 4];
  PriorityQueue<ReferencePosition> priorUp=new PriorityQueue<ReferencePosition>(labels.size() * 4 * 2 + labels.size() / 10 * 2,ReferencePositionYComparator.INSTANCE);
  PriorityQueue<ReferencePosition> priorDown=new PriorityQueue<ReferencePosition>(labels.size() * 4 * 2 + labels.size() / 10 * 2,ReferencePositionHeightComparator.INSTANCE);
  PointTextContainer tmp;
  int dis=START_DISTANCE_TO_SYMBOLS;
  for (int z=0; z < labels.size(); z++) {
    if (labels.get(z) != null) {
      if (labels.get(z).symbol != null) {
        tmp=labels.get(z);
        refPos[z * 4]=new ReferencePosition(tmp.x - (float)tmp.boundary.getWidth() / 2,tmp.y - (float)tmp.symbol.symbol.getHeight() / 2 - dis,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 1]=new ReferencePosition(tmp.x - (float)tmp.boundary.getWidth() / 2,tmp.y + (float)tmp.symbol.symbol.getHeight() / 2 + (float)tmp.boundary.getHeight() + dis,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 2]=new ReferencePosition(tmp.x - (float)tmp.symbol.symbol.getWidth() / 2 - tmp.boundary.getWidth() - dis,tmp.y + (float)tmp.boundary.getHeight() / 2,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 3]=new ReferencePosition(tmp.x + (float)tmp.symbol.symbol.getWidth() / 2 + dis,tmp.y + (float)tmp.boundary.getHeight() / 2 - 0.1f,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
      }
 else {
        refPos[z * 4]=new ReferencePosition(labels.get(z).x - (((float)labels.get(z).boundary.getWidth()) / 2),labels.get(z).y,z,labels.get(z).boundary.getWidth(),labels.get(z).boundary.getHeight());
        refPos[z * 4 + 1]=null;
        refPos[z * 4 + 2]=null;
        refPos[z * 4 + 3]=null;
      }
    }
  }
  removeNonValidateReferencePosition(refPos,symbols,areaLabels,tileSize);
  for (int i=0; i < refPos.length; i++) {
    this.referencePosition=refPos[i];
    if (this.referencePosition != null) {
      priorUp.add(this.referencePosition);
      priorDown.add(this.referencePosition);
    }
  }
  while (priorUp.size() != 0) {
    this.referencePosition=priorUp.remove();
    this.label=labels.get(this.referencePosition.nodeNumber);
    resolutionSet.add(new PointTextContainer(this.label.text,this.referencePosition.x,this.referencePosition.y,this.label.paintFront,this.label.paintBack,this.label.symbol));
    if (priorUp.size() == 0) {
      return resolutionSet;
    }
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 0]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 1]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 2]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 3]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 0]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 1]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 2]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 3]);
    LinkedList<ReferencePosition> linkedRef=new LinkedList<ReferencePosition>();
    while (priorDown.size() != 0) {
      if (priorDown.peek().x < this.referencePosition.x + this.referencePosition.width) {
        linkedRef.add(priorDown.remove());
      }
 else {
        break;
      }
    }
    for (int i=0; i < linkedRef.size(); i++) {
      if ((linkedRef.get(i).x <= this.referencePosition.x + this.referencePosition.width) && (linkedRef.get(i).y >= this.referencePosition.y - linkedRef.get(i).height) && (linkedRef.get(i).y <= this.referencePosition.y + linkedRef.get(i).height)) {
        priorUp.remove(linkedRef.get(i));
        linkedRef.remove(i);
        i--;
      }
    }
    priorDown.addAll(linkedRef);
  }
  return resolutionSet;
}"
93373,"public MapWorker(TileCache tileCache,JobQueue<RendererJob> jobQueue,DatabaseRenderer databaseRenderer,Layer layer){
  super();
  this.tileCache=tileCache;
  this.jobQueue=jobQueue;
  this.databaseRenderer=databaseRenderer;
  this.layer=layer;
}","public MapWorker(TileCache tileCache,JobQueue<RendererJob> jobQueue,DatabaseRenderer databaseRenderer,Layer layer){
  super();
  if (DEBUG_TIMING) {
    totalTime=new AtomicLong();
    totalExecutions=new AtomicLong();
  }
 else {
    totalTime=null;
    totalExecutions=null;
  }
  this.tileCache=tileCache;
  this.jobQueue=jobQueue;
  this.databaseRenderer=databaseRenderer;
  this.layer=layer;
}"
93374,"public DisplayModel(){
  this.setTileSize();
}","public DisplayModel(){
  super();
  this.setTileSize();
}"
93375,"public RenderThemeBuilder(GraphicFactory graphicFactory,DisplayModel displayModel1,String elementName,Attributes attributes) throws SAXException {
  this.baseStrokeWidth=1f;
  this.baseTextSize=1f;
  this.mapBackground=graphicFactory.createColor(Color.WHITE);
  extractValues(graphicFactory,elementName,attributes);
}","public RenderThemeBuilder(GraphicFactory graphicFactory,String elementName,Attributes attributes) throws SAXException {
  this.baseStrokeWidth=1f;
  this.baseTextSize=1f;
  this.mapBackground=graphicFactory.createColor(Color.WHITE);
  extractValues(graphicFactory,elementName,attributes);
}"
93376,"@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  try {
    if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDER_THEME);
      this.renderTheme=new RenderThemeBuilder(this.graphicFactory,this.displayModel,qName,attributes).build();
    }
 else     if (ELEMENT_NAME_RULE.equals(qName)) {
      checkState(qName,Element.RULE);
      Rule rule=new RuleBuilder(qName,attributes,this.ruleStack).build();
      if (!this.ruleStack.empty()) {
        this.currentRule.addSubRule(rule);
      }
      this.currentRule=rule;
      this.ruleStack.push(this.currentRule);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Area area=new AreaBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(area);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Caption caption=new CaptionBuilder(this.graphicFactory,this.displayModel,qName,attributes).build();
      this.currentRule.addRenderingInstruction(caption);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Circle circle=new CircleBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++).build();
      this.currentRule.addRenderingInstruction(circle);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Line line=new LineBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(line);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      LineSymbol lineSymbol=new LineSymbolBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(lineSymbol);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      PathText pathText=new PathTextBuilder(this.graphicFactory,this.displayModel,qName,attributes).build();
      this.currentRule.addRenderingInstruction(pathText);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Symbol symbol=new SymbolBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(symbol);
    }
 else {
      throw new SAXException(""String_Node_Str"" + qName);
    }
  }
 catch (  IOException e) {
    LOGGER.warning(""String_Node_Str"" + e.getMessage());
  }
}","@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  try {
    if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDER_THEME);
      this.renderTheme=new RenderThemeBuilder(this.graphicFactory,qName,attributes).build();
    }
 else     if (ELEMENT_NAME_RULE.equals(qName)) {
      checkState(qName,Element.RULE);
      Rule rule=new RuleBuilder(qName,attributes,this.ruleStack).build();
      if (!this.ruleStack.empty()) {
        this.currentRule.addSubRule(rule);
      }
      this.currentRule=rule;
      this.ruleStack.push(this.currentRule);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Area area=new AreaBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(area);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Caption caption=new CaptionBuilder(this.graphicFactory,this.displayModel,qName,attributes).build();
      this.currentRule.addRenderingInstruction(caption);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Circle circle=new CircleBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++).build();
      this.currentRule.addRenderingInstruction(circle);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Line line=new LineBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(line);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      LineSymbol lineSymbol=new LineSymbolBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(lineSymbol);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      PathText pathText=new PathTextBuilder(this.graphicFactory,this.displayModel,qName,attributes).build();
      this.currentRule.addRenderingInstruction(pathText);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Symbol symbol=new SymbolBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(symbol);
    }
 else {
      throw new SAXException(""String_Node_Str"" + qName);
    }
  }
 catch (  IOException e) {
    LOGGER.warning(""String_Node_Str"" + e.getMessage());
  }
}"
93377,"/** 
 * @see List#add(Object)
 */
public synchronized void add(Layer layer){
  checkIsNull(layer);
  layer.setDisplayModel(this.displayModel);
  this.layersList.add(layer);
  layer.assign(this.redrawer);
}","/** 
 * @see List#add(Object)
 */
public synchronized void add(Layer layer){
  checkIsNull(layer);
  layer.setDisplayModel(this.displayModel);
  this.layersList.add(layer);
  layer.assign(this.redrawer);
  this.redrawer.redrawLayers();
}"
93378,"/** 
 * @see List#addAll(int,Collection)
 */
public synchronized void addAll(int index,Collection<Layer> layers){
  checkIsNull(layers);
  this.layersList.addAll(index,layers);
  for (  Layer layer : layers) {
    layer.setDisplayModel(this.displayModel);
    layer.assign(this.redrawer);
  }
}","/** 
 * @see List#addAll(int,Collection)
 */
public synchronized void addAll(int index,Collection<Layer> layers){
  checkIsNull(layers);
  this.layersList.addAll(index,layers);
  for (  Layer layer : layers) {
    layer.setDisplayModel(this.displayModel);
    layer.assign(this.redrawer);
  }
  this.redrawer.redrawLayers();
}"
93379,"/** 
 * @see List#clear()
 */
public synchronized void clear(){
  for (  Layer layer : this.layersList) {
    layer.unassign();
  }
  this.layersList.clear();
}","/** 
 * @see List#clear()
 */
public synchronized void clear(){
  for (  Layer layer : this.layersList) {
    layer.unassign();
  }
  this.layersList.clear();
  this.redrawer.redrawLayers();
}"
93380,"/** 
 * @see List#remove(Object)
 */
public synchronized boolean remove(Layer layer){
  checkIsNull(layer);
  if (this.layersList.remove(layer)) {
    layer.unassign();
    return true;
  }
  return false;
}","/** 
 * @see List#remove(Object)
 */
public synchronized boolean remove(Layer layer){
  checkIsNull(layer);
  if (this.layersList.remove(layer)) {
    layer.unassign();
    this.redrawer.redrawLayers();
    return true;
  }
  return false;
}"
93381,"/** 
 * Get the number of tiles that can be stored on the file system
 * @param directory where the cache will reside
 * @param fileSize average size of tile to be cached
 * @return number of tiles that can be stored without running out of space
 */
@SuppressWarnings(""String_Node_Str"") @TargetApi(18) public static long getAvailableCacheSlots(String directory,int fileSize){
  StatFs statfs=new StatFs(directory);
  if (android.os.Build.VERSION.SDK_INT >= 18) {
    return statfs.getAvailableBytes() / fileSize;
  }
  int result=statfs.getAvailableBlocks() / (fileSize / statfs.getBlockSize());
  return result;
}","/** 
 * Get the number of tiles that can be stored on the file system
 * @param directory where the cache will reside
 * @param fileSize average size of tile to be cached
 * @return number of tiles that can be stored without running out of space
 */
@SuppressWarnings(""String_Node_Str"") @TargetApi(18) public static long getAvailableCacheSlots(String directory,int fileSize){
  StatFs statfs=new StatFs(directory);
  if (android.os.Build.VERSION.SDK_INT >= 18) {
    return statfs.getAvailableBytes() / fileSize;
  }
  int blocksPerFile=Math.max(fileSize / statfs.getBlockSize(),1);
  return statfs.getAvailableBlocks() / blocksPerFile;
}"
93382,"/** 
 * Utility function to create a two-level tile cache with the right size. When the cache is created we do not actually know the size of the mapview, so the screenRatio is an approximation of the required size
 * @param c              the Android context
 * @param id             name for the storage directory
 * @param tileSize       tile size
 * @param screenRatio    part of the screen the view takes up
 * @param overdraw       overdraw allowance
 * @return a new cache created on the external storage
 */
public static TileCache createTileCache(Context c,String id,int tileSize,float screenRatio,double overdraw){
  int cacheSize=(int)Math.round(AndroidUtil.getMinimumCacheSize(c,tileSize,overdraw,screenRatio));
  return createExternalStorageTileCache(c,id,cacheSize,tileSize);
}","/** 
 * Utility function to create a two-level tile cache with the right size. When the cache is created we do not actually know the size of the mapview, so the screenRatio is an approximation of the required size
 * @param c              the Android context
 * @param id             name for the storage directory
 * @param tileSize       tile size
 * @param screenRatio    part of the screen the view takes up
 * @param overdraw       overdraw allowance
 * @return a new cache created on the external storage
 */
public static TileCache createTileCache(Context c,String id,int tileSize,float screenRatio,double overdraw){
  int cacheSize=Math.round(AndroidUtil.getMinimumCacheSize(c,tileSize,overdraw,screenRatio));
  return createExternalStorageTileCache(c,id,cacheSize,tileSize);
}"
93383,"@Override public void draw(BoundingBox boundingBox,byte zoomLevel,Canvas canvas,Point topLeftPoint){
  List<TilePosition> tilePositions=LayerUtil.getTilePositions(boundingBox,zoomLevel,topLeftPoint,this.displayModel.getTileSize());
  if (!isTransparent) {
    canvas.fillColor(this.displayModel.getBackgroundColor());
  }
  for (int i=tilePositions.size() - 1; i >= 0; --i) {
    TilePosition tilePosition=tilePositions.get(i);
    Point point=tilePosition.point;
    Tile tile=tilePosition.tile;
    Bitmap bitmap=this.tileCache.get(createJob(tile));
    if (bitmap == null) {
      this.jobQueue.add(createJob(tile));
      drawParentTileBitmap(canvas,point,tile);
    }
 else {
      canvas.drawBitmap(bitmap,(int)Math.round(point.x),(int)Math.round(point.y));
      bitmap.decrementRefCount();
    }
  }
  this.jobQueue.notifyWorkers();
}","@Override public void draw(BoundingBox boundingBox,byte zoomLevel,Canvas canvas,Point topLeftPoint){
  List<TilePosition> tilePositions=LayerUtil.getTilePositions(boundingBox,zoomLevel,topLeftPoint,this.displayModel.getTileSize());
  canvas.resetClip();
  if (!isTransparent) {
    canvas.fillColor(this.displayModel.getBackgroundColor());
  }
  for (int i=tilePositions.size() - 1; i >= 0; --i) {
    TilePosition tilePosition=tilePositions.get(i);
    Point point=tilePosition.point;
    Tile tile=tilePosition.tile;
    Bitmap bitmap=this.tileCache.get(createJob(tile));
    if (bitmap == null) {
      this.jobQueue.add(createJob(tile));
      drawParentTileBitmap(canvas,point,tile);
    }
 else {
      canvas.drawBitmap(bitmap,(int)Math.round(point.x),(int)Math.round(point.y));
      bitmap.decrementRefCount();
    }
  }
  this.jobQueue.notifyWorkers();
}"
93384,"@Override public void renderArea(Paint fill,Paint stroke,int level){
  List<ShapePaintContainer> list=this.drawingLayers.get(level);
  list.add(new ShapePaintContainer(this.shapeContainer,fill));
  list.add(new ShapePaintContainer(this.shapeContainer,stroke));
}","@Override public void renderArea(Paint fill,Paint stroke,int level){
  List<ShapePaintContainer> list=this.drawingLayers.get(level);
  list.add(new ShapePaintContainer(this.shapeContainer,stroke));
  list.add(new ShapePaintContainer(this.shapeContainer,fill));
}"
93385,"public static Point getTopLeftPoint(MapPosition mapPosition,Dimension canvasDimension){
  LatLong centerPoint=mapPosition.latLong;
  byte zoomLevel=mapPosition.zoomLevel;
  int halfCanvasWidth=canvasDimension.width / 2;
  int halfCanvasHeight=canvasDimension.height / 2;
  double pixelX=MercatorProjection.longitudeToPixelX(centerPoint.longitude,zoomLevel) - halfCanvasWidth;
  double pixelY=MercatorProjection.latitudeToPixelY(centerPoint.latitude,zoomLevel) - halfCanvasHeight;
  return new Point(pixelX,pixelY);
}","public static Point getTopLeftPoint(MapPosition mapPosition,Dimension canvasDimension){
  LatLong centerPoint=mapPosition.latLong;
  byte zoomLevel=mapPosition.zoomLevel;
  int halfCanvasWidth=canvasDimension.width / 2;
  int halfCanvasHeight=canvasDimension.height / 2;
  double pixelX=Math.round(MercatorProjection.longitudeToPixelX(centerPoint.longitude,zoomLevel));
  double pixelY=Math.round(MercatorProjection.latitudeToPixelY(centerPoint.latitude,zoomLevel));
  return new Point((int)pixelX - halfCanvasWidth,(int)pixelY - halfCanvasHeight);
}"
93386,"@Override protected void init(){
  super.init();
  this.mapView2.getModel().mapViewPosition.setZoomLevel((byte)12);
  this.observer=new MapViewPositionObserver(this.mapView.getModel().mapViewPosition,this.mapView2.getModel().mapViewPosition){
    Polyline lastLine;
    @Override protected void setCenter(){
      super.setCenter();
      BoundingBox bbox=MapPositionUtil.getBoundingBox(DualOverviewMapViewer.this.mapView.getModel().mapViewPosition.getMapPosition(),DualOverviewMapViewer.this.mapView.getDimension());
      Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.RED),2,Style.STROKE);
      Polyline polygon=new Polyline(paintStroke);
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.maxLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.maxLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.minLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
      if (this.lastLine != null) {
        DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().remove(this.lastLine);
      }
      DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().add(polygon);
      this.lastLine=polygon;
    }
    @Override protected void setZoom(){
    }
  }
;
}","@Override protected void init(){
  super.init();
  this.mapView2.getModel().mapViewPosition.setZoomLevel((byte)12);
  this.observer=new MapViewPositionObserver(this.mapView.getModel().mapViewPosition,this.mapView2.getModel().mapViewPosition){
    Polyline lastLine;
    @Override protected void setCenter(){
      super.setCenter();
      BoundingBox bbox=MapPositionUtil.getBoundingBox(DualOverviewMapViewer.this.mapView.getModel().mapViewPosition.getMapPosition(),DualOverviewMapViewer.this.mapView.getDimension());
      Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.RED),2,Style.STROKE);
      Polyline polygon=new Polyline(paintStroke,AndroidGraphicFactory.INSTANCE);
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.maxLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.maxLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.minLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
      if (this.lastLine != null) {
        DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().remove(this.lastLine);
      }
      DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().add(polygon);
      this.lastLine=polygon;
    }
    @Override protected void setZoom(){
    }
  }
;
}"
93387,"@Override protected void setCenter(){
  super.setCenter();
  BoundingBox bbox=MapPositionUtil.getBoundingBox(DualOverviewMapViewer.this.mapView.getModel().mapViewPosition.getMapPosition(),DualOverviewMapViewer.this.mapView.getDimension());
  Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.RED),2,Style.STROKE);
  Polyline polygon=new Polyline(paintStroke);
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.maxLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.maxLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.minLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
  if (this.lastLine != null) {
    DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().remove(this.lastLine);
  }
  DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().add(polygon);
  this.lastLine=polygon;
}","@Override protected void setCenter(){
  super.setCenter();
  BoundingBox bbox=MapPositionUtil.getBoundingBox(DualOverviewMapViewer.this.mapView.getModel().mapViewPosition.getMapPosition(),DualOverviewMapViewer.this.mapView.getDimension());
  Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.RED),2,Style.STROKE);
  Polyline polygon=new Polyline(paintStroke,AndroidGraphicFactory.INSTANCE);
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.maxLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.maxLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.minLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
  if (this.lastLine != null) {
    DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().remove(this.lastLine);
  }
  DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().add(polygon);
  this.lastLine=polygon;
}"
93388,"protected void addOverlayLayers(List<Layer> layers){
  LatLong latLong1=new LatLong(52.5,13.4);
  LatLong latLong2=new LatLong(52.499,13.402);
  LatLong latLong3=new LatLong(52.503,13.399);
  LatLong latLong4=new LatLong(52.51,13.401);
  LatLong latLong5=new LatLong(52.508,13.408);
  Polyline polyline=new Polyline(Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.BLUE),8,Style.STROKE));
  List<LatLong> latLongs=polyline.getLatLongs();
  latLongs.add(latLong1);
  latLongs.add(latLong2);
  latLongs.add(latLong3);
  Paint paintFill=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.GREEN),2,Style.STROKE);
  Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.BLACK),2,Style.STROKE);
  Polygon polygon=new Polygon(paintFill,paintStroke,AndroidGraphicFactory.INSTANCE);
  latLongs=polygon.getLatLongs();
  latLongs.add(latLong2);
  latLongs.add(latLong3);
  latLongs.add(latLong4);
  latLongs.add(latLong5);
  Marker marker1=Utils.createMarker(this,R.drawable.marker_red,latLong1);
  Circle circle=new Circle(latLong3,300,Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.WHITE),0,Style.FILL),null);
  layers.add(polyline);
  layers.add(polygon);
  layers.add(circle);
  layers.add(marker1);
}","protected void addOverlayLayers(List<Layer> layers){
  LatLong latLong1=new LatLong(52.5,13.4);
  LatLong latLong2=new LatLong(52.499,13.402);
  LatLong latLong3=new LatLong(52.503,13.399);
  LatLong latLong4=new LatLong(52.51,13.401);
  LatLong latLong5=new LatLong(52.508,13.408);
  Polyline polyline=new Polyline(Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.BLUE),8,Style.STROKE),AndroidGraphicFactory.INSTANCE);
  List<LatLong> latLongs=polyline.getLatLongs();
  latLongs.add(latLong1);
  latLongs.add(latLong2);
  latLongs.add(latLong3);
  Paint paintFill=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.GREEN),2,Style.STROKE);
  Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.BLACK),2,Style.STROKE);
  Polygon polygon=new Polygon(paintFill,paintStroke,AndroidGraphicFactory.INSTANCE);
  latLongs=polygon.getLatLongs();
  latLongs.add(latLong2);
  latLongs.add(latLong3);
  latLongs.add(latLong4);
  latLongs.add(latLong5);
  Marker marker1=Utils.createMarker(this,R.drawable.marker_red,latLong1);
  Circle circle=new Circle(latLong3,300,Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.WHITE),0,Style.FILL),null);
  layers.add(polyline);
  layers.add(polygon);
  layers.add(circle);
  layers.add(marker1);
}"
93389,"private MapReadResult processBlocks(QueryParameters queryParameters,SubFileParameter subFileParameter) throws IOException {
  boolean queryIsWater=true;
  boolean queryReadWaterInfo=false;
  MapReadResultBuilder mapReadResultBuilder=new MapReadResultBuilder();
  for (long row=queryParameters.fromBlockY; row <= queryParameters.toBlockY; ++row) {
    for (long column=queryParameters.fromBlockX; column <= queryParameters.toBlockX; ++column) {
      long blockNumber=row * subFileParameter.blocksWidth + column;
      long currentBlockIndexEntry=this.databaseIndexCache.getIndexEntry(subFileParameter,blockNumber);
      if (queryIsWater) {
        queryIsWater&=(currentBlockIndexEntry & BITMASK_INDEX_WATER) != 0;
        queryReadWaterInfo=true;
      }
      long currentBlockPointer=currentBlockIndexEntry & BITMASK_INDEX_OFFSET;
      if (currentBlockPointer < 1 || currentBlockPointer > subFileParameter.subFileSize) {
        LOGGER.warning(""String_Node_Str"" + currentBlockPointer);
        LOGGER.warning(""String_Node_Str"" + subFileParameter.subFileSize);
        return null;
      }
      long nextBlockPointer;
      if (blockNumber + 1 == subFileParameter.numberOfBlocks) {
        nextBlockPointer=subFileParameter.subFileSize;
      }
 else {
        nextBlockPointer=this.databaseIndexCache.getIndexEntry(subFileParameter,blockNumber + 1) & BITMASK_INDEX_OFFSET;
        if (nextBlockPointer > subFileParameter.subFileSize) {
          LOGGER.warning(""String_Node_Str"" + nextBlockPointer);
          LOGGER.warning(""String_Node_Str"" + subFileParameter.subFileSize);
          return null;
        }
      }
      int currentBlockSize=(int)(nextBlockPointer - currentBlockPointer);
      if (currentBlockSize < 0) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
 else       if (currentBlockSize == 0) {
        continue;
      }
 else       if (currentBlockSize > ReadBuffer.MAXIMUM_BUFFER_SIZE) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        continue;
      }
 else       if (currentBlockPointer + currentBlockSize > this.fileSize) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
      this.inputFile.seek(subFileParameter.startAddress + currentBlockPointer);
      if (!this.readBuffer.readFromFile(currentBlockSize)) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
      this.tileLatitude=MercatorProjection.tileYToLatitude(subFileParameter.boundaryTileTop + row,subFileParameter.baseZoomLevel);
      this.tileLongitude=MercatorProjection.tileXToLongitude(subFileParameter.boundaryTileLeft + column,subFileParameter.baseZoomLevel);
      try {
        PoiWayBundle poiWayBundle=processBlock(queryParameters,subFileParameter);
        mapReadResultBuilder.add(poiWayBundle);
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        LOGGER.log(Level.SEVERE,null,e);
      }
    }
  }
  if (queryIsWater && queryReadWaterInfo) {
    mapReadResultBuilder.isWater=true;
  }
  return mapReadResultBuilder.build();
}","private MapReadResult processBlocks(QueryParameters queryParameters,SubFileParameter subFileParameter) throws IOException {
  boolean queryIsWater=true;
  boolean queryReadWaterInfo=false;
  MapReadResultBuilder mapReadResultBuilder=new MapReadResultBuilder();
  for (long row=queryParameters.fromBlockY; row <= queryParameters.toBlockY; ++row) {
    for (long column=queryParameters.fromBlockX; column <= queryParameters.toBlockX; ++column) {
      long blockNumber=row * subFileParameter.blocksWidth + column;
      long currentBlockIndexEntry=this.databaseIndexCache.getIndexEntry(subFileParameter,blockNumber);
      if (queryIsWater) {
        queryIsWater&=(currentBlockIndexEntry & BITMASK_INDEX_WATER) != 0;
        queryReadWaterInfo=true;
      }
      long currentBlockPointer=currentBlockIndexEntry & BITMASK_INDEX_OFFSET;
      if (currentBlockPointer < 1 || currentBlockPointer > subFileParameter.subFileSize) {
        LOGGER.warning(""String_Node_Str"" + currentBlockPointer);
        LOGGER.warning(""String_Node_Str"" + subFileParameter.subFileSize);
        return null;
      }
      long nextBlockPointer;
      if (blockNumber + 1 == subFileParameter.numberOfBlocks) {
        nextBlockPointer=subFileParameter.subFileSize;
      }
 else {
        nextBlockPointer=this.databaseIndexCache.getIndexEntry(subFileParameter,blockNumber + 1) & BITMASK_INDEX_OFFSET;
        if (nextBlockPointer > subFileParameter.subFileSize) {
          LOGGER.warning(""String_Node_Str"" + nextBlockPointer);
          LOGGER.warning(""String_Node_Str"" + subFileParameter.subFileSize);
          return null;
        }
      }
      int currentBlockSize=(int)(nextBlockPointer - currentBlockPointer);
      if (currentBlockSize < 0) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
 else       if (currentBlockSize == 0) {
        continue;
      }
 else       if (currentBlockSize > ReadBuffer.MAXIMUM_BUFFER_SIZE) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        continue;
      }
 else       if (currentBlockPointer + currentBlockSize > this.fileSize) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
      this.inputFile.seek(subFileParameter.startAddress + currentBlockPointer);
      if (!this.readBuffer.readFromFile(currentBlockSize)) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
      this.tileLatitude=MercatorProjection.tileYToLatitude(subFileParameter.boundaryTileTop + row,subFileParameter.baseZoomLevel);
      this.tileLongitude=MercatorProjection.tileXToLongitude(subFileParameter.boundaryTileLeft + column,subFileParameter.baseZoomLevel);
      try {
        PoiWayBundle poiWayBundle=processBlock(queryParameters,subFileParameter);
        if (poiWayBundle != null) {
          mapReadResultBuilder.add(poiWayBundle);
        }
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        LOGGER.log(Level.SEVERE,null,e);
      }
    }
  }
  if (queryIsWater && queryReadWaterInfo) {
    mapReadResultBuilder.isWater=true;
  }
  return mapReadResultBuilder.build();
}"
93390,"private TileCache createTileCache(){
  TileCache firstLevelTileCache=new InMemoryTileCache(32);
  File cacheDirectory=getDir(""String_Node_Str"",MODE_PRIVATE);
  TileCache secondLevelTileCache=new FileSystemTileCache(1024,cacheDirectory,AndroidGraphics.INSTANCE);
  return new TwoLevelTileCache(firstLevelTileCache,secondLevelTileCache);
}","private TileCache createTileCache(){
  TileCache firstLevelTileCache=new InMemoryTileCache(64);
  File cacheDirectory=getDir(""String_Node_Str"",MODE_PRIVATE);
  TileCache secondLevelTileCache=new FileSystemTileCache(1024,cacheDirectory,AndroidGraphics.INSTANCE);
  return new TwoLevelTileCache(firstLevelTileCache,secondLevelTileCache);
}"
93391,"private static Layer createTileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,LayerManager layerManager){
  TileSource tileSource=OpenStreetMapMapnik.INSTANCE;
  return new TileDownloadLayer(tileCache,mapViewPosition,tileSource,layerManager,GRAPHIC_FACTORY);
}","private static Layer createTileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,LayerManager layerManager){
  TileSource tileSource=OpenStreetMapMapnik.INSTANCE;
  TileDownloadLayer tileDownloadLayer=new TileDownloadLayer(tileCache,mapViewPosition,tileSource,layerManager,GRAPHIC_FACTORY);
  tileDownloadLayer.start();
  return tileDownloadLayer;
}"
93392,"@Override public void drawCircle(int x,int y,int radius,Paint paint){
  AwtPaint awtPaint=AwtGraphicFactory.getAwtPaint(paint);
  setColorAndStroke(awtPaint);
  int doubleRadius=radius * 2;
  Style style=awtPaint.style;
switch (style) {
case FILL:
    this.graphics2D.fillOval(x - radius,y - radius,doubleRadius,doubleRadius);
  return;
case STROKE:
this.graphics2D.drawOval(x - radius,y - radius,doubleRadius,doubleRadius);
return;
}
throw new IllegalArgumentException(""String_Node_Str"" + style);
}","@Override public void drawCircle(int x,int y,int radius,Paint paint){
  AwtPaint awtPaint=AwtGraphicFactory.getAwtPaint(paint);
  setColorAndStroke(awtPaint);
  int doubleRadius=radius * 2;
  Style style=awtPaint.style;
switch (style) {
case FILL:
    this.graphics2D.fillOval(x - radius,y - radius,doubleRadius,doubleRadius);
  return;
case STROKE:
this.graphics2D.drawOval(x - radius,y - radius,doubleRadius,doubleRadius);
return;
}
throw new IllegalArgumentException(UNKNOWN_STYLE + style);
}"
93393,"@Override public void drawPath(Path path,Paint paint){
  AwtPaint awtPaint=AwtGraphicFactory.getAwtPaint(paint);
  AwtPath awtPath=AwtGraphicFactory.getAwtPath(path);
  setColorAndStroke(awtPaint);
  this.graphics2D.setPaint(awtPaint.texturePaint);
  Style style=awtPaint.style;
switch (style) {
case FILL:
    this.graphics2D.fill(awtPath.path2D);
  return;
case STROKE:
this.graphics2D.draw(awtPath.path2D);
return;
}
throw new IllegalArgumentException(""String_Node_Str"" + style);
}","@Override public void drawPath(Path path,Paint paint){
  AwtPaint awtPaint=AwtGraphicFactory.getAwtPaint(paint);
  AwtPath awtPath=AwtGraphicFactory.getAwtPath(path);
  setColorAndStroke(awtPaint);
  this.graphics2D.setPaint(awtPaint.texturePaint);
  Style style=awtPaint.style;
switch (style) {
case FILL:
    this.graphics2D.fill(awtPath.path2D);
  return;
case STROKE:
this.graphics2D.draw(awtPath.path2D);
return;
}
throw new IllegalArgumentException(UNKNOWN_STYLE + style);
}"
93394,"static AwtPaint getAwtPaint(Paint paint){
  return ((AwtPaint)paint);
}","static AwtPaint getAwtPaint(Paint paint){
  return (AwtPaint)paint;
}"
93395,"static AwtPath getAwtPath(Path path){
  return ((AwtPath)path);
}","static AwtPath getAwtPath(Path path){
  return (AwtPath)path;
}"
93396,"public TileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,TileSource tileSource,LayerManager layerManager,GraphicFactory graphicFactory){
  super(tileCache,mapViewPosition,graphicFactory);
  if (tileSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (layerManager == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.tileSource=tileSource;
  int numberOfDownloadThreads=Math.min(tileSource.getParallelRequestsLimit(),DOWNLOAD_THREADS_MAX);
  this.tileDownloadThreads=new TileDownloadThread[numberOfDownloadThreads];
  for (int i=0; i < numberOfDownloadThreads; ++i) {
    TileDownloadThread tileDownloadThread=new TileDownloadThread(tileCache,this.jobQueue,layerManager,graphicFactory);
    tileDownloadThread.start();
    this.tileDownloadThreads[i]=tileDownloadThread;
  }
}","public TileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,TileSource tileSource,LayerManager layerManager,GraphicFactory graphicFactory){
  super(tileCache,mapViewPosition,graphicFactory);
  if (tileSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (layerManager == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.tileSource=tileSource;
  int numberOfDownloadThreads=Math.min(tileSource.getParallelRequestsLimit(),DOWNLOAD_THREADS_MAX);
  this.tileDownloadThreads=new TileDownloadThread[numberOfDownloadThreads];
  for (int i=0; i < numberOfDownloadThreads; ++i) {
    this.tileDownloadThreads[i]=new TileDownloadThread(tileCache,this.jobQueue,layerManager,graphicFactory);
  }
}"
93397,"@Override public synchronized void draw(BoundingBox boundingBox,byte zoomLevel,Canvas canvas,Point canvasPosition){
  if (this.latLong == null || this.bitmap == null) {
    return;
  }
  double pixelX=MercatorProjection.longitudeToPixelX(this.latLong.longitude,zoomLevel);
  double pixelY=MercatorProjection.latitudeToPixelY(this.latLong.latitude,zoomLevel);
  int left=(int)(pixelX - canvasPosition.x + this.dx - (this.bitmap.getWidth() / 2));
  int top=(int)(pixelY - canvasPosition.y + this.dy - (this.bitmap.getHeight() / 2));
  int right=left + this.bitmap.getWidth();
  int bottom=top + this.bitmap.getHeight();
  Rectangle bitmapRectangle=new Rectangle(left,top,right,bottom);
  Rectangle canvasRectangle=new Rectangle(0,0,canvas.getWidth(),canvas.getHeight());
  if (!canvasRectangle.intersects(bitmapRectangle)) {
    return;
  }
  canvas.drawBitmap(this.bitmap,left,top);
}","@Override public synchronized void draw(BoundingBox boundingBox,byte zoomLevel,Canvas canvas,Point canvasPosition){
  if (this.latLong == null || this.bitmap == null) {
    return;
  }
  double pixelX=MercatorProjection.longitudeToPixelX(this.latLong.longitude,zoomLevel);
  double pixelY=MercatorProjection.latitudeToPixelY(this.latLong.latitude,zoomLevel);
  int halfBitmapWidth=this.bitmap.getWidth() / 2;
  int halfBitmapHeight=this.bitmap.getHeight() / 2;
  int left=(int)(pixelX - canvasPosition.x - halfBitmapWidth + this.dx);
  int top=(int)(pixelY - canvasPosition.y - halfBitmapHeight + this.dy);
  int right=left + this.bitmap.getWidth();
  int bottom=top + this.bitmap.getHeight();
  Rectangle bitmapRectangle=new Rectangle(left,top,right,bottom);
  Rectangle canvasRectangle=new Rectangle(0,0,canvas.getWidth(),canvas.getHeight());
  if (!canvasRectangle.intersects(bitmapRectangle)) {
    return;
  }
  canvas.drawBitmap(this.bitmap,left,top);
}"
93398,"@Override public void destroy(){
  this.mapWorker.interrupt();
  this.mapDatabase.closeFile();
  super.destroy();
}","@Override public void destroy(){
  new DestroyThread(this.mapWorker,this.mapDatabase).start();
  super.destroy();
}"
93399,"private void restoreMapView(MapView mapView){
  SharedPreferences sharedPreferences=getSharedPreferences(PREFERENCES_FILE,MODE_PRIVATE);
  if (containsMapViewPosition(sharedPreferences)) {
    if (sharedPreferences.contains(KEY_MAP_FILE)) {
      mapView.setMapFile(new File(sharedPreferences.getString(KEY_MAP_FILE,null)));
    }
    float latitude=sharedPreferences.getFloat(KEY_LATITUDE,0);
    float longitude=sharedPreferences.getFloat(KEY_LONGITUDE,0);
    int zoomLevel=sharedPreferences.getInt(KEY_ZOOM_LEVEL,-1);
    GeoPoint geoPoint=new GeoPoint(latitude,longitude);
    MapPosition mapPosition=new MapPosition(geoPoint,(byte)zoomLevel);
    mapView.getMapViewPosition().setMapPosition(mapPosition);
  }
}","private void restoreMapView(MapView mapView){
  SharedPreferences sharedPreferences=getSharedPreferences(PREFERENCES_FILE,MODE_PRIVATE);
  if (isCompatible(sharedPreferences) && containsMapViewPosition(sharedPreferences)) {
    if (sharedPreferences.contains(KEY_MAP_FILE)) {
      mapView.setMapFile(new File(sharedPreferences.getString(KEY_MAP_FILE,null)));
    }
    float latitude=sharedPreferences.getFloat(KEY_LATITUDE,0);
    float longitude=sharedPreferences.getFloat(KEY_LONGITUDE,0);
    int zoomLevel=sharedPreferences.getInt(KEY_ZOOM_LEVEL,-1);
    GeoPoint geoPoint=new GeoPoint(latitude,longitude);
    MapPosition mapPosition=new MapPosition(geoPoint,(byte)zoomLevel);
    mapView.getMapViewPosition().setMapPosition(mapPosition);
  }
}"
93400,"@Override protected void onPause(){
  super.onPause();
  if (this.mapViews.isEmpty()) {
    return;
  }
  for (int i=0, n=this.mapViews.size(); i < n; ++i) {
    this.mapViews.get(i).onPause();
  }
  Editor editor=getSharedPreferences(PREFERENCES_FILE,MODE_PRIVATE).edit();
  editor.clear();
  MapView mapView=this.mapViews.get(0);
  MapPosition mapPosition=mapView.getMapViewPosition().getMapPosition();
  GeoPoint geoPoint=mapPosition.geoPoint;
  editor.putFloat(KEY_LATITUDE,(float)geoPoint.latitude);
  editor.putFloat(KEY_LONGITUDE,(float)geoPoint.longitude);
  editor.putInt(KEY_ZOOM_LEVEL,mapPosition.zoomLevel);
  if (mapView.getMapFile() != null) {
    editor.putString(KEY_MAP_FILE,mapView.getMapFile().getAbsolutePath());
  }
  editor.commit();
}","@Override protected void onPause(){
  super.onPause();
  if (this.mapViews.isEmpty()) {
    return;
  }
  for (int i=0, n=this.mapViews.size(); i < n; ++i) {
    this.mapViews.get(i).onPause();
  }
  Editor editor=getSharedPreferences(PREFERENCES_FILE,MODE_PRIVATE).edit();
  editor.clear();
  editor.putInt(PREFERENCES_VERSION_KEY,PREFERENCES_VERSION_NUMBER);
  MapView mapView=this.mapViews.get(0);
  MapPosition mapPosition=mapView.getMapViewPosition().getMapPosition();
  GeoPoint geoPoint=mapPosition.geoPoint;
  editor.putFloat(KEY_LATITUDE,(float)geoPoint.latitude);
  editor.putFloat(KEY_LONGITUDE,(float)geoPoint.longitude);
  editor.putInt(KEY_ZOOM_LEVEL,mapPosition.zoomLevel);
  if (mapView.getMapFile() != null) {
    editor.putString(KEY_MAP_FILE,mapView.getMapFile().getAbsolutePath());
  }
  editor.commit();
}"
93401,"synchronized void onSizeChanged(){
  this.width=this.mapView.getWidth();
  this.height=this.mapView.getHeight();
  this.mapViewBitmap1=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  this.mapViewBitmap2=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  clear();
  this.mapViewCanvas.setBitmap(this.mapViewBitmap1);
}","synchronized void onSizeChanged(){
  this.destroy();
  this.mapViewCanvas=new Canvas();
  this.width=this.mapView.getWidth();
  this.height=this.mapView.getHeight();
  this.mapViewBitmap1=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  this.mapViewBitmap2=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  clear();
  this.mapViewCanvas.setBitmap(this.mapViewBitmap1);
}"
93402,"synchronized void destroy(){
  if (this.mapViewBitmap1 != null) {
    this.mapViewBitmap1.recycle();
  }
  if (this.mapViewBitmap2 != null) {
    this.mapViewBitmap2.recycle();
  }
}","synchronized void destroy(){
  if (this.mapViewBitmap1 != null) {
    this.mapViewBitmap1.recycle();
  }
  if (this.mapViewBitmap2 != null) {
    this.mapViewBitmap2.recycle();
  }
  this.mapViewCanvas=null;
}"
93403,"void destroy(){
  this.overlayController.interrupt();
  this.mapMover.interrupt();
  this.mapWorker.interrupt();
  this.zoomAnimator.interrupt();
  try {
    this.mapWorker.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  this.frameBuffer.destroy();
  this.mapScaleBar.destroy();
  this.inMemoryTileCache.destroy();
  this.fileSystemTileCache.destroy();
  this.mapDatabase.closeFile();
}","void destroy(){
  this.overlayController.interrupt();
  this.mapMover.interrupt();
  this.mapWorker.interrupt();
  this.zoomAnimator.interrupt();
  try {
    this.mapWorker.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  this.frameBuffer.destroy();
  this.mapScaleBar.destroy();
  this.inMemoryTileCache.destroy();
  this.fileSystemTileCache.destroy();
  this.databaseRenderer.destroy();
  this.mapDatabase.closeFile();
}"
93404,"/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}","/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}"
93405,"private boolean checkSize(){
  if (this.changeSizeNeeded) {
    return changeSize();
  }
  return true;
}","private boolean checkSize(){
  this.sizeChange.writeLock().lock();
  try {
    if (this.changeSizeNeeded) {
      return changeSize();
    }
    return true;
  }
  finally {
    this.sizeChange.writeLock().unlock();
  }
}"
93406,"private void recycleBitmaps(){
  recycleBitmap(this.bitmap1);
  recycleBitmap(this.bitmap2);
}","private void recycleBitmaps(){
  if (this.bitmap1 != null) {
    this.bitmap1.recycle();
    this.bitmap1=null;
  }
  if (this.bitmap2 != null) {
    this.bitmap2.recycle();
    this.bitmap2=null;
  }
  this.overlayCanvas=null;
}"
93407,"@Override protected void afterRun(){
  recycleBitmaps();
}","@Override protected void afterRun(){
  this.recycleBitmaps();
}"
93408,"private void redraw(){
  this.bitmap2.eraseColor(Color.TRANSPARENT);
  this.overlayCanvas.setBitmap(this.bitmap2);
  MapPosition mapPositionBefore=this.mapView.getMapViewPosition().getMapPosition();
  BoundingBox boundingBox=this.mapView.getMapViewPosition().getBoundingBox();
  List<Overlay> overlays=this.mapView.getOverlays();
synchronized (overlays) {
    for (    Overlay overlay : overlays) {
      overlay.draw(boundingBox,mapPositionBefore.zoomLevel,this.overlayCanvas);
    }
  }
  MapPosition mapPositionAfter=this.mapView.getMapViewPosition().getMapPosition();
synchronized (this.matrix) {
    adjustMatrix(mapPositionBefore,mapPositionAfter);
    swapBitmaps();
  }
  this.mapView.postInvalidate();
}","private void redraw(){
  if (this.overlayCanvas == null) {
    this.overlayCanvas=new Canvas();
  }
  this.bitmap2.eraseColor(Color.TRANSPARENT);
  this.overlayCanvas.setBitmap(this.bitmap2);
  MapPosition mapPositionBefore=this.mapView.getMapViewPosition().getMapPosition();
  BoundingBox boundingBox=this.mapView.getMapViewPosition().getBoundingBox();
  List<Overlay> overlays=this.mapView.getOverlays();
synchronized (overlays) {
    for (    Overlay overlay : overlays) {
      overlay.draw(boundingBox,mapPositionBefore.zoomLevel,this.overlayCanvas);
    }
  }
  MapPosition mapPositionAfter=this.mapView.getMapViewPosition().getMapPosition();
synchronized (this.matrix) {
    adjustMatrix(mapPositionBefore,mapPositionAfter);
    swapBitmaps();
  }
  this.mapView.postInvalidate();
}"
93409,"public OverlayController(MapView mapView){
  super();
  this.mapView=mapView;
  this.matrix=new Matrix();
  this.overlayCanvas=new Canvas();
  this.changeSizeNeeded=true;
}","public OverlayController(MapView mapView){
  super();
  this.mapView=mapView;
  this.matrix=new Matrix();
  this.changeSizeNeeded=true;
}"
93410,"private boolean changeSize(){
  recycleBitmaps();
  int width=this.mapView.getWidth();
  int height=this.mapView.getHeight();
  if (width > 0 && height > 0) {
    this.bitmap1=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    this.bitmap2=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    this.changeSizeNeeded=false;
    this.redrawNeeded=true;
    return true;
  }
  return false;
}","private boolean changeSize(){
  int newWidth=this.mapView.getWidth();
  int newHeight=this.mapView.getHeight();
  if (newWidth > 0 && newHeight > 0) {
    if (this.width == newWidth && this.height == newHeight) {
      this.changeSizeNeeded=false;
      this.redrawNeeded=false;
      return false;
    }
    recycleBitmaps();
    this.width=newWidth;
    this.height=newHeight;
    this.bitmap1=Bitmap.createBitmap(newWidth,newHeight,Bitmap.Config.ARGB_8888);
    this.bitmap2=Bitmap.createBitmap(newWidth,newHeight,Bitmap.Config.ARGB_8888);
    this.changeSizeNeeded=false;
    this.redrawNeeded=true;
    return true;
  }
  return false;
}"
93411,"private void checkRedraw(){
  if (this.redrawNeeded) {
    this.redrawNeeded=false;
    redraw();
  }
}","private void checkRedraw(){
  this.sizeChange.readLock().lock();
  try {
    if (this.redrawNeeded) {
      this.redrawNeeded=false;
      redraw();
    }
  }
  finally {
    this.sizeChange.readLock().unlock();
  }
}"
93412,"@Override public void setBitmapShader(org.mapsforge.map.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  android.graphics.Bitmap androidBitmap=android.graphics.Bitmap.createBitmap(bitmap.getPixels(),bitmap.getWidth(),bitmap.getHeight(),Config.ARGB_8888);
  Shader shader=new BitmapShader(androidBitmap,TileMode.REPEAT,TileMode.REPEAT);
  this.paint.setShader(shader);
}","@Override public void setBitmapShader(org.mapsforge.map.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  this.bitmap=bitmap;
  android.graphics.Bitmap androidBitmap=android.graphics.Bitmap.createBitmap(bitmap.getPixels(),bitmap.getWidth(),bitmap.getHeight(),Config.ARGB_8888);
  Shader shader=new BitmapShader(androidBitmap,TileMode.REPEAT,TileMode.REPEAT);
  this.paint.setShader(shader);
}"
93413,"@Override public void destroy(){
}","@Override public void destroy(){
  this.fill.destroy();
  this.stroke.destroy();
}"
93414,"@Override public void destroy(){
}","@Override public void destroy(){
  this.stroke.destroy();
}"
93415,"void scale(float scaleX,float scaleY,float pivotX,float pivotY);","void scale(float scaleX,float scaleY);"
93416,"@Override public void scale(float scaleX,float scaleY,float pivotX,float pivotY){
  this.matrix.preScale(scaleX,scaleY,pivotX,pivotY);
}","@Override public void scale(float scaleX,float scaleY){
  this.matrix.preScale(scaleX,scaleY);
}"
93417,"@Override public void scale(float scaleX,float scaleY,float pivotX,float pivotY){
  this.affineTransform.scale(scaleX,scaleY);
}","@Override public void scale(float scaleX,float scaleY){
  this.affineTransform.scale(scaleX,scaleY);
}"
93418,"private void drawParentTileBitmap(Canvas canvas,Point point,Tile tile){
  Tile cachedParentTile=getCachedParentTile(tile,4);
  if (cachedParentTile != null) {
    Bitmap bitmap=this.tileCache.get(createJob(cachedParentTile));
    if (bitmap != null) {
      long translateX=tile.getShiftX(cachedParentTile) * Tile.TILE_SIZE;
      long translateY=tile.getShiftY(cachedParentTile) * Tile.TILE_SIZE;
      byte zoomLevelDiff=(byte)(tile.zoomLevel - cachedParentTile.zoomLevel);
      float scaleFactor=(float)Math.pow(2,zoomLevelDiff);
      this.matrix.reset();
      this.matrix.scale(scaleFactor,scaleFactor);
      this.matrix.translate((float)(point.x - translateX),(float)(point.y - translateY));
      canvas.drawBitmap(bitmap,this.matrix);
    }
  }
}","private void drawParentTileBitmap(Canvas canvas,Point point,Tile tile){
  Tile cachedParentTile=getCachedParentTile(tile,4);
  if (cachedParentTile != null) {
    Bitmap bitmap=this.tileCache.get(createJob(cachedParentTile));
    if (bitmap != null) {
      long translateX=tile.getShiftX(cachedParentTile) * Tile.TILE_SIZE;
      long translateY=tile.getShiftY(cachedParentTile) * Tile.TILE_SIZE;
      byte zoomLevelDiff=(byte)(tile.zoomLevel - cachedParentTile.zoomLevel);
      float scaleFactor=(float)Math.pow(2,zoomLevelDiff);
      this.matrix.reset();
      this.matrix.translate((float)(point.x - translateX),(float)(point.y - translateY));
      this.matrix.scale(scaleFactor,scaleFactor);
      canvas.drawBitmap(bitmap,this.matrix);
    }
  }
}"
93419,"public void setOverdrawFactor(double overdrawFactor){
  if (overdrawFactor <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + overdrawFactor);
  }
synchronized (this) {
    this.overdrawFactor=overdrawFactor;
  }
  notifyObservers();
}","/** 
 * @throws IllegalArgumentException if the  {@code overdrawFactor} is less or equal zero.
 */
public void setOverdrawFactor(double overdrawFactor){
  if (overdrawFactor <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + overdrawFactor);
  }
synchronized (this) {
    this.overdrawFactor=overdrawFactor;
  }
  notifyObservers();
}"
93420,"public synchronized void adjustMatrix(float diffX,float diffY,float scaleFactor,Dimension mapViewDimension){
  if (this.dimension == null) {
    return;
  }
  int pivotX=this.dimension.width / 2;
  int pivotY=this.dimension.height / 2;
  this.matrix.reset();
  this.matrix.scale(scaleFactor,scaleFactor,pivotX,pivotY);
  this.matrix.translate(diffX,diffY);
  float dx=(this.dimension.width - mapViewDimension.width) / -2f;
  float dy=(this.dimension.height - mapViewDimension.height) / -2f;
  this.matrix.translate(dx,dy);
}","public synchronized void adjustMatrix(float diffX,float diffY,float scaleFactor,Dimension mapViewDimension){
  if (this.dimension == null) {
    return;
  }
  this.matrix.reset();
  centerFrameBufferToMapView(mapViewDimension);
  scale(scaleFactor);
  this.matrix.translate(diffX,diffY);
}"
93421,"@Override public synchronized void destroy(){
  if (!this.persistent || !serializeMap(this.cacheDirectory,this.map)) {
    for (    File file : this.map.values()) {
      if (!file.delete()) {
        file.deleteOnExit();
      }
    }
    this.map.clear();
    File[] filesToDelete=this.cacheDirectory.listFiles(ImageFileNameFilter.INSTANCE);
    if (filesToDelete != null) {
      for (      File file : filesToDelete) {
        if (!file.delete()) {
          file.deleteOnExit();
        }
      }
    }
    if (!this.cacheDirectory.delete()) {
      this.cacheDirectory.deleteOnExit();
    }
  }
}","@Override public synchronized void destroy(){
  if (this.bitmapGet != null) {
    this.bitmapGet.recycle();
  }
  if (this.capacity == 0) {
    return;
  }
  if (!this.persistent || !serializeMap(this.cacheDirectory,this.map)) {
    for (    File file : this.map.values()) {
      if (!file.delete()) {
        file.deleteOnExit();
      }
    }
    this.map.clear();
    if (this.cacheDirectory != null) {
      File[] filesToDelete=this.cacheDirectory.listFiles(ImageFileNameFilter.INSTANCE);
      if (filesToDelete != null) {
        for (        File file : filesToDelete) {
          if (!file.delete()) {
            file.deleteOnExit();
          }
        }
      }
      if (!this.cacheDirectory.delete()) {
        this.cacheDirectory.deleteOnExit();
      }
    }
  }
}"
93422,"@Override public synchronized void put(MapGeneratorJob mapGeneratorJob,Bitmap bitmap){
  if (this.capacity == 0) {
    return;
  }
  FileOutputStream fileOutputStream=null;
  try {
    File outputFile;
    do {
      ++this.cacheId;
      outputFile=new File(this.cacheDirectory,this.cacheId + IMAGE_FILE_NAME_EXTENSION);
    }
 while (outputFile.exists());
    this.byteBuffer.rewind();
    bitmap.copyPixelsToBuffer(this.byteBuffer);
    byte[] array=this.byteBuffer.array();
    fileOutputStream=new FileOutputStream(outputFile);
    fileOutputStream.write(array,0,array.length);
    this.map.put(mapGeneratorJob,outputFile);
  }
 catch (  IOException e) {
    LOGGER.log(Level.SEVERE,null,e);
  }
 finally {
    try {
      if (fileOutputStream != null) {
        fileOutputStream.close();
      }
    }
 catch (    IOException e) {
      LOGGER.log(Level.SEVERE,null,e);
    }
  }
}","@Override public synchronized void put(MapGeneratorJob mapGeneratorJob,Bitmap bitmap){
  if (this.capacity == 0) {
    return;
  }
  FileOutputStream fileOutputStream=null;
  try {
    File outputFile;
    do {
      ++this.cacheId;
      outputFile=new File(this.cacheDirectory,this.cacheId + IMAGE_FILE_NAME_EXTENSION);
    }
 while (outputFile.exists());
    this.byteBuffer.rewind();
    bitmap.copyPixelsToBuffer(this.byteBuffer);
    byte[] array=this.byteBuffer.array();
    fileOutputStream=new FileOutputStream(outputFile);
    fileOutputStream.write(array,0,array.length);
    this.map.put(mapGeneratorJob,outputFile);
  }
 catch (  IOException e) {
    LOGGER.log(Level.SEVERE,""String_Node_Str"",e);
    this.capacity=0;
  }
 finally {
    try {
      if (fileOutputStream != null) {
        fileOutputStream.close();
      }
    }
 catch (    IOException e) {
      LOGGER.log(Level.SEVERE,null,e);
    }
  }
}"
93423,"/** 
 * @param capacity the maximum number of entries in this cache.
 * @param mapViewId the ID of the MapView to separate caches for different MapViews.
 * @throws IllegalArgumentException if the capacity is negative.
 */
public FileSystemTileCache(int capacity,int mapViewId){
  this.capacity=getCapacity(capacity);
  String externalStorageDirectory=Environment.getExternalStorageDirectory().getAbsolutePath();
  String cacheDirectoryPath=externalStorageDirectory + CACHE_DIRECTORY + mapViewId;
  this.cacheDirectory=createDirectory(cacheDirectoryPath);
  Map<MapGeneratorJob,File> deserializedMap=deserializeMap(this.cacheDirectory);
  if (deserializedMap == null) {
    this.map=createMap(this.capacity);
  }
 else {
    this.map=deserializedMap;
  }
  this.byteBuffer=ByteBuffer.allocate(TILE_SIZE_IN_BYTES);
  this.bitmapGet=Bitmap.createBitmap(Tile.TILE_SIZE,Tile.TILE_SIZE,Config.RGB_565);
}","/** 
 * @param capacity the maximum number of entries in this cache.
 * @param mapViewId the ID of the MapView to separate caches for different MapViews.
 * @throws IllegalArgumentException if the capacity is negative.
 */
public FileSystemTileCache(int capacity,int mapViewId){
  this.mapViewId=mapViewId;
  this.capacity=checkCapacity(capacity);
  if (this.capacity > 0 && this.cacheDirectory != null) {
    Map<MapGeneratorJob,File> deserializedMap=deserializeMap(this.cacheDirectory);
    if (deserializedMap == null) {
      this.map=createMap(this.capacity);
    }
 else {
      this.map=deserializedMap;
    }
    this.byteBuffer=ByteBuffer.allocate(TILE_SIZE_IN_BYTES);
    this.bitmapGet=Bitmap.createBitmap(Tile.TILE_SIZE,Tile.TILE_SIZE,Config.RGB_565);
  }
 else {
    this.byteBuffer=null;
    this.bitmapGet=null;
    this.map=createMap(0);
  }
}"
93424,"@Override public synchronized void setCapacity(int capacity){
  if (this.capacity == capacity) {
    return;
  }
  this.capacity=getCapacity(capacity);
  Map<MapGeneratorJob,File> newMap=createMap(this.capacity);
  newMap.putAll(this.map);
  this.map=newMap;
}","@Override public synchronized void setCapacity(int capacity){
  if (this.capacity == capacity) {
    return;
  }
  this.capacity=checkCapacity(capacity);
  if (this.capacity != 0) {
    Map<MapGeneratorJob,File> newMap=createMap(this.capacity);
    if (this.map != null) {
      newMap.putAll(this.map);
    }
    this.map=newMap;
  }
}"
93425,"/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}","/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
    this.previousTextScale=-1;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}"
93426,"private void parseAttributes(AttributeSet attrs){
  TypedArray a=getContext().obtainStyledAttributes(attrs,R.styleable.CropImageView);
  final int crop=a.getInt(R.styleable.CropImageView_crop,CropType.NONE.getCrop());
  if (crop >= 0) {
    setScaleType(ScaleType.MATRIX);
    this.cropType=CropType.get(crop);
  }
  a.recycle();
}","private void parseAttributes(AttributeSet attrs){
  final TypedArray a=getContext().obtainStyledAttributes(attrs,R.styleable.CropImageView);
  final int crop=a.getInt(R.styleable.CropImageView_crop,CropType.NONE.getCrop());
  if (crop >= 0) {
    setScaleType(ScaleType.MATRIX);
    this.cropType=CropType.get(crop);
  }
  a.recycle();
}"
93427,"@Override protected boolean setFrame(int l,int t,int r,int b){
  final boolean changed=super.setFrame(l,t,r,b);
  if (!isInEditMode()) {
    this.computeImageMatrix();
  }
  return changed;
}","@Override protected boolean setFrame(int l,int t,int r,int b){
  final boolean changed=super.setFrame(l,t,r,b);
  final Drawable drawable=getDrawable();
  if (!isInEditMode() && drawable != null) {
    this.computeImageMatrix(drawable);
  }
  return changed;
}"
93428,"@TargetApi(Build.VERSION_CODES.LOLLIPOP) public CropImageView(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
  super(context,attrs,defStyleAttr,defStyleRes);
  this.parseAttributes(attrs);
}","@TargetApi(Build.VERSION_CODES.LOLLIPOP) public CropImageView(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
  super(context,attrs,defStyleAttr,defStyleRes);
  parseAttributes(attrs);
}"
93429,"private void computeImageMatrix(){
  final int viewWidth=getWidth() - getPaddingLeft() - getPaddingRight();
  final int viewHeight=getHeight() - getPaddingTop() - getPaddingBottom();
  if (cropType != CropType.NONE && viewHeight > 0 && viewWidth > 0) {
    final Matrix matrix=getImageMatrix();
    int drawableWidth=getDrawable().getIntrinsicWidth();
    int drawableHeight=getDrawable().getIntrinsicHeight();
    final float scaleY=(float)viewHeight / (float)drawableHeight;
    final float scaleX=(float)viewWidth / (float)drawableWidth;
    final float scale=scaleX > scaleY ? scaleX : scaleY;
    matrix.setScale(scale,scale);
    final boolean verticalImageMode=scaleX > scaleY;
    final float postDrawableWidth=drawableWidth * scale;
    final float xTranslation=getXTranslation(cropType,viewWidth,postDrawableWidth,verticalImageMode);
    final float postDrawabeHeigth=drawableHeight * scale;
    final float yTranslation=getYTranslation(cropType,viewHeight,postDrawabeHeigth,verticalImageMode);
    matrix.postTranslate(xTranslation,yTranslation);
    setImageMatrix(matrix);
  }
}","private void computeImageMatrix(Drawable drawable){
  final int viewWidth=getWidth() - getPaddingLeft() - getPaddingRight();
  final int viewHeight=getHeight() - getPaddingTop() - getPaddingBottom();
  if (cropType != CropType.NONE && viewHeight > 0 && viewWidth > 0) {
    final Matrix matrix=getImageMatrix();
    int drawableWidth=drawable.getIntrinsicWidth();
    int drawableHeight=drawable.getIntrinsicHeight();
    final float scaleY=(float)viewHeight / (float)drawableHeight;
    final float scaleX=(float)viewWidth / (float)drawableWidth;
    final float scale=scaleX > scaleY ? scaleX : scaleY;
    matrix.setScale(scale,scale);
    final boolean verticalImageMode=scaleX > scaleY;
    final float postDrawableWidth=drawableWidth * scale;
    final float xTranslation=getXTranslation(cropType,viewWidth,postDrawableWidth,verticalImageMode);
    final float postDrawabeHeigth=drawableHeight * scale;
    final float yTranslation=getYTranslation(cropType,viewHeight,postDrawabeHeigth,verticalImageMode);
    matrix.postTranslate(xTranslation,yTranslation);
    setImageMatrix(matrix);
  }
}"
93430,"private float getYTranslation(CropType cropType,float scale,int viewHeight,int drawableHeight,boolean verticalImageMode){
  if (verticalImageMode) {
switch (cropType) {
case CENTER_BOTTOM:
case LEFT_BOTTOM:
case RIGHT_BOTTOM:
      return viewHeight - (scale * drawableHeight);
case LEFT_CENTER:
case RIGHT_CENTER:
    return (float)(((float)viewHeight / 2.0) - ((float)drawableHeight / 2.0));
}
}
return 0;
}","private float getYTranslation(CropType cropType,int viewHeight,float postDrawabeHeigth,boolean verticalImageMode){
  if (verticalImageMode) {
switch (cropType) {
case CENTER_BOTTOM:
case LEFT_BOTTOM:
case RIGHT_BOTTOM:
      return viewHeight - postDrawabeHeigth;
case LEFT_CENTER:
case RIGHT_CENTER:
    return (viewHeight - postDrawabeHeigth) / 2f;
}
}
return 0;
}"
93431,"private float getXTranslation(CropType cropType,float scale,int viewWidth,int drawableWidth,boolean verticalImageMode){
  if (!verticalImageMode) {
switch (cropType) {
case RIGHT_TOP:
case RIGHT_CENTER:
case RIGHT_BOTTOM:
      return viewWidth - (drawableWidth * scale);
case CENTER_TOP:
case CENTER_BOTTOM:
    return (float)(((float)viewWidth / 2.0) + ((float)drawableWidth / 2.0));
}
}
return 0;
}","private float getXTranslation(CropType cropType,int viewWidth,float postDrawableWidth,boolean verticalImageMode){
  if (!verticalImageMode) {
switch (cropType) {
case RIGHT_TOP:
case RIGHT_CENTER:
case RIGHT_BOTTOM:
      return viewWidth - postDrawableWidth;
case CENTER_TOP:
case CENTER_BOTTOM:
    return (viewWidth - postDrawableWidth) / 2f;
}
}
return 0;
}"
93432,"private void computeImageMatrix(){
  final int viewWidth=getWidth() - getPaddingLeft() - getPaddingRight();
  final int viewHeight=getHeight() - getPaddingTop() - getPaddingBottom();
  if (cropType != CropType.NONE && viewHeight > 0 && viewWidth > 0) {
    final Matrix matrix=getImageMatrix();
    int drawableWidth=getDrawable().getIntrinsicWidth();
    int drawableHeight=getDrawable().getIntrinsicHeight();
    final float scaleY=(float)viewHeight / (float)drawableHeight;
    final float scaleX=(float)viewWidth / (float)drawableWidth;
    final float scale=scaleX > scaleY ? scaleX : scaleY;
    matrix.setScale(scale,scale);
    final boolean verticalImageMode=scaleX > scaleY;
    final float xTranslation=getXTranslation(cropType,scale,viewWidth,drawableWidth,verticalImageMode);
    final float yTranslation=getYTranslation(cropType,scale,viewHeight,drawableHeight,verticalImageMode);
    matrix.postTranslate(xTranslation,yTranslation);
    setImageMatrix(matrix);
  }
}","private void computeImageMatrix(){
  final int viewWidth=getWidth() - getPaddingLeft() - getPaddingRight();
  final int viewHeight=getHeight() - getPaddingTop() - getPaddingBottom();
  if (cropType != CropType.NONE && viewHeight > 0 && viewWidth > 0) {
    final Matrix matrix=getImageMatrix();
    int drawableWidth=getDrawable().getIntrinsicWidth();
    int drawableHeight=getDrawable().getIntrinsicHeight();
    final float scaleY=(float)viewHeight / (float)drawableHeight;
    final float scaleX=(float)viewWidth / (float)drawableWidth;
    final float scale=scaleX > scaleY ? scaleX : scaleY;
    matrix.setScale(scale,scale);
    final boolean verticalImageMode=scaleX > scaleY;
    final float postDrawableWidth=drawableWidth * scale;
    final float xTranslation=getXTranslation(cropType,viewWidth,postDrawableWidth,verticalImageMode);
    final float postDrawabeHeigth=drawableHeight * scale;
    final float yTranslation=getYTranslation(cropType,viewHeight,postDrawabeHeigth,verticalImageMode);
    matrix.postTranslate(xTranslation,yTranslation);
    setImageMatrix(matrix);
  }
}"
93433,"private void initData(){
  this.pagerView.setAdapter(new CropImageAdapter());
  this.indicatorView.setViewPager(this.pagerView);
  this.indicatorView.setOnPageChangeListener(new ViewPager.OnPageChangeListener(){
    @Override public void onPageScrolled(    int i,    float v,    int i2){
    }
    @Override public void onPageSelected(    int i){
    }
    @Override public void onPageScrollStateChanged(    int i){
    }
  }
);
}","private void initData(){
  this.pagerView.setAdapter(new CropImageAdapter());
  final int pagerMargin=getResources().getDimensionPixelSize(R.dimen.activity_horizontal_margin);
  this.pagerView.setPageMargin(pagerMargin);
  this.indicatorView.setViewPager(this.pagerView);
  this.indicatorView.setOnPageChangeListener(new ViewPager.OnPageChangeListener(){
    @Override public void onPageScrolled(    int i,    float v,    int i2){
    }
    @Override public void onPageSelected(    int i){
    }
    @Override public void onPageScrollStateChanged(    int i){
    }
  }
);
}"
93434,"@Override public Object instantiateItem(ViewGroup container,int position){
  CropImageView cropImageView=new CropImageView(CropActivity.this);
  cropImageView.setImageDrawable(getResources().getDrawable(images[position]));
  final CropImageView.CropType cropType=imageCrops[position];
  cropImageView.setId(cropType.getCrop());
  cropImageView.setCropType(cropType);
  final int matchParent=ViewGroup.LayoutParams.MATCH_PARENT;
  FrameLayout.LayoutParams imageParams=new FrameLayout.LayoutParams(matchParent,matchParent);
  container.addView(cropImageView,imageParams);
  return cropImageView;
}","@Override public Object instantiateItem(ViewGroup container,int position){
  ForegroundImageView cropImageView=new ForegroundImageView(CropActivity.this);
  final Resources res=getResources();
  cropImageView.setImageDrawable(res.getDrawable(images[position]));
  cropImageView.setForeground(res.getDrawable(R.drawable.shape_grad_black_transp_70));
  final CropImageView.CropType cropType=imageCrops[position];
  cropImageView.setCropType(cropType);
  cropImageView.setId(cropType.getCrop());
  final int matchParent=ViewGroup.LayoutParams.MATCH_PARENT;
  FrameLayout.LayoutParams imageParams=new FrameLayout.LayoutParams(matchParent,matchParent);
  container.addView(cropImageView,imageParams);
  return cropImageView;
}"
93435,"/** 
 * Generate the mac based on HMAC_ALGORITHM
 * @param integrityKey The key used for hmac
 * @param byteCipherText the cipher text
 * @return A byte array of the HMAC for the given key & ciphertext
 * @throws NoSuchAlgorithmException
 * @throws InvalidKeyException
 */
public static byte[] generateMac(byte[] byteCipherText,SecretKey integrityKey) throws NoSuchAlgorithmException, InvalidKeyException {
  Mac sha256_HMAC=Mac.getInstance(HMAC_ALGORITHM);
  sha256_HMAC.init(integrityKey);
  return sha256_HMAC.doFinal(byteCipherText);
}","/** 
 * Generate the mac based on HMAC_ALGORITHM
 * @param integrityKey The key used for hmac
 * @param byteCipherText the cipher text
 * @return A byte array of the HMAC for the given key and ciphertext
 * @throws NoSuchAlgorithmException
 * @throws InvalidKeyException
 */
public static byte[] generateMac(byte[] byteCipherText,SecretKey integrityKey) throws NoSuchAlgorithmException, InvalidKeyException {
  Mac sha256_HMAC=Mac.getInstance(HMAC_ALGORITHM);
  sha256_HMAC.init(integrityKey);
  return sha256_HMAC.doFinal(byteCipherText);
}"
93436,"/** 
 * An aes key derived from a base64 encoded key. This does not generate the key. It's not random or a PBE key.
 * @param keysStr a base64 encoded AES key / hmac key as base64(aesKey) : base64(hmacKey).
 * @return an AES & HMAC key set suitable for other functions.
 */
public static SecretKeys keys(String keysStr) throws InvalidKeyException {
  String[] keysArr=keysStr.split(""String_Node_Str"");
  if (keysArr.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else {
    byte[] confidentialityKey=Base64.decode(keysArr[0],BASE64_FLAGS);
    if (confidentialityKey.length != AES_KEY_LENGTH_BITS / 8) {
      throw new InvalidKeyException(""String_Node_Str"" + AES_KEY_LENGTH_BITS + ""String_Node_Str"");
    }
    byte[] integrityKey=Base64.decode(keysArr[1],BASE64_FLAGS);
    if (integrityKey.length != HMAC_KEY_LENGTH_BITS / 8) {
      throw new InvalidKeyException(""String_Node_Str"" + HMAC_KEY_LENGTH_BITS + ""String_Node_Str"");
    }
    return new SecretKeys(new SecretKeySpec(confidentialityKey,0,confidentialityKey.length,CIPHER),new SecretKeySpec(integrityKey,HMAC_ALGORITHM));
  }
}","/** 
 * An aes key derived from a base64 encoded key. This does not generate the key. It's not random or a PBE key.
 * @param keysStr a base64 encoded AES key / hmac key as base64(aesKey) : base64(hmacKey).
 * @return an AES and HMAC key set suitable for other functions.
 */
public static SecretKeys keys(String keysStr) throws InvalidKeyException {
  String[] keysArr=keysStr.split(""String_Node_Str"");
  if (keysArr.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else {
    byte[] confidentialityKey=Base64.decode(keysArr[0],BASE64_FLAGS);
    if (confidentialityKey.length != AES_KEY_LENGTH_BITS / 8) {
      throw new InvalidKeyException(""String_Node_Str"" + AES_KEY_LENGTH_BITS + ""String_Node_Str"");
    }
    byte[] integrityKey=Base64.decode(keysArr[1],BASE64_FLAGS);
    if (integrityKey.length != HMAC_KEY_LENGTH_BITS / 8) {
      throw new InvalidKeyException(""String_Node_Str"" + HMAC_KEY_LENGTH_BITS + ""String_Node_Str"");
    }
    return new SecretKeys(new SecretKeySpec(confidentialityKey,0,confidentialityKey.length,CIPHER),new SecretKeySpec(integrityKey,HMAC_ALGORITHM));
  }
}"
93437,"/** 
 * Generates a random IV and encrypts this plain text with the given key. Then attaches a hashed MAC, which is contained in the CipherTextIvMac class.
 * @param plaintext The text that will be encrypted
 * @param secretKeys The combined AES & HMAC keys with which to encrypt
 * @return a tuple of the IV, ciphertext, mac
 * @throws GeneralSecurityException if AES is not implemented on this system
 */
public static CipherTextIvMac encrypt(byte[] plaintext,SecretKeys secretKeys) throws GeneralSecurityException {
  byte[] iv=generateIv();
  Cipher aesCipherForEncryption=Cipher.getInstance(CIPHER_TRANSFORMATION);
  aesCipherForEncryption.init(Cipher.ENCRYPT_MODE,secretKeys.getConfidentialityKey(),new IvParameterSpec(iv));
  iv=aesCipherForEncryption.getIV();
  byte[] byteCipherText=aesCipherForEncryption.doFinal(plaintext);
  byte[] ivCipherConcat=CipherTextIvMac.ivCipherConcat(iv,byteCipherText);
  byte[] integrityMac=generateMac(ivCipherConcat,secretKeys.getIntegrityKey());
  return new CipherTextIvMac(byteCipherText,iv,integrityMac);
}","/** 
 * Generates a random IV and encrypts this plain text with the given key. Then attaches a hashed MAC, which is contained in the CipherTextIvMac class.
 * @param plaintext The text that will be encrypted
 * @param secretKeys The combined AES and HMAC keys with which to encrypt
 * @return a tuple of the IV, ciphertext, mac
 * @throws GeneralSecurityException if AES is not implemented on this system
 */
public static CipherTextIvMac encrypt(byte[] plaintext,SecretKeys secretKeys) throws GeneralSecurityException {
  byte[] iv=generateIv();
  Cipher aesCipherForEncryption=Cipher.getInstance(CIPHER_TRANSFORMATION);
  aesCipherForEncryption.init(Cipher.ENCRYPT_MODE,secretKeys.getConfidentialityKey(),new IvParameterSpec(iv));
  iv=aesCipherForEncryption.getIV();
  byte[] byteCipherText=aesCipherForEncryption.doFinal(plaintext);
  byte[] ivCipherConcat=CipherTextIvMac.ivCipherConcat(iv,byteCipherText);
  byte[] integrityMac=generateMac(ivCipherConcat,secretKeys.getIntegrityKey());
  return new CipherTextIvMac(byteCipherText,iv,integrityMac);
}"
93438,"/** 
 * A function that generates password-based AES & HMAC keys. See generateKeyFromPassword.
 * @param password The password to derive the AES/HMAC keys from
 * @param salt A string version of the salt; base64 encoded.
 * @return The AES & HMAC keys.
 * @throws GeneralSecurityException
 */
public static SecretKeys generateKeyFromPassword(String password,String salt) throws GeneralSecurityException {
  return generateKeyFromPassword(password,Base64.decode(salt,BASE64_FLAGS));
}","/** 
 * A function that generates password-based AES and HMAC keys. See generateKeyFromPassword.
 * @param password The password to derive the AES/HMAC keys from
 * @param salt A string version of the salt; base64 encoded.
 * @return The AES and HMAC keys.
 * @throws GeneralSecurityException
 */
public static SecretKeys generateKeyFromPassword(String password,String salt) throws GeneralSecurityException {
  return generateKeyFromPassword(password,Base64.decode(salt,BASE64_FLAGS));
}"
93439,"/** 
 * Converts the given AES/HMAC keys into a base64 encoded string suitable for storage. Sister function of keys.
 * @param keys The combined aes and hmac keys
 * @return a base 64 encoded AES string & hmac key as base64(aesKey) : base64(hmacKey)
 */
public static String keyString(SecretKeys keys){
  return keys.toString();
}","/** 
 * Converts the given AES/HMAC keys into a base64 encoded string suitable for storage. Sister function of keys.
 * @param keys The combined aes and hmac keys
 * @return a base 64 encoded AES string and hmac key as base64(aesKey) : base64(hmacKey)
 */
public static String keyString(SecretKeys keys){
  return keys.toString();
}"
93440,"/** 
 * AES CBC decrypt.
 * @param civ The cipher text, IV, and mac
 * @param secretKeys The AES & HMAC keys
 * @return A string derived from the decrypted bytes, which are interpretedas a UTF-8 String
 * @throws GeneralSecurityException if AES is not implemented on this system
 * @throws UnsupportedEncodingException if UTF-8 is not supported
 */
public static String decryptString(CipherTextIvMac civ,SecretKeys secretKeys) throws UnsupportedEncodingException, GeneralSecurityException {
  return decryptString(civ,secretKeys,""String_Node_Str"");
}","/** 
 * AES CBC decrypt.
 * @param civ The cipher text, IV, and mac
 * @param secretKeys The AES and HMAC keys
 * @return A string derived from the decrypted bytes, which are interpretedas a UTF-8 String
 * @throws GeneralSecurityException if AES is not implemented on this system
 * @throws UnsupportedEncodingException if UTF-8 is not supported
 */
public static String decryptString(CipherTextIvMac civ,SecretKeys secretKeys) throws UnsupportedEncodingException, GeneralSecurityException {
  return decryptString(civ,secretKeys,""String_Node_Str"");
}"
93441,"/** 
 * A function that generates random AES & HMAC keys and prints out exceptions but doesn't throw them since none should be encountered. If they are encountered, the return value is null.
 * @return The AES & HMAC keys.
 * @throws GeneralSecurityException if AES is not implemented on this system,or a suitable RNG is not available
 */
public static SecretKeys generateKey() throws GeneralSecurityException {
  fixPrng();
  KeyGenerator keyGen=KeyGenerator.getInstance(CIPHER);
  keyGen.init(AES_KEY_LENGTH_BITS);
  SecretKey confidentialityKey=keyGen.generateKey();
  byte[] integrityKeyBytes=randomBytes(HMAC_KEY_LENGTH_BITS / 8);
  SecretKey integrityKey=new SecretKeySpec(integrityKeyBytes,HMAC_ALGORITHM);
  return new SecretKeys(confidentialityKey,integrityKey);
}","/** 
 * A function that generates random AES and HMAC keys and prints out exceptions but doesn't throw them since none should be encountered. If they are encountered, the return value is null.
 * @return The AES and HMAC keys.
 * @throws GeneralSecurityException if AES is not implemented on this system,or a suitable RNG is not available
 */
public static SecretKeys generateKey() throws GeneralSecurityException {
  fixPrng();
  KeyGenerator keyGen=KeyGenerator.getInstance(CIPHER);
  keyGen.init(AES_KEY_LENGTH_BITS);
  SecretKey confidentialityKey=keyGen.generateKey();
  byte[] integrityKeyBytes=randomBytes(HMAC_KEY_LENGTH_BITS / 8);
  SecretKey integrityKey=new SecretKeySpec(integrityKeyBytes,HMAC_ALGORITHM);
  return new SecretKeys(confidentialityKey,integrityKey);
}"
93442,"/** 
 * AES CBC decrypt.
 * @param civ the cipher text, iv, and mac
 * @param secretKeys the AES & HMAC keys
 * @return The raw decrypted bytes
 * @throws GeneralSecurityException if MACs don't match or AES is not implemented
 */
public static byte[] decrypt(CipherTextIvMac civ,SecretKeys secretKeys) throws GeneralSecurityException {
  byte[] ivCipherConcat=CipherTextIvMac.ivCipherConcat(civ.getIv(),civ.getCipherText());
  byte[] computedMac=generateMac(ivCipherConcat,secretKeys.getIntegrityKey());
  if (constantTimeEq(computedMac,civ.getMac())) {
    Cipher aesCipherForDecryption=Cipher.getInstance(CIPHER_TRANSFORMATION);
    aesCipherForDecryption.init(Cipher.DECRYPT_MODE,secretKeys.getConfidentialityKey(),new IvParameterSpec(civ.getIv()));
    return aesCipherForDecryption.doFinal(civ.getCipherText());
  }
 else {
    throw new GeneralSecurityException(""String_Node_Str"");
  }
}","/** 
 * AES CBC decrypt.
 * @param civ the cipher text, iv, and mac
 * @param secretKeys the AES and HMAC keys
 * @return The raw decrypted bytes
 * @throws GeneralSecurityException if MACs don't match or AES is not implemented
 */
public static byte[] decrypt(CipherTextIvMac civ,SecretKeys secretKeys) throws GeneralSecurityException {
  byte[] ivCipherConcat=CipherTextIvMac.ivCipherConcat(civ.getIv(),civ.getCipherText());
  byte[] computedMac=generateMac(ivCipherConcat,secretKeys.getIntegrityKey());
  if (constantTimeEq(computedMac,civ.getMac())) {
    Cipher aesCipherForDecryption=Cipher.getInstance(CIPHER_TRANSFORMATION);
    aesCipherForDecryption.init(Cipher.DECRYPT_MODE,secretKeys.getConfidentialityKey(),new IvParameterSpec(civ.getIv()));
    return aesCipherForDecryption.doFinal(civ.getCipherText());
  }
 else {
    throw new GeneralSecurityException(""String_Node_Str"");
  }
}"
93443,"/** 
 * Upsert the collection properties.
 * @param dbName the database name of the collection
 * @param collName the collection name
 * @param properties the new collection properties
 * @param requestEtag the entity tag. must match to allow actual write ifcheckEtag is true (otherwise http error code is returned)
 * @param updating true if updating existing document
 * @param patching true if use patch semantic (update only specified fields)
 * @param checkEtag true if etag must be checked
 * @return the HttpStatus code to set in the http response
 */
@SuppressWarnings(""String_Node_Str"") OperationResult upsertCollection(final String dbName,final String collName,final BsonDocument properties,final String requestEtag,final boolean updating,final boolean patching,final boolean checkEtag){
  if (patching && !updating) {
    return new OperationResult(HttpStatus.SC_NOT_FOUND);
  }
  if (!updating) {
    client.getDatabase(dbName).createCollection(collName);
  }
  ObjectId newEtag=new ObjectId();
  final BsonDocument content=DAOUtils.validContent(properties);
  content.put(""String_Node_Str"",new BsonObjectId(newEtag));
  content.remove(""String_Node_Str"");
  MongoDatabase mdb=client.getDatabase(dbName);
  MongoCollection<BsonDocument> mcoll=mdb.getCollection(""String_Node_Str"",BsonDocument.class);
  if (checkEtag && updating) {
    BsonDocument oldProperties=mcoll.find(eq(""String_Node_Str"",""String_Node_Str"".concat(collName))).projection(FIELDS_TO_RETURN).first();
    if (oldProperties != null) {
      BsonValue oldEtag=oldProperties.get(""String_Node_Str"");
      if (oldEtag != null && requestEtag == null) {
        return new OperationResult(HttpStatus.SC_CONFLICT,oldEtag);
      }
      BsonValue _requestEtag;
      if (ObjectId.isValid(requestEtag)) {
        _requestEtag=new BsonObjectId(new ObjectId(requestEtag));
      }
 else {
        _requestEtag=new BsonString(requestEtag);
      }
      if (Objects.equals(_requestEtag,oldEtag)) {
        return doCollPropsUpdate(collName,patching,updating,mcoll,content,newEtag);
      }
 else {
        return new OperationResult(HttpStatus.SC_PRECONDITION_FAILED,oldEtag);
      }
    }
 else {
      return doCollPropsUpdate(collName,patching,updating,mcoll,content,newEtag);
    }
  }
 else {
    return doCollPropsUpdate(collName,patching,updating,mcoll,content,newEtag);
  }
}","/** 
 * Upsert the collection properties.
 * @param dbName the database name of the collection
 * @param collName the collection name
 * @param properties the new collection properties
 * @param requestEtag the entity tag. must match to allow actual write ifcheckEtag is true (otherwise http error code is returned)
 * @param updating true if updating existing document
 * @param patching true if use patch semantic (update only specified fields)
 * @param checkEtag true if etag must be checked
 * @return the HttpStatus code to set in the http response
 */
@SuppressWarnings(""String_Node_Str"") OperationResult upsertCollection(final String dbName,final String collName,final BsonDocument properties,final String requestEtag,boolean updating,final boolean patching,final boolean checkEtag){
  if (patching && !updating) {
    return new OperationResult(HttpStatus.SC_NOT_FOUND);
  }
  if (!updating) {
    try {
      client.getDatabase(dbName).createCollection(collName);
    }
 catch (    MongoCommandException ex) {
      if (ex.getErrorCode() != 48) {
        throw ex;
      }
 else {
        updating=true;
      }
    }
  }
  ObjectId newEtag=new ObjectId();
  final BsonDocument content=DAOUtils.validContent(properties);
  content.put(""String_Node_Str"",new BsonObjectId(newEtag));
  content.remove(""String_Node_Str"");
  MongoDatabase mdb=client.getDatabase(dbName);
  MongoCollection<BsonDocument> mcoll=mdb.getCollection(""String_Node_Str"",BsonDocument.class);
  if (checkEtag && updating) {
    BsonDocument oldProperties=mcoll.find(eq(""String_Node_Str"",""String_Node_Str"".concat(collName))).projection(FIELDS_TO_RETURN).first();
    if (oldProperties != null) {
      BsonValue oldEtag=oldProperties.get(""String_Node_Str"");
      if (oldEtag != null && requestEtag == null) {
        return new OperationResult(HttpStatus.SC_CONFLICT,oldEtag);
      }
      BsonValue _requestEtag;
      if (ObjectId.isValid(requestEtag)) {
        _requestEtag=new BsonObjectId(new ObjectId(requestEtag));
      }
 else {
        _requestEtag=new BsonString(requestEtag);
      }
      if (Objects.equals(_requestEtag,oldEtag)) {
        return doCollPropsUpdate(collName,patching,updating,mcoll,content,newEtag);
      }
 else {
        return new OperationResult(HttpStatus.SC_PRECONDITION_FAILED,oldEtag);
      }
    }
 else {
      return doCollPropsUpdate(collName,patching,updating,mcoll,content,newEtag);
    }
  }
 else {
    return doCollPropsUpdate(collName,patching,updating,mcoll,content,newEtag);
  }
}"
93444,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  BsonValue responseContent=context.getResponseContent();
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    if (responseContent == null) {
      responseContent=new BsonDocument();
    }
    BsonArray warnings=new BsonArray();
    if (responseContent.isDocument()) {
      if (context.getRepresentationFormat() == RequestContext.REPRESENTATION_FORMAT.PJ || context.getRepresentationFormat() == RequestContext.REPRESENTATION_FORMAT.PLAIN_JSON) {
        context.setResponseContentType(Representation.JSON_MEDIA_TYPE);
        responseContent.asDocument().append(""String_Node_Str"",warnings);
        context.getWarnings().forEach(w -> warnings.add(new BsonString(w)));
      }
 else {
        context.setResponseContentType(Representation.HAL_JSON_MEDIA_TYPE);
        BsonDocument _embedded;
        if (responseContent.asDocument().get(""String_Node_Str"") == null) {
          _embedded=new BsonDocument();
          responseContent.asDocument().append(""String_Node_Str"",_embedded);
        }
 else {
          _embedded=responseContent.asDocument().get(""String_Node_Str"").asDocument();
        }
        _embedded.append(""String_Node_Str"",warnings);
        context.getWarnings().forEach(w -> warnings.add(getWarningDoc(w)));
      }
    }
  }
  if (context.getRepresentationFormat() == RequestContext.REPRESENTATION_FORMAT.HAL) {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,Representation.HAL_JSON_MEDIA_TYPE);
  }
 else {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,Representation.JSON_MEDIA_TYPE);
  }
  exchange.setStatusCode(context.getResponseStatusCode());
  if (responseContent != null) {
    exchange.getResponseSender().send(JsonUtils.toJson(responseContent));
  }
  exchange.endExchange();
  next(exchange,context);
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  BsonValue responseContent=context.getResponseContent();
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    if (responseContent == null) {
      responseContent=new BsonDocument();
    }
    BsonArray warnings=new BsonArray();
    if (responseContent.isDocument()) {
      if (context.getRepresentationFormat() == RequestContext.REPRESENTATION_FORMAT.PJ || context.getRepresentationFormat() == RequestContext.REPRESENTATION_FORMAT.PLAIN_JSON) {
        context.setResponseContentType(Representation.JSON_MEDIA_TYPE);
        responseContent.asDocument().append(""String_Node_Str"",warnings);
        context.getWarnings().forEach(w -> warnings.add(new BsonString(w)));
      }
 else {
        context.setResponseContentType(Representation.HAL_JSON_MEDIA_TYPE);
        BsonDocument _embedded;
        if (responseContent.asDocument().get(""String_Node_Str"") == null) {
          _embedded=new BsonDocument();
          responseContent.asDocument().append(""String_Node_Str"",_embedded);
        }
 else {
          _embedded=responseContent.asDocument().get(""String_Node_Str"").asDocument();
        }
        _embedded.append(""String_Node_Str"",warnings);
        context.getWarnings().forEach(w -> warnings.add(getWarningDoc(w)));
      }
    }
  }
  if (context.getRepresentationFormat() == RequestContext.REPRESENTATION_FORMAT.HAL) {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,Representation.HAL_JSON_MEDIA_TYPE);
  }
 else {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,Representation.JSON_MEDIA_TYPE);
  }
  if (!exchange.isResponseStarted()) {
    exchange.setStatusCode(context.getResponseStatusCode());
  }
  if (responseContent != null) {
    exchange.getResponseSender().send(JsonUtils.toJson(responseContent));
  }
  exchange.endExchange();
  next(exchange,context);
}"
93445,"private void sendBinaryContent(final GridFSBucket gridFSBucket,final GridFSFile file,final HttpServerExchange exchange) throws IOException {
  LOGGER.trace(""String_Node_Str"",file.getFilename());
  LOGGER.trace(""String_Node_Str"",file.getLength());
  if (file.getMetadata() != null && file.getMetadata().get(""String_Node_Str"") != null) {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,file.getMetadata().get(""String_Node_Str"").toString());
  }
 else   if (file.getExtraElements() != null && file.getExtraElements().get(""String_Node_Str"") != null) {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,file.getExtraElements().get(""String_Node_Str"").toString());
  }
 else {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,APPLICATION_OCTET_STREAM);
  }
  exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH,file.getLength());
  exchange.getResponseHeaders().put(Headers.CONTENT_DISPOSITION,String.format(""String_Node_Str"",extractFilename(file)));
  exchange.getResponseHeaders().put(Headers.CONTENT_TRANSFER_ENCODING,CONTENT_TRANSFER_ENCODING_BINARY);
  ResponseHelper.injectEtagHeader(exchange,file.getMetadata());
  exchange.setStatusCode(HttpStatus.SC_OK);
  gridFSBucket.downloadToStream(file.getId(),exchange.getOutputStream());
  exchange.endExchange();
}","private void sendBinaryContent(final RequestContext context,final GridFSBucket gridFSBucket,final GridFSFile file,final HttpServerExchange exchange) throws IOException {
  LOGGER.trace(""String_Node_Str"",file.getFilename());
  LOGGER.trace(""String_Node_Str"",file.getLength());
  if (file.getMetadata() != null && file.getMetadata().get(""String_Node_Str"") != null) {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,file.getMetadata().get(""String_Node_Str"").toString());
  }
 else   if (file.getMetadata() != null && file.getMetadata().get(""String_Node_Str"") != null) {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,file.getMetadata().get(""String_Node_Str"").toString());
  }
 else {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,APPLICATION_OCTET_STREAM);
  }
  exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH,file.getLength());
  exchange.getResponseHeaders().put(Headers.CONTENT_DISPOSITION,String.format(""String_Node_Str"",extractFilename(file)));
  exchange.getResponseHeaders().put(Headers.CONTENT_TRANSFER_ENCODING,CONTENT_TRANSFER_ENCODING_BINARY);
  ResponseHelper.injectEtagHeader(exchange,file.getMetadata());
  context.setResponseStatusCode(HttpStatus.SC_OK);
  gridFSBucket.downloadToStream(file.getId(),exchange.getOutputStream());
}"
93446,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.isInError()) {
    next(exchange,context);
    return;
  }
  LOGGER.trace(""String_Node_Str"" + exchange.getRequestURL());
  final String bucket=extractBucketName(context.getCollectionName());
  GridFSBucket gridFSBucket=GridFSBuckets.create(MongoDBClientSingleton.getInstance().getClient().getDatabase(context.getDBName()),bucket);
  GridFSFile dbsfile=gridFSBucket.find(eq(""String_Node_Str"",context.getDocumentId())).limit(1).iterator().tryNext();
  if (dbsfile == null) {
    fileNotFound(context,exchange);
  }
 else   if (!checkEtag(exchange,dbsfile)) {
    sendBinaryContent(gridFSBucket,dbsfile,exchange);
  }
  next(exchange,context);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.isInError()) {
    next(exchange,context);
    return;
  }
  LOGGER.trace(""String_Node_Str"" + exchange.getRequestURL());
  final String bucket=extractBucketName(context.getCollectionName());
  GridFSBucket gridFSBucket=GridFSBuckets.create(MongoDBClientSingleton.getInstance().getClient().getDatabase(context.getDBName()),bucket);
  GridFSFile dbsfile=gridFSBucket.find(eq(""String_Node_Str"",context.getDocumentId())).limit(1).iterator().tryNext();
  if (dbsfile == null) {
    fileNotFound(context,exchange);
  }
 else   if (!checkEtag(exchange,dbsfile)) {
    sendBinaryContent(context,gridFSBucket,dbsfile,exchange);
  }
  next(exchange,context);
}"
93447,"/** 
 * Returns the correct response generator for any given accept header. behaviour is: * by default, return prometheus format * if something else is wanted, return that (if available) * if Accept header cannot be satisfied, return 406 (NOT ACCEPTABLE)
 */
public static ResponseType forAcceptHeader(String acceptHeader){
  if (acceptHeader == null) {
    return ResponseType.PROMETHEUS;
  }
  return Arrays.stream(acceptHeader.split(""String_Node_Str"")).map(String::trim).map(AcceptHeaderEntry::of).filter(Objects::nonNull).sorted(new AcceptHeaderEntryComparator()).flatMap(x -> Arrays.stream(ResponseType.values()).filter(rt -> rt.isAcceptableFor(x))).findFirst().orElse(null);
}","/** 
 * Returns the correct response generator for any given accept header. behaviour is: * by default, return prometheus format * if something else is wanted, return that (if available) * if Accept header cannot be satisfied, return 406 (NOT ACCEPTABLE)
 */
public static ResponseType forAcceptHeader(String acceptHeader){
  if (acceptHeader == null || acceptHeader.equalsIgnoreCase(""String_Node_Str"")) {
    return ResponseType.PROMETHEUS;
  }
  return Arrays.stream(acceptHeader.split(""String_Node_Str"")).map(String::trim).map(AcceptHeaderEntry::of).filter(Objects::nonNull).sorted(new AcceptHeaderEntryComparator()).flatMap(x -> Arrays.stream(ResponseType.values()).filter(rt -> rt.isAcceptableFor(x))).findFirst().orElse(null);
}"
93448,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(final HttpServerExchange exchange,final RequestContext context) throws Exception {
  if (context.isInError()) {
    next(exchange,context);
    return;
  }
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.OPTIONS || context.getMethod() == RequestContext.METHOD.DELETE) {
    next(exchange,context);
    return;
  }
  BsonValue content;
  final HeaderValues contentType=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (isFormOrMultipart(contentType)) {
    if (!((isPostRequest(context) && isFilesBucketRequest(context)) || (isPutRequest(context) && isFileRequest(context)))) {
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,ERROR_INVALID_CONTENTTYPE_FILE);
      next(exchange,context);
      return;
    }
    FormDataParser parser=this.formParserFactory.createParser(exchange);
    if (parser == null) {
      String errMsg=""String_Node_Str"" + ""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
      next(exchange,context);
      return;
    }
    FormData formData;
    try {
      formData=parser.parseBlocking();
    }
 catch (    IOException ioe) {
      String errMsg=""String_Node_Str"" + ""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,ioe);
      next(exchange,context);
      return;
    }
    try {
      content=extractMetadata(formData);
    }
 catch (    JSONParseException|IllegalArgumentException ex) {
      String errMsg=""String_Node_Str"" + ""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,ex);
      next(exchange,context);
      return;
    }
    final String fileField=extractFileField(formData);
    if (fileField == null) {
      String errMsg=""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
      next(exchange,context);
      return;
    }
    final Path path=formData.getFirst(fileField).getPath();
    context.setFilePath(path);
    injectContentTypeFromFile(content.asDocument(),path.toFile());
  }
 else   if (isHalOrJson(contentType)) {
    final String contentString=ChannelReader.read(exchange.getRequestChannel());
    context.setRawContent(contentString);
    if (contentString != null && !contentString.isEmpty()) {
      try {
        content=JsonUtils.parse(contentString);
        if (content != null && !content.isDocument() && !content.isArray()) {
          throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ content.getBsonType().name());
        }
      }
 catch (      JsonParseException|IllegalArgumentException ex) {
        ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
        next(exchange,context);
        return;
      }
    }
 else {
      content=null;
    }
  }
 else   if (contentType == null) {
    content=null;
  }
 else {
    ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,ERROR_INVALID_CONTENTTYPE);
    next(exchange,context);
    return;
  }
  if (content == null) {
    content=new BsonDocument();
  }
 else   if (content.isArray()) {
    if (context.getType() != RequestContext.TYPE.COLLECTION || (context.getMethod() != RequestContext.METHOD.POST)) {
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      next(exchange,context);
      return;
    }
    if (!content.asArray().stream().anyMatch(_doc -> {
      if (_doc.isDocument()) {
        BsonValue _id=_doc.asDocument().get(_ID);
        if (_id != null && _id.isArray()) {
          String errMsg=""String_Node_Str"" + ""String_Node_Str"" + (_id == null ? ""String_Node_Str"" : _id.getBsonType().name());
          ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
          return false;
        }
        filterJsonContent(_doc.asDocument(),context);
        return true;
      }
 else {
        String errMsg=""String_Node_Str"" + ""String_Node_Str"";
        ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
        return false;
      }
    }
)) {
      next(exchange,context);
      return;
    }
  }
 else   if (content.isDocument()) {
    BsonDocument _content=content.asDocument();
    BsonValue _id=_content.get(_ID);
    if (_id != null && _id.isArray()) {
      String errMsg=""String_Node_Str"" + ""String_Node_Str"" + (_id == null ? ""String_Node_Str"" : _id.getBsonType().name());
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
      next(exchange,context);
      return;
    }
    filterJsonContent(_content,context);
  }
  context.setContent(content);
  next(exchange,context);
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(final HttpServerExchange exchange,final RequestContext context) throws Exception {
  if (context.isInError()) {
    next(exchange,context);
    return;
  }
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.OPTIONS || context.getMethod() == RequestContext.METHOD.DELETE) {
    next(exchange,context);
    return;
  }
  BsonValue content;
  final HeaderValues contentType=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (isFormOrMultipart(contentType)) {
    if (!((isPostRequest(context) && isFilesBucketRequest(context)) || (isPutRequest(context) && isFileRequest(context)))) {
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,ERROR_INVALID_CONTENTTYPE_FILE);
      next(exchange,context);
      return;
    }
    FormDataParser parser=this.formParserFactory.createParser(exchange);
    if (parser == null) {
      String errMsg=""String_Node_Str"" + ""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
      next(exchange,context);
      return;
    }
    FormData formData;
    try {
      formData=parser.parseBlocking();
    }
 catch (    IOException ioe) {
      String errMsg=""String_Node_Str"" + ""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,ioe);
      next(exchange,context);
      return;
    }
    try {
      content=extractMetadata(formData);
    }
 catch (    JSONParseException|IllegalArgumentException ex) {
      String errMsg=""String_Node_Str"" + ""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,ex);
      next(exchange,context);
      return;
    }
    final String fileField=extractFileField(formData);
    if (fileField == null) {
      String errMsg=""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
      next(exchange,context);
      return;
    }
    final Path path=formData.getFirst(fileField).getPath();
    context.setFilePath(path);
    injectContentTypeFromFile(content.asDocument(),path.toFile());
  }
 else {
    final String contentString=ChannelReader.read(exchange.getRequestChannel());
    context.setRawContent(contentString);
    if (isHalOrJson(contentType)) {
      if (contentString != null && !contentString.isEmpty()) {
        try {
          content=JsonUtils.parse(contentString);
          if (content != null && !content.isDocument() && !content.isArray()) {
            throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ content.getBsonType().name());
          }
        }
 catch (        JsonParseException|IllegalArgumentException ex) {
          ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
          next(exchange,context);
          return;
        }
      }
 else {
        content=null;
      }
    }
 else     if (contentType == null) {
      content=null;
    }
 else {
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,ERROR_INVALID_CONTENTTYPE);
      next(exchange,context);
      return;
    }
  }
  if (content == null) {
    content=new BsonDocument();
  }
 else   if (content.isArray()) {
    if (context.getType() != RequestContext.TYPE.COLLECTION || (context.getMethod() != RequestContext.METHOD.POST)) {
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      next(exchange,context);
      return;
    }
    if (!content.asArray().stream().anyMatch(_doc -> {
      if (_doc.isDocument()) {
        BsonValue _id=_doc.asDocument().get(_ID);
        if (_id != null && _id.isArray()) {
          String errMsg=""String_Node_Str"" + ""String_Node_Str"" + (_id == null ? ""String_Node_Str"" : _id.getBsonType().name());
          ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
          return false;
        }
        filterJsonContent(_doc.asDocument(),context);
        return true;
      }
 else {
        String errMsg=""String_Node_Str"" + ""String_Node_Str"";
        ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
        return false;
      }
    }
)) {
      next(exchange,context);
      return;
    }
  }
 else   if (content.isDocument()) {
    BsonDocument _content=content.asDocument();
    BsonValue _id=_content.get(_ID);
    if (_id != null && _id.isArray()) {
      String errMsg=""String_Node_Str"" + ""String_Node_Str"" + (_id == null ? ""String_Node_Str"" : _id.getBsonType().name());
      ResponseHelper.endExchangeWithMessage(exchange,context,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
      next(exchange,context);
      return;
    }
    filterJsonContent(_content,context);
  }
  context.setContent(content);
  next(exchange,context);
}"
93449,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.isInError()) {
    next(exchange,context);
    return;
  }
  if (doesTransformerAppy()) {
    transform(exchange,context);
  }
  next(exchange,context);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (doesTransformerAppy()) {
    transform(exchange,context);
  }
  next(exchange,context);
}"
93450,"/** 
 * logLoggingConfiguration
 * @param fork
 */
private static void logLoggingConfiguration(boolean fork){
  if (configuration.isLogToFile()) {
    LOGGER.info(""String_Node_Str"",configuration.getLogFilePath(),configuration.getLogLevel());
  }
  if (!fork) {
    if (!configuration.isLogToConsole()) {
      LOGGER.info(""String_Node_Str"");
    }
 else {
      LOGGER.info(""String_Node_Str"",configuration.getLogLevel());
    }
  }
}","/** 
 * logLoggingConfiguration
 * @param fork
 */
private static void logLoggingConfiguration(boolean fork){
  String logbackConfigurationFile=System.getProperty(""String_Node_Str"");
  boolean usesLogback=logbackConfigurationFile != null && !logbackConfigurationFile.equals(""String_Node_Str"");
  if (usesLogback)   return;
  if (configuration.isLogToFile()) {
    LOGGER.info(""String_Node_Str"",configuration.getLogFilePath(),configuration.getLogLevel());
  }
  if (!fork) {
    if (!configuration.isLogToConsole()) {
      LOGGER.info(""String_Node_Str"");
    }
 else {
      LOGGER.info(""String_Node_Str"",configuration.getLogLevel());
    }
  }
}"
93451,"/** 
 * @return the logLevel
 */
public final Level getLogLevel(){
  return logLevel;
}","/** 
 * @return the logLevel
 */
public final Level getLogLevel(){
  String logbackConfigurationFile=System.getProperty(""String_Node_Str"");
  if (logbackConfigurationFile != null && !logbackConfigurationFile.equals(""String_Node_Str"")) {
    LoggerContext loggerContext=(LoggerContext)LoggerFactory.getILoggerFactory();
    ch.qos.logback.classic.Logger logger=loggerContext.getLogger(""String_Node_Str"");
    return logger.getLevel();
  }
  return logLevel;
}"
93452,"/** 
 * @param level
 */
public static void setLogLevel(Level level){
  LoggerContext loggerContext=(LoggerContext)LoggerFactory.getILoggerFactory();
  Logger logger=loggerContext.getLogger(""String_Node_Str"");
  logger.setLevel(level);
}","/** 
 * @param level
 */
public static void setLogLevel(Level level){
  LoggerContext loggerContext=(LoggerContext)LoggerFactory.getILoggerFactory();
  Logger logger=loggerContext.getLogger(""String_Node_Str"");
  String logbackConfigurationFile=System.getProperty(""String_Node_Str"");
  if (logbackConfigurationFile != null && !logbackConfigurationFile.equals(""String_Node_Str"")) {
    logger.info(""String_Node_Str"",logger.getLevel());
    level=logger.getLevel();
  }
  logger.setLevel(level);
}"
93453,"private void sendBinaryContent(final GridFSBucket gridFSBucket,final GridFSFile file,final HttpServerExchange exchange) throws IOException {
  LOGGER.trace(""String_Node_Str"",file.getFilename());
  LOGGER.trace(""String_Node_Str"",file.getLength());
  if (file.getMetadata() != null && file.getMetadata().get(""String_Node_Str"") != null) {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,file.getMetadata().get(""String_Node_Str"").toString());
  }
 else   if (file.getExtraElements() != null && file.getExtraElements().get(""String_Node_Str"") != null) {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,file.getExtraElements().get(""String_Node_Str"").toString());
  }
 else {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,APPLICATION_OCTET_STREAM);
  }
  exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH,file.getLength());
  exchange.getResponseHeaders().put(Headers.CONTENT_DISPOSITION,String.format(""String_Node_Str"",extractFilename(file)));
  exchange.getResponseHeaders().put(Headers.CONTENT_TRANSFER_ENCODING,CONTENT_TRANSFER_ENCODING_BINARY);
  ResponseHelper.injectEtagHeader(exchange,file.getMetadata());
  exchange.setStatusCode(HttpStatus.SC_OK);
  gridFSBucket.downloadToStream(file.getId().asObjectId().getValue(),exchange.getOutputStream());
  exchange.endExchange();
}","private void sendBinaryContent(final GridFSBucket gridFSBucket,final GridFSFile file,final HttpServerExchange exchange) throws IOException {
  LOGGER.trace(""String_Node_Str"",file.getFilename());
  LOGGER.trace(""String_Node_Str"",file.getLength());
  if (file.getMetadata() != null && file.getMetadata().get(""String_Node_Str"") != null) {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,file.getMetadata().get(""String_Node_Str"").toString());
  }
 else   if (file.getExtraElements() != null && file.getExtraElements().get(""String_Node_Str"") != null) {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,file.getExtraElements().get(""String_Node_Str"").toString());
  }
 else {
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,APPLICATION_OCTET_STREAM);
  }
  exchange.getResponseHeaders().put(Headers.CONTENT_LENGTH,file.getLength());
  exchange.getResponseHeaders().put(Headers.CONTENT_DISPOSITION,String.format(""String_Node_Str"",extractFilename(file)));
  exchange.getResponseHeaders().put(Headers.CONTENT_TRANSFER_ENCODING,CONTENT_TRANSFER_ENCODING_BINARY);
  ResponseHelper.injectEtagHeader(exchange,file.getMetadata());
  exchange.setStatusCode(HttpStatus.SC_OK);
  gridFSBucket.downloadToStream(file.getId(),exchange.getOutputStream());
  exchange.endExchange();
}"
93454,"/** 
 * @param jsonString
 * @return minified json string
 */
public static String minify(String jsonString){
  if (true) {
    return minifier.minify(jsonString);
  }
  boolean in_string=false;
  boolean in_multiline_comment=false;
  boolean in_singleline_comment=false;
  char string_opener='x';
  StringBuilder out=new StringBuilder();
  for (int i=0; i < jsonString.length(); i++) {
    char c=jsonString.charAt(i);
    String cc=jsonString.substring(i,Math.min(i + 2,jsonString.length()));
    if (in_string) {
      if (c == string_opener) {
        in_string=false;
        out.append(c);
      }
 else       if (c == '\\') {
        out.append(cc);
        ++i;
      }
 else {
        out.append(c);
      }
    }
 else     if (in_singleline_comment) {
      if (c == '\r' || c == '\n') {
        in_singleline_comment=false;
      }
    }
 else     if (in_multiline_comment) {
      if (cc.equals(""String_Node_Str"")) {
        in_multiline_comment=false;
        ++i;
      }
    }
 else     if (cc.equals(""String_Node_Str"")) {
      in_multiline_comment=true;
      ++i;
    }
 else     if (cc.equals(""String_Node_Str"")) {
      in_singleline_comment=true;
      ++i;
    }
 else     if (c == '""' || c == '\'') {
      in_string=true;
      string_opener=c;
      out.append(c);
    }
 else     if (!Character.isWhitespace(c)) {
      out.append(c);
    }
  }
  return out.toString();
}","/** 
 * @param jsonString
 * @return minified json string
 */
public static String minify(String jsonString){
  Minify minifier=new Minify();
  if (true) {
    return minifier.minify(jsonString);
  }
  boolean in_string=false;
  boolean in_multiline_comment=false;
  boolean in_singleline_comment=false;
  char string_opener='x';
  StringBuilder out=new StringBuilder();
  for (int i=0; i < jsonString.length(); i++) {
    char c=jsonString.charAt(i);
    String cc=jsonString.substring(i,Math.min(i + 2,jsonString.length()));
    if (in_string) {
      if (c == string_opener) {
        in_string=false;
        out.append(c);
      }
 else       if (c == '\\') {
        out.append(cc);
        ++i;
      }
 else {
        out.append(c);
      }
    }
 else     if (in_singleline_comment) {
      if (c == '\r' || c == '\n') {
        in_singleline_comment=false;
      }
    }
 else     if (in_multiline_comment) {
      if (cc.equals(""String_Node_Str"")) {
        in_multiline_comment=false;
        ++i;
      }
    }
 else     if (cc.equals(""String_Node_Str"")) {
      in_multiline_comment=true;
      ++i;
    }
 else     if (cc.equals(""String_Node_Str"")) {
      in_singleline_comment=true;
      ++i;
    }
 else     if (c == '""' || c == '\'') {
      in_string=true;
      string_opener=c;
      out.append(c);
    }
 else     if (!Character.isWhitespace(c)) {
      out.append(c);
    }
  }
  return out.toString();
}"
93455,"public BsonDocument getSortByDocument() throws JsonParseException {
  BsonDocument sort=new BsonDocument();
  if (sortBy == null || sortBy.isEmpty()) {
    sort.put(""String_Node_Str"",new BsonInt32(-1));
  }
 else {
    sortBy.stream().forEach((s) -> {
      String _s=s.trim();
      try {
        BsonDocument _sort=BsonDocument.parse(_s);
        sort.putAll(_sort);
      }
 catch (      JsonParseException e) {
        if (_s.startsWith(""String_Node_Str"")) {
          sort.put(_s.substring(1),new BsonInt32(-1));
        }
 else         if (_s.startsWith(""String_Node_Str"")) {
          sort.put(_s.substring(1),new BsonInt32(11));
        }
 else {
          sort.put(_s,new BsonInt32(1));
        }
      }
    }
);
  }
  return sort;
}","public BsonDocument getSortByDocument() throws JsonParseException {
  BsonDocument sort=new BsonDocument();
  if (sortBy == null) {
    sort.put(""String_Node_Str"",new BsonInt32(-1));
  }
 else {
    sortBy.stream().forEach((s) -> {
      String _s=s.trim();
      try {
        BsonDocument _sort=BsonDocument.parse(_s);
        sort.putAll(_sort);
      }
 catch (      JsonParseException e) {
        if (_s.startsWith(""String_Node_Str"")) {
          sort.put(_s.substring(1),new BsonInt32(-1));
        }
 else         if (_s.startsWith(""String_Node_Str"")) {
          sort.put(_s.substring(1),new BsonInt32(11));
        }
 else {
          sort.put(_s,new BsonInt32(1));
        }
      }
    }
);
  }
  return sort;
}"
93456,"@Override public void transform(HttpServerExchange exchange,RequestContext context,BsonValue contentToTransform,BsonValue args){
  if (!context.isInError() && (context.getType() == TYPE.DOCUMENT || context.getType() == TYPE.FILE || context.getType() == TYPE.INDEX)) {
    return;
  }
  RequestContext.REPRESENTATION_FORMAT rf=context.getRepresentationFormat();
  if (rf == null) {
    rf=Bootstrapper.getConfiguration().getDefaultRepresentationFormat();
  }
  if (contentToTransform == null || (rf != RequestContext.REPRESENTATION_FORMAT.PJ && rf != RequestContext.REPRESENTATION_FORMAT.PLAIN_JSON)) {
    return;
  }
  BsonDocument responseContent=new BsonDocument();
  context.setResponseContentType(Representation.JSON_MEDIA_TYPE);
  if (contentToTransform.isDocument()) {
    BsonValue _embedded=contentToTransform.asDocument().get(""String_Node_Str"");
    if (_embedded != null) {
      BsonDocument embedded=_embedded.asDocument();
      BsonArray __embedded=new BsonArray();
      addItems(__embedded,embedded,""String_Node_Str"");
      addItems(__embedded,embedded,""String_Node_Str"");
      addItems(__embedded,embedded,""String_Node_Str"");
      addItems(__embedded,embedded,""String_Node_Str"");
      addItems(__embedded,embedded,""String_Node_Str"");
      addItems(__embedded,embedded,""String_Node_Str"");
      if (context.getMethod() == METHOD.GET && context.getResponseStatusCode() == HttpStatus.SC_OK) {
        responseContent.append(""String_Node_Str"",__embedded);
      }
      BsonArray _results=new BsonArray();
      addItems(_results,embedded,""String_Node_Str"");
      if (!_results.isEmpty()) {
        responseContent.append(""String_Node_Str"",_results);
      }
      BsonArray _errors=new BsonArray();
      addItems(_errors,embedded,""String_Node_Str"");
      if (!_errors.isEmpty()) {
        responseContent.append(""String_Node_Str"",_errors);
      }
      BsonArray _exception=new BsonArray();
      addItems(_exception,embedded,""String_Node_Str"");
      if (!_exception.isEmpty()) {
        responseContent.append(""String_Node_Str"",_exception);
      }
      BsonArray _warnings=new BsonArray();
      addItems(_warnings,embedded,""String_Node_Str"");
      if (!_warnings.isEmpty()) {
        responseContent.append(""String_Node_Str"",_warnings);
      }
    }
 else     if (context.getMethod() == METHOD.GET && context.getResponseStatusCode() == HttpStatus.SC_OK) {
      responseContent.append(""String_Node_Str"",new BsonArray());
    }
  }
  if (!context.isNoProps() || context.isInError()) {
    contentToTransform.asDocument().keySet().stream().filter(key -> !""String_Node_Str"".equals(key) && !""String_Node_Str"".equals(key)).forEach(key -> responseContent.append(key,contentToTransform.asDocument().get(key)));
    context.setResponseContent(responseContent);
  }
 else   if (!context.isInError()) {
    if (responseContent.get(""String_Node_Str"") != null && !responseContent.get(""String_Node_Str"").asArray().isEmpty()) {
      context.setResponseContent(responseContent.get(""String_Node_Str""));
    }
 else     if (responseContent.get(""String_Node_Str"") != null && !responseContent.get(""String_Node_Str"").asArray().isEmpty()) {
      context.setResponseContent(responseContent.get(""String_Node_Str""));
    }
 else     if (responseContent.get(""String_Node_Str"") != null) {
      context.setResponseContent(responseContent.get(""String_Node_Str""));
    }
 else     if (responseContent.get(""String_Node_Str"") != null && !responseContent.get(""String_Node_Str"").asArray().isEmpty()) {
      context.setResponseContent(responseContent.get(""String_Node_Str""));
    }
 else {
      context.setResponseContent(null);
    }
  }
 else {
    context.setResponseContent(responseContent);
  }
}","@Override public void transform(HttpServerExchange exchange,RequestContext context,BsonValue contentToTransform,BsonValue args){
  if (!context.isInError() && (context.getType() == TYPE.DOCUMENT || context.getType() == TYPE.FILE || context.getType() == TYPE.INDEX)) {
    return;
  }
  RequestContext.REPRESENTATION_FORMAT rf=context.getRepresentationFormat();
  if (rf == null) {
    rf=Bootstrapper.getConfiguration().getDefaultRepresentationFormat();
  }
  if (contentToTransform == null || (rf != RequestContext.REPRESENTATION_FORMAT.PJ && rf != RequestContext.REPRESENTATION_FORMAT.PLAIN_JSON)) {
    return;
  }
  context.setResponseContentType(Representation.JSON_MEDIA_TYPE);
  BsonDocument responseContent=new BsonDocument();
  transformError(contentToTransform,responseContent);
  if (context.isInError()) {
    contentToTransform.asDocument().keySet().stream().filter(key -> !""String_Node_Str"".equals(key) && !""String_Node_Str"".equals(key)).forEach(key -> responseContent.append(key,contentToTransform.asDocument().get(key)));
    context.setResponseContent(responseContent);
  }
 else   if (context.getMethod() == METHOD.GET) {
    transformRead(context,contentToTransform,responseContent);
    if (!context.isNoProps()) {
      contentToTransform.asDocument().keySet().stream().filter(key -> !""String_Node_Str"".equals(key) && !""String_Node_Str"".equals(key)).forEach(key -> responseContent.append(key,contentToTransform.asDocument().get(key)));
      context.setResponseContent(responseContent);
    }
 else {
      if (responseContent.get(""String_Node_Str"") != null) {
        context.setResponseContent(responseContent.get(""String_Node_Str""));
      }
 else {
        context.setResponseContent(null);
      }
    }
  }
 else {
    transformWrite(contentToTransform,responseContent);
    context.setResponseContent(responseContent);
  }
}"
93457,"@Override public void transform(HttpServerExchange exchange,RequestContext context,BsonValue contentToTransform,BsonValue args){
  if (context.getDbOperationResult() == null) {
    return;
  }
 else {
    BsonDocument resp=null;
    if (contentToTransform == null || !contentToTransform.isDocument()) {
      resp=new BsonDocument();
      context.setResponseContent(resp);
    }
 else     if (contentToTransform.isDocument()) {
      resp=contentToTransform.asDocument();
    }
    if (resp != null) {
      resp.append(""String_Node_Str"",context.getDbOperationResult().getOldData() == null ? new BsonNull() : context.getDbOperationResult().getOldData());
      resp.append(""String_Node_Str"",context.getDbOperationResult().getNewData());
    }
  }
}","@Override public void transform(HttpServerExchange exchange,RequestContext context,BsonValue contentToTransform,BsonValue args){
  if (context.getDbOperationResult() == null) {
    return;
  }
 else {
    BsonDocument resp=null;
    if (contentToTransform == null || !contentToTransform.isDocument()) {
      resp=new BsonDocument();
      context.setResponseContent(resp);
    }
 else     if (contentToTransform.isDocument()) {
      resp=contentToTransform.asDocument();
    }
    if (resp != null) {
      resp.append(""String_Node_Str"",context.getDbOperationResult().getOldData() == null ? new BsonNull() : context.getDbOperationResult().getOldData());
      resp.append(""String_Node_Str"",context.getDbOperationResult().getNewData() == null ? new BsonNull() : context.getDbOperationResult().getNewData());
    }
  }
}"
93458,"/** 
 * startCoreSystem
 */
private static void startCoreSystem(){
  if (configuration == null) {
    logErrorAndExit(""String_Node_Str"",null,false,-1);
  }
  if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
    logErrorAndExit(""String_Node_Str"",null,false,-1);
  }
  final IdentityManager identityManager=loadIdentityManager();
  final AccessManager accessManager=loadAccessManager();
  if (configuration.isAuthTokenEnabled()) {
    LOGGER.info(""String_Node_Str"",configuration.getAuthTokenTtl());
  }
  SSLContext sslContext=null;
  try {
    KeyManagerFactory kmf;
    KeyStore ks;
    if (getConfiguration().isUseEmbeddedKeystore()) {
      char[] storepass=""String_Node_Str"".toCharArray();
      char[] keypass=""String_Node_Str"".toCharArray();
      String storename=""String_Node_Str"";
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
      ks=KeyStore.getInstance(""String_Node_Str"");
      ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename),storepass);
      kmf.init(ks,keypass);
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
 else {
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
      ks=KeyStore.getInstance(""String_Node_Str"");
      try (FileInputStream fis=new FileInputStream(new File(configuration.getKeystoreFile()))){
        ks.load(fis,configuration.getKeystorePassword().toCharArray());
        kmf.init(ks,configuration.getCertPassword().toCharArray());
        sslContext.init(kmf.getKeyManagers(),null,null);
      }
     }
  }
 catch (  KeyManagementException|NoSuchAlgorithmException|KeyStoreException|CertificateException|UnrecoverableKeyException ex) {
    logErrorAndExit(""String_Node_Str"",ex,false,-1);
  }
catch (  FileNotFoundException ex) {
    logErrorAndExit(""String_Node_Str"",ex,false,-1);
  }
catch (  IOException ex) {
    logErrorAndExit(""String_Node_Str"",ex,false,-1);
  }
  Builder builder=Undertow.builder();
  if (configuration.isHttpsListener()) {
    builder.addHttpsListener(configuration.getHttpsPort(),configuration.getHttpHost(),sslContext);
    LOGGER.info(""String_Node_Str"",configuration.getHttpsHost(),configuration.getHttpsPort());
  }
  if (configuration.isHttpListener()) {
    builder.addHttpListener(configuration.getHttpPort(),configuration.getHttpsHost());
    LOGGER.info(""String_Node_Str"",configuration.getHttpHost(),configuration.getHttpPort());
  }
  if (configuration.isAjpListener()) {
    builder.addAjpListener(configuration.getAjpPort(),configuration.getAjpHost());
    LOGGER.info(""String_Node_Str"",configuration.getAjpHost(),configuration.getAjpPort());
  }
  LocalCachesSingleton.init(configuration);
  if (configuration.isLocalCacheEnabled()) {
    LOGGER.info(""String_Node_Str"",configuration.getLocalCacheTtl() < 0 ? ""String_Node_Str"" : configuration.getLocalCacheTtl());
  }
 else {
    LOGGER.info(""String_Node_Str"");
  }
  if (configuration.isSchemaCacheEnabled()) {
    LOGGER.info(""String_Node_Str"",configuration.getSchemaCacheTtl() < 0 ? ""String_Node_Str"" : configuration.getSchemaCacheTtl());
  }
 else {
    LOGGER.info(""String_Node_Str"");
  }
  shutdownHandler=getHandlersPipe(identityManager,accessManager);
  builder=builder.setIoThreads(configuration.getIoThreads()).setWorkerThreads(configuration.getWorkerThreads()).setDirectBuffers(configuration.isDirectBuffers()).setBufferSize(configuration.getBufferSize()).setBuffersPerRegion(configuration.getBuffersPerRegion()).setHandler(shutdownHandler);
  ConfigurationHelper.setConnectionOptions(builder,configuration);
  builder.build().start();
}","/** 
 * startCoreSystem
 */
private static void startCoreSystem(){
  if (configuration == null) {
    logErrorAndExit(""String_Node_Str"",null,false,-1);
  }
  if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
    logErrorAndExit(""String_Node_Str"",null,false,-1);
  }
  final IdentityManager identityManager=loadIdentityManager();
  final AccessManager accessManager=loadAccessManager();
  if (configuration.isAuthTokenEnabled()) {
    LOGGER.info(""String_Node_Str"",configuration.getAuthTokenTtl());
  }
  SSLContext sslContext=null;
  try {
    KeyManagerFactory kmf;
    KeyStore ks;
    if (getConfiguration().isUseEmbeddedKeystore()) {
      char[] storepass=""String_Node_Str"".toCharArray();
      char[] keypass=""String_Node_Str"".toCharArray();
      String storename=""String_Node_Str"";
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
      ks=KeyStore.getInstance(""String_Node_Str"");
      ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename),storepass);
      kmf.init(ks,keypass);
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
 else {
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
      ks=KeyStore.getInstance(""String_Node_Str"");
      try (FileInputStream fis=new FileInputStream(new File(configuration.getKeystoreFile()))){
        ks.load(fis,configuration.getKeystorePassword().toCharArray());
        kmf.init(ks,configuration.getCertPassword().toCharArray());
        sslContext.init(kmf.getKeyManagers(),null,null);
      }
     }
  }
 catch (  KeyManagementException|NoSuchAlgorithmException|KeyStoreException|CertificateException|UnrecoverableKeyException ex) {
    logErrorAndExit(""String_Node_Str"",ex,false,-1);
  }
catch (  FileNotFoundException ex) {
    logErrorAndExit(""String_Node_Str"",ex,false,-1);
  }
catch (  IOException ex) {
    logErrorAndExit(""String_Node_Str"",ex,false,-1);
  }
  Builder builder=Undertow.builder();
  if (configuration.isHttpsListener()) {
    builder.addHttpsListener(configuration.getHttpsPort(),configuration.getHttpHost(),sslContext);
    LOGGER.info(""String_Node_Str"",configuration.getHttpsHost(),configuration.getHttpsPort());
  }
  if (configuration.isHttpListener()) {
    builder.addHttpListener(configuration.getHttpPort(),configuration.getHttpsHost());
    LOGGER.info(""String_Node_Str"",configuration.getHttpHost(),configuration.getHttpPort());
  }
  if (configuration.isAjpListener()) {
    builder.addAjpListener(configuration.getAjpPort(),configuration.getAjpHost());
    LOGGER.info(""String_Node_Str"",configuration.getAjpHost(),configuration.getAjpPort());
  }
  LocalCachesSingleton.init(configuration);
  if (configuration.isLocalCacheEnabled()) {
    LOGGER.info(""String_Node_Str"",configuration.getLocalCacheTtl() < 0 ? ""String_Node_Str"" : configuration.getLocalCacheTtl());
  }
 else {
    LOGGER.info(""String_Node_Str"");
  }
  if (configuration.isSchemaCacheEnabled()) {
    LOGGER.info(""String_Node_Str"",configuration.getSchemaCacheTtl() < 0 ? ""String_Node_Str"" : configuration.getSchemaCacheTtl());
  }
 else {
    LOGGER.info(""String_Node_Str"");
  }
  shutdownHandler=getHandlersPipe(identityManager,accessManager);
  builder=builder.setIoThreads(configuration.getIoThreads()).setWorkerThreads(configuration.getWorkerThreads()).setDirectBuffers(configuration.isDirectBuffers()).setBufferSize(configuration.getBufferSize()).setBuffersPerRegion(configuration.getBuffersPerRegion()).setHandler(shutdownHandler);
  ConfigurationHelper.setConnectionOptions(builder,configuration);
  undertowServer=builder.build();
  undertowServer.start();
}"
93459,"/** 
 * stopServer
 * @param silent
 * @param removePid
 */
private static void stopServer(boolean silent,boolean removePid){
  if (!silent) {
    LOGGER.info(""String_Node_Str"");
  }
  if (shutdownHandler != null) {
    if (!silent) {
      LOGGER.info(""String_Node_Str"");
    }
    try {
      shutdownHandler.shutdown();
      shutdownHandler.awaitShutdown(60 * 1000);
    }
 catch (    InterruptedException ie) {
      LOGGER.error(""String_Node_Str"",ie);
    }
  }
  if (MongoDBClientSingleton.isInitialized()) {
    MongoClient client=MongoDBClientSingleton.getInstance().getClient();
    if (!silent) {
      LOGGER.info(""String_Node_Str"");
    }
    try {
      client.close();
    }
 catch (    Throwable t) {
      LOGGER.warn(""String_Node_Str"",t);
    }
  }
  Path pidFilePath=FileUtils.getPidFilePath(FileUtils.getFileAbsoultePathHash(CONF_FILE_PATH));
  if (removePid && pidFilePath != null) {
    if (!silent) {
      LOGGER.info(""String_Node_Str"",pidFilePath.toString());
    }
    try {
      Files.deleteIfExists(pidFilePath);
    }
 catch (    IOException ex) {
      LOGGER.error(""String_Node_Str"",pidFilePath.toString(),ex);
    }
  }
  if (!silent) {
    LOGGER.info(""String_Node_Str"");
  }
  TMP_EXTRACTED_FILES.keySet().forEach(k -> {
    try {
      ResourcesExtractor.deleteTempDir(k,TMP_EXTRACTED_FILES.get(k));
    }
 catch (    URISyntaxException|IOException ex) {
      LOGGER.error(""String_Node_Str"",TMP_EXTRACTED_FILES.get(k).toString(),ex);
    }
  }
);
  if (!silent) {
    LOGGER.info(ansi().fg(GREEN).bold().a(""String_Node_Str"").reset().toString());
  }
  LoggingInitializer.stopLogging();
}","/** 
 * stopServer
 * @param silent
 * @param removePid
 */
private static void stopServer(boolean silent,boolean removePid){
  if (!silent) {
    LOGGER.info(""String_Node_Str"");
  }
  if (shutdownHandler != null) {
    if (!silent) {
      LOGGER.info(""String_Node_Str"");
    }
    try {
      shutdownHandler.shutdown();
      shutdownHandler.awaitShutdown(60 * 1000);
    }
 catch (    InterruptedException ie) {
      LOGGER.error(""String_Node_Str"",ie);
    }
  }
  if (MongoDBClientSingleton.isInitialized()) {
    MongoClient client=MongoDBClientSingleton.getInstance().getClient();
    if (!silent) {
      LOGGER.info(""String_Node_Str"");
    }
    try {
      client.close();
    }
 catch (    Throwable t) {
      LOGGER.warn(""String_Node_Str"",t);
    }
  }
  Path pidFilePath=FileUtils.getPidFilePath(FileUtils.getFileAbsoultePathHash(CONF_FILE_PATH));
  if (removePid && pidFilePath != null) {
    if (!silent) {
      LOGGER.info(""String_Node_Str"",pidFilePath.toString());
    }
    try {
      Files.deleteIfExists(pidFilePath);
    }
 catch (    IOException ex) {
      LOGGER.error(""String_Node_Str"",pidFilePath.toString(),ex);
    }
  }
  if (!silent) {
    LOGGER.info(""String_Node_Str"");
  }
  TMP_EXTRACTED_FILES.keySet().forEach(k -> {
    try {
      ResourcesExtractor.deleteTempDir(k,TMP_EXTRACTED_FILES.get(k));
    }
 catch (    URISyntaxException|IOException ex) {
      LOGGER.error(""String_Node_Str"",TMP_EXTRACTED_FILES.get(k).toString(),ex);
    }
  }
);
  undertowServer.stop();
  if (!silent) {
    LOGGER.info(ansi().fg(GREEN).bold().a(""String_Node_Str"").reset().toString());
  }
  LoggingInitializer.stopLogging();
}"
93460,"/** 
 * this filters out the nullable and optional conditions where the path resolves to null
 * @param conditions
 * @param content
 * @return
 */
protected BasicDBList filterMissingOptionalAndNullNullableConditions(BasicDBList conditions,DBObject content){
  Set<String> nullPaths=new HashSet<>();
  BasicDBList ret=new BasicDBList();
  conditions.stream().forEach((  Object condition) -> {
    if (condition instanceof BasicDBObject) {
      Boolean nullable=false;
      Object _nullable=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_nullable != null && _nullable instanceof Boolean) {
        nullable=(Boolean)_nullable;
      }
      Boolean optional=false;
      Object _optional=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_optional != null && _optional instanceof Boolean) {
        optional=(Boolean)_optional;
      }
      if (nullable || optional) {
        Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
        if (_path != null && _path instanceof String) {
          String path=(String)_path;
          List<Optional<Object>> props;
          try {
            props=JsonUtils.getPropsFromPath(content,path);
            if (props != null && props.stream().allMatch((            Optional<Object> prop) -> {
              return prop != null && !prop.isPresent();
            }
)) {
              LOGGER.debug(""String_Node_Str"",path);
              nullPaths.add(path);
            }
          }
 catch (          IllegalArgumentException ex) {
            nullPaths.add(path);
          }
        }
      }
    }
  }
);
  conditions.stream().forEach((  Object condition) -> {
    if (condition instanceof BasicDBObject) {
      Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_path != null && _path instanceof String) {
        String path=(String)_path;
        boolean hasNullParent=nullPaths.stream().anyMatch((        String nullPath) -> {
          return JsonUtils.isAncestorPath(nullPath,path);
        }
);
        if (!hasNullParent) {
          ret.add(condition);
        }
      }
    }
  }
);
  return ret;
}","/** 
 * this filters out the nullable and optional conditions where the path resolves to null
 * @param conditions
 * @param content
 * @return
 */
protected BasicDBList filterMissingOptionalAndNullNullableConditions(BasicDBList conditions,DBObject content){
  Set<String> nullPaths=new HashSet<>();
  BasicDBList ret=new BasicDBList();
  conditions.stream().forEach((  Object condition) -> {
    if (condition instanceof BasicDBObject) {
      Boolean nullable=false;
      Object _nullable=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_nullable != null && _nullable instanceof Boolean) {
        nullable=(Boolean)_nullable;
      }
      Boolean optional=false;
      Object _optional=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_optional != null && _optional instanceof Boolean) {
        optional=(Boolean)_optional;
      }
      if (nullable) {
        Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
        if (_path != null && _path instanceof String) {
          String path=(String)_path;
          List<Optional<Object>> props;
          try {
            props=JsonUtils.getPropsFromPath(content,path);
            if (props != null && props.stream().allMatch((            Optional<Object> prop) -> {
              return prop != null && !prop.isPresent();
            }
)) {
              LOGGER.debug(""String_Node_Str"",path);
              nullPaths.add(path);
            }
          }
 catch (          IllegalArgumentException ex) {
            nullPaths.add(path);
          }
        }
      }
      if (optional) {
        Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
        if (_path != null && _path instanceof String) {
          String path=(String)_path;
          List<Optional<Object>> props;
          try {
            props=JsonUtils.getPropsFromPath(content,path);
            if (props == null || props.stream().allMatch((            Optional<Object> prop) -> {
              return prop == null;
            }
)) {
              nullPaths.add(path);
            }
          }
 catch (          IllegalArgumentException ex) {
            nullPaths.add(path);
          }
        }
      }
    }
  }
);
  conditions.stream().forEach((  Object condition) -> {
    if (condition instanceof BasicDBObject) {
      Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_path != null && _path instanceof String) {
        String path=(String)_path;
        boolean hasNullParent=nullPaths.stream().anyMatch((        String nullPath) -> {
          return JsonUtils.isAncestorPath(nullPath,path);
        }
);
        if (!hasNullParent) {
          ret.add(condition);
        }
      }
    }
  }
);
  return ret;
}"
93461,"@Override public boolean check(HttpServerExchange exchange,RequestContext context,BasicDBObject contentToCheck,DBObject args){
  if (args instanceof BasicDBList) {
    BasicDBList conditions=filterMissingOptionalAndNullNullableConditions((BasicDBList)args,context.getContent());
    return applyConditions(conditions,contentToCheck,context);
  }
 else {
    context.addWarning(""String_Node_Str"");
    return true;
  }
}","@Override public boolean check(HttpServerExchange exchange,RequestContext context,BasicDBObject contentToCheck,DBObject args){
  if (args instanceof BasicDBList) {
    BasicDBList conditions=filterMissingOptionalAndNullNullableConditions((BasicDBList)args,contentToCheck);
    return applyConditions(conditions,contentToCheck,context);
  }
 else {
    context.addWarning(""String_Node_Str"");
    return true;
  }
}"
93462,"/** 
 * see bug https://softinstigate.atlassian.net/browse/RH-160 the bug is won't fix because checker is deprecated
 * @throws Exception 
 */
@Test public void testPatchIncompleteObject() throws Exception {
  Response resp;
  final String VALID_USER=getResourceFile(""String_Node_Str"");
  resp=adminExecutor.execute(Request.Post(collectionTmpUri).bodyString(VALID_USER,halCT).addHeader(Headers.CONTENT_TYPE_STRING,Representation.HAL_JSON_MEDIA_TYPE));
  check(""String_Node_Str"",resp,HttpStatus.SC_CREATED);
  final String INCOMPLETE_OBJ=""String_Node_Str"";
  resp=adminExecutor.execute(Request.Patch(userURI).bodyString(INCOMPLETE_OBJ,halCT).addHeader(Headers.CONTENT_TYPE_STRING,Representation.HAL_JSON_MEDIA_TYPE));
  check(""String_Node_Str"",resp,HttpStatus.SC_BAD_REQUEST);
}","/** 
 * see bug https://softinstigate.atlassian.net/browse/RH-160
 * @throws Exception 
 */
@Test public void testPatchIncompleteObject() throws Exception {
  Response resp;
  final String VALID_USER=getResourceFile(""String_Node_Str"");
  resp=adminExecutor.execute(Request.Post(collectionTmpUri).bodyString(VALID_USER,halCT).addHeader(Headers.CONTENT_TYPE_STRING,Representation.HAL_JSON_MEDIA_TYPE));
  check(""String_Node_Str"",resp,HttpStatus.SC_CREATED);
  final String INCOMPLETE_OBJ=""String_Node_Str"";
  resp=adminExecutor.execute(Request.Patch(userURI).bodyString(INCOMPLETE_OBJ,halCT).addHeader(Headers.CONTENT_TYPE_STRING,Representation.HAL_JSON_MEDIA_TYPE));
  check(""String_Node_Str"",resp,HttpStatus.SC_BAD_REQUEST);
}"
93463,"/** 
 * @param exchange
 * @param context
 * @param size
 * @return
 * @throws IllegalQueryParamenterException
 */
public static TreeMap<String,String> getPaginationLinks(HttpServerExchange exchange,RequestContext context,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtils.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=URLUtils.decodeQueryString(exchange.getQueryString());
  int page=context.getPage();
  int pagesize=context.getPagesize();
  long totalPages=0;
  if (size >= 0) {
    float _size=size + 0f;
    float _pagesize=pagesize + 0f;
    totalPages=Math.max(1,Math.round(Math.ceil(_size / _pagesize)));
  }
  TreeMap<String,String> links=new TreeMap<>();
  if (queryString == null || queryString.isEmpty()) {
    if (totalPages > 0 && page < totalPages) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
    }
  }
 else {
    String queryStringNoPagingProps=URLUtils.decodeQueryString(URLUtils.getQueryStringRemovingParams(exchange,""String_Node_Str"",""String_Node_Str""));
    if (queryStringNoPagingProps == null || queryStringNoPagingProps.isEmpty()) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize);
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize));
      }
    }
 else {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      if (totalPages <= 0) {
        links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize)+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
    }
  }
  return links;
}","/** 
 * @param exchange
 * @param context
 * @param size
 * @return
 * @throws IllegalQueryParamenterException
 */
public static TreeMap<String,String> getPaginationLinks(HttpServerExchange exchange,RequestContext context,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtils.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=URLUtils.decodeQueryString(exchange.getQueryString());
  int page=context.getPage();
  int pagesize=context.getPagesize();
  long totalPages=0;
  if (size >= 0) {
    float _size=size + 0f;
    float _pagesize=pagesize + 0f;
    totalPages=Math.max(1,Math.round(Math.ceil(_size / _pagesize)));
  }
  TreeMap<String,String> links=new TreeMap<>();
  if (queryString == null || queryString.isEmpty()) {
    if (totalPages > 0 && page < totalPages) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
    }
  }
 else {
    String queryStringNoPagingProps=URLUtils.decodeQueryString(URLUtils.getQueryStringRemovingParams(exchange,""String_Node_Str"",""String_Node_Str""));
    if (queryStringNoPagingProps == null || queryStringNoPagingProps.isEmpty()) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize);
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize));
      }
    }
 else {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      if (totalPages <= 0) {
        links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + (totalPages == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + (totalPages == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize)+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
    }
  }
  return links;
}"
93464,"private void embeddedDocuments(List<DBObject> embeddedData,String requestPath,HttpServerExchange exchange,RequestContext context,Representation rep) throws IllegalQueryParamenterException {
  for (  DBObject d : embeddedData) {
    Object _id=d.get(""String_Node_Str"");
    if (RequestContext.isReservedResourceCollection(_id.toString())) {
      rep.addWarning(""String_Node_Str"" + requestPath + ""String_Node_Str""+ _id.toString());
    }
 else {
      Representation nrep=new DocumentRepresentationFactory().getRepresentation(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
      if (context.getType() == RequestContext.TYPE.FILES_BUCKET) {
        if (context.isFullHalMode()) {
          DocumentRepresentationFactory.addSpecialProperties(nrep,TYPE.FILE,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
 else       if (context.getType() == RequestContext.TYPE.SCHEMA_STORE) {
        if (context.isFullHalMode()) {
          DocumentRepresentationFactory.addSpecialProperties(nrep,TYPE.SCHEMA,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
 else {
        if (context.isFullHalMode()) {
          DocumentRepresentationFactory.addSpecialProperties(nrep,TYPE.DOCUMENT,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
    }
  }
}","private void embeddedDocuments(List<DBObject> embeddedData,String requestPath,HttpServerExchange exchange,RequestContext context,Representation rep) throws IllegalQueryParamenterException {
  for (  DBObject d : embeddedData) {
    Object _id=d.get(""String_Node_Str"");
    if (_id != null && RequestContext.isReservedResourceCollection(_id.toString())) {
      rep.addWarning(""String_Node_Str"" + requestPath + ""String_Node_Str""+ _id.toString());
    }
 else {
      Representation nrep;
      if (_id == null) {
        nrep=new DocumentRepresentationFactory().getRepresentation(requestPath + ""String_Node_Str"",exchange,context,d);
      }
 else {
        nrep=new DocumentRepresentationFactory().getRepresentation(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
      }
      if (context.getType() == RequestContext.TYPE.FILES_BUCKET) {
        if (context.isFullHalMode()) {
          DocumentRepresentationFactory.addSpecialProperties(nrep,TYPE.FILE,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
 else       if (context.getType() == RequestContext.TYPE.SCHEMA_STORE) {
        if (context.isFullHalMode()) {
          DocumentRepresentationFactory.addSpecialProperties(nrep,TYPE.SCHEMA,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
 else {
        if (context.isFullHalMode()) {
          DocumentRepresentationFactory.addSpecialProperties(nrep,TYPE.DOCUMENT,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
    }
  }
}"
93465,"public static Object getId(String id,DOC_ID_TYPE type) throws UnsupportedDocumentIdException {
  if (id == null) {
    return null;
  }
  if (type == null) {
    type=DOC_ID_TYPE.STRING_OID;
  }
  if (RequestContext.MAX_KEY_ID.equalsIgnoreCase(id)) {
    return new MaxKey();
  }
  if (RequestContext.MIN_KEY_ID.equalsIgnoreCase(id)) {
    return new MinKey();
  }
  try {
switch (type) {
case STRING_OID:
      return getIdAsStringOrObjectId(id);
case OID:
    return getIdAsObjectId(id);
case STRING:
  return id;
case NUMBER:
return getIdAsNumber(id);
case MINKEY:
return new MinKey();
case MAXKEY:
return new MaxKey();
case DATE:
return getIdAsDate(id);
}
}
 catch (IllegalArgumentException iar) {
throw new UnsupportedDocumentIdException(iar);
}
return id;
}","public static Object getId(String id,DOC_ID_TYPE type) throws UnsupportedDocumentIdException {
  if (id == null) {
    return null;
  }
  if (type == null) {
    type=DOC_ID_TYPE.STRING_OID;
  }
  if (RequestContext.MAX_KEY_ID.equalsIgnoreCase(id)) {
    return new MaxKey();
  }
  if (RequestContext.MIN_KEY_ID.equalsIgnoreCase(id)) {
    return new MinKey();
  }
  if (RequestContext.NULL_KEY_ID.equalsIgnoreCase(id)) {
    return null;
  }
  try {
switch (type) {
case STRING_OID:
      return getIdAsStringOrObjectId(id);
case OID:
    return getIdAsObjectId(id);
case STRING:
  return id;
case NUMBER:
return getIdAsNumber(id);
case MINKEY:
return new MinKey();
case MAXKEY:
return new MaxKey();
case DATE:
return getIdAsDate(id);
}
}
 catch (IllegalArgumentException iar) {
throw new UnsupportedDocumentIdException(iar);
}
return id;
}"
93466,"public static String getReferenceLink(RequestContext context,String parentUrl,Object docId){
  if (context == null || parentUrl == null || docId == null) {
    LOGGER.error(""String_Node_Str"",context,parentUrl,docId);
    return ""String_Node_Str"";
  }
  String uri=""String_Node_Str"";
  if (docId instanceof String && ObjectId.isValid((String)docId)) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString()).concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.STRING.name());
  }
 else   if (docId instanceof String || docId instanceof ObjectId) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString());
  }
 else   if (docId instanceof Integer) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString()).concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.NUMBER.name());
  }
 else   if (docId instanceof Long) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString()).concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.NUMBER.name());
  }
 else   if (docId instanceof Float) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString()).concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.NUMBER.name());
  }
 else   if (docId instanceof Double) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString()).concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.NUMBER.name());
  }
 else   if (docId instanceof MinKey) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(""String_Node_Str"");
  }
 else   if (docId instanceof MaxKey) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(""String_Node_Str"");
  }
 else   if (docId instanceof Date) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(((Date)docId).getTime() + ""String_Node_Str"").concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.DATE.name());
  }
 else {
    context.addWarning(""String_Node_Str"" + docId.getClass().getSimpleName());
  }
  return uri;
}","public static String getReferenceLink(RequestContext context,String parentUrl,Object docId){
  if (context == null || parentUrl == null) {
    LOGGER.error(""String_Node_Str"",context,parentUrl,docId);
    return ""String_Node_Str"";
  }
  String uri=""String_Node_Str"";
  if (docId == null) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(""String_Node_Str"");
  }
 else   if (docId instanceof String && ObjectId.isValid((String)docId)) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString()).concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.STRING.name());
  }
 else   if (docId instanceof String || docId instanceof ObjectId) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString());
  }
 else   if (docId instanceof Integer) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString()).concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.NUMBER.name());
  }
 else   if (docId instanceof Long) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString()).concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.NUMBER.name());
  }
 else   if (docId instanceof Float) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString()).concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.NUMBER.name());
  }
 else   if (docId instanceof Double) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(docId.toString()).concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.NUMBER.name());
  }
 else   if (docId instanceof MinKey) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(""String_Node_Str"");
  }
 else   if (docId instanceof MaxKey) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(""String_Node_Str"");
  }
 else   if (docId instanceof Date) {
    uri=URLUtils.removeTrailingSlashes(parentUrl).concat(""String_Node_Str"").concat(((Date)docId).getTime() + ""String_Node_Str"").concat(""String_Node_Str"").concat(DOC_ID_TYPE_QPARAM_KEY).concat(""String_Node_Str"").concat(DOC_ID_TYPE.DATE.name());
  }
 else {
    context.addWarning(""String_Node_Str"" + docId.getClass().getSimpleName());
  }
  return uri;
}"
93467,"/** 
 * @param type
 * @param documentIdRaw
 * @return true if the documentIdRaw is a reserved resource
 */
public static boolean isReservedResourceDocument(TYPE type,String documentIdRaw){
  if (documentIdRaw == null) {
    return false;
  }
  return (documentIdRaw.startsWith(UNDERSCORE) || (type != TYPE.AGGREGATION && _AGGREGATIONS.equalsIgnoreCase(documentIdRaw))) && !documentIdRaw.equalsIgnoreCase(_INDEXES) && !documentIdRaw.equalsIgnoreCase(MIN_KEY_ID)&& !documentIdRaw.equalsIgnoreCase(MAX_KEY_ID)&& !(type == TYPE.AGGREGATION) || (documentIdRaw.equals(RESOURCES_WILDCARD_KEY) && !(type == TYPE.BULK_DOCUMENTS));
}","/** 
 * @param type
 * @param documentIdRaw
 * @return true if the documentIdRaw is a reserved resource
 */
public static boolean isReservedResourceDocument(TYPE type,String documentIdRaw){
  if (documentIdRaw == null) {
    return false;
  }
  return (documentIdRaw.startsWith(UNDERSCORE) || (type != TYPE.AGGREGATION && _AGGREGATIONS.equalsIgnoreCase(documentIdRaw))) && !documentIdRaw.equalsIgnoreCase(_INDEXES) && !documentIdRaw.equalsIgnoreCase(MIN_KEY_ID)&& !documentIdRaw.equalsIgnoreCase(MAX_KEY_ID)&& !documentIdRaw.equalsIgnoreCase(NULL_KEY_ID)&& !(type == TYPE.AGGREGATION) || (documentIdRaw.equals(RESOURCES_WILDCARD_KEY) && !(type == TYPE.BULK_DOCUMENTS));
}"
93468,"/** 
 * @param dbName
 * @return
 */
@Override public boolean doesDbExist(String dbName){
  if (dbName == null || dbName.isEmpty() || dbName.contains(""String_Node_Str"")) {
    return false;
  }
  return client.getDatabase(dbName).listCollectionNames().first() != null;
}","/** 
 * @param dbName
 * @return
 */
@Override public boolean doesDbExist(String dbName){
  return client.getDatabase(dbName).listCollectionNames().first() != null;
}"
93469,"/** 
 * @param dbName
 * @param collName
 * @return
 */
List<DBObject> getCollectionIndexes(String dbName,String collName){
  List<DBObject> indexes=client.getDB(dbName).getCollection(""String_Node_Str"").find(new BasicDBObject(""String_Node_Str"",dbName + ""String_Node_Str"" + collName),FIELDS_TO_RETURN_INDEXES).sort(new BasicDBObject(""String_Node_Str"",1)).toArray();
  indexes.forEach((i) -> {
    i.put(""String_Node_Str"",i.get(""String_Node_Str""));
    i.removeField(""String_Node_Str"");
  }
);
  return indexes;
}","/** 
 * @param dbName
 * @param collName
 * @return
 */
List<DBObject> getCollectionIndexes(String dbName,String collName){
  List<DBObject> indexes=client.getDB(dbName).getCollection(collName).getIndexInfo();
  indexes.forEach(i -> {
    i.put(""String_Node_Str"",i.get(""String_Node_Str""));
    i.removeField(""String_Node_Str"");
  }
);
  return indexes;
}"
93470,"/** 
 * main method
 * @param args command line arguments
 */
public static void main(final String[] args){
  CONF_FILE_PATH=FileUtils.getConfigurationFilePath(args);
  try {
    configuration=FileUtils.getConfiguration(args,true);
  }
 catch (  ConfigurationException ex) {
    LOGGER.info(""String_Node_Str"" + ansi().fg(RED).bold().a(""String_Node_Str"").reset().toString());
    if (RESTHEART_VERSION != null) {
      LOGGER.info(""String_Node_Str"",RESTHEART_VERSION);
    }
    LOGGER.error(ex.getMessage() + ""String_Node_Str"",ex);
    stopServer(false);
    System.exit(-1);
  }
  if (!hasForkOption(args)) {
    startServer(false);
  }
 else {
    if (OSChecker.isWindows()) {
      LOGGER.info(""String_Node_Str"" + ansi().fg(RED).bold().a(""String_Node_Str"").reset().toString());
      if (RESTHEART_VERSION != null) {
        LOGGER.info(""String_Node_Str"",RESTHEART_VERSION);
      }
      LOGGER.error(""String_Node_Str"");
      LOGGER.info(ansi().fg(GREEN).bold().a(""String_Node_Str"").reset().toString());
      System.exit(-1);
    }
    final boolean isPosix=FileSystems.getDefault().supportedFileAttributeViews().contains(""String_Node_Str"");
    if (!isPosix) {
      LOGGER.info(""String_Node_Str"" + ""String_Node_Str"");
      stopServer(false);
      System.exit(-1);
    }
    RHDaemon d=new RHDaemon();
    if (d.isDaemonized()) {
      try {
        d.init();
        LOGGER.info(""String_Node_Str"",LIBC.getpid());
        initLogging(args,d);
      }
 catch (      Throwable t) {
        LOGGER.error(""String_Node_Str"",t);
        stopServer(false,false);
        System.exit(-1);
      }
      startServer(true);
    }
 else {
      initLogging(args,d);
      try {
        LOGGER.info(""String_Node_Str"" + ansi().fg(RED).bold().a(""String_Node_Str"").reset().toString());
        if (RESTHEART_VERSION != null) {
          LOGGER.info(""String_Node_Str"",RESTHEART_VERSION);
        }
        logLoggingConfiguration(true);
        d.daemonize();
      }
 catch (      Throwable t) {
        LOGGER.error(""String_Node_Str"",t);
        stopServer(false,false);
        System.exit(-1);
      }
    }
  }
}","/** 
 * main method
 * @param args command line arguments
 */
public static void main(final String[] args){
  CONF_FILE_PATH=FileUtils.getConfigurationFilePath(args);
  try {
    configuration=FileUtils.getConfiguration(args,true);
  }
 catch (  ConfigurationException ex) {
    LOGGER.info(""String_Node_Str"" + ansi().fg(RED).bold().a(""String_Node_Str"").reset().toString());
    if (RESTHEART_VERSION != null) {
      LOGGER.info(""String_Node_Str"",RESTHEART_VERSION);
    }
    LOGGER.error(ex.getMessage() + ""String_Node_Str"",ex);
    stopServer(false);
    System.exit(-1);
  }
  if (!hasForkOption(args)) {
    initLogging(args,null);
    startServer(false);
  }
 else {
    if (OSChecker.isWindows()) {
      LOGGER.info(""String_Node_Str"" + ansi().fg(RED).bold().a(""String_Node_Str"").reset().toString());
      if (RESTHEART_VERSION != null) {
        LOGGER.info(""String_Node_Str"",RESTHEART_VERSION);
      }
      LOGGER.error(""String_Node_Str"");
      LOGGER.info(ansi().fg(GREEN).bold().a(""String_Node_Str"").reset().toString());
      System.exit(-1);
    }
    final boolean isPosix=FileSystems.getDefault().supportedFileAttributeViews().contains(""String_Node_Str"");
    if (!isPosix) {
      LOGGER.info(""String_Node_Str"" + ""String_Node_Str"");
      stopServer(false);
      System.exit(-1);
    }
    RHDaemon d=new RHDaemon();
    if (d.isDaemonized()) {
      try {
        d.init();
        LOGGER.info(""String_Node_Str"",LIBC.getpid());
        initLogging(args,d);
      }
 catch (      Throwable t) {
        LOGGER.error(""String_Node_Str"",t);
        stopServer(false,false);
        System.exit(-1);
      }
      startServer(true);
    }
 else {
      initLogging(args,d);
      try {
        LOGGER.info(""String_Node_Str"" + ansi().fg(RED).bold().a(""String_Node_Str"").reset().toString());
        if (RESTHEART_VERSION != null) {
          LOGGER.info(""String_Node_Str"",RESTHEART_VERSION);
        }
        logLoggingConfiguration(true);
        d.daemonize();
      }
 catch (      Throwable t) {
        LOGGER.error(""String_Node_Str"",t);
        stopServer(false,false);
        System.exit(-1);
      }
    }
  }
}"
93471,"/** 
 * @param exchange the url rewriting feature is implemented by the whatUriand whereUri parameters the exchange request path is rewritten replacing the whereUri string with the whatUri string the special whatUri value * means any resource: the whereUri is replaced with / example 1 whatUri = /mydb/mycollection whereUri = / then the requestPath / is rewritten to /mydb/mycollection example 2 whatUri = * whereUri = /data then the requestPath /data is rewritten to /
 * @param whereUri the uri to map to
 * @param whatUri the uri to map
 */
public RequestContext(HttpServerExchange exchange,String whereUri,String whatUri){
  this.whereUri=URLUtils.removeTrailingSlashes(whereUri == null ? null : whereUri.startsWith(""String_Node_Str"") ? whereUri : ""String_Node_Str"" + whereUri);
  this.whatUri=URLUtils.removeTrailingSlashes(whatUri == null ? null : whatUri.startsWith(""String_Node_Str"") ? whatUri : ""String_Node_Str"" + whatUri);
  this.unmappedRequestUri=exchange.getRequestPath();
  this.mappedRequestUri=unmapUri(exchange.getRequestPath());
  this.pathTokens=this.mappedRequestUri.split(SLASH);
  this.type=selectRequestType(pathTokens);
  this.method=selectRequestMethod(exchange.getRequestMethod());
}","/** 
 * @param exchange the url rewriting feature is implemented by the whatUriand whereUri parameters the exchange request path is rewritten replacing the whereUri string with the whatUri string the special whatUri value * means any resource: the whereUri is replaced with / example 1 whatUri = /mydb/mycollection whereUri = / then the requestPath / is rewritten to /mydb/mycollection example 2 whatUri = * whereUri = /data then the requestPath /data is rewritten to /
 * @param whereUri the uri to map to
 * @param whatUri the uri to map
 */
public RequestContext(HttpServerExchange exchange,String whereUri,String whatUri){
  this.whereUri=URLUtils.removeTrailingSlashes(whereUri == null ? null : whereUri.startsWith(""String_Node_Str"") ? whereUri : ""String_Node_Str"" + whereUri);
  this.whatUri=URLUtils.removeTrailingSlashes(whatUri == null ? null : whatUri.startsWith(""String_Node_Str"") || ""String_Node_Str"".equals(whatUri) ? whatUri : ""String_Node_Str"" + whatUri);
  this.unmappedRequestUri=exchange.getRequestPath();
  this.mappedRequestUri=unmapUri(exchange.getRequestPath());
  this.pathTokens=this.mappedRequestUri.split(SLASH);
  this.type=selectRequestType(pathTokens);
  this.method=selectRequestMethod(exchange.getRequestMethod());
}"
93472,"/** 
 * WARNING: slow method.
 * @param dbName
 * @return
 */
@Override public boolean doesDbExist(String dbName){
  if (dbName == null || dbName.isEmpty() || dbName.contains(""String_Node_Str"")) {
    return false;
  }
  CommandResult res=client.getDB(dbName).command(""String_Node_Str"");
  return (res.get(""String_Node_Str"") != null && res.get(""String_Node_Str"") instanceof BasicDBObject && ((BasicDBObject)res.get(""String_Node_Str"")).get(""String_Node_Str"") != null && ((BasicDBObject)res.get(""String_Node_Str"")).get(""String_Node_Str"") instanceof BasicDBList && ((BasicDBList)((BasicDBObject)res.get(""String_Node_Str"")).get(""String_Node_Str"")).size() > 0);
}","/** 
 * @param dbName
 * @return
 */
@Override public boolean doesDbExist(String dbName){
  if (dbName == null || dbName.isEmpty() || dbName.contains(""String_Node_Str"")) {
    return false;
  }
  return client.getDB(dbName).collectionExists(""String_Node_Str"");
}"
93473,"protected void addReturnedProperty(final List<DBObject> embeddedData,final Representation rep){
  long count=embeddedData == null ? 0 : embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
  rep.addProperty(""String_Node_Str"",count);
}","protected void addReturnedProperty(final List<DBObject> embeddedData,final Representation rep){
  long count=embeddedData == null ? 0 : embeddedData.stream().filter((props) -> props != null && props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
  rep.addProperty(""String_Node_Str"",count);
}"
93474,"/** 
 * Put into handlersMultimap all the default combinations of types, methods and PipedHttpHandler objects
 */
private void defaultInit(){
  LOGGER.info(""String_Node_Str"");
  putPipedHttpHandler(TYPE.ROOT,METHOD.GET,new GetRootHandler());
  putPipedHttpHandler(TYPE.DB,METHOD.GET,new GetDBHandler(new ResponseTranformerMetadataHandler(null)));
  putPipedHttpHandler(TYPE.DB,METHOD.PUT,new RequestTransformerMetadataHandler(new PutDBHandler()));
  putPipedHttpHandler(TYPE.DB,METHOD.DELETE,new DeleteDBHandler());
  putPipedHttpHandler(TYPE.DB,METHOD.PATCH,new RequestTransformerMetadataHandler(new PatchDBHandler()));
  putPipedHttpHandler(TYPE.COLLECTION,METHOD.GET,new GetCollectionHandler(new ResponseTranformerMetadataHandler(null)));
  putPipedHttpHandler(TYPE.COLLECTION,METHOD.POST,new CheckMetadataHandler(new RequestTransformerMetadataHandler(new PostCollectionHandler())));
  putPipedHttpHandler(TYPE.COLLECTION,METHOD.PUT,new RequestTransformerMetadataHandler(new PutCollectionHandler()));
  putPipedHttpHandler(TYPE.COLLECTION,METHOD.DELETE,new DeleteCollectionHandler());
  putPipedHttpHandler(TYPE.COLLECTION,METHOD.PATCH,new RequestTransformerMetadataHandler(new PatchCollectionHandler()));
  putPipedHttpHandler(TYPE.DOCUMENT,METHOD.GET,new GetDocumentHandler(new ResponseTranformerMetadataHandler(null)));
  putPipedHttpHandler(TYPE.DOCUMENT,METHOD.PUT,new CheckMetadataHandler(new RequestTransformerMetadataHandler(new PutDocumentHandler())));
  putPipedHttpHandler(TYPE.DOCUMENT,METHOD.DELETE,new DeleteDocumentHandler());
  putPipedHttpHandler(TYPE.DOCUMENT,METHOD.PATCH,new CheckMetadataHandler(new RequestTransformerMetadataHandler(new PatchDocumentHandler())));
  putPipedHttpHandler(TYPE.COLLECTION_INDEXES,METHOD.GET,new GetIndexesHandler());
  putPipedHttpHandler(TYPE.INDEX,METHOD.PUT,new PutIndexHandler());
  putPipedHttpHandler(TYPE.INDEX,METHOD.DELETE,new DeleteIndexHandler());
  putPipedHttpHandler(TYPE.FILES_BUCKET,METHOD.GET,new GetCollectionHandler(new ResponseTranformerMetadataHandler(null)));
  putPipedHttpHandler(TYPE.FILES_BUCKET,METHOD.POST,new CheckMetadataHandler(new RequestTransformerMetadataHandler(new PostBucketHandler())));
  putPipedHttpHandler(TYPE.FILES_BUCKET,METHOD.PUT,new RequestTransformerMetadataHandler(new PutBucketHandler()));
  putPipedHttpHandler(TYPE.FILES_BUCKET,METHOD.DELETE,new DeleteBucketHandler());
  putPipedHttpHandler(TYPE.FILE,METHOD.GET,new GetFileHandler(new ResponseTranformerMetadataHandler(null)));
  putPipedHttpHandler(TYPE.FILE_BINARY,METHOD.GET,new GetFileBinaryHandler());
  putPipedHttpHandler(TYPE.FILE,METHOD.PUT,new CheckMetadataHandler(new RequestTransformerMetadataHandler(new PutFileHandler())));
  putPipedHttpHandler(TYPE.FILE,METHOD.DELETE,new DeleteFileHandler());
  putPipedHttpHandler(TYPE.AGGREGATION,METHOD.GET,new GetAggregationHandler(new ResponseTranformerMetadataHandler(null)));
}","/** 
 * Put into handlersMultimap all the default combinations of types, methods and PipedHttpHandler objects
 */
private void defaultInit(){
  LOGGER.debug(""String_Node_Str"");
  putPipedHttpHandler(TYPE.ROOT,METHOD.GET,new GetRootHandler());
  putPipedHttpHandler(TYPE.DB,METHOD.GET,new GetDBHandler(new ResponseTranformerMetadataHandler(null)));
  putPipedHttpHandler(TYPE.DB,METHOD.PUT,new RequestTransformerMetadataHandler(new PutDBHandler()));
  putPipedHttpHandler(TYPE.DB,METHOD.DELETE,new DeleteDBHandler());
  putPipedHttpHandler(TYPE.DB,METHOD.PATCH,new RequestTransformerMetadataHandler(new PatchDBHandler()));
  putPipedHttpHandler(TYPE.COLLECTION,METHOD.GET,new GetCollectionHandler(new ResponseTranformerMetadataHandler(null)));
  putPipedHttpHandler(TYPE.COLLECTION,METHOD.POST,new CheckMetadataHandler(new RequestTransformerMetadataHandler(new PostCollectionHandler())));
  putPipedHttpHandler(TYPE.COLLECTION,METHOD.PUT,new RequestTransformerMetadataHandler(new PutCollectionHandler()));
  putPipedHttpHandler(TYPE.COLLECTION,METHOD.DELETE,new DeleteCollectionHandler());
  putPipedHttpHandler(TYPE.COLLECTION,METHOD.PATCH,new RequestTransformerMetadataHandler(new PatchCollectionHandler()));
  putPipedHttpHandler(TYPE.DOCUMENT,METHOD.GET,new GetDocumentHandler(new ResponseTranformerMetadataHandler(null)));
  putPipedHttpHandler(TYPE.DOCUMENT,METHOD.PUT,new CheckMetadataHandler(new RequestTransformerMetadataHandler(new PutDocumentHandler())));
  putPipedHttpHandler(TYPE.DOCUMENT,METHOD.DELETE,new DeleteDocumentHandler());
  putPipedHttpHandler(TYPE.DOCUMENT,METHOD.PATCH,new CheckMetadataHandler(new RequestTransformerMetadataHandler(new PatchDocumentHandler())));
  putPipedHttpHandler(TYPE.COLLECTION_INDEXES,METHOD.GET,new GetIndexesHandler());
  putPipedHttpHandler(TYPE.INDEX,METHOD.PUT,new PutIndexHandler());
  putPipedHttpHandler(TYPE.INDEX,METHOD.DELETE,new DeleteIndexHandler());
  putPipedHttpHandler(TYPE.FILES_BUCKET,METHOD.GET,new GetCollectionHandler(new ResponseTranformerMetadataHandler(null)));
  putPipedHttpHandler(TYPE.FILES_BUCKET,METHOD.POST,new CheckMetadataHandler(new RequestTransformerMetadataHandler(new PostBucketHandler())));
  putPipedHttpHandler(TYPE.FILES_BUCKET,METHOD.PUT,new RequestTransformerMetadataHandler(new PutBucketHandler()));
  putPipedHttpHandler(TYPE.FILES_BUCKET,METHOD.DELETE,new DeleteBucketHandler());
  putPipedHttpHandler(TYPE.FILE,METHOD.GET,new GetFileHandler(new ResponseTranformerMetadataHandler(null)));
  putPipedHttpHandler(TYPE.FILE_BINARY,METHOD.GET,new GetFileBinaryHandler());
  putPipedHttpHandler(TYPE.FILE,METHOD.PUT,new CheckMetadataHandler(new RequestTransformerMetadataHandler(new PutFileHandler())));
  putPipedHttpHandler(TYPE.FILE,METHOD.DELETE,new DeleteFileHandler());
  putPipedHttpHandler(TYPE.AGGREGATION,METHOD.GET,new GetAggregationHandler(new ResponseTranformerMetadataHandler(null)));
}"
93475,"private void embeddedDbs(RequestContext context,List<DBObject> embeddedData,boolean trailingSlash,String requestPath,Representation rep){
  embeddedData.stream().forEach((d) -> {
    Object _id=d.get(""String_Node_Str"");
    if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
      Representation nrep;
      if (trailingSlash) {
        nrep=new Representation(requestPath + _id.toString());
      }
 else {
        nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
      }
      if (context.isFullHalMode()) {
        DBRepresentationFactory.addSpecialProperties(nrep,RequestContext.TYPE.DB,d);
      }
      nrep.addProperties(d);
      rep.addRepresentation(""String_Node_Str"",nrep);
    }
 else {
      LOGGER.error(""String_Node_Str"",d);
    }
  }
);
}","private void embeddedDbs(RequestContext context,List<DBObject> embeddedData,boolean trailingSlash,String requestPath,Representation rep){
  embeddedData.stream().filter(d -> d != null).forEach((d) -> {
    Object _id=d.get(""String_Node_Str"");
    if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
      Representation nrep;
      if (trailingSlash) {
        nrep=new Representation(requestPath + _id.toString());
      }
 else {
        nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
      }
      if (context.isFullHalMode()) {
        DBRepresentationFactory.addSpecialProperties(nrep,RequestContext.TYPE.DB,d);
      }
      nrep.addProperties(d);
      rep.addRepresentation(""String_Node_Str"",nrep);
    }
 else {
      LOGGER.error(""String_Node_Str"",d);
    }
  }
);
}"
93476,"private void embeddedDocuments(List<DBObject> embeddedData,String requestPath,HttpServerExchange exchange,RequestContext context,Representation rep) throws IllegalQueryParamenterException {
  for (  DBObject d : embeddedData) {
    Object _id=d.get(""String_Node_Str"");
    if (RequestContext.isReservedResourceCollection(_id.toString())) {
      rep.addWarning(""String_Node_Str"" + requestPath + ""String_Node_Str""+ _id.toString());
    }
 else {
      Representation nrep=new DocumentRepresentationFactory().getRepresentation(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
      if (rep.getType() == RequestContext.TYPE.FILES_BUCKET) {
        if (context.isFullHalMode()) {
          DocumentRepresentationFactory.addSpecialProperties(nrep,TYPE.FILE,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
 else {
        if (context.isFullHalMode()) {
          DocumentRepresentationFactory.addSpecialProperties(nrep,TYPE.DOCUMENT,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
    }
  }
}","private void embeddedDocuments(List<DBObject> embeddedData,String requestPath,HttpServerExchange exchange,RequestContext context,Representation rep) throws IllegalQueryParamenterException {
  for (  DBObject d : embeddedData) {
    Object _id=d.get(""String_Node_Str"");
    if (RequestContext.isReservedResourceCollection(_id.toString())) {
      rep.addWarning(""String_Node_Str"" + requestPath + ""String_Node_Str""+ _id.toString());
    }
 else {
      Representation nrep=new DocumentRepresentationFactory().getRepresentation(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
      if (context.getType() == RequestContext.TYPE.FILES_BUCKET) {
        if (context.isFullHalMode()) {
          DocumentRepresentationFactory.addSpecialProperties(nrep,TYPE.FILE,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
 else {
        if (context.isFullHalMode()) {
          DocumentRepresentationFactory.addSpecialProperties(nrep,TYPE.DOCUMENT,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
    }
  }
}"
93477,"private void addLinkTemplates(final HttpServerExchange exchange,final RequestContext context,final Representation rep,final String requestPath){
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
  }
  if (TYPE.FILES_BUCKET.equals(context.getType())) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"" + RequestContext.FS_FILES_SUFFIX,true));
    rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  }
 else   if (TYPE.COLLECTION.equals(context.getType())) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"",true));
    rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"" + context.getDBName()+ ""String_Node_Str""+ context.getCollectionName()+ ""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str""));
}","private void addLinkTemplates(final RequestContext context,final Representation rep,final String requestPath){
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
  }
  if (TYPE.FILES_BUCKET.equals(context.getType())) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"" + RequestContext.FS_FILES_SUFFIX,true));
    rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  }
 else   if (TYPE.COLLECTION.equals(context.getType())) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"",true));
    rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"" + context.getDBName()+ ""String_Node_Str""+ context.getCollectionName()+ ""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str""));
}"
93478,"/** 
 * @param exchange
 * @param context
 * @param embeddedData
 * @param size
 * @return
 * @throws IllegalQueryParamenterException
 */
@Override public Representation getRepresentation(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  final String requestPath=buildRequestPath(exchange);
  final Representation rep=createRepresentation(exchange,context,requestPath);
  addProperties(rep,context);
  addSizeAndTotalPagesProperties(size,context,rep);
  addAggregationsLinks(context,rep,requestPath);
  addEmbeddedData(embeddedData,rep,requestPath,exchange,context);
  if (context.isFullHalMode()) {
    addSpecialProperties(rep,context.getType(),context.getCollectionProps());
    addPaginationLinks(exchange,context,size,rep);
    addLinkTemplates(exchange,context,rep,requestPath);
    rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
  }
 else {
    rep.addLinkArray(""String_Node_Str"");
  }
  return rep;
}","/** 
 * @param exchange
 * @param context
 * @param embeddedData
 * @param size
 * @return
 * @throws IllegalQueryParamenterException
 */
@Override public Representation getRepresentation(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  final String requestPath=buildRequestPath(exchange);
  final Representation rep=createRepresentation(exchange,context,requestPath);
  addProperties(rep,context);
  addSizeAndTotalPagesProperties(size,context,rep);
  addAggregationsLinks(context,rep,requestPath);
  addEmbeddedData(embeddedData,rep,requestPath,exchange,context);
  if (context.isFullHalMode()) {
    addSpecialProperties(rep,context.getType(),context.getCollectionProps());
    addPaginationLinks(exchange,context,size,rep);
    addLinkTemplates(context,rep,requestPath);
    rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
  }
 else {
    rep.addLinkArray(""String_Node_Str"");
  }
  return rep;
}"
93479,"/** 
 * @param dbName
 * @return
 */
public boolean addDbProps(String dbName){
  if (!dbsDAO.existsDatabaseWithName(dbName)) {
    return false;
  }
  DBObject dbmd=dbsDAO.getDatabaseProperties(dbName,false);
  if (dbmd != null) {
    return false;
  }
  DBObject properties=new BasicDBObject();
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  properties.put(""String_Node_Str"",""String_Node_Str"");
  properties.put(""String_Node_Str"",now.toString());
  properties.put(""String_Node_Str"",timestamp);
  DBCollection coll=dbsDAO.getCollection(dbName,""String_Node_Str"");
  coll.insert(properties);
  LOGGER.info(""String_Node_Str"",dbName);
  return true;
}","/** 
 * @param dbName
 * @return
 */
public boolean addDbProps(String dbName){
  if (!dbsDAO.doesDbExist(dbName)) {
    return false;
  }
  DBObject dbmd=dbsDAO.getDatabaseProperties(dbName,false);
  if (dbmd != null) {
    return false;
  }
  DBObject properties=new BasicDBObject();
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  properties.put(""String_Node_Str"",""String_Node_Str"");
  properties.put(""String_Node_Str"",now.toString());
  properties.put(""String_Node_Str"",timestamp);
  DBCollection coll=dbsDAO.getCollection(dbName,""String_Node_Str"");
  coll.insert(properties);
  LOGGER.info(""String_Node_Str"",dbName);
  return true;
}"
93480,"/** 
 * @param exchange the url rewriting feature is implemented by the whatUriand whereUri parameters the exchange request path is rewritten replacing the whereUri string with the whatUri string the special whatUri value * means any resource: the whereUri is replaced with / example 1 whatUri = /mydb/mycollection whereUri = / then the requestPath / is rewritten to /mydb/mycollection example 2 whatUri = * whereUri = /data then the requestPath /data is rewritten to /
 * @param whereUri the uri to map to
 * @param whatUri the uri to map
 */
public RequestContext(HttpServerExchange exchange,String whereUri,String whatUri){
  this.whereUri=URLUtils.removeTrailingSlashes(whereUri);
  this.whatUri=whatUri;
  this.unmappedRequestUri=exchange.getRequestPath();
  this.mappedRequestUri=unmapUri(exchange.getRequestPath());
  this.pathTokens=this.mappedRequestUri.split(SLASH);
  this.type=selectRequestType(pathTokens);
  this.method=selectRequestMethod(exchange.getRequestMethod());
}","/** 
 * @param exchange the url rewriting feature is implemented by the whatUriand whereUri parameters the exchange request path is rewritten replacing the whereUri string with the whatUri string the special whatUri value * means any resource: the whereUri is replaced with / example 1 whatUri = /mydb/mycollection whereUri = / then the requestPath / is rewritten to /mydb/mycollection example 2 whatUri = * whereUri = /data then the requestPath /data is rewritten to /
 * @param whereUri the uri to map to
 * @param whatUri the uri to map
 */
public RequestContext(HttpServerExchange exchange,String whereUri,String whatUri){
  this.whereUri=URLUtils.removeTrailingSlashes(whereUri == null ? null : whereUri.startsWith(""String_Node_Str"") ? whereUri : ""String_Node_Str"" + whereUri);
  this.whatUri=URLUtils.removeTrailingSlashes(whatUri == null ? null : whatUri.startsWith(""String_Node_Str"") ? whatUri : ""String_Node_Str"" + whatUri);
  this.unmappedRequestUri=exchange.getRequestPath();
  this.mappedRequestUri=unmapUri(exchange.getRequestPath());
  this.pathTokens=this.mappedRequestUri.split(SLASH);
  this.type=selectRequestType(pathTokens);
  this.method=selectRequestMethod(exchange.getRequestMethod());
}"
93481,"/** 
 * given a mapped uri (/some/mapping/coll) returns the canonical uri (/db/coll) URLs are mapped to mongodb resources by using the mongo-mounts configuration properties
 * @param mappedUri
 * @return
 */
public final String unmapUri(String mappedUri){
  String ret=URLUtils.removeTrailingSlashes(mappedUri);
  if (whatUri.equals(""String_Node_Str"")) {
    if (!this.whereUri.equals(SLASH)) {
      ret=ret.replaceFirst(""String_Node_Str"" + this.whereUri,""String_Node_Str"");
    }
  }
 else {
    ret=URLUtils.removeTrailingSlashes(ret.replaceFirst(""String_Node_Str"" + this.whereUri,this.whatUri));
  }
  if (ret.isEmpty()) {
    ret=SLASH;
  }
  return ret;
}","/** 
 * given a mapped uri (/some/mapping/coll) returns the canonical uri (/db/coll) URLs are mapped to mongodb resources by using the mongo-mounts configuration properties
 * @param mappedUri
 * @return
 */
public final String unmapUri(String mappedUri){
  String ret=URLUtils.removeTrailingSlashes(mappedUri);
  if (whatUri.equals(""String_Node_Str"")) {
    if (!this.whereUri.equals(SLASH)) {
      ret=ret.replaceFirst(""String_Node_Str"" + this.whereUri,""String_Node_Str"");
    }
  }
 else {
    if (!this.whereUri.equals(SLASH)) {
      ret=URLUtils.removeTrailingSlashes(ret.replaceFirst(""String_Node_Str"" + this.whereUri,this.whatUri));
    }
 else {
      ret=URLUtils.removeTrailingSlashes(URLUtils.removeTrailingSlashes(this.whatUri) + ret);
    }
  }
  if (ret.isEmpty()) {
    ret=SLASH;
  }
  return ret;
}"
93482,"private void embeddedCollections(final List<DBObject> embeddedData,final RequestContext context,final String requestPath,final Representation rep){
  embeddedData.stream().forEach((d) -> {
    Object _id=d.get(""String_Node_Str"");
    if (_id != null && _id instanceof String) {
      String id=(String)_id;
      Representation nrep=new Representation(requestPath + ""String_Node_Str"" + id);
      nrep.addProperties(d);
      if (id.endsWith(RequestContext.FS_FILES_SUFFIX)) {
        if (context.isFullHalMode()) {
          CollectionRepresentationFactory.addSpecialProperties(nrep,TYPE.FILES_BUCKET,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
 else {
        if (context.isFullHalMode()) {
          CollectionRepresentationFactory.addSpecialProperties(nrep,TYPE.COLLECTION,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
    }
 else {
      LOGGER.error(""String_Node_Str"",_id);
    }
  }
);
}","private void embeddedCollections(final List<DBObject> embeddedData,final RequestContext context,final String requestPath,final Representation rep){
  embeddedData.stream().forEach((d) -> {
    Object _id=d.get(""String_Node_Str"");
    if (_id != null && _id instanceof String) {
      String id=(String)_id;
      String rp=URLUtils.removeTrailingSlashes(requestPath);
      rp=""String_Node_Str"".equals(rp) ? ""String_Node_Str"" : rp;
      Representation nrep=new Representation(rp + ""String_Node_Str"" + id);
      nrep.addProperties(d);
      if (id.endsWith(RequestContext.FS_FILES_SUFFIX)) {
        if (context.isFullHalMode()) {
          CollectionRepresentationFactory.addSpecialProperties(nrep,TYPE.FILES_BUCKET,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
 else {
        if (context.isFullHalMode()) {
          CollectionRepresentationFactory.addSpecialProperties(nrep,TYPE.COLLECTION,d);
        }
        rep.addRepresentation(""String_Node_Str"",nrep);
      }
    }
 else {
      LOGGER.error(""String_Node_Str"",_id);
    }
  }
);
}"
93483,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  OperationResult result=getDatabase().deleteCollection(context.getDBName(),context.getCollectionName(),etag);
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.injectEtagHeader(exchange,context.getCollectionProps());
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  OperationResult result=getDatabase().deleteCollection(context.getDBName(),context.getCollectionName(),etag);
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93484,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(RepresentationTransformer.RTS_ELEMENT_NAME)) {
    try {
      RepresentationTransformer.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(RequestChecker.SCS_ELEMENT_NAME)) {
    try {
      RequestChecker.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  OperationResult result=getDatabase().upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(RepresentationTransformer.RTS_ELEMENT_NAME)) {
    try {
      RepresentationTransformer.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(RequestChecker.SCS_ELEMENT_NAME)) {
    try {
      RequestChecker.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.injectEtagHeader(exchange,context.getCollectionProps());
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  OperationResult result=getDatabase().upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93485,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  OperationResult result=getDatabase().deleteDatabase(context.getDBName(),etag);
  exchange.setResponseCode(result.getHttpCode());
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.injectEtagHeader(exchange,context.getDbProps());
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  OperationResult result=getDatabase().deleteDatabase(context.getDBName(),etag);
  exchange.setResponseCode(result.getHttpCode());
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}"
93486,"/** 
 * partial update db properties
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(RepresentationTransformer.RTS_ELEMENT_NAME)) {
    try {
      RepresentationTransformer.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  OperationResult result=getDatabase().upsertDB(context.getDBName(),content,etag,true,true);
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}","/** 
 * partial update db properties
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(RepresentationTransformer.RTS_ELEMENT_NAME)) {
    try {
      RepresentationTransformer.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.injectEtagHeader(exchange,context.getDbProps());
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  OperationResult result=getDatabase().upsertDB(context.getDBName(),content,etag,true,true);
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}"
93487,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  OperationResult result=this.documentDAO.deleteDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),etag);
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.injectEtagHeader(exchange,this.documentDAO.getDocumentEtag(context.getDBName(),context.getCollectionName(),context.getDocumentId()));
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  OperationResult result=this.documentDAO.deleteDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),etag);
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
}"
93488,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  Object id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",id);
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId requestEtag=RequestHelper.getWriteEtag(exchange);
  OperationResult result=documentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,requestEtag,true);
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
 else {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  Object id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",id);
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId requestEtag=RequestHelper.getWriteEtag(exchange);
  OperationResult result=documentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,requestEtag,true);
  if (result.getEtag() != null) {
    exchange.getResponseHeaders().put(Headers.ETAG,result.getEtag().toString());
  }
 else {
    ResponseHelper.injectEtagHeader(exchange,this.documentDAO.getDocumentEtag(context.getDBName(),context.getCollectionName(),context.getDocumentId()));
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.IF_MATCH + ""String_Node_Str"");
    return;
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(result.getHttpCode(),exchange,context);
  }
 else {
    exchange.setResponseCode(result.getHttpCode());
  }
  exchange.endExchange();
}"
93489,"/** 
 * @param exchange
 * @param properties
 */
public static void injectEtagHeader(HttpServerExchange exchange,DBObject properties){
  if (properties == null) {
    return;
  }
  Object _etag=properties.get(""String_Node_Str"");
  if (ObjectId.isValid(""String_Node_Str"" + _etag)) {
    ObjectId etag=(ObjectId)_etag;
    exchange.getResponseHeaders().put(Headers.ETAG,etag.toString());
  }
}","/** 
 * @param exchange
 * @param properties
 */
public static void injectEtagHeader(HttpServerExchange exchange,DBObject properties){
  if (properties == null) {
    return;
  }
  Object _etag=properties.get(""String_Node_Str"");
  if (_etag == null || !(_etag instanceof ObjectId)) {
    return;
  }
  exchange.getResponseHeaders().put(Headers.ETAG,_etag.toString());
}"
93490,"/** 
 * @param channel
 * @return
 * @throws IOException
 */
public static String read(StreamSourceChannel channel) throws IOException {
  final int capacity=1024;
  ByteArrayOutputStream os=new ByteArrayOutputStream(capacity);
  ByteBuffer buf=ByteBuffer.allocate(capacity);
  while (Channels.readBlocking(channel,buf) != -1) {
    buf.flip();
    os.write(buf.array());
    buf.clear();
  }
  return new String(os.toByteArray(),CHARSET);
}","/** 
 * @param channel
 * @return
 * @throws IOException
 */
public static String read(StreamSourceChannel channel) throws IOException {
  final int capacity=1024;
  ByteArrayOutputStream os=new ByteArrayOutputStream(capacity);
  ByteBuffer buf=ByteBuffer.allocate(capacity);
  int read=Channels.readBlocking(channel,buf);
  while (read != -1) {
    buf.flip();
    os.write(buf.array(),0,read);
    buf.clear();
    read=Channels.readBlocking(channel,buf);
  }
  String ret=os.toString(CHARSET.name());
  return ret;
}"
93491,"private void addLinkTemplates(final HttpServerExchange exchange,final RequestContext context,final Representation rep,final String requestPath){
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"" + RequestContext.FS_FILES_SUFFIX,true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
}","private void addLinkTemplates(final HttpServerExchange exchange,final RequestContext context,final Representation rep,final String requestPath){
  String parentPath=URLUtils.getParentPath(requestPath);
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",parentPath));
  }
  if (parentPath.endsWith(""String_Node_Str"")) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.removeTrailingSlashes(URLUtils.getParentPath(requestPath)) + ""String_Node_Str"",true));
  }
 else {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.removeTrailingSlashes(URLUtils.getParentPath(requestPath)) + ""String_Node_Str"",true));
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"" + RequestContext.FS_FILES_SUFFIX,true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
}"
93492,"private void addEmbeddedData(List<DBObject> embeddedData,final Representation rep,final String requestPath,final HttpServerExchange exchange,final RequestContext context) throws IllegalQueryParamenterException {
  if (embeddedData != null) {
    addReturnedProperty(embeddedData,rep);
    if (!embeddedData.isEmpty()) {
      embeddedDocuments(embeddedData,requestPath,exchange,context,rep);
    }
  }
}","private void addEmbeddedData(List<DBObject> embeddedData,final Representation rep,final String requestPath,final HttpServerExchange exchange,final RequestContext context) throws IllegalQueryParamenterException {
  if (embeddedData != null) {
    addReturnedProperty(embeddedData,rep);
    if (!embeddedData.isEmpty()) {
      embeddedDocuments(embeddedData,requestPath,exchange,context,rep);
    }
  }
 else {
    rep.addProperty(""String_Node_Str"",0);
  }
}"
93493,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBCollection coll=getDatabase().getCollection(context.getDBName(),context.getCollectionName());
  long size=-1;
  if (context.isCount()) {
    size=getDatabase().getCollectionSize(coll,exchange.getQueryParameters().get(""String_Node_Str""));
  }
  ArrayList<DBObject> data=null;
  if (context.getPagesize() > 0 && (context.getHalMode() == HAL_MODE.F || context.getHalMode() == HAL_MODE.FULL)) {
    try {
      data=getDatabase().getCollectionData(coll,context.getPage(),context.getPagesize(),context.getSortBy(),context.getFilter(),context.getKeys(),context.getCursorAllocationPolicy());
    }
 catch (    JSONParseException jpe) {
      LOGGER.debug(""String_Node_Str"",context.getFilter(),jpe);
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_BAD_REQUEST,""String_Node_Str"",jpe);
      return;
    }
catch (    MongoException me) {
      if (me.getMessage().matches(""String_Node_Str"")) {
        LOGGER.debug(""String_Node_Str"",context.getFilter(),me);
        ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_BAD_REQUEST,""String_Node_Str"",me);
        return;
      }
 else {
        throw me;
      }
    }
  }
  if (exchange.isComplete()) {
    return;
  }
  if ((context.getPagesize() > 0 && (data == null || data.isEmpty())) && (context.getCollectionProps() == null || context.getCollectionProps().keySet().isEmpty())) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_FOUND);
    return;
  }
  try {
    CollectionRepresentationFactory crp=new CollectionRepresentationFactory();
    Representation rep=crp.getRepresentation(exchange,context,data,size);
    exchange.setResponseCode(HttpStatus.SC_OK);
    if (getNext() != null) {
      DBObject responseContent=rep.asDBObject();
      context.setResponseContent(responseContent);
      getNext().handleRequest(exchange,context);
    }
    crp.sendRepresentation(exchange,context,rep);
    exchange.endExchange();
  }
 catch (  IllegalQueryParamenterException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_BAD_REQUEST,ex.getMessage(),ex);
  }
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBCollection coll=getDatabase().getCollection(context.getDBName(),context.getCollectionName());
  long size=-1;
  if (context.isCount()) {
    size=getDatabase().getCollectionSize(coll,exchange.getQueryParameters().get(""String_Node_Str""));
  }
  ArrayList<DBObject> data=null;
  if (context.getPagesize() > 0) {
    try {
      data=getDatabase().getCollectionData(coll,context.getPage(),context.getPagesize(),context.getSortBy(),context.getFilter(),context.getKeys(),context.getCursorAllocationPolicy());
    }
 catch (    JSONParseException jpe) {
      LOGGER.debug(""String_Node_Str"",context.getFilter(),jpe);
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_BAD_REQUEST,""String_Node_Str"",jpe);
      return;
    }
catch (    MongoException me) {
      if (me.getMessage().matches(""String_Node_Str"")) {
        LOGGER.debug(""String_Node_Str"",context.getFilter(),me);
        ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_BAD_REQUEST,""String_Node_Str"",me);
        return;
      }
 else {
        throw me;
      }
    }
  }
  if (exchange.isComplete()) {
    return;
  }
  if ((context.getPagesize() > 0 && (data == null || data.isEmpty())) && (context.getCollectionProps() == null || context.getCollectionProps().keySet().isEmpty())) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_FOUND);
    return;
  }
  try {
    CollectionRepresentationFactory crp=new CollectionRepresentationFactory();
    Representation rep=crp.getRepresentation(exchange,context,data,size);
    exchange.setResponseCode(HttpStatus.SC_OK);
    if (getNext() != null) {
      DBObject responseContent=rep.asDBObject();
      context.setResponseContent(responseContent);
      getNext().handleRequest(exchange,context);
    }
    crp.sendRepresentation(exchange,context,rep);
    exchange.endExchange();
  }
 catch (  IllegalQueryParamenterException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_BAD_REQUEST,ex.getMessage(),ex);
  }
}"
93494,"private void addEmbeddedData(final List<DBObject> embeddedData,final Representation rep,final String requestPath){
  if (embeddedData != null) {
    addReturnedProperty(embeddedData,rep);
    if (!embeddedData.isEmpty()) {
      embeddedCollections(embeddedData,requestPath,rep);
    }
  }
}","private void addEmbeddedData(final List<DBObject> embeddedData,final Representation rep,final String requestPath){
  if (embeddedData != null) {
    addReturnedProperty(embeddedData,rep);
    if (!embeddedData.isEmpty()) {
      embeddedCollections(embeddedData,requestPath,rep);
    }
  }
 else {
    rep.addProperty(""String_Node_Str"",0);
  }
}"
93495,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  List<String> colls=getDatabase().getCollectionNames(getDatabase().getDB(context.getDBName()));
  List<DBObject> data=null;
  if (context.getPagesize() > 0 && (context.getHalMode() == RequestContext.HAL_MODE.F || context.getHalMode() == RequestContext.HAL_MODE.FULL)) {
    data=getDatabase().getData(context.getDBName(),colls,context.getPage(),context.getPagesize());
  }
  DBRepresentationFactory repf=new DBRepresentationFactory();
  Representation rep=repf.getRepresentation(exchange,context,data,getDatabase().getDBSize(colls));
  exchange.setResponseCode(HttpStatus.SC_OK);
  if (getNext() != null) {
    DBObject responseContent=rep.asDBObject();
    context.setResponseContent(responseContent);
    getNext().handleRequest(exchange,context);
  }
  repf.sendRepresentation(exchange,context,rep);
  exchange.endExchange();
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  List<String> colls=getDatabase().getCollectionNames(getDatabase().getDB(context.getDBName()));
  List<DBObject> data=null;
  if (context.getPagesize() > 0) {
    data=getDatabase().getData(context.getDBName(),colls,context.getPage(),context.getPagesize());
  }
  DBRepresentationFactory repf=new DBRepresentationFactory();
  Representation rep=repf.getRepresentation(exchange,context,data,getDatabase().getDBSize(colls));
  exchange.setResponseCode(HttpStatus.SC_OK);
  if (getNext() != null) {
    DBObject responseContent=rep.asDBObject();
    context.setResponseContent(responseContent);
    getNext().handleRequest(exchange,context);
  }
  repf.sendRepresentation(exchange,context,rep);
  exchange.endExchange();
}"
93496,"/** 
 * @param channel
 * @return
 * @throws IOException
 */
public static String read(StreamSourceChannel channel) throws IOException {
  StringBuilder content=new StringBuilder();
  ByteBuffer buf=ByteBuffer.allocate(128);
  while (Channels.readBlocking(channel,buf) != -1) {
    buf.flip();
    content.append(charset.decode(buf));
    buf.clear();
  }
  return content.toString();
}","/** 
 * @param channel
 * @return
 * @throws IOException
 */
public static String read(StreamSourceChannel channel) throws IOException {
  final int capacity=1024;
  ByteArrayOutputStream os=new ByteArrayOutputStream(capacity);
  ByteBuffer buf=ByteBuffer.allocate(capacity);
  while (Channels.readBlocking(channel,buf) != -1) {
    buf.flip();
    os.write(buf.array());
    buf.clear();
  }
  return new String(os.toByteArray(),CHARSET);
}"
93497,"ArrayList<DBObject> getCollectionData(DBCollection coll,int page,int pagesize,Deque<String> sortBy,Deque<String> filters,Deque<String> keys,DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY eager) throws JSONParseException {
  ArrayList<DBObject> ret=new ArrayList<>();
  int toskip=pagesize * (page - 1);
  DBCursor cursor;
  SkippedDBCursor _cursor=null;
  if (eager != DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY.NONE) {
    _cursor=DBCursorPool.getInstance().get(new DBCursorPoolEntryKey(coll,sortBy,filters,keys,toskip,0),eager);
  }
  int alreadySkipped;
  if (_cursor == null) {
    cursor=getCollectionDBCursor(coll,sortBy,filters,keys);
    alreadySkipped=0;
  }
 else {
    cursor=_cursor.getCursor();
    alreadySkipped=_cursor.getAlreadySkipped();
  }
  while (toskip > alreadySkipped) {
    cursor.next();
    alreadySkipped++;
  }
  while (pagesize > 0 && cursor.hasNext()) {
    ret.add(cursor.next());
    pagesize--;
  }
  ret.forEach(row -> {
    Object etag=row.get(""String_Node_Str"");
    if (row.get(""String_Node_Str"") == null && etag != null && etag instanceof ObjectId) {
      row.put(""String_Node_Str"",Instant.ofEpochSecond(((ObjectId)etag).getTimestamp()).toString());
    }
    Object id=row.get(""String_Node_Str"");
    if (row.get(""String_Node_Str"") == null && id != null && id instanceof ObjectId) {
      row.put(""String_Node_Str"",Instant.ofEpochSecond(((ObjectId)id).getTimestamp()).toString());
    }
  }
);
  return ret;
}","ArrayList<DBObject> getCollectionData(DBCollection coll,int page,int pagesize,Deque<String> sortBy,Deque<String> filters,Deque<String> keys,DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY eager) throws JSONParseException {
  ArrayList<DBObject> ret=new ArrayList<>();
  int toskip=pagesize * (page - 1);
  DBCursor cursor;
  SkippedDBCursor _cursor=null;
  if (eager != DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY.NONE) {
    _cursor=DBCursorPool.getInstance().get(new DBCursorPoolEntryKey(coll,sortBy,filters,keys,toskip,0),eager);
  }
  if (_cursor == null) {
    cursor=getCollectionDBCursor(coll,sortBy,filters,keys);
    cursor.skip(toskip);
    while (pagesize > 0 && cursor.hasNext()) {
      ret.add(cursor.next());
      pagesize--;
    }
  }
 else {
    int alreadySkipped;
    cursor=_cursor.getCursor();
    alreadySkipped=_cursor.getAlreadySkipped();
    while (toskip > alreadySkipped && cursor.hasNext()) {
      cursor.next();
      alreadySkipped++;
    }
    while (pagesize > 0 && cursor.hasNext()) {
      ret.add(cursor.next());
      pagesize--;
    }
  }
  ret.forEach(row -> {
    Object etag=row.get(""String_Node_Str"");
    if (row.get(""String_Node_Str"") == null && etag != null && etag instanceof ObjectId) {
      row.put(""String_Node_Str"",Instant.ofEpochSecond(((ObjectId)etag).getTimestamp()).toString());
    }
    Object id=row.get(""String_Node_Str"");
    if (row.get(""String_Node_Str"") == null && id != null && id instanceof ObjectId) {
      row.put(""String_Node_Str"",Instant.ofEpochSecond(((ObjectId)id).getTimestamp()).toString());
    }
  }
);
  DBCursorPool.getInstance().populateCache(new DBCursorPoolEntryKey(coll,sortBy,filters,keys,toskip,0),eager);
  return ret;
}"
93498,"/** 
 * Returs the DBCursor of the collection applying sorting and filtering.
 * @param coll the mongodb DBCollection object
 * @param sortBy the Deque collection of fields to use for sorting (prependfield name with - for descending sorting)
 * @param filters the filters to apply. it is a Deque collection of mongodbquery conditions.
 * @param keys 
 * @return
 * @throws JSONParseException
 */
DBCursor getCollectionDBCursor(DBCollection coll,Deque<String> sortBy,Deque<String> filters,Deque<String> keys) throws JSONParseException {
  DBObject sort=new BasicDBObject();
  if (sortBy == null || sortBy.isEmpty()) {
    sort.put(""String_Node_Str"",-1);
  }
 else {
    sortBy.stream().forEach((s) -> {
      String _s=s.trim();
      if (_s.startsWith(""String_Node_Str"")) {
        sort.put(_s.substring(1),-1);
      }
 else       if (_s.startsWith(""String_Node_Str"")) {
        sort.put(_s.substring(1),1);
      }
 else {
        sort.put(_s,1);
      }
    }
);
  }
  final BasicDBObject query=new BasicDBObject();
  if (filters != null) {
    filters.stream().forEach((    String f) -> {
      BSONObject filterQuery=(BSONObject)JSON.parse(f);
      query.putAll(filterQuery);
    }
);
  }
  final BasicDBObject fields=new BasicDBObject();
  if (keys != null) {
    keys.stream().forEach((    String f) -> {
      BSONObject keyQuery=(BSONObject)JSON.parse(f);
      fields.putAll(keyQuery);
    }
);
  }
  return coll.find(query,fields).sort(sort);
}","/** 
 * Returs the DBCursor of the collection applying sorting and filtering.
 * @param coll the mongodb DBCollection object
 * @param sortBy the Deque collection of fields to use for sorting (prependfield name with - for descending sorting)
 * @param filters the filters to apply. it is a Deque collection of mongodbquery conditions.
 * @param keys
 * @return
 * @throws JSONParseException
 */
DBCursor getCollectionDBCursor(DBCollection coll,Deque<String> sortBy,Deque<String> filters,Deque<String> keys) throws JSONParseException {
  DBObject sort=new BasicDBObject();
  if (sortBy == null || sortBy.isEmpty()) {
    sort.put(""String_Node_Str"",-1);
  }
 else {
    sortBy.stream().forEach((s) -> {
      String _s=s.trim();
      if (_s.startsWith(""String_Node_Str"")) {
        sort.put(_s.substring(1),-1);
      }
 else       if (_s.startsWith(""String_Node_Str"")) {
        sort.put(_s.substring(1),1);
      }
 else {
        sort.put(_s,1);
      }
    }
);
  }
  final BasicDBObject query=new BasicDBObject();
  if (filters != null) {
    filters.stream().forEach((    String f) -> {
      BSONObject filterQuery=(BSONObject)JSON.parse(f);
      query.putAll(filterQuery);
    }
);
  }
  final BasicDBObject fields=new BasicDBObject();
  if (keys != null) {
    keys.stream().forEach((    String f) -> {
      BSONObject keyQuery=(BSONObject)JSON.parse(f);
      fields.putAll(keyQuery);
    }
);
  }
  return coll.find(query,fields).sort(sort);
}"
93499,"private void populateCacheRandom(DBCursorPoolEntryKey key){
  executor.submit(() -> {
    Long size=collSizes.getLoading(key).get();
    int sliceWidht;
    int slices=0;
    int totalSlices=size.intValue() / SKIP_SLICE_RND_MIN_WIDTH + 1;
    if (totalSlices <= SKIP_SLICE_RND_MAX_CURSORS) {
      slices=totalSlices;
      sliceWidht=SKIP_SLICE_RND_MIN_WIDTH;
    }
 else {
      slices=SKIP_SLICE_RND_MAX_CURSORS;
      sliceWidht=size.intValue() / slices;
    }
    for (int slice=1; slice < slices; slice++) {
      int sliceSkips=(int)slice * sliceWidht;
      DBCursorPoolEntryKey sliceKey=new DBCursorPoolEntryKey(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys(),sliceSkips,-1);
      long existing=getSliceHeight(sliceKey);
      for (long cont=1 - existing; cont > 0; cont--) {
        DBCursor cursor=dbsDAO.getCollectionDBCursor(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys());
        cursor.skip(sliceSkips);
        DBCursorPoolEntryKey newkey=new DBCursorPoolEntryKey(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys(),sliceSkips,System.nanoTime());
        cache.put(newkey,cursor);
        LOGGER.debug(""String_Node_Str"",newkey);
      }
    }
  }
);
}","private void populateCacheRandom(DBCursorPoolEntryKey key){
  executor.submit(() -> {
    Long size=collSizes.getLoading(key).get();
    int sliceWidht;
    int slices;
    int totalSlices=size.intValue() / SKIP_SLICE_RND_MIN_WIDTH + 1;
    if (totalSlices <= SKIP_SLICE_RND_MAX_CURSORS) {
      slices=totalSlices;
      sliceWidht=SKIP_SLICE_RND_MIN_WIDTH;
    }
 else {
      slices=SKIP_SLICE_RND_MAX_CURSORS;
      sliceWidht=size.intValue() / slices;
    }
    for (int slice=1; slice < slices; slice++) {
      int sliceSkips=(int)slice * sliceWidht;
      DBCursorPoolEntryKey sliceKey=new DBCursorPoolEntryKey(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys(),sliceSkips,-1);
      long existing=getSliceHeight(sliceKey);
      if (existing == 0) {
        DBCursor cursor=dbsDAO.getCollectionDBCursor(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys());
        cursor.skip(sliceSkips).limit(1000 + sliceWidht);
        cursor.hasNext();
        DBCursorPoolEntryKey newkey=new DBCursorPoolEntryKey(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys(),sliceSkips,System.nanoTime());
        cache.put(newkey,cursor);
        LOGGER.debug(""String_Node_Str"",newkey);
      }
    }
  }
);
}"
93500,"private void populateCacheLinear(DBCursorPoolEntryKey key){
  if (key.getSkipped() < SKIP_SLICE_LINEAR_WIDTH) {
    return;
  }
  int firstSlice=key.getSkipped() / SKIP_SLICE_LINEAR_WIDTH;
  executor.submit(() -> {
    int slice=firstSlice;
    for (    int tohave : SKIP_SLICES_HEIGHTS) {
      int sliceSkips=slice * SKIP_SLICE_LINEAR_WIDTH - SKIP_SLICE_LINEAR_DELTA;
      DBCursorPoolEntryKey sliceKey=new DBCursorPoolEntryKey(key.getCollection(),key.getSort(),key.getFilter(),key.getFilter(),sliceSkips,-1);
      long existing=getSliceHeight(sliceKey);
      for (long cont=tohave - existing; cont > 0; cont--) {
        DBCursor cursor=dbsDAO.getCollectionDBCursor(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys());
        cursor.skip(sliceSkips);
        DBCursorPoolEntryKey newkey=new DBCursorPoolEntryKey(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys(),sliceSkips,System.nanoTime());
        cache.put(newkey,cursor);
        LOGGER.debug(""String_Node_Str"",newkey);
      }
      slice++;
    }
  }
);
}","private void populateCacheLinear(DBCursorPoolEntryKey key){
  if (key.getSkipped() < SKIP_SLICE_LINEAR_WIDTH) {
    return;
  }
  int firstSlice=key.getSkipped() / SKIP_SLICE_LINEAR_WIDTH;
  executor.submit(() -> {
    int slice=firstSlice;
    for (    int tohave : SKIP_SLICES_HEIGHTS) {
      int sliceSkips=slice * SKIP_SLICE_LINEAR_WIDTH - SKIP_SLICE_LINEAR_DELTA;
      DBCursorPoolEntryKey sliceKey=new DBCursorPoolEntryKey(key.getCollection(),key.getSort(),key.getFilter(),key.getFilter(),sliceSkips,-1);
      long existing=getSliceHeight(sliceKey);
      long tocreate=tohave - existing;
      if (tocreate > 0) {
        DBCursor cursor=dbsDAO.getCollectionDBCursor(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys());
        cursor.limit(1000 + SKIP_SLICE_LINEAR_DELTA).skip(sliceSkips);
        cursor.hasNext();
        DBCursorPoolEntryKey newkey=new DBCursorPoolEntryKey(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys(),sliceSkips,System.nanoTime());
        cache.put(newkey,cursor);
        LOGGER.debug(""String_Node_Str"",newkey);
        tocreate--;
        for (long cont=tocreate; cont > 0; cont--) {
          newkey=new DBCursorPoolEntryKey(key.getCollection(),key.getSort(),key.getFilter(),key.getKeys(),sliceSkips,System.nanoTime());
          cache.put(newkey,cursor.copy());
          LOGGER.debug(""String_Node_Str"",newkey);
        }
      }
      slice++;
    }
  }
);
}"
93501,"private void populateCache(DBCursorPoolEntryKey key,EAGER_CURSOR_ALLOCATION_POLICY allocationPolicy){
  if (allocationPolicy == EAGER_CURSOR_ALLOCATION_POLICY.LINEAR) {
    populateCacheLinear(key);
  }
 else   if (allocationPolicy == EAGER_CURSOR_ALLOCATION_POLICY.RANDOM) {
    populateCacheRandom(key);
  }
}","void populateCache(DBCursorPoolEntryKey key,EAGER_CURSOR_ALLOCATION_POLICY allocationPolicy){
  if (allocationPolicy == EAGER_CURSOR_ALLOCATION_POLICY.LINEAR) {
    populateCacheLinear(key);
  }
 else   if (allocationPolicy == EAGER_CURSOR_ALLOCATION_POLICY.RANDOM) {
    populateCacheRandom(key);
  }
}"
93502,"private DBCursorPool(DbsDAO dbsDAO){
  this.dbsDAO=dbsDAO;
  cache=CacheFactory.createLocalCache(POOL_SIZE,Cache.EXPIRE_POLICY.AFTER_READ,TTL,(  Map.Entry<DBCursorPoolEntryKey,Optional<DBCursor>> entry) -> {
    if (entry != null && entry.getValue() != null) {
      entry.getValue().ifPresent(v -> v.close());
    }
  }
);
  collSizes=CacheFactory.createLocalLoadingCache(100,org.restheart.cache.Cache.EXPIRE_POLICY.AFTER_WRITE,60 * 1000,(  DBCursorPoolEntryKey key) -> {
    return dbsDAO.getCollectionSize(key.getCollection(),key.getFilter());
  }
);
  if (LOGGER.isDebugEnabled()) {
    Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -> {
      getCacheSizes().forEach((s,c) -> {
        LOGGER.debug(""String_Node_Str"",s,c);
      }
);
      LOGGER.trace(""String_Node_Str"",cache.asMap().keySet());
    }
,1,1,TimeUnit.MINUTES);
  }
}","private DBCursorPool(DbsDAO dbsDAO){
  this.dbsDAO=dbsDAO;
  cache=CacheFactory.createLocalCache(POOL_SIZE,Cache.EXPIRE_POLICY.AFTER_READ,TTL);
  collSizes=CacheFactory.createLocalLoadingCache(100,org.restheart.cache.Cache.EXPIRE_POLICY.AFTER_WRITE,60 * 1000,(  DBCursorPoolEntryKey key) -> {
    return dbsDAO.getCollectionSize(key.getCollection(),key.getFilter());
  }
);
  if (LOGGER.isDebugEnabled()) {
    Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -> {
      getCacheSizes().forEach((s,c) -> {
        LOGGER.debug(""String_Node_Str"",s,c);
      }
);
      LOGGER.trace(""String_Node_Str"",cache.asMap().keySet());
    }
,1,1,TimeUnit.MINUTES);
  }
}"
93503,"public void getPagesLinearly() throws Exception {
  Integer _page=threadPages.get(Thread.currentThread().getId());
  if (_page == null) {
    threadPages.put(Thread.currentThread().getId(),page);
    _page=page;
  }
  String pagedUrl=url + ""String_Node_Str"" + (_page % 10000);
  _page++;
  threadPages.put(Thread.currentThread().getId(),_page);
  if (printData) {
    System.out.println(Thread.currentThread().getId() + ""String_Node_Str"" + pagedUrl);
  }
  Response resp=httpExecutor.execute(Request.Get(new URI(pagedUrl)));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
}","public void getPagesLinearly() throws Exception {
  Integer _page=threadPages.get(Thread.currentThread().getId());
  if (_page == null) {
    threadPages.put(Thread.currentThread().getId(),page);
    _page=page;
  }
  String pagedUrl=url + ""String_Node_Str"" + (_page % 10000);
  if (getEager() != null) {
    pagedUrl=pagedUrl + ""String_Node_Str"" + getEager();
  }
  _page++;
  threadPages.put(Thread.currentThread().getId(),_page);
  if (printData) {
    System.out.println(Thread.currentThread().getId() + ""String_Node_Str"" + pagedUrl);
  }
  Response resp=httpExecutor.execute(Request.Get(new URI(pagedUrl)));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
}"
93504,"/** 
 * @param context
 * @param dbName
 * @param collName
 * @param id
 * @return
 * @throws org.restheart.hal.UnsupportedDocumentIdException
 */
static public String getUriWithDocId(RequestContext context,String dbName,String collName,Object id) throws UnsupportedDocumentIdException {
  DOC_ID_TYPE docIdType=URLUtils.checkId(id);
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(id);
  if (docIdType == DOC_ID_TYPE.STRING_OID && ObjectId.isValid((String)id)) {
    sb.append(""String_Node_Str"");
  }
 else   if (docIdType != DOC_ID_TYPE.STRING_OID) {
    sb.append(""String_Node_Str"").append(docIdType.name());
  }
  return context.mapUri(sb.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
}","/** 
 * @param context
 * @param dbName
 * @param collName
 * @param id
 * @return
 * @throws org.restheart.hal.UnsupportedDocumentIdException
 */
static public String getUriWithDocId(RequestContext context,String dbName,String collName,Object id) throws UnsupportedDocumentIdException {
  DOC_ID_TYPE docIdType=URLUtils.checkId(id);
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(id);
  if (docIdType == DOC_ID_TYPE.STRING_OID && ObjectId.isValid((String)id)) {
    sb.append(""String_Node_Str"");
  }
 else   if (docIdType != DOC_ID_TYPE.STRING_OID) {
    sb.append(""String_Node_Str"").append(docIdType.name());
  }
  return context.mapUri(sb.toString());
}"
93505,"/** 
 * @param context
 * @param dbName
 * @param collName
 * @param referenceField
 * @param id
 * @return
 * @throws org.restheart.hal.UnsupportedDocumentIdException
 */
static public String getUriWithFilterOne(RequestContext context,String dbName,String collName,String referenceField,Object id) throws UnsupportedDocumentIdException {
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(referenceField).append(""String_Node_Str"").append(""String_Node_Str"").append(getIdString(id)).append(""String_Node_Str"");
  return context.mapUri(sb.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
}","/** 
 * @param context
 * @param dbName
 * @param collName
 * @param referenceField
 * @param id
 * @return
 * @throws org.restheart.hal.UnsupportedDocumentIdException
 */
static public String getUriWithFilterOne(RequestContext context,String dbName,String collName,String referenceField,Object id) throws UnsupportedDocumentIdException {
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(referenceField).append(""String_Node_Str"").append(""String_Node_Str"").append(getIdString(id)).append(""String_Node_Str"");
  return context.mapUri(sb.toString());
}"
93506,"private static String getIdsString(Object[] ids) throws UnsupportedDocumentIdException {
  if (ids == null) {
    return null;
  }
  int cont=0;
  String[] _ids=new String[ids.length];
  for (  Object id : ids) {
    _ids[cont]=getIdString(id);
    cont++;
  }
  return Arrays.toString(_ids);
}","private static String getIdsString(Object[] ids) throws UnsupportedDocumentIdException {
  if (ids == null) {
    return null;
  }
  int cont=0;
  String[] _ids=new String[ids.length];
  for (  Object id : ids) {
    _ids[cont]=getIdString(id);
    cont++;
  }
  return JsonUtils.minify(Arrays.toString(_ids));
}"
93507,"/** 
 * @param context
 * @param dbName
 * @param collName
 * @param referenceField
 * @param id
 * @return
 * @throws org.restheart.hal.UnsupportedDocumentIdException
 */
static public String getUriWithFilterManyInverse(RequestContext context,String dbName,String collName,String referenceField,Object id) throws UnsupportedDocumentIdException {
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(""String_Node_Str"").append(referenceField).append(""String_Node_Str"").append(""String_Node_Str"").append(getIdString(id)).append(""String_Node_Str"");
  return context.mapUri(sb.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
}","/** 
 * @param context
 * @param dbName
 * @param collName
 * @param referenceField
 * @param id
 * @return
 * @throws org.restheart.hal.UnsupportedDocumentIdException
 */
static public String getUriWithFilterManyInverse(RequestContext context,String dbName,String collName,String referenceField,Object id) throws UnsupportedDocumentIdException {
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(""String_Node_Str"").append(referenceField).append(""String_Node_Str"").append(""String_Node_Str"").append(getIdString(id)).append(""String_Node_Str"");
  return JsonUtils.minify(context.mapUri(sb.toString()));
}"
93508,"/** 
 * @param context
 * @param dbName
 * @param collName
 * @param ids
 * @return
 * @throws org.restheart.hal.UnsupportedDocumentIdException
 */
static public String getUriWithFilterMany(RequestContext context,String dbName,String collName,Object[] ids) throws UnsupportedDocumentIdException {
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(getIdsString(ids)).append(""String_Node_Str"");
  return context.mapUri(sb.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
}","/** 
 * @param context
 * @param dbName
 * @param collName
 * @param ids
 * @return
 * @throws org.restheart.hal.UnsupportedDocumentIdException
 */
static public String getUriWithFilterMany(RequestContext context,String dbName,String collName,Object[] ids) throws UnsupportedDocumentIdException {
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(getIdsString(ids)).append(""String_Node_Str"");
  return context.mapUri(sb.toString());
}"
93509,"private static String getIdString(Object id) throws UnsupportedDocumentIdException {
  if (id == null) {
    return null;
  }
 else {
    return serializer.serialize(id).replace(""String_Node_Str"",""String_Node_Str"");
  }
}","private static String getIdString(Object id) throws UnsupportedDocumentIdException {
  if (id == null) {
    return null;
  }
 else {
    return JsonUtils.minify(serializer.serialize(id).replace(""String_Node_Str"",""String_Node_Str""));
  }
}"
93510,"private static RepresentationTransformer getSingleFromJson(DBObject props) throws InvalidMetadataException {
  Object _phase=props.get(RT_PHASE_ELEMENT_NAME);
  Object _scope=props.get(RT_SCOPE_ELEMENT_NAME);
  Object _name=props.get(RT_NAME_ELEMENT_NAME);
  Object _args=props.get(RT_ARGS_ELEMENT_NAME);
  if (_phase == null || !(_phase instanceof String)) {
    throw new InvalidMetadataException((_phase == null ? ""String_Node_Str"" : ""String_Node_Str"") + RT_PHASE_ELEMENT_NAME + ""String_Node_Str""+ Arrays.toString(PHASE.values()));
  }
  PHASE phase;
  try {
    phase=PHASE.valueOf((String)_phase);
  }
 catch (  IllegalArgumentException iae) {
    throw new InvalidMetadataException(""String_Node_Str"" + RT_PHASE_ELEMENT_NAME + ""String_Node_Str""+ Arrays.toString(PHASE.values()));
  }
  if (_scope == null || !(_scope instanceof String)) {
    throw new InvalidMetadataException((_phase == null ? ""String_Node_Str"" : ""String_Node_Str"") + RT_SCOPE_ELEMENT_NAME + ""String_Node_Str""+ Arrays.toString(SCOPE.values()));
  }
  SCOPE scope;
  try {
    scope=SCOPE.valueOf((String)_scope);
  }
 catch (  IllegalArgumentException iae) {
    throw new InvalidMetadataException(""String_Node_Str"" + RT_SCOPE_ELEMENT_NAME + ""String_Node_Str""+ Arrays.toString(SCOPE.values()));
  }
  if (_name == null || !(_name instanceof String)) {
    throw new InvalidMetadataException((_name == null ? ""String_Node_Str"" : ""String_Node_Str"") + RT_NAME_ELEMENT_NAME + ""String_Node_Str"");
  }
  String name=(String)_name;
  DBObject args;
  if (_args == null || !(_args instanceof DBObject)) {
    args=null;
  }
 else {
    args=(DBObject)_args;
  }
  return new RepresentationTransformer(phase,scope,name,args);
}","private static RepresentationTransformer getSingleFromJson(DBObject props) throws InvalidMetadataException {
  Object _phase=props.get(RT_PHASE_ELEMENT_NAME);
  Object _scope=props.get(RT_SCOPE_ELEMENT_NAME);
  Object _name=props.get(RT_NAME_ELEMENT_NAME);
  Object _args=props.get(RT_ARGS_ELEMENT_NAME);
  if (_phase == null || !(_phase instanceof String)) {
    throw new InvalidMetadataException((_phase == null ? ""String_Node_Str"" : ""String_Node_Str"") + RT_PHASE_ELEMENT_NAME + ""String_Node_Str""+ Arrays.toString(PHASE.values()));
  }
  PHASE phase;
  try {
    phase=PHASE.valueOf((String)_phase);
  }
 catch (  IllegalArgumentException iae) {
    throw new InvalidMetadataException(""String_Node_Str"" + RT_PHASE_ELEMENT_NAME + ""String_Node_Str""+ Arrays.toString(PHASE.values()));
  }
  if (_scope == null || !(_scope instanceof String)) {
    throw new InvalidMetadataException((phase == null ? ""String_Node_Str"" : ""String_Node_Str"") + RT_SCOPE_ELEMENT_NAME + ""String_Node_Str""+ Arrays.toString(SCOPE.values()));
  }
  SCOPE scope;
  try {
    scope=SCOPE.valueOf((String)_scope);
  }
 catch (  IllegalArgumentException iae) {
    throw new InvalidMetadataException(""String_Node_Str"" + RT_SCOPE_ELEMENT_NAME + ""String_Node_Str""+ Arrays.toString(SCOPE.values()));
  }
  if (_name == null || !(_name instanceof String)) {
    throw new InvalidMetadataException((_name == null ? ""String_Node_Str"" : ""String_Node_Str"") + RT_NAME_ELEMENT_NAME + ""String_Node_Str"");
  }
  String name=(String)_name;
  DBObject args;
  if (_args == null || !(_args instanceof DBObject)) {
    args=null;
  }
 else {
    args=(DBObject)_args;
  }
  return new RepresentationTransformer(phase,scope,name,args);
}"
93511,"private void addLinkTemplatesAndCuries(final HttpServerExchange exchange,final RequestContext context,final Representation rep,final String requestPath){
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
  }
  if (TYPE.FILES_BUCKET.equals(context.getType())) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"",true));
    rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  }
 else   if (TYPE.COLLECTION.equals(context.getType())) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"",true));
    rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"" + context.getDBName()+ ""String_Node_Str""+ context.getCollectionName()+ ""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
}","private void addLinkTemplatesAndCuries(final HttpServerExchange exchange,final RequestContext context,final Representation rep,final String requestPath){
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
  }
  if (TYPE.FILES_BUCKET.equals(context.getType())) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"" + RequestContext.FS_FILES_SUFFIX,true));
    rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  }
 else   if (TYPE.COLLECTION.equals(context.getType())) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"",true));
    rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"" + context.getDBName()+ ""String_Node_Str""+ context.getCollectionName()+ ""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
}"
93512,"private void addLinkTemplatesAndCuries(final HttpServerExchange exchange,final RequestContext context,final Representation rep,final String requestPath){
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
}","private void addLinkTemplatesAndCuries(final HttpServerExchange exchange,final RequestContext context,final Representation rep,final String requestPath){
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"" + RequestContext.FS_FILES_SUFFIX,true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
}"
93513,"/** 
 * @param href
 * @param exchange
 * @param context
 * @param data
 * @return
 * @throws IllegalQueryParamenterException
 */
public Representation getRepresentation(String href,HttpServerExchange exchange,RequestContext context,DBObject data) throws IllegalQueryParamenterException {
  Representation rep;
  Object id=data.get(""String_Node_Str"");
  String _docIdType=null;
  rep=new Representation(URLUtils.getReferenceLink(context,URLUtils.getParentPath(href),id));
  rep.addProperty(""String_Node_Str"",context.getType().name());
  data.keySet().stream().forEach((key) -> rep.addProperty(key,data.get(key)));
  TreeMap<String,String> links;
  links=getRelationshipsLinks(rep,context,data);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  String requestPath=URLUtils.removeTrailingSlashes(exchange.getRequestPath());
  if (isBinaryFile(data)) {
    if (_docIdType == null) {
      rep.addLink(new Link(""String_Node_Str"",String.format(""String_Node_Str"",href,RequestContext.BINARY_CONTENT)));
    }
 else {
      rep.addLink(new Link(""String_Node_Str"",String.format(""String_Node_Str"",href,RequestContext.BINARY_CONTENT,_docIdType)));
    }
    if (context.isParentAccessible()) {
      rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
    }
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"",true));
  }
 else {
    if (context.isParentAccessible()) {
      rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
    }
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath) + ""String_Node_Str"",true));
  }
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
  return rep;
}","/** 
 * @param href
 * @param exchange
 * @param context
 * @param data
 * @return
 * @throws IllegalQueryParamenterException
 */
public Representation getRepresentation(String href,HttpServerExchange exchange,RequestContext context,DBObject data) throws IllegalQueryParamenterException {
  Representation rep;
  Object id=data.get(""String_Node_Str"");
  String _docIdType=null;
  rep=new Representation(URLUtils.getReferenceLink(context,URLUtils.getParentPath(href),id));
  rep.addProperty(""String_Node_Str"",context.getType().name());
  data.keySet().stream().forEach((key) -> rep.addProperty(key,data.get(key)));
  TreeMap<String,String> links;
  links=getRelationshipsLinks(rep,context,data);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  String requestPath=URLUtils.removeTrailingSlashes(exchange.getRequestPath());
  String parentPath;
  if (TYPE.COLLECTION.equals(context.getType()) || TYPE.FILES_BUCKET.equals(context.getType())) {
    parentPath=requestPath;
  }
 else {
    parentPath=URLUtils.getParentPath(requestPath);
  }
  if (isBinaryFile(data)) {
    if (_docIdType == null) {
      rep.addLink(new Link(""String_Node_Str"",String.format(""String_Node_Str"",href,RequestContext.BINARY_CONTENT)));
    }
 else {
      rep.addLink(new Link(""String_Node_Str"",String.format(""String_Node_Str"",href,RequestContext.BINARY_CONTENT,_docIdType)));
    }
    if (context.isParentAccessible()) {
      rep.addLink(new Link(""String_Node_Str"",parentPath));
    }
    rep.addLink(new Link(""String_Node_Str"",parentPath + ""String_Node_Str"",true));
  }
 else {
    if (context.isParentAccessible()) {
      rep.addLink(new Link(""String_Node_Str"",parentPath));
    }
    rep.addLink(new Link(""String_Node_Str"",parentPath + ""String_Node_Str"",true));
  }
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
  return rep;
}"
93514,"/** 
 * @param exchange
 * @param context
 * @param embeddedData
 * @param size
 * @throws IllegalQueryParamenterException
 */
static public void sendHal(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtils.removeTrailingSlashes(context.getMappedRequestUri());
  String queryString=exchange.getQueryString() == null || exchange.getQueryString().isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + URLUtils.decodeQueryString(exchange.getQueryString());
  Representation rep=new Representation(requestPath + queryString);
  rep.addProperty(""String_Node_Str"",context.getType().name());
  if (size >= 0) {
    rep.addProperty(""String_Node_Str"",size);
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedDocuments(embeddedData,requestPath,rep);
    }
  }
  if (context.isParentAccessible()) {
    if (context.getCollectionName().endsWith(""String_Node_Str"")) {
      rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
    }
 else {
      rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
    }
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}","/** 
 * @param exchange
 * @param context
 * @param embeddedData
 * @param size
 * @throws IllegalQueryParamenterException
 */
static public void sendHal(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtils.removeTrailingSlashes(context.getMappedRequestUri());
  String queryString=exchange.getQueryString() == null || exchange.getQueryString().isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + URLUtils.decodeQueryString(exchange.getQueryString());
  Representation rep=new Representation(requestPath + queryString);
  rep.addProperty(""String_Node_Str"",context.getType().name());
  if (size >= 0) {
    rep.addProperty(""String_Node_Str"",size);
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedDocuments(embeddedData,requestPath,rep);
    }
  }
  if (context.isParentAccessible()) {
    if (context.getCollectionName().endsWith(RequestContext.FS_FILES_SUFFIX)) {
      rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
    }
 else {
      rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
    }
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}"
93515,"private boolean checkRegex(DBObject json,String path,String regex,boolean optional,boolean nullable,RequestContext context){
  BasicDBObject _json=(BasicDBObject)json;
  List<Optional<Object>> props;
  try {
    props=JsonUtils.getPropsFromPath(_json,path);
  }
 catch (  IllegalArgumentException ex) {
    return false;
  }
  if (props == null) {
    return optional;
  }
  boolean ret;
  Pattern p=Pattern.compile(regex,Pattern.CASE_INSENSITIVE);
  ret=props.stream().allMatch((  Optional<Object> prop) -> {
    if (prop == null) {
      return optional;
    }
    if (prop.isPresent()) {
      return p.matcher(JsonUtils.serialize(prop.get())).find();
    }
 else {
      return nullable;
    }
  }
);
  LOGGER.debug(""String_Node_Str"",path,regex,props,ret);
  if (ret == false) {
    context.addWarning(""String_Node_Str"" + path + ""String_Node_Str""+ regex+ ""String_Node_Str""+ props);
  }
  return ret;
}","private boolean checkRegex(DBObject json,String path,String regex,boolean optional,boolean nullable,RequestContext context){
  BasicDBObject _json=(BasicDBObject)json;
  List<Optional<Object>> props;
  try {
    props=JsonUtils.getPropsFromPath(_json,path);
  }
 catch (  IllegalArgumentException ex) {
    LOGGER.debug(""String_Node_Str"",path,regex,ex.getMessage());
    context.addWarning(""String_Node_Str"" + path + ""String_Node_Str""+ regex+ ""String_Node_Str""+ ex.getMessage());
    return false;
  }
  boolean ret;
  if (props == null) {
    ret=optional;
  }
 else {
    Pattern p=Pattern.compile(regex,Pattern.CASE_INSENSITIVE);
    ret=props.stream().allMatch((    Optional<Object> prop) -> {
      if (prop == null) {
        return optional;
      }
      if (prop.isPresent()) {
        return p.matcher(JsonUtils.serialize(prop.get())).find();
      }
 else {
        return nullable;
      }
    }
);
  }
  LOGGER.debug(""String_Node_Str"",path,regex,props,ret);
  if (ret == false) {
    context.addWarning(""String_Node_Str"" + path + ""String_Node_Str""+ regex+ ""String_Node_Str""+ props);
  }
  return ret;
}"
93516,"private BasicDBList filterMissingOptionalAndNullNullableConditions(BasicDBList conditions,DBObject content){
  Set<String> nullPaths=new HashSet<>();
  BasicDBList ret=new BasicDBList();
  conditions.stream().forEach((  Object condition) -> {
    if (condition instanceof BasicDBObject) {
      Boolean nullable=false;
      Object _nullable=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_nullable != null && _nullable instanceof Boolean) {
        nullable=(Boolean)_nullable;
      }
      Boolean optional=false;
      Object _optional=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_optional != null && _optional instanceof Boolean) {
        optional=(Boolean)_optional;
      }
      if (nullable) {
        Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
        if (_path != null && _path instanceof String) {
          String path=(String)_path;
          List<Optional<Object>> props;
          try {
            props=JsonUtils.getPropsFromPath(content,path);
            if (props != null && props.stream().allMatch((            Optional<Object> prop) -> {
              return prop != null && !prop.isPresent();
            }
)) {
              nullPaths.add(path);
            }
          }
 catch (          IllegalArgumentException ex) {
            nullPaths.add(path);
          }
        }
      }
      if (optional) {
        Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
        if (_path != null && _path instanceof String) {
          String path=(String)_path;
          List<Optional<Object>> props;
          try {
            props=JsonUtils.getPropsFromPath(content,path);
            if (props == null || props.stream().allMatch((            Optional<Object> prop) -> {
              return prop == null;
            }
)) {
              nullPaths.add(path);
            }
          }
 catch (          IllegalArgumentException ex) {
            nullPaths.add(path);
          }
        }
      }
    }
  }
);
  conditions.stream().forEach(condition -> {
    if (condition instanceof BasicDBObject) {
      Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_path != null && _path instanceof String) {
        String path=(String)_path;
        boolean hasNullParent=nullPaths.stream().anyMatch(nullPath -> {
          return JsonUtils.isAncestorPath(nullPath,path);
        }
);
        if (!hasNullParent) {
          ret.add(condition);
        }
      }
    }
  }
);
  return ret;
}","private BasicDBList filterMissingOptionalAndNullNullableConditions(BasicDBList conditions,DBObject content,boolean patching){
  Set<String> nullPaths=new HashSet<>();
  BasicDBList ret=new BasicDBList();
  conditions.stream().forEach((  Object condition) -> {
    if (condition instanceof BasicDBObject) {
      Boolean nullable=false;
      Object _nullable=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_nullable != null && _nullable instanceof Boolean) {
        nullable=(Boolean)_nullable;
      }
      Boolean optional=false;
      Object _optional=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_optional != null && _optional instanceof Boolean) {
        optional=(Boolean)_optional;
      }
      if (nullable) {
        Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
        if (_path != null && _path instanceof String) {
          String path=(String)_path;
          List<Optional<Object>> props;
          try {
            props=JsonUtils.getPropsFromPath(content,path);
            if (props != null && props.stream().allMatch((            Optional<Object> prop) -> {
              return prop != null && !prop.isPresent();
            }
)) {
              nullPaths.add(path);
            }
          }
 catch (          IllegalArgumentException ex) {
            nullPaths.add(path);
          }
        }
      }
      if (optional || patching) {
        Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
        if (_path != null && _path instanceof String) {
          String path=(String)_path;
          List<Optional<Object>> props;
          try {
            props=JsonUtils.getPropsFromPath(content,path);
            if (props == null || props.stream().allMatch((            Optional<Object> prop) -> {
              return prop == null;
            }
)) {
              nullPaths.add(path);
            }
          }
 catch (          IllegalArgumentException ex) {
            nullPaths.add(path);
          }
        }
      }
    }
  }
);
  conditions.stream().forEach(condition -> {
    if (condition instanceof BasicDBObject) {
      Object _path=((BasicDBObject)condition).get(""String_Node_Str"");
      if (_path != null && _path instanceof String) {
        String path=(String)_path;
        boolean hasNullParent=nullPaths.stream().anyMatch(nullPath -> {
          return JsonUtils.isAncestorPath(nullPath,path);
        }
);
        if (!hasNullParent) {
          ret.add(condition);
        }
      }
    }
  }
);
  return ret;
}"
93517,"@Override public boolean check(HttpServerExchange exchange,RequestContext context,DBObject args){
  if (args instanceof BasicDBList) {
    boolean patching=context.getMethod() == RequestContext.METHOD.PATCH;
    BasicDBList conditions=filterMissingOptionalAndNullNullableConditions((BasicDBList)args,context.getContent());
    if (patching) {
      DBObject content=context.getContent();
      return !content.keySet().stream().anyMatch(key -> {
        return !applyConditions(conditions,remapJson(key,content.get(key)),context);
      }
);
    }
 else {
      return applyConditions(conditions,context.getContent(),context);
    }
  }
 else {
    context.addWarning(""String_Node_Str"");
    return true;
  }
}","@Override public boolean check(HttpServerExchange exchange,RequestContext context,DBObject args){
  if (args instanceof BasicDBList) {
    boolean patching=context.getMethod() == RequestContext.METHOD.PATCH;
    if (patching) {
      DBObject content=context.getContent();
      return !content.keySet().stream().anyMatch(key -> {
        DBObject remappedContent=remapJson(key,content.get(key));
        BasicDBList conditions=filterMissingOptionalAndNullNullableConditions((BasicDBList)args,remappedContent,true);
        return !applyConditions(conditions,remappedContent,context);
      }
);
    }
 else {
      BasicDBList conditions=filterMissingOptionalAndNullNullableConditions((BasicDBList)args,context.getContent(),false);
      return applyConditions(conditions,context.getContent(),context);
    }
  }
 else {
    context.addWarning(""String_Node_Str"");
    return true;
  }
}"
93518,"/** 
 * @param left the json path expression
 * @param right the json path expression
 * @return true if the left json path is an acestor of the right path, i.e.left path selects a values set that includes the one selected by the right path examples: ($, $.a) -> true, ($.a, $.b) -> false, ($.*, $.a) -> true, ($.a.[*].c, $.a.0.c) -> true, ($.a.[*], $.a.b) -> false
 */
public static boolean isAncestorPath(final String left,final String right){
  if (left == null || !left.startsWith(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"" + left);
  }
  if (right == null || !right.startsWith(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"" + right);
  }
  if (right.startsWith(left)) {
    return true;
  }
 else {
    String leftPathTokens[]=left.split(Pattern.quote(""String_Node_Str""));
    String rightPathTokens[]=right.split(Pattern.quote(""String_Node_Str""));
    if (leftPathTokens.length > rightPathTokens.length) {
      return false;
    }
    for (int cont=0; cont < leftPathTokens.length; cont++) {
      String lt=leftPathTokens[cont];
      String rt=rightPathTokens[cont];
switch (lt) {
case ""String_Node_Str"":
        break;
case ""String_Node_Str"":
      try {
        Integer.parseInt(rt);
        break;
      }
 catch (      NumberFormatException nfe) {
        return false;
      }
default :
    return rt.equals(lt);
}
}
}
return true;
}","/** 
 * @param left the json path expression
 * @param right the json path expression
 * @return true if the left json path is an acestor of the right path, i.e.left path selects a values set that includes the one selected by the right path examples: ($, $.a) -> true, ($.a, $.b) -> false, ($.*, $.a) -> true, ($.a.[*].c, $.a.0.c) -> true, ($.a.[*], $.a.b) -> false
 */
public static boolean isAncestorPath(final String left,final String right){
  if (left == null || !left.startsWith(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"" + left);
  }
  if (right == null || !right.startsWith(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"" + right);
  }
  boolean ret=true;
  if (!right.startsWith(left)) {
    String leftPathTokens[]=left.split(Pattern.quote(""String_Node_Str""));
    String rightPathTokens[]=right.split(Pattern.quote(""String_Node_Str""));
    if (leftPathTokens.length > rightPathTokens.length) {
      ret=false;
    }
 else {
      outerloop:       for (int cont=0; cont < leftPathTokens.length; cont++) {
        String lt=leftPathTokens[cont];
        String rt=rightPathTokens[cont];
switch (lt) {
case ""String_Node_Str"":
          break;
case ""String_Node_Str"":
        try {
          Integer.parseInt(rt);
          break;
        }
 catch (        NumberFormatException nfe) {
          ret=false;
          break outerloop;
        }
default :
      ret=rt.equals(lt);
    if (!ret) {
      break outerloop;
    }
 else {
      break;
    }
}
}
}
}
LOGGER.debug(""String_Node_Str"",left,right,ret);
return ret;
}"
93519,"ArrayList<DBObject> getCollectionData(DBCollection coll,int page,int pagesize,Deque<String> sortBy,Deque<String> filters,Deque<String> keys,DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY eager) throws JSONParseException {
  ArrayList<DBObject> ret=new ArrayList<>();
  int toskip=pagesize * (page - 1);
  DBCursor cursor;
  SkippedDBCursor _cursor=null;
  if (eager != DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY.NONE) {
    _cursor=DBCursorPool.getInstance().get(new DBCursorPoolEntryKey(coll,sortBy,filters,keys,toskip,0),eager);
  }
  int alreadySkipped;
  if (_cursor == null) {
    cursor=getCollectionDBCursor(coll,sortBy,filters,keys);
    alreadySkipped=0;
  }
 else {
    cursor=_cursor.getCursor();
    alreadySkipped=_cursor.getAlreadySkipped();
  }
  if (toskip - alreadySkipped > 0) {
    cursor.skip(toskip - alreadySkipped);
  }
  while (pagesize > 0 && cursor.hasNext()) {
    ret.add(cursor.next());
    pagesize--;
  }
  ret.forEach(row -> {
    Object etag=row.get(""String_Node_Str"");
    if (row.get(""String_Node_Str"") == null && etag != null && etag instanceof ObjectId) {
      row.put(""String_Node_Str"",Instant.ofEpochSecond(((ObjectId)etag).getTimestamp()).toString());
    }
    Object id=row.get(""String_Node_Str"");
    if (row.get(""String_Node_Str"") == null && id != null && id instanceof ObjectId) {
      row.put(""String_Node_Str"",Instant.ofEpochSecond(((ObjectId)id).getTimestamp()).toString());
    }
  }
);
  return ret;
}","ArrayList<DBObject> getCollectionData(DBCollection coll,int page,int pagesize,Deque<String> sortBy,Deque<String> filters,Deque<String> keys,DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY eager) throws JSONParseException {
  ArrayList<DBObject> ret=new ArrayList<>();
  int toskip=pagesize * (page - 1);
  DBCursor cursor;
  SkippedDBCursor _cursor=null;
  if (eager != DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY.NONE) {
    _cursor=DBCursorPool.getInstance().get(new DBCursorPoolEntryKey(coll,sortBy,filters,keys,toskip,0),eager);
  }
  int alreadySkipped;
  if (_cursor == null) {
    cursor=getCollectionDBCursor(coll,sortBy,filters,keys);
    alreadySkipped=0;
  }
 else {
    cursor=_cursor.getCursor();
    alreadySkipped=_cursor.getAlreadySkipped();
  }
  while (toskip > alreadySkipped) {
    cursor.next();
    alreadySkipped++;
  }
  while (pagesize > 0 && cursor.hasNext()) {
    ret.add(cursor.next());
    pagesize--;
  }
  ret.forEach(row -> {
    Object etag=row.get(""String_Node_Str"");
    if (row.get(""String_Node_Str"") == null && etag != null && etag instanceof ObjectId) {
      row.put(""String_Node_Str"",Instant.ofEpochSecond(((ObjectId)etag).getTimestamp()).toString());
    }
    Object id=row.get(""String_Node_Str"");
    if (row.get(""String_Node_Str"") == null && id != null && id instanceof ObjectId) {
      row.put(""String_Node_Str"",Instant.ofEpochSecond(((ObjectId)id).getTimestamp()).toString());
    }
  }
);
  return ret;
}"
93520,"public synchronized SkippedDBCursor get(DBCursorPoolEntryKey key,EAGER_CURSOR_ALLOCATION_POLICY allocationPolicy){
  if (key.getSkipped() < SKIP_SLICE_LINEAR_WIDTH) {
    LOGGER.trace(""String_Node_Str"",key.getSkipped(),SKIP_SLICE_LINEAR_WIDTH);
    return null;
  }
  Optional<DBCursorPoolEntryKey> _bestKey=cache.asMap().keySet().stream().filter(cursorsPoolFilterGt(key)).sorted(Comparator.comparingInt(DBCursorPoolEntryKey::getSkipped).reversed()).findFirst();
  SkippedDBCursor ret;
  if (_bestKey.isPresent()) {
    Optional<DBCursor> _dbcur=cache.get(_bestKey.get());
    if (_dbcur != null && _dbcur.isPresent()) {
      ret=new SkippedDBCursor(_dbcur.get(),_bestKey.get().getSkipped());
      cache.invalidate(_bestKey.get());
      LOGGER.debug(""String_Node_Str"",key.getSkipped(),_bestKey.get().getSkipped());
    }
 else {
      ret=null;
      LOGGER.debug(""String_Node_Str"",key.getSkipped());
    }
  }
 else {
    ret=null;
    LOGGER.debug(""String_Node_Str"",key.getSkipped());
  }
  populateCache(key,allocationPolicy);
  return ret;
}","public synchronized SkippedDBCursor get(DBCursorPoolEntryKey key,EAGER_CURSOR_ALLOCATION_POLICY allocationPolicy){
  if (key.getSkipped() < SKIP_SLICE_LINEAR_WIDTH) {
    LOGGER.trace(""String_Node_Str"",key.getSkipped(),SKIP_SLICE_LINEAR_WIDTH);
    return null;
  }
  Optional<DBCursorPoolEntryKey> _bestKey=cache.asMap().keySet().stream().filter(cursorsPoolFilterGte(key)).sorted(Comparator.comparingInt(DBCursorPoolEntryKey::getSkipped).reversed()).findFirst();
  SkippedDBCursor ret;
  if (_bestKey.isPresent()) {
    Optional<DBCursor> _dbcur=cache.get(_bestKey.get());
    if (_dbcur != null && _dbcur.isPresent()) {
      ret=new SkippedDBCursor(_dbcur.get(),_bestKey.get().getSkipped());
      cache.invalidate(_bestKey.get());
      LOGGER.debug(""String_Node_Str"",key.getSkipped(),_bestKey.get().getSkipped());
    }
 else {
      ret=null;
      LOGGER.debug(""String_Node_Str"",key.getSkipped());
    }
  }
 else {
    ret=null;
    LOGGER.debug(""String_Node_Str"",key.getSkipped());
  }
  populateCache(key,allocationPolicy);
  return ret;
}"
93521,"@Override public void tranform(final HttpServerExchange exchange,final RequestContext context,DBObject contentToTransform,final DBObject args){
  LOGGER.info(""String_Node_Str"" + ExchangeAttributes.remoteUser().readAttribute(exchange));
  contentToTransform.put(""String_Node_Str"",ExchangeAttributes.remoteUser().readAttribute(exchange));
}","@Override public void tranform(final HttpServerExchange exchange,final RequestContext context,DBObject contentToTransform,final DBObject args){
  LOGGER.info(""String_Node_Str"" + args);
  contentToTransform.putAll(args);
}"
93522,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(RepresentationTransformer.RTS_ELEMENT_NAME)) {
    try {
      RepresentationTransformer.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(SchemaCheckerMetadata.SC_ELEMENT_NAME)) {
    try {
      SchemaCheckerMetadata.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int httpCode=getDatabase().upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(RepresentationTransformer.RTS_ELEMENT_NAME)) {
    try {
      RepresentationTransformer.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(SchemaChecker.SC_ELEMENT_NAME)) {
    try {
      SchemaChecker.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int httpCode=getDatabase().upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93523,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(UNDERSCORE)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    content=new BasicDBObject();
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(RepresentationTransformer.RTS_ELEMENT_NAME)) {
    try {
      RepresentationTransformer.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(SchemaCheckerMetadata.SC_ELEMENT_NAME)) {
    try {
      SchemaCheckerMetadata.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  boolean updating=context.getCollectionProps() != null;
  int httpCode=getDatabase().upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,updating,false);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(UNDERSCORE)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    content=new BasicDBObject();
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(RepresentationTransformer.RTS_ELEMENT_NAME)) {
    try {
      RepresentationTransformer.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  if (content.containsField(SchemaChecker.SC_ELEMENT_NAME)) {
    try {
      SchemaChecker.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  boolean updating=context.getCollectionProps() != null;
  int httpCode=getDatabase().upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,updating,false);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93524,"@Override void enforceCollRepresentationTransformLogic(HttpServerExchange exchange,RequestContext context) throws InvalidMetadataException, ScriptException {
  List<RepresentationTransformer> dbRts=RepresentationTransformer.getFromJson(context.getCollectionProps());
  RequestContext.TYPE requestType=context.getType();
  for (  RepresentationTransformer rt : dbRts) {
    if (rt.getPhase() == RepresentationTransformer.PHASE.REQUEST) {
      Transformer t=(Transformer)NamedSingletonsFactory.getInstance().get(""String_Node_Str"",rt.getName());
      if (t == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + rt.getName() + ""String_Node_Str"");
      }
      if (rt.getScope() == RepresentationTransformer.SCOPE.THIS && requestType == RequestContext.TYPE.COLLECTION) {
        t.tranform(exchange,context,context.getContent(),rt.getArgs());
      }
 else       if (rt.getScope() == RepresentationTransformer.SCOPE.CHILDREN && requestType == RequestContext.TYPE.DOCUMENT) {
        t.tranform(exchange,context,context.getContent(),rt.getArgs());
      }
    }
  }
}","@Override void enforceCollRepresentationTransformLogic(HttpServerExchange exchange,RequestContext context) throws InvalidMetadataException {
  List<RepresentationTransformer> dbRts=RepresentationTransformer.getFromJson(context.getCollectionProps());
  RequestContext.TYPE requestType=context.getType();
  for (  RepresentationTransformer rt : dbRts) {
    if (rt.getPhase() == RepresentationTransformer.PHASE.REQUEST) {
      Transformer t=(Transformer)NamedSingletonsFactory.getInstance().get(""String_Node_Str"",rt.getName());
      if (t == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + rt.getName() + ""String_Node_Str"");
      }
      if (rt.getScope() == RepresentationTransformer.SCOPE.THIS && requestType == RequestContext.TYPE.COLLECTION) {
        t.tranform(exchange,context,context.getContent(),rt.getArgs());
      }
 else       if (rt.getScope() == RepresentationTransformer.SCOPE.CHILDREN && requestType == RequestContext.TYPE.DOCUMENT) {
        t.tranform(exchange,context,context.getContent(),rt.getArgs());
      }
    }
  }
}"
93525,"@Override void enforceDbRepresentationTransformLogic(HttpServerExchange exchange,RequestContext context) throws InvalidMetadataException, ScriptException {
  List<RepresentationTransformer> dbRts=RepresentationTransformer.getFromJson(context.getDbProps());
  RequestContext.TYPE requestType=context.getType();
  for (  RepresentationTransformer rt : dbRts) {
    Transformer t=(Transformer)NamedSingletonsFactory.getInstance().get(""String_Node_Str"",rt.getName());
    if (t == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + rt.getName() + ""String_Node_Str"");
    }
    if (rt.getPhase() == RepresentationTransformer.PHASE.REQUEST) {
      if (rt.getScope() == RepresentationTransformer.SCOPE.THIS && requestType == RequestContext.TYPE.DB) {
        t.tranform(exchange,context,context.getContent(),rt.getArgs());
      }
 else       if (rt.getScope() == RepresentationTransformer.SCOPE.CHILDREN && requestType == RequestContext.TYPE.COLLECTION) {
        t.tranform(exchange,context,context.getContent(),rt.getArgs());
      }
    }
  }
}","@Override void enforceDbRepresentationTransformLogic(HttpServerExchange exchange,RequestContext context) throws InvalidMetadataException {
  List<RepresentationTransformer> dbRts=RepresentationTransformer.getFromJson(context.getDbProps());
  RequestContext.TYPE requestType=context.getType();
  for (  RepresentationTransformer rt : dbRts) {
    Transformer t=(Transformer)NamedSingletonsFactory.getInstance().get(""String_Node_Str"",rt.getName());
    if (t == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + rt.getName() + ""String_Node_Str"");
    }
    if (rt.getPhase() == RepresentationTransformer.PHASE.REQUEST) {
      if (rt.getScope() == RepresentationTransformer.SCOPE.THIS && requestType == RequestContext.TYPE.DB) {
        t.tranform(exchange,context,context.getContent(),rt.getArgs());
      }
 else {
        t.tranform(exchange,context,context.getContent(),rt.getArgs());
      }
    }
  }
}"
93526,"private static void startCoreSystem(){
  if (configuration == null) {
    LOGGER.error(""String_Node_Str"");
    stopServer(false);
    System.exit(-1);
  }
  if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
    LOGGER.error(""String_Node_Str"");
    stopServer(false);
    System.exit(-1);
  }
  IdentityManager identityManager=null;
  if (configuration.getIdmImpl() == null) {
    LOGGER.warn(""String_Node_Str"");
    identityManager=null;
  }
 else {
    try {
      Object idm=Class.forName(configuration.getIdmImpl()).getConstructor(Map.class).newInstance(configuration.getIdmArgs());
      identityManager=(IdentityManager)idm;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      LOGGER.error(""String_Node_Str"",configuration.getIdmImpl(),ex);
      stopServer(false);
      System.exit(-3);
    }
  }
  AccessManager accessManager=null;
  if (configuration.getAmImpl() == null && configuration.getIdmImpl() != null) {
    LOGGER.warn(""String_Node_Str"");
    accessManager=new FullAccessManager();
  }
 else   if (configuration.getAmImpl() == null && configuration.getIdmImpl() == null) {
    LOGGER.warn(""String_Node_Str"");
    accessManager=new FullAccessManager();
  }
 else {
    try {
      Object am=Class.forName(configuration.getAmImpl()).getConstructor(Map.class).newInstance(configuration.getAmArgs());
      accessManager=(AccessManager)am;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      LOGGER.error(""String_Node_Str"",configuration.getAmImpl(),ex);
      stopServer(false);
      System.exit(-3);
    }
  }
  if (configuration.isAuthTokenEnabled()) {
    LOGGER.info(""String_Node_Str"",configuration.getAuthTokenTtl());
  }
  SSLContext sslContext=null;
  try {
    KeyManagerFactory kmf;
    KeyStore ks;
    if (getConfiguration().isUseEmbeddedKeystore()) {
      char[] storepass=""String_Node_Str"".toCharArray();
      char[] keypass=""String_Node_Str"".toCharArray();
      String storename=""String_Node_Str"";
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename),storepass);
      kmf.init(ks,keypass);
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
 else {
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      try (FileInputStream fis=new FileInputStream(new File(configuration.getKeystoreFile()))){
        ks.load(fis,configuration.getKeystorePassword().toCharArray());
        kmf.init(ks,configuration.getCertPassword().toCharArray());
        sslContext.init(kmf.getKeyManagers(),null,null);
      }
     }
  }
 catch (  KeyManagementException|NoSuchAlgorithmException|KeyStoreException|CertificateException|UnrecoverableKeyException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer(false);
    System.exit(-1);
  }
catch (  FileNotFoundException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer(false);
    System.exit(-1);
  }
catch (  IOException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer(false);
    System.exit(-1);
  }
  Builder builder=Undertow.builder();
  if (configuration.isHttpsListener()) {
    builder.addHttpsListener(configuration.getHttpsPort(),configuration.getHttpHost(),sslContext);
    LOGGER.info(""String_Node_Str"",configuration.getHttpsHost(),configuration.getHttpsPort());
  }
  if (configuration.isHttpListener()) {
    builder.addHttpListener(configuration.getHttpPort(),configuration.getHttpsHost());
    LOGGER.info(""String_Node_Str"",configuration.getHttpHost(),configuration.getHttpPort());
  }
  if (configuration.isAjpListener()) {
    builder.addAjpListener(configuration.getAjpPort(),configuration.getAjpHost());
    LOGGER.info(""String_Node_Str"",configuration.getAjpHost(),configuration.getAjpPort());
  }
  LocalCachesSingleton.init(configuration);
  if (configuration.isLocalCacheEnabled()) {
    LOGGER.info(""String_Node_Str"");
  }
 else {
    LOGGER.info(""String_Node_Str"");
  }
  shutdownHandler=getHandlersPipe(identityManager,accessManager);
  builder.setIoThreads(configuration.getIoThreads()).setWorkerThreads(configuration.getWorkerThreads()).setDirectBuffers(configuration.isDirectBuffers()).setBufferSize(configuration.getBufferSize()).setBuffersPerRegion(configuration.getBuffersPerRegion()).setHandler(shutdownHandler);
  builder.build().start();
}","private static void startCoreSystem(){
  if (configuration == null) {
    LOGGER.error(""String_Node_Str"");
    stopServer(false);
    System.exit(-1);
  }
  if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
    LOGGER.error(""String_Node_Str"");
    stopServer(false);
    System.exit(-1);
  }
  IdentityManager identityManager=null;
  if (configuration.getIdmImpl() == null) {
    LOGGER.warn(""String_Node_Str"");
    identityManager=null;
  }
 else {
    try {
      Object idm=Class.forName(configuration.getIdmImpl()).getConstructor(Map.class).newInstance(configuration.getIdmArgs());
      identityManager=(IdentityManager)idm;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      LOGGER.error(""String_Node_Str"",configuration.getIdmImpl(),ex);
      stopServer(false);
      System.exit(-3);
    }
  }
  AccessManager accessManager=null;
  if (configuration.getAmImpl() == null && configuration.getIdmImpl() != null) {
    LOGGER.warn(""String_Node_Str"");
    accessManager=new FullAccessManager();
  }
 else   if (configuration.getAmImpl() == null && configuration.getIdmImpl() == null) {
    LOGGER.warn(""String_Node_Str"");
    accessManager=new FullAccessManager();
  }
 else {
    try {
      Object am=Class.forName(configuration.getAmImpl()).getConstructor(Map.class).newInstance(configuration.getAmArgs());
      accessManager=(AccessManager)am;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      LOGGER.error(""String_Node_Str"",configuration.getAmImpl(),ex);
      stopServer(false);
      System.exit(-3);
    }
  }
  if (configuration.isAuthTokenEnabled()) {
    LOGGER.info(""String_Node_Str"",configuration.getAuthTokenTtl());
  }
  SSLContext sslContext=null;
  try {
    KeyManagerFactory kmf;
    KeyStore ks;
    if (getConfiguration().isUseEmbeddedKeystore()) {
      char[] storepass=""String_Node_Str"".toCharArray();
      char[] keypass=""String_Node_Str"".toCharArray();
      String storename=""String_Node_Str"";
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
      ks=KeyStore.getInstance(""String_Node_Str"");
      ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename),storepass);
      kmf.init(ks,keypass);
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
 else {
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
      ks=KeyStore.getInstance(""String_Node_Str"");
      try (FileInputStream fis=new FileInputStream(new File(configuration.getKeystoreFile()))){
        ks.load(fis,configuration.getKeystorePassword().toCharArray());
        kmf.init(ks,configuration.getCertPassword().toCharArray());
        sslContext.init(kmf.getKeyManagers(),null,null);
      }
     }
  }
 catch (  KeyManagementException|NoSuchAlgorithmException|KeyStoreException|CertificateException|UnrecoverableKeyException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer(false);
    System.exit(-1);
  }
catch (  FileNotFoundException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer(false);
    System.exit(-1);
  }
catch (  IOException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer(false);
    System.exit(-1);
  }
  Builder builder=Undertow.builder();
  if (configuration.isHttpsListener()) {
    builder.addHttpsListener(configuration.getHttpsPort(),configuration.getHttpHost(),sslContext);
    LOGGER.info(""String_Node_Str"",configuration.getHttpsHost(),configuration.getHttpsPort());
  }
  if (configuration.isHttpListener()) {
    builder.addHttpListener(configuration.getHttpPort(),configuration.getHttpsHost());
    LOGGER.info(""String_Node_Str"",configuration.getHttpHost(),configuration.getHttpPort());
  }
  if (configuration.isAjpListener()) {
    builder.addAjpListener(configuration.getAjpPort(),configuration.getAjpHost());
    LOGGER.info(""String_Node_Str"",configuration.getAjpHost(),configuration.getAjpPort());
  }
  LocalCachesSingleton.init(configuration);
  if (configuration.isLocalCacheEnabled()) {
    LOGGER.info(""String_Node_Str"");
  }
 else {
    LOGGER.info(""String_Node_Str"");
  }
  shutdownHandler=getHandlersPipe(identityManager,accessManager);
  builder.setIoThreads(configuration.getIoThreads()).setWorkerThreads(configuration.getWorkerThreads()).setDirectBuffers(configuration.isDirectBuffers()).setBufferSize(configuration.getBufferSize()).setBuffersPerRegion(configuration.getBuffersPerRegion()).setHandler(shutdownHandler);
  builder.build().start();
}"
93527,"private void setup() throws UnknownHostException {
  if (isInitialized()) {
    List<ServerAddress> servers=new ArrayList<>();
    List<MongoCredential> credentials=new ArrayList<>();
    for (    Map<String,Object> mongoServer : mongoServers) {
      Object mongoHost=mongoServer.get(Configuration.MONGO_HOST_KEY);
      Object mongoPort=mongoServer.get(Configuration.MONGO_PORT_KEY);
      if (mongoHost != null && mongoHost instanceof String && mongoPort != null && mongoPort instanceof Integer) {
        servers.add(new ServerAddress((String)mongoHost,(int)mongoPort));
      }
    }
    if (mongoCredentials != null) {
      mongoCredentials.stream().forEach((mongoCredential) -> {
        Object mongoAuthDb=mongoCredential.get(Configuration.MONGO_AUTH_DB_KEY);
        Object mongoUser=mongoCredential.get(Configuration.MONGO_USER_KEY);
        Object mongoPwd=mongoCredential.get(Configuration.MONGO_PASSWORD_KEY);
        if (mongoAuthDb != null && mongoAuthDb instanceof String && mongoUser != null && mongoUser instanceof String && mongoPwd != null && mongoPwd instanceof String) {
          credentials.add(MongoCredential.createMongoCRCredential((String)mongoUser,(String)mongoAuthDb,((String)mongoPwd).toCharArray()));
        }
      }
);
    }
    MongoClientOptions opts=MongoClientOptions.builder().readPreference(ReadPreference.primaryPreferred()).writeConcern(WriteConcern.ACKNOWLEDGED).build();
    mongoClient=new MongoClient(servers,credentials,opts);
  }
}","private void setup() throws UnknownHostException {
  if (isInitialized()) {
    List<ServerAddress> servers=new ArrayList<>();
    List<MongoCredential> credentials=new ArrayList<>();
    for (    Map<String,Object> mongoServer : mongoServers) {
      Object mongoHost=mongoServer.get(Configuration.MONGO_HOST_KEY);
      Object mongoPort=mongoServer.get(Configuration.MONGO_PORT_KEY);
      if (mongoHost != null && mongoHost instanceof String && mongoPort != null && mongoPort instanceof Integer) {
        servers.add(new ServerAddress((String)mongoHost,(int)mongoPort));
      }
    }
    if (mongoCredentials != null) {
      mongoCredentials.stream().forEach((mongoCredential) -> {
        Object mongoAuthDb=mongoCredential.get(Configuration.MONGO_AUTH_DB_KEY);
        Object mongoUser=mongoCredential.get(Configuration.MONGO_USER_KEY);
        Object mongoPwd=mongoCredential.get(Configuration.MONGO_PASSWORD_KEY);
        if (mongoAuthDb != null && mongoAuthDb instanceof String && mongoUser != null && mongoUser instanceof String && mongoPwd != null && mongoPwd instanceof String) {
          credentials.add(MongoCredential.createCredential((String)mongoUser,(String)mongoAuthDb,((String)mongoPwd).toCharArray()));
        }
      }
);
    }
    MongoClientOptions opts=MongoClientOptions.builder().readPreference(ReadPreference.primaryPreferred()).writeConcern(WriteConcern.ACKNOWLEDGED).build();
    mongoClient=new MongoClient(servers,credentials,opts);
  }
}"
93528,"private static PipedHttpHandler getSecurityHandlerChain(final PipedHttpHandler next,final IdentityManager identityManager,final AccessManager accessManager,final boolean challenging){
  PipedHttpHandler handler=null;
  if (identityManager != null) {
    final List<AuthenticationMechanism> mechanisms=new ArrayList<>();
    mechanisms.add(new AuthTokenAuthenticationMechanism(RESTHEART_REALM));
    if (challenging) {
      mechanisms.add(new BasicAuthenticationMechanism(RESTHEART_REALM));
    }
 else {
      mechanisms.add(new SilentBasicAuthenticationMechanism(RESTHEART_REALM));
    }
    handler=buildSecurityHandlerChain(next,accessManager,identityManager,mechanisms);
  }
  return handler;
}","private static PipedHttpHandler getSecurityHandlerChain(final PipedHttpHandler next,final IdentityManager identityManager,final AccessManager accessManager,final boolean challenging){
  if (identityManager != null) {
    final List<AuthenticationMechanism> mechanisms=new ArrayList<>();
    mechanisms.add(new AuthTokenAuthenticationMechanism(RESTHEART_REALM));
    if (challenging) {
      mechanisms.add(new BasicAuthenticationMechanism(RESTHEART_REALM));
    }
 else {
      mechanisms.add(new SilentBasicAuthenticationMechanism(RESTHEART_REALM));
    }
    return buildSecurityHandlerChain(next,accessManager,identityManager,mechanisms);
  }
 else {
    return next;
  }
}"
93529,"private static HttpHandler getSecurityHandlerChain(final IdentityManager identityManager,final AccessManager accessManager){
  HttpHandler handler=null;
  if (identityManager != null) {
    final List<AuthenticationMechanism> mechanisms=new ArrayList<>();
    mechanisms.add(new AuthTokenAuthenticationMechanism(RESTHEART_REALM));
    mechanisms.add(new BasicAuthenticationMechanism(RESTHEART_REALM));
    handler=buildSecurityHandlerChain(accessManager,identityManager,mechanisms);
  }
  return handler;
}","private static PipedHttpHandler getSecurityHandlerChain(final PipedHttpHandler next,final IdentityManager identityManager,final AccessManager accessManager){
  PipedHttpHandler handler=null;
  if (identityManager != null) {
    final List<AuthenticationMechanism> mechanisms=new ArrayList<>();
    mechanisms.add(new AuthTokenAuthenticationMechanism(RESTHEART_REALM));
    mechanisms.add(new BasicAuthenticationMechanism(RESTHEART_REALM));
    handler=buildSecurityHandlerChain(next,accessManager,identityManager,mechanisms);
  }
  return handler;
}"
93530,"/** 
 * @param next
 * @param identityManager
 * @param accessManager
 */
public ChallengingSecurityHandler(final PipedHttpHandler next,final IdentityManager identityManager,final AccessManager accessManager){
  super(next,getSecurityHandlerChain(identityManager,accessManager));
}","/** 
 * @param next
 * @param identityManager
 * @param accessManager
 */
public ChallengingSecurityHandler(final PipedHttpHandler next,final IdentityManager identityManager,final AccessManager accessManager){
  super(getSecurityHandlerChain(next,identityManager,accessManager));
}"
93531,"private static void startCoreSystem(){
  if (configuration == null) {
    LOGGER.error(""String_Node_Str"");
    stopServer();
    System.exit(-1);
  }
  if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
    LOGGER.error(""String_Node_Str"");
    stopServer();
    System.exit(-1);
  }
  IdentityManager identityManager=null;
  if (configuration.getIdmImpl() == null) {
    LOGGER.warn(""String_Node_Str"");
    identityManager=null;
  }
 else {
    try {
      Object idm=Class.forName(configuration.getIdmImpl()).getConstructor(Map.class).newInstance(configuration.getIdmArgs());
      identityManager=(IdentityManager)idm;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      LOGGER.error(""String_Node_Str"",configuration.getIdmImpl(),ex);
      stopServer();
      System.exit(-3);
    }
  }
  AccessManager accessManager=null;
  if (configuration.getAmImpl() == null && configuration.getIdmImpl() != null) {
    LOGGER.warn(""String_Node_Str"");
    accessManager=null;
  }
 else   if (configuration.getAmImpl() == null && configuration.getIdmImpl() == null) {
    LOGGER.warn(""String_Node_Str"");
    accessManager=null;
  }
 else {
    try {
      Object am=Class.forName(configuration.getAmImpl()).getConstructor(Map.class).newInstance(configuration.getAmArgs());
      accessManager=(AccessManager)am;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      LOGGER.error(""String_Node_Str"",configuration.getAmImpl(),ex);
      stopServer();
      System.exit(-3);
    }
  }
  if (configuration.isAuthTokenEnabled()) {
    LOGGER.info(""String_Node_Str"",configuration.getAuthTokenTtl());
  }
  SSLContext sslContext=null;
  try {
    KeyManagerFactory kmf;
    KeyStore ks;
    if (getConf().isUseEmbeddedKeystore()) {
      char[] storepass=""String_Node_Str"".toCharArray();
      char[] keypass=""String_Node_Str"".toCharArray();
      String storename=""String_Node_Str"";
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename),storepass);
      kmf.init(ks,keypass);
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
 else {
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      try (FileInputStream fis=new FileInputStream(new File(configuration.getKeystoreFile()))){
        ks.load(fis,configuration.getKeystorePassword().toCharArray());
        kmf.init(ks,configuration.getCertPassword().toCharArray());
        sslContext.init(kmf.getKeyManagers(),null,null);
      }
     }
  }
 catch (  KeyManagementException|NoSuchAlgorithmException|KeyStoreException|CertificateException|UnrecoverableKeyException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer();
    System.exit(-1);
  }
catch (  FileNotFoundException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer();
    System.exit(-1);
  }
catch (  IOException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer();
    System.exit(-1);
  }
  Builder builder=Undertow.builder();
  if (configuration.isHttpsListener()) {
    builder.addHttpsListener(configuration.getHttpsPort(),configuration.getHttpHost(),sslContext);
    LOGGER.info(""String_Node_Str"",configuration.getHttpsHost(),configuration.getHttpsPort());
  }
  if (configuration.isHttpListener()) {
    builder.addHttpListener(configuration.getHttpPort(),configuration.getHttpsHost());
    LOGGER.info(""String_Node_Str"",configuration.getHttpHost(),configuration.getHttpPort());
  }
  if (configuration.isAjpListener()) {
    builder.addAjpListener(configuration.getAjpPort(),configuration.getAjpHost());
    LOGGER.info(""String_Node_Str"",configuration.getAjpHost(),configuration.getAjpPort());
  }
  LocalCachesSingleton.init(configuration);
  if (configuration.isLocalCacheEnabled()) {
    LOGGER.info(""String_Node_Str"");
  }
 else {
    LOGGER.info(""String_Node_Str"");
  }
  hanldersPipe=getHandlersPipe(identityManager,accessManager);
  builder.setIoThreads(configuration.getIoThreads()).setWorkerThreads(configuration.getWorkerThreads()).setDirectBuffers(configuration.isDirectBuffers()).setBufferSize(configuration.getBufferSize()).setBuffersPerRegion(configuration.getBuffersPerRegion()).setHandler(hanldersPipe);
  builder.build().start();
}","private static void startCoreSystem(){
  if (configuration == null) {
    LOGGER.error(""String_Node_Str"");
    stopServer();
    System.exit(-1);
  }
  if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
    LOGGER.error(""String_Node_Str"");
    stopServer();
    System.exit(-1);
  }
  IdentityManager identityManager=null;
  if (configuration.getIdmImpl() == null) {
    LOGGER.warn(""String_Node_Str"");
    identityManager=null;
  }
 else {
    try {
      Object idm=Class.forName(configuration.getIdmImpl()).getConstructor(Map.class).newInstance(configuration.getIdmArgs());
      identityManager=(IdentityManager)idm;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      LOGGER.error(""String_Node_Str"",configuration.getIdmImpl(),ex);
      stopServer();
      System.exit(-3);
    }
  }
  AccessManager accessManager=null;
  if (configuration.getAmImpl() == null && configuration.getIdmImpl() != null) {
    LOGGER.warn(""String_Node_Str"");
    accessManager=new FullAccessManager();
  }
 else   if (configuration.getAmImpl() == null && configuration.getIdmImpl() == null) {
    LOGGER.warn(""String_Node_Str"");
    accessManager=new FullAccessManager();
  }
 else {
    try {
      Object am=Class.forName(configuration.getAmImpl()).getConstructor(Map.class).newInstance(configuration.getAmArgs());
      accessManager=(AccessManager)am;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      LOGGER.error(""String_Node_Str"",configuration.getAmImpl(),ex);
      stopServer();
      System.exit(-3);
    }
  }
  if (configuration.isAuthTokenEnabled()) {
    LOGGER.info(""String_Node_Str"",configuration.getAuthTokenTtl());
  }
  SSLContext sslContext=null;
  try {
    KeyManagerFactory kmf;
    KeyStore ks;
    if (getConf().isUseEmbeddedKeystore()) {
      char[] storepass=""String_Node_Str"".toCharArray();
      char[] keypass=""String_Node_Str"".toCharArray();
      String storename=""String_Node_Str"";
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename),storepass);
      kmf.init(ks,keypass);
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
 else {
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      try (FileInputStream fis=new FileInputStream(new File(configuration.getKeystoreFile()))){
        ks.load(fis,configuration.getKeystorePassword().toCharArray());
        kmf.init(ks,configuration.getCertPassword().toCharArray());
        sslContext.init(kmf.getKeyManagers(),null,null);
      }
     }
  }
 catch (  KeyManagementException|NoSuchAlgorithmException|KeyStoreException|CertificateException|UnrecoverableKeyException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer();
    System.exit(-1);
  }
catch (  FileNotFoundException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer();
    System.exit(-1);
  }
catch (  IOException ex) {
    LOGGER.error(""String_Node_Str"",ex);
    stopServer();
    System.exit(-1);
  }
  Builder builder=Undertow.builder();
  if (configuration.isHttpsListener()) {
    builder.addHttpsListener(configuration.getHttpsPort(),configuration.getHttpHost(),sslContext);
    LOGGER.info(""String_Node_Str"",configuration.getHttpsHost(),configuration.getHttpsPort());
  }
  if (configuration.isHttpListener()) {
    builder.addHttpListener(configuration.getHttpPort(),configuration.getHttpsHost());
    LOGGER.info(""String_Node_Str"",configuration.getHttpHost(),configuration.getHttpPort());
  }
  if (configuration.isAjpListener()) {
    builder.addAjpListener(configuration.getAjpPort(),configuration.getAjpHost());
    LOGGER.info(""String_Node_Str"",configuration.getAjpHost(),configuration.getAjpPort());
  }
  LocalCachesSingleton.init(configuration);
  if (configuration.isLocalCacheEnabled()) {
    LOGGER.info(""String_Node_Str"");
  }
 else {
    LOGGER.info(""String_Node_Str"");
  }
  hanldersPipe=getHandlersPipe(identityManager,accessManager);
  builder.setIoThreads(configuration.getIoThreads()).setWorkerThreads(configuration.getWorkerThreads()).setDirectBuffers(configuration.isDirectBuffers()).setBufferSize(configuration.getBufferSize()).setBuffersPerRegion(configuration.getBuffersPerRegion()).setHandler(hanldersPipe);
  builder.build().start();
}"
93532,"private static GracefulShutdownHandler getHandlersPipe(final IdentityManager identityManager,final AccessManager accessManager){
  PipedHttpHandler coreHandlerChain=new DbPropsInjectorHandler(new CollectionPropsInjectorHandler(new BodyInjectorHandler(new RequestScriptMetadataHandler(new RequestDispacherHandler()))));
  PathHandler paths=path();
  configuration.getMongoMounts().stream().forEach(m -> {
    String url=(String)m.get(Configuration.MONGO_MOUNT_WHERE_KEY);
    String db=(String)m.get(Configuration.MONGO_MOUNT_WHAT_KEY);
    paths.addPrefixPath(url,new AuthTokenInjecterHandler(new CORSHandler(new RequestContextInjectorHandler(url,db,new OptionsHandler(new SecurityHandler(coreHandlerChain,identityManager,accessManager))))));
    LOGGER.info(""String_Node_Str"",url,db);
  }
);
  pipeStaticResourcesHandlers(configuration,paths,identityManager,accessManager);
  pipeApplicationLogicHandlers(configuration,paths,identityManager,accessManager);
  paths.addPrefixPath(""String_Node_Str"",new SecurityHandler(new AuthTokenHandler(),identityManager,accessManager));
  return new GracefulShutdownHandler(new RequestLimitingHandler(new RequestLimit(configuration.getRequestLimit()),new AllowedMethodsHandler(new BlockingHandler(new GzipEncodingHandler(new ErrorHandler(new HttpContinueAcceptingHandler(paths)),configuration.isForceGzipEncoding())),HttpString.tryFromString(RequestContext.METHOD.GET.name()),HttpString.tryFromString(RequestContext.METHOD.POST.name()),HttpString.tryFromString(RequestContext.METHOD.PUT.name()),HttpString.tryFromString(RequestContext.METHOD.DELETE.name()),HttpString.tryFromString(RequestContext.METHOD.PATCH.name()),HttpString.tryFromString(RequestContext.METHOD.OPTIONS.name()))));
}","private static GracefulShutdownHandler getHandlersPipe(final IdentityManager identityManager,final AccessManager accessManager){
  PipedHttpHandler coreHandlerChain=new DbPropsInjectorHandler(new CollectionPropsInjectorHandler(new BodyInjectorHandler(new RequestScriptMetadataHandler(new RequestDispacherHandler()))));
  PathHandler paths=path();
  configuration.getMongoMounts().stream().forEach(m -> {
    String url=(String)m.get(Configuration.MONGO_MOUNT_WHERE_KEY);
    String db=(String)m.get(Configuration.MONGO_MOUNT_WHAT_KEY);
    paths.addPrefixPath(url,new AuthTokenInjecterHandler(new CORSHandler(new RequestContextInjectorHandler(url,db,new OptionsHandler(new SecurityHandler(coreHandlerChain,identityManager,accessManager))))));
    LOGGER.info(""String_Node_Str"",url,db);
  }
);
  pipeStaticResourcesHandlers(configuration,paths,identityManager,accessManager);
  pipeApplicationLogicHandlers(configuration,paths,identityManager,accessManager);
  paths.addPrefixPath(""String_Node_Str"",new AuthTokenInjecterHandler(new CORSHandler(new SecurityHandler(new AuthTokenHandler(),identityManager,new FullAccessManager()))));
  return new GracefulShutdownHandler(new RequestLimitingHandler(new RequestLimit(configuration.getRequestLimit()),new AllowedMethodsHandler(new BlockingHandler(new GzipEncodingHandler(new ErrorHandler(new HttpContinueAcceptingHandler(paths)),configuration.isForceGzipEncoding())),HttpString.tryFromString(RequestContext.METHOD.GET.name()),HttpString.tryFromString(RequestContext.METHOD.POST.name()),HttpString.tryFromString(RequestContext.METHOD.PUT.name()),HttpString.tryFromString(RequestContext.METHOD.DELETE.name()),HttpString.tryFromString(RequestContext.METHOD.PATCH.name()),HttpString.tryFromString(RequestContext.METHOD.OPTIONS.name()))));
}"
93533,"private static void pipeApplicationLogicHandlers(final Configuration conf,final PathHandler paths,final IdentityManager identityManager,final AccessManager accessManager){
  if (conf.getApplicationLogicMounts() != null) {
    conf.getApplicationLogicMounts().stream().forEach(al -> {
      try {
        String alClazz=(String)al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHAT_KEY);
        String alWhere=(String)al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHERE_KEY);
        boolean alSecured=(Boolean)al.get(Configuration.APPLICATION_LOGIC_MOUNT_SECURED_KEY);
        Object alArgs=al.get(Configuration.APPLICATION_LOGIC_MOUNT_ARGS_KEY);
        if (alWhere == null || !alWhere.startsWith(""String_Node_Str"")) {
          LOGGER.error(""String_Node_Str"",alWhere);
          return;
        }
        if (alArgs != null && !(alArgs instanceof Map)) {
          LOGGER.error(""String_Node_Str"" + ""String_Node_Str"",alWhere,alWhere.getClass());
          return;
        }
        Object o=Class.forName(alClazz).getConstructor(PipedHttpHandler.class,Map.class).newInstance(null,(Map)alArgs);
        if (o instanceof ApplicationLogicHandler) {
          ApplicationLogicHandler alHandler=(ApplicationLogicHandler)o;
          PipedHttpHandler handler=new CORSHandler(new RequestContextInjectorHandler(""String_Node_Str"",""String_Node_Str"",alHandler));
          if (alSecured) {
            paths.addPrefixPath(""String_Node_Str"" + alWhere,new SecurityHandler(handler,identityManager,accessManager));
          }
 else {
            paths.addPrefixPath(""String_Node_Str"" + alWhere,handler);
          }
          LOGGER.info(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + alWhere,alClazz,alSecured);
        }
 else {
          LOGGER.error(""String_Node_Str"" + ""String_Node_Str"",alWhere,alClazz);
        }
      }
 catch (      Throwable t) {
        LOGGER.error(""String_Node_Str"",al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHERE_KEY),t);
      }
    }
);
  }
}","private static void pipeApplicationLogicHandlers(final Configuration conf,final PathHandler paths,final IdentityManager identityManager,final AccessManager accessManager){
  if (conf.getApplicationLogicMounts() != null) {
    conf.getApplicationLogicMounts().stream().forEach(al -> {
      try {
        String alClazz=(String)al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHAT_KEY);
        String alWhere=(String)al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHERE_KEY);
        boolean alSecured=(Boolean)al.get(Configuration.APPLICATION_LOGIC_MOUNT_SECURED_KEY);
        Object alArgs=al.get(Configuration.APPLICATION_LOGIC_MOUNT_ARGS_KEY);
        if (alWhere == null || !alWhere.startsWith(""String_Node_Str"")) {
          LOGGER.error(""String_Node_Str"",alWhere);
          return;
        }
        if (alArgs != null && !(alArgs instanceof Map)) {
          LOGGER.error(""String_Node_Str"" + ""String_Node_Str"",alWhere,alWhere.getClass());
          return;
        }
        Object o=Class.forName(alClazz).getConstructor(PipedHttpHandler.class,Map.class).newInstance(null,(Map)alArgs);
        if (o instanceof ApplicationLogicHandler) {
          ApplicationLogicHandler alHandler=(ApplicationLogicHandler)o;
          PipedHttpHandler handler=new CORSHandler(new RequestContextInjectorHandler(""String_Node_Str"",""String_Node_Str"",alHandler));
          if (alSecured) {
            paths.addPrefixPath(""String_Node_Str"" + alWhere,new SecurityHandler(handler,identityManager,accessManager));
          }
 else {
            paths.addPrefixPath(""String_Node_Str"" + alWhere,new SecurityHandler(handler,identityManager,new FullAccessManager()));
          }
          LOGGER.info(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + alWhere,alClazz,alSecured);
        }
 else {
          LOGGER.error(""String_Node_Str"" + ""String_Node_Str"",alWhere,alClazz);
        }
      }
 catch (      Throwable t) {
        LOGGER.error(""String_Node_Str"",al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHERE_KEY),t);
      }
    }
);
  }
}"
93534,"/** 
 * Creates a new instance of OptionsHandler OPTIONS is used in CORS preflight phase and needs to be outside the security zone (i.e. not Authorization header required) It is important that OPTIONS responds to any resource URL, regardless its existance: This is because OPTIONS http://restheart/employees/tofire/andrea shall not give any information
 * @param next
 */
public OptionsHandler(PipedHttpHandler next){
  super(next);
}","/** 
 * Creates a new instance of OptionsHandler OPTIONS is used in CORS preflight phase and needs to be outside the security zone (i.e. not Authorization header required) It is important that OPTIONS responds to any resource URL, regardless its existance: This is because OPTIONS http://restheart.org/employees/tofire/andrea shall not give any information The Access-Control-Allow-Methods header indicates, as part of the response to a preflight request,  which methods can be used during the actual request. 
 * @param next
 */
public OptionsHandler(PipedHttpHandler next){
  super(next);
}"
93535,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (!(context.getMethod() == RequestContext.METHOD.OPTIONS)) {
    getNext().handleRequest(exchange,context);
    return;
  }
  if (context.getType() == RequestContext.TYPE.ROOT) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"" + AUTH_TOKEN_HEADER + ""String_Node_Str""+ AUTH_TOKEN_VALID_HEADER+ ""String_Node_Str""+ AUTH_TOKEN_LOCATION_HEADER);
  }
 else   if (context.getType() == RequestContext.TYPE.DB) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"" + AUTH_TOKEN_HEADER + ""String_Node_Str""+ AUTH_TOKEN_VALID_HEADER+ ""String_Node_Str""+ AUTH_TOKEN_LOCATION_HEADER);
  }
 else   if (context.getType() == RequestContext.TYPE.COLLECTION) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"" + AUTH_TOKEN_HEADER + ""String_Node_Str""+ AUTH_TOKEN_VALID_HEADER+ ""String_Node_Str""+ AUTH_TOKEN_LOCATION_HEADER);
  }
 else   if (context.getType() == RequestContext.TYPE.DOCUMENT) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"" + AUTH_TOKEN_HEADER + ""String_Node_Str""+ AUTH_TOKEN_VALID_HEADER+ ""String_Node_Str""+ AUTH_TOKEN_LOCATION_HEADER);
  }
 else   if (context.getType() == RequestContext.TYPE.INDEX) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"" + AUTH_TOKEN_HEADER + ""String_Node_Str""+ AUTH_TOKEN_VALID_HEADER+ ""String_Node_Str""+ AUTH_TOKEN_LOCATION_HEADER);
  }
 else   if (context.getType() == RequestContext.TYPE.COLLECTION_INDEXES) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"" + AUTH_TOKEN_HEADER + ""String_Node_Str""+ AUTH_TOKEN_VALID_HEADER+ ""String_Node_Str""+ AUTH_TOKEN_LOCATION_HEADER);
  }
  exchange.setResponseCode(HttpStatus.SC_OK);
  exchange.endExchange();
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (!(context.getMethod() == RequestContext.METHOD.OPTIONS)) {
    getNext().handleRequest(exchange,context);
    return;
  }
  if (context.getType() == RequestContext.TYPE.ROOT) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"");
  }
 else   if (context.getType() == RequestContext.TYPE.DB) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"");
  }
 else   if (context.getType() == RequestContext.TYPE.COLLECTION) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"");
  }
 else   if (context.getType() == RequestContext.TYPE.DOCUMENT) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"");
  }
 else   if (context.getType() == RequestContext.TYPE.INDEX) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"");
  }
 else   if (context.getType() == RequestContext.TYPE.COLLECTION_INDEXES) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"").put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"");
  }
  exchange.setResponseCode(HttpStatus.SC_OK);
  exchange.endExchange();
}"
93536,"private void injectAccessControlAllowHeaders(HeadersManager headers){
  if (headers.isRequestHeaderSet(ORIGIN)) {
    headers.addResponseHeader(ACCESS_CONTROL_ALLOW_ORIGIN,headers.getRequestHeader(ORIGIN).getFirst());
  }
 else {
    headers.addResponseHeader(ACCESS_CONTROL_ALLOW_ORIGIN,ALL_ORIGINS);
  }
  headers.addResponseHeader(ACCESS_CONTROL_ALLOW_CREDENTIAL,TRUE);
  headers.addResponseHeader(ACCESS_CONTROL_EXPOSE_HEADERS,LOCATION_STRING);
}","private void injectAccessControlAllowHeaders(HeadersManager headers){
  if (headers.isRequestHeaderSet(ORIGIN)) {
    headers.addResponseHeader(ACCESS_CONTROL_ALLOW_ORIGIN,headers.getRequestHeader(ORIGIN).getFirst());
  }
 else {
    headers.addResponseHeader(ACCESS_CONTROL_ALLOW_ORIGIN,ALL_ORIGINS);
  }
  headers.addResponseHeader(ACCESS_CONTROL_ALLOW_CREDENTIAL,TRUE);
  headers.addResponseHeader(ACCESS_CONTROL_EXPOSE_HEADERS,LOCATION_STRING);
  headers.addResponseHeader(ACCESS_CONTROL_EXPOSE_HEADERS,LOCATION_STRING + ""String_Node_Str"" + AUTH_TOKEN_HEADER.toString()+ ""String_Node_Str""+ AUTH_TOKEN_VALID_HEADER.toString()+ ""String_Node_Str""+ AUTH_TOKEN_LOCATION_HEADER.toString());
}"
93537,"private static GracefulShutdownHandler getHandlersPipe(final IdentityManager identityManager,final AccessManager accessManager){
  PipedHttpHandler coreHandlerChain=new DbPropsInjectorHandler(new CollectionPropsInjectorHandler(new BodyInjectorHandler(new RequestScriptMetadataHandler(new RequestDispacherHandler()))));
  PathHandler paths=path();
  configuration.getMongoMounts().stream().forEach(m -> {
    String url=(String)m.get(Configuration.MONGO_MOUNT_WHERE_KEY);
    String db=(String)m.get(Configuration.MONGO_MOUNT_WHAT_KEY);
    paths.addPrefixPath(url,new AuthTokenInjecterHandler(new CORSHandler(new RequestContextInjectorHandler(url,db,new OptionsHandler(new SecurityHandler(coreHandlerChain,identityManager,accessManager))))));
    LOGGER.info(""String_Node_Str"",url,db);
  }
);
  pipeStaticResourcesHandlers(configuration,paths,identityManager,accessManager);
  pipeApplicationLogicHandlers(configuration,paths,identityManager,accessManager);
  paths.addPrefixPath(""String_Node_Str"",new AuthTokenInjecterHandler(new CORSHandler(new SecurityHandler(new AuthTokenHandler(),identityManager,new FullAccessManager()))));
  return new GracefulShutdownHandler(new RequestLimitingHandler(new RequestLimit(configuration.getRequestLimit()),new AllowedMethodsHandler(new BlockingHandler(new GzipEncodingHandler(new ErrorHandler(new HttpContinueAcceptingHandler(paths)),configuration.isForceGzipEncoding())),HttpString.tryFromString(RequestContext.METHOD.GET.name()),HttpString.tryFromString(RequestContext.METHOD.POST.name()),HttpString.tryFromString(RequestContext.METHOD.PUT.name()),HttpString.tryFromString(RequestContext.METHOD.DELETE.name()),HttpString.tryFromString(RequestContext.METHOD.PATCH.name()),HttpString.tryFromString(RequestContext.METHOD.OPTIONS.name()))));
}","private static GracefulShutdownHandler getHandlersPipe(final IdentityManager identityManager,final AccessManager accessManager){
  PipedHttpHandler coreHandlerChain=new DbPropsInjectorHandler(new CollectionPropsInjectorHandler(new BodyInjectorHandler(new RequestScriptMetadataHandler(new RequestDispacherHandler()))));
  PathHandler paths=path();
  configuration.getMongoMounts().stream().forEach(m -> {
    String url=(String)m.get(Configuration.MONGO_MOUNT_WHERE_KEY);
    String db=(String)m.get(Configuration.MONGO_MOUNT_WHAT_KEY);
    paths.addPrefixPath(url,new CORSHandler(new RequestContextInjectorHandler(url,db,new OptionsHandler(new SecurityHandler(coreHandlerChain,identityManager,accessManager)))));
    LOGGER.info(""String_Node_Str"",url,db);
  }
);
  pipeStaticResourcesHandlers(configuration,paths,identityManager,accessManager);
  pipeApplicationLogicHandlers(configuration,paths,identityManager,accessManager);
  paths.addPrefixPath(""String_Node_Str"",new CORSHandler(new SecurityHandler(new AuthTokenHandler(),identityManager,new FullAccessManager())));
  return new GracefulShutdownHandler(new RequestLimitingHandler(new RequestLimit(configuration.getRequestLimit()),new AllowedMethodsHandler(new BlockingHandler(new GzipEncodingHandler(new ErrorHandler(new HttpContinueAcceptingHandler(paths)),configuration.isForceGzipEncoding())),HttpString.tryFromString(RequestContext.METHOD.GET.name()),HttpString.tryFromString(RequestContext.METHOD.POST.name()),HttpString.tryFromString(RequestContext.METHOD.PUT.name()),HttpString.tryFromString(RequestContext.METHOD.DELETE.name()),HttpString.tryFromString(RequestContext.METHOD.PATCH.name()),HttpString.tryFromString(RequestContext.METHOD.OPTIONS.name()))));
}"
93538,"protected static HttpHandler buildSecurityHandlerChain(final AccessManager accessManager,final IdentityManager identityManager,final List<AuthenticationMechanism> mechanisms){
  HttpHandler handler=null;
  if (accessManager != null) {
    handler=new AccessManagerHandler(accessManager,new AuthTokenInjecterHandler(null));
  }
  handler=new SecurityInitialHandler(AuthenticationMode.PRO_ACTIVE,identityManager,new AuthenticationMechanismsHandler(new PredicateAuthenticationConstraintHandler(new AuthenticationCallHandler(handler),accessManager),mechanisms));
  return handler;
}","protected static HttpHandler buildSecurityHandlerChain(final AccessManager accessManager,final IdentityManager identityManager,final List<AuthenticationMechanism> mechanisms){
  HttpHandler handler;
  if (accessManager == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  handler=new AuthTokenInjecterHandler(new AccessManagerHandler(accessManager,null));
  handler=new SecurityInitialHandler(AuthenticationMode.PRO_ACTIVE,identityManager,new AuthenticationMechanismsHandler(new PredicateAuthenticationConstraintHandler(new AuthenticationCallHandler(handler),accessManager),mechanisms));
  return handler;
}"
93539,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (accessManager.isAllowed(exchange,context)) {
    if (getNext() != null) {
      getNext().handleRequest(exchange,context);
    }
  }
 else {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_UNAUTHORIZED);
  }
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (accessManager.isAllowed(exchange,context)) {
    if (getNext() != null) {
      getNext().handleRequest(exchange,context);
    }
  }
 else {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_FORBIDDEN);
  }
}"
93540,"/** 
 * Handles the request.
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == METHOD.OPTIONS) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"");
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"");
    exchange.setResponseCode(HttpStatus.SC_OK);
    exchange.endExchange();
  }
 else   if (context.getMethod() == METHOD.GET) {
    if (!(context.getUnmappedRequestUri().equals(URLUtils.removeTrailingSlashes(url) + ""String_Node_Str"" + exchange.getSecurityContext().getAuthenticatedAccount().getPrincipal().getName()))) {
      exchange.setResponseCode(HttpStatus.SC_UNAUTHORIZED);
      exchange.getResponseHeaders().remove(AUTH_TOKEN_HEADER);
      exchange.getResponseHeaders().remove(AUTH_TOKEN_VALID_HEADER);
      exchange.getResponseHeaders().remove(AUTH_TOKEN_LOCATION_HEADER);
      exchange.endExchange();
      return;
    }
    Representation rep=new Representation(url);
    if (exchange.getSecurityContext() == null || exchange.getSecurityContext().getAuthenticatedAccount() == null || exchange.getSecurityContext().getAuthenticatedAccount().getPrincipal() == null) {
      BasicDBObject root=new BasicDBObject();
      root.append(""String_Node_Str"",false);
      root.append(""String_Node_Str"",null);
      rep.addProperties(root);
    }
 else {
      BasicDBObject root=new BasicDBObject();
      Set<String> _roles=exchange.getSecurityContext().getAuthenticatedAccount().getRoles();
      root.append(""String_Node_Str"",true);
      root.append(""String_Node_Str"",_roles);
      rep.addProperties(root);
    }
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
    exchange.getResponseSender().send(rep.toString());
    exchange.endExchange();
  }
 else {
    exchange.setResponseCode(HttpStatus.SC_METHOD_NOT_ALLOWED);
    exchange.endExchange();
  }
}","/** 
 * Handles the request.
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  Representation rep;
  if (context.getMethod() == METHOD.OPTIONS) {
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"");
    exchange.getResponseHeaders().put(HttpString.tryFromString(""String_Node_Str""),""String_Node_Str"");
    exchange.setResponseCode(HttpStatus.SC_OK);
    exchange.endExchange();
  }
 else   if (context.getMethod() == METHOD.GET) {
    if ((exchange.getSecurityContext() == null || exchange.getSecurityContext().getAuthenticatedAccount() == null || exchange.getSecurityContext().getAuthenticatedAccount().getPrincipal() == null) || !(context.getUnmappedRequestUri().equals(URLUtils.removeTrailingSlashes(url) + ""String_Node_Str"" + exchange.getSecurityContext().getAuthenticatedAccount().getPrincipal().getName()))) {
{
        exchange.setResponseCode(HttpStatus.SC_UNAUTHORIZED);
        exchange.getResponseHeaders().remove(AUTH_TOKEN_HEADER);
        exchange.getResponseHeaders().remove(AUTH_TOKEN_VALID_HEADER);
        exchange.getResponseHeaders().remove(AUTH_TOKEN_LOCATION_HEADER);
        exchange.endExchange();
        return;
      }
    }
 else {
      rep=new Representation(URLUtils.removeTrailingSlashes(url) + ""String_Node_Str"" + exchange.getSecurityContext().getAuthenticatedAccount().getPrincipal().getName());
      BasicDBObject root=new BasicDBObject();
      Set<String> _roles=exchange.getSecurityContext().getAuthenticatedAccount().getRoles();
      root.append(""String_Node_Str"",true);
      root.append(""String_Node_Str"",_roles);
      rep.addProperties(root);
    }
    exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
    exchange.getResponseSender().send(rep.toString());
    exchange.endExchange();
  }
 else {
    exchange.setResponseCode(HttpStatus.SC_METHOD_NOT_ALLOWED);
    exchange.endExchange();
  }
}"
93541,"private static void pipeApplicationLogicHandlers(final Configuration conf,final PathHandler paths,final IdentityManager identityManager,final AccessManager accessManager){
  if (conf.getApplicationLogicMounts() != null) {
    conf.getApplicationLogicMounts().stream().forEach(al -> {
      try {
        String alClazz=(String)al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHAT_KEY);
        String alWhere=(String)al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHERE_KEY);
        boolean alSecured=(Boolean)al.get(Configuration.APPLICATION_LOGIC_MOUNT_SECURED_KEY);
        Object alArgs=al.get(Configuration.APPLICATION_LOGIC_MOUNT_ARGS_KEY);
        if (alWhere == null || !alWhere.startsWith(""String_Node_Str"")) {
          LOGGER.error(""String_Node_Str"",alWhere);
          return;
        }
        if (alArgs != null && !(alArgs instanceof Map)) {
          LOGGER.error(""String_Node_Str"" + ""String_Node_Str"",alWhere,alWhere.getClass());
          return;
        }
        Object o=Class.forName(alClazz).getConstructor(PipedHttpHandler.class,Map.class).newInstance(null,(Map)alArgs);
        if (o instanceof ApplicationLogicHandler) {
          ApplicationLogicHandler alHandler=(ApplicationLogicHandler)o;
          PipedHttpHandler handler=new CORSHandler(new RequestContextInjectorHandler(""String_Node_Str"",""String_Node_Str"",alHandler));
          if (alSecured) {
            paths.addPrefixPath(""String_Node_Str"" + alWhere,new SecurityHandler(handler,identityManager,accessManager));
          }
 else {
            paths.addPrefixPath(""String_Node_Str"" + alWhere,new SecurityHandler(handler,identityManager,new FullAccessManager()));
          }
          LOGGER.info(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + alWhere,alClazz,alSecured);
        }
 else {
          LOGGER.error(""String_Node_Str"" + ""String_Node_Str"",alWhere,alClazz);
        }
      }
 catch (      Throwable t) {
        LOGGER.error(""String_Node_Str"",al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHERE_KEY),t);
      }
    }
);
  }
}","private static void pipeApplicationLogicHandlers(final Configuration conf,final PathHandler paths,final IdentityManager identityManager,final AccessManager accessManager){
  if (conf.getApplicationLogicMounts() != null) {
    conf.getApplicationLogicMounts().stream().forEach(al -> {
      try {
        String alClazz=(String)al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHAT_KEY);
        String alWhere=(String)al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHERE_KEY);
        boolean alSecured=(Boolean)al.get(Configuration.APPLICATION_LOGIC_MOUNT_SECURED_KEY);
        Object alArgs=al.get(Configuration.APPLICATION_LOGIC_MOUNT_ARGS_KEY);
        if (alWhere == null || !alWhere.startsWith(""String_Node_Str"")) {
          LOGGER.error(""String_Node_Str"",alWhere);
          return;
        }
        if (alArgs != null && !(alArgs instanceof Map)) {
          LOGGER.error(""String_Node_Str"" + ""String_Node_Str"",alWhere,alWhere.getClass());
          return;
        }
        Object o=Class.forName(alClazz).getConstructor(PipedHttpHandler.class,Map.class).newInstance(null,(Map)alArgs);
        if (o instanceof ApplicationLogicHandler) {
          ApplicationLogicHandler alHandler=(ApplicationLogicHandler)o;
          PipedHttpHandler handler=new RequestContextInjectorHandler(""String_Node_Str"",""String_Node_Str"",alHandler);
          if (alSecured) {
            paths.addPrefixPath(""String_Node_Str"" + alWhere,new CORSHandler(new SecurityHandler(handler,identityManager,accessManager)));
          }
 else {
            paths.addPrefixPath(""String_Node_Str"" + alWhere,new CORSHandler(new SecurityHandler(handler,identityManager,new FullAccessManager())));
          }
          LOGGER.info(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + alWhere,alClazz,alSecured);
        }
 else {
          LOGGER.error(""String_Node_Str"" + ""String_Node_Str"",alWhere,alClazz);
        }
      }
 catch (      Throwable t) {
        LOGGER.error(""String_Node_Str"",al.get(Configuration.APPLICATION_LOGIC_MOUNT_WHERE_KEY),t);
      }
    }
);
  }
}"
93542,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  Object id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",id);
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  int httpCode=documentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,true);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  Object id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",id);
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  int httpCode=documentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,true);
  ResponseHelper.injectEtagHeader(exchange,content);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
}"
93543,"protected static TYPE selectRequestType(String[] pathTokens){
  TYPE type;
  if (pathTokens.length < 2) {
    type=TYPE.ROOT;
  }
 else   if (pathTokens.length < 3) {
    type=TYPE.DB;
  }
 else   if (pathTokens.length >= 3 && pathTokens[2].endsWith(FS_FILES_SUFFIX)) {
    if (pathTokens.length == 3) {
      type=TYPE.FILES_BUCKET;
    }
 else     if (pathTokens.length == 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
      type=TYPE.COLLECTION_INDEXES;
    }
 else     if (pathTokens.length == 4 && !pathTokens[3].equalsIgnoreCase(_INDEXES)) {
      type=TYPE.FILE;
    }
 else     if (pathTokens.length == 5 && pathTokens[4].equalsIgnoreCase(BINARY_CONTENT)) {
      type=TYPE.FILE;
    }
 else {
      type=TYPE.DOCUMENT;
    }
  }
 else   if (pathTokens.length < 4) {
    type=TYPE.COLLECTION;
  }
 else   if (pathTokens.length == 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
    type=TYPE.COLLECTION_INDEXES;
  }
 else   if (pathTokens.length > 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
    type=TYPE.INDEX;
  }
 else {
    type=TYPE.DOCUMENT;
  }
  return type;
}","protected static TYPE selectRequestType(String[] pathTokens){
  TYPE type;
  if (pathTokens.length < 2) {
    type=TYPE.ROOT;
  }
 else   if (pathTokens.length < 3) {
    type=TYPE.DB;
  }
 else   if (pathTokens.length >= 3 && pathTokens[2].endsWith(FS_FILES_SUFFIX)) {
    if (pathTokens.length == 3) {
      type=TYPE.FILES_BUCKET;
    }
 else     if (pathTokens.length == 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
      type=TYPE.COLLECTION_INDEXES;
    }
 else     if (pathTokens.length == 4 && !pathTokens[3].equalsIgnoreCase(_INDEXES)) {
      type=TYPE.FILE;
    }
 else     if (pathTokens.length > 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
      type=TYPE.INDEX;
    }
 else     if (pathTokens.length > 4 && !pathTokens[3].equalsIgnoreCase(_INDEXES) && !pathTokens[4].equalsIgnoreCase(BINARY_CONTENT)) {
      type=TYPE.FILE;
    }
 else     if (pathTokens.length == 5 && pathTokens[4].equalsIgnoreCase(BINARY_CONTENT)) {
      type=TYPE.FILE;
    }
 else {
      type=TYPE.DOCUMENT;
    }
  }
 else   if (pathTokens.length < 4) {
    type=TYPE.COLLECTION;
  }
 else   if (pathTokens.length == 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
    type=TYPE.COLLECTION_INDEXES;
  }
 else   if (pathTokens.length > 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
    type=TYPE.INDEX;
  }
 else {
    type=TYPE.DOCUMENT;
  }
  return type;
}"
93544,"@Test public void test_FILE_selectRequestType(){
  System.out.println(""String_Node_Str"");
  String[] pathTokens=""String_Node_Str"".split(""String_Node_Str"");
  assertEquals(RequestContext.TYPE.DOCUMENT,RequestContext.selectRequestType(pathTokens));
  pathTokens=""String_Node_Str"".split(""String_Node_Str"");
  assertEquals(RequestContext.TYPE.FILE,RequestContext.selectRequestType(pathTokens));
  pathTokens=""String_Node_Str"".split(""String_Node_Str"");
  assertEquals(RequestContext.TYPE.DOCUMENT,RequestContext.selectRequestType(pathTokens));
}","@Test public void test_FILE_selectRequestType(){
  System.out.println(""String_Node_Str"");
  String[] pathTokens=""String_Node_Str"".split(""String_Node_Str"");
  assertEquals(RequestContext.TYPE.FILE,RequestContext.selectRequestType(pathTokens));
  pathTokens=""String_Node_Str"".split(""String_Node_Str"");
  assertEquals(RequestContext.TYPE.FILE,RequestContext.selectRequestType(pathTokens));
  pathTokens=""String_Node_Str"".split(""String_Node_Str"");
  assertEquals(RequestContext.TYPE.FILE,RequestContext.selectRequestType(pathTokens));
}"
93545,"@Test public void testCheckCollectionFilesPost(){
  System.out.println(""String_Node_Str"");
  RequestContext context=createContext(""String_Node_Str"",""String_Node_Str"");
  assertEquals(context.getType(),RequestContext.TYPE.FILES_BUCKET);
  assertEquals(context.getMethod(),RequestContext.METHOD.POST);
  assertEquals(false,CollectionPropsInjectorHandler.checkCollection(context));
}","@Test public void testCheckCollectionFilesPost(){
  System.out.println(""String_Node_Str"");
  RequestContext context=createContext(""String_Node_Str"",""String_Node_Str"");
  assertEquals(context.getType(),RequestContext.TYPE.FILES_BUCKET);
  assertEquals(context.getMethod(),RequestContext.METHOD.POST);
  assertEquals(true,CollectionPropsInjectorHandler.checkCollection(context));
}"
93546,"protected static TYPE selectRequestType(String[] pathTokens){
  TYPE type;
  if (pathTokens.length < 2) {
    type=TYPE.ROOT;
  }
 else   if (pathTokens.length < 3) {
    type=TYPE.DB;
  }
 else   if (pathTokens.length >= 3 && pathTokens[2].endsWith(FS_FILES_SUFFIX)) {
    if (pathTokens.length == 3) {
      type=TYPE.FILES_BUCKET;
    }
 else     if (pathTokens.length == 4 && pathTokens[2].endsWith(FS_FILES_SUFFIX) && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
      type=TYPE.COLLECTION_INDEXES;
    }
 else     if (pathTokens.length == 5 && pathTokens[2].endsWith(FS_FILES_SUFFIX) && pathTokens[4].equalsIgnoreCase(BINARY_CONTENT)) {
      type=TYPE.FILE;
    }
 else {
      type=TYPE.DOCUMENT;
    }
  }
 else   if (pathTokens.length < 4) {
    type=TYPE.COLLECTION;
  }
 else   if (pathTokens.length == 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
    type=TYPE.COLLECTION_INDEXES;
  }
 else   if (pathTokens.length > 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
    type=TYPE.INDEX;
  }
 else {
    type=TYPE.DOCUMENT;
  }
  return type;
}","protected static TYPE selectRequestType(String[] pathTokens){
  TYPE type;
  if (pathTokens.length < 2) {
    type=TYPE.ROOT;
  }
 else   if (pathTokens.length < 3) {
    type=TYPE.DB;
  }
 else   if (pathTokens.length >= 3 && pathTokens[2].endsWith(FS_FILES_SUFFIX)) {
    if (pathTokens.length == 3) {
      type=TYPE.FILES_BUCKET;
    }
 else     if (pathTokens.length == 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
      type=TYPE.COLLECTION_INDEXES;
    }
 else     if (pathTokens.length == 4 && !pathTokens[3].equalsIgnoreCase(_INDEXES)) {
      type=TYPE.FILE;
    }
 else     if (pathTokens.length == 5 && pathTokens[4].equalsIgnoreCase(BINARY_CONTENT)) {
      type=TYPE.FILE;
    }
 else {
      type=TYPE.DOCUMENT;
    }
  }
 else   if (pathTokens.length < 4) {
    type=TYPE.COLLECTION;
  }
 else   if (pathTokens.length == 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
    type=TYPE.COLLECTION_INDEXES;
  }
 else   if (pathTokens.length > 4 && pathTokens[3].equalsIgnoreCase(_INDEXES)) {
    type=TYPE.INDEX;
  }
 else {
    type=TYPE.DOCUMENT;
  }
  return type;
}"
93547,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  FormDataParser parser=this.formParserFactory.createParser(exchange);
  FormData data=parser.parseBlocking();
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"");
    data.forEach((    String field) -> {
      if (!data.getFirst(field).isFile()) {
        LOGGER.debug(""String_Node_Str"",field,data.getFirst(field).getValue());
      }
    }
);
  }
  final String fileFieldName=findFile(data);
  if (fileFieldName == null) {
    String errMsg=""String_Node_Str"";
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
    return;
  }
  final DBObject props;
  try {
    props=findProps(data);
  }
 catch (  JSONParseException jpe) {
    String errMsg=""String_Node_Str"";
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,jpe);
    return;
  }
  Object _id=props.get(""String_Node_Str"");
  if (_id == null) {
    _id=new ObjectId();
    ;
  }
 else {
    try {
      URLUtils.checkId(_id);
    }
 catch (    UnsupportedDocumentIdException udie) {
      String errMsg=""String_Node_Str"" + _id.getClass().getSimpleName();
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,udie);
      return;
    }
  }
  FormData.FormValue file=data.getFirst(fileFieldName);
  try {
    if (file.getFile() != null) {
      gridFsDAO.createFile(getDatabase(),context.getDBName(),context.getCollectionName(),_id,props,file.getFile());
    }
  }
 catch (  Throwable t) {
    if (t instanceof DuplicateKeyException) {
      String errMsg=""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_IMPLEMENTED,errMsg);
      return;
    }
    throw t;
  }
  exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(context,exchange.getRequestURL(),_id));
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  FormDataParser parser=this.formParserFactory.createParser(exchange);
  FormData data=parser.parseBlocking();
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"");
    data.forEach((    String field) -> {
      if (!data.getFirst(field).isFile()) {
        LOGGER.debug(""String_Node_Str"",field,data.getFirst(field).getValue());
      }
    }
);
  }
  final String fileFieldName=findFile(data);
  if (fileFieldName == null) {
    String errMsg=""String_Node_Str"";
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
    return;
  }
  final DBObject props;
  try {
    props=findProps(data);
  }
 catch (  JSONParseException jpe) {
    String errMsg=""String_Node_Str"";
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,jpe);
    return;
  }
  Object _id=props.get(""String_Node_Str"");
  if (_id == null) {
    _id=new ObjectId();
    ;
  }
 else {
    try {
      URLUtils.checkId(_id);
    }
 catch (    UnsupportedDocumentIdException udie) {
      String errMsg=""String_Node_Str"" + _id.getClass().getSimpleName();
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,udie);
      return;
    }
  }
  FormData.FormValue file=data.getFirst(fileFieldName);
  int code;
  try {
    if (file.getFile() != null) {
      code=gridFsDAO.createFile(getDatabase(),context.getDBName(),context.getCollectionName(),_id,props,file.getFile());
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Throwable t) {
    if (t instanceof DuplicateKeyException) {
      String errMsg=""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_IMPLEMENTED,errMsg);
      return;
    }
    throw t;
  }
  exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(context,exchange.getRequestURL(),_id));
  exchange.setResponseCode(code);
  exchange.endExchange();
}"
93548,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  FormDataParser parser=this.formParserFactory.createParser(exchange);
  FormData data=parser.parseBlocking();
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"");
    data.forEach((    String field) -> {
      if (!data.getFirst(field).isFile()) {
        LOGGER.debug(""String_Node_Str"",field,data.getFirst(field).getValue());
      }
    }
);
  }
  final String fileFieldName=findFile(data);
  if (fileFieldName == null) {
    String errMsg=""String_Node_Str"";
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
    return;
  }
  final DBObject props;
  try {
    props=findProps(data);
  }
 catch (  JSONParseException jpe) {
    String errMsg=""String_Node_Str"";
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,jpe);
    return;
  }
  Object id=context.getDocumentId();
  if (props.get(""String_Node_Str"") == null) {
    props.put(""String_Node_Str"",id);
  }
 else   if (!props.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  try {
    URLUtils.checkId(id);
  }
 catch (  UnsupportedDocumentIdException udie) {
    String errMsg=""String_Node_Str"" + id.getClass().getSimpleName();
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,udie);
    return;
  }
  FormData.FormValue file=data.getFirst(fileFieldName);
  try {
    if (file.getFile() != null) {
      gridFsDAO.createFile(getDatabase(),context.getDBName(),context.getCollectionName(),id,props,file.getFile());
    }
  }
 catch (  Throwable t) {
    if (t instanceof DuplicateKeyException) {
      String errMsg=""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_IMPLEMENTED,errMsg);
      return;
    }
    throw t;
  }
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  FormDataParser parser=this.formParserFactory.createParser(exchange);
  FormData data=parser.parseBlocking();
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"");
    data.forEach((    String field) -> {
      if (!data.getFirst(field).isFile()) {
        LOGGER.debug(""String_Node_Str"",field,data.getFirst(field).getValue());
      }
    }
);
  }
  final String fileFieldName=findFile(data);
  if (fileFieldName == null) {
    String errMsg=""String_Node_Str"";
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg);
    return;
  }
  final DBObject props;
  try {
    props=findProps(data);
  }
 catch (  JSONParseException jpe) {
    String errMsg=""String_Node_Str"";
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,jpe);
    return;
  }
  Object id=context.getDocumentId();
  if (props.get(""String_Node_Str"") == null) {
    props.put(""String_Node_Str"",id);
  }
 else   if (!props.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  try {
    URLUtils.checkId(id);
  }
 catch (  UnsupportedDocumentIdException udie) {
    String errMsg=""String_Node_Str"" + id.getClass().getSimpleName();
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,errMsg,udie);
    return;
  }
  FormData.FormValue file=data.getFirst(fileFieldName);
  int code;
  try {
    if (file.getFile() != null) {
      code=gridFsDAO.createFile(getDatabase(),context.getDBName(),context.getCollectionName(),id,props,file.getFile());
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Throwable t) {
    if (t instanceof DuplicateKeyException) {
      String errMsg=""String_Node_Str"";
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_IMPLEMENTED,errMsg);
      return;
    }
    throw t;
  }
  exchange.setResponseCode(code);
  exchange.endExchange();
}"
93549,"@Ignore public void testPostBinaryFileHandler() throws Exception {
  System.out.println(""String_Node_Str"");
  HttpServerExchange exchange=new HttpServerExchange();
  exchange.setRequestPath(""String_Node_Str"");
  exchange.setRequestMethod(new HttpString(""String_Node_Str""));
  RequestContext context=new RequestContext(exchange,""String_Node_Str"",""String_Node_Str"");
  dispacher.putPipedHttpHandler(RequestContext.TYPE.FILES_BUCKET,RequestContext.METHOD.POST,new PostBinaryFileHandler(null,null));
  dispacher.handleRequest(exchange,context);
  assertEquals(HttpStatus.SC_NOT_IMPLEMENTED,exchange.getResponseCode());
}","@Ignore public void testPostBinaryFileHandler() throws Exception {
  System.out.println(""String_Node_Str"");
  HttpServerExchange exchange=new HttpServerExchange();
  exchange.setRequestPath(""String_Node_Str"");
  exchange.setRequestMethod(new HttpString(""String_Node_Str""));
  RequestContext context=new RequestContext(exchange,""String_Node_Str"",""String_Node_Str"");
  dispacher.putPipedHttpHandler(RequestContext.TYPE.FILES_BUCKET,RequestContext.METHOD.POST,new PostFileHandler(null,null));
  dispacher.handleRequest(exchange,context);
  assertEquals(HttpStatus.SC_NOT_IMPLEMENTED,exchange.getResponseCode());
}"
93550,"@Test public void testExtractBucket(){
  System.out.println(""String_Node_Str"");
  assertEquals(""String_Node_Str"",GetBinaryFileHandler.extractBucketName(""String_Node_Str""));
}","@Test public void testExtractBucket(){
  System.out.println(""String_Node_Str"");
  assertEquals(""String_Node_Str"",GetFileHandler.extractBucketName(""String_Node_Str""));
}"
93551,"/** 
 * Creates a new instance of ErrorHandler from the configuration file For any missing property the default value is used.
 * @param confFilePath the path of the configuration file
 * @param silent
 * @throws org.restheart.ConfigurationException
 */
public Configuration(final Path confFilePath,boolean silent) throws ConfigurationException {
  this.silent=silent;
  Yaml yaml=new Yaml();
  Map<String,Object> conf=null;
  FileInputStream fis=null;
  try {
    fis=new FileInputStream(confFilePath.toFile());
    conf=(Map<String,Object>)yaml.load(fis);
  }
 catch (  FileNotFoundException fne) {
    throw new ConfigurationException(""String_Node_Str"",fne);
  }
catch (  Throwable t) {
    throw new ConfigurationException(""String_Node_Str"",t);
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException ioe) {
        LOGGER.warn(""String_Node_Str"",ioe);
      }
    }
  }
  httpsListener=getAsBooleanOrDefault(conf,HTTPS_LISTENER,true);
  httpsPort=getAsIntegerOrDefault(conf,HTTPS_PORT_KEY,DEFAULT_HTTPS_PORT);
  httpsHost=getAsStringOrDefault(conf,HTTPS_HOST_KEY,DEFAULT_HTTPS_HOST);
  httpListener=getAsBooleanOrDefault(conf,HTTP_LISTENER_KEY,false);
  httpPort=getAsIntegerOrDefault(conf,HTTP_PORT_KEY,DEFAULT_HTTP_PORT);
  httpHost=getAsStringOrDefault(conf,HTTP_HOST_KEY,DEFAULT_HTTP_HOST);
  ajpListener=getAsBooleanOrDefault(conf,AJP_LISTENER_KEY,false);
  ajpPort=getAsIntegerOrDefault(conf,AJP_PORT_KEY,DEFAULT_AJP_PORT);
  ajpHost=getAsStringOrDefault(conf,AJP_HOST_KEY,DEFAULT_AJP_HOST);
  useEmbeddedKeystore=getAsBooleanOrDefault(conf,USE_EMBEDDED_KEYSTORE_KEY,true);
  keystoreFile=getAsStringOrDefault(conf,KEYSTORE_FILE_KEY,null);
  keystorePassword=getAsStringOrDefault(conf,KEYSTORE_PASSWORD_KEY,null);
  certPassword=getAsStringOrDefault(conf,CERT_PASSWORD_KEY,null);
  List<Map<String,Object>> mongoServersDefault=new ArrayList<>();
  Map<String,Object> defaultMongoServer=new HashMap<>();
  defaultMongoServer.put(MONGO_HOST_KEY,""String_Node_Str"");
  defaultMongoServer.put(MONGO_PORT_KEY,27017);
  mongoServersDefault.add(defaultMongoServer);
  mongoServers=getAsListOfMaps(conf,MONGO_SERVERS_KEY,mongoServersDefault);
  mongoCredentials=getAsListOfMaps(conf,MONGO_CREDENTIALS_KEY,null);
  List<Map<String,Object>> mongoMountsDefault=new ArrayList<>();
  Map<String,Object> defaultMongoMounts=new HashMap<>();
  defaultMongoMounts.put(MONGO_MOUNT_WHAT_KEY,""String_Node_Str"");
  defaultMongoMounts.put(MONGO_MOUNT_WHERE_KEY,""String_Node_Str"");
  mongoMountsDefault.add(defaultMongoMounts);
  mongoMounts=getAsListOfMaps(conf,MONGO_MOUNTS_KEY,mongoMountsDefault);
  applicationLogicMounts=getAsListOfMaps(conf,APPLICATION_LOGIC_MOUNTS_KEY,new ArrayList<>());
  staticResourcesMounts=getAsListOfMaps(conf,STATIC_RESOURCES_MOUNTS_KEY,new ArrayList<>());
  Map<String,Object> idm=getAsMap(conf,IDM_KEY);
  Map<String,Object> am=getAsMap(conf,ACCESS_MANAGER_KEY);
  idmImpl=getAsStringOrDefault(idm,IMPLEMENTATION_CLASS_KEY,DEFAULT_IDM_IMPLEMENTATION_CLASS);
  idmArgs=idm;
  amImpl=getAsStringOrDefault(am,IMPLEMENTATION_CLASS_KEY,DEFAULT_AM_IMPLEMENTATION_CLASS);
  amArgs=am;
  logFilePath=getAsStringOrDefault(conf,LOG_FILE_PATH_KEY,URLUtils.removeTrailingSlashes(System.getProperty(""String_Node_Str"")).concat(File.separator + ""String_Node_Str""));
  String _logLevel=getAsStringOrDefault(conf,LOG_LEVEL_KEY,""String_Node_Str"");
  logToConsole=getAsBooleanOrDefault(conf,ENABLE_LOG_CONSOLE_KEY,true);
  logToFile=getAsBooleanOrDefault(conf,ENABLE_LOG_FILE_KEY,true);
  Level level;
  try {
    level=Level.valueOf(_logLevel);
  }
 catch (  Exception e) {
    if (!silent) {
      LOGGER.info(""String_Node_Str"",""String_Node_Str"",_logLevel,""String_Node_Str"");
    }
    level=Level.INFO;
  }
  logLevel=level;
  requestsLimit=getAsIntegerOrDefault(conf,REQUESTS_LIMIT_KEY,100);
  localCacheEnabled=getAsBooleanOrDefault(conf,LOCAL_CACHE_ENABLED_KEY,true);
  localCacheTtl=getAsLongOrDefault(conf,LOCAL_CACHE_TTL_KEY,(long)1000);
  ioThreads=getAsIntegerOrDefault(conf,IO_THREADS_KEY,2);
  workerThreads=getAsIntegerOrDefault(conf,WORKER_THREADS_KEY,32);
  bufferSize=getAsIntegerOrDefault(conf,BUFFER_SIZE_KEY,16384);
  buffersPerRegion=getAsIntegerOrDefault(conf,BUFFERS_PER_REGION_KEY,20);
  directBuffers=getAsBooleanOrDefault(conf,DIRECT_BUFFERS_KEY,true);
  forceGzipEncoding=getAsBooleanOrDefault(conf,FORCE_GZIP_ENCODING_KEY,false);
  eagerPoolSize=getAsIntegerOrDefault(conf,EAGER_POOL_SIZE,100);
  eagerLinearSliceWidht=getAsIntegerOrDefault(conf,EAGER_LINEAR_SLICE_WIDHT,1000);
  eagerLinearSliceDelta=getAsIntegerOrDefault(conf,EAGER_LINEAR_SLICE_DELTA,100);
  eagerLinearSliceHeights=getAsArrayOfInts(conf,EAGER_LINEAR_HEIGHTS,new int[]{4,2,1});
  eagerRndSliceMinWidht=getAsIntegerOrDefault(conf,EAGER_RND_SLICE_MIN_WIDHT,1000);
  eagerRndMaxCursors=getAsIntegerOrDefault(conf,EAGER_RND_MAX_CURSORS,50);
  authTokenEnabled=getAsBooleanOrDefault(conf,AUTH_TOKEN_ENABLED,true);
  authTokenTtl=getAsIntegerOrDefault(conf,AUTH_TOKEN_TTL,15);
}","/** 
 * Creates a new instance of ErrorHandler from the configuration file For any missing property the default value is used.
 * @param confFilePath the path of the configuration file
 * @param silent
 * @throws org.restheart.ConfigurationException
 */
public Configuration(final Path confFilePath,boolean silent) throws ConfigurationException {
  this.silent=silent;
  Yaml yaml=new Yaml();
  Map<String,Object> conf=null;
  FileInputStream fis=null;
  try {
    fis=new FileInputStream(confFilePath.toFile());
    conf=(Map<String,Object>)yaml.load(fis);
  }
 catch (  FileNotFoundException fne) {
    throw new ConfigurationException(""String_Node_Str"",fne);
  }
catch (  Throwable t) {
    throw new ConfigurationException(""String_Node_Str"",t);
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException ioe) {
        LOGGER.warn(""String_Node_Str"",ioe);
      }
    }
  }
  httpsListener=getAsBooleanOrDefault(conf,HTTPS_LISTENER,true);
  httpsPort=getAsIntegerOrDefault(conf,HTTPS_PORT_KEY,DEFAULT_HTTPS_PORT);
  httpsHost=getAsStringOrDefault(conf,HTTPS_HOST_KEY,DEFAULT_HTTPS_HOST);
  httpListener=getAsBooleanOrDefault(conf,HTTP_LISTENER_KEY,false);
  httpPort=getAsIntegerOrDefault(conf,HTTP_PORT_KEY,DEFAULT_HTTP_PORT);
  httpHost=getAsStringOrDefault(conf,HTTP_HOST_KEY,DEFAULT_HTTP_HOST);
  ajpListener=getAsBooleanOrDefault(conf,AJP_LISTENER_KEY,false);
  ajpPort=getAsIntegerOrDefault(conf,AJP_PORT_KEY,DEFAULT_AJP_PORT);
  ajpHost=getAsStringOrDefault(conf,AJP_HOST_KEY,DEFAULT_AJP_HOST);
  useEmbeddedKeystore=getAsBooleanOrDefault(conf,USE_EMBEDDED_KEYSTORE_KEY,true);
  keystoreFile=getAsStringOrDefault(conf,KEYSTORE_FILE_KEY,null);
  keystorePassword=getAsStringOrDefault(conf,KEYSTORE_PASSWORD_KEY,null);
  certPassword=getAsStringOrDefault(conf,CERT_PASSWORD_KEY,null);
  List<Map<String,Object>> mongoServersDefault=new ArrayList<>();
  Map<String,Object> defaultMongoServer=new HashMap<>();
  defaultMongoServer.put(MONGO_HOST_KEY,DEFAULT_MONGO_HOST);
  defaultMongoServer.put(MONGO_PORT_KEY,DEFAULT_MONGO_PORT);
  mongoServersDefault.add(defaultMongoServer);
  mongoServers=getAsListOfMaps(conf,MONGO_SERVERS_KEY,mongoServersDefault);
  mongoCredentials=getAsListOfMaps(conf,MONGO_CREDENTIALS_KEY,null);
  List<Map<String,Object>> mongoMountsDefault=new ArrayList<>();
  Map<String,Object> defaultMongoMounts=new HashMap<>();
  defaultMongoMounts.put(MONGO_MOUNT_WHAT_KEY,""String_Node_Str"");
  defaultMongoMounts.put(MONGO_MOUNT_WHERE_KEY,""String_Node_Str"");
  mongoMountsDefault.add(defaultMongoMounts);
  mongoMounts=getAsListOfMaps(conf,MONGO_MOUNTS_KEY,mongoMountsDefault);
  applicationLogicMounts=getAsListOfMaps(conf,APPLICATION_LOGIC_MOUNTS_KEY,new ArrayList<>());
  staticResourcesMounts=getAsListOfMaps(conf,STATIC_RESOURCES_MOUNTS_KEY,new ArrayList<>());
  Map<String,Object> idm=getAsMap(conf,IDM_KEY);
  Map<String,Object> am=getAsMap(conf,ACCESS_MANAGER_KEY);
  idmImpl=getAsStringOrDefault(idm,IMPLEMENTATION_CLASS_KEY,DEFAULT_IDM_IMPLEMENTATION_CLASS);
  idmArgs=idm;
  amImpl=getAsStringOrDefault(am,IMPLEMENTATION_CLASS_KEY,DEFAULT_AM_IMPLEMENTATION_CLASS);
  amArgs=am;
  logFilePath=getAsStringOrDefault(conf,LOG_FILE_PATH_KEY,URLUtils.removeTrailingSlashes(System.getProperty(""String_Node_Str"")).concat(File.separator + ""String_Node_Str""));
  String _logLevel=getAsStringOrDefault(conf,LOG_LEVEL_KEY,""String_Node_Str"");
  logToConsole=getAsBooleanOrDefault(conf,ENABLE_LOG_CONSOLE_KEY,true);
  logToFile=getAsBooleanOrDefault(conf,ENABLE_LOG_FILE_KEY,true);
  Level level;
  try {
    level=Level.valueOf(_logLevel);
  }
 catch (  Exception e) {
    if (!silent) {
      LOGGER.info(""String_Node_Str"",""String_Node_Str"",_logLevel,""String_Node_Str"");
    }
    level=Level.INFO;
  }
  logLevel=level;
  requestsLimit=getAsIntegerOrDefault(conf,REQUESTS_LIMIT_KEY,100);
  localCacheEnabled=getAsBooleanOrDefault(conf,LOCAL_CACHE_ENABLED_KEY,true);
  localCacheTtl=getAsLongOrDefault(conf,LOCAL_CACHE_TTL_KEY,(long)1000);
  ioThreads=getAsIntegerOrDefault(conf,IO_THREADS_KEY,2);
  workerThreads=getAsIntegerOrDefault(conf,WORKER_THREADS_KEY,32);
  bufferSize=getAsIntegerOrDefault(conf,BUFFER_SIZE_KEY,16384);
  buffersPerRegion=getAsIntegerOrDefault(conf,BUFFERS_PER_REGION_KEY,20);
  directBuffers=getAsBooleanOrDefault(conf,DIRECT_BUFFERS_KEY,true);
  forceGzipEncoding=getAsBooleanOrDefault(conf,FORCE_GZIP_ENCODING_KEY,false);
  eagerPoolSize=getAsIntegerOrDefault(conf,EAGER_POOL_SIZE,100);
  eagerLinearSliceWidht=getAsIntegerOrDefault(conf,EAGER_LINEAR_SLICE_WIDHT,1000);
  eagerLinearSliceDelta=getAsIntegerOrDefault(conf,EAGER_LINEAR_SLICE_DELTA,100);
  eagerLinearSliceHeights=getAsArrayOfInts(conf,EAGER_LINEAR_HEIGHTS,new int[]{4,2,1});
  eagerRndSliceMinWidht=getAsIntegerOrDefault(conf,EAGER_RND_SLICE_MIN_WIDHT,1000);
  eagerRndMaxCursors=getAsIntegerOrDefault(conf,EAGER_RND_MAX_CURSORS,50);
  authTokenEnabled=getAsBooleanOrDefault(conf,AUTH_TOKEN_ENABLED,true);
  authTokenTtl=getAsIntegerOrDefault(conf,AUTH_TOKEN_TTL,15);
}"
93552,"public static void main(final String[] args){
  if (askingForHelp(args)) {
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    System.exit(0);
  }
  if (OSChecker.isWindows()) {
    LOGGER.error(""String_Node_Str"");
    System.exit(-5);
  }
  if (FileUtils.getConfigurationFilePath(args) == null) {
    LOGGER.info(""String_Node_Str"");
  }
 else {
    LOGGER.info(""String_Node_Str"",FileUtils.getConfigurationFilePath(args).toString());
  }
  int pid=FileUtils.getPidFromFile(FileUtils.getPidFilePath(FileUtils.getFileAbsoultePathHash(FileUtils.getConfigurationFilePath(args))));
  if (pid < 0) {
    LOGGER.warn(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    System.exit(-1);
  }
  CLibrary.LIBC.kill(pid,15);
  LOGGER.info(""String_Node_Str"",pid);
  Configuration conf;
  try {
    conf=FileUtils.getConfiguration(args,true);
    LOGGER.info(""String_Node_Str"",conf.getLogFilePath());
  }
 catch (  ConfigurationException ex) {
    LOGGER.warn(ex.getMessage());
  }
}","public static void main(final String[] args){
  LOGGER.info(""String_Node_Str"");
  if (askingForHelp(args)) {
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    System.exit(0);
  }
  if (OSChecker.isWindows()) {
    LOGGER.error(""String_Node_Str"");
    System.exit(-5);
  }
  if (FileUtils.getConfigurationFilePath(args) == null) {
    LOGGER.info(""String_Node_Str"");
  }
 else {
    LOGGER.info(""String_Node_Str"",FileUtils.getConfigurationFilePath(args).toString());
  }
  int pid=FileUtils.getPidFromFile(FileUtils.getPidFilePath(FileUtils.getFileAbsoultePathHash(FileUtils.getConfigurationFilePath(args))));
  if (pid < 0) {
    LOGGER.warn(""String_Node_Str"");
    LOGGER.info(""String_Node_Str"");
    System.exit(-1);
  }
  CLibrary.LIBC.kill(pid,15);
  LOGGER.info(""String_Node_Str"",pid);
  Configuration conf;
  try {
    conf=FileUtils.getConfiguration(args,true);
    LOGGER.info(""String_Node_Str"",conf.getLogFilePath());
  }
 catch (  ConfigurationException ex) {
    LOGGER.warn(ex.getMessage());
  }
}"
93553,"public void deleteChunksCollection(Database db,String dbName,String bucketName){
  String chunksCollName=extractBucketName(bucketName).concat(""String_Node_Str"");
  client.getDB(dbName).getCollection(chunksCollName).drop();
}","@Override public void deleteChunksCollection(Database db,String dbName,String bucketName){
  String chunksCollName=extractBucketName(bucketName).concat(""String_Node_Str"");
  client.getDB(dbName).getCollection(chunksCollName).drop();
}"
93554,"private static DB getDatabase() throws UnknownHostException {
  Mongo mongo=new MongoClient();
  DB db=mongo.getDB(DB_NAME);
  return db;
}","private static DB getDatabase() throws UnknownHostException {
  return mongoClient.getDB(dbTmpName);
}"
93555,"@Test public void testHandleRequest() throws Exception {
  System.out.println(""String_Node_Str"");
  String url=DB_URL + ""String_Node_Str"" + BUCKET+ ""String_Node_Str""+ OID+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + url);
  Response resp=executor.execute(Request.Get(url));
  File tempFile=tempFolder.newFile(FILENAME);
  resp.saveContent(tempFile);
  assertTrue(tempFile.length() > 0);
}","@Test public void testHandleRequest() throws Exception {
  System.out.println(""String_Node_Str"");
  createFile();
  String url=dbTmpUri + ""String_Node_Str"" + BUCKET+ ""String_Node_Str""+ OID+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + url);
  Response resp=adminExecutor.execute(Request.Get(url));
  File tempFile=tempFolder.newFile(FILENAME);
  resp.saveContent(tempFile);
  assertTrue(tempFile.length() > 0);
}"
93556,"private String replaceObjectIdsInFilters(BSONObject source){
  if (source == null) {
    return null;
  }
  BasicDBObject ret=new BasicDBObject();
  source.keySet().stream().forEach((key) -> {
    Object value=source.get(key);
    if (value instanceof BSONObject) {
      ret.append(key,replaceObjectIdsInFilters((BSONObject)value));
    }
 else     if (ObjectId.isValid(value.toString())) {
      ret.append(key,new ObjectId(value.toString()));
    }
 else {
      ret.append(key,value);
    }
  }
);
  return ret.toString();
}","private void replaceObjectIdsInFilters(BSONObject source){
  if (source == null) {
    return;
  }
  source.keySet().stream().forEach((key) -> {
    Object value=source.get(key);
    if (value instanceof BSONObject) {
      replaceObjectIdsInFilters((BSONObject)value);
    }
 else     if (ObjectId.isValid(value.toString())) {
      source.put(key,new ObjectId(value.toString()));
    }
  }
);
}"
93557,"/** 
 * @param context
 * @param dbName
 * @param collName
 * @param data
 * @return
 * @throws IllegalArgumentException
 * @throws org.restheart.utils.UnsupportedDocumentIdException
 */
public String getRelationshipLink(RequestContext context,String dbName,String collName,DBObject data) throws IllegalArgumentException, UnsupportedDocumentIdException {
  Object _referenceValue=data.get(referenceField);
  Object[] ids=null;
  Object id=null;
  if (role == ROLE.OWNING) {
    if (_referenceValue == null) {
      return null;
    }
    if (type == TYPE.ONE_TO_ONE || type == TYPE.MANY_TO_ONE) {
      if (!(_referenceValue instanceof String)) {
        throw new IllegalArgumentException(""String_Node_Str"" + dbName + ""String_Node_Str""+ collName+ ""String_Node_Str""+ data.get(""String_Node_Str"")+ ""String_Node_Str""+ type.name()+ ""String_Node_Str""+ this.referenceField+ ""String_Node_Str""+ _referenceValue);
      }
      id=_referenceValue;
    }
 else {
      if (!(_referenceValue instanceof BasicDBList)) {
        throw new IllegalArgumentException(""String_Node_Str"" + dbName + ""String_Node_Str""+ collName+ ""String_Node_Str""+ data.get(""String_Node_Str"")+ ""String_Node_Str""+ type.name()+ ""String_Node_Str""+ this.referenceField+ ""String_Node_Str""+ _referenceValue);
      }
      ids=((BasicDBList)_referenceValue).toArray();
    }
  }
 else {
    id=data.get(""String_Node_Str"");
  }
  String db=(targetDb == null ? dbName : targetDb);
  if (role == ROLE.OWNING) {
    if (type == TYPE.ONE_TO_ONE || type == TYPE.MANY_TO_ONE) {
      return URLUtils.getUriWithDocId(context,db,targetCollection,id,refFieldType);
    }
 else     if (type == TYPE.ONE_TO_MANY || type == TYPE.MANY_TO_MANY) {
      return URLUtils.getUriWithFilterMany(context,db,targetCollection,referenceField,ids,RequestContext.DOC_ID_TYPE.STRING != refFieldType);
    }
  }
 else {
    if (type == TYPE.ONE_TO_ONE || type == TYPE.ONE_TO_MANY) {
      return URLUtils.getUriWithFilterOne(context,db,targetCollection,referenceField,ids,RequestContext.DOC_ID_TYPE.STRING != refFieldType);
    }
 else     if (type == TYPE.MANY_TO_ONE || type == TYPE.MANY_TO_MANY) {
      return URLUtils.getUriWithFilterManyInverse(context,db,targetCollection,referenceField,ids,RequestContext.DOC_ID_TYPE.STRING != refFieldType);
    }
  }
  LOGGER.debug(""String_Node_Str"",this,data);
  return null;
}","/** 
 * @param context
 * @param dbName
 * @param collName
 * @param data
 * @return
 * @throws IllegalArgumentException
 * @throws org.restheart.utils.UnsupportedDocumentIdException
 */
public String getRelationshipLink(RequestContext context,String dbName,String collName,DBObject data) throws IllegalArgumentException, UnsupportedDocumentIdException {
  Object _referenceValue=data.get(referenceField);
  Object[] ids=null;
  Object id=null;
  if (role == ROLE.OWNING) {
    if (_referenceValue == null) {
      return null;
    }
    if (type == TYPE.ONE_TO_ONE || type == TYPE.MANY_TO_ONE) {
      id=_referenceValue;
    }
 else {
      if (!(_referenceValue instanceof BasicDBList)) {
        throw new IllegalArgumentException(""String_Node_Str"" + dbName + ""String_Node_Str""+ collName+ ""String_Node_Str""+ data.get(""String_Node_Str"")+ ""String_Node_Str""+ type.name()+ ""String_Node_Str""+ this.referenceField+ ""String_Node_Str""+ _referenceValue);
      }
      ids=((BasicDBList)_referenceValue).toArray();
    }
  }
 else {
    id=data.get(""String_Node_Str"");
  }
  String db=(targetDb == null ? dbName : targetDb);
  if (role == ROLE.OWNING) {
    if (type == TYPE.ONE_TO_ONE || type == TYPE.MANY_TO_ONE) {
      return URLUtils.getUriWithDocId(context,db,targetCollection,id,refFieldType);
    }
 else     if (type == TYPE.ONE_TO_MANY || type == TYPE.MANY_TO_MANY) {
      return URLUtils.getUriWithFilterMany(context,db,targetCollection,ids,RequestContext.DOC_ID_TYPE.STRING != refFieldType);
    }
  }
 else {
    if (type == TYPE.ONE_TO_ONE || type == TYPE.ONE_TO_MANY) {
      return URLUtils.getUriWithFilterOne(context,db,targetCollection,referenceField,ids,RequestContext.DOC_ID_TYPE.STRING != refFieldType);
    }
 else     if (type == TYPE.MANY_TO_ONE || type == TYPE.MANY_TO_MANY) {
      return URLUtils.getUriWithFilterManyInverse(context,db,targetCollection,referenceField,ids,RequestContext.DOC_ID_TYPE.STRING != refFieldType);
    }
  }
  LOGGER.debug(""String_Node_Str"",this,data);
  return null;
}"
93558,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    content=new BasicDBObject();
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (content.get(""String_Node_Str"") != null && content.get(""String_Node_Str"") instanceof String && RequestContext.isReservedResourceDocument((String)content.get(""String_Node_Str""))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_FORBIDDEN,""String_Node_Str"");
    return;
  }
  Object docId;
  if (content.get(""String_Node_Str"") == null) {
    if (context.getDocIdType() == DOC_ID_TYPE.OBJECTID || context.getDocIdType() == DOC_ID_TYPE.STRING_OBJECTID) {
      docId=new ObjectId();
    }
 else {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + context.getDocIdType().name());
      return;
    }
  }
 else {
    try {
      docId=URLUtils.getId(content.get(""String_Node_Str""),context.getDocIdType());
    }
 catch (    UnsupportedDocumentIdException idide) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + context.getDocIdType().name());
      return;
    }
  }
  int httpCode=this.documentDAO.upsertDocumentPost(context.getDBName(),context.getCollectionName(),docId,content,etag);
  exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(context,exchange.getRequestURL(),docId));
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    content=new BasicDBObject();
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (content.get(""String_Node_Str"") != null && content.get(""String_Node_Str"") instanceof String && RequestContext.isReservedResourceDocument((String)content.get(""String_Node_Str""))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_FORBIDDEN,""String_Node_Str"");
    return;
  }
  Object docId;
  if (content.get(""String_Node_Str"") == null) {
    if (context.getDocIdType() == DOC_ID_TYPE.OBJECTID || context.getDocIdType() == DOC_ID_TYPE.STRING_OBJECTID) {
      docId=new ObjectId();
    }
 else {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + context.getDocIdType().name());
      return;
    }
  }
 else {
    try {
      URLUtils.checkId(content.get(""String_Node_Str""));
      docId=content.get(""String_Node_Str"");
    }
 catch (    UnsupportedDocumentIdException idide) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + content.get(""String_Node_Str"").getClass().getSimpleName());
      return;
    }
  }
  int httpCode=this.documentDAO.upsertDocumentPost(context.getDBName(),context.getCollectionName(),docId,content,etag);
  exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(context,exchange.getRequestURL(),docId));
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
}"
93559,"/** 
 * @param context
 * @param dbName
 * @param collName
 * @param referenceField
 * @param id
 * @param detectOids if false adds the detect_oids=false query parameter
 * @return
 */
static public String getUriWithFilterManyInverse(RequestContext context,String dbName,String collName,String referenceField,Object id,boolean detectOids) throws UnsupportedDocumentIdException {
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(""String_Node_Str"").append(referenceField).append(""String_Node_Str"").append(""String_Node_Str"").append(getIdString(id)).append(""String_Node_Str"");
  if (!detectOids) {
    sb.append(""String_Node_Str"");
  }
  return context.mapUri(sb.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
}","/** 
 * @param context
 * @param dbName
 * @param collName
 * @param referenceField
 * @param id
 * @param detectOids if false adds the detect_oids=false query parameter
 * @return
 * @throws org.restheart.utils.UnsupportedDocumentIdException
 */
static public String getUriWithFilterManyInverse(RequestContext context,String dbName,String collName,String referenceField,Object id,boolean detectOids) throws UnsupportedDocumentIdException {
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(""String_Node_Str"").append(referenceField).append(""String_Node_Str"").append(""String_Node_Str"").append(getIdString(id)).append(""String_Node_Str"");
  if (!detectOids) {
    sb.append(""String_Node_Str"");
  }
  return context.mapUri(sb.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
}"
93560,"/** 
 * @param context
 * @param dbName
 * @param collName
 * @param referenceField
 * @param ids
 * @param detectOids if false adds the detect_oids=false query parameter
 * @return
 */
static public String getUriWithFilterMany(RequestContext context,String dbName,String collName,String referenceField,Object[] ids,boolean detectOids) throws UnsupportedDocumentIdException {
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(referenceField).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(getIdsString(ids)).append(""String_Node_Str"");
  if (!detectOids) {
    sb.append(""String_Node_Str"");
  }
  return context.mapUri(sb.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
}","/** 
 * @param context
 * @param dbName
 * @param collName
 * @param ids
 * @param detectOids if false adds the detect_oids=false query parameter
 * @return
 * @throws org.restheart.utils.UnsupportedDocumentIdException
 */
static public String getUriWithFilterMany(RequestContext context,String dbName,String collName,Object[] ids,boolean detectOids) throws UnsupportedDocumentIdException {
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(dbName).append(""String_Node_Str"").append(collName).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(getIdsString(ids)).append(""String_Node_Str"");
  if (!detectOids) {
    sb.append(""String_Node_Str"");
  }
  return context.mapUri(sb.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
}"
93561,"@Test public void testGetUriWithFilterManyString(){
  System.out.println(""String_Node_Str"");
  Object[] ids=new Object[]{1,20.0f,""String_Node_Str""};
  RequestContext context=prepareRequestContext();
  String expResult=""String_Node_Str"";
  String result;
  try {
    result=URLUtils.getUriWithFilterMany(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ids,false);
    assertEquals(expResult,result);
  }
 catch (  UnsupportedDocumentIdException ex) {
    fail(ex.getMessage());
  }
}","@Test public void testGetUriWithFilterManyString(){
  System.out.println(""String_Node_Str"");
  Object[] ids=new Object[]{1,20.0f,""String_Node_Str""};
  RequestContext context=prepareRequestContext();
  String expResult=""String_Node_Str"";
  String result;
  try {
    result=URLUtils.getUriWithFilterMany(context,""String_Node_Str"",""String_Node_Str"",ids,false);
    assertEquals(expResult,result);
  }
 catch (  UnsupportedDocumentIdException ex) {
    fail(ex.getMessage());
  }
}"
93562,"@Test public void testGetUriWithFilterMany(){
  System.out.println(""String_Node_Str"");
  Object[] ids=new Object[]{1,20.0f,""String_Node_Str""};
  RequestContext context=prepareRequestContext();
  String expResult=""String_Node_Str"";
  String result;
  try {
    result=URLUtils.getUriWithFilterMany(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ids,true);
    assertEquals(expResult,result);
  }
 catch (  UnsupportedDocumentIdException ex) {
    fail(ex.getMessage());
  }
}","@Test public void testGetUriWithFilterMany(){
  System.out.println(""String_Node_Str"");
  Object[] ids=new Object[]{1,20.0f,""String_Node_Str""};
  RequestContext context=prepareRequestContext();
  String expResult=""String_Node_Str"";
  String result;
  try {
    result=URLUtils.getUriWithFilterMany(context,""String_Node_Str"",""String_Node_Str"",ids,true);
    assertEquals(expResult,result);
  }
 catch (  UnsupportedDocumentIdException ex) {
    fail(ex.getMessage());
  }
}"
93563,"/** 
 * @param exchange
 * @param dbName
 * @param collName
 * @param docId
 * @param content
 * @param requestEtag
 * @return
 */
@Override public int upsertDocumentPost(HttpServerExchange exchange,String dbName,String collName,Object documentId,DBObject content,ObjectId requestEtag){
  DB db=client.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  content.put(""String_Node_Str"",now.toString());
  Object _idInContent=content.get(""String_Node_Str"");
  content.removeField(""String_Node_Str"");
  if (_idInContent == null) {
    content.put(""String_Node_Str"",documentId);
    coll.insert(content);
    exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(exchange.getRequestURL(),documentId.toString()).toString());
    return HttpStatus.SC_CREATED;
  }
 else {
    exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(exchange.getRequestURL(),_idInContent.toString()).toString());
  }
  BasicDBObject idQuery=new BasicDBObject(""String_Node_Str"",documentId);
  DBObject oldDocument=coll.findAndModify(idQuery,null,null,false,content,false,true);
  if (oldDocument != null) {
    Object oldTimestamp=oldDocument.get(""String_Node_Str"");
    if (oldTimestamp == null) {
      oldTimestamp=now.toString();
      LOGGER.warn(""String_Node_Str"",dbName,collName,_idInContent.toString());
    }
    BasicDBObject createdContent=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
    createdContent.markAsPartialObject();
    coll.update(idQuery,new BasicDBObject(""String_Node_Str"",createdContent),true,false);
    return optimisticCheckEtag(coll,oldDocument,requestEtag,HttpStatus.SC_OK);
  }
 else {
    return HttpStatus.SC_CREATED;
  }
}","/** 
 * @param dbName
 * @param collName
 * @param docId
 * @param content
 * @param requestEtag
 * @return
 */
@Override public int upsertDocumentPost(String dbName,String collName,Object documentId,DBObject content,ObjectId requestEtag){
  DB db=client.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  content.put(""String_Node_Str"",now.toString());
  Object _idInContent=content.get(""String_Node_Str"");
  content.removeField(""String_Node_Str"");
  if (_idInContent == null) {
    content.put(""String_Node_Str"",documentId);
    coll.insert(content);
    return HttpStatus.SC_CREATED;
  }
  BasicDBObject idQuery=new BasicDBObject(""String_Node_Str"",documentId);
  DBObject oldDocument=coll.findAndModify(idQuery,null,null,false,content,false,true);
  if (oldDocument != null) {
    Object oldTimestamp=oldDocument.get(""String_Node_Str"");
    if (oldTimestamp == null) {
      oldTimestamp=now.toString();
      LOGGER.warn(""String_Node_Str"",dbName,collName,_idInContent.toString());
    }
    BasicDBObject createdContent=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
    createdContent.markAsPartialObject();
    coll.update(idQuery,new BasicDBObject(""String_Node_Str"",createdContent),true,false);
    return optimisticCheckEtag(coll,oldDocument,requestEtag,HttpStatus.SC_OK);
  }
 else {
    return HttpStatus.SC_CREATED;
  }
}"
93564,"int upsertDocumentPost(HttpServerExchange exchange,String dbName,String collName,Object documentId,DBObject content,ObjectId requestEtag);","int upsertDocumentPost(String dbName,String collName,Object documentId,DBObject content,ObjectId requestEtag);"
93565,"/** 
 * @return the docIdType
 */
public URLUtils.DOC_ID_TYPE getDocIdType(){
  return docIdType;
}","/** 
 * @return the docIdType
 */
public DOC_ID_TYPE getDocIdType(){
  return docIdType;
}"
93566,"/** 
 * @param docIdType the docIdType to set
 */
public void setDocIdType(URLUtils.DOC_ID_TYPE docIdType){
  this.docIdType=docIdType;
}","/** 
 * @param docIdType the docIdType to set
 */
public void setDocIdType(DOC_ID_TYPE docIdType){
  this.docIdType=docIdType;
}"
93567,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    content=new BasicDBObject();
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (content.get(""String_Node_Str"") != null && content.get(""String_Node_Str"") instanceof String && RequestContext.isReservedResourceDocument((String)content.get(""String_Node_Str""))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_FORBIDDEN,""String_Node_Str"");
    return;
  }
  Object docId;
  if (content.get(""String_Node_Str"") == null) {
    if (context.getDocIdType() == URLUtils.DOC_ID_TYPE.OBJECTID || context.getDocIdType() == URLUtils.DOC_ID_TYPE.STRING_OBJECTID) {
      docId=new ObjectId();
    }
 else {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + context.getDocIdType().name());
      return;
    }
  }
 else {
    try {
      docId=URLUtils.getId(content.get(""String_Node_Str""),context.getDocIdType());
    }
 catch (    IllegalDocumentIdException idide) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + context.getDocIdType().name());
      return;
    }
  }
  int httpCode=this.documentDAO.upsertDocumentPost(exchange,context.getDBName(),context.getCollectionName(),docId,content,etag);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    content=new BasicDBObject();
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (content.get(""String_Node_Str"") != null && content.get(""String_Node_Str"") instanceof String && RequestContext.isReservedResourceDocument((String)content.get(""String_Node_Str""))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_FORBIDDEN,""String_Node_Str"");
    return;
  }
  Object docId;
  if (content.get(""String_Node_Str"") == null) {
    if (context.getDocIdType() == DOC_ID_TYPE.OBJECTID || context.getDocIdType() == DOC_ID_TYPE.STRING_OBJECTID) {
      docId=new ObjectId();
    }
 else {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + context.getDocIdType().name());
      return;
    }
  }
 else {
    try {
      docId=URLUtils.getId(content.get(""String_Node_Str""),context.getDocIdType());
    }
 catch (    IllegalDocumentIdException idide) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + context.getDocIdType().name());
      return;
    }
  }
  int httpCode=this.documentDAO.upsertDocumentPost(context.getDBName(),context.getCollectionName(),docId,content,etag);
  exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(context,exchange.getRequestURL(),docId));
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
}"
93568,"/** 
 * @param href
 * @param exchange
 * @param context
 * @param data
 * @return
 * @throws IllegalQueryParamenterException
 */
public static Representation getDocument(String href,HttpServerExchange exchange,RequestContext context,DBObject data) throws IllegalQueryParamenterException {
  Representation rep;
  Object id=data.get(""String_Node_Str"");
  if (id == null) {
    rep=new Representation(""String_Node_Str"");
  }
 else   if (id instanceof Integer) {
    rep=new Representation(href + ""String_Node_Str"" + DOC_ID_TYPE.INT);
  }
 else   if (id instanceof Long) {
    rep=new Representation(href + ""String_Node_Str"" + DOC_ID_TYPE.LONG);
  }
 else   if (id instanceof Float) {
    rep=new Representation(href + ""String_Node_Str"" + DOC_ID_TYPE.FLOAT);
  }
 else   if (id instanceof Double) {
    rep=new Representation(href + ""String_Node_Str"" + DOC_ID_TYPE.DOUBLE);
  }
 else {
    rep=new Representation(""String_Node_Str"");
    rep.addWarning(""String_Node_Str"" + id.getClass().getSimpleName());
  }
  rep.addProperty(""String_Node_Str"",context.getType().name());
  data.keySet().stream().forEach((key) -> rep.addProperty(key,data.get(key)));
  TreeMap<String,String> links;
  links=getRelationshipsLinks(rep,context,data);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  String requestPath=URLUtils.removeTrailingSlashes(exchange.getRequestPath());
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",false),true);
  return rep;
}","/** 
 * @param href
 * @param exchange
 * @param context
 * @param data
 * @return
 * @throws IllegalQueryParamenterException
 */
public static Representation getDocument(String href,HttpServerExchange exchange,RequestContext context,DBObject data) throws IllegalQueryParamenterException {
  Representation rep;
  Object id=data.get(""String_Node_Str"");
  if (id == null) {
    rep=new Representation(""String_Node_Str"");
  }
 else   if (id instanceof String || id instanceof ObjectId) {
    rep=new Representation(href);
  }
 else   if (id instanceof Integer) {
    rep=new Representation(href + ""String_Node_Str"" + DOC_ID_TYPE.INT);
  }
 else   if (id instanceof Long) {
    rep=new Representation(href + ""String_Node_Str"" + DOC_ID_TYPE.LONG);
  }
 else   if (id instanceof Float) {
    rep=new Representation(href + ""String_Node_Str"" + DOC_ID_TYPE.FLOAT);
  }
 else   if (id instanceof Double) {
    rep=new Representation(href + ""String_Node_Str"" + DOC_ID_TYPE.DOUBLE);
  }
 else {
    rep=new Representation(""String_Node_Str"");
    rep.addWarning(""String_Node_Str"" + id.getClass().getSimpleName());
  }
  rep.addProperty(""String_Node_Str"",context.getType().name());
  data.keySet().stream().forEach((key) -> rep.addProperty(key,data.get(key)));
  TreeMap<String,String> links;
  links=getRelationshipsLinks(rep,context,data);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  String requestPath=URLUtils.removeTrailingSlashes(exchange.getRequestPath());
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtils.getParentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",false),true);
  return rep;
}"
93569,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.OPTIONS || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (unsupportedContentType(contentTypes)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ Representation.JSON_MEDIA_TYPE+ ""String_Node_Str""+ Representation.APP_FORM_URLENCODED_TYPE+ ""String_Node_Str""+ Representation.MULTIPART_FORM_DATA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  if (content == null) {
    context.setContent(null);
  }
 else {
    content.keySet().stream().filter(key -> key.startsWith(""String_Node_Str"") && !key.equals(""String_Node_Str"")).forEach(key -> {
      keysToRemove.add(key);
    }
);
    keysToRemove.stream().map(keyToRemove -> {
      content.removeField(keyToRemove);
      return keyToRemove;
    }
).forEach(keyToRemove -> {
      context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
    }
);
    if (context.isDetectObjectIds())     HALUtils.replaceStringsWithObjectIds(content);
    context.setContent(content);
  }
  next.handleRequest(exchange,context);
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.OPTIONS || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (unsupportedContentType(contentTypes)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ Representation.JSON_MEDIA_TYPE+ ""String_Node_Str""+ Representation.APP_FORM_URLENCODED_TYPE+ ""String_Node_Str""+ Representation.MULTIPART_FORM_DATA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  if (content == null) {
    context.setContent(null);
  }
 else {
    content.keySet().stream().filter(key -> key.startsWith(""String_Node_Str"") && !key.equals(""String_Node_Str"")).forEach(key -> {
      keysToRemove.add(key);
    }
);
    keysToRemove.stream().map(keyToRemove -> {
      content.removeField(keyToRemove);
      return keyToRemove;
    }
).forEach(keyToRemove -> {
      context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
    }
);
    if (context.isDetectObjectIds()) {
      Object keepId=null;
      if (context.getDocIdType() == RequestContext.DOC_ID_TYPE.STRING) {
        keepId=content.removeField(""String_Node_Str"");
      }
      HALUtils.replaceStringsWithObjectIds(content);
      if (keepId != null) {
        content.put(""String_Node_Str"",keepId);
      }
    }
    context.setContent(content);
  }
  next.handleRequest(exchange,context);
}"
93570,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(SC,exchange,context);
  }
 else {
    exchange.setResponseCode(SC);
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  final CollectionDAO collectionDAO=new CollectionDAO();
  int httpCode=collectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93571,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    content=new BasicDBObject();
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  boolean updating=context.getCollectionProps() != null;
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,updating,false);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(SC,exchange,context);
  }
 else {
    exchange.setResponseCode(SC);
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    content=new BasicDBObject();
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  boolean updating=context.getCollectionProps() != null;
  final CollectionDAO collectionDAO=new CollectionDAO();
  int httpCode=collectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,updating,false);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(httpCode,exchange,context);
  }
 else {
    exchange.setResponseCode(httpCode);
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93572,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId oid;
  String sid;
  if (ObjectId.isValid(context.getDocumentId())) {
    sid=null;
    oid=new ObjectId(context.getDocumentId());
  }
 else {
    sid=context.getDocumentId();
    oid=null;
  }
  BasicDBObject query;
  if (oid != null) {
    query=new BasicDBObject(""String_Node_Str"",oid);
  }
 else {
    query=new BasicDBObject(""String_Node_Str"",sid);
  }
  DBObject document=CollectionDAO.getCollection(context.getDBName(),context.getCollectionName()).findOne(query);
  if (document == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"");
    return;
  }
  Object etag=document.get(""String_Node_Str"");
  if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
    ObjectId _etag=new ObjectId(""String_Node_Str"" + etag);
    document.put(""String_Node_Str"",Instant.ofEpochSecond(_etag.getTimestamp()).toString());
    if (RequestHelper.checkReadEtag(exchange,etag.toString())) {
      ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_MODIFIED);
      return;
    }
  }
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  ResponseHelper.injectEtagHeader(exchange,document);
  exchange.setResponseCode(HttpStatus.SC_OK);
  DocumentRepresentationFactory.sendDocument(requestPath,exchange,context,document);
  exchange.endExchange();
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId oid;
  String sid;
  if (ObjectId.isValid(context.getDocumentId())) {
    sid=null;
    oid=new ObjectId(context.getDocumentId());
  }
 else {
    sid=context.getDocumentId();
    oid=null;
  }
  BasicDBObject query;
  if (oid != null) {
    query=new BasicDBObject(""String_Node_Str"",oid);
  }
 else {
    query=new BasicDBObject(""String_Node_Str"",sid);
  }
  final CollectionDAO collectionDAO=new CollectionDAO();
  DBObject document=collectionDAO.getCollection(context.getDBName(),context.getCollectionName()).findOne(query);
  if (document == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"");
    return;
  }
  Object etag=document.get(""String_Node_Str"");
  if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
    ObjectId _etag=new ObjectId(""String_Node_Str"" + etag);
    document.put(""String_Node_Str"",Instant.ofEpochSecond(_etag.getTimestamp()).toString());
    if (RequestHelper.checkReadEtag(exchange,etag.toString())) {
      ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_MODIFIED);
      return;
    }
  }
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  ResponseHelper.injectEtagHeader(exchange,document);
  exchange.setResponseCode(HttpStatus.SC_OK);
  DocumentRepresentationFactory.sendDocument(requestPath,exchange,context,document);
  exchange.endExchange();
}"
93573,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName() != null && context.getCollectionName() != null) {
    DBObject collProps;
    if (!LocalCachesSingleton.isEnabled()) {
      collProps=CollectionDAO.getCollectionProps(context.getDBName(),context.getCollectionName());
      if (collProps != null) {
        collProps.put(""String_Node_Str"",false);
      }
 else       if (!(context.getType() == RequestContext.TYPE.COLLECTION && context.getMethod() == RequestContext.METHOD.PUT) && context.getType() != RequestContext.TYPE.ROOT && context.getType() != RequestContext.TYPE.DB) {
        ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"");
        return;
      }
    }
 else {
      collProps=LocalCachesSingleton.getInstance().getCollectionProps(context.getDBName(),context.getCollectionName());
    }
    if (collProps == null && !(context.getType() == RequestContext.TYPE.COLLECTION && context.getMethod() == RequestContext.METHOD.PUT) && context.getType() != RequestContext.TYPE.ROOT && context.getType() != RequestContext.TYPE.DB) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"");
      return;
    }
    context.setCollectionProps(collProps);
  }
  next.handleRequest(exchange,context);
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName() != null && context.getCollectionName() != null) {
    DBObject collProps;
    if (!LocalCachesSingleton.isEnabled()) {
      final CollectionDAO collectionDAO=new CollectionDAO();
      collProps=collectionDAO.getCollectionProps(context.getDBName(),context.getCollectionName());
      if (collProps != null) {
        collProps.put(""String_Node_Str"",false);
      }
 else       if (!(context.getType() == RequestContext.TYPE.COLLECTION && context.getMethod() == RequestContext.METHOD.PUT) && context.getType() != RequestContext.TYPE.ROOT && context.getType() != RequestContext.TYPE.DB) {
        ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"");
        return;
      }
    }
 else {
      collProps=LocalCachesSingleton.getInstance().getCollectionProps(context.getDBName(),context.getCollectionName());
    }
    if (collProps == null && !(context.getType() == RequestContext.TYPE.COLLECTION && context.getMethod() == RequestContext.METHOD.PUT) && context.getType() != RequestContext.TYPE.ROOT && context.getType() != RequestContext.TYPE.DB) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"");
      return;
    }
    context.setCollectionProps(collProps);
  }
  next.handleRequest(exchange,context);
}"
93574,"@Override public Optional<DBObject> load(String key) throws Exception {
  String[] dbNameAndCollectionName=key.split(SEPARATOR);
  return Optional.ofNullable(CollectionDAO.getCollectionProps(dbNameAndCollectionName[0],dbNameAndCollectionName[1]));
}","@Override public Optional<DBObject> load(String key) throws Exception {
  String[] dbNameAndCollectionName=key.split(SEPARATOR);
  return Optional.ofNullable(collectionDAO.getCollectionProps(dbNameAndCollectionName[0],dbNameAndCollectionName[1]));
}"
93575,"private void setup(){
  if (!initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  CacheBuilder builder=CacheBuilder.newBuilder();
  builder.maximumSize(maxCacheSize);
  if (ttl > 0) {
    builder.expireAfterWrite(ttl,TimeUnit.MILLISECONDS);
  }
  if (enabled) {
    this.dbPropsCache=builder.build(new CacheLoader<String,Optional<DBObject>>(){
      @Override public Optional<DBObject> load(      String key) throws Exception {
        return Optional.ofNullable(DBDAO.getDbProps(key));
      }
    }
);
    this.collectionPropsCache=builder.build(new CacheLoader<String,Optional<DBObject>>(){
      @Override public Optional<DBObject> load(      String key) throws Exception {
        String[] dbNameAndCollectionName=key.split(SEPARATOR);
        return Optional.ofNullable(CollectionDAO.getCollectionProps(dbNameAndCollectionName[0],dbNameAndCollectionName[1]));
      }
    }
);
  }
}","private void setup(){
  if (!initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  CacheBuilder builder=CacheBuilder.newBuilder();
  builder.maximumSize(maxCacheSize);
  if (ttl > 0) {
    builder.expireAfterWrite(ttl,TimeUnit.MILLISECONDS);
  }
  if (enabled) {
    this.dbPropsCache=builder.build(new CacheLoader<String,Optional<DBObject>>(){
      @Override public Optional<DBObject> load(      String key) throws Exception {
        return Optional.ofNullable(DBDAO.getDbProps(key));
      }
    }
);
    this.collectionPropsCache=builder.build(new CacheLoader<String,Optional<DBObject>>(){
      final CollectionDAO collectionDAO=new CollectionDAO();
      @Override public Optional<DBObject> load(      String key) throws Exception {
        String[] dbNameAndCollectionName=key.split(SEPARATOR);
        return Optional.ofNullable(collectionDAO.getCollectionProps(dbNameAndCollectionName[0],dbNameAndCollectionName[1]));
      }
    }
);
  }
}"
93576,"private void createTestData(){
  DBDAO.upsertDB(dbName,dbProps,new ObjectId(),false);
  CollectionDAO.upsertCollection(dbName,collection1Name,coll1Props,new ObjectId(),false,false);
  CollectionDAO.upsertCollection(dbName,collection2Name,coll2Props,new ObjectId(),false,false);
  CollectionDAO.upsertCollection(dbName,docsCollectionName,docsCollectionProps,new ObjectId(),false,false);
  for (  String index : docsCollectionIndexesStrings) {
    IndexDAO.createIndex(dbName,docsCollectionName,((DBObject)JSON.parse(index)),null);
  }
  final DocumentDAO documentDAO=new DocumentDAO();
  documentDAO.put(new PutDocumentEntity(dbName,collection1Name,document1Id,document1Props,new ObjectId(),false));
  documentDAO.put(new PutDocumentEntity(dbName,collection2Name,document2Id,document2Props,new ObjectId(),false));
  for (  String doc : docsPropsStrings) {
    documentDAO.put(new PutDocumentEntity(dbName,docsCollectionName,new ObjectId().toString(),((DBObject)JSON.parse(doc)),new ObjectId(),false));
  }
  LOG.info(""String_Node_Str"");
}","private void createTestData(){
  DBDAO.upsertDB(dbName,dbProps,new ObjectId(),false);
  final CollectionDAO collectionDAO=new CollectionDAO();
  collectionDAO.upsertCollection(dbName,collection1Name,coll1Props,new ObjectId(),false,false);
  collectionDAO.upsertCollection(dbName,collection2Name,coll2Props,new ObjectId(),false,false);
  collectionDAO.upsertCollection(dbName,docsCollectionName,docsCollectionProps,new ObjectId(),false,false);
  for (  String index : docsCollectionIndexesStrings) {
    IndexDAO.createIndex(dbName,docsCollectionName,((DBObject)JSON.parse(index)),null);
  }
  final DocumentDAO documentDAO=new DocumentDAO();
  documentDAO.put(new PutDocumentEntity(dbName,collection1Name,document1Id,document1Props,new ObjectId(),false));
  documentDAO.put(new PutDocumentEntity(dbName,collection2Name,document2Id,document2Props,new ObjectId(),false));
  for (  String doc : docsPropsStrings) {
    documentDAO.put(new PutDocumentEntity(dbName,docsCollectionName,new ObjectId().toString(),((DBObject)JSON.parse(doc)),new ObjectId(),false));
  }
  LOG.info(""String_Node_Str"");
}"
93577,"/** 
 */
public void dbdirect(){
  DBCollection dbcoll=CollectionDAO.getCollection(db,coll);
  Deque<String> _filter;
  if (filter == null) {
    _filter=null;
  }
 else {
    _filter=new ArrayDeque<>();
    _filter.add(filter);
  }
  ArrayList<DBObject> data;
  try {
    data=CollectionDAO.getCollectionData(dbcoll,page,pagesize,null,_filter,DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY.NONE);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  assertNotNull(data);
  assertFalse(data.isEmpty());
  if (printData) {
    System.out.println(data);
  }
}","/** 
 */
public void dbdirect(){
  final CollectionDAO collectionDAO=new CollectionDAO();
  DBCollection dbcoll=collectionDAO.getCollection(db,coll);
  Deque<String> _filter;
  if (filter == null) {
    _filter=null;
  }
 else {
    _filter=new ArrayDeque<>();
    _filter.add(filter);
  }
  ArrayList<DBObject> data;
  try {
    data=collectionDAO.getCollectionData(dbcoll,page,pagesize,null,_filter,DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY.NONE);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  assertNotNull(data);
  assertFalse(data.isEmpty());
  if (printData) {
    System.out.println(data);
  }
}"
93578,"/** 
 * given a mapped uri (/some/mapping/coll) returns the canonical uri (/db/coll) URLs are mapped to mongodb resources by using the mongo-mounts configuration properties
 * @param mappedUri
 * @return
 */
public final String unmapUri(String mappedUri){
  String ret=URLUtilis.removeTrailingSlashes(mappedUri);
  if (this.whatUri.equals(""String_Node_Str"") && !this.whereUri.equals(SLASH)) {
    ret=ret.replaceFirst(""String_Node_Str"" + this.whereUri,""String_Node_Str"");
  }
 else {
    ret=URLUtilis.removeTrailingSlashes(ret.replaceFirst(""String_Node_Str"" + this.whereUri,this.whatUri));
  }
  if (ret.isEmpty()) {
    ret=SLASH;
  }
  return ret;
}","/** 
 * given a mapped uri (/some/mapping/coll) returns the canonical uri (/db/coll) URLs are mapped to mongodb resources by using the mongo-mounts configuration properties
 * @param mappedUri
 * @return
 */
public final String unmapUri(String mappedUri){
  String ret=URLUtilis.removeTrailingSlashes(mappedUri);
  if (whatUri.equals(""String_Node_Str"")) {
    if (!this.whereUri.equals(SLASH)) {
      ret=ret.replaceFirst(""String_Node_Str"" + this.whereUri,""String_Node_Str"");
    }
  }
 else {
    ret=URLUtilis.removeTrailingSlashes(ret.replaceFirst(""String_Node_Str"" + this.whereUri,this.whatUri));
  }
  if (ret.isEmpty()) {
    ret=SLASH;
  }
  return ret;
}"
93579,"/** 
 * given a canonical uri (/db/coll) returns the mapped uri (/db/coll) relative to this context URLs are mapped to mongodb resources by using the mongo-mounts configuration properties
 * @param unmappedUri
 * @return
 */
public final String mapUri(String unmappedUri){
  String ret=URLUtilis.removeTrailingSlashes(unmappedUri);
  if (this.whatUri.equals(""String_Node_Str"") && !this.whereUri.equals(SLASH)) {
    ret=this.whereUri + unmappedUri;
  }
 else {
    ret=URLUtilis.removeTrailingSlashes(ret.replaceFirst(""String_Node_Str"" + this.whatUri,this.whereUri));
  }
  if (ret.isEmpty()) {
    ret=SLASH;
  }
  return ret;
}","/** 
 * given a canonical uri (/db/coll) returns the mapped uri (/db/coll) relative to this context URLs are mapped to mongodb resources by using the mongo-mounts configuration properties
 * @param unmappedUri
 * @return
 */
public final String mapUri(String unmappedUri){
  String ret=URLUtilis.removeTrailingSlashes(unmappedUri);
  if (whatUri.equals(""String_Node_Str"")) {
    if (!this.whereUri.equals(SLASH)) {
      return this.whereUri + unmappedUri;
    }
  }
 else {
    ret=URLUtilis.removeTrailingSlashes(ret.replaceFirst(""String_Node_Str"" + this.whatUri,this.whereUri));
  }
  if (ret.isEmpty()) {
    ret=SLASH;
  }
  return ret;
}"
93580,"/** 
 * Returs the DBCursor of the collection applying sorting and filtering.
 * @param coll the mongodb DBCollection object
 * @param sortBy the Deque collection of fields to use for sorting (prependfield name with - for descending sorting)
 * @param filters the filters to apply. it is a Deque collection of mongodbquery conditions.
 * @return
 * @throws JSONParseException
 */
protected static DBCursor getCollectionDBCursor(DBCollection coll,Deque<String> sortBy,Deque<String> filters) throws JSONParseException {
  DBObject sort=new BasicDBObject();
  if (sortBy == null || sortBy.isEmpty()) {
    sort.put(""String_Node_Str"",-1);
  }
 else {
    sortBy.stream().forEach((s) -> {
      String _s=s.trim();
      _s=_s.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (_s.startsWith(""String_Node_Str"")) {
        sort.put(_s.substring(1),-1);
      }
 else       if (_s.startsWith(""String_Node_Str"")) {
        sort.put(_s.substring(1),1);
      }
 else {
        sort.put(_s,1);
      }
    }
);
  }
  final BasicDBObject query=new BasicDBObject(DOCUMENTS_QUERY);
  if (filters != null) {
    filters.stream().forEach((    String f) -> {
      BSONObject filterQuery=(BSONObject)JSON.parse(f);
      replaceObjectIds(filterQuery);
      query.putAll(filterQuery);
    }
);
  }
  return coll.find(query).sort(sort);
}","/** 
 * Returs the DBCursor of the collection applying sorting and filtering.
 * @param coll the mongodb DBCollection object
 * @param sortBy the Deque collection of fields to use for sorting (prependfield name with - for descending sorting)
 * @param filters the filters to apply. it is a Deque collection of mongodbquery conditions.
 * @return
 * @throws JSONParseException
 */
protected static DBCursor getCollectionDBCursor(DBCollection coll,Deque<String> sortBy,Deque<String> filters) throws JSONParseException {
  DBObject sort=new BasicDBObject();
  if (sortBy == null || sortBy.isEmpty()) {
    sort.put(""String_Node_Str"",-1);
  }
 else {
    sortBy.stream().forEach((s) -> {
      String _s=s.trim();
      _s=_s.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (_s.startsWith(""String_Node_Str"")) {
        sort.put(_s.substring(1),-1);
      }
 else       if (_s.startsWith(""String_Node_Str"")) {
        sort.put(_s.substring(1),1);
      }
 else {
        sort.put(_s,1);
      }
    }
);
  }
  final BasicDBObject query=new BasicDBObject(DOCUMENTS_QUERY);
  if (filters != null) {
    filters.stream().forEach((    String f) -> {
      BSONObject filterQuery=(BSONObject)JSON.parse(f);
      HALUtils.replaceStringsWithObjectIds(filterQuery);
      query.putAll(filterQuery);
    }
);
  }
  return coll.find(query).sort(sort);
}"
93581,"/** 
 * @param exchange
 * @param dbName
 * @param collName
 * @param content
 * @param requestEtag
 * @return the HttpStatus code to retrun
 */
public static int upsertDocumentPost(HttpServerExchange exchange,String dbName,String collName,DBObject content,ObjectId requestEtag){
  DB db=DBDAO.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  content.put(""String_Node_Str"",now.toString());
  Object _id=content.get(""String_Node_Str"");
  content.removeField(""String_Node_Str"");
  if (_id == null) {
    ObjectId id=new ObjectId();
    content.put(""String_Node_Str"",id);
    coll.insert(content);
    exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(exchange.getRequestURL(),id.toString()).toString());
    return HttpStatus.SC_CREATED;
  }
  BasicDBObject idQuery=new BasicDBObject(""String_Node_Str"",getId(""String_Node_Str"" + _id));
  DBObject oldDocument=coll.findAndModify(idQuery,null,null,false,content,false,true);
  if (oldDocument != null) {
    Object oldTimestamp=oldDocument.get(""String_Node_Str"");
    if (oldTimestamp == null) {
      oldTimestamp=now.toString();
      logger.warn(""String_Node_Str"",dbName,collName,_id.toString());
    }
    BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
    createdContet.markAsPartialObject();
    coll.update(idQuery,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
    return optimisticCheckEtag(coll,oldDocument,requestEtag,HttpStatus.SC_OK);
  }
 else {
    return HttpStatus.SC_CREATED;
  }
}","/** 
 * @param exchange
 * @param dbName
 * @param collName
 * @param content
 * @param requestEtag
 * @return the HttpStatus code to retrun
 */
public static int upsertDocumentPost(HttpServerExchange exchange,String dbName,String collName,DBObject content,ObjectId requestEtag){
  DB db=DBDAO.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  content.put(""String_Node_Str"",now.toString());
  Object _id=content.get(""String_Node_Str"");
  content.removeField(""String_Node_Str"");
  if (_id == null) {
    ObjectId id=new ObjectId();
    content.put(""String_Node_Str"",id);
    coll.insert(content);
    exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(exchange.getRequestURL(),id.toString()).toString());
    return HttpStatus.SC_CREATED;
  }
 else {
    exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(exchange.getRequestURL(),_id.toString()).toString());
  }
  BasicDBObject idQuery=new BasicDBObject(""String_Node_Str"",getId(""String_Node_Str"" + _id));
  DBObject oldDocument=coll.findAndModify(idQuery,null,null,false,content,false,true);
  if (oldDocument != null) {
    Object oldTimestamp=oldDocument.get(""String_Node_Str"");
    if (oldTimestamp == null) {
      oldTimestamp=now.toString();
      logger.warn(""String_Node_Str"",dbName,collName,_id.toString());
    }
    BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
    createdContet.markAsPartialObject();
    coll.update(idQuery,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
    return optimisticCheckEtag(coll,oldDocument,requestEtag,HttpStatus.SC_OK);
  }
 else {
    return HttpStatus.SC_CREATED;
  }
}"
93582,"/** 
 * @param props
 */
public void addProperties(DBObject props){
  if (props == null) {
    return;
  }
  properties.putAll(props);
}","/** 
 * @param props
 */
public void addProperties(DBObject props){
  if (props == null) {
    return;
  }
  HALUtils.replaceObjectIdsWithStrings(props);
  properties.putAll(props);
}"
93583,"/** 
 * @param key
 * @param value
 */
public void addProperty(String key,Object value){
  properties.append(key,value);
}","/** 
 * @param key
 * @param value
 */
public void addProperty(String key,Object value){
  if (value instanceof ObjectId) {
    properties.append(key,value.toString());
  }
 else   if (value instanceof BSONObject) {
    HALUtils.replaceObjectIdsWithStrings((BSONObject)value);
    properties.append(key,value);
  }
 else {
    properties.append(key,value);
  }
}"
93584,"/** 
 * @param exchange
 * @param context
 * @param embeddedData
 * @param size
 * @return
 * @throws IllegalQueryParamenterException
 */
static public Representation getCollection(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=exchange.getQueryString() == null || exchange.getQueryString().isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + URLUtilis.decodeQueryString(exchange.getQueryString());
  Representation rep=new Representation(requestPath + queryString);
  rep.addProperty(""String_Node_Str"",context.getType().name());
  DBObject collProps=context.getCollectionProps();
  if (collProps != null) {
    HALUtils.addData(rep,collProps);
  }
  if (size >= 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedDocuments(embeddedData,requestPath,exchange,context,rep);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}","/** 
 * @param exchange
 * @param context
 * @param embeddedData
 * @param size
 * @return
 * @throws IllegalQueryParamenterException
 */
static public Representation getCollection(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=exchange.getQueryString() == null || exchange.getQueryString().isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + URLUtilis.decodeQueryString(exchange.getQueryString());
  Representation rep=new Representation(requestPath + queryString);
  rep.addProperty(""String_Node_Str"",context.getType().name());
  DBObject collProps=context.getCollectionProps();
  if (collProps != null) {
    rep.addProperties(collProps);
  }
  if (size >= 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedDocuments(embeddedData,requestPath,exchange,context,rep);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}"
93585,"/** 
 * @param exchange
 * @param context
 * @param embeddedData
 * @param size
 * @throws IllegalQueryParamenterException
 */
static public void sendHal(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=exchange.getQueryString() == null || exchange.getQueryString().isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + URLUtilis.decodeQueryString(exchange.getQueryString());
  Representation rep=new Representation(requestPath + queryString);
  rep.addProperty(""String_Node_Str"",context.getType().name());
  DBObject dbProps=context.getDbProps();
  if (dbProps != null) {
    HALUtils.addData(rep,dbProps);
  }
  if (size >= 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedCollections(embeddedData,requestPath,rep);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",false),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}","/** 
 * @param exchange
 * @param context
 * @param embeddedData
 * @param size
 * @throws IllegalQueryParamenterException
 */
static public void sendHal(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=exchange.getQueryString() == null || exchange.getQueryString().isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"" + URLUtilis.decodeQueryString(exchange.getQueryString());
  Representation rep=new Representation(requestPath + queryString);
  rep.addProperty(""String_Node_Str"",context.getType().name());
  DBObject dbProps=context.getDbProps();
  if (dbProps != null) {
    rep.addProperties(dbProps);
  }
  if (size >= 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedCollections(embeddedData,requestPath,rep);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",false),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}"
93586,"/** 
 * @param href
 * @param exchange
 * @param context
 * @param data
 * @return
 * @throws IllegalQueryParamenterException
 */
public static Representation getDocument(String href,HttpServerExchange exchange,RequestContext context,DBObject data) throws IllegalQueryParamenterException {
  Representation rep=new Representation(href);
  rep.addProperty(""String_Node_Str"",context.getType().name());
  data.keySet().stream().forEach((key) -> {
    Object value=data.get(key);
    if (value instanceof ObjectId) {
      value=value.toString();
    }
    rep.addProperty(key,value);
  }
);
  TreeMap<String,String> links;
  links=getRelationshipsLinks(context,data);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",false),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}","/** 
 * @param href
 * @param exchange
 * @param context
 * @param data
 * @return
 * @throws IllegalQueryParamenterException
 */
public static Representation getDocument(String href,HttpServerExchange exchange,RequestContext context,DBObject data) throws IllegalQueryParamenterException {
  Representation rep=new Representation(href);
  rep.addProperty(""String_Node_Str"",context.getType().name());
  data.keySet().stream().forEach((key) -> rep.addProperty(key,data.get(key)));
  TreeMap<String,String> links;
  links=getRelationshipsLinks(context,data);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  if (context.isParentAccessible()) {
    rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  }
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.RESTHEART_ONLINE_DOC_URL + ""String_Node_Str"",false),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}"
93587,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    content=new BasicDBObject();
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  String id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",getId(id));
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_ACCEPTABLE);
    logger.warn(""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  int SC=DocumentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,false);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(SC,exchange,context);
  }
 else {
    exchange.setResponseCode(SC);
  }
  exchange.endExchange();
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    content=new BasicDBObject();
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  String id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",getId(id));
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  int SC=DocumentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,false);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    sendWarnings(SC,exchange,context);
  }
 else {
    exchange.setResponseCode(SC);
  }
  exchange.endExchange();
}"
93588,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.OPTIONS || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (contentTypes == null || contentTypes.isEmpty() || contentTypes.stream().noneMatch(ct -> ct.startsWith(Representation.HAL_JSON_MEDIA_TYPE) || ct.startsWith(JSON_MEDIA_TYPE))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ JSON_MEDIA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  if (content == null) {
    context.setContent(null);
  }
 else {
    content.keySet().stream().filter(key -> key.startsWith(""String_Node_Str"") && !key.equals(""String_Node_Str"")).forEach(key -> {
      keysToRemove.add(key);
    }
);
    keysToRemove.stream().map(keyToRemove -> {
      content.removeField(keyToRemove);
      return keyToRemove;
    }
).forEach(keyToRemove -> {
      context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
    }
);
    context.setContent(content);
  }
  next.handleRequest(exchange,context);
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.OPTIONS || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (contentTypes == null || contentTypes.isEmpty() || contentTypes.stream().noneMatch(ct -> ct.startsWith(Representation.HAL_JSON_MEDIA_TYPE) || ct.startsWith(JSON_MEDIA_TYPE))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ JSON_MEDIA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  if (content == null) {
    context.setContent(null);
  }
 else {
    content.keySet().stream().filter(key -> key.startsWith(""String_Node_Str"") && !key.equals(""String_Node_Str"")).forEach(key -> {
      keysToRemove.add(key);
    }
);
    keysToRemove.stream().map(keyToRemove -> {
      content.removeField(keyToRemove);
      return keyToRemove;
    }
).forEach(keyToRemove -> {
      context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
    }
);
    HALUtils.replaceStringsWithObjectIds(content);
    context.setContent(content);
  }
  next.handleRequest(exchange,context);
}"
93589,"/** 
 */
public void dbdirect(){
  DBCollection dbcoll=CollectionDAO.getCollection(db,coll);
  Deque<String> _filter;
  if (filter == null) {
    _filter=null;
  }
 else {
    _filter=new ArrayDeque<>();
    _filter.add(filter);
  }
  ArrayList<DBObject> data;
  try {
    data=CollectionDAO.getCollectionData(dbcoll,page,100,null,_filter,DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY.NONE);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  assertNotNull(data);
  assertFalse(data.isEmpty());
  if (printData) {
    System.out.println(data);
  }
}","/** 
 */
public void dbdirect(){
  DBCollection dbcoll=CollectionDAO.getCollection(db,coll);
  Deque<String> _filter;
  if (filter == null) {
    _filter=null;
  }
 else {
    _filter=new ArrayDeque<>();
    _filter.add(filter);
  }
  ArrayList<DBObject> data;
  try {
    data=CollectionDAO.getCollectionData(dbcoll,page,pagesize,null,_filter,DBCursorPool.EAGER_CURSOR_ALLOCATION_POLICY.NONE);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
  assertNotNull(data);
  assertFalse(data.isEmpty());
  if (printData) {
    System.out.println(data);
  }
}"
93590,"/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId oid;
  String sid;
  if (ObjectId.isValid(context.getDocumentId())) {
    sid=null;
    oid=new ObjectId(context.getDocumentId());
  }
 else {
    sid=context.getDocumentId();
    oid=null;
  }
  BasicDBObject query;
  if (oid != null) {
    query=new BasicDBObject(""String_Node_Str"",oid);
  }
 else {
    query=new BasicDBObject(""String_Node_Str"",sid);
  }
  DBObject document=CollectionDAO.getCollection(context.getDBName(),context.getCollectionName()).findOne(query);
  if (document == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"");
    return;
  }
  Object etag=document.get(""String_Node_Str"");
  if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
    ObjectId _etag=new ObjectId(""String_Node_Str"" + etag);
    document.put(""String_Node_Str"",Instant.ofEpochSecond(_etag.getTimestamp()).toString());
    if (false && RequestHelper.checkReadEtag(exchange,etag.toString())) {
      ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_MODIFIED);
      return;
    }
  }
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  ResponseHelper.injectEtagHeader(exchange,document);
  exchange.setResponseCode(HttpStatus.SC_OK);
  DocumentRepresentationFactory.sendDocument(requestPath,exchange,context,document);
  exchange.endExchange();
}","/** 
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId oid;
  String sid;
  if (ObjectId.isValid(context.getDocumentId())) {
    sid=null;
    oid=new ObjectId(context.getDocumentId());
  }
 else {
    sid=context.getDocumentId();
    oid=null;
  }
  BasicDBObject query;
  if (oid != null) {
    query=new BasicDBObject(""String_Node_Str"",oid);
  }
 else {
    query=new BasicDBObject(""String_Node_Str"",sid);
  }
  DBObject document=CollectionDAO.getCollection(context.getDBName(),context.getCollectionName()).findOne(query);
  if (document == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"");
    return;
  }
  Object etag=document.get(""String_Node_Str"");
  if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
    ObjectId _etag=new ObjectId(""String_Node_Str"" + etag);
    document.put(""String_Node_Str"",Instant.ofEpochSecond(_etag.getTimestamp()).toString());
    if (RequestHelper.checkReadEtag(exchange,etag.toString())) {
      ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_MODIFIED);
      return;
    }
  }
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  ResponseHelper.injectEtagHeader(exchange,document);
  exchange.setResponseCode(HttpStatus.SC_OK);
  DocumentRepresentationFactory.sendDocument(requestPath,exchange,context,document);
  exchange.endExchange();
}"
93591,"/** 
 * Returns the number of documents in the given collection (taking into account the filters in case).
 * @param coll the mongodb DBCollection object.
 * @param filters the filters to apply. it is a Deque collection of mongodbquery conditions.
 * @return the number of documents in the given collection (taking intoaccount the filters in case)
 */
public static long getCollectionSize(DBCollection coll,Deque<String> filters){
  final BasicDBObject query=DOCUMENTS_QUERY;
  if (filters != null) {
    try {
      filters.stream().forEach(f -> {
        query.putAll((BSONObject)JSON.parse(f));
      }
);
    }
 catch (    JSONParseException jpe) {
      logger.warn(""String_Node_Str"",filters,jpe);
    }
  }
  return coll.count(query);
}","/** 
 * Returns the number of documents in the given collection (taking into account the filters in case).
 * @param coll the mongodb DBCollection object.
 * @param filters the filters to apply. it is a Deque collection of mongodbquery conditions.
 * @return the number of documents in the given collection (taking intoaccount the filters in case)
 */
public static long getCollectionSize(DBCollection coll,Deque<String> filters){
  final BasicDBObject query=new BasicDBObject(DOCUMENTS_QUERY);
  if (filters != null) {
    try {
      filters.stream().forEach(f -> {
        query.putAll((BSONObject)JSON.parse(f));
      }
);
    }
 catch (    JSONParseException jpe) {
      logger.warn(""String_Node_Str"",filters,jpe);
    }
  }
  return coll.count(query);
}"
93592,"private static void createTestData(){
  DBDAO.upsertDB(dbName,dbProps,new ObjectId(),false);
  CollectionDAO.upsertCollection(dbName,collection1Name,coll1Props,new ObjectId(),false,false);
  CollectionDAO.upsertCollection(dbName,collection2Name,coll2Props,new ObjectId(),false,false);
  CollectionDAO.upsertCollection(dbName,docsCollectionName,docsCollectionProps,new ObjectId(),false,false);
  for (  String index : docsCollectionIndexesStrings) {
    IndexDAO.createIndex(dbName,docsCollectionName,((DBObject)JSON.parse(index)),null);
  }
  DocumentDAO.upsertDocument(dbName,collection1Name,document1Id,document1Props,new ObjectId(),false);
  DocumentDAO.upsertDocument(dbName,collection2Name,document2Id,document2Props,new ObjectId(),false);
  for (  String doc : docsPropsStrings) {
    DocumentDAO.upsertDocument(dbName,docsCollectionName,new ObjectId().toString(),((DBObject)JSON.parse(doc)),new ObjectId(),false);
  }
  LOG.info(""String_Node_Str"");
}","private void createTestData(){
  DBDAO.upsertDB(dbName,dbProps,new ObjectId(),false);
  CollectionDAO.upsertCollection(dbName,collection1Name,coll1Props,new ObjectId(),false,false);
  CollectionDAO.upsertCollection(dbName,collection2Name,coll2Props,new ObjectId(),false,false);
  CollectionDAO.upsertCollection(dbName,docsCollectionName,docsCollectionProps,new ObjectId(),false,false);
  for (  String index : docsCollectionIndexesStrings) {
    IndexDAO.createIndex(dbName,docsCollectionName,((DBObject)JSON.parse(index)),null);
  }
  DocumentDAO.upsertDocument(dbName,collection1Name,document1Id,document1Props,new ObjectId(),false);
  DocumentDAO.upsertDocument(dbName,collection2Name,document2Id,document2Props,new ObjectId(),false);
  for (  String doc : docsPropsStrings) {
    DocumentDAO.upsertDocument(dbName,docsCollectionName,new ObjectId().toString(),((DBObject)JSON.parse(doc)),new ObjectId(),false);
  }
  LOG.info(""String_Node_Str"");
}"
93593,"@Before public void setUp(){
  initializeTestData();
}","@Before public void setUp(){
  createTestData();
}"
93594,"@After public void tearDown(){
}","@After public void tearDown(){
  deleteTestData();
}"
93595,"public void testGetCollectionSort() throws Exception {
  Response resp=adminExecutor.execute(Request.Get(docsCollectionUriSort));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
  assertNotNull(""String_Node_Str"",entity.getContentType());
  assertEquals(""String_Node_Str"",Representation.HAL_JSON_MEDIA_TYPE,entity.getContentType().getValue());
  String content=EntityUtils.toString(entity);
  assertNotNull(""String_Node_Str"",content);
  JsonObject json=null;
  try {
    json=JsonObject.readFrom(content);
  }
 catch (  Throwable t) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json);
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject embedded=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",embedded.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(embedded.get(""String_Node_Str"") instanceof JsonArray));
  JsonArray rhdoc=(JsonArray)embedded.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rhdoc.get(0));
  assertTrue(""String_Node_Str"",(rhdoc.get(0) instanceof JsonObject));
  JsonObject rhdoc0=(JsonObject)rhdoc.get(0);
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",""String_Node_Str"",rhdoc0.get(""String_Node_Str"").asString());
  JsonObject rhdoc1=(JsonObject)rhdoc.get(1);
  assertNotNull(""String_Node_Str"",rhdoc1.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",rhdoc1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",""String_Node_Str"",rhdoc1.get(""String_Node_Str"").asString());
}","@Test public void testGetCollectionSort() throws Exception {
  LOG.info(""String_Node_Str"" + docsCollectionUriSort);
  Response resp=adminExecutor.execute(Request.Get(docsCollectionUriSort));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
  assertNotNull(""String_Node_Str"",entity.getContentType());
  assertEquals(""String_Node_Str"",Representation.HAL_JSON_MEDIA_TYPE,entity.getContentType().getValue());
  String content=EntityUtils.toString(entity);
  assertNotNull(""String_Node_Str"",content);
  JsonObject json=null;
  try {
    json=JsonObject.readFrom(content);
  }
 catch (  Throwable t) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json);
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject embedded=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",embedded.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(embedded.get(""String_Node_Str"") instanceof JsonArray));
  JsonArray rhdoc=(JsonArray)embedded.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rhdoc.get(0));
  assertTrue(""String_Node_Str"",(rhdoc.get(0) instanceof JsonObject));
  JsonObject rhdoc0=(JsonObject)rhdoc.get(0);
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",""String_Node_Str"",rhdoc0.get(""String_Node_Str"").asString());
  JsonObject rhdoc1=(JsonObject)rhdoc.get(1);
  assertNotNull(""String_Node_Str"",rhdoc1.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",rhdoc1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",""String_Node_Str"",rhdoc1.get(""String_Node_Str"").asString());
}"
93596,"private void testGetCollection(URI uri) throws Exception {
  LOG.info(""String_Node_Str"" + uri);
  Response resp=adminExecutor.execute(Request.Get(uri));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
  assertNotNull(""String_Node_Str"",entity.getContentType());
  assertEquals(""String_Node_Str"",Representation.HAL_JSON_MEDIA_TYPE,entity.getContentType().getValue());
  String content=EntityUtils.toString(entity);
  assertNotNull(""String_Node_Str"",content);
  JsonObject json=null;
  try {
    json=JsonObject.readFrom(content);
    LOG.info(json.asString());
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"",t);
    fail(""String_Node_Str"" + uri);
  }
  assertNotNull(""String_Node_Str"",json);
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject embedded=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",embedded.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(embedded.get(""String_Node_Str"") instanceof JsonArray));
  JsonArray rhdoc=(JsonArray)embedded.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rhdoc.get(0));
  assertTrue(""String_Node_Str"",(rhdoc.get(0) instanceof JsonObject));
  JsonObject rhdoc0=(JsonObject)rhdoc.get(0);
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(rhdoc0.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject rhdoc0Links=(JsonObject)rhdoc0.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rhdoc0Links.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(rhdoc0Links.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject rhdb0LinksSelf=(JsonObject)rhdoc0Links.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rhdb0LinksSelf.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(rhdb0LinksSelf.get(""String_Node_Str"").isString()));
  try {
    URI _uri=new URI(rhdb0LinksSelf.get(""String_Node_Str"").asString());
  }
 catch (  URISyntaxException use) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject links=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  if (!uri.equals(collection1UriRemappedCollection)) {
    assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  }
 else {
    assertNull(""String_Node_Str"",links.get(""String_Node_Str""));
  }
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
}","private void testGetCollection(URI uri) throws Exception {
  LOG.info(""String_Node_Str"" + uri);
  Response resp=adminExecutor.execute(Request.Get(uri));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
  assertNotNull(""String_Node_Str"",entity.getContentType());
  assertEquals(""String_Node_Str"",Representation.HAL_JSON_MEDIA_TYPE,entity.getContentType().getValue());
  String content=EntityUtils.toString(entity);
  assertNotNull(content);
  JsonObject json=null;
  try {
    json=JsonObject.readFrom(content);
  }
 catch (  Throwable t) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json);
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject embedded=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",embedded.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(embedded.get(""String_Node_Str"") instanceof JsonArray));
  JsonArray rhdoc=(JsonArray)embedded.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rhdoc.get(0));
  assertTrue(""String_Node_Str"",(rhdoc.get(0) instanceof JsonObject));
  JsonObject rhdoc0=(JsonObject)rhdoc.get(0);
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(rhdoc0.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject rhdoc0Links=(JsonObject)rhdoc0.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rhdoc0Links.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(rhdoc0Links.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject rhdb0LinksSelf=(JsonObject)rhdoc0Links.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rhdb0LinksSelf.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(rhdb0LinksSelf.get(""String_Node_Str"").isString()));
  try {
    URI _uri=new URI(rhdb0LinksSelf.get(""String_Node_Str"").asString());
  }
 catch (  URISyntaxException use) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject links=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  if (!uri.equals(collection1UriRemappedCollection)) {
    assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  }
 else {
    assertNull(""String_Node_Str"",links.get(""String_Node_Str""));
  }
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
}"
93597,"public void testGetCollectionCountAndPaging() throws Exception {
  Response resp=adminExecutor.execute(Request.Get(docsCollectionUriCountAndPaging));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
  assertNotNull(""String_Node_Str"",entity.getContentType());
  assertEquals(""String_Node_Str"",Representation.HAL_JSON_MEDIA_TYPE,entity.getContentType().getValue());
  String content=EntityUtils.toString(entity);
  assertNotNull(""String_Node_Str"",content);
  JsonObject json=null;
  try {
    json=JsonObject.readFrom(content);
  }
 catch (  Throwable t) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json);
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",2,json.get(""String_Node_Str"").asInt());
  assertEquals(""String_Node_Str"",10,json.get(""String_Node_Str"").asInt());
  assertEquals(""String_Node_Str"",5,json.get(""String_Node_Str"").asInt());
  JsonObject links=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  Response respSelf=adminExecutor.execute(Request.Get(docsCollectionUriCountAndPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespSelf=respSelf.returnResponse();
  assertNotNull(""String_Node_Str"",httpRespSelf);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,httpRespSelf.getStatusLine().getStatusCode());
  Response respRhdb=adminExecutor.execute(Request.Get(docsCollectionUriCountAndPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespRhdb=respRhdb.returnResponse();
  assertNotNull(""String_Node_Str"",httpRespRhdb);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,httpRespRhdb.getStatusLine().getStatusCode());
  Response respNext=adminExecutor.execute(Request.Get(docsCollectionUriCountAndPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespNext=respNext.returnResponse();
  assertNotNull(""String_Node_Str"",httpRespNext);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,httpRespSelf.getStatusLine().getStatusCode());
  Response respPrevious=adminExecutor.execute(Request.Get(docsCollectionUriCountAndPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespPrevious=respPrevious.returnResponse();
  assertNotNull(""String_Node_Str"",httpRespPrevious);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,httpRespSelf.getStatusLine().getStatusCode());
  Response respFirst=adminExecutor.execute(Request.Get(dbUriPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse respRespFirst=respFirst.returnResponse();
  assertNotNull(""String_Node_Str"",respRespFirst);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,respRespFirst.getStatusLine().getStatusCode());
  Response respLast=adminExecutor.execute(Request.Get(dbUriPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespLast=respLast.returnResponse();
  assertNotNull(""String_Node_Str"",httpRespLast);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,httpRespLast.getStatusLine().getStatusCode());
}","@Test public void testGetCollectionCountAndPaging() throws Exception {
  LOG.info(""String_Node_Str"" + docsCollectionUriCountAndPaging);
  Response resp=adminExecutor.execute(Request.Get(docsCollectionUriCountAndPaging));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
  assertNotNull(""String_Node_Str"",entity.getContentType());
  assertEquals(""String_Node_Str"",Representation.HAL_JSON_MEDIA_TYPE,entity.getContentType().getValue());
  String content=EntityUtils.toString(entity);
  assertNotNull(""String_Node_Str"",content);
  JsonObject json=null;
  try {
    json=JsonObject.readFrom(content);
  }
 catch (  Throwable t) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  assertEquals(""String_Node_Str"",2,json.get(""String_Node_Str"").asInt());
  assertEquals(""String_Node_Str"",10,json.get(""String_Node_Str"").asInt());
  assertEquals(""String_Node_Str"",5,json.get(""String_Node_Str"").asInt());
  JsonObject links=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  Response respSelf=adminExecutor.execute(Request.Get(docsCollectionUriCountAndPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespSelf=respSelf.returnResponse();
  assertNotNull(""String_Node_Str"",httpRespSelf);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,httpRespSelf.getStatusLine().getStatusCode());
  Response respRhdb=adminExecutor.execute(Request.Get(docsCollectionUriCountAndPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespRhdb=respRhdb.returnResponse();
  assertNotNull(""String_Node_Str"",httpRespRhdb);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,httpRespRhdb.getStatusLine().getStatusCode());
  Response respNext=adminExecutor.execute(Request.Get(docsCollectionUriCountAndPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespNext=respNext.returnResponse();
  assertNotNull(""String_Node_Str"",httpRespNext);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,httpRespSelf.getStatusLine().getStatusCode());
  Response respPrevious=adminExecutor.execute(Request.Get(docsCollectionUriCountAndPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespPrevious=respPrevious.returnResponse();
  assertNotNull(""String_Node_Str"",httpRespPrevious);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,httpRespSelf.getStatusLine().getStatusCode());
  Response respFirst=adminExecutor.execute(Request.Get(dbUriPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse respRespFirst=respFirst.returnResponse();
  assertNotNull(""String_Node_Str"",respRespFirst);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,respRespFirst.getStatusLine().getStatusCode());
  Response respLast=adminExecutor.execute(Request.Get(dbUriPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespLast=respLast.returnResponse();
  assertNotNull(""String_Node_Str"",httpRespLast);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,httpRespLast.getStatusLine().getStatusCode());
}"
93598,"public void testGetCollectionPaging() throws Exception {
  Response resp=adminExecutor.execute(Request.Get(docsCollectionUriPaging));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
  assertNotNull(""String_Node_Str"",entity.getContentType());
  assertEquals(""String_Node_Str"",Representation.HAL_JSON_MEDIA_TYPE,entity.getContentType().getValue());
  String content=EntityUtils.toString(entity);
  assertNotNull(""String_Node_Str"",content);
  JsonObject json=null;
  try {
    json=JsonObject.readFrom(content);
  }
 catch (  Throwable t) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json);
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",2,json.get(""String_Node_Str"").asInt());
  JsonObject links=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",links.get(""String_Node_Str""));
  Response respSelf=adminExecutor.execute(Request.Get(docsCollectionUriPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespSelf=respSelf.returnResponse();
  assertNotNull(httpRespSelf);
  Response respDb=adminExecutor.execute(Request.Get(docsCollectionUriPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespDb=respDb.returnResponse();
  assertNotNull(httpRespDb);
  Response respNext=adminExecutor.execute(Request.Get(docsCollectionUriPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespNext=respNext.returnResponse();
  assertNotNull(httpRespNext);
}","@Test public void testGetCollectionPaging() throws Exception {
  LOG.info(""String_Node_Str"" + docsCollectionUriPaging);
  Response resp=adminExecutor.execute(Request.Get(docsCollectionUriPaging));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
  assertNotNull(""String_Node_Str"",entity.getContentType());
  assertEquals(""String_Node_Str"",Representation.HAL_JSON_MEDIA_TYPE,entity.getContentType().getValue());
  String content=EntityUtils.toString(entity);
  assertNotNull(""String_Node_Str"",content);
  JsonObject json=null;
  try {
    json=JsonObject.readFrom(content);
  }
 catch (  Throwable t) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json);
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",2,json.get(""String_Node_Str"").asInt());
  JsonObject links=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",links.get(""String_Node_Str""));
  assertNull(""String_Node_Str"",links.get(""String_Node_Str""));
  Response respSelf=adminExecutor.execute(Request.Get(docsCollectionUriPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespSelf=respSelf.returnResponse();
  assertNotNull(httpRespSelf);
  Response respDb=adminExecutor.execute(Request.Get(docsCollectionUriPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespDb=respDb.returnResponse();
  assertNotNull(httpRespDb);
  Response respNext=adminExecutor.execute(Request.Get(docsCollectionUriPaging.resolve(links.get(""String_Node_Str"").asObject().get(""String_Node_Str"").asString())));
  HttpResponse httpRespNext=respNext.returnResponse();
  assertNotNull(httpRespNext);
}"
93599,"public void testGetCollectionFilter() throws Exception {
  Response resp=adminExecutor.execute(Request.Get(docsCollectionUriFilter));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
  assertNotNull(""String_Node_Str"",entity.getContentType());
  assertEquals(""String_Node_Str"",Representation.HAL_JSON_MEDIA_TYPE,entity.getContentType().getValue());
  String content=EntityUtils.toString(entity);
  assertNotNull(""String_Node_Str"",content);
  JsonObject json=null;
  try {
    json=JsonObject.readFrom(content);
  }
 catch (  Throwable t) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json);
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",2,json.get(""String_Node_Str"").asInt());
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",2,json.get(""String_Node_Str"").asInt());
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject embedded=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",embedded.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(embedded.get(""String_Node_Str"") instanceof JsonArray));
  JsonArray rhdoc=(JsonArray)embedded.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rhdoc.get(0));
  assertTrue(""String_Node_Str"",(rhdoc.get(0) instanceof JsonObject));
  JsonObject rhdoc0=(JsonObject)rhdoc.get(0);
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",""String_Node_Str"",rhdoc0.get(""String_Node_Str"").asString());
  JsonObject rhdoc1=(JsonObject)rhdoc.get(1);
  assertNotNull(""String_Node_Str"",rhdoc1.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",rhdoc1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",""String_Node_Str"",rhdoc1.get(""String_Node_Str"").asString());
}","@Test public void testGetCollectionFilter() throws Exception {
  LOG.info(""String_Node_Str"" + docsCollectionUriFilter);
  Response resp=adminExecutor.execute(Request.Get(docsCollectionUriFilter));
  HttpResponse httpResp=resp.returnResponse();
  assertNotNull(httpResp);
  HttpEntity entity=httpResp.getEntity();
  assertNotNull(entity);
  StatusLine statusLine=httpResp.getStatusLine();
  assertNotNull(statusLine);
  assertEquals(""String_Node_Str"",HttpStatus.SC_OK,statusLine.getStatusCode());
  assertNotNull(""String_Node_Str"",entity.getContentType());
  assertEquals(""String_Node_Str"",Representation.HAL_JSON_MEDIA_TYPE,entity.getContentType().getValue());
  String content=EntityUtils.toString(entity);
  assertNotNull(""String_Node_Str"",content);
  JsonObject json=null;
  try {
    json=JsonObject.readFrom(content);
  }
 catch (  Throwable t) {
    fail(""String_Node_Str"");
  }
  assertNotNull(""String_Node_Str"",json);
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",2,json.get(""String_Node_Str"").asInt());
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",2,json.get(""String_Node_Str"").asInt());
  assertNotNull(""String_Node_Str"",json.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(json.get(""String_Node_Str"") instanceof JsonObject));
  JsonObject embedded=(JsonObject)json.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",embedded.get(""String_Node_Str""));
  assertTrue(""String_Node_Str"",(embedded.get(""String_Node_Str"") instanceof JsonArray));
  JsonArray rhdoc=(JsonArray)embedded.get(""String_Node_Str"");
  assertNotNull(""String_Node_Str"",rhdoc.get(0));
  assertTrue(""String_Node_Str"",(rhdoc.get(0) instanceof JsonObject));
  JsonObject rhdoc0=(JsonObject)rhdoc.get(0);
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",rhdoc0.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",""String_Node_Str"",rhdoc0.get(""String_Node_Str"").asString());
  JsonObject rhdoc1=(JsonObject)rhdoc.get(1);
  assertNotNull(""String_Node_Str"",rhdoc1.get(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",rhdoc1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",""String_Node_Str"",rhdoc1.get(""String_Node_Str"").asString());
}"
93600,"/** 
 * @param exchange
 * @param context
 * @param size
 * @return
 * @throws IllegalQueryParamenterException
 */
public static TreeMap<String,String> getPaginationLinks(HttpServerExchange exchange,RequestContext context,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=exchange.getQueryString();
  int page=context.getPage();
  int pagesize=context.getPagesize();
  long totalPages=0;
  if (size >= 0) {
    float _size=size + 0f;
    float _pagesize=pagesize + 0f;
    totalPages=Math.max(1,Math.round(Math.ceil(_size / _pagesize)));
  }
  TreeMap<String,String> links=new TreeMap<>();
  if (queryString == null || queryString.isEmpty()) {
    if (totalPages > 0 && page < totalPages) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
    }
  }
 else {
    String queryStringNoPagingProps=URLUtilis.getQueryStringRemovingParams(exchange,""String_Node_Str"",""String_Node_Str"");
    if (queryStringNoPagingProps == null || queryStringNoPagingProps.isEmpty()) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize);
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page > 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize));
      }
    }
 else {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      if (totalPages <= 0) {
        links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize)+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
    }
  }
  return links;
}","/** 
 * @param exchange
 * @param context
 * @param size
 * @return
 * @throws IllegalQueryParamenterException
 */
public static TreeMap<String,String> getPaginationLinks(HttpServerExchange exchange,RequestContext context,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=exchange.getQueryString();
  int page=context.getPage();
  int pagesize=context.getPagesize();
  long totalPages=0;
  if (size >= 0) {
    float _size=size + 0f;
    float _pagesize=pagesize + 0f;
    totalPages=Math.max(1,Math.round(Math.ceil(_size / _pagesize)));
  }
  TreeMap<String,String> links=new TreeMap<>();
  if (queryString == null || queryString.isEmpty()) {
    if (totalPages > 0 && page < totalPages) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
    }
  }
 else {
    String queryStringNoPagingProps=URLUtilis.getQueryStringRemovingParams(exchange,""String_Node_Str"",""String_Node_Str"");
    if (queryStringNoPagingProps == null || queryStringNoPagingProps.isEmpty()) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize);
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize));
      }
    }
 else {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      if (totalPages <= 0) {
        links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize)+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
    }
  }
  return links;
}"
93601,"public static DBObject getCollectionProps(String dbName,String collName){
  DBCollection coll=CollectionDAO.getCollection(dbName,collName);
  DBObject properties=coll.findOne(PROPS_QUERY);
  if (properties != null) {
    properties.removeField(""String_Node_Str"");
    Object etag=properties.get(""String_Node_Str"");
    if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
      ObjectId oid=new ObjectId(""String_Node_Str"" + etag);
      properties.put(""String_Node_Str"",Instant.ofEpochSecond(oid.getTimestamp()).toString());
    }
  }
  return properties;
}","public static DBObject getCollectionProps(String dbName,String collName){
  DBCollection coll=CollectionDAO.getCollection(dbName,collName);
  DBObject properties=coll.findOne(PROPS_QUERY);
  if (properties != null) {
    properties.put(""String_Node_Str"",collName);
    Object etag=properties.get(""String_Node_Str"");
    if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
      ObjectId oid=new ObjectId(""String_Node_Str"" + etag);
      properties.put(""String_Node_Str"",Instant.ofEpochSecond(oid.getTimestamp()).toString());
    }
  }
  return properties;
}"
93602,"/** 
 * @param dbName
 * @return the db props
 */
public static DBObject getDbProps(String dbName){
  if (!DBDAO.doesDbExists(dbName))   return null;
  DBCollection propscoll=CollectionDAO.getCollection(dbName,""String_Node_Str"");
  DBObject row=propscoll.findOne(METADATA_QUERY);
  if (row != null) {
    row.removeField(""String_Node_Str"");
    Object etag=row.get(""String_Node_Str"");
    if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
      ObjectId oid=new ObjectId(""String_Node_Str"" + etag);
      row.put(""String_Node_Str"",Instant.ofEpochSecond(oid.getTimestamp()).toString());
    }
  }
  return row;
}","/** 
 * @param dbName
 * @return the db props
 */
public static DBObject getDbProps(String dbName){
  if (!DBDAO.doesDbExists(dbName))   return null;
  DBCollection propscoll=CollectionDAO.getCollection(dbName,""String_Node_Str"");
  DBObject row=propscoll.findOne(METADATA_QUERY);
  if (row != null) {
    row.put(""String_Node_Str"",dbName);
    Object etag=row.get(""String_Node_Str"");
    if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
      ObjectId oid=new ObjectId(""String_Node_Str"" + etag);
      row.put(""String_Node_Str"",Instant.ofEpochSecond(oid.getTimestamp()).toString());
    }
  }
  return row;
}"
93603,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName() != null && context.getCollectionName() != null) {
    DBObject collProps;
    if (!cacheEnabled) {
      collProps=CollectionDAO.getCollectionProps(context.getDBName(),context.getCollectionName());
      if (collProps != null)       collProps.put(""String_Node_Str"",false);
    }
 else {
      LoadingCache<String,Optional<DBObject>> collectionPropsCache=LocalCachesSingleton.getInstance().getCollectionCache();
      Optional<DBObject> _collMetadata=collectionPropsCache.getIfPresent(context.getDBName() + SEPARATOR + context.getCollectionName());
      if (_collMetadata != null) {
        if (_collMetadata.isPresent()) {
          collProps=_collMetadata.get();
          collProps.put(""String_Node_Str"",true);
        }
 else         collProps=null;
      }
 else {
        try {
          _collMetadata=collectionPropsCache.getUnchecked(context.getDBName() + SEPARATOR + context.getCollectionName());
        }
 catch (        UncheckedExecutionException uex) {
          if (uex.getCause() instanceof MongoException) {
            throw (MongoException)uex.getCause();
          }
 else {
            throw uex;
          }
        }
        if (_collMetadata.isPresent()) {
          collProps=_collMetadata.get();
          collProps.put(""String_Node_Str"",false);
        }
 else         collProps=null;
      }
    }
    context.setCollectionProps(collProps);
  }
  next.handleRequest(exchange,context);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName() != null && context.getCollectionName() != null) {
    DBObject collProps;
    if (!cacheEnabled) {
      collProps=CollectionDAO.getCollectionProps(context.getDBName(),context.getCollectionName());
      if (collProps != null)       collProps.put(""String_Node_Str"",false);
 else {
        ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"" + context.getDBName() + ""String_Node_Str""+ context.getCollectionName()+ ""String_Node_Str"");
        return;
      }
    }
 else {
      LoadingCache<String,Optional<DBObject>> collectionPropsCache=LocalCachesSingleton.getInstance().getCollectionCache();
      Optional<DBObject> _collMetadata=collectionPropsCache.getIfPresent(context.getDBName() + SEPARATOR + context.getCollectionName());
      if (_collMetadata != null) {
        if (_collMetadata.isPresent()) {
          collProps=_collMetadata.get();
          collProps.put(""String_Node_Str"",true);
        }
 else         collProps=null;
      }
 else {
        try {
          _collMetadata=collectionPropsCache.getUnchecked(context.getDBName() + SEPARATOR + context.getCollectionName());
        }
 catch (        UncheckedExecutionException uex) {
          if (uex.getCause() instanceof MongoException) {
            throw (MongoException)uex.getCause();
          }
 else {
            throw uex;
          }
        }
        if (_collMetadata.isPresent()) {
          collProps=_collMetadata.get();
          collProps.put(""String_Node_Str"",false);
        }
 else         collProps=null;
      }
    }
    if (collProps == null) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"" + context.getDBName() + ""String_Node_Str""+ context.getCollectionName()+ ""String_Node_Str"");
      return;
    }
    context.setCollectionProps(collProps);
  }
  next.handleRequest(exchange,context);
}"
93604,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName() != null) {
    DBObject dbProps;
    if (!cacheEnabled) {
      dbProps=DBDAO.getDbProps(context.getDBName());
      if (dbProps != null)       dbProps.put(""String_Node_Str"",false);
    }
 else {
      LoadingCache<String,Optional<DBObject>> dbPropsCache=LocalCachesSingleton.getInstance().getDbCache();
      Optional<DBObject> _dbMetadata=dbPropsCache.getIfPresent(context.getDBName());
      if (_dbMetadata != null) {
        if (_dbMetadata.isPresent()) {
          dbProps=_dbMetadata.get();
          dbProps.put(""String_Node_Str"",true);
        }
 else         dbProps=null;
      }
 else {
        try {
          _dbMetadata=dbPropsCache.getUnchecked(context.getDBName());
        }
 catch (        UncheckedExecutionException uex) {
          if (uex.getCause() instanceof MongoException) {
            throw (MongoException)uex.getCause();
          }
 else {
            throw uex;
          }
        }
        if (_dbMetadata != null && _dbMetadata.isPresent()) {
          dbProps=_dbMetadata.get();
          dbProps.put(""String_Node_Str"",false);
        }
 else         dbProps=null;
      }
    }
    context.setDbProps(dbProps);
  }
  next.handleRequest(exchange,context);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName() != null) {
    DBObject dbProps;
    if (!cacheEnabled) {
      dbProps=DBDAO.getDbProps(context.getDBName());
      if (dbProps != null)       dbProps.put(""String_Node_Str"",false);
 else {
        ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"" + context.getDBName() + ""String_Node_Str"");
        return;
      }
    }
 else {
      LoadingCache<String,Optional<DBObject>> dbPropsCache=LocalCachesSingleton.getInstance().getDbCache();
      Optional<DBObject> _dbMetadata=dbPropsCache.getIfPresent(context.getDBName());
      if (_dbMetadata != null) {
        if (_dbMetadata.isPresent()) {
          dbProps=_dbMetadata.get();
          dbProps.put(""String_Node_Str"",true);
        }
 else         dbProps=null;
      }
 else {
        try {
          _dbMetadata=dbPropsCache.getUnchecked(context.getDBName());
        }
 catch (        UncheckedExecutionException uex) {
          if (uex.getCause() instanceof MongoException) {
            throw (MongoException)uex.getCause();
          }
 else {
            throw uex;
          }
        }
        if (_dbMetadata != null && _dbMetadata.isPresent()) {
          dbProps=_dbMetadata.get();
          dbProps.put(""String_Node_Str"",false);
        }
 else         dbProps=null;
      }
    }
    if (dbProps == null) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"" + context.getDBName() + ""String_Node_Str"");
      return;
    }
    context.setDbProps(dbProps);
  }
  next.handleRequest(exchange,context);
}"
93605,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  List<String> _dbs=client.getDatabaseNames();
  List<String> dbs=_dbs.stream().filter(db -> !RequestContext.isReservedResourceDb(db)).collect(Collectors.toList());
  if (dbs == null) {
    dbs=new ArrayList<>();
  }
  int size=dbs.size();
  Collections.sort(dbs);
  dbs=dbs.subList((context.getPage() - 1) * context.getPagesize(),(context.getPage() - 1) * context.getPagesize() + context.getPagesize() > dbs.size() ? dbs.size() : (context.getPage() - 1) * context.getPagesize() + context.getPagesize());
  List<DBObject> data=new ArrayList<>();
  dbs.stream().map((db) -> {
    DBObject props=DBDAO.getDbProps(db);
    BasicDBObject _db=new BasicDBObject(""String_Node_Str"",db);
    if (props != null)     _db.putAll((DBObject)props);
    return _db;
  }
).forEach((item) -> {
    data.add(item);
  }
);
  exchange.setResponseCode(HttpStatus.SC_OK);
  RootRepresentationFactory.sendHal(exchange,context,data,size);
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  List<String> _dbs=client.getDatabaseNames();
  List<String> dbs=_dbs.stream().filter(db -> !RequestContext.isReservedResourceDb(db)).collect(Collectors.toList());
  if (dbs == null) {
    dbs=new ArrayList<>();
  }
  int size=dbs.size();
  Collections.sort(dbs);
  dbs=dbs.subList((context.getPage() - 1) * context.getPagesize(),(context.getPage() - 1) * context.getPagesize() + context.getPagesize() > dbs.size() ? dbs.size() : (context.getPage() - 1) * context.getPagesize() + context.getPagesize());
  List<DBObject> data=new ArrayList<>();
  dbs.stream().map((db) -> {
    return DBDAO.getDbProps(db);
  }
).forEach((item) -> {
    data.add(item);
  }
);
  exchange.setResponseCode(HttpStatus.SC_OK);
  RootRepresentationFactory.sendHal(exchange,context,data,size);
  exchange.endExchange();
}"
93606,"static private Representation getDbs(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=context.getRequestUri();
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  boolean trailingSlash=requestPath.substring(requestPath.length() > 0 ? requestPath.length() - 1 : 0).equals(""String_Node_Str"");
  Representation rep=new Representation(requestPath + queryString);
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep;
          if (trailingSlash)           nrep=new Representation(requestPath + _id.toString());
 else           nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          if (d.get(""String_Node_Str"") != null && d.get(""String_Node_Str"") instanceof ObjectId)           d.put(""String_Node_Str"",((ObjectId)d.get(""String_Node_Str"")).toString());
          d.removeField(""String_Node_Str"");
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}","static private Representation getDbs(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  boolean trailingSlash=requestPath.substring(requestPath.length() > 0 ? requestPath.length() - 1 : 0).equals(""String_Node_Str"");
  Representation rep=new Representation(requestPath + queryString);
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep;
          if (trailingSlash)           nrep=new Representation(requestPath + _id.toString());
 else           nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          if (d.get(""String_Node_Str"") != null && d.get(""String_Node_Str"") instanceof ObjectId)           d.put(""String_Node_Str"",((ObjectId)d.get(""String_Node_Str"")).toString());
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}"
93607,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  List<String> _dbs=client.getDatabaseNames();
  List<String> dbs=_dbs.stream().filter(db -> !RequestContext.isReservedResourceDb(db)).collect(Collectors.toList());
  if (dbs == null) {
    dbs=new ArrayList<>();
  }
  int size=dbs.size();
  Collections.sort(dbs);
  dbs=dbs.subList((context.getPage() - 1) * context.getPagesize(),(context.getPage() - 1) * context.getPagesize() + context.getPagesize() > dbs.size() ? dbs.size() : (context.getPage() - 1) * context.getPagesize() + context.getPagesize());
  List<DBObject> data=new ArrayList<>();
  dbs.stream().map((db) -> {
    return new BasicDBObject(""String_Node_Str"",db);
  }
).forEach((item) -> {
    data.add(item);
  }
);
  exchange.setResponseCode(HttpStatus.SC_OK);
  RootRepresentationFactory.sendHal(exchange,context,data,size);
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  List<String> _dbs=client.getDatabaseNames();
  List<String> dbs=_dbs.stream().filter(db -> !RequestContext.isReservedResourceDb(db)).collect(Collectors.toList());
  if (dbs == null) {
    dbs=new ArrayList<>();
  }
  int size=dbs.size();
  Collections.sort(dbs);
  dbs=dbs.subList((context.getPage() - 1) * context.getPagesize(),(context.getPage() - 1) * context.getPagesize() + context.getPagesize() > dbs.size() ? dbs.size() : (context.getPage() - 1) * context.getPagesize() + context.getPagesize());
  List<DBObject> data=new ArrayList<>();
  dbs.stream().map((db) -> {
    DBObject props=DBDAO.getDbProps(db);
    BasicDBObject _db=new BasicDBObject(""String_Node_Str"",db);
    if (props != null)     _db.putAll((DBObject)props);
    return _db;
  }
).forEach((item) -> {
    data.add(item);
  }
);
  exchange.setResponseCode(HttpStatus.SC_OK);
  RootRepresentationFactory.sendHal(exchange,context,data,size);
  exchange.endExchange();
}"
93608,"static private Representation getDbs(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=context.getRequestUri();
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  boolean trailingSlash=requestPath.substring(requestPath.length() > 0 ? requestPath.length() - 1 : 0).equals(""String_Node_Str"");
  Representation rep=new Representation(requestPath + queryString);
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep;
          if (trailingSlash)           nrep=new Representation(requestPath + _id.toString());
 else           nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          if (d.get(""String_Node_Str"") != null && d.get(""String_Node_Str"") instanceof ObjectId)           d.put(""String_Node_Str"",((ObjectId)d.get(""String_Node_Str"")).toString());
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}","static private Representation getDbs(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=context.getRequestUri();
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  boolean trailingSlash=requestPath.substring(requestPath.length() > 0 ? requestPath.length() - 1 : 0).equals(""String_Node_Str"");
  Representation rep=new Representation(requestPath + queryString);
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep;
          if (trailingSlash)           nrep=new Representation(requestPath + _id.toString());
 else           nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          if (d.get(""String_Node_Str"") != null && d.get(""String_Node_Str"") instanceof ObjectId)           d.put(""String_Node_Str"",((ObjectId)d.get(""String_Node_Str"")).toString());
          d.removeField(""String_Node_Str"");
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}"
93609,"private static void start(){
  if (conf == null) {
    logger.error(""String_Node_Str"");
    System.exit(-1);
  }
  if (!conf.isHttpsListener() && !conf.isHttpListener() && !conf.isAjpListener()) {
    logger.error(""String_Node_Str"");
    System.exit(-1);
  }
  IdentityManager identityManager=null;
  if (conf.getIdmImpl() == null) {
    logger.warn(""String_Node_Str"");
    identityManager=null;
  }
 else {
    try {
      Object idm=Class.forName(conf.getIdmImpl()).getConstructor(Map.class).newInstance(conf.getIdmArgs());
      identityManager=(IdentityManager)idm;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",conf.getIdmImpl(),ex);
      System.exit(-3);
    }
  }
  AccessManager accessManager=null;
  if (conf.getAmImpl() == null && conf.getIdmImpl() != null) {
    logger.warn(""String_Node_Str"");
    accessManager=null;
  }
 else   if (conf.getAmImpl() == null && conf.getIdmImpl() == null) {
    logger.warn(""String_Node_Str"");
    accessManager=null;
  }
 else {
    try {
      Object am=Class.forName(conf.getAmImpl()).getConstructor(Map.class).newInstance(conf.getAmArgs());
      accessManager=(AccessManager)am;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",conf.getAmImpl(),ex);
      System.exit(-3);
    }
  }
  SSLContext sslContext=null;
  try {
    KeyManagerFactory kmf;
    KeyStore ks;
    if (conf.isUseEmbeddedKeystore()) {
      char[] storepass=""String_Node_Str"".toCharArray();
      char[] keypass=""String_Node_Str"".toCharArray();
      String storename=""String_Node_Str"";
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename),storepass);
      kmf.init(ks,keypass);
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
 else {
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      FileInputStream fis=new FileInputStream(new File(conf.getKeystoreFile()));
      ks.load(fis,conf.getKeystorePassword().toCharArray());
      kmf.init(ks,conf.getCertPassword().toCharArray());
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
  }
 catch (  KeyManagementException|NoSuchAlgorithmException|KeyStoreException|CertificateException|UnrecoverableKeyException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
catch (  FileNotFoundException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
catch (  IOException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
  try {
    browserRootFile=ResourcesExtractor.extract(""String_Node_Str"");
  }
 catch (  URISyntaxException|IOException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
  logger.info(""String_Node_Str"",browserRootFile.toString());
  Builder builder=Undertow.builder();
  if (conf.isHttpsListener()) {
    builder.addHttpsListener(conf.getHttpsPort(),conf.getHttpHost(),sslContext);
    logger.info(""String_Node_Str"",conf.getHttpsHost(),conf.getHttpsPort());
  }
  if (conf.isHttpListener()) {
    builder.addHttpListener(conf.getHttpPort(),conf.getHttpsHost());
    logger.info(""String_Node_Str"",conf.getHttpHost(),conf.getHttpPort());
  }
  if (conf.isAjpListener()) {
    builder.addAjpListener(conf.getAjpPort(),conf.getAjpHost());
    logger.info(""String_Node_Str"",conf.getAjpHost(),conf.getAjpPort());
  }
  if (conf.isLocalCacheEnabled()) {
    LocalCachesSingleton.init(conf);
    logger.info(""String_Node_Str"");
  }
  hanldersPipe=getHandlersPipe(identityManager,accessManager);
  builder.setIoThreads(conf.getIoThreads()).setWorkerThreads(conf.getWorkerThreads()).setDirectBuffers(conf.isDirectBuffers()).setBufferSize(conf.getBufferSize()).setBuffersPerRegion(conf.getBuffersPerRegion()).setHandler(hanldersPipe);
  builder.build().start();
}","private static void start(){
  if (conf == null) {
    logger.error(""String_Node_Str"");
    System.exit(-1);
  }
  if (!conf.isHttpsListener() && !conf.isHttpListener() && !conf.isAjpListener()) {
    logger.error(""String_Node_Str"");
    System.exit(-1);
  }
  IdentityManager identityManager=null;
  if (conf.getIdmImpl() == null) {
    logger.warn(""String_Node_Str"");
    identityManager=null;
  }
 else {
    try {
      Object idm=Class.forName(conf.getIdmImpl()).getConstructor(Map.class).newInstance(conf.getIdmArgs());
      identityManager=(IdentityManager)idm;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",conf.getIdmImpl(),ex);
      System.exit(-3);
    }
  }
  AccessManager accessManager=null;
  if (conf.getAmImpl() == null && conf.getIdmImpl() != null) {
    logger.warn(""String_Node_Str"");
    accessManager=null;
  }
 else   if (conf.getAmImpl() == null && conf.getIdmImpl() == null) {
    logger.warn(""String_Node_Str"");
    accessManager=null;
  }
 else {
    try {
      Object am=Class.forName(conf.getAmImpl()).getConstructor(Map.class).newInstance(conf.getAmArgs());
      accessManager=(AccessManager)am;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",conf.getAmImpl(),ex);
      System.exit(-3);
    }
  }
  SSLContext sslContext=null;
  try {
    KeyManagerFactory kmf;
    KeyStore ks;
    if (conf.isUseEmbeddedKeystore()) {
      char[] storepass=""String_Node_Str"".toCharArray();
      char[] keypass=""String_Node_Str"".toCharArray();
      String storename=""String_Node_Str"";
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename),storepass);
      kmf.init(ks,keypass);
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
 else {
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      FileInputStream fis=new FileInputStream(new File(conf.getKeystoreFile()));
      ks.load(fis,conf.getKeystorePassword().toCharArray());
      kmf.init(ks,conf.getCertPassword().toCharArray());
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
  }
 catch (  KeyManagementException|NoSuchAlgorithmException|KeyStoreException|CertificateException|UnrecoverableKeyException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
catch (  FileNotFoundException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
catch (  IOException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
  try {
    browserRootFile=ResourcesExtractor.extract(""String_Node_Str"");
  }
 catch (  URISyntaxException|IOException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
  logger.info(""String_Node_Str"",browserRootFile.toString());
  Builder builder=Undertow.builder();
  if (conf.isHttpsListener()) {
    builder.addHttpsListener(conf.getHttpsPort(),conf.getHttpHost(),sslContext);
    logger.info(""String_Node_Str"",conf.getHttpsHost(),conf.getHttpsPort());
  }
  if (conf.isHttpListener()) {
    builder.addHttpListener(conf.getHttpPort(),conf.getHttpsHost());
    logger.info(""String_Node_Str"",conf.getHttpHost(),conf.getHttpPort());
  }
  if (conf.isAjpListener()) {
    builder.addAjpListener(conf.getAjpPort(),conf.getAjpHost());
    logger.info(""String_Node_Str"",conf.getAjpHost(),conf.getAjpPort());
  }
  LocalCachesSingleton.init(conf);
  if (conf.isLocalCacheEnabled())   logger.info(""String_Node_Str"");
 else   logger.info(""String_Node_Str"");
  hanldersPipe=getHandlersPipe(identityManager,accessManager);
  builder.setIoThreads(conf.getIoThreads()).setWorkerThreads(conf.getWorkerThreads()).setDirectBuffers(conf.isDirectBuffers()).setBufferSize(conf.getBufferSize()).setBuffersPerRegion(conf.getBuffersPerRegion()).setHandler(hanldersPipe);
  builder.build().start();
}"
93610,"public Configuration(String confFilePath){
  Yaml yaml=new Yaml();
  Map<String,Object> conf=null;
  try {
    conf=(Map<String,Object>)yaml.load(new FileInputStream(new File(confFilePath)));
  }
 catch (  FileNotFoundException fnef) {
    logger.error(""String_Node_Str"");
    conf=null;
  }
catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    conf=null;
  }
  if (conf == null) {
    httpsListener=true;
    httpsPort=8443;
    httpsHost=""String_Node_Str"";
    httpListener=true;
    httpPort=8080;
    httpHost=""String_Node_Str"";
    ajpListener=false;
    ajpPort=8009;
    ajpHost=""String_Node_Str"";
    useEmbeddedKeystore=true;
    keystoreFile=null;
    keystorePassword=null;
    certPassword=null;
    mongoServers=new ArrayList<>();
    Map<String,Object> defaultMongoServer=new HashMap<>();
    defaultMongoServer.put(MONGO_HOST,""String_Node_Str"");
    defaultMongoServer.put(MONGO_PORT,27017);
    mongoServers.add(defaultMongoServer);
    mongoMounts=new ArrayList<>();
    Map<String,Object> defaultMongoMounts=new HashMap<>();
    defaultMongoMounts.put(MONGO_MOUNT_WHAT,""String_Node_Str"");
    defaultMongoMounts.put(MONGO_MOUNT_WHERE,""String_Node_Str"");
    mongoMounts.add(defaultMongoMounts);
    applicationLogicMounts=new ArrayList<>();
    mongoCredentials=null;
    idmImpl=null;
    idmArgs=null;
    amImpl=null;
    amArgs=null;
    logFilePath=URLUtilis.removeTrailingSlashes(System.getProperty(""String_Node_Str"")) + File.separator + ""String_Node_Str"";
    logToConsole=true;
    logToFile=true;
    logLevel=Level.INFO;
    localCacheEnabled=false;
    localCacheTtl=1000;
    requestsLimit=100;
    ioThreads=2;
    workerThreads=32;
    bufferSize=16384;
    buffersPerRegion=20;
    directBuffers=true;
    forceGzipEncoding=false;
  }
 else {
    httpsListener=getAsBooleanOrDefault(conf,HTTPS_LISTENER,true);
    httpsPort=getAsIntegerOrDefault(conf,HTTPS_PORT,8443);
    httpsHost=getAsStringOrDefault(conf,HTTPS_HOST,""String_Node_Str"");
    httpListener=getAsBooleanOrDefault(conf,HTTP_LISTENER,false);
    httpPort=getAsIntegerOrDefault(conf,HTTP_PORT,8080);
    httpHost=getAsStringOrDefault(conf,HTTP_HOST,""String_Node_Str"");
    ajpListener=getAsBooleanOrDefault(conf,AJP_LISTENER,false);
    ajpPort=getAsIntegerOrDefault(conf,AJP_PORT,8009);
    ajpHost=getAsStringOrDefault(conf,AJP_HOST,""String_Node_Str"");
    useEmbeddedKeystore=getAsBooleanOrDefault(conf,USE_EMBEDDED_KEYSTORE,true);
    keystoreFile=getAsStringOrDefault(conf,KEYSTORE_FILE,null);
    keystorePassword=getAsStringOrDefault(conf,KEYSTORE_PASSWORD,null);
    certPassword=getAsStringOrDefault(conf,CERT_PASSWORD,null);
    List<Map<String,Object>> mongoServersDefault=new ArrayList<>();
    Map<String,Object> defaultMongoServer=new HashMap<>();
    defaultMongoServer.put(MONGO_HOST,""String_Node_Str"");
    defaultMongoServer.put(MONGO_PORT,27017);
    mongoServersDefault.add(defaultMongoServer);
    mongoServers=getAsListOfMaps(conf,MONGO_SERVERS,mongoServersDefault);
    mongoCredentials=getAsListOfMaps(conf,MONGO_CREDENTIALS,null);
    List<Map<String,Object>> mongoMountsDefault=new ArrayList<>();
    Map<String,Object> defaultMongoMounts=new HashMap<>();
    defaultMongoMounts.put(MONGO_MOUNT_WHAT,""String_Node_Str"");
    defaultMongoMounts.put(MONGO_MOUNT_WHERE,""String_Node_Str"");
    mongoMountsDefault.add(defaultMongoMounts);
    mongoMounts=getAsListOfMaps(conf,MONGO_MOUNTS,mongoMountsDefault);
    applicationLogicMounts=getAsListOfMaps(conf,APPLICATION_LOGIC_MOUNTS,new ArrayList<>());
    Map<String,Object> idm=getAsMap(conf,IDM);
    Map<String,Object> am=getAsMap(conf,ACCESS_MANAGER);
    idmImpl=getAsStringOrDefault(idm,IMPLEMENTATION_CLASS,""String_Node_Str"");
    idmArgs=idm;
    amImpl=getAsStringOrDefault(am,IMPLEMENTATION_CLASS,""String_Node_Str"");
    amArgs=am;
    logFilePath=getAsStringOrDefault(conf,LOG_FILE_PATH,URLUtilis.removeTrailingSlashes(System.getProperty(""String_Node_Str"")) + File.separator + ""String_Node_Str"");
    String _logLevel=getAsStringOrDefault(conf,LOG_LEVEL,""String_Node_Str"");
    logToConsole=getAsBooleanOrDefault(conf,ENABLE_LOG_CONSOLE,true);
    logToFile=getAsBooleanOrDefault(conf,ENABLE_LOG_FILE,true);
    Level level;
    try {
      level=Level.valueOf(_logLevel);
    }
 catch (    Exception e) {
      logger.info(""String_Node_Str"",""String_Node_Str"",_logLevel,""String_Node_Str"");
      level=Level.WARN;
    }
    logLevel=level;
    requestsLimit=getAsIntegerOrDefault(conf,REQUESTS_LIMIT,100);
    localCacheEnabled=getAsBooleanOrDefault(conf,LOCAL_CACHE_ENABLED,false);
    localCacheTtl=getAsLongOrDefault(conf,LOCAL_CACHE_TTL,(long)1000);
    ioThreads=getAsIntegerOrDefault(conf,IO_THREADS,2);
    workerThreads=getAsIntegerOrDefault(conf,WORKER_THREADS,32);
    bufferSize=getAsIntegerOrDefault(conf,BUFFER_SIZE,16384);
    buffersPerRegion=getAsIntegerOrDefault(conf,BUFFERS_PER_REGION,20);
    directBuffers=getAsBooleanOrDefault(conf,DIRECT_BUFFERS,true);
    forceGzipEncoding=getAsBooleanOrDefault(conf,FORCE_GZIP_ENCODING,false);
  }
}","public Configuration(String confFilePath){
  Yaml yaml=new Yaml();
  Map<String,Object> conf=null;
  try {
    conf=(Map<String,Object>)yaml.load(new FileInputStream(new File(confFilePath)));
  }
 catch (  FileNotFoundException fnef) {
    logger.error(""String_Node_Str"");
    conf=null;
  }
catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    conf=null;
  }
  if (conf == null) {
    httpsListener=true;
    httpsPort=8443;
    httpsHost=""String_Node_Str"";
    httpListener=true;
    httpPort=8080;
    httpHost=""String_Node_Str"";
    ajpListener=false;
    ajpPort=8009;
    ajpHost=""String_Node_Str"";
    useEmbeddedKeystore=true;
    keystoreFile=null;
    keystorePassword=null;
    certPassword=null;
    mongoServers=new ArrayList<>();
    Map<String,Object> defaultMongoServer=new HashMap<>();
    defaultMongoServer.put(MONGO_HOST,""String_Node_Str"");
    defaultMongoServer.put(MONGO_PORT,27017);
    mongoServers.add(defaultMongoServer);
    mongoMounts=new ArrayList<>();
    Map<String,Object> defaultMongoMounts=new HashMap<>();
    defaultMongoMounts.put(MONGO_MOUNT_WHAT,""String_Node_Str"");
    defaultMongoMounts.put(MONGO_MOUNT_WHERE,""String_Node_Str"");
    mongoMounts.add(defaultMongoMounts);
    applicationLogicMounts=new ArrayList<>();
    mongoCredentials=null;
    idmImpl=null;
    idmArgs=null;
    amImpl=null;
    amArgs=null;
    logFilePath=URLUtilis.removeTrailingSlashes(System.getProperty(""String_Node_Str"")) + File.separator + ""String_Node_Str"";
    logToConsole=true;
    logToFile=true;
    logLevel=Level.INFO;
    localCacheEnabled=true;
    localCacheTtl=1000;
    requestsLimit=100;
    ioThreads=2;
    workerThreads=32;
    bufferSize=16384;
    buffersPerRegion=20;
    directBuffers=true;
    forceGzipEncoding=false;
  }
 else {
    httpsListener=getAsBooleanOrDefault(conf,HTTPS_LISTENER,true);
    httpsPort=getAsIntegerOrDefault(conf,HTTPS_PORT,8443);
    httpsHost=getAsStringOrDefault(conf,HTTPS_HOST,""String_Node_Str"");
    httpListener=getAsBooleanOrDefault(conf,HTTP_LISTENER,false);
    httpPort=getAsIntegerOrDefault(conf,HTTP_PORT,8080);
    httpHost=getAsStringOrDefault(conf,HTTP_HOST,""String_Node_Str"");
    ajpListener=getAsBooleanOrDefault(conf,AJP_LISTENER,false);
    ajpPort=getAsIntegerOrDefault(conf,AJP_PORT,8009);
    ajpHost=getAsStringOrDefault(conf,AJP_HOST,""String_Node_Str"");
    useEmbeddedKeystore=getAsBooleanOrDefault(conf,USE_EMBEDDED_KEYSTORE,true);
    keystoreFile=getAsStringOrDefault(conf,KEYSTORE_FILE,null);
    keystorePassword=getAsStringOrDefault(conf,KEYSTORE_PASSWORD,null);
    certPassword=getAsStringOrDefault(conf,CERT_PASSWORD,null);
    List<Map<String,Object>> mongoServersDefault=new ArrayList<>();
    Map<String,Object> defaultMongoServer=new HashMap<>();
    defaultMongoServer.put(MONGO_HOST,""String_Node_Str"");
    defaultMongoServer.put(MONGO_PORT,27017);
    mongoServersDefault.add(defaultMongoServer);
    mongoServers=getAsListOfMaps(conf,MONGO_SERVERS,mongoServersDefault);
    mongoCredentials=getAsListOfMaps(conf,MONGO_CREDENTIALS,null);
    List<Map<String,Object>> mongoMountsDefault=new ArrayList<>();
    Map<String,Object> defaultMongoMounts=new HashMap<>();
    defaultMongoMounts.put(MONGO_MOUNT_WHAT,""String_Node_Str"");
    defaultMongoMounts.put(MONGO_MOUNT_WHERE,""String_Node_Str"");
    mongoMountsDefault.add(defaultMongoMounts);
    mongoMounts=getAsListOfMaps(conf,MONGO_MOUNTS,mongoMountsDefault);
    applicationLogicMounts=getAsListOfMaps(conf,APPLICATION_LOGIC_MOUNTS,new ArrayList<>());
    Map<String,Object> idm=getAsMap(conf,IDM);
    Map<String,Object> am=getAsMap(conf,ACCESS_MANAGER);
    idmImpl=getAsStringOrDefault(idm,IMPLEMENTATION_CLASS,""String_Node_Str"");
    idmArgs=idm;
    amImpl=getAsStringOrDefault(am,IMPLEMENTATION_CLASS,""String_Node_Str"");
    amArgs=am;
    logFilePath=getAsStringOrDefault(conf,LOG_FILE_PATH,URLUtilis.removeTrailingSlashes(System.getProperty(""String_Node_Str"")) + File.separator + ""String_Node_Str"");
    String _logLevel=getAsStringOrDefault(conf,LOG_LEVEL,""String_Node_Str"");
    logToConsole=getAsBooleanOrDefault(conf,ENABLE_LOG_CONSOLE,true);
    logToFile=getAsBooleanOrDefault(conf,ENABLE_LOG_FILE,true);
    Level level;
    try {
      level=Level.valueOf(_logLevel);
    }
 catch (    Exception e) {
      logger.info(""String_Node_Str"",""String_Node_Str"",_logLevel,""String_Node_Str"");
      level=Level.WARN;
    }
    logLevel=level;
    requestsLimit=getAsIntegerOrDefault(conf,REQUESTS_LIMIT,100);
    localCacheEnabled=getAsBooleanOrDefault(conf,LOCAL_CACHE_ENABLED,true);
    localCacheTtl=getAsLongOrDefault(conf,LOCAL_CACHE_TTL,(long)1000);
    ioThreads=getAsIntegerOrDefault(conf,IO_THREADS,2);
    workerThreads=getAsIntegerOrDefault(conf,WORKER_THREADS,32);
    bufferSize=getAsIntegerOrDefault(conf,BUFFER_SIZE,16384);
    buffersPerRegion=getAsIntegerOrDefault(conf,BUFFERS_PER_REGION,20);
    directBuffers=getAsBooleanOrDefault(conf,DIRECT_BUFFERS,true);
    forceGzipEncoding=getAsBooleanOrDefault(conf,FORCE_GZIP_ENCODING,false);
  }
}"
93611,"static public Representation getCollection(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  Representation rep=new Representation(requestPath + queryString);
  DBObject collProps=context.getCollectionProps();
  if (collProps != null) {
    HALUtils.addData(rep,collProps);
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      for (      DBObject d : embeddedData) {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=DocumentRepresentationFactory.getDocument(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (!requestPath.equals(""String_Node_Str""))   rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}","static public Representation getCollection(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  Representation rep=new Representation(requestPath + queryString);
  DBObject collProps=context.getCollectionProps();
  if (collProps != null) {
    HALUtils.addData(rep,collProps);
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      for (      DBObject d : embeddedData) {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=DocumentRepresentationFactory.getDocument(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
          if (d.get(""String_Node_Str"") != null && d.get(""String_Node_Str"") instanceof ObjectId)           d.put(""String_Node_Str"",((ObjectId)d.get(""String_Node_Str"")).toString());
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (!requestPath.equals(""String_Node_Str""))   rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}"
93612,"static public void sendHal(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  Representation rep=new Representation(requestPath + queryString);
  DBObject dbProps=context.getDbProps();
  if (dbProps != null) {
    HALUtils.addData(rep,dbProps);
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (!requestPath.equals(""String_Node_Str""))   rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}","static public void sendHal(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  Representation rep=new Representation(requestPath + queryString);
  DBObject dbProps=context.getDbProps();
  if (dbProps != null) {
    HALUtils.addData(rep,dbProps);
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          if (d.get(""String_Node_Str"") != null && d.get(""String_Node_Str"") instanceof ObjectId)           d.put(""String_Node_Str"",((ObjectId)d.get(""String_Node_Str"")).toString());
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (!requestPath.equals(""String_Node_Str""))   rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}"
93613,"static private Representation getDbs(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=context.getRequestUri();
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  boolean trailingSlash=requestPath.substring(requestPath.length() > 0 ? requestPath.length() - 1 : 0).equals(""String_Node_Str"");
  Representation rep=new Representation(requestPath + queryString);
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep;
          if (trailingSlash)           nrep=new Representation(requestPath + _id.toString());
 else           nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}","static private Representation getDbs(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=context.getRequestUri();
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  boolean trailingSlash=requestPath.substring(requestPath.length() > 0 ? requestPath.length() - 1 : 0).equals(""String_Node_Str"");
  Representation rep=new Representation(requestPath + queryString);
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep;
          if (trailingSlash)           nrep=new Representation(requestPath + _id.toString());
 else           nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          if (d.get(""String_Node_Str"") != null && d.get(""String_Node_Str"") instanceof ObjectId)           d.put(""String_Node_Str"",((ObjectId)d.get(""String_Node_Str"")).toString());
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}"
93614,"private static void start(){
  if (conf == null) {
    logger.error(""String_Node_Str"");
    System.exit(-1);
  }
  if (!conf.isHttpsListener() && !conf.isHttpListener() && !conf.isAjpListener()) {
    logger.error(""String_Node_Str"");
    System.exit(-1);
  }
  IdentityManager identityManager=null;
  if (conf.getIdmImpl() == null) {
    logger.warn(""String_Node_Str"");
    identityManager=null;
  }
 else {
    try {
      Object idm=Class.forName(conf.getIdmImpl()).getConstructor(Map.class).newInstance(conf.getIdmArgs());
      identityManager=(IdentityManager)idm;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",conf.getIdmImpl(),ex);
      System.exit(-3);
    }
  }
  AccessManager accessManager=null;
  if (conf.getAmImpl() == null) {
    logger.warn(""String_Node_Str"");
    accessManager=null;
  }
 else {
    try {
      Object am=Class.forName(conf.getAmImpl()).getConstructor(Map.class).newInstance(conf.getAmArgs());
      accessManager=(AccessManager)am;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",conf.getAmImpl(),ex);
      System.exit(-3);
    }
  }
  SSLContext sslContext=null;
  try {
    KeyManagerFactory kmf;
    KeyStore ks;
    if (conf.isUseEmbeddedKeystore()) {
      char[] storepass=""String_Node_Str"".toCharArray();
      char[] keypass=""String_Node_Str"".toCharArray();
      String storename=""String_Node_Str"";
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename),storepass);
      kmf.init(ks,keypass);
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
 else {
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      FileInputStream fis=new FileInputStream(new File(conf.getKeystoreFile()));
      ks.load(fis,conf.getKeystorePassword().toCharArray());
      kmf.init(ks,conf.getCertPassword().toCharArray());
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
  }
 catch (  KeyManagementException|NoSuchAlgorithmException|KeyStoreException|CertificateException|UnrecoverableKeyException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
catch (  FileNotFoundException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
catch (  IOException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
  try {
    browserRootFile=ResourcesExtractor.extract(""String_Node_Str"");
  }
 catch (  URISyntaxException|IOException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
  try {
    docsRootFile=ResourcesExtractor.extract(""String_Node_Str"");
  }
 catch (  URISyntaxException|IOException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
  logger.info(""String_Node_Str"",browserRootFile.toString(),docsRootFile.toString());
  Builder builder=Undertow.builder();
  if (conf.isHttpsListener()) {
    builder.addHttpsListener(conf.getHttpsPort(),conf.getHttpHost(),sslContext);
    logger.info(""String_Node_Str"",conf.getHttpsHost(),conf.getHttpsPort());
  }
  if (conf.isHttpListener()) {
    builder.addHttpListener(conf.getHttpPort(),conf.getHttpsHost());
    logger.info(""String_Node_Str"",conf.getHttpHost(),conf.getHttpPort());
  }
  if (conf.isAjpListener()) {
    builder.addAjpListener(conf.getAjpPort(),conf.getAjpHost());
    logger.info(""String_Node_Str"",conf.getAjpHost(),conf.getAjpPort());
  }
  if (conf.isLocalCacheEnabled()) {
    LocalCachesSingleton.init(conf);
    logger.info(""String_Node_Str"");
  }
  hanldersPipe=getHandlersPipe(identityManager,accessManager);
  builder.setIoThreads(conf.getIoThreads()).setWorkerThreads(conf.getWorkerThreads()).setDirectBuffers(conf.isDirectBuffers()).setBufferSize(conf.getBufferSize()).setBuffersPerRegion(conf.getBuffersPerRegion()).setHandler(hanldersPipe);
  builder.build().start();
}","private static void start(){
  if (conf == null) {
    logger.error(""String_Node_Str"");
    System.exit(-1);
  }
  if (!conf.isHttpsListener() && !conf.isHttpListener() && !conf.isAjpListener()) {
    logger.error(""String_Node_Str"");
    System.exit(-1);
  }
  IdentityManager identityManager=null;
  if (conf.getIdmImpl() == null) {
    logger.warn(""String_Node_Str"");
    identityManager=null;
  }
 else {
    try {
      Object idm=Class.forName(conf.getIdmImpl()).getConstructor(Map.class).newInstance(conf.getIdmArgs());
      identityManager=(IdentityManager)idm;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",conf.getIdmImpl(),ex);
      System.exit(-3);
    }
  }
  AccessManager accessManager=null;
  if (conf.getAmImpl() == null && conf.getIdmImpl() != null) {
    logger.warn(""String_Node_Str"");
    accessManager=null;
  }
 else   if (conf.getAmImpl() == null && conf.getIdmImpl() == null) {
    logger.warn(""String_Node_Str"");
    accessManager=null;
  }
 else {
    try {
      Object am=Class.forName(conf.getAmImpl()).getConstructor(Map.class).newInstance(conf.getAmArgs());
      accessManager=(AccessManager)am;
    }
 catch (    ClassCastException|NoSuchMethodException|SecurityException|ClassNotFoundException|IllegalArgumentException|InstantiationException|IllegalAccessException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",conf.getAmImpl(),ex);
      System.exit(-3);
    }
  }
  SSLContext sslContext=null;
  try {
    KeyManagerFactory kmf;
    KeyStore ks;
    if (conf.isUseEmbeddedKeystore()) {
      char[] storepass=""String_Node_Str"".toCharArray();
      char[] keypass=""String_Node_Str"".toCharArray();
      String storename=""String_Node_Str"";
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename),storepass);
      kmf.init(ks,keypass);
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
 else {
      sslContext=SSLContext.getInstance(""String_Node_Str"");
      kmf=KeyManagerFactory.getInstance(""String_Node_Str"");
      ks=KeyStore.getInstance(""String_Node_Str"");
      FileInputStream fis=new FileInputStream(new File(conf.getKeystoreFile()));
      ks.load(fis,conf.getKeystorePassword().toCharArray());
      kmf.init(ks,conf.getCertPassword().toCharArray());
      sslContext.init(kmf.getKeyManagers(),null,null);
    }
  }
 catch (  KeyManagementException|NoSuchAlgorithmException|KeyStoreException|CertificateException|UnrecoverableKeyException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
catch (  FileNotFoundException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
catch (  IOException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
  try {
    browserRootFile=ResourcesExtractor.extract(""String_Node_Str"");
  }
 catch (  URISyntaxException|IOException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
  try {
    docsRootFile=ResourcesExtractor.extract(""String_Node_Str"");
  }
 catch (  URISyntaxException|IOException ex) {
    logger.error(""String_Node_Str"",ex);
    System.exit(-1);
  }
  logger.info(""String_Node_Str"",browserRootFile.toString(),docsRootFile.toString());
  Builder builder=Undertow.builder();
  if (conf.isHttpsListener()) {
    builder.addHttpsListener(conf.getHttpsPort(),conf.getHttpHost(),sslContext);
    logger.info(""String_Node_Str"",conf.getHttpsHost(),conf.getHttpsPort());
  }
  if (conf.isHttpListener()) {
    builder.addHttpListener(conf.getHttpPort(),conf.getHttpsHost());
    logger.info(""String_Node_Str"",conf.getHttpHost(),conf.getHttpPort());
  }
  if (conf.isAjpListener()) {
    builder.addAjpListener(conf.getAjpPort(),conf.getAjpHost());
    logger.info(""String_Node_Str"",conf.getAjpHost(),conf.getAjpPort());
  }
  if (conf.isLocalCacheEnabled()) {
    LocalCachesSingleton.init(conf);
    logger.info(""String_Node_Str"");
  }
  hanldersPipe=getHandlersPipe(identityManager,accessManager);
  builder.setIoThreads(conf.getIoThreads()).setWorkerThreads(conf.getWorkerThreads()).setDirectBuffers(conf.isDirectBuffers()).setBufferSize(conf.getBufferSize()).setBuffersPerRegion(conf.getBuffersPerRegion()).setHandler(hanldersPipe);
  builder.build().start();
}"
93615,"public static void main(final String[] args){
  if (args == null || args.length < 1) {
    conf=new Configuration();
  }
 else {
    conf=new Configuration(args[0]);
  }
  LoggingInitializer.setLogLevel(conf.getLogLevel());
  if (conf.isLogToFile()) {
    LoggingInitializer.startFileLogging(conf.getLogFilePath());
  }
  logger.info(""String_Node_Str"");
  String mongoHosts=conf.getMongoServers().stream().map(s -> s.get(Configuration.MONGO_HOST) + ""String_Node_Str"" + s.get(Configuration.MONGO_PORT)+ ""String_Node_Str"").reduce(""String_Node_Str"",String::concat);
  logger.info(""String_Node_Str"",mongoHosts);
  try {
    MongoDBClientSingleton.init(conf);
    logger.info(""String_Node_Str"");
    PropsFixer.fixAllMissingProps();
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    System.exit(-1);
  }
  try {
    start();
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    System.exit(-2);
  }
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      logger.info(""String_Node_Str"");
      logger.info(""String_Node_Str"");
      try {
        hanldersPipe.shutdown();
        hanldersPipe.awaitShutdown(60 * 1000);
      }
 catch (      InterruptedException ie) {
        logger.error(""String_Node_Str"",ie);
      }
      if (server != null) {
        try {
          server.stop();
        }
 catch (        Throwable t) {
          logger.error(""String_Node_Str"",t);
        }
      }
      try {
        MongoClient client=MongoDBClientSingleton.getInstance().getClient();
        client.fsync(false);
        client.close();
      }
 catch (      Throwable t) {
        logger.error(""String_Node_Str"",t);
      }
      if (browserRootFile != null) {
        try {
          ResourcesExtractor.deleteTempDir(""String_Node_Str"",browserRootFile);
        }
 catch (        URISyntaxException|IOException ex) {
          logger.error(""String_Node_Str"",browserRootFile.toString(),ex);
        }
      }
      if (docsRootFile != null) {
        try {
          ResourcesExtractor.deleteTempDir(""String_Node_Str"",docsRootFile);
        }
 catch (        URISyntaxException|IOException ex) {
          logger.error(""String_Node_Str"",docsRootFile.toString(),ex);
        }
      }
      logger.info(""String_Node_Str"");
    }
  }
);
  logger.info(""String_Node_Str"");
  if (conf.isLogToFile()) {
    logger.info(""String_Node_Str"",conf.getLogFilePath(),conf.getLogLevel());
  }
  if (!conf.isLogToConsole()) {
    logger.info(""String_Node_Str"");
    LoggingInitializer.stopConsoleLogging();
  }
 else {
    logger.info(""String_Node_Str"",conf.getLogLevel());
  }
}","public static void main(final String[] args){
  if (args == null || args.length < 1) {
    conf=new Configuration();
  }
 else {
    conf=new Configuration(args[0]);
  }
  LoggingInitializer.setLogLevel(conf.getLogLevel());
  if (conf.isLogToFile()) {
    LoggingInitializer.startFileLogging(conf.getLogFilePath());
  }
  logger.info(""String_Node_Str"");
  String mongoHosts=conf.getMongoServers().stream().map(s -> s.get(Configuration.MONGO_HOST) + ""String_Node_Str"" + s.get(Configuration.MONGO_PORT)+ ""String_Node_Str"").reduce(""String_Node_Str"",String::concat);
  logger.info(""String_Node_Str"",mongoHosts);
  try {
    MongoDBClientSingleton.init(conf);
    logger.info(""String_Node_Str"");
    PropsFixer.fixAllMissingProps();
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    System.exit(-1);
  }
  try {
    start();
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    System.exit(-2);
  }
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      logger.info(""String_Node_Str"");
      logger.info(""String_Node_Str"");
      try {
        hanldersPipe.shutdown();
        hanldersPipe.awaitShutdown(60 * 1000);
      }
 catch (      InterruptedException ie) {
        logger.error(""String_Node_Str"",ie);
      }
      if (server != null) {
        try {
          server.stop();
        }
 catch (        Throwable t) {
          logger.error(""String_Node_Str"",t);
        }
      }
      try {
        MongoClient client=MongoDBClientSingleton.getInstance().getClient();
        client.fsync(false);
        client.close();
      }
 catch (      Throwable t) {
        logger.error(""String_Node_Str"",t);
      }
      if (browserRootFile != null) {
        try {
          ResourcesExtractor.deleteTempDir(""String_Node_Str"",browserRootFile);
        }
 catch (        URISyntaxException|IOException ex) {
          logger.error(""String_Node_Str"",browserRootFile.toString(),ex);
        }
      }
      if (docsRootFile != null) {
        try {
          ResourcesExtractor.deleteTempDir(""String_Node_Str"",docsRootFile);
        }
 catch (        URISyntaxException|IOException ex) {
          logger.error(""String_Node_Str"",docsRootFile.toString(),ex);
        }
      }
      logger.info(""String_Node_Str"");
    }
  }
);
  if (conf.isLogToFile()) {
    logger.info(""String_Node_Str"",conf.getLogFilePath(),conf.getLogLevel());
  }
  if (!conf.isLogToConsole()) {
    logger.info(""String_Node_Str"");
    LoggingInitializer.stopConsoleLogging();
  }
 else {
    logger.info(""String_Node_Str"",conf.getLogLevel());
  }
  logger.info(""String_Node_Str"");
}"
93616,"/** 
 * @param dbName
 * @param colls the collections list as got from getDbCollections()
 * @param page
 * @param pagesize
 * @return the db data
 * @throws com.softinstigate.restheart.handlers.IllegalQueryParamenterException
 */
public static List<DBObject> getData(String dbName,List<String> colls,int page,int pagesize) throws IllegalQueryParamenterException {
  List<String> _colls=colls.stream().filter(coll -> !RequestContext.isReservedResourceCollection(coll)).collect(Collectors.toList());
  int size=_colls.size();
  long total_pages;
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=pagesize + 0f;
    total_pages=Math.max(1,Math.round(Math.nextUp(_size / _pagesize)));
    if (page > total_pages) {
      throw new IllegalQueryParamenterException(""String_Node_Str"" + total_pages);
    }
  }
  _colls=_colls.subList((page - 1) * pagesize,(page - 1) * pagesize + pagesize > _colls.size() ? _colls.size() : (page - 1) * pagesize + pagesize);
  List<DBObject> data=new ArrayList<>();
  _colls.stream().map((coll) -> {
    BasicDBObject properties=new BasicDBObject();
    properties.put(""String_Node_Str"",coll);
    DBObject collProperties=CollectionDAO.getCollectionProps(dbName,coll);
    if (collProperties != null)     properties.putAll(collProperties);
    return properties;
  }
).forEach((item) -> {
    data.add(item);
  }
);
  return data;
}","/** 
 * @param dbName
 * @param colls the collections list as got from getDbCollections()
 * @param page
 * @param pagesize
 * @return the db data
 * @throws com.softinstigate.restheart.handlers.IllegalQueryParamenterException
 */
public static List<DBObject> getData(String dbName,List<String> colls,int page,int pagesize) throws IllegalQueryParamenterException {
  List<String> _colls=colls.stream().filter(coll -> !RequestContext.isReservedResourceCollection(coll)).collect(Collectors.toList());
  int size=_colls.size();
  long total_pages;
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=pagesize + 0f;
    total_pages=Math.max(1,Math.round(Math.ceil(_size / _pagesize)));
    if (page > total_pages) {
      throw new IllegalQueryParamenterException(""String_Node_Str"" + total_pages);
    }
  }
  _colls=_colls.subList((page - 1) * pagesize,(page - 1) * pagesize + pagesize > _colls.size() ? _colls.size() : (page - 1) * pagesize + pagesize);
  List<DBObject> data=new ArrayList<>();
  _colls.stream().map((coll) -> {
    BasicDBObject properties=new BasicDBObject();
    properties.put(""String_Node_Str"",coll);
    DBObject collProperties=CollectionDAO.getCollectionProps(dbName,coll);
    if (collProperties != null)     properties.putAll(collProperties);
    return properties;
  }
).forEach((item) -> {
    data.add(item);
  }
);
  return data;
}"
93617,"public static TreeMap<String,String> getPaginationLinks(HttpServerExchange exchange,RequestContext context,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=exchange.getQueryString();
  int page=context.getPage();
  int pagesize=context.getPagesize();
  int totalPages=0;
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=pagesize + 0f;
    totalPages=Math.max(1,Math.round(Math.nextUp(_size / _pagesize)));
  }
  TreeMap<String,String> links=new TreeMap<>();
  if (queryString == null || queryString.isEmpty()) {
    links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
  }
 else {
    String queryStringNoPagingProps=URLUtilis.getQueryStringRemovingParams(exchange,""String_Node_Str"",""String_Node_Str"");
    if (queryStringNoPagingProps == null || queryStringNoPagingProps.isEmpty()) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize);
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page > 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize));
      }
    }
 else {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      if (totalPages <= 0) {
        links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize)+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
    }
  }
  return links;
}","public static TreeMap<String,String> getPaginationLinks(HttpServerExchange exchange,RequestContext context,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=exchange.getQueryString();
  int page=context.getPage();
  int pagesize=context.getPagesize();
  long totalPages=0;
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=pagesize + 0f;
    totalPages=Math.max(1,Math.round(Math.ceil(_size / _pagesize)));
  }
  TreeMap<String,String> links=new TreeMap<>();
  if (queryString == null || queryString.isEmpty()) {
    links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
  }
 else {
    String queryStringNoPagingProps=URLUtilis.getQueryStringRemovingParams(exchange,""String_Node_Str"",""String_Node_Str"");
    if (queryStringNoPagingProps == null || queryStringNoPagingProps.isEmpty()) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize);
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page > 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize));
      }
    }
 else {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      if (totalPages <= 0) {
        links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryStringNoPagingProps);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize)+ ""String_Node_Str""+ queryStringNoPagingProps);
      }
    }
  }
  return links;
}"
93618,"static public Representation getCollection(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  Representation rep=new Representation(requestPath + queryString);
  DBObject collProps=context.getCollectionProps();
  if (collProps != null) {
    HALUtils.addData(rep,collProps);
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.nextUp(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      for (      DBObject d : embeddedData) {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=DocumentRepresentationFactory.getDocument(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (!requestPath.equals(""String_Node_Str""))   rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}","static public Representation getCollection(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  Representation rep=new Representation(requestPath + queryString);
  DBObject collProps=context.getCollectionProps();
  if (collProps != null) {
    HALUtils.addData(rep,collProps);
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      for (      DBObject d : embeddedData) {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=DocumentRepresentationFactory.getDocument(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (!requestPath.equals(""String_Node_Str""))   rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str""));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}"
93619,"static public void sendHal(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  Representation rep=new Representation(requestPath + queryString);
  DBObject dbProps=context.getDbProps();
  if (dbProps != null) {
    HALUtils.addData(rep,dbProps);
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.nextUp(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (!requestPath.equals(""String_Node_Str""))   rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}","static public void sendHal(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(exchange.getRequestPath());
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  Representation rep=new Representation(requestPath + queryString);
  DBObject dbProps=context.getDbProps();
  if (dbProps != null) {
    HALUtils.addData(rep,dbProps);
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  if (!requestPath.equals(""String_Node_Str""))   rep.addLink(new Link(""String_Node_Str"",URLUtilis.getPerentPath(requestPath)));
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}"
93620,"static private Representation getDbs(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=context.getRequestUri();
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  boolean trailingSlash=requestPath.substring(requestPath.length() > 0 ? requestPath.length() - 1 : 0).equals(""String_Node_Str"");
  Representation rep=new Representation(requestPath + queryString);
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.nextUp(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep;
          if (trailingSlash)           nrep=new Representation(requestPath + _id.toString());
 else           nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}","static private Representation getDbs(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=context.getRequestUri();
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  boolean trailingSlash=requestPath.substring(requestPath.length() > 0 ? requestPath.length() - 1 : 0).equals(""String_Node_Str"");
  Representation rep=new Representation(requestPath + queryString);
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.ceil(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",count);
    if (!embeddedData.isEmpty()) {
      embeddedData.stream().forEach((d) -> {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep;
          if (trailingSlash)           nrep=new Representation(requestPath + _id.toString());
 else           nrep=new Representation(requestPath + ""String_Node_Str"" + _id.toString());
          nrep.addProperties(d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
);
    }
  }
  TreeMap<String,String> links;
  links=HALUtils.getPaginationLinks(exchange,context,size);
  if (links != null) {
    links.keySet().stream().forEach((k) -> {
      rep.addLink(new Link(k,links.get(k)));
    }
);
  }
  rep.addLink(new Link(""String_Node_Str"",requestPath + ""String_Node_Str"",true));
  rep.addLink(new Link(""String_Node_Str"",""String_Node_Str"",Configuration.DOC_Path + ""String_Node_Str"",true),true);
  ResponseHelper.injectWarnings(rep,exchange,context);
  return rep;
}"
93621,"/** 
 * @param dbName
 * @param collName
 * @param content
 * @param etag
 * @param patching
 * @return the HttpStatus code to retrun
 */
public static int upsertCollection(String dbName,String collName,DBObject content,ObjectId etag,boolean updating,boolean patching){
  DB db=DBDAO.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  if (patching && !updating) {
    return HttpStatus.SC_NOT_FOUND;
  }
  if (updating) {
    if (etag == null) {
      logger.warn(""String_Node_Str"",Headers.ETAG);
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
    BasicDBObject idAndEtagQuery=new BasicDBObject(""String_Node_Str"",""String_Node_Str"");
    idAndEtagQuery.append(""String_Node_Str"",etag);
    if (coll.count(idAndEtagQuery) < 1) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
  }
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.removeField(""String_Node_Str"");
  if (updating) {
    content.removeField(""String_Node_Str"");
    content.put(""String_Node_Str"",timestamp);
  }
 else {
    content.put(""String_Node_Str"",""String_Node_Str"");
    content.put(""String_Node_Str"",now.toString());
    content.put(""String_Node_Str"",timestamp);
  }
  if (patching) {
    coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",content),true,false);
    return HttpStatus.SC_OK;
  }
 else {
    DBObject old=coll.findAndModify(PROPS_QUERY,fieldsToReturn,null,false,content,false,true);
    if (old != null) {
      Object oldTimestamp=old.get(""String_Node_Str"");
      if (oldTimestamp == null) {
        oldTimestamp=now.toString();
        logger.warn(""String_Node_Str"",coll.getFullName());
      }
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
      createdContet.markAsPartialObject();
      coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_OK;
    }
 else {
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",now.toString());
      createdContet.markAsPartialObject();
      coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      initDefaultIndexes(coll);
      return HttpStatus.SC_CREATED;
    }
  }
}","/** 
 * @param dbName
 * @param collName
 * @param content
 * @param etag
 * @param updating
 * @param patching
 * @return the HttpStatus code to retrun
 */
public static int upsertCollection(String dbName,String collName,DBObject content,ObjectId etag,boolean updating,boolean patching){
  DB db=DBDAO.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  if (patching && !updating) {
    return HttpStatus.SC_NOT_FOUND;
  }
  if (updating) {
    if (etag == null) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
    BasicDBObject idAndEtagQuery=new BasicDBObject(""String_Node_Str"",""String_Node_Str"");
    idAndEtagQuery.append(""String_Node_Str"",etag);
    if (coll.count(idAndEtagQuery) < 1) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
  }
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.removeField(""String_Node_Str"");
  if (updating) {
    content.removeField(""String_Node_Str"");
    content.put(""String_Node_Str"",timestamp);
  }
 else {
    content.put(""String_Node_Str"",""String_Node_Str"");
    content.put(""String_Node_Str"",now.toString());
    content.put(""String_Node_Str"",timestamp);
  }
  if (patching) {
    coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",content),true,false);
    return HttpStatus.SC_OK;
  }
 else {
    DBObject old=coll.findAndModify(PROPS_QUERY,fieldsToReturn,null,false,content,false,true);
    if (old != null) {
      Object oldTimestamp=old.get(""String_Node_Str"");
      if (oldTimestamp == null) {
        oldTimestamp=now.toString();
        logger.warn(""String_Node_Str"",coll.getFullName());
      }
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
      createdContet.markAsPartialObject();
      coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_OK;
    }
 else {
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",now.toString());
      createdContet.markAsPartialObject();
      coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      initDefaultIndexes(coll);
      return HttpStatus.SC_CREATED;
    }
  }
}"
93622,"public static int upsertDB(String dbName,DBObject content,ObjectId etag,boolean patching){
  DB db=client.getDB(dbName);
  boolean existing=db.getCollectionNames().size() > 0;
  if (patching && !existing) {
    return HttpStatus.SC_NOT_FOUND;
  }
  DBCollection coll=db.getCollection(""String_Node_Str"");
  if (db.collectionExists(""String_Node_Str"")) {
    if (etag == null) {
      logger.warn(""String_Node_Str"",Headers.ETAG);
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
    BasicDBObject idAndEtagQuery=new BasicDBObject(""String_Node_Str"",""String_Node_Str"");
    idAndEtagQuery.append(""String_Node_Str"",etag);
    if (coll.count(idAndEtagQuery) < 1) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
  }
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  content.removeField(""String_Node_Str"");
  content.removeField(""String_Node_Str"");
  if (patching) {
    coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",content),true,false);
    return HttpStatus.SC_OK;
  }
 else {
    DBObject old=coll.findAndModify(METADATA_QUERY,fieldsToReturn,null,false,content,false,true);
    if (old != null) {
      Object oldTimestamp=old.get(""String_Node_Str"");
      if (oldTimestamp == null) {
        oldTimestamp=now.toString();
        logger.warn(""String_Node_Str"",coll.getFullName());
      }
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
      createdContet.markAsPartialObject();
      coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_OK;
    }
 else {
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",now.toString());
      createdContet.markAsPartialObject();
      coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_CREATED;
    }
  }
}","public static int upsertDB(String dbName,DBObject content,ObjectId etag,boolean patching){
  DB db=client.getDB(dbName);
  boolean existing=db.getCollectionNames().size() > 0;
  if (patching && !existing) {
    return HttpStatus.SC_NOT_FOUND;
  }
  DBCollection coll=db.getCollection(""String_Node_Str"");
  if (db.collectionExists(""String_Node_Str"")) {
    if (etag == null) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
    BasicDBObject idAndEtagQuery=new BasicDBObject(""String_Node_Str"",""String_Node_Str"");
    idAndEtagQuery.append(""String_Node_Str"",etag);
    if (coll.count(idAndEtagQuery) < 1) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
  }
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  content.removeField(""String_Node_Str"");
  content.removeField(""String_Node_Str"");
  if (patching) {
    coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",content),true,false);
    return HttpStatus.SC_OK;
  }
 else {
    DBObject old=coll.findAndModify(METADATA_QUERY,fieldsToReturn,null,false,content,false,true);
    if (old != null) {
      Object oldTimestamp=old.get(""String_Node_Str"");
      if (oldTimestamp == null) {
        oldTimestamp=now.toString();
        logger.warn(""String_Node_Str"",coll.getFullName());
      }
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
      createdContet.markAsPartialObject();
      coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_OK;
    }
 else {
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",now.toString());
      createdContet.markAsPartialObject();
      coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_CREATED;
    }
  }
}"
93623,"private static int optimisticCheckEtag(DBCollection coll,DBObject oldDocument,ObjectId requestEtag,int httpStatusIfOk){
  if (requestEtag == null) {
    logger.warn(""String_Node_Str"",Headers.ETAG);
    coll.save(oldDocument);
    return HttpStatus.SC_CONFLICT;
  }
  Object oldEtag=RequestHelper.getEtagAsObjectId(oldDocument.get(""String_Node_Str""));
  if (oldEtag == null) {
    return HttpStatus.SC_NO_CONTENT;
  }
 else {
    if (oldEtag.equals(requestEtag)) {
      return httpStatusIfOk;
    }
 else {
      coll.save(oldDocument);
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
  }
}","private static int optimisticCheckEtag(DBCollection coll,DBObject oldDocument,ObjectId requestEtag,int httpStatusIfOk){
  if (requestEtag == null) {
    coll.save(oldDocument);
    return HttpStatus.SC_CONFLICT;
  }
  Object oldEtag=RequestHelper.getEtagAsObjectId(oldDocument.get(""String_Node_Str""));
  if (oldEtag == null) {
    return HttpStatus.SC_NO_CONTENT;
  }
 else {
    if (oldEtag.equals(requestEtag)) {
      return httpStatusIfOk;
    }
 else {
      coll.save(oldDocument);
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
  }
}"
93624,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=CollectionDAO.deleteCollection(context.getDBName(),context.getCollectionName(),etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=CollectionDAO.deleteCollection(context.getDBName(),context.getCollectionName(),etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93625,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93626,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  int SC=DocumentDAO.upsertDocumentPost(exchange,context.getDBName(),context.getCollectionName(),content,etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  int SC=DocumentDAO.upsertDocumentPost(exchange,context.getDBName(),context.getCollectionName(),content,etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93627,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  boolean updating=context.getCollectionProps() != null;
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,updating,false);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  boolean updating=context.getCollectionProps() != null;
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,updating,false);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93628,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DBDAO.deleteDB(context.getDBName(),etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DBDAO.deleteDB(context.getDBName(),etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}"
93629,"/** 
 * partial update db properties
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DBDAO.upsertDB(context.getDBName(),content,etag,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}","/** 
 * partial update db properties
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int SC=DBDAO.upsertDB(context.getDBName(),content,etag,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93630,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  int SC=DBDAO.upsertDB(context.getDBName(),content,etag,false);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  int SC=DBDAO.upsertDB(context.getDBName(),content,etag,false);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}"
93631,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DocumentDAO.deleteDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int SC=DocumentDAO.deleteDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93632,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  String id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",getId(id));
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DocumentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  String id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",getId(id));
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int SC=DocumentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93633,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  String id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",getId(id));
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_ACCEPTABLE);
    logger.warn(""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  int SC=DocumentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,false);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  String id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",getId(id));
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_ACCEPTABLE);
    logger.warn(""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  int SC=DocumentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,false);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93634,"public static ObjectId getEtagAsObjectId(Object etag){
  if (etag == null)   return null;
  if (ObjectId.isValid(""String_Node_Str"" + etag))   return new ObjectId(""String_Node_Str"" + etag);
 else   return null;
}","public static ObjectId getEtagAsObjectId(Object etag){
  if (etag == null)   return null;
  if (ObjectId.isValid(""String_Node_Str"" + etag))   return new ObjectId(""String_Node_Str"" + etag);
 else   return new ObjectId();
}"
93635,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (contentTypes == null || contentTypes.isEmpty() || contentTypes.stream().noneMatch(ct -> ct.startsWith(Representation.HAL_JSON_MEDIA_TYPE) || ct.startsWith(JSON_MEDIA_TYPE))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ JSON_MEDIA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  content.keySet().stream().filter((key) -> (key.startsWith(""String_Node_Str""))).forEach((key) -> {
    keysToRemove.add(key);
  }
);
  keysToRemove.stream().map((keyToRemove) -> {
    content.removeField(keyToRemove);
    return keyToRemove;
  }
).forEach((keyToRemove) -> {
    context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
  }
);
  context.setContent(content);
  next.handleRequest(exchange,context);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (contentTypes == null || contentTypes.isEmpty() || contentTypes.stream().noneMatch(ct -> ct.startsWith(Representation.HAL_JSON_MEDIA_TYPE) || ct.startsWith(JSON_MEDIA_TYPE))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ JSON_MEDIA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  if (content == null) {
    context.setContent(null);
  }
 else {
    content.keySet().stream().filter((key) -> (key.startsWith(""String_Node_Str""))).forEach((key) -> {
      keysToRemove.add(key);
    }
);
    keysToRemove.stream().map((keyToRemove) -> {
      content.removeField(keyToRemove);
      return keyToRemove;
    }
).forEach((keyToRemove) -> {
      context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
    }
);
    context.setContent(content);
  }
  next.handleRequest(exchange,context);
}"
93636,"public static void deleteIndex(String db,String co,String indexId){
  client.getDB(db).getCollection(co).dropIndex(indexId);
}","public static int deleteIndex(String db,String co,String indexId){
  client.getDB(db).getCollection(co).dropIndex(indexId);
  return HttpStatus.SC_GONE;
}"
93637,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,CollectionDAO.deleteCollection(context.getDBName(),context.getCollectionName(),etag));
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=CollectionDAO.deleteCollection(context.getDBName(),context.getCollectionName(),etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93638,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,SC);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93639,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  int SC=DocumentDAO.upsertDocumentPost(exchange,context.getDBName(),context.getCollectionName(),content,etag);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,SC);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  int SC=DocumentDAO.upsertDocumentPost(exchange,context.getDBName(),context.getCollectionName(),content,etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93640,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  boolean updating=context.getCollectionProps() != null;
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,updating,false);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,SC);
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  boolean updating=context.getCollectionProps() != null;
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,updating,false);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93641,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,DBDAO.deleteDB(context.getDBName(),etag));
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DBDAO.deleteDB(context.getDBName(),etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}"
93642,"/** 
 * partial update db properties
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DBDAO.upsertDB(context.getDBName(),content,etag,true);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,SC);
}","/** 
 * partial update db properties
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DBDAO.upsertDB(context.getDBName(),content,etag,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93643,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  int SC=DBDAO.upsertDB(context.getDBName(),content,etag,false);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,SC);
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  int SC=DBDAO.upsertDB(context.getDBName(),content,etag,false);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}"
93644,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DocumentDAO.deleteDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),etag);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,SC);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DocumentDAO.deleteDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),etag);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93645,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  String id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",getId(id));
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DocumentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,true);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,SC);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  String id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",getId(id));
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    logger.warn(""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_CONFLICT,""String_Node_Str"" + Headers.ETAG + ""String_Node_Str"");
    logger.warn(""String_Node_Str"",Headers.ETAG);
    return;
  }
  int SC=DocumentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93646,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  String id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",getId(id));
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_ACCEPTABLE);
    logger.warn(""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  int SC=DocumentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,false);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,SC);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  DBObject content=context.getContent();
  if (content == null)   content=new BasicDBObject();
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  String id=context.getDocumentId();
  if (content.get(""String_Node_Str"") == null) {
    content.put(""String_Node_Str"",getId(id));
  }
 else   if (!content.get(""String_Node_Str"").equals(id)) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_ACCEPTABLE);
    logger.warn(""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getUpdateEtag(exchange);
  int SC=DocumentDAO.upsertDocument(context.getDBName(),context.getCollectionName(),context.getDocumentId(),content,etag,false);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93647,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  String db=context.getDBName();
  String co=context.getCollectionName();
  String id=context.getIndexId();
  if (id.startsWith(""String_Node_Str"") || id.equals(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNAUTHORIZED,id + ""String_Node_Str"");
    return;
  }
  IndexDAO.deleteIndex(db,co,id);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,HttpStatus.SC_GONE);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  String db=context.getDBName();
  String co=context.getCollectionName();
  String id=context.getIndexId();
  if (id.startsWith(""String_Node_Str"") || id.equals(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNAUTHORIZED,id + ""String_Node_Str"");
    return;
  }
  int SC=IndexDAO.deleteIndex(db,co,id);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93648,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  String db=context.getDBName();
  String co=context.getCollectionName();
  String id=context.getIndexId();
  if (id.startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  DBObject keys=(DBObject)content.get(""String_Node_Str"");
  DBObject ops=(DBObject)content.get(""String_Node_Str"");
  if (keys == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",null);
    return;
  }
  if (ops == null) {
    ops=new BasicDBObject();
  }
  ops.put(""String_Node_Str"",id);
  try {
    IndexDAO.createIndex(db,co,keys,ops);
  }
 catch (  Throwable t) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",t);
  }
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  ResponseHelper.endExchange(exchange,HttpStatus.SC_CREATED);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  String db=context.getDBName();
  String co=context.getCollectionName();
  String id=context.getIndexId();
  if (id.startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  DBObject keys=(DBObject)content.get(""String_Node_Str"");
  DBObject ops=(DBObject)content.get(""String_Node_Str"");
  if (keys == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",null);
    return;
  }
  if (ops == null) {
    ops=new BasicDBObject();
  }
  ops.put(""String_Node_Str"",id);
  try {
    IndexDAO.createIndex(db,co,keys,ops);
  }
 catch (  Throwable t) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",t);
    return;
  }
  exchange.setResponseCode(HttpStatus.SC_CREATED);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}"
93649,"public String getRelationshipLink(RequestContext context,String dbName,String collName,DBObject data) throws IllegalArgumentException {
  Object _referenceValue=data.get(referenceField);
  String reference;
  if (role == ROLE.OWNING && _referenceValue != null) {
    if (type == TYPE.ONE_TO_ONE || type == TYPE.MANY_TO_ONE) {
      if (!(_referenceValue instanceof String))       throw new IllegalArgumentException(""String_Node_Str"" + dbName + ""String_Node_Str""+ collName+ ""String_Node_Str""+ data.get(""String_Node_Str"")+ ""String_Node_Str""+ type.name()+ ""String_Node_Str""+ this.referenceField+ ""String_Node_Str""+ _referenceValue);
      reference=(String)_referenceValue;
    }
 else {
      if (!(_referenceValue instanceof BasicDBList))       throw new IllegalArgumentException(""String_Node_Str"" + dbName + ""String_Node_Str""+ collName+ ""String_Node_Str""+ data.get(""String_Node_Str"")+ ""String_Node_Str""+ type.name()+ ""String_Node_Str""+ this.referenceField+ ""String_Node_Str""+ _referenceValue);
      String[] ids=((BasicDBList)_referenceValue).toArray(new String[0]);
      for (int idx=ids.length - 1; idx >= 0; idx--) {
        ids[idx]=""String_Node_Str"" + ids[idx] + ""String_Node_Str"";
      }
      reference=Arrays.toString(ids);
    }
  }
 else {
    reference=""String_Node_Str"" + data.get(""String_Node_Str"").toString() + ""String_Node_Str"";
  }
  String db=(targetDb == null ? dbName : targetDb);
  if (role == ROLE.OWNING) {
    if (type == TYPE.ONE_TO_ONE || type == TYPE.MANY_TO_ONE) {
      return URLUtilis.getUriWithDocId(context,db,targetCollection,reference);
    }
 else     if (type == TYPE.ONE_TO_MANY || type == TYPE.MANY_TO_MANY) {
      return URLUtilis.getUriWithFilterMany(context,db,targetCollection,referenceField,reference);
    }
  }
 else {
    if (type == TYPE.ONE_TO_ONE || type == TYPE.ONE_TO_MANY) {
      return URLUtilis.getUriWithFilterOne(context,db,targetCollection,referenceField,reference);
    }
 else     if (type == TYPE.MANY_TO_ONE || type == TYPE.MANY_TO_MANY) {
      return URLUtilis.getUriWithFilterManyInverse(context,db,targetCollection,referenceField,reference);
    }
  }
  logger.debug(""String_Node_Str"",this,data);
  return null;
}","public String getRelationshipLink(RequestContext context,String dbName,String collName,DBObject data) throws IllegalArgumentException {
  Object _referenceValue=data.get(referenceField);
  String reference;
  if (role == ROLE.OWNING) {
    if (_referenceValue == null) {
      return null;
    }
    if (type == TYPE.ONE_TO_ONE || type == TYPE.MANY_TO_ONE) {
      if (!(_referenceValue instanceof String))       throw new IllegalArgumentException(""String_Node_Str"" + dbName + ""String_Node_Str""+ collName+ ""String_Node_Str""+ data.get(""String_Node_Str"")+ ""String_Node_Str""+ type.name()+ ""String_Node_Str""+ this.referenceField+ ""String_Node_Str""+ _referenceValue);
      reference=(String)_referenceValue;
    }
 else {
      if (!(_referenceValue instanceof BasicDBList))       throw new IllegalArgumentException(""String_Node_Str"" + dbName + ""String_Node_Str""+ collName+ ""String_Node_Str""+ data.get(""String_Node_Str"")+ ""String_Node_Str""+ type.name()+ ""String_Node_Str""+ this.referenceField+ ""String_Node_Str""+ _referenceValue);
      String[] ids=((BasicDBList)_referenceValue).toArray(new String[0]);
      for (int idx=ids.length - 1; idx >= 0; idx--) {
        ids[idx]=""String_Node_Str"" + ids[idx] + ""String_Node_Str"";
      }
      reference=Arrays.toString(ids);
    }
  }
 else {
    reference=""String_Node_Str"" + data.get(""String_Node_Str"").toString() + ""String_Node_Str"";
  }
  String db=(targetDb == null ? dbName : targetDb);
  if (role == ROLE.OWNING) {
    if (type == TYPE.ONE_TO_ONE || type == TYPE.MANY_TO_ONE) {
      return URLUtilis.getUriWithDocId(context,db,targetCollection,reference);
    }
 else     if (type == TYPE.ONE_TO_MANY || type == TYPE.MANY_TO_MANY) {
      return URLUtilis.getUriWithFilterMany(context,db,targetCollection,referenceField,reference);
    }
  }
 else {
    if (type == TYPE.ONE_TO_ONE || type == TYPE.ONE_TO_MANY) {
      return URLUtilis.getUriWithFilterOne(context,db,targetCollection,referenceField,reference);
    }
 else     if (type == TYPE.MANY_TO_ONE || type == TYPE.MANY_TO_MANY) {
      return URLUtilis.getUriWithFilterManyInverse(context,db,targetCollection,referenceField,reference);
    }
  }
  logger.debug(""String_Node_Str"",this,data);
  return null;
}"
93650,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (contentTypes == null || contentTypes.isEmpty() || !(contentTypes.contains(Representation.HAL_JSON_MEDIA_TYPE) || contentTypes.contains(JSON_MEDIA_TYPE))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ JSON_MEDIA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  content.keySet().stream().filter((key) -> (key.startsWith(""String_Node_Str""))).forEach((key) -> {
    keysToRemove.add(key);
  }
);
  keysToRemove.stream().map((keyToRemove) -> {
    content.removeField(keyToRemove);
    return keyToRemove;
  }
).forEach((keyToRemove) -> {
    context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
  }
);
  context.setContent(content);
  next.handleRequest(exchange,context);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (contentTypes == null || contentTypes.isEmpty() || contentTypes.stream().noneMatch(ct -> ct.startsWith(Representation.HAL_JSON_MEDIA_TYPE) || ct.startsWith(JSON_MEDIA_TYPE))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ JSON_MEDIA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  content.keySet().stream().filter((key) -> (key.startsWith(""String_Node_Str""))).forEach((key) -> {
    keysToRemove.add(key);
  }
);
  keysToRemove.stream().map((keyToRemove) -> {
    content.removeField(keyToRemove);
    return keyToRemove;
  }
).forEach((keyToRemove) -> {
    context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
  }
);
  context.setContent(content);
  next.handleRequest(exchange,context);
}"
93651,"/** 
 * @param dbName
 * @return the db props
 */
public static DBObject getDbProps(String dbName){
  DBCollection propscoll=CollectionDAO.getCollection(dbName,""String_Node_Str"");
  DBObject row=propscoll.findOne(METADATA_QUERY);
  if (row != null) {
    row.removeField(""String_Node_Str"");
    Object etag=row.get(""String_Node_Str"");
    if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
      ObjectId oid=new ObjectId(""String_Node_Str"" + etag);
      row.put(""String_Node_Str"",Instant.ofEpochSecond(oid.getTimestamp()).toString());
    }
  }
  return row;
}","/** 
 * @param dbName
 * @return the db props
 */
public static DBObject getDbProps(String dbName){
  if (!DBDAO.doesDbExists(dbName))   return null;
  DBCollection propscoll=CollectionDAO.getCollection(dbName,""String_Node_Str"");
  DBObject row=propscoll.findOne(METADATA_QUERY);
  if (row != null) {
    row.removeField(""String_Node_Str"");
    Object etag=row.get(""String_Node_Str"");
    if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
      ObjectId oid=new ObjectId(""String_Node_Str"" + etag);
      row.put(""String_Node_Str"",Instant.ofEpochSecond(oid.getTimestamp()).toString());
    }
  }
  return row;
}"
93652,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  List<String> colls=DBDAO.getDbCollections(DBDAO.getDB(context.getDBName()));
  List<DBObject> data;
  data=DBDAO.getData(context.getDBName(),colls,context.getPage(),context.getPagesize());
  exchange.setResponseCode(HttpStatus.SC_OK);
  DBRepresentationFactory.sendHal(exchange,context,data,colls.size());
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  List<String> colls=DBDAO.getDbCollections(DBDAO.getDB(context.getDBName()));
  List<DBObject> data=DBDAO.getData(context.getDBName(),colls,context.getPage(),context.getPagesize());
  exchange.setResponseCode(HttpStatus.SC_OK);
  DBRepresentationFactory.sendHal(exchange,context,data,colls.size());
  exchange.endExchange();
}"
93653,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (contentTypes == null || contentTypes.isEmpty() || contentTypes.stream().noneMatch(ct -> ct.startsWith(Representation.HAL_JSON_MEDIA_TYPE) || ct.startsWith(JSON_MEDIA_TYPE))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ JSON_MEDIA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  if (content == null) {
    context.setContent(null);
  }
 else {
    content.keySet().stream().filter((key) -> (key.startsWith(""String_Node_Str""))).forEach((key) -> {
      keysToRemove.add(key);
    }
);
    keysToRemove.stream().map((keyToRemove) -> {
      content.removeField(keyToRemove);
      return keyToRemove;
    }
).forEach((keyToRemove) -> {
      context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
    }
);
    context.setContent(content);
  }
  next.handleRequest(exchange,context);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (contentTypes == null || contentTypes.isEmpty() || contentTypes.stream().noneMatch(ct -> ct.startsWith(Representation.HAL_JSON_MEDIA_TYPE) || ct.startsWith(JSON_MEDIA_TYPE))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ JSON_MEDIA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  if (content == null) {
    context.setContent(null);
  }
 else {
    content.keySet().stream().filter((key) -> (key.startsWith(""String_Node_Str"") && !key.equals(""String_Node_Str""))).forEach((key) -> {
      keysToRemove.add(key);
    }
);
    keysToRemove.stream().map((keyToRemove) -> {
      content.removeField(keyToRemove);
      return keyToRemove;
    }
).forEach((keyToRemove) -> {
      context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
    }
);
    context.setContent(content);
  }
  next.handleRequest(exchange,context);
}"
93654,"/** 
 * @param dbName
 * @param collName
 * @param content
 * @param etag
 * @param updating
 * @param patching
 * @return the HttpStatus code to retrun
 */
public static int upsertCollection(String dbName,String collName,DBObject content,ObjectId etag,boolean updating,boolean patching){
  DB db=DBDAO.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  if (patching && !updating) {
    return HttpStatus.SC_NOT_FOUND;
  }
  if (updating) {
    if (etag == null) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
    BasicDBObject idAndEtagQuery=new BasicDBObject(""String_Node_Str"",""String_Node_Str"");
    idAndEtagQuery.append(""String_Node_Str"",etag);
    if (coll.count(idAndEtagQuery) < 1) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
  }
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.removeField(""String_Node_Str"");
  if (updating) {
    content.removeField(""String_Node_Str"");
    content.put(""String_Node_Str"",timestamp);
  }
 else {
    content.put(""String_Node_Str"",""String_Node_Str"");
    content.put(""String_Node_Str"",now.toString());
    content.put(""String_Node_Str"",timestamp);
  }
  if (patching) {
    coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",content),true,false);
    return HttpStatus.SC_OK;
  }
 else {
    DBObject old=coll.findAndModify(PROPS_QUERY,fieldsToReturn,null,false,content,false,true);
    if (old != null) {
      Object oldTimestamp=old.get(""String_Node_Str"");
      if (oldTimestamp == null) {
        oldTimestamp=now.toString();
        logger.warn(""String_Node_Str"",coll.getFullName());
      }
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
      createdContet.markAsPartialObject();
      coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_OK;
    }
 else {
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",now.toString());
      createdContet.markAsPartialObject();
      coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      initDefaultIndexes(coll);
      return HttpStatus.SC_CREATED;
    }
  }
}","/** 
 * @param dbName
 * @param collName
 * @param content
 * @param etag
 * @param updating
 * @param patching
 * @return the HttpStatus code to retrun
 */
public static int upsertCollection(String dbName,String collName,DBObject content,ObjectId etag,boolean updating,boolean patching){
  DB db=DBDAO.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  if (patching && !updating) {
    return HttpStatus.SC_NOT_FOUND;
  }
  if (updating) {
    if (etag == null) {
      return HttpStatus.SC_CONFLICT;
    }
    BasicDBObject idAndEtagQuery=new BasicDBObject(""String_Node_Str"",""String_Node_Str"");
    idAndEtagQuery.append(""String_Node_Str"",etag);
    if (coll.count(idAndEtagQuery) < 1) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
  }
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.removeField(""String_Node_Str"");
  if (updating) {
    content.removeField(""String_Node_Str"");
    content.put(""String_Node_Str"",timestamp);
  }
 else {
    content.put(""String_Node_Str"",""String_Node_Str"");
    content.put(""String_Node_Str"",now.toString());
    content.put(""String_Node_Str"",timestamp);
  }
  if (patching) {
    coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",content),true,false);
    return HttpStatus.SC_OK;
  }
 else {
    DBObject old=coll.findAndModify(PROPS_QUERY,fieldsToReturn,null,false,content,false,true);
    if (old != null) {
      Object oldTimestamp=old.get(""String_Node_Str"");
      if (oldTimestamp == null) {
        oldTimestamp=now.toString();
        logger.warn(""String_Node_Str"",coll.getFullName());
      }
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
      createdContet.markAsPartialObject();
      coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_OK;
    }
 else {
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",now.toString());
      createdContet.markAsPartialObject();
      coll.update(PROPS_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      initDefaultIndexes(coll);
      return HttpStatus.SC_CREATED;
    }
  }
}"
93655,"public static int upsertDB(String dbName,DBObject content,ObjectId etag,boolean patching){
  DB db=client.getDB(dbName);
  boolean existing=db.getCollectionNames().size() > 0;
  if (patching && !existing) {
    return HttpStatus.SC_NOT_FOUND;
  }
  DBCollection coll=db.getCollection(""String_Node_Str"");
  if (db.collectionExists(""String_Node_Str"")) {
    if (etag == null) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
    BasicDBObject idAndEtagQuery=new BasicDBObject(""String_Node_Str"",""String_Node_Str"");
    idAndEtagQuery.append(""String_Node_Str"",etag);
    if (coll.count(idAndEtagQuery) < 1) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
  }
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  content.removeField(""String_Node_Str"");
  content.removeField(""String_Node_Str"");
  if (patching) {
    coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",content),true,false);
    return HttpStatus.SC_OK;
  }
 else {
    DBObject old=coll.findAndModify(METADATA_QUERY,fieldsToReturn,null,false,content,false,true);
    if (old != null) {
      Object oldTimestamp=old.get(""String_Node_Str"");
      if (oldTimestamp == null) {
        oldTimestamp=now.toString();
        logger.warn(""String_Node_Str"",coll.getFullName());
      }
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
      createdContet.markAsPartialObject();
      coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_OK;
    }
 else {
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",now.toString());
      createdContet.markAsPartialObject();
      coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_CREATED;
    }
  }
}","public static int upsertDB(String dbName,DBObject content,ObjectId etag,boolean patching){
  DB db=client.getDB(dbName);
  boolean existing=db.getCollectionNames().size() > 0;
  if (patching && !existing) {
    return HttpStatus.SC_NOT_FOUND;
  }
  DBCollection coll=db.getCollection(""String_Node_Str"");
  if (db.collectionExists(""String_Node_Str"")) {
    if (etag == null) {
      return HttpStatus.SC_CONFLICT;
    }
    BasicDBObject idAndEtagQuery=new BasicDBObject(""String_Node_Str"",""String_Node_Str"");
    idAndEtagQuery.append(""String_Node_Str"",etag);
    if (coll.count(idAndEtagQuery) < 1) {
      return HttpStatus.SC_PRECONDITION_FAILED;
    }
  }
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  content.removeField(""String_Node_Str"");
  content.removeField(""String_Node_Str"");
  if (patching) {
    coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",content),true,false);
    return HttpStatus.SC_OK;
  }
 else {
    DBObject old=coll.findAndModify(METADATA_QUERY,fieldsToReturn,null,false,content,false,true);
    if (old != null) {
      Object oldTimestamp=old.get(""String_Node_Str"");
      if (oldTimestamp == null) {
        oldTimestamp=now.toString();
        logger.warn(""String_Node_Str"",coll.getFullName());
      }
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
      createdContet.markAsPartialObject();
      coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_OK;
    }
 else {
      BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",now.toString());
      createdContet.markAsPartialObject();
      coll.update(METADATA_QUERY,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
      return HttpStatus.SC_CREATED;
    }
  }
}"
93656,"public static void main(final String[] args){
  if (args == null || args.length < 1) {
    conf=new Configuration();
  }
 else {
    conf=new Configuration(args[0]);
  }
  LoggingInitializer.setLogLevel(conf.getLogLevel());
  if (conf.isLogToFile()) {
    LoggingInitializer.startFileLogging(conf.getLogFilePath());
  }
  logger.info(""String_Node_Str"");
  String mongoHosts=conf.getMongoServers().stream().map(s -> s.get(Configuration.MONGO_HOST) + ""String_Node_Str"" + s.get(Configuration.MONGO_PORT)+ ""String_Node_Str"").reduce(""String_Node_Str"",String::concat);
  logger.info(""String_Node_Str"",mongoHosts);
  try {
    MongoDBClientSingleton.init(conf);
    logger.info(""String_Node_Str"");
    MetadataFixer.fixMetadata();
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    System.exit(-1);
  }
  try {
    start();
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    System.exit(-2);
  }
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      logger.info(""String_Node_Str"");
      logger.info(""String_Node_Str"");
      try {
        hanldersPipe.shutdown();
        hanldersPipe.awaitShutdown(60 * 1000);
      }
 catch (      InterruptedException ie) {
        logger.error(""String_Node_Str"",ie);
      }
      if (server != null) {
        try {
          server.stop();
        }
 catch (        Throwable t) {
          logger.error(""String_Node_Str"",t);
        }
      }
      try {
        MongoClient client=MongoDBClientSingleton.getInstance().getClient();
        client.fsync(false);
        client.close();
      }
 catch (      Throwable t) {
        logger.error(""String_Node_Str"",t);
      }
      if (browserRootFile != null) {
        try {
          ResourcesExtractor.deleteTempDir(""String_Node_Str"",browserRootFile);
        }
 catch (        URISyntaxException|IOException ex) {
          logger.error(""String_Node_Str"",browserRootFile.toString(),ex);
        }
      }
      if (docsRootFile != null) {
        try {
          ResourcesExtractor.deleteTempDir(""String_Node_Str"",docsRootFile);
        }
 catch (        URISyntaxException|IOException ex) {
          logger.error(""String_Node_Str"",docsRootFile.toString(),ex);
        }
      }
      logger.info(""String_Node_Str"");
    }
  }
);
  logger.info(""String_Node_Str"");
  if (conf.isLogToFile()) {
    logger.info(""String_Node_Str"",conf.getLogFilePath(),conf.getLogLevel());
  }
  if (!conf.isLogToConsole()) {
    logger.info(""String_Node_Str"");
    LoggingInitializer.stopConsoleLogging();
  }
 else {
    logger.info(""String_Node_Str"",conf.getLogLevel());
  }
}","public static void main(final String[] args){
  if (args == null || args.length < 1) {
    conf=new Configuration();
  }
 else {
    conf=new Configuration(args[0]);
  }
  LoggingInitializer.setLogLevel(conf.getLogLevel());
  if (conf.isLogToFile()) {
    LoggingInitializer.startFileLogging(conf.getLogFilePath());
  }
  logger.info(""String_Node_Str"");
  String mongoHosts=conf.getMongoServers().stream().map(s -> s.get(Configuration.MONGO_HOST) + ""String_Node_Str"" + s.get(Configuration.MONGO_PORT)+ ""String_Node_Str"").reduce(""String_Node_Str"",String::concat);
  logger.info(""String_Node_Str"",mongoHosts);
  try {
    MongoDBClientSingleton.init(conf);
    logger.info(""String_Node_Str"");
    PropsFixer.fixAllMissingProps();
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    System.exit(-1);
  }
  try {
    start();
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    System.exit(-2);
  }
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      logger.info(""String_Node_Str"");
      logger.info(""String_Node_Str"");
      try {
        hanldersPipe.shutdown();
        hanldersPipe.awaitShutdown(60 * 1000);
      }
 catch (      InterruptedException ie) {
        logger.error(""String_Node_Str"",ie);
      }
      if (server != null) {
        try {
          server.stop();
        }
 catch (        Throwable t) {
          logger.error(""String_Node_Str"",t);
        }
      }
      try {
        MongoClient client=MongoDBClientSingleton.getInstance().getClient();
        client.fsync(false);
        client.close();
      }
 catch (      Throwable t) {
        logger.error(""String_Node_Str"",t);
      }
      if (browserRootFile != null) {
        try {
          ResourcesExtractor.deleteTempDir(""String_Node_Str"",browserRootFile);
        }
 catch (        URISyntaxException|IOException ex) {
          logger.error(""String_Node_Str"",browserRootFile.toString(),ex);
        }
      }
      if (docsRootFile != null) {
        try {
          ResourcesExtractor.deleteTempDir(""String_Node_Str"",docsRootFile);
        }
 catch (        URISyntaxException|IOException ex) {
          logger.error(""String_Node_Str"",docsRootFile.toString(),ex);
        }
      }
      logger.info(""String_Node_Str"");
    }
  }
);
  logger.info(""String_Node_Str"");
  if (conf.isLogToFile()) {
    logger.info(""String_Node_Str"",conf.getLogFilePath(),conf.getLogLevel());
  }
  if (!conf.isLogToConsole()) {
    logger.info(""String_Node_Str"");
    LoggingInitializer.stopConsoleLogging();
  }
 else {
    logger.info(""String_Node_Str"",conf.getLogLevel());
  }
}"
93657,"@Override public void handleRequest(HttpServerExchange exchange) throws Exception {
  try {
    next.handleRequest(exchange);
  }
 catch (  CommandFailureException cfe) {
    logger.error(""String_Node_Str"",cfe);
    Object errmsg=cfe.getCommandResult().get(""String_Node_Str"");
    if (""String_Node_Str"".equals(errmsg))     ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_INTERNAL_SERVER_ERROR,""String_Node_Str"",cfe);
 else     ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_INTERNAL_SERVER_ERROR,""String_Node_Str"",cfe);
  }
catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_INTERNAL_SERVER_ERROR,""String_Node_Str"",t);
  }
}","@Override public void handleRequest(HttpServerExchange exchange) throws Exception {
  try {
    next.handleRequest(exchange);
  }
 catch (  CommandFailureException cfe) {
    logger.error(""String_Node_Str"",cfe);
    Object errmsg=cfe.getCommandResult().get(""String_Node_Str"");
    if (errmsg != null && errmsg instanceof String && (""String_Node_Str"".equals(errmsg) || ((String)errmsg).contains(""String_Node_Str"")))     ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_INTERNAL_SERVER_ERROR,""String_Node_Str"",cfe);
 else     ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_INTERNAL_SERVER_ERROR,""String_Node_Str"",cfe);
  }
catch (  Throwable t) {
    logger.error(""String_Node_Str"",t);
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_INTERNAL_SERVER_ERROR,""String_Node_Str"",t);
  }
}"
93658,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName() != null && context.getCollectionName() != null) {
    DBObject collProps=null;
    if (!cacheEnabled) {
      collProps=CollectionDAO.getCollectionProps(context.getDBName(),context.getCollectionName());
      if (collProps != null)       collProps.put(""String_Node_Str"",false);
    }
 else {
      LoadingCache<String,Optional<DBObject>> collectionPropsCache=LocalCachesSingleton.getInstance().getCollectionCache();
      Optional<DBObject> _collMetadata=collectionPropsCache.getIfPresent(context.getDBName() + SEPARATOR + context.getCollectionName());
      if (_collMetadata != null) {
        if (_collMetadata.isPresent()) {
          collProps=_collMetadata.get();
          collProps.put(""String_Node_Str"",true);
        }
 else         collProps=null;
      }
 else {
        _collMetadata=collectionPropsCache.get(context.getDBName() + SEPARATOR + context.getCollectionName());
        if (_collMetadata.isPresent()) {
          collProps=_collMetadata.get();
          collProps.put(""String_Node_Str"",false);
        }
 else         collProps=null;
      }
    }
    context.setCollectionProps(collProps);
  }
  next.handleRequest(exchange,context);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName() != null && context.getCollectionName() != null) {
    DBObject collProps=null;
    if (!cacheEnabled) {
      collProps=CollectionDAO.getCollectionProps(context.getDBName(),context.getCollectionName());
      if (collProps != null)       collProps.put(""String_Node_Str"",false);
    }
 else {
      LoadingCache<String,Optional<DBObject>> collectionPropsCache=LocalCachesSingleton.getInstance().getCollectionCache();
      Optional<DBObject> _collMetadata=collectionPropsCache.getIfPresent(context.getDBName() + SEPARATOR + context.getCollectionName());
      if (_collMetadata != null) {
        if (_collMetadata.isPresent()) {
          collProps=_collMetadata.get();
          collProps.put(""String_Node_Str"",true);
        }
 else         collProps=null;
      }
 else {
        try {
          _collMetadata=collectionPropsCache.getUnchecked(context.getDBName() + SEPARATOR + context.getCollectionName());
        }
 catch (        UncheckedExecutionException uex) {
          if (uex.getCause() instanceof MongoException) {
            throw (MongoException)uex.getCause();
          }
 else {
            throw uex;
          }
        }
        if (_collMetadata.isPresent()) {
          collProps=_collMetadata.get();
          collProps.put(""String_Node_Str"",false);
        }
 else         collProps=null;
      }
    }
    context.setCollectionProps(collProps);
  }
  next.handleRequest(exchange,context);
}"
93659,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName() != null) {
    DBObject dbProps=null;
    if (!cacheEnabled) {
      dbProps=DBDAO.getDbProps(context.getDBName());
      if (dbProps != null)       dbProps.put(""String_Node_Str"",false);
    }
 else {
      LoadingCache<String,Optional<DBObject>> dbPropsCache=LocalCachesSingleton.getInstance().getDbCache();
      Optional<DBObject> _dbMetadata=dbPropsCache.getIfPresent(context.getDBName());
      if (_dbMetadata != null) {
        if (_dbMetadata.isPresent()) {
          dbProps=_dbMetadata.get();
          dbProps.put(""String_Node_Str"",true);
        }
 else         dbProps=null;
      }
 else {
        _dbMetadata=dbPropsCache.get(context.getDBName());
        if (_dbMetadata.isPresent()) {
          dbProps=_dbMetadata.get();
          dbProps.put(""String_Node_Str"",false);
        }
 else         dbProps=null;
      }
    }
    context.setDbProps(dbProps);
  }
  next.handleRequest(exchange,context);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName() != null) {
    DBObject dbProps;
    if (!cacheEnabled) {
      dbProps=DBDAO.getDbProps(context.getDBName());
      if (dbProps != null)       dbProps.put(""String_Node_Str"",false);
    }
 else {
      LoadingCache<String,Optional<DBObject>> dbPropsCache=LocalCachesSingleton.getInstance().getDbCache();
      Optional<DBObject> _dbMetadata=dbPropsCache.getIfPresent(context.getDBName());
      if (_dbMetadata != null) {
        if (_dbMetadata.isPresent()) {
          dbProps=_dbMetadata.get();
          dbProps.put(""String_Node_Str"",true);
        }
 else         dbProps=null;
      }
 else {
        try {
          _dbMetadata=dbPropsCache.getUnchecked(context.getDBName());
        }
 catch (        UncheckedExecutionException uex) {
          if (uex.getCause() instanceof MongoException) {
            throw (MongoException)uex.getCause();
          }
 else {
            throw uex;
          }
        }
        if (_dbMetadata != null && _dbMetadata.isPresent()) {
          dbProps=_dbMetadata.get();
          dbProps.put(""String_Node_Str"",false);
        }
 else         dbProps=null;
      }
    }
    context.setDbProps(dbProps);
  }
  next.handleRequest(exchange,context);
}"
93660,"private static BasicDBList getStackTraceJson(Throwable t){
  if (t == null || t.getStackTrace() == null)   return null;
  BasicDBList list=new BasicDBList();
  for (  StackTraceElement e : t.getStackTrace()) {
    list.add(e.toString());
  }
  return list;
}","private static BasicDBList getStackTraceJson(Throwable t){
  if (t == null || t.getStackTrace() == null)   return null;
  StringWriter sw=new StringWriter();
  PrintWriter pw=new PrintWriter(sw);
  t.printStackTrace(pw);
  String st=sw.toString();
  st=st.replaceAll(""String_Node_Str"",""String_Node_Str"");
  String[] lines=st.split(""String_Node_Str"");
  BasicDBList list=new BasicDBList();
  list.addAll(Arrays.asList(lines));
  return list;
}"
93661,"/** 
 * @param exchange
 * @param dbName
 * @param collName
 * @param content
 * @param requestEtag
 * @return the HttpStatus code to retrun
 */
public static int upsertDocumentPost(HttpServerExchange exchange,String dbName,String collName,DBObject content,ObjectId requestEtag){
  DB db=DBDAO.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  content.put(""String_Node_Str"",now.toString());
  Object _id=content.get(""String_Node_Str"");
  content.removeField(""String_Node_Str"");
  if (_id == null) {
    ObjectId id=new ObjectId();
    content.put(""String_Node_Str"",id);
    coll.insert(content);
    exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(exchange.getRequestURL(),id.toString()).toString());
    return HttpStatus.SC_CREATED;
  }
  BasicDBObject idQuery=new BasicDBObject(""String_Node_Str"",getId(""String_Node_Str"" + _id));
  DBObject oldDocument=coll.findAndModify(idQuery,null,null,false,content,false,true);
  if (oldDocument != null) {
    Object oldTimestamp=oldDocument.get(""String_Node_Str"");
    if (oldTimestamp == null) {
      oldTimestamp=now.toString();
      logger.warn(""String_Node_Str"",dbName,collName,_id.toString());
    }
    BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
    createdContet.markAsPartialObject();
    coll.update(idQuery,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
    return optimisticCheckEtag(coll,oldDocument,requestEtag,HttpStatus.SC_NO_CONTENT);
  }
 else {
    return HttpStatus.SC_CREATED;
  }
}","/** 
 * @param exchange
 * @param dbName
 * @param collName
 * @param content
 * @param requestEtag
 * @return the HttpStatus code to retrun
 */
public static int upsertDocumentPost(HttpServerExchange exchange,String dbName,String collName,DBObject content,ObjectId requestEtag){
  DB db=DBDAO.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  content.put(""String_Node_Str"",now.toString());
  Object _id=content.get(""String_Node_Str"");
  content.removeField(""String_Node_Str"");
  if (_id == null) {
    ObjectId id=new ObjectId();
    content.put(""String_Node_Str"",id);
    coll.insert(content);
    exchange.getResponseHeaders().add(HttpString.tryFromString(""String_Node_Str""),getReferenceLink(exchange.getRequestURL(),id.toString()).toString());
    return HttpStatus.SC_CREATED;
  }
  BasicDBObject idQuery=new BasicDBObject(""String_Node_Str"",getId(""String_Node_Str"" + _id));
  DBObject oldDocument=coll.findAndModify(idQuery,null,null,false,content,false,true);
  if (oldDocument != null) {
    Object oldTimestamp=oldDocument.get(""String_Node_Str"");
    if (oldTimestamp == null) {
      oldTimestamp=now.toString();
      logger.warn(""String_Node_Str"",dbName,collName,_id.toString());
    }
    BasicDBObject createdContet=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
    createdContet.markAsPartialObject();
    coll.update(idQuery,new BasicDBObject(""String_Node_Str"",createdContet),true,false);
    return optimisticCheckEtag(coll,oldDocument,requestEtag,HttpStatus.SC_OK);
  }
 else {
    return HttpStatus.SC_CREATED;
  }
}"
93662,"/** 
 * @param dbName
 * @param collName
 * @param documentId
 * @param content
 * @param requestEtag
 * @param patching
 * @return the HttpStatus code to retrun
 */
public static int upsertDocument(String dbName,String collName,String documentId,DBObject content,ObjectId requestEtag,boolean patching){
  DB db=DBDAO.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  BasicDBObject idQuery=new BasicDBObject(""String_Node_Str"",getId(documentId));
  if (patching) {
    content.removeField(""String_Node_Str"");
    DBObject oldDocument=coll.findAndModify(idQuery,null,null,false,new BasicDBObject(""String_Node_Str"",content),false,false);
    if (oldDocument == null) {
      return HttpStatus.SC_NOT_FOUND;
    }
 else {
      return optimisticCheckEtag(coll,oldDocument,requestEtag,HttpStatus.SC_NO_CONTENT);
    }
  }
 else {
    content.put(""String_Node_Str"",now.toString());
    DBObject oldDocument=coll.findAndModify(idQuery,null,null,false,content,false,true);
    if (oldDocument != null) {
      Object oldTimestamp=oldDocument.get(""String_Node_Str"");
      if (oldTimestamp == null) {
        oldTimestamp=now.toString();
        logger.warn(""String_Node_Str"",dbName,collName,documentId);
      }
      BasicDBObject created=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
      created.markAsPartialObject();
      coll.update(idQuery,new BasicDBObject(""String_Node_Str"",created),true,false);
      return optimisticCheckEtag(coll,oldDocument,requestEtag,HttpStatus.SC_NO_CONTENT);
    }
 else {
      return HttpStatus.SC_CREATED;
    }
  }
}","/** 
 * @param dbName
 * @param collName
 * @param documentId
 * @param content
 * @param requestEtag
 * @param patching
 * @return the HttpStatus code to retrun
 */
public static int upsertDocument(String dbName,String collName,String documentId,DBObject content,ObjectId requestEtag,boolean patching){
  DB db=DBDAO.getDB(dbName);
  DBCollection coll=db.getCollection(collName);
  ObjectId timestamp=new ObjectId();
  Instant now=Instant.ofEpochSecond(timestamp.getTimestamp());
  if (content == null) {
    content=new BasicDBObject();
  }
  content.put(""String_Node_Str"",timestamp);
  BasicDBObject idQuery=new BasicDBObject(""String_Node_Str"",getId(documentId));
  if (patching) {
    content.removeField(""String_Node_Str"");
    DBObject oldDocument=coll.findAndModify(idQuery,null,null,false,new BasicDBObject(""String_Node_Str"",content),false,false);
    if (oldDocument == null) {
      return HttpStatus.SC_NOT_FOUND;
    }
 else {
      return optimisticCheckEtag(coll,oldDocument,requestEtag,HttpStatus.SC_OK);
    }
  }
 else {
    content.put(""String_Node_Str"",now.toString());
    DBObject oldDocument=coll.findAndModify(idQuery,null,null,false,content,false,true);
    if (oldDocument != null) {
      Object oldTimestamp=oldDocument.get(""String_Node_Str"");
      if (oldTimestamp == null) {
        oldTimestamp=now.toString();
        logger.warn(""String_Node_Str"",dbName,collName,documentId);
      }
      BasicDBObject created=new BasicDBObject(""String_Node_Str"",""String_Node_Str"" + oldTimestamp);
      created.markAsPartialObject();
      coll.update(idQuery,new BasicDBObject(""String_Node_Str"",created),true,false);
      return optimisticCheckEtag(coll,oldDocument,requestEtag,HttpStatus.SC_OK);
    }
 else {
      return HttpStatus.SC_CREATED;
    }
  }
}"
93663,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty()) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (context.getCollectionName().isEmpty() || context.getCollectionName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content.containsField(Relationship.RELATIONSHIPS_ELEMENT_NAME)) {
    try {
      Relationship.getFromJson(content);
    }
 catch (    InvalidMetadataException ex) {
      ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"" + ex.getMessage(),ex);
      return;
    }
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int SC=CollectionDAO.upsertCollection(context.getDBName(),context.getCollectionName(),content,etag,true,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateCollection(context.getDBName(),context.getCollectionName());
}"
93664,"/** 
 * partial update db properties
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int SC=DBDAO.upsertDB(context.getDBName(),content,etag,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
}","/** 
 * partial update db properties
 * @param exchange
 * @param context
 * @throws Exception
 */
@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getDBName().isEmpty() || context.getDBName().startsWith(""String_Node_Str"")) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  DBObject content=context.getContent();
  if (content == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  if (content instanceof BasicDBList) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"");
    return;
  }
  ObjectId etag=RequestHelper.getWriteEtag(exchange);
  if (etag == null) {
    ResponseHelper.endExchange(exchange,HttpStatus.SC_CONFLICT);
    return;
  }
  int SC=DBDAO.upsertDB(context.getDBName(),content,etag,true);
  exchange.setResponseCode(SC);
  if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
    DocumentRepresentationFactory.sendDocument(exchange.getRequestPath(),exchange,context,new BasicDBObject());
  }
  exchange.endExchange();
  LocalCachesSingleton.getInstance().invalidateDb(context.getDBName());
}"
93665,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (contentTypes == null || contentTypes.isEmpty() || !contentTypes.contains(Representation.HAL_JSON_MEDIA_TYPE) || !contentTypes.contains(JSON_MEDIA_TYPE)) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ JSON_MEDIA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  content.keySet().stream().filter((key) -> (key.startsWith(""String_Node_Str""))).forEach((key) -> {
    keysToRemove.add(key);
  }
);
  keysToRemove.stream().map((keyToRemove) -> {
    content.removeField(keyToRemove);
    return keyToRemove;
  }
).forEach((keyToRemove) -> {
    context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
  }
);
  context.setContent(content);
  next.handleRequest(exchange,context);
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  if (context.getMethod() == RequestContext.METHOD.GET || context.getMethod() == RequestContext.METHOD.DELETE) {
    next.handleRequest(exchange,context);
    return;
  }
  HeaderValues contentTypes=exchange.getRequestHeaders().get(Headers.CONTENT_TYPE);
  if (contentTypes == null || contentTypes.isEmpty() || !(contentTypes.contains(Representation.HAL_JSON_MEDIA_TYPE) || contentTypes.contains(JSON_MEDIA_TYPE))) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE,""String_Node_Str"" + Representation.HAL_JSON_MEDIA_TYPE + ""String_Node_Str""+ JSON_MEDIA_TYPE);
    return;
  }
  String _content=ChannelReader.read(exchange.getRequestChannel());
  DBObject content;
  try {
    content=(DBObject)JSON.parse(_content);
  }
 catch (  JSONParseException ex) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_ACCEPTABLE,""String_Node_Str"",ex);
    return;
  }
  HashSet<String> keysToRemove=new HashSet<>();
  content.keySet().stream().filter((key) -> (key.startsWith(""String_Node_Str""))).forEach((key) -> {
    keysToRemove.add(key);
  }
);
  keysToRemove.stream().map((keyToRemove) -> {
    content.removeField(keyToRemove);
    return keyToRemove;
  }
).forEach((keyToRemove) -> {
    context.addWarning(""String_Node_Str"" + keyToRemove + ""String_Node_Str"");
  }
);
  context.setContent(content);
  next.handleRequest(exchange,context);
}"
93666,"@Before @Override public void setUp() throws Exception {
  super.setUp();
  notDecompressingExecutor=Executor.newInstance(HttpClients.custom().disableContentCompression().build()).auth(new HttpHost(conf.getHttpHost()),""String_Node_Str"",""String_Node_Str"");
}","@Before @Override public void setUp() throws Exception {
  super.setUp();
  notDecompressingExecutor=Executor.newInstance(HttpClients.custom().disableContentCompression().build()).auth(new HttpHost(""String_Node_Str""),""String_Node_Str"",""String_Node_Str"");
}"
93667,"public void addRepresentation(String rel,Representation rep){
  if (dbObject.get(""String_Node_Str"") == null)   dbObject.put(""String_Node_Str"",new BasicDBObject());
  BasicDBObject _embedded=(BasicDBObject)dbObject.get(""String_Node_Str"");
  if (_embedded.get(rel) == null)   _embedded.put(rel,new BasicDBObject());
  BasicDBObject _rel=(BasicDBObject)_embedded.get(rel);
  _rel.putAll((BSONObject)((Representation)rep).getDBObject());
}","public void addRepresentation(String rel,Representation rep){
  if (dbObject.get(""String_Node_Str"") == null)   dbObject.put(""String_Node_Str"",new BasicDBObject());
  BasicDBObject _embedded=(BasicDBObject)dbObject.get(""String_Node_Str"");
  if (_embedded.get(rel) == null)   _embedded.put(rel,new BasicDBList());
  BasicDBList _rel=(BasicDBList)_embedded.get(rel);
  _rel.add(((Representation)rep).getDBObject());
}"
93668,"static public void sendCollection(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.getRequestPath(exchange);
  Representation rep=new Representation(requestPath);
  DBObject collProps=context.getCollectionProps();
  if (collProps != null) {
    rep=addData(rep,collProps);
  }
 else {
    DBObject dbProps=context.getDbProps();
    if (dbProps != null) {
      rep=addData(rep,dbProps);
    }
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.nextUp(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",""String_Node_Str"" + count);
    if (!embeddedData.isEmpty()) {
      for (      DBObject d : embeddedData) {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=DocumentRepresentationFactory.getDocument(exchange,context,d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
    }
  }
  TreeMap<String,String> links;
  links=getPaginationLinks(exchange,context,size);
  if (links != null) {
    for (    String k : links.keySet()) {
      rep.addLink(new Link(k,links.get(k)));
    }
  }
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}","static public void sendCollection(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(URLUtilis.getRequestPath(exchange));
  Representation rep=new Representation(requestPath);
  if (context.getType() == RequestContext.TYPE.COLLECTION) {
    DBObject collProps=context.getCollectionProps();
    if (collProps != null) {
      addData(rep,collProps);
    }
 else {
      DBObject dbProps=context.getDbProps();
      if (dbProps != null) {
        addData(rep,dbProps);
      }
    }
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.nextUp(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",""String_Node_Str"" + count);
    if (!embeddedData.isEmpty()) {
      for (      DBObject d : embeddedData) {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=DocumentRepresentationFactory.getDocument(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
    }
  }
  if (context.getType() != RequestContext.TYPE.COLLECTION_INDEXES) {
    TreeMap<String,String> links;
    links=getPaginationLinks(exchange,context,size);
    if (links != null) {
      for (      String k : links.keySet()) {
        rep.addLink(new Link(k,links.get(k)));
      }
    }
  }
  if (context.getType() == RequestContext.TYPE.COLLECTION) {
    rep.addLink(new Link(""String_Node_Str"",URLUtilis.removeTrailingSlashes(URLUtilis.getRequestPath(exchange)) + ""String_Node_Str""));
  }
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}"
93669,"private static Representation addData(Representation rep,DBObject data){
  data.keySet().stream().forEach((key) -> {
    Object value=data.get(key);
    if (value instanceof DBObject) {
      rep.addRepresentation(key,addData(new Representation(""String_Node_Str""),(DBObject)value));
    }
 else     if (value instanceof BasicDBList) {
      BasicDBList list=((BasicDBList)value);
      for (      String key2 : list.keySet()) {
        if (list.get(key2) instanceof DBObject) {
          rep.addRepresentation(key2,addData(new Representation(""String_Node_Str"" + key2),(DBObject)value));
        }
 else {
          rep.addProperty(key2,value);
        }
      }
    }
 else {
      if (value instanceof ObjectId) {
        value=value.toString();
      }
      rep.addProperty(key,value);
    }
  }
);
  return rep;
}","private static void addData(Representation rep,DBObject data){
  data.keySet().stream().forEach((key) -> {
    Object value=data.get(key);
    if (value instanceof ObjectId) {
      rep.addProperty(key,value.toString());
    }
 else {
      rep.addProperty(key,value);
    }
  }
);
}"
93670,"public static Representation getDocument(HttpServerExchange exchange,RequestContext context,DBObject data) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.getRequestPath(exchange);
  Representation rep=new Representation(requestPath);
  data.keySet().stream().forEach((key) -> {
    Object value=data.get(key);
    if (value instanceof ObjectId) {
      value=value.toString();
    }
    rep.addProperty(key,value);
  }
);
  TreeMap<String,String> links=null;
  try {
    links=getRelationshipsLinks(exchange,context,data);
  }
 catch (  InvalidMetadataException ex) {
    logger.warn(ex.getMessage(),context.getDBName(),context.getCollectionName(),ex);
  }
  if (links != null) {
    for (    String k : links.keySet()) {
      rep.addLink(new Link(k,links.get(k)));
    }
  }
  return rep;
}","public static Representation getDocument(String href,HttpServerExchange exchange,RequestContext context,DBObject data) throws IllegalQueryParamenterException {
  Representation rep=new Representation(href);
  data.keySet().stream().forEach((key) -> {
    Object value=data.get(key);
    if (value instanceof ObjectId) {
      value=value.toString();
    }
    rep.addProperty(key,value);
  }
);
  TreeMap<String,String> links=null;
  try {
    links=getRelationshipsLinks(context,data);
  }
 catch (  InvalidMetadataException ex) {
    logger.warn(ex.getMessage(),context.getDBName(),context.getCollectionName(),ex);
  }
  if (links != null) {
    for (    String k : links.keySet()) {
      rep.addLink(new Link(k,links.get(k)));
    }
  }
  return rep;
}"
93671,"public static void sendDocument(HttpServerExchange exchange,RequestContext context,DBObject data) throws IllegalQueryParamenterException, URISyntaxException {
  Representation rep=getDocument(exchange,context,data);
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}","public static void sendDocument(String href,HttpServerExchange exchange,RequestContext context,DBObject data) throws IllegalQueryParamenterException, URISyntaxException {
  Representation rep=getDocument(href,exchange,context,data);
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}"
93672,"private static TreeMap<String,String> getRelationshipsLinks(HttpServerExchange exchange,RequestContext context,DBObject data) throws InvalidMetadataException {
  TreeMap<String,String> links=new TreeMap<>();
  List<Relationship> rels;
  try {
    rels=Relationship.getFromJson((DBObject)context.getCollectionProps());
  }
 catch (  InvalidMetadataException ex) {
    logger.error(""String_Node_Str"",context.getDBName(),context.getCollectionName(),ex);
    throw new InvalidMetadataException(""String_Node_Str"" + context.getDBName() + ""String_Node_Str""+ context.getCollectionName()+ ""String_Node_Str"",ex);
  }
  if (rels == null) {
    return links;
  }
  for (  Relationship rel : rels) {
    try {
      String link=rel.getRelationshipLink(context.getDBName(),context.getCollectionName(),data);
      if (link != null) {
        links.put(rel.getRel(),link);
      }
    }
 catch (    IllegalArgumentException ex) {
      logger.warn(""String_Node_Str"",context.getDBName(),context.getCollectionName(),context.getDocumentId(),ex);
    }
  }
  return links;
}","private static TreeMap<String,String> getRelationshipsLinks(RequestContext context,DBObject data) throws InvalidMetadataException {
  TreeMap<String,String> links=new TreeMap<>();
  List<Relationship> rels;
  try {
    rels=Relationship.getFromJson((DBObject)context.getCollectionProps());
  }
 catch (  InvalidMetadataException ex) {
    logger.error(""String_Node_Str"",context.getDBName(),context.getCollectionName(),ex);
    throw new InvalidMetadataException(""String_Node_Str"" + context.getDBName() + ""String_Node_Str""+ context.getCollectionName()+ ""String_Node_Str"",ex);
  }
  if (rels == null) {
    return links;
  }
  for (  Relationship rel : rels) {
    try {
      String link=rel.getRelationshipLink(context.getDBName(),context.getCollectionName(),data);
      if (link != null) {
        links.put(rel.getRel(),link);
      }
    }
 catch (    IllegalArgumentException ex) {
      logger.warn(""String_Node_Str"",context.getDBName(),context.getCollectionName(),context.getDocumentId(),ex);
    }
  }
  return links;
}"
93673,"@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId oid;
  String sid;
  if (ObjectId.isValid(context.getDocumentId())) {
    sid=null;
    oid=new ObjectId(context.getDocumentId());
  }
 else {
    sid=context.getDocumentId();
    oid=null;
  }
  BasicDBObject query;
  if (oid != null) {
    query=new BasicDBObject(""String_Node_Str"",oid);
  }
 else {
    query=new BasicDBObject(""String_Node_Str"",sid);
  }
  DBObject document=CollectionDAO.getCollection(context.getDBName(),context.getCollectionName()).findOne(query);
  if (document == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"" + context.getDBName() + ""String_Node_Str""+ context.getCollectionName()+ ""String_Node_Str""+ context.getDocumentId()+ ""String_Node_Str"");
    return;
  }
  Object etag=document.get(""String_Node_Str"");
  if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
    ObjectId _etag=new ObjectId(""String_Node_Str"" + etag);
    document.put(""String_Node_Str"",Instant.ofEpochSecond(_etag.getTimestamp()).toString());
    if (false && RequestHelper.checkReadEtag(exchange,etag.toString())) {
      ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_MODIFIED);
      return;
    }
  }
  ResponseHelper.injectEtagHeader(exchange,document);
  exchange.setResponseCode(HttpStatus.SC_OK);
  DocumentRepresentationFactory.sendDocument(exchange,context,document);
  exchange.endExchange();
}","@Override public void handleRequest(HttpServerExchange exchange,RequestContext context) throws Exception {
  ObjectId oid;
  String sid;
  if (ObjectId.isValid(context.getDocumentId())) {
    sid=null;
    oid=new ObjectId(context.getDocumentId());
  }
 else {
    sid=context.getDocumentId();
    oid=null;
  }
  BasicDBObject query;
  if (oid != null) {
    query=new BasicDBObject(""String_Node_Str"",oid);
  }
 else {
    query=new BasicDBObject(""String_Node_Str"",sid);
  }
  DBObject document=CollectionDAO.getCollection(context.getDBName(),context.getCollectionName()).findOne(query);
  if (document == null) {
    ResponseHelper.endExchangeWithMessage(exchange,HttpStatus.SC_NOT_FOUND,""String_Node_Str"" + context.getDBName() + ""String_Node_Str""+ context.getCollectionName()+ ""String_Node_Str""+ context.getDocumentId()+ ""String_Node_Str"");
    return;
  }
  Object etag=document.get(""String_Node_Str"");
  if (etag != null && ObjectId.isValid(""String_Node_Str"" + etag)) {
    ObjectId _etag=new ObjectId(""String_Node_Str"" + etag);
    document.put(""String_Node_Str"",Instant.ofEpochSecond(_etag.getTimestamp()).toString());
    if (false && RequestHelper.checkReadEtag(exchange,etag.toString())) {
      ResponseHelper.endExchange(exchange,HttpStatus.SC_NOT_MODIFIED);
      return;
    }
  }
  String requestPath=URLUtilis.removeTrailingSlashes(URLUtilis.getRequestPath(exchange));
  ResponseHelper.injectEtagHeader(exchange,document);
  exchange.setResponseCode(HttpStatus.SC_OK);
  DocumentRepresentationFactory.sendDocument(requestPath,exchange,context,document);
  exchange.endExchange();
}"
93674,"static public void sendCollection(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(URLUtilis.getRequestPath(exchange));
  Representation rep=new Representation(requestPath);
  if (context.getType() == RequestContext.TYPE.COLLECTION) {
    DBObject collProps=context.getCollectionProps();
    if (collProps != null) {
      addData(rep,collProps);
    }
 else {
      DBObject dbProps=context.getDbProps();
      if (dbProps != null) {
        addData(rep,dbProps);
      }
    }
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.nextUp(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",""String_Node_Str"" + count);
    if (!embeddedData.isEmpty()) {
      for (      DBObject d : embeddedData) {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=DocumentRepresentationFactory.getDocument(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
    }
  }
  if (context.getType() != RequestContext.TYPE.COLLECTION_INDEXES) {
    TreeMap<String,String> links;
    links=getPaginationLinks(exchange,context,size);
    if (links != null) {
      for (      String k : links.keySet()) {
        rep.addLink(new Link(k,links.get(k)));
      }
    }
  }
  if (context.getType() == RequestContext.TYPE.COLLECTION) {
    rep.addLink(new Link(""String_Node_Str"",URLUtilis.removeTrailingSlashes(URLUtilis.getRequestPath(exchange)) + ""String_Node_Str""));
  }
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}","static public void sendCollection(HttpServerExchange exchange,RequestContext context,List<DBObject> embeddedData,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.removeTrailingSlashes(URLUtilis.getRequestPath(exchange));
  String queryString=(exchange.getQueryString() == null || exchange.getQueryString().isEmpty()) ? ""String_Node_Str"" : ""String_Node_Str"" + exchange.getQueryString();
  Representation rep=new Representation(requestPath + queryString);
  if (context.getType() == RequestContext.TYPE.COLLECTION) {
    DBObject collProps=context.getCollectionProps();
    if (collProps != null) {
      addData(rep,collProps);
    }
 else {
      DBObject dbProps=context.getDbProps();
      if (dbProps != null) {
        addData(rep,dbProps);
      }
    }
  }
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=context.getPagesize() + 0f;
    rep.addProperty(""String_Node_Str"",size);
    rep.addProperty(""String_Node_Str"",Math.max(1,Math.round(Math.nextUp(_size / _pagesize))));
  }
  if (embeddedData != null) {
    long count=embeddedData.stream().filter((props) -> props.keySet().stream().anyMatch((k) -> k.equals(""String_Node_Str"") || k.equals(""String_Node_Str""))).count();
    rep.addProperty(""String_Node_Str"",""String_Node_Str"" + count);
    if (!embeddedData.isEmpty()) {
      for (      DBObject d : embeddedData) {
        Object _id=d.get(""String_Node_Str"");
        if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
          Representation nrep=DocumentRepresentationFactory.getDocument(requestPath + ""String_Node_Str"" + _id.toString(),exchange,context,d);
          rep.addRepresentation(""String_Node_Str"",nrep);
        }
 else {
          logger.error(""String_Node_Str"",d);
        }
      }
    }
  }
  if (context.getType() != RequestContext.TYPE.COLLECTION_INDEXES) {
    TreeMap<String,String> links;
    links=getPaginationLinks(exchange,context,size);
    if (links != null) {
      links.keySet().stream().forEach((k) -> {
        rep.addLink(new Link(k,links.get(k)));
      }
);
    }
  }
  if (context.getType() == RequestContext.TYPE.COLLECTION) {
    rep.addLink(new Link(""String_Node_Str"",URLUtilis.removeTrailingSlashes(URLUtilis.getRequestPath(exchange)) + ""String_Node_Str""));
  }
  exchange.getResponseHeaders().put(Headers.CONTENT_TYPE,HAL_JSON_MEDIA_TYPE);
  exchange.getResponseSender().send(rep.toString());
}"
93675,"private static TreeMap<String,String> getPaginationLinks(HttpServerExchange exchange,RequestContext context,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.getRequestPath(exchange);
  String queryString=exchange.getQueryString();
  int page=context.getPage();
  int pagesize=context.getPagesize();
  int totalPages=0;
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=pagesize + 0f;
    totalPages=Math.max(1,Math.round(Math.nextUp(_size / _pagesize)));
  }
  TreeMap<String,String> links=new TreeMap<>();
  if (queryString == null || queryString.isEmpty()) {
    links.put(""String_Node_Str"",requestPath);
    links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
  }
 else {
    String queryString2=removePagingParamsFromQueryString(queryString,exchange.getQueryParameters().get(""String_Node_Str""),exchange.getQueryParameters().get(""String_Node_Str""));
    links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + queryString2);
    if (queryString2 == null || queryString2.isEmpty()) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize);
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryString2);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page > 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize));
      }
    }
 else {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize+ ""String_Node_Str""+ queryString2);
      if (totalPages <= 0) {
        links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryString2);
      }
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryString2);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryString2);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryString2);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize)+ ""String_Node_Str""+ queryString2);
      }
    }
  }
  return links;
}","private static TreeMap<String,String> getPaginationLinks(HttpServerExchange exchange,RequestContext context,long size) throws IllegalQueryParamenterException {
  String requestPath=URLUtilis.getRequestPath(exchange);
  String queryString=exchange.getQueryString();
  int page=context.getPage();
  int pagesize=context.getPagesize();
  int totalPages=0;
  if (size > 0) {
    float _size=size + 0f;
    float _pagesize=pagesize + 0f;
    totalPages=Math.max(1,Math.round(Math.nextUp(_size / _pagesize)));
  }
  TreeMap<String,String> links=new TreeMap<>();
  if (queryString == null || queryString.isEmpty()) {
    links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
  }
 else {
    String queryString2=removePagingParamsFromQueryString(queryString,exchange.getQueryParameters().get(""String_Node_Str""),exchange.getQueryParameters().get(""String_Node_Str""));
    if (queryString2 == null || queryString2.isEmpty()) {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize);
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize);
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryString2);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page > 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize));
      }
    }
 else {
      links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + pagesize+ ""String_Node_Str""+ queryString2);
      if (totalPages <= 0) {
        links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryString2);
      }
      if (totalPages > 0) {
        if (page < totalPages) {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryString2);
          links.put(""String_Node_Str"",requestPath + ""String_Node_Str"" + (page + 1)+ ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryString2);
        }
 else {
          links.put(""String_Node_Str"",requestPath + (totalPages != 1 ? ""String_Node_Str"" + totalPages : ""String_Node_Str"") + ""String_Node_Str""+ pagesize+ ""String_Node_Str""+ queryString2);
        }
      }
      if (page > 1) {
        links.put(""String_Node_Str"",requestPath + (page >= 2 ? ""String_Node_Str"" + (page - 1) : ""String_Node_Str"") + (page >= 2 ? ""String_Node_Str"" + pagesize : ""String_Node_Str"" + pagesize)+ ""String_Node_Str""+ queryString2);
      }
    }
  }
  return links;
}"
93676,"/** 
 * Expire a cookie, notifying a User Agent to remove it from its cookie jar. The context must have first been routed to a   {@link io.vertx.ext.web.handler.CookieHandler} for this to work.
 * @param name  the name of the cookie
 * @return the cookie, if it existed, or null
 */
@Nullable Cookie removeCookie(String name);","/** 
 * Remove a cookie from the cookie set. If invalidate is true then it will expire a cookie, notifying a User Agent to remove it from its cookie jar. The context must have first been routed to a  {@link io.vertx.ext.web.handler.CookieHandler} for this to work.
 * @param name  the name of the cookie
 * @return the cookie, if it existed, or null
 */
@Nullable Cookie removeCookie(String name,boolean invalidate);"
93677,"private void addStoreSessionHandler(RoutingContext context){
  context.addHeadersEndHandler(v -> {
    Session session=context.session();
    if (!session.isDestroyed()) {
      final int currentStatusCode=context.response().getStatusCode();
      if (currentStatusCode >= 200 && currentStatusCode < 400) {
        session.setAccessed();
        if (session.isRegenerated()) {
          final Cookie cookie=context.getCookie(sessionCookieName);
          cookie.setValue(session.id()).setPath(""String_Node_Str"").setSecure(sessionCookieSecure).setHttpOnly(sessionCookieHttpOnly);
          sessionStore.delete(session.oldId(),delete -> {
            if (delete.failed()) {
              log.error(""String_Node_Str"",delete.cause());
            }
 else {
              sessionStore.put(session,res -> {
                if (res.failed()) {
                  log.error(""String_Node_Str"",res.cause());
                }
              }
);
            }
          }
);
        }
 else {
          sessionStore.put(session,res -> {
            if (res.failed()) {
              log.error(""String_Node_Str"",res.cause());
            }
          }
);
        }
      }
 else {
        context.removeCookie(sessionCookieName);
      }
    }
 else {
      sessionStore.delete(session.id(),res -> {
        if (res.failed()) {
          log.error(""String_Node_Str"",res.cause());
        }
      }
);
    }
  }
);
}","private void addStoreSessionHandler(RoutingContext context){
  context.addHeadersEndHandler(v -> {
    Session session=context.session();
    if (!session.isDestroyed()) {
      final int currentStatusCode=context.response().getStatusCode();
      if (currentStatusCode >= 200 && currentStatusCode < 400) {
        session.setAccessed();
        if (session.isRegenerated()) {
          final Cookie cookie=context.getCookie(sessionCookieName);
          cookie.setValue(session.id()).setPath(""String_Node_Str"").setSecure(sessionCookieSecure).setHttpOnly(sessionCookieHttpOnly);
          sessionStore.delete(session.oldId(),delete -> {
            if (delete.failed()) {
              log.error(""String_Node_Str"",delete.cause());
            }
 else {
              sessionStore.put(session,res -> {
                if (res.failed()) {
                  log.error(""String_Node_Str"",res.cause());
                }
              }
);
            }
          }
);
        }
 else {
          sessionStore.put(session,res -> {
            if (res.failed()) {
              log.error(""String_Node_Str"",res.cause());
            }
          }
);
        }
      }
 else {
        context.removeCookie(sessionCookieName,false);
      }
    }
 else {
      sessionStore.delete(session.id(),res -> {
        if (res.failed()) {
          log.error(""String_Node_Str"",res.cause());
        }
      }
);
    }
  }
);
}"
93678,"@Override public Cookie removeCookie(String name){
  return decoratedContext.removeCookie(name);
}","@Override public Cookie removeCookie(String name,boolean invalidate){
  return decoratedContext.removeCookie(name,invalidate);
}"
93679,"@Override public Cookie removeCookie(String name){
  Cookie cookie=cookiesMap().get(name);
  if (cookie != null) {
    if (cookie.isFromUserAgent()) {
      cookie.setMaxAge(0L);
    }
 else {
      cookiesMap().remove(name);
    }
  }
  return cookie;
}","@Override public Cookie removeCookie(String name,boolean invalidate){
  Cookie cookie=cookiesMap().get(name);
  if (cookie != null) {
    if (invalidate && cookie.isFromUserAgent()) {
      cookie.setMaxAge(0L);
    }
 else {
      cookiesMap().remove(name);
    }
  }
  return cookie;
}"
93680,"@Override public Cookie removeCookie(String name){
  return inner.removeCookie(name);
}","@Override public Cookie removeCookie(String name,boolean invalidate){
  return inner.removeCookie(name,invalidate);
}"
93681,"@Override public ReadStream<Buffer> handler(Handler<Buffer> handler){
  if (handler != null) {
    handler.handle(TestUtils.randomBuffer(1024));
    vertx.runOnContext(v -> exceptionHandler.handle(cause));
  }
  return this;
}","@Override public ReadStream<Buffer> handler(Handler<Buffer> handler){
  if (handler != null) {
    vertx.runOnContext(v -> exceptionHandler.handle(cause));
  }
  return this;
}"
93682,"@Test public void testRequestPumpErrorNotYetConnected() throws Exception {
  HttpRequest<Buffer> post=client.post(DEFAULT_HTTP_PORT,DEFAULT_HTTP_HOST,""String_Node_Str"");
  server.requestHandler(req -> fail());
  Throwable cause=new Throwable();
  startServer();
  post.sendStream(new ReadStream<Buffer>(){
    Handler<Throwable> exceptionHandler;
    @Override public ReadStream<Buffer> exceptionHandler(    Handler<Throwable> handler){
      exceptionHandler=handler;
      return this;
    }
    @Override public ReadStream<Buffer> handler(    Handler<Buffer> handler){
      if (handler != null) {
        handler.handle(TestUtils.randomBuffer(1024));
        vertx.runOnContext(v -> exceptionHandler.handle(cause));
      }
      return this;
    }
    @Override public ReadStream<Buffer> pause(){
      return this;
    }
    @Override public ReadStream<Buffer> resume(){
      return this;
    }
    @Override public ReadStream<Buffer> endHandler(    Handler<Void> endHandler){
      return this;
    }
  }
,onFailure(err -> {
    assertSame(cause,err);
    testComplete();
  }
));
  await();
}","@Test public void testRequestPumpErrorNotYetConnected() throws Exception {
  HttpRequest<Buffer> post=client.post(DEFAULT_HTTP_PORT,DEFAULT_HTTP_HOST,""String_Node_Str"");
  server.requestHandler(req -> fail());
  Throwable cause=new Throwable();
  startServer();
  post.sendStream(new ReadStream<Buffer>(){
    Handler<Throwable> exceptionHandler;
    @Override public ReadStream<Buffer> exceptionHandler(    Handler<Throwable> handler){
      exceptionHandler=handler;
      return this;
    }
    @Override public ReadStream<Buffer> handler(    Handler<Buffer> handler){
      if (handler != null) {
        vertx.runOnContext(v -> exceptionHandler.handle(cause));
      }
      return this;
    }
    @Override public ReadStream<Buffer> pause(){
      return this;
    }
    @Override public ReadStream<Buffer> resume(){
      return this;
    }
    @Override public ReadStream<Buffer> endHandler(    Handler<Void> endHandler){
      return this;
    }
  }
,onFailure(err -> {
    assertSame(cause,err);
    testComplete();
  }
));
  await();
}"
93683,"@Override public RequestParameter isValidSingleParam(String value){
  try {
    Number number=parseNumber.apply(value);
    if (number != null && this.testMaximum(number) && this.testMinimum(number) && this.testMultipleOf(number)) {
      return RequestParameter.create(number);
    }
 else {
      throw ValidationException.ValidationExceptionFactory.generateNotMatchValidationException(""String_Node_Str"");
    }
  }
 catch (  NumberFormatException e) {
    throw ValidationException.ValidationExceptionFactory.generateNotMatchValidationException(""String_Node_Str"");
  }
}","@Override public RequestParameter isValidSingleParam(String value){
  try {
    Number number=parseNumber.apply(value);
    checkMaximum(number);
    checkMinimum(number);
    checkMultipleOf(number);
    return RequestParameter.create(number);
  }
 catch (  NumberFormatException e) {
    throw ValidationException.ValidationExceptionFactory.generateNotMatchValidationException(""String_Node_Str"");
  }
}"
93684,"@Override public Router getRouter(){
  Router router=Router.router(vertx);
  router.route().handler(BodyHandler.create());
  for (  OperationValue operation : operations.values()) {
    if (!options.isMountNotImplementedHandler() && !operation.isConfigured())     continue;
    List<Handler> handlersToLoad=new ArrayList<>();
    List<Handler> failureHandlersToLoad=new ArrayList<>();
    List<SecurityRequirement> securityRequirements=operation.getOperationModel().getSecurity();
    if (securityRequirements != null) {
      for (      SecurityRequirement securityRequirement : securityRequirements) {
        for (        Map.Entry<String,List<String>> securityValue : securityRequirement.entrySet()) {
          if (securityValue.getValue() != null && securityValue.getValue().size() != 0) {
            for (            String scope : securityValue.getValue()) {
              Handler securityHandlerToLoad=this.securityHandlers.get(new SecurityRequirementKey(securityValue.getKey(),scope));
              if (securityHandlerToLoad == null) {
                securityHandlerToLoad=this.securityHandlers.get(new SecurityRequirementKey(securityValue.getKey()));
                if (securityHandlerToLoad == null && options.isRequireSecurityHandlers())                 throw RouterFactoryException.createMissingSecurityHandler(securityValue.getKey(),scope);
 else                 handlersToLoad.add(securityHandlerToLoad);
              }
 else               handlersToLoad.add(securityHandlerToLoad);
            }
          }
 else {
            Handler securityHandlerToLoad=this.securityHandlers.get(new SecurityRequirementKey(securityValue.getKey()));
            if (securityHandlerToLoad == null && options.isRequireSecurityHandlers())             throw RouterFactoryException.createMissingSecurityHandler(securityValue.getKey());
 else             handlersToLoad.add(securityHandlerToLoad);
          }
        }
      }
    }
    Handler<RoutingContext> validationHandler=new OpenAPI3RequestValidationHandlerImpl(operation.getOperationModel(),operation.getParameters(),this.spec);
    handlersToLoad.add(validationHandler);
    if (this.options.isMountValidationFailureHandler())     failureHandlersToLoad.add(this.options.getValidationFailureHandler());
    if (operation.isConfigured()) {
      handlersToLoad.addAll(operation.getUserHandlers());
      failureHandlersToLoad.addAll(operation.getUserFailureHandlers());
    }
 else {
      handlersToLoad.add(this.options.getNotImplementedFailureHandler());
    }
    OpenAPI3PathResolver pathResolver=new OpenAPI3PathResolver(operation.getPath(),operation.getParameters());
    Route route=router.routeWithRegex(operation.getMethod(),pathResolver.solve().toString());
    Set<String> consumes=new HashSet<>();
    Set<String> produces=new HashSet<>();
    if (operation.getOperationModel().getRequestBody() != null && operation.getOperationModel().getRequestBody().getContent() != null)     consumes.addAll(operation.getOperationModel().getRequestBody().getContent().keySet());
    if (operation.getOperationModel().getResponses() != null)     for (    ApiResponse response : operation.getOperationModel().getResponses().values())     if (response.getContent() != null)     produces.addAll(response.getContent().keySet());
    for (    String ct : consumes)     route.consumes(ct);
    for (    String ct : produces)     route.produces(ct);
    if (options.isMountResponseContentTypeHandler() && produces.size() != 0)     route.handler(ResponseContentTypeHandler.create());
    route.setRegexGroupsNames(new ArrayList<>(pathResolver.getMappedGroups().values()));
    for (    Handler handler : handlersToLoad)     route.handler(handler);
    for (    Handler failureHandler : failureHandlersToLoad)     route.failureHandler(failureHandler);
  }
  return router;
}","@Override public Router getRouter(){
  Router router=Router.router(vertx);
  router.route().handler(BodyHandler.create());
  for (  OperationValue operation : operations.values()) {
    if (!options.isMountNotImplementedHandler() && !operation.isConfigured())     continue;
    List<Handler> handlersToLoad=new ArrayList<>();
    List<Handler> failureHandlersToLoad=new ArrayList<>();
    handlersToLoad.addAll(securityHandlers.solveSecurityHandlers(operation.getOperationModel().getSecurity(),this.options().isRequireSecurityHandlers()));
    Handler<RoutingContext> validationHandler=new OpenAPI3RequestValidationHandlerImpl(operation.getOperationModel(),operation.getParameters(),this.spec);
    handlersToLoad.add(validationHandler);
    if (this.options.isMountValidationFailureHandler())     failureHandlersToLoad.add(this.options.getValidationFailureHandler());
    if (operation.isConfigured()) {
      handlersToLoad.addAll(operation.getUserHandlers());
      failureHandlersToLoad.addAll(operation.getUserFailureHandlers());
    }
 else {
      handlersToLoad.add(this.options.getNotImplementedFailureHandler());
    }
    OpenAPI3PathResolver pathResolver=new OpenAPI3PathResolver(operation.getPath(),operation.getParameters());
    Route route=router.routeWithRegex(operation.getMethod(),pathResolver.solve().toString());
    Set<String> consumes=new HashSet<>();
    Set<String> produces=new HashSet<>();
    if (operation.getOperationModel().getRequestBody() != null && operation.getOperationModel().getRequestBody().getContent() != null)     consumes.addAll(operation.getOperationModel().getRequestBody().getContent().keySet());
    if (operation.getOperationModel().getResponses() != null)     for (    ApiResponse response : operation.getOperationModel().getResponses().values())     if (response.getContent() != null)     produces.addAll(response.getContent().keySet());
    for (    String ct : consumes)     route.consumes(ct);
    for (    String ct : produces)     route.produces(ct);
    if (options.isMountResponseContentTypeHandler() && produces.size() != 0)     route.handler(ResponseContentTypeHandler.create());
    route.setRegexGroupsNames(new ArrayList<>(pathResolver.getMappedGroups().values()));
    for (    Handler handler : handlersToLoad)     route.handler(handler);
    for (    Handler failureHandler : failureHandlersToLoad)     route.failureHandler(failureHandler);
  }
  return router;
}"
93685,"@Override public OpenAPI3RouterFactory addSecurityHandler(String securitySchemaName,Handler handler){
  SecurityRequirementKey key=new SecurityRequirementKey(securitySchemaName);
  securityHandlers.put(key,handler);
  return this;
}","@Override public OpenAPI3RouterFactory addSecurityHandler(String securitySchemaName,Handler handler){
  securityHandlers.addSecurityRequirement(securitySchemaName,handler);
  return this;
}"
93686,"public OpenAPI3RouterFactoryImpl(Vertx vertx,OpenAPI spec){
  super(vertx,spec);
  this.operations=new LinkedHashMap<>();
  this.securityHandlers=new HashMap<>();
  for (  Map.Entry<String,? extends PathItem> pathEntry : spec.getPaths().entrySet()) {
    for (    Map.Entry<PathItem.HttpMethod,? extends Operation> opEntry : pathEntry.getValue().readOperationsMap().entrySet()) {
      this.operations.put(opEntry.getValue().getOperationId(),new OperationValue(HttpMethod.valueOf(opEntry.getKey().name()),pathEntry.getKey(),opEntry.getValue(),pathEntry.getValue().getParameters()));
    }
  }
}","public OpenAPI3RouterFactoryImpl(Vertx vertx,OpenAPI spec){
  super(vertx,spec);
  this.operations=new LinkedHashMap<>();
  this.securityHandlers=new SecurityHandlersStore();
  for (  Map.Entry<String,? extends PathItem> pathEntry : spec.getPaths().entrySet()) {
    for (    Map.Entry<PathItem.HttpMethod,? extends Operation> opEntry : pathEntry.getValue().readOperationsMap().entrySet()) {
      this.operations.put(opEntry.getValue().getOperationId(),new OperationValue(HttpMethod.valueOf(opEntry.getKey().name()),pathEntry.getKey(),opEntry.getValue(),pathEntry.getValue().getParameters()));
    }
  }
}"
93687,"@Override public OpenAPI3RouterFactory addSecuritySchemaScopeValidator(String securitySchemaName,String scopeName,Handler handler){
  SecurityRequirementKey key=new SecurityRequirementKey(securitySchemaName,scopeName);
  securityHandlers.put(key,handler);
  return this;
}","@Override public OpenAPI3RouterFactory addSecuritySchemaScopeValidator(String securitySchemaName,String scopeName,Handler handler){
  securityHandlers.addSecurityRequirement(securitySchemaName,scopeName,handler);
  return this;
}"
93688,"@Test public void requireSecurityHandler() throws Exception {
  CountDownLatch latch=new CountDownLatch(1);
  OpenAPI3RouterFactory.createRouterFactoryFromFile(this.vertx,""String_Node_Str"",openAPI3RouterFactoryAsyncResult -> {
    routerFactory=openAPI3RouterFactoryAsyncResult.result();
    routerFactory.setOptions(new DesignDrivenRouterFactoryOptions().setRequireSecurityHandlers(true));
    routerFactory.addHandlerByOperationId(""String_Node_Str"",routingContext -> {
      routingContext.response().setStatusCode(200).setStatusMessage(routingContext.get(""String_Node_Str"") + ""String_Node_Str"").end();
    }
);
    latch.countDown();
  }
);
  awaitLatch(latch);
  assertThrow(() -> routerFactory.getRouter(),RouterFactoryException.class);
  routerFactory.addSecurityHandler(""String_Node_Str"",routingContext -> routingContext.next());
  assertNotThrow(() -> routerFactory.getRouter(),RouterFactoryException.class);
}","@Test public void requireSecurityHandler() throws Exception {
  CountDownLatch latch=new CountDownLatch(1);
  OpenAPI3RouterFactory.createRouterFactoryFromFile(this.vertx,""String_Node_Str"",openAPI3RouterFactoryAsyncResult -> {
    routerFactory=openAPI3RouterFactoryAsyncResult.result();
    routerFactory.setOptions(new DesignDrivenRouterFactoryOptions().setRequireSecurityHandlers(true));
    routerFactory.addHandlerByOperationId(""String_Node_Str"",routingContext -> {
      routingContext.response().setStatusCode(200).setStatusMessage(routingContext.get(""String_Node_Str"") + ""String_Node_Str"").end();
    }
);
    latch.countDown();
  }
);
  awaitLatch(latch);
  assertThrow(routerFactory::getRouter,RouterFactoryException.class);
  routerFactory.addSecurityHandler(""String_Node_Str"",routingContext -> routingContext.next());
  assertNotThrow(routerFactory::getRouter,RouterFactoryException.class);
}"
93689,"/** 
 * Create a new OpenAPI3RouterFactory from an url
 * @param vertx
 * @param url
 * @param handler  When specification is loaded, this handler will be called with AsyncResult<OpenAPI3RouterFactory>
 */
static void createRouterFactoryFromURL(Vertx vertx,String url,Handler<AsyncResult<OpenAPI3RouterFactory>> handler){
  vertx.executeBlocking((  Future<OpenAPI3RouterFactory> future) -> {
    try {
      URL urlObj=new URL(url);
      SwaggerParseResult swaggerParseResult=new OpenAPIV3Parser().readLocation(urlObj.toString(),null,OpenApi3Utils.getParseOptions());
      if (swaggerParseResult.getMessages().isEmpty())       future.complete(new OpenAPI3RouterFactoryImpl(vertx,swaggerParseResult.getOpenAPI()));
 else {
        if (swaggerParseResult.getMessages().size() == 1 && swaggerParseResult.getMessages().get(0).startsWith(""String_Node_Str""))         future.fail(RouterFactoryException.createSpecNotExistsException(url));
 else         future.fail(RouterFactoryException.createSpecInvalidException(StringUtils.join(swaggerParseResult.getMessages(),""String_Node_Str"")));
      }
    }
 catch (    IOException e) {
      future.fail(RouterFactoryException.createSpecNotExistsException(url));
    }
  }
,handler);
}","/** 
 * Create a new OpenAPI3RouterFactory from an url
 * @param vertx
 * @param url
 * @param handler  When specification is loaded, this handler will be called with AsyncResult<OpenAPI3RouterFactory>
 */
static void createRouterFactoryFromURL(Vertx vertx,String url,Handler<AsyncResult<OpenAPI3RouterFactory>> handler){
  vertx.executeBlocking((  Future<OpenAPI3RouterFactory> future) -> {
    try {
      URL urlObj=new URL(url);
      SwaggerParseResult swaggerParseResult=new OpenAPIV3Parser().readLocation(urlObj.toString(),null,OpenApi3Utils.getParseOptions());
      if (swaggerParseResult.getMessages().isEmpty())       future.complete(new OpenAPI3RouterFactoryImpl(vertx,swaggerParseResult.getOpenAPI()));
 else {
        if (swaggerParseResult.getMessages().size() == 1 && swaggerParseResult.getMessages().get(0).startsWith(""String_Node_Str"" + url))         future.fail(RouterFactoryException.createSpecNotExistsException(url));
 else         future.fail(RouterFactoryException.createSpecInvalidException(StringUtils.join(swaggerParseResult.getMessages(),""String_Node_Str"")));
      }
    }
 catch (    IOException e) {
      future.fail(RouterFactoryException.createSpecNotExistsException(url));
    }
  }
,handler);
}"
93690,"@Override protected RequestParameter validate(Map<String,String> values) throws ValidationException {
  Map<String,RequestParameter> parsedParams=new HashMap<>();
  for (  Map.Entry<String,ObjectField> field : fieldsMap.entrySet()) {
    String valueToValidate=values.get(field.getKey());
    if (valueToValidate == null) {
      if (field.getValue().required)       throw ValidationException.ValidationExceptionFactory.generateObjectFieldNotFound(field.getKey());
 else       if (field.getValue().validator.getDefault() != null)       parsedParams.put(field.getKey(),RequestParameter.create(field.getKey(),field.getValue().validator.getDefault()));
    }
 else {
      RequestParameter param=field.getValue().validator.isValid(valueToValidate);
      param.setName(field.getKey());
      parsedParams.put(field.getKey(),param);
    }
  }
  return RequestParameter.create(parsedParams);
}","@Override protected RequestParameter validate(Map<String,String> values) throws ValidationException {
  Map<String,RequestParameter> parsedParams=new HashMap<>();
  for (  Map.Entry<String,ObjectField> field : fieldsMap.entrySet()) {
    if (!values.containsKey(field.getKey())) {
      if (field.getValue().required)       throw ValidationException.ValidationExceptionFactory.generateObjectFieldNotFound(field.getKey());
 else       if (field.getValue().validator.getDefault() != null)       parsedParams.put(field.getKey(),RequestParameter.create(field.getKey(),field.getValue().validator.getDefault()));
    }
 else {
      RequestParameter param=field.getValue().validator.isValid(values.get(field.getKey()));
      param.setName(field.getKey());
      parsedParams.put(field.getKey(),param);
    }
  }
  return RequestParameter.create(parsedParams);
}"
93691,"public ParameterValidationRuleImpl(String name,ParameterTypeValidator validator,boolean isOptional,boolean allowEmptyValue,ParameterLocation location){
  if (name == null)   throw new NullPointerException(""String_Node_Str"");
  this.name=name;
  if (validator == null)   throw new NullPointerException(""String_Node_Str"");
  this.validator=validator;
  this.isOptional=isOptional;
  this.allowEmptyValue=allowEmptyValue;
  this.location=location;
}","public ParameterValidationRuleImpl(String name,ParameterTypeValidator validator,boolean isOptional,boolean allowEmptyValue,ParameterLocation location){
  if (name == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.name=name;
  if (validator == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.validator=validator;
  this.isOptional=isOptional;
  this.allowEmptyValue=allowEmptyValue;
  this.location=location;
}"
93692,"@Override public Map<String,String> deserializeObject(String serialized) throws ValidationException {
  Map<String,String> result=new HashMap<>();
  String[] values=serialized.split(separator,-1);
  if (values.length % 2 != 0)   throw ValidationException.ValidationExceptionFactory.generateDeserializationError(""String_Node_Str"" + ""String_Node_Str"");
  for (int i=0; i < values.length; i+=2) {
    if (values[i].length() == 0) {
      throw ValidationException.ValidationExceptionFactory.generateDeserializationError(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      result.put(values[i],values[i + 1]);
    }
  }
  return result;
}","@Override public Map<String,String> deserializeObject(String serialized) throws ValidationException {
  Map<String,String> result=new HashMap<>();
  String[] values=serialized.split(separator,-1);
  if (values.length % 2 != 0)   throw ValidationException.ValidationExceptionFactory.generateDeserializationError(""String_Node_Str"" + ""String_Node_Str"");
  for (int i=0; i < values.length; i+=2) {
    if (values[i].length() == 0) {
      throw ValidationException.ValidationExceptionFactory.generateDeserializationError(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      result.put(values[i],this.nullateValue(values[i + 1]));
    }
  }
  return result;
}"
93693,"@Override public List<String> deserializeArray(String serialized) throws ValidationException {
  List<String> values=new ArrayList<>();
  for (  String v : serialized.split(separator,-1)) {
    values.add(v);
  }
  return values;
}","@Override public List<String> deserializeArray(String serialized) throws ValidationException {
  List<String> values=new ArrayList<>();
  for (  String v : serialized.split(separator,-1)) {
    values.add(this.nullateValue(v));
  }
  return values;
}"
93694,"/** 
 * Test: query_form_explode_empty Expected parameters sent: color: color= Expected response: {""color"":null}
 * @throws Exception
 */
@Test public void testQueryFormExplodeEmpty() throws Exception {
  routerFactory.addHandlerByOperationId(""String_Node_Str"",routingContext -> {
    RequestParameters params=routingContext.get(""String_Node_Str"");
    JsonObject res=new JsonObject();
    RequestParameter color_query=params.queryParameter(""String_Node_Str"");
    assertNotNull(color_query);
    assertTrue(color_query.isEmpty());
    res.putNull(""String_Node_Str"");
    routingContext.response().setStatusCode(200).setStatusMessage(""String_Node_Str"").putHeader(""String_Node_Str"",""String_Node_Str"").end(res.encode());
  }
);
  CountDownLatch latch=new CountDownLatch(1);
  String color_query;
  color_query=""String_Node_Str"";
  startServer();
  apiClient.queryFormExplodeEmpty(color_query,(  AsyncResult<HttpResponse> ar) -> {
    if (ar.succeeded()) {
      assertEquals(200,ar.result().statusCode());
      assertTrue(""String_Node_Str"" + new JsonObject(""String_Node_Str"").encode() + ""String_Node_Str""+ ar.result().bodyAsJsonObject().encode(),new JsonObject(""String_Node_Str"").equals(ar.result().bodyAsJsonObject()));
    }
 else {
      assertTrue(ar.cause().getMessage(),false);
    }
    latch.countDown();
  }
);
  awaitLatch(latch);
}","/** 
 * Test: query_form_explode_empty Expected parameters sent: color: color= Expected response: {""color"":null}
 * @throws Exception
 */
@Test public void testQueryFormExplodeEmpty() throws Exception {
  routerFactory.addHandlerByOperationId(""String_Node_Str"",routingContext -> {
    RequestParameters params=routingContext.get(""String_Node_Str"");
    JsonObject res=new JsonObject();
    RequestParameter color_query=params.queryParameter(""String_Node_Str"");
    assertNotNull(color_query.getString());
    assertTrue(color_query.getString().isEmpty());
    res.putNull(""String_Node_Str"");
    routingContext.response().setStatusCode(200).setStatusMessage(""String_Node_Str"").putHeader(""String_Node_Str"",""String_Node_Str"").end(res.encode());
  }
);
  CountDownLatch latch=new CountDownLatch(1);
  String color_query;
  color_query=""String_Node_Str"";
  startServer();
  apiClient.queryFormExplodeEmpty(color_query,(  AsyncResult<HttpResponse> ar) -> {
    if (ar.succeeded()) {
      assertEquals(200,ar.result().statusCode());
      assertTrue(""String_Node_Str"" + new JsonObject(""String_Node_Str"").encode() + ""String_Node_Str""+ ar.result().bodyAsJsonObject().encode(),new JsonObject(""String_Node_Str"").equals(ar.result().bodyAsJsonObject()));
    }
 else {
      assertTrue(ar.cause().getMessage(),false);
    }
    latch.countDown();
  }
);
  awaitLatch(latch);
}"
93695,"/** 
 * Test: query_form_noexplode_empty Expected parameters sent: color: color= Expected response: {""color"":null}
 * @throws Exception
 */
@Test public void testQueryFormNoexplodeEmpty() throws Exception {
  routerFactory.addHandlerByOperationId(""String_Node_Str"",routingContext -> {
    RequestParameters params=routingContext.get(""String_Node_Str"");
    JsonObject res=new JsonObject();
    RequestParameter color_query=params.queryParameter(""String_Node_Str"");
    assertNotNull(color_query);
    assertTrue(color_query.isEmpty());
    res.putNull(""String_Node_Str"");
    routingContext.response().setStatusCode(200).setStatusMessage(""String_Node_Str"").putHeader(""String_Node_Str"",""String_Node_Str"").end(res.encode());
  }
);
  CountDownLatch latch=new CountDownLatch(1);
  String color_query;
  color_query=""String_Node_Str"";
  startServer();
  apiClient.queryFormNoexplodeEmpty(color_query,(  AsyncResult<HttpResponse> ar) -> {
    if (ar.succeeded()) {
      assertEquals(200,ar.result().statusCode());
      assertTrue(""String_Node_Str"" + new JsonObject(""String_Node_Str"").encode() + ""String_Node_Str""+ ar.result().bodyAsJsonObject().encode(),new JsonObject(""String_Node_Str"").equals(ar.result().bodyAsJsonObject()));
    }
 else {
      assertTrue(ar.cause().getMessage(),false);
    }
    latch.countDown();
  }
);
  awaitLatch(latch);
}","/** 
 * Test: query_form_noexplode_empty Expected parameters sent: color: color= Expected response: {""color"":null}
 * @throws Exception
 */
@Test public void testQueryFormNoexplodeEmpty() throws Exception {
  routerFactory.addHandlerByOperationId(""String_Node_Str"",routingContext -> {
    RequestParameters params=routingContext.get(""String_Node_Str"");
    JsonObject res=new JsonObject();
    RequestParameter color_query=params.queryParameter(""String_Node_Str"");
    assertNotNull(color_query.getString());
    assertTrue(color_query.getString().isEmpty());
    res.putNull(""String_Node_Str"");
    routingContext.response().setStatusCode(200).setStatusMessage(""String_Node_Str"").putHeader(""String_Node_Str"",""String_Node_Str"").end(res.encode());
  }
);
  CountDownLatch latch=new CountDownLatch(1);
  String color_query;
  color_query=""String_Node_Str"";
  startServer();
  apiClient.queryFormNoexplodeEmpty(color_query,(  AsyncResult<HttpResponse> ar) -> {
    if (ar.succeeded()) {
      assertEquals(200,ar.result().statusCode());
      assertTrue(""String_Node_Str"" + new JsonObject(""String_Node_Str"").encode() + ""String_Node_Str""+ ar.result().bodyAsJsonObject().encode(),new JsonObject(""String_Node_Str"").equals(ar.result().bodyAsJsonObject()));
    }
 else {
      assertTrue(ar.cause().getMessage(),false);
    }
    latch.countDown();
  }
);
  awaitLatch(latch);
}"
93696,"/** 
 * Test: cookie_form_explode_empty Expected parameters sent: color: color= Expected response: {""color"":null}
 * @throws Exception
 */
@Test public void testCookieFormExplodeEmpty() throws Exception {
  routerFactory.addHandlerByOperationId(""String_Node_Str"",routingContext -> {
    RequestParameters params=routingContext.get(""String_Node_Str"");
    JsonObject res=new JsonObject();
    RequestParameter color_cookie=params.cookieParameter(""String_Node_Str"");
    assertNotNull(color_cookie);
    assertTrue(color_cookie.isEmpty());
    res.putNull(""String_Node_Str"");
    routingContext.response().setStatusCode(200).setStatusMessage(""String_Node_Str"").putHeader(""String_Node_Str"",""String_Node_Str"").end(res.encode());
  }
);
  CountDownLatch latch=new CountDownLatch(1);
  String color_cookie;
  color_cookie=""String_Node_Str"";
  startServer();
  apiClient.cookieFormExplodeEmpty(color_cookie,(  AsyncResult<HttpResponse> ar) -> {
    if (ar.succeeded()) {
      assertEquals(200,ar.result().statusCode());
      assertTrue(""String_Node_Str"" + new JsonObject(""String_Node_Str"").encode() + ""String_Node_Str""+ ar.result().bodyAsJsonObject().encode(),new JsonObject(""String_Node_Str"").equals(ar.result().bodyAsJsonObject()));
    }
 else {
      assertTrue(ar.cause().getMessage(),false);
    }
    latch.countDown();
  }
);
  awaitLatch(latch);
}","/** 
 * Test: cookie_form_explode_empty Expected parameters sent: color: color= Expected response: {""color"":null}
 * @throws Exception
 */
@Test public void testCookieFormExplodeEmpty() throws Exception {
  routerFactory.addHandlerByOperationId(""String_Node_Str"",routingContext -> {
    RequestParameters params=routingContext.get(""String_Node_Str"");
    JsonObject res=new JsonObject();
    RequestParameter color_cookie=params.cookieParameter(""String_Node_Str"");
    assertNotNull(color_cookie.getString());
    assertTrue(color_cookie.getString().isEmpty());
    res.putNull(""String_Node_Str"");
    routingContext.response().setStatusCode(200).setStatusMessage(""String_Node_Str"").putHeader(""String_Node_Str"",""String_Node_Str"").end(res.encode());
  }
);
  CountDownLatch latch=new CountDownLatch(1);
  String color_cookie;
  color_cookie=""String_Node_Str"";
  startServer();
  apiClient.cookieFormExplodeEmpty(color_cookie,(  AsyncResult<HttpResponse> ar) -> {
    if (ar.succeeded()) {
      assertEquals(200,ar.result().statusCode());
      assertTrue(""String_Node_Str"" + new JsonObject(""String_Node_Str"").encode() + ""String_Node_Str""+ ar.result().bodyAsJsonObject().encode(),new JsonObject(""String_Node_Str"").equals(ar.result().bodyAsJsonObject()));
    }
 else {
      assertTrue(ar.cause().getMessage(),false);
    }
    latch.countDown();
  }
);
  awaitLatch(latch);
}"
93697,"/** 
 * Test: cookie_form_noexplode_empty Expected parameters sent: color: color= Expected response: {""color"":null}
 * @throws Exception
 */
@Test public void testCookieFormNoexplodeEmpty() throws Exception {
  routerFactory.addHandlerByOperationId(""String_Node_Str"",routingContext -> {
    RequestParameters params=routingContext.get(""String_Node_Str"");
    JsonObject res=new JsonObject();
    RequestParameter color_cookie=params.cookieParameter(""String_Node_Str"");
    assertNotNull(color_cookie);
    assertTrue(color_cookie.isEmpty());
    res.putNull(""String_Node_Str"");
    routingContext.response().setStatusCode(200).setStatusMessage(""String_Node_Str"").putHeader(""String_Node_Str"",""String_Node_Str"").end(res.encode());
  }
);
  CountDownLatch latch=new CountDownLatch(1);
  String color_cookie;
  color_cookie=""String_Node_Str"";
  startServer();
  apiClient.cookieFormNoexplodeEmpty(color_cookie,(  AsyncResult<HttpResponse> ar) -> {
    if (ar.succeeded()) {
      assertEquals(200,ar.result().statusCode());
      assertTrue(""String_Node_Str"" + new JsonObject(""String_Node_Str"").encode() + ""String_Node_Str""+ ar.result().bodyAsJsonObject().encode(),new JsonObject(""String_Node_Str"").equals(ar.result().bodyAsJsonObject()));
    }
 else {
      assertTrue(ar.cause().getMessage(),false);
    }
    latch.countDown();
  }
);
  awaitLatch(latch);
}","/** 
 * Test: cookie_form_noexplode_empty Expected parameters sent: color: color= Expected response: {""color"":null}
 * @throws Exception
 */
@Test public void testCookieFormNoexplodeEmpty() throws Exception {
  routerFactory.addHandlerByOperationId(""String_Node_Str"",routingContext -> {
    RequestParameters params=routingContext.get(""String_Node_Str"");
    JsonObject res=new JsonObject();
    RequestParameter color_cookie=params.cookieParameter(""String_Node_Str"");
    assertNotNull(color_cookie.getString());
    assertTrue(color_cookie.getString().isEmpty());
    res.putNull(""String_Node_Str"");
    routingContext.response().setStatusCode(200).setStatusMessage(""String_Node_Str"").putHeader(""String_Node_Str"",""String_Node_Str"").end(res.encode());
  }
);
  CountDownLatch latch=new CountDownLatch(1);
  String color_cookie;
  color_cookie=""String_Node_Str"";
  startServer();
  apiClient.cookieFormNoexplodeEmpty(color_cookie,(  AsyncResult<HttpResponse> ar) -> {
    if (ar.succeeded()) {
      assertEquals(200,ar.result().statusCode());
      assertTrue(""String_Node_Str"" + new JsonObject(""String_Node_Str"").encode() + ""String_Node_Str""+ ar.result().bodyAsJsonObject().encode(),new JsonObject(""String_Node_Str"").equals(ar.result().bodyAsJsonObject()));
    }
 else {
      assertTrue(ar.cause().getMessage(),false);
    }
    latch.countDown();
  }
);
  awaitLatch(latch);
}"
93698,"/** 
 * Create a new OpenAPI3RouterFactory from an url
 * @param vertx
 * @param url
 * @param handler  When specification is loaded, this handler will be called with AsyncResult<OpenAPI3RouterFactory>
 */
static void createRouterFactoryFromURL(Vertx vertx,String url,Handler<AsyncResult<OpenAPI3RouterFactory>> handler){
  vertx.executeBlocking((  Future<OpenAPI3RouterFactory> future) -> {
    try {
      URL urlObj=new URL(url);
      SwaggerParseResult swaggerParseResult=new OpenAPIV3Parser().readLocation(urlObj.toString(),null,OpenApi3Utils.getParseOptions());
      if (swaggerParseResult.getMessages().isEmpty())       future.complete(new OpenAPI3RouterFactoryImpl(vertx,swaggerParseResult.getOpenAPI()));
 else {
        if (swaggerParseResult.getMessages().size() == 1 && swaggerParseResult.getMessages().get(0).startsWith(""String_Node_Str"" + url))         future.fail(RouterFactoryException.createSpecNotExistsException(url));
 else         future.fail(RouterFactoryException.createSpecInvalidException(StringUtils.join(swaggerParseResult.getMessages(),""String_Node_Str"")));
      }
    }
 catch (    IOException e) {
      future.fail(RouterFactoryException.createSpecNotExistsException(url));
    }
  }
,handler);
}","/** 
 * Create a new OpenAPI3RouterFactory from an url
 * @param vertx
 * @param url
 * @param handler  When specification is loaded, this handler will be called with AsyncResult<OpenAPI3RouterFactory>
 */
static void createRouterFactoryFromURL(Vertx vertx,String url,Handler<AsyncResult<OpenAPI3RouterFactory>> handler){
  vertx.executeBlocking((  Future<OpenAPI3RouterFactory> future) -> {
    try {
      URL urlObj=new URL(url);
      SwaggerParseResult swaggerParseResult=new OpenAPIV3Parser().readLocation(urlObj.toString(),null,OpenApi3Utils.getParseOptions());
      if (swaggerParseResult.getMessages().isEmpty())       future.complete(new OpenAPI3RouterFactoryImpl(vertx,swaggerParseResult.getOpenAPI()));
 else {
        if (swaggerParseResult.getMessages().size() == 1 && swaggerParseResult.getMessages().get(0).matches(""String_Node_Str"" + url + ""String_Node_Str""))         future.fail(RouterFactoryException.createSpecNotExistsException(url));
 else         future.fail(RouterFactoryException.createSpecInvalidException(StringUtils.join(swaggerParseResult.getMessages(),""String_Node_Str"")));
      }
    }
 catch (    IOException e) {
      future.fail(RouterFactoryException.createSpecNotExistsException(url));
    }
  }
,handler);
}"
93699,"@Override public HTTPRequestValidationHandler addFormParamsArrayWithPattern(String parameterName,String pattern,boolean required){
  this.addFormParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(parameterName,ParameterTypeValidator.createArrayTypeValidator(ParameterTypeValidator.createStringTypeValidator(pattern)),!required,false,ParameterLocation.BODY_FORM));
  return this;
}","@Override public HTTPRequestValidationHandler addFormParamsArrayWithPattern(String parameterName,String pattern,boolean required){
  this.addFormParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(parameterName,ParameterTypeValidator.createArrayTypeValidator(ParameterTypeValidator.createStringTypeValidator(pattern,null)),!required,false,ParameterLocation.BODY_FORM));
  return this;
}"
93700,"@Override public HTTPRequestValidationHandler addQueryParamWithPattern(String parameterName,String pattern,boolean required){
  this.addQueryParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(parameterName,ParameterTypeValidator.createStringTypeValidator(pattern),!required,false,ParameterLocation.QUERY));
  return this;
}","@Override public HTTPRequestValidationHandler addQueryParamWithPattern(String parameterName,String pattern,boolean required){
  this.addQueryParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(parameterName,ParameterTypeValidator.createStringTypeValidator(pattern,null),!required,false,ParameterLocation.QUERY));
  return this;
}"
93701,"@Override public HTTPRequestValidationHandler addPathParamWithPattern(String parameterName,String pattern){
  this.addPathParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(parameterName,ParameterTypeValidator.createStringTypeValidator(pattern),false,false,ParameterLocation.PATH));
  return this;
}","@Override public HTTPRequestValidationHandler addPathParamWithPattern(String parameterName,String pattern){
  this.addPathParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(parameterName,ParameterTypeValidator.createStringTypeValidator(pattern,null),false,false,ParameterLocation.PATH));
  return this;
}"
93702,"@Override public HTTPRequestValidationHandler addHeaderParamWithPattern(String headerName,String pattern,boolean required){
  this.addHeaderParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(headerName,ParameterTypeValidator.createStringTypeValidator(pattern),!required,false,ParameterLocation.HEADER));
  return this;
}","@Override public HTTPRequestValidationHandler addHeaderParamWithPattern(String headerName,String pattern,boolean required){
  this.addHeaderParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(headerName,ParameterTypeValidator.createStringTypeValidator(pattern,null),!required,false,ParameterLocation.HEADER));
  return this;
}"
93703,"@Override public HTTPRequestValidationHandler addQueryParamsArrayWithPattern(String arrayName,String pattern,boolean required){
  this.addQueryParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(arrayName,ParameterTypeValidator.createArrayTypeValidator(ParameterTypeValidator.createStringTypeValidator(pattern)),!required,false,ParameterLocation.QUERY));
  return this;
}","@Override public HTTPRequestValidationHandler addQueryParamsArrayWithPattern(String arrayName,String pattern,boolean required){
  this.addQueryParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(arrayName,ParameterTypeValidator.createArrayTypeValidator(ParameterTypeValidator.createStringTypeValidator(pattern,null)),!required,false,ParameterLocation.QUERY));
  return this;
}"
93704,"@Override public HTTPRequestValidationHandler addFormParamWithPattern(String parameterName,String pattern,boolean required){
  this.addFormParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(parameterName,ParameterTypeValidator.createStringTypeValidator(pattern),!required,false,ParameterLocation.BODY_FORM));
  return this;
}","@Override public HTTPRequestValidationHandler addFormParamWithPattern(String parameterName,String pattern,boolean required){
  this.addFormParamRule(ParameterValidationRuleImpl.ParameterValidationRuleFactory.createValidationRuleWithCustomTypeValidator(parameterName,ParameterTypeValidator.createStringTypeValidator(pattern,null),!required,false,ParameterLocation.BODY_FORM));
  return this;
}"
93705,"/** 
 * Create a new OpenAPI3RouterFactory from a filename
 * @param vertx
 * @param filename
 * @param handler  When specification is loaded, this handler will be called with AsyncResult<OpenAPI3RouterFactory>
 */
static void createRouterFactoryFromFile(Vertx vertx,String filename,Handler<AsyncResult<OpenAPI3RouterFactory>> handler){
  vertx.executeBlocking((  Future<OpenAPI3RouterFactory> future) -> {
    File spec=new File(filename);
    if (!spec.exists())     future.fail(RouterFactoryException.createSpecNotExistsException(filename));
    SwaggerParseResult swaggerParseResult=new OpenAPIV3Parser().readLocation(spec.getAbsolutePath(),null,null);
    if (swaggerParseResult.getMessages().isEmpty())     future.complete(new OpenAPI3RouterFactoryImpl(vertx,swaggerParseResult.getOpenAPI()));
 else {
      future.fail(RouterFactoryException.createSpecInvalidException(StringUtils.join(swaggerParseResult.getMessages(),""String_Node_Str"")));
    }
  }
,handler);
}","/** 
 * Create a new OpenAPI3RouterFactory from a filename
 * @param vertx
 * @param filename
 * @param handler  When specification is loaded, this handler will be called with AsyncResult<OpenAPI3RouterFactory>
 */
static void createRouterFactoryFromFile(Vertx vertx,String filename,Handler<AsyncResult<OpenAPI3RouterFactory>> handler){
  vertx.executeBlocking((  Future<OpenAPI3RouterFactory> future) -> {
    File spec=new File(filename);
    if (!spec.exists()) {
      future.fail(RouterFactoryException.createSpecNotExistsException(filename));
    }
 else {
      SwaggerParseResult swaggerParseResult=new OpenAPIV3Parser().readLocation(spec.getAbsolutePath(),null,null);
      if (swaggerParseResult.getMessages().isEmpty())       future.complete(new OpenAPI3RouterFactoryImpl(vertx,swaggerParseResult.getOpenAPI()));
 else {
        future.fail(RouterFactoryException.createSpecInvalidException(StringUtils.join(swaggerParseResult.getMessages(),""String_Node_Str"")));
      }
    }
  }
,handler);
}"
93706,"/** 
 * Create a new OpenAPI3RouterFactory from a filename
 * @param vertx
 * @param filename
 * @param handler  When specification is loaded, this handler will be called with AsyncResult<OpenAPI3RouterFactory>
 */
static void createRouterFactoryFromFile(Vertx vertx,String filename,Handler<AsyncResult<OpenAPI3RouterFactory>> handler){
  vertx.executeBlocking((  Future<OpenAPI3RouterFactory> future) -> {
    File spec=new File(filename);
    if (!spec.exists()) {
      future.fail(RouterFactoryException.createSpecNotExistsException(filename));
    }
 else {
      SwaggerParseResult swaggerParseResult=new OpenAPIV3Parser().readLocation(spec.getAbsolutePath(),null,null);
      if (swaggerParseResult.getMessages().isEmpty())       future.complete(new OpenAPI3RouterFactoryImpl(vertx,swaggerParseResult.getOpenAPI()));
 else {
        future.fail(RouterFactoryException.createSpecInvalidException(StringUtils.join(swaggerParseResult.getMessages(),""String_Node_Str"")));
      }
    }
  }
,handler);
}","/** 
 * Create a new OpenAPI3RouterFactory from a filename
 * @param vertx
 * @param filename
 * @param handler  When specification is loaded, this handler will be called with AsyncResult<OpenAPI3RouterFactory>
 */
static void createRouterFactoryFromFile(Vertx vertx,String filename,Handler<AsyncResult<OpenAPI3RouterFactory>> handler){
  vertx.executeBlocking((  Future<OpenAPI3RouterFactory> future) -> {
    File spec=new File(filename);
    if (!spec.exists())     future.fail(RouterFactoryException.createSpecNotExistsException(filename));
    SwaggerParseResult swaggerParseResult=new OpenAPIV3Parser().readLocation(spec.getAbsolutePath(),null,null);
    if (swaggerParseResult.getMessages().isEmpty())     future.complete(new OpenAPI3RouterFactoryImpl(vertx,swaggerParseResult.getOpenAPI()));
 else {
      future.fail(RouterFactoryException.createSpecInvalidException(StringUtils.join(swaggerParseResult.getMessages(),""String_Node_Str"")));
    }
  }
,handler);
}"
93707,"private void send(String contentType,Object body,Handler<AsyncResult<HttpResponse<T>>> handler){
  Future<HttpClientResponse> responseFuture=Future.<HttpClientResponse>future().setHandler(ar -> {
    if (ar.succeeded()) {
      HttpClientResponse resp=ar.result();
      Future<HttpResponse<T>> fut=Future.future();
      fut.setHandler(handler);
      resp.exceptionHandler(err -> {
        if (!fut.isComplete()) {
          fut.fail(err);
        }
      }
);
      resp.pause();
      codec.create(ar2 -> {
        resp.resume();
        if (ar2.succeeded()) {
          BodyStream<T> stream=ar2.result();
          stream.exceptionHandler(err -> {
            if (!fut.isComplete()) {
              fut.fail(err);
            }
          }
);
          resp.endHandler(v -> {
            if (!fut.isComplete()) {
              stream.end();
              if (stream.result().succeeded()) {
                fut.complete(new HttpResponseImpl<>(resp,null,stream.result().result()));
              }
 else {
                fut.fail(stream.result().cause());
              }
            }
          }
);
          Pump responsePump=Pump.pump(resp,stream);
          responsePump.start();
        }
 else {
          handler.handle(Future.failedFuture(ar2.cause()));
        }
      }
);
    }
 else {
      handler.handle(Future.failedFuture(ar.cause()));
    }
  }
);
  HttpClientRequest req;
  String requestURI;
  if (params != null && params.size() > 0) {
    QueryStringEncoder enc=new QueryStringEncoder(uri);
    params.forEach(param -> {
      enc.addParam(param.getKey(),param.getValue());
    }
);
    requestURI=enc.toString();
  }
 else {
    requestURI=uri;
  }
  if (ssl != options.isSsl()) {
    req=client.request(method,new RequestOptions().setSsl(ssl).setHost(host).setPort(port).setURI(uri));
  }
 else {
    req=client.request(method,port,host,requestURI);
  }
  req.setFollowRedirects(followRedirects);
  if (headers != null) {
    req.headers().addAll(headers);
  }
  req.exceptionHandler(err -> {
    if (!responseFuture.isComplete()) {
      responseFuture.fail(err);
    }
  }
);
  req.handler(resp -> {
    if (!responseFuture.isComplete()) {
      responseFuture.complete(resp);
    }
  }
);
  if (timeout > 0) {
    req.setTimeout(timeout);
  }
  if (body != null) {
    if (contentType != null) {
      String prev=req.headers().get(HttpHeaders.CONTENT_TYPE);
      if (prev == null) {
        req.putHeader(HttpHeaders.CONTENT_TYPE,contentType);
      }
 else {
        contentType=prev;
      }
    }
    if (body instanceof ReadStream<?>) {
      ReadStream<Buffer> stream=(ReadStream<Buffer>)body;
      if (headers == null || !headers.contains(HttpHeaders.CONTENT_LENGTH)) {
        req.setChunked(true);
      }
      Pump pump=Pump.pump(stream,req);
      stream.exceptionHandler(err -> {
        req.reset();
        if (!responseFuture.isComplete()) {
          responseFuture.fail(err);
        }
      }
);
      stream.endHandler(v -> {
        pump.stop();
        req.end();
      }
);
      pump.start();
    }
 else {
      Buffer buffer;
      if (body instanceof Buffer) {
        buffer=(Buffer)body;
      }
 else       if (body instanceof MultiMap) {
        try {
          MultiMap attributes=(MultiMap)body;
          boolean multipart=""String_Node_Str"".equals(contentType);
          DefaultFullHttpRequest request=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,io.netty.handler.codec.http.HttpMethod.POST,""String_Node_Str"");
          HttpPostRequestEncoder encoder=new HttpPostRequestEncoder(request,multipart);
          for (          Map.Entry<String,String> attribute : attributes) {
            encoder.addBodyAttribute(attribute.getKey(),attribute.getValue());
          }
          encoder.finalizeRequest();
          for (          String headerName : request.headers().names()) {
            req.putHeader(headerName,request.headers().get(headerName));
          }
          if (encoder.isChunked()) {
            buffer=Buffer.buffer();
            while (true) {
              HttpContent chunk=encoder.readChunk(new UnpooledByteBufAllocator(false));
              ByteBuf content=chunk.content();
              if (content.readableBytes() == 0) {
                break;
              }
              buffer.appendBuffer(Buffer.buffer(content));
            }
          }
 else {
            ByteBuf content=request.content();
            buffer=Buffer.buffer(content);
          }
        }
 catch (        Exception e) {
          throw new VertxException(e);
        }
      }
 else       if (body instanceof JsonObject) {
        buffer=Buffer.buffer(((JsonObject)body).encode());
      }
 else {
        buffer=Buffer.buffer(Json.encode(body));
      }
      req.end(buffer);
    }
  }
 else {
    req.end();
  }
}","private void send(String contentType,Object body,Handler<AsyncResult<HttpResponse<T>>> handler){
  Future<HttpClientResponse> responseFuture=Future.<HttpClientResponse>future().setHandler(ar -> {
    if (ar.succeeded()) {
      HttpClientResponse resp=ar.result();
      Future<HttpResponse<T>> fut=Future.future();
      fut.setHandler(handler);
      resp.exceptionHandler(err -> {
        if (!fut.isComplete()) {
          fut.fail(err);
        }
      }
);
      resp.pause();
      codec.create(ar2 -> {
        resp.resume();
        if (ar2.succeeded()) {
          BodyStream<T> stream=ar2.result();
          stream.exceptionHandler(err -> {
            if (!fut.isComplete()) {
              fut.fail(err);
            }
          }
);
          resp.endHandler(v -> {
            if (!fut.isComplete()) {
              stream.end();
              if (stream.result().succeeded()) {
                fut.complete(new HttpResponseImpl<>(resp,null,stream.result().result()));
              }
 else {
                fut.fail(stream.result().cause());
              }
            }
          }
);
          Pump responsePump=Pump.pump(resp,stream);
          responsePump.start();
        }
 else {
          handler.handle(Future.failedFuture(ar2.cause()));
        }
      }
);
    }
 else {
      handler.handle(Future.failedFuture(ar.cause()));
    }
  }
);
  HttpClientRequest req;
  String requestURI;
  if (params != null && params.size() > 0) {
    QueryStringEncoder enc=new QueryStringEncoder(uri);
    params.forEach(param -> {
      enc.addParam(param.getKey(),param.getValue());
    }
);
    requestURI=enc.toString();
  }
 else {
    requestURI=uri;
  }
  if (ssl != options.isSsl()) {
    req=client.request(method,new RequestOptions().setSsl(ssl).setHost(host).setPort(port).setURI(requestURI));
  }
 else {
    req=client.request(method,port,host,requestURI);
  }
  req.setFollowRedirects(followRedirects);
  if (headers != null) {
    req.headers().addAll(headers);
  }
  req.exceptionHandler(err -> {
    if (!responseFuture.isComplete()) {
      responseFuture.fail(err);
    }
  }
);
  req.handler(resp -> {
    if (!responseFuture.isComplete()) {
      responseFuture.complete(resp);
    }
  }
);
  if (timeout > 0) {
    req.setTimeout(timeout);
  }
  if (body != null) {
    if (contentType != null) {
      String prev=req.headers().get(HttpHeaders.CONTENT_TYPE);
      if (prev == null) {
        req.putHeader(HttpHeaders.CONTENT_TYPE,contentType);
      }
 else {
        contentType=prev;
      }
    }
    if (body instanceof ReadStream<?>) {
      ReadStream<Buffer> stream=(ReadStream<Buffer>)body;
      if (headers == null || !headers.contains(HttpHeaders.CONTENT_LENGTH)) {
        req.setChunked(true);
      }
      Pump pump=Pump.pump(stream,req);
      stream.exceptionHandler(err -> {
        req.reset();
        if (!responseFuture.isComplete()) {
          responseFuture.fail(err);
        }
      }
);
      stream.endHandler(v -> {
        pump.stop();
        req.end();
      }
);
      pump.start();
    }
 else {
      Buffer buffer;
      if (body instanceof Buffer) {
        buffer=(Buffer)body;
      }
 else       if (body instanceof MultiMap) {
        try {
          MultiMap attributes=(MultiMap)body;
          boolean multipart=""String_Node_Str"".equals(contentType);
          DefaultFullHttpRequest request=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,io.netty.handler.codec.http.HttpMethod.POST,""String_Node_Str"");
          HttpPostRequestEncoder encoder=new HttpPostRequestEncoder(request,multipart);
          for (          Map.Entry<String,String> attribute : attributes) {
            encoder.addBodyAttribute(attribute.getKey(),attribute.getValue());
          }
          encoder.finalizeRequest();
          for (          String headerName : request.headers().names()) {
            req.putHeader(headerName,request.headers().get(headerName));
          }
          if (encoder.isChunked()) {
            buffer=Buffer.buffer();
            while (true) {
              HttpContent chunk=encoder.readChunk(new UnpooledByteBufAllocator(false));
              ByteBuf content=chunk.content();
              if (content.readableBytes() == 0) {
                break;
              }
              buffer.appendBuffer(Buffer.buffer(content));
            }
          }
 else {
            ByteBuf content=request.content();
            buffer=Buffer.buffer(content);
          }
        }
 catch (        Exception e) {
          throw new VertxException(e);
        }
      }
 else       if (body instanceof JsonObject) {
        buffer=Buffer.buffer(((JsonObject)body).encode());
      }
 else {
        buffer=Buffer.buffer(Json.encode(body));
      }
      req.end(buffer);
    }
  }
 else {
    req.end();
  }
}"
93708,"private void testTLS(boolean clientSSL,boolean serverSSL,Function<WebClient,HttpRequest<Buffer>> requestProvider) throws Exception {
  WebClient sslClient=WebClient.create(vertx,new WebClientOptions().setSsl(clientSSL).setTrustAll(true).setDefaultHost(DEFAULT_HTTPS_HOST).setDefaultPort(DEFAULT_HTTPS_PORT));
  HttpServer sslServer=vertx.createHttpServer(new HttpServerOptions().setSsl(serverSSL).setKeyStoreOptions(Cert.CLIENT_JKS.get()).setPort(DEFAULT_HTTPS_PORT).setHost(DEFAULT_HTTPS_HOST));
  sslServer.requestHandler(req -> {
    assertEquals(serverSSL,req.isSSL());
    req.response().end();
  }
);
  try {
    startServer(sslServer);
    HttpRequest<Buffer> builder=requestProvider.apply(sslClient);
    builder.send(onSuccess(resp -> {
      testComplete();
    }
));
    await();
  }
  finally {
    sslClient.close();
    sslServer.close();
  }
}","private void testTLS(boolean clientSSL,boolean serverSSL,Function<WebClient,HttpRequest<Buffer>> requestProvider,Consumer<HttpServerRequest> serverAssertions) throws Exception {
  WebClient sslClient=WebClient.create(vertx,new WebClientOptions().setSsl(clientSSL).setTrustAll(true).setDefaultHost(DEFAULT_HTTPS_HOST).setDefaultPort(DEFAULT_HTTPS_PORT));
  HttpServer sslServer=vertx.createHttpServer(new HttpServerOptions().setSsl(serverSSL).setKeyStoreOptions(Cert.CLIENT_JKS.get()).setPort(DEFAULT_HTTPS_PORT).setHost(DEFAULT_HTTPS_HOST));
  sslServer.requestHandler(req -> {
    assertEquals(serverSSL,req.isSSL());
    if (serverAssertions != null) {
      serverAssertions.accept(req);
    }
    req.response().end();
  }
);
  try {
    startServer(sslServer);
    HttpRequest<Buffer> builder=requestProvider.apply(sslClient);
    builder.send(onSuccess(resp -> {
      testComplete();
    }
));
    await();
  }
  finally {
    sslClient.close();
    sslServer.close();
  }
}"
93709,"@Test public void testTemplateJsonArrayResolverError() throws Exception {
  TemplateEngine engine=HandlebarsTemplateEngine.create();
  JsonArray jsonArray=new JsonArray();
  jsonArray.add(""String_Node_Str"").add(""String_Node_Str"").add(new JsonObject().put(""String_Node_Str"",""String_Node_Str""));
  AtomicReference<RoutingContext> contextRef=new AtomicReference<>();
  router.route().handler(context -> {
    context.put(""String_Node_Str"",jsonArray);
    context.next();
    contextRef.set(context);
  }
);
  router.route().handler(TemplateHandler.create(engine,""String_Node_Str"",""String_Node_Str""));
  testRequest(HttpMethod.GET,""String_Node_Str"" + ""String_Node_Str"",500,""String_Node_Str"");
  if (contextRef.get().failure() instanceof HandlebarsException) {
    HandlebarsException exception=((HandlebarsException)contextRef.get().failure());
    assertTrue(exception.getMessage().contains(""String_Node_Str""));
  }
 else {
    fail(""String_Node_Str"");
  }
}","@Test public void testTemplateJsonArrayResolverError() throws Exception {
  TemplateEngine engine=HandlebarsTemplateEngine.create();
  JsonArray jsonArray=new JsonArray();
  jsonArray.add(""String_Node_Str"").add(""String_Node_Str"").add(new JsonObject().put(""String_Node_Str"",""String_Node_Str""));
  AtomicReference<RoutingContext> contextRef=new AtomicReference<>();
  router.route().handler(context -> {
    contextRef.set(context);
    context.put(""String_Node_Str"",jsonArray);
    context.next();
  }
);
  router.route().handler(TemplateHandler.create(engine,""String_Node_Str"",""String_Node_Str""));
  testRequest(HttpMethod.GET,""String_Node_Str"" + ""String_Node_Str"",500,""String_Node_Str"");
  if (contextRef.get().failure() instanceof HandlebarsException) {
    HandlebarsException exception=((HandlebarsException)contextRef.get().failure());
    assertTrue(exception.getMessage().contains(""String_Node_Str""));
  }
 else {
    fail(""String_Node_Str"");
  }
}"
93710,"@Override public void handle(RoutingContext ctx){
  if (nagHttps) {
    String uri=ctx.request().absoluteURI();
    if (!uri.startsWith(""String_Node_Str"")) {
      log.warn(""String_Node_Str"" + uri);
    }
  }
  HttpMethod method=ctx.request().method();
switch (method) {
case GET:
    final String token=generateToken();
  ctx.put(headerName,token);
ctx.addCookie(Cookie.cookie(cookieName,token));
ctx.next();
break;
case POST:
case PUT:
case DELETE:
case PATCH:
final String header=ctx.request().getHeader(headerName);
if (validateToken(header == null ? ctx.request().getFormAttribute(headerName) : header)) {
ctx.next();
}
 else {
ctx.fail(403);
}
break;
default :
ctx.next();
break;
}
}","@Override public void handle(RoutingContext ctx){
  if (nagHttps) {
    String uri=ctx.request().absoluteURI();
    if (!uri.startsWith(""String_Node_Str"")) {
      log.warn(""String_Node_Str"" + uri);
    }
  }
  HttpMethod method=ctx.request().method();
switch (method) {
case GET:
    final String token=generateToken();
  ctx.put(headerName,token);
ctx.addCookie(Cookie.cookie(cookieName,token));
ctx.next();
break;
case POST:
case PUT:
case DELETE:
case PATCH:
final String header=ctx.request().getHeader(headerName);
if (validateToken(header == null ? ctx.request().getFormAttribute(headerName) : header)) {
ctx.next();
}
 else {
forbidden(ctx);
}
break;
default :
ctx.next();
break;
}
}"
93711,"private void send(String contentType,Object body,Handler<AsyncResult<HttpResponse<T>>> handler){
  Future<HttpClientResponse> responseFuture=Future.<HttpClientResponse>future().setHandler(ar -> {
    if (ar.succeeded()) {
      HttpClientResponse resp=ar.result();
      Future<HttpResponse<T>> fut=Future.future();
      fut.setHandler(handler);
      resp.exceptionHandler(err -> {
        if (!fut.isComplete()) {
          fut.fail(err);
        }
      }
);
      resp.pause();
      codec.create(ar2 -> {
        resp.resume();
        if (ar2.succeeded()) {
          BodyStream<T> stream=ar2.result();
          stream.exceptionHandler(err -> {
            if (!fut.isComplete()) {
              fut.fail(err);
            }
          }
);
          resp.endHandler(v -> {
            if (!fut.isComplete()) {
              stream.end();
              if (stream.result().succeeded()) {
                fut.complete(new HttpResponseImpl<>(resp,null,stream.result().result()));
              }
 else {
                fut.fail(stream.result().cause());
              }
            }
          }
);
          Pump responsePump=Pump.pump(resp,stream);
          responsePump.start();
        }
 else {
          handler.handle(Future.failedFuture(ar2.cause()));
        }
      }
);
    }
 else {
      handler.handle(Future.failedFuture(ar.cause()));
    }
  }
);
  HttpClientRequest req;
  String requestURI;
  if (params != null && params.size() > 0) {
    QueryStringEncoder enc=new QueryStringEncoder(uri);
    params.forEach(param -> {
      enc.addParam(param.getKey(),param.getValue());
    }
);
    requestURI=enc.toString();
  }
 else {
    requestURI=uri;
  }
  if (ssl != options.isSsl()) {
    req=client.request(method,new RequestOptions().setSsl(ssl).setHost(host).setPort(port).setURI(uri));
  }
 else {
    req=client.request(method,port,host,requestURI);
  }
  req.setFollowRedirects(followRedirects);
  if (headers != null) {
    req.headers().addAll(headers);
  }
  req.exceptionHandler(err -> {
    if (!responseFuture.isComplete()) {
      responseFuture.fail(err);
    }
  }
);
  req.handler(resp -> {
    if (!responseFuture.isComplete()) {
      responseFuture.complete(resp);
    }
  }
);
  if (timeout > 0) {
    req.setTimeout(timeout);
  }
  if (body != null) {
    if (contentType != null) {
      String prev=req.headers().get(HttpHeaders.CONTENT_TYPE);
      if (prev == null) {
        req.putHeader(HttpHeaders.CONTENT_TYPE,contentType);
      }
 else {
        contentType=prev;
      }
    }
    if (body instanceof ReadStream<?>) {
      ReadStream<Buffer> stream=(ReadStream<Buffer>)body;
      if (headers == null || !headers.contains(HttpHeaders.CONTENT_LENGTH)) {
        req.setChunked(true);
      }
      Pump pump=Pump.pump(stream,req);
      stream.exceptionHandler(err -> {
        req.reset();
        if (!responseFuture.isComplete()) {
          responseFuture.fail(err);
        }
      }
);
      stream.endHandler(v -> {
        pump.stop();
        req.end();
      }
);
      pump.start();
    }
 else {
      Buffer buffer;
      if (body instanceof Buffer) {
        buffer=(Buffer)body;
      }
 else       if (body instanceof MultiMap) {
        try {
          MultiMap attributes=(MultiMap)body;
          boolean multipart=""String_Node_Str"".equals(contentType);
          DefaultFullHttpRequest request=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,io.netty.handler.codec.http.HttpMethod.POST,""String_Node_Str"");
          HttpPostRequestEncoder encoder=new HttpPostRequestEncoder(request,multipart);
          for (          Map.Entry<String,String> attribute : attributes) {
            encoder.addBodyAttribute(attribute.getKey(),attribute.getValue());
          }
          encoder.finalizeRequest();
          for (          String headerName : request.headers().names()) {
            req.putHeader(headerName,request.headers().get(headerName));
          }
          if (encoder.isChunked()) {
            buffer=Buffer.buffer();
            while (true) {
              HttpContent chunk=encoder.readChunk(new UnpooledByteBufAllocator(false));
              ByteBuf content=chunk.content();
              if (content.readableBytes() == 0) {
                break;
              }
              buffer.appendBuffer(Buffer.buffer(content));
            }
          }
 else {
            ByteBuf content=request.content();
            buffer=Buffer.buffer(content);
          }
        }
 catch (        Exception e) {
          throw new VertxException(e);
        }
      }
 else       if (body instanceof JsonObject) {
        buffer=Buffer.buffer(((JsonObject)body).encode());
      }
 else {
        buffer=Buffer.buffer(Json.encode(body));
      }
      req.end(buffer);
    }
  }
 else {
    req.end();
  }
}","private void send(String contentType,Object body,Handler<AsyncResult<HttpResponse<T>>> handler){
  Future<HttpClientResponse> responseFuture=Future.<HttpClientResponse>future().setHandler(ar -> {
    if (ar.succeeded()) {
      HttpClientResponse resp=ar.result();
      Future<HttpResponse<T>> fut=Future.future();
      fut.setHandler(handler);
      resp.exceptionHandler(err -> {
        if (!fut.isComplete()) {
          fut.fail(err);
        }
      }
);
      resp.pause();
      codec.create(ar2 -> {
        resp.resume();
        if (ar2.succeeded()) {
          BodyStream<T> stream=ar2.result();
          stream.exceptionHandler(err -> {
            if (!fut.isComplete()) {
              fut.fail(err);
            }
          }
);
          resp.endHandler(v -> {
            if (!fut.isComplete()) {
              stream.end();
              if (stream.result().succeeded()) {
                fut.complete(new HttpResponseImpl<>(resp,null,stream.result().result()));
              }
 else {
                fut.fail(stream.result().cause());
              }
            }
          }
);
          Pump responsePump=Pump.pump(resp,stream);
          responsePump.start();
        }
 else {
          handler.handle(Future.failedFuture(ar2.cause()));
        }
      }
);
    }
 else {
      handler.handle(Future.failedFuture(ar.cause()));
    }
  }
);
  HttpClientRequest req;
  String requestURI;
  if (params != null && params.size() > 0) {
    QueryStringEncoder enc=new QueryStringEncoder(uri);
    params.forEach(param -> {
      enc.addParam(param.getKey(),param.getValue());
    }
);
    requestURI=enc.toString();
  }
 else {
    requestURI=uri;
  }
  if (ssl != options.isSsl()) {
    req=client.request(method,new RequestOptions().setSsl(ssl).setHost(host).setPort(port).setURI(requestURI));
  }
 else {
    req=client.request(method,port,host,requestURI);
  }
  req.setFollowRedirects(followRedirects);
  if (headers != null) {
    req.headers().addAll(headers);
  }
  req.exceptionHandler(err -> {
    if (!responseFuture.isComplete()) {
      responseFuture.fail(err);
    }
  }
);
  req.handler(resp -> {
    if (!responseFuture.isComplete()) {
      responseFuture.complete(resp);
    }
  }
);
  if (timeout > 0) {
    req.setTimeout(timeout);
  }
  if (body != null) {
    if (contentType != null) {
      String prev=req.headers().get(HttpHeaders.CONTENT_TYPE);
      if (prev == null) {
        req.putHeader(HttpHeaders.CONTENT_TYPE,contentType);
      }
 else {
        contentType=prev;
      }
    }
    if (body instanceof ReadStream<?>) {
      ReadStream<Buffer> stream=(ReadStream<Buffer>)body;
      if (headers == null || !headers.contains(HttpHeaders.CONTENT_LENGTH)) {
        req.setChunked(true);
      }
      Pump pump=Pump.pump(stream,req);
      stream.exceptionHandler(err -> {
        req.reset();
        if (!responseFuture.isComplete()) {
          responseFuture.fail(err);
        }
      }
);
      stream.endHandler(v -> {
        pump.stop();
        req.end();
      }
);
      pump.start();
    }
 else {
      Buffer buffer;
      if (body instanceof Buffer) {
        buffer=(Buffer)body;
      }
 else       if (body instanceof MultiMap) {
        try {
          MultiMap attributes=(MultiMap)body;
          boolean multipart=""String_Node_Str"".equals(contentType);
          DefaultFullHttpRequest request=new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,io.netty.handler.codec.http.HttpMethod.POST,""String_Node_Str"");
          HttpPostRequestEncoder encoder=new HttpPostRequestEncoder(request,multipart);
          for (          Map.Entry<String,String> attribute : attributes) {
            encoder.addBodyAttribute(attribute.getKey(),attribute.getValue());
          }
          encoder.finalizeRequest();
          for (          String headerName : request.headers().names()) {
            req.putHeader(headerName,request.headers().get(headerName));
          }
          if (encoder.isChunked()) {
            buffer=Buffer.buffer();
            while (true) {
              HttpContent chunk=encoder.readChunk(new UnpooledByteBufAllocator(false));
              ByteBuf content=chunk.content();
              if (content.readableBytes() == 0) {
                break;
              }
              buffer.appendBuffer(Buffer.buffer(content));
            }
          }
 else {
            ByteBuf content=request.content();
            buffer=Buffer.buffer(content);
          }
        }
 catch (        Exception e) {
          throw new VertxException(e);
        }
      }
 else       if (body instanceof JsonObject) {
        buffer=Buffer.buffer(((JsonObject)body).encode());
      }
 else {
        buffer=Buffer.buffer(Json.encode(body));
      }
      req.end(buffer);
    }
  }
 else {
    req.end();
  }
}"
93712,"@Override public void render(RoutingContext context,String templateFileName,Handler<AsyncResult<Buffer>> handler){
  try {
    Template template=cache.get(templateFileName);
    if (template == null) {
synchronized (this) {
        loader.setVertx(context.vertx());
        template=handlebars.compile(templateFileName);
        cache.put(templateFileName,template);
      }
    }
    handler.handle(Future.succeededFuture(Buffer.buffer(template.apply(context.data()))));
  }
 catch (  Exception ex) {
    handler.handle(Future.failedFuture(ex));
  }
}","@Override public void render(RoutingContext context,String templateFileName,Handler<AsyncResult<Buffer>> handler){
  try {
    Template template=cache.get(templateFileName);
    if (template == null) {
synchronized (this) {
        loader.setVertx(context.vertx());
        template=handlebars.compile(templateFileName);
        cache.put(templateFileName,template);
      }
    }
    Context engineContext=Context.newBuilder(context.data()).resolver(getResolvers()).build();
    handler.handle(Future.succeededFuture(Buffer.buffer(template.apply(engineContext))));
  }
 catch (  Exception ex) {
    handler.handle(Future.failedFuture(ex));
  }
}"
93713,"@Override public Reader getReader(String s) throws LoaderException {
  try {
    final char[] buffer=vertx.fileSystem().readFileBlocking(s).toString(charset).toCharArray();
    final int[] pos={0};
    return new Reader(){
      @Override public int read(      char[] cbuf,      int off,      int len) throws IOException {
        if (pos[0] == buffer.length) {
          return -1;
        }
        final int end=Math.min(buffer.length,pos[0] + len);
        System.arraycopy(buffer,pos[0],cbuf,off,end);
        final int read=end - pos[0];
        pos[0]=end;
        return read;
      }
      @Override public void close() throws IOException {
      }
    }
;
  }
 catch (  RuntimeException e) {
    throw new LoaderException(e,e.getMessage());
  }
}","@Override public Reader getReader(String s) throws LoaderException {
  try {
    final String buffer=vertx.fileSystem().readFileBlocking(s).toString(charset);
    return new StringReader(buffer);
  }
 catch (  RuntimeException e) {
    throw new LoaderException(e,e.getMessage());
  }
}"
93714,"@Override public Reader getReader(String s) throws LoaderException {
  try {
    final char[] buffer=vertx.fileSystem().readFileBlocking(s).toString(charset).toCharArray();
    final int[] pos={0};
    return new Reader(){
      @Override public int read(      char[] cbuf,      int off,      int len) throws IOException {
        if (pos[0] == buffer.length) {
          return -1;
        }
        final int end=Math.min(buffer.length,pos[0] + len);
        System.arraycopy(buffer,pos[0],cbuf,off,end);
        final int read=end - pos[0];
        pos[0]=end;
        return read;
      }
      @Override public void close() throws IOException {
      }
    }
;
  }
 catch (  RuntimeException e) {
    throw new LoaderException(e,e.getMessage());
  }
}","@Override public Reader getReader(String s) throws LoaderException {
  try {
    final String buffer=vertx.fileSystem().readFileBlocking(s).toString(charset);
    return new StringReader(buffer);
  }
 catch (  RuntimeException e) {
    throw new LoaderException(e,e.getMessage());
  }
}"
93715,"private <R>void perform2(String contentType,Object body,BodyCodec<R> unmarshaller,Handler<AsyncResult<HttpResponse<R>>> handler){
  perform(contentType,body,ar -> {
    if (ar.succeeded()) {
      HttpClientResponse resp=ar.result();
      Future<HttpResponse<R>> fut=Future.future();
      fut.setHandler(handler);
      resp.exceptionHandler(err -> {
        if (!fut.isComplete()) {
          fut.fail(err);
        }
      }
);
      resp.bodyHandler(buff -> {
        if (!fut.isComplete()) {
          BodyStream<R> state=unmarshaller.stream();
          state.write(buff);
          state.end();
          fut.complete(new HttpResponseImpl<>(resp,buff,state.state().result()));
        }
      }
);
    }
 else {
      handler.handle(Future.failedFuture(ar.cause()));
    }
  }
);
}","private <R>void perform2(String contentType,Object body,BodyCodec<R> unmarshaller,Handler<AsyncResult<HttpResponse<R>>> handler){
  perform(contentType,body,ar -> {
    if (ar.succeeded()) {
      HttpClientResponse resp=ar.result();
      Future<HttpResponse<R>> fut=Future.future();
      fut.setHandler(handler);
      resp.exceptionHandler(err -> {
        if (!fut.isComplete()) {
          fut.fail(err);
        }
      }
);
      resp.bodyHandler(buff -> {
        if (!fut.isComplete()) {
          BodyStream<R> state=unmarshaller.stream();
          state.write(buff);
          state.end();
          if (state.state().succeeded()) {
            fut.complete(new HttpResponseImpl<>(resp,buff,state.state().result()));
          }
 else {
            fut.fail(state.state().cause());
          }
        }
      }
);
    }
 else {
      handler.handle(Future.failedFuture(ar.cause()));
    }
  }
);
}"
93716,"protected boolean isMatchedBy2(ParsableHeaderValue matchTry){
  if (matchTry.parameter == null) {
    return true;
  }
  if (parameter == null) {
    return false;
  }
  for (  Entry<String,String> requiredParameter : matchTry.parameter.entrySet()) {
    String parameterValueToTest=parameter.get(requiredParameter.getKey());
    String requiredParamVal=requiredParameter.getValue();
    if (parameterValueToTest == null || (requiredParamVal != null && !requiredParamVal.equals(parameterValueToTest))) {
      return false;
    }
  }
  return true;
}","protected boolean isMatchedBy2(ParsableHeaderValue matchTry){
  ensureHeaderProcessed();
  if (matchTry.parameter == null) {
    return true;
  }
  if (parameter == null) {
    return false;
  }
  for (  Entry<String,String> requiredParameter : matchTry.parameter.entrySet()) {
    String parameterValueToTest=parameter.get(requiredParameter.getKey());
    String requiredParamVal=requiredParameter.getValue();
    if (parameterValueToTest == null || (requiredParamVal != EMPTY && !requiredParamVal.equals(parameterValueToTest))) {
      return false;
    }
  }
  return true;
}"
93717,"/** 
 * Parses a header value
 * @param headerContent 
 * @param valueCallback
 * @param weightCallback
 * @param parameterCallback
 */
public static void parseHeaderValue(String headerContent,Consumer<String> valueCallback,Consumer<Float> weightCallback,BiConsumer<String,String> parameterCallback){
  int paramIndex=headerContent.indexOf(';');
  if (paramIndex < 0) {
    valueCallback.accept(headerContent);
  }
 else {
    valueCallback.accept(headerContent.substring(0,paramIndex));
    Matcher paramFindings=PARAMETER_FINDER.matcher(headerContent);
    while (paramFindings.find()) {
      String key=paramFindings.group(""String_Node_Str"");
      String value=matchedSelector(paramFindings.group(""String_Node_Str""),paramFindings.group(""String_Node_Str""));
      if (""String_Node_Str"".equalsIgnoreCase(key)) {
        try {
          weightCallback.accept(Float.parseFloat(value));
        }
 catch (        NumberFormatException e) {
          log.info(""String_Node_Str"",value);
        }
      }
 else {
        parameterCallback.accept(key,value);
      }
    }
  }
}","/** 
 * Parses a header value
 * @param headerContent 
 * @param valueCallback
 * @param weightCallback
 * @param parameterCallback
 */
public static void parseHeaderValue(String headerContent,Consumer<String> valueCallback,Consumer<Float> weightCallback,BiConsumer<String,String> parameterCallback){
  int paramIndex=headerContent.indexOf(';');
  if (paramIndex < 0) {
    valueCallback.accept(headerContent);
  }
 else {
    valueCallback.accept(headerContent.substring(0,paramIndex));
    Matcher paramFindings=PARAMETER_FINDER.matcher(headerContent);
    while (paramFindings.find()) {
      String key=paramFindings.group(""String_Node_Str"");
      String value=matchedSelector(paramFindings.group(""String_Node_Str""),paramFindings.group(""String_Node_Str""));
      if (""String_Node_Str"".equalsIgnoreCase(key)) {
        try {
          if (value != null) {
            weightCallback.accept(Float.parseFloat(value));
          }
        }
 catch (        NumberFormatException e) {
          log.info(""String_Node_Str"",value);
        }
      }
 else {
        parameterCallback.accept(key,value);
      }
    }
  }
}"
93718,"protected boolean isMatchedBy2(ParsableHeaderValue matchTry){
  ensureHeaderProcessed();
  if (matchTry.parameter == null) {
    return true;
  }
  if (parameter == null) {
    return false;
  }
  for (  Entry<String,String> requiredParameter : matchTry.parameter.entrySet()) {
    String parameterValueToTest=parameter.get(requiredParameter.getKey());
    String requiredParamVal=requiredParameter.getValue();
    if (parameterValueToTest == null || (requiredParamVal != EMPTY && !requiredParamVal.equals(parameterValueToTest))) {
      return false;
    }
  }
  return true;
}","protected boolean isMatchedBy2(ParsableHeaderValue matchTry){
  ensureHeaderProcessed();
  if (matchTry.parameter.isEmpty()) {
    return true;
  }
  if (parameter.isEmpty()) {
    return false;
  }
  for (  Entry<String,String> requiredParameter : matchTry.parameter.entrySet()) {
    String parameterValueToTest=parameter.get(requiredParameter.getKey());
    String requiredParamVal=requiredParameter.getValue();
    if (parameterValueToTest == null || (requiredParamVal != EMPTY && !requiredParamVal.equals(parameterValueToTest))) {
      return false;
    }
  }
  return true;
}"
93719,"@Override public void handle(RoutingContext context){
  User user=context.user();
  if (user != null) {
    authorise(user,context);
  }
 else {
    HttpServerRequest request=context.request();
    String authorization=request.headers().get(HttpHeaders.AUTHORIZATION);
    if (authorization == null) {
      handle401(context);
    }
 else {
      String suser;
      String spass;
      String sscheme;
      try {
        String[] parts=authorization.split(""String_Node_Str"");
        sscheme=parts[0];
        String[] credentials=new String(Base64.getDecoder().decode(parts[1])).split(""String_Node_Str"");
        suser=credentials[0];
        spass=credentials.length > 1 ? credentials[1] : null;
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        handle401(context);
        return;
      }
catch (      IllegalArgumentException|NullPointerException e) {
        context.fail(e);
        return;
      }
      if (!""String_Node_Str"".equals(sscheme)) {
        context.fail(400);
      }
 else {
        JsonObject authInfo=new JsonObject().put(""String_Node_Str"",suser).put(""String_Node_Str"",spass);
        authProvider.authenticate(authInfo,res -> {
          if (res.succeeded()) {
            User authenticated=res.result();
            context.setUser(authenticated);
            authorise(authenticated,context);
          }
 else {
            handle401(context);
          }
        }
);
      }
    }
  }
}","@Override public void handle(RoutingContext context){
  User user=context.user();
  if (user != null) {
    authorise(user,context);
  }
 else {
    HttpServerRequest request=context.request();
    String authorization=request.headers().get(HttpHeaders.AUTHORIZATION);
    if (authorization == null) {
      handle401(context);
    }
 else {
      String suser;
      String spass;
      String sscheme;
      try {
        String[] parts=authorization.split(""String_Node_Str"");
        sscheme=parts[0];
        String[] credentials=new String(Base64.getDecoder().decode(parts[1])).split(""String_Node_Str"");
        suser=credentials[0];
        if (credentials.length == 2)         spass=credentials[1];
 else         if (credentials.length > 2) {
          spass=joinCredentials(credentials);
        }
 else {
          spass=null;
        }
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        handle401(context);
        return;
      }
catch (      IllegalArgumentException|NullPointerException e) {
        context.fail(e);
        return;
      }
      if (!""String_Node_Str"".equals(sscheme)) {
        context.fail(400);
      }
 else {
        JsonObject authInfo=new JsonObject().put(""String_Node_Str"",suser).put(""String_Node_Str"",spass);
        authProvider.authenticate(authInfo,res -> {
          if (res.succeeded()) {
            User authenticated=res.result();
            context.setUser(authenticated);
            authorise(authenticated,context);
          }
 else {
            handle401(context);
          }
        }
);
      }
    }
  }
}"
93720,"public void end(Buffer t){
  this.delegate.end((io.vertx.core.buffer.Buffer)t.getDelegate());
}","/** 
 * Call   {@link io.vertx.ext.web.handler.sockjs.SockJSSocket}.
 */
public void end(){
  ((io.vertx.ext.web.handler.sockjs.SockJSSocket)delegate).end();
}"
93721,"private void checkHandleNoMatch(){
  if (failed()) {
    unhandledFailure(statusCode,failure,router);
  }
 else {
    response().setStatusCode(404);
    response().end(DEFAULT_404);
  }
}","private void checkHandleNoMatch(){
  if (failed()) {
    unhandledFailure(statusCode,failure,router);
  }
 else {
    response().setStatusCode(404);
    if (request().method() == HttpMethod.HEAD) {
      response().end();
    }
 else {
      response().end(DEFAULT_404);
    }
  }
}"
93722,"/** 
 * Specify a blocking request handler for the route. This method works just like   {@link #handler(Handler)} excepted that it will run the blocking handler on a worker threadso that it won't block the event loop. Note that it's safe to call context.next() from the blocking handler as it will be executed on the event loop context (and not on the worker thread. If the blocking handler is ordered it means that any blocking handlers for the same context are never executed concurrently but always in the order they were called. The default value of ordered is true. If you do not want this behaviour and don't mind if your blocking handlers are executed in parallel you can set ordered to false.
 * @param requestHandler  the blocking request handler
 * @param ordered
 * @return a reference to this, so the API can be used fluently
 */
@Fluent Route blockingHandler(Handler<RoutingContext> requestHandler,boolean ordered);","/** 
 * Specify a blocking request handler for the route. This method works just like   {@link #handler(Handler)} excepted that it will run the blocking handler on a worker threadso that it won't block the event loop. Note that it's safe to call context.next() from the blocking handler as it will be executed on the event loop context (and not on the worker thread. If the blocking handler is ordered it means that any blocking handlers for the same context are never executed concurrently but always in the order they were called. The default value of ordered is true. If you do not want this behaviour and don't mind if your blocking handlers are executed in parallel you can set ordered to false.
 * @param requestHandler  the blocking request handler
 * @param ordered if true handlers are executed in sequence, otherwise are run in parallel
 * @return a reference to this, so the API can be used fluently
 */
@Fluent Route blockingHandler(Handler<RoutingContext> requestHandler,boolean ordered);"
93723,"/** 
 * Create all required header so content can be cache by Caching servers or Browsers
 * @param request
 * @param props
 */
private void writeCacheHeaders(HttpServerRequest request,FileProps props){
  MultiMap headers=request.response().headers();
  if (cachingEnabled) {
    headers.set(""String_Node_Str"",""String_Node_Str"" + maxAgeSeconds);
    headers.set(""String_Node_Str"",dateTimeFormatter.format(props.lastModifiedTime()));
  }
  headers.set(""String_Node_Str"",dateTimeFormatter.format(new Date()));
}","/** 
 * Create all required header so content can be cache by Caching servers or Browsers
 * @param request base HttpServerRequest
 * @param props file properties
 */
private void writeCacheHeaders(HttpServerRequest request,FileProps props){
  MultiMap headers=request.response().headers();
  if (cachingEnabled) {
    headers.set(""String_Node_Str"",""String_Node_Str"" + maxAgeSeconds);
    headers.set(""String_Node_Str"",dateTimeFormatter.format(props.lastModifiedTime()));
  }
  headers.set(""String_Node_Str"",dateTimeFormatter.format(new Date()));
}"
93724,"private BHandler(RoutingContext context){
  this.context=context;
  Set<FileUpload> fileUploads=context.fileUploads();
  context.request().setExpectMultipart(true);
  context.request().exceptionHandler(context::fail);
  context.request().uploadHandler(upload -> {
    String uploadedFileName=new File(uploadsDir,UUID.randomUUID().toString()).getPath();
    upload.streamToFileSystem(uploadedFileName);
    FileUploadImpl fileUpload=new FileUploadImpl(uploadedFileName,upload);
    fileUploads.add(fileUpload);
    upload.exceptionHandler(context::fail);
  }
);
}","private BHandler(RoutingContext context){
  this.context=context;
  Set<FileUpload> fileUploads=context.fileUploads();
  context.request().setExpectMultipart(true);
  context.request().exceptionHandler(context::fail);
  context.request().uploadHandler(upload -> {
    uploadCount.incrementAndGet();
    String uploadedFileName=new File(uploadsDir,UUID.randomUUID().toString()).getPath();
    upload.streamToFileSystem(uploadedFileName);
    FileUploadImpl fileUpload=new FileUploadImpl(uploadedFileName,upload);
    fileUploads.add(fileUpload);
    upload.exceptionHandler(context::fail);
    upload.endHandler(v -> uploadEnded());
  }
);
}"
93725,"void end(){
  if (failed) {
    return;
  }
  HttpServerRequest req=context.request();
  if (mergeFormAttributes && req.isExpectMultipart()) {
    req.params().addAll(req.formAttributes());
  }
  context.setBody(body);
  context.next();
}","void end(){
  if (uploadCount.get() == 0) {
    doEnd();
  }
}"
93726,"private void testFileUpload(String uploadsDir,int size) throws Exception {
  String name=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  String contentType=""String_Node_Str"";
  Buffer fileData=TestUtils.randomBuffer(size);
  router.route().handler(rc -> {
    Set<FileUpload> fileUploads=rc.fileUploads();
    assertNotNull(fileUploads);
    assertEquals(1,fileUploads.size());
    FileUpload upload=fileUploads.iterator().next();
    assertEquals(name,upload.name());
    assertEquals(fileName,upload.fileName());
    assertEquals(contentType,upload.contentType());
    assertEquals(""String_Node_Str"",upload.contentTransferEncoding());
    assertEquals(fileData.length(),upload.size());
    String uploadedFileName=upload.uploadedFileName();
    assertTrue(uploadedFileName.startsWith(uploadsDir + File.separator));
    Buffer uploaded=vertx.fileSystem().readFileBlocking(uploadedFileName);
    assertEquals(fileData,uploaded);
    Buffer rawBody=rc.getBody();
    assertNotNull(rawBody);
    assertTrue(rawBody.length() > fileData.length());
    rc.response().end();
  }
);
  sendFileUploadRequest(fileData,200,""String_Node_Str"");
}","private void testFileUpload(String uploadsDir,int size) throws Exception {
  String name=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  String contentType=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + size);
  Buffer fileData=TestUtils.randomBuffer(size);
  router.route().handler(rc -> {
    Set<FileUpload> fileUploads=rc.fileUploads();
    assertNotNull(fileUploads);
    assertEquals(1,fileUploads.size());
    FileUpload upload=fileUploads.iterator().next();
    assertEquals(name,upload.name());
    assertEquals(fileName,upload.fileName());
    assertEquals(contentType,upload.contentType());
    assertEquals(""String_Node_Str"",upload.contentTransferEncoding());
    assertEquals(fileData.length(),upload.size());
    String uploadedFileName=upload.uploadedFileName();
    assertTrue(uploadedFileName.startsWith(uploadsDir + File.separator));
    Buffer uploaded=vertx.fileSystem().readFileBlocking(uploadedFileName);
    System.out.println(""String_Node_Str"" + uploaded.length());
    assertEquals(fileData,uploaded);
    Buffer rawBody=rc.getBody();
    assertNotNull(rawBody);
    assertTrue(rawBody.length() > fileData.length());
    rc.response().end();
  }
);
  sendFileUploadRequest(fileData,200,""String_Node_Str"");
}"
93727,"private boolean pathMatches(String mountPoint,RoutingContext ctx){
  String thePath=mountPoint == null ? path : mountPoint + path;
  String requestPath=useNormalisedPath ? ctx.normalisedPath() : ctx.request().path();
  if (exactPath) {
    return pathMatchesExact(requestPath,thePath);
  }
 else {
    return requestPath.startsWith(removeTrailing(thePath));
  }
}","private boolean pathMatches(String mountPoint,RoutingContext ctx){
  String thePath=mountPoint == null ? path : mountPoint + path;
  String requestPath=useNormalisedPath ? ctx.normalisedPath() : ctx.request().path();
  if (exactPath) {
    return pathMatchesExact(requestPath,thePath);
  }
 else {
    if (thePath.endsWith(""String_Node_Str"") && requestPath.equals(removeTrailing(thePath))) {
      return true;
    }
    return requestPath.startsWith(thePath);
  }
}"
93728,"private void testPathBegin(HttpMethod method,String path) throws Exception {
  testRequest(method,path,200,path);
  testRequest(method,path + ""String_Node_Str"",200,path + ""String_Node_Str"");
  testRequest(method,path + ""String_Node_Str"",200,path + ""String_Node_Str"");
  testRequest(method,path + ""String_Node_Str"",200,path + ""String_Node_Str"");
  testRequest(method,path.substring(0,path.length() - 1),404,""String_Node_Str"");
  testRequest(method,""String_Node_Str"",404,""String_Node_Str"");
  testRequest(method,""String_Node_Str"" + UUID.randomUUID().toString(),404,""String_Node_Str"");
}","private void testPathBegin(HttpMethod method,String path) throws Exception {
  testRequest(method,path,200,path);
  testRequest(method,path + ""String_Node_Str"",200,path + ""String_Node_Str"");
  if (path.endsWith(""String_Node_Str"")) {
    testRequest(method,path.substring(0,path.length() - 1) + ""String_Node_Str"",404,""String_Node_Str"");
    testRequest(method,path.substring(0,path.length() - 1) + ""String_Node_Str"",200,path.substring(0,path.length() - 1) + ""String_Node_Str"");
  }
 else {
    testRequest(method,path + ""String_Node_Str"",200,path + ""String_Node_Str"");
    testRequest(method,path + ""String_Node_Str"",200,path + ""String_Node_Str"");
    testRequest(method,path.substring(0,path.length() - 1),404,""String_Node_Str"");
  }
  testRequest(method,""String_Node_Str"",404,""String_Node_Str"");
  testRequest(method,""String_Node_Str"" + UUID.randomUUID().toString(),404,""String_Node_Str"");
}"
93729,"private void checkAddAccceptedReplyAddress(final String replyAddress){
  if (replyAddress != null) {
    acceptedReplyAddresses.add(replyAddress);
    vertx.setTimer(replyTimeout,id -> acceptedReplyAddresses.remove(replyAddress));
  }
}","private void checkAddAccceptedReplyAddress(Message message){
  String replyAddress=message.replyAddress();
  if (replyAddress != null) {
    messagesAwaitingReply.put(replyAddress,message);
    vertx.setTimer(replyTimeout,tid -> messagesAwaitingReply.remove(replyAddress));
  }
}"
93730,"private void internalHandleRegister(SockJSSocket sock,String address,Map<String,MessageConsumer> registrations){
  if (address.length() > maxAddressLength) {
    log.warn(""String_Node_Str"");
    replyError(sock,""String_Node_Str"");
    return;
  }
  final SockInfo info=sockInfos.get(sock);
  if (!checkMaxHandlers(sock,info)) {
    return;
  }
  if (handlePreRegister(sock,address)) {
    final boolean debug=log.isDebugEnabled();
    Match match=checkMatches(false,address,null);
    if (match.doesMatch) {
      Handler<Message<Object>> handler=msg -> {
        Match curMatch=checkMatches(false,address,msg.body());
        if (curMatch.doesMatch) {
          if (curMatch.requiredPermission != null || curMatch.requiredRole != null) {
            authorise(curMatch,sock.apexSession(),res -> {
              if (res.succeeded()) {
                if (res.result()) {
                  checkAddAccceptedReplyAddress(msg.replyAddress());
                  deliverMessage(sock,address,msg);
                }
 else {
                  if (debug) {
                    log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
                  }
                }
              }
 else {
                log.error(res.cause());
              }
            }
);
          }
 else {
            checkAddAccceptedReplyAddress(msg.replyAddress());
            deliverMessage(sock,address,msg);
          }
        }
 else {
          if (debug) {
            log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
          }
        }
      }
;
      MessageConsumer reg=eb.consumer(address).handler(handler);
      registrations.put(address,reg);
      handlePostRegister(sock,address);
      info.handlerCount++;
    }
 else {
      if (debug) {
        log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
      }
      replyError(sock,""String_Node_Str"");
    }
  }
}","private void internalHandleRegister(SockJSSocket sock,String address,Map<String,MessageConsumer> registrations){
  if (address.length() > maxAddressLength) {
    log.warn(""String_Node_Str"");
    replyError(sock,""String_Node_Str"");
    return;
  }
  final SockInfo info=sockInfos.get(sock);
  if (!checkMaxHandlers(sock,info)) {
    return;
  }
  if (handlePreRegister(sock,address)) {
    final boolean debug=log.isDebugEnabled();
    Match match=checkMatches(false,address,null);
    if (match.doesMatch) {
      Handler<Message<Object>> handler=msg -> {
        Match curMatch=checkMatches(false,address,msg.body());
        if (curMatch.doesMatch) {
          if (curMatch.requiredPermission != null || curMatch.requiredRole != null) {
            authorise(curMatch,sock.apexSession(),res -> {
              if (res.succeeded()) {
                if (res.result()) {
                  checkAddAccceptedReplyAddress(msg);
                  deliverMessage(sock,address,msg);
                }
 else {
                  if (debug) {
                    log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
                  }
                }
              }
 else {
                log.error(res.cause());
              }
            }
);
          }
 else {
            checkAddAccceptedReplyAddress(msg);
            deliverMessage(sock,address,msg);
          }
        }
 else {
          if (debug) {
            log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
          }
        }
      }
;
      MessageConsumer reg=eb.consumer(address).handler(handler);
      registrations.put(address,reg);
      handlePostRegister(sock,address);
      info.handlerCount++;
    }
 else {
      if (debug) {
        log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
      }
      replyError(sock,""String_Node_Str"");
    }
  }
}"
93731,"private Match checkMatches(boolean inbound,String address,Object body){
  if (inbound && acceptedReplyAddresses.remove(address)) {
    return new Match(true);
  }
  List<PermittedOptions> matches=inbound ? inboundPermitted : outboundPermitted;
  for (  PermittedOptions matchHolder : matches) {
    String matchAddress=matchHolder.getAddress();
    String matchRegex;
    if (matchAddress == null) {
      matchRegex=matchHolder.getAddressRegex();
    }
 else {
      matchRegex=null;
    }
    boolean addressOK;
    if (matchAddress == null) {
      if (matchRegex == null) {
        addressOK=true;
      }
 else {
        addressOK=regexMatches(matchRegex,address);
      }
    }
 else {
      addressOK=matchAddress.equals(address);
    }
    if (addressOK) {
      boolean matched=structureMatches(matchHolder.getMatch(),body);
      if (matched) {
        String requiredRole=matchHolder.getRequiredRole();
        String requiredPermission=matchHolder.getRequiredPermission();
        return new Match(true,requiredRole,requiredPermission);
      }
    }
  }
  return new Match(false);
}","private Match checkMatches(boolean inbound,String address,Object body){
  List<PermittedOptions> matches=inbound ? inboundPermitted : outboundPermitted;
  for (  PermittedOptions matchHolder : matches) {
    String matchAddress=matchHolder.getAddress();
    String matchRegex;
    if (matchAddress == null) {
      matchRegex=matchHolder.getAddressRegex();
    }
 else {
      matchRegex=null;
    }
    boolean addressOK;
    if (matchAddress == null) {
      if (matchRegex == null) {
        addressOK=true;
      }
 else {
        addressOK=regexMatches(matchRegex,address);
      }
    }
 else {
      addressOK=matchAddress.equals(address);
    }
    if (addressOK) {
      boolean matched=structureMatches(matchHolder.getMatch(),body);
      if (matched) {
        String requiredRole=matchHolder.getRequiredRole();
        String requiredPermission=matchHolder.getRequiredPermission();
        return new Match(true,requiredRole,requiredPermission);
      }
    }
  }
  return new Match(false);
}"
93732,"private void checkAndSend(boolean send,String address,Object body,SockJSSocket sock,String replyAddress){
  final SockInfo info=sockInfos.get(sock);
  if (replyAddress != null && !checkMaxHandlers(sock,info)) {
    return;
  }
  final Handler<AsyncResult<Message<Object>>> replyHandler;
  if (replyAddress != null) {
    replyHandler=result -> {
      if (result.succeeded()) {
        Message message=result.result();
        checkAddAccceptedReplyAddress(message.replyAddress());
        deliverMessage(sock,replyAddress,message);
      }
 else {
        ReplyException cause=(ReplyException)result.cause();
        JsonObject envelope=new JsonObject().put(""String_Node_Str"",replyAddress).put(""String_Node_Str"",cause.failureCode()).put(""String_Node_Str"",cause.failureType().name()).put(""String_Node_Str"",cause.getMessage());
        sock.write(buffer(envelope.encode()));
      }
      info.handlerCount--;
    }
;
  }
 else {
    replyHandler=null;
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
  }
  if (send) {
    eb.send(address,body,new DeliveryOptions().setSendTimeout(replyTimeout),replyHandler);
    if (replyAddress != null) {
      info.handlerCount++;
    }
  }
 else {
    eb.publish(address,body);
  }
}","private void checkAndSend(boolean send,String address,Object body,SockJSSocket sock,String replyAddress,Message awaitingReply){
  final SockInfo info=sockInfos.get(sock);
  if (replyAddress != null && !checkMaxHandlers(sock,info)) {
    return;
  }
  final Handler<AsyncResult<Message<Object>>> replyHandler;
  if (replyAddress != null) {
    replyHandler=result -> {
      if (result.succeeded()) {
        Message message=result.result();
        checkAddAccceptedReplyAddress(message);
        deliverMessage(sock,replyAddress,message);
      }
 else {
        ReplyException cause=(ReplyException)result.cause();
        JsonObject envelope=new JsonObject().put(""String_Node_Str"",replyAddress).put(""String_Node_Str"",cause.failureCode()).put(""String_Node_Str"",cause.failureType().name()).put(""String_Node_Str"",cause.getMessage());
        sock.write(buffer(envelope.encode()));
      }
      info.handlerCount--;
    }
;
  }
 else {
    replyHandler=null;
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
  }
  if (send) {
    if (awaitingReply != null) {
      awaitingReply.reply(body,replyHandler);
    }
 else {
      eb.send(address,body,new DeliveryOptions().setSendTimeout(replyTimeout),replyHandler);
    }
    if (replyAddress != null) {
      info.handlerCount++;
    }
  }
 else {
    eb.publish(address,body);
  }
}"
93733,"private void doSendOrPub(boolean send,SockJSSocket sock,String address,JsonObject message){
  final Object body=message.getValue(""String_Node_Str"");
  final String replyAddress=message.getString(""String_Node_Str"");
  if (replyAddress != null && replyAddress.length() > 36) {
    log.error(""String_Node_Str"");
    replyError(sock,""String_Node_Str"");
    return;
  }
  final boolean debug=log.isDebugEnabled();
  if (debug) {
    log.debug(""String_Node_Str"" + address + ""String_Node_Str""+ body);
  }
  Match curMatch=checkMatches(true,address,body);
  if (curMatch.doesMatch) {
    if (curMatch.requiredPermission != null || curMatch.requiredRole != null) {
      Session apexSession=sock.apexSession();
      if (apexSession != null) {
        if (!apexSession.isLoggedIn()) {
          replyError(sock,""String_Node_Str"");
        }
 else {
          authorise(curMatch,apexSession,res -> {
            if (res.succeeded()) {
              if (res.result()) {
                checkAndSend(send,address,body,sock,replyAddress);
              }
 else {
                replyError(sock,""String_Node_Str"");
                if (debug) {
                  log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
                }
              }
            }
 else {
              replyError(sock,""String_Node_Str"");
              log.error(""String_Node_Str"",res.cause());
            }
          }
);
        }
      }
 else {
        replyError(sock,""String_Node_Str"");
        if (debug) {
          log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
        }
      }
    }
 else {
      checkAndSend(send,address,body,sock,replyAddress);
    }
  }
 else {
    replyError(sock,""String_Node_Str"");
    if (debug) {
      log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
    }
  }
}","private void doSendOrPub(boolean send,SockJSSocket sock,String address,JsonObject message){
  final Object body=message.getValue(""String_Node_Str"");
  final String replyAddress=message.getString(""String_Node_Str"");
  if (replyAddress != null && replyAddress.length() > 36) {
    log.error(""String_Node_Str"");
    replyError(sock,""String_Node_Str"");
    return;
  }
  final boolean debug=log.isDebugEnabled();
  if (debug) {
    log.debug(""String_Node_Str"" + address + ""String_Node_Str""+ body);
  }
  final Message awaitingReply=messagesAwaitingReply.remove(address);
  Match curMatch;
  if (awaitingReply != null) {
    curMatch=new Match(true);
  }
 else {
    curMatch=checkMatches(true,address,body);
  }
  if (curMatch.doesMatch) {
    if (curMatch.requiredPermission != null || curMatch.requiredRole != null) {
      Session apexSession=sock.apexSession();
      if (apexSession != null) {
        if (!apexSession.isLoggedIn()) {
          replyError(sock,""String_Node_Str"");
        }
 else {
          authorise(curMatch,apexSession,res -> {
            if (res.succeeded()) {
              if (res.result()) {
                checkAndSend(send,address,body,sock,replyAddress,null);
              }
 else {
                replyError(sock,""String_Node_Str"");
                if (debug) {
                  log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
                }
              }
            }
 else {
              replyError(sock,""String_Node_Str"");
              log.error(""String_Node_Str"",res.cause());
            }
          }
);
        }
      }
 else {
        replyError(sock,""String_Node_Str"");
        if (debug) {
          log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
        }
      }
    }
 else {
      checkAndSend(send,address,body,sock,replyAddress,awaitingReply);
    }
  }
 else {
    replyError(sock,""String_Node_Str"");
    if (debug) {
      log.debug(""String_Node_Str"" + address + ""String_Node_Str"");
    }
  }
}"
93734,"@Override public void handle(Buffer buff){
  if (failed) {
    return;
  }
  if (bodyLimit != -1 && body.length() > bodyLimit) {
    failed=true;
    context.fail(413);
  }
 else {
    body.appendBuffer(buff);
  }
}","@Override public void handle(Buffer buff){
  if (failed) {
    return;
  }
  if (bodyLimit != -1 && (body.length() + buff.length()) > bodyLimit) {
    failed=true;
    context.fail(413);
  }
 else {
    body.appendBuffer(buff);
  }
}"
93735,"boolean shouldUseCached(HttpServerRequest request){
  String ifModifiedSince=request.headers().get(""String_Node_Str"");
  if (ifModifiedSince == null) {
    return false;
  }
  Date ifModifiedSinceDate=parseDate(ifModifiedSince);
  boolean modifiedSince=props.lastModifiedTime() > ifModifiedSinceDate.getTime();
  return !modifiedSince;
}","boolean shouldUseCached(HttpServerRequest request){
  String ifModifiedSince=request.headers().get(""String_Node_Str"");
  if (ifModifiedSince == null) {
    return false;
  }
  Date ifModifiedSinceDate=parseDate(ifModifiedSince);
  boolean modifiedSince=Utils.secondsFactor(props.lastModifiedTime()) > ifModifiedSinceDate.getTime();
  return !modifiedSince;
}"
93736,"private void sendDirectory(String dir,RoutingContext context){
  FileSystem fileSystem=context.vertx().fileSystem();
  HttpServerRequest request=context.request();
  fileSystem.readDir(dir,asyncResult -> {
    if (asyncResult.failed()) {
      context.fail(asyncResult.cause());
    }
 else {
      String accept=request.headers().get(""String_Node_Str"");
      if (accept == null) {
        accept=""String_Node_Str"";
      }
      if (accept.contains(""String_Node_Str"")) {
        String normalizedDir=dir.substring(webRoot.length());
        if (!normalizedDir.endsWith(""String_Node_Str"")) {
          normalizedDir+=""String_Node_Str"";
        }
        String file;
        StringBuilder files=new StringBuilder(""String_Node_Str"");
        List<String> list=asyncResult.result();
        Collections.sort(list);
        for (        String s : list) {
          file=s.substring(s.lastIndexOf('/') + 1);
          if (!includeHidden && file.charAt(0) == '.') {
            continue;
          }
          files.append(""String_Node_Str"");
          files.append(normalizedDir);
          files.append(file);
          files.append(""String_Node_Str"");
          files.append(file);
          files.append(""String_Node_Str"");
          files.append(file);
          files.append(""String_Node_Str"");
        }
        files.append(""String_Node_Str"");
        int slashPos=0;
        for (int i=dir.length() - 2; i > 0; i--) {
          if (dir.charAt(i) == '/') {
            slashPos=i;
            break;
          }
        }
        String parent=""String_Node_Str"" + dir.substring(0,slashPos + 1) + ""String_Node_Str"";
        request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
        request.response().end(directoryTemplate(context.vertx()).replace(""String_Node_Str"",normalizedDir).replace(""String_Node_Str"",parent).replace(""String_Node_Str"",files.toString()));
      }
 else       if (accept.contains(""String_Node_Str"")) {
        String file;
        JsonArray json=new JsonArray();
        for (        String s : asyncResult.result()) {
          file=s.substring(s.lastIndexOf('/') + 1);
          if (!includeHidden && file.charAt(0) == '.') {
            continue;
          }
          json.add(file);
        }
        request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
        request.response().end(json.encode());
      }
 else {
        String file;
        StringBuilder buffer=new StringBuilder();
        for (        String s : asyncResult.result()) {
          file=s.substring(s.lastIndexOf('/') + 1);
          if (!includeHidden && file.charAt(0) == '.') {
            continue;
          }
          buffer.append(file);
          buffer.append('\n');
        }
        request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
        request.response().end(buffer.toString());
      }
    }
  }
);
}","private void sendDirectory(String dir,RoutingContext context){
  FileSystem fileSystem=context.vertx().fileSystem();
  HttpServerRequest request=context.request();
  fileSystem.readDir(dir,asyncResult -> {
    if (asyncResult.failed()) {
      context.fail(asyncResult.cause());
    }
 else {
      String accept=request.headers().get(""String_Node_Str"");
      if (accept == null) {
        accept=""String_Node_Str"";
      }
      if (accept.contains(""String_Node_Str"")) {
        String normalizedDir=dir.substring(webRoot.length());
        if (!normalizedDir.endsWith(""String_Node_Str"")) {
          normalizedDir+=""String_Node_Str"";
        }
        String file;
        StringBuilder files=new StringBuilder(""String_Node_Str"");
        List<String> list=asyncResult.result();
        Collections.sort(list);
        for (        String s : list) {
          file=s.substring(s.lastIndexOf(File.separatorChar) + 1);
          if (!includeHidden && file.charAt(0) == '.') {
            continue;
          }
          files.append(""String_Node_Str"");
          files.append(normalizedDir);
          files.append(file);
          files.append(""String_Node_Str"");
          files.append(file);
          files.append(""String_Node_Str"");
          files.append(file);
          files.append(""String_Node_Str"");
        }
        files.append(""String_Node_Str"");
        int slashPos=0;
        for (int i=dir.length() - 2; i > 0; i--) {
          if (dir.charAt(i) == '/') {
            slashPos=i;
            break;
          }
        }
        String parent=""String_Node_Str"" + dir.substring(0,slashPos + 1) + ""String_Node_Str"";
        request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
        request.response().end(directoryTemplate(context.vertx()).replace(""String_Node_Str"",normalizedDir).replace(""String_Node_Str"",parent).replace(""String_Node_Str"",files.toString()));
      }
 else       if (accept.contains(""String_Node_Str"")) {
        String file;
        JsonArray json=new JsonArray();
        for (        String s : asyncResult.result()) {
          file=s.substring(s.lastIndexOf(File.separatorChar) + 1);
          if (!includeHidden && file.charAt(0) == '.') {
            continue;
          }
          json.add(file);
        }
        request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
        request.response().end(json.encode());
      }
 else {
        String file;
        StringBuilder buffer=new StringBuilder();
        for (        String s : asyncResult.result()) {
          file=s.substring(s.lastIndexOf(File.separatorChar) + 1);
          if (!includeHidden && file.charAt(0) == '.') {
            continue;
          }
          buffer.append(file);
          buffer.append('\n');
        }
        request.response().putHeader(""String_Node_Str"",""String_Node_Str"");
        request.response().end(buffer.toString());
      }
    }
  }
);
}"
93737,"private void testFileUpload(String uploadsDir,int size) throws Exception {
  String name=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  String contentType=""String_Node_Str"";
  Buffer fileData=TestUtils.randomBuffer(size);
  router.route().handler(rc -> {
    Set<FileUpload> fileUploads=rc.fileUploads();
    assertNotNull(fileUploads);
    assertEquals(1,fileUploads.size());
    FileUpload upload=fileUploads.iterator().next();
    assertEquals(name,upload.name());
    assertEquals(fileName,upload.fileName());
    assertEquals(contentType,upload.contentType());
    assertEquals(""String_Node_Str"",upload.contentTransferEncoding());
    assertEquals(fileData.length(),upload.size());
    String uploadedFileName=upload.uploadedFileName();
    assertTrue(uploadedFileName.startsWith(uploadsDir + ""String_Node_Str""));
    Buffer uploaded=vertx.fileSystem().readFileBlocking(uploadedFileName);
    assertEquals(fileData,uploaded);
    Buffer rawBody=rc.getBody();
    assertNotNull(rawBody);
    assertTrue(rawBody.length() > fileData.length());
    rc.response().end();
  }
);
  sendFileUploadRequest(fileData,200,""String_Node_Str"");
}","private void testFileUpload(String uploadsDir,int size) throws Exception {
  String name=""String_Node_Str"";
  String fileName=""String_Node_Str"";
  String contentType=""String_Node_Str"";
  Buffer fileData=TestUtils.randomBuffer(size);
  router.route().handler(rc -> {
    Set<FileUpload> fileUploads=rc.fileUploads();
    assertNotNull(fileUploads);
    assertEquals(1,fileUploads.size());
    FileUpload upload=fileUploads.iterator().next();
    assertEquals(name,upload.name());
    assertEquals(fileName,upload.fileName());
    assertEquals(contentType,upload.contentType());
    assertEquals(""String_Node_Str"",upload.contentTransferEncoding());
    assertEquals(fileData.length(),upload.size());
    String uploadedFileName=upload.uploadedFileName();
    assertTrue(uploadedFileName.startsWith(uploadsDir + File.separator));
    Buffer uploaded=vertx.fileSystem().readFileBlocking(uploadedFileName);
    assertEquals(fileData,uploaded);
    Buffer rawBody=rc.getBody();
    assertNotNull(rawBody);
    assertTrue(rawBody.length() > fileData.length());
    rc.response().end();
  }
);
  sendFileUploadRequest(fileData,200,""String_Node_Str"");
}"
93738,"@Test public void testContentHeadersSet() throws Exception {
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String contentType=res.headers().get(""String_Node_Str"");
    String contentLength=res.headers().get(""String_Node_Str"");
    assertEquals(""String_Node_Str"",contentType);
    assertEquals(36,Integer.valueOf(contentLength).intValue());
  }
,200,""String_Node_Str"",null);
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String contentType=res.headers().get(""String_Node_Str"");
    String contentLength=res.headers().get(""String_Node_Str"");
    assertEquals(""String_Node_Str"",contentType);
    assertEquals(18,Integer.valueOf(contentLength).intValue());
  }
,200,""String_Node_Str"",null);
}","@Test public void testContentHeadersSet() throws Exception {
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String contentType=res.headers().get(""String_Node_Str"");
    String contentLength=res.headers().get(""String_Node_Str"");
    assertEquals(""String_Node_Str"",contentType);
    assertEquals(36,Integer.valueOf(contentLength).intValue());
  }
,200,""String_Node_Str"",null);
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String contentType=res.headers().get(""String_Node_Str"");
    String contentLength=res.headers().get(""String_Node_Str"");
    assertEquals(""String_Node_Str"",contentType);
    int contentLengthInt=Integer.valueOf(contentLength);
    assertTrue(18 == contentLengthInt || 20 == contentLengthInt);
  }
,200,""String_Node_Str"",null);
}"
93739,"@Test public void testCacheFilesNotReadOnly() throws Exception {
  stat.setFilesReadOnly(false);
  stat.setWebRoot(""String_Node_Str"");
  long modified=new File(""String_Node_Str"",""String_Node_Str"").lastModified();
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String lastModified=res.headers().get(""String_Node_Str"");
    assertEquals(modified,toDateTime(lastModified));
  }
,200,""String_Node_Str"",""String_Node_Str"");
  testRequest(HttpMethod.GET,""String_Node_Str"",req -> {
    req.putHeader(""String_Node_Str"",dateTimeFormatter.format(modified));
  }
,null,304,""String_Node_Str"",null);
}","@Test public void testCacheFilesNotReadOnly() throws Exception {
  stat.setFilesReadOnly(false);
  stat.setWebRoot(""String_Node_Str"");
  long modified=Utils.secondsFactor(new File(""String_Node_Str"",""String_Node_Str"").lastModified());
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String lastModified=res.headers().get(""String_Node_Str"");
    assertEquals(modified,toDateTime(lastModified));
  }
,200,""String_Node_Str"",""String_Node_Str"");
  testRequest(HttpMethod.GET,""String_Node_Str"",req -> {
    req.putHeader(""String_Node_Str"",dateTimeFormatter.format(modified));
  }
,null,304,""String_Node_Str"",null);
}"
93740,"@Test public void testCacheReturnFromCache() throws Exception {
  AtomicReference<String> lastModifiedRef=new AtomicReference<>();
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String cacheControl=res.headers().get(""String_Node_Str"");
    String lastModified=res.headers().get(""String_Node_Str"");
    lastModifiedRef.set(lastModified);
    assertNotNull(cacheControl);
    assertNotNull(lastModified);
    long diff=System.currentTimeMillis() - toDateTime(lastModified);
    assertTrue(diff > 0 && diff < 2000);
    assertEquals(""String_Node_Str"" + StaticHandler.DEFAULT_MAX_AGE_SECONDS,cacheControl);
  }
,200,""String_Node_Str"",""String_Node_Str"");
  testRequest(HttpMethod.GET,""String_Node_Str"",req -> {
    req.putHeader(""String_Node_Str"",lastModifiedRef.get());
  }
,null,304,""String_Node_Str"",null);
}","@Test public void testCacheReturnFromCache() throws Exception {
  AtomicReference<String> lastModifiedRef=new AtomicReference<>();
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String cacheControl=res.headers().get(""String_Node_Str"");
    String lastModified=res.headers().get(""String_Node_Str"");
    lastModifiedRef.set(lastModified);
    assertNotNull(cacheControl);
    assertNotNull(lastModified);
    assertEquals(""String_Node_Str"" + StaticHandler.DEFAULT_MAX_AGE_SECONDS,cacheControl);
  }
,200,""String_Node_Str"",""String_Node_Str"");
  testRequest(HttpMethod.GET,""String_Node_Str"",req -> {
    req.putHeader(""String_Node_Str"",lastModifiedRef.get());
  }
,null,304,""String_Node_Str"",null);
}"
93741,"@Test public void testCacheFilesEntryOld() throws Exception {
  stat.setFilesReadOnly(false);
  stat.setWebRoot(""String_Node_Str"");
  stat.setCacheEntryTimeout(2000);
  File resource=new File(""String_Node_Str"",""String_Node_Str"");
  long modified=resource.lastModified();
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String lastModified=res.headers().get(""String_Node_Str"");
    assertEquals(modified,toDateTime(lastModified));
    resource.setLastModified(modified + 1000);
  }
,200,""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(2001);
  testRequest(HttpMethod.GET,""String_Node_Str"",req -> {
    req.putHeader(""String_Node_Str"",dateTimeFormatter.format(modified));
  }
,res -> {
    String lastModified=res.headers().get(""String_Node_Str"");
    assertEquals(modified + 1000,toDateTime(lastModified));
  }
,200,""String_Node_Str"",""String_Node_Str"");
}","@Test public void testCacheFilesEntryOld() throws Exception {
  stat.setFilesReadOnly(false);
  stat.setWebRoot(""String_Node_Str"");
  stat.setCacheEntryTimeout(2000);
  File resource=new File(""String_Node_Str"",""String_Node_Str"");
  long modified=Utils.secondsFactor(resource.lastModified());
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String lastModified=res.headers().get(""String_Node_Str"");
    assertEquals(modified,toDateTime(lastModified));
    resource.setLastModified(modified + 1000);
  }
,200,""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(2001);
  testRequest(HttpMethod.GET,""String_Node_Str"",req -> {
    req.putHeader(""String_Node_Str"",dateTimeFormatter.format(modified));
  }
,res -> {
    String lastModified=res.headers().get(""String_Node_Str"");
    assertEquals(modified + 1000,toDateTime(lastModified));
  }
,200,""String_Node_Str"",""String_Node_Str"");
}"
93742,"@Test public void testCacheGetNew() throws Exception {
  AtomicReference<String> lastModifiedRef=new AtomicReference<>();
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String cacheControl=res.headers().get(""String_Node_Str"");
    String lastModified=res.headers().get(""String_Node_Str"");
    lastModifiedRef.set(lastModified);
    assertNotNull(cacheControl);
    assertNotNull(lastModified);
    long diff=System.currentTimeMillis() - toDateTime(lastModified);
    assertTrue(diff > 0 && diff < 2000);
    assertEquals(""String_Node_Str"" + StaticHandler.DEFAULT_MAX_AGE_SECONDS,cacheControl);
  }
,200,""String_Node_Str"",""String_Node_Str"");
  testRequest(HttpMethod.GET,""String_Node_Str"",req -> {
    req.putHeader(""String_Node_Str"",dateTimeFormatter.format(toDateTime(lastModifiedRef.get()) - 1));
  }
,res -> {
  }
,200,""String_Node_Str"",""String_Node_Str"");
}","@Test public void testCacheGetNew() throws Exception {
  AtomicReference<String> lastModifiedRef=new AtomicReference<>();
  testRequest(HttpMethod.GET,""String_Node_Str"",null,res -> {
    String cacheControl=res.headers().get(""String_Node_Str"");
    String lastModified=res.headers().get(""String_Node_Str"");
    lastModifiedRef.set(lastModified);
    assertNotNull(cacheControl);
    assertNotNull(lastModified);
    assertEquals(""String_Node_Str"" + StaticHandler.DEFAULT_MAX_AGE_SECONDS,cacheControl);
  }
,200,""String_Node_Str"",""String_Node_Str"");
  testRequest(HttpMethod.GET,""String_Node_Str"",req -> {
    req.putHeader(""String_Node_Str"",dateTimeFormatter.format(toDateTime(lastModifiedRef.get()) - 1));
  }
,res -> {
  }
,200,""String_Node_Str"",""String_Node_Str"");
}"
93743,"@Test public void testTemplateHandlerNoExtension() throws Exception {
  TemplateEngine engine=MVELTemplateEngine.create();
  testTemplateHandler(engine,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test public void testTemplateHandlerNoExtension() throws Exception {
  TemplateEngine engine=MVELTemplateEngine.create();
  testTemplateHandler(engine,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + Utils.LINE_SEPARATOR + ""String_Node_Str"");
}"
93744,"@Test public void testTemplateHandlerOnFileSystem() throws Exception {
  TemplateEngine engine=MVELTemplateEngine.create();
  testTemplateHandler(engine,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test public void testTemplateHandlerOnFileSystem() throws Exception {
  TemplateEngine engine=MVELTemplateEngine.create();
  testTemplateHandler(engine,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + Utils.LINE_SEPARATOR + ""String_Node_Str"");
}"
93745,"@Test public void testTemplateHandlerChangeExtension() throws Exception {
  TemplateEngine engine=MVELTemplateEngine.create().setExtension(""String_Node_Str"");
  testTemplateHandler(engine,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test public void testTemplateHandlerChangeExtension() throws Exception {
  TemplateEngine engine=MVELTemplateEngine.create().setExtension(""String_Node_Str"");
  testTemplateHandler(engine,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + Utils.LINE_SEPARATOR + ""String_Node_Str"");
}"
93746,"@Test public void testTemplateHandlerOnClasspath() throws Exception {
  TemplateEngine engine=MVELTemplateEngine.create();
  testTemplateHandler(engine,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test public void testTemplateHandlerOnClasspath() throws Exception {
  TemplateEngine engine=MVELTemplateEngine.create();
  testTemplateHandler(engine,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + Utils.LINE_SEPARATOR + ""String_Node_Str"");
}"
93747,"@Test public void testRenderToBuffer() throws Exception {
  TemplateEngine engine=new TestEngine(false);
  String expected=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  router.route().handler(context -> {
    context.put(""String_Node_Str"",""String_Node_Str"");
    context.put(""String_Node_Str"",""String_Node_Str"");
    engine.render(context,""String_Node_Str"",onSuccess(res -> {
      String rendered=res.toString();
      assertEquals(expected,rendered);
      context.response().putHeader(HttpHeaders.CONTENT_TYPE,""String_Node_Str"");
      context.response().end(rendered);
      testComplete();
    }
));
  }
);
  testRequest(HttpMethod.GET,""String_Node_Str"",200,""String_Node_Str"",expected);
  await();
}","@Test public void testRenderToBuffer() throws Exception {
  TemplateEngine engine=new TestEngine(false);
  String expected=""String_Node_Str"" + Utils.LINE_SEPARATOR + ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str"";
  router.route().handler(context -> {
    context.put(""String_Node_Str"",""String_Node_Str"");
    context.put(""String_Node_Str"",""String_Node_Str"");
    engine.render(context,""String_Node_Str"",onSuccess(res -> {
      String rendered=res.toString();
      assertEquals(expected,rendered);
      context.response().putHeader(HttpHeaders.CONTENT_TYPE,""String_Node_Str"");
      context.response().end(rendered);
      testComplete();
    }
));
  }
);
  testRequest(HttpMethod.GET,""String_Node_Str"",200,""String_Node_Str"",expected);
  await();
}"
93748,"private void testRelativeToRoutePath(String pathPrefix) throws Exception {
  TemplateEngine engine=new TestEngine(false);
  router.route().handler(context -> {
    context.put(""String_Node_Str"",""String_Node_Str"");
    context.put(""String_Node_Str"",""String_Node_Str"");
    context.next();
  }
);
  Route route=router.route();
  if (pathPrefix != null) {
    route.path(pathPrefix);
  }
  route.handler(TemplateHandler.create(engine,""String_Node_Str"",""String_Node_Str""));
  String expected=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  testRequest(HttpMethod.GET,pathPrefix != null ? pathPrefix + ""String_Node_Str"" : ""String_Node_Str"",200,""String_Node_Str"",expected);
}","private void testRelativeToRoutePath(String pathPrefix) throws Exception {
  TemplateEngine engine=new TestEngine(false);
  router.route().handler(context -> {
    context.put(""String_Node_Str"",""String_Node_Str"");
    context.put(""String_Node_Str"",""String_Node_Str"");
    context.next();
  }
);
  Route route=router.route();
  if (pathPrefix != null) {
    route.path(pathPrefix);
  }
  route.handler(TemplateHandler.create(engine,""String_Node_Str"",""String_Node_Str""));
  String expected=""String_Node_Str"" + Utils.LINE_SEPARATOR + ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str"";
  testRequest(HttpMethod.GET,pathPrefix != null ? pathPrefix + ""String_Node_Str"" : ""String_Node_Str"",200,""String_Node_Str"",expected);
}"
93749,"@Test public void testRenderDirectly() throws Exception {
  TemplateEngine engine=new TestEngine(false);
  router.route().handler(context -> {
    context.put(""String_Node_Str"",""String_Node_Str"");
    context.put(""String_Node_Str"",""String_Node_Str"");
    engine.render(context,""String_Node_Str"",res -> {
      if (res.succeeded()) {
        context.response().putHeader(HttpHeaders.CONTENT_TYPE,""String_Node_Str"").end(res.result());
      }
 else {
        context.fail(res.cause());
      }
    }
);
  }
);
  String expected=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  testRequest(HttpMethod.GET,""String_Node_Str"",200,""String_Node_Str"",expected);
}","@Test public void testRenderDirectly() throws Exception {
  TemplateEngine engine=new TestEngine(false);
  router.route().handler(context -> {
    context.put(""String_Node_Str"",""String_Node_Str"");
    context.put(""String_Node_Str"",""String_Node_Str"");
    engine.render(context,""String_Node_Str"",res -> {
      if (res.succeeded()) {
        context.response().putHeader(HttpHeaders.CONTENT_TYPE,""String_Node_Str"").end(res.result());
      }
 else {
        context.fail(res.cause());
      }
    }
);
  }
);
  String expected=""String_Node_Str"" + Utils.LINE_SEPARATOR + ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str""+ Utils.LINE_SEPARATOR+ ""String_Node_Str"";
  testRequest(HttpMethod.GET,""String_Node_Str"",200,""String_Node_Str"",expected);
}"
93750,"@SuppressLint(""String_Node_Str"") public List<AppInfo> loadAppInfo(Context context){
  List<AppInfo> appInfos=new ArrayList<AppInfo>();
  List<AppInfo> kanjiStartAppInfos=new ArrayList<AppInfo>();
  List<AppInfo> nonKanjiStartAppInfos=new ArrayList<AppInfo>();
  do {
    if (null == context) {
      break;
    }
    PackageManager pm=context.getPackageManager();
    long startLoadTime=System.currentTimeMillis();
    int flags=PackageManager.GET_UNINSTALLED_PACKAGES;
    List<PackageInfo> packageInfos=pm.getInstalledPackages(flags);
    Log.i(TAG,packageInfos.size() + ""String_Node_Str"");
    for (    PackageInfo pi : packageInfos) {
      boolean canLaunchTheMainActivity=AppUtil.appCanLaunchTheMainActivity(mContext,pi.packageName);
      if (true == canLaunchTheMainActivity) {
        AppInfo appInfo=getAppInfo(pm,pi);
        PinyinUtil.chineseStringToPinyinUnit(appInfo.getLabel(),appInfo.getLabelPinyinUnits());
        String sortKey=PinyinUtil.getSortKey(appInfo.getLabelPinyinUnits()).toUpperCase();
        appInfo.setSortKey(praseSortKey(sortKey));
        boolean isKanji=PinyinUtil.isKanji(appInfo.getLabel().charAt(0));
        if (true == isKanji) {
          kanjiStartAppInfos.add(appInfo);
        }
 else {
          nonKanjiStartAppInfos.add(appInfo);
        }
      }
    }
    long endLoadTime=System.currentTimeMillis();
    Log.i(TAG,""String_Node_Str"" + (endLoadTime - startLoadTime) + ""String_Node_Str"");
    break;
  }
 while (false);
  long sortStartTime=System.currentTimeMillis();
  Collections.sort(kanjiStartAppInfos,AppInfo.mAscComparator);
  Collections.sort(nonKanjiStartAppInfos,AppInfo.mAscComparator);
  appInfos.addAll(kanjiStartAppInfos);
  int lastIndex=0;
  boolean shouldBeAdd=false;
  for (int i=0; i < nonKanjiStartAppInfos.size(); i++) {
    String nonKanfirstLetter=PinyinUtil.getFirstLetter(nonKanjiStartAppInfos.get(i).getLabelPinyinUnits());
    int j=0;
    for (j=0 + lastIndex; j < appInfos.size(); j++) {
      String firstLetter=PinyinUtil.getFirstLetter(appInfos.get(j).getLabelPinyinUnits());
      lastIndex++;
      if (nonKanfirstLetter.charAt(0) < firstLetter.charAt(0) || nonKanfirstLetter.charAt(0) > THE_LAST_ALPHABET) {
        shouldBeAdd=true;
        break;
      }
 else {
        shouldBeAdd=false;
      }
    }
    if (lastIndex >= appInfos.size()) {
      lastIndex++;
      shouldBeAdd=true;
    }
    if (true == shouldBeAdd) {
      appInfos.add(j,nonKanjiStartAppInfos.get(i));
      shouldBeAdd=false;
    }
  }
  long sortEndTime=System.currentTimeMillis();
  Log.i(TAG,""String_Node_Str"" + (sortEndTime - sortStartTime) + ""String_Node_Str"");
  Log.i(TAG,""String_Node_Str"" + appInfos.size());
  return appInfos;
}","@SuppressLint(""String_Node_Str"") public List<AppInfo> loadAppInfo(Context context){
  List<AppInfo> appInfos=new ArrayList<AppInfo>();
  List<AppInfo> kanjiStartAppInfos=new ArrayList<AppInfo>();
  List<AppInfo> nonKanjiStartAppInfos=new ArrayList<AppInfo>();
  do {
    if (null == context) {
      break;
    }
    PackageManager pm=context.getPackageManager();
    long startLoadTime=System.currentTimeMillis();
    int flags=PackageManager.GET_UNINSTALLED_PACKAGES;
    List<PackageInfo> packageInfos=pm.getInstalledPackages(flags);
    Log.i(TAG,packageInfos.size() + ""String_Node_Str"");
    for (    PackageInfo pi : packageInfos) {
      boolean canLaunchTheMainActivity=AppUtil.appCanLaunchTheMainActivity(mContext,pi.packageName);
      if (true == canLaunchTheMainActivity) {
        AppInfo appInfo=getAppInfo(pm,pi);
        if (TextUtils.isEmpty(appInfo.getLabel())) {
          continue;
        }
        PinyinUtil.chineseStringToPinyinUnit(appInfo.getLabel(),appInfo.getLabelPinyinUnits());
        String sortKey=PinyinUtil.getSortKey(appInfo.getLabelPinyinUnits()).toUpperCase();
        appInfo.setSortKey(praseSortKey(sortKey));
        boolean isKanji=PinyinUtil.isKanji(appInfo.getLabel().charAt(0));
        if (true == isKanji) {
          kanjiStartAppInfos.add(appInfo);
        }
 else {
          nonKanjiStartAppInfos.add(appInfo);
        }
      }
    }
    long endLoadTime=System.currentTimeMillis();
    Log.i(TAG,""String_Node_Str"" + (endLoadTime - startLoadTime) + ""String_Node_Str"");
    break;
  }
 while (false);
  long sortStartTime=System.currentTimeMillis();
  Collections.sort(kanjiStartAppInfos,AppInfo.mAscComparator);
  Collections.sort(nonKanjiStartAppInfos,AppInfo.mAscComparator);
  appInfos.addAll(kanjiStartAppInfos);
  int lastIndex=0;
  boolean shouldBeAdd=false;
  for (int i=0; i < nonKanjiStartAppInfos.size(); i++) {
    String nonKanfirstLetter=PinyinUtil.getFirstLetter(nonKanjiStartAppInfos.get(i).getLabelPinyinUnits());
    int j=0;
    for (j=0 + lastIndex; j < appInfos.size(); j++) {
      String firstLetter=PinyinUtil.getFirstLetter(appInfos.get(j).getLabelPinyinUnits());
      lastIndex++;
      if (nonKanfirstLetter.charAt(0) < firstLetter.charAt(0) || nonKanfirstLetter.charAt(0) > THE_LAST_ALPHABET) {
        shouldBeAdd=true;
        break;
      }
 else {
        shouldBeAdd=false;
      }
    }
    if (lastIndex >= appInfos.size()) {
      lastIndex++;
      shouldBeAdd=true;
    }
    if (true == shouldBeAdd) {
      appInfos.add(j,nonKanjiStartAppInfos.get(i));
      shouldBeAdd=false;
    }
  }
  long sortEndTime=System.currentTimeMillis();
  Log.i(TAG,""String_Node_Str"" + (sortEndTime - sortStartTime) + ""String_Node_Str"");
  Log.i(TAG,""String_Node_Str"" + appInfos.size());
  return appInfos;
}"
93751,"@Override public void onContactsLoadSuccess(){
  ContactsHelper.getInstance().parseQwertyInputSearchContacts(null);
  mContactsOperationView.contactsLoadSuccess();
  ContactsHelper.getInstance().showContactsInfo();
  ContactsIndexHelper.getInstance().praseContacts(ContactsHelper.getInstance().getBaseContacts());
}","@Override public void onContactsLoadSuccess(){
  ContactsHelper.getInstance().parseQwertyInputSearchContacts(null);
  mContactsOperationView.contactsLoadSuccess();
  ContactsIndexHelper.getInstance().praseContacts(ContactsHelper.getInstance().getBaseContacts());
}"
93752,"@Override public View getView(int position,View convertView,ViewGroup parent){
  View view=null;
  ViewHolder viewHolder;
  Contacts contacts=getItem(position);
  if (null == convertView) {
    view=LayoutInflater.from(mContext).inflate(mTextViewResourceId,null);
    viewHolder=new ViewHolder();
    viewHolder.mAlphabetTv=(TextView)view.findViewById(R.id.alphabet_text_view);
    viewHolder.mContactsMultiplePhoneOperationPromptIv=(ImageView)view.findViewById(R.id.contacts_multiple_phone_operation_prompt_image_view);
    viewHolder.mSelectContactsCB=(CheckBox)view.findViewById(R.id.select_contacts_check_box);
    viewHolder.mNameTv=(TextView)view.findViewById(R.id.name_text_view);
    viewHolder.mPhoneNumber=(TextView)view.findViewById(R.id.phone_number_text_view);
    viewHolder.mOperationViewIv=(ImageView)view.findViewById(R.id.operation_view_image_view);
    viewHolder.mOperationViewLayout=(View)view.findViewById(R.id.operation_view_layout);
    viewHolder.mCallIv=(ImageView)view.findViewById(R.id.call_image_view);
    viewHolder.mSmsIv=(ImageView)view.findViewById(R.id.sms_image_view);
    view.setTag(viewHolder);
  }
 else {
    view=convertView;
    viewHolder=(ViewHolder)view.getTag();
  }
  showAlphabetIndex(viewHolder.mAlphabetTv,position,contacts);
switch (contacts.getSearchByType()) {
case SearchByNull:
    ViewUtil.showTextNormal(viewHolder.mNameTv,contacts.getName());
  if (null == contacts.getNextContacts()) {
    if ((true == contacts.isBelongMultipleContactsPhone()) && (false == contacts.isHideMultipleContacts())) {
      ViewUtil.invisibleView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
    }
 else {
      ViewUtil.hideView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
    }
    ViewUtil.showTextNormal(viewHolder.mPhoneNumber,contacts.getPhoneNumber());
  }
 else {
    if (true == contacts.getNextContacts().isHideMultipleContacts()) {
      ViewUtil.hideView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
      ViewUtil.showTextNormal(viewHolder.mPhoneNumber,contacts.getPhoneNumber() + mContext.getString(R.string.phone_number_count,multipleNumbersContactsCount(contacts) + 1));
    }
 else {
      ViewUtil.showView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
      ViewUtil.showTextNormal(viewHolder.mPhoneNumber,contacts.getPhoneNumber() + ""String_Node_Str"" + mContext.getString(R.string.click_to_hide)+ ""String_Node_Str"");
    }
  }
break;
case SearchByPhoneNumber:
ViewUtil.hideView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
ViewUtil.showTextNormal(viewHolder.mNameTv,contacts.getName());
ViewUtil.showTextHighlight(viewHolder.mPhoneNumber,contacts.getPhoneNumber(),contacts.getMatchKeywords().toString());
break;
case SearchByName:
ViewUtil.hideView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
ViewUtil.showTextHighlight(viewHolder.mNameTv,contacts.getName(),contacts.getMatchKeywords().toString());
ViewUtil.showTextNormal(viewHolder.mPhoneNumber,contacts.getPhoneNumber());
break;
default :
break;
}
viewHolder.mSelectContactsCB.setTag(position);
viewHolder.mSelectContactsCB.setChecked(contacts.isSelected());
viewHolder.mSelectContactsCB.setOnCheckedChangeListener(new OnCheckedChangeListener(){
@Override public void onCheckedChanged(CompoundButton buttonView,boolean isChecked){
int position=(Integer)buttonView.getTag();
Contacts contacts=getItem(position);
if ((true == isChecked) && (false == contacts.isSelected())) {
contacts.setSelected(isChecked);
addSelectedContacts(contacts);
}
 else if ((false == isChecked) && (true == contacts.isSelected())) {
contacts.setSelected(isChecked);
removeSelectedContacts(contacts);
}
 else {
return;
}
}
}
);
viewHolder.mOperationViewIv.setTag(position);
int resid=(true == contacts.isHideOperationView()) ? (R.drawable.arrow_down) : (R.drawable.arrow_up);
viewHolder.mOperationViewIv.setBackgroundResource(resid);
if (true == contacts.isHideOperationView()) {
ViewUtil.hideView(viewHolder.mOperationViewLayout);
}
 else {
ViewUtil.showView(viewHolder.mOperationViewLayout);
}
viewHolder.mOperationViewIv.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
int position=(Integer)v.getTag();
Contacts contacts=getItem(position);
contacts.setHideOperationView(!contacts.isHideOperationView());
if (null != mOnContactsAdapter) {
mOnContactsAdapter.onContactsRefreshView();
}
}
}
);
viewHolder.mCallIv.setTag(position);
viewHolder.mCallIv.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
int position=(Integer)v.getTag();
Contacts contacts=getItem(position);
if (null != mOnContactsAdapter) {
mOnContactsAdapter.onContactsCall(contacts);
}
}
}
);
viewHolder.mSmsIv.setTag(position);
viewHolder.mSmsIv.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
int position=(Integer)v.getTag();
Contacts contacts=getItem(position);
if (null != mOnContactsAdapter) {
mOnContactsAdapter.onContactsSms(contacts);
}
}
}
);
return view;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  View view=null;
  ViewHolder viewHolder;
  Contacts contacts=getItem(position);
  if (null == convertView) {
    view=LayoutInflater.from(mContext).inflate(mTextViewResourceId,null);
    viewHolder=new ViewHolder();
    viewHolder.mAlphabetTv=(TextView)view.findViewById(R.id.alphabet_text_view);
    viewHolder.mContactsMultiplePhoneOperationPromptIv=(ImageView)view.findViewById(R.id.contacts_multiple_phone_operation_prompt_image_view);
    viewHolder.mSelectContactsCB=(CheckBox)view.findViewById(R.id.select_contacts_check_box);
    viewHolder.mNameTv=(TextView)view.findViewById(R.id.name_text_view);
    viewHolder.mPhoneNumber=(TextView)view.findViewById(R.id.phone_number_text_view);
    viewHolder.mOperationViewIv=(ImageView)view.findViewById(R.id.operation_view_image_view);
    viewHolder.mOperationViewLayout=(View)view.findViewById(R.id.operation_view_layout);
    viewHolder.mCallIv=(ImageView)view.findViewById(R.id.call_image_view);
    viewHolder.mSmsIv=(ImageView)view.findViewById(R.id.sms_image_view);
    view.setTag(viewHolder);
  }
 else {
    view=convertView;
    viewHolder=(ViewHolder)view.getTag();
  }
  showAlphabetIndex(viewHolder.mAlphabetTv,position,contacts);
switch (contacts.getSearchByType()) {
case SearchByNull:
    ViewUtil.showTextNormal(viewHolder.mNameTv,contacts.getName());
  if (false == contacts.isBelongMultipleContactsPhone()) {
    ViewUtil.hideView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
    ViewUtil.showTextNormal(viewHolder.mPhoneNumber,contacts.getPhoneNumber());
  }
 else {
    if (true == contacts.isFirstMultipleContacts()) {
      if (true == contacts.getNextContacts().isHideMultipleContacts()) {
        ViewUtil.hideView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
        ViewUtil.showTextNormal(viewHolder.mPhoneNumber,contacts.getPhoneNumber() + mContext.getString(R.string.phone_number_count,multipleNumbersContactsCount(contacts) + 1));
      }
 else {
        ViewUtil.showView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
        ViewUtil.showTextNormal(viewHolder.mPhoneNumber,contacts.getPhoneNumber() + ""String_Node_Str"" + mContext.getString(R.string.click_to_hide)+ ""String_Node_Str"");
      }
    }
 else {
      if (false == contacts.isHideMultipleContacts()) {
        ViewUtil.invisibleView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
      }
 else {
        ViewUtil.hideView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
      }
      ViewUtil.showTextNormal(viewHolder.mPhoneNumber,contacts.getPhoneNumber());
    }
  }
break;
case SearchByPhoneNumber:
ViewUtil.hideView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
ViewUtil.showTextNormal(viewHolder.mNameTv,contacts.getName());
ViewUtil.showTextHighlight(viewHolder.mPhoneNumber,contacts.getPhoneNumber(),contacts.getMatchKeywords().toString());
break;
case SearchByName:
ViewUtil.hideView(viewHolder.mContactsMultiplePhoneOperationPromptIv);
ViewUtil.showTextHighlight(viewHolder.mNameTv,contacts.getName(),contacts.getMatchKeywords().toString());
ViewUtil.showTextNormal(viewHolder.mPhoneNumber,contacts.getPhoneNumber());
break;
default :
break;
}
viewHolder.mSelectContactsCB.setTag(position);
viewHolder.mSelectContactsCB.setChecked(contacts.isSelected());
viewHolder.mSelectContactsCB.setOnCheckedChangeListener(new OnCheckedChangeListener(){
@Override public void onCheckedChanged(CompoundButton buttonView,boolean isChecked){
int position=(Integer)buttonView.getTag();
Contacts contacts=getItem(position);
if ((true == isChecked) && (false == contacts.isSelected())) {
contacts.setSelected(isChecked);
addSelectedContacts(contacts);
}
 else if ((false == isChecked) && (true == contacts.isSelected())) {
contacts.setSelected(isChecked);
removeSelectedContacts(contacts);
}
 else {
return;
}
}
}
);
viewHolder.mOperationViewIv.setTag(position);
int resid=(true == contacts.isHideOperationView()) ? (R.drawable.arrow_down) : (R.drawable.arrow_up);
viewHolder.mOperationViewIv.setBackgroundResource(resid);
if (true == contacts.isHideOperationView()) {
ViewUtil.hideView(viewHolder.mOperationViewLayout);
}
 else {
ViewUtil.showView(viewHolder.mOperationViewLayout);
}
viewHolder.mOperationViewIv.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
int position=(Integer)v.getTag();
Contacts contacts=getItem(position);
contacts.setHideOperationView(!contacts.isHideOperationView());
if (null != mOnContactsAdapter) {
mOnContactsAdapter.onContactsRefreshView();
}
}
}
);
viewHolder.mCallIv.setTag(position);
viewHolder.mCallIv.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
int position=(Integer)v.getTag();
Contacts contacts=getItem(position);
if (null != mOnContactsAdapter) {
mOnContactsAdapter.onContactsCall(contacts);
}
}
}
);
viewHolder.mSmsIv.setTag(position);
viewHolder.mSmsIv.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
int position=(Integer)v.getTag();
Contacts contacts=getItem(position);
if (null != mOnContactsAdapter) {
mOnContactsAdapter.onContactsSms(contacts);
}
}
}
);
return view;
}"
93753,"public Contacts(String id,String name,String phoneNumber,String sortKey){
  super();
  setId(id);
  setName(name);
  setPhoneNumber(phoneNumber);
  setSortKey(sortKey);
  setNamePinyinUnits(new ArrayList<PinyinUnit>());
  setSearchByType(SearchByType.SearchByNull);
  setMatchKeywords(new StringBuffer());
  getMatchKeywords().delete(0,getMatchKeywords().length());
  setMatchStartIndex(-1);
  setMatchLength(0);
  setNextContacts(null);
  setSelected(false);
  setHideMultipleContacts(false);
  setHideOperationView(true);
  setBelongMultipleContactsPhone(false);
}","public Contacts(String id,String name,String phoneNumber,String sortKey){
  super();
  setId(id);
  setName(name);
  setPhoneNumber(phoneNumber);
  setSortKey(sortKey);
  setNamePinyinUnits(new ArrayList<PinyinUnit>());
  setSearchByType(SearchByType.SearchByNull);
  setMatchKeywords(new StringBuffer());
  getMatchKeywords().delete(0,getMatchKeywords().length());
  setMatchStartIndex(-1);
  setMatchLength(0);
  setNextContacts(null);
  setSelected(false);
  setFirstMultipleContacts(true);
  setHideMultipleContacts(false);
  setHideOperationView(true);
  setBelongMultipleContactsPhone(false);
}"
93754,"/** 
 * @description match Pinyin Units
 * @param pinyinUnits
 * @param baseData the original string which be parsed to PinyinUnit
 * @param search search key words
 * @param chineseKeyWord the sub string of base data
 * @return true if match success,false otherwise.
 */
@SuppressLint(""String_Node_Str"") public static boolean matchPinyinUnits(final List<PinyinUnit> pinyinUnits,final String baseData,String search,StringBuffer chineseKeyWord){
  if ((null == pinyinUnits) || (null == search) || (null == chineseKeyWord)) {
    return false;
  }
  StringBuffer matchSearch=new StringBuffer();
  matchSearch.delete(0,matchSearch.length());
  chineseKeyWord.delete(0,chineseKeyWord.length());
  String searchLowerCase=search.toLowerCase();
  int index=baseData.toLowerCase().indexOf(searchLowerCase);
  if (index > -1) {
    chineseKeyWord.append(baseData.substring(index,index + searchLowerCase.length()));
    return true;
  }
  int pinyinUnitsLength=pinyinUnits.size();
  StringBuffer searchBuffer=new StringBuffer();
  for (int i=0; i < pinyinUnitsLength; i++) {
    int j=0;
    chineseKeyWord.delete(0,chineseKeyWord.length());
    searchBuffer.delete(0,searchBuffer.length());
    searchBuffer.append(searchLowerCase);
    boolean found=findPinyinUnits(pinyinUnits,i,j,baseData,searchBuffer,chineseKeyWord);
    if (true == found) {
      return true;
    }
  }
  return false;
}","/** 
 * @description match Pinyin Units
 * @param pinyinUnits
 * @param baseData			the original string which be parsed to PinyinUnit
 * @param search			search key words
 * @param chineseKeyWord	the sub string of base data
 * @return true if match success,false otherwise.
 */
@SuppressLint(""String_Node_Str"") public static boolean matchPinyinUnits(final List<PinyinUnit> pinyinUnits,final String baseData,String search,StringBuffer chineseKeyWord){
  if ((null == pinyinUnits) || (null == search) || (null == chineseKeyWord)) {
    return false;
  }
  StringBuffer matchSearch=new StringBuffer();
  matchSearch.delete(0,matchSearch.length());
  chineseKeyWord.delete(0,chineseKeyWord.length());
  String searchLowerCase=search.toLowerCase();
  int index=baseData.toLowerCase().indexOf(searchLowerCase);
  if (index > -1) {
    chineseKeyWord.append(baseData.substring(index,index + searchLowerCase.length()));
    return true;
  }
  int pinyinUnitsLength=pinyinUnits.size();
  StringBuffer searchBuffer=new StringBuffer();
  for (int i=0; i < pinyinUnitsLength; i++) {
    int j=0;
    chineseKeyWord.delete(0,chineseKeyWord.length());
    searchBuffer.delete(0,searchBuffer.length());
    searchBuffer.append(searchLowerCase);
    boolean found=findPinyinUnits(pinyinUnits,i,j,baseData,searchBuffer,chineseKeyWord);
    if (true == found) {
      return true;
    }
  }
  return false;
}"
93755,"/** 
 * @description match search string with pinyinUnits,if success,save theChinese keywords.
 * @param pinyinUnits pinyinUnits head node index
 * @param pinyinUnitIndex pinyinUint Index
 * @param qwertyPinyinUnitIndex pinyinBaseUnit Index
 * @param baseData base data for search.
 * @param searchBuffer search keyword.
 * @param chineseKeyWord save the Chinese keyword.
 * @return true if find,false otherwise.
 */
private static boolean findPinyinUnits(final List<PinyinUnit> pinyinUnits,int pinyinUnitIndex,int qwertyPinyinUnitIndex,final String baseData,StringBuffer searchBuffer,StringBuffer chineseKeyWord){
  if ((null == pinyinUnits) || (null == baseData) || (null == searchBuffer)|| (null == chineseKeyWord)) {
    return false;
  }
  String search=searchBuffer.toString();
  if (search.length() <= 0) {
    return true;
  }
  if (pinyinUnitIndex >= pinyinUnits.size()) {
    return false;
  }
  PinyinUnit pyUnit=pinyinUnits.get(pinyinUnitIndex);
  if (qwertyPinyinUnitIndex >= pyUnit.getPinyinBaseUnitIndex().size()) {
    return false;
  }
  PinyinBaseUnit pinyinBaseUnit=pyUnit.getPinyinBaseUnitIndex().get(qwertyPinyinUnitIndex);
  if (pyUnit.isPinyin()) {
    if (search.startsWith(String.valueOf(pinyinBaseUnit.getPinyin().charAt(0)))) {
      searchBuffer.delete(0,1);
      chineseKeyWord.append(baseData.charAt(pyUnit.getStartPosition()));
      boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex + 1,0,baseData,searchBuffer,chineseKeyWord);
      if (true == found) {
        return true;
      }
 else {
        searchBuffer.insert(0,pinyinBaseUnit.getPinyin().charAt(0));
        chineseKeyWord.deleteCharAt(chineseKeyWord.length() - 1);
      }
    }
    if (pinyinBaseUnit.getPinyin().startsWith(search)) {
      chineseKeyWord.append(baseData.charAt(pyUnit.getStartPosition()));
      searchBuffer.delete(0,searchBuffer.length());
      return true;
    }
 else     if (search.startsWith(pinyinBaseUnit.getPinyin())) {
      searchBuffer.delete(0,pinyinBaseUnit.getPinyin().length());
      chineseKeyWord.append(baseData.charAt(pyUnit.getStartPosition()));
      boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex + 1,0,baseData,searchBuffer,chineseKeyWord);
      if (true == found) {
        return true;
      }
 else {
        searchBuffer.insert(0,pinyinBaseUnit.getPinyin());
        chineseKeyWord.deleteCharAt(chineseKeyWord.length() - 1);
      }
    }
 else {
      boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex,qwertyPinyinUnitIndex + 1,baseData,searchBuffer,chineseKeyWord);
      if (found == true) {
        return true;
      }
    }
  }
 else {
    if (pinyinBaseUnit.getPinyin().startsWith(search)) {
      int startIndex=0;
      chineseKeyWord.append(baseData.substring(startIndex + pyUnit.getStartPosition(),startIndex + pyUnit.getStartPosition() + search.length()));
      searchBuffer.delete(0,searchBuffer.length());
      return true;
    }
 else     if (search.startsWith(pinyinBaseUnit.getPinyin())) {
      int startIndex=0;
      searchBuffer.delete(0,pinyinBaseUnit.getPinyin().length());
      chineseKeyWord.append(baseData.substring(startIndex + pyUnit.getStartPosition(),startIndex + pyUnit.getStartPosition() + pinyinBaseUnit.getPinyin().length()));
      boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex + 1,0,baseData,searchBuffer,chineseKeyWord);
      if (true == found) {
        return true;
      }
 else {
        searchBuffer.insert(0,pinyinBaseUnit.getPinyin());
        chineseKeyWord.delete(chineseKeyWord.length() - pinyinBaseUnit.getPinyin().length(),chineseKeyWord.length());
      }
    }
 else     if ((chineseKeyWord.length() <= 0)) {
      if (pinyinBaseUnit.getPinyin().contains(search)) {
        int index=pinyinBaseUnit.getPinyin().indexOf(search);
        chineseKeyWord.append(baseData.substring(index + pyUnit.getStartPosition(),index + pyUnit.getStartPosition() + search.length()));
        searchBuffer.delete(0,searchBuffer.length());
        return true;
      }
 else {
        int numLength=pinyinBaseUnit.getPinyin().length();
        for (int i=0; i < numLength; i++) {
          String subStr=pinyinBaseUnit.getPinyin().substring(i);
          if (search.startsWith(subStr)) {
            searchBuffer.delete(0,subStr.length());
            chineseKeyWord.append(baseData.substring(i + pyUnit.getStartPosition(),i + pyUnit.getStartPosition() + subStr.length()));
            boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex + 1,0,baseData,searchBuffer,chineseKeyWord);
            if (true == found) {
              return true;
            }
 else {
              searchBuffer.insert(0,pinyinBaseUnit.getPinyin().substring(i));
              chineseKeyWord.delete(chineseKeyWord.length() - subStr.length(),chineseKeyWord.length());
            }
          }
        }
        boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex,qwertyPinyinUnitIndex + 1,baseData,searchBuffer,chineseKeyWord);
        if (true == found) {
          return true;
        }
      }
    }
 else {
      boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex,qwertyPinyinUnitIndex + 1,baseData,searchBuffer,chineseKeyWord);
      if (true == found) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * @description match search string with pinyinUnits,if success,save the Chinese keywords.
 * @param pinyinUnits    		pinyinUnits head node index
 * @param pinyinUnitIndex		pinyinUint Index
 * @param qwertyPinyinUnitIndex	pinyinBaseUnit Index
 * @param baseData				base data for search.
 * @param searchBuffer			search keyword.
 * @param chineseKeyWord		save the Chinese keyword.
 * @return true if find,false otherwise.
 */
private static boolean findPinyinUnits(final List<PinyinUnit> pinyinUnits,int pinyinUnitIndex,int qwertyPinyinUnitIndex,final String baseData,StringBuffer searchBuffer,StringBuffer chineseKeyWord){
  if ((null == pinyinUnits) || (null == baseData) || (null == searchBuffer)|| (null == chineseKeyWord)) {
    return false;
  }
  String search=searchBuffer.toString();
  if (search.length() <= 0) {
    return true;
  }
  if (pinyinUnitIndex >= pinyinUnits.size()) {
    return false;
  }
  PinyinUnit pyUnit=pinyinUnits.get(pinyinUnitIndex);
  if (qwertyPinyinUnitIndex >= pyUnit.getPinyinBaseUnitIndex().size()) {
    return false;
  }
  PinyinBaseUnit pinyinBaseUnit=pyUnit.getPinyinBaseUnitIndex().get(qwertyPinyinUnitIndex);
  if (pyUnit.isPinyin()) {
    if (search.startsWith(String.valueOf(pinyinBaseUnit.getPinyin().charAt(0)))) {
      searchBuffer.delete(0,1);
      chineseKeyWord.append(baseData.charAt(pyUnit.getStartPosition()));
      boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex + 1,0,baseData,searchBuffer,chineseKeyWord);
      if (true == found) {
        return true;
      }
 else {
        searchBuffer.insert(0,pinyinBaseUnit.getPinyin().charAt(0));
        chineseKeyWord.deleteCharAt(chineseKeyWord.length() - 1);
      }
    }
    if (pinyinBaseUnit.getPinyin().startsWith(search)) {
      chineseKeyWord.append(baseData.charAt(pyUnit.getStartPosition()));
      searchBuffer.delete(0,searchBuffer.length());
      return true;
    }
 else     if (search.startsWith(pinyinBaseUnit.getPinyin())) {
      searchBuffer.delete(0,pinyinBaseUnit.getPinyin().length());
      chineseKeyWord.append(baseData.charAt(pyUnit.getStartPosition()));
      boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex + 1,0,baseData,searchBuffer,chineseKeyWord);
      if (true == found) {
        return true;
      }
 else {
        searchBuffer.insert(0,pinyinBaseUnit.getPinyin());
        chineseKeyWord.deleteCharAt(chineseKeyWord.length() - 1);
      }
    }
 else {
      boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex,qwertyPinyinUnitIndex + 1,baseData,searchBuffer,chineseKeyWord);
      if (found == true) {
        return true;
      }
    }
  }
 else {
    if (pinyinBaseUnit.getPinyin().startsWith(search)) {
      int startIndex=0;
      chineseKeyWord.append(baseData.substring(startIndex + pyUnit.getStartPosition(),startIndex + pyUnit.getStartPosition() + search.length()));
      searchBuffer.delete(0,searchBuffer.length());
      return true;
    }
 else     if (search.startsWith(pinyinBaseUnit.getPinyin())) {
      int startIndex=0;
      searchBuffer.delete(0,pinyinBaseUnit.getPinyin().length());
      chineseKeyWord.append(baseData.substring(startIndex + pyUnit.getStartPosition(),startIndex + pyUnit.getStartPosition() + pinyinBaseUnit.getPinyin().length()));
      boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex + 1,0,baseData,searchBuffer,chineseKeyWord);
      if (true == found) {
        return true;
      }
 else {
        searchBuffer.insert(0,pinyinBaseUnit.getPinyin());
        chineseKeyWord.delete(chineseKeyWord.length() - pinyinBaseUnit.getPinyin().length(),chineseKeyWord.length());
      }
    }
 else     if ((chineseKeyWord.length() <= 0)) {
      if (pinyinBaseUnit.getPinyin().contains(search)) {
        int index=pinyinBaseUnit.getPinyin().indexOf(search);
        chineseKeyWord.append(baseData.substring(index + pyUnit.getStartPosition(),index + pyUnit.getStartPosition() + search.length()));
        searchBuffer.delete(0,searchBuffer.length());
        return true;
      }
 else {
        int numLength=pinyinBaseUnit.getPinyin().length();
        for (int i=0; i < numLength; i++) {
          String subStr=pinyinBaseUnit.getPinyin().substring(i);
          if (search.startsWith(subStr)) {
            searchBuffer.delete(0,subStr.length());
            chineseKeyWord.append(baseData.substring(i + pyUnit.getStartPosition(),i + pyUnit.getStartPosition() + subStr.length()));
            boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex + 1,0,baseData,searchBuffer,chineseKeyWord);
            if (true == found) {
              return true;
            }
 else {
              searchBuffer.insert(0,pinyinBaseUnit.getPinyin().substring(i));
              chineseKeyWord.delete(chineseKeyWord.length() - subStr.length(),chineseKeyWord.length());
            }
          }
        }
        boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex,qwertyPinyinUnitIndex + 1,baseData,searchBuffer,chineseKeyWord);
        if (true == found) {
          return true;
        }
      }
    }
 else {
      boolean found=findPinyinUnits(pinyinUnits,pinyinUnitIndex,qwertyPinyinUnitIndex + 1,baseData,searchBuffer,chineseKeyWord);
      if (true == found) {
        return true;
      }
    }
  }
  return false;
}"
93756,"@SuppressLint(""String_Node_Str"") private List<Contacts> loadContacts(Context context){
  List<Contacts> kanjiStartContacts=new ArrayList<Contacts>();
  HashMap<String,Contacts> kanjiStartContactsHashMap=new HashMap<String,Contacts>();
  List<Contacts> nonKanjiStartContacts=new ArrayList<Contacts>();
  HashMap<String,Contacts> nonKanjiStartContactsHashMap=new HashMap<String,Contacts>();
  List<Contacts> contacts=new ArrayList<Contacts>();
  Contacts cs=null;
  Cursor cursor=null;
  String sortkey=null;
  long startLoadTime=System.currentTimeMillis();
  String[] projection=new String[]{ContactsContract.CommonDataKinds.Phone.CONTACT_ID,ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME,ContactsContract.CommonDataKinds.Phone.NUMBER};
  try {
    cursor=context.getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,projection,null,null,""String_Node_Str"");
    int idColumnIndex=cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.CONTACT_ID);
    int dispalyNameColumnIndex=cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME);
    int numberColumnIndex=cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER);
    while (cursor.moveToNext()) {
      String id=cursor.getString(idColumnIndex);
      String displayName=cursor.getString(dispalyNameColumnIndex);
      String phoneNumber=cursor.getString(numberColumnIndex);
      boolean kanjiStartContactsExist=kanjiStartContactsHashMap.containsKey(id);
      boolean nonKanjiStartContactsExist=nonKanjiStartContactsHashMap.containsKey(id);
      if (true == kanjiStartContactsExist) {
        cs=kanjiStartContactsHashMap.get(id);
        cs.addPhoneNumber(phoneNumber);
      }
 else       if (true == nonKanjiStartContactsExist) {
        cs=nonKanjiStartContactsHashMap.get(id);
        cs.addPhoneNumber(phoneNumber);
      }
 else {
        cs=new Contacts(id,displayName,phoneNumber);
        PinyinUtil.chineseStringToPinyinUnit(cs.getName(),cs.getNamePinyinUnits());
        sortkey=PinyinUtil.getSortKey(cs.getNamePinyinUnits()).toUpperCase();
        cs.setSortKey(praseSortKey(sortkey));
        boolean isKanji=PinyinUtil.isKanji(cs.getName().charAt(0));
        if (true == isKanji) {
          kanjiStartContactsHashMap.put(id,cs);
        }
 else {
          nonKanjiStartContactsHashMap.put(id,cs);
        }
      }
    }
  }
 catch (  Exception e) {
  }
 finally {
    if (null != cursor) {
      cursor.close();
      cursor=null;
    }
  }
  kanjiStartContacts.addAll(kanjiStartContactsHashMap.values());
  Collections.sort(kanjiStartContacts,Contacts.mAscComparator);
  nonKanjiStartContacts.addAll(nonKanjiStartContactsHashMap.values());
  Collections.sort(nonKanjiStartContacts,Contacts.mAscComparator);
  contacts.addAll(kanjiStartContacts);
  int lastIndex=0;
  boolean shouldBeAdd=false;
  for (int i=0; i < nonKanjiStartContacts.size(); i++) {
    String nonKanfirstLetter=PinyinUtil.getFirstLetter(nonKanjiStartContacts.get(i).getNamePinyinUnits());
    int j=0;
    for (j=0 + lastIndex; j < contacts.size(); j++) {
      String firstLetter=PinyinUtil.getFirstLetter(contacts.get(j).getNamePinyinUnits());
      lastIndex++;
      if (firstLetter.charAt(0) > nonKanfirstLetter.charAt(0)) {
        shouldBeAdd=true;
        break;
      }
 else {
        shouldBeAdd=false;
      }
    }
    if (true == shouldBeAdd) {
      contacts.add(j,nonKanjiStartContacts.get(i));
      shouldBeAdd=false;
    }
  }
  long endLoadTime=System.currentTimeMillis();
  Log.i(TAG,""String_Node_Str"" + (endLoadTime - startLoadTime) + ""String_Node_Str"");
  return contacts;
}","@SuppressLint(""String_Node_Str"") private List<Contacts> loadContacts(Context context){
  List<Contacts> kanjiStartContacts=new ArrayList<Contacts>();
  HashMap<String,Contacts> kanjiStartContactsHashMap=new HashMap<String,Contacts>();
  List<Contacts> nonKanjiStartContacts=new ArrayList<Contacts>();
  HashMap<String,Contacts> nonKanjiStartContactsHashMap=new HashMap<String,Contacts>();
  List<Contacts> contacts=new ArrayList<Contacts>();
  Contacts cs=null;
  Cursor cursor=null;
  String sortkey=null;
  long startLoadTime=System.currentTimeMillis();
  String[] projection=new String[]{ContactsContract.CommonDataKinds.Phone.CONTACT_ID,ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME,ContactsContract.CommonDataKinds.Phone.NUMBER};
  try {
    cursor=context.getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,projection,null,null,""String_Node_Str"");
    int idColumnIndex=cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.CONTACT_ID);
    int dispalyNameColumnIndex=cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME);
    int numberColumnIndex=cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER);
    while (cursor.moveToNext()) {
      String id=cursor.getString(idColumnIndex);
      String displayName=cursor.getString(dispalyNameColumnIndex);
      String phoneNumber=cursor.getString(numberColumnIndex);
      boolean kanjiStartContactsExist=kanjiStartContactsHashMap.containsKey(id);
      boolean nonKanjiStartContactsExist=nonKanjiStartContactsHashMap.containsKey(id);
      if (true == kanjiStartContactsExist) {
        cs=kanjiStartContactsHashMap.get(id);
        cs.addPhoneNumber(phoneNumber);
      }
 else       if (true == nonKanjiStartContactsExist) {
        cs=nonKanjiStartContactsHashMap.get(id);
        cs.addPhoneNumber(phoneNumber);
      }
 else {
        cs=new Contacts(id,displayName,phoneNumber);
        PinyinUtil.chineseStringToPinyinUnit(cs.getName(),cs.getNamePinyinUnits());
        sortkey=PinyinUtil.getSortKey(cs.getNamePinyinUnits()).toUpperCase();
        cs.setSortKey(praseSortKey(sortkey));
        boolean isKanji=PinyinUtil.isKanji(cs.getName().charAt(0));
        if (true == isKanji) {
          kanjiStartContactsHashMap.put(id,cs);
        }
 else {
          nonKanjiStartContactsHashMap.put(id,cs);
        }
      }
    }
  }
 catch (  Exception e) {
  }
 finally {
    if (null != cursor) {
      cursor.close();
      cursor=null;
    }
  }
  kanjiStartContacts.addAll(kanjiStartContactsHashMap.values());
  Collections.sort(kanjiStartContacts,Contacts.mAscComparator);
  nonKanjiStartContacts.addAll(nonKanjiStartContactsHashMap.values());
  Collections.sort(nonKanjiStartContacts,Contacts.mAscComparator);
  contacts.addAll(kanjiStartContacts);
  int lastIndex=0;
  boolean shouldBeAdd=false;
  for (int i=0; i < nonKanjiStartContacts.size(); i++) {
    String nonKanfirstLetter=PinyinUtil.getFirstLetter(nonKanjiStartContacts.get(i).getNamePinyinUnits());
    int j=0;
    for (j=0 + lastIndex; j < contacts.size(); j++) {
      String firstLetter=PinyinUtil.getFirstLetter(contacts.get(j).getNamePinyinUnits());
      lastIndex++;
      if (firstLetter.charAt(0) > nonKanfirstLetter.charAt(0)) {
        shouldBeAdd=true;
        break;
      }
 else {
        shouldBeAdd=false;
      }
    }
    if (lastIndex >= contacts.size()) {
      lastIndex++;
      shouldBeAdd=true;
    }
    if (true == shouldBeAdd) {
      contacts.add(j,nonKanjiStartContacts.get(i));
      shouldBeAdd=false;
    }
  }
  long endLoadTime=System.currentTimeMillis();
  Log.i(TAG,""String_Node_Str"" + (endLoadTime - startLoadTime) + ""String_Node_Str""+ contacts.size());
  return contacts;
}"
93757,"@Override public void onContactsLoadSuccess(){
  mContactsOperationView.contactsLoadSuccess();
  ContactsIndexHelper.getInstance().praseContacts(ContactsHelper.getInstance().getBaseContacts());
}","@Override public void onContactsLoadSuccess(){
  mContactsOperationView.contactsLoadSuccess();
  ContactsIndexHelper.getInstance().praseContacts(ContactsHelper.getInstance().getBaseContacts());
  ContactsIndexHelper.getInstance().showContactsInfo();
}"
93758,"private String getAlphabet(String str){
  if ((null == str) || (str.length() <= 0)) {
    return PINYIN_FIRST_LETTER_DEFAULT_VALUE;
  }
  String alphabet=null;
  char chr=str.charAt(0);
  if (chr >= 'A' && chr <= 'Z') {
    alphabet=String.valueOf(chr);
  }
 else   if (chr >= 'a' && chr <= 'z') {
    alphabet=String.valueOf((char)('A' + chr - 'a'));
  }
 else {
    alphabet=PINYIN_FIRST_LETTER_DEFAULT_VALUE;
  }
  return alphabet;
}","private String getAlphabet(String str){
  if ((null == str) || (str.length() <= 0)) {
    return String.valueOf(QuickAlphabeticBar.DEFAULT_INDEX_CHARACTER);
  }
  String alphabet=null;
  char chr=str.charAt(0);
  if (chr >= 'A' && chr <= 'Z') {
    alphabet=String.valueOf(chr);
  }
 else   if (chr >= 'a' && chr <= 'z') {
    alphabet=String.valueOf((char)('A' + chr - 'a'));
  }
 else {
    alphabet=String.valueOf(QuickAlphabeticBar.DEFAULT_INDEX_CHARACTER);
  }
  return alphabet;
}"
93759,"public void showContactsInfo(){
  if (null == mContactsIndexs) {
    return;
  }
  int contactsIndexsSize=mContactsIndexs.size();
  for (int i=0; i < contactsIndexsSize; i++) {
    Log.i(""String_Node_Str"",""String_Node_Str"" + mContactsIndexs.get(i).getIndexKey() + ""String_Node_Str"");
    int contactsCount=mContactsIndexs.get(i).getContacts().size();
    for (int j=0; j < contactsCount; j++) {
      mContactsIndexs.get(i).getContacts().get(j).showContacts();
    }
  }
}","public void showContactsInfo(){
  if (null == mContactsIndexs) {
    return;
  }
  int contactsIndexsSize=mContactsIndexs.size();
  for (int i=0; i < contactsIndexsSize; i++) {
    int contactsCount=mContactsIndexs.get(i).getContacts().size();
    for (int j=0; j < contactsCount; j++) {
      mContactsIndexs.get(i).getContacts().get(j).showContacts();
    }
  }
}"
93760,"@Override public void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  Adapter adapter=mContactsLv.getAdapter();
  if ((null != adapter) && adapter.getCount() > 0) {
    Contacts contacts=(Contacts)adapter.getItem(firstVisibleItem);
    char firstChar=contacts.getSortKey().charAt(0);
    mQuickAlphabeticBar.setCurrentSelectChar(firstChar);
  }
}","@Override public void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  Adapter adapter=mContactsLv.getAdapter();
  int currentIndex=0;
  if ((null != adapter) && adapter.getCount() > 0) {
    currentIndex=((firstVisibleItem + visibleItemCount) < totalItemCount) ? (firstVisibleItem) : (totalItemCount - 1);
    Contacts contacts=(Contacts)adapter.getItem(currentIndex);
    char currentSelectChar=contacts.getSortKey().charAt(0);
    mQuickAlphabeticBar.setCurrentSelectChar(currentSelectChar);
  }
}"
93761,"private void initListener(){
  mContactsLv.setOnItemClickListener(new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      Contacts contacts=ContactsHelper.getInstance().getSearchContacts().get(position);
      String uri=""String_Node_Str"" + contacts.getPhoneNumber();
      Intent intent=new Intent(Intent.ACTION_DIAL,Uri.parse(uri));
      mContext.startActivity(intent);
    }
  }
);
  mContactsLv.setOnScrollListener(new OnScrollListener(){
    @Override public void onScrollStateChanged(    AbsListView view,    int scrollState){
    }
    @Override public void onScroll(    AbsListView view,    int firstVisibleItem,    int visibleItemCount,    int totalItemCount){
      Adapter adapter=mContactsLv.getAdapter();
      if ((null != adapter) && adapter.getCount() > 0) {
        Contacts contacts=(Contacts)adapter.getItem(firstVisibleItem);
        char firstChar=contacts.getSortKey().charAt(0);
        mQuickAlphabeticBar.setCurrentSelectChar(firstChar);
      }
    }
  }
);
  mQuickAlphabeticBar.setSectionIndexer(mContactsAdapter);
  mQuickAlphabeticBar.setQuickAlphabeticLv(mContactsLv);
  mQuickAlphabeticBar.setSelectCharTv(mSelectCharTv);
}","private void initListener(){
  mContactsLv.setOnItemClickListener(new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      Contacts contacts=ContactsHelper.getInstance().getSearchContacts().get(position);
      String uri=""String_Node_Str"" + contacts.getPhoneNumber();
      Intent intent=new Intent(Intent.ACTION_DIAL,Uri.parse(uri));
      mContext.startActivity(intent);
    }
  }
);
  mContactsLv.setOnScrollListener(new OnScrollListener(){
    @Override public void onScrollStateChanged(    AbsListView view,    int scrollState){
    }
    @Override public void onScroll(    AbsListView view,    int firstVisibleItem,    int visibleItemCount,    int totalItemCount){
      Adapter adapter=mContactsLv.getAdapter();
      int currentIndex=0;
      if ((null != adapter) && adapter.getCount() > 0) {
        currentIndex=((firstVisibleItem + visibleItemCount) < totalItemCount) ? (firstVisibleItem) : (totalItemCount - 1);
        Contacts contacts=(Contacts)adapter.getItem(currentIndex);
        char currentSelectChar=contacts.getSortKey().charAt(0);
        mQuickAlphabeticBar.setCurrentSelectChar(currentSelectChar);
      }
    }
  }
);
  mQuickAlphabeticBar.setSectionIndexer(mContactsAdapter);
  mQuickAlphabeticBar.setQuickAlphabeticLv(mContactsLv);
  mQuickAlphabeticBar.setSelectCharTv(mSelectCharTv);
}"
93762,"/** 
 * Preset based on Nexus 4 camera recording with 720p quality. This preset is ensured to work on any Android &gt;=4.3 devices by Android CTS (if codec is available). <p/> Note: audio transcoding is experimental feature.
 * @param bitrate       Preferred bitrate for video encoding.
 * @param audioBitrate  Preferred bitrate for audio encoding.
 * @param audioChannels Output audio channels.
 */
public static MediaFormatStrategy createAndroid720pStrategy(int bitrate,int audioBitrate,int audioChannels){
  return new Android720pFormatStrategy(bitrate,audioBitrate,audioChannels);
}","/** 
 * Preset based on Nexus 4 camera recording with 720p quality. This preset is ensured to work on any Android &gt;=4.3 devices by Android CTS (if codec is available). <br> Note: audio transcoding is experimental feature.
 * @param bitrate       Preferred bitrate for video encoding.
 * @param audioBitrate  Preferred bitrate for audio encoding.
 * @param audioChannels Output audio channels.
 */
public static MediaFormatStrategy createAndroid720pStrategy(int bitrate,int audioBitrate,int audioChannels){
  return new Android720pFormatStrategy(bitrate,audioBitrate,audioChannels);
}"
93763,"/** 
 * Preset based on Nexus 4 camera recording with 720p quality. This preset is ensured to work on any Android >=4.3 devices by Android CTS (if codec is available).
 * @param bitRate Preferred bit rate for encoding.
 */
public static MediaFormatStrategy createAndroid720pStrategy(int bitRate){
  return new Android720pFormatStrategy(bitRate);
}","/** 
 * Preset based on Nexus 4 camera recording with 720p quality. This preset is ensured to work on any Android &gt;=4.3 devices by Android CTS (if codec is available).
 * @param bitRate Preferred bit rate for encoding.
 */
public static MediaFormatStrategy createAndroid720pStrategy(int bitRate){
  return new Android720pFormatStrategy(bitRate);
}"
93764,"private void apkChoose(){
  final FileDialog fileDialog=new FileDialog(this,""String_Node_Str"",FileDialog.LOAD);
  fileDialog.setFile(""String_Node_Str"");
  fileDialog.setAlwaysOnTop(true);
  fileDialog.setVisible(true);
  if (fileDialog.getFile() != null) {
    String apkPath=new File(fileDialog.getFile()).getAbsolutePath();
    if (apkPath.toLowerCase().endsWith(""String_Node_Str"")) {
      this.apkField.setBackground(SystemColor.GREEN);
      this.apkField.setText(apkPath);
      contSelectPanel.setVisible(true);
      this.pack();
      this.isValidApkToPatch=true;
      updateContainerBoxes(1);
    }
 else {
      this.apkField.setBackground(SystemColor.control);
      this.apkField.setText(""String_Node_Str"");
      this.isValidApkToPatch=false;
    }
  }
}","private void apkChoose(){
  final FileDialog fileDialog=new FileDialog(this,""String_Node_Str"",FileDialog.LOAD);
  fileDialog.setAlwaysOnTop(true);
  fileDialog.setVisible(true);
  if (fileDialog.getDirectory() != null && fileDialog.getFiles() != null && fileDialog.getFiles().length == 1) {
    String apkPath=fileDialog.getFiles()[0].getAbsolutePath();
    if (apkPath.toLowerCase().endsWith(""String_Node_Str"")) {
      this.apkField.setBackground(SystemColor.GREEN);
      this.apkField.setText(apkPath);
      contSelectPanel.setVisible(true);
      this.pack();
      this.isValidApkToPatch=true;
      updateContainerBoxes(1);
    }
 else {
      this.apkField.setBackground(SystemColor.control);
      this.apkField.setText(""String_Node_Str"");
      this.isValidApkToPatch=false;
    }
  }
}"
93765,"final String getPackageNameWithAssociatedCertificate(String packageName){
  String currentPackageName=packageName;
  if (!packageNameToHasCertificateMap.containsKey(currentPackageName))   return ""String_Node_Str"";
  while (!packageNameToHasCertificateMap.get(currentPackageName))   currentPackageName=getUpALevel(currentPackageName);
  Log.d(TAG_PACKAGE_NAME_TRIE,packageName + ""String_Node_Str"" + packageName+ ""String_Node_Str"");
  return currentPackageName;
}","final String getPackageNameWithAssociatedCertificate(String packageName){
  String currentPackageName=packageName;
  if (!packageNameToHasCertificateMap.containsKey(currentPackageName))   return ""String_Node_Str"";
  while (!packageNameToHasCertificateMap.get(currentPackageName))   currentPackageName=getUpALevel(currentPackageName);
  Log.d(TAG_PACKAGE_NAME_TRIE,currentPackageName + ""String_Node_Str"" + packageName+ ""String_Node_Str"");
  return currentPackageName;
}"
93766,"public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap.isEmpty())   return null;
  if (hasBeenWipedOut)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath;
synchronized (packageNameToContainerPathMap) {
    containerPath=packageNameToContainerPathMap.get(packageName);
  }
  if (containerPath == null)   return null;
  if (performLazyEvaluation) {
    boolean alreadyVerifiedPackageName;
synchronized (lazyAlreadyVerifiedPackageNameSet) {
      alreadyVerifiedPackageName=lazyAlreadyVerifiedPackageNameSet.contains(packageName);
    }
    if (alreadyVerifiedPackageName) {
      return mDexClassLoader.loadClass(className);
    }
 else {
      String rootPackageNameWithCertificate=mPackageNameTrie.getPackageNameWithAssociatedCertificate(packageName);
      X509Certificate verifiedCertificate=null;
      if (!rootPackageNameWithCertificate.isEmpty()) {
        verifiedCertificate=importCertificateFromPackageName(packageName);
      }
      if (verifiedCertificate != null) {
        boolean signatureCheckIsSuccessful=verifyContainerSignatureAgainstCertificate(containerPath,verifiedCertificate);
        if (signatureCheckIsSuccessful) {
synchronized (lazyAlreadyVerifiedPackageNameSet) {
            Iterator<String> packageNamesIterator=packageNameToContainerPathMap.keySet().iterator();
            while (packageNamesIterator.hasNext()) {
              String currentPackageName=packageNamesIterator.next();
              if (packageNameToContainerPathMap.get(currentPackageName).equals(containerPath)) {
                lazyAlreadyVerifiedPackageNameSet.add(currentPackageName);
              }
            }
          }
          return mDexClassLoader.loadClass(className);
        }
        File containerToRemove=new File(containerPath);
        if (!containerToRemove.delete())         Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + containerPath);
synchronized (packageNameToContainerPathMap) {
          Iterator<String> packageNamesIterator=packageNameToContainerPathMap.keySet().iterator();
          while (packageNamesIterator.hasNext()) {
            String currentPackageName=packageNamesIterator.next();
            if (packageNameToContainerPathMap.get(currentPackageName).equals(containerPath))             packageNamesIterator.remove();
          }
        }
        return null;
      }
      return null;
    }
  }
  return mDexClassLoader.loadClass(className);
}","public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap.isEmpty())   return null;
  if (hasBeenWipedOut)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath;
synchronized (packageNameToContainerPathMap) {
    containerPath=packageNameToContainerPathMap.get(packageName);
  }
  if (containerPath == null)   return null;
  if (performLazyEvaluation) {
    boolean alreadyVerifiedPackageName;
synchronized (lazyAlreadyVerifiedPackageNameSet) {
      alreadyVerifiedPackageName=lazyAlreadyVerifiedPackageNameSet.contains(packageName);
    }
    if (alreadyVerifiedPackageName) {
      return mDexClassLoader.loadClass(className);
    }
 else {
      String rootPackageNameWithCertificate=mPackageNameTrie.getPackageNameWithAssociatedCertificate(packageName);
      X509Certificate verifiedCertificate=null;
      if (!rootPackageNameWithCertificate.isEmpty()) {
        verifiedCertificate=importCertificateFromPackageName(rootPackageNameWithCertificate);
      }
      if (verifiedCertificate != null) {
        boolean signatureCheckIsSuccessful=verifyContainerSignatureAgainstCertificate(containerPath,verifiedCertificate);
        if (signatureCheckIsSuccessful) {
synchronized (lazyAlreadyVerifiedPackageNameSet) {
            Iterator<String> packageNamesIterator=packageNameToContainerPathMap.keySet().iterator();
            while (packageNamesIterator.hasNext()) {
              String currentPackageName=packageNamesIterator.next();
              if (packageNameToContainerPathMap.get(currentPackageName).equals(containerPath)) {
                lazyAlreadyVerifiedPackageNameSet.add(currentPackageName);
              }
            }
          }
          return mDexClassLoader.loadClass(className);
        }
        File containerToRemove=new File(containerPath);
        if (!containerToRemove.delete())         Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + containerPath);
synchronized (packageNameToContainerPathMap) {
          Iterator<String> packageNamesIterator=packageNameToContainerPathMap.keySet().iterator();
          while (packageNamesIterator.hasNext()) {
            String currentPackageName=packageNamesIterator.next();
            if (packageNameToContainerPathMap.get(currentPackageName).equals(containerPath))             packageNamesIterator.remove();
          }
        }
        return null;
      }
      return null;
    }
  }
  return mDexClassLoader.loadClass(className);
}"
93767,"private void verifyAllContainersSignature(){
  Map<String,Boolean> alreadyCheckedContainerMap=new HashMap<String,Boolean>();
  Iterator<String> packageNamesIterator=packageNameToContainerPathMap.keySet().iterator();
  while (packageNamesIterator.hasNext()) {
    String currentPackageName=packageNamesIterator.next();
    String containerPath=packageNameToContainerPathMap.get(currentPackageName);
    if (alreadyCheckedContainerMap.containsKey(containerPath)) {
      if (!alreadyCheckedContainerMap.get(containerPath))       packageNamesIterator.remove();
    }
 else {
      String rootPackageNameWithCertificate=mPackageNameTrie.getPackageNameWithAssociatedCertificate(currentPackageName);
      X509Certificate verifiedCertificate=null;
      if (!rootPackageNameWithCertificate.isEmpty()) {
        verifiedCertificate=importCertificateFromPackageName(currentPackageName);
      }
      boolean signatureCheckIsSuccessful=true;
      if (verifiedCertificate != null) {
        signatureCheckIsSuccessful=verifyContainerSignatureAgainstCertificate(containerPath,verifiedCertificate);
        if (signatureCheckIsSuccessful) {
          alreadyCheckedContainerMap.put(containerPath,Boolean.valueOf(true));
        }
      }
      if ((verifiedCertificate == null) || ((verifiedCertificate != null) && (signatureCheckIsSuccessful == false))) {
        alreadyCheckedContainerMap.put(containerPath,Boolean.valueOf(false));
        File containerToRemove=new File(containerPath);
        if (!containerToRemove.delete())         Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + containerPath);
        packageNamesIterator.remove();
      }
    }
  }
}","private void verifyAllContainersSignature(){
  Map<String,Boolean> alreadyCheckedContainerMap=new HashMap<String,Boolean>();
  Iterator<String> packageNamesIterator=packageNameToContainerPathMap.keySet().iterator();
  while (packageNamesIterator.hasNext()) {
    String currentPackageName=packageNamesIterator.next();
    String containerPath=packageNameToContainerPathMap.get(currentPackageName);
    if (alreadyCheckedContainerMap.containsKey(containerPath)) {
      if (!alreadyCheckedContainerMap.get(containerPath))       packageNamesIterator.remove();
    }
 else {
      String rootPackageNameWithCertificate=mPackageNameTrie.getPackageNameWithAssociatedCertificate(currentPackageName);
      X509Certificate verifiedCertificate=null;
      if (!rootPackageNameWithCertificate.isEmpty()) {
        verifiedCertificate=importCertificateFromPackageName(rootPackageNameWithCertificate);
      }
      boolean signatureCheckIsSuccessful=true;
      if (verifiedCertificate != null) {
        signatureCheckIsSuccessful=verifyContainerSignatureAgainstCertificate(containerPath,verifiedCertificate);
        if (signatureCheckIsSuccessful) {
          alreadyCheckedContainerMap.put(containerPath,Boolean.valueOf(true));
        }
      }
      if ((verifiedCertificate == null) || ((verifiedCertificate != null) && (signatureCheckIsSuccessful == false))) {
        alreadyCheckedContainerMap.put(containerPath,Boolean.valueOf(false));
        File containerToRemove=new File(containerPath);
        if (!containerToRemove.delete())         Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + containerPath);
        packageNamesIterator.remove();
      }
    }
  }
}"
93768,"private X509Certificate importCertificateFromAppPrivateDir(String packageName){
  File[] certMatchingFiles=certificateFolder.listFiles(new CertFileFilter(packageName));
  X509Certificate verifiedCertificate=null;
  if (certMatchingFiles != null && certMatchingFiles.length != 0) {
    InputStream inStream=null;
    try {
      inStream=new FileInputStream(certMatchingFiles[0]);
      CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"");
      verifiedCertificate=(X509Certificate)cf.generateCertificate(inStream);
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    CertificateException e) {
      e.printStackTrace();
    }
 finally {
      if (inStream != null) {
        try {
          inStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    if (verifiedCertificate != null) {
      try {
        verifiedCertificate.checkValidity();
        if (verifiedCertificate.getKeyUsage() != null) {
          int keyCertSignIndex=5;
          if (!verifiedCertificate.getKeyUsage()[keyCertSignIndex])           throw new CertificateExpiredException(""String_Node_Str"");
          Log.i(TAG_SECURE_DEX_CLASS_LOADER,verifiedCertificate.getKeyUsage().toString());
        }
        String androidDebugModeDN=""String_Node_Str"";
        X500Principal androidDebugModePrincipal=new X500Principal(androidDebugModeDN);
        if (verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) || verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal))         throw new CertificateExpiredException(""String_Node_Str"");
      }
 catch (      CertificateExpiredException|CertificateNotYetValidException e) {
        verifiedCertificate=null;
        String certFileToErase=certMatchingFiles[0].getName();
        if (certMatchingFiles[0].delete()) {
          Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
 else {
          Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
      }
    }
  }
  return verifiedCertificate;
}","private X509Certificate importCertificateFromAppPrivateDir(String packageName){
  File[] certMatchingFiles=certificateFolder.listFiles(new CertFileFilter(packageName));
  X509Certificate verifiedCertificate=null;
  if (certMatchingFiles != null && certMatchingFiles.length != 0) {
    InputStream inStream=null;
    try {
      inStream=new FileInputStream(certMatchingFiles[0]);
      CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"");
      verifiedCertificate=(X509Certificate)cf.generateCertificate(inStream);
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    CertificateException e) {
      e.printStackTrace();
    }
 finally {
      if (inStream != null) {
        try {
          inStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    if (verifiedCertificate != null) {
      try {
        verifiedCertificate.checkValidity();
        if (verifiedCertificate.getKeyUsage() != null) {
          int keyCertSignIndex=5;
          if (verifiedCertificate.getKeyUsage()[keyCertSignIndex])           throw new CertificateExpiredException(""String_Node_Str"");
          Log.i(TAG_SECURE_DEX_CLASS_LOADER,verifiedCertificate.getKeyUsage().toString());
        }
        String androidDebugModeDN=""String_Node_Str"";
        X500Principal androidDebugModePrincipal=new X500Principal(androidDebugModeDN);
        if (verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) || verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal))         throw new CertificateExpiredException(""String_Node_Str"");
      }
 catch (      CertificateExpiredException|CertificateNotYetValidException e) {
        verifiedCertificate=null;
        String certFileToErase=certMatchingFiles[0].getName();
        if (certMatchingFiles[0].delete()) {
          Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
 else {
          Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
      }
    }
  }
  return verifiedCertificate;
}"
93769,"@Override public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap == null)   return null;
  if (hasBeenWipedOut)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath=packageNameToContainerPathMap.get(packageName);
  if (containerPath == null)   return null;
  X509Certificate verifiedCertificate;
  verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
  if (verifiedCertificate == null) {
    boolean isCertificateDownloadSuccessful=downloadCertificateRemotelyViaHttps(packageName);
    if (isCertificateDownloadSuccessful) {
      verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
    }
  }
  if (verifiedCertificate != null) {
    int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
    String extension=containerPath.substring(extensionIndex);
    boolean signatureCheckIsSuccessful=false;
    if (extension.equals(""String_Node_Str"")) {
      try {
        Signature mSignature=Signature.getInstance(verifiedCertificate.getSigAlgName());
        mSignature.initVerify(verifiedCertificate);
        FileInputStream containerFIS=null;
        BufferedInputStream containerBufIn=null;
        try {
          containerFIS=new FileInputStream(containerPath);
          containerBufIn=new BufferedInputStream(containerFIS);
          byte[] buffer=new byte[1024];
          int len;
          while (containerBufIn.available() != 0) {
            len=containerBufIn.read(buffer);
            mSignature.update(buffer,0,len);
          }
          ;
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
 finally {
          if (containerBufIn != null) {
            try {
              containerBufIn.close();
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
        android.content.pm.Signature apkSignature=mPackageManager.getPackageArchiveInfo(containerPath,PackageManager.GET_SIGNATURES).signatures[0];
        signatureCheckIsSuccessful=mSignature.verify(apkSignature.toByteArray());
      }
 catch (      NoSuchAlgorithmException e) {
        e.printStackTrace();
      }
catch (      InvalidKeyException e) {
        e.printStackTrace();
      }
catch (      SignatureException e) {
        e.printStackTrace();
      }
    }
 else {
      if (extension.equals(""String_Node_Str"")) {
        JarFile jarContainerToVerify=null;
        try {
          jarContainerToVerify=new JarFile(containerPath);
          verifyJARContainer(jarContainerToVerify,verifiedCertificate);
          signatureCheckIsSuccessful=true;
        }
 catch (        IOException e) {
          signatureCheckIsSuccessful=false;
        }
 finally {
          if (jarContainerToVerify != null)           try {
            jarContainerToVerify.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
    }
    if (signatureCheckIsSuccessful) {
      return super.loadClass(className);
    }
    File containerToRemove=new File(containerPath);
    containerToRemove.delete();
    packageNameToContainerPathMap.remove(packageName);
    return null;
  }
  return null;
}","@Override public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap == null)   return null;
  if (hasBeenWipedOut)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath=packageNameToContainerPathMap.get(packageName);
  if (containerPath == null)   return null;
  X509Certificate verifiedCertificate;
  verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
  if (verifiedCertificate == null) {
    boolean isCertificateDownloadSuccessful=downloadCertificateRemotelyViaHttps(packageName);
    if (isCertificateDownloadSuccessful) {
      verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
    }
  }
  if (verifiedCertificate != null) {
    int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
    String extension=containerPath.substring(extensionIndex);
    boolean signatureCheckIsSuccessful=false;
    if (extension.equals(""String_Node_Str"")) {
      try {
        Signature mSignature=Signature.getInstance(verifiedCertificate.getSigAlgName());
        mSignature.initVerify(verifiedCertificate);
        FileInputStream containerFIS=null;
        BufferedInputStream containerBufIn=null;
        try {
          containerFIS=new FileInputStream(containerPath);
          containerBufIn=new BufferedInputStream(containerFIS);
          byte[] buffer=new byte[1024];
          int len;
          while (containerBufIn.available() != 0) {
            len=containerBufIn.read(buffer);
            mSignature.update(buffer,0,len);
          }
          ;
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
 finally {
          if (containerBufIn != null) {
            try {
              containerBufIn.close();
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
        PackageInfo mPackageSignatureInfo=mPackageManager.getPackageArchiveInfo(containerPath,PackageManager.GET_SIGNATURES);
        android.content.pm.Signature apkSignature=mPackageSignatureInfo.signatures[0];
        signatureCheckIsSuccessful=mSignature.verify(apkSignature.toByteArray());
      }
 catch (      NoSuchAlgorithmException e) {
        e.printStackTrace();
      }
catch (      InvalidKeyException e) {
        e.printStackTrace();
      }
catch (      SignatureException e) {
        e.printStackTrace();
      }
    }
 else {
      if (extension.equals(""String_Node_Str"")) {
        JarFile jarContainerToVerify=null;
        try {
          jarContainerToVerify=new JarFile(containerPath);
          verifyJARContainer(jarContainerToVerify,verifiedCertificate);
          signatureCheckIsSuccessful=true;
        }
 catch (        IOException e) {
          signatureCheckIsSuccessful=false;
        }
 finally {
          if (jarContainerToVerify != null)           try {
            jarContainerToVerify.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
    }
    if (signatureCheckIsSuccessful) {
      return super.loadClass(className);
    }
    File containerToRemove=new File(containerPath);
    containerToRemove.delete();
    packageNameToContainerPathMap.remove(packageName);
    return null;
  }
  return null;
}"
93770,"@Override public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap == null)   return null;
  if (hasBeenWipedOut)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath=packageNameToContainerPathMap.get(packageName);
  if (containerPath == null)   return null;
  X509Certificate verifiedCertificate;
  verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
  if (verifiedCertificate == null) {
    boolean isCertificateDownloadSuccessful=downloadCertificateRemotelyViaHttps(packageName);
    if (isCertificateDownloadSuccessful) {
      verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
    }
  }
  if (verifiedCertificate != null) {
    int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
    String extension=containerPath.substring(extensionIndex);
    boolean signatureCheckIsSuccessful=false;
    if (extension.equals(""String_Node_Str"")) {
      Signature[] signatures=mPackageManager.getPackageArchiveInfo(containerPath,PackageManager.GET_SIGNATURES).signatures;
      if (signatures != null) {
        for (        Signature sign : signatures) {
          if (sign != null) {
            X509Certificate certFromSign=null;
            InputStream inStream=null;
            try {
              inStream=new ByteArrayInputStream(sign.toByteArray());
              CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"");
              certFromSign=(X509Certificate)cf.generateCertificate(inStream);
              certFromSign.checkValidity();
              if (certFromSign.equals(verifiedCertificate))               signatureCheckIsSuccessful=true;
            }
 catch (            CertificateException e) {
            }
 finally {
              if (inStream != null) {
                try {
                  inStream.close();
                }
 catch (                IOException e) {
                  e.printStackTrace();
                }
              }
            }
          }
        }
      }
    }
    if (extension.equals(""String_Node_Str"") || (extension.equals(""String_Node_Str"") && signatureCheckIsSuccessful == true)) {
      JarFile containerToVerify=null;
      try {
        containerToVerify=new JarFile(containerPath);
        verifyJARContainer(containerToVerify,verifiedCertificate);
        signatureCheckIsSuccessful=true;
      }
 catch (      Exception e) {
        signatureCheckIsSuccessful=false;
      }
 finally {
        if (containerToVerify != null)         try {
          containerToVerify.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    if (signatureCheckIsSuccessful) {
      return super.loadClass(className);
    }
    File containerToRemove=new File(containerPath);
    if (!containerToRemove.delete())     Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + containerPath);
    packageNameToContainerPathMap.remove(packageName);
    return null;
  }
  return null;
}","public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap == null)   return null;
  if (hasBeenWipedOut)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath=packageNameToContainerPathMap.get(packageName);
  if (containerPath == null)   return null;
  X509Certificate verifiedCertificate;
  verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
  if (verifiedCertificate == null) {
    boolean isCertificateDownloadSuccessful=downloadCertificateRemotelyViaHttps(packageName);
    if (isCertificateDownloadSuccessful) {
      verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
    }
  }
  if (verifiedCertificate != null) {
    int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
    String extension=containerPath.substring(extensionIndex);
    boolean signatureCheckIsSuccessful=false;
    if (extension.equals(""String_Node_Str"")) {
      Signature[] signatures=mPackageManager.getPackageArchiveInfo(containerPath,PackageManager.GET_SIGNATURES).signatures;
      if (signatures != null) {
        for (        Signature sign : signatures) {
          if (sign != null) {
            X509Certificate certFromSign=null;
            InputStream inStream=null;
            try {
              inStream=new ByteArrayInputStream(sign.toByteArray());
              CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"");
              certFromSign=(X509Certificate)cf.generateCertificate(inStream);
              certFromSign.checkValidity();
              if (certFromSign.equals(verifiedCertificate))               signatureCheckIsSuccessful=true;
            }
 catch (            CertificateException e) {
            }
 finally {
              if (inStream != null) {
                try {
                  inStream.close();
                }
 catch (                IOException e) {
                  e.printStackTrace();
                }
              }
            }
          }
        }
      }
    }
    if (extension.equals(""String_Node_Str"") || (extension.equals(""String_Node_Str"") && signatureCheckIsSuccessful == true)) {
      JarFile containerToVerify=null;
      try {
        containerToVerify=new JarFile(containerPath);
        verifyJARContainer(containerToVerify,verifiedCertificate);
        signatureCheckIsSuccessful=true;
      }
 catch (      Exception e) {
        signatureCheckIsSuccessful=false;
      }
 finally {
        if (containerToVerify != null)         try {
          containerToVerify.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    if (signatureCheckIsSuccessful) {
      return mDexClassLoader.loadClass(className);
    }
    File containerToRemove=new File(containerPath);
    if (!containerToRemove.delete())     Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + containerPath);
    packageNameToContainerPathMap.remove(packageName);
    return null;
  }
  return null;
}"
93771,"SecureDexClassLoader(String dexPath,String optimizedDirectory,String libraryPath,ClassLoader parent,ContextWrapper parentContextWrapper){
  super(dexPath,optimizedDirectory,libraryPath,parent);
  certificateFolder=parentContextWrapper.getDir(CERTIFICATE_DIR,ContextWrapper.MODE_PRIVATE);
  resDownloadFolder=parentContextWrapper.getDir(SecureLoaderFactory.RES_DOWNLOAD_DIR,ContextWrapper.MODE_PRIVATE);
  mPackageManager=parentContextWrapper.getPackageManager();
  mFileDownloader=new FileDownloader(parentContextWrapper);
  hasBeenWipedOut=false;
  packageNameToCertificateMap=null;
  packageNameToContainerPathMap=new HashMap<String,String>();
  String[] pathStrings=dexPath.split(Pattern.quote(File.pathSeparator));
  for (  String currentPath : pathStrings) {
    String packageName=getPackageNameFromContainerPath(currentPath);
    if (packageName != null) {
      String previousPath=packageNameToContainerPathMap.put(packageName,currentPath);
      if (previousPath != null) {
        Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + packageName + ""String_Node_Str""+ previousPath+ ""String_Node_Str""+ currentPath+ ""String_Node_Str"");
      }
    }
  }
}","SecureDexClassLoader(String dexPath,String optimizedDirectory,String libraryPath,ClassLoader parent,ContextWrapper parentContextWrapper){
  mDexClassLoader=new DexClassLoader(dexPath,optimizedDirectory,libraryPath,parent);
  certificateFolder=parentContextWrapper.getDir(CERTIFICATE_DIR,ContextWrapper.MODE_PRIVATE);
  resDownloadFolder=parentContextWrapper.getDir(SecureLoaderFactory.RES_DOWNLOAD_DIR,ContextWrapper.MODE_PRIVATE);
  mPackageManager=parentContextWrapper.getPackageManager();
  mFileDownloader=new FileDownloader(parentContextWrapper);
  hasBeenWipedOut=false;
  packageNameToCertificateMap=null;
  packageNameToContainerPathMap=new HashMap<String,String>();
  String[] pathStrings=dexPath.split(Pattern.quote(File.pathSeparator));
  for (  String currentPath : pathStrings) {
    String packageName=getPackageNameFromContainerPath(currentPath);
    if (packageName != null) {
      String previousPath=packageNameToContainerPathMap.put(packageName,currentPath);
      if (previousPath != null) {
        Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + packageName + ""String_Node_Str""+ previousPath+ ""String_Node_Str""+ currentPath+ ""String_Node_Str"");
      }
    }
  }
}"
93772,"private X509Certificate importCertificateFromAppPrivateDir(String packageName){
  File[] certMatchingFiles=certificateFolder.listFiles(new CertFileFilter(packageName));
  X509Certificate verifiedCertificate=null;
  if (certMatchingFiles != null && certMatchingFiles.length != 0) {
    InputStream inStream=null;
    try {
      inStream=new FileInputStream(certMatchingFiles[0]);
      CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"");
      verifiedCertificate=(X509Certificate)cf.generateCertificate(inStream);
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    CertificateException e) {
      e.printStackTrace();
    }
 finally {
      if (inStream != null) {
        try {
          inStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    if (verifiedCertificate != null) {
      try {
        verifiedCertificate.checkValidity();
        if (verifiedCertificate.getKeyUsage() != null) {
          int keyCertSignIndex=5;
          if (verifiedCertificate.getKeyUsage()[keyCertSignIndex])           throw new CertificateExpiredException(""String_Node_Str"");
          Log.i(TAG_SECURE_DEX_CLASS_LOADER,verifiedCertificate.getKeyUsage().toString());
        }
        String androidDebugModeDN=""String_Node_Str"";
        X500Principal androidDebugModePrincipal=new X500Principal(androidDebugModeDN);
        if (verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) || verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal))         throw new CertificateExpiredException(""String_Node_Str"");
      }
 catch (      CertificateExpiredException|CertificateNotYetValidException e) {
        verifiedCertificate=null;
        String certFileToErase=certMatchingFiles[0].getName();
        if (certMatchingFiles[0].delete()) {
          Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
 else {
          Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
      }
    }
  }
  return verifiedCertificate;
}","private X509Certificate importCertificateFromAppPrivateDir(String packageName){
  File[] certMatchingFiles=certificateFolder.listFiles(new CertFileFilter(packageName));
  X509Certificate verifiedCertificate=null;
  if (certMatchingFiles != null && certMatchingFiles.length != 0) {
    InputStream inStream=null;
    try {
      inStream=new FileInputStream(certMatchingFiles[0]);
      CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"");
      verifiedCertificate=(X509Certificate)cf.generateCertificate(inStream);
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    CertificateException e) {
      e.printStackTrace();
    }
 finally {
      if (inStream != null) {
        try {
          inStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    if (verifiedCertificate != null) {
      try {
        verifiedCertificate.checkValidity();
        if (verifiedCertificate.getKeyUsage() != null) {
          int keyCertSignIndex=5;
          if (verifiedCertificate.getKeyUsage()[keyCertSignIndex])           throw new CertificateExpiredException(""String_Node_Str"");
          Log.d(TAG_SECURE_DEX_CLASS_LOADER,verifiedCertificate.getKeyUsage().toString());
        }
        String androidDebugModeDN=""String_Node_Str"";
        X500Principal androidDebugModePrincipal=new X500Principal(androidDebugModeDN);
        if (verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) || verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal))         throw new CertificateExpiredException(""String_Node_Str"");
      }
 catch (      CertificateExpiredException|CertificateNotYetValidException e) {
        verifiedCertificate=null;
        String certFileToErase=certMatchingFiles[0].getName();
        if (certMatchingFiles[0].delete()) {
          Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
 else {
          Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
      }
    }
  }
  return verifiedCertificate;
}"
93773,"@Override public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap == null)   return null;
  if (hasBeenWipedOut)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath=packageNameToContainerPathMap.get(packageName);
  if (containerPath == null)   return null;
  X509Certificate verifiedCertificate;
  verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
  if (verifiedCertificate == null) {
    boolean isCertificateDownloadSuccessful=downloadCertificateRemotelyViaHttps(packageName);
    if (isCertificateDownloadSuccessful) {
      verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
    }
  }
  if (verifiedCertificate != null) {
    int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
    String extension=containerPath.substring(extensionIndex);
    boolean signatureCheckIsSuccessful=false;
    if (extension.equals(""String_Node_Str"")) {
      Signature[] signatures=mPackageManager.getPackageArchiveInfo(containerPath,PackageManager.GET_SIGNATURES).signatures;
      if (signatures != null) {
        for (        Signature sign : signatures) {
          if (sign != null) {
            X509Certificate certFromSign=null;
            InputStream inStream=null;
            try {
              inStream=new ByteArrayInputStream(sign.toByteArray());
              CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"");
              certFromSign=(X509Certificate)cf.generateCertificate(inStream);
              certFromSign.checkValidity();
              if (certFromSign.getSubjectDN().equals(verifiedCertificate.getSubjectDN()) && certFromSign.getIssuerDN().equals(verifiedCertificate.getIssuerDN())) {
                if (certFromSign.getPublicKey().equals(verifiedCertificate.getPublicKey()))                 signatureCheckIsSuccessful=true;
              }
            }
 catch (            CertificateException e) {
            }
 finally {
              if (inStream != null) {
                try {
                  inStream.close();
                }
 catch (                IOException e) {
                  e.printStackTrace();
                }
              }
            }
          }
        }
      }
    }
    if (extension.equals(""String_Node_Str"") || (extension.equals(""String_Node_Str"") && signatureCheckIsSuccessful == true)) {
      JarFile containerToVerify=null;
      try {
        containerToVerify=new JarFile(containerPath);
        verifyJARContainer(containerToVerify,verifiedCertificate);
        signatureCheckIsSuccessful=true;
      }
 catch (      Exception e) {
        signatureCheckIsSuccessful=false;
      }
 finally {
        if (containerToVerify != null)         try {
          containerToVerify.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    if (signatureCheckIsSuccessful) {
      return super.loadClass(className);
    }
    File containerToRemove=new File(containerPath);
    containerToRemove.delete();
    packageNameToContainerPathMap.remove(packageName);
    return null;
  }
  return null;
}","@Override public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap == null)   return null;
  if (hasBeenWipedOut)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath=packageNameToContainerPathMap.get(packageName);
  if (containerPath == null)   return null;
  X509Certificate verifiedCertificate;
  verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
  if (verifiedCertificate == null) {
    boolean isCertificateDownloadSuccessful=downloadCertificateRemotelyViaHttps(packageName);
    if (isCertificateDownloadSuccessful) {
      verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
    }
  }
  if (verifiedCertificate != null) {
    int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
    String extension=containerPath.substring(extensionIndex);
    boolean signatureCheckIsSuccessful=false;
    if (extension.equals(""String_Node_Str"")) {
      Signature[] signatures=mPackageManager.getPackageArchiveInfo(containerPath,PackageManager.GET_SIGNATURES).signatures;
      if (signatures != null) {
        for (        Signature sign : signatures) {
          if (sign != null) {
            X509Certificate certFromSign=null;
            InputStream inStream=null;
            try {
              inStream=new ByteArrayInputStream(sign.toByteArray());
              CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"");
              certFromSign=(X509Certificate)cf.generateCertificate(inStream);
              certFromSign.checkValidity();
              if (certFromSign.equals(verifiedCertificate))               signatureCheckIsSuccessful=true;
            }
 catch (            CertificateException e) {
            }
 finally {
              if (inStream != null) {
                try {
                  inStream.close();
                }
 catch (                IOException e) {
                  e.printStackTrace();
                }
              }
            }
          }
        }
      }
    }
    if (extension.equals(""String_Node_Str"") || (extension.equals(""String_Node_Str"") && signatureCheckIsSuccessful == true)) {
      JarFile containerToVerify=null;
      try {
        containerToVerify=new JarFile(containerPath);
        verifyJARContainer(containerToVerify,verifiedCertificate);
        signatureCheckIsSuccessful=true;
      }
 catch (      Exception e) {
        signatureCheckIsSuccessful=false;
      }
 finally {
        if (containerToVerify != null)         try {
          containerToVerify.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    if (signatureCheckIsSuccessful) {
      return super.loadClass(className);
    }
    File containerToRemove=new File(containerPath);
    if (!containerToRemove.delete())     Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + containerPath);
    packageNameToContainerPathMap.remove(packageName);
    return null;
  }
  return null;
}"
93774,"private void verifyJARContainer(JarFile jarFile,X509Certificate trustedCert) throws IOException {
  if (jarFile == null || trustedCert == null)   throw new SecurityException(""String_Node_Str"");
  Vector<JarEntry> entriesVec=new Vector<JarEntry>();
  Manifest man=jarFile.getManifest();
  if (man == null)   throw new SecurityException(""String_Node_Str"");
  byte[] buffer=new byte[2048];
  Enumeration<JarEntry> entries=jarFile.entries();
  while (entries.hasMoreElements()) {
    JarEntry je=(JarEntry)entries.nextElement();
    if (je.isDirectory())     continue;
    entriesVec.addElement(je);
    InputStream inStream=jarFile.getInputStream(je);
    while (inStream.read(buffer,0,buffer.length) != -1) {
    }
    inStream.close();
  }
  Enumeration<JarEntry> signedEntries=entriesVec.elements();
  while (signedEntries.hasMoreElements()) {
    JarEntry signedEntry=(JarEntry)signedEntries.nextElement();
    X509Certificate[] certificates=(X509Certificate[])signedEntry.getCertificates();
    if ((certificates == null) || (certificates.length == 0)) {
      if (!signedEntry.getName().startsWith(""String_Node_Str""))       throw new SecurityException(""String_Node_Str"");
    }
 else {
      boolean signedAsExpected=false;
      for (      X509Certificate signerCert : certificates) {
        try {
          signerCert.checkValidity();
        }
 catch (        CertificateExpiredException|CertificateNotYetValidException e) {
          throw new SecurityException(""String_Node_Str"");
        }
        if (signerCert.equals(trustedCert))         signedAsExpected=true;
      }
      if (!signedAsExpected)       throw new SecurityException(""String_Node_Str"");
    }
  }
}","private void verifyJARContainer(JarFile jarFile,X509Certificate trustedCert) throws IOException {
  if (jarFile == null || trustedCert == null)   throw new SecurityException(""String_Node_Str"");
  Vector<JarEntry> entriesVec=new Vector<JarEntry>();
  Manifest man=jarFile.getManifest();
  if (man == null) {
    Log.d(TAG_SECURE_DEX_CLASS_LOADER,jarFile.getName() + ""String_Node_Str"");
    throw new SecurityException(""String_Node_Str"");
  }
  byte[] buffer=new byte[8192];
  Enumeration<JarEntry> entries=jarFile.entries();
  while (entries.hasMoreElements()) {
    JarEntry je=(JarEntry)entries.nextElement();
    if (je.isDirectory())     continue;
    entriesVec.addElement(je);
    InputStream inStream=jarFile.getInputStream(je);
    while (inStream.read(buffer,0,buffer.length) != -1) {
    }
    inStream.close();
  }
  Enumeration<JarEntry> signedEntries=entriesVec.elements();
  while (signedEntries.hasMoreElements()) {
    JarEntry signedEntry=(JarEntry)signedEntries.nextElement();
    Certificate[] certificates=signedEntry.getCertificates();
    if ((certificates == null) || (certificates.length == 0)) {
      if (!signedEntry.getName().startsWith(""String_Node_Str"")) {
        Log.d(TAG_SECURE_DEX_CLASS_LOADER,signedEntry.getName() + ""String_Node_Str"");
        throw new SecurityException(""String_Node_Str"");
      }
    }
 else {
      boolean signedAsExpected=false;
      for (      Certificate signerCert : certificates) {
        try {
          ((X509Certificate)signerCert).checkValidity();
        }
 catch (        CertificateExpiredException|CertificateNotYetValidException e) {
          Log.d(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + signedEntry.getName() + ""String_Node_Str"");
          throw new SecurityException(""String_Node_Str"");
        }
catch (        Exception e) {
        }
        if (signerCert.equals(trustedCert))         signedAsExpected=true;
      }
      if (!signedAsExpected) {
        Log.d(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + signedEntry.getName());
        throw new SecurityException(""String_Node_Str"");
      }
    }
  }
}"
93775,"/** 
 * When one of the two initial buttons in this activity is clicked  a different component is dynamically loaded and used to customize the rest of the layout.
 * @param view
 */
public void onBtnClick(View view){
  if (isSecureModeChosen) {
  }
 else {
    if (view.getId() == firstBtn.getId()) {
      mComponentModifier=retrieveComponentModifier(firstClassName);
      Log.i(TAG_DEX_SAMPLE,""String_Node_Str"");
    }
 else {
      mComponentModifier=retrieveComponentModifier(secondClassName);
      Log.i(TAG_DEX_SAMPLE,""String_Node_Str"");
    }
  }
  List<Button> buttonList=new ArrayList<Button>();
  buttonList.add(firstBtn);
  buttonList.add(secondBtn);
  buttonList.add(thirdBtn);
  mComponentModifier.customizeButtons(buttonList);
  mComponentModifier.customizeSwitch(switchSlider);
  mComponentModifier.customizeTextView(textView);
  Log.i(TAG_DEX_SAMPLE,""String_Node_Str"");
}","/** 
 * When one of the two initial buttons in this activity is clicked  a different component is dynamically loaded and used to customize the rest of the layout.
 * @param view
 */
public void onBtnClick(View view){
  if (isSecureModeChosen) {
  }
 else {
    if (view.getId() == firstBtn.getId()) {
      mComponentModifier=retrieveComponentModifier(firstClassName);
      Log.d(TAG_DEX_SAMPLE,""String_Node_Str"");
    }
 else {
      mComponentModifier=retrieveComponentModifier(secondClassName);
      Log.d(TAG_DEX_SAMPLE,""String_Node_Str"");
    }
  }
  List<Button> buttonList=new ArrayList<Button>();
  buttonList.add(firstBtn);
  buttonList.add(secondBtn);
  buttonList.add(thirdBtn);
  mComponentModifier.customizeButtons(buttonList);
  mComponentModifier.customizeSwitch(switchSlider);
  mComponentModifier.customizeTextView(textView);
  Log.i(TAG_DEX_SAMPLE,""String_Node_Str"");
}"
93776,"/** 
 * This effect is used to end the activity.
 * @param view
 */
public void onBtnClickExit(View view){
  toastHandler.post(new Runnable(){
    @Override public void run(){
      Toast.makeText(DexClassSampleActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
  }
);
  Log.i(TAG_DEX_SAMPLE,""String_Node_Str"" + R.string.title_activity_dex_class_sample + ""String_Node_Str"");
  finish();
}","/** 
 * This effect is used to end the activity.
 * @param view
 */
public void onBtnClickExit(View view){
  toastHandler.post(new Runnable(){
    @Override public void run(){
      Toast.makeText(DexClassSampleActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
  }
);
  Log.d(TAG_DEX_SAMPLE,""String_Node_Str"" + R.string.title_activity_dex_class_sample + ""String_Node_Str"");
  finish();
}"
93777,"private ComponentModifier retrieveComponentModifier(String className){
  Log.i(TAG_DEX_SAMPLE,""String_Node_Str"");
  ComponentModifier retComponentModifier=null;
  final String jarContainerPath=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
  File dexOutputDir=getDir(""String_Node_Str"",MODE_PRIVATE);
  DexClassLoader mDexClassLoader=new DexClassLoader(jarContainerPath,dexOutputDir.getAbsolutePath(),null,getClass().getClassLoader());
  try {
    Class<?> loadedClass=mDexClassLoader.loadClass(className);
    retComponentModifier=(ComponentModifier)loadedClass.newInstance();
  }
 catch (  ClassNotFoundException e) {
    Log.e(TAG_DEX_SAMPLE,""String_Node_Str"");
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    Log.e(TAG_DEX_SAMPLE,""String_Node_Str"");
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    Log.e(TAG_DEX_SAMPLE,""String_Node_Str"");
    e.printStackTrace();
  }
  if (retComponentModifier != null) {
    final String shortClassName=retComponentModifier.getClass().getSimpleName();
    Log.i(TAG_DEX_SAMPLE,""String_Node_Str"" + shortClassName + ""String_Node_Str""+ jarContainerPath);
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(DexClassSampleActivity.this,""String_Node_Str"" + shortClassName + ""String_Node_Str""+ jarContainerPath,Toast.LENGTH_LONG).show();
      }
    }
);
  }
 else {
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(DexClassSampleActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    finish();
  }
  return retComponentModifier;
}","private ComponentModifier retrieveComponentModifier(String className){
  Log.d(TAG_DEX_SAMPLE,""String_Node_Str"");
  ComponentModifier retComponentModifier=null;
  final String jarContainerPath=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
  File dexOutputDir=getDir(""String_Node_Str"",MODE_PRIVATE);
  DexClassLoader mDexClassLoader=new DexClassLoader(jarContainerPath,dexOutputDir.getAbsolutePath(),null,getClass().getClassLoader());
  try {
    Class<?> loadedClass=mDexClassLoader.loadClass(className);
    retComponentModifier=(ComponentModifier)loadedClass.newInstance();
  }
 catch (  ClassNotFoundException e) {
    Log.e(TAG_DEX_SAMPLE,""String_Node_Str"");
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    Log.e(TAG_DEX_SAMPLE,""String_Node_Str"");
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    Log.e(TAG_DEX_SAMPLE,""String_Node_Str"");
    e.printStackTrace();
  }
  if (retComponentModifier != null) {
    final String shortClassName=retComponentModifier.getClass().getSimpleName();
    Log.i(TAG_DEX_SAMPLE,""String_Node_Str"" + shortClassName + ""String_Node_Str""+ jarContainerPath);
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(DexClassSampleActivity.this,""String_Node_Str"" + shortClassName + ""String_Node_Str""+ jarContainerPath,Toast.LENGTH_LONG).show();
      }
    }
);
  }
 else {
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(DexClassSampleActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    finish();
  }
  return retComponentModifier;
}"
93778,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  effectiveDexClassLoader=false;
  effectiveSecureDexClassLoader=false;
  toastHandler=new Handler();
  exampleTestAPKPath=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
  exampleSignedAPKPath=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
  classNameInAPK=""String_Node_Str"";
  ListView listView=(ListView)findViewById(R.id.listview);
  listView.setAdapter(new ArrayAdapter<String>(MainActivity.this,android.R.layout.simple_list_item_1,techinquesToExecute));
  OnItemClickListener mMessageClickedHandler=new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
switch (position) {
case DEX_CLASS_LOADER_APK:
        effectiveDexClassLoader=true;
      setUpDexClassLoader();
    effectiveDexClassLoader=false;
  Log.i(TAG_MAIN,""String_Node_Str"");
break;
case DEX_CLASS_LOADER_JAR:
Intent dexClassLoaderIntent=new Intent(MainActivity.this,DexClassSampleActivity.class);
dexClassLoaderIntent.putExtra(IS_SECURE_LOADING_CHOSEN,false);
startActivity(dexClassLoaderIntent);
Log.i(TAG_MAIN,""String_Node_Str"");
break;
case SECURE_DEX_CLASS_LOADER_APK:
effectiveSecureDexClassLoader=true;
setUpSecureDexClassLoader();
effectiveSecureDexClassLoader=false;
Log.i(TAG_MAIN,""String_Node_Str"");
break;
case SECURE_DEX_CLASS_LOADER_JAR:
Intent secureDexClassLoaderIntent=new Intent(MainActivity.this,DexClassSampleActivity.class);
secureDexClassLoaderIntent.putExtra(IS_SECURE_LOADING_CHOSEN,true);
startActivity(secureDexClassLoaderIntent);
Log.i(TAG_MAIN,""String_Node_Str"");
break;
case CREATE_PACK_CTX:
break;
default :
Log.d(TAG_MAIN,""String_Node_Str"");
}
}
}
;
listView.setOnItemClickListener(mMessageClickedHandler);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  effectiveDexClassLoader=false;
  effectiveSecureDexClassLoader=false;
  toastHandler=new Handler();
  exampleTestAPKPath=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
  exampleSignedAPKPath=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
  classNameInAPK=""String_Node_Str"";
  ListView listView=(ListView)findViewById(R.id.listview);
  listView.setAdapter(new ArrayAdapter<String>(MainActivity.this,android.R.layout.simple_list_item_1,techinquesToExecute));
  OnItemClickListener mMessageClickedHandler=new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
switch (position) {
case DEX_CLASS_LOADER_APK:
        effectiveDexClassLoader=true;
      Log.d(TAG_MAIN,""String_Node_Str"");
    setUpDexClassLoader();
  effectiveDexClassLoader=false;
break;
case DEX_CLASS_LOADER_JAR:
Intent dexClassLoaderIntent=new Intent(MainActivity.this,DexClassSampleActivity.class);
dexClassLoaderIntent.putExtra(IS_SECURE_LOADING_CHOSEN,false);
Log.d(TAG_MAIN,""String_Node_Str"");
startActivity(dexClassLoaderIntent);
break;
case SECURE_DEX_CLASS_LOADER_APK:
effectiveSecureDexClassLoader=true;
Log.d(TAG_MAIN,""String_Node_Str"");
setUpSecureDexClassLoader();
effectiveSecureDexClassLoader=false;
break;
case SECURE_DEX_CLASS_LOADER_JAR:
Intent secureDexClassLoaderIntent=new Intent(MainActivity.this,DexClassSampleActivity.class);
secureDexClassLoaderIntent.putExtra(IS_SECURE_LOADING_CHOSEN,true);
Log.d(TAG_MAIN,""String_Node_Str"");
startActivity(secureDexClassLoaderIntent);
break;
case CREATE_PACK_CTX:
break;
default :
Log.d(TAG_MAIN,""String_Node_Str"");
}
}
}
;
listView.setOnItemClickListener(mMessageClickedHandler);
}"
93779,"/** 
 * This method is used to set up and manage a DexClassLoader component in  order to retrieve a new activity from an .apk, which has been  already downloaded and installed on the mobile device. If everything works fine, it will instantiate the main activity of  this .apk.
 */
protected void setUpDexClassLoader(){
  if (!effectiveDexClassLoader)   return;
  Log.i(TAG_MAIN,""String_Node_Str"");
  File dexOutputDir=getDir(""String_Node_Str"",MODE_PRIVATE);
  DexClassLoader mDexClassLoader=new DexClassLoader(exampleTestAPKPath,dexOutputDir.getAbsolutePath(),null,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mDexClassLoader.loadClass(classNameInAPK);
    final Activity NasaDailyActivity=(Activity)loadedClass.newInstance();
    Log.i(TAG_MAIN,""String_Node_Str"" + loadedClass.getSimpleName() + ""String_Node_Str""+ exampleTestAPKPath.toString());
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"" + NasaDailyActivity.getClass().getName(),Toast.LENGTH_SHORT).show();
      }
    }
);
  }
 catch (  ClassNotFoundException e) {
    Log.e(TAG_MAIN,""String_Node_Str"");
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    e.printStackTrace();
  }
catch (  ActivityNotFoundException e) {
    Log.e(TAG_MAIN,""String_Node_Str"");
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
}","/** 
 * This method is used to set up and manage a DexClassLoader component in  order to retrieve a new activity from an .apk, which has been  already downloaded and installed on the mobile device. If everything works fine, it will instantiate the main activity of  this .apk.
 */
protected void setUpDexClassLoader(){
  if (!effectiveDexClassLoader)   return;
  Log.d(TAG_MAIN,""String_Node_Str"");
  File dexOutputDir=getDir(""String_Node_Str"",MODE_PRIVATE);
  DexClassLoader mDexClassLoader=new DexClassLoader(exampleSignedAPKPath,dexOutputDir.getAbsolutePath(),null,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mDexClassLoader.loadClass(classNameInAPK);
    final Activity NasaDailyActivity=(Activity)loadedClass.newInstance();
    Log.i(TAG_MAIN,""String_Node_Str"" + loadedClass.getSimpleName() + ""String_Node_Str""+ exampleSignedAPKPath.toString());
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"" + NasaDailyActivity.getClass().getName(),Toast.LENGTH_SHORT).show();
      }
    }
);
  }
 catch (  ClassNotFoundException e) {
    Log.e(TAG_MAIN,""String_Node_Str"");
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    e.printStackTrace();
  }
catch (  ActivityNotFoundException e) {
    Log.e(TAG_MAIN,""String_Node_Str"");
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
}"
93780,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
switch (position) {
case DEX_CLASS_LOADER_APK:
    effectiveDexClassLoader=true;
  setUpDexClassLoader();
effectiveDexClassLoader=false;
Log.i(TAG_MAIN,""String_Node_Str"");
break;
case DEX_CLASS_LOADER_JAR:
Intent dexClassLoaderIntent=new Intent(MainActivity.this,DexClassSampleActivity.class);
dexClassLoaderIntent.putExtra(IS_SECURE_LOADING_CHOSEN,false);
startActivity(dexClassLoaderIntent);
Log.i(TAG_MAIN,""String_Node_Str"");
break;
case SECURE_DEX_CLASS_LOADER_APK:
effectiveSecureDexClassLoader=true;
setUpSecureDexClassLoader();
effectiveSecureDexClassLoader=false;
Log.i(TAG_MAIN,""String_Node_Str"");
break;
case SECURE_DEX_CLASS_LOADER_JAR:
Intent secureDexClassLoaderIntent=new Intent(MainActivity.this,DexClassSampleActivity.class);
secureDexClassLoaderIntent.putExtra(IS_SECURE_LOADING_CHOSEN,true);
startActivity(secureDexClassLoaderIntent);
Log.i(TAG_MAIN,""String_Node_Str"");
break;
case CREATE_PACK_CTX:
break;
default :
Log.d(TAG_MAIN,""String_Node_Str"");
}
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
switch (position) {
case DEX_CLASS_LOADER_APK:
    effectiveDexClassLoader=true;
  Log.d(TAG_MAIN,""String_Node_Str"");
setUpDexClassLoader();
effectiveDexClassLoader=false;
break;
case DEX_CLASS_LOADER_JAR:
Intent dexClassLoaderIntent=new Intent(MainActivity.this,DexClassSampleActivity.class);
dexClassLoaderIntent.putExtra(IS_SECURE_LOADING_CHOSEN,false);
Log.d(TAG_MAIN,""String_Node_Str"");
startActivity(dexClassLoaderIntent);
break;
case SECURE_DEX_CLASS_LOADER_APK:
effectiveSecureDexClassLoader=true;
Log.d(TAG_MAIN,""String_Node_Str"");
setUpSecureDexClassLoader();
effectiveSecureDexClassLoader=false;
break;
case SECURE_DEX_CLASS_LOADER_JAR:
Intent secureDexClassLoaderIntent=new Intent(MainActivity.this,DexClassSampleActivity.class);
secureDexClassLoaderIntent.putExtra(IS_SECURE_LOADING_CHOSEN,true);
Log.d(TAG_MAIN,""String_Node_Str"");
startActivity(secureDexClassLoaderIntent);
break;
case CREATE_PACK_CTX:
break;
default :
Log.d(TAG_MAIN,""String_Node_Str"");
}
}"
93781,"protected void setUpSecureDexClassLoader(){
  if (!effectiveSecureDexClassLoader)   return;
  Log.i(TAG_MAIN,""String_Node_Str"");
  SecureLoaderFactory mSecureLoaderFactory=new SecureLoaderFactory(this);
  SecureDexClassLoader mSecureDexClassLoader;
  String listAPKPaths=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"" + exampleTestAPKPath;
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,null,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  mSecureDexClassLoader.wipeOutPrivateAppCachedData(true,true);
  Map<String,String> packageNamesToCertMap=new HashMap<String,String>();
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(exampleTestAPKPath,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  Log.i(TAG_MAIN,""String_Node_Str"");
  listAPKPaths=""String_Node_Str"" + exampleSignedAPKPath;
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Activity NasaDailyActivity=(Activity)loadedClass.newInstance();
      Log.i(TAG_MAIN,""String_Node_Str"" + NasaDailyActivity.getLocalClassName() + ""String_Node_Str""+ NasaDailyActivity.getPackageResourcePath()+ ""String_Node_Str"");
    }
 else {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
  mSecureDexClassLoader.wipeOutPrivateAppCachedData(false,true);
}","protected void setUpSecureDexClassLoader(){
  if (!effectiveSecureDexClassLoader)   return;
  Log.d(TAG_MAIN,""String_Node_Str"");
  SecureLoaderFactory mSecureLoaderFactory=new SecureLoaderFactory(this);
  SecureDexClassLoader mSecureDexClassLoader;
  String listAPKPaths=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"" + exampleTestAPKPath;
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,null,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  mSecureDexClassLoader.wipeOutPrivateAppCachedData(true,true);
  Map<String,String> packageNamesToCertMap=new HashMap<String,String>();
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(exampleTestAPKPath,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  Log.i(TAG_MAIN,""String_Node_Str"");
  listAPKPaths=""String_Node_Str"" + exampleSignedAPKPath;
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Activity NasaDailyActivity=(Activity)loadedClass.newInstance();
      Log.i(TAG_MAIN,""String_Node_Str"" + NasaDailyActivity.getLocalClassName() + ""String_Node_Str""+ NasaDailyActivity.getPackageResourcePath()+ ""String_Node_Str"");
    }
 else {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
catch (  InstantiationException e) {
    Log.w(TAG_MAIN,""String_Node_Str"");
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    Log.w(TAG_MAIN,""String_Node_Str"");
    e.printStackTrace();
  }
  mSecureDexClassLoader.wipeOutPrivateAppCachedData(false,true);
  Log.d(TAG_MAIN,""String_Node_Str"");
}"
93782,"private boolean downloadCertificateRemotelyViaHttps(String packageName){
  NetworkInfo activeNetworkInfo=mConnectivityManager.getActiveNetworkInfo();
  if (activeNetworkInfo != null && activeNetworkInfo.isConnected()) {
    String urlString=packageNameToCertificateMap.get(packageName);
    HttpsURLConnection urlConnection=null;
    InputStream inputStream=null;
    OutputStream outputStream=null;
    try {
      URL certificateURL=new URL(urlString);
      urlConnection=(HttpsURLConnection)certificateURL.openConnection();
      urlConnection.connect();
      Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"");
      inputStream=urlConnection.getInputStream();
      String downloadPath=certificateFolder.getAbsolutePath() + ""String_Node_Str"" + packageName+ ""String_Node_Str"";
      outputStream=new FileOutputStream(downloadPath);
      int read=0;
      byte[] bytes=new byte[1024];
      while ((read=inputStream.read(bytes)) != -1) {
        outputStream.write(bytes,0,read);
      }
      Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + downloadPath);
    }
 catch (    MalformedURLException e) {
      return false;
    }
catch (    IOException e) {
      return false;
    }
 finally {
      if (inputStream != null) {
        try {
          inputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      if (outputStream != null) {
        try {
          outputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      if (urlConnection != null)       urlConnection.disconnect();
      Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"");
    }
    return true;
  }
  Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"");
  return false;
}","private boolean downloadCertificateRemotelyViaHttps(String packageName){
  NetworkInfo activeNetworkInfo=mConnectivityManager.getActiveNetworkInfo();
  if (activeNetworkInfo != null && activeNetworkInfo.isConnected()) {
    String urlString=packageNameToCertificateMap.get(packageName);
    HttpsURLConnection urlConnection=null;
    InputStream inputStream=null;
    OutputStream outputStream=null;
    try {
      URL certificateURL=new URL(urlString);
      urlConnection=(HttpsURLConnection)certificateURL.openConnection();
      if (urlConnection.getResponseCode() == HttpsURLConnection.HTTP_OK) {
        Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"");
        inputStream=urlConnection.getInputStream();
        String downloadPath=certificateFolder.getAbsolutePath() + ""String_Node_Str"" + packageName+ ""String_Node_Str"";
        outputStream=new FileOutputStream(downloadPath);
        int read=0;
        byte[] bytes=new byte[1024];
        while ((read=inputStream.read(bytes)) > 0) {
          outputStream.write(bytes,0,read);
        }
        Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + downloadPath);
      }
    }
 catch (    MalformedURLException e) {
      return false;
    }
catch (    IOException e) {
      return false;
    }
 finally {
      Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"");
      if (urlConnection != null)       urlConnection.disconnect();
      if (inputStream != null) {
        try {
          inputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      if (outputStream != null) {
        try {
          outputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
 else       return false;
    }
    return true;
  }
  Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"");
  return false;
}"
93783,"private String revertPackageNameToURL(String packageName){
  String urlString, firstLevelDomain, secondLevelDomain;
  int firstPointChar=packageName.indexOf('.');
  int secondPointChar=packageName.indexOf('.',firstPointChar + 1);
  firstLevelDomain=packageName.substring(0,firstPointChar);
  secondLevelDomain=packageName.substring(firstPointChar + 1,secondPointChar);
  urlString=""String_Node_Str"" + secondLevelDomain + firstLevelDomain+ packageName.substring(secondPointChar).replaceAll(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
  return urlString;
}","private String revertPackageNameToURL(String packageName){
  String firstLevelDomain, secondLevelDomain;
  int firstPointChar=packageName.indexOf('.');
  if (firstPointChar == -1) {
    return ""String_Node_Str"" + packageName + ""String_Node_Str"";
  }
  firstLevelDomain=packageName.substring(0,firstPointChar);
  int secondPointChar=packageName.indexOf('.',firstPointChar + 1);
  if (secondPointChar == -1) {
    return ""String_Node_Str"" + packageName.substring(firstPointChar + 1) + ""String_Node_Str""+ firstLevelDomain+ ""String_Node_Str"";
  }
  secondLevelDomain=packageName.substring(firstPointChar + 1,secondPointChar);
  return ""String_Node_Str"" + secondLevelDomain + ""String_Node_Str""+ firstLevelDomain+ packageName.substring(secondPointChar).replaceAll(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
}"
93784,"private String getPackageNameFromContainerPath(String containerPath){
  int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
  String extension=containerPath.substring(extensionIndex);
  if (extension.equals(""String_Node_Str"")) {
    return mPackageManager.getPackageArchiveInfo(containerPath,0).packageName;
  }
  if (extension.equals(""String_Node_Str"")) {
    DexFile classesDexFile=null;
    String packageName;
    try {
      classesDexFile=new DexFile(containerPath);
      Enumeration<String> classesNames=classesDexFile.entries();
      String firstClassName=classesNames.nextElement().replaceAll(Pattern.quote(File.separator),""String_Node_Str"");
      packageName=firstClassName.substring(0,firstClassName.lastIndexOf('.'));
    }
 catch (    IOException e) {
      return null;
    }
 finally {
      if (classesDexFile != null) {
        try {
          classesDexFile.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    return packageName;
  }
  return null;
}","private String getPackageNameFromContainerPath(String containerPath){
  int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
  String extension=containerPath.substring(extensionIndex);
  if (extension.equals(""String_Node_Str"")) {
    if (mPackageManager.getPackageArchiveInfo(containerPath,0) != null)     return mPackageManager.getPackageArchiveInfo(containerPath,0).packageName;
    return null;
  }
  if (extension.equals(""String_Node_Str"")) {
    DexFile classesDexFile=null;
    String packageName;
    try {
      classesDexFile=new DexFile(containerPath);
      Enumeration<String> classesNames=classesDexFile.entries();
      String firstClassName=classesNames.nextElement().replaceAll(Pattern.quote(File.separator),""String_Node_Str"");
      packageName=firstClassName.substring(0,firstClassName.lastIndexOf('.'));
    }
 catch (    IOException e) {
      return null;
    }
 finally {
      if (classesDexFile != null) {
        try {
          classesDexFile.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    return packageName;
  }
  return null;
}"
93785,"private Map<String,String> sanitizePackageNameToCertificateMap(Map<String,String> packageNameToCertificateMap){
  if (packageNameToCertificateMap == null || packageNameToCertificateMap.isEmpty())   return null;
  Map<String,String> santiziedPackageNameToCertificateMap=packageNameToCertificateMap;
  Iterator<String> packageNamesIterator=santiziedPackageNameToCertificateMap.keySet().iterator();
  while (packageNamesIterator.hasNext()) {
    String currentPackageName=packageNamesIterator.next();
    String[] packStrings=currentPackageName.split(""String_Node_Str"");
    boolean isValidPackageName=true;
    boolean removeThisPackageName=false;
    for (    String packString : packStrings) {
      if (packString.isEmpty())       isValidPackageName=false;
    }
    if (isValidPackageName) {
      URL certificateURL;
      try {
        String certificateURLString=santiziedPackageNameToCertificateMap.get(currentPackageName);
        certificateURL=new URL(certificateURLString);
        if (certificateURL.getProtocol() == ""String_Node_Str"") {
          santiziedPackageNameToCertificateMap.put(currentPackageName,certificateURLString.replace(""String_Node_Str"",""String_Node_Str""));
        }
 else {
          if (certificateURL.getProtocol() != ""String_Node_Str"") {
            removeThisPackageName=true;
          }
        }
      }
 catch (      MalformedURLException e) {
        removeThisPackageName=true;
      }
    }
 else     removeThisPackageName=true;
    if (removeThisPackageName) {
      packageNamesIterator.remove();
    }
  }
  return santiziedPackageNameToCertificateMap;
}","private Map<String,String> sanitizePackageNameToCertificateMap(Map<String,String> packageNameToCertificateMap){
  if (packageNameToCertificateMap == null || packageNameToCertificateMap.isEmpty())   return null;
  Map<String,String> santiziedPackageNameToCertificateMap=packageNameToCertificateMap;
  Iterator<String> packageNamesIterator=santiziedPackageNameToCertificateMap.keySet().iterator();
  while (packageNamesIterator.hasNext()) {
    String currentPackageName=packageNamesIterator.next();
    String[] packStrings=currentPackageName.split(""String_Node_Str"");
    boolean isValidPackageName=true;
    boolean removeThisPackageName=false;
    for (    String packString : packStrings) {
      if (packString.isEmpty())       isValidPackageName=false;
    }
    if (isValidPackageName) {
      URL certificateURL;
      try {
        String certificateURLString=santiziedPackageNameToCertificateMap.get(currentPackageName);
        certificateURL=new URL(certificateURLString);
        if (certificateURL.getProtocol().equals(""String_Node_Str"")) {
          santiziedPackageNameToCertificateMap.put(currentPackageName,certificateURLString.replace(""String_Node_Str"",""String_Node_Str""));
        }
 else {
          if (!certificateURL.getProtocol().equals(""String_Node_Str"")) {
            removeThisPackageName=true;
          }
        }
      }
 catch (      MalformedURLException e) {
        removeThisPackageName=true;
      }
    }
 else     removeThisPackageName=true;
    if (removeThisPackageName) {
      packageNamesIterator.remove();
    }
  }
  return santiziedPackageNameToCertificateMap;
}"
93786,"private String downloadContainerIntoFolder(String urlPath,File resOutputDir){
  if (urlPath == null)   return null;
  if (resOutputDir == null || !resOutputDir.exists())   return null;
  if (!resOutputDir.isDirectory() || !resOutputDir.canRead() || !resOutputDir.canWrite())   return null;
  URL url;
  try {
    url=new URL(urlPath);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    return null;
  }
  if (url.getProtocol() != ""String_Node_Str"" && url.getProtocol() != ""String_Node_Str"")   return null;
  int finalSeparatorIndex=url.getPath().lastIndexOf(""String_Node_Str"");
  String containerName=url.getPath().substring(finalSeparatorIndex);
  if (containerName == null || containerName.isEmpty())   return null;
  int extensionIndex=containerName.lastIndexOf(""String_Node_Str"");
  String extension=containerName.substring(extensionIndex);
  if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str""))   return null;
  File checkFile=new File(resOutputDir.getAbsolutePath() + ""String_Node_Str"" + containerName);
  String finalContainerName;
  if (checkFile.exists()) {
    int currentIndex=0;
    do {
      currentIndex++;
      finalContainerName=containerName.substring(0,extensionIndex) + currentIndex + extension;
      checkFile=new File(resOutputDir.getAbsolutePath() + ""String_Node_Str"" + finalContainerName);
    }
 while (checkFile.exists());
  }
 else {
    finalContainerName=containerName;
  }
  URLConnection urlConnection=null;
  InputStream inputStream=null;
  OutputStream outputStream=null;
  String localContainerPath=resOutputDir.getAbsolutePath() + ""String_Node_Str"" + finalContainerName;
  activeNetworkInfo=mConnectivityManager.getActiveNetworkInfo();
  if (activeNetworkInfo != null && activeNetworkInfo.isConnected()) {
    try {
      if (url.getProtocol() != ""String_Node_Str"") {
        urlConnection=(HttpsURLConnection)url.openConnection();
      }
 else {
        urlConnection=(HttpURLConnection)url.openConnection();
      }
      urlConnection.connect();
      Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + url.toString());
      inputStream=urlConnection.getInputStream();
      outputStream=new FileOutputStream(localContainerPath);
      int read=0;
      byte[] bytes=new byte[1024];
      while ((read=inputStream.read(bytes)) != -1) {
        outputStream.write(bytes,0,read);
      }
      Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + localContainerPath);
    }
 catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
 finally {
      if (inputStream != null) {
        try {
          inputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      if (outputStream != null) {
        try {
          outputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      if (urlConnection != null)       ((HttpURLConnection)urlConnection).disconnect();
      Log.i(TAG_SECURE_FACTORY,""String_Node_Str"");
    }
    return localContainerPath;
  }
  Log.i(TAG_SECURE_FACTORY,""String_Node_Str"");
  return null;
}","private String downloadContainerIntoFolder(String urlPath,File resOutputDir){
  if (urlPath == null)   return null;
  if (resOutputDir == null || !resOutputDir.exists())   return null;
  if (!resOutputDir.isDirectory() || !resOutputDir.canRead() || !resOutputDir.canWrite())   return null;
  URL url;
  try {
    url=new URL(urlPath);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    return null;
  }
  if (!url.getProtocol().equals(""String_Node_Str"") && !url.getProtocol().equals(""String_Node_Str""))   return null;
  int finalSeparatorIndex=url.getPath().lastIndexOf(""String_Node_Str"");
  String containerName=url.getFile().substring(finalSeparatorIndex);
  if (containerName == null || containerName.isEmpty())   return null;
  int extensionIndex=containerName.lastIndexOf(""String_Node_Str"");
  String extension=containerName.substring(extensionIndex);
  if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str""))   return null;
  File checkFile=new File(resOutputDir.getAbsolutePath() + containerName);
  String finalContainerName;
  if (checkFile.exists()) {
    int currentIndex=0;
    do {
      currentIndex++;
      finalContainerName=containerName.substring(0,extensionIndex) + currentIndex + extension;
      checkFile=new File(resOutputDir.getAbsolutePath() + finalContainerName);
    }
 while (checkFile.exists());
  }
 else {
    finalContainerName=containerName;
  }
  HttpURLConnection urlConnection=null;
  InputStream inputStream=null;
  OutputStream outputStream=null;
  String localContainerPath=resOutputDir.getAbsolutePath() + finalContainerName;
  activeNetworkInfo=mConnectivityManager.getActiveNetworkInfo();
  if (activeNetworkInfo != null && activeNetworkInfo.isConnected()) {
    try {
      if (url.getProtocol().equals(""String_Node_Str"")) {
        urlConnection=(HttpsURLConnection)url.openConnection();
      }
 else {
        urlConnection=(HttpURLConnection)url.openConnection();
      }
      Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + url.toString());
      inputStream=new BufferedInputStream(urlConnection.getInputStream());
      outputStream=new FileOutputStream(localContainerPath);
      int read=0;
      byte[] bytes=new byte[1024];
      while ((read=inputStream.read(bytes)) > 0) {
        outputStream.write(bytes,0,read);
      }
      Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + localContainerPath);
    }
 catch (    IOException e) {
      return null;
    }
 finally {
      Log.i(TAG_SECURE_FACTORY,""String_Node_Str"");
      if (urlConnection != null)       ((HttpURLConnection)urlConnection).disconnect();
      if (inputStream != null) {
        try {
          inputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      if (outputStream != null) {
        try {
          outputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
 else {
        return null;
      }
    }
    return localContainerPath;
  }
  Log.i(TAG_SECURE_FACTORY,""String_Node_Str"");
  return null;
}"
93787,"/** 
 * Creates a   {@link SecureDexClassLoader} that finds interpreted and native code in a set ofprovided locations (either local or remote via HTTP or HTTPS) in dexPath. Interpreted classes are found in a set of DEX files contained in Jar or Apk files and  stored into an application-private, writable directory. Before executing one of these classes the signature of the target class is  verified against the certificate associated with its package name. Certificates location are provided by filling appropriately  {@link packageNameToCertificateMap}}; each package name must be linked with the remote location of the certificate that should be used to validate all the classes of that package. It's important  that each one of these locations uses HTTPS as its protocol; otherwise this  choice will be enforced! If a class package name do not match any of the provided entries in the map,  certificate location will be constructed by simply reverting package name and  transforming it into a web-based URL using HTTPS. Note that this method returns null if no matching Jar or Apk file is found at the provided dexPath parameter; otherwise a   {@link SecureDexClassLoader} instance is returned.Dynamic class loading with the returned  {@link SecureDexClassLoader} will fail whetherat least one of these conditions is not accomplished: target class is not found in dexPath or is in a missing remote container (i.e. Internet connectivity is not present), missing or invalid (i.e. expired) certificate is associated with the package name of the target class, target class signature check fails against the associated certificate.
 * @param dexPath the list of jar/apk files containing classes and resources; these paths could be either local URLs pointing to a location in the device or URLs that links to a resource stored in the web via HTTP/HTTPS. In the latter case, if Internet connectivity is available, the resource will be imported in a private-application  directory before being used.
 * @param libraryPath the list of directories containing native libraries; it may be null
 * @param packageNameToCertificateMap a map that couples each package name to a URL which contains the certificate that must be used to validate all the classes that belong to that package before launching them at run time.
 * @param parent the parent class loader
 * @return secureDexClassLoader
 */
public SecureDexClassLoader createDexClassLoader(String dexPath,String libraryPath,Map<String,String> packageNameToCertificateMap,ClassLoader parent){
  StringBuilder finalDexPath=new StringBuilder();
  String[] strings=dexPath.split(Pattern.quote(File.pathSeparator));
  File resDownloadDir=null;
  boolean isResourceFolderInitialized=false;
  for (  String path : strings) {
    if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
      if (!isResourceFolderInitialized) {
        resDownloadDir=mContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
        Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + resDownloadDir.getAbsolutePath());
        isResourceFolderInitialized=true;
      }
      String downloadedContainerPath=downloadContainerIntoFolder(path,resDownloadDir);
      if (downloadedContainerPath != null) {
        finalDexPath.append(downloadedContainerPath + Pattern.quote(File.pathSeparator));
        Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + finalDexPath);
      }
    }
 else {
      finalDexPath.append(path + Pattern.quote(File.pathSeparator));
    }
  }
  finalDexPath.deleteCharAt(finalDexPath.lastIndexOf(Pattern.quote(File.pathSeparator)));
  File dexOutputDir=mContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
  Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + dexOutputDir.getAbsolutePath());
  Map<String,String> santiziedPackageNameToCertificateMap=sanitizePackageNameToCertificateMap(packageNameToCertificateMap);
  SecureDexClassLoader mSecureDexClassLoader=new SecureDexClassLoader(finalDexPath.toString(),dexOutputDir.getAbsolutePath(),libraryPath,parent,mContextWrapper);
  if (mSecureDexClassLoader != null)   mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
  return mSecureDexClassLoader;
}","/** 
 * Creates a   {@link SecureDexClassLoader} that finds interpreted and native code in a set ofprovided locations (either local or remote via HTTP or HTTPS) in dexPath. Interpreted classes are found in a set of DEX files contained in Jar or Apk files and  stored into an application-private, writable directory. Before executing one of these classes the signature of the target class is  verified against the certificate associated with its package name. Certificates location are provided by filling appropriately  {@link packageNameToCertificateMap}}; each package name must be linked with the remote location of the certificate that should be used to validate all the classes of that package. It's important  that each one of these locations uses HTTPS as its protocol; otherwise this  choice will be enforced! If a class package name do not match any of the provided entries in the map,  certificate location will be constructed by simply reverting package name and  transforming it into a web-based URL using HTTPS. Note that this method returns null if no matching Jar or Apk file is found at the provided dexPath parameter; otherwise a   {@link SecureDexClassLoader} instance is returned.Dynamic class loading with the returned  {@link SecureDexClassLoader} will fail whetherat least one of these conditions is not accomplished: target class is not found in dexPath or is in a missing remote container (i.e. Internet connectivity is not present), missing or invalid (i.e. expired) certificate is associated with the package name of the target class, target class signature check fails against the associated certificate.
 * @param dexPath the list of jar/apk files containing classes and resources; these paths could be either local URLs pointing to a location in the device or URLs that links to a resource stored in the web via HTTP/HTTPS. In the latter case, if Internet connectivity is available, the resource will be imported in a private-application  directory before being used.
 * @param libraryPath the list of directories containing native libraries; it may be null
 * @param packageNameToCertificateMap a map that couples each package name to a URL which contains the certificate that must be used to validate all the classes that belong to that package before launching them at run time.
 * @param parent the parent class loader
 * @return secureDexClassLoader
 */
public SecureDexClassLoader createDexClassLoader(String dexPath,String libraryPath,Map<String,String> packageNameToCertificateMap,ClassLoader parent){
  StringBuilder finalDexPath=new StringBuilder();
  String tempPath=dexPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  tempPath=tempPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  String[] strings=tempPath.split(Pattern.quote(File.pathSeparator));
  File resDownloadDir=null;
  boolean isResourceFolderInitialized=false;
  for (  String path : strings) {
    if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
      String fixedPath=path.replaceAll(""String_Node_Str"",""String_Node_Str"");
      fixedPath=fixedPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (!isResourceFolderInitialized) {
        resDownloadDir=mContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
        Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + resDownloadDir.getAbsolutePath());
        isResourceFolderInitialized=true;
      }
      String downloadedContainerPath=downloadContainerIntoFolder(fixedPath,resDownloadDir);
      if (downloadedContainerPath != null) {
        finalDexPath.append(downloadedContainerPath + File.pathSeparator);
        Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + finalDexPath);
      }
    }
 else {
      finalDexPath.append(path + File.pathSeparator);
    }
  }
  finalDexPath.deleteCharAt(finalDexPath.lastIndexOf(File.pathSeparator));
  File dexOutputDir=mContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
  Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + dexOutputDir.getAbsolutePath());
  Map<String,String> santiziedPackageNameToCertificateMap=sanitizePackageNameToCertificateMap(packageNameToCertificateMap);
  SecureDexClassLoader mSecureDexClassLoader=new SecureDexClassLoader(finalDexPath.toString(),dexOutputDir.getAbsolutePath(),libraryPath,parent,mContextWrapper);
  if (mSecureDexClassLoader != null)   mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
  return mSecureDexClassLoader;
}"
93788,"protected void setUpSecureDexClassLoader(){
  if (!effectiveSecureDexClassLoader)   return;
  Log.i(TAG_MAIN,""String_Node_Str"");
  SecureLoaderFactory mSecureLoaderFactory=new SecureLoaderFactory(this);
  SecureDexClassLoader mSecureDexClassLoader;
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(exampleTestAPKPath,null,null,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  String listAPKPaths=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"" + exampleTestAPKPath+ ""String_Node_Str"";
  Map<String,String> packageNamesToCertMap=new HashMap<String,String>();
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  Log.i(TAG_MAIN,""String_Node_Str"");
  listAPKPaths=""String_Node_Str"" + exampleSignedAPKPath;
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Activity NasaDailyActivity=(Activity)loadedClass.newInstance();
      Log.i(TAG_MAIN,""String_Node_Str"" + NasaDailyActivity.getLocalClassName() + ""String_Node_Str""+ NasaDailyActivity.getPackageResourcePath()+ ""String_Node_Str"");
    }
 else {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
}","protected void setUpSecureDexClassLoader(){
  if (!effectiveSecureDexClassLoader)   return;
  Log.i(TAG_MAIN,""String_Node_Str"");
  SecureLoaderFactory mSecureLoaderFactory=new SecureLoaderFactory(this);
  SecureDexClassLoader mSecureDexClassLoader;
  String listAPKPaths=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"" + exampleTestAPKPath+ ""String_Node_Str"";
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,null,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  Map<String,String> packageNamesToCertMap=new HashMap<String,String>();
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(exampleTestAPKPath,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  Log.i(TAG_MAIN,""String_Node_Str"");
  listAPKPaths=""String_Node_Str"" + exampleSignedAPKPath;
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Activity NasaDailyActivity=(Activity)loadedClass.newInstance();
      Log.i(TAG_MAIN,""String_Node_Str"" + NasaDailyActivity.getLocalClassName() + ""String_Node_Str""+ NasaDailyActivity.getPackageResourcePath()+ ""String_Node_Str"");
    }
 else {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
}"
93789,"boolean downloadRemoteUrl(final URL remoteURL,final String localURI){
  activeNetworkInfo=mConnectivityManager.getActiveNetworkInfo();
  if (activeNetworkInfo == null || !activeNetworkInfo.isConnected()) {
    Log.w(TAG_FILE_DOWNLOADER,""String_Node_Str"");
    return false;
  }
  dialog=ProgressDialog.show(mContextWrapper,""String_Node_Str"",""String_Node_Str"");
  Thread dataThread=new Thread(){
    @Override public void run(){
      HttpURLConnection urlConnection=null;
      InputStream inputStream=null;
      OutputStream outputStream=null;
      try {
        if (remoteURL.getProtocol().equals(""String_Node_Str"")) {
          urlConnection=(HttpsURLConnection)remoteURL.openConnection();
        }
 else {
          urlConnection=(HttpURLConnection)remoteURL.openConnection();
        }
        Log.d(TAG_FILE_DOWNLOADER,""String_Node_Str"" + remoteURL.toString());
        inputStream=new BufferedInputStream(urlConnection.getInputStream());
        outputStream=new FileOutputStream(localURI);
        int read=0;
        byte[] bytes=new byte[1024];
        while ((read=inputStream.read(bytes)) > 0) {
          outputStream.write(bytes,0,read);
        }
        Log.i(TAG_FILE_DOWNLOADER,""String_Node_Str"" + localURI);
      }
 catch (      IOException e) {
      }
 finally {
        Log.d(TAG_FILE_DOWNLOADER,""String_Node_Str"");
        if (urlConnection != null)         ((HttpURLConnection)urlConnection).disconnect();
        if (inputStream != null) {
          try {
            inputStream.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
        if (outputStream != null) {
          try {
            outputStream.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
      handler.post(new Runnable(){
        @Override public void run(){
          dialog.dismiss();
        }
      }
);
    }
  }
;
  dataThread.start();
  try {
    dataThread.join();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    return false;
  }
  File fileAtLocalURI=new File(localURI);
  if (fileAtLocalURI.exists() && fileAtLocalURI.length() > 0)   return true;
 else   return false;
}","boolean downloadRemoteUrl(final URL remoteURL,final String localURI){
  activeNetworkInfo=mConnectivityManager.getActiveNetworkInfo();
  if (activeNetworkInfo == null || !activeNetworkInfo.isConnected()) {
    Log.w(TAG_FILE_DOWNLOADER,""String_Node_Str"");
    return false;
  }
  dialog=ProgressDialog.show((Activity)mContextWrapper,""String_Node_Str"",""String_Node_Str"");
  Thread dataThread=new Thread(){
    @Override public void run(){
      HttpURLConnection urlConnection=null;
      InputStream inputStream=null;
      OutputStream outputStream=null;
      try {
        if (remoteURL.getProtocol().equals(""String_Node_Str"")) {
          urlConnection=(HttpsURLConnection)remoteURL.openConnection();
        }
 else {
          urlConnection=(HttpURLConnection)remoteURL.openConnection();
        }
        Log.d(TAG_FILE_DOWNLOADER,""String_Node_Str"" + remoteURL.toString());
        inputStream=new BufferedInputStream(urlConnection.getInputStream());
        outputStream=new FileOutputStream(localURI);
        int read=0;
        byte[] bytes=new byte[1024];
        while ((read=inputStream.read(bytes)) > 0) {
          outputStream.write(bytes,0,read);
        }
        Log.i(TAG_FILE_DOWNLOADER,""String_Node_Str"" + localURI);
      }
 catch (      IOException e) {
      }
 finally {
        Log.d(TAG_FILE_DOWNLOADER,""String_Node_Str"");
        if (urlConnection != null)         ((HttpURLConnection)urlConnection).disconnect();
        if (inputStream != null) {
          try {
            inputStream.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
        if (outputStream != null) {
          try {
            outputStream.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
      handler.post(new Runnable(){
        @Override public void run(){
          dialog.dismiss();
        }
      }
);
    }
  }
;
  dataThread.start();
  try {
    dataThread.join();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    return false;
  }
  File fileAtLocalURI=new File(localURI);
  if (fileAtLocalURI.exists() && fileAtLocalURI.length() > 0)   return true;
 else   return false;
}"
93790,"private X509Certificate importCertificateFromAppPrivateDir(String packageName){
  File[] certMatchingFiles=certificateFolder.listFiles(new CertFileFilter(packageName));
  X509Certificate verifiedCertificate=null;
  if (certMatchingFiles != null && certMatchingFiles.length != 0) {
    InputStream inStream=null;
    try {
      inStream=new FileInputStream(certMatchingFiles[0]);
      CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"");
      verifiedCertificate=(X509Certificate)cf.generateCertificate(inStream);
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    CertificateException e) {
      e.printStackTrace();
    }
 finally {
      if (inStream != null) {
        try {
          inStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    if (verifiedCertificate != null) {
      try {
        verifiedCertificate.checkValidity();
        int keyCertSignIndex=5;
        if (!verifiedCertificate.getKeyUsage()[keyCertSignIndex])         throw new CertificateExpiredException(""String_Node_Str"");
        String androidDebugModeDN=""String_Node_Str"";
        X500Principal androidDebugModePrincipal=new X500Principal(androidDebugModeDN);
        if (verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) || verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal))         throw new CertificateExpiredException(""String_Node_Str"");
      }
 catch (      CertificateExpiredException|CertificateNotYetValidException e) {
        verifiedCertificate=null;
        String certFileToErase=certMatchingFiles[0].getName();
        if (certMatchingFiles[0].delete()) {
          Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
 else {
          Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
      }
    }
  }
  return verifiedCertificate;
}","private X509Certificate importCertificateFromAppPrivateDir(String packageName){
  File[] certMatchingFiles=certificateFolder.listFiles(new CertFileFilter(packageName));
  X509Certificate verifiedCertificate=null;
  if (certMatchingFiles != null && certMatchingFiles.length != 0) {
    InputStream inStream=null;
    try {
      inStream=new FileInputStream(certMatchingFiles[0]);
      CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"");
      verifiedCertificate=(X509Certificate)cf.generateCertificate(inStream);
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    CertificateException e) {
      e.printStackTrace();
    }
 finally {
      if (inStream != null) {
        try {
          inStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    if (verifiedCertificate != null) {
      try {
        verifiedCertificate.checkValidity();
        if (verifiedCertificate.getKeyUsage() != null) {
          int keyCertSignIndex=5;
          if (!verifiedCertificate.getKeyUsage()[keyCertSignIndex])           throw new CertificateExpiredException(""String_Node_Str"");
          Log.i(TAG_SECURE_DEX_CLASS_LOADER,verifiedCertificate.getKeyUsage().toString());
        }
        String androidDebugModeDN=""String_Node_Str"";
        X500Principal androidDebugModePrincipal=new X500Principal(androidDebugModeDN);
        if (verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) || verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal))         throw new CertificateExpiredException(""String_Node_Str"");
      }
 catch (      CertificateExpiredException|CertificateNotYetValidException e) {
        verifiedCertificate=null;
        String certFileToErase=certMatchingFiles[0].getName();
        if (certMatchingFiles[0].delete()) {
          Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
 else {
          Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + certFileToErase + ""String_Node_Str"");
        }
      }
    }
  }
  return verifiedCertificate;
}"
93791,"@Override public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap == null)   return null;
  if (hasBeenWipedOut)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath=packageNameToContainerPathMap.get(packageName);
  if (containerPath == null)   return null;
  X509Certificate verifiedCertificate;
  verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
  if (verifiedCertificate == null) {
    boolean isCertificateDownloadSuccessful=downloadCertificateRemotelyViaHttps(packageName);
    if (isCertificateDownloadSuccessful) {
      verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
    }
  }
  if (verifiedCertificate != null) {
    int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
    String extension=containerPath.substring(extensionIndex);
    boolean signatureCheckIsSuccessful=false;
    if (extension.equals(""String_Node_Str"")) {
      try {
        Signature mSignature=Signature.getInstance(verifiedCertificate.getSigAlgName());
        FileInputStream containerFIS=null;
        BufferedInputStream containerBufIn=null;
        try {
          containerFIS=new FileInputStream(containerPath);
          containerBufIn=new BufferedInputStream(containerFIS);
          byte[] buffer=new byte[1024];
          int len;
          while (containerBufIn.available() != 0) {
            len=containerBufIn.read(buffer);
            mSignature.update(buffer,0,len);
          }
          ;
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
 finally {
          if (containerBufIn != null) {
            try {
              containerBufIn.close();
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
        mSignature.initVerify(verifiedCertificate);
        android.content.pm.Signature apkSignature=mPackageManager.getPackageArchiveInfo(containerPath,PackageManager.GET_SIGNATURES).signatures[0];
        signatureCheckIsSuccessful=mSignature.verify(apkSignature.toByteArray());
      }
 catch (      NoSuchAlgorithmException e) {
        e.printStackTrace();
      }
catch (      InvalidKeyException e) {
        e.printStackTrace();
      }
catch (      SignatureException e) {
        e.printStackTrace();
      }
    }
 else {
      if (extension.equals(""String_Node_Str"")) {
        JarFile jarContainerToVerify=null;
        try {
          jarContainerToVerify=new JarFile(containerPath);
          verifyJARContainer(jarContainerToVerify,verifiedCertificate);
          signatureCheckIsSuccessful=true;
        }
 catch (        IOException e) {
          signatureCheckIsSuccessful=false;
        }
 finally {
          if (jarContainerToVerify != null)           try {
            jarContainerToVerify.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
    }
    if (signatureCheckIsSuccessful) {
      return super.loadClass(className);
    }
    File containerToRemove=new File(containerPath);
    containerToRemove.delete();
    packageNameToContainerPathMap.remove(packageName);
    return null;
  }
  return null;
}","@Override public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap == null)   return null;
  if (hasBeenWipedOut)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath=packageNameToContainerPathMap.get(packageName);
  if (containerPath == null)   return null;
  X509Certificate verifiedCertificate;
  verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
  if (verifiedCertificate == null) {
    boolean isCertificateDownloadSuccessful=downloadCertificateRemotelyViaHttps(packageName);
    if (isCertificateDownloadSuccessful) {
      verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
    }
  }
  if (verifiedCertificate != null) {
    int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
    String extension=containerPath.substring(extensionIndex);
    boolean signatureCheckIsSuccessful=false;
    if (extension.equals(""String_Node_Str"")) {
      try {
        Signature mSignature=Signature.getInstance(verifiedCertificate.getSigAlgName());
        mSignature.initVerify(verifiedCertificate);
        FileInputStream containerFIS=null;
        BufferedInputStream containerBufIn=null;
        try {
          containerFIS=new FileInputStream(containerPath);
          containerBufIn=new BufferedInputStream(containerFIS);
          byte[] buffer=new byte[1024];
          int len;
          while (containerBufIn.available() != 0) {
            len=containerBufIn.read(buffer);
            mSignature.update(buffer,0,len);
          }
          ;
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
 finally {
          if (containerBufIn != null) {
            try {
              containerBufIn.close();
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
        android.content.pm.Signature apkSignature=mPackageManager.getPackageArchiveInfo(containerPath,PackageManager.GET_SIGNATURES).signatures[0];
        signatureCheckIsSuccessful=mSignature.verify(apkSignature.toByteArray());
      }
 catch (      NoSuchAlgorithmException e) {
        e.printStackTrace();
      }
catch (      InvalidKeyException e) {
        e.printStackTrace();
      }
catch (      SignatureException e) {
        e.printStackTrace();
      }
    }
 else {
      if (extension.equals(""String_Node_Str"")) {
        JarFile jarContainerToVerify=null;
        try {
          jarContainerToVerify=new JarFile(containerPath);
          verifyJARContainer(jarContainerToVerify,verifiedCertificate);
          signatureCheckIsSuccessful=true;
        }
 catch (        IOException e) {
          signatureCheckIsSuccessful=false;
        }
 finally {
          if (jarContainerToVerify != null)           try {
            jarContainerToVerify.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
    }
    if (signatureCheckIsSuccessful) {
      return super.loadClass(className);
    }
    File containerToRemove=new File(containerPath);
    containerToRemove.delete();
    packageNameToContainerPathMap.remove(packageName);
    return null;
  }
  return null;
}"
93792,"/** 
 * This method is used to set up and manage a DexClassLoader component in  order to retrieve a new activity from an .apk, which has been  already downloaded and installed on the mobile device. If everything works fine, it will instantiate the main activity of  this .apk.
 */
protected void setUpDexClassLoader(){
  if (!effectiveDexClassLoader)   return;
  Log.i(TAG_MAIN,""String_Node_Str"");
  File dexOutputDir=getDir(""String_Node_Str"",MODE_PRIVATE);
  DexClassLoader mDexClassLoader=new DexClassLoader(exampleTestAPKPath,dexOutputDir.getAbsolutePath(),null,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mDexClassLoader.loadClass(classNameInAPK);
    final Activity NasaDailyActivity=(Activity)loadedClass.newInstance();
    Log.i(TAG_MAIN,""String_Node_Str"" + loadedClass.getSimpleName() + ""String_Node_Str""+ exampleTestAPKPath.toString());
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"" + NasaDailyActivity.getComponentName(),Toast.LENGTH_SHORT).show();
      }
    }
);
  }
 catch (  ClassNotFoundException e) {
    Log.e(TAG_MAIN,""String_Node_Str"");
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    e.printStackTrace();
  }
catch (  ActivityNotFoundException e) {
    Log.e(TAG_MAIN,""String_Node_Str"");
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
}","/** 
 * This method is used to set up and manage a DexClassLoader component in  order to retrieve a new activity from an .apk, which has been  already downloaded and installed on the mobile device. If everything works fine, it will instantiate the main activity of  this .apk.
 */
protected void setUpDexClassLoader(){
  if (!effectiveDexClassLoader)   return;
  Log.i(TAG_MAIN,""String_Node_Str"");
  File dexOutputDir=getDir(""String_Node_Str"",MODE_PRIVATE);
  DexClassLoader mDexClassLoader=new DexClassLoader(exampleTestAPKPath,dexOutputDir.getAbsolutePath(),null,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mDexClassLoader.loadClass(classNameInAPK);
    final Activity NasaDailyActivity=(Activity)loadedClass.newInstance();
    Log.i(TAG_MAIN,""String_Node_Str"" + loadedClass.getSimpleName() + ""String_Node_Str""+ exampleTestAPKPath.toString());
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"" + NasaDailyActivity.getClass().getName(),Toast.LENGTH_SHORT).show();
      }
    }
);
  }
 catch (  ClassNotFoundException e) {
    Log.e(TAG_MAIN,""String_Node_Str"");
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    e.printStackTrace();
  }
catch (  ActivityNotFoundException e) {
    Log.e(TAG_MAIN,""String_Node_Str"");
    toastHandler.post(new Runnable(){
      @Override public void run(){
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
}"
93793,"protected void setUpSecureDexClassLoader(){
  if (!effectiveSecureDexClassLoader)   return;
  Log.i(TAG_MAIN,""String_Node_Str"");
  SecureLoaderFactory mSecureLoaderFactory=new SecureLoaderFactory(this);
  SecureDexClassLoader mSecureDexClassLoader;
  String listAPKPaths=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"" + exampleTestAPKPath+ ""String_Node_Str"";
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,null,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  Map<String,String> packageNamesToCertMap=new HashMap<String,String>();
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(exampleTestAPKPath,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  Log.i(TAG_MAIN,""String_Node_Str"");
  listAPKPaths=""String_Node_Str"" + exampleSignedAPKPath;
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Activity NasaDailyActivity=(Activity)loadedClass.newInstance();
      Log.i(TAG_MAIN,""String_Node_Str"" + NasaDailyActivity.getLocalClassName() + ""String_Node_Str""+ NasaDailyActivity.getPackageResourcePath()+ ""String_Node_Str"");
    }
 else {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
}","protected void setUpSecureDexClassLoader(){
  if (!effectiveSecureDexClassLoader)   return;
  Log.i(TAG_MAIN,""String_Node_Str"");
  SecureLoaderFactory mSecureLoaderFactory=new SecureLoaderFactory(this);
  SecureDexClassLoader mSecureDexClassLoader;
  String listAPKPaths=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"" + exampleTestAPKPath;
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,null,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  mSecureDexClassLoader.wipeOutPrivateAppCachedData(true,true);
  Map<String,String> packageNamesToCertMap=new HashMap<String,String>();
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  packageNamesToCertMap.put(""String_Node_Str"",""String_Node_Str"");
  Log.i(TAG_MAIN,""String_Node_Str"");
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(exampleTestAPKPath,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
 else {
      Log.i(TAG_MAIN,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
  Log.i(TAG_MAIN,""String_Node_Str"");
  listAPKPaths=""String_Node_Str"" + exampleSignedAPKPath;
  mSecureDexClassLoader=mSecureLoaderFactory.createDexClassLoader(listAPKPaths,null,packageNamesToCertMap,ClassLoader.getSystemClassLoader().getParent());
  try {
    Class<?> loadedClass=mSecureDexClassLoader.loadClass(classNameInAPK);
    if (loadedClass != null) {
      Activity NasaDailyActivity=(Activity)loadedClass.newInstance();
      Log.i(TAG_MAIN,""String_Node_Str"" + NasaDailyActivity.getLocalClassName() + ""String_Node_Str""+ NasaDailyActivity.getPackageResourcePath()+ ""String_Node_Str"");
    }
 else {
      Log.w(TAG_MAIN,""String_Node_Str"");
    }
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
    Log.w(TAG_MAIN,""String_Node_Str"");
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
  mSecureDexClassLoader.wipeOutPrivateAppCachedData(false,true);
}"
93794,"@Override public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap == null)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath=packageNameToContainerPathMap.get(packageName);
  if (containerPath == null)   return null;
  X509Certificate verifiedCertificate;
  verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
  if (verifiedCertificate == null) {
    boolean isCertificateDownloadSuccessful=downloadCertificateRemotelyViaHttps(packageName);
    if (isCertificateDownloadSuccessful) {
      verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
    }
  }
  if (verifiedCertificate != null) {
    try {
      int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
      String extension=containerPath.substring(extensionIndex);
      boolean signatureCheckIsSuccessful=false;
      if (extension.equals(""String_Node_Str"")) {
        Signature mSignature=Signature.getInstance(verifiedCertificate.getSigAlgName());
        FileInputStream containerFIS=null;
        BufferedInputStream containerBufIn=null;
        try {
          containerFIS=new FileInputStream(containerPath);
          containerBufIn=new BufferedInputStream(containerFIS);
          byte[] buffer=new byte[1024];
          int len;
          while (containerBufIn.available() != 0) {
            len=containerBufIn.read(buffer);
            mSignature.update(buffer,0,len);
          }
          ;
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
 finally {
          if (containerBufIn != null) {
            try {
              containerBufIn.close();
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
        mSignature.initVerify(verifiedCertificate);
        android.content.pm.Signature apkSignature=mPackageManager.getPackageArchiveInfo(containerPath,PackageManager.GET_SIGNATURES).signatures[0];
        signatureCheckIsSuccessful=mSignature.verify(apkSignature.toByteArray());
      }
 else {
        if (extension.equals(""String_Node_Str"")) {
          JarFile jarContainerToVerify=null;
          try {
            jarContainerToVerify=new JarFile(containerPath);
            verifyJARContainer(jarContainerToVerify,verifiedCertificate);
            signatureCheckIsSuccessful=true;
          }
 catch (          IOException e) {
            signatureCheckIsSuccessful=false;
          }
 finally {
            if (jarContainerToVerify != null)             try {
              jarContainerToVerify.close();
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
      }
      if (signatureCheckIsSuccessful) {
        return super.loadClass(className);
      }
      File containerToRemove=new File(containerPath);
      containerToRemove.delete();
      packageNameToContainerPathMap.remove(packageName);
      return null;
    }
 catch (    NoSuchAlgorithmException e) {
      e.printStackTrace();
    }
catch (    InvalidKeyException e) {
      e.printStackTrace();
    }
catch (    SignatureException e) {
      e.printStackTrace();
    }
  }
  return null;
}","@Override public Class<?> loadClass(String className) throws ClassNotFoundException {
  if (packageNameToCertificateMap == null)   return null;
  String packageName=className.substring(0,className.lastIndexOf('.'));
  String containerPath=packageNameToContainerPathMap.get(packageName);
  if (containerPath == null)   return null;
  X509Certificate verifiedCertificate;
  verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
  if (verifiedCertificate == null) {
    boolean isCertificateDownloadSuccessful=downloadCertificateRemotelyViaHttps(packageName);
    if (isCertificateDownloadSuccessful) {
      verifiedCertificate=importCertificateFromAppPrivateDir(packageName);
    }
  }
  if (verifiedCertificate != null) {
    int extensionIndex=containerPath.lastIndexOf(""String_Node_Str"");
    String extension=containerPath.substring(extensionIndex);
    boolean signatureCheckIsSuccessful=false;
    if (extension.equals(""String_Node_Str"")) {
      try {
        Signature mSignature=Signature.getInstance(verifiedCertificate.getSigAlgName());
        FileInputStream containerFIS=null;
        BufferedInputStream containerBufIn=null;
        try {
          containerFIS=new FileInputStream(containerPath);
          containerBufIn=new BufferedInputStream(containerFIS);
          byte[] buffer=new byte[1024];
          int len;
          while (containerBufIn.available() != 0) {
            len=containerBufIn.read(buffer);
            mSignature.update(buffer,0,len);
          }
          ;
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
 finally {
          if (containerBufIn != null) {
            try {
              containerBufIn.close();
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
        mSignature.initVerify(verifiedCertificate);
        android.content.pm.Signature apkSignature=mPackageManager.getPackageArchiveInfo(containerPath,PackageManager.GET_SIGNATURES).signatures[0];
        signatureCheckIsSuccessful=mSignature.verify(apkSignature.toByteArray());
      }
 catch (      NoSuchAlgorithmException e) {
        e.printStackTrace();
      }
catch (      InvalidKeyException e) {
        e.printStackTrace();
      }
catch (      SignatureException e) {
        e.printStackTrace();
      }
    }
 else {
      if (extension.equals(""String_Node_Str"")) {
        JarFile jarContainerToVerify=null;
        try {
          jarContainerToVerify=new JarFile(containerPath);
          verifyJARContainer(jarContainerToVerify,verifiedCertificate);
          signatureCheckIsSuccessful=true;
        }
 catch (        IOException e) {
          signatureCheckIsSuccessful=false;
        }
 finally {
          if (jarContainerToVerify != null)           try {
            jarContainerToVerify.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
    }
    if (signatureCheckIsSuccessful) {
      return super.loadClass(className);
    }
    File containerToRemove=new File(containerPath);
    containerToRemove.delete();
    packageNameToContainerPathMap.remove(packageName);
    return null;
  }
  return null;
}"
93795,"private FileDownloader(ContextWrapper parentContextWrapper){
  handler=new Handler();
  mContextWrapper=parentContextWrapper;
  mConnectivityManager=(ConnectivityManager)parentContextWrapper.getSystemService(Context.CONNECTIVITY_SERVICE);
}","FileDownloader(ContextWrapper parentContextWrapper){
  handler=new Handler();
  mContextWrapper=parentContextWrapper;
  mConnectivityManager=(ConnectivityManager)parentContextWrapper.getSystemService(Context.CONNECTIVITY_SERVICE);
}"
93796,"private boolean downloadCertificateRemotelyViaHttps(String packageName){
  String urlString=packageNameToCertificateMap.get(packageName);
  URL certificateRemoteURL;
  try {
    certificateRemoteURL=new URL(urlString);
  }
 catch (  MalformedURLException e) {
    return false;
  }
  String localCertPath=certificateFolder.getAbsolutePath() + ""String_Node_Str"" + packageName+ ""String_Node_Str"";
  return SecureLoaderFactory.FileDownloader.downloadRemoteUrl(certificateRemoteURL,localCertPath);
}","private boolean downloadCertificateRemotelyViaHttps(String packageName){
  String urlString=packageNameToCertificateMap.get(packageName);
  URL certificateRemoteURL;
  try {
    certificateRemoteURL=new URL(urlString);
  }
 catch (  MalformedURLException e) {
    return false;
  }
  String localCertPath=certificateFolder.getAbsolutePath() + ""String_Node_Str"" + packageName+ ""String_Node_Str"";
  return mFileDownloader.downloadRemoteUrl(certificateRemoteURL,localCertPath);
}"
93797,"SecureDexClassLoader(String dexPath,String optimizedDirectory,String libraryPath,ClassLoader parent,ContextWrapper parentContextWrapper){
  super(dexPath,optimizedDirectory,libraryPath,parent);
  certificateFolder=parentContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
  mPackageManager=parentContextWrapper.getPackageManager();
  packageNameToCertificateMap=null;
  packageNameToContainerPathMap=new HashMap<String,String>();
  String[] pathStrings=dexPath.split(Pattern.quote(File.pathSeparator));
  for (  String currentPath : pathStrings) {
    String packageName=getPackageNameFromContainerPath(currentPath);
    if (packageName != null) {
      String previousPath=packageNameToContainerPathMap.put(packageName,currentPath);
      if (previousPath != null) {
        Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + packageName + ""String_Node_Str""+ previousPath+ ""String_Node_Str""+ currentPath+ ""String_Node_Str"");
      }
    }
  }
}","SecureDexClassLoader(String dexPath,String optimizedDirectory,String libraryPath,ClassLoader parent,ContextWrapper parentContextWrapper){
  super(dexPath,optimizedDirectory,libraryPath,parent);
  certificateFolder=parentContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
  mPackageManager=parentContextWrapper.getPackageManager();
  mFileDownloader=new FileDownloader(parentContextWrapper);
  packageNameToCertificateMap=null;
  packageNameToContainerPathMap=new HashMap<String,String>();
  String[] pathStrings=dexPath.split(Pattern.quote(File.pathSeparator));
  for (  String currentPath : pathStrings) {
    String packageName=getPackageNameFromContainerPath(currentPath);
    if (packageName != null) {
      String previousPath=packageNameToContainerPathMap.put(packageName,currentPath);
      if (previousPath != null) {
        Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + packageName + ""String_Node_Str""+ previousPath+ ""String_Node_Str""+ currentPath+ ""String_Node_Str"");
      }
    }
  }
}"
93798,"private String downloadContainerIntoFolder(String urlPath,File resOutputDir){
  if (urlPath == null)   return null;
  if (resOutputDir == null || !resOutputDir.exists())   return null;
  if (!resOutputDir.isDirectory() || !resOutputDir.canRead() || !resOutputDir.canWrite())   return null;
  URL url;
  try {
    url=new URL(urlPath);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    return null;
  }
  if (!url.getProtocol().equals(""String_Node_Str"") && !url.getProtocol().equals(""String_Node_Str""))   return null;
  int finalSeparatorIndex=url.getPath().lastIndexOf(""String_Node_Str"");
  String containerName=url.getFile().substring(finalSeparatorIndex);
  if (containerName == null || containerName.isEmpty())   return null;
  int extensionIndex=containerName.lastIndexOf(""String_Node_Str"");
  String extension=containerName.substring(extensionIndex);
  if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str""))   return null;
  File checkFile=new File(resOutputDir.getAbsolutePath() + containerName);
  String finalContainerName;
  if (checkFile.exists()) {
    int currentIndex=0;
    do {
      currentIndex++;
      finalContainerName=containerName.substring(0,extensionIndex) + currentIndex + extension;
      checkFile=new File(resOutputDir.getAbsolutePath() + finalContainerName);
    }
 while (checkFile.exists());
  }
 else {
    finalContainerName=containerName;
  }
  String localContainerPath=resOutputDir.getAbsolutePath() + finalContainerName;
  boolean isDownloadSuccessful=FileDownloader.downloadRemoteUrl(url,localContainerPath);
  if (isDownloadSuccessful)   return localContainerPath;
  return null;
}","private String downloadContainerIntoFolder(String urlPath,File resOutputDir){
  if (urlPath == null)   return null;
  if (resOutputDir == null || !resOutputDir.exists())   return null;
  if (!resOutputDir.isDirectory() || !resOutputDir.canRead() || !resOutputDir.canWrite())   return null;
  URL url;
  try {
    url=new URL(urlPath);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    return null;
  }
  if (!url.getProtocol().equals(""String_Node_Str"") && !url.getProtocol().equals(""String_Node_Str""))   return null;
  int finalSeparatorIndex=url.getPath().lastIndexOf(""String_Node_Str"");
  String containerName=url.getFile().substring(finalSeparatorIndex);
  if (containerName == null || containerName.isEmpty())   return null;
  int extensionIndex=containerName.lastIndexOf(""String_Node_Str"");
  String extension=containerName.substring(extensionIndex);
  if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str""))   return null;
  File checkFile=new File(resOutputDir.getAbsolutePath() + containerName);
  String finalContainerName;
  if (checkFile.exists()) {
    int currentIndex=0;
    do {
      currentIndex++;
      finalContainerName=containerName.substring(0,extensionIndex) + currentIndex + extension;
      checkFile=new File(resOutputDir.getAbsolutePath() + finalContainerName);
    }
 while (checkFile.exists());
  }
 else {
    finalContainerName=containerName;
  }
  String localContainerPath=resOutputDir.getAbsolutePath() + finalContainerName;
  boolean isDownloadSuccessful=mFileDownloader.downloadRemoteUrl(url,localContainerPath);
  if (isDownloadSuccessful)   return localContainerPath;
  return null;
}"
93799,"/** 
 * Creates a   {@code SecureLoaderFactory} used to check and generate instances from secure dynamic code loader classes. It requires a  {@link ContextWrapper} (i.e. the launching activity) which should be used to manage and retrieve internal directories  of the application.
 * @param parentContextWrapper The content wrapper coming from the launching Activity
 */
public SecureLoaderFactory(ContextWrapper parentContextWrapper){
  mContextWrapper=parentContextWrapper;
  FileDownloader=FileDownloader.getInstance(mContextWrapper);
}","/** 
 * Creates a   {@code SecureLoaderFactory} used to check and generate instances from secure dynamic code loader classes. It requires a  {@link ContextWrapper} (i.e. the launching activity) which should be used to manage and retrieve internal directories  of the application.
 * @param parentContextWrapper The content wrapper coming from the launching Activity
 */
public SecureLoaderFactory(ContextWrapper parentContextWrapper){
  mContextWrapper=parentContextWrapper;
  mFileDownloader=new FileDownloader(mContextWrapper);
}"
93800,"static FileDownloader getInstance(ContextWrapper parentContextWrapper){
  if (instance == null) {
    instance=new FileDownloader(parentContextWrapper);
  }
  return instance;
}","FileDownloader getInstance(ContextWrapper parentContextWrapper){
  if (instance == null) {
    instance=new FileDownloader(parentContextWrapper);
  }
  return instance;
}"
93801,"boolean downloadRemoteUrl(final URL remoteURL,final String localURI){
  activeNetworkInfo=mConnectivityManager.getActiveNetworkInfo();
  if (activeNetworkInfo == null || !activeNetworkInfo.isConnected())   return false;
  dialog=ProgressDialog.show(mContextWrapper,""String_Node_Str"",""String_Node_Str"");
  Thread dataThread=new Thread(){
    @Override public void run(){
      HttpURLConnection urlConnection=null;
      InputStream inputStream=null;
      OutputStream outputStream=null;
      try {
        if (remoteURL.getProtocol().equals(""String_Node_Str"")) {
          urlConnection=(HttpsURLConnection)remoteURL.openConnection();
        }
 else {
          urlConnection=(HttpURLConnection)remoteURL.openConnection();
        }
        Log.d(TAG_FILE_DOWNLOADER,""String_Node_Str"" + remoteURL.toString());
        inputStream=new BufferedInputStream(urlConnection.getInputStream());
        outputStream=new FileOutputStream(localURI);
        int read=0;
        byte[] bytes=new byte[1024];
        while ((read=inputStream.read(bytes)) > 0) {
          outputStream.write(bytes,0,read);
        }
        Log.i(TAG_FILE_DOWNLOADER,""String_Node_Str"" + localURI);
      }
 catch (      IOException e) {
      }
 finally {
        Log.i(TAG_FILE_DOWNLOADER,""String_Node_Str"");
        if (urlConnection != null)         ((HttpURLConnection)urlConnection).disconnect();
        if (inputStream != null) {
          try {
            inputStream.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
        if (outputStream != null) {
          try {
            outputStream.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
      handler.post(new Runnable(){
        @Override public void run(){
          dialog.dismiss();
        }
      }
);
    }
  }
;
  dataThread.start();
  try {
    dataThread.join();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    return false;
  }
  File fileAtLocalURI=new File(localURI);
  if (fileAtLocalURI.exists() && fileAtLocalURI.length() > 0)   return true;
 else   return false;
}","boolean downloadRemoteUrl(final URL remoteURL,final String localURI){
  activeNetworkInfo=mConnectivityManager.getActiveNetworkInfo();
  if (activeNetworkInfo == null || !activeNetworkInfo.isConnected()) {
    Log.w(TAG_FILE_DOWNLOADER,""String_Node_Str"");
    return false;
  }
  dialog=ProgressDialog.show(mContextWrapper,""String_Node_Str"",""String_Node_Str"");
  Thread dataThread=new Thread(){
    @Override public void run(){
      HttpURLConnection urlConnection=null;
      InputStream inputStream=null;
      OutputStream outputStream=null;
      try {
        if (remoteURL.getProtocol().equals(""String_Node_Str"")) {
          urlConnection=(HttpsURLConnection)remoteURL.openConnection();
        }
 else {
          urlConnection=(HttpURLConnection)remoteURL.openConnection();
        }
        Log.d(TAG_FILE_DOWNLOADER,""String_Node_Str"" + remoteURL.toString());
        inputStream=new BufferedInputStream(urlConnection.getInputStream());
        outputStream=new FileOutputStream(localURI);
        int read=0;
        byte[] bytes=new byte[1024];
        while ((read=inputStream.read(bytes)) > 0) {
          outputStream.write(bytes,0,read);
        }
        Log.i(TAG_FILE_DOWNLOADER,""String_Node_Str"" + localURI);
      }
 catch (      IOException e) {
      }
 finally {
        Log.d(TAG_FILE_DOWNLOADER,""String_Node_Str"");
        if (urlConnection != null)         ((HttpURLConnection)urlConnection).disconnect();
        if (inputStream != null) {
          try {
            inputStream.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
        if (outputStream != null) {
          try {
            outputStream.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
      handler.post(new Runnable(){
        @Override public void run(){
          dialog.dismiss();
        }
      }
);
    }
  }
;
  dataThread.start();
  try {
    dataThread.join();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    return false;
  }
  File fileAtLocalURI=new File(localURI);
  if (fileAtLocalURI.exists() && fileAtLocalURI.length() > 0)   return true;
 else   return false;
}"
93802,"private boolean downloadCertificateRemotelyViaHttps(String packageName){
  NetworkInfo activeNetworkInfo=mConnectivityManager.getActiveNetworkInfo();
  if (activeNetworkInfo != null && activeNetworkInfo.isConnected()) {
    String urlString=packageNameToCertificateMap.get(packageName);
    HttpsURLConnection urlConnection=null;
    InputStream inputStream=null;
    OutputStream outputStream=null;
    try {
      URL certificateURL=new URL(urlString);
      urlConnection=(HttpsURLConnection)certificateURL.openConnection();
      if (urlConnection.getResponseCode() == HttpsURLConnection.HTTP_OK) {
        Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"");
        inputStream=urlConnection.getInputStream();
        String downloadPath=certificateFolder.getAbsolutePath() + ""String_Node_Str"" + packageName+ ""String_Node_Str"";
        outputStream=new FileOutputStream(downloadPath);
        int read=0;
        byte[] bytes=new byte[1024];
        while ((read=inputStream.read(bytes)) > 0) {
          outputStream.write(bytes,0,read);
        }
        Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + downloadPath);
      }
    }
 catch (    MalformedURLException e) {
      return false;
    }
catch (    IOException e) {
      return false;
    }
 finally {
      Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"");
      if (urlConnection != null)       urlConnection.disconnect();
      if (inputStream != null) {
        try {
          inputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      if (outputStream != null) {
        try {
          outputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
 else       return false;
    }
    return true;
  }
  Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"");
  return false;
}","private boolean downloadCertificateRemotelyViaHttps(String packageName){
  String urlString=packageNameToCertificateMap.get(packageName);
  URL certificateRemoteURL;
  try {
    certificateRemoteURL=new URL(urlString);
  }
 catch (  MalformedURLException e) {
    return false;
  }
  String localCertPath=certificateFolder.getAbsolutePath() + ""String_Node_Str"" + packageName+ ""String_Node_Str"";
  return SecureLoaderFactory.FileDownloader.downloadRemoteUrl(certificateRemoteURL,localCertPath);
}"
93803,"SecureDexClassLoader(String dexPath,String optimizedDirectory,String libraryPath,ClassLoader parent,ContextWrapper parentContextWrapper){
  super(dexPath,optimizedDirectory,libraryPath,parent);
  certificateFolder=parentContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
  mConnectivityManager=(ConnectivityManager)parentContextWrapper.getSystemService(Context.CONNECTIVITY_SERVICE);
  mPackageManager=parentContextWrapper.getPackageManager();
  packageNameToCertificateMap=null;
  packageNameToContainerPathMap=new HashMap<String,String>();
  String[] pathStrings=dexPath.split(Pattern.quote(File.pathSeparator));
  for (  String currentPath : pathStrings) {
    String packageName=getPackageNameFromContainerPath(currentPath);
    if (packageName != null) {
      String previousPath=packageNameToContainerPathMap.put(packageName,currentPath);
      if (previousPath != null) {
        Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + packageName + ""String_Node_Str""+ previousPath+ ""String_Node_Str""+ currentPath+ ""String_Node_Str"");
      }
    }
  }
}","SecureDexClassLoader(String dexPath,String optimizedDirectory,String libraryPath,ClassLoader parent,ContextWrapper parentContextWrapper){
  super(dexPath,optimizedDirectory,libraryPath,parent);
  certificateFolder=parentContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
  mPackageManager=parentContextWrapper.getPackageManager();
  packageNameToCertificateMap=null;
  packageNameToContainerPathMap=new HashMap<String,String>();
  String[] pathStrings=dexPath.split(Pattern.quote(File.pathSeparator));
  for (  String currentPath : pathStrings) {
    String packageName=getPackageNameFromContainerPath(currentPath);
    if (packageName != null) {
      String previousPath=packageNameToContainerPathMap.put(packageName,currentPath);
      if (previousPath != null) {
        Log.w(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + packageName + ""String_Node_Str""+ previousPath+ ""String_Node_Str""+ currentPath+ ""String_Node_Str"");
      }
    }
  }
}"
93804,"void setCertificateLocationMap(Map<String,String> extPackageNameToCertificateMap){
  if (extPackageNameToCertificateMap == null)   packageNameToCertificateMap=new HashMap<String,String>();
 else   packageNameToCertificateMap=extPackageNameToCertificateMap;
  Iterator<String> packageNameIterator=packageNameToContainerPathMap.keySet().iterator();
  while (packageNameIterator.hasNext()) {
    String currentPackageName=packageNameIterator.next();
    if (packageNameToCertificateMap.get(currentPackageName) == null) {
      String certificateRemoteURL=revertPackageNameToURL(currentPackageName);
      packageNameToCertificateMap.put(currentPackageName,certificateRemoteURL);
      Log.i(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + currentPackageName + ""String_Node_Str""+ certificateRemoteURL+ ""String_Node_Str"");
    }
  }
}","void setCertificateLocationMap(Map<String,String> extPackageNameToCertificateMap){
  if (extPackageNameToCertificateMap == null)   packageNameToCertificateMap=new HashMap<String,String>();
 else   packageNameToCertificateMap=extPackageNameToCertificateMap;
  Iterator<String> packageNameIterator=packageNameToContainerPathMap.keySet().iterator();
  while (packageNameIterator.hasNext()) {
    String currentPackageName=packageNameIterator.next();
    if (packageNameToCertificateMap.get(currentPackageName) == null) {
      String certificateRemoteURL=revertPackageNameToURL(currentPackageName);
      packageNameToCertificateMap.put(currentPackageName,certificateRemoteURL);
      Log.d(TAG_SECURE_DEX_CLASS_LOADER,""String_Node_Str"" + currentPackageName + ""String_Node_Str""+ certificateRemoteURL+ ""String_Node_Str"");
    }
  }
}"
93805,"private String downloadContainerIntoFolder(String urlPath,File resOutputDir){
  if (urlPath == null)   return null;
  if (resOutputDir == null || !resOutputDir.exists())   return null;
  if (!resOutputDir.isDirectory() || !resOutputDir.canRead() || !resOutputDir.canWrite())   return null;
  URL url;
  try {
    url=new URL(urlPath);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    return null;
  }
  if (!url.getProtocol().equals(""String_Node_Str"") && !url.getProtocol().equals(""String_Node_Str""))   return null;
  int finalSeparatorIndex=url.getPath().lastIndexOf(""String_Node_Str"");
  String containerName=url.getFile().substring(finalSeparatorIndex);
  if (containerName == null || containerName.isEmpty())   return null;
  int extensionIndex=containerName.lastIndexOf(""String_Node_Str"");
  String extension=containerName.substring(extensionIndex);
  if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str""))   return null;
  File checkFile=new File(resOutputDir.getAbsolutePath() + containerName);
  String finalContainerName;
  if (checkFile.exists()) {
    int currentIndex=0;
    do {
      currentIndex++;
      finalContainerName=containerName.substring(0,extensionIndex) + currentIndex + extension;
      checkFile=new File(resOutputDir.getAbsolutePath() + finalContainerName);
    }
 while (checkFile.exists());
  }
 else {
    finalContainerName=containerName;
  }
  HttpURLConnection urlConnection=null;
  InputStream inputStream=null;
  OutputStream outputStream=null;
  String localContainerPath=resOutputDir.getAbsolutePath() + finalContainerName;
  activeNetworkInfo=mConnectivityManager.getActiveNetworkInfo();
  if (activeNetworkInfo != null && activeNetworkInfo.isConnected()) {
    try {
      if (url.getProtocol().equals(""String_Node_Str"")) {
        urlConnection=(HttpsURLConnection)url.openConnection();
      }
 else {
        urlConnection=(HttpURLConnection)url.openConnection();
      }
      Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + url.toString());
      inputStream=new BufferedInputStream(urlConnection.getInputStream());
      outputStream=new FileOutputStream(localContainerPath);
      int read=0;
      byte[] bytes=new byte[1024];
      while ((read=inputStream.read(bytes)) > 0) {
        outputStream.write(bytes,0,read);
      }
      Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + localContainerPath);
    }
 catch (    IOException e) {
      return null;
    }
 finally {
      Log.i(TAG_SECURE_FACTORY,""String_Node_Str"");
      if (urlConnection != null)       ((HttpURLConnection)urlConnection).disconnect();
      if (inputStream != null) {
        try {
          inputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      if (outputStream != null) {
        try {
          outputStream.close();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
 else {
        return null;
      }
    }
    return localContainerPath;
  }
  Log.i(TAG_SECURE_FACTORY,""String_Node_Str"");
  return null;
}","private String downloadContainerIntoFolder(String urlPath,File resOutputDir){
  if (urlPath == null)   return null;
  if (resOutputDir == null || !resOutputDir.exists())   return null;
  if (!resOutputDir.isDirectory() || !resOutputDir.canRead() || !resOutputDir.canWrite())   return null;
  URL url;
  try {
    url=new URL(urlPath);
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    return null;
  }
  if (!url.getProtocol().equals(""String_Node_Str"") && !url.getProtocol().equals(""String_Node_Str""))   return null;
  int finalSeparatorIndex=url.getPath().lastIndexOf(""String_Node_Str"");
  String containerName=url.getFile().substring(finalSeparatorIndex);
  if (containerName == null || containerName.isEmpty())   return null;
  int extensionIndex=containerName.lastIndexOf(""String_Node_Str"");
  String extension=containerName.substring(extensionIndex);
  if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str""))   return null;
  File checkFile=new File(resOutputDir.getAbsolutePath() + containerName);
  String finalContainerName;
  if (checkFile.exists()) {
    int currentIndex=0;
    do {
      currentIndex++;
      finalContainerName=containerName.substring(0,extensionIndex) + currentIndex + extension;
      checkFile=new File(resOutputDir.getAbsolutePath() + finalContainerName);
    }
 while (checkFile.exists());
  }
 else {
    finalContainerName=containerName;
  }
  String localContainerPath=resOutputDir.getAbsolutePath() + finalContainerName;
  boolean isDownloadSuccessful=FileDownloader.downloadRemoteUrl(url,localContainerPath);
  if (isDownloadSuccessful)   return localContainerPath;
  return null;
}"
93806,"/** 
 * Creates a   {@code SecureLoaderFactory} used to check and generate instances from secure dynamic code loader classes. It requires a  {@link ContextWrapper} (i.e. the launching activity) which should be used to manage and retrieve internal directories  of the application.
 * @param parentContextWrapper The content wrapper coming from the launching Activity
 */
public SecureLoaderFactory(ContextWrapper parentContextWrapper){
  mContextWrapper=parentContextWrapper;
  mConnectivityManager=(ConnectivityManager)parentContextWrapper.getSystemService(Context.CONNECTIVITY_SERVICE);
}","/** 
 * Creates a   {@code SecureLoaderFactory} used to check and generate instances from secure dynamic code loader classes. It requires a  {@link ContextWrapper} (i.e. the launching activity) which should be used to manage and retrieve internal directories  of the application.
 * @param parentContextWrapper The content wrapper coming from the launching Activity
 */
public SecureLoaderFactory(ContextWrapper parentContextWrapper){
  mContextWrapper=parentContextWrapper;
  FileDownloader=FileDownloader.getInstance(mContextWrapper);
}"
93807,"/** 
 * Creates a   {@link SecureDexClassLoader} that finds interpreted and native code in a set ofprovided locations (either local or remote via HTTP or HTTPS) in dexPath. Interpreted classes are found in a set of DEX files contained in Jar or Apk files and  stored into an application-private, writable directory. Before executing one of these classes the signature of the target class is  verified against the certificate associated with its package name. Certificates location are provided by filling appropriately  {@link packageNameToCertificateMap}}; each package name must be linked with the remote location of the certificate that should be used to validate all the classes of that package. It's important  that each one of these locations uses HTTPS as its protocol; otherwise this  choice will be enforced! If a class package name do not match any of the provided entries in the map,  certificate location will be constructed by simply reverting package name and  transforming it into a web-based URL using HTTPS. Note that this method returns null if no matching Jar or Apk file is found at the provided dexPath parameter; otherwise a   {@link SecureDexClassLoader} instance is returned.Dynamic class loading with the returned  {@link SecureDexClassLoader} will fail whetherat least one of these conditions is not accomplished: target class is not found in dexPath or is in a missing remote container (i.e. Internet connectivity is not present), missing or invalid (i.e. expired) certificate is associated with the package name of the target class, target class signature check fails against the associated certificate.
 * @param dexPath the list of jar/apk files containing classes and resources; these paths could be either local URLs pointing to a location in the device or URLs that links to a resource stored in the web via HTTP/HTTPS. In the latter case, if Internet connectivity is available, the resource will be imported in a private-application  directory before being used.
 * @param libraryPath the list of directories containing native libraries; it may be null
 * @param packageNameToCertificateMap a map that couples each package name to a URL which contains the certificate that must be used to validate all the classes that belong to that package before launching them at run time.
 * @param parent the parent class loader
 * @return secureDexClassLoader
 */
public SecureDexClassLoader createDexClassLoader(String dexPath,String libraryPath,Map<String,String> packageNameToCertificateMap,ClassLoader parent){
  StringBuilder finalDexPath=new StringBuilder();
  String tempPath=dexPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  tempPath=tempPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  String[] strings=tempPath.split(Pattern.quote(File.pathSeparator));
  File resDownloadDir=null;
  boolean isResourceFolderInitialized=false;
  for (  String path : strings) {
    if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
      String fixedPath=path.replaceAll(""String_Node_Str"",""String_Node_Str"");
      fixedPath=fixedPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (!isResourceFolderInitialized) {
        resDownloadDir=mContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
        Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + resDownloadDir.getAbsolutePath());
        isResourceFolderInitialized=true;
      }
      String downloadedContainerPath=downloadContainerIntoFolder(fixedPath,resDownloadDir);
      if (downloadedContainerPath != null) {
        finalDexPath.append(downloadedContainerPath + File.pathSeparator);
        Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + finalDexPath);
      }
    }
 else {
      finalDexPath.append(path + File.pathSeparator);
    }
  }
  finalDexPath.deleteCharAt(finalDexPath.lastIndexOf(File.pathSeparator));
  File dexOutputDir=mContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
  Log.i(TAG_SECURE_FACTORY,""String_Node_Str"" + dexOutputDir.getAbsolutePath());
  Map<String,String> santiziedPackageNameToCertificateMap=sanitizePackageNameToCertificateMap(packageNameToCertificateMap);
  SecureDexClassLoader mSecureDexClassLoader=new SecureDexClassLoader(finalDexPath.toString(),dexOutputDir.getAbsolutePath(),libraryPath,parent,mContextWrapper);
  if (mSecureDexClassLoader != null)   mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
  return mSecureDexClassLoader;
}","/** 
 * Creates a   {@link SecureDexClassLoader} that finds interpreted and native code in a set ofprovided locations (either local or remote via HTTP or HTTPS) in dexPath. Interpreted classes are found in a set of DEX files contained in Jar or Apk files and  stored into an application-private, writable directory. Before executing one of these classes the signature of the target class is  verified against the certificate associated with its package name. Certificates location are provided by filling appropriately  {@link packageNameToCertificateMap}}; each package name must be linked with the remote location of the certificate that should be used to validate all the classes of that package. It's important  that each one of these locations uses HTTPS as its protocol; otherwise this  choice will be enforced! If a class package name do not match any of the provided entries in the map,  certificate location will be constructed by simply reverting package name and  transforming it into a web-based URL using HTTPS. Note that this method returns null if no matching Jar or Apk file is found at the provided dexPath parameter; otherwise a   {@link SecureDexClassLoader} instance is returned.Dynamic class loading with the returned  {@link SecureDexClassLoader} will fail whetherat least one of these conditions is not accomplished: target class is not found in dexPath or is in a missing remote container (i.e. Internet connectivity is not present), missing or invalid (i.e. expired) certificate is associated with the package name of the target class, target class signature check fails against the associated certificate.
 * @param dexPath the list of jar/apk files containing classes and resources; these paths could be either local URLs pointing to a location in the device or URLs that links to a resource stored in the web via HTTP/HTTPS. In the latter case, if Internet connectivity is available, the resource will be imported in a private-application  directory before being used.
 * @param libraryPath the list of directories containing native libraries; it may be null
 * @param packageNameToCertificateMap a map that couples each package name to a URL which contains the certificate that must be used to validate all the classes that belong to that package before launching them at run time.
 * @param parent the parent class loader
 * @return secureDexClassLoader
 */
public SecureDexClassLoader createDexClassLoader(String dexPath,String libraryPath,Map<String,String> packageNameToCertificateMap,ClassLoader parent){
  StringBuilder finalDexPath=new StringBuilder();
  String tempPath=dexPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  tempPath=tempPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
  String[] strings=tempPath.split(Pattern.quote(File.pathSeparator));
  File resDownloadDir=null;
  boolean isResourceFolderInitialized=false;
  for (  String path : strings) {
    if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
      String fixedPath=path.replaceAll(""String_Node_Str"",""String_Node_Str"");
      fixedPath=fixedPath.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (!isResourceFolderInitialized) {
        resDownloadDir=mContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
        Log.d(TAG_SECURE_FACTORY,""String_Node_Str"" + resDownloadDir.getAbsolutePath());
        isResourceFolderInitialized=true;
      }
      String downloadedContainerPath=downloadContainerIntoFolder(fixedPath,resDownloadDir);
      if (downloadedContainerPath != null) {
        finalDexPath.append(downloadedContainerPath + File.pathSeparator);
        Log.d(TAG_SECURE_FACTORY,""String_Node_Str"" + finalDexPath);
      }
    }
 else {
      finalDexPath.append(path + File.pathSeparator);
    }
  }
  finalDexPath.deleteCharAt(finalDexPath.lastIndexOf(File.pathSeparator));
  File dexOutputDir=mContextWrapper.getDir(""String_Node_Str"",ContextWrapper.MODE_PRIVATE);
  Log.d(TAG_SECURE_FACTORY,""String_Node_Str"" + dexOutputDir.getAbsolutePath());
  Map<String,String> santiziedPackageNameToCertificateMap=sanitizePackageNameToCertificateMap(packageNameToCertificateMap);
  SecureDexClassLoader mSecureDexClassLoader=new SecureDexClassLoader(finalDexPath.toString(),dexOutputDir.getAbsolutePath(),libraryPath,parent,mContextWrapper);
  if (mSecureDexClassLoader != null)   mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
  return mSecureDexClassLoader;
}"
93808,"@Override public void navigate(boolean requestFocus){
  if (element instanceof NavigationItem) {
    ((NavigationItem)element).navigate(requestFocus);
  }
}","@Override public void navigate(boolean requestFocus){
  element.navigate(requestFocus);
}"
93809,"@Override public String getAlphaSortKey(){
  return element instanceof PsiNamedElement ? ((PsiNamedElement)element).getName() : null;
}","@NotNull @Override public String getAlphaSortKey(){
  String name=element.getName();
  return name != null ? name : ""String_Node_Str"";
}"
93810,"@Override public TreeElement[] getChildren(){
  if (element instanceof SimpleFile) {
    SimpleProperty[] properties=PsiTreeUtil.getChildrenOfType(element,SimpleProperty.class);
    List<TreeElement> treeElements=new ArrayList<TreeElement>(properties.length);
    for (    SimpleProperty property : properties) {
      treeElements.add(new SimpleStructureViewElement(property));
    }
    return treeElements.toArray(new TreeElement[treeElements.size()]);
  }
 else {
    return EMPTY_ARRAY;
  }
}","@Override public TreeElement[] getChildren(){
  if (element instanceof SimpleFile) {
    SimpleProperty[] properties=PsiTreeUtil.getChildrenOfType(element,SimpleProperty.class);
    List<TreeElement> treeElements=new ArrayList<TreeElement>(properties.length);
    for (    SimpleProperty property : properties) {
      treeElements.add(new SimpleStructureViewElement((SimplePropertyImpl)property));
    }
    return treeElements.toArray(new TreeElement[treeElements.size()]);
  }
 else {
    return EMPTY_ARRAY;
  }
}"
93811,"@Override public boolean canNavigate(){
  return element instanceof NavigationItem && ((NavigationItem)element).canNavigate();
}","@Override public boolean canNavigate(){
  return element.canNavigate();
}"
93812,"@Override public ItemPresentation getPresentation(){
  return element instanceof NavigationItem ? ((NavigationItem)element).getPresentation() : null;
}","@NotNull @Override public ItemPresentation getPresentation(){
  ItemPresentation presentation=element.getPresentation();
  return presentation != null ? presentation : new PresentationData();
}"
93813,"public SimpleStructureViewElement(PsiElement element){
  this.element=element;
}","public SimpleStructureViewElement(NavigatablePsiElement element){
  this.element=element;
}"
93814,"@Override public boolean canNavigateToSource(){
  return element instanceof NavigationItem && ((NavigationItem)element).canNavigateToSource();
}","@Override public boolean canNavigateToSource(){
  return element.canNavigateToSource();
}"
93815,"@Nullable @Override public WordsScanner getWordsScanner(){
  return new DefaultWordsScanner(new SimpleLexerAdapter(),TokenSet.create(SimpleTypes.KEY),TokenSet.create(SimpleTypes.COMMENT),TokenSet.EMPTY);
  ;
}","@Nullable @Override public WordsScanner getWordsScanner(){
  return new DefaultWordsScanner(new SimpleLexerAdapter(),TokenSet.create(SimpleTypes.KEY),TokenSet.create(SimpleTypes.COMMENT),TokenSet.EMPTY);
}"
93816,"public void testCompletion(){
  myFixture.configureByFiles(""String_Node_Str"",""String_Node_Str"");
  myFixture.complete(CompletionType.BASIC,1);
  System.out.println(myFixture.getLookupElementStrings());
}","public void testCompletion(){
  myFixture.configureByFiles(""String_Node_Str"",""String_Node_Str"");
  myFixture.complete(CompletionType.BASIC,1);
  List<String> strings=myFixture.getLookupElementStrings();
  assertTrue(strings.containsAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  assertEquals(5,strings.size());
}"
93817,"@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  StatusbarUtils.from(this).setTransparentStatusbar(true).setLightStatusBar(false).process();
  setContentView(R.layout.fragment_image_detailed_card);
  ButterKnife.bind(this);
  mNavigationBar.setProgress(true);
  mNavigationBar.setTextColor(Color.WHITE);
  imageResult=getIntent().getParcelableExtra(EXTRA_IMAGE);
  Picasso.with(this).load(imageResult.getPreviewUrl().replace(ImageRepo.END_POINT,ImageRepo.END_POINT_CDN)).config(Bitmap.Config.ARGB_8888).into(ivDetailedCard,new Callback.EmptyCallback(){
    @Override public void onSuccess(){
      Observable.just(ivDetailedCard).map(new Func1<ImageView,Bitmap>(){
        @Override public Bitmap call(        ImageView imageView){
          return ((BitmapDrawable)imageView.getDrawable()).getBitmap();
        }
      }
).map(new Func1<Bitmap,Bitmap>(){
        @Override public Bitmap call(        Bitmap bitmap){
          return Blur.fastblur(DetailedActivity.this,bitmap,20);
        }
      }
).subscribeOn(Schedulers.computation()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Action1<Bitmap>(){
        @TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void call(        final Bitmap bitmap){
          anim(ivDetailedCard,getPosition(getIntent()),true,new Animation.AnimationListener(){
            @Override public void onAnimationStart(            Animation animation){
              Animation trans=new TranslateAnimation(0,0,mLlDetailedDownloads.getHeight(),0);
              Animation scale=new ScaleAnimation(1.5f,1f,1.5f,1f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0f);
              AnimationSet set=new AnimationSet(true);
              set.addAnimation(scale);
              set.addAnimation(trans);
              set.setDuration(animation.getDuration() * 2);
              mLlDetailedDownloads.startAnimation(set);
            }
            @Override public void onAnimationEnd(            Animation animation){
              AnimateUtils.animateViewBitmap(ivDetailedCardBlur,bitmap);
            }
            @Override public void onAnimationRepeat(            Animation animation){
            }
          }
);
        }
      }
);
    }
  }
);
}","@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  StatusbarUtils.from(this).setTransparentStatusbar(true).setLightStatusBar(false).process();
  setContentView(R.layout.fragment_image_detailed_card);
  ButterKnife.bind(this);
  mNavigationBar.setProgress(true);
  mNavigationBar.setTextColor(Color.WHITE);
  imageResult=getIntent().getParcelableExtra(EXTRA_IMAGE);
  Picasso.with(this).load(imageResult.getPreviewUrl().replace(ImageRepo.END_POINT,ImageRepo.END_POINT_CDN)).config(Bitmap.Config.ARGB_8888).into(ivDetailedCard,new Callback.EmptyCallback(){
    @Override public void onSuccess(){
      Observable.just(ivDetailedCard).map(new Func1<ImageView,Bitmap>(){
        @Override public Bitmap call(        ImageView imageView){
          return ((BitmapDrawable)imageView.getDrawable()).getBitmap();
        }
      }
).map(new Func1<Bitmap,Bitmap>(){
        @Override public Bitmap call(        Bitmap bitmap){
          return Blur.fastblur(DetailedActivity.this,bitmap,20);
        }
      }
).subscribeOn(Schedulers.computation()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Action1<Bitmap>(){
        @TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void call(        final Bitmap bitmap){
          AnimateUtils.animateViewBitmap(ivDetailedCardBlur,bitmap);
          anim(getPosition(getIntent()),true,new Animator.AnimatorListener(){
            @Override public void onAnimationStart(            Animator animation){
            }
            @Override public void onAnimationEnd(            Animator animation){
              AnimateUtils.animateViewBitmap(ivDetailedCardBlur,bitmap);
            }
            @Override public void onAnimationCancel(            Animator animation){
            }
            @Override public void onAnimationRepeat(            Animator animation){
            }
          }
,ivDetailedCard,mLlDetailedDownloads);
        }
      }
);
    }
  }
);
}"
93818,"@Override public void onAnimationEnd(Animation animation){
  DetailedActivity.super.onBackPressed();
  overridePendingTransition(0,0);
}","@Override public void onAnimationEnd(Animator animation){
  DetailedActivity.super.onBackPressed();
  overridePendingTransition(0,0);
}"
93819,"@TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void call(final Bitmap bitmap){
  anim(ivDetailedCard,getPosition(getIntent()),true,new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
      Animation trans=new TranslateAnimation(0,0,mLlDetailedDownloads.getHeight(),0);
      Animation scale=new ScaleAnimation(1.5f,1f,1.5f,1f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0f);
      AnimationSet set=new AnimationSet(true);
      set.addAnimation(scale);
      set.addAnimation(trans);
      set.setDuration(animation.getDuration() * 2);
      mLlDetailedDownloads.startAnimation(set);
    }
    @Override public void onAnimationEnd(    Animation animation){
      AnimateUtils.animateViewBitmap(ivDetailedCardBlur,bitmap);
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
}","@TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void call(final Bitmap bitmap){
  AnimateUtils.animateViewBitmap(ivDetailedCardBlur,bitmap);
  anim(getPosition(getIntent()),true,new Animator.AnimatorListener(){
    @Override public void onAnimationStart(    Animator animation){
    }
    @Override public void onAnimationEnd(    Animator animation){
      AnimateUtils.animateViewBitmap(ivDetailedCardBlur,bitmap);
    }
    @Override public void onAnimationCancel(    Animator animation){
    }
    @Override public void onAnimationRepeat(    Animator animation){
    }
  }
,ivDetailedCard,mLlDetailedDownloads);
}"
93820,"@OnClick(R.id.iv_detailed_card) void download(final ImageView v){
  final File file=getFilesDir();
  Log.d(TAG,file.toString());
  PhotoViewActivity.startScaleActivity(v.getContext(),Position.from(v));
}","@OnClick(R.id.iv_detailed_card) void download(final ImageView v){
  Toast.makeText(DetailedActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}"
93821,"@Override public void onAnimationRepeat(Animation animation){
}","@Override public void onAnimationRepeat(Animator animation){
}"
93822,"/** 
 * 
 */
void anim(View view,Position position,boolean isEnter,Animation.AnimationListener listener){
  float delta=((float)(position.width)) / ((float)(position.heigth));
  float fromDelta, toDelta, fromY, toY;
  float delt_Y=position.top;
  float delt_X=position.left - view.getLeft();
  if (isEnter) {
    fromDelta=1f;
    toDelta=delta;
    fromY=delt_Y;
    toY=0;
  }
 else {
    fromDelta=delta;
    toDelta=1f;
    fromY=0;
    toY=delt_Y;
  }
  Animation anim=new ScaleAnimation(fromDelta,toDelta,fromDelta,toDelta,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0f);
  Animation trans=new TranslateAnimation(0,0f,fromY,toY);
  AnimationSet set=new AnimationSet(true);
  set.addAnimation(anim);
  set.addAnimation(trans);
  set.setFillEnabled(true);
  set.setFillAfter(true);
  set.setAnimationListener(listener);
  set.setDuration(AnimateUtils.ANIM_DORITION);
  view.startAnimation(set);
}","/** 
 * 
 */
void anim(final Position position,final boolean isEnter,final Animator.AnimatorListener listener,View... views){
  if (isPlaying) {
    listener.onAnimationEnd(null);
    return;
  }
  float delta=((float)(position.width)) / ((float)(position.height));
  final float fromY, toY;
  float[] toDelta=new float[2];
  float[] fromDelta=new float[2];
  View view=views[0];
  float delt_Y=position.top;
  float delt_X=position.left - view.getLeft();
  if (isEnter) {
    fromDelta[0]=1f;
    toDelta[0]=delta;
    fromDelta[1]=2f;
    toDelta[1]=1f;
    fromY=delt_Y;
    toY=0;
  }
 else {
    fromDelta[0]=delta;
    toDelta[0]=1f;
    fromDelta[1]=1f;
    toDelta[1]=2f;
    fromY=0;
    toY=delt_Y;
  }
  view.setPivotX(view.getWidth() / 2);
  ObjectAnimator trans_Y=ObjectAnimator.ofFloat(view,View.TRANSLATION_Y,fromY,toY);
  ObjectAnimator scale_X=ObjectAnimator.ofFloat(view,View.SCALE_X,fromDelta[0],toDelta[0]);
  ObjectAnimator scale_Y=ObjectAnimator.ofFloat(view,View.SCALE_Y,fromDelta[0],toDelta[0]);
  ObjectAnimator scale_icn_X=ObjectAnimator.ofFloat(views[1],View.SCALE_X,fromDelta[1],toDelta[1]);
  ObjectAnimator scale_icn_Y=ObjectAnimator.ofFloat(views[1],View.SCALE_Y,fromDelta[1],toDelta[1]);
  AnimatorSet set=new AnimatorSet();
  set.playTogether(trans_Y,scale_X,scale_Y);
  set.playTogether(scale_icn_X,scale_icn_Y);
  set.setDuration(400);
  set.addListener(new Animator.AnimatorListener(){
    @Override public void onAnimationStart(    Animator animation){
      listener.onAnimationStart(animation);
      isPlaying=true;
    }
    @Override public void onAnimationEnd(    Animator animation){
      listener.onAnimationEnd(animation);
      isPlaying=false;
    }
    @Override public void onAnimationCancel(    Animator animation){
      listener.onAnimationCancel(animation);
      isPlaying=false;
    }
    @Override public void onAnimationRepeat(    Animator animation){
      listener.onAnimationRepeat(animation);
    }
  }
);
  set.setInterpolator(new AccelerateInterpolator());
  set.start();
}"
93823,"@Override public void onSuccess(){
  Observable.just(ivDetailedCard).map(new Func1<ImageView,Bitmap>(){
    @Override public Bitmap call(    ImageView imageView){
      return ((BitmapDrawable)imageView.getDrawable()).getBitmap();
    }
  }
).map(new Func1<Bitmap,Bitmap>(){
    @Override public Bitmap call(    Bitmap bitmap){
      return Blur.fastblur(DetailedActivity.this,bitmap,20);
    }
  }
).subscribeOn(Schedulers.computation()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Action1<Bitmap>(){
    @TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void call(    final Bitmap bitmap){
      anim(ivDetailedCard,getPosition(getIntent()),true,new Animation.AnimationListener(){
        @Override public void onAnimationStart(        Animation animation){
          Animation trans=new TranslateAnimation(0,0,mLlDetailedDownloads.getHeight(),0);
          Animation scale=new ScaleAnimation(1.5f,1f,1.5f,1f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0f);
          AnimationSet set=new AnimationSet(true);
          set.addAnimation(scale);
          set.addAnimation(trans);
          set.setDuration(animation.getDuration() * 2);
          mLlDetailedDownloads.startAnimation(set);
        }
        @Override public void onAnimationEnd(        Animation animation){
          AnimateUtils.animateViewBitmap(ivDetailedCardBlur,bitmap);
        }
        @Override public void onAnimationRepeat(        Animation animation){
        }
      }
);
    }
  }
);
}","@Override public void onSuccess(){
  Observable.just(ivDetailedCard).map(new Func1<ImageView,Bitmap>(){
    @Override public Bitmap call(    ImageView imageView){
      return ((BitmapDrawable)imageView.getDrawable()).getBitmap();
    }
  }
).map(new Func1<Bitmap,Bitmap>(){
    @Override public Bitmap call(    Bitmap bitmap){
      return Blur.fastblur(DetailedActivity.this,bitmap,20);
    }
  }
).subscribeOn(Schedulers.computation()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Action1<Bitmap>(){
    @TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void call(    final Bitmap bitmap){
      AnimateUtils.animateViewBitmap(ivDetailedCardBlur,bitmap);
      anim(getPosition(getIntent()),true,new Animator.AnimatorListener(){
        @Override public void onAnimationStart(        Animator animation){
        }
        @Override public void onAnimationEnd(        Animator animation){
          AnimateUtils.animateViewBitmap(ivDetailedCardBlur,bitmap);
        }
        @Override public void onAnimationCancel(        Animator animation){
        }
        @Override public void onAnimationRepeat(        Animator animation){
        }
      }
,ivDetailedCard,mLlDetailedDownloads);
    }
  }
);
}"
93824,"@Override public void onAnimationStart(Animation animation){
  mLlDetailedDownloads.animate().alpha(0f).setDuration(AnimateUtils.ANIM_DORITION).start();
  AnimateUtils.animateViewBitmap(ivDetailedCardBlur,null);
}","@Override public void onAnimationStart(Animator animation){
  AnimateUtils.animateViewBitmap(ivDetailedCardBlur,null);
}"
93825,"@Override public void onBackPressed(){
  if (alertView != null && alertView.isShowing()) {
    alertView.dismiss();
    return;
  }
  anim(ivDetailedCard,getPosition(getIntent()),false,new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
      mLlDetailedDownloads.animate().alpha(0f).setDuration(AnimateUtils.ANIM_DORITION).start();
      AnimateUtils.animateViewBitmap(ivDetailedCardBlur,null);
    }
    @Override public void onAnimationEnd(    Animation animation){
      DetailedActivity.super.onBackPressed();
      overridePendingTransition(0,0);
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
}","@Override public void onBackPressed(){
  if (alertView != null && alertView.isShowing()) {
    alertView.dismiss();
    return;
  }
  anim(getPosition(getIntent()),false,new Animator.AnimatorListener(){
    @Override public void onAnimationStart(    Animator animation){
      AnimateUtils.animateViewBitmap(ivDetailedCardBlur,null);
    }
    @Override public void onAnimationEnd(    Animator animation){
      DetailedActivity.super.onBackPressed();
      overridePendingTransition(0,0);
    }
    @Override public void onAnimationCancel(    Animator animation){
    }
    @Override public void onAnimationRepeat(    Animator animation){
    }
  }
,ivDetailedCard,mLlDetailedDownloads);
}"
93826,"@Override public void onError(Throwable e){
  e.printStackTrace();
  if (mNavigationBar != null) {
    mNavigationBar.setProgress(false);
  }
  isLoadingMore=false;
}","@Override public void onError(Throwable e){
  e.printStackTrace();
  if (mNavigationBar != null) {
    mNavigationBar.setProgress(false);
  }
  isLoadingMore=false;
  Toast.makeText(MainActivity.this,e.getMessage(),Toast.LENGTH_SHORT).show();
}"
93827,"void loadPage(Map<String,Object> query){
  if (isLoadingMore) {
    return;
  }
  if (mNavigationBar != null) {
    mNavigationBar.setProgress(true);
  }
  if (query == null) {
    query=new HashMap<>();
  }
  if ((query.isEmpty()) || (!query.containsKey(ImageRepo.TAGS))) {
    query.put(ImageRepo.TAGS,ImageRepo.TAG_SAFE);
    query.put(ImageRepo.LIMIT,10);
  }
  RetrofitUtils.getCachedAdapter().create(ImageRepo.class).getImageList(query).subscribeOn(Schedulers.io()).flatMap(new Func1<List<ImageResult>,Observable<ImageResult>>(){
    @Override public Observable<ImageResult> call(    List<ImageResult> imageResults){
      return Observable.from(imageResults);
    }
  }
).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<ImageResult>(){
    @Override public void onCompleted(){
      if (mRvFragCard != null && mRvFragCard.getAdapter() != null) {
        mRvFragCard.getAdapter().notifyDataSetChanged();
      }
      if (mNavigationBar != null) {
        mNavigationBar.setProgress(false);
      }
      isLoadingMore=false;
    }
    @Override public void onError(    Throwable e){
      e.printStackTrace();
      if (mNavigationBar != null) {
        mNavigationBar.setProgress(false);
      }
      isLoadingMore=false;
    }
    @Override public void onNext(    ImageResult imageResult){
      ((CardAdapter)mRvFragCard.getAdapter()).getData().add(imageResult);
    }
  }
);
}","void loadPage(Map<String,Object> query){
  if (isLoadingMore) {
    return;
  }
  if (mNavigationBar != null) {
    mNavigationBar.setProgress(true);
  }
  if (query == null) {
    query=new HashMap<>();
  }
  if ((query.isEmpty()) || (!query.containsKey(ImageRepo.TAGS))) {
    query.put(ImageRepo.TAGS,ImageRepo.TAG_SAFE);
    query.put(ImageRepo.LIMIT,10);
  }
  RetrofitUtils.getCachedAdapter().create(ImageRepo.class).getImageList(query).subscribeOn(Schedulers.io()).flatMap(new Func1<List<ImageResult>,Observable<ImageResult>>(){
    @Override public Observable<ImageResult> call(    List<ImageResult> imageResults){
      return Observable.from(imageResults);
    }
  }
).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber<ImageResult>(){
    @Override public void onCompleted(){
      if (mRvFragCard != null && mRvFragCard.getAdapter() != null) {
        mRvFragCard.getAdapter().notifyDataSetChanged();
      }
      if (mNavigationBar != null) {
        mNavigationBar.setProgress(false);
      }
      isLoadingMore=false;
    }
    @Override public void onError(    Throwable e){
      e.printStackTrace();
      if (mNavigationBar != null) {
        mNavigationBar.setProgress(false);
      }
      isLoadingMore=false;
      Toast.makeText(MainActivity.this,e.getMessage(),Toast.LENGTH_SHORT).show();
    }
    @Override public void onNext(    ImageResult imageResult){
      ((CardAdapter)mRvFragCard.getAdapter()).getData().add(imageResult);
    }
  }
);
}"
93828,"@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  StatusbarUtils.from(this).setTransparentStatusbar(true).setLightStatusBar(false).process();
  setContentView(R.layout.activity_photoview);
  ButterKnife.bind(this);
  Picasso.with(this).load(R.drawable.place_holder).into(mIvPhoto,new Callback(){
    @Override public void onSuccess(){
      Position position=getPosition(getIntent());
      Log.d(TAG,position.toString());
      ((ViewGroup)mIvPhoto.getParent()).setClipChildren(false);
      float del_scale=((float)getWindowManager().getDefaultDisplay().getHeight()) / ((float)position.heigth);
      Log.d(TAG,del_scale + ""String_Node_Str"");
      Animation anim=new ScaleAnimation(1f,del_scale,1f,del_scale,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,((float)position.heigth) / (1f / ((float)position.top) + 1f / ((float)position.bottom)));
      anim.setDuration(3000);
      anim.setFillAfter(true);
      mIvPhoto.startAnimation(anim);
    }
    @Override public void onError(){
    }
  }
);
}","@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  StatusbarUtils.from(this).setTransparentStatusbar(true).setLightStatusBar(false).process();
  setContentView(R.layout.activity_photoview);
  ButterKnife.bind(this);
  Picasso.with(this).load(R.drawable.place_holder).into(mIvPhoto,new Callback(){
    @Override public void onSuccess(){
      Position position=getPosition(getIntent());
      Log.d(TAG,position.toString());
      ((ViewGroup)mIvPhoto.getParent()).setClipChildren(false);
      float del_scale=((float)getWindowManager().getDefaultDisplay().getHeight()) / ((float)position.height);
      Log.d(TAG,del_scale + ""String_Node_Str"");
      Animation anim=new ScaleAnimation(1f,del_scale,1f,del_scale,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,((float)position.height) / (1f / ((float)position.top) + 1f / ((float)position.bottom)));
      anim.setDuration(3000);
      anim.setFillAfter(true);
      mIvPhoto.startAnimation(anim);
    }
    @Override public void onError(){
    }
  }
);
}"
93829,"@Override public void onSuccess(){
  Position position=getPosition(getIntent());
  Log.d(TAG,position.toString());
  ((ViewGroup)mIvPhoto.getParent()).setClipChildren(false);
  float del_scale=((float)getWindowManager().getDefaultDisplay().getHeight()) / ((float)position.heigth);
  Log.d(TAG,del_scale + ""String_Node_Str"");
  Animation anim=new ScaleAnimation(1f,del_scale,1f,del_scale,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,((float)position.heigth) / (1f / ((float)position.top) + 1f / ((float)position.bottom)));
  anim.setDuration(3000);
  anim.setFillAfter(true);
  mIvPhoto.startAnimation(anim);
}","@Override public void onSuccess(){
  Position position=getPosition(getIntent());
  Log.d(TAG,position.toString());
  ((ViewGroup)mIvPhoto.getParent()).setClipChildren(false);
  float del_scale=((float)getWindowManager().getDefaultDisplay().getHeight()) / ((float)position.height);
  Log.d(TAG,del_scale + ""String_Node_Str"");
  Animation anim=new ScaleAnimation(1f,del_scale,1f,del_scale,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,((float)position.height) / (1f / ((float)position.top) + 1f / ((float)position.bottom)));
  anim.setDuration(3000);
  anim.setFillAfter(true);
  mIvPhoto.startAnimation(anim);
}"
93830,"protected Position(Parcel in){
  this.left=in.readInt();
  this.right=in.readInt();
  this.top=in.readInt();
  this.bottom=in.readInt();
  this.width=in.readInt();
  this.heigth=in.readInt();
}","protected Position(Parcel in){
  this.left=in.readInt();
  this.right=in.readInt();
  this.top=in.readInt();
  this.bottom=in.readInt();
  this.width=in.readInt();
  this.height=in.readInt();
}"
93831,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + left + ""String_Node_Str""+ right+ ""String_Node_Str""+ top+ ""String_Node_Str""+ bottom+ ""String_Node_Str""+ width+ ""String_Node_Str""+ heigth+ '}';
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + left + ""String_Node_Str""+ right+ ""String_Node_Str""+ top+ ""String_Node_Str""+ bottom+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ '}';
}"
93832,"@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeInt(this.left);
  dest.writeInt(this.right);
  dest.writeInt(this.top);
  dest.writeInt(this.bottom);
  dest.writeInt(this.width);
  dest.writeInt(this.heigth);
}","@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeInt(this.left);
  dest.writeInt(this.right);
  dest.writeInt(this.top);
  dest.writeInt(this.bottom);
  dest.writeInt(this.width);
  dest.writeInt(this.height);
}"
93833,"@Override public IExtractedFileSet extractFileSet(Distribution distribution) throws IOException {
  try {
    final File dir=this.eDir.asFile();
    final FileSet filesSet=downloadConfig.getPackageResolver().getFileSet(distribution);
    if (dir.exists() && dir.isDirectory() && filesSet.entries().stream().allMatch(entry -> exists(get(dir.getPath(),""String_Node_Str"",""String_Node_Str"")))) {
      final Builder extracted=builder(dir).baseDirIsGenerated(false);
      iterateFiles(dir,TRUE,TRUE).forEachRemaining(file -> {
        FileType type=Library;
        if (filesSet.entries().stream().anyMatch(entry -> entry.matchingPattern().matcher(file.getPath()).matches())) {
          type=Executable;
        }
        extracted.file(type,file);
      }
);
      return extracted.build();
    }
 else {
      return super.extractFileSet(distribution);
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    return new EmptyFileSet();
  }
}","@Override public IExtractedFileSet extractFileSet(Distribution distribution) throws IOException {
  try {
    final File dir=this.eDir.asFile();
    final FileSet filesSet=downloadConfig.getPackageResolver().getFileSet(distribution);
    final Path path=get(dir.getPath(),""String_Node_Str"" + ""String_Node_Str"" + distribution.getVersion().asInDownloadPath(),""String_Node_Str"");
    if (filesSet.entries().stream().allMatch(entry -> exists(path))) {
      final Builder extracted=builder(dir).baseDirIsGenerated(false);
      iterateFiles(dir,TRUE,TRUE).forEachRemaining(file -> {
        FileType type=Library;
        if (filesSet.entries().stream().anyMatch(entry -> entry.matchingPattern().matcher(file.getPath()).matches())) {
          type=Executable;
        }
        extracted.file(type,file);
      }
);
      return extracted.build();
    }
 else {
      return super.extractFileSet(distribution);
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    return new EmptyFileSet();
  }
}"
93834,"@Override public IExtractedFileSet extractFileSet(Distribution distribution) throws IOException {
  IPackageResolver packageResolver=downloadConfig.getPackageResolver();
  File artifact=getArtifact(downloadConfig,distribution);
  final ArchiveType archiveType=packageResolver.getArchiveType(distribution);
  IExtractor extractor=Extractors.getExtractor(archiveType);
  try {
    final FileSet fileSet=packageResolver.getFileSet(distribution);
    return extractor.extract(downloadConfig,artifact,new PostgresFilesToExtract(tempDirFactory,executableNaming,fileSet));
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    return new EmptyFileSet();
  }
}","@Override public IExtractedFileSet extractFileSet(Distribution distribution) throws IOException {
  IPackageResolver packageResolver=downloadConfig.getPackageResolver();
  File artifact=getArtifact(downloadConfig,distribution);
  final ArchiveType archiveType=packageResolver.getArchiveType(distribution);
  IExtractor extractor=Extractors.getExtractor(archiveType);
  try {
    final FileSet fileSet=packageResolver.getFileSet(distribution);
    return extractor.extract(downloadConfig,artifact,new PostgresFilesToExtract(tempDirFactory,executableNaming,fileSet,distribution));
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    return new EmptyFileSet();
  }
}"
93835,"/** 
 * This is actually the very dirty hack method to adopt the Flapdoodle's API to the compatible way to extract and run TODO: hacky method. Should be considered for complete rewriting //NOSONAR
 */
@Override public IExtractionMatch find(final IArchiveEntry entry){
  if (entry.getName().matches(SKIP_PATTERN)) {
    return null;
  }
  if (extractDir == null || extractDir.asFile() == null) {
    return null;
  }
  String basePath=extractDir.asFile().getPath();
  final Path path=Paths.get(basePath,entry.getName());
  return new IExtractionMatch(){
    @Override public File write(    InputStream source,    long size) throws IOException {
      boolean isSymLink=false;
      String linkName=""String_Node_Str"";
      if (entry instanceof CommonsArchiveEntryAdapter) {
        try {
          Field archiveEntryField=CommonsArchiveEntryAdapter.class.getDeclaredField(""String_Node_Str"");
          archiveEntryField.setAccessible(true);
          ArchiveEntry archiveEntry=(ArchiveEntry)archiveEntryField.get(entry);
          if (archiveEntry instanceof TarArchiveEntry && (isSymLink=((TarArchiveEntry)archiveEntry).isSymbolicLink())) {
            linkName=((TarArchiveEntry)archiveEntry).getLinkName();
          }
          archiveEntry.getSize();
        }
 catch (        NoSuchFieldException|IllegalAccessException e) {
          throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
        }
      }
synchronized (PostgresFilesToExtract.class) {
        final File outputFile=path.toFile();
        if (entry.isDirectory()) {
          if (!outputFile.exists()) {
            Files.createDir(outputFile);
          }
        }
 else {
          if (!outputFile.exists()) {
            if (isSymLink) {
              try {
                final Path target=path.getParent().resolve(Paths.get(linkName));
                java.nio.file.Files.createSymbolicLink(outputFile.toPath(),target);
              }
 catch (              Exception e) {
                LOGGER.trace(""String_Node_Str"",e);
              }
            }
 else {
              Files.write(source,outputFile);
            }
          }
          if (entry.getName().matches(EXECUTABLE_PATTERN)) {
            outputFile.setExecutable(true);
          }
        }
        return outputFile;
      }
    }
    @Override public FileType type(){
      for (      FileSet.Entry matchingEntry : fileSet.entries()) {
        if (matchingEntry.matchingPattern().matcher(path.toString()).matches()) {
          return matchingEntry.type();
        }
      }
      return FileType.Library;
    }
  }
;
}","/** 
 * This is actually the very dirty hack method to adopt the Flapdoodle's API to the compatible way to extract and run TODO: hacky method. Should be considered for complete rewriting //NOSONAR
 */
@Override public IExtractionMatch find(final IArchiveEntry entry){
  if (this.extractBasePath == null) {
    return null;
  }
  if (entry.getName().matches(SKIP_PATTERN)) {
    return null;
  }
  final Path path=Paths.get(this.extractBasePath,entry.getName());
  return new IExtractionMatch(){
    @Override public File write(    InputStream source,    long size) throws IOException {
      boolean isSymLink=false;
      String linkName=""String_Node_Str"";
      if (entry instanceof CommonsArchiveEntryAdapter) {
        try {
          Field archiveEntryField=CommonsArchiveEntryAdapter.class.getDeclaredField(""String_Node_Str"");
          archiveEntryField.setAccessible(true);
          ArchiveEntry archiveEntry=(ArchiveEntry)archiveEntryField.get(entry);
          if (archiveEntry instanceof TarArchiveEntry && (isSymLink=((TarArchiveEntry)archiveEntry).isSymbolicLink())) {
            linkName=((TarArchiveEntry)archiveEntry).getLinkName();
          }
          archiveEntry.getSize();
        }
 catch (        NoSuchFieldException|IllegalAccessException e) {
          throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"",e);
        }
      }
synchronized (PostgresFilesToExtract.class) {
        final File outputFile=path.toFile();
        if (entry.isDirectory()) {
          if (!outputFile.exists()) {
            Files.createDir(outputFile);
          }
        }
 else {
          if (!outputFile.exists()) {
            if (isSymLink) {
              try {
                final Path target=path.getParent().resolve(Paths.get(linkName));
                java.nio.file.Files.createSymbolicLink(outputFile.toPath(),target);
              }
 catch (              Exception e) {
                LOGGER.trace(""String_Node_Str"",e);
              }
            }
 else {
              Files.write(source,outputFile);
            }
          }
          if (entry.getName().matches(EXECUTABLE_PATTERN)) {
            outputFile.setExecutable(true);
          }
        }
        return outputFile;
      }
    }
    @Override public FileType type(){
      for (      FileSet.Entry matchingEntry : fileSet.entries()) {
        if (matchingEntry.matchingPattern().matcher(path.toString()).matches()) {
          return matchingEntry.type();
        }
      }
      return FileType.Library;
    }
  }
;
}"
93836,"public PostgresFilesToExtract(IDirectory dirFactory,ITempNaming executableNaming,FileSet fileSet){
  super(dirFactory,executableNaming,fileSet);
  this.fileSet=fileSet;
  this.extractDir=dirFactory;
}","public PostgresFilesToExtract(IDirectory dirFactory,ITempNaming executableNaming,FileSet fileSet,Distribution distribution){
  super(dirFactory,executableNaming,fileSet);
  this.fileSet=fileSet;
  if (dirFactory.asFile() != null) {
    final File file=new File(dirFactory.asFile(),""String_Node_Str"" + distribution.getVersion().asInDownloadPath());
    if (!file.exists()) {
      file.mkdir();
    }
    this.extractBasePath=file.getPath();
  }
 else {
    this.extractBasePath=null;
  }
}"
93837,"@Override protected void onBeforeProcess(IRuntimeConfig runtimeConfig) throws IOException {
  super.onBeforeProcess(runtimeConfig);
  PostgresConfig config=getConfig();
  runCmd(config,runtimeConfig,InitDb,""String_Node_Str"",1000);
}","@Override protected void onBeforeProcess(IRuntimeConfig runtimeConfig) throws IOException {
  super.onBeforeProcess(runtimeConfig);
  PostgresConfig config=getConfig();
  final File dbDir=config.storage().dbDir();
  if (dbDir.exists() && dbDir.listFiles() != null && dbDir.listFiles().length > 0) {
    return;
  }
  runCmd(config,runtimeConfig,InitDb,""String_Node_Str"",1000);
}"
93838,"protected void deleteTempFiles(){
  final Storage storage=getConfig().storage();
  if ((storage.dbDir() != null) && (storage.isTmpDir()) && (!forceDelete(storage.dbDir()))) {
    LOGGER.warn(""String_Node_Str"",storage.dbDir());
  }
}","protected void deleteTempFiles(){
  final Storage storage=getConfig().storage();
  if (storage.dbDir() == null) {
    return;
  }
  if (!storage.isTmpDir()) {
    return;
  }
  if (!forceDelete(storage.dbDir())) {
    LOGGER.warn(""String_Node_Str"",storage.dbDir());
  }
}"
93839,"@Override protected final void onAfterProcessStart(ProcessControl process,IRuntimeConfig runtimeConfig) throws IOException {
  final Path pidFilePath=Paths.get(getConfig().storage().dbDir().getAbsolutePath(),""String_Node_Str"");
  final File pidFile=new File(pidFilePath.toAbsolutePath().toString());
  int timeout=TIMEOUT;
  while (!pidFile.exists() && ((timeout=timeout - 100) > 0)) {
    try {
      sleep(100);
    }
 catch (    InterruptedException ie) {
    }
  }
  int pid=-1;
  try {
    pid=Integer.valueOf(readLines(pidFilePath.toFile()).get(0));
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e.getMessage(),e);
  }
  if (pid != -1) {
    setProcessId(pid);
  }
 else {
    setProcessId(getPidFromFile(pidFile()));
  }
  int trial=0;
  do {
    String output=runCmd(getConfig(),runtimeConfig,CreateDb,""String_Node_Str"",new HashSet<>(singleton(""String_Node_Str"")),3000,getConfig().storage().dbName());
    try {
      if (isEmpty(output) || !output.contains(""String_Node_Str"")) {
        this.processReady=true;
        break;
      }
      LOGGER.warn(""String_Node_Str"",trial,MAX_CREATEDB_TRIALS);
      sleep(100);
    }
 catch (    InterruptedException ie) {
    }
  }
 while (trial++ < MAX_CREATEDB_TRIALS);
}","@Override protected final void onAfterProcessStart(ProcessControl process,IRuntimeConfig runtimeConfig) throws IOException {
  final Storage storage=getConfig().storage();
  final Path pidFilePath=Paths.get(storage.dbDir().getAbsolutePath(),""String_Node_Str"");
  final File pidFile=new File(pidFilePath.toAbsolutePath().toString());
  int timeout=TIMEOUT;
  while (!pidFile.exists() && ((timeout=timeout - 100) > 0)) {
    try {
      sleep(100);
    }
 catch (    InterruptedException ie) {
    }
  }
  int pid=-1;
  try {
    pid=Integer.valueOf(readLines(pidFilePath.toFile()).get(0));
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e.getMessage(),e);
  }
  if (pid != -1) {
    setProcessId(pid);
  }
 else {
    setProcessId(getPidFromFile(pidFile()));
  }
  int trial=0;
  do {
    String output=runCmd(getConfig(),runtimeConfig,CreateDb,""String_Node_Str"",new HashSet<>(singleton(""String_Node_Str"")),3000,storage.dbName());
    try {
      if (isEmpty(output) || !output.contains(""String_Node_Str"")) {
        this.processReady=true;
        break;
      }
      LOGGER.warn(""String_Node_Str"",trial,MAX_CREATEDB_TRIALS);
      sleep(100);
    }
 catch (    InterruptedException ie) {
    }
  }
 while (trial++ < MAX_CREATEDB_TRIALS);
}"
93840,"private void startFakeTouchTask(){
  mTimer=new Timer();
  mSendFakeTouchTask=new TimerTask(){
    @Override public void run(){
      Instrumentation instrumentation=new Instrumentation();
      instrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACKSLASH);
    }
  }
;
  mTimer.schedule(mSendFakeTouchTask,1000,1000);
}","private void startFakeTouchTask(){
  mTimer=new Timer();
  mSendFakeTouchTask=new TimerTask(){
    @Override public void run(){
      try {
        Instrumentation instrumentation=new Instrumentation();
        instrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACKSLASH);
      }
 catch (      SecurityException e) {
      }
    }
  }
;
  mTimer.schedule(mSendFakeTouchTask,1000,1000);
}"
93841,"@Override public void run(){
  Instrumentation instrumentation=new Instrumentation();
  instrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACKSLASH);
}","@Override public void run(){
  try {
    Instrumentation instrumentation=new Instrumentation();
    instrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACKSLASH);
  }
 catch (  SecurityException e) {
  }
}"
93842,"/** 
 * Sets the window function type.
 * @param windowType window function type. One of the {@link #WINDOW_RECTANGULAR = 0},   {@link #WINDOW_HANN},   {@link #WINDOW_HAMMING},    {@link #WINDOW_BLACKMAN},   {@link #WINDOW_FLAT_TOP} with optional {@link WINDOW_OPT_APPLY_FOR_WAVEFORM} flag.
 * @return {@link #SUCCESS} in case of success,{@link #ERROR_INVALID_OPERATION} or {@link #ERROR_DEAD_OBJECT} incase of failure.
 * @throws IllegalStateException
 */
int setWindowFunction(int windowType) throws IllegalStateException ;","/** 
 * Sets the window function type.
 * @param windowType window function type. One of the {@link #WINDOW_RECTANGULAR = 0},   {@link #WINDOW_HANN},   {@link #WINDOW_HAMMING},    {@link #WINDOW_BLACKMAN},   {@link #WINDOW_FLAT_TOP} with optional {@link #WINDOW_OPT_APPLY_FOR_WAVEFORM} flag.
 * @return {@link #SUCCESS} in case of success,{@link #ERROR_INVALID_OPERATION} or {@link #ERROR_DEAD_OBJECT} incase of failure.
 * @throws IllegalStateException
 */
int setWindowFunction(int windowType) throws IllegalStateException ;"
93843,"/** 
 * Retrieves the latest peak and RMS measurement. Sets the peak and RMS fields of the supplied   {@link Visualizer.MeasurementPeakRms} to thelatest measured values.
 * @param measurement a non-null {@link Visualizer.MeasurementPeakRms}instance to store the measurement values.
 * @return {@link #SUCCESS} in case of success, {@link #ERROR_BAD_VALUE},  {@link #ERROR_NO_MEMORY},   {@link #ERROR_INVALID_OPERATION} or{@link #ERROR_DEAD_OBJECT} in case of failure.
 */
int getMeasurementPeakRms(MeasurementPeakRms measurement);","/** 
 * Retrieves the latest peak and RMS measurement. Sets the peak and RMS fields of the supplied   {@link MeasurementPeakRms} to thelatest measured values.
 * @param measurement a non-null {@link MeasurementPeakRms}instance to store the measurement values.
 * @return {@link #SUCCESS} in case of success, {@link #ERROR_BAD_VALUE},  {@link #ERROR_NO_MEMORY},   {@link #ERROR_INVALID_OPERATION} or{@link #ERROR_DEAD_OBJECT} in case of failure.
 */
int getMeasurementPeakRms(MeasurementPeakRms measurement);"
93844,"private ILoudnessEnhancer createLoudnessEnhancer(){
  if (mLoudnessEnhancer == null) {
    try {
      mLoudnessEnhancer=mFactory.createLoudnessEnhancer(getPlayer(0));
    }
 catch (    UnsupportedOperationException e) {
    }
  }
  return mLoudnessEnhancer;
}","private ILoudnessEnhancer createLoudnessEnhancer(){
  if (mLoudnessEnhancer == null) {
    try {
      mLoudnessEnhancer=mFactory.createLoudnessEnhancer(getPlayer(0));
    }
 catch (    UnsupportedOperationException e) {
    }
catch (    IllegalArgumentException e) {
    }
  }
  return mLoudnessEnhancer;
}"
93845,"public IVisualizer createVisualizer(){
  if (mVisualizer == null) {
    try {
      mVisualizer=mFactory.createVisualizer(getPlayer(0));
    }
 catch (    UnsupportedOperationException e) {
    }
  }
  return mVisualizer;
}","public IVisualizer createVisualizer(){
  if (mVisualizer == null) {
    try {
      mVisualizer=mFactory.createVisualizer(getPlayer(0));
    }
 catch (    UnsupportedOperationException e) {
    }
catch (    IllegalArgumentException e) {
    }
  }
  return mVisualizer;
}"
93846,"private IPresetReverb createPresetReverb(){
  if (mPresetReverb == null) {
    try {
      mPresetReverb=mFactory.createPresetReverb();
    }
 catch (    UnsupportedOperationException e) {
    }
  }
  return mPresetReverb;
}","private IPresetReverb createPresetReverb(){
  if (mPresetReverb == null) {
    try {
      mPresetReverb=mFactory.createPresetReverb();
    }
 catch (    UnsupportedOperationException e) {
    }
catch (    IllegalArgumentException e) {
    }
  }
  return mPresetReverb;
}"
93847,"private IVirtualizer createVirtualizer(){
  if (mVirtualizer == null) {
    try {
      mVirtualizer=mFactory.createVirtualizer(getPlayer(0));
    }
 catch (    UnsupportedOperationException e) {
    }
  }
  return mVirtualizer;
}","private IVirtualizer createVirtualizer(){
  if (mVirtualizer == null) {
    try {
      mVirtualizer=mFactory.createVirtualizer(getPlayer(0));
    }
 catch (    UnsupportedOperationException e) {
    }
catch (    IllegalArgumentException e) {
    }
  }
  return mVirtualizer;
}"
93848,"private IEqualizer createEqualizer(){
  if (mEqualizer == null) {
    try {
      mEqualizer=mFactory.createEqualizer(getPlayer(0));
    }
 catch (    UnsupportedOperationException e) {
    }
  }
  return mEqualizer;
}","private IEqualizer createEqualizer(){
  if (mEqualizer == null) {
    try {
      mEqualizer=mFactory.createEqualizer(getPlayer(0));
    }
 catch (    UnsupportedOperationException e) {
    }
catch (    IllegalArgumentException e) {
    }
  }
  return mEqualizer;
}"
93849,"private IBassBoost createBassBoost(){
  if (mBassBoost == null) {
    try {
      mBassBoost=mFactory.createBassBoost(getPlayer(0));
    }
 catch (    UnsupportedOperationException e) {
    }
  }
  return mBassBoost;
}","private IBassBoost createBassBoost(){
  if (mBassBoost == null) {
    try {
      mBassBoost=mFactory.createBassBoost(getPlayer(0));
    }
 catch (    UnsupportedOperationException e) {
    }
catch (    IllegalArgumentException e) {
    }
  }
  return mBassBoost;
}"
93850,"@Override protected void finalize() throws Throwable {
  release();
}","@Override protected void finalize() throws Throwable {
  super.finalize();
  release();
}"
93851,"static void closeQuietly(Closeable c){
  if (c != null) {
    try {
      c.close();
    }
 catch (    IOException e) {
      Log.w(TAG,""String_Node_Str"" + e.getStackTrace());
    }
  }
}","static void closeQuietly(AssetFileDescriptor afd){
  if (afd != null) {
    try {
      afd.close();
    }
 catch (    IOException e) {
      Log.w(TAG,""String_Node_Str"" + e.getStackTrace());
    }
  }
}"
93852,"protected static void closeQuietly(Closeable c){
  CommonTestCaseUtils.closeQuietly(c);
}","protected static void closeQuietly(InputStream is){
  CommonTestCaseUtils.closeQuietly(is);
}"
93853,"public static void closeQuietly(Closeable c){
  if (c == null)   return;
  try {
    c.close();
  }
 catch (  Exception e) {
  }
}","public static void closeQuietly(FileChannel is){
  if (is == null)   return;
  try {
    is.close();
  }
 catch (  Exception e) {
  }
}"
93854,"protected Context getContext(){
  return getInstrumentation().getContext();
}","protected Context getContext(){
  return getInstrumentation().getTargetContext();
}"
93855,"private void setUp(DrawerLayout drawerLayout,ViewGroup containerView){
  mFragmentContainerView=containerView;
  mDrawerLayout=drawerLayout;
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayHomeAsUpEnabled(true);
  actionBar.setHomeButtonEnabled(true);
  mDrawerToggle=new ActionBarDrawerToggle(getActivity(),mDrawerLayout,R.string.navigation_drawer_open,R.string.navigation_drawer_close){
    @Override public void onDrawerClosed(    View drawerView){
      super.onDrawerClosed(drawerView);
      if (!isAdded()) {
        return;
      }
      getActivity().supportInvalidateOptionsMenu();
    }
    @Override public void onDrawerOpened(    View drawerView){
      super.onDrawerOpened(drawerView);
      if (!isAdded()) {
        return;
      }
      getActivity().supportInvalidateOptionsMenu();
    }
  }
;
  mDrawerLayout.post(new Runnable(){
    @Override public void run(){
      mDrawerToggle.syncState();
    }
  }
);
  mDrawerLayout.setDrawerListener(mDrawerToggle);
}","private void setUp(DrawerLayout drawerLayout,ViewGroup containerView){
  mFragmentContainerView=containerView;
  mDrawerLayout=drawerLayout;
  mDrawerToggle=new ActionBarDrawerToggle(getActivity(),mDrawerLayout,R.string.navigation_drawer_open,R.string.navigation_drawer_close){
    @Override public void onDrawerClosed(    View drawerView){
      super.onDrawerClosed(drawerView);
      if (!isAdded()) {
        return;
      }
      getActivity().supportInvalidateOptionsMenu();
    }
    @Override public void onDrawerOpened(    View drawerView){
      super.onDrawerOpened(drawerView);
      if (!isAdded()) {
        return;
      }
      getActivity().supportInvalidateOptionsMenu();
    }
  }
;
  mDrawerLayout.post(new Runnable(){
    @Override public void run(){
      mDrawerToggle.syncState();
    }
  }
);
  mDrawerLayout.setDrawerListener(mDrawerToggle);
}"
93856,"long crc32(long address,long offset,long len){
  CRC32 crc=new CRC32();
  for (; len-- > 0; len--, offset++)   crc.update(Uns.getByte(address,offset));
  long h=crc.getValue();
  h|=h << 32;
  return h;
}","long crc32(long address,long offset,long len){
  CRC32 crc=new CRC32();
  for (; len-- > 0; offset++)   crc.update(Uns.getByte(address,offset));
  long h=crc.getValue();
  h|=h << 32;
  return h;
}"
93857,"static boolean compare(long hashEntryAdr,long offset,long otherHashEntryAdr,long otherOffset,long len){
  if (hashEntryAdr == 0L)   return false;
  int p=0;
  for (; p <= len - 8; p+=8, offset+=8, otherOffset+=8)   if (Uns.getLong(hashEntryAdr,offset) != Uns.getLong(otherHashEntryAdr,otherOffset))   return false;
  for (; p <= len - 4; p+=4, offset+=4, otherOffset+=4)   if (Uns.getInt(hashEntryAdr,offset) != Uns.getInt(otherHashEntryAdr,otherOffset))   return false;
  for (; p <= len - 2; p+=2, offset+=2, otherOffset+=2)   if (Uns.getShort(hashEntryAdr,offset) != Uns.getShort(otherHashEntryAdr,otherOffset))   return false;
  for (; p < len; p++, offset++, otherOffset++)   if (Uns.getByte(hashEntryAdr,offset) != Uns.getByte(otherHashEntryAdr,otherOffset))   return false;
  return true;
}","static boolean compare(long hashEntryAdr,long offset,long otherHashEntryAdr,long otherOffset,long len){
}"
93858,"public boolean commit(){
  if (closed)   return false;
  closed=true;
  if (segment(hash).putEntry(hashEntryAdr,hash,keyLen,bytes,false,0L,0L))   return true;
  Uns.free(hashEntryAdr);
  return false;
}","public boolean commit(){
  if (closed)   return false;
  if (segment(hash).putEntry(hashEntryAdr,hash,keyLen,bytes,false,0L,0L,0L)) {
    closed=true;
    return true;
  }
  super.close();
  return false;
}"
93859,"private boolean putInternal(K k,V v,boolean ifAbsent,V old){
  if (k == null || v == null)   throw new NullPointerException();
  long keyLen=keySerializer.serializedSize(k);
  long valueLen=valueSerializer.serializedSize(v);
  long bytes=Util.allocLen(keyLen,valueLen);
  long oldValueAdr=0L;
  long oldValueLen=0L;
  try {
    if (old != null) {
      oldValueLen=valueSerializer.serializedSize(old);
      oldValueAdr=Uns.allocate(oldValueLen,throwOOME);
      if (oldValueAdr == 0L)       throw new RuntimeException(""String_Node_Str"" + oldValueLen + ""String_Node_Str"");
      try {
        valueSerializer.serialize(old,new HashEntryValueOutput(oldValueAdr,oldValueLen));
      }
 catch (      RuntimeException|Error e) {
        throw e;
      }
catch (      Throwable e) {
        throw new RuntimeException(e);
      }
    }
    long hashEntryAdr;
    if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L) {
      putFailCount++;
      remove(k);
      return false;
    }
    long hash=serializeForPut(k,v,keyLen,valueLen,hashEntryAdr);
    HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
    if (segment(hash).putEntry(hashEntryAdr,hash,keyLen,bytes,ifAbsent,oldValueAdr,oldValueLen))     return true;
    Uns.free(hashEntryAdr);
    return false;
  }
  finally {
    Uns.free(oldValueAdr);
  }
}","private boolean putInternal(K k,V v,boolean ifAbsent,V old){
  if (k == null || v == null)   throw new NullPointerException();
  long keyLen=keySerializer.serializedSize(k);
  long valueLen=valueSerializer.serializedSize(v);
  long bytes=Util.allocLen(keyLen,valueLen);
  long oldValueAdr=0L;
  long oldValueLen=0L;
  try {
    if (old != null) {
      oldValueLen=valueSerializer.serializedSize(old);
      oldValueAdr=Uns.allocate(oldValueLen,throwOOME);
      if (oldValueAdr == 0L)       throw new RuntimeException(""String_Node_Str"" + oldValueLen + ""String_Node_Str"");
      try {
        valueSerializer.serialize(old,new HashEntryValueOutput(oldValueAdr,oldValueLen));
      }
 catch (      RuntimeException|Error e) {
        throw e;
      }
catch (      Throwable e) {
        throw new RuntimeException(e);
      }
    }
    long hashEntryAdr;
    if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L) {
      putFailCount++;
      remove(k);
      return false;
    }
    long hash=serializeForPut(k,v,keyLen,valueLen,hashEntryAdr);
    HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
    if (segment(hash).putEntry(hashEntryAdr,hash,keyLen,bytes,ifAbsent,oldValueAdr,0L,oldValueLen))     return true;
    Uns.free(hashEntryAdr);
    return false;
  }
  finally {
    Uns.free(oldValueAdr);
  }
}"
93860,"public DirectValueAccess putIfAbsentDirect(K k,long valueLen){
  if (k == null)   throw new NullPointerException();
  final long keyLen=keySerializer.serializedSize(k);
  final long bytes=Util.allocLen(keyLen,valueLen);
  final long hashEntryAdr;
  if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L) {
    putFailCount++;
    return null;
  }
  final long hash=serializeForPut(k,null,keyLen,valueLen,hashEntryAdr);
  HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
  if (segment(hash).hasEntry(hashEntryAdr,hash,keyLen))   return null;
  return new DirectValueAccessImpl(hashEntryAdr,keyLen,valueLen,false){
    public void close(){
      commit();
    }
    public boolean commit(){
      if (closed)       return false;
      closed=true;
      if (segment(hash).putEntry(hashEntryAdr,hash,keyLen,bytes,true,0L,0L))       return true;
      Uns.free(hashEntryAdr);
      return false;
    }
  }
;
}","public DirectValueAccess putIfAbsentDirect(K k,long valueLen){
  if (k == null)   throw new NullPointerException();
  final long keyLen=keySerializer.serializedSize(k);
  final long bytes=Util.allocLen(keyLen,valueLen);
  final long hashEntryAdr;
  if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L) {
    putFailCount++;
    return null;
  }
  final long hash=serializeForPut(k,null,keyLen,valueLen,hashEntryAdr);
  HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
  if (segment(hash).hasEntry(hashEntryAdr,hash,keyLen)) {
    Uns.free(hashEntryAdr);
    return null;
  }
  return new DirectValueAccessImpl(hashEntryAdr,keyLen,valueLen,false){
    public void close(){
      commit();
    }
    public boolean commit(){
      if (closed)       return false;
      if (segment(hash).putEntry(hashEntryAdr,hash,keyLen,bytes,true,0L,0L,0L)) {
        closed=true;
        return true;
      }
      super.close();
      return false;
    }
  }
;
}"
93861,"public DirectValueAccess addOrReplaceDirect(K k,DirectValueAccess old,long valueLen){
  if (k == null)   throw new NullPointerException();
  final DirectValueAccessImpl oldImpl=(DirectValueAccessImpl)old;
  if (oldImpl != null && oldImpl.closed)   throw new IllegalStateException(""String_Node_Str"");
  final long keyLen=keySerializer.serializedSize(k);
  final long bytes=Util.allocLen(keyLen,valueLen);
  final long hashEntryAdr;
  if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L) {
    putFailCount++;
    remove(k);
    return null;
  }
  final long hash=serializeForPut(k,null,keyLen,valueLen,hashEntryAdr);
  HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
  if (!segment(hash).hasEntry(hashEntryAdr,hash,keyLen))   return null;
  return new DirectValueAccessImpl(hashEntryAdr,keyLen,valueLen,false){
    public void close(){
      commit();
    }
    public boolean commit(){
      if (closed)       return false;
      closed=true;
      if (segment(hash).putEntry(hashEntryAdr,hash,keyLen,bytes,false,oldImpl != null ? oldImpl.valueAdr() : 0L,oldImpl != null ? oldImpl.valueLen() : 0L))       return true;
      Uns.free(hashEntryAdr);
      return false;
    }
  }
;
}","public DirectValueAccess addOrReplaceDirect(K k,DirectValueAccess old,long valueLen){
  if (k == null)   throw new NullPointerException();
  final DirectValueAccessImpl oldImpl=(DirectValueAccessImpl)old;
  if (oldImpl != null && oldImpl.closed)   throw new IllegalStateException(""String_Node_Str"");
  final long keyLen=keySerializer.serializedSize(k);
  final long bytes=Util.allocLen(keyLen,valueLen);
  final long hashEntryAdr;
  if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L) {
    putFailCount++;
    remove(k);
    return null;
  }
  final long hash=serializeForPut(k,null,keyLen,valueLen,hashEntryAdr);
  HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
  if (!segment(hash).hasEntry(hashEntryAdr,hash,keyLen)) {
    Uns.free(hashEntryAdr);
    return null;
  }
  return new DirectValueAccessImpl(hashEntryAdr,keyLen,valueLen,false){
    public void close(){
      commit();
    }
    public boolean commit(){
      if (closed)       return false;
      if (segment(hash).putEntry(hashEntryAdr,hash,keyLen,bytes,false,oldImpl != null ? oldImpl.hashEntryAdr() : 0L,oldImpl != null ? oldImpl.valueOffset() : 0L,oldImpl != null ? oldImpl.valueLen() : 0L)) {
        closed=true;
        return true;
      }
      super.close();
      return false;
    }
  }
;
}"
93862,"public boolean deserializeEntry(ReadableByteChannel channel) throws IOException {
  byte[] hashKeyValueLen=new byte[3 * 8];
  ByteBuffer bb=ByteBuffer.wrap(hashKeyValueLen);
  if (!Util.readFully(channel,bb))   return false;
  long hash=Uns.getLongFromByteArray(hashKeyValueLen,0);
  long valueLen=Uns.getLongFromByteArray(hashKeyValueLen,8);
  long keyLen=Uns.getLongFromByteArray(hashKeyValueLen,16);
  long kvLen=Util.roundUpTo8(keyLen) + valueLen;
  long totalLen=kvLen + Util.ENTRY_OFF_DATA;
  long hashEntryAdr;
  if ((maxEntrySize > 0L && totalLen > maxEntrySize) || (hashEntryAdr=Uns.allocate(totalLen,throwOOME)) == 0L) {
    if (channel instanceof SeekableByteChannel) {
      SeekableByteChannel sc=(SeekableByteChannel)channel;
      sc.position(sc.position() + kvLen);
    }
 else {
      ByteBuffer tmp=ByteBuffer.allocate(8192);
      while (kvLen > 0L) {
        tmp.clear();
        if (kvLen < tmp.capacity())         tmp.limit((int)kvLen);
        if (!Util.readFully(channel,tmp))         return false;
        kvLen-=tmp.limit();
      }
    }
    return false;
  }
  HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
  if (!Util.readFully(channel,Uns.directBufferFor(hashEntryAdr,Util.ENTRY_OFF_DATA,kvLen,false)) || !segment(hash).putEntry(hashEntryAdr,hash,keyLen,totalLen,false,0L,0L)) {
    Uns.free(hashEntryAdr);
    return false;
  }
  return true;
}","public boolean deserializeEntry(ReadableByteChannel channel) throws IOException {
  byte[] hashKeyValueLen=new byte[3 * 8];
  ByteBuffer bb=ByteBuffer.wrap(hashKeyValueLen);
  if (!Util.readFully(channel,bb))   return false;
  long hash=Uns.getLongFromByteArray(hashKeyValueLen,0);
  long valueLen=Uns.getLongFromByteArray(hashKeyValueLen,8);
  long keyLen=Uns.getLongFromByteArray(hashKeyValueLen,16);
  long kvLen=Util.roundUpTo8(keyLen) + valueLen;
  long totalLen=kvLen + Util.ENTRY_OFF_DATA;
  long hashEntryAdr;
  if ((maxEntrySize > 0L && totalLen > maxEntrySize) || (hashEntryAdr=Uns.allocate(totalLen,throwOOME)) == 0L) {
    if (channel instanceof SeekableByteChannel) {
      SeekableByteChannel sc=(SeekableByteChannel)channel;
      sc.position(sc.position() + kvLen);
    }
 else {
      ByteBuffer tmp=ByteBuffer.allocate(8192);
      while (kvLen > 0L) {
        tmp.clear();
        if (kvLen < tmp.capacity())         tmp.limit((int)kvLen);
        if (!Util.readFully(channel,tmp))         return false;
        kvLen-=tmp.limit();
      }
    }
    return false;
  }
  HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
  if (!Util.readFully(channel,Uns.directBufferFor(hashEntryAdr,Util.ENTRY_OFF_DATA,kvLen,false)) || !segment(hash).putEntry(hashEntryAdr,hash,keyLen,totalLen,false,0L,0L,0L)) {
    Uns.free(hashEntryAdr);
    return false;
  }
  return true;
}"
93863,"public Future<V> getWithLoaderAsync(final K key,final CacheLoader<K,V> loader){
  if (key == null)   throw new NullPointerException();
  if (executorService == null || executorService.isShutdown() || closed)   throw new IllegalStateException(""String_Node_Str"");
  final KeyBuffer keySource=keySource(key);
  final OffHeapMap segment=segment(keySource.hash());
  long hashEntryAdr=segment.getEntry(keySource,true);
  if (hashEntryAdr == 0L) {
    final long keyLen=keySerializer.serializedSize(key);
    long bytes=Util.allocLen(keyLen,0L);
    if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L) {
      putFailCount++;
      remove(key);
      return Futures.immediateFailedFuture(new RuntimeException(""String_Node_Str""));
    }
    final HashEntryKeyOutput keyOut=new HashEntryKeyOutput(hashEntryAdr,keyLen);
    try {
      keySerializer.serialize(key,keyOut);
    }
 catch (    Throwable e) {
      freeAndThrow(e,hashEntryAdr);
    }
    final long hash=keyOut.hash(hasher);
    HashEntries.init(hash,keyLen,0L,hashEntryAdr,Util.SENTINEL_LOADING);
    if (segment.putEntry(hashEntryAdr,hash,keyLen,bytes,true,0L,0L)) {
      final long sentinelHashEntryAdr=hashEntryAdr;
      return executorService.submit(new Callable<V>(){
        public V call() throws Exception {
          Exception failure=null;
          V value=null;
          boolean replaced=false;
          try {
            value=loader.load(key);
            long valueLen=valueSerializer.serializedSize(value);
            long bytes=Util.allocLen(keyLen,valueLen);
            long hashEntryAdr;
            if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L)             throw new RuntimeException(""String_Node_Str"");
            long hash=serializeForPut(key,value,keyLen,valueLen,hashEntryAdr);
            HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
            if (!segment.replaceEntry(hash,sentinelHashEntryAdr,hashEntryAdr,bytes))             throw new RuntimeException(""String_Node_Str"");
            replaced=true;
            HashEntries.setSentinel(sentinelHashEntryAdr,Util.SENTINEL_SUCCESS);
            HashEntries.dereference(sentinelHashEntryAdr);
          }
 catch (          PermanentLoadException e) {
            HashEntries.setSentinel(sentinelHashEntryAdr,Util.SENTINEL_PERMANENT_FAILURE);
            throw e;
          }
catch (          Throwable e) {
            failure=e instanceof Exception ? (Exception)e : new RuntimeException(e);
            HashEntries.setSentinel(sentinelHashEntryAdr,Util.SENTINEL_TEMPORARY_FAILURE);
            if (replaced)             HashEntries.dereference(sentinelHashEntryAdr);
 else             segment.removeEntry(sentinelHashEntryAdr);
          }
          if (failure != null)           throw failure;
          return value;
        }
      }
);
    }
 else {
      Uns.free(hashEntryAdr);
    }
  }
  int sentinelStatus=HashEntries.getSentinel(hashEntryAdr);
switch (sentinelStatus) {
case Util.SENTINEL_NOT_PRESENT:
    try {
      return Futures.immediateFuture(valueSerializer.deserialize(new HashEntryValueInput(hashEntryAdr)));
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
 finally {
      HashEntries.dereference(hashEntryAdr);
    }
case Util.SENTINEL_PERMANENT_FAILURE:
  HashEntries.dereference(hashEntryAdr);
return Futures.immediateFailedFuture(new PermanentLoadException());
}
final SettableFuture<V> future=SettableFuture.create();
final long sentinelHashEntryAdr=hashEntryAdr;
executorService.schedule(new Runnable(){
public void run(){
if (future.isCancelled() || closed) {
  HashEntries.dereference(sentinelHashEntryAdr);
  return;
}
int sentinelStatus=HashEntries.getSentinel(sentinelHashEntryAdr);
switch (sentinelStatus) {
case Util.SENTINEL_SUCCESS:
  break;
case Util.SENTINEL_LOADING:
reschedule(0L);
return;
case Util.SENTINEL_PERMANENT_FAILURE:
failure(0L,new PermanentLoadException());
return;
case Util.SENTINEL_TEMPORARY_FAILURE:
failure(0L,new TemporaryLoadException());
return;
default :
failure(0L,new AssertionError(""String_Node_Str"" + sentinelStatus));
return;
}
long hashEntryAdr=segment.getEntry(keySource,true);
if (hashEntryAdr == 0L) {
future.setException(new TemporaryLoadException());
}
if (hashEntryAdr == sentinelHashEntryAdr) {
reschedule(0L);
return;
}
sentinelStatus=HashEntries.getSentinel(hashEntryAdr);
switch (sentinelStatus) {
case Util.SENTINEL_NOT_PRESENT:
try {
future.set(valueSerializer.deserialize(new HashEntryValueInput(hashEntryAdr)));
HashEntries.dereference(hashEntryAdr);
HashEntries.dereference(sentinelHashEntryAdr);
}
 catch (Throwable e) {
failure(hashEntryAdr,e);
}
break;
case Util.SENTINEL_SUCCESS:
case Util.SENTINEL_LOADING:
HashEntries.dereference(hashEntryAdr);
reschedule(hashEntryAdr);
break;
case Util.SENTINEL_PERMANENT_FAILURE:
failure(hashEntryAdr,new PermanentLoadException());
break;
case Util.SENTINEL_TEMPORARY_FAILURE:
failure(hashEntryAdr,new TemporaryLoadException());
break;
default :
failure(hashEntryAdr,new AssertionError(""String_Node_Str"" + sentinelStatus));
break;
}
}
private void failure(long hashEntryAdr,Throwable e){
if (hashEntryAdr != 0L) HashEntries.dereference(hashEntryAdr);
HashEntries.dereference(sentinelHashEntryAdr);
future.setException(e);
}
private void reschedule(long hashEntryAdr){
try {
executorService.schedule(this,10,TimeUnit.MILLISECONDS);
}
 catch (Throwable t) {
failure(hashEntryAdr,t);
}
}
}
,10,TimeUnit.MILLISECONDS);
return future;
}","public Future<V> getWithLoaderAsync(final K key,final CacheLoader<K,V> loader){
  if (key == null)   throw new NullPointerException();
  if (executorService == null || executorService.isShutdown() || closed)   throw new IllegalStateException(""String_Node_Str"");
  final KeyBuffer keySource=keySource(key);
  final OffHeapMap segment=segment(keySource.hash());
  long hashEntryAdr=segment.getEntry(keySource,true);
  if (hashEntryAdr == 0L) {
    final long keyLen=keySerializer.serializedSize(key);
    long bytes=Util.allocLen(keyLen,0L);
    if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L) {
      putFailCount++;
      remove(key);
      return Futures.immediateFailedFuture(new RuntimeException(""String_Node_Str""));
    }
    final HashEntryKeyOutput keyOut=new HashEntryKeyOutput(hashEntryAdr,keyLen);
    try {
      keySerializer.serialize(key,keyOut);
    }
 catch (    Throwable e) {
      freeAndThrow(e,hashEntryAdr);
    }
    final long hash=keyOut.hash(hasher);
    HashEntries.init(hash,keyLen,0L,hashEntryAdr,Util.SENTINEL_LOADING);
    if (segment.putEntry(hashEntryAdr,hash,keyLen,bytes,true,0L,0L,0L)) {
      final long sentinelHashEntryAdr=hashEntryAdr;
      return executorService.submit(new Callable<V>(){
        public V call() throws Exception {
          Exception failure=null;
          V value=null;
          boolean replaced=false;
          try {
            value=loader.load(key);
            long valueLen=valueSerializer.serializedSize(value);
            long bytes=Util.allocLen(keyLen,valueLen);
            long hashEntryAdr;
            if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L)             throw new RuntimeException(""String_Node_Str"");
            long hash=serializeForPut(key,value,keyLen,valueLen,hashEntryAdr);
            HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
            if (!segment.replaceEntry(hash,sentinelHashEntryAdr,hashEntryAdr,bytes))             throw new RuntimeException(""String_Node_Str"");
            replaced=true;
            HashEntries.setSentinel(sentinelHashEntryAdr,Util.SENTINEL_SUCCESS);
            HashEntries.dereference(sentinelHashEntryAdr);
          }
 catch (          PermanentLoadException e) {
            HashEntries.setSentinel(sentinelHashEntryAdr,Util.SENTINEL_PERMANENT_FAILURE);
            throw e;
          }
catch (          Throwable e) {
            failure=e instanceof Exception ? (Exception)e : new RuntimeException(e);
            HashEntries.setSentinel(sentinelHashEntryAdr,Util.SENTINEL_TEMPORARY_FAILURE);
            if (replaced)             HashEntries.dereference(sentinelHashEntryAdr);
 else             segment.removeEntry(sentinelHashEntryAdr);
          }
          if (failure != null)           throw failure;
          return value;
        }
      }
);
    }
 else {
      Uns.free(hashEntryAdr);
    }
  }
  int sentinelStatus=HashEntries.getSentinel(hashEntryAdr);
switch (sentinelStatus) {
case Util.SENTINEL_NOT_PRESENT:
    try {
      return Futures.immediateFuture(valueSerializer.deserialize(new HashEntryValueInput(hashEntryAdr)));
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
 finally {
      HashEntries.dereference(hashEntryAdr);
    }
case Util.SENTINEL_PERMANENT_FAILURE:
  HashEntries.dereference(hashEntryAdr);
return Futures.immediateFailedFuture(new PermanentLoadException());
}
final SettableFuture<V> future=SettableFuture.create();
final long sentinelHashEntryAdr=hashEntryAdr;
executorService.schedule(new Runnable(){
public void run(){
if (future.isCancelled() || closed) {
  HashEntries.dereference(sentinelHashEntryAdr);
  return;
}
int sentinelStatus=HashEntries.getSentinel(sentinelHashEntryAdr);
switch (sentinelStatus) {
case Util.SENTINEL_SUCCESS:
  break;
case Util.SENTINEL_LOADING:
reschedule(0L);
return;
case Util.SENTINEL_PERMANENT_FAILURE:
failure(0L,new PermanentLoadException());
return;
case Util.SENTINEL_TEMPORARY_FAILURE:
failure(0L,new TemporaryLoadException());
return;
default :
failure(0L,new AssertionError(""String_Node_Str"" + sentinelStatus));
return;
}
long hashEntryAdr=segment.getEntry(keySource,true);
if (hashEntryAdr == 0L) {
future.setException(new TemporaryLoadException());
}
if (hashEntryAdr == sentinelHashEntryAdr) {
reschedule(0L);
return;
}
sentinelStatus=HashEntries.getSentinel(hashEntryAdr);
switch (sentinelStatus) {
case Util.SENTINEL_NOT_PRESENT:
try {
future.set(valueSerializer.deserialize(new HashEntryValueInput(hashEntryAdr)));
HashEntries.dereference(hashEntryAdr);
HashEntries.dereference(sentinelHashEntryAdr);
}
 catch (Throwable e) {
failure(hashEntryAdr,e);
}
break;
case Util.SENTINEL_SUCCESS:
case Util.SENTINEL_LOADING:
HashEntries.dereference(hashEntryAdr);
reschedule(hashEntryAdr);
break;
case Util.SENTINEL_PERMANENT_FAILURE:
failure(hashEntryAdr,new PermanentLoadException());
break;
case Util.SENTINEL_TEMPORARY_FAILURE:
failure(hashEntryAdr,new TemporaryLoadException());
break;
default :
failure(hashEntryAdr,new AssertionError(""String_Node_Str"" + sentinelStatus));
break;
}
}
private void failure(long hashEntryAdr,Throwable e){
if (hashEntryAdr != 0L) HashEntries.dereference(hashEntryAdr);
HashEntries.dereference(sentinelHashEntryAdr);
future.setException(e);
}
private void reschedule(long hashEntryAdr){
try {
executorService.schedule(this,10,TimeUnit.MILLISECONDS);
}
 catch (Throwable t) {
failure(hashEntryAdr,t);
}
}
}
,10,TimeUnit.MILLISECONDS);
return future;
}"
93864,"public DirectValueAccess putDirect(K k,long valueLen){
  if (k == null)   throw new NullPointerException();
  final long keyLen=keySerializer.serializedSize(k);
  final long bytes=Util.allocLen(keyLen,valueLen);
  final long hashEntryAdr;
  if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L) {
    putFailCount++;
    remove(k);
    return null;
  }
  final long hash=serializeForPut(k,null,keyLen,valueLen,hashEntryAdr);
  HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
  return new DirectValueAccessImpl(hashEntryAdr,keyLen,valueLen,false){
    public void close(){
      commit();
    }
    public boolean commit(){
      if (closed)       return false;
      closed=true;
      if (segment(hash).putEntry(hashEntryAdr,hash,keyLen,bytes,false,0L,0L))       return true;
      Uns.free(hashEntryAdr);
      return false;
    }
  }
;
}","public DirectValueAccess putDirect(K k,long valueLen){
  if (k == null)   throw new NullPointerException();
  final long keyLen=keySerializer.serializedSize(k);
  final long bytes=Util.allocLen(keyLen,valueLen);
  final long hashEntryAdr;
  if ((maxEntrySize > 0L && bytes > maxEntrySize) || (hashEntryAdr=Uns.allocate(bytes,throwOOME)) == 0L) {
    putFailCount++;
    remove(k);
    return null;
  }
  final long hash=serializeForPut(k,null,keyLen,valueLen,hashEntryAdr);
  HashEntries.init(hash,keyLen,valueLen,hashEntryAdr,Util.SENTINEL_NOT_PRESENT);
  return new DirectValueAccessImpl(hashEntryAdr,keyLen,valueLen,false){
    public void close(){
      commit();
    }
    public boolean commit(){
      if (closed)       return false;
      if (segment(hash).putEntry(hashEntryAdr,hash,keyLen,bytes,false,0L,0L,0L)) {
        closed=true;
        return true;
      }
      super.close();
      return false;
    }
  }
;
}"
93865,"boolean putEntry(long newHashEntryAdr,long hash,long keyLen,long bytes,boolean ifAbsent,long oldValueAdr,long oldValueLen){
  long removeHashEntryAdr=0L;
  LongArrayList derefList=null;
  lock.lock();
  try {
    long oldHashEntryAdr=0L;
    long hashEntryAdr;
    long prevEntryAdr=0L;
    for (hashEntryAdr=table.getFirst(hash); hashEntryAdr != 0L; prevEntryAdr=hashEntryAdr, hashEntryAdr=HashEntries.getNext(hashEntryAdr)) {
      if (notSameKey(newHashEntryAdr,hash,keyLen,hashEntryAdr))       continue;
      if (ifAbsent)       return false;
      if (oldValueAdr != 0L) {
        long valueLen=HashEntries.getValueLen(hashEntryAdr);
        if (valueLen != oldValueLen || !HashEntries.compare(hashEntryAdr,Util.ENTRY_OFF_DATA + Util.roundUpTo8(keyLen),oldValueAdr,0L,oldValueLen))         return false;
      }
      removeInternal(hashEntryAdr,prevEntryAdr);
      removeHashEntryAdr=hashEntryAdr;
      oldHashEntryAdr=hashEntryAdr;
      break;
    }
    while (freeCapacity < bytes) {
      long eldestHashAdr=removeEldest();
      if (eldestHashAdr == 0L) {
        if (oldHashEntryAdr != 0L)         size--;
        return false;
      }
      if (derefList == null)       derefList=new LongArrayList();
      derefList.add(eldestHashAdr);
    }
    if (hashEntryAdr == 0L) {
      if (size >= threshold)       rehash();
      size++;
    }
    freeCapacity-=bytes;
    add(newHashEntryAdr,hash);
    if (hashEntryAdr == 0L)     putAddCount++;
 else     putReplaceCount++;
    return true;
  }
  finally {
    lock.unlock();
    if (removeHashEntryAdr != 0L)     HashEntries.dereference(removeHashEntryAdr);
    if (derefList != null)     for (int i=0; i < derefList.size(); i++)     HashEntries.dereference(derefList.getLong(i));
  }
}","boolean putEntry(long newHashEntryAdr,long hash,long keyLen,long bytes,boolean ifAbsent,long oldValueAddr,long oldValueOffset,long oldValueLen){
  long removeHashEntryAdr=0L;
  LongArrayList derefList=null;
  lock.lock();
  try {
    long oldHashEntryAdr=0L;
    long hashEntryAdr;
    long prevEntryAdr=0L;
    for (hashEntryAdr=table.getFirst(hash); hashEntryAdr != 0L; prevEntryAdr=hashEntryAdr, hashEntryAdr=HashEntries.getNext(hashEntryAdr)) {
      if (notSameKey(newHashEntryAdr,hash,keyLen,hashEntryAdr))       continue;
      if (ifAbsent)       return false;
      if (oldValueAddr != 0L) {
        long valueLen=HashEntries.getValueLen(hashEntryAdr);
        if (valueLen != oldValueLen || !HashEntries.compare(hashEntryAdr,Util.ENTRY_OFF_DATA + Util.roundUpTo8(keyLen),oldValueAddr,oldValueOffset,oldValueLen))         return false;
      }
      removeInternal(hashEntryAdr,prevEntryAdr);
      removeHashEntryAdr=hashEntryAdr;
      oldHashEntryAdr=hashEntryAdr;
      break;
    }
    while (freeCapacity < bytes) {
      long eldestHashAdr=removeEldest();
      if (eldestHashAdr == 0L) {
        if (oldHashEntryAdr != 0L)         size--;
        return false;
      }
      if (derefList == null)       derefList=new LongArrayList();
      derefList.add(eldestHashAdr);
    }
    if (hashEntryAdr == 0L) {
      if (size >= threshold)       rehash();
      size++;
    }
    freeCapacity-=bytes;
    add(newHashEntryAdr,hash);
    if (hashEntryAdr == 0L)     putAddCount++;
 else     putReplaceCount++;
    return true;
  }
  finally {
    lock.unlock();
    if (removeHashEntryAdr != 0L)     HashEntries.dereference(removeHashEntryAdr);
    if (derefList != null)     for (int i=0; i < derefList.size(); i++)     HashEntries.dereference(derefList.getLong(i));
  }
}"
93866,"static void clearUnsDebugForTest(){
  if (__DEBUG_OFF_HEAP_MEMORY_ACCESS) {
    try {
      if (!ohDebug.isEmpty()) {
        for (        Map.Entry<Long,AllocInfo> addrSize : ohDebug.entrySet()) {
          System.err.printf(""String_Node_Str"",addrSize.getKey(),addrSize.getValue().size);
          addrSize.getValue().trace.printStackTrace();
        }
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  finally {
      ohDebug.clear();
      ohFreeDebug.clear();
    }
  }
}","static void clearUnsDebugForTest(){
  if (__DEBUG_OFF_HEAP_MEMORY_ACCESS) {
    try {
      if (!ohDebug.isEmpty()) {
        for (        Map.Entry<Long,AllocInfo> addrSize : ohDebug.entrySet()) {
          System.err.printf(""String_Node_Str"",addrSize.getKey(),addrSize.getValue().size,getInt(addrSize.getKey(),Util.ENTRY_OFF_REFCOUNT));
          addrSize.getValue().trace.printStackTrace();
        }
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  finally {
      ohDebug.clear();
      ohFreeDebug.clear();
    }
  }
}"
93867,"@Test public void testDirectAddOrReplace() throws Exception {
  try (OHCache<Integer,String> cache=OHCacheBuilder.<Integer,String>newBuilder().keySerializer(TestUtils.intSerializer).valueSerializer(TestUtils.stringSerializer).capacity(64 * 1024 * 1024).build()){
    for (int i=0; i < 100; i++) {
      Assert.assertNull(cache.addOrReplaceDirect(i,null,i + 10));
      DirectValueAccess direct=cache.putIfAbsentDirect(i,i + 10);
      try {
        for (int j=0; j < 100; j++)         Assert.assertNull(cache.getDirect(i));
        for (int c=0; c < i + 10; c++)         direct.buffer().put((byte)i);
      }
  finally {
        Assert.assertTrue(direct.commit());
      }
    }
    for (int i=0; i < 100; i++) {
      try (DirectValueAccess ex=cache.getDirect(i)){
        Assert.assertNotNull(ex);
        DirectValueAccess direct=cache.addOrReplaceDirect(i,ex,i + 10);
        try {
          for (int c=0; c < i + 10; c++)           direct.buffer().put((byte)i);
        }
  finally {
          Assert.assertTrue(direct.commit());
        }
      }
     }
    for (int i=0; i < 100; i++) {
      DirectValueAccess direct=cache.addOrReplaceDirect(i,null,i + 10);
      try {
        for (int c=0; c < i + 10; c++)         direct.buffer().put((byte)i);
      }
  finally {
        Assert.assertTrue(direct.commit());
      }
    }
  }
 }","@Test public void testDirectAddOrReplace() throws Exception {
  try (OHCache<Integer,String> cache=OHCacheBuilder.<Integer,String>newBuilder().keySerializer(TestUtils.intSerializer).valueSerializer(TestUtils.stringSerializer).capacity(64 * 1024 * 1024).build()){
    for (int i=0; i < 100; i++) {
      Assert.assertNull(cache.addOrReplaceDirect(i,null,i + 10));
      DirectValueAccess direct=cache.putIfAbsentDirect(i,i + 10);
      try {
        for (int j=0; j < 100; j++)         Assert.assertNull(cache.getDirect(i));
        for (int c=0; c < i + 10; c++)         direct.buffer().put((byte)i);
      }
  finally {
        Assert.assertTrue(direct.commit());
      }
      Assert.assertNull(cache.putIfAbsentDirect(i,i + 10));
    }
    cache.clear();
    for (int i=0; i < 100; i++) {
      Assert.assertNull(cache.addOrReplaceDirect(i,null,i + 10));
      DirectValueAccess direct=cache.putIfAbsentDirect(i,i + 10);
      try {
        try (DirectValueAccess conc=cache.putDirect(i,i + 10)){
          for (int c=0; c < i + 10; c++)           conc.buffer().put((byte)i);
        }
         for (int j=0; j < 100; j++)         try (DirectValueAccess chk=cache.getDirect(i)){
          Assert.assertNotNull(chk);
        }
         for (int c=0; c < i + 10; c++)         direct.buffer().put((byte)i);
      }
  finally {
        Assert.assertFalse(direct.commit());
      }
      Assert.assertNull(cache.putIfAbsentDirect(i,i + 10));
    }
    for (int i=0; i < 100; i++) {
      try (DirectValueAccess ex=cache.getDirect(i)){
        Assert.assertNotNull(ex);
        DirectValueAccess direct=cache.addOrReplaceDirect(i,ex,i + 10);
        try {
          for (int c=0; c < i + 10; c++)           direct.buffer().put((byte)i);
        }
  finally {
          Assert.assertTrue(direct.commit());
        }
      }
     }
    for (int i=0; i < 100; i++) {
      try (DirectValueAccess ex=cache.getDirect(i)){
        Assert.assertNotNull(ex);
        cache.put(i,""String_Node_Str"" + i);
        DirectValueAccess direct=cache.addOrReplaceDirect(i,ex,i + 10);
        try {
          for (int c=0; c < i + 10; c++)           direct.buffer().put((byte)i);
        }
  finally {
          Assert.assertFalse(direct.commit());
        }
        Assert.assertEquals(cache.get(i),""String_Node_Str"" + i);
      }
     }
    for (int i=0; i < 100; i++) {
      DirectValueAccess direct=cache.addOrReplaceDirect(i,null,i + 10);
      try {
        for (int c=0; c < i + 10; c++)         direct.buffer().put((byte)i);
      }
  finally {
        Assert.assertTrue(direct.commit());
      }
    }
  }
 }"
93868,"synchronized long[] hotN(int n){
  long[] r=new long[n];
  int i=0;
  for (long hashEntryAdr=lruHead; hashEntryAdr != 0L; hashEntryAdr=getLruNext(hashEntryAdr)) {
    r[i++]=hashEntryAdr;
    HashEntries.reference(hashEntryAdr);
  }
  return r;
}","synchronized long[] hotN(int n){
  long[] r=new long[n];
  int i=0;
  for (long hashEntryAdr=lruHead; hashEntryAdr != 0L && i < n; hashEntryAdr=getLruNext(hashEntryAdr)) {
    r[i++]=hashEntryAdr;
    HashEntries.reference(hashEntryAdr);
  }
  return r;
}"
93869,"private void dereference(long hashEntryAdr){
  if (HashEntries.dereference(hashEntryAdr))   free(hashEntryAdr);
}","private void dereference(long hashEntryAdr){
  if (HashEntries.dereference(hashEntryAdr)) {
    if (hashEntryAdr == 0L)     throw new NullPointerException();
    long bytes=HashEntries.getAllocLen(hashEntryAdr);
    if (bytes == 0L)     throw new IllegalStateException();
    long hash=HashEntries.getHash(hashEntryAdr);
    Uns.free(hashEntryAdr);
    segment(hash).freed(bytes);
  }
}"
93870,"private PutResult put(K k,V v,boolean ifAbsent){
  KeyBuffer key=keySource(k);
  long keyLen=key.size();
  long valueLen=valueSerializer.serializedSize(v);
  long hash=key.hash();
  long bytes=allocLen(keyLen,valueLen);
  long hashEntryAdr;
  if (bytes > maxEntrySize || (hashEntryAdr=Uns.allocate(bytes)) == 0L) {
    if (statisticsEnabled)     putFailCount++;
    removeInternal(key);
    return PutResult.FAIL;
  }
  HashEntries.init(hash,keyLen,valueLen,hashEntryAdr);
  HashEntries.toOffHeap(key,hashEntryAdr,ENTRY_OFF_DATA);
  try {
    valueSerializer.serialize(v,new HashEntryValueOutput(hashEntryAdr,key.size(),valueLen));
  }
 catch (  Error e) {
    Uns.free(hashEntryAdr);
    throw e;
  }
catch (  Throwable e) {
    Uns.free(hashEntryAdr);
    throw new IOError(e);
  }
  return segment(hash).putEntry(key,hashEntryAdr,bytes,ifAbsent) ? PutResult.OK : PutResult.KEY_PRESENT;
}","private PutResult put(K k,V v,boolean ifAbsent){
  KeyBuffer key=keySource(k);
  long keyLen=key.size();
  long valueLen=valueSerializer.serializedSize(v);
  long hash=key.hash();
  long bytes=allocLen(keyLen,valueLen);
  long hashEntryAdr;
  if (bytes > maxEntrySize || (hashEntryAdr=Uns.allocate(bytes)) == 0L) {
    putFailCount++;
    removeInternal(key);
    return PutResult.FAIL;
  }
  HashEntries.init(hash,keyLen,valueLen,hashEntryAdr);
  HashEntries.toOffHeap(key,hashEntryAdr,ENTRY_OFF_DATA);
  try {
    valueSerializer.serialize(v,new HashEntryValueOutput(hashEntryAdr,key.size(),valueLen));
  }
 catch (  Error e) {
    Uns.free(hashEntryAdr);
    throw e;
  }
catch (  Throwable e) {
    Uns.free(hashEntryAdr);
    throw new IOError(e);
  }
  return segment(hash).putEntry(key,hashEntryAdr,bytes,ifAbsent) ? PutResult.OK : PutResult.KEY_PRESENT;
}"
93871,"public SegmentedCacheImpl(OHCacheBuilder<K,V> builder){
  long capacity=builder.getCapacity();
  if (capacity <= 0L)   throw new IllegalArgumentException(""String_Node_Str"");
  double cuTrigger=builder.getCleanUpTriggerFree();
  long cleanUpTriggerFree;
  if (cuTrigger < 0d) {
    if (capacity < 8L * ONE_GIGABYTE)     cleanUpTriggerFree=(long)(.125d * capacity);
 else     if (capacity < 16L * ONE_GIGABYTE)     cleanUpTriggerFree=(long)(.10d * capacity);
 else     cleanUpTriggerFree=(long)(.05d * capacity);
  }
 else {
    if (cuTrigger >= 1d)     throw new IllegalArgumentException(""String_Node_Str"" + String.format(""String_Node_Str"",cuTrigger));
    cuTrigger*=capacity;
    cleanUpTriggerFree=(long)cuTrigger;
  }
  int segments=builder.getSegmentCount();
  if (segments <= 0)   segments=Runtime.getRuntime().availableProcessors() * 2;
  segments=OffHeapMap.roundUpToPowerOf2(segments);
  maps=new OffHeapMap[segments];
  for (int i=0; i < segments; i++)   maps[i]=new OffHeapMap(builder,capacity / segments,cleanUpTriggerFree / segments);
  int bitNum=bitNum(segments) - 1;
  this.segmentShift=64 - bitNum;
  this.segmentMask=((long)segments - 1) << segmentShift;
  double mes=builder.getMaxEntrySize();
  long maxEntrySize;
  if (mes <= 0d || mes >= 1d)   maxEntrySize=capacity / segments / 128;
 else   maxEntrySize=(long)(mes * capacity / segments);
  this.maxEntrySize=maxEntrySize;
  this.statisticsEnabled=builder.isStatisticsEnabled();
  this.keySerializer=builder.getKeySerializer();
  if (keySerializer == null)   throw new NullPointerException(""String_Node_Str"");
  this.valueSerializer=builder.getValueSerializer();
  if (valueSerializer == null)   throw new NullPointerException(""String_Node_Str"");
}","public SegmentedCacheImpl(OHCacheBuilder<K,V> builder){
  long capacity=builder.getCapacity();
  if (capacity <= 0L)   throw new IllegalArgumentException(""String_Node_Str"");
  double cuTrigger=builder.getCleanUpTriggerFree();
  long cleanUpTriggerFree;
  if (cuTrigger < 0d) {
    if (capacity < 8L * ONE_GIGABYTE)     cleanUpTriggerFree=(long)(.125d * capacity);
 else     if (capacity < 16L * ONE_GIGABYTE)     cleanUpTriggerFree=(long)(.10d * capacity);
 else     cleanUpTriggerFree=(long)(.05d * capacity);
  }
 else {
    if (cuTrigger >= 1d)     throw new IllegalArgumentException(""String_Node_Str"" + String.format(""String_Node_Str"",cuTrigger));
    cuTrigger*=capacity;
    cleanUpTriggerFree=(long)cuTrigger;
  }
  int segments=builder.getSegmentCount();
  if (segments <= 0)   segments=Runtime.getRuntime().availableProcessors() * 2;
  segments=OffHeapMap.roundUpToPowerOf2(segments);
  maps=new OffHeapMap[segments];
  for (int i=0; i < segments; i++)   maps[i]=new OffHeapMap(builder,capacity / segments,cleanUpTriggerFree / segments);
  int bitNum=bitNum(segments) - 1;
  this.segmentShift=64 - bitNum;
  this.segmentMask=((long)segments - 1) << segmentShift;
  double mes=builder.getMaxEntrySize();
  long maxEntrySize;
  if (mes <= 0d || mes >= 1d)   maxEntrySize=capacity / segments / 128;
 else   maxEntrySize=(long)(mes * capacity / segments);
  this.maxEntrySize=maxEntrySize;
  this.keySerializer=builder.getKeySerializer();
  if (keySerializer == null)   throw new NullPointerException(""String_Node_Str"");
  this.valueSerializer=builder.getValueSerializer();
  if (valueSerializer == null)   throw new NullPointerException(""String_Node_Str"");
}"
93872,"public void put(K k,V v){
  assertNotClosed();
  if (valueSerializer == null)   throw new NullPointerException(""String_Node_Str"");
  BytesSource.ByteArraySource ks=keySource(k);
  int hash=ks.hashCode();
  long valueLen=valueSerializer.serializedSize(v);
  long newHashEntryAdr=hashEntryAccess.createNewEntryChain(hash,ks,null,valueLen);
  if (newHashEntryAdr == 0L)   return;
  try {
    hashEntryAccess.valueToHashEntry(newHashEntryAdr,valueSerializer,v,ks.size(),valueLen);
  }
 catch (  IOException e) {
    freeBlocks.freeChain(newHashEntryAdr);
    throw new IOError(e);
  }
  putInternal(hash,ks,null,newHashEntryAdr);
}","public void put(K k,V v){
  assertNotClosed();
  if (valueSerializer == null)   throw new NullPointerException(""String_Node_Str"");
  BytesSource.ByteArraySource ks=keySource(k);
  int hash=ks.hashCode();
  long valueLen=valueSerializer.serializedSize(v);
  long newHashEntryAdr=hashEntryAccess.createNewEntryChain(hash,ks,null,valueLen);
  if (newHashEntryAdr == 0L) {
    remove(ks.hashCode(),ks);
    return;
  }
  try {
    hashEntryAccess.valueToHashEntry(newHashEntryAdr,valueSerializer,v,ks.size(),valueLen);
  }
 catch (  IOException e) {
    freeBlocks.freeChain(newHashEntryAdr);
    throw new IOError(e);
  }
  putInternal(hash,ks,null,newHashEntryAdr);
}"
93873,"/** 
 * {@inheritDoc}
 */
public boolean readColumns(final List<String> columns) throws IOException {
  if (columns == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  columns.clear();
  currentColumn.setLength(0);
  currentRow.setLength(0);
  String line;
  do {
    line=readLine();
    if (line == null) {
      return false;
    }
  }
 while (ignoreEmptyLines && line.length() == 0 || (commentMatcher != null && commentMatcher.isComment(line)));
  currentRow.append(line);
  TokenizerState state=TokenizerState.NORMAL;
  int quoteScopeStartingLine=-1;
  int potentialSpaces=0;
  int charIndex=0;
  while (true) {
    boolean EOLReached=charIndex == line.length();
    if (EOLReached) {
      if (TokenizerState.NORMAL.equals(state)) {
        if (!surroundingSpacesNeedQuotes) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        columns.add(currentColumn.length() > 0 ? currentColumn.toString() : null);
        return true;
      }
 else {
        currentColumn.append(NEWLINE);
        currentRow.append(NEWLINE);
        charIndex=0;
        line=readLine();
        if (line == null) {
          throw new SuperCsvException(String.format(""String_Node_Str"",quoteScopeStartingLine,getLineNumber()));
        }
        currentRow.append(line);
      }
    }
    final char c=line.charAt(charIndex);
    if (TokenizerState.NORMAL.equals(state)) {
      if (c == delimeterChar) {
        if (!surroundingSpacesNeedQuotes) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        columns.add(currentColumn.length() > 0 ? currentColumn.toString() : null);
        potentialSpaces=0;
        currentColumn.setLength(0);
      }
 else       if (c == SPACE) {
        potentialSpaces++;
      }
 else       if (c == quoteChar) {
        state=TokenizerState.QUOTE_MODE;
        quoteScopeStartingLine=getLineNumber();
        if (!surroundingSpacesNeedQuotes || currentColumn.length() > 0) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        potentialSpaces=0;
      }
 else {
        if (!surroundingSpacesNeedQuotes || currentColumn.length() > 0) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        potentialSpaces=0;
        currentColumn.append(c);
      }
    }
 else {
      if (c == quoteChar) {
        int nextCharIndex=charIndex + 1;
        boolean availableCharacters=nextCharIndex < line.length();
        boolean nextCharIsQuote=availableCharacters && line.charAt(nextCharIndex) == quoteChar;
        if (nextCharIsQuote) {
          currentColumn.append(c);
          charIndex++;
        }
 else {
          state=TokenizerState.NORMAL;
          quoteScopeStartingLine=-1;
        }
      }
 else {
        currentColumn.append(c);
      }
    }
    charIndex++;
  }
}","/** 
 * {@inheritDoc}
 */
public boolean readColumns(final List<String> columns) throws IOException {
  if (columns == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  columns.clear();
  currentColumn.setLength(0);
  currentRow.setLength(0);
  String line;
  do {
    line=readLine();
    if (line == null) {
      return false;
    }
  }
 while (ignoreEmptyLines && line.length() == 0 || (commentMatcher != null && commentMatcher.isComment(line)));
  currentRow.append(line);
  TokenizerState state=TokenizerState.NORMAL;
  int quoteScopeStartingLine=-1;
  int potentialSpaces=0;
  int charIndex=0;
  while (true) {
    boolean EOLReached=charIndex == line.length();
    if (EOLReached) {
      if (TokenizerState.NORMAL.equals(state)) {
        if (!surroundingSpacesNeedQuotes) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        columns.add(currentColumn.length() > 0 ? currentColumn.toString() : null);
        return true;
      }
 else {
        currentColumn.append(NEWLINE);
        currentRow.append(NEWLINE);
        charIndex=0;
        line=readLine();
        if (line == null) {
          throw new SuperCsvException(String.format(""String_Node_Str"",quoteScopeStartingLine,getLineNumber()));
        }
        currentRow.append(line);
        if (line.length() == 0)         continue;
      }
    }
    final char c=line.charAt(charIndex);
    if (TokenizerState.NORMAL.equals(state)) {
      if (c == delimeterChar) {
        if (!surroundingSpacesNeedQuotes) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        columns.add(currentColumn.length() > 0 ? currentColumn.toString() : null);
        potentialSpaces=0;
        currentColumn.setLength(0);
      }
 else       if (c == SPACE) {
        potentialSpaces++;
      }
 else       if (c == quoteChar) {
        state=TokenizerState.QUOTE_MODE;
        quoteScopeStartingLine=getLineNumber();
        if (!surroundingSpacesNeedQuotes || currentColumn.length() > 0) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        potentialSpaces=0;
      }
 else {
        if (!surroundingSpacesNeedQuotes || currentColumn.length() > 0) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        potentialSpaces=0;
        currentColumn.append(c);
      }
    }
 else {
      if (c == quoteChar) {
        int nextCharIndex=charIndex + 1;
        boolean availableCharacters=nextCharIndex < line.length();
        boolean nextCharIsQuote=availableCharacters && line.charAt(nextCharIndex) == quoteChar;
        if (nextCharIsQuote) {
          currentColumn.append(c);
          charIndex++;
        }
 else {
          state=TokenizerState.NORMAL;
          quoteScopeStartingLine=-1;
        }
      }
 else {
        currentColumn.append(c);
      }
    }
    charIndex++;
  }
}"
93874,"/** 
 * Constructs a new <tt>SuperCsvException</tt>.
 * @param msg the exception message
 * @param context the CSV context
 * @param t the nested exception
 */
public SuperCsvException(final String msg,final CsvContext context,final Throwable t){
  super(msg,t);
  this.csvContext=context;
}","/** 
 * Constructs a new <tt>SuperCsvException</tt>.
 * @param msg the exception message
 * @param context the CSV context
 * @param t the nested exception
 */
public SuperCsvException(final String msg,final CsvContext context,final Throwable t){
  super(msg,t);
  if (context != null) {
    this.csvContext=context.clone();
  }
}"
93875,"/** 
 * {@inheritDoc}
 */
public boolean readColumns(final List<String> columns) throws IOException {
  if (columns == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  columns.clear();
  currentColumn.setLength(0);
  currentRow.setLength(0);
  String line;
  do {
    line=readLine();
    if (line == null) {
      return false;
    }
  }
 while (ignoreEmptyLines && line.length() == 0 || (commentMatcher != null && commentMatcher.isComment(line)));
  currentRow.append(line);
  TokenizerState state=TokenizerState.NORMAL;
  int quoteScopeStartingLine=-1;
  int potentialSpaces=0;
  int charIndex=0;
  while (true) {
    boolean endOfLineReached=charIndex == line.length();
    if (endOfLineReached) {
      if (TokenizerState.NORMAL.equals(state)) {
        if (!surroundingSpacesNeedQuotes) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        columns.add(currentColumn.length() > 0 ? currentColumn.toString() : null);
        return true;
      }
 else {
        currentColumn.append(NEWLINE);
        currentRow.append(NEWLINE);
        charIndex=0;
        line=readLine();
        if (maxLinesPerRow > 0 && getLineNumber() - quoteScopeStartingLine + 1 > maxLinesPerRow) {
          String msg=maxLinesPerRow == 1 ? String.format(""String_Node_Str"",getLineNumber() - 1) : String.format(""String_Node_Str"" + ""String_Node_Str"",quoteScopeStartingLine,getLineNumber());
          throw new SuperCsvException(msg);
        }
 else         if (line == null) {
          throw new SuperCsvException(String.format(""String_Node_Str"",quoteScopeStartingLine,getLineNumber()));
        }
        currentRow.append(line);
        if (line.length() == 0) {
          continue;
        }
      }
    }
    final char c=line.charAt(charIndex);
    if (TokenizerState.NORMAL.equals(state)) {
      if (c == delimeterChar) {
        if (!surroundingSpacesNeedQuotes) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        columns.add(currentColumn.length() > 0 ? currentColumn.toString() : null);
        potentialSpaces=0;
        currentColumn.setLength(0);
      }
 else       if (c == SPACE) {
        potentialSpaces++;
      }
 else       if (c == quoteChar) {
        state=TokenizerState.QUOTE_MODE;
        quoteScopeStartingLine=getLineNumber();
        if (!surroundingSpacesNeedQuotes || currentColumn.length() > 0) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        potentialSpaces=0;
      }
 else {
        if (!surroundingSpacesNeedQuotes || currentColumn.length() > 0) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        potentialSpaces=0;
        currentColumn.append(c);
      }
    }
 else {
      if (c == quoteChar) {
        int nextCharIndex=charIndex + 1;
        boolean availableCharacters=nextCharIndex < line.length();
        boolean nextCharIsQuote=availableCharacters && line.charAt(nextCharIndex) == quoteChar;
        if (nextCharIsQuote) {
          currentColumn.append(c);
          charIndex++;
        }
 else {
          state=TokenizerState.NORMAL;
          quoteScopeStartingLine=-1;
        }
      }
 else {
        currentColumn.append(c);
      }
    }
    charIndex++;
  }
}","/** 
 * {@inheritDoc}
 */
public boolean readColumns(final List<String> columns) throws IOException {
  if (columns == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  columns.clear();
  currentColumn.setLength(0);
  currentRow.setLength(0);
  String line;
  do {
    line=readLine();
    if (line == null) {
      return false;
    }
  }
 while (ignoreEmptyLines && line.length() == 0 || (commentMatcher != null && commentMatcher.isComment(line)));
  currentRow.append(line);
  TokenizerState state=TokenizerState.NORMAL;
  int quoteScopeStartingLine=-1;
  int potentialSpaces=0;
  int charIndex=0;
  while (true) {
    boolean endOfLineReached=charIndex == line.length();
    if (endOfLineReached) {
      if (TokenizerState.NORMAL.equals(state)) {
        if (!surroundingSpacesNeedQuotes) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        columns.add(currentColumn.length() > 0 ? currentColumn.toString() : null);
        return true;
      }
 else {
        currentColumn.append(NEWLINE);
        currentRow.append(NEWLINE);
        charIndex=0;
        if (maxLinesPerRow > 0 && getLineNumber() - quoteScopeStartingLine + 1 >= maxLinesPerRow) {
          String msg=maxLinesPerRow == 1 ? String.format(""String_Node_Str"",getLineNumber()) : String.format(""String_Node_Str"" + ""String_Node_Str"",quoteScopeStartingLine,getLineNumber());
          throw new SuperCsvException(msg);
        }
 else         if ((line=readLine()) == null) {
          throw new SuperCsvException(String.format(""String_Node_Str"",quoteScopeStartingLine,getLineNumber()));
        }
        currentRow.append(line);
        if (line.length() == 0) {
          continue;
        }
      }
    }
    final char c=line.charAt(charIndex);
    if (TokenizerState.NORMAL.equals(state)) {
      if (c == delimeterChar) {
        if (!surroundingSpacesNeedQuotes) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        columns.add(currentColumn.length() > 0 ? currentColumn.toString() : null);
        potentialSpaces=0;
        currentColumn.setLength(0);
      }
 else       if (c == SPACE) {
        potentialSpaces++;
      }
 else       if (c == quoteChar) {
        state=TokenizerState.QUOTE_MODE;
        quoteScopeStartingLine=getLineNumber();
        if (!surroundingSpacesNeedQuotes || currentColumn.length() > 0) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        potentialSpaces=0;
      }
 else {
        if (!surroundingSpacesNeedQuotes || currentColumn.length() > 0) {
          appendSpaces(currentColumn,potentialSpaces);
        }
        potentialSpaces=0;
        currentColumn.append(c);
      }
    }
 else {
      if (c == quoteChar) {
        int nextCharIndex=charIndex + 1;
        boolean availableCharacters=nextCharIndex < line.length();
        boolean nextCharIsQuote=availableCharacters && line.charAt(nextCharIndex) == quoteChar;
        if (nextCharIsQuote) {
          currentColumn.append(c);
          charIndex++;
        }
 else {
          state=TokenizerState.NORMAL;
          quoteScopeStartingLine=-1;
        }
      }
 else {
        currentColumn.append(c);
      }
    }
    charIndex++;
  }
}"
93876,"/** 
 * {@inheritDoc}
 */
@Override public Object execute(final Object value,final CSVContext context) throws SuperCSVException {
  if (value == null) {
    throw new NullInputException(""String_Node_Str"",context,this);
  }
  return value.toString().replaceAll(searchText,replaceText);
}","/** 
 * {@inheritDoc}
 */
@Override public Object execute(final Object value,final CSVContext context) throws SuperCSVException {
  if (value == null) {
    throw new NullInputException(""String_Node_Str"",context,this);
  }
  String result=value.toString().replaceAll(searchText,replaceText);
  return next.execute(result,context);
}"
93877,"@Override public String toString(){
  return getMessage() + ""String_Node_Str"" + csvContext.toString()+ ""String_Node_Str""+ offendingProcessor;
}","@Override public String toString(){
  return String.format(""String_Node_Str"",getMessage(),csvContext,offendingProcessor);
}"
93878,"/** 
 * @param destinationObject the object on which to call the method
 * @param methodPrefix ""get"" (not used with ""set"" anymore due to overloading lookup
 * @param variableName specifies method to search for
 * @param requiredNumberOfArgs the number of arguments the method to search for has to have
 * @return
 */
private Method inspectClass(final Object destinationObject,final String methodPrefix,final String variableName,final int requiredNumberOfArgs){
  final String methodName=methodPrefix + variableName.substring(0,1).toUpperCase() + variableName.substring(1);
  for (  final Method meth : destinationObject.getClass().getMethods()) {
    if (meth.getName().equals(methodName) && meth.getParameterTypes().length == requiredNumberOfArgs) {
      return meth;
    }
  }
  throw new SuperCSVReflectionException(String.format(""String_Node_Str"",methodName,destinationObject.getClass().getName()));
}","/** 
 * @param destinationObject the object on which to call the method
 * @param methodPrefix ""get"" (not used with ""set"" anymore due to overloading lookup
 * @param variableName specifies method to search for
 * @param requiredNumberOfArgs the number of arguments the method to search for has to have
 * @return
 */
private Method inspectClass(final Object destinationObject,final String methodPrefix,final String variableName,final int requiredNumberOfArgs){
  final String methodName=methodPrefix + variableName.substring(0,1).toUpperCase() + variableName.substring(1);
  for (  final Method meth : destinationObject.getClass().getMethods()) {
    if (meth.getName().equals(methodName) && meth.getParameterTypes().length == requiredNumberOfArgs) {
      System.out.println(""String_Node_Str"" + meth.toString());
      return meth;
    }
  }
  throw new SuperCSVReflectionException(String.format(""String_Node_Str"",methodName,destinationObject.getClass().getName()));
}"
93879,"public <T>Method getSetMethod(final Object destinationObject,final String variableName,final Class<?> variableType){
  Method method=setMethodsCache.get(destinationObject.getClass(),variableType,variableName);
  if (method == null) {
    if (variableType == null) {
      method=inspectClass(destinationObject,""String_Node_Str"",variableName,1);
    }
 else {
      method=inspectClassForSetMethods(destinationObject,variableType,variableName);
    }
    setMethodsCache.set(destinationObject.getClass(),variableType,variableName,method);
  }
  return method;
}","public <T>Method getSetMethod(final Object destinationObject,final String variableName,final Class<?> variableType){
  Method method=setMethodsCache.get(destinationObject.getClass(),variableType,variableName);
  if (method == null) {
    if (variableType == null) {
      method=findSetMethodWithNonPrimitiveParameter(destinationObject,variableName);
    }
 else {
      method=inspectClassForSetMethods(destinationObject,variableType,variableName);
    }
    setMethodsCache.set(destinationObject.getClass(),variableType,variableName,method);
  }
  return method;
}"
93880,"/** 
 * @param source
 * @param nameMapping
 * @return A filled object
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
protected void fillListFromObject(final Object source,final String[] nameMapping) throws IllegalAccessException, InvocationTargetException {
  result.clear();
  for (  final String methodName : nameMapping) {
    result.add(cache.getGetMethod(source,methodName).invoke(source));
  }
}","/** 
 * populate <tt>result</tt> based on the source
 * @param source
 * @param nameMapping
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
protected void fillListFromObject(final Object source,final String[] nameMapping) throws IllegalAccessException, InvocationTargetException {
  result.clear();
  for (  final String methodName : nameMapping) {
    result.add(cache.getGetMethod(source,methodName).invoke(source));
  }
}"
93881,"/** 
 * Set the manufacturer data
 * @deprecated Please don't use anymore. Use {@link #addManufacturerData(short,byte[])} instead.
 */
@Deprecated public final BleScanInfo setManufacturerData(byte[] data){
  m_manufacturerData=data;
  return this;
}","/** 
 * Set the manufacturer data
 * @deprecated Please don't use anymore. Use {@link #addManufacturerData(short,byte[])} instead.
 */
@Deprecated public final BleScanInfo setManufacturerData(byte[] data){
  m_manufacturerData=data;
  if (m_tempManData == null)   m_tempManData=new ManufacturerData();
  m_tempManData.m_data=data;
  return this;
}"
93882,"/** 
 * Build a byte[] scan record from the data stored in this instance.
 */
public final byte[] buildPacket(){
  Map<BleUuid,byte[]> map=new HashMap<>(m_serviceUuids.size() + m_serviceData.size());
  if (m_serviceUuids.size() > 0) {
    for (    BleUuid u : m_serviceUuids) {
      map.put(u,null);
    }
  }
  if (m_serviceData.size() > 0) {
    for (    UUID u : m_serviceData.keySet()) {
      map.put(new BleUuid(u,BleUuid.UuidSize.SHORT),m_serviceData.get(u));
    }
  }
  if (m_manufactuerId != null) {
    ManufacturerData data=new ManufacturerData();
    data.m_id=m_manufactuerId;
    if (m_manufacturerData != null) {
      data.m_data=m_manufacturerData;
    }
    m_manufacturerDataList.add(data);
  }
  byte flags=m_advFlags.value != null ? m_advFlags.value.byteValue() : 0;
  byte tx=m_txPower.value != null ? m_txPower.value.byteValue() : 0;
  return Utils_ScanRecord.newScanRecord(flags,map,m_completeUuidList,m_localName,m_shortName,tx,m_manufacturerDataList);
}","/** 
 * Build a byte[] scan record from the data stored in this instance.
 */
public final byte[] buildPacket(){
  Map<BleUuid,byte[]> map=new HashMap<>(m_serviceUuids.size() + m_serviceData.size());
  if (m_serviceUuids.size() > 0) {
    for (    BleUuid u : m_serviceUuids) {
      map.put(u,null);
    }
  }
  if (m_serviceData.size() > 0) {
    for (    UUID u : m_serviceData.keySet()) {
      map.put(new BleUuid(u,BleUuid.UuidSize.SHORT),m_serviceData.get(u));
    }
  }
  if (m_tempManData != null) {
    m_manufacturerDataList.add(m_tempManData);
  }
  byte flags=m_advFlags.value != null ? m_advFlags.value.byteValue() : 0;
  byte tx=m_txPower.value != null ? m_txPower.value.byteValue() : 0;
  return Utils_ScanRecord.newScanRecord(flags,map,m_completeUuidList,m_localName,m_shortName,tx,m_manufacturerDataList);
}"
93883,"/** 
 * Set the manufacturer Id
 * @deprecated Please don't use anymore. Use {@link #addManufacturerData(short,byte[])} instead.
 */
@Deprecated public final BleScanInfo setManufacturerId(short id){
  m_manufactuerId=id;
  return this;
}","/** 
 * Set the manufacturer Id
 * @deprecated Please don't use anymore. Use {@link #addManufacturerData(short,byte[])} instead.
 */
@Deprecated public final BleScanInfo setManufacturerId(short id){
  m_manufactuerId=id;
  if (m_tempManData == null)   m_tempManData=new ManufacturerData();
  m_tempManData.m_id=id;
  return this;
}"
93884,"@Override public void onScanFailed(int errorCode){
  m_manager.getLogger().e(Utils_String.concatStrings(""String_Node_Str"",String.valueOf(errorCode)));
  if (errorCode != SCAN_FAILED_ALREADY_STARTED) {
    fail();
  }
 else {
    tryClassicDiscovery(PA_StateTracker.E_Intent.UNINTENTIONAL,false);
    m_mode=Mode_CLASSIC;
  }
}","@Override public void onScanFailed(int errorCode){
  if (errorCode == SCAN_FAILED_ALREADY_STARTED) {
    m_manager.ASSERT(false,""String_Node_Str"");
  }
 else {
    m_manager.getLogger().e(Utils_String.concatStrings(""String_Node_Str"",String.valueOf(errorCode)));
    if (m_manager.m_config.revertToClassicDiscoveryIfNeeded) {
      m_manager.getLogger().i(""String_Node_Str"");
      tryClassicDiscovery(PA_StateTracker.E_Intent.UNINTENTIONAL,false);
      m_mode=Mode_CLASSIC;
    }
 else     fail();
  }
}"
93885,"private void turnOff_private(final boolean removeAllBonds){
  if (isAny(TURNING_OFF,OFF))   return;
  if (is(ON)) {
    m_stateTracker.update(E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,TURNING_OFF,true,ON,false);
  }
  m_deviceMngr.disconnectAllForTurnOff(PE_TaskPriority.CRITICAL);
  if (removeAllBonds) {
    m_deviceMngr.unbondAll(PE_TaskPriority.CRITICAL,BondListener.Status.CANCELLED_FROM_BLE_TURNING_OFF);
  }
  if (m_server != null) {
    m_server.disconnect_internal(BleServer.ServiceAddListener.Status.CANCELLED_FROM_BLE_TURNING_OFF,BleServer.ConnectionFailListener.Status.CANCELLED_FROM_BLE_TURNING_OFF,ChangeIntent.INTENTIONAL);
  }
  final P_Task_TurnBleOff task=new P_Task_TurnBleOff(this,false,new PA_Task.I_StateListener(){
    @Override public void onStateChange(    PA_Task taskClass,    PE_TaskState state){
      if (state == PE_TaskState.EXECUTING) {
        if (is(RESETTING)) {
          m_nativeStateTracker.append(RESETTING,E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
        }
        m_deviceMngr.undiscoverAllForTurnOff(m_deviceMngr_cache,E_Intent.INTENTIONAL);
      }
    }
  }
);
  m_taskQueue.add(task);
}","private void turnOff_private(final boolean removeAllBonds){
  if (isAny(TURNING_OFF,OFF))   return;
  if (is(ON)) {
    m_stateTracker.update(E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,TURNING_OFF,true,ON,false);
  }
  m_deviceMngr.disconnectAllForTurnOff(PE_TaskPriority.CRITICAL);
  if (removeAllBonds) {
    m_deviceMngr.unbondAll(PE_TaskPriority.CRITICAL,BondListener.Status.CANCELLED_FROM_BLE_TURNING_OFF);
  }
  if (m_server != null) {
    m_server.disconnect_internal(BleServer.ServiceAddListener.Status.CANCELLED_FROM_BLE_TURNING_OFF,BleServer.ConnectionFailListener.Status.CANCELLED_FROM_BLE_TURNING_OFF,State.ChangeIntent.INTENTIONAL);
  }
  final P_Task_TurnBleOff task=new P_Task_TurnBleOff(this,false,new PA_Task.I_StateListener(){
    @Override public void onStateChange(    PA_Task taskClass,    PE_TaskState state){
      if (state == PE_TaskState.EXECUTING) {
        if (is(RESETTING)) {
          m_nativeStateTracker.append(RESETTING,E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
        }
        m_deviceMngr.undiscoverAllForTurnOff(m_deviceMngr_cache,E_Intent.INTENTIONAL);
      }
    }
  }
);
  m_taskQueue.add(task);
}"
93886,"/** 
 * Overload of   {@link #enableNotify(UUID,Interval,ReadWriteListener)} for when you have characteristics with identical uuids under different services.
 */
public final ReadWriteListener.ReadWriteEvent enableNotify(final UUID serviceUuid,final UUID characteristicUuid,final Interval forceReadTimeout,final DescriptorFilter descriptorFilter,final ReadWriteListener listener){
  final ReadWriteEvent earlyOutResult=serviceMngr_device().getEarlyOutEvent(serviceUuid,characteristicUuid,Uuids.INVALID,descriptorFilter,P_Const.EMPTY_FUTURE_DATA,Type.ENABLING_NOTIFICATION,ReadWriteListener.Target.CHARACTERISTIC);
  if (earlyOutResult != null) {
    invokeReadWriteCallback(listener,earlyOutResult);
    if (earlyOutResult.status() == ReadWriteListener.Status.NO_MATCHING_TARGET || (Interval.INFINITE.equals(forceReadTimeout) || Interval.DISABLED.equals(forceReadTimeout))) {
      return earlyOutResult;
    }
  }
  final NativeBleCharacteristic characteristic=getServiceManager().getCharacteristic(serviceUuid,characteristicUuid);
  final int notifyState=m_pollMngr.getNotifyState(serviceUuid,characteristicUuid);
  final boolean shouldSendOutNotifyEnable=notifyState == P_PollManager.E_NotifyState__NOT_ENABLED && (earlyOutResult == null || earlyOutResult.status() != ReadWriteListener.Status.OPERATION_NOT_SUPPORTED);
  final ReadWriteEvent result;
  final boolean isConnected=is(CONNECTED);
  if (shouldSendOutNotifyEnable && characteristic != null && isConnected) {
    m_bondMngr.bondIfNeeded(characteristicUuid,CharacteristicEventType.ENABLE_NOTIFY);
    final P_Task_ToggleNotify task;
    if (descriptorFilter == null) {
      task=new P_Task_ToggleNotify(this,characteristic.getCharacteristic(),true,m_txnMngr.getCurrent(),listener,getOverrideReadWritePriority());
    }
 else {
      task=new P_Task_ToggleNotify(this,serviceUuid,characteristicUuid,descriptorFilter,true,m_txnMngr.getCurrent(),listener,getOverrideReadWritePriority());
    }
    queue().add(task);
    m_pollMngr.onNotifyStateChange(serviceUuid,characteristicUuid,P_PollManager.E_NotifyState__ENABLING);
    result=NULL_READWRITE_EVENT();
  }
 else   if (notifyState == P_PollManager.E_NotifyState__ENABLED) {
    if (listener != null && isConnected) {
      result=m_pollMngr.newAlreadyEnabledEvent(characteristic.getCharacteristic(),serviceUuid,characteristicUuid,descriptorFilter);
      invokeReadWriteCallback(listener,result);
    }
 else {
      result=NULL_READWRITE_EVENT();
    }
    if (!isConnected) {
      getManager().ASSERT(false,""String_Node_Str"");
    }
  }
 else {
    result=NULL_READWRITE_EVENT();
  }
  m_pollMngr.startPoll(serviceUuid,characteristicUuid,descriptorFilter,forceReadTimeout.secs(),listener,true,true);
  return result;
}","/** 
 * Overload of   {@link #enableNotify(UUID,Interval,ReadWriteListener)} for when you have characteristics with identical uuids under different services.
 */
public final ReadWriteListener.ReadWriteEvent enableNotify(final UUID serviceUuid,final UUID characteristicUuid,final Interval forceReadTimeout,final DescriptorFilter descriptorFilter,final ReadWriteListener listener){
  final ReadWriteEvent earlyOutResult=serviceMngr_device().getEarlyOutEvent(serviceUuid,characteristicUuid,Uuids.INVALID,descriptorFilter,P_Const.EMPTY_FUTURE_DATA,Type.ENABLING_NOTIFICATION,ReadWriteListener.Target.CHARACTERISTIC);
  if (earlyOutResult != null) {
    invokeReadWriteCallback(listener,earlyOutResult);
    if (earlyOutResult.status() == ReadWriteListener.Status.NO_MATCHING_TARGET || (Interval.INFINITE.equals(forceReadTimeout) || Interval.DISABLED.equals(forceReadTimeout))) {
      return earlyOutResult;
    }
  }
  final BleCharacteristicWrapper characteristic=getServiceManager().getCharacteristic(serviceUuid,characteristicUuid);
  final int notifyState=m_pollMngr.getNotifyState(serviceUuid,characteristicUuid);
  final boolean shouldSendOutNotifyEnable=notifyState == P_PollManager.E_NotifyState__NOT_ENABLED && (earlyOutResult == null || earlyOutResult.status() != ReadWriteListener.Status.OPERATION_NOT_SUPPORTED);
  final ReadWriteEvent result;
  final boolean isConnected=is(CONNECTED);
  if (shouldSendOutNotifyEnable && characteristic != null && isConnected) {
    m_bondMngr.bondIfNeeded(characteristicUuid,CharacteristicEventType.ENABLE_NOTIFY);
    final P_Task_ToggleNotify task;
    if (descriptorFilter == null) {
      task=new P_Task_ToggleNotify(this,characteristic.getCharacteristic(),true,m_txnMngr.getCurrent(),listener,getOverrideReadWritePriority());
    }
 else {
      task=new P_Task_ToggleNotify(this,serviceUuid,characteristicUuid,descriptorFilter,true,m_txnMngr.getCurrent(),listener,getOverrideReadWritePriority());
    }
    queue().add(task);
    m_pollMngr.onNotifyStateChange(serviceUuid,characteristicUuid,P_PollManager.E_NotifyState__ENABLING);
    result=NULL_READWRITE_EVENT();
  }
 else   if (notifyState == P_PollManager.E_NotifyState__ENABLED) {
    if (listener != null && isConnected) {
      result=m_pollMngr.newAlreadyEnabledEvent(characteristic.getCharacteristic(),serviceUuid,characteristicUuid,descriptorFilter);
      invokeReadWriteCallback(listener,result);
    }
 else {
      result=NULL_READWRITE_EVENT();
    }
    if (!isConnected) {
      getManager().ASSERT(false,""String_Node_Str"");
    }
  }
 else {
    result=NULL_READWRITE_EVENT();
  }
  m_pollMngr.startPoll(serviceUuid,characteristicUuid,descriptorFilter,forceReadTimeout.secs(),listener,true,true);
  return result;
}"
93887,"/** 
 * Read the battery level of this device. This method is intended to be used if the device being read has two battery characteristics in the battery service. This method allows you to state which descriptor to match the @param valueToMatch to, to pick the correct characteristic to read the battery level from. This method is needed if you do not implement dual battery level exactly to the Bluetooth spec.
 * @deprecated - Use any of the read() methods which accept a {@link DescriptorFilter} instead, so you're not locked into the default service/char for battery.
 */
@Deprecated @Advanced public final ReadWriteEvent readBatteryLevel(byte[] valueToMatch,UUID descriptorUuid,ReadWriteListener listener){
  final ReadWriteEvent earlyOutResult=serviceMngr_device().getEarlyOutEvent(Uuids.BATTERY_SERVICE_UUID,Uuids.BATTERY_LEVEL,Uuids.INVALID,null,P_Const.EMPTY_FUTURE_DATA,Type.READ,ReadWriteListener.Target.CHARACTERISTIC);
  if (earlyOutResult != null) {
    invokeReadWriteCallback(listener,earlyOutResult);
    return earlyOutResult;
  }
  final NativeBleCharacteristic characteristic=getServiceManager().getCharacteristic(Uuids.BATTERY_SERVICE_UUID,Uuids.BATTERY_LEVEL);
  final boolean requiresBonding=m_bondMngr.bondIfNeeded(characteristic.getCharacteristic().getUuid(),BondFilter.CharacteristicEventType.READ);
  queue().add(new P_Task_BatteryLevel(this,valueToMatch,descriptorUuid,listener,requiresBonding,m_txnMngr.getCurrent(),getOverrideReadWritePriority()));
  return NULL_READWRITE_EVENT();
}","/** 
 * Read the battery level of this device. This method is intended to be used if the device being read has two battery characteristics in the battery service. This method allows you to state which descriptor to match the @param valueToMatch to, to pick the correct characteristic to read the battery level from. This method is needed if you do not implement dual battery level exactly to the Bluetooth spec.
 * @deprecated - Use any of the read() methods which accept a {@link DescriptorFilter} instead, so you're not locked into the default service/char for battery.
 */
@Deprecated @Advanced public final ReadWriteEvent readBatteryLevel(byte[] valueToMatch,UUID descriptorUuid,ReadWriteListener listener){
  final ReadWriteEvent earlyOutResult=serviceMngr_device().getEarlyOutEvent(Uuids.BATTERY_SERVICE_UUID,Uuids.BATTERY_LEVEL,Uuids.INVALID,null,P_Const.EMPTY_FUTURE_DATA,Type.READ,ReadWriteListener.Target.CHARACTERISTIC);
  if (earlyOutResult != null) {
    invokeReadWriteCallback(listener,earlyOutResult);
    return earlyOutResult;
  }
  final BleCharacteristicWrapper characteristic=getServiceManager().getCharacteristic(Uuids.BATTERY_SERVICE_UUID,Uuids.BATTERY_LEVEL);
  final boolean requiresBonding=m_bondMngr.bondIfNeeded(characteristic.getCharacteristic().getUuid(),BondFilter.CharacteristicEventType.READ);
  queue().add(new P_Task_BatteryLevel(this,valueToMatch,descriptorUuid,listener,requiresBonding,m_txnMngr.getCurrent(),getOverrideReadWritePriority()));
  return NULL_READWRITE_EVENT();
}"
93888,"final ReadWriteListener.ReadWriteEvent write_internal(final com.idevicesinc.sweetblue.WriteBuilder wb){
  final ReadWriteEvent earlyOutResult=serviceMngr_device().getEarlyOutEvent(wb.serviceUuid,wb.charUuid,wb.descriptorUuid,wb.descriptorFilter,wb.data,Type.WRITE,ReadWriteListener.Target.CHARACTERISTIC);
  if (earlyOutResult != null) {
    invokeReadWriteCallback(wb.readWriteListener,earlyOutResult);
    return earlyOutResult;
  }
  if (wb.descriptorUuid == null || wb.descriptorUuid.equals(Uuids.INVALID)) {
    final NativeBleCharacteristic characteristic=getServiceManager().getCharacteristic(wb.serviceUuid,wb.charUuid);
    final boolean requiresBonding=m_bondMngr.bondIfNeeded(characteristic.getCharacteristic().getUuid(),BondFilter.CharacteristicEventType.WRITE);
    addWriteTasks(characteristic.getCharacteristic(),wb.data,requiresBonding,wb.writeType,wb.descriptorFilter,wb.readWriteListener);
  }
 else {
    final boolean requiresBonding=false;
    final BluetoothGattDescriptor descriptor=getNativeDescriptor(wb.serviceUuid,wb.charUuid,wb.descriptorUuid);
    addWriteDescriptorTasks(descriptor,wb.data,requiresBonding,wb.readWriteListener);
  }
  return NULL_READWRITE_EVENT();
}","final ReadWriteListener.ReadWriteEvent write_internal(final com.idevicesinc.sweetblue.WriteBuilder wb){
  final ReadWriteEvent earlyOutResult=serviceMngr_device().getEarlyOutEvent(wb.serviceUuid,wb.charUuid,wb.descriptorUuid,wb.descriptorFilter,wb.data,Type.WRITE,ReadWriteListener.Target.CHARACTERISTIC);
  if (earlyOutResult != null) {
    invokeReadWriteCallback(wb.readWriteListener,earlyOutResult);
    return earlyOutResult;
  }
  if (wb.descriptorUuid == null || wb.descriptorUuid.equals(Uuids.INVALID)) {
    final BleCharacteristicWrapper characteristic=getServiceManager().getCharacteristic(wb.serviceUuid,wb.charUuid);
    final boolean requiresBonding=m_bondMngr.bondIfNeeded(characteristic.getCharacteristic().getUuid(),BondFilter.CharacteristicEventType.WRITE);
    addWriteTasks(characteristic.getCharacteristic(),wb.data,requiresBonding,wb.writeType,wb.descriptorFilter,wb.readWriteListener);
  }
 else {
    final boolean requiresBonding=false;
    final BluetoothGattDescriptor descriptor=getNativeDescriptor(wb.serviceUuid,wb.charUuid,wb.descriptorUuid);
    addWriteDescriptorTasks(descriptor,wb.data,requiresBonding,wb.readWriteListener);
  }
  return NULL_READWRITE_EVENT();
}"
93889,"final ReadWriteListener.ReadWriteEvent read_internal(final UUID serviceUuid,final UUID characteristicUuid,final UUID descriptorUuid,final Type type,DescriptorFilter descriptorFilter,final ReadWriteListener listener){
  final ReadWriteEvent earlyOutResult=serviceMngr_device().getEarlyOutEvent(serviceUuid,characteristicUuid,Uuids.INVALID,descriptorFilter,P_Const.EMPTY_FUTURE_DATA,type,ReadWriteListener.Target.CHARACTERISTIC);
  if (earlyOutResult != null) {
    invokeReadWriteCallback(listener,earlyOutResult);
    return earlyOutResult;
  }
  if (descriptorUuid == null || descriptorUuid.equals(Uuids.INVALID)) {
    final NativeBleCharacteristic characteristic=getServiceManager().getCharacteristic(serviceUuid,characteristicUuid);
    final boolean requiresBonding=m_bondMngr.bondIfNeeded(characteristicUuid,BondFilter.CharacteristicEventType.READ);
    final P_Task_Read task;
    if (descriptorFilter == null) {
      task=new P_Task_Read(this,characteristic.getCharacteristic(),type,requiresBonding,listener,m_txnMngr.getCurrent(),getOverrideReadWritePriority());
    }
 else {
      task=new P_Task_Read(this,characteristic.getCharacteristic().getService().getUuid(),characteristicUuid,type,requiresBonding,descriptorFilter,listener,m_txnMngr.getCurrent(),getOverrideReadWritePriority());
    }
    queue().add(task);
  }
 else {
    final boolean requiresBonding=false;
    final BluetoothGattDescriptor descriptor=getNativeDescriptor(serviceUuid,characteristicUuid,descriptorUuid);
    queue().add(new P_Task_ReadDescriptor(this,descriptor,type,requiresBonding,listener,m_txnMngr.getCurrent(),getOverrideReadWritePriority()));
  }
  return NULL_READWRITE_EVENT();
}","final ReadWriteListener.ReadWriteEvent read_internal(final UUID serviceUuid,final UUID characteristicUuid,final UUID descriptorUuid,final Type type,DescriptorFilter descriptorFilter,final ReadWriteListener listener){
  final ReadWriteEvent earlyOutResult=serviceMngr_device().getEarlyOutEvent(serviceUuid,characteristicUuid,Uuids.INVALID,descriptorFilter,P_Const.EMPTY_FUTURE_DATA,type,ReadWriteListener.Target.CHARACTERISTIC);
  if (earlyOutResult != null) {
    invokeReadWriteCallback(listener,earlyOutResult);
    return earlyOutResult;
  }
  if (descriptorUuid == null || descriptorUuid.equals(Uuids.INVALID)) {
    final BleCharacteristicWrapper characteristic=getServiceManager().getCharacteristic(serviceUuid,characteristicUuid);
    final boolean requiresBonding=m_bondMngr.bondIfNeeded(characteristicUuid,BondFilter.CharacteristicEventType.READ);
    final P_Task_Read task;
    if (descriptorFilter == null) {
      task=new P_Task_Read(this,characteristic.getCharacteristic(),type,requiresBonding,listener,m_txnMngr.getCurrent(),getOverrideReadWritePriority());
    }
 else {
      task=new P_Task_Read(this,characteristic.getCharacteristic().getService().getUuid(),characteristicUuid,type,requiresBonding,descriptorFilter,listener,m_txnMngr.getCurrent(),getOverrideReadWritePriority());
    }
    queue().add(task);
  }
 else {
    final boolean requiresBonding=false;
    final BluetoothGattDescriptor descriptor=getNativeDescriptor(serviceUuid,characteristicUuid,descriptorUuid);
    queue().add(new P_Task_ReadDescriptor(this,descriptor,type,requiresBonding,listener,m_txnMngr.getCurrent(),getOverrideReadWritePriority()));
  }
  return NULL_READWRITE_EVENT();
}"
93890,"private ReadWriteListener.ReadWriteEvent disableNotify_private(UUID serviceUuid,UUID characteristicUuid,Double forceReadTimeout,DescriptorFilter descriptorFilter,ReadWriteListener listener){
  final ReadWriteEvent earlyOutResult=serviceMngr_device().getEarlyOutEvent(serviceUuid,characteristicUuid,Uuids.INVALID,descriptorFilter,P_Const.EMPTY_FUTURE_DATA,Type.DISABLING_NOTIFICATION,ReadWriteListener.Target.CHARACTERISTIC);
  if (earlyOutResult != null) {
    invokeReadWriteCallback(listener,earlyOutResult);
    return earlyOutResult;
  }
  final NativeBleCharacteristic characteristic=getServiceManager().getCharacteristic(serviceUuid,characteristicUuid);
  if (characteristic != null && is(CONNECTED)) {
    final P_Task_ToggleNotify task;
    if (descriptorFilter == null) {
      task=new P_Task_ToggleNotify(this,characteristic.getCharacteristic(),false,m_txnMngr.getCurrent(),listener,getOverrideReadWritePriority());
    }
 else {
      task=new P_Task_ToggleNotify(this,serviceUuid,characteristicUuid,descriptorFilter,false,m_txnMngr.getCurrent(),listener,getOverrideReadWritePriority());
    }
    queue().add(task);
  }
  m_pollMngr.stopPoll(serviceUuid,characteristicUuid,descriptorFilter,forceReadTimeout,listener,true);
  return NULL_READWRITE_EVENT();
}","private ReadWriteListener.ReadWriteEvent disableNotify_private(UUID serviceUuid,UUID characteristicUuid,Double forceReadTimeout,DescriptorFilter descriptorFilter,ReadWriteListener listener){
  final ReadWriteEvent earlyOutResult=serviceMngr_device().getEarlyOutEvent(serviceUuid,characteristicUuid,Uuids.INVALID,descriptorFilter,P_Const.EMPTY_FUTURE_DATA,Type.DISABLING_NOTIFICATION,ReadWriteListener.Target.CHARACTERISTIC);
  if (earlyOutResult != null) {
    invokeReadWriteCallback(listener,earlyOutResult);
    return earlyOutResult;
  }
  final BleCharacteristicWrapper characteristic=getServiceManager().getCharacteristic(serviceUuid,characteristicUuid);
  if (characteristic != null && is(CONNECTED)) {
    final P_Task_ToggleNotify task;
    if (descriptorFilter == null) {
      task=new P_Task_ToggleNotify(this,characteristic.getCharacteristic(),false,m_txnMngr.getCurrent(),listener,getOverrideReadWritePriority());
    }
 else {
      task=new P_Task_ToggleNotify(this,serviceUuid,characteristicUuid,descriptorFilter,false,m_txnMngr.getCurrent(),listener,getOverrideReadWritePriority());
    }
    queue().add(task);
  }
  m_pollMngr.stopPoll(serviceUuid,characteristicUuid,descriptorFilter,forceReadTimeout,listener,true);
  return NULL_READWRITE_EVENT();
}"
93891,"/** 
 * Overload of   {@link #getNativeCharacteristic(UUID)} for when you have characteristics with identical uuids under different services.Note that this will never return a <code>null</code> instance. You need to call  {@link NativeBleCharacteristic#isNull()} to check if the {@link BluetoothGattCharacteristic}actually exists (in other words, it will return <code>true</code> if we were unable to find the requested characteristic).
 */
public @Nullable(Nullable.Prevalence.NEVER) NativeBleCharacteristic getNativeBleCharacteristic(final UUID serviceUuid,final UUID charUuid){
  return m_serviceMngr.getCharacteristic(serviceUuid,charUuid);
}","/** 
 * Overload of   {@link #getNativeCharacteristic(UUID)} for when you have characteristics with identical uuids under different services.Note that this will never return a <code>null</code> instance. You need to call  {@link BleCharacteristicWrapper#isNull()} to check if the {@link BluetoothGattCharacteristic}actually exists (in other words, it will return <code>true</code> if we were unable to find the requested characteristic).
 */
public @Nullable(Nullable.Prevalence.NEVER) BleCharacteristicWrapper getNativeBleCharacteristic(final UUID serviceUuid,final UUID charUuid){
  return m_serviceMngr.getCharacteristic(serviceUuid,charUuid);
}"
93892,"/** 
 * Overload of   {@link #getNativeCharacteristic(UUID,UUID)} for when you have characteristics with identical uuids within the same service.
 */
public @Nullable(Nullable.Prevalence.NORMAL) BluetoothGattCharacteristic getNativeCharacteristic(final UUID serviceUuid,final UUID charUuid,final DescriptorFilter descriptorFilter){
  return m_serviceMngr.getCharacteristic(serviceUuid,charUuid,descriptorFilter);
}","/** 
 * Overload of   {@link #getNativeCharacteristic(UUID,UUID)} for when you have characteristics with identical uuids within the same service.
 */
public @Nullable(Nullable.Prevalence.NORMAL) BluetoothGattCharacteristic getNativeCharacteristic(final UUID serviceUuid,final UUID charUuid,final DescriptorFilter descriptorFilter){
  return m_serviceMngr.getCharacteristic(serviceUuid,charUuid,descriptorFilter).getCharacteristic();
}"
93893,"/** 
 * Overload of   {@link #getNativeDescriptor(UUID,UUID,UUID)} that will return the first descriptor we findinside the given service matching the given  {@link UUID}. Note that this will never return a <code>null</code> instance. You need to call   {@link NativeBleDescriptor#isNull()} to check if the {@link BluetoothGattDescriptor}actually exists (in other words, it will return <code>true</code> if we were unable to find the requested descriptor).
 */
public @Nullable(Nullable.Prevalence.NEVER) NativeBleDescriptor getNativeBleDescriptor_inService(final UUID serviceUuid,final UUID descUuid){
  return getNativeBleDescriptor(serviceUuid,null,descUuid);
}","/** 
 * Overload of   {@link #getNativeDescriptor(UUID,UUID,UUID)} that will return the first descriptor we findinside the given service matching the given  {@link UUID}. Note that this will never return a <code>null</code> instance. You need to call   {@link BleDescriptorWrapper#isNull()} to check if the {@link BluetoothGattDescriptor}actually exists (in other words, it will return <code>true</code> if we were unable to find the requested descriptor).
 */
public @Nullable(Nullable.Prevalence.NEVER) BleDescriptorWrapper getNativeBleDescriptor_inService(final UUID serviceUuid,final UUID descUuid){
  return getNativeBleDescriptor(serviceUuid,null,descUuid);
}"
93894,"/** 
 * Overload of   {@link #getNativeDescriptor(UUID,UUID,UUID)} that will return the first descriptor we findinside the given characteristic matching the given  {@link UUID}. Note that this will never return a <code>null</code> instance. You need to call   {@link NativeBleDescriptor#isNull()} to check if the {@link BluetoothGattDescriptor}actually exists (in other words, it will return <code>true</code> if we were unable to find the requested descriptor).
 */
public @Nullable(Nullable.Prevalence.NEVER) NativeBleDescriptor getNativeBleDescriptor_inChar(final UUID charUuid,final UUID descUuid){
  return getNativeBleDescriptor(null,charUuid,descUuid);
}","/** 
 * Overload of   {@link #getNativeDescriptor(UUID,UUID,UUID)} that will return the first descriptor we findinside the given characteristic matching the given  {@link UUID}. Note that this will never return a <code>null</code> instance. You need to call   {@link BleDescriptorWrapper#isNull()} to check if the {@link BluetoothGattDescriptor}actually exists (in other words, it will return <code>true</code> if we were unable to find the requested descriptor).
 */
public @Nullable(Nullable.Prevalence.NEVER) BleDescriptorWrapper getNativeBleDescriptor_inChar(final UUID charUuid,final UUID descUuid){
  return getNativeBleDescriptor(null,charUuid,descUuid);
}"
93895,"/** 
 * Returns the   {@link NativeBleDescriptor} for the given UUID in case you need lower-level access.Note that this will never return a <code>null</code> instance. You need to call  {@link NativeBleDescriptor#isNull()} to check if the {@link BluetoothGattDescriptor}actually exists (in other words, it will return <code>true</code> if we were unable to find the requested descriptor).
 */
public @Nullable(Nullable.Prevalence.NEVER) NativeBleDescriptor getNativeBleDescriptor(final UUID serviceUuid,final UUID charUuid,final UUID descUuid){
  return m_serviceMngr.getDescriptor(serviceUuid,charUuid,descUuid);
}","/** 
 * Returns the   {@link BleDescriptorWrapper} for the given UUID in case you need lower-level access.Note that this will never return a <code>null</code> instance. You need to call  {@link BleDescriptorWrapper#isNull()} to check if the {@link BluetoothGattDescriptor}actually exists (in other words, it will return <code>true</code> if we were unable to find the requested descriptor).
 */
public @Nullable(Nullable.Prevalence.NEVER) BleDescriptorWrapper getNativeBleDescriptor(final UUID serviceUuid,final UUID charUuid,final UUID descUuid){
  return m_serviceMngr.getDescriptor(serviceUuid,charUuid,descUuid);
}"
93896,"/** 
 * Returns the native service for the given UUID in case you need lower-level access. Note that this will never return a <code>null</code> instance. You need to call   {@link NativeBleGattService#isNull()} to check if the {@link BluetoothGattService}actually exists (in other words, it will return <code>true</code> if we were unable to find the requested service).
 */
@com.idevicesinc.sweetblue.annotations.Advanced public @Nullable(Nullable.Prevalence.NEVER) NativeBleGattService getNativeBleService(final UUID serviceUuid){
  return m_serviceMngr.getServiceDirectlyFromNativeNode(serviceUuid);
}","/** 
 * Returns the native service for the given UUID in case you need lower-level access. Note that this will never return a <code>null</code> instance. You need to call   {@link BleServiceWrapper#isNull()} to check if the {@link BluetoothGattService}actually exists (in other words, it will return <code>true</code> if we were unable to find the requested service).
 */
@com.idevicesinc.sweetblue.annotations.Advanced public @Nullable(Nullable.Prevalence.NEVER) BleServiceWrapper getNativeBleService(final UUID serviceUuid){
  return m_serviceMngr.getServiceDirectlyFromNativeNode(serviceUuid);
}"
93897,"@NonNull @Override public View getView(int position,@Nullable View convertView,@NonNull ViewGroup parent){
  ViewHolder h;
  if (convertView == null) {
    convertView=View.inflate(getContext(),R.layout.service_layout,null);
    h=new ViewHolder();
    h.name=(TextView)convertView.findViewById(R.id.serviceName);
    h.uuid=(TextView)convertView.findViewById(R.id.uuid);
    h.type=(TextView)convertView.findViewById(R.id.serviceType);
    convertView.setTag(h);
  }
 else {
    h=(ViewHolder)convertView.getTag();
  }
  final BluetoothGattService service=m_serviceList.get(position);
  final String serviceName=UuidUtil.getServiceName(service);
  h.name.setText(serviceName);
  final String uuid=serviceName.equals(UuidUtil.CUSTOM_SERVICE) ? service.getUuid().toString() : UuidUtil.getShortUuid(service.getUuid());
  h.uuid.setText(uuid);
  final String type=service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY ? getContext().getString(R.string.primary_service) : getContext().getString(R.string.secondary_service);
  h.type.setText(type);
  return convertView;
}","@NonNull @Override public View getView(int position,@Nullable View convertView,@NonNull ViewGroup parent){
  ViewHolder h;
  if (convertView == null) {
    convertView=View.inflate(getContext(),R.layout.service_layout,null);
    h=new ViewHolder();
    h.name=(TextView)convertView.findViewById(R.id.serviceName);
    h.uuid=(TextView)convertView.findViewById(R.id.uuid);
    h.type=(TextView)convertView.findViewById(R.id.serviceType);
    convertView.setTag(h);
  }
 else {
    h=(ViewHolder)convertView.getTag();
  }
  final BluetoothGattService service=m_serviceList.get(position);
  final String serviceName=UuidUtil.getServiceName(service);
  h.name.setText(serviceName);
  final String uuid=serviceName.equals(UuidUtil.CUSTOM_SERVICE) ? service.getUuid().toString() : UuidUtil.getShortUuid(service.getUuid());
  h.uuid.setText(uuid);
  ViewUtil.postFixRunnable(h.uuid);
  final String type=service.getType() == BluetoothGattService.SERVICE_TYPE_PRIMARY ? getContext().getString(R.string.primary_service) : getContext().getString(R.string.secondary_service);
  h.type.setText(type);
  return convertView;
}"
93898,"@Override public void onClick(View v){
  Intent intent=new Intent(context,WriteValueActivity.class);
  intent.putExtra(""String_Node_Str"",m_device.getMacAddress());
  intent.putExtra(""String_Node_Str"",m_service.getUuid().toString());
  intent.putExtra(""String_Node_Str"",characteristic.getUuid().toString());
  context.startActivity(intent);
}","@Override public void onClick(View v){
  Intent intent=new Intent(context,WriteValueActivity.class);
  intent.putExtra(""String_Node_Str"",m_device.getMacAddress());
  intent.putExtra(""String_Node_Str"",m_service.getUuid().toString());
  intent.putExtra(""String_Node_Str"",bgc.getUuid().toString());
  context.startActivity(intent);
}"
93899,"@Override public View getGroupView(final int groupPosition,boolean isExpanded,View convertView,final ViewGroup parent){
  final BluetoothGattCharacteristic characteristic=m_characteristicList.get(groupPosition);
  final String name=UuidUtil.getCharacteristicName(characteristic);
  final ExpandableListView elv=(ExpandableListView)parent;
  final Context context=parent.getContext();
  boolean writable=(characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) != 0;
  boolean readable=(characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) != 0;
  Uuids.GATTCharacteristic gc=Uuids.GATTCharacteristic.getCharacteristicForUUID(characteristic.getUuid());
  Uuids.GATTDisplayType dt=gc != null ? gc.getDisplayType() : Uuids.GATTDisplayType.Hex;
  final CharViewHolder h;
  if (convertView == null) {
    convertView=View.inflate(context,R.layout.characteristic_layout,null);
    h=new CharViewHolder();
    h.parentLayout=(RelativeLayout)convertView.findViewById(R.id.parentLayout);
    h.name=(TextView)convertView.findViewById(R.id.characteristicName);
    h.uuid=(TextView)convertView.findViewById(R.id.uuid);
    h.properties=(TextView)convertView.findViewById(R.id.properties);
    h.valueDisplayTypeLabel=(TextView)convertView.findViewById(R.id.valueDisplayTypeLabel);
    h.value=(TextView)convertView.findViewById(R.id.value);
    h.displayType=dt;
    h.expandArrow=(ImageView)convertView.findViewById(R.id.expandArrow);
    h.parentLayout.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        if (elv.isGroupExpanded(groupPosition))         elv.collapseGroup(groupPosition);
 else         elv.expandGroup(groupPosition);
      }
    }
);
{
      View v=convertView.findViewById(R.id.fakeOverflowMenu);
      final View anchor=convertView.findViewById(R.id.fakeOverflowMenuAnchor);
      v.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          PopupMenu popup=new PopupMenu(context,anchor);
          popup.getMenuInflater().inflate(R.menu.char_value_type_popup,popup.getMenu());
          popup.getMenu().getItem(h.displayType.ordinal()).setChecked(true);
          popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
            public boolean onMenuItemClick(            MenuItem item){
switch (item.getItemId()) {
case R.id.displayTypeBoolean:
                h.displayType=Uuids.GATTDisplayType.Boolean;
              break;
case R.id.displayTypeBitfield:
            h.displayType=Uuids.GATTDisplayType.Bitfield;
          break;
case R.id.displayTypeUnsignedInteger:
        h.displayType=Uuids.GATTDisplayType.UnsignedInteger;
      break;
case R.id.displayTypeSignedInteger:
    h.displayType=Uuids.GATTDisplayType.SignedInteger;
  break;
case R.id.displayTypeDecimal:
h.displayType=Uuids.GATTDisplayType.Decimal;
break;
case R.id.displayTypeString:
h.displayType=Uuids.GATTDisplayType.String;
break;
case R.id.displayTypeHex:
h.displayType=Uuids.GATTDisplayType.Hex;
break;
}
refreshValue(h,characteristic);
return true;
}
}
);
popup.show();
}
}
);
}
convertView.setTag(h);
}
 else {
h=(CharViewHolder)convertView.getTag();
}
if (writable) {
h.valueDisplayTypeLabel.setVisibility(View.VISIBLE);
h.value.setVisibility(View.VISIBLE);
h.value.setTextColor(context.getResources().getColor(R.color.item_title_blue));
h.value.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
Intent intent=new Intent(context,WriteValueActivity.class);
intent.putExtra(""String_Node_Str"",m_device.getMacAddress());
intent.putExtra(""String_Node_Str"",m_service.getUuid().toString());
intent.putExtra(""String_Node_Str"",characteristic.getUuid().toString());
context.startActivity(intent);
}
}
);
}
 else if (readable) {
h.valueDisplayTypeLabel.setVisibility(View.VISIBLE);
h.value.setVisibility(View.VISIBLE);
h.value.setTextColor(context.getResources().getColor(R.color.primary_gray));
}
 else {
h.valueDisplayTypeLabel.setVisibility(View.GONE);
h.value.setVisibility(View.GONE);
}
h.name.setText(name);
final String uuid;
if (name.equals(UuidUtil.CUSTOM_CHARACTERISTIC)) {
uuid=characteristic.getUuid().toString();
}
 else {
uuid=UuidUtil.getShortUuid(characteristic.getUuid());
}
h.uuid.setText(uuid);
final String properties=getPropertyString(characteristic);
h.properties.setText(properties);
{
if (getChildrenCount(groupPosition) < 1) h.expandArrow.setVisibility(View.GONE);
 else h.expandArrow.setVisibility(View.VISIBLE);
boolean expanded=elv.isGroupExpanded(groupPosition);
h.expandArrow.setImageResource(expanded ? R.drawable.ic_expand_less_black_24dp : R.drawable.ic_expand_more_black_24dp);
}
{
if (getChildrenCount(groupPosition) < 1) h.parentLayout.setBackground(null);
}
refreshValue(h,characteristic);
postFixRunnable(h.uuid,h);
return convertView;
}","@Override public View getGroupView(final int groupPosition,boolean isExpanded,View convertView,final ViewGroup parent){
  final BluetoothGattCharacteristic characteristic=m_characteristicList.get(groupPosition);
  final Context context=parent.getContext();
  final ExpandableListView elv=(ExpandableListView)parent;
  Uuids.GATTCharacteristic gc=Uuids.GATTCharacteristic.getCharacteristicForUUID(characteristic.getUuid());
  Uuids.GATTDisplayType dt=gc != null ? gc.getDisplayType() : Uuids.GATTDisplayType.Hex;
  final CharViewHolder h;
  if (convertView == null) {
    convertView=View.inflate(context,R.layout.characteristic_layout,null);
    h=new CharViewHolder();
    h.parentLayout=(RelativeLayout)convertView.findViewById(R.id.parentLayout);
    h.name=(TextView)convertView.findViewById(R.id.characteristicName);
    h.uuid=(TextView)convertView.findViewById(R.id.uuid);
    h.uuidOriginalTextSize=h.uuid.getTextSize();
    h.properties=(TextView)convertView.findViewById(R.id.properties);
    h.valueDisplayTypeLabel=(TextView)convertView.findViewById(R.id.valueDisplayTypeLabel);
    h.value=(TextView)convertView.findViewById(R.id.value);
    h.displayType=dt;
    h.expandArrow=(ImageView)convertView.findViewById(R.id.expandArrow);
    h.parentLayout.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        if (elv.isGroupExpanded(groupPosition))         elv.collapseGroup(groupPosition);
 else         elv.expandGroup(groupPosition);
      }
    }
);
{
      View v=convertView.findViewById(R.id.fakeOverflowMenu);
      final View anchor=convertView.findViewById(R.id.fakeOverflowMenuAnchor);
      v.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          PopupMenu popup=new PopupMenu(context,anchor);
          popup.getMenuInflater().inflate(R.menu.char_value_type_popup,popup.getMenu());
          popup.getMenu().getItem(h.displayType.ordinal()).setChecked(true);
          popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
            public boolean onMenuItemClick(            MenuItem item){
switch (item.getItemId()) {
case R.id.displayTypeBoolean:
                h.displayType=Uuids.GATTDisplayType.Boolean;
              break;
case R.id.displayTypeBitfield:
            h.displayType=Uuids.GATTDisplayType.Bitfield;
          break;
case R.id.displayTypeUnsignedInteger:
        h.displayType=Uuids.GATTDisplayType.UnsignedInteger;
      break;
case R.id.displayTypeSignedInteger:
    h.displayType=Uuids.GATTDisplayType.SignedInteger;
  break;
case R.id.displayTypeDecimal:
h.displayType=Uuids.GATTDisplayType.Decimal;
break;
case R.id.displayTypeString:
h.displayType=Uuids.GATTDisplayType.String;
break;
case R.id.displayTypeHex:
h.displayType=Uuids.GATTDisplayType.Hex;
break;
}
refreshValue(h,characteristic);
return true;
}
}
);
popup.show();
}
}
);
}
convertView.setTag(h);
}
 else {
h=(CharViewHolder)convertView.getTag();
}
refreshCharacteristicView(elv,groupPosition,h,characteristic);
return convertView;
}"
93900,"@Override public View getChildView(int groupPosition,int childPosition,boolean isLastChild,View convertView,ViewGroup parent){
  final DescViewHolder h;
  if (convertView == null) {
    convertView=View.inflate(parent.getContext(),R.layout.descriptor_layout,null);
    h=new DescViewHolder();
    h.name=(TextView)convertView.findViewById(R.id.descriptorName);
    h.uuid=(TextView)convertView.findViewById(R.id.uuid);
    h.value=(TextView)convertView.findViewById(R.id.value);
    convertView.setTag(h);
  }
 else {
    h=(DescViewHolder)convertView.getTag();
  }
  final BluetoothGattCharacteristic characteristic=m_characteristicList.get(groupPosition);
  final List<BluetoothGattDescriptor> descList=m_charDescMap.get(characteristic);
  final BluetoothGattDescriptor descriptor=descList.get(childPosition);
  final String name=UuidUtil.getDescriptorName(descriptor);
  h.name.setText(name);
  final String uuid;
  if (name.equals(UuidUtil.CUSTOM_DESCRIPTOR)) {
    uuid=descriptor.getUuid().toString();
  }
 else {
    uuid=UuidUtil.getShortUuid(descriptor.getUuid());
  }
  h.uuid.setText(uuid);
  return convertView;
}","@Override public View getChildView(int groupPosition,int childPosition,boolean isLastChild,View convertView,ViewGroup parent){
  final DescViewHolder h;
  if (convertView == null) {
    convertView=View.inflate(parent.getContext(),R.layout.descriptor_layout,null);
    h=new DescViewHolder();
    h.name=(TextView)convertView.findViewById(R.id.descriptorName);
    h.uuid=(TextView)convertView.findViewById(R.id.uuid);
    h.value=(TextView)convertView.findViewById(R.id.value);
    convertView.setTag(h);
  }
 else {
    h=(DescViewHolder)convertView.getTag();
  }
  final BluetoothGattCharacteristic characteristic=m_characteristicList.get(groupPosition);
  final List<BluetoothGattDescriptor> descList=m_charDescMap.get(characteristic);
  final BluetoothGattDescriptor descriptor=descList.get(childPosition);
  final String name=UuidUtil.getDescriptorName(descriptor);
  h.name.setText(name);
  final String uuid;
  if (name.equals(UuidUtil.CUSTOM_DESCRIPTOR)) {
    uuid=descriptor.getUuid().toString();
  }
 else {
    uuid=UuidUtil.getShortUuid(descriptor.getUuid());
  }
  h.uuid.setText(uuid);
  String hexString=(descriptor != null && descriptor.getValue() != null ? Utils_Byte.bytesToHexString(descriptor.getValue()) : ""String_Node_Str"");
  h.value.setText(hexString);
  ViewUtil.postFixRunnable(h.uuid);
  return convertView;
}"
93901,"public CharacteristicAdapter(Context context,@NonNull BleDevice device,@NonNull BluetoothGattService service,@NonNull List<BluetoothGattCharacteristic> charList){
  READ=context.getString(R.string.read);
  WRITE=context.getString(R.string.write);
  NOTIFY=context.getString(R.string.notify);
  INDICATE=context.getString(R.string.indicate);
  BROADCAST=context.getString(R.string.broadcast);
  SIGNED_WRITE=context.getString(R.string.signed_write);
  EXTENDED_PROPS=context.getString(R.string.extended_properties);
  WRITE_NO_RESPONSE=context.getString(R.string.write_no_response);
  m_device=device;
  m_service=service;
  m_charDescMap=new HashMap<>(charList.size());
  m_characteristicList=charList;
  Collections.sort(m_characteristicList,new CharacteristicComparator());
  for (  BluetoothGattCharacteristic ch : charList) {
    m_charDescMap.put(ch,ch.getDescriptors());
    m_device.read(ch.getUuid(),new BleDevice.ReadWriteListener(){
      @Override public void onEvent(      ReadWriteEvent e){
        notifyDataSetChanged();
      }
    }
);
  }
}","public CharacteristicAdapter(Context context,@NonNull BleDevice device,@NonNull BluetoothGattService service,@NonNull List<BluetoothGattCharacteristic> charList){
  READ=context.getString(R.string.read);
  WRITE=context.getString(R.string.write);
  NOTIFY=context.getString(R.string.notify);
  INDICATE=context.getString(R.string.indicate);
  BROADCAST=context.getString(R.string.broadcast);
  SIGNED_WRITE=context.getString(R.string.signed_write);
  EXTENDED_PROPS=context.getString(R.string.extended_properties);
  WRITE_NO_RESPONSE=context.getString(R.string.write_no_response);
  m_device=device;
  m_service=service;
  m_charDescMap=new HashMap<>(charList.size());
  m_characteristicList=charList;
  Collections.sort(m_characteristicList,new CharacteristicComparator());
  for (  BluetoothGattCharacteristic ch : charList) {
    m_charDescMap.put(ch,ch.getDescriptors());
    m_device.read(ch.getUuid(),new BleDevice.ReadWriteListener(){
      @Override public void onEvent(      ReadWriteEvent e){
        notifyDataSetChanged();
      }
    }
);
    List<BluetoothGattDescriptor> descriptorList=ch.getDescriptors();
    for (    BluetoothGattDescriptor bgd : descriptorList) {
      m_device.readDescriptor(ch.getUuid(),bgd.getUuid());
    }
  }
}"
93902,"private void initConfigDependentMembers(){
  try {
    Class.forName(""String_Node_Str"");
    m_config.unitTest=true;
  }
 catch (  ClassNotFoundException e) {
    m_config.unitTest=false;
  }
  m_listeners.updatePollRate(m_config.defaultStatePollRate);
  m_filterMngr.updateFilter(m_config.defaultScanFilter);
  if (m_config.nativeManagerLayer instanceof P_AndroidBluetoothManager) {
    ((P_AndroidBluetoothManager)m_config.nativeManagerLayer).setBleManager(this);
  }
  if (m_config.nativeManagerLayer.isManagerNull()) {
    m_config.nativeManagerLayer.resetManager(m_context);
  }
  boolean startUpdate=true;
  if (m_updateRunnable != null) {
    m_postManager.removeUpdateCallbacks(m_updateRunnable);
  }
 else {
    if (Interval.isEnabled(m_config.autoUpdateRate)) {
      m_updateRunnable=new UpdateRunnable(m_config.autoUpdateRate.millis());
    }
 else {
      startUpdate=false;
      m_updateRunnable=new UpdateRunnable();
    }
  }
  if (m_config.scanMode != null) {
    m_config.scanApi=BleScanApi.fromBleScanMode(m_config.scanMode);
    if (m_config.scanMode.isLollipopScanMode()) {
      m_config.scanPower=BleScanPower.fromBleScanMode(m_config.scanMode);
    }
    m_config.scanMode=null;
  }
  m_uhOhThrottler=new P_UhOhThrottler(this,Interval.secs(m_config.uhOhCallbackThrottle));
  if (m_wakeLockMngr == null) {
    m_wakeLockMngr=new P_WakeLockManager(this,m_config.manageCpuWakeLock);
  }
 else   if (m_wakeLockMngr != null && m_config.manageCpuWakeLock == false) {
    m_wakeLockMngr.clear();
    m_wakeLockMngr=new P_WakeLockManager(this,m_config.manageCpuWakeLock);
  }
  if (m_config.defaultDiscoveryListener != null) {
    this.setListener_Discovery(m_config.defaultDiscoveryListener);
  }
  initPostManager();
  if (startUpdate) {
    m_postManager.postToUpdateThreadDelayed(m_updateRunnable,m_config.autoUpdateRate.millis());
  }
}","private void initConfigDependentMembers(){
  try {
    Class.forName(""String_Node_Str"");
    m_config.unitTest=true;
  }
 catch (  ClassNotFoundException e) {
    m_config.unitTest=false;
  }
  m_listeners.updatePollRate(m_config.defaultStatePollRate);
  m_filterMngr.updateFilter(m_config.defaultScanFilter);
  if (m_config.nativeManagerLayer instanceof P_AndroidBluetoothManager) {
    ((P_AndroidBluetoothManager)m_config.nativeManagerLayer).setBleManager(this);
  }
  if (m_config.nativeManagerLayer.isManagerNull()) {
    m_config.nativeManagerLayer.resetManager(m_context);
  }
  boolean startUpdate=true;
  if (m_updateRunnable != null) {
    m_updateRunnable.m_shutdown=false;
    m_postManager.removeUpdateCallbacks(m_updateRunnable);
  }
 else {
    if (Interval.isEnabled(m_config.autoUpdateRate)) {
      m_updateRunnable=new UpdateRunnable(m_config.autoUpdateRate.millis());
    }
 else {
      startUpdate=false;
      m_updateRunnable=new UpdateRunnable();
    }
  }
  if (m_config.scanMode != null) {
    m_config.scanApi=BleScanApi.fromBleScanMode(m_config.scanMode);
    if (m_config.scanMode.isLollipopScanMode()) {
      m_config.scanPower=BleScanPower.fromBleScanMode(m_config.scanMode);
    }
    m_config.scanMode=null;
  }
  m_uhOhThrottler=new P_UhOhThrottler(this,Interval.secs(m_config.uhOhCallbackThrottle));
  if (m_wakeLockMngr == null) {
    m_wakeLockMngr=new P_WakeLockManager(this,m_config.manageCpuWakeLock);
  }
 else   if (m_wakeLockMngr != null && m_config.manageCpuWakeLock == false) {
    m_wakeLockMngr.clear();
    m_wakeLockMngr=new P_WakeLockManager(this,m_config.manageCpuWakeLock);
  }
  if (m_config.defaultDiscoveryListener != null) {
    this.setListener_Discovery(m_config.defaultDiscoveryListener);
  }
  initPostManager();
  if (startUpdate) {
    m_postManager.postToUpdateThreadDelayed(m_updateRunnable,m_config.autoUpdateRate.millis());
  }
}"
93903,"@Override public void run(){
  long currentTime=System.currentTimeMillis();
  double timeStep=((double)currentTime - m_lastAutoUpdateTime) / 1000.0;
  timeStep=timeStep <= 0.0 ? .00001 : timeStep;
  update(timeStep,currentTime);
  m_lastAutoUpdateTime=currentTime;
  if (!m_shutdown) {
    m_postManager.postToUpdateThreadDelayed(this,m_autoUpdateRate);
  }
}","@Override public void run(){
  long currentTime=System.currentTimeMillis();
  if (m_lastAutoUpdateTime == null) {
    m_lastAutoUpdateTime=currentTime;
  }
  double timeStep=((double)currentTime - m_lastAutoUpdateTime) / 1000.0;
  timeStep=timeStep <= 0.0 ? .00001 : timeStep;
  update(timeStep,currentTime);
  m_lastAutoUpdateTime=currentTime;
  if (!m_shutdown) {
    m_postManager.postToUpdateThreadDelayed(this,m_autoUpdateRate);
  }
}"
93904,"/** 
 * Disconnects all devices, shuts down the BleManager, and it's backing thread, and unregisters any receivers that may be in use. This also clears out it's static instance. This is meant to be called upon application exit. However, to use it again, just call   {@link BleManager#get(Context)}, or   {@link BleManager#get(Context,BleManagerConfig)} again.
 */
public final void shutdown(){
  disconnectAll();
  m_updateRunnable.m_shutdown=true;
  m_postManager.removeUpdateCallbacks(m_updateRunnable);
  m_postManager.quit();
  m_wakeLockMngr.clear();
  m_listeners.onDestroy();
  s_instance=null;
}","/** 
 * Disconnects all devices, shuts down the BleManager, and it's backing thread, and unregisters any receivers that may be in use. This also clears out it's static instance. This is meant to be called upon application exit. However, to use it again, just call   {@link BleManager#get(Context)}, or   {@link BleManager#get(Context,BleManagerConfig)} again.
 */
public final void shutdown(){
  disconnectAll();
  m_uhOhThrottler.shutdown();
  m_updateRunnable.m_shutdown=true;
  m_postManager.removeUpdateCallbacks(m_updateRunnable);
  m_postManager.quit();
  m_wakeLockMngr.clear();
  m_listeners.onDestroy();
  s_instance=null;
}"
93905,"public P_UhOhThrottler(BleManager mngr,double throttle){
  m_mngr=mngr;
  m_throttle=throttle;
}","public P_UhOhThrottler(BleManager mngr,double throttle){
  m_mngr=mngr;
  m_throttle=throttle;
  if (mngr.m_config.manageLastUhOhOnDisk) {
    loadLastUhOhs();
  }
}"
93906,"public synchronized void setListener(UhOhListener listener){
  m_uhOhListener=listener;
}","public final synchronized void setListener(UhOhListener listener){
  m_uhOhListener=listener;
}"
93907,"void update(double timeStep){
  m_timeTracker+=timeStep;
}","final void update(double timeStep){
  m_timeTracker+=timeStep;
}"
93908,"synchronized void uhOh(UhOh reason,double throttle){
  m_mngr.getLogger().w(reason + ""String_Node_Str"");
  if (throttle > 0.0) {
    Double lastTimeCalled=m_lastTimesCalled.get(reason);
    if (lastTimeCalled != null) {
      if (m_timeTracker - lastTimeCalled < throttle) {
        return;
      }
    }
  }
  if (m_uhOhListener != null) {
    m_lastTimesCalled.put(reason,m_timeTracker);
    UhOhEvent event=new UhOhEvent(m_mngr,reason);
    m_mngr.postEvent(m_uhOhListener,event);
  }
}","final synchronized void uhOh(UhOh reason,double throttle){
  m_mngr.getLogger().w(reason + ""String_Node_Str"");
  if (throttle > 0.0) {
    Double lastTimeCalled=m_lastTimesCalled.get(reason);
    if (lastTimeCalled != null) {
      if (m_timeTracker - lastTimeCalled < throttle) {
        return;
      }
    }
  }
  if (m_mngr.m_config.manageLastUhOhOnDisk) {
    prefs().edit().putString(reason.toString(),String.valueOf(m_timeTracker)).putString(TIME_TRACKER_KEY,String.valueOf(m_timeTracker)).putString(LAST_TIME,String.valueOf(System.currentTimeMillis())).commit();
  }
  if (m_uhOhListener != null) {
    m_lastTimesCalled.put(reason,m_timeTracker);
    UhOhEvent event=new UhOhEvent(m_mngr,reason);
    m_mngr.postEvent(m_uhOhListener,event);
  }
}"
93909,"final boolean startScan_private(ScanOptions options){
  m_scanManager.resetTimeNotScanning();
  options.m_scanTime=options.m_scanTime.secs() < 0.0 ? Interval.INFINITE : options.m_scanTime;
  if (false == isBluetoothEnabled()) {
    m_logger.e(BleManager.class.getSimpleName() + ""String_Node_Str"" + ON+ ""String_Node_Str"");
    return false;
  }
  m_scanManager.setInfiniteScan(options.m_scanTime.equals(Interval.INFINITE));
  if (options.m_discoveryListener != null) {
    setListener_Discovery(options.m_discoveryListener);
  }
  if (options.m_scanFilter != null) {
    m_filterMngr.add(options.m_scanFilter);
  }
  if (options.m_isPeriodic) {
    m_config.autoScanActiveTime=options.m_scanTime;
    m_config.autoScanPauseInterval=options.m_pauseTime;
  }
  final P_Task_Scan scanTask=m_taskQueue.get(P_Task_Scan.class,this);
  if (scanTask != null) {
    scanTask.resetTimeout(options.m_scanTime.secs());
  }
 else {
    ASSERT(!m_taskQueue.isCurrentOrInQueue(P_Task_Scan.class,this));
    m_stateTracker.append(BleManagerState.STARTING_SCAN,E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
    PE_TaskPriority pri=options.m_isPriorityScan ? PE_TaskPriority.CRITICAL : null;
    boolean startScan=true;
    if (options.m_isPeriodic) {
      if (!doAutoScan()) {
        startScan=false;
      }
    }
    if (startScan) {
      m_taskQueue.add(new P_Task_Scan(this,m_listeners.getScanTaskListener(),options.m_scanTime.secs(),pri));
    }
  }
  return true;
}","final boolean startScan_private(ScanOptions options){
  if (m_taskQueue.isInQueue(P_Task_Scan.class,this)) {
    getLogger().w(""String_Node_Str"");
    return false;
  }
  if (false == isBluetoothEnabled()) {
    m_logger.e(BleManager.class.getSimpleName() + ""String_Node_Str"" + ON+ ""String_Node_Str"");
    return false;
  }
  final P_Task_Scan scanTask=m_taskQueue.get(P_Task_Scan.class,this);
  if (scanTask != null) {
    scanTask.resetTimeout(options.m_scanTime.secs());
  }
 else {
    ASSERT(!m_taskQueue.isCurrentOrInQueue(P_Task_Scan.class,this));
    m_stateTracker.append(BleManagerState.STARTING_SCAN,E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
    m_scanManager.resetTimeNotScanning();
    options.m_scanTime=options.m_scanTime.secs() < 0.0 ? Interval.INFINITE : options.m_scanTime;
    m_scanManager.setInfiniteScan(options.m_scanTime.equals(Interval.INFINITE));
    if (options.m_discoveryListener != null) {
      setListener_Discovery(options.m_discoveryListener);
    }
    if (options.m_scanFilter != null) {
      m_filterMngr.add(options.m_scanFilter);
    }
    if (options.m_isPeriodic) {
      m_config.autoScanActiveTime=options.m_scanTime;
      m_config.autoScanPauseInterval=options.m_pauseTime;
    }
    PE_TaskPriority pri=options.m_isPriorityScan ? PE_TaskPriority.CRITICAL : null;
    boolean startScan=true;
    if (options.m_isPeriodic) {
      if (!doAutoScan()) {
        startScan=false;
      }
    }
    if (startScan) {
      m_taskQueue.add(new P_Task_Scan(this,m_listeners.getScanTaskListener(),options.m_scanTime.secs(),pri));
    }
  }
  return true;
}"
93910,"final boolean update(double timeStep,long currentTime){
  if (!m_manager.isAny(SCANNING,STARTING_SCAN)) {
    m_timeNotScanning+=timeStep;
  }
  boolean stopClassicBoost=false;
  if (m_manager.is(BOOST_SCANNING)) {
    m_timeClassicBoosting+=timeStep;
    if (m_timeClassicBoosting >= m_classicLength) {
      stopClassicBoost=true;
    }
  }
  boolean startScan=false;
  if (Interval.isEnabled(m_manager.m_config.autoScanActiveTime) && m_manager.ready() && !m_manager.is(BOOST_SCANNING)) {
    if (m_manager.isForegrounded()) {
      if (Interval.isEnabled(m_manager.m_config.autoScanDelayAfterBleTurnsOn) && m_triedToStartScanAfterTurnedOn && (currentTime - m_manager.timeTurnedOn()) >= m_manager.m_config.autoScanDelayAfterBleTurnsOn.millis()) {
        m_triedToStartScanAfterTurnedOn=true;
        if (!m_manager.is(SCANNING)) {
          startScan=true;
        }
      }
 else       if (Interval.isEnabled(m_manager.m_config.autoScanDelayAfterResume) && !m_triedToStartScanAfterResume && m_manager.timeForegrounded() >= Interval.secs(m_manager.m_config.autoScanDelayAfterResume)) {
        m_triedToStartScanAfterResume=true;
        if (!m_manager.is(SCANNING)) {
          startScan=true;
        }
      }
    }
    if (!m_manager.is(SCANNING)) {
      double scanInterval=Interval.secs(m_manager.isForegrounded() ? m_manager.m_config.autoScanPauseInterval : m_manager.m_config.autoScanPauseTimeWhileAppIsBackgrounded);
      if (Interval.isEnabled(scanInterval) && m_timeNotScanning >= scanInterval) {
        startScan=true;
      }
    }
  }
  if (startScan) {
    if (m_manager.doAutoScan()) {
      m_manager.startScan_private(new ScanOptions().scanPeriodically(m_manager.m_config.autoScanActiveTime,m_manager.m_config.autoScanPauseInterval));
    }
  }
  final P_Task_Scan scanTask=m_manager.getTaskQueue().get(P_Task_Scan.class,m_manager);
  if (scanTask != null) {
    if (stopClassicBoost) {
      m_timeClassicBoosting=0;
      stopClassicDiscovery();
      scanTask.onClassicBoostFinished();
    }
    if (scanTask.getState() == PE_TaskState.EXECUTING) {
      m_manager.tryPurgingStaleDevices(scanTask.getAggregatedTimeArmedAndExecuting());
    }
  }
  return startScan;
}","final boolean update(double timeStep,long currentTime){
  if (!m_manager.isAny(SCANNING,STARTING_SCAN)) {
    m_timeNotScanning+=timeStep;
  }
  boolean stopClassicBoost=false;
  if (m_manager.is(BOOST_SCANNING)) {
    m_timeClassicBoosting+=timeStep;
    if (m_timeClassicBoosting >= m_classicLength) {
      stopClassicBoost=true;
    }
  }
  boolean startScan=false;
  if (Interval.isEnabled(m_manager.m_config.autoScanActiveTime) && m_manager.ready() && !m_manager.is(BOOST_SCANNING)) {
    if (m_manager.isForegrounded()) {
      if (Interval.isEnabled(m_manager.m_config.autoScanDelayAfterBleTurnsOn) && m_triedToStartScanAfterTurnedOn && (currentTime - m_manager.timeTurnedOn()) >= m_manager.m_config.autoScanDelayAfterBleTurnsOn.millis()) {
        m_triedToStartScanAfterTurnedOn=true;
        if (!m_manager.isAny(SCANNING,STARTING_SCAN)) {
          startScan=true;
        }
      }
 else       if (Interval.isEnabled(m_manager.m_config.autoScanDelayAfterResume) && !m_triedToStartScanAfterResume && m_manager.timeForegrounded() >= Interval.secs(m_manager.m_config.autoScanDelayAfterResume)) {
        m_triedToStartScanAfterResume=true;
        if (!m_manager.isAny(SCANNING,STARTING_SCAN)) {
          startScan=true;
        }
      }
    }
    if (!m_manager.isAny(SCANNING,STARTING_SCAN)) {
      double scanInterval=Interval.secs(m_manager.isForegrounded() ? m_manager.m_config.autoScanPauseInterval : m_manager.m_config.autoScanPauseTimeWhileAppIsBackgrounded);
      if (Interval.isEnabled(scanInterval) && m_timeNotScanning >= scanInterval) {
        startScan=true;
      }
    }
  }
  if (startScan) {
    if (m_manager.doAutoScan()) {
      m_manager.startScan_private(new ScanOptions().scanPeriodically(m_manager.m_config.autoScanActiveTime,m_manager.m_config.autoScanPauseInterval));
    }
  }
  final P_Task_Scan scanTask=m_manager.getTaskQueue().get(P_Task_Scan.class,m_manager);
  if (scanTask != null) {
    if (stopClassicBoost) {
      m_timeClassicBoosting=0;
      stopClassicDiscovery();
      scanTask.onClassicBoostFinished();
    }
    if (scanTask.getState() == PE_TaskState.EXECUTING) {
      m_manager.tryPurgingStaleDevices(scanTask.getAggregatedTimeArmedAndExecuting());
    }
  }
  return startScan;
}"
93911,"@Override public String toString(){
  final String current=m_current.get() != null ? m_current.toString() : ""String_Node_Str"";
  final String queue=m_queue.size() > 0 ? m_queue.toString() : ""String_Node_Str"";
  final String toReturn=current + ""String_Node_Str"" + queue;
  return toReturn;
}","@Override public String toString(){
  final String current=m_current.get() != null ? m_current.get().toString() : ""String_Node_Str"";
  final String queue=m_queue.size() > 0 ? m_queue.toString() : ""String_Node_Str"";
  final String toReturn=current + ""String_Node_Str"" + queue;
  return toReturn;
}"
93912,"public P_Task_Scan(BleManager manager,I_StateListener listener,double scanTime,PE_TaskPriority priority){
  super(manager,listener);
  m_priority=priority == null ? PE_TaskPriority.TRIVIAL : priority;
  m_scanTime=scanTime;
}","public P_Task_Scan(BleManager manager,I_StateListener listener,double scanTime,PE_TaskPriority priority){
  super(manager,listener);
  m_priority=priority == null ? PE_TaskPriority.TRIVIAL : priority;
  m_scanTime=scanTime;
  Log.e(""String_Node_Str"",""String_Node_Str"");
  new Exception().printStackTrace();
}"
93913,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mListView=(ListView)findViewById(R.id.listView);
  mDevices=new ArrayList<>(0);
  mAdaptor=new ScanAdaptor(this,mDevices);
  mListView.setAdapter(mAdaptor);
  mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      final BleDevice device=mDevices.get(position);
      device.setListener_State(new BleDevice.StateListener(){
        @Override public void onEvent(        StateEvent e){
          if (e.didEnter(BleDeviceState.INITIALIZED)) {
            byte[] fakeData=new byte[100];
            new Random().nextBytes(fakeData);
            device.write(tempUuid,fakeData,null);
          }
          mAdaptor.notifyDataSetChanged();
        }
      }
);
      device.connect();
    }
  }
);
  mListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener(){
    @Override public boolean onItemLongClick(    AdapterView<?> parent,    View view,    int position,    long id){
      BleDevice device=mDevices.get(position);
      if (device.is(BleDeviceState.CONNECTED)) {
        device.disconnect();
        return true;
      }
      return false;
    }
  }
);
  registerForContextMenu(mListView);
  mStartScan=(Button)findViewById(R.id.startScan);
  mStartScan.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mgr.startPeriodicScan(Interval.TEN_SECS,Interval.ONE_SEC);
    }
  }
);
  mStopScan=(Button)findViewById(R.id.stopScan);
  mStopScan.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mgr.stopPeriodicScan();
    }
  }
);
  mLogger=new DebugLogger(250);
  BleManagerConfig config=new BleManagerConfig();
  config.loggingEnabled=true;
  config.logger=mLogger;
  config.scanApi=BleScanApi.PRE_LOLLIPOP;
  config.runOnMainThread=false;
  config.reconnectFilter=new BleNodeConfig.DefaultReconnectFilter(Interval.ONE_SEC,Interval.secs(3.0),Interval.FIVE_SECS,Interval.secs(45));
  config.uhOhCallbackThrottle=Interval.secs(60.0);
  config.defaultScanFilter=new BleManagerConfig.ScanFilter(){
    @Override public Please onEvent(    ScanEvent e){
      return Please.acknowledgeIf(e.name_normalized().contains(""String_Node_Str""));
    }
  }
;
  mgr=BleManager.get(this,config);
  mgr.setListener_UhOh(new BleManager.UhOhListener(){
    @Override public void onEvent(    UhOhEvent e){
      Log.e(""String_Node_Str"",""String_Node_Str"" + e.uhOh() + ""String_Node_Str""+ e.remedy());
    }
  }
);
  mgr.setListener_State(new BleManager.StateListener(){
    @Override public void onEvent(    StateEvent event){
      if (event.didEnter(BleManagerState.ON)) {
        mStartScan.setEnabled(true);
      }
 else       if (event.didEnter(BleManagerState.SCANNING)) {
        mStartScan.setEnabled(false);
        mStopScan.setEnabled(true);
      }
 else       if (event.didExit(BleManagerState.SCANNING)) {
        mStartScan.setEnabled(true);
      }
    }
  }
);
  mgr.setListener_Discovery(new BleManager.DiscoveryListener(){
    @Override public void onEvent(    BleManager.DiscoveryListener.DiscoveryEvent e){
      if (e.was(BleManager.DiscoveryListener.LifeCycle.DISCOVERED)) {
        if (!mDevices.contains(e.device())) {
          mDevices.add(e.device());
          mAdaptor.notifyDataSetChanged();
        }
      }
 else       if (e.was(BleManager.DiscoveryListener.LifeCycle.REDISCOVERED)) {
      }
    }
  }
);
  mStartScan.setEnabled(false);
  BluetoothEnabler.start(this,new BluetoothEnabler.DefaultBluetoothEnablerFilter(){
    @Override public Please onEvent(    BluetoothEnablerEvent e){
      if (e.isDone()) {
        mStartScan.setEnabled(true);
      }
      return super.onEvent(e);
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mListView=(ListView)findViewById(R.id.listView);
  mDevices=new ArrayList<>(0);
  mAdaptor=new ScanAdaptor(this,mDevices);
  mListView.setAdapter(mAdaptor);
  mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      final BleDevice device=mDevices.get(position);
      device.setListener_State(new BleDevice.StateListener(){
        @Override public void onEvent(        StateEvent e){
          if (e.didEnter(BleDeviceState.INITIALIZED)) {
            byte[] fakeData=new byte[100];
            new Random().nextBytes(fakeData);
            device.write(tempUuid,fakeData,null);
          }
          mAdaptor.notifyDataSetChanged();
        }
      }
);
      device.connect();
    }
  }
);
  mListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener(){
    @Override public boolean onItemLongClick(    AdapterView<?> parent,    View view,    int position,    long id){
      BleDevice device=mDevices.get(position);
      if (device.is(BleDeviceState.CONNECTED)) {
        device.disconnect();
        return true;
      }
      return false;
    }
  }
);
  registerForContextMenu(mListView);
  mStartScan=(Button)findViewById(R.id.startScan);
  mStartScan.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mgr.startPeriodicScan(Interval.TEN_SECS,Interval.ONE_SEC);
    }
  }
);
  mStopScan=(Button)findViewById(R.id.stopScan);
  mStopScan.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mgr.stopPeriodicScan();
    }
  }
);
  mLogger=new DebugLogger(250);
  BleManagerConfig config=new BleManagerConfig();
  config.loggingEnabled=true;
  config.logger=mLogger;
  config.scanApi=BleScanApi.POST_LOLLIPOP;
  config.runOnMainThread=false;
  config.reconnectFilter=new BleNodeConfig.DefaultReconnectFilter(Interval.ONE_SEC,Interval.secs(3.0),Interval.FIVE_SECS,Interval.secs(45));
  config.uhOhCallbackThrottle=Interval.secs(60.0);
  config.defaultScanFilter=new BleManagerConfig.ScanFilter(){
    @Override public Please onEvent(    ScanEvent e){
      return Please.acknowledgeIf(e.name_normalized().contains(""String_Node_Str""));
    }
  }
;
  mgr=BleManager.get(this,config);
  mgr.setListener_UhOh(new BleManager.UhOhListener(){
    @Override public void onEvent(    UhOhEvent e){
      Log.e(""String_Node_Str"",""String_Node_Str"" + e.uhOh() + ""String_Node_Str""+ e.remedy());
    }
  }
);
  mgr.setListener_State(new BleManager.StateListener(){
    @Override public void onEvent(    StateEvent event){
      if (event.didEnter(BleManagerState.ON)) {
        mStartScan.setEnabled(true);
      }
 else       if (event.didEnter(BleManagerState.SCANNING)) {
        mStartScan.setEnabled(false);
        mStopScan.setEnabled(true);
      }
 else       if (event.didExit(BleManagerState.SCANNING)) {
        mStartScan.setEnabled(true);
      }
    }
  }
);
  mgr.setListener_Discovery(new BleManager.DiscoveryListener(){
    @Override public void onEvent(    BleManager.DiscoveryListener.DiscoveryEvent e){
      if (e.was(BleManager.DiscoveryListener.LifeCycle.DISCOVERED)) {
        if (!mDevices.contains(e.device())) {
          mDevices.add(e.device());
          mAdaptor.notifyDataSetChanged();
        }
      }
 else       if (e.was(BleManager.DiscoveryListener.LifeCycle.REDISCOVERED)) {
      }
    }
  }
);
  mStartScan.setEnabled(false);
  BluetoothEnabler.start(this,new BluetoothEnabler.DefaultBluetoothEnablerFilter(){
    @Override public Please onEvent(    BluetoothEnablerEvent e){
      if (e.isDone()) {
        mStartScan.setEnabled(true);
      }
      return super.onEvent(e);
    }
  }
);
}"
93914,"final void postScanResult(final BluetoothDevice device,final int rssi,final byte[] scanRecord){
  final Pointer<String> name=new Pointer<>(device.getName());
  m_manager.getPostManager().runOrPostToUpdateThread(new Runnable(){
    @Override public void run(){
      final P_NativeDeviceLayer layer=m_manager.m_config.newDeviceLayer(BleDevice.NULL);
      layer.setNativeDevice(device);
      final String name2=device.getName();
      if (name.value != null && name2 != null && !name.value.equals(name2)) {
        return;
      }
      m_manager.getCrashResolver().notifyScannedDevice(layer,m_preLollipopScanCallback);
      m_manager.onDiscoveredFromNativeStack(layer,rssi,scanRecord);
    }
  }
);
}","final void postScanResult(final BluetoothDevice device,final int rssi,final byte[] scanRecord){
  final Pointer<String> name=new Pointer<>(device != null ? device.getName() : null);
  m_manager.getPostManager().runOrPostToUpdateThread(new Runnable(){
    @Override public void run(){
      final P_NativeDeviceLayer layer=m_manager.m_config.newDeviceLayer(BleDevice.NULL);
      layer.setNativeDevice(device);
      final String name2=device != null ? device.getName() : null;
      if (name.value != null && name2 != null && !name.value.equals(name2)) {
        return;
      }
      m_manager.getCrashResolver().notifyScannedDevice(layer,m_preLollipopScanCallback);
      m_manager.onDiscoveredFromNativeStack(layer,rssi,scanRecord);
    }
  }
);
}"
93915,"@Test public void defaultInitTransactionTest() throws Exception {
  m_config.runOnMainThread=false;
  m_config.defaultScanFilter=new BleManagerConfig.ScanFilter(){
    @Override public Please onEvent(    ScanEvent e){
      return Please.acknowledgeIf(e.name_native().contains(""String_Node_Str""));
    }
  }
;
  m_config.defaultInitFactory=new BleDeviceConfig.InitTransactionFactory(){
    @Override public BleTransaction.Init newInitTxn(){
      return new BleTransaction.Init(){
        @Override protected void start(        BleDevice device){
          device.read(mInitServiceUuid,mInitCharUuid,new BleDevice.ReadWriteListener(){
            @Override public void onEvent(            ReadWriteEvent e){
              succeed();
            }
          }
);
        }
      }
;
    }
  }
;
  m_config.loggingEnabled=true;
  connectToMultipleDevices(m_config);
  m_mgr.stopScan();
  m_mgr.disconnectAll();
  m_config.runOnMainThread=true;
  connectToMultipleDevices(m_config);
}","@Test(timeout=10000) public void defaultInitTransactionTest() throws Exception {
  m_config.runOnMainThread=false;
  m_config.defaultScanFilter=new BleManagerConfig.ScanFilter(){
    @Override public Please onEvent(    ScanEvent e){
      return Please.acknowledgeIf(e.name_native().contains(""String_Node_Str""));
    }
  }
;
  m_config.defaultInitFactory=new BleDeviceConfig.InitTransactionFactory(){
    @Override public BleTransaction.Init newInitTxn(){
      return new BleTransaction.Init(){
        @Override protected void start(        BleDevice device){
          device.read(mInitServiceUuid,mInitCharUuid,new BleDevice.ReadWriteListener(){
            @Override public void onEvent(            ReadWriteEvent e){
              succeed();
            }
          }
);
        }
      }
;
    }
  }
;
  m_config.loggingEnabled=true;
  connectToMultipleDevices(m_config);
  m_mgr.stopScan();
  m_mgr.disconnectAll();
  m_config.runOnMainThread=true;
  connectToMultipleDevices(m_config);
}"
93916,"@Test public void defaultAuthTransactionTest() throws Exception {
  m_config.runOnMainThread=false;
  m_config.defaultScanFilter=new BleManagerConfig.ScanFilter(){
    @Override public Please onEvent(    ScanEvent e){
      return Please.acknowledgeIf(e.name_native().contains(""String_Node_Str""));
    }
  }
;
  m_config.defaultAuthFactory=new BleDeviceConfig.AuthTransactionFactory(){
    @Override public BleTransaction.Auth newAuthTxn(){
      return new BleTransaction.Auth(){
        @Override protected void start(        BleDevice device){
          device.read(mAuthServiceUuid,mAuthCharUuid,new BleDevice.ReadWriteListener(){
            @Override public void onEvent(            ReadWriteEvent e){
              succeed();
            }
          }
);
        }
      }
;
    }
  }
;
  m_config.loggingEnabled=true;
  connectToMultipleDevices(m_config);
  m_mgr.stopScan();
  m_mgr.disconnectAll();
  m_config.runOnMainThread=true;
  connectToMultipleDevices(m_config);
}","@Test(timeout=10000) public void defaultAuthTransactionTest() throws Exception {
  m_config.runOnMainThread=false;
  m_config.defaultScanFilter=new BleManagerConfig.ScanFilter(){
    @Override public Please onEvent(    ScanEvent e){
      return Please.acknowledgeIf(e.name_native().contains(""String_Node_Str""));
    }
  }
;
  m_config.defaultAuthFactory=new BleDeviceConfig.AuthTransactionFactory(){
    @Override public BleTransaction.Auth newAuthTxn(){
      return new BleTransaction.Auth(){
        @Override protected void start(        BleDevice device){
          device.read(mAuthServiceUuid,mAuthCharUuid,new BleDevice.ReadWriteListener(){
            @Override public void onEvent(            ReadWriteEvent e){
              succeed();
            }
          }
);
        }
      }
;
    }
  }
;
  m_config.loggingEnabled=true;
  connectToMultipleDevices(m_config);
  m_mgr.stopScan();
  m_mgr.disconnectAll();
  m_config.runOnMainThread=true;
  connectToMultipleDevices(m_config);
}"
93917,"@Test public void defaultAuthAndInitTransactionTest() throws Exception {
  m_config.runOnMainThread=false;
  m_config.defaultScanFilter=new BleManagerConfig.ScanFilter(){
    @Override public Please onEvent(    ScanEvent e){
      return Please.acknowledgeIf(e.name_native().contains(""String_Node_Str""));
    }
  }
;
  m_config.defaultInitFactory=new BleDeviceConfig.InitTransactionFactory(){
    @Override public BleTransaction.Init newInitTxn(){
      return new BleTransaction.Init(){
        @Override protected void start(        BleDevice device){
          device.read(mInitServiceUuid,mInitCharUuid,new BleDevice.ReadWriteListener(){
            @Override public void onEvent(            ReadWriteEvent e){
              succeed();
            }
          }
);
        }
      }
;
    }
  }
;
  m_config.defaultAuthFactory=new BleDeviceConfig.AuthTransactionFactory(){
    @Override public BleTransaction.Auth newAuthTxn(){
      return new BleTransaction.Auth(){
        @Override protected void start(        BleDevice device){
          device.read(mAuthServiceUuid,mAuthCharUuid,new BleDevice.ReadWriteListener(){
            @Override public void onEvent(            ReadWriteEvent e){
              succeed();
            }
          }
);
        }
      }
;
    }
  }
;
  m_config.loggingEnabled=true;
  connectToMultipleDevices(m_config);
  m_mgr.stopScan();
  m_mgr.disconnectAll();
  m_config.runOnMainThread=true;
  connectToMultipleDevices(m_config);
}","@Test(timeout=10000) public void defaultAuthAndInitTransactionTest() throws Exception {
  m_config.runOnMainThread=false;
  m_config.defaultScanFilter=new BleManagerConfig.ScanFilter(){
    @Override public Please onEvent(    ScanEvent e){
      return Please.acknowledgeIf(e.name_native().contains(""String_Node_Str""));
    }
  }
;
  m_config.defaultInitFactory=new BleDeviceConfig.InitTransactionFactory(){
    @Override public BleTransaction.Init newInitTxn(){
      return new BleTransaction.Init(){
        @Override protected void start(        BleDevice device){
          device.read(mInitServiceUuid,mInitCharUuid,new BleDevice.ReadWriteListener(){
            @Override public void onEvent(            ReadWriteEvent e){
              succeed();
            }
          }
);
        }
      }
;
    }
  }
;
  m_config.defaultAuthFactory=new BleDeviceConfig.AuthTransactionFactory(){
    @Override public BleTransaction.Auth newAuthTxn(){
      return new BleTransaction.Auth(){
        @Override protected void start(        BleDevice device){
          device.read(mAuthServiceUuid,mAuthCharUuid,new BleDevice.ReadWriteListener(){
            @Override public void onEvent(            ReadWriteEvent e){
              succeed();
            }
          }
);
        }
      }
;
    }
  }
;
  m_config.loggingEnabled=true;
  connectToMultipleDevices(m_config);
  m_mgr.stopScan();
  m_mgr.disconnectAll();
  m_config.runOnMainThread=true;
  connectToMultipleDevices(m_config);
}"
93918,"private void BleManager(Context context,BleManagerConfig config){
  m_context=context.getApplicationContext();
  m_currentTick=System.currentTimeMillis();
  addLifecycleCallbacks();
  m_config=config.clone();
  m_scanManager=new P_ScanManager(this);
  initLogger(null);
  m_historicalDatabase=PU_HistoricalData.newDatabase(context,this);
  m_diskOptionsMngr=new P_DiskOptionsManager(m_context);
  m_filterMngr=new P_ScanFilterManager(this,m_config.defaultScanFilter);
  if (m_config.nativeManagerLayer.isManagerNull()) {
    m_config.nativeManagerLayer.resetManager(m_context);
  }
  BleManagerState nativeState=BleManagerState.get(m_config.nativeManagerLayer.getState());
  if (m_timeTurnedOn == 0 && nativeState.overlaps(BluetoothAdapter.STATE_ON)) {
    m_timeTurnedOn=System.currentTimeMillis();
  }
  m_stateTracker=new P_BleStateTracker(this);
  m_stateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_nativeStateTracker=new P_NativeBleStateTracker(this);
  m_nativeStateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_taskQueue=new P_TaskQueue(this);
  m_crashResolver=new P_BluetoothCrashResolver(m_context);
  m_deviceMngr=new P_DeviceManager(this);
  m_deviceMngr_cache=new P_DeviceManager(this);
  m_listeners=new P_BleManager_Listeners(this);
  initConfigDependentMembers();
  m_logger.printBuildInfo();
}","private void BleManager(Context context,BleManagerConfig config){
  m_context=context.getApplicationContext();
  m_currentTick=System.currentTimeMillis();
  addLifecycleCallbacks();
  m_config=config.clone();
  m_scanManager=new P_ScanManager(this);
  initLogger(null);
  m_historicalDatabase=PU_HistoricalData.newDatabase(context,this);
  m_diskOptionsMngr=new P_DiskOptionsManager(m_context);
  m_filterMngr=new P_ScanFilterManager(this,m_config.defaultScanFilter);
  if (m_config.nativeManagerLayer.isManagerNull()) {
    m_config.nativeManagerLayer.resetManager(m_context);
  }
  BleManagerState nativeState=BleManagerState.get(m_config.nativeManagerLayer.getState());
  if (m_timeTurnedOn == 0 && nativeState.overlaps(BluetoothAdapter.STATE_ON)) {
    m_timeTurnedOn=System.currentTimeMillis();
  }
  m_stateTracker=new P_BleStateTracker(this);
  m_stateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_nativeStateTracker=new P_NativeBleStateTracker(this);
  m_nativeStateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_taskQueue=new P_TaskQueue(this);
  m_crashResolver=new P_BluetoothCrashResolver(m_context);
  m_deviceMngr=new P_DeviceManager(this);
  m_deviceMngr_cache=new P_DeviceManager(this);
  m_listeners=new P_BleManager_Listeners(this);
  m_lastTaskExecution=System.currentTimeMillis();
  initConfigDependentMembers();
  m_logger.printBuildInfo();
}"
93919,"@Override public void run(){
  long currentTime=System.currentTimeMillis();
  double timeStep=((double)currentTime - m_lastAutoUpdateTime) / 1000.0;
  timeStep=timeStep <= 0.0 ? .00001 : timeStep;
  timeStep=timeStep > 1.0 ? 1.0 : timeStep;
  update(timeStep,currentTime);
  m_lastAutoUpdateTime=currentTime;
  m_postManager.postToUpdateThreadDelayed(this,m_autoUpdateRate);
}","@Override public void run(){
  long currentTime=System.currentTimeMillis();
  double timeStep=((double)currentTime - m_lastAutoUpdateTime) / 1000.0;
  timeStep=timeStep <= 0.0 ? .00001 : timeStep;
  timeStep=timeStep > 1.0 ? 1.0 : timeStep;
  update(timeStep,currentTime);
  m_lastAutoUpdateTime=currentTime;
  if (!m_shutdown) {
    m_postManager.postToUpdateThreadDelayed(this,m_autoUpdateRate);
  }
}"
93920,"/** 
 * Shuts down the BleManager, and it's backing thread, and unregisters any receivers that may be in use. This also clears out it's static instance. This is meant to be called upon application exit. However, to use it again, just call   {@link BleManager#get(Context)}, or   {@link BleManager#get(Context,BleManagerConfig)} again.
 */
public final void shutdown(){
  m_postManager.removeUpdateCallbacks(m_updateRunnable);
  m_postManager.quit();
  m_wakeLockMngr.clear();
  m_listeners.onDestroy();
  s_instance=null;
}","/** 
 * Shuts down the BleManager, and it's backing thread, and unregisters any receivers that may be in use. This also clears out it's static instance. This is meant to be called upon application exit. However, to use it again, just call   {@link BleManager#get(Context)}, or   {@link BleManager#get(Context,BleManagerConfig)} again.
 */
public final void shutdown(){
  m_updateRunnable.m_shutdown=true;
  m_postManager.removeUpdateCallbacks(m_updateRunnable);
  m_postManager.quit();
  m_wakeLockMngr.clear();
  m_listeners.onDestroy();
  s_instance=null;
}"
93921,"final boolean update(double timeStep,long currentTime){
  if (!m_manager.isAny(SCANNING,STARTING_SCAN)) {
    m_timeNotScanning+=timeStep;
  }
  boolean stopClassicBoost=false;
  if (m_classicBoost && m_manager.is(SCANNING)) {
    m_timeClassicBoosting+=timeStep;
    if (m_timeClassicBoosting >= m_classicLength) {
      stopClassicBoost=true;
    }
  }
  boolean startScan=false;
  if (Interval.isEnabled(m_manager.m_config.autoScanActiveTime) && m_manager.ready() && !m_classicBoost) {
    if (m_manager.isForegrounded()) {
      if (Interval.isEnabled(m_manager.m_config.autoScanDelayAfterBleTurnsOn) && m_triedToStartScanAfterTurnedOn && (currentTime - m_manager.timeTurnedOn()) >= m_manager.m_config.autoScanDelayAfterBleTurnsOn.millis()) {
        m_triedToStartScanAfterTurnedOn=true;
        if (!m_manager.is(SCANNING)) {
          startScan=true;
        }
      }
 else       if (Interval.isEnabled(m_manager.m_config.autoScanDelayAfterResume) && !m_triedToStartScanAfterResume && m_manager.timeForegrounded() >= Interval.secs(m_manager.m_config.autoScanDelayAfterResume)) {
        m_triedToStartScanAfterResume=true;
        if (!m_manager.is(SCANNING)) {
          startScan=true;
        }
      }
    }
    if (!m_manager.is(SCANNING)) {
      double scanInterval=Interval.secs(m_manager.isForegrounded() ? m_manager.m_config.autoScanPauseInterval : m_manager.m_config.autoScanPauseTimeWhileAppIsBackgrounded);
      if (Interval.isEnabled(scanInterval) && m_timeNotScanning >= scanInterval) {
        startScan=true;
      }
    }
  }
  if (startScan) {
    if (m_manager.doAutoScan()) {
      m_manager.startScan_private(m_manager.m_config.autoScanActiveTime,null,null,true);
    }
  }
  final P_Task_Scan scanTask=m_manager.getTaskQueue().get(P_Task_Scan.class,m_manager);
  if (scanTask != null) {
    if (stopClassicBoost) {
      m_classicBoost=false;
      m_timeClassicBoosting=0;
      stopClassicDiscovery();
      scanTask.onClassicBoostFinished();
    }
    if (scanTask.getState() == PE_TaskState.EXECUTING) {
      m_manager.tryPurgingStaleDevices(scanTask.getAggregatedTimeArmedAndExecuting());
    }
  }
  return startScan;
}","final boolean update(double timeStep,long currentTime){
  if (!m_manager.isAny(SCANNING,STARTING_SCAN)) {
    m_timeNotScanning+=timeStep;
  }
  boolean stopClassicBoost=false;
  if (m_manager.is(BOOST_SCANNING)) {
    m_timeClassicBoosting+=timeStep;
    if (m_timeClassicBoosting >= m_classicLength) {
      stopClassicBoost=true;
    }
  }
  boolean startScan=false;
  if (Interval.isEnabled(m_manager.m_config.autoScanActiveTime) && m_manager.ready() && !m_manager.is(BOOST_SCANNING)) {
    if (m_manager.isForegrounded()) {
      if (Interval.isEnabled(m_manager.m_config.autoScanDelayAfterBleTurnsOn) && m_triedToStartScanAfterTurnedOn && (currentTime - m_manager.timeTurnedOn()) >= m_manager.m_config.autoScanDelayAfterBleTurnsOn.millis()) {
        m_triedToStartScanAfterTurnedOn=true;
        if (!m_manager.is(SCANNING)) {
          startScan=true;
        }
      }
 else       if (Interval.isEnabled(m_manager.m_config.autoScanDelayAfterResume) && !m_triedToStartScanAfterResume && m_manager.timeForegrounded() >= Interval.secs(m_manager.m_config.autoScanDelayAfterResume)) {
        m_triedToStartScanAfterResume=true;
        if (!m_manager.is(SCANNING)) {
          startScan=true;
        }
      }
    }
    if (!m_manager.is(SCANNING)) {
      double scanInterval=Interval.secs(m_manager.isForegrounded() ? m_manager.m_config.autoScanPauseInterval : m_manager.m_config.autoScanPauseTimeWhileAppIsBackgrounded);
      if (Interval.isEnabled(scanInterval) && m_timeNotScanning >= scanInterval) {
        startScan=true;
      }
    }
  }
  if (startScan) {
    if (m_manager.doAutoScan()) {
      m_manager.startScan_private(m_manager.m_config.autoScanActiveTime,null,null,true);
    }
  }
  final P_Task_Scan scanTask=m_manager.getTaskQueue().get(P_Task_Scan.class,m_manager);
  if (scanTask != null) {
    if (stopClassicBoost) {
      m_timeClassicBoosting=0;
      stopClassicDiscovery();
      scanTask.onClassicBoostFinished();
    }
    if (scanTask.getState() == PE_TaskState.EXECUTING) {
      m_manager.tryPurgingStaleDevices(scanTask.getAggregatedTimeArmedAndExecuting());
    }
  }
  return startScan;
}"
93922,"private boolean tryClassicDiscovery(final PA_StateTracker.E_Intent intent,final boolean suppressUhOh){
  if (m_manager.m_config.revertToClassicDiscoveryIfNeeded) {
    if (false == startClassicDiscovery()) {
      m_manager.getLogger().w(""String_Node_Str"");
      fail();
      m_manager.uhOh(BleManager.UhOhListener.UhOh.CLASSIC_DISCOVERY_FAILED);
      return false;
    }
 else {
      if (false == suppressUhOh) {
        m_manager.uhOh(BleManager.UhOhListener.UhOh.START_BLE_SCAN_FAILED__USING_CLASSIC);
      }
      m_mode=Mode_CLASSIC;
      m_manager.getStateTracker().update(PA_StateTracker.E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,BleManagerState.SCANNING,true,SCANNING_PAUSED,false,STARTING_SCAN,false);
      return true;
    }
  }
 else {
    fail();
    m_manager.uhOh(BleManager.UhOhListener.UhOh.START_BLE_SCAN_FAILED);
    return false;
  }
}","private boolean tryClassicDiscovery(final PA_StateTracker.E_Intent intent,final boolean suppressUhOh){
  if (m_manager.m_config.revertToClassicDiscoveryIfNeeded) {
    if (false == startClassicDiscovery()) {
      m_manager.getLogger().w(""String_Node_Str"");
      fail();
      m_manager.uhOh(BleManager.UhOhListener.UhOh.CLASSIC_DISCOVERY_FAILED);
      return false;
    }
 else {
      if (false == suppressUhOh) {
        m_manager.uhOh(BleManager.UhOhListener.UhOh.START_BLE_SCAN_FAILED__USING_CLASSIC);
      }
      m_mode=Mode_CLASSIC;
      setStateToScanning();
      return true;
    }
  }
 else {
    fail();
    m_manager.uhOh(BleManager.UhOhListener.UhOh.START_BLE_SCAN_FAILED);
    return false;
  }
}"
93923,"private boolean startScanPreLollipop(PA_StateTracker.E_Intent intent){
  int retryCount=0;
  while (retryCount <= m_retryCountMax) {
    final boolean success=startLeScan();
    if (success) {
      if (retryCount >= 1) {
      }
      break;
    }
    retryCount++;
    if (retryCount <= m_retryCountMax) {
      if (retryCount == 1) {
        m_manager.getLogger().w(""String_Node_Str"");
        stopLeScan();
      }
 else {
        m_manager.getLogger().w(""String_Node_Str"" + retryCount + ""String_Node_Str"");
      }
    }
  }
  if (retryCount > m_retryCountMax) {
    m_manager.getLogger().w(""String_Node_Str"");
    tryClassicDiscovery(intent,false);
    return true;
  }
 else {
    if (retryCount > 0) {
      m_manager.getLogger().w(""String_Node_Str"" + (retryCount + 1) + ""String_Node_Str"");
    }
    if (m_manager.m_config.enableCrashResolver) {
      m_manager.getCrashResolver().start();
    }
    m_mode=Mode_BLE;
    m_manager.getStateTracker().update(PA_StateTracker.E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,BleManagerState.SCANNING,true,SCANNING_PAUSED,false,STARTING_SCAN,false);
    return true;
  }
}","private boolean startScanPreLollipop(PA_StateTracker.E_Intent intent){
  int retryCount=0;
  while (retryCount <= m_retryCountMax) {
    final boolean success=startLeScan();
    if (success) {
      if (retryCount >= 1) {
      }
      break;
    }
    retryCount++;
    if (retryCount <= m_retryCountMax) {
      if (retryCount == 1) {
        m_manager.getLogger().w(""String_Node_Str"");
        stopLeScan();
      }
 else {
        m_manager.getLogger().w(""String_Node_Str"" + retryCount + ""String_Node_Str"");
      }
    }
  }
  if (retryCount > m_retryCountMax) {
    m_manager.getLogger().w(""String_Node_Str"");
    tryClassicDiscovery(intent,false);
    return true;
  }
 else {
    if (retryCount > 0) {
      m_manager.getLogger().w(""String_Node_Str"" + (retryCount + 1) + ""String_Node_Str"");
    }
    if (m_manager.m_config.enableCrashResolver) {
      m_manager.getCrashResolver().start();
    }
    m_mode=Mode_BLE;
    setStateToScanning();
    return true;
  }
}"
93924,"private boolean startScanPostLollipop(double scanTime,boolean m_isPoll){
  int nativePowerMode;
  BleScanPower power=m_manager.m_config.scanPower;
  if (power == BleScanPower.AUTO) {
    if (m_manager.isForegrounded()) {
      if (m_isPoll || scanTime == Double.POSITIVE_INFINITY) {
        power=BleScanPower.MEDIUM_POWER;
        nativePowerMode=BleScanPower.MEDIUM_POWER.getNativeMode();
      }
 else {
        power=BleScanPower.HIGH_POWER;
        nativePowerMode=BleScanPower.HIGH_POWER.getNativeMode();
      }
    }
 else {
      power=BleScanPower.LOW_POWER;
      nativePowerMode=BleScanPower.LOW_POWER.getNativeMode();
    }
  }
 else {
    if (power == BleScanPower.VERY_LOW_POWER) {
      if (!Utils.isMarshmallow()) {
        m_manager.getLogger().e(""String_Node_Str"");
        power=BleScanPower.LOW_POWER;
      }
    }
    nativePowerMode=power.getNativeMode();
  }
  if (Utils.isMarshmallow()) {
    startMScan(nativePowerMode);
  }
 else {
    startLScan(nativePowerMode);
  }
  m_mode=Mode_BLE_POST_LOLLIPOP;
  mCurrentPower.set(power);
  m_manager.getStateTracker().update(PA_StateTracker.E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,BleManagerState.SCANNING,true,SCANNING_PAUSED,false,STARTING_SCAN,false);
  return true;
}","private boolean startScanPostLollipop(double scanTime,boolean m_isPoll){
  int nativePowerMode;
  BleScanPower power=m_manager.m_config.scanPower;
  if (power == BleScanPower.AUTO) {
    if (m_manager.isForegrounded()) {
      if (m_isPoll || scanTime == Double.POSITIVE_INFINITY) {
        power=BleScanPower.MEDIUM_POWER;
        nativePowerMode=BleScanPower.MEDIUM_POWER.getNativeMode();
      }
 else {
        power=BleScanPower.HIGH_POWER;
        nativePowerMode=BleScanPower.HIGH_POWER.getNativeMode();
      }
    }
 else {
      power=BleScanPower.LOW_POWER;
      nativePowerMode=BleScanPower.LOW_POWER.getNativeMode();
    }
  }
 else {
    if (power == BleScanPower.VERY_LOW_POWER) {
      if (!Utils.isMarshmallow()) {
        m_manager.getLogger().e(""String_Node_Str"");
        power=BleScanPower.LOW_POWER;
      }
    }
    nativePowerMode=power.getNativeMode();
  }
  if (Utils.isMarshmallow()) {
    startMScan(nativePowerMode);
  }
 else {
    startLScan(nativePowerMode);
  }
  m_mode=Mode_BLE_POST_LOLLIPOP;
  mCurrentPower.set(power);
  setStateToScanning();
  return true;
}"
93925,"private void stopScan_private(boolean stopping){
switch (mCurrentApi.get()) {
case CLASSIC:
    stopClassicDiscovery();
  break;
case POST_LOLLIPOP:
if (Utils.isLollipop()) {
  stopScanPostLollipop();
}
 else {
  stopScanPreLollipop();
}
break;
case AUTO:
case PRE_LOLLIPOP:
stopScanPreLollipop();
}
if (stopping) {
m_manager.getStateTracker().update(PA_StateTracker.E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,SCANNING,false);
}
 else {
m_manager.getStateTracker().update(PA_StateTracker.E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,SCANNING,false,SCANNING_PAUSED,true);
}
}","private void stopScan_private(boolean stopping){
switch (mCurrentApi.get()) {
case CLASSIC:
    stopClassicDiscovery();
  break;
case POST_LOLLIPOP:
if (Utils.isLollipop()) {
  stopScanPostLollipop();
}
 else {
  stopScanPreLollipop();
}
break;
case AUTO:
case PRE_LOLLIPOP:
stopScanPreLollipop();
}
if (stopping) {
m_manager.getStateTracker().update(PA_StateTracker.E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,SCANNING,false,BOOST_SCANNING,false);
}
 else {
m_manager.getStateTracker().update(PA_StateTracker.E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,SCANNING,false,SCANNING_PAUSED,true,BOOST_SCANNING,false);
}
}"
93926,"public final boolean classicBoost(double scanTime){
  m_classicBoost=true;
  m_classicLength=scanTime;
  return tryClassicDiscovery(PA_StateTracker.E_Intent.INTENTIONAL,true);
}","public final boolean classicBoost(double scanTime){
  m_classicLength=scanTime;
  return startClassicBoost();
}"
93927,"public final boolean startScan(PA_StateTracker.E_Intent intent,double scanTime,boolean m_isPoll){
switch (m_manager.m_config.scanApi) {
case CLASSIC:
    mCurrentApi.set(BleScanApi.CLASSIC);
  return tryClassicDiscovery(intent,true);
case POST_LOLLIPOP:
if (isBleScanReady()) {
  if (Utils.isLollipop()) {
    mCurrentApi.set(BleScanApi.POST_LOLLIPOP);
    return startScanPostLollipop(scanTime,m_isPoll);
  }
 else {
    m_manager.getLogger().e(""String_Node_Str"");
    mCurrentApi.set(BleScanApi.PRE_LOLLIPOP);
    return startScanPreLollipop(intent);
  }
}
 else {
  m_manager.getLogger().e(""String_Node_Str"");
  mCurrentApi.set(BleScanApi.CLASSIC);
  return startClassicDiscovery();
}
case AUTO:
case PRE_LOLLIPOP:
mCurrentApi.set(BleScanApi.PRE_LOLLIPOP);
return startScanPreLollipop(intent);
default :
return false;
}
}","public final boolean startScan(PA_StateTracker.E_Intent intent,double scanTime,boolean m_isPoll){
switch (m_manager.m_config.scanApi) {
case CLASSIC:
    mCurrentApi.set(BleScanApi.CLASSIC);
  return tryClassicDiscovery(intent,true);
case POST_LOLLIPOP:
if (isBleScanReady()) {
  if (Utils.isLollipop()) {
    mCurrentApi.set(BleScanApi.POST_LOLLIPOP);
    return startScanPostLollipop(scanTime,m_isPoll);
  }
 else {
    m_manager.getLogger().e(""String_Node_Str"");
    mCurrentApi.set(BleScanApi.PRE_LOLLIPOP);
    return startScanPreLollipop(intent);
  }
}
 else {
  m_manager.getLogger().e(""String_Node_Str"");
  mCurrentApi.set(BleScanApi.CLASSIC);
  return tryClassicDiscovery(intent,true);
}
case AUTO:
case PRE_LOLLIPOP:
mCurrentApi.set(BleScanApi.PRE_LOLLIPOP);
return startScanPreLollipop(intent);
default :
return false;
}
}"
93928,"void disconnectWithReason(PE_TaskPriority disconnectPriority_nullable,ConnectionFailListener.Status connectionFailReasonIfConnecting,Timing timing,int gattStatus,int bondFailReason,ReadWriteListener.ReadWriteEvent txnFailReason){
  if (isNull())   return;
  final boolean cancelled=connectionFailReasonIfConnecting != null && connectionFailReasonIfConnecting.wasCancelled();
  final boolean explicit=connectionFailReasonIfConnecting != null && connectionFailReasonIfConnecting.wasExplicit();
  final BleDeviceState highestState=BleDeviceState.getTransitoryConnectionState(getStateMask());
  if (explicit) {
    m_reconnectMngr_shortTerm.stop();
  }
  if (cancelled) {
    m_useAutoConnect=m_alwaysUseAutoConnect;
    m_connectionFailMngr.onExplicitDisconnect();
  }
  final boolean wasConnecting=is_internal(CONNECTING_OVERALL);
  final boolean attemptingReconnect_longTerm=cancelled ? false : is(RECONNECTING_LONG_TERM);
  E_Intent intent=cancelled ? E_Intent.INTENTIONAL : E_Intent.UNINTENTIONAL;
  m_lastConnectOrDisconnectWasUserExplicit=intent == E_Intent.INTENTIONAL;
  final boolean cancellableFromConnect=BleDeviceConfig.bool(conf_device().disconnectIsCancellable,conf_mngr().disconnectIsCancellable);
  final boolean tryBondingWhileDisconnected=connectionFailReasonIfConnecting == Status.BONDING_FAILED && BleDeviceConfig.bool(conf_device().tryBondingWhileDisconnected,conf_mngr().tryBondingWhileDisconnected);
  final boolean underwentPossibleImplicitBondingAttempt=m_nativeWrapper.isNativelyUnbonded() && m_underwentPossibleImplicitBondingAttempt == true;
  final boolean taskIsCancellable=cancellableFromConnect == true && tryBondingWhileDisconnected == false && underwentPossibleImplicitBondingAttempt == false;
{
    saveLastDisconnect(explicit);
    final boolean saveLastDisconnectAfterTaskCompletes=connectionFailReasonIfConnecting != Status.ROGUE_DISCONNECT;
    final int taskOrdinal;
    final boolean clearQueue;
    if (isAny_internal(CONNECTED,CONNECTING_OVERALL,INITIALIZED)) {
      final P_Task_Disconnect disconnectTask=new P_Task_Disconnect(this,m_taskStateListener,true,disconnectPriority_nullable,taskIsCancellable,saveLastDisconnectAfterTaskCompletes);
      queue().add(disconnectTask);
      taskOrdinal=disconnectTask.getOrdinal();
      clearQueue=true;
    }
 else {
      taskOrdinal=-1;
      clearQueue=false;
    }
    final Object[] overrideBondingStates=m_bondMngr.getOverrideBondStatesForDisconnect(connectionFailReasonIfConnecting);
    final boolean forceMainStateTracker=explicit;
    setStateToDisconnected(attemptingReconnect_longTerm,intent,gattStatus,forceMainStateTracker,overrideBondingStates);
    m_txnMngr.cancelAllTransactions();
    if (clearQueue) {
      queue().clearQueueOf(PA_Task_RequiresConnection.class,this,taskOrdinal);
    }
    if (!attemptingReconnect_longTerm) {
      m_reconnectMngr_longTerm.stop();
    }
  }
  if (wasConnecting) {
    if (getManager().ASSERT(connectionFailReasonIfConnecting != null)) {
      m_connectionFailMngr.onConnectionFailed(connectionFailReasonIfConnecting,timing,attemptingReconnect_longTerm,gattStatus,bondFailReason,highestState,ConnectionFailListener.AutoConnectUsage.NOT_APPLICABLE,txnFailReason);
    }
  }
}","void disconnectWithReason(final PE_TaskPriority disconnectPriority_nullable,final ConnectionFailListener.Status connectionFailReasonIfConnecting,final Timing timing,final int gattStatus,final int bondFailReason,final ReadWriteListener.ReadWriteEvent txnFailReason){
  getManager().getPostManager().postToUpdateThread(new Runnable(){
    @Override public void run(){
      if (isNull())       return;
      final boolean cancelled=connectionFailReasonIfConnecting != null && connectionFailReasonIfConnecting.wasCancelled();
      final boolean explicit=connectionFailReasonIfConnecting != null && connectionFailReasonIfConnecting.wasExplicit();
      final BleDeviceState highestState=BleDeviceState.getTransitoryConnectionState(getStateMask());
      if (explicit) {
        m_reconnectMngr_shortTerm.stop();
      }
      if (cancelled) {
        m_useAutoConnect=m_alwaysUseAutoConnect;
        m_connectionFailMngr.onExplicitDisconnect();
      }
      final boolean wasConnecting=is_internal(CONNECTING_OVERALL);
      final boolean attemptingReconnect_longTerm=cancelled ? false : is(RECONNECTING_LONG_TERM);
      E_Intent intent=cancelled ? E_Intent.INTENTIONAL : E_Intent.UNINTENTIONAL;
      m_lastConnectOrDisconnectWasUserExplicit=intent == E_Intent.INTENTIONAL;
      final boolean cancellableFromConnect=BleDeviceConfig.bool(conf_device().disconnectIsCancellable,conf_mngr().disconnectIsCancellable);
      final boolean tryBondingWhileDisconnected=connectionFailReasonIfConnecting == Status.BONDING_FAILED && BleDeviceConfig.bool(conf_device().tryBondingWhileDisconnected,conf_mngr().tryBondingWhileDisconnected);
      final boolean underwentPossibleImplicitBondingAttempt=m_nativeWrapper.isNativelyUnbonded() && m_underwentPossibleImplicitBondingAttempt == true;
      final boolean taskIsCancellable=cancellableFromConnect == true && tryBondingWhileDisconnected == false && underwentPossibleImplicitBondingAttempt == false;
{
        saveLastDisconnect(explicit);
        final boolean saveLastDisconnectAfterTaskCompletes=connectionFailReasonIfConnecting != Status.ROGUE_DISCONNECT;
        final int taskOrdinal;
        final boolean clearQueue;
        if (isAny_internal(CONNECTED,CONNECTING_OVERALL,INITIALIZED)) {
          final P_Task_Disconnect disconnectTask=new P_Task_Disconnect(BleDevice.this,m_taskStateListener,true,disconnectPriority_nullable,taskIsCancellable,saveLastDisconnectAfterTaskCompletes);
          queue().add(disconnectTask);
          taskOrdinal=disconnectTask.getOrdinal();
          clearQueue=true;
        }
 else {
          taskOrdinal=-1;
          clearQueue=false;
        }
        final Object[] overrideBondingStates=m_bondMngr.getOverrideBondStatesForDisconnect(connectionFailReasonIfConnecting);
        final boolean forceMainStateTracker=explicit;
        setStateToDisconnected(attemptingReconnect_longTerm,intent,gattStatus,forceMainStateTracker,overrideBondingStates);
        m_txnMngr.cancelAllTransactions();
        if (clearQueue) {
          queue().clearQueueOf(PA_Task_RequiresConnection.class,BleDevice.this,taskOrdinal);
        }
        if (!attemptingReconnect_longTerm) {
          m_reconnectMngr_longTerm.stop();
        }
      }
      if (wasConnecting) {
        if (getManager().ASSERT(connectionFailReasonIfConnecting != null)) {
          m_connectionFailMngr.onConnectionFailed(connectionFailReasonIfConnecting,timing,attemptingReconnect_longTerm,gattStatus,bondFailReason,highestState,ConnectionFailListener.AutoConnectUsage.NOT_APPLICABLE,txnFailReason);
        }
      }
    }
  }
);
}"
93929,"/** 
 * Wrapper for   {@link BluetoothGatt#requestConnectionPriority(int)} which attempts to change the connection priority for a given connection.This will eventually update the value returned by  {@link #getConnectionPriority()} but it is notinstantaneous. When we receive confirmation from the native stack then this value will be updated. The device must be  {@link BleDeviceState#CONNECTED} forthis call to succeed.
 * @see #setConnectionPriority(BleConnectionPriority,ReadWriteListener)
 * @see #getConnectionPriority()
 * @return (see similar comment for return value of {@link #connect(BleTransaction.Auth,BleTransaction.Init,StateListener,ConnectionFailListener)}).
 */
@Advanced public @Nullable(Prevalence.NEVER) ReadWriteListener.ReadWriteEvent setConnectionPriority(final BleConnectionPriority connectionPriority,final ReadWriteListener listener){
  return setConnectionPriority_private(connectionPriority,listener,getOverrideReadWritePriority());
}","/** 
 * Wrapper for   {@link BluetoothGatt#requestConnectionPriority(int)} which attempts to change the connection priority for a given connection.This will eventually update the value returned by  {@link #getConnectionPriority()} but it is notinstantaneous. When we receive confirmation from the native stack then this value will be updated. The device must be  {@link BleDeviceState#CONNECTED} forthis call to succeed.
 * @return (see similar comment for return value of {@link #connect(BleTransaction.Auth,BleTransaction.Init,StateListener,ConnectionFailListener)}).
 * @see #setConnectionPriority(BleConnectionPriority,ReadWriteListener)
 * @see #getConnectionPriority()
 */
@Advanced public @Nullable(Prevalence.NEVER) ReadWriteListener.ReadWriteEvent setConnectionPriority(final BleConnectionPriority connectionPriority,final ReadWriteListener listener){
  return setConnectionPriority_private(connectionPriority,listener,getOverrideReadWritePriority());
}"
93930,"/** 
 * Returns the cached data from the lastest successful read or notify received for a given uuid. Basically if you receive a   {@link ReadWriteListener.ReadWriteEvent} for which {@link ReadWriteListener.ReadWriteEvent#isRead()}and   {@link ReadWriteListener.ReadWriteEvent#wasSuccess()} both return <code>true</code> then {@link ReadWriteListener.ReadWriteEvent#data()}, will be cached and is retrievable by this method.
 * @see BleNodeConfig.HistoricalDataLogFilter
 * @see BleNodeConfig.DefaultHistoricalDataLogFilter
 * @return The cached value from a previous read or notify, or {@link HistoricalData#NULL} otherwise.
 */
@Advanced public @Nullable(Nullable.Prevalence.NEVER) HistoricalData getHistoricalData_latest(final UUID uuid){
  return getHistoricalData_atOffset(uuid,getHistoricalDataCount(uuid) - 1);
}","/** 
 * Returns the cached data from the lastest successful read or notify received for a given uuid. Basically if you receive a   {@link ReadWriteListener.ReadWriteEvent} for which {@link ReadWriteListener.ReadWriteEvent#isRead()}and   {@link ReadWriteListener.ReadWriteEvent#wasSuccess()} both return <code>true</code> then {@link ReadWriteListener.ReadWriteEvent#data()}, will be cached and is retrievable by this method.
 * @return The cached value from a previous read or notify, or {@link HistoricalData#NULL} otherwise.
 * @see BleNodeConfig.HistoricalDataLogFilter
 * @see BleNodeConfig.DefaultHistoricalDataLogFilter
 */
@Advanced public @Nullable(Nullable.Prevalence.NEVER) HistoricalData getHistoricalData_latest(final UUID uuid){
  return getHistoricalData_atOffset(uuid,getHistoricalDataCount(uuid) - 1);
}"
93931,"private void connect_private(BleTransaction.Auth authenticationTxn,BleTransaction.Init initTxn,final boolean isReconnect){
  if (is_internal(INITIALIZED)) {
    getManager().ASSERT(false,""String_Node_Str"");
    return;
  }
  BleTransaction.Auth auth=authenticationTxn != null ? authenticationTxn : m_config.defaultAuthTransaction;
  BleTransaction.Init init=initTxn != null ? initTxn : m_config.defaultInitTransaction;
  m_txnMngr.onConnect(auth,init);
  final Object[] extraBondingStates;
  if (is(UNBONDED) && Utils.isKitKat()) {
    final boolean tryBondingWhileDisconnected=BleDeviceConfig.bool(conf_device().tryBondingWhileDisconnected,conf_mngr().tryBondingWhileDisconnected);
    final boolean tryBondingWhileDisconnected_manageOnDisk=BleDeviceConfig.bool(conf_device().tryBondingWhileDisconnected_manageOnDisk,conf_mngr().tryBondingWhileDisconnected_manageOnDisk);
    final boolean doPreBond=getManager().m_diskOptionsMngr.loadNeedsBonding(getMacAddress(),tryBondingWhileDisconnected_manageOnDisk);
    if (doPreBond && tryBondingWhileDisconnected) {
      bond_justAddTheTask(E_TransactionLockBehavior.PASSES);
      extraBondingStates=P_BondManager.OVERRIDE_BONDING_STATES;
    }
 else {
      extraBondingStates=P_BondManager.OVERRIDE_EMPTY_STATES;
    }
  }
 else {
    extraBondingStates=P_BondManager.OVERRIDE_EMPTY_STATES;
  }
  onConnecting(true,isReconnect,extraBondingStates,false);
  if (!is_internal(CONNECTING_OVERALL)) {
    return;
  }
  queue().add(new P_Task_Connect(this,m_taskStateListener));
  onConnecting(true,isReconnect,extraBondingStates,true);
}","private void connect_private(BleTransaction.Auth authenticationTxn,BleTransaction.Init initTxn,final boolean isReconnect){
  if (is_internal(INITIALIZED)) {
    getManager().ASSERT(false,""String_Node_Str"");
    return;
  }
  BleTransaction.Auth auth=authenticationTxn != null ? authenticationTxn : conf_device().defaultAuthTransaction;
  BleTransaction.Init init=initTxn != null ? initTxn : conf_device().defaultInitTransaction;
  m_txnMngr.onConnect(auth,init);
  final Object[] extraBondingStates;
  if (is(UNBONDED) && Utils.isKitKat()) {
    final boolean tryBondingWhileDisconnected=BleDeviceConfig.bool(conf_device().tryBondingWhileDisconnected,conf_mngr().tryBondingWhileDisconnected);
    final boolean tryBondingWhileDisconnected_manageOnDisk=BleDeviceConfig.bool(conf_device().tryBondingWhileDisconnected_manageOnDisk,conf_mngr().tryBondingWhileDisconnected_manageOnDisk);
    final boolean doPreBond=getManager().m_diskOptionsMngr.loadNeedsBonding(getMacAddress(),tryBondingWhileDisconnected_manageOnDisk);
    if (doPreBond && tryBondingWhileDisconnected) {
      bond_justAddTheTask(E_TransactionLockBehavior.PASSES);
      extraBondingStates=P_BondManager.OVERRIDE_BONDING_STATES;
    }
 else {
      extraBondingStates=P_BondManager.OVERRIDE_EMPTY_STATES;
    }
  }
 else {
    extraBondingStates=P_BondManager.OVERRIDE_EMPTY_STATES;
  }
  onConnecting(true,isReconnect,extraBondingStates,false);
  if (!is_internal(CONNECTING_OVERALL)) {
    return;
  }
  queue().add(new P_Task_Connect(this,m_taskStateListener));
  onConnecting(true,isReconnect,extraBondingStates,true);
}"
93932,"/** 
 * Same as   {@link #connect(BleTransaction.Auth,BleTransaction.Init)} but calls {@link #setListener_State(StateListener)} and{@link #setListener_ConnectionFail(ConnectionFailListener)} for you.
 * @return	If the attempt could not even ""leave the gate"" for some resaon, a valid {@link ConnectionFailEvent} is returned telling you why. Otherwisethis method will still return a non-null instance but  {@link ConnectionFailEvent#isNull()} will be <code>true</code>.<br><br> NOTE: your  {@link ConnectionFailListener} will still be called even if this method early-outs.<br><br> TIP:	You can use the return value as an optimization. Many apps will call this method (or its overloads) and throw up a spinner until receiving a callback to  {@link ConnectionFailListener}. However if   {@link ConnectionFailEvent#isNull()} for the return value is <code>false</code>, meaningthe connection attempt couldn't even start for some reason, then you don't have to throw up the spinner in the first place.
 */
public @Nullable(Prevalence.NEVER) ConnectionFailListener.ConnectionFailEvent connect(BleTransaction.Auth authenticationTxn,BleTransaction.Init initTxn,DeviceStateListener stateListener,ConnectionFailListener failListener){
  if (stateListener != null) {
    setListener_State(stateListener);
  }
  if (failListener != null) {
    setListener_ConnectionFail(failListener);
  }
  m_connectionFailMngr.onExplicitConnectionStarted();
  final ConnectionFailListener.ConnectionFailEvent info_earlyOut=connect_earlyOut();
  if (info_earlyOut != null)   return info_earlyOut;
  m_lastConnectOrDisconnectWasUserExplicit=true;
  if (isAny(CONNECTED,CONNECTING,CONNECTING_OVERALL)) {
    stateTracker_main().remove(RECONNECTING_LONG_TERM,E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
    final ConnectionFailListener.ConnectionFailEvent info_alreadyConnected=ConnectionFailListener.ConnectionFailEvent.EARLY_OUT(this,Status.ALREADY_CONNECTING_OR_CONNECTED);
    m_connectionFailMngr.invokeCallback(info_alreadyConnected);
    return info_alreadyConnected;
  }
  connect_private(authenticationTxn,initTxn,false);
  return NULL_CONNECTIONFAIL_INFO();
}","/** 
 * Same as   {@link #connect(BleTransaction.Auth,BleTransaction.Init)} but calls {@link #setListener_State(StateListener)} and{@link #setListener_ConnectionFail(ConnectionFailListener)} for you.
 * @return If the attempt could not even ""leave the gate"" for some resaon, a valid {@link ConnectionFailEvent} is returned telling you why. Otherwisethis method will still return a non-null instance but  {@link ConnectionFailEvent#isNull()} will be <code>true</code>.<br><br> NOTE: your  {@link ConnectionFailListener} will still be called even if this method early-outs.<br><br> TIP:	You can use the return value as an optimization. Many apps will call this method (or its overloads) and throw up a spinner until receiving a callback to  {@link ConnectionFailListener}. However if   {@link ConnectionFailEvent#isNull()} for the return value is <code>false</code>, meaningthe connection attempt couldn't even start for some reason, then you don't have to throw up the spinner in the first place.
 */
public @Nullable(Prevalence.NEVER) ConnectionFailListener.ConnectionFailEvent connect(BleTransaction.Auth authenticationTxn,BleTransaction.Init initTxn,DeviceStateListener stateListener,ConnectionFailListener failListener){
  if (stateListener != null) {
    setListener_State(stateListener);
  }
  if (failListener != null) {
    setListener_ConnectionFail(failListener);
  }
  m_connectionFailMngr.onExplicitConnectionStarted();
  final ConnectionFailListener.ConnectionFailEvent info_earlyOut=connect_earlyOut();
  if (info_earlyOut != null)   return info_earlyOut;
  m_lastConnectOrDisconnectWasUserExplicit=true;
  if (isAny(CONNECTED,CONNECTING,CONNECTING_OVERALL)) {
    stateTracker_main().remove(RECONNECTING_LONG_TERM,E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
    final ConnectionFailListener.ConnectionFailEvent info_alreadyConnected=ConnectionFailListener.ConnectionFailEvent.EARLY_OUT(this,Status.ALREADY_CONNECTING_OR_CONNECTED);
    m_connectionFailMngr.invokeCallback(info_alreadyConnected);
    return info_alreadyConnected;
  }
  connect_private(authenticationTxn,initTxn,false);
  return NULL_CONNECTIONFAIL_INFO();
}"
93933,"/** 
 * Provides all historical data through the ""for each"" provided within the range provided.
 * @see BleNodeConfig.HistoricalDataLogFilter
 * @see BleNodeConfig.DefaultHistoricalDataLogFilter
 * @return <code>true</code> if there are any entries, <code>false</code> otherwise.
 */
@Advanced public boolean getHistoricalData_forEach(final UUID uuid,final EpochTimeRange range,final ForEach_Breakable<HistoricalData> forEach){
  if (isNull())   return false;
  return m_historicalDataMngr.doForEach(uuid,EpochTimeRange.denull(range),forEach);
}","/** 
 * Provides all historical data through the ""for each"" provided within the range provided.
 * @return <code>true</code> if there are any entries, <code>false</code> otherwise.
 * @see BleNodeConfig.HistoricalDataLogFilter
 * @see BleNodeConfig.DefaultHistoricalDataLogFilter
 */
@Advanced public boolean getHistoricalData_forEach(final UUID uuid,final EpochTimeRange range,final ForEach_Breakable<HistoricalData> forEach){
  if (isNull())   return false;
  return m_historicalDataMngr.doForEach(uuid,EpochTimeRange.denull(range),forEach);
}"
93934,"void invokeReadWriteCallback(final ReadWriteListener listener_nullable,final ReadWriteListener.ReadWriteEvent event){
  if (event.wasSuccess() && event.isRead() && event.target() == ReadWriteListener.Target.CHARACTERISTIC) {
    final EpochTime timestamp=new EpochTime();
    final BleNodeConfig.HistoricalDataLogFilter.Source source=event.type().toHistoricalDataSource();
    m_historicalDataMngr.add_single(event.charUuid(),event.data(),timestamp,source);
  }
  m_txnMngr.onReadWriteResult(event);
  if (listener_nullable != null) {
    postEvent(listener_nullable,event);
  }
  if (m_defaultReadWriteListener != null) {
    postEvent(m_defaultReadWriteListener,event);
  }
  if (getManager() != null && getManager().m_defaultReadWriteListener != null) {
    postEvent(getManager().m_defaultReadWriteListener,event);
  }
  if (m_defaultNotificationListener != null && (event.type().isNotification() || event.type() == Type.DISABLING_NOTIFICATION || event.type() == Type.ENABLING_NOTIFICATION)) {
    m_defaultNotificationListener.onEvent(fromReadWriteEvent(event));
  }
  m_txnMngr.onReadWriteResultCallbacksCalled();
}","void invokeReadWriteCallback(final ReadWriteListener listener_nullable,final ReadWriteListener.ReadWriteEvent event){
  if (event.wasSuccess() && event.isRead() && event.target() == ReadWriteListener.Target.CHARACTERISTIC) {
    final EpochTime timestamp=new EpochTime();
    final BleNodeConfig.HistoricalDataLogFilter.Source source=event.type().toHistoricalDataSource();
    m_historicalDataMngr.add_single(event.charUuid(),event.data(),timestamp,source);
  }
  m_txnMngr.onReadWriteResult(event);
  if (listener_nullable != null) {
    postEvent(listener_nullable,event);
  }
  if (m_defaultReadWriteListener != null) {
    postEvent(m_defaultReadWriteListener,event);
  }
  if (getManager() != null && getManager().m_defaultReadWriteListener != null) {
    postEvent(getManager().m_defaultReadWriteListener,event);
  }
  if (m_defaultNotificationListener != null && (event.type().isNotification() || event.type() == Type.DISABLING_NOTIFICATION || event.type() == Type.ENABLING_NOTIFICATION)) {
    postEvent(m_defaultNotificationListener,fromReadWriteEvent(event));
  }
  m_txnMngr.onReadWriteResultCallbacksCalled();
}"
93935,"public void tryExecuting(){
  if (m_state == PE_TaskState.ARMED) {
{
      if (m_softlyCancelled) {
        softlyCancel();
        return;
      }
      if (isExecutable()) {
        setState(PE_TaskState.EXECUTING);
        execute_wrapper();
        return;
      }
 else {
        onNotExecutable();
        return;
      }
    }
  }
}","/** 
 * Returns <code>true</code> if   {@link P_TaskQueue#print()} ends up getting called.
 */
public boolean tryExecuting(){
  if (m_state == PE_TaskState.ARMED) {
{
      if (m_softlyCancelled) {
        softlyCancel();
        return false;
      }
      if (isExecutable()) {
        boolean printCalled=setState(PE_TaskState.EXECUTING);
        execute_wrapper();
        return printCalled;
      }
 else {
        onNotExecutable();
      }
    }
  }
  return false;
}"
93936,"private void setState(PE_TaskState newState){
  if (!m_manager.ASSERT(newState != m_state))   return;
  m_state=newState;
  if (getLogger().isEnabled()) {
    if (m_state.isEndingState()) {
      String logText=this.toString();
      if (m_queue != null) {
        logText+=""String_Node_Str"" + m_queue.getUpdateCount();
      }
      getLogger().i(logText);
    }
 else     if (m_state == PE_TaskState.EXECUTING) {
      getQueue().print();
    }
  }
  if (m_stateListener != null)   m_stateListener.onStateChange(this,m_state);
}","/** 
 * Returns <code>true</code> if   {@link P_TaskQueue#print()} was called.
 */
private boolean setState(PE_TaskState newState){
  if (!m_manager.ASSERT(newState != m_state))   return false;
  m_state=newState;
  if (getLogger().isEnabled()) {
    if (m_state.isEndingState()) {
      String logText=this.toString();
      if (m_queue != null) {
        logText+=""String_Node_Str"" + m_queue.getUpdateCount();
      }
      getLogger().i(logText);
    }
 else     if (m_state == PE_TaskState.EXECUTING) {
      getQueue().print();
      return true;
    }
  }
  if (m_stateListener != null)   m_stateListener.onStateChange(this,m_state);
  return false;
}"
93937,"private void resetFailCount(){
  m_failCount=0;
  m_highestStateReached_total=null;
  m_timeOfFirstConnect=m_timeOfLastConnectFail=null;
  m_history.clear();
}","private void resetFailCount(){
  m_device.getManager().getPostManager().postToUpdateThread(new Runnable(){
    @Override public void run(){
      m_failCount=0;
      m_highestStateReached_total=null;
      m_timeOfFirstConnect=m_timeOfLastConnectFail=null;
      m_history.clear();
    }
  }
);
}"
93938,"public final void postToUpdateThread(Runnable action){
  if (isOnSweetBlueThread()) {
    action.run();
  }
 else {
    m_updateHandler.post(action);
  }
}","public final void postToUpdateThread(Runnable action){
  m_updateHandler.post(action);
}"
93939,"private synchronized boolean dequeue(){
  if (!m_mngr.ASSERT(m_current == null))   return false;
  if (m_queue.size() == 0)   return false;
  for (int i=0; i < m_queue.size(); i++) {
    PA_Task newPotentialCurrent=m_queue.get(i);
    if (newPotentialCurrent.isArmable()) {
      m_queue.remove(i);
      m_current=newPotentialCurrent;
      m_current.arm();
      m_current.tryExecuting();
      print();
      return true;
    }
  }
  print();
  return false;
}","private synchronized boolean dequeue(){
  if (!m_mngr.ASSERT(m_current == null))   return false;
  if (m_queue.size() == 0)   return false;
  for (int i=0; i < m_queue.size(); i++) {
    PA_Task newPotentialCurrent=m_queue.get(i);
    if (newPotentialCurrent.isArmable()) {
      m_queue.remove(i);
      m_current=newPotentialCurrent;
      m_current.arm();
      if (!m_current.tryExecuting()) {
        print();
      }
      return true;
    }
  }
  return false;
}"
93940,"@Override protected void update(double timeStep){
  if (m_gattRefresh) {
    m_curGattDelay+=timeStep;
    if (m_curGattDelay >= m_gattDelayTarget) {
      if (!getDevice().gattLayer().discoverServices()) {
        failImmediately();
        getManager().uhOh(UhOh.SERVICE_DISCOVERY_IMMEDIATELY_FAILED);
      }
    }
  }
}","@Override protected void update(double timeStep){
  if (m_gattRefresh && !m_discoverAttempted) {
    m_curGattDelay+=timeStep;
    if (m_curGattDelay >= m_gattDelayTarget) {
      m_discoverAttempted=true;
      if (!getDevice().gattLayer().discoverServices()) {
        failImmediately();
        getManager().uhOh(UhOh.SERVICE_DISCOVERY_IMMEDIATELY_FAILED);
      }
    }
  }
}"
93941,"@Override public void execute(){
{
    if (m_gattRefresh) {
      getDevice().gattLayer().refreshGatt();
      return;
    }
  }
  if (!getDevice().gattLayer().discoverServices()) {
    failImmediately();
    getManager().uhOh(UhOh.SERVICE_DISCOVERY_IMMEDIATELY_FAILED);
  }
}","@Override public void execute(){
{
    if (m_gattRefresh) {
      getDevice().gattLayer().refreshGatt();
      return;
    }
  }
  if (!getDevice().gattLayer().discoverServices()) {
    failImmediately();
    getManager().uhOh(UhOh.SERVICE_DISCOVERY_IMMEDIATELY_FAILED);
  }
  m_discoverAttempted=true;
}"
93942,"void invokeReadWriteCallback(final ReadWriteListener listener_nullable,final ReadWriteListener.ReadWriteEvent event){
  if (event.wasSuccess() && event.isRead() && event.target() == ReadWriteListener.Target.CHARACTERISTIC) {
    final EpochTime timestamp=new EpochTime();
    final BleNodeConfig.HistoricalDataLogFilter.Source source=event.type().toHistoricalDataSource();
    m_historicalDataMngr.add_single(event.charUuid(),event.data(),timestamp,source);
  }
  m_txnMngr.onReadWriteResult(event);
  if (listener_nullable != null) {
    postEvent(listener_nullable,event);
  }
  if (m_defaultReadWriteListener != null) {
    postEvent(m_defaultReadWriteListener,event);
  }
  if (getManager() != null && getManager().m_defaultReadWriteListener != null) {
    postEvent(getManager().m_defaultReadWriteListener,event);
  }
  if (m_defaultNotificationListener != null && event.type().isNotification() || event.type() == Type.DISABLING_NOTIFICATION || event.type() == Type.ENABLING_NOTIFICATION) {
    m_defaultNotificationListener.onEvent(fromReadWriteEvent(event));
  }
  m_txnMngr.onReadWriteResultCallbacksCalled();
}","void invokeReadWriteCallback(final ReadWriteListener listener_nullable,final ReadWriteListener.ReadWriteEvent event){
  if (event.wasSuccess() && event.isRead() && event.target() == ReadWriteListener.Target.CHARACTERISTIC) {
    final EpochTime timestamp=new EpochTime();
    final BleNodeConfig.HistoricalDataLogFilter.Source source=event.type().toHistoricalDataSource();
    m_historicalDataMngr.add_single(event.charUuid(),event.data(),timestamp,source);
  }
  m_txnMngr.onReadWriteResult(event);
  if (listener_nullable != null) {
    postEvent(listener_nullable,event);
  }
  if (m_defaultReadWriteListener != null) {
    postEvent(m_defaultReadWriteListener,event);
  }
  if (getManager() != null && getManager().m_defaultReadWriteListener != null) {
    postEvent(getManager().m_defaultReadWriteListener,event);
  }
  if (m_defaultNotificationListener != null && (event.type().isNotification() || event.type() == Type.DISABLING_NOTIFICATION || event.type() == Type.ENABLING_NOTIFICATION)) {
    m_defaultNotificationListener.onEvent(fromReadWriteEvent(event));
  }
  m_txnMngr.onReadWriteResultCallbacksCalled();
}"
93943,"public void onDescriptorRead(BluetoothGattDescriptor desc,byte[] value,int gattStatus){
  if (!isFor(desc)) {
    return;
  }
  if (Utils.isSuccess(gattStatus)) {
    if (Arrays.equals(value,mNameSpaceAndDescription)) {
      if (false == getDevice().getNativeGatt().readCharacteristic(desc.getCharacteristic())) {
        fail(BleDevice.ReadWriteListener.Status.FAILED_TO_SEND_OUT,BleStatuses.GATT_STATUS_NOT_APPLICABLE,BleDevice.ReadWriteListener.Target.DESCRIPTOR,desc.getCharacteristic().getUuid(),BleDevice.ReadWriteListener.ReadWriteEvent.NON_APPLICABLE_UUID);
      }
 else {
      }
    }
 else {
      batteryChars.remove(desc.getCharacteristic());
      if (batteryChars.size() == 0) {
        fail(BleDevice.ReadWriteListener.Status.NO_MATCHING_TARGET,BleStatuses.GATT_STATUS_NOT_APPLICABLE,BleDevice.ReadWriteListener.Target.DESCRIPTOR,desc.getCharacteristic().getUuid(),desc.getUuid());
      }
 else {
        final BluetoothGattCharacteristic ch=batteryChars.get(0);
        final BluetoothGattDescriptor descr=ch.getDescriptor(Uuids.CHARACTERISTIC_PRESENTATION_FORMAT_DESCRIPTOR_UUID);
        if (!getDevice().getNativeGatt().readDescriptor(descr)) {
          fail(BleDevice.ReadWriteListener.Status.FAILED_TO_SEND_OUT,BleStatuses.GATT_STATUS_NOT_APPLICABLE,BleDevice.ReadWriteListener.Target.DESCRIPTOR,ch.getUuid(),descr.getUuid());
        }
 else {
        }
      }
    }
  }
 else {
    fail(BleDevice.ReadWriteListener.Status.REMOTE_GATT_FAILURE,gattStatus,getDefaultTarget(),getCharUuid(),getDescUuid());
  }
}","public void onDescriptorRead(BluetoothGattDescriptor desc,byte[] value,int gattStatus){
  if (!batteryChars.contains(desc.getCharacteristic())) {
    return;
  }
  if (Utils.isSuccess(gattStatus)) {
    final byte[] nmdesc=Arrays.copyOfRange(value,4,7);
    if (Arrays.equals(nmdesc,mNameSpaceAndDescription)) {
      if (false == getDevice().getNativeGatt().readCharacteristic(desc.getCharacteristic())) {
        fail(BleDevice.ReadWriteListener.Status.FAILED_TO_SEND_OUT,BleStatuses.GATT_STATUS_NOT_APPLICABLE,BleDevice.ReadWriteListener.Target.DESCRIPTOR,desc.getCharacteristic().getUuid(),BleDevice.ReadWriteListener.ReadWriteEvent.NON_APPLICABLE_UUID);
      }
 else {
      }
    }
 else {
      batteryChars.remove(desc.getCharacteristic());
      if (batteryChars.size() == 0) {
        fail(BleDevice.ReadWriteListener.Status.NO_MATCHING_TARGET,BleStatuses.GATT_STATUS_NOT_APPLICABLE,BleDevice.ReadWriteListener.Target.DESCRIPTOR,desc.getCharacteristic().getUuid(),desc.getUuid());
      }
 else {
        final BluetoothGattCharacteristic ch=batteryChars.get(0);
        final BluetoothGattDescriptor descr=ch.getDescriptor(Uuids.CHARACTERISTIC_PRESENTATION_FORMAT_DESCRIPTOR_UUID);
        if (!getDevice().getNativeGatt().readDescriptor(descr)) {
          fail(BleDevice.ReadWriteListener.Status.FAILED_TO_SEND_OUT,BleStatuses.GATT_STATUS_NOT_APPLICABLE,BleDevice.ReadWriteListener.Target.DESCRIPTOR,ch.getUuid(),descr.getUuid());
        }
 else {
        }
      }
    }
  }
 else {
    fail(BleDevice.ReadWriteListener.Status.REMOTE_GATT_FAILURE,gattStatus,getDefaultTarget(),getCharUuid(),getDescUuid());
  }
}"
93944,"/** 
 * A constructor which taken an activity and a custom implementation of   {@link BluetoothEnablerFilter}.
 */
private void BluetoothEnabler(Activity activity,BluetoothEnablerFilter enablerFilter){
  m_defaultActivity=activity;
  m_enablerFilter=enablerFilter;
  m_lifecycleCallback=newLifecycleCallbacks();
  m_defaultActivity.getApplication().registerActivityLifecycleCallbacks(m_lifecycleCallback);
  m_isForegrounded=true;
  m_currentStage=BluetoothEnablerFilter.Stage.START;
  dispatchEvent(getStage(),getStage().next(),BluetoothEnablerFilter.Status.NULL);
}","/** 
 * A constructor which taken an activity and a custom implementation of   {@link BluetoothEnablerFilter}.
 */
private void BluetoothEnabler(Activity activity,BluetoothEnablerFilter enablerFilter){
  m_defaultActivity=activity;
  m_enablerFilter=enablerFilter;
  m_lifecycleCallback=newLifecycleCallbacks();
  m_defaultActivity.getApplication().registerActivityLifecycleCallbacks(m_lifecycleCallback);
  m_isForegrounded=true;
  m_currentStage=BluetoothEnablerFilter.Stage.START;
}"
93945,"/** 
 * Kicks off the complex flow needed to fully enable Bluetooth on Build versions greater than or equal to   {@link android.os.Build.VERSION_CODES#M}.
 */
public static BluetoothEnabler start(final Activity activity,final BluetoothEnablerFilter filter){
  if (s_instance != null && false == s_instance.isDone()) {
    s_instance.setNewFilter(filter);
  }
 else {
    s_instance=new BluetoothEnabler(activity,filter);
  }
  return s_instance;
}","/** 
 * Kicks off the complex flow needed to fully enable Bluetooth on Build versions greater than or equal to   {@link android.os.Build.VERSION_CODES#M}.
 */
public static BluetoothEnabler start(final Activity activity,final BluetoothEnablerFilter filter){
  if (s_instance != null && false == s_instance.isDone()) {
    s_instance.setNewFilter(filter);
  }
 else {
    s_instance=new BluetoothEnabler(activity,filter);
    s_instance.dispatchEvent(s_instance.getStage(),s_instance.getStage().next(),BluetoothEnablerFilter.Status.NULL);
  }
  return s_instance;
}"
93946,"private int getBleState(){
  if (Utils.isMarshmallow()) {
    try {
      final Method method=BluetoothAdapter.class.getDeclaredMethod(""String_Node_Str"");
      final Integer state=(Integer)method.invoke(m_mngr.getNativeAdapter());
      return state;
    }
 catch (    Exception e) {
      return m_mngr.getNativeAdapter().getState();
    }
  }
 else {
    return m_mngr.getNativeAdapter().getState();
  }
}","private int getBleState(){
  if (Utils.isMarshmallow()) {
    try {
      final Method method=BluetoothAdapter.class.getDeclaredMethod(""String_Node_Str"");
      final Integer state=(Integer)method.invoke(m_mngr.getNativeAdapter());
      final Integer state2=m_mngr.getNativeAdapter().getState();
      if (state == BleStatuses.STATE_BLE_ON && state2 == OFF.getNativeCode()) {
        return state2;
      }
      return state;
    }
 catch (    Exception e) {
      return m_mngr.getNativeAdapter().getState();
    }
  }
 else {
    return m_mngr.getNativeAdapter().getState();
  }
}"
93947,"/** 
 * Returns <code>true</code> if   {@link #turnOnLocationWithIntent_forPermissions(Activity,int)} will pop a system dialog, <code>false</code> if it will bringyou to the OS's Application Settings. The <code>true</code> case happens if the app has never shown a request Location Permissions dialog or has shown a request Location Permission dialog and the user has yet to select ""Never ask again"". This method is used to weed out the false negative from  {@link Activity#shouldShowRequestPermissionRationale(String)} when the Location Permission has never been requested. Make sure to use this in conjunction with {@link #isLocationEnabledForScanning_byRuntimePermissions()}which will tell you if permissions are already enabled.
 * @see com.idevicesinc.sweetblue.utils.BluetoothEnabler
 */
public boolean willLocationPermissionSystemDialogBeShown(Activity callingActivity){
  SharedPreferences preferences=callingActivity.getSharedPreferences(LOCATION_PERMISSION_NAMESPACE,Context.MODE_PRIVATE);
  boolean hasNeverAskAgainBeenSelected=!callingActivity.shouldShowRequestPermissionRationale(Manifest.permission.ACCESS_COARSE_LOCATION);
  boolean hasLocationPermissionSystemDialogShownOnce=preferences.getBoolean(LOCATION_PERMISSION_KEY,false);
  return (!hasLocationPermissionSystemDialogShownOnce) || (hasLocationPermissionSystemDialogShownOnce && !hasNeverAskAgainBeenSelected);
}","/** 
 * Returns <code>true</code> if   {@link #turnOnLocationWithIntent_forPermissions(Activity,int)} will pop a system dialog, <code>false</code> if it will bringyou to the OS's Application Settings. The <code>true</code> case happens if the app has never shown a request Location Permissions dialog or has shown a request Location Permission dialog and the user has yet to select ""Never ask again"". This method is used to weed out the false negative from  {@link Activity#shouldShowRequestPermissionRationale(String)} when the Location Permission has never been requested. Make sure to use this in conjunction with {@link #isLocationEnabledForScanning_byRuntimePermissions()}which will tell you if permissions are already enabled.
 * @see com.idevicesinc.sweetblue.utils.BluetoothEnabler
 */
@TargetApi(Build.VERSION_CODES.M) public boolean willLocationPermissionSystemDialogBeShown(Activity callingActivity){
  SharedPreferences preferences=callingActivity.getSharedPreferences(LOCATION_PERMISSION_NAMESPACE,Context.MODE_PRIVATE);
  boolean hasNeverAskAgainBeenSelected=!callingActivity.shouldShowRequestPermissionRationale(Manifest.permission.ACCESS_COARSE_LOCATION);
  boolean hasLocationPermissionSystemDialogShownOnce=preferences.getBoolean(LOCATION_PERMISSION_KEY,false);
  return (!hasLocationPermissionSystemDialogShownOnce) || (hasLocationPermissionSystemDialogShownOnce && !hasNeverAskAgainBeenSelected);
}"
93948,"@Override public void onClick(DialogInterface dialog,int which){
  dialog.dismiss();
}","@Override public void onClick(DialogInterface dialog,int which){
}"
93949,"private void updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status newStatus){
  m_currentEvent=new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentEvent.stage(),newStatus);
  m_lastPlease=m_startupListener.onEvent(m_currentEvent);
  handlePleaseResponse();
}","private void updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status newStatus){
  BluetoothEnablerListener.BluetoothEnablerEvent currentEvent=new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage,newStatus);
  m_lastPlease=m_startupListener.onEvent(currentEvent);
  handlePleaseResponse();
}"
93950,"public void BluetoothEnabler(Activity activity,BluetoothEnablerListener startupListener){
  m_bleManager=BleManager.get(activity);
  m_passedActivity=activity;
  m_currentStage=BluetoothEnablerListener.Stage.START;
  m_currentEvent=new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage,BluetoothEnablerListener.Status.NULL);
  m_startupListener=startupListener;
  nextStage();
}","public void BluetoothEnabler(Activity activity,BluetoothEnablerListener startupListener){
  m_bleManager=BleManager.get(activity);
  m_passedActivity=activity;
  m_currentStage=BluetoothEnablerListener.Stage.START;
  BluetoothEnablerListener.BluetoothEnablerEvent startEvent=new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage,BluetoothEnablerListener.Status.NULL);
  m_startupListener=startupListener;
  nextStage(startEvent);
}"
93951,"private void nextStage(){
  if (m_currentEvent.stage() == BluetoothEnablerListener.Stage.START) {
    if (m_bleManager.isBleSupported() && !m_bleManager.is(BleManagerState.ON)) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.NEEDS_ENABLING);
    }
 else {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.ALREADY_ENABLED);
    }
  }
 else   if (m_currentStage == BluetoothEnablerListener.Stage.BLUETOOTH) {
    if (m_currentEvent.status() == BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG);
    }
 else     if (m_currentEvent.status() == BluetoothEnablerListener.Status.SKIPPED) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.SKIPPED);
    }
 else     if (m_bleManager.isBleSupported() && !m_bleManager.is(BleManagerState.ON)) {
      Activity resultActivity=m_lastPlease.m_activity != null ? m_lastPlease.m_activity : m_passedActivity;
      m_bleManager.turnOnWithIntent(resultActivity,m_lastPlease.m_requestCode);
    }
 else {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.ALREADY_ENABLED);
    }
  }
 else   if (m_currentStage == BluetoothEnablerListener.Stage.LOCATION_PERMISSION) {
    if (!Utils.isMarshmallow()) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.NOT_NEEDED);
    }
 else {
      if (m_currentEvent.status() == BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) {
        updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG);
      }
 else       if (m_currentEvent.status() == BluetoothEnablerListener.Status.SKIPPED) {
        updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.SKIPPED);
      }
 else       if (!m_bleManager.isLocationEnabledForScanning_byRuntimePermissions()) {
        Activity resultActivity=m_lastPlease.m_activity != null ? m_lastPlease.m_activity : m_passedActivity;
        m_bleManager.turnOnLocationWithIntent_forPermissions(resultActivity,m_lastPlease.m_requestCode);
      }
 else {
        updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.ALREADY_ENABLED);
      }
    }
  }
 else   if (m_currentStage == BluetoothEnablerListener.Stage.LOCATION_SERVICES) {
    if (m_currentEvent.status() == BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG);
    }
 else     if (m_currentEvent.status() == BluetoothEnablerListener.Status.SKIPPED) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.SKIPPED);
    }
 else     if (!m_bleManager.isLocationEnabledForScanning_byOsServices()) {
      Activity resultActivity=m_lastPlease.m_activity != null ? m_lastPlease.m_activity : m_passedActivity;
      m_bleManager.turnOnLocationWithIntent_forOsServices(resultActivity,m_lastPlease.m_requestCode);
    }
 else {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.ALREADY_ENABLED);
    }
  }
}","private void nextStage(BluetoothEnablerListener.BluetoothEnablerEvent nextEvent){
  if (m_currentStage == BluetoothEnablerListener.Stage.START) {
    if (m_bleManager.isBleSupported() && !m_bleManager.is(BleManagerState.ON)) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.NEEDS_ENABLING);
    }
 else {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.ALREADY_ENABLED);
    }
  }
 else   if (m_currentStage == BluetoothEnablerListener.Stage.BLUETOOTH) {
    if (nextEvent.status() == BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG);
    }
 else     if (nextEvent.status() == BluetoothEnablerListener.Status.SKIPPED) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.SKIPPED);
    }
 else     if (m_bleManager.isBleSupported() && !m_bleManager.is(BleManagerState.ON)) {
      Activity resultActivity=m_lastPlease.m_activity != null ? m_lastPlease.m_activity : m_passedActivity;
      m_bleManager.turnOnWithIntent(resultActivity,m_lastPlease.m_requestCode);
    }
 else {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.ALREADY_ENABLED);
    }
  }
 else   if (m_currentStage == BluetoothEnablerListener.Stage.LOCATION_PERMISSION) {
    if (!Utils.isMarshmallow()) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.NOT_NEEDED);
    }
 else {
      if (nextEvent.status() == BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) {
        updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG);
      }
 else       if (nextEvent.status() == BluetoothEnablerListener.Status.SKIPPED) {
        updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.SKIPPED);
      }
 else       if (!m_bleManager.isLocationEnabledForScanning_byRuntimePermissions()) {
        Activity resultActivity=m_lastPlease.m_activity != null ? m_lastPlease.m_activity : m_passedActivity;
        m_bleManager.turnOnLocationWithIntent_forPermissions(resultActivity,m_lastPlease.m_requestCode);
      }
 else {
        updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.ALREADY_ENABLED);
      }
    }
  }
 else   if (m_currentStage == BluetoothEnablerListener.Stage.LOCATION_SERVICES) {
    if (nextEvent.status() == BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG);
    }
 else     if (nextEvent.status() == BluetoothEnablerListener.Status.SKIPPED) {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.SKIPPED);
    }
 else     if (!m_bleManager.isLocationEnabledForScanning_byOsServices()) {
      Activity resultActivity=m_lastPlease.m_activity != null ? m_lastPlease.m_activity : m_passedActivity;
      m_bleManager.turnOnLocationWithIntent_forOsServices(resultActivity,m_lastPlease.m_requestCode);
    }
 else {
      updateEventStatusAndPassEventToUser(BluetoothEnablerListener.Status.ALREADY_ENABLED);
    }
  }
}"
93952,"private void finishPleaseResponse(boolean wasCancelledByDialog){
  if (m_lastPlease.m_stateCode == BluetoothEnablerListener.Please.DO_NEXT) {
    m_currentStage=m_currentStage.next();
    m_currentEvent=wasCancelledByDialog ? new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage,BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) : new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage);
    nextStage();
  }
 else   if (m_lastPlease.m_stateCode == BluetoothEnablerListener.Please.SKIP_NEXT) {
    m_currentStage=m_currentStage.next();
    m_currentEvent=wasCancelledByDialog ? new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage,BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) : new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage,BluetoothEnablerListener.Status.SKIPPED);
    nextStage();
  }
 else   if (m_lastPlease.m_stateCode == BluetoothEnablerListener.Please.END) {
    m_currentStage=BluetoothEnablerListener.Stage.LOCATION_SERVICES;
    m_currentEvent=wasCancelledByDialog ? new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage,BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) : new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage);
  }
}","private void finishPleaseResponse(boolean wasCancelledByDialog){
  if (m_lastPlease.m_stateCode == BluetoothEnablerListener.Please.DO_NEXT) {
    m_currentStage=m_currentStage.next();
    BluetoothEnablerListener.BluetoothEnablerEvent nextEvent=wasCancelledByDialog ? new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage,BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) : new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage);
    nextStage(nextEvent);
  }
 else   if (m_lastPlease.m_stateCode == BluetoothEnablerListener.Please.SKIP_NEXT) {
    m_currentStage=m_currentStage.next();
    BluetoothEnablerListener.BluetoothEnablerEvent nextEvent=wasCancelledByDialog ? new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage,BluetoothEnablerListener.Status.CANCELLED_BY_DIALOG) : new BluetoothEnablerListener.BluetoothEnablerEvent(m_currentStage,BluetoothEnablerListener.Status.SKIPPED);
    nextStage(nextEvent);
  }
 else   if (m_lastPlease.m_stateCode == BluetoothEnablerListener.Please.END) {
  }
}"
93953,"private void startNativeScan_postLollipop(){
  final BleScanMode scanMode_abstracted=getManager().m_config.scanMode;
  final int scanMode;
  if (scanMode_abstracted == null || scanMode_abstracted == BleScanMode.AUTO) {
    if (getManager().isForegrounded()) {
      if (m_isPoll || m_scanTime == Double.POSITIVE_INFINITY) {
        scanMode=ScanSettings.SCAN_MODE_BALANCED;
      }
 else {
        scanMode=ScanSettings.SCAN_MODE_LOW_LATENCY;
      }
    }
 else {
      scanMode=ScanSettings.SCAN_MODE_LOW_POWER;
    }
  }
 else {
    scanMode=scanMode_abstracted.getNativeMode();
  }
  if (false == Utils.isLollipop()) {
    getManager().ASSERT(false,""String_Node_Str"");
  }
 else {
    final ScanSettings.Builder builder=new ScanSettings.Builder();
    builder.setScanMode(scanMode);
    if (getManager().getNativeAdapter().isOffloadedScanBatchingSupported()) {
      final Interval scanReportDelay=getManager().m_config.scanReportDelay;
      final long scanReportDelay_millis=false == Interval.isDisabled(scanReportDelay) ? scanReportDelay.millis() : 0;
      builder.setReportDelay(scanReportDelay_millis);
    }
 else {
      builder.setReportDelay(0);
    }
    if (Utils.isMarshmallow()) {
      builder.setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES);
      builder.setMatchMode(ScanSettings.MATCH_MODE_AGGRESSIVE);
      builder.setNumOfMatches(ScanSettings.MATCH_NUM_MAX_ADVERTISEMENT);
    }
    final ScanSettings scanSettings=builder.build();
    getManager().getNativeAdapter().getBluetoothLeScanner().startScan(null,scanSettings,m_scanCallback_postLollipop);
  }
}","private void startNativeScan_postLollipop(){
  final BleScanMode scanMode_abstracted=getManager().m_config.scanMode;
  final int scanMode;
  if (scanMode_abstracted == null || scanMode_abstracted == BleScanMode.AUTO) {
    if (getManager().isForegrounded()) {
      if (m_isPoll || m_scanTime == Double.POSITIVE_INFINITY) {
        scanMode=ScanSettings.SCAN_MODE_BALANCED;
      }
 else {
        scanMode=ScanSettings.SCAN_MODE_LOW_LATENCY;
      }
    }
 else {
      scanMode=ScanSettings.SCAN_MODE_LOW_POWER;
    }
  }
 else {
    scanMode=scanMode_abstracted.getNativeMode();
  }
  if (false == Utils.isLollipop()) {
    getManager().ASSERT(false,""String_Node_Str"");
    fail();
  }
 else {
    final ScanSettings.Builder builder=new ScanSettings.Builder();
    builder.setScanMode(scanMode);
    if (getManager().getNativeAdapter().isOffloadedScanBatchingSupported()) {
      final Interval scanReportDelay=getManager().m_config.scanReportDelay;
      final long scanReportDelay_millis=false == Interval.isDisabled(scanReportDelay) ? scanReportDelay.millis() : 0;
      builder.setReportDelay(scanReportDelay_millis);
    }
 else {
      builder.setReportDelay(0);
    }
    if (Utils.isMarshmallow()) {
      builder.setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES);
      builder.setMatchMode(ScanSettings.MATCH_MODE_AGGRESSIVE);
      builder.setNumOfMatches(ScanSettings.MATCH_NUM_MAX_ADVERTISEMENT);
    }
    final ScanSettings scanSettings=builder.build();
    getManager().getNativeAdapter().getBluetoothLeScanner().startScan(null,scanSettings,m_scanCallback_postLollipop);
  }
}"
93954,"private Part_Function function(final String function,final HistoricalDataColumn column){
  if (!m_query.m_select.isEmpty()) {
    m_query.m_select+=""String_Node_Str"";
  }
  m_query.m_select+=""String_Node_Str"" + function + ""String_Node_Str""+ column.getColumnName()+ ""String_Node_Str"";
  return new Part_Function(m_query);
}","private Part_Function function(final String function,final HistoricalDataColumn column){
  if (!m_query.m_select.isEmpty()) {
    m_query.m_select+=""String_Node_Str"";
  }
  m_query.m_select+=""String_Node_Str"" + function + ""String_Node_Str"";
  return new Part_Function(m_query);
}"
93955,"public static byte[] subBytes(byte[] source,int sourceBegin,int sourceEnd){
  byte[] destination=new byte[sourceEnd - sourceBegin];
  System.arraycopy(source,sourceBegin,destination,0,sourceEnd - sourceBegin);
  return destination;
}","public static byte[] subBytes(final byte[] source,final int sourceBegin){
  return subBytes(source,sourceBegin,source.length - 1);
}"
93956,"public static String normalizeDeviceName(String deviceName){
  if (deviceName == null || deviceName.length() == 0)   return ""String_Node_Str"";
  String[] nameParts=deviceName.split(""String_Node_Str"");
  String consistentName=nameParts[0];
  consistentName=consistentName.toLowerCase();
  consistentName=consistentName.replace(""String_Node_Str"",""String_Node_Str"");
  return consistentName;
}","public static String normalizeDeviceName(String deviceName){
  if (deviceName == null || deviceName.length() == 0)   return ""String_Node_Str"";
  String[] nameParts=deviceName.split(""String_Node_Str"");
  String consistentName=nameParts[0];
  consistentName=consistentName.toLowerCase();
  consistentName=consistentName.trim();
  consistentName=consistentName.replace(""String_Node_Str"",""String_Node_Str"");
  return consistentName;
}"
93957,"@Override public Please onEvent(BluetoothEnablerEvent e){
  if (e.nextStage() == Stage.BLUETOOTH) {
    return Please.doNext().withImplicitActivityResultHandling();
  }
 else   if (e.nextStage() == Stage.LOCATION_PERMISSION) {
    if (e.status() == Status.ALREADY_ENABLED || e.status() == Status.ENABLED) {
      if (!m_bleMngr.isLocationEnabledForScanning_byRuntimePermissions() && !m_bleMngr.isLocationEnabledForScanning_byOsServices()) {
        return Please.doNext().withImplicitActivityResultHandling().withDialog(""String_Node_Str"");
      }
 else       if (!m_bleMngr.isLocationEnabledForScanning_byRuntimePermissions()) {
        return Please.doNext().withImplicitActivityResultHandling().withDialog(""String_Node_Str"");
      }
 else       if (!m_bleMngr.isLocationEnabledForScanning_byOsServices()) {
        return Please.doNext().withImplicitActivityResultHandling().withDialog(""String_Node_Str"");
      }
 else {
        return Please.stop();
      }
    }
 else     if (e.status() == Status.CANCELLED_BY_DIALOG || e.status() == Status.CANCELLED_BY_INTENT) {
      return Please.stop();
    }
  }
 else   if (e.nextStage() == Stage.LOCATION_SERVICES && e.stage() != Stage.LOCATION_SERVICES) {
    if (e.status() == Status.ALREADY_ENABLED || e.status() == Status.ENABLED) {
      return Please.doNext().withImplicitActivityResultHandling();
    }
 else     if (e.status() == Status.CANCELLED_BY_DIALOG || e.status() == Status.CANCELLED_BY_INTENT) {
      return Please.stop();
    }
  }
 else   if (e.stage() == Stage.LOCATION_SERVICES) {
    return Please.stop();
  }
  return Please.doNext();
}","@Override public Please onEvent(BluetoothEnablerEvent e){
  if (e.nextStage() == Stage.BLUETOOTH) {
    return Please.doNext().withImplicitActivityResultHandling();
  }
 else   if (e.nextStage() == Stage.LOCATION_PERMISSION) {
    if (e.status() == Status.ALREADY_ENABLED || e.status() == Status.ENABLED) {
      if (!e.isEnabled(Stage.LOCATION_SERVICES) && !e.isEnabled(Stage.LOCATION_PERMISSION)) {
        return Please.doNext().withImplicitActivityResultHandling().withDialog(""String_Node_Str"");
      }
 else       if (!e.isEnabled(Stage.LOCATION_PERMISSION)) {
        return Please.doNext().withImplicitActivityResultHandling().withDialog(""String_Node_Str"");
      }
 else       if (!e.isEnabled(Stage.LOCATION_SERVICES)) {
        return Please.doNext().withImplicitActivityResultHandling().withDialog(""String_Node_Str"");
      }
 else {
        return Please.stop();
      }
    }
 else     if (e.status() == Status.CANCELLED_BY_DIALOG || e.status() == Status.CANCELLED_BY_INTENT) {
      return Please.stop();
    }
  }
 else   if (e.nextStage() == Stage.LOCATION_SERVICES && e.stage() != Stage.LOCATION_SERVICES) {
    if (e.status() == Status.ALREADY_ENABLED || e.status() == Status.ENABLED) {
      return Please.doNext().withImplicitActivityResultHandling();
    }
 else     if (e.status() == Status.CANCELLED_BY_DIALOG || e.status() == Status.CANCELLED_BY_INTENT) {
      return Please.stop();
    }
  }
 else   if (e.stage() == Stage.LOCATION_SERVICES) {
    return Please.stop();
  }
  return Please.doNext();
}"
93958,"/** 
 * Returns the cached data from the lastest successful read or notify received for a given uuid. Basically if you receive a   {@link ReadWriteListener.ReadWriteEvent} for which {@link ReadWriteListener.ReadWriteEvent#isRead()}and   {@link ReadWriteListener.ReadWriteEvent#wasSuccess()} both return <code>true</code> then {@link ReadWriteListener.ReadWriteEvent#data()}, will be cached and is retrievable by this method.
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.DefaultHistoricalDataLogFilter
 * @return The cached value from a previous read or notify, or {@link HistoricalData#NULL} otherwise.
 */
@com.idevicesinc.sweetblue.annotations.Advanced public @Nullable(Nullable.Prevalence.NEVER) HistoricalData getHistoricalData_latest(final UUID uuid){
  return getHistoricalData_atOffset(uuid,getHistoricalDataCount(uuid) - 1);
}","/** 
 * Returns the cached data from the lastest successful read or notify received for a given uuid. Basically if you receive a   {@link ReadWriteListener.ReadWriteEvent} for which {@link ReadWriteListener.ReadWriteEvent#isRead()}and   {@link ReadWriteListener.ReadWriteEvent#wasSuccess()} both return <code>true</code> then {@link ReadWriteListener.ReadWriteEvent#data()}, will be cached and is retrievable by this method.
 * @see BleNodeConfig.HistoricalDataLogFilter
 * @see BleNodeConfig.DefaultHistoricalDataLogFilter
 * @return The cached value from a previous read or notify, or {@link HistoricalData#NULL} otherwise.
 */
@com.idevicesinc.sweetblue.annotations.Advanced public @Nullable(Nullable.Prevalence.NEVER) HistoricalData getHistoricalData_latest(final UUID uuid){
  return getHistoricalData_atOffset(uuid,getHistoricalDataCount(uuid) - 1);
}"
93959,"/** 
 * Returns the   {@link BleDeviceConfig.HistoricalDataLogFilter.Source} equivalentfor this  {@link BleDevice.ReadWriteListener.Type}, or   {@link BleDeviceConfig.HistoricalDataLogFilter.Source#NULL}.
 */
public BleDeviceConfig.HistoricalDataLogFilter.Source toHistoricalDataSource(){
switch (this) {
case READ:
    return BleDeviceConfig.HistoricalDataLogFilter.Source.READ;
case POLL:
  return BleDeviceConfig.HistoricalDataLogFilter.Source.POLL;
case NOTIFICATION:
return BleDeviceConfig.HistoricalDataLogFilter.Source.NOTIFICATION;
case INDICATION:
return BleDeviceConfig.HistoricalDataLogFilter.Source.INDICATION;
case PSUEDO_NOTIFICATION:
return BleDeviceConfig.HistoricalDataLogFilter.Source.PSUEDO_NOTIFICATION;
}
return BleDeviceConfig.HistoricalDataLogFilter.Source.NULL;
}","/** 
 * Returns the   {@link BleNodeConfig.HistoricalDataLogFilter.Source} equivalentfor this  {@link BleDevice.ReadWriteListener.Type}, or   {@link BleNodeConfig.HistoricalDataLogFilter.Source#NULL}.
 */
public BleNodeConfig.HistoricalDataLogFilter.Source toHistoricalDataSource(){
switch (this) {
case READ:
    return BleNodeConfig.HistoricalDataLogFilter.Source.READ;
case POLL:
  return BleNodeConfig.HistoricalDataLogFilter.Source.POLL;
case NOTIFICATION:
return BleNodeConfig.HistoricalDataLogFilter.Source.NOTIFICATION;
case INDICATION:
return BleNodeConfig.HistoricalDataLogFilter.Source.INDICATION;
case PSUEDO_NOTIFICATION:
return BleNodeConfig.HistoricalDataLogFilter.Source.PSUEDO_NOTIFICATION;
}
return BleNodeConfig.HistoricalDataLogFilter.Source.NULL;
}"
93960,"/** 
 * Clears the first <code>count</code> number of   {@link com.idevicesinc.sweetblue.utils.HistoricalData} tracked by this device for a particularcharacteristic  {@link java.util.UUID} within the given range.
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public void clearHistoricalData_memoryOnly(final UUID characteristicUuid,final EpochTimeRange range,final long count){
  if (isNull())   return;
  m_historicalDataMngr.delete(characteristicUuid,range,count,true);
}","/** 
 * Clears the first <code>count</code> number of   {@link com.idevicesinc.sweetblue.utils.HistoricalData} tracked by this device for a particularcharacteristic  {@link java.util.UUID} within the given range.
 * @see com.idevicesinc.sweetblue.BleNodeConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleNodeConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public void clearHistoricalData_memoryOnly(final UUID characteristicUuid,final EpochTimeRange range,final long count){
  if (isNull())   return;
  m_historicalDataMngr.delete(characteristicUuid,range,count,true);
}"
93961,"/** 
 * Same as   {@link #getHistoricalData_atOffset(java.util.UUID,int)} but offset is relative to the time range provided.
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public @Nullable(Nullable.Prevalence.NEVER) HistoricalData getHistoricalData_atOffset(final UUID uuid,final EpochTimeRange range,final int offsetFromStart){
  if (isNull())   return HistoricalData.NULL;
  return m_historicalDataMngr.getWithOffset(uuid,EpochTimeRange.denull(range),offsetFromStart);
}","/** 
 * Same as   {@link #getHistoricalData_atOffset(java.util.UUID,int)} but offset is relative to the time range provided.
 * @see com.idevicesinc.sweetblue.BleNodeConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleNodeConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public @Nullable(Nullable.Prevalence.NEVER) HistoricalData getHistoricalData_atOffset(final UUID uuid,final EpochTimeRange range,final int offsetFromStart){
  if (isNull())   return HistoricalData.NULL;
  return m_historicalDataMngr.getWithOffset(uuid,EpochTimeRange.denull(range),offsetFromStart);
}"
93962,"/** 
 * Forwards   {@link com.idevicesinc.sweetblue.BleDevice.ConnectionFailListener.Status#shouldBeReportedToUser()}using   {@link #status()}.
 */
public boolean shouldBeReportedToUser(){
  return status().shouldBeReportedToUser();
}","/** 
 * Forwards   {@link BleDevice.ConnectionFailListener.Status#shouldBeReportedToUser()} using {@link #status()}.
 */
public boolean shouldBeReportedToUser(){
  return status().shouldBeReportedToUser();
}"
93963,"/** 
 * Returns an iterator that will iterate through all   {@link HistoricalData} entries within the range provided.
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public @Nullable(Nullable.Prevalence.NEVER) Iterator<HistoricalData> getHistoricalData_iterator(final UUID uuid,final EpochTimeRange range){
  if (isNull())   return new EmptyIterator<HistoricalData>();
  return m_historicalDataMngr.getIterator(uuid,EpochTimeRange.denull(range));
}","/** 
 * Returns an iterator that will iterate through all   {@link HistoricalData} entries within the range provided.
 * @see com.idevicesinc.sweetblue.BleNodeConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleNodeConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public @Nullable(Nullable.Prevalence.NEVER) Iterator<HistoricalData> getHistoricalData_iterator(final UUID uuid,final EpochTimeRange range){
  if (isNull())   return new EmptyIterator<HistoricalData>();
  return m_historicalDataMngr.getIterator(uuid,EpochTimeRange.denull(range));
}"
93964,"/** 
 * Sets a default backup   {@link com.idevicesinc.sweetblue.BleDevice.HistoricalDataLoadListener} that will be invokedfor all historical data loads to memory for all uuids.
 */
public void setListener_HistoricalDataLoad(@Nullable(Prevalence.NORMAL) final HistoricalDataLoadListener listener_nullable){
  if (isNull())   return;
  m_historicalDataMngr.setListener(listener_nullable);
}","/** 
 * Sets a default backup   {@link BleNode.HistoricalDataLoadListener} that will be invokedfor all historical data loads to memory for all uuids.
 */
public void setListener_HistoricalDataLoad(@Nullable(Prevalence.NORMAL) final BleNode.HistoricalDataLoadListener listener_nullable){
  if (isNull())   return;
  m_historicalDataMngr.setListener(listener_nullable);
}"
93965,"/** 
 * Clears the first <code>count</code> number of   {@link com.idevicesinc.sweetblue.utils.HistoricalData} tracked by this device for a particularcharacteristic  {@link java.util.UUID} within the given range.
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public void clearHistoricalData(final UUID uuid,final EpochTimeRange range,final long count){
  if (isNull())   return;
  m_historicalDataMngr.delete(uuid,range,count,false);
}","/** 
 * Clears the first <code>count</code> number of   {@link com.idevicesinc.sweetblue.utils.HistoricalData} tracked by this device for a particularcharacteristic  {@link java.util.UUID} within the given range.
 * @see com.idevicesinc.sweetblue.BleNodeConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleNodeConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public void clearHistoricalData(final UUID uuid,final EpochTimeRange range,final long count){
  if (isNull())   return;
  m_historicalDataMngr.delete(uuid,range,count,false);
}"
93966,"/** 
 * Provides all historical data through the ""for each"" provided within the range provided.
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.DefaultHistoricalDataLogFilter
 * @return <code>true</code> if there are any entries, <code>false</code> otherwise.
 */
@com.idevicesinc.sweetblue.annotations.Advanced public boolean getHistoricalData_forEach(final UUID uuid,final EpochTimeRange range,final ForEach_Breakable<HistoricalData> forEach){
  if (isNull())   return false;
  return m_historicalDataMngr.doForEach(uuid,EpochTimeRange.denull(range),forEach);
}","/** 
 * Provides all historical data through the ""for each"" provided within the range provided.
 * @see com.idevicesinc.sweetblue.BleNodeConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleNodeConfig.DefaultHistoricalDataLogFilter
 * @return <code>true</code> if there are any entries, <code>false</code> otherwise.
 */
@com.idevicesinc.sweetblue.annotations.Advanced public boolean getHistoricalData_forEach(final UUID uuid,final EpochTimeRange range,final ForEach_Breakable<HistoricalData> forEach){
  if (isNull())   return false;
  return m_historicalDataMngr.doForEach(uuid,EpochTimeRange.denull(range),forEach);
}"
93967,"/** 
 * Whether this reason honors a   {@link Please#isRetry()}. Returns <code>false</code> if   {@link #wasCancelled()} or<code>this</code> is  {@link #ALREADY_CONNECTING_OR_CONNECTED}.
 */
public boolean allowsRetry(){
  return !this.wasCancelled() && this != ALREADY_CONNECTING_OR_CONNECTED;
}","/** 
 * Whether this status honors a   {@link BleNode.ConnectionFailListener.Please#isRetry()}. Returns <code>false</code> if   {@link #wasCancelled()} or<code>this</code> is  {@link #ALREADY_CONNECTING_OR_CONNECTED}.
 */
public boolean allowsRetry(){
  return !this.wasCancelled() && this != ALREADY_CONNECTING_OR_CONNECTED;
}"
93968,"/** 
 * Returns the number of historical data entries that have been logged for the device's given characteristic within the range provided.
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public int getHistoricalDataCount(final UUID uuid,final EpochTimeRange range){
  if (isNull())   return 0;
  return m_historicalDataMngr.getCount(uuid,EpochTimeRange.denull(range));
}","/** 
 * Returns the number of historical data entries that have been logged for the device's given characteristic within the range provided.
 * @see com.idevicesinc.sweetblue.BleNodeConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleNodeConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public int getHistoricalDataCount(final UUID uuid,final EpochTimeRange range){
  if (isNull())   return 0;
  return m_historicalDataMngr.getCount(uuid,EpochTimeRange.denull(range));
}"
93969,"/** 
 * Returns <code>true</code> if there is any historical data for the given uuid within the given range.
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public boolean hasHistoricalData(final UUID uuid,final EpochTimeRange range){
  if (isNull())   return false;
  return m_historicalDataMngr.hasHistoricalData(uuid,range);
}","/** 
 * Returns <code>true</code> if there is any historical data for the given uuid within the given range.
 * @see com.idevicesinc.sweetblue.BleNodeConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleNodeConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public boolean hasHistoricalData(final UUID uuid,final EpochTimeRange range){
  if (isNull())   return false;
  return m_historicalDataMngr.hasHistoricalData(uuid,range);
}"
93970,"/** 
 * Same as   {@link #addHistoricalData(UUID,byte[],EpochTime)} but for large datasets this is more efficient when writing to disk.
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleDeviceConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public void addHistoricalData(final UUID uuid,final ForEach_Returning<HistoricalData> historicalData){
  if (isNull())   return;
  m_historicalDataMngr.add_multiple(uuid,historicalData);
}","/** 
 * Same as   {@link #addHistoricalData(UUID,byte[],EpochTime)} but for large datasets this is more efficient when writing to disk.
 * @see com.idevicesinc.sweetblue.BleNodeConfig.HistoricalDataLogFilter
 * @see com.idevicesinc.sweetblue.BleNodeConfig.DefaultHistoricalDataLogFilter
 */
@com.idevicesinc.sweetblue.annotations.Advanced public void addHistoricalData(final UUID uuid,final ForEach_Returning<HistoricalData> historicalData){
  if (isNull())   return;
  m_historicalDataMngr.add_multiple(uuid,historicalData);
}"
93971,"/** 
 * Returns <code>true</code> if the historical data for a given uuid is loaded into memory. Use   {@link com.idevicesinc.sweetblue.BleDevice.HistoricalDataLoadListener}to listen for when the load actually completes. If   {@link #hasHistoricalData(UUID)}returns <code>false</code> then this will also always return <code>false</code>.
 */
@com.idevicesinc.sweetblue.annotations.Advanced public boolean isHistoricalDataLoaded(final UUID uuid){
  return m_historicalDataMngr.isLoaded(uuid);
}","/** 
 * Returns <code>true</code> if the historical data for a given uuid is loaded into memory. Use   {@link BleNode.HistoricalDataLoadListener}to listen for when the load actually completes. If   {@link #hasHistoricalData(UUID)}returns <code>false</code> then this will also always return <code>false</code>.
 */
@com.idevicesinc.sweetblue.annotations.Advanced public boolean isHistoricalDataLoaded(final UUID uuid){
  return m_historicalDataMngr.isLoaded(uuid);
}"
93972,"void invokeReadWriteCallback(final ReadWriteListener listener_nullable,final ReadWriteListener.ReadWriteEvent event){
  if (event.wasSuccess() && event.isRead() && event.target() == ReadWriteListener.Target.CHARACTERISTIC) {
    final EpochTime timestamp=new EpochTime();
    final BleDeviceConfig.HistoricalDataLogFilter.Source source=event.type().toHistoricalDataSource();
    m_historicalDataMngr.add_single(event.charUuid(),event.data(),timestamp,source);
  }
  m_txnMngr.onReadWriteResult(event);
  if (listener_nullable != null) {
    listener_nullable.onEvent(event);
  }
  if (m_defaultReadWriteListener != null) {
    m_defaultReadWriteListener.onEvent(event);
  }
  if (getManager() != null && getManager().m_defaultReadWriteListener != null) {
    getManager().m_defaultReadWriteListener.onEvent(event);
  }
  m_txnMngr.onReadWriteResultCallbacksCalled();
}","void invokeReadWriteCallback(final ReadWriteListener listener_nullable,final ReadWriteListener.ReadWriteEvent event){
  if (event.wasSuccess() && event.isRead() && event.target() == ReadWriteListener.Target.CHARACTERISTIC) {
    final EpochTime timestamp=new EpochTime();
    final BleNodeConfig.HistoricalDataLogFilter.Source source=event.type().toHistoricalDataSource();
    m_historicalDataMngr.add_single(event.charUuid(),event.data(),timestamp,source);
  }
  m_txnMngr.onReadWriteResult(event);
  if (listener_nullable != null) {
    listener_nullable.onEvent(event);
  }
  if (m_defaultReadWriteListener != null) {
    m_defaultReadWriteListener.onEvent(event);
  }
  if (getManager() != null && getManager().m_defaultReadWriteListener != null) {
    getManager().m_defaultReadWriteListener.onEvent(event);
  }
  m_txnMngr.onReadWriteResultCallbacksCalled();
}"
93973,"/** 
 * Returns the discovery listener set with   {@link #setListener_Discovery(com.idevicesinc.sweetblue.BleManager.DiscoveryListener)} or{@link BleManagerConfig#defaultDiscoveryListener}, or <code>null</code> if not set.
 */
public DiscoveryListener getListener_Discovery(){
  return m_discoveryListener;
}","/** 
 * Returns the discovery listener set with   {@link #setListener_Discovery(BleManager.DiscoveryListener)} or{@link BleManagerConfig#defaultDiscoveryListener}, or <code>null</code> if not set.
 */
public DiscoveryListener getListener_Discovery(){
  return m_discoveryListener;
}"
93974,"/** 
 * Sets a default backup   {@link com.idevicesinc.sweetblue.BleDevice.HistoricalDataLoadListener} that will be invokedfor all historical data loads to memory for all uuids for all devices.
 */
public void setListener_HistoricalDataLoad(@Nullable(Prevalence.NORMAL) final BleDevice.HistoricalDataLoadListener listener_nullable){
  m_historicalDataLoadListener=listener_nullable;
}","/** 
 * Sets a default backup   {@link BleNode.HistoricalDataLoadListener} that will be invokedfor all historical data loads to memory for all uuids for all devices.
 */
public void setListener_HistoricalDataLoad(@Nullable(Prevalence.NORMAL) final BleNode.HistoricalDataLoadListener listener_nullable){
  m_historicalDataLoadListener=listener_nullable;
}"
93975,"/** 
 * See explanation at   {@link BleDevice#getLastDisconnectIntent()}. <br><br> TIP: If   {@link ScanEvent#lastDisconnectIntent} isn't {@link State.ChangeIntent#NULL} then most likely you can early-outand return <code>true</code> from  {@link ScanFilter#onEvent(ScanEvent)} without having to checkuuids or names matching, because obviously you've seen and connected to this device before.
 */
public State.ChangeIntent lastDisconnectIntent(){
  return m_lastDisconnectIntent;
}","/** 
 * See explanation at   {@link BleDevice#getLastDisconnectIntent()}. <br><br> TIP: If   {@link ScanEvent#lastDisconnectIntent} isn't {@link com.idevicesinc.sweetblue.utils.State.ChangeIntent#NULL} then most likely you can early-outand return <code>true</code> from  {@link ScanFilter#onEvent(ScanEvent)} without having to checkuuids or names matching, because obviously you've seen and connected to this device before.
 */
public State.ChangeIntent lastDisconnectIntent(){
  return m_lastDisconnectIntent;
}"
93976,"/** 
 * Acknowledges the discovery if there's an overlap between the given advertisedServices and the   {@link Collection} passed into {@link BleManagerConfig.DefaultScanFilter#DefaultScanFilter(Collection)}.
 */
@Override public Please onEvent(ScanEvent e){
  return Please.acknowledgeIf(Utils.haveMatchingIds(e.advertisedServices(),m_whitelist));
}","/** 
 * Acknowledges the discovery if there's an overlap between the given advertisedServices and the   {@link Collection} passed into the constructor of {@link BleManagerConfig.DefaultScanFilter}.
 */
@Override public Please onEvent(ScanEvent e){
  return Please.acknowledgeIf(Utils.haveMatchingIds(e.advertisedServices(),m_whitelist));
}"
93977,"/** 
 * Return this from   {@link ReconnectFilter#onEvent(ReconnectFilter.ReconnectEvent)} to retry after the given amount of time.
 */
public static Please retryIn(Interval interval){
  return new Please(interval != null ? interval : SHOULD_TRY_AGAIN__INSTANTLY);
}","/** 
 * Return this from   {@link BleNodeConfig.ReconnectFilter#onEvent(BleNodeConfig.ReconnectFilter.ReconnectEvent)} to retry after the given amount of time.
 */
public static Please retryIn(Interval interval){
  return new Please(interval != null ? interval : SHOULD_TRY_AGAIN__INSTANTLY);
}"
93978,"/** 
 * Return this from   {@link ReconnectFilter#onEvent(ReconnectFilter.ReconnectEvent)} to stop a reconnect attempt loop.Note that  {@link BleDevice#disconnect()} {@link BleServer#disconnect(String)} will also stop any ongoing reconnect loops.
 */
public static Please stopRetrying(){
  return SHOULD_CONTINUE__STOP;
}","/** 
 * Return this from   {@link BleNodeConfig.ReconnectFilter#onEvent(BleNodeConfig.ReconnectFilter.ReconnectEvent)} to stop a reconnect attempt loop.Note that  {@link BleDevice#disconnect()} {@link BleServer#disconnect(String)} will also stop any ongoing reconnect loops.
 */
public static Please stopRetrying(){
  return SHOULD_CONTINUE__STOP;
}"
93979,"/** 
 * When   {@link ReconnectEvent#type()} is either {@link Type#SHORT_TERM__SHOULD_TRY_AGAIN} or {@link Type#LONG_TERM__SHOULD_TRY_AGAIN}, return this from   {@link ReconnectFilter#onEvent(ReconnectFilter.ReconnectEvent)} to instantly reconnect.
 */
public static Please retryInstantly(){
  return new Please(SHOULD_TRY_AGAIN__INSTANTLY);
}","/** 
 * When   {@link BleNodeConfig.ReconnectFilter.ReconnectEvent#type()} is either {@link Type#SHORT_TERM__SHOULD_TRY_AGAIN} or {@link Type#LONG_TERM__SHOULD_TRY_AGAIN}, return this from   {@link BleNodeConfig.ReconnectFilter#onEvent(BleNodeConfig.ReconnectFilter.ReconnectEvent)} to instantly reconnect.
 */
public static Please retryInstantly(){
  return new Please(SHOULD_TRY_AGAIN__INSTANTLY);
}"
93980,"/** 
 * The previous   {@link Interval} returned through {@link com.idevicesinc.sweetblue.BleNodeConfig.ReconnectFilter.Please#retryIn(Interval)}, or   {@link Interval#ZERO} for the first invocation.
 */
public Interval previousDelay(){
  return m_previousDelay;
}","/** 
 * The previous   {@link Interval} returned through {@link BleNodeConfig.ReconnectFilter.Please#retryIn(Interval)}, or   {@link Interval#ZERO} for the first invocation.
 */
public Interval previousDelay(){
  return m_previousDelay;
}"
93981,"static double getTimeout(final TaskTimeoutRequestFilter.TimeoutRequestEvent event){
  final BleManager manager=event.manager();
  final BleDevice device_nullable=!event.device().isNull() ? event.device() : null;
  final BleServer server_nullable=!event.server().isNull() ? event.server() : null;
  final TaskTimeoutRequestFilter filter_specific;
  if (device_nullable != null) {
    filter_specific=device_nullable.conf_device().taskTimeoutRequestFilter;
  }
 else   if (server_nullable != null) {
    filter_specific=server_nullable.conf_endpoint().taskTimeoutRequestFilter;
  }
 else {
    filter_specific=null;
  }
  final TaskTimeoutRequestFilter filter_mngr=manager.m_config.taskTimeoutRequestFilter;
  final TaskTimeoutRequestFilter filter=filter_specific != null ? filter_specific : filter_mngr;
  final TaskTimeoutRequestFilter.Please please=filter != null ? filter.onEvent(event) : null;
  final Interval timeout=please != null ? please.m_interval : Interval.DISABLED;
  final double toReturn=timeout != null ? timeout.secs() : Interval.DISABLED.secs();
  event.device().getManager().getLogger().checkPlease(please,TaskTimeoutRequestFilter.Please.class);
  return toReturn;
}","static double getTimeout(final TaskTimeoutRequestFilter.TaskTimeoutRequestEvent event){
  final BleManager manager=event.manager();
  final BleDevice device_nullable=!event.device().isNull() ? event.device() : null;
  final BleServer server_nullable=!event.server().isNull() ? event.server() : null;
  final TaskTimeoutRequestFilter filter_specific;
  if (device_nullable != null) {
    filter_specific=device_nullable.conf_device().taskTimeoutRequestFilter;
  }
 else   if (server_nullable != null) {
    filter_specific=server_nullable.conf_endpoint().taskTimeoutRequestFilter;
  }
 else {
    filter_specific=null;
  }
  final TaskTimeoutRequestFilter filter_mngr=manager.m_config.taskTimeoutRequestFilter;
  final TaskTimeoutRequestFilter filter=filter_specific != null ? filter_specific : filter_mngr;
  final TaskTimeoutRequestFilter.Please please=filter != null ? filter.onEvent(event) : null;
  final Interval timeout=please != null ? please.m_interval : Interval.DISABLED;
  final double toReturn=timeout != null ? timeout.secs() : Interval.DISABLED.secs();
  event.device().getManager().getLogger().checkPlease(please,TaskTimeoutRequestFilter.Please.class);
  return toReturn;
}"
93982,"/** 
 * Whether this reason honors a   {@link BleServer.ConnectionFailListener.Please#isRetry()}. Returns <code>false</code> if   {@link #wasCancelled()} or<code>this</code> is  {@link #ALREADY_CONNECTING_OR_CONNECTED}.
 */
public boolean allowsRetry(){
  return !this.wasCancelled() && this != ALREADY_CONNECTING_OR_CONNECTED;
}","/** 
 * Whether this reason honors a   {@link BleNode.ConnectionFailListener.Please#isRetry()}. Returns <code>false</code> if   {@link #wasCancelled()} or<code>this</code> is  {@link #ALREADY_CONNECTING_OR_CONNECTED}.
 */
public boolean allowsRetry(){
  return !this.wasCancelled() && this != ALREADY_CONNECTING_OR_CONNECTED;
}"
93983,"/** 
 * For each old->new bit difference, this mask will tell you if the transition was intentional. ""Intentional"" generally means a call was made to a public method of the library from app-code to trigger the state change, and so usually the stacktrace started from a user input event upstream. Otherwise the given bit will be 0x0 and so the state change was ""unintentional"". An example of intentional is if you call  {@link BleDevice#disconnect()} in response to a button click, whereas unintentional would be if the device disconnected because itwent out of range. As much as possible these flags are meant to represent the actual app <i>user's</i> intent through the app, not the intent of you the programmer, nor the intent of the user outside the bounds of the app, like disconnecting by turning the peripheral off. For example after a disconnect you might be using  {@link BleManagerConfig#reconnectRequestFilter_longTerm} to try periodicallyreconnecting. From you the programmer's perspective a connect, if/when it happens, is arguably an intentional action. From the user's perspective however the connect was unintentional. Therefore this mask is currently meant to serve an analytics or debugging role, not to necessarily gate application logic.
 */
public int intentMask(){
  return m_intentMask;
}","/** 
 * For each old->new bit difference, this mask will tell you if the transition was intentional. ""Intentional"" generally means a call was made to a public method of the library from app-code to trigger the state change, and so usually the stacktrace started from a user input event upstream. Otherwise the given bit will be 0x0 and so the state change was ""unintentional"". An example of intentional is if you call  {@link BleDevice#disconnect()} in response to a button click, whereas unintentional would be if the device disconnected because itwent out of range. As much as possible these flags are meant to represent the actual app <i>user's</i> intent through the app, not the intent of you the programmer, nor the intent of the user outside the bounds of the app, like disconnecting by turning the peripheral off. For example after a disconnect you might be using  {@link BleManagerConfig#reconnectFilter} to try periodicallyreconnecting. From you the programmer's perspective a connect, if/when it happens, is arguably an intentional action. From the user's perspective however the connect was unintentional. Therefore this mask is currently meant to serve an analytics or debugging role, not to necessarily gate application logic.
 */
public int intentMask(){
  return m_intentMask;
}"
93984,"/** 
 * Returns the device's name and current state for logging and debugging purposes.
 */
@Override public String toString(){
  if (isNull()) {
    return NULL_STRING();
  }
 else {
    return getName_debug() + ""String_Node_Str"" + stateTracker_main().toString();
  }
}","/** 
 * Returns the device's name and current state for logging and debugging purposes.
 */
@Override public String toString(){
  if (isNull()) {
    return NULL_STRING();
  }
 else {
    return m_nativeWrapper.getDebugName() + ""String_Node_Str"" + stateTracker_main().toString();
  }
}"
93985,"/** 
 * Pretty-prints the list of connecting or connected clients.
 */
public String toString(){
  return this.getClass().getSimpleName() + ""String_Node_Str"" + getClientCount(CONNECTING,CONNECTED)+ ""String_Node_Str"";
}","/** 
 * Pretty-prints the list of connecting or connected clients.
 */
public String toString(){
  return this.getClass().getSimpleName() + ""String_Node_Str"" + m_clientMngr.getClientCount(BleServerState.toBits(CONNECTING,CONNECTED))+ ""String_Node_Str"";
}"
93986,"void update_internal(double timeStep){
synchronized (this) {
    m_totalTimeArmedAndExecuting+=timeStep;
    m_updateCount++;
    if (m_totalTimeArmedAndExecuting >= m_executionDelay) {
      if (m_state == PE_TaskState.ARMED) {
        if (m_updateCount > 1) {
          if (m_softlyCancelled) {
            softlyCancel();
            return;
          }
          if (isExecutable()) {
            setState(PE_TaskState.EXECUTING);
            if (executeOnSeperateThread()) {
              m_executeHandler.post(m_executeRunnable);
            }
 else {
              execute_wrapper();
            }
            return;
          }
 else {
            failWithoutRetry();
            return;
          }
        }
      }
 else       if (m_state == PE_TaskState.EXECUTING) {
        if (!Interval.isDisabled(m_timeout) && m_timeout != Interval.INFINITE.secs()) {
          double timeExecuting=(System.currentTimeMillis() - m_resetableExecuteStartTime) / 1000.0;
          if (timeExecuting >= m_timeout) {
            timeout();
            return;
          }
        }
      }
    }
    this.update(timeStep);
  }
}","void update_internal(double timeStep){
synchronized (this) {
    m_totalTimeArmedAndExecuting+=timeStep;
    m_updateCount++;
    if (m_totalTimeArmedAndExecuting >= m_executionDelay) {
      if (m_state == PE_TaskState.ARMED) {
        if (m_updateCount > 1) {
          if (m_softlyCancelled) {
            softlyCancel();
            return;
          }
          if (isExecutable()) {
            setState(PE_TaskState.EXECUTING);
            if (executeOnSeperateThread()) {
              m_executeHandler.post(m_executeRunnable);
            }
 else {
              execute_wrapper();
            }
            return;
          }
 else {
            onNotExecutable();
            return;
          }
        }
      }
 else       if (m_state == PE_TaskState.EXECUTING) {
        if (!Interval.isDisabled(m_timeout) && m_timeout != Interval.INFINITE.secs()) {
          double timeExecuting=(System.currentTimeMillis() - m_resetableExecuteStartTime) / 1000.0;
          if (timeExecuting >= m_timeout) {
            timeout();
            return;
          }
        }
      }
    }
    this.update(timeStep);
  }
}"
93987,"protected void fail(Status status,int gattStatus,Target target,UUID charUuid,UUID descUuid){
  getDevice().invokeReadWriteCallback(m_readWriteListener,newReadWriteEvent(status,gattStatus,target,getServiceUuid(),charUuid,descUuid));
  this.fail();
}","protected void fail(Status status,int gattStatus,Target target,UUID charUuid,UUID descUuid){
  this.fail();
  getDevice().invokeReadWriteCallback(m_readWriteListener,newReadWriteEvent(status,gattStatus,target,getServiceUuid(),charUuid,descUuid));
}"
93988,"private void succeed(byte[] value,Target target){
  ReadWriteEvent result=newReadWriteEvent(value,target,getCharUuid(),ReadWriteEvent.NON_APPLICABLE_UUID);
  getDevice().addReadTime(result.time_total().secs());
  getDevice().invokeReadWriteCallback(m_readWriteListener,result);
  super.succeed();
}","private void succeed(byte[] value,Target target){
  super.succeed();
  final ReadWriteEvent event=newReadWriteEvent(value,target,getCharUuid(),ReadWriteEvent.NON_APPLICABLE_UUID);
  getDevice().addReadTime(event.time_total().secs());
  getDevice().invokeReadWriteCallback(m_readWriteListener,event);
}"
93989,"private void fail(Status status,int gattStatus){
  getDevice().invokeReadWriteCallback(m_readWriteListener,newEvent(status,gattStatus,0));
  this.fail();
}","private void fail(Status status,int gattStatus){
  this.fail();
  getDevice().invokeReadWriteCallback(m_readWriteListener,newEvent(status,gattStatus,0));
}"
93990,"private void succeed(int gattStatus,int rssi){
  ReadWriteEvent result=newEvent(Status.SUCCESS,gattStatus,rssi);
  getDevice().invokeReadWriteCallback(m_readWriteListener,result);
  super.succeed();
}","private void succeed(int gattStatus,int rssi){
  super.succeed();
  final ReadWriteEvent event=newEvent(Status.SUCCESS,gattStatus,rssi);
  getDevice().invokeReadWriteCallback(m_readWriteListener,event);
}"
93991,"@Override protected void fail(Status status,int gattStatus,Target target,UUID charUuid,UUID descUuid){
  if (m_enable) {
    getDevice().getPollManager().onNotifyStateChange(getServiceUuid(),charUuid,E_NotifyState.NOT_ENABLED);
  }
  super.fail(status,gattStatus,target,charUuid,descUuid);
}","@Override protected void fail(Status status,int gattStatus,Target target,UUID charUuid,UUID descUuid){
  super.fail(status,gattStatus,target,charUuid,descUuid);
  if (m_enable) {
    getDevice().getPollManager().onNotifyStateChange(getServiceUuid(),charUuid,E_NotifyState.NOT_ENABLED);
  }
}"
93992,"@Override protected void succeed(){
  ReadWriteEvent result=newReadWriteEvent(Status.SUCCESS,BluetoothGatt.GATT_SUCCESS,Target.DESCRIPTOR,getServiceUuid(),getCharUuid(),m_descUuid);
  if (m_enable) {
    getDevice().getPollManager().onNotifyStateChange(getServiceUuid(),getCharUuid(),E_NotifyState.ENABLED);
  }
 else {
    getDevice().getPollManager().onNotifyStateChange(getServiceUuid(),getCharUuid(),E_NotifyState.NOT_ENABLED);
  }
  getDevice().invokeReadWriteCallback(m_readWriteListener,result);
  super.succeed();
}","@Override protected void succeed(){
  if (m_enable) {
    getDevice().getPollManager().onNotifyStateChange(getServiceUuid(),getCharUuid(),E_NotifyState.ENABLED);
  }
 else {
    getDevice().getPollManager().onNotifyStateChange(getServiceUuid(),getCharUuid(),E_NotifyState.NOT_ENABLED);
  }
  super.succeed();
  final ReadWriteEvent event=newReadWriteEvent(Status.SUCCESS,BluetoothGatt.GATT_SUCCESS,Target.DESCRIPTOR,getServiceUuid(),getCharUuid(),m_descUuid);
  getDevice().invokeReadWriteCallback(m_readWriteListener,event);
}"
93993,"@Override public void execute(){
  super.execute();
  BluetoothGattCharacteristic char_native=getDevice().getNativeCharacteristic(getServiceUuid(),getCharUuid());
  if (char_native == null) {
    this.fail(Status.NO_MATCHING_TARGET,BleStatuses.GATT_STATUS_NOT_APPLICABLE,Target.CHARACTERISTIC,getCharUuid(),ReadWriteEvent.NON_APPLICABLE_UUID);
    return;
  }
  if (!getDevice().getNativeGatt().setCharacteristicNotification(char_native,m_enable)) {
    this.fail(Status.FAILED_TO_TOGGLE_NOTIFICATION,BleStatuses.GATT_STATUS_NOT_APPLICABLE,Target.CHARACTERISTIC,getCharUuid(),ReadWriteEvent.NON_APPLICABLE_UUID);
    return;
  }
  BluetoothGattDescriptor descriptor=char_native.getDescriptor(m_descUuid);
  if (descriptor == null) {
    succeed();
    return;
  }
  m_writeValue=getWriteValue(char_native,m_enable);
  if (!descriptor.setValue(getWriteValue())) {
    this.fail(Status.FAILED_TO_SET_VALUE_ON_TARGET,BleStatuses.GATT_STATUS_NOT_APPLICABLE,Target.DESCRIPTOR,getCharUuid(),m_descUuid);
    return;
  }
  if (!getDevice().getNativeGatt().writeDescriptor(descriptor)) {
    this.fail(Status.FAILED_TO_SEND_OUT,BleStatuses.GATT_STATUS_NOT_APPLICABLE,Target.DESCRIPTOR,getCharUuid(),m_descUuid);
    return;
  }
}","@Override public void execute(){
  super.execute();
  final BluetoothGattCharacteristic char_native=getDevice().getNativeCharacteristic(getServiceUuid(),getCharUuid());
  if (char_native == null) {
    this.fail(Status.NO_MATCHING_TARGET,BleStatuses.GATT_STATUS_NOT_APPLICABLE,Target.CHARACTERISTIC,getCharUuid(),ReadWriteEvent.NON_APPLICABLE_UUID);
    return;
  }
  if (!getDevice().getNativeGatt().setCharacteristicNotification(char_native,m_enable)) {
    this.fail(Status.FAILED_TO_TOGGLE_NOTIFICATION,BleStatuses.GATT_STATUS_NOT_APPLICABLE,Target.CHARACTERISTIC,getCharUuid(),ReadWriteEvent.NON_APPLICABLE_UUID);
    return;
  }
  final BluetoothGattDescriptor descriptor=char_native.getDescriptor(m_descUuid);
  if (descriptor == null) {
    succeed();
    return;
  }
  m_writeValue=getWriteValue(char_native,m_enable);
  if (!descriptor.setValue(getWriteValue())) {
    this.fail(Status.FAILED_TO_SET_VALUE_ON_TARGET,BleStatuses.GATT_STATUS_NOT_APPLICABLE,Target.DESCRIPTOR,getCharUuid(),m_descUuid);
    return;
  }
  if (!getDevice().getNativeGatt().writeDescriptor(descriptor)) {
    this.fail(Status.FAILED_TO_SEND_OUT,BleStatuses.GATT_STATUS_NOT_APPLICABLE,Target.DESCRIPTOR,getCharUuid(),m_descUuid);
    return;
  }
}"
93994,"@Override protected void succeed(){
  ReadWriteEvent result=newReadWriteEvent(Status.SUCCESS,BluetoothGatt.GATT_SUCCESS,getDefaultTarget(),getServiceUuid(),getCharUuid(),ReadWriteEvent.NON_APPLICABLE_UUID);
  getDevice().addWriteTime(result.time_total().secs());
  getDevice().invokeReadWriteCallback(m_readWriteListener,result);
  super.succeed();
}","@Override protected void succeed(){
  super.succeed();
  final ReadWriteEvent event=newReadWriteEvent(Status.SUCCESS,BluetoothGatt.GATT_SUCCESS,getDefaultTarget(),getServiceUuid(),getCharUuid(),ReadWriteEvent.NON_APPLICABLE_UUID);
  getDevice().addWriteTime(event.time_total().secs());
  getDevice().invokeReadWriteCallback(m_readWriteListener,event);
}"
93995,"private void BleManager(Context context,BleManagerConfig config){
  m_context=context.getApplicationContext();
  m_config=config.clone();
  initLogger();
  m_historicalDatabase=PU_HistoricalData.newDatabase(context,this);
  m_diskOptionsMngr=new P_DiskOptionsManager(m_context);
  m_filterMngr=new P_ScanFilterManager(m_config.defaultScanFilter);
  m_btMngr=(BluetoothManager)m_context.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
  BleManagerState nativeState;
  if (m_btMngr == null) {
    nativeState=BleManagerState.get(BluetoothAdapter.STATE_ON);
  }
 else {
    nativeState=BleManagerState.get(m_btMngr.getAdapter().getState());
  }
  m_stateTracker=new P_BleStateTracker(this);
  m_stateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_nativeStateTracker=new P_NativeBleStateTracker(this);
  m_nativeStateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_mainThreadHandler=new Handler(m_context.getMainLooper());
  m_taskQueue=new P_TaskQueue(this);
  m_crashResolver=new P_BluetoothCrashResolver(m_context);
  m_deviceMngr=new P_DeviceManager(this);
  m_deviceMngr_cache=new P_DeviceManager(this);
  m_listeners=new P_BleManager_Listeners(this);
  initConfigDependentMembers();
  m_logger.printBuildInfo();
}","private void BleManager(Context context,BleManagerConfig config){
  m_context=context.getApplicationContext();
  m_config=config.clone();
  initLogger();
  m_historicalDatabase=PU_HistoricalData.newDatabase(context,this);
  m_diskOptionsMngr=new P_DiskOptionsManager(m_context);
  m_filterMngr=new P_ScanFilterManager(this,m_config.defaultScanFilter);
  m_btMngr=(BluetoothManager)m_context.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
  BleManagerState nativeState;
  if (m_btMngr == null) {
    nativeState=BleManagerState.get(BluetoothAdapter.STATE_ON);
  }
 else {
    nativeState=BleManagerState.get(m_btMngr.getAdapter().getState());
  }
  m_stateTracker=new P_BleStateTracker(this);
  m_stateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_nativeStateTracker=new P_NativeBleStateTracker(this);
  m_nativeStateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_mainThreadHandler=new Handler(m_context.getMainLooper());
  m_taskQueue=new P_TaskQueue(this);
  m_crashResolver=new P_BluetoothCrashResolver(m_context);
  m_deviceMngr=new P_DeviceManager(this);
  m_deviceMngr_cache=new P_DeviceManager(this);
  m_listeners=new P_BleManager_Listeners(this);
  initConfigDependentMembers();
  m_logger.printBuildInfo();
}"
93996,"/** 
 * Set a listener here to override any listener provided previously either through this method or through   {@link BleManager#newServer(IncomingListener)} or otherwise.
 */
public void setListener_Incoming(@Nullable(Nullable.Prevalence.NORMAL) final IncomingListener listener_nullable){
  m_incomingListener=listener_nullable;
}","/** 
 * Set a listener here to override any listener provided previously.
 */
public void setListener_Incoming(@Nullable(Nullable.Prevalence.NORMAL) final IncomingListener listener_nullable){
  m_incomingListener=listener_nullable;
}"
93997,"void onNativeConnect(final String macAddress,final boolean explicit){
  m_clientMngr.onConnected(macAddress);
  final ChangeIntent intent=explicit ? ChangeIntent.INTENTIONAL : ChangeIntent.UNINTENTIONAL;
  m_stateTracker.doStateTransition(macAddress,BleServerState.CONNECTING,BleServerState.CONNECTED,intent,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
}","void onNativeConnect(final String macAddress,final boolean explicit){
  m_clientMngr.onConnected(macAddress);
  final ChangeIntent intent=explicit ? ChangeIntent.INTENTIONAL : ChangeIntent.UNINTENTIONAL;
  final BleServerState previousState=explicit ? BleServerState.DISCONNECTED : BleServerState.CONNECTING;
  m_stateTracker.doStateTransition(macAddress,previousState,BleServerState.CONNECTED,intent,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
}"
93998,"/** 
 * Returns service conforming to the ""Current Time Service"" specificiation.
 */
public static BleService currentTime(){
  final BleDescriptor descriptor=new BleDescriptor(Uuids.CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR_UUID,BleDescriptorPermission.READ,BleDescriptorPermission.WRITE);
  final BleCharacteristic characteristic_currentTime=new BleCharacteristic(Uuids.CURRENT_TIME_SERVICE__CURRENT_TIME,descriptor,BleCharacteristicPermission.READ,BleCharacteristicProperty.READ,BleCharacteristicProperty.NOTIFY);
  final BleCharacteristic characteristic_localTime=new BleCharacteristic(Uuids.CURRENT_TIME_SERVICE__LOCAL_TIME_INFO,BleCharacteristicPermission.READ,BleCharacteristicProperty.READ);
  final BleService currentTimeService=new BleService(Uuids.CURRENT_TIME_SERVICE,characteristic_currentTime,characteristic_localTime);
  return currentTimeService;
}","/** 
 * Returns a new service conforming to the ""Current Time Service"" specification.
 */
public static BleService currentTime(){
  final BleDescriptor descriptor=new BleDescriptor(Uuids.CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR_UUID,BleDescriptorPermission.READ,BleDescriptorPermission.WRITE);
  final BleCharacteristic characteristic_currentTime=new BleCharacteristic(Uuids.CURRENT_TIME_SERVICE__CURRENT_TIME,descriptor,BleCharacteristicPermission.READ,BleCharacteristicProperty.READ,BleCharacteristicProperty.NOTIFY);
  final BleCharacteristic characteristic_localTime=new BleCharacteristic(Uuids.CURRENT_TIME_SERVICE__LOCAL_TIME_INFO,BleCharacteristicPermission.READ,BleCharacteristicProperty.READ);
  final BleService currentTimeService=new BleService(Uuids.CURRENT_TIME_SERVICE,characteristic_currentTime,characteristic_localTime);
  return currentTimeService;
}"
93999,"BleManagerConfig.ScanFilter.Please allow(P_Logger logger,BluetoothDevice nativeInstance,List<UUID> uuids,String deviceName,String normalizedDeviceName,byte[] scanRecord,int rssi,State.ChangeIntent lastDisconnectIntent){
  if (m_filters.size() == 0 && m_default == null)   return Please.acknowledge();
  ScanEvent result=null;
  if (m_default != null) {
    result=new ScanEvent(nativeInstance,uuids,deviceName,normalizedDeviceName,scanRecord,rssi,lastDisconnectIntent);
    final Please please=m_default.onEvent(result);
    logger.checkPlease(please,Please.class);
    if (please != null && please.ack()) {
      return please;
    }
  }
  for (int i=0; i < m_filters.size(); i++) {
    result=result != null ? result : new ScanEvent(nativeInstance,uuids,deviceName,normalizedDeviceName,scanRecord,rssi,lastDisconnectIntent);
    ScanFilter ithFilter=m_filters.get(i);
    final Please please=ithFilter.onEvent(result);
    logger.checkPlease(please,Please.class);
    if (please != null && please.ack()) {
      return please;
    }
  }
  return BleManagerConfig.ScanFilter.Please.ignore();
}","BleManagerConfig.ScanFilter.Please allow(P_Logger logger,BluetoothDevice nativeInstance,List<UUID> uuids,String deviceName,String normalizedDeviceName,byte[] scanRecord,int rssi,State.ChangeIntent lastDisconnectIntent){
  if (m_filters.size() == 0 && m_default == null)   return Please.acknowledge();
  ScanEvent result=null;
  if (m_default != null) {
    result=new ScanEvent(nativeInstance,uuids,deviceName,normalizedDeviceName,scanRecord,rssi,lastDisconnectIntent);
    final Please please=m_default.onEvent(result);
    logger.checkPlease(please,Please.class);
    stopScanningIfNeeded(m_default,please);
    if (please != null && please.ack()) {
      return please;
    }
  }
  for (int i=0; i < m_filters.size(); i++) {
    result=result != null ? result : new ScanEvent(nativeInstance,uuids,deviceName,normalizedDeviceName,scanRecord,rssi,lastDisconnectIntent);
    final ScanFilter ithFilter=m_filters.get(i);
    final Please please=ithFilter.onEvent(result);
    logger.checkPlease(please,Please.class);
    stopScanningIfNeeded(ithFilter,please);
    if (please != null && please.ack()) {
      return please;
    }
  }
  return BleManagerConfig.ScanFilter.Please.ignore();
}"
94000,"P_ScanFilterManager(ScanFilter defaultFilter){
  m_default=defaultFilter;
}","P_ScanFilterManager(final BleManager mngr,final ScanFilter defaultFilter){
  m_mngr=mngr;
  m_default=defaultFilter;
}"
