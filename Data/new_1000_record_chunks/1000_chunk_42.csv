record_number,buggy_code,fixed_code
41001,"/** 
 * Adds logic to the BuildPlan to call a Script on a remote machine
 * @param context the TemplatePlanContext where the logical provisioning operation is called
 * @param operation the operation to call
 * @param ia the ia that implements the operation
 * @return true iff adding BPEL Fragment was successful
 */
public boolean handle(TemplatePlanContext templateContext,AbstractOperation operation,AbstractImplementationArtifact ia){
  AbstractArtifactReference scriptRef=this.fetchScriptRefFromIA(ia);
  if (scriptRef == null) {
    return false;
  }
  if (templateContext.getNodeTemplate() == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String serverIp : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(serverIp);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmUserName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(vmUserName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmUserName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmUserName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmUserPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
default :
return false;
}
}
String templateId=""String_Node_Str"";
for (AbstractNodeTemplate nodeTemplate : templateContext.getNodeTemplates()) {
if (PluginUtils.isSupportedUbuntuVMNodeType(nodeTemplate.getType().getId())) {
templateId=nodeTemplate.getId();
}
}
if (templateId.equals(""String_Node_Str"")) {
Handler.LOG.warn(""String_Node_Str"");
return false;
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
Variable runShScriptStringVar=this.appendBPELAssignOperationShScript(templateContext,operation,scriptRef,ia);
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
default :
return false;
}
return true;
}","/** 
 * Adds logic to the BuildPlan to call a Script on a remote machine
 * @param context the TemplatePlanContext where the logical provisioning operation is called
 * @param operation the operation to call
 * @param ia the ia that implements the operation
 * @return true iff adding BPEL Fragment was successful
 */
public boolean handle(TemplatePlanContext templateContext,AbstractOperation operation,AbstractImplementationArtifact ia){
  AbstractArtifactReference scriptRef=this.fetchScriptRefFromIA(ia);
  if (scriptRef == null) {
    return false;
  }
  List<AbstractNodeTemplate> nodes=new ArrayList<AbstractNodeTemplate>();
  Utils.getNodesFromNodeToSink(templateContext.getNodeTemplate(),nodes);
  nodes.add(templateContext.getNodeTemplate());
  AbstractNodeTemplate ubuntuNodeTemplate=null;
  String templateId=""String_Node_Str"";
  for (  AbstractNodeTemplate nodeTemplate : nodes) {
    if (PluginUtils.isSupportedUbuntuVMNodeType(nodeTemplate.getType().getId())) {
      ubuntuNodeTemplate=nodeTemplate;
      templateId=nodeTemplate.getId();
    }
  }
  if (templateId.equals(""String_Node_Str"")) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  if (templateContext.getNodeTemplate() == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String serverIp : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(ubuntuNodeTemplate,serverIp);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmUserName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmUserName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmUserName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmUserPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
default :
return false;
}
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
Variable runShScriptStringVar=this.appendBPELAssignOperationShScript(templateContext,operation,scriptRef,ia);
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
default :
return false;
}
return true;
}"
41002,"public boolean handleOpenStackLiberty12WithUbuntu1404(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate){
  AbstractNodeTemplate ubuntuNodeTemplate=this.findUbuntuNode(nodeTemplate);
  Variable ubuntuAMIIdVar=null;
  if (ubuntuNodeTemplate == null) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  if (this.isUbuntuNodeTypeWithImplicitImage(ubuntuNodeTemplate.getType().getId())) {
    ubuntuAMIIdVar=context.createGlobalStringVariable(""String_Node_Str"",this.createUbuntuImageStringFromNodeType(ubuntuNodeTemplate.getType().getId()));
  }
  LOG.debug(""String_Node_Str"" + ubuntuNodeTemplate.getId() + ""String_Node_Str""+ ubuntuNodeTemplate.getType().getId().toString());
  Variable instanceIdPropWrapper=null;
  for (  String instanceIdName : PluginUtils.getSupportedVirtualMachineInstanceIdPropertyNames()) {
    instanceIdPropWrapper=context.getPropertyVariable(instanceIdName);
    if (instanceIdPropWrapper == null) {
      instanceIdPropWrapper=context.getPropertyVariable(instanceIdName,true);
      if (instanceIdPropWrapper == null) {
        instanceIdPropWrapper=context.getPropertyVariable(instanceIdName,false);
      }
    }
  }
  if (instanceIdPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String vmIpName : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=context.getPropertyVariable(vmIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=context.getPropertyVariable(vmIpName,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=context.getPropertyVariable(vmIpName,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String userName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=context.getPropertyVariable(userName);
    if (sshUserVariable == null) {
      sshUserVariable=context.getPropertyVariable(userName,true);
      if (sshUserVariable == null) {
        sshUserVariable=context.getPropertyVariable(userName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,context)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String passwordName : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=context.getPropertyVariable(passwordName);
    if (sshKeyVariable == null) {
      sshKeyVariable=context.getPropertyVariable(passwordName,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=context.getPropertyVariable(passwordName,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,context)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
  }
  if (sshKeyVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
  }
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  Map<String,Variable> createEC2InternalExternalPropsInput=new HashMap<String,Variable>();
  for (  String externalParameter : Handler.createVMInstanceExternalInputParams) {
    Variable variable=context.getPropertyVariable(externalParameter);
    if (variable == null) {
      variable=context.getPropertyVariable(externalParameter,true);
      if (variable == null) {
        variable=context.getPropertyVariable(externalParameter,false);
      }
    }
    if (externalParameter.equals(""String_Node_Str"") && ubuntuAMIIdVar != null) {
      createEC2InternalExternalPropsInput.put(externalParameter,ubuntuAMIIdVar);
      continue;
    }
    if (variable == null) {
      Handler.LOG.warn(""String_Node_Str"" + externalParameter);
      return false;
    }
 else {
      Handler.LOG.debug(""String_Node_Str"" + externalParameter);
    }
    if (Utils.isVariableValueEmpty(variable,context)) {
      Handler.LOG.debug(""String_Node_Str"");
      createEC2InternalExternalPropsInput.put(externalParameter,null);
    }
 else {
      createEC2InternalExternalPropsInput.put(externalParameter,variable);
    }
  }
  Map<String,Variable> createEC2InternalExternalPropsOutput=new HashMap<String,Variable>();
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMINSTANCEID,instanceIdPropWrapper);
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP,serverIpPropWrapper);
  context.addStringValueToPlanRequest(""String_Node_Str"");
  this.invokerOpPlugin.handle(context,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER_CREATEVM,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER,""String_Node_Str"",createEC2InternalExternalPropsInput,createEC2InternalExternalPropsOutput);
  Map<String,Variable> startRequestInputParams=new HashMap<String,Variable>();
  startRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  startRequestInputParams.put(""String_Node_Str"",sshUserVariable);
  startRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
  this.invokerOpPlugin.handle(context,ubuntuNodeTemplate.getId(),true,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM_WAITFORAVAIL,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",startRequestInputParams,new HashMap<String,Variable>(),false);
  return true;
}","public boolean handleOpenStackLiberty12WithUbuntu1404(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate){
  AbstractNodeTemplate ubuntuNodeTemplate=this.findUbuntuNode(nodeTemplate);
  Variable ubuntuAMIIdVar=null;
  if (ubuntuNodeTemplate == null) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  if (this.isUbuntuNodeTypeWithImplicitImage(ubuntuNodeTemplate.getType().getId())) {
    ubuntuAMIIdVar=context.createGlobalStringVariable(""String_Node_Str"",this.createUbuntuImageStringFromNodeType(ubuntuNodeTemplate.getType().getId()));
  }
  LOG.debug(""String_Node_Str"" + ubuntuNodeTemplate.getId() + ""String_Node_Str""+ ubuntuNodeTemplate.getType().getId().toString());
  Variable instanceIdPropWrapper=null;
  for (  String instanceIdName : PluginUtils.getSupportedVirtualMachineInstanceIdPropertyNames()) {
    instanceIdPropWrapper=context.getPropertyVariable(ubuntuNodeTemplate,instanceIdName);
    if (instanceIdPropWrapper == null) {
      instanceIdPropWrapper=context.getPropertyVariable(instanceIdName,true);
    }
  }
  if (instanceIdPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String vmIpName : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=context.getPropertyVariable(ubuntuNodeTemplate,vmIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=context.getPropertyVariable(vmIpName,true);
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String userName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=context.getPropertyVariable(ubuntuNodeTemplate,userName);
    if (sshUserVariable == null) {
      sshUserVariable=context.getPropertyVariable(userName,true);
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,context)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String passwordName : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=context.getPropertyVariable(ubuntuNodeTemplate,passwordName);
    if (sshKeyVariable == null) {
      sshKeyVariable=context.getPropertyVariable(passwordName,true);
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,context)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
  }
  if (sshKeyVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
  }
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  Map<String,Variable> createEC2InternalExternalPropsInput=new HashMap<String,Variable>();
  for (  String externalParameter : Handler.createVMInstanceExternalInputParams) {
    Variable variable=context.getPropertyVariable(ubuntuNodeTemplate,externalParameter);
    if (variable == null) {
      variable=context.getPropertyVariable(externalParameter,true);
    }
    if (externalParameter.equals(""String_Node_Str"") && ubuntuAMIIdVar != null) {
      createEC2InternalExternalPropsInput.put(externalParameter,ubuntuAMIIdVar);
      continue;
    }
    if (variable == null) {
      Handler.LOG.warn(""String_Node_Str"" + externalParameter);
      return false;
    }
 else {
      Handler.LOG.debug(""String_Node_Str"" + externalParameter);
    }
    if (Utils.isVariableValueEmpty(variable,context)) {
      Handler.LOG.debug(""String_Node_Str"");
      createEC2InternalExternalPropsInput.put(externalParameter,null);
    }
 else {
      createEC2InternalExternalPropsInput.put(externalParameter,variable);
    }
  }
  Map<String,Variable> createEC2InternalExternalPropsOutput=new HashMap<String,Variable>();
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMINSTANCEID,instanceIdPropWrapper);
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP,serverIpPropWrapper);
  context.addStringValueToPlanRequest(""String_Node_Str"");
  this.invokerOpPlugin.handle(context,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER_CREATEVM,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER,""String_Node_Str"",createEC2InternalExternalPropsInput,createEC2InternalExternalPropsOutput);
  Map<String,Variable> startRequestInputParams=new HashMap<String,Variable>();
  startRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  startRequestInputParams.put(""String_Node_Str"",sshUserVariable);
  startRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
  this.invokerOpPlugin.handle(context,ubuntuNodeTemplate.getId(),true,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM_WAITFORAVAIL,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",startRequestInputParams,new HashMap<String,Variable>(),false);
  return true;
}"
41003,"/** 
 * Adds fragments to provision a VM
 * @param context a TemplatePlanContext for a EC2, VM or Ubuntu Node
 * @param nodeTemplate the NodeTemplate on which the fragments are used
 * @return true iff adding the fragments was successful
 */
public boolean handle(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate){
  AbstractNodeTemplate ubuntuNodeTemplate=this.findUbuntuNode(nodeTemplate);
  Variable ubuntuAMIIdVar=null;
  if (ubuntuNodeTemplate == null) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  if (this.isUbuntuNodeTypeWithImplicitImage(ubuntuNodeTemplate.getType().getId())) {
    ubuntuAMIIdVar=context.createGlobalStringVariable(""String_Node_Str"",this.createUbuntuImageStringFromNodeType(ubuntuNodeTemplate.getType().getId()));
  }
  LOG.debug(""String_Node_Str"" + ubuntuNodeTemplate.getId() + ""String_Node_Str""+ ubuntuNodeTemplate.getType().getId().toString());
  Variable instanceIdPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_INSTANCEID);
  if (instanceIdPropWrapper == null) {
    instanceIdPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_INSTANCEID,true);
    if (instanceIdPropWrapper == null) {
      instanceIdPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_INSTANCEID,false);
    }
  }
  if (instanceIdPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP);
  if (serverIpPropWrapper == null) {
    serverIpPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP,true);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP,false);
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=context.getPropertyVariable(""String_Node_Str"");
  if (sshUserVariable == null) {
    sshUserVariable=context.getPropertyVariable(""String_Node_Str"",true);
    if (sshUserVariable == null) {
      sshUserVariable=context.getPropertyVariable(""String_Node_Str"",false);
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,context)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=context.getPropertyVariable(""String_Node_Str"");
  if (sshKeyVariable == null) {
    sshKeyVariable=context.getPropertyVariable(""String_Node_Str"",true);
    if (sshKeyVariable == null) {
      sshKeyVariable=context.getPropertyVariable(""String_Node_Str"",false);
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,context)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(""String_Node_Str"");
  }
  if (sshKeyVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(""String_Node_Str"");
  }
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  Map<String,Variable> createEC2InternalExternalPropsInput=new HashMap<String,Variable>();
  for (  String externalParameter : Handler.createEC2InstanceExternalInputParams) {
    Variable variable=context.getPropertyVariable(externalParameter);
    if (variable == null) {
      variable=context.getPropertyVariable(externalParameter,true);
      if (variable == null) {
        variable=context.getPropertyVariable(externalParameter,false);
      }
    }
    if (externalParameter.equals(""String_Node_Str"") && ubuntuAMIIdVar != null) {
      createEC2InternalExternalPropsInput.put(externalParameter,ubuntuAMIIdVar);
      continue;
    }
    if (variable == null) {
      Handler.LOG.warn(""String_Node_Str"" + externalParameter);
      return false;
    }
 else {
      Handler.LOG.debug(""String_Node_Str"" + externalParameter);
    }
    if (Utils.isVariableValueEmpty(variable,context)) {
      Handler.LOG.debug(""String_Node_Str"");
      createEC2InternalExternalPropsInput.put(externalParameter,null);
    }
 else {
      createEC2InternalExternalPropsInput.put(externalParameter,variable);
    }
  }
  Map<String,Variable> createEC2InternalExternalPropsOutput=new HashMap<String,Variable>();
  createEC2InternalExternalPropsOutput.put(""String_Node_Str"",instanceIdPropWrapper);
  createEC2InternalExternalPropsOutput.put(""String_Node_Str"",serverIpPropWrapper);
  context.addStringValueToPlanRequest(""String_Node_Str"");
  this.invokerOpPlugin.handle(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",createEC2InternalExternalPropsInput,createEC2InternalExternalPropsOutput);
  Map<String,Variable> startRequestInputParams=new HashMap<String,Variable>();
  startRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  startRequestInputParams.put(""String_Node_Str"",sshUserVariable);
  startRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
  this.invokerOpPlugin.handle(context,ubuntuNodeTemplate.getId(),true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",startRequestInputParams,new HashMap<String,Variable>(),false);
  return true;
}","/** 
 * Adds fragments to provision a VM
 * @param context a TemplatePlanContext for a EC2, VM or Ubuntu Node
 * @param nodeTemplate the NodeTemplate on which the fragments are used
 * @return true iff adding the fragments was successful
 */
public boolean handle(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate){
  AbstractNodeTemplate ubuntuNodeTemplate=this.findUbuntuNode(nodeTemplate);
  Variable ubuntuAMIIdVar=null;
  if (ubuntuNodeTemplate == null) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  if (this.isUbuntuNodeTypeWithImplicitImage(ubuntuNodeTemplate.getType().getId())) {
    ubuntuAMIIdVar=context.createGlobalStringVariable(""String_Node_Str"",this.createUbuntuImageStringFromNodeType(ubuntuNodeTemplate.getType().getId()));
  }
  LOG.debug(""String_Node_Str"" + ubuntuNodeTemplate.getId() + ""String_Node_Str""+ ubuntuNodeTemplate.getType().getId().toString());
  Variable instanceIdPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_INSTANCEID,true);
  if (instanceIdPropWrapper == null) {
    instanceIdPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_INSTANCEID);
  }
  if (instanceIdPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP,true);
  if (serverIpPropWrapper == null) {
    serverIpPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP);
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=context.getPropertyVariable(""String_Node_Str"",true);
  if (sshUserVariable == null) {
    sshUserVariable=context.getPropertyVariable(""String_Node_Str"");
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,context)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=context.getPropertyVariable(""String_Node_Str"",true);
  if (sshKeyVariable == null) {
    sshKeyVariable=context.getPropertyVariable(""String_Node_Str"");
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,context)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(""String_Node_Str"");
  }
  if (sshKeyVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(""String_Node_Str"");
  }
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  Map<String,Variable> createEC2InternalExternalPropsInput=new HashMap<String,Variable>();
  for (  String externalParameter : Handler.createEC2InstanceExternalInputParams) {
    Variable variable=context.getPropertyVariable(externalParameter,true);
    if (variable == null) {
      variable=context.getPropertyVariable(externalParameter);
    }
    if (externalParameter.equals(""String_Node_Str"") && ubuntuAMIIdVar != null) {
      createEC2InternalExternalPropsInput.put(externalParameter,ubuntuAMIIdVar);
      continue;
    }
    if (variable == null) {
      Handler.LOG.warn(""String_Node_Str"" + externalParameter);
      return false;
    }
 else {
      Handler.LOG.debug(""String_Node_Str"" + externalParameter);
    }
    if (Utils.isVariableValueEmpty(variable,context)) {
      Handler.LOG.debug(""String_Node_Str"");
      createEC2InternalExternalPropsInput.put(externalParameter,null);
    }
 else {
      createEC2InternalExternalPropsInput.put(externalParameter,variable);
    }
  }
  Map<String,Variable> createEC2InternalExternalPropsOutput=new HashMap<String,Variable>();
  createEC2InternalExternalPropsOutput.put(""String_Node_Str"",instanceIdPropWrapper);
  createEC2InternalExternalPropsOutput.put(""String_Node_Str"",serverIpPropWrapper);
  context.addStringValueToPlanRequest(""String_Node_Str"");
  this.invokerOpPlugin.handle(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",createEC2InternalExternalPropsInput,createEC2InternalExternalPropsOutput);
  Map<String,Variable> startRequestInputParams=new HashMap<String,Variable>();
  startRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  startRequestInputParams.put(""String_Node_Str"",sshUserVariable);
  startRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
  this.invokerOpPlugin.handle(context,ubuntuNodeTemplate.getId(),true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",startRequestInputParams,new HashMap<String,Variable>(),false);
  return true;
}"
41004,"/** 
 * Checks whether this Plugin can handle deploying artifacts of the given artfiactType to a given InfrastructureNode of the given infrastructureNodeType
 * @param scriptArtifactType a QName denoting an scriptArtifactType
 * @param infrastructureNodeType a QName denoting an infrastructureNodeType
 * @return a Boolean. True if given pair of QName's denotes a pair whichthis plugin can handle
 */
private boolean isSupportedDeploymentPair(QName artifactType,QName infrastructureNodeType){
  boolean isSupportedInfrastructureNode=false;
  isSupportedInfrastructureNode|=PluginUtils.isSupportedUbuntuVMNodeType(infrastructureNodeType);
  isSupportedInfrastructureNode|=infrastructureNodeType.equals(Utils.externalResourceNodeType);
  if (!isSupportedInfrastructureNode) {
    return false;
  }
  boolean isSupportedArtifactType=false;
  if (this.archiveArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.scriptArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.warArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.bpelArchiveArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.sqlArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  return isSupportedArtifactType;
}","/** 
 * Checks whether this Plugin can handle deploying artifacts of the given artfiactType to a given InfrastructureNode of the given infrastructureNodeType
 * @param scriptArtifactType a QName denoting an scriptArtifactType
 * @param infrastructureNodeType a QName denoting an infrastructureNodeType
 * @param isDA indicates whether this check is on an IA or DA with the given artifactType
 * @return a Boolean. True if given pair of QName's denotes a pair whichthis plugin can handle
 */
private boolean isSupportedDeploymentPair(QName artifactType,QName infrastructureNodeType,boolean isDA){
  if (!isDA && this.warArtifactType.equals(artifactType) && infrastructureNodeType.equals(new QName(""String_Node_Str"",""String_Node_Str""))) {
    return true;
  }
  boolean isSupportedArtifactType=false;
  if (this.archiveArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.scriptArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.bpelArchiveArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.warArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.sqlArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (!PluginUtils.isSupportedUbuntuVMNodeType(infrastructureNodeType)) {
    return false;
  }
  return isSupportedArtifactType;
}"
41005,"@Override public boolean canHandle(AbstractImplementationArtifact ia,AbstractNodeType infrastructureNodeType){
  QName type=ia.getArtifactType();
  PrePhasePlugin.LOG.debug(""String_Node_Str"" + type.toString() + ""String_Node_Str""+ infrastructureNodeType.getId().toString()+ ""String_Node_Str"");
  return this.isSupportedDeploymentPair(type,infrastructureNodeType.getId());
}","@Override public boolean canHandle(AbstractImplementationArtifact ia,AbstractNodeType infrastructureNodeType){
  QName type=ia.getArtifactType();
  PrePhasePlugin.LOG.debug(""String_Node_Str"" + type.toString() + ""String_Node_Str""+ infrastructureNodeType.getId().toString()+ ""String_Node_Str"");
  return this.isSupportedDeploymentPair(type,infrastructureNodeType.getId(),false);
}"
41006,"/** 
 * Adds necessary BPEL logic through the given Context, to deploy the given ArtifactReferences unto the specified InfrastructureNode
 * @param context a TemplateContext
 * @param refs the ArtifactReferences to deploy
 * @param artifactName the name of the artifact, where the references originate from
 * @param nodeTemplate a NodeTemplate which is a InfrastructureNode to deploy the AbstractReferences on
 * @return true iff adding the logic was successful
 */
private boolean handle(TemplatePlanContext templateContext,List<AbstractArtifactReference> refs,String artifactName,AbstractNodeTemplate nodeTemplate){
  Variable serverIpPropWrapper=null;
  for (  String serverIpName : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(nodeTemplate,serverIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmLoginName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(nodeTemplate,vmLoginName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmLoginName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmLoginName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmLoginPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(nodeTemplate,vmLoginPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
LOG.debug(""String_Node_Str"");
String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
default :
return false;
}
}
String templateId=nodeTemplate.getId();
if (templateId.equals(""String_Node_Str"")) {
Handler.LOG.warn(""String_Node_Str"");
return false;
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
for (AbstractArtifactReference ref : refs) {
this.invokerPlugin.handleArtifactReferenceUpload(ref,templateContext,serverIpPropWrapper,sshUserVariable,sshKeyVariable,templateId);
}
return true;
}","/** 
 * Adds necessary BPEL logic through the given Context, to deploy the given ArtifactReferences unto the specified InfrastructureNode
 * @param context a TemplateContext
 * @param refs the ArtifactReferences to deploy
 * @param artifactName the name of the artifact, where the references originate from
 * @param nodeTemplate a NodeTemplate which is a InfrastructureNode to deploy the AbstractReferences on
 * @return true iff adding the logic was successful
 */
private boolean handle(TemplatePlanContext templateContext,List<AbstractArtifactReference> refs,String artifactName,AbstractNodeTemplate nodeTemplate){
  Variable serverIpPropWrapper=null;
  for (  String serverIpName : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(nodeTemplate,serverIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmLoginName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(nodeTemplate,vmLoginName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmLoginName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmLoginName,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmLoginPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(nodeTemplate,vmLoginPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANUSER);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
LOG.debug(""String_Node_Str"");
String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANPASSWD);
break;
default :
return false;
}
}
String templateId=nodeTemplate.getId();
if (templateId.equals(""String_Node_Str"")) {
Handler.LOG.warn(""String_Node_Str"");
return false;
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
for (AbstractArtifactReference ref : refs) {
this.invokerPlugin.handleArtifactReferenceUpload(ref,templateContext,serverIpPropWrapper,sshUserVariable,sshKeyVariable,templateId);
}
return true;
}"
41007,"public boolean handleArtifactReferenceUpload(AbstractArtifactReference ref,TemplatePlanContext templateContext,Variable serverIp,Variable sshUser,Variable sshKey,String templateId,boolean appendToPrePhase) throws IOException {
  LOG.debug(""String_Node_Str"" + ref.getReference());
  String ubuntuFilePath=""String_Node_Str"" + templateContext.getCSARFileName() + ""String_Node_Str""+ ref.getReference();
  String ubuntuFilePathVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable ubuntuFilePathVar=templateContext.createGlobalStringVariable(ubuntuFilePathVarName,ubuntuFilePath);
  String ubuntuFolderPathScript=""String_Node_Str"" + this.fileReferenceToFolder(ubuntuFilePath);
  String containerAPIAbsoluteURIXPathQuery=this.createXPathQueryForURLRemoteFilePath(ref.getReference());
  String containerAPIAbsoluteURIVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable containerAPIAbsoluteURIVar=templateContext.createGlobalStringVariable(containerAPIAbsoluteURIVarName,""String_Node_Str"");
  try {
    Node assignNode=this.loadAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + templateContext.getIdForNames(),containerAPIAbsoluteURIXPathQuery,containerAPIAbsoluteURIVar.getName());
    assignNode=templateContext.importNode(assignNode);
    if (appendToPrePhase) {
      templateContext.getPrePhaseElement().appendChild(assignNode);
    }
 else {
      templateContext.getProvisioningPhaseElement().appendChild(assignNode);
    }
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
    return false;
  }
catch (  SAXException e) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
  String mkdirScriptVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable mkdirScriptVar=templateContext.createGlobalStringVariable(mkdirScriptVarName,ubuntuFolderPathScript);
  String cleanName=serverIp.getName().substring(serverIp.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
    runScriptRequestInputParams.put(""String_Node_Str"",serverIp);
  runScriptRequestInputParams.put(""String_Node_Str"",sshKey);
runScriptRequestInputParams.put(""String_Node_Str"",sshUser);
runScriptRequestInputParams.put(""String_Node_Str"",mkdirScriptVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIp);
runScriptRequestInputParams.put(""String_Node_Str"",sshUser);
runScriptRequestInputParams.put(""String_Node_Str"",sshKey);
runScriptRequestInputParams.put(""String_Node_Str"",mkdirScriptVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
default :
return false;
}
Map<String,Variable> transferFileRequestInputParams=new HashMap<String,Variable>();
String cleanName2=serverIp.getName().substring(serverIp.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName2) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
transferFileRequestInputParams.put(""String_Node_Str"",serverIp);
transferFileRequestInputParams.put(""String_Node_Str"",sshUser);
transferFileRequestInputParams.put(""String_Node_Str"",sshKey);
transferFileRequestInputParams.put(""String_Node_Str"",ubuntuFilePathVar);
transferFileRequestInputParams.put(""String_Node_Str"",containerAPIAbsoluteURIVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",transferFileRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
transferFileRequestInputParams.put(""String_Node_Str"",serverIp);
transferFileRequestInputParams.put(""String_Node_Str"",sshUser);
transferFileRequestInputParams.put(""String_Node_Str"",sshKey);
transferFileRequestInputParams.put(""String_Node_Str"",ubuntuFilePathVar);
transferFileRequestInputParams.put(""String_Node_Str"",containerAPIAbsoluteURIVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",transferFileRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
default :
return false;
}
return true;
}","public boolean handleArtifactReferenceUpload(AbstractArtifactReference ref,TemplatePlanContext templateContext,Variable serverIp,Variable sshUser,Variable sshKey,String templateId,boolean appendToPrePhase) throws IOException {
  LOG.debug(""String_Node_Str"" + ref.getReference());
  String ubuntuFilePath=""String_Node_Str"" + templateContext.getCSARFileName() + ""String_Node_Str""+ ref.getReference();
  String ubuntuFilePathVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable ubuntuFilePathVar=templateContext.createGlobalStringVariable(ubuntuFilePathVarName,ubuntuFilePath);
  String ubuntuFolderPathScript=""String_Node_Str"" + this.fileReferenceToFolder(ubuntuFilePath);
  String containerAPIAbsoluteURIXPathQuery=this.createXPathQueryForURLRemoteFilePath(ref.getReference());
  String containerAPIAbsoluteURIVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable containerAPIAbsoluteURIVar=templateContext.createGlobalStringVariable(containerAPIAbsoluteURIVarName,""String_Node_Str"");
  try {
    Node assignNode=this.loadAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + templateContext.getIdForNames(),containerAPIAbsoluteURIXPathQuery,containerAPIAbsoluteURIVar.getName());
    assignNode=templateContext.importNode(assignNode);
    if (appendToPrePhase) {
      templateContext.getPrePhaseElement().appendChild(assignNode);
    }
 else {
      templateContext.getProvisioningPhaseElement().appendChild(assignNode);
    }
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
    return false;
  }
catch (  SAXException e) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
  String mkdirScriptVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable mkdirScriptVar=templateContext.createGlobalStringVariable(mkdirScriptVarName,ubuntuFolderPathScript);
  String cleanName=serverIp.getName().substring(serverIp.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
    runScriptRequestInputParams.put(""String_Node_Str"",serverIp);
  runScriptRequestInputParams.put(""String_Node_Str"",sshKey);
runScriptRequestInputParams.put(""String_Node_Str"",sshUser);
runScriptRequestInputParams.put(""String_Node_Str"",mkdirScriptVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIp);
runScriptRequestInputParams.put(""String_Node_Str"",sshUser);
runScriptRequestInputParams.put(""String_Node_Str"",sshKey);
runScriptRequestInputParams.put(""String_Node_Str"",mkdirScriptVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
default :
return false;
}
Map<String,Variable> transferFileRequestInputParams=new HashMap<String,Variable>();
String cleanName2=serverIp.getName().substring(serverIp.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName2) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
transferFileRequestInputParams.put(""String_Node_Str"",serverIp);
transferFileRequestInputParams.put(""String_Node_Str"",sshUser);
transferFileRequestInputParams.put(""String_Node_Str"",sshKey);
transferFileRequestInputParams.put(""String_Node_Str"",ubuntuFilePathVar);
transferFileRequestInputParams.put(""String_Node_Str"",containerAPIAbsoluteURIVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",transferFileRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
transferFileRequestInputParams.put(""String_Node_Str"",serverIp);
transferFileRequestInputParams.put(""String_Node_Str"",sshUser);
transferFileRequestInputParams.put(""String_Node_Str"",sshKey);
transferFileRequestInputParams.put(""String_Node_Str"",ubuntuFilePathVar);
transferFileRequestInputParams.put(""String_Node_Str"",containerAPIAbsoluteURIVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",transferFileRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
default :
return false;
}
return true;
}"
41008,"/** 
 * Adds logic to the BuildPlan to call a Script on a remote machine
 * @param context the TemplatePlanContext where the logical provisioning operation is called
 * @param operation the operation to call
 * @param ia the ia that implements the operation
 * @return true iff adding BPEL Fragment was successful
 */
public boolean handle(TemplatePlanContext templateContext,AbstractOperation operation,AbstractImplementationArtifact ia){
  AbstractArtifactReference scriptRef=this.fetchScriptRefFromIA(ia);
  if (scriptRef == null) {
    return false;
  }
  List<AbstractNodeTemplate> nodes=new ArrayList<AbstractNodeTemplate>();
  Utils.getInfrastructureNodes(templateContext.getNodeTemplate(),nodes);
  nodes.add(templateContext.getNodeTemplate());
  AbstractNodeTemplate ubuntuNodeTemplate=null;
  String templateId=""String_Node_Str"";
  for (  AbstractNodeTemplate nodeTemplate : nodes) {
    if (PluginUtils.isSupportedUbuntuVMNodeType(nodeTemplate.getType().getId())) {
      ubuntuNodeTemplate=nodeTemplate;
      templateId=nodeTemplate.getId();
    }
  }
  if (templateId.equals(""String_Node_Str"")) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  if (templateContext.getNodeTemplate() == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String serverIp : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(ubuntuNodeTemplate,serverIp);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmUserName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmUserName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmUserName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmUserPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
default :
return false;
}
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
Variable runShScriptStringVar=this.appendBPELAssignOperationShScript(templateContext,operation,scriptRef,ia);
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
default :
return false;
}
return true;
}","/** 
 * Adds logic to the BuildPlan to call a Script on a remote machine
 * @param context the TemplatePlanContext where the logical provisioning operation is called
 * @param operation the operation to call
 * @param ia the ia that implements the operation
 * @return true iff adding BPEL Fragment was successful
 */
public boolean handle(TemplatePlanContext templateContext,AbstractOperation operation,AbstractImplementationArtifact ia){
  AbstractArtifactReference scriptRef=this.fetchScriptRefFromIA(ia);
  if (scriptRef == null) {
    return false;
  }
  List<AbstractNodeTemplate> nodes=templateContext.getInfrastructureNodes();
  nodes.add(templateContext.getNodeTemplate());
  AbstractNodeTemplate ubuntuNodeTemplate=null;
  String templateId=""String_Node_Str"";
  for (  AbstractNodeTemplate nodeTemplate : nodes) {
    if (PluginUtils.isSupportedUbuntuVMNodeType(nodeTemplate.getType().getId())) {
      ubuntuNodeTemplate=nodeTemplate;
      templateId=nodeTemplate.getId();
    }
  }
  if (templateId.equals(""String_Node_Str"")) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  if (templateContext.getNodeTemplate() == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String serverIp : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(ubuntuNodeTemplate,serverIp);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmUserName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmUserName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmUserName,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmUserPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANUSER);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANPASSWD);
break;
default :
return false;
}
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
Variable runShScriptStringVar=this.appendBPELAssignOperationShScript(templateContext,operation,scriptRef,ia);
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
default :
return false;
}
return true;
}"
41009,"/** 
 * Exports the given BuildPlans repackaged with the CSAR denoted by the given CSARID
 * @param buildPlans the BuildPlans to export
 * @param csarId the CSARID of a CSAR
 * @return a File denoting the absolute Path to the exported CSAR
 */
public File export(List<BuildPlan> buildPlans,CSARID csarId){
  CSARContent csarContent=null;
  try {
    csarContent=this.handler.getCSARContentForID(csarId);
  }
 catch (  UserException e1) {
    Exporter.LOG.error(""String_Node_Str"",e1);
  }
  if (csarContent == null) {
    return null;
  }
  String csarName=csarId.getFileName();
  IFileAccessService service=this.getFileAccessService();
  File tempDir=service.getTemp();
  File pathToRepackagedCsar=service.getTemp();
  File repackagedCsar=new File(pathToRepackagedCsar,csarName);
  try {
    Set<AbstractFile> files=csarContent.getFilesRecursively();
    AbstractFile mainDefFile=csarContent.getRootTOSCA();
    File rootDefFile=mainDefFile.getFile().toFile();
    Definitions defs=this.parseDefinitionsFile(rootDefFile);
    List<TServiceTemplate> servTemps=this.getServiceTemplates(defs);
    List<BuildPlan> plansToExport=new ArrayList<BuildPlan>();
    for (    BuildPlan buildPlan : buildPlans) {
      for (      TServiceTemplate serviceTemplate : servTemps) {
        if (buildPlan.getServiceTemplate().toString().equals(this.buildQName(defs,serviceTemplate).toString())) {
          TPlans plans=serviceTemplate.getPlans();
          if (plans == null) {
            plans=this.toscaFactory.createTPlans();
            serviceTemplate.setPlans(plans);
          }
          List<TPlan> planList=plans.getPlan();
          planList.add(this.generateTPlanElement(buildPlan));
          plansToExport.add(buildPlan);
        }
      }
    }
    for (    AbstractFile file : files) {
      if (file.getFile().toFile().toString().equals(rootDefFile.toString())) {
        continue;
      }
      File newLocation=new File(tempDir,file.getPath());
      Exporter.LOG.debug(newLocation.getAbsolutePath());
      Exporter.LOG.debug(file.getFile().toString());
      if (newLocation.isDirectory()) {
        FileUtils.copyDirectory(file.getFile().toFile(),newLocation);
      }
 else {
        FileUtils.copyFile(file.getFile().toFile(),newLocation);
      }
    }
    File newDefsFile=new File(tempDir,mainDefFile.getPath());
    newDefsFile.createNewFile();
    JAXBContext jaxbContext=JAXBContext.newInstance(Definitions.class);
    Marshaller m=jaxbContext.createMarshaller();
    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
    m.marshal(defs,newDefsFile);
    for (    BuildPlan plan : plansToExport) {
      File planPath=new File(tempDir,this.generateRelativePlanPath(plan));
      Exporter.LOG.debug(planPath.toString());
      planPath.getParentFile().mkdirs();
      planPath.createNewFile();
      this.simpleExporter.export(planPath.toURI(),plan);
    }
    File selfServiceDir=new File(tempDir,""String_Node_Str"");
    File selfServiceDataXml=new File(selfServiceDir,""String_Node_Str"");
    JAXBContext jaxbContextWineryApplication=JAXBContext.newInstance(Application.class);
    if (selfServiceDir.exists() && selfServiceDataXml.exists()) {
      Unmarshaller u=jaxbContextWineryApplication.createUnmarshaller();
      Application appDesc=(Application)u.unmarshal(selfServiceDataXml);
      if (appDesc.getOptions() != null) {
        for (        ApplicationOption option : appDesc.getOptions().getOption()) {
          for (          BuildPlan plan : plansToExport) {
            if (option.getPlanServiceName().equals(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart())) {
              if (!new File(selfServiceDir,option.getPlanInputMessageUrl()).exists()) {
                File planInputFile=new File(selfServiceDir,option.getPlanInputMessageUrl());
                this.writePlanInputMessageInstance(plan,planInputFile);
              }
            }
          }
        }
      }
 else {
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
 else {
      if (selfServiceDir.mkdirs() && selfServiceDataXml.createNewFile()) {
        Application appDesc=new Application();
        appDesc.setDisplayName(csarName);
        appDesc.setDescription(""String_Node_Str"");
        appDesc.setIconUrl(""String_Node_Str"");
        appDesc.setImageUrl(""String_Node_Str"");
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
  }
 catch (  IOException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  JAXBException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  SystemException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
  service.zip(tempDir,repackagedCsar);
  Exporter.LOG.debug(repackagedCsar.toString());
  return repackagedCsar;
}","/** 
 * Exports the given BuildPlans repackaged with the CSAR denoted by the given CSARID
 * @param buildPlans the BuildPlans to export
 * @param csarId the CSARID of a CSAR
 * @return a File denoting the absolute Path to the exported CSAR
 */
public File export(List<BuildPlan> buildPlans,CSARID csarId){
  CSARContent csarContent=null;
  try {
    csarContent=this.handler.getCSARContentForID(csarId);
  }
 catch (  UserException e1) {
    Exporter.LOG.error(""String_Node_Str"",e1);
  }
  if (csarContent == null) {
    return null;
  }
  String csarName=csarId.getFileName();
  IFileAccessService service=this.getFileAccessService();
  File tempDir=service.getTemp();
  File pathToRepackagedCsar=service.getTemp();
  File repackagedCsar=new File(pathToRepackagedCsar,csarName);
  try {
    Set<AbstractFile> files=csarContent.getFilesRecursively();
    AbstractFile mainDefFile=csarContent.getRootTOSCA();
    File rootDefFile=mainDefFile.getFile().toFile();
    Definitions defs=this.parseDefinitionsFile(rootDefFile);
    List<TServiceTemplate> servTemps=this.getServiceTemplates(defs);
    List<BuildPlan> plansToExport=new ArrayList<BuildPlan>();
    for (    BuildPlan buildPlan : buildPlans) {
      for (      TServiceTemplate serviceTemplate : servTemps) {
        if (buildPlan.getServiceTemplate().equals(this.buildQName(defs,serviceTemplate))) {
          TPlans plans=serviceTemplate.getPlans();
          if (plans == null) {
            plans=this.toscaFactory.createTPlans();
            serviceTemplate.setPlans(plans);
          }
          List<TPlan> planList=plans.getPlan();
          planList.add(this.generateTPlanElement(buildPlan));
          plansToExport.add(buildPlan);
        }
      }
    }
    for (    AbstractFile file : files) {
      if (file.getFile().toFile().toString().equals(rootDefFile.toString())) {
        continue;
      }
      File newLocation=new File(tempDir,file.getPath());
      Exporter.LOG.debug(newLocation.getAbsolutePath());
      Exporter.LOG.debug(file.getFile().toString());
      if (newLocation.isDirectory()) {
        FileUtils.copyDirectory(file.getFile().toFile(),newLocation);
      }
 else {
        FileUtils.copyFile(file.getFile().toFile(),newLocation);
      }
    }
    File newDefsFile=new File(tempDir,mainDefFile.getPath());
    newDefsFile.createNewFile();
    JAXBContext jaxbContext=JAXBContext.newInstance(Definitions.class);
    Marshaller m=jaxbContext.createMarshaller();
    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
    m.marshal(defs,newDefsFile);
    for (    BuildPlan plan : plansToExport) {
      File planPath=new File(tempDir,this.generateRelativePlanPath(plan));
      Exporter.LOG.debug(planPath.toString());
      planPath.getParentFile().mkdirs();
      planPath.createNewFile();
      this.simpleExporter.export(planPath.toURI(),plan);
    }
    File selfServiceDir=new File(tempDir,""String_Node_Str"");
    File selfServiceDataXml=new File(selfServiceDir,""String_Node_Str"");
    JAXBContext jaxbContextWineryApplication=JAXBContext.newInstance(Application.class);
    if (selfServiceDir.exists() && selfServiceDataXml.exists()) {
      Unmarshaller u=jaxbContextWineryApplication.createUnmarshaller();
      Application appDesc=(Application)u.unmarshal(selfServiceDataXml);
      if (appDesc.getOptions() != null) {
        for (        ApplicationOption option : appDesc.getOptions().getOption()) {
          for (          BuildPlan plan : plansToExport) {
            if (option.getPlanServiceName().equals(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart())) {
              if (!new File(selfServiceDir,option.getPlanInputMessageUrl()).exists()) {
                File planInputFile=new File(selfServiceDir,option.getPlanInputMessageUrl());
                this.writePlanInputMessageInstance(plan,planInputFile);
              }
            }
          }
        }
      }
 else {
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
 else {
      if (selfServiceDir.mkdirs() && selfServiceDataXml.createNewFile()) {
        Application appDesc=new Application();
        appDesc.setDisplayName(csarName);
        appDesc.setDescription(""String_Node_Str"");
        appDesc.setIconUrl(""String_Node_Str"");
        appDesc.setImageUrl(""String_Node_Str"");
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
  }
 catch (  IOException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  JAXBException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  SystemException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
  service.zip(tempDir,repackagedCsar);
  Exporter.LOG.debug(repackagedCsar.toString());
  return repackagedCsar;
}"
41010,"private void rewriteServiceNames(Deploy deploy,List<File> referencedFiles,String csarName) throws WSDLException, FileNotFoundException {
  WSDLFactory factory=WSDLFactory.newInstance();
  WSDLReader reader=factory.newWSDLReader();
  WSDLWriter writer=factory.newWSDLWriter();
  List<TInvoke> invokes=deploy.getProcess().get(0).getInvoke();
  List<TProvide> provides=deploy.getProcess().get(0).getProvide();
  List<QName> servicesToRewrite=new ArrayList<QName>();
  for (  TInvoke invoke : invokes) {
    if (invoke.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    TService service=invoke.getService();
    QName serviceName=service.getName();
    servicesToRewrite.add(serviceName);
    QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart());
    service.setName(renamedServiceName);
    invoke.setService(service);
  }
  for (  TProvide provide : provides) {
    if (provide.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    TService service=provide.getService();
    QName serviceName=service.getName();
    servicesToRewrite.add(serviceName);
    QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart());
    service.setName(renamedServiceName);
    provide.setService(service);
  }
  for (  QName serviceName : servicesToRewrite) {
    for (    File file : referencedFiles) {
      if (!file.getAbsolutePath().endsWith(""String_Node_Str"")) {
        continue;
      }
      Definition def=reader.readWSDL(file.getAbsolutePath());
      List<QName> servicesToRemove=new ArrayList<QName>();
      for (      Object obj : def.getAllServices().values()) {
        Service service=(Service)obj;
        if (serviceName.toString().equals(service.getQName().toString())) {
          servicesToRemove.add(service.getQName());
          Service newService=new ServiceImpl();
          for (          Object o : service.getPorts().values()) {
            Port port=(Port)o;
            newService.addPort(port);
          }
          newService.setQName(new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart()));
          def.addService(newService);
        }
      }
      for (      QName serviceToRemove : servicesToRemove) {
        def.removeService(serviceToRemove);
      }
      writer.writeWSDL(def,new FileOutputStream(file));
    }
  }
}","private void rewriteServiceNames(Deploy deploy,List<File> referencedFiles,String csarName) throws WSDLException, FileNotFoundException {
  WSDLFactory factory=WSDLFactory.newInstance();
  WSDLReader reader=factory.newWSDLReader();
  WSDLWriter writer=factory.newWSDLWriter();
  List<TInvoke> invokes=deploy.getProcess().get(0).getInvoke();
  List<TProvide> provides=deploy.getProcess().get(0).getProvide();
  List<QName> servicesToRewrite=new ArrayList<QName>();
  for (  TInvoke invoke : invokes) {
    if (invoke.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    TService service=invoke.getService();
    QName serviceName=service.getName();
    servicesToRewrite.add(serviceName);
    QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart());
    service.setName(renamedServiceName);
    invoke.setService(service);
  }
  for (  TProvide provide : provides) {
    if (provide.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    TService service=provide.getService();
    QName serviceName=service.getName();
    servicesToRewrite.add(serviceName);
    QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart());
    service.setName(renamedServiceName);
    provide.setService(service);
  }
  for (  QName serviceName : servicesToRewrite) {
    for (    File file : referencedFiles) {
      if (!file.getAbsolutePath().endsWith(""String_Node_Str"")) {
        continue;
      }
      Definition def=reader.readWSDL(file.getAbsolutePath());
      List<QName> servicesToRemove=new ArrayList<QName>();
      for (      Object obj : def.getAllServices().values()) {
        Service service=(Service)obj;
        if (serviceName.equals(service.getQName())) {
          servicesToRemove.add(service.getQName());
          Service newService=new ServiceImpl();
          for (          Object o : service.getPorts().values()) {
            Port port=(Port)o;
            newService.addPort(port);
          }
          newService.setQName(new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart()));
          def.addService(newService);
        }
      }
      for (      QName serviceToRemove : servicesToRemove) {
        def.removeService(serviceToRemove);
      }
      writer.writeWSDL(def,new FileOutputStream(file));
    }
  }
}"
41011,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  DeploymentArtifactImpl other=(DeploymentArtifactImpl)obj;
  if (artifact == null) {
    if (other.artifact != null)     return false;
  }
 else   if (!artifact.equals(other.artifact))   return false;
  if (def == null) {
    if (other.def != null)     return false;
  }
 else   if (!def.equals(other.def))   return false;
  if (!other.getArtifactType().toString().equals(this.getArtifactType().toString())) {
    return false;
  }
  if (!this.getName().equals(other.getName())) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  DeploymentArtifactImpl other=(DeploymentArtifactImpl)obj;
  if (artifact == null) {
    if (other.artifact != null)     return false;
  }
 else   if (!artifact.equals(other.artifact))   return false;
  if (def == null) {
    if (other.def != null)     return false;
  }
 else   if (!def.equals(other.def))   return false;
  if (!other.getArtifactType().equals(this.getArtifactType())) {
    return false;
  }
  if (!this.getName().equals(other.getName())) {
    return false;
  }
  return true;
}"
41012,"/** 
 * {@inheritDoc}
 */
@Override public List<AbstractNodeTypeImplementation> getImplementations(){
  List<AbstractNodeTypeImplementation> impls=new ArrayList<AbstractNodeTypeImplementation>();
  List<AbstractNodeTypeImplementation> foundImpls=this.findNodeTypeImpls(this.definitions);
  for (  AbstractNodeTypeImplementation impl : foundImpls) {
    if (impl == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (impl.getNodeType() == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (this.nodeTemplate == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (this.nodeTemplate.getType() == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    NodeTemplateImpl.LOG.debug(""String_Node_Str"" + impl.getName() + ""String_Node_Str""+ this.nodeTemplate.getId());
    if (impl.getNodeType().getId().toString().equals(this.nodeTemplate.getType().toString())) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"" + this.nodeTemplate.getId() + ""String_Node_Str""+ impl.getName());
      impls.add(impl);
    }
  }
  return impls;
}","/** 
 * {@inheritDoc}
 */
@Override public List<AbstractNodeTypeImplementation> getImplementations(){
  List<AbstractNodeTypeImplementation> impls=new ArrayList<AbstractNodeTypeImplementation>();
  List<AbstractNodeTypeImplementation> foundImpls=this.findNodeTypeImpls(this.definitions);
  for (  AbstractNodeTypeImplementation impl : foundImpls) {
    if (impl == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (impl.getNodeType() == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (this.nodeTemplate == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (this.nodeTemplate.getType() == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    NodeTemplateImpl.LOG.debug(""String_Node_Str"" + impl.getName() + ""String_Node_Str""+ this.nodeTemplate.getId());
    if (impl.getNodeType().getId().equals(this.nodeTemplate.getType())) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"" + this.nodeTemplate.getId() + ""String_Node_Str""+ impl.getName());
      impls.add(impl);
    }
  }
  return impls;
}"
41013,"/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getType(){
  if (this.nodeTemplate == null) {
    NodeTemplateImpl.LOG.debug(""String_Node_Str"");
  }
  if (this.nodeTemplate.getType() == null) {
    NodeTemplateImpl.LOG.debug(""String_Node_Str"");
  }
  for (  AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
    if (nodeType.getId().toString().equals(this.nodeTemplate.getType().toString())) {
      return nodeType;
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getType(){
  if (this.nodeTemplate == null) {
    NodeTemplateImpl.LOG.debug(""String_Node_Str"");
  }
  if (this.nodeTemplate.getType() == null) {
    NodeTemplateImpl.LOG.debug(""String_Node_Str"");
  }
  for (  AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
    if (nodeType.getId().equals(this.nodeTemplate.getType())) {
      return nodeType;
    }
  }
  return null;
}"
41014,"/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getTypeRef(){
  if (this.nodeType.getDerivedFrom() != null) {
    for (    AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
      if (nodeType.getId().toString().equals(this.nodeType.getDerivedFrom().getTypeRef().toString())) {
        return nodeType;
      }
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getTypeRef(){
  if (this.nodeType.getDerivedFrom() != null) {
    for (    AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
      if (nodeType.getId().equals(this.nodeType.getDerivedFrom().getTypeRef())) {
        return nodeType;
      }
    }
  }
  return null;
}"
41015,"/** 
 * {@inheritDoc}
 */
@Override public QName getId(){
  String namespace;
  if ((this.getTargetNamespace() != null) && !this.getTargetNamespace().equals(""String_Node_Str"")) {
    namespace=this.getTargetNamespace();
  }
 else {
    namespace=this.definitions.getTargetNamespace();
  }
  return new QName(""String_Node_Str"" + namespace + ""String_Node_Str""+ this.getName());
}","/** 
 * {@inheritDoc}
 */
@Override public QName getId(){
  String namespace;
  if ((this.getTargetNamespace() != null) && !this.getTargetNamespace().equals(""String_Node_Str"")) {
    namespace=this.getTargetNamespace();
  }
 else {
    namespace=this.definitions.getTargetNamespace();
  }
  return new QName(namespace,this.getName());
}"
41016,"/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getNodeType(){
  if (this.nodeTypeImpl.getNodeType() == null) {
    NodeTypeImplementationImpl.LOG.error(""String_Node_Str"",""String_Node_Str"" + this.getTargetNamespace() + ""String_Node_Str""+ this.getName());
  }
  for (  AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
    if (nodeType.getId().toString().equals(this.nodeTypeImpl.getNodeType().toString())) {
      return nodeType;
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getNodeType(){
  if (this.nodeTypeImpl.getNodeType() == null) {
    NodeTypeImplementationImpl.LOG.error(""String_Node_Str"",""String_Node_Str"" + this.getTargetNamespace() + ""String_Node_Str""+ this.getName());
  }
  for (  AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
    if (nodeType.getId().equals(this.nodeTypeImpl.getNodeType())) {
      return nodeType;
    }
  }
  return null;
}"
41017,"/** 
 * {@inheritDoc}
 */
@Override public List<AbstractRelationshipTypeImplementation> getImplementations(){
  List<AbstractRelationshipTypeImplementation> impls=new ArrayList<AbstractRelationshipTypeImplementation>();
  for (  AbstractRelationshipTypeImplementation impl : this.findRelationshipTypeImpls(this.definitions)) {
    if (impl.getRelationshipType().getId().equals(this.relationshipTemplate.getType().getLocalPart())) {
      impls.add(impl);
    }
  }
  return impls;
}","/** 
 * {@inheritDoc}
 */
@Override public List<AbstractRelationshipTypeImplementation> getImplementations(){
  List<AbstractRelationshipTypeImplementation> impls=new ArrayList<AbstractRelationshipTypeImplementation>();
  for (  AbstractRelationshipTypeImplementation impl : this.findRelationshipTypeImpls(this.definitions)) {
    if (impl.getRelationshipType().getId().equals(this.relationshipTemplate.getType())) {
      impls.add(impl);
    }
  }
  return impls;
}"
41018,"/** 
 * {@inheritDoc}
 */
@Override public AbstractRelationshipType getReferencedType(){
  if (this.getTypeRef() != null) {
    for (    AbstractRelationshipType relation : this.definitions.getAllRelationshipTypes()) {
      if (relation.getId().toString().equals(this.getTypeRef().toString())) {
        return relation;
      }
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractRelationshipType getReferencedType(){
  if (this.getTypeRef() != null) {
    for (    AbstractRelationshipType relation : this.definitions.getAllRelationshipTypes()) {
      if (relation.getId().equals(this.getTypeRef())) {
        return relation;
      }
    }
  }
  return null;
}"
41019,"/** 
 * {@inheritDoc}
 */
@Override public AbstractRelationshipType getRelationshipType(){
  for (  AbstractRelationshipType relation : this.defs.getAllRelationshipTypes()) {
    if (relation.getId().toString().equals(this.relationshipTypeImpl.getRelationshipType().toString())) {
      return relation;
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractRelationshipType getRelationshipType(){
  for (  AbstractRelationshipType relation : this.defs.getAllRelationshipTypes()) {
    if (relation.getId().equals(this.relationshipTypeImpl.getRelationshipType())) {
      return relation;
    }
  }
  return null;
}"
41020,"/** 
 * Returns a RelationshipType for the given QName. This method looks trough the whole Definitions space, which means the search looks trough the imported Definitions of this Definitions.
 * @param relationshipTypeId a QName
 * @return an AbstractRelationshipType, if nothing was found null
 */
public AbstractRelationshipType getRelationshipType(QName relationshipTypeId){
  for (  AbstractRelationshipType relationshipType : this.getRelationshipTypes()) {
    if (relationshipType.getId().toString().equals(relationshipTypeId.toString())) {
      return relationshipType;
    }
  }
  return null;
}","/** 
 * Returns a RelationshipType for the given QName. This method looks trough the whole Definitions space, which means the search looks trough the imported Definitions of this Definitions.
 * @param relationshipTypeId a QName
 * @return an AbstractRelationshipType, if nothing was found null
 */
public AbstractRelationshipType getRelationshipType(QName relationshipTypeId){
  for (  AbstractRelationshipType relationshipType : this.getRelationshipTypes()) {
    if (relationshipType.getId().equals(relationshipTypeId)) {
      return relationshipType;
    }
  }
  return null;
}"
41021,"/** 
 * Returns a NodeType for the given QName, This method looks trough the whole Definitions space, which means the search looks trough the imported Definitions of this Definitions
 * @param nodeTypeId a QName
 * @return an AbstractNodeType, if nothing was found null
 */
public AbstractNodeType getNodeType(QName nodeTypeId){
  for (  AbstractNodeType nodeType : this.getNodeTypes()) {
    if (nodeType.getId().toString().equals(nodeTypeId.toString())) {
      return nodeType;
    }
  }
  return null;
}","/** 
 * Returns a NodeType for the given QName, This method looks trough the whole Definitions space, which means the search looks trough the imported Definitions of this Definitions
 * @param nodeTypeId a QName
 * @return an AbstractNodeType, if nothing was found null
 */
public AbstractNodeType getNodeType(QName nodeTypeId){
  for (  AbstractNodeType nodeType : this.getNodeTypes()) {
    if (nodeType.getId().equals(nodeTypeId)) {
      return nodeType;
    }
  }
  return null;
}"
41022,"/** 
 * Checks whether the given Node is an ubuntu nodeType that can be handled by the set of plugins used by the PlanBuilder.
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if the given nodeType is an ubuntu nodeType
 */
public static boolean isSupportedUbuntuVMNodeType(QName nodeType){
  if (nodeType.toString().equals(Types.ubuntuNodeType.toString())) {
    return true;
  }
  String nodeTypeNS=nodeType.getNamespaceURI();
  String nodeTypeLN=nodeType.getLocalPart();
  if (nodeTypeNS.equals(""String_Node_Str"") && PluginUtils.isProperUbuntuLocalName(nodeTypeLN)) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given Node is an ubuntu nodeType that can be handled by the set of plugins used by the PlanBuilder.
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if the given nodeType is an ubuntu nodeType
 */
public static boolean isSupportedUbuntuVMNodeType(QName nodeType){
  if (nodeType.equals(Types.ubuntuNodeType)) {
    return true;
  }
  String nodeTypeNS=nodeType.getNamespaceURI();
  String nodeTypeLN=nodeType.getLocalPart();
  if (nodeTypeNS.equals(""String_Node_Str"") && PluginUtils.isProperUbuntuLocalName(nodeTypeLN)) {
    return true;
  }
  return false;
}"
41023,"/** 
 * Checks whether the given NodeType is a cloud provider nodeType that can be handled by the set of plugins used by the PlanBuilder.
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if the given nodeType is a cloud providernodeType
 */
public static boolean isSupportedCloudProviderNodeType(QName nodeType){
  if (nodeType.toString().equals(Types.ec2NodeType.toString()) | nodeType.toString().equals(Types.openStackNodeType.toString())) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given NodeType is a cloud provider nodeType that can be handled by the set of plugins used by the PlanBuilder.
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if the given nodeType is a cloud providernodeType
 */
public static boolean isSupportedCloudProviderNodeType(QName nodeType){
  if (nodeType.equals(Types.ec2NodeType) | nodeType.equals(Types.openStackNodeType)) {
    return true;
  }
  return false;
}"
41024,"/** 
 * Checks whether the given Node is a virtual machine nodeType that can by handled by the set of plugins used by the PlanBuilder
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if given nodeType is a virtual machine nodeType
 */
public static boolean isSupportedVMNodeType(QName nodeType){
  if (nodeType.toString().equals(Types.vmNodeType.toString())) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given Node is a virtual machine nodeType that can by handled by the set of plugins used by the PlanBuilder
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if given nodeType is a virtual machine nodeType
 */
public static boolean isSupportedVMNodeType(QName nodeType){
  if (nodeType.equals(Types.vmNodeType)) {
    return true;
  }
  return false;
}"
41025,"private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().toString().equals(this.zipArtifactType.toString())) {
    return true;
  }
 else {
    return false;
  }
}","private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().equals(this.zipArtifactType)) {
    return true;
  }
 else {
    return false;
  }
}"
41026,"private AbstractArtifactReference fetchPhpAppDA(List<AbstractDeploymentArtifact> das){
  for (  AbstractDeploymentArtifact da : das) {
    if (da.getArtifactType().toString().equals(this.zipArtifactType.toString())) {
      for (      AbstractArtifactReference ref : da.getArtifactRef().getArtifactReferences()) {
        if (ref.getReference().endsWith(""String_Node_Str"")) {
          return ref;
        }
      }
    }
  }
  return null;
}","private AbstractArtifactReference fetchPhpAppDA(List<AbstractDeploymentArtifact> das){
  for (  AbstractDeploymentArtifact da : das) {
    if (da.getArtifactType().equals(this.zipArtifactType)) {
      for (      AbstractArtifactReference ref : da.getArtifactRef().getArtifactReferences()) {
        if (ref.getReference().endsWith(""String_Node_Str"")) {
          return ref;
        }
      }
    }
  }
  return null;
}"
41027,"/** 
 * Checks whether this Plugin can handle deploying artifacts of the given artfiactType to a given InfrastructureNode of the given infrastructureNodeType
 * @param scriptArtifactType a QName denoting an scriptArtifactType
 * @param infrastructureNodeType a QName denoting an infrastructureNodeType
 * @return a Boolean. True if given pair of QName's denotes a pair whichthis plugin can handle
 */
private boolean isSupportedDeploymentPair(QName artifactType,QName infrastructureNodeType){
  if (!PluginUtils.isSupportedUbuntuVMNodeType(infrastructureNodeType)) {
    return false;
  }
  boolean isSupportedArtifactType=false;
  if (this.archiveArtifactType.toString().equals(artifactType.toString())) {
    isSupportedArtifactType|=true;
  }
  if (this.scriptArtifactType.toString().equals(artifactType.toString())) {
    isSupportedArtifactType|=true;
  }
  if (this.warArtifactType.toString().equals(artifactType.toString())) {
    isSupportedArtifactType|=true;
  }
  return isSupportedArtifactType;
}","/** 
 * Checks whether this Plugin can handle deploying artifacts of the given artfiactType to a given InfrastructureNode of the given infrastructureNodeType
 * @param scriptArtifactType a QName denoting an scriptArtifactType
 * @param infrastructureNodeType a QName denoting an infrastructureNodeType
 * @return a Boolean. True if given pair of QName's denotes a pair whichthis plugin can handle
 */
private boolean isSupportedDeploymentPair(QName artifactType,QName infrastructureNodeType){
  if (!PluginUtils.isSupportedUbuntuVMNodeType(infrastructureNodeType)) {
    return false;
  }
  boolean isSupportedArtifactType=false;
  if (this.archiveArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.scriptArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.warArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  return isSupportedArtifactType;
}"
41028,"/** 
 * {@inheritDoc}
 */
@Override public boolean canHandle(QName artifactType){
  return artifactType.toString().equals(this.baseTypeScriptArtifact.toString());
}","/** 
 * {@inheritDoc}
 */
@Override public boolean canHandle(QName artifactType){
  return artifactType.equals(this.baseTypeScriptArtifact);
}"
41029,"/** 
 * {@inheritDoc}
 */
@Override public boolean canHandle(QName artifactType){
  return artifactType.toString().equals(this.openTOSCAWar.toString());
}","/** 
 * {@inheritDoc}
 */
@Override public boolean canHandle(QName artifactType){
  return artifactType.equals(this.openTOSCAWar);
}"
41030,"/** 
 * Checks whether the given QName represents a Apache Web Server NodeType compatible with this plugin
 * @param nodeTypeId a QName denoting a TOSCA NodeType
 * @return true iff the given QName is a NodeType this plugin can handle
 */
public static boolean isApacheNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.toString().equals(Plugin.apacheNodeType.toString())) {
    return true;
  }
  if (nodeTypeId.toString().equals(Plugin.apacheNodeTypeTOSCASpecificType.toString())) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given QName represents a Apache Web Server NodeType compatible with this plugin
 * @param nodeTypeId a QName denoting a TOSCA NodeType
 * @return true iff the given QName is a NodeType this plugin can handle
 */
public static boolean isApacheNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.equals(Plugin.apacheNodeType)) {
    return true;
  }
  if (nodeTypeId.equals(Plugin.apacheNodeTypeTOSCASpecificType)) {
    return true;
  }
  return false;
}"
41031,"public static boolean isSqlScriptArtifact(AbstractDeploymentArtifact da){
  if (da.getArtifactType().toString().equals(Constants.sqlScriptArtifactType.toString())) {
    return true;
  }
  return false;
}","public static boolean isSqlScriptArtifact(AbstractDeploymentArtifact da){
  if (da.getArtifactType().equals(Constants.sqlScriptArtifactType)) {
    return true;
  }
  return false;
}"
41032,"/** 
 * Checks whether the given QName represents a MySQL Server NodeType understood by this plugin
 * @param nodeTypeId a QName
 * @return true iff the QName represents a MySQL NodeType
 */
public static boolean isCompatibleMySQLServerNodeType(QName nodeTypeId){
  return Plugin.mySqlServerNodeType.toString().equals(nodeTypeId.toString());
}","/** 
 * Checks whether the given QName represents a MySQL Server NodeType understood by this plugin
 * @param nodeTypeId a QName
 * @return true iff the QName represents a MySQL NodeType
 */
public static boolean isCompatibleMySQLServerNodeType(QName nodeTypeId){
  return Plugin.mySqlServerNodeType.equals(nodeTypeId);
}"
41033,"/** 
 * Checks whether the given QName is accepted as an ApacheWebServer Node
 * @param nodeTypeId a QName
 * @return true iff the QName represents an ApacheWebServer
 */
private boolean isApacheWebServerNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.toString().equals(this.apacheNodeType.toString())) {
    return true;
  }
  if (nodeTypeId.toString().equals(this.apacheNodeTypeTOSCASpecificType.toString())) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given QName is accepted as an ApacheWebServer Node
 * @param nodeTypeId a QName
 * @return true iff the QName represents an ApacheWebServer
 */
private boolean isApacheWebServerNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.equals(this.apacheNodeType)) {
    return true;
  }
  if (nodeTypeId.equals(this.apacheNodeTypeTOSCASpecificType)) {
    return true;
  }
  return false;
}"
41034,"/** 
 * Checks whether the given QName is accepted as an PhpModule Node
 * @param nodeTypeId a QName
 * @return true iff the QName represents an PhpModule
 */
private boolean isPhpModuleNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.toString().equals(this.phpModule.toString())) {
    return true;
  }
  if (nodeTypeId.toString().equals(this.phpModuleTOSCASpecificType.toString())) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given QName is accepted as an PhpModule Node
 * @param nodeTypeId a QName
 * @return true iff the QName represents an PhpModule
 */
private boolean isPhpModuleNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.equals(this.phpModule)) {
    return true;
  }
  if (nodeTypeId.equals(this.phpModuleTOSCASpecificType)) {
    return true;
  }
  return false;
}"
41035,"private boolean isCompatiblePhpAppNodeType(AbstractNodeType nodeType){
  if (nodeType.getId().toString().equals(this.phpApp.toString())) {
    return true;
  }
  if (nodeType.getId().toString().equals(this.phpAppNodeTypePlanBuilder.toString())) {
    return true;
  }
  QName test=nodeType.getId();
  List<QName> typesInHierarchy=Utils.getNodeTypeHierarchy(nodeType);
  for (  QName hierarchyType : typesInHierarchy) {
    if (hierarchyType.toString().equals(this.phpApp.toString()) | hierarchyType.toString().equals(this.phpAppNodeTypePlanBuilder.toString())) {
      return true;
    }
  }
  return false;
}","private boolean isCompatiblePhpAppNodeType(AbstractNodeType nodeType){
  if (nodeType.getId().equals(this.phpApp)) {
    return true;
  }
  if (nodeType.getId().equals(this.phpAppNodeTypePlanBuilder)) {
    return true;
  }
  QName test=nodeType.getId();
  List<QName> typesInHierarchy=Utils.getNodeTypeHierarchy(nodeType);
  for (  QName hierarchyType : typesInHierarchy) {
    if (hierarchyType.equals(this.phpApp) | hierarchyType.equals(this.phpAppNodeTypePlanBuilder)) {
      return true;
    }
  }
  return false;
}"
41036,"private boolean hasZipArtfiactReference(AbstractDeploymentArtifact da){
  if (da.getArtifactType().toString().equals(this.zipArtifactType.toString())) {
    for (    AbstractArtifactReference ref : da.getArtifactRef().getArtifactReferences()) {
      if (ref.getReference().endsWith(""String_Node_Str"")) {
        return true;
      }
    }
  }
  return false;
}","private boolean hasZipArtfiactReference(AbstractDeploymentArtifact da){
  if (da.getArtifactType().equals(this.zipArtifactType)) {
    for (    AbstractArtifactReference ref : da.getArtifactRef().getArtifactReferences()) {
      if (ref.getReference().endsWith(""String_Node_Str"")) {
        return true;
      }
    }
  }
  return false;
}"
41037,"private boolean isCompatiblePhpModuleNodeType(QName nodeTypeId){
  if (nodeTypeId.toString().equals(this.phpModule.toString())) {
    return true;
  }
  if (nodeTypeId.toString().equals(this.phpModuleNodeTypeTOSCASpecificType.toString())) {
    return true;
  }
  return false;
}","private boolean isCompatiblePhpModuleNodeType(QName nodeTypeId){
  if (nodeTypeId.equals(this.phpModule)) {
    return true;
  }
  if (nodeTypeId.equals(this.phpModuleNodeTypeTOSCASpecificType)) {
    return true;
  }
  return false;
}"
41038,"private boolean isCompatibleApacheWebServerNodeType(QName nodeTypeId){
  if (nodeTypeId.toString().equals(this.apacheWebServer.toString())) {
    return true;
  }
  if (nodeTypeId.toString().equals(this.apacheWebServerNodeTypeTOSCASpecificType.toString())) {
    return true;
  }
  return false;
}","private boolean isCompatibleApacheWebServerNodeType(QName nodeTypeId){
  if (nodeTypeId.equals(this.apacheWebServer)) {
    return true;
  }
  if (nodeTypeId.equals(this.apacheWebServerNodeTypeTOSCASpecificType)) {
    return true;
  }
  return false;
}"
41039,"private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().toString().equals(this.zipArtifactType.toString())) {
    return true;
  }
 else {
    return false;
  }
}","private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().equals(this.zipArtifactType)) {
    return true;
  }
 else {
    return false;
  }
}"
41040,"private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().toString().equals(this.zipArtifactType.toString())) {
    return true;
  }
 else {
    return false;
  }
}","private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().equals(this.zipArtifactType)) {
    return true;
  }
 else {
    return false;
  }
}"
41041,"/** 
 * {@inheritDoc}
 */
@Override public QName getId(){
  String namespace;
  if ((this.getTargetNamespace() != null) && !this.getTargetNamespace().equals(""String_Node_Str"")) {
    namespace=this.getTargetNamespace();
  }
 else {
    namespace=this.definitions.getTargetNamespace();
  }
  QName id=new QName(""String_Node_Str"" + namespace + ""String_Node_Str""+ this.relationshipType.getName());
  return id;
}","/** 
 * {@inheritDoc}
 */
@Override public QName getId(){
  String namespace;
  if ((this.getTargetNamespace() != null) && !this.getTargetNamespace().equals(""String_Node_Str"")) {
    namespace=this.getTargetNamespace();
  }
 else {
    namespace=this.definitions.getTargetNamespace();
  }
  QName id=new QName(namespace,this.relationshipType.getName());
  return id;
}"
41042,"public void _endpoint_show_wsdl(CommandInterpreter commandInterpreter){
  this.em.getTransaction().begin();
  Query query=this.em.createQuery(""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") List<WSDLEndpoint> queryResults=query.getResultList();
  for (  WSDLEndpoint e : queryResults) {
    commandInterpreter.println(""String_Node_Str"" + e.getCSARId());
    commandInterpreter.println(""String_Node_Str"" + e.getPortType().toString());
    commandInterpreter.println(""String_Node_Str"" + (e.getPlanId() == null ? ""String_Node_Str"" : e.getPlanId().toString()));
    commandInterpreter.println(""String_Node_Str"" + (e.getNodeTypeImplementation() == null ? ""String_Node_Str"" : e.getNodeTypeImplementation().toString()));
    commandInterpreter.println(""String_Node_Str"" + (e.getIaName() == null ? ""String_Node_Str"" : e.getIaName()));
    commandInterpreter.println(""String_Node_Str"" + e.getURI().toString());
    commandInterpreter.println(""String_Node_Str"");
  }
  this.em.getTransaction().commit();
}","public void _endpoint_show_wsdl(CommandInterpreter commandInterpreter){
  this.em.getTransaction().begin();
  Query query=this.em.createQuery(""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") List<WSDLEndpoint> queryResults=query.getResultList();
  for (  WSDLEndpoint e : queryResults) {
    commandInterpreter.println(""String_Node_Str"" + e.getCSARId());
    if (e.getPortType() != null) {
      commandInterpreter.println(""String_Node_Str"" + e.getPortType().toString());
    }
    commandInterpreter.println(""String_Node_Str"" + (e.getPlanId() == null ? ""String_Node_Str"" : e.getPlanId().toString()));
    commandInterpreter.println(""String_Node_Str"" + (e.getNodeTypeImplementation() == null ? ""String_Node_Str"" : e.getNodeTypeImplementation().toString()));
    commandInterpreter.println(""String_Node_Str"" + (e.getIaName() == null ? ""String_Node_Str"" : e.getIaName()));
    commandInterpreter.println(""String_Node_Str"" + e.getURI().toString());
    commandInterpreter.println(""String_Node_Str"");
  }
  this.em.getTransaction().commit();
}"
41043,"/** 
 * Checks whether the given Node is a virtual machine nodeType that can by handled by the set of plugins used by the PlanBuilder
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if given nodeType is a virtual machine nodeType
 */
public static boolean isSupportedVMNodeType(QName nodeType){
  if (nodeType.toString().equals(Types.vmNodeType)) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given Node is a virtual machine nodeType that can by handled by the set of plugins used by the PlanBuilder
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if given nodeType is a virtual machine nodeType
 */
public static boolean isSupportedVMNodeType(QName nodeType){
  if (nodeType.toString().equals(Types.vmNodeType.toString())) {
    return true;
  }
  return false;
}"
41044,"/** 
 * Generates BuildPlans for ServiceTemplates which don't have a BuildPlan defined inside the given Definitions document
 * @param defs an AbstractDefinitions
 * @param csarName the FileName of the CSAR the given Definitions iscontained in
 * @return a List of BuildPlans
 */
protected List<BuildPlan> buildPlans(AbstractDefinitions defs,String csarName){
  PlanBuilder planBuilder=new PlanBuilder();
  return planBuilder.buildPlans(csarName,defs);
}","/** 
 * Generates BuildPlans for ServiceTemplates, which haven't a BuildPlan defined, inside the given Definitions document
 * @param defs an AbstractDefinitions
 * @param csarName the FileName of the CSAR the given Definitions iscontained in
 * @return a List of BuildPlans
 */
public List<BuildPlan> buildPlans(AbstractDefinitions defs,String csarName){
  PlanBuilder planBuilder=new PlanBuilder();
  return planBuilder.buildPlans(csarName,defs);
}"
41045,"/** 
 * Creates a BuildPlan for the given ServiceTemplate
 * @param defs an AbstractDefinitions
 * @param csarName the File name of the CSAR the Definitions document isdefined in
 * @param serviceTemplate a QName representing a ServiceTemplate inside thegiven Definitions Document
 * @return a BuildPlan if generating a BuildPlan was successful, else null
 */
protected BuildPlan buildPlan(AbstractDefinitions defs,String csarName,QName serviceTemplate){
  PlanBuilder planBuilder=new PlanBuilder();
  return planBuilder.buildPlan(csarName,defs,serviceTemplate);
}","/** 
 * Creates a BuildPlan for the given ServiceTemplate
 * @param defs an AbstractDefinitions
 * @param csarName the File name of the CSAR the Definitions document isdefined in
 * @param serviceTemplate a QName representing a ServiceTemplate inside thegiven Definitions Document
 * @return a BuildPlan if generating a BuildPlan was successful, else null
 */
public BuildPlan buildPlan(AbstractDefinitions defs,String csarName,QName serviceTemplate){
  PlanBuilder planBuilder=new PlanBuilder();
  return planBuilder.buildPlan(csarName,defs,serviceTemplate);
}"
41046,"/** 
 * Stores a CSAR given as file object
 * @param file File referencing a CSAR
 * @return an Object representing an ID of the stored CSAR, if somethingwent wrong null is returned instead
 * @throws SystemException
 * @throws UserException
 */
public Object storeCSAR(File file) throws UserException, SystemException {
  CSARHandler.LOG.debug(""String_Node_Str"");
  BundleContext bundleContext=FrameworkUtil.getBundle(this.getClass()).getBundleContext();
  CSARHandler.LOG.debug(""String_Node_Str"");
  ServiceReference<?> fileServiceRef=bundleContext.getServiceReference(ICoreFileService.class.getName());
  CSARHandler.LOG.debug(""String_Node_Str"");
  ICoreFileService fileService=(ICoreFileService)bundleContext.getService(fileServiceRef);
  CSARHandler.LOG.debug(""String_Node_Str"");
  CSARID csarId=fileService.storeCSAR(file.toPath());
  if (csarId == null) {
    CSARHandler.LOG.warn(""String_Node_Str"");
    return null;
  }
  CSARHandler.LOG.info(""String_Node_Str"");
  return csarId;
}","/** 
 * Stores a CSAR given as file object
 * @param file File referencing a CSAR
 * @return an Object representing an ID of the stored CSAR, if somethingwent wrong null is returned instead
 * @throws SystemException
 * @throws UserException
 */
public Object storeCSAR(File file) throws UserException, SystemException {
  CSARHandler.LOG.debug(""String_Node_Str"");
  ICoreFileService fileService=this.fetchCoreFileService();
  CSARID csarId=fileService.storeCSAR(file.toPath());
  if (csarId == null) {
    CSARHandler.LOG.warn(""String_Node_Str"");
    return null;
  }
  CSARHandler.LOG.info(""String_Node_Str"");
  return csarId;
}"
41047,"/** 
 * Returns a CSARContent Object for the given CSARID
 * @param id a CSARID
 * @return the CSARContent for the given CSARID
 * @throws UserException is thrown when something inside the OpenTOSCA Corefails
 */
public CSARContent getCSARContentForID(CSARID id) throws UserException {
  CSARHandler.LOG.debug(""String_Node_Str"");
  BundleContext bundleContext=FrameworkUtil.getBundle(this.getClass()).getBundleContext();
  CSARHandler.LOG.debug(""String_Node_Str"");
  ServiceReference<?> fileServiceRef=bundleContext.getServiceReference(ICoreFileService.class.getName());
  CSARHandler.LOG.debug(""String_Node_Str"");
  ICoreFileService fileService=(ICoreFileService)bundleContext.getService(fileServiceRef);
  return fileService.getCSAR(id);
}","/** 
 * Returns a CSARContent Object for the given CSARID
 * @param id a CSARID
 * @return the CSARContent for the given CSARID
 * @throws UserException is thrown when something inside the OpenTOSCA Core fails
 */
public CSARContent getCSARContentForID(CSARID id) throws UserException {
  LOG.debug(""String_Node_Str"");
  return this.fetchCoreFileService().getCSAR(id);
}"
41048,"/** 
 * Deletes all CSARs in the OpenTOSCA Core
 */
public void deleteAllCsars(){
  CSARHandler.LOG.debug(""String_Node_Str"");
  BundleContext bundleContext=FrameworkUtil.getBundle(this.getClass()).getBundleContext();
  CSARHandler.LOG.debug(""String_Node_Str"");
  ServiceReference<?> fileServiceRef=bundleContext.getServiceReference(ICoreFileService.class.getName());
  CSARHandler.LOG.debug(""String_Node_Str"");
  ICoreFileService fileService=(ICoreFileService)bundleContext.getService(fileServiceRef);
  CSARHandler.LOG.info(""String_Node_Str"");
  try {
    fileService.deleteCSARs();
  }
 catch (  SystemException e) {
  }
}","/** 
 * Deletes all CSARs in the OpenTOSCA Core
 */
public void deleteAllCsars(){
  CSARHandler.LOG.info(""String_Node_Str"");
  ICoreFileService fileService=this.fetchCoreFileService();
  try {
    fileService.deleteCSARs();
  }
 catch (  SystemException e) {
  }
}"
41049,"/** 
 * Adds a copy from a String variable to the specified Element inside the output message of the given BuildPlan
 * @param variableName the variableName of the given BuildPlan the valueshould be assigned from
 * @param outputElementName the Element LocalName inside the outputMessageof the BuildPlan
 * @param buildPlan the BuildPlan to add the copy to
 * @return true if adding the copy was successful, else false
 */
public boolean assginOutputWithVariableValue(String variableName,String outputElementName,BuildPlan buildPlan){
  BPELProcessHandler.LOG.debug(""String_Node_Str"",variableName,outputElementName,buildPlan.getBpelProcessElement().getAttribute(""String_Node_Str""));
  Element outputAssignElement=buildPlan.getBpelMainSequenceOutputAssignElement();
  Element copyElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element fromElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element toElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element queryElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  CDATASection cdataSection=buildPlan.getBpelDocument().createCDATASection(""String_Node_Str"" + outputElementName);
  fromElement.setAttribute(""String_Node_Str"",variableName);
  toElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  toElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  queryElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  queryElement.appendChild(cdataSection);
  toElement.appendChild(cdataSection);
  copyElement.appendChild(fromElement);
  copyElement.appendChild(toElement);
  outputAssignElement.appendChild(copyElement);
  BPELProcessHandler.LOG.debug(""String_Node_Str"");
  return true;
}","/** 
 * Adds a copy from a String variable to the specified Element inside the output message of the given BuildPlan
 * @param variableName the variableName of the given BuildPlan the valueshould be assigned from
 * @param outputElementName the Element LocalName inside the outputMessageof the BuildPlan
 * @param buildPlan the BuildPlan to add the copy to
 * @return true if adding the copy was successful, else false
 */
public boolean assginOutputWithVariableValue(String variableName,String outputElementName,BuildPlan buildPlan){
  BPELProcessHandler.LOG.debug(""String_Node_Str"",variableName,outputElementName,buildPlan.getBpelProcessElement().getAttribute(""String_Node_Str""));
  Element outputAssignElement=buildPlan.getBpelMainSequenceOutputAssignElement();
  Element copyElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element fromElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element toElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element queryElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  CDATASection cdataSection=buildPlan.getBpelDocument().createCDATASection(""String_Node_Str"" + outputElementName);
  fromElement.setAttribute(""String_Node_Str"",variableName);
  toElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  toElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  queryElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  queryElement.appendChild(cdataSection);
  toElement.appendChild(queryElement);
  copyElement.appendChild(fromElement);
  copyElement.appendChild(toElement);
  outputAssignElement.appendChild(copyElement);
  BPELProcessHandler.LOG.debug(""String_Node_Str"");
  return true;
}"
41050,"/** 
 * Initializes Property variables for the given TemplateBuildPlan which handles a NodeTemplate
 * @param map a PropertyMap to save the result/mappings to
 * @param templatePlan a TemplateBuildPlan which handles a NodeTemplate
 */
private void initPropsAsVarsInNode(PropertyMap map,TemplateBuildPlan templatePlan){
  AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
  if (nodeTemplate.getProperties() != null) {
    Element propertyElement=nodeTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      String propName=propertyElement.getChildNodes().item(i).getLocalName();
      String propVarName=nodeTemplate.getId() + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(nodeTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      if (!value.trim().isEmpty() && !value.trim().equals(""String_Node_Str"")) {
        this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
      }
    }
  }
}","/** 
 * Initializes Property variables for the given TemplateBuildPlan which handles a NodeTemplate
 * @param map a PropertyMap to save the result/mappings to
 * @param templatePlan a TemplateBuildPlan which handles a NodeTemplate
 */
private void initPropsAsVarsInNode(PropertyMap map,TemplateBuildPlan templatePlan){
  AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
  if (nodeTemplate.getProperties() != null) {
    Element propertyElement=nodeTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      String propName=propertyElement.getChildNodes().item(i).getLocalName();
      String propVarName=nodeTemplate.getId() + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(nodeTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
    }
  }
}"
41051,"/** 
 * {@inheritDoc}
 */
@Override public AbstractProperties getProperties(){
  return new PropertiesImpl(this.properties.getAny());
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractProperties getProperties(){
  if (this.properties.getAny() != null) {
    return new PropertiesImpl(this.properties.getAny());
  }
 else {
    return null;
  }
}"
41052,"/** 
 * Exports the given BuildPlans repackaged with the CSAR denoted by the given CSARID
 * @param buildPlans the BuildPlans to export
 * @param csarId the CSARID of a CSAR
 * @return a File denoting the absolute Path to the exported CSAR
 */
public File export(List<BuildPlan> buildPlans,CSARID csarId){
  CSARContent csarContent=null;
  try {
    csarContent=this.handler.getCSARContentForID(csarId);
  }
 catch (  UserException e1) {
    Exporter.LOG.error(""String_Node_Str"",e1);
  }
  if (csarContent == null) {
    return null;
  }
  String csarName=csarId.getFileName();
  IFileAccessService service=this.getFileAccessService();
  File tempDir=service.getTemp();
  File pathToRepackagedCsar=service.getTemp();
  File repackagedCsar=new File(pathToRepackagedCsar,csarName);
  try {
    Set<AbstractFile> files=csarContent.getFilesRecursively();
    AbstractFile mainDefFile=csarContent.getRootTOSCA();
    File rootDefFile=mainDefFile.getFile().toFile();
    Definitions defs=this.parseDefinitionsFile(rootDefFile);
    List<TServiceTemplate> servTemps=this.getServiceTemplates(defs);
    List<BuildPlan> plansToExport=new ArrayList<BuildPlan>();
    for (    BuildPlan buildPlan : buildPlans) {
      for (      TServiceTemplate serviceTemplate : servTemps) {
        if (buildPlan.getServiceTemplate().toString().equals(this.buildQName(defs,serviceTemplate).toString())) {
          TPlans plans=serviceTemplate.getPlans();
          if (plans == null) {
            plans=this.toscaFactory.createTPlans();
            serviceTemplate.setPlans(plans);
          }
          List<TPlan> planList=plans.getPlan();
          planList.add(this.generateTPlanElement(buildPlan));
          plansToExport.add(buildPlan);
        }
      }
    }
    for (    AbstractFile file : files) {
      if (file.getFile().toFile().toString().equals(rootDefFile.toString())) {
        continue;
      }
      File newLocation=new File(tempDir,file.getPath());
      Exporter.LOG.debug(newLocation.getAbsolutePath());
      Exporter.LOG.debug(file.getFile().toString());
      if (newLocation.isDirectory()) {
        FileUtils.copyDirectory(file.getFile().toFile(),newLocation);
      }
 else {
        FileUtils.copyFile(file.getFile().toFile(),newLocation);
      }
    }
    File newDefsFile=new File(tempDir,mainDefFile.getPath());
    newDefsFile.createNewFile();
    JAXBContext jaxbContext=JAXBContext.newInstance(Definitions.class);
    Marshaller m=jaxbContext.createMarshaller();
    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
    m.marshal(defs,newDefsFile);
    for (    BuildPlan plan : plansToExport) {
      File planPath=new File(tempDir,this.generateRelativePlanPath(plan));
      Exporter.LOG.debug(planPath.toString());
      planPath.getParentFile().mkdirs();
      planPath.createNewFile();
      this.simpleExporter.export(planPath.toURI(),plan);
    }
    File selfServiceDir=new File(tempDir,""String_Node_Str"");
    File selfServiceDataXml=new File(selfServiceDir,""String_Node_Str"");
    JAXBContext jaxbContextWineryApplication=JAXBContext.newInstance(Application.class);
    if (selfServiceDir.exists() && selfServiceDataXml.exists()) {
      Unmarshaller u=jaxbContextWineryApplication.createUnmarshaller();
      Application appDesc=(Application)u.unmarshal(selfServiceDataXml);
      for (      ApplicationOption option : appDesc.getOptions().getOption()) {
        for (        BuildPlan plan : plansToExport) {
          if (option.getPlanServiceName().equals(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart())) {
            if (!new File(selfServiceDir,option.getPlanInputMessageUrl()).exists()) {
              File planInputFile=new File(selfServiceDir,option.getPlanInputMessageUrl());
              this.writePlanInputMessageInstance(plan,planInputFile);
            }
          }
        }
      }
    }
 else {
      if (selfServiceDir.mkdirs() && selfServiceDataXml.createNewFile()) {
        Application appDesc=new Application();
        appDesc.setDisplayName(csarName);
        appDesc.setDescription(""String_Node_Str"");
        appDesc.setIconUrl(""String_Node_Str"");
        appDesc.setImageUrl(""String_Node_Str"");
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
  }
 catch (  IOException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  JAXBException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  SystemException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
  service.zip(tempDir,repackagedCsar);
  Exporter.LOG.debug(repackagedCsar.toString());
  return repackagedCsar;
}","/** 
 * Exports the given BuildPlans repackaged with the CSAR denoted by the given CSARID
 * @param buildPlans the BuildPlans to export
 * @param csarId the CSARID of a CSAR
 * @return a File denoting the absolute Path to the exported CSAR
 */
public File export(List<BuildPlan> buildPlans,CSARID csarId){
  CSARContent csarContent=null;
  try {
    csarContent=this.handler.getCSARContentForID(csarId);
  }
 catch (  UserException e1) {
    Exporter.LOG.error(""String_Node_Str"",e1);
  }
  if (csarContent == null) {
    return null;
  }
  String csarName=csarId.getFileName();
  IFileAccessService service=this.getFileAccessService();
  File tempDir=service.getTemp();
  File pathToRepackagedCsar=service.getTemp();
  File repackagedCsar=new File(pathToRepackagedCsar,csarName);
  try {
    Set<AbstractFile> files=csarContent.getFilesRecursively();
    AbstractFile mainDefFile=csarContent.getRootTOSCA();
    File rootDefFile=mainDefFile.getFile().toFile();
    Definitions defs=this.parseDefinitionsFile(rootDefFile);
    List<TServiceTemplate> servTemps=this.getServiceTemplates(defs);
    List<BuildPlan> plansToExport=new ArrayList<BuildPlan>();
    for (    BuildPlan buildPlan : buildPlans) {
      for (      TServiceTemplate serviceTemplate : servTemps) {
        if (buildPlan.getServiceTemplate().toString().equals(this.buildQName(defs,serviceTemplate).toString())) {
          TPlans plans=serviceTemplate.getPlans();
          if (plans == null) {
            plans=this.toscaFactory.createTPlans();
            serviceTemplate.setPlans(plans);
          }
          List<TPlan> planList=plans.getPlan();
          planList.add(this.generateTPlanElement(buildPlan));
          plansToExport.add(buildPlan);
        }
      }
    }
    for (    AbstractFile file : files) {
      if (file.getFile().toFile().toString().equals(rootDefFile.toString())) {
        continue;
      }
      File newLocation=new File(tempDir,file.getPath());
      Exporter.LOG.debug(newLocation.getAbsolutePath());
      Exporter.LOG.debug(file.getFile().toString());
      if (newLocation.isDirectory()) {
        FileUtils.copyDirectory(file.getFile().toFile(),newLocation);
      }
 else {
        FileUtils.copyFile(file.getFile().toFile(),newLocation);
      }
    }
    File newDefsFile=new File(tempDir,mainDefFile.getPath());
    newDefsFile.createNewFile();
    JAXBContext jaxbContext=JAXBContext.newInstance(Definitions.class);
    Marshaller m=jaxbContext.createMarshaller();
    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
    m.marshal(defs,newDefsFile);
    for (    BuildPlan plan : plansToExport) {
      File planPath=new File(tempDir,this.generateRelativePlanPath(plan));
      Exporter.LOG.debug(planPath.toString());
      planPath.getParentFile().mkdirs();
      planPath.createNewFile();
      this.simpleExporter.export(planPath.toURI(),plan);
    }
    File selfServiceDir=new File(tempDir,""String_Node_Str"");
    File selfServiceDataXml=new File(selfServiceDir,""String_Node_Str"");
    JAXBContext jaxbContextWineryApplication=JAXBContext.newInstance(Application.class);
    if (selfServiceDir.exists() && selfServiceDataXml.exists()) {
      Unmarshaller u=jaxbContextWineryApplication.createUnmarshaller();
      Application appDesc=(Application)u.unmarshal(selfServiceDataXml);
      if (appDesc.getOptions() != null) {
        for (        ApplicationOption option : appDesc.getOptions().getOption()) {
          for (          BuildPlan plan : plansToExport) {
            if (option.getPlanServiceName().equals(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart())) {
              if (!new File(selfServiceDir,option.getPlanInputMessageUrl()).exists()) {
                File planInputFile=new File(selfServiceDir,option.getPlanInputMessageUrl());
                this.writePlanInputMessageInstance(plan,planInputFile);
              }
            }
          }
        }
      }
 else {
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
 else {
      if (selfServiceDir.mkdirs() && selfServiceDataXml.createNewFile()) {
        Application appDesc=new Application();
        appDesc.setDisplayName(csarName);
        appDesc.setDescription(""String_Node_Str"");
        appDesc.setIconUrl(""String_Node_Str"");
        appDesc.setImageUrl(""String_Node_Str"");
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
  }
 catch (  IOException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  JAXBException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  SystemException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
  service.zip(tempDir,repackagedCsar);
  Exporter.LOG.debug(repackagedCsar.toString());
  return repackagedCsar;
}"
41053,"/** 
 * Initializes the internal IAs
 */
private void initIas(){
  for (  TImplementationArtifact artifact : this.nodeTypeImpl.getImplementationArtifacts().getImplementationArtifact()) {
    this.ias.add(new ImplementationArtifactImpl(artifact,this.definitions));
  }
}","/** 
 * Initializes the internal IAs
 */
private void initIas(){
  if (this.nodeTypeImpl.getImplementationArtifacts() != null) {
    for (    TImplementationArtifact artifact : this.nodeTypeImpl.getImplementationArtifacts().getImplementationArtifact()) {
      this.ias.add(new ImplementationArtifactImpl(artifact,this.definitions));
    }
  }
}"
41054,"/** 
 * {@inheritDoc}
 */
@Override public QName getTypeRef(){
  if (this.relationshipType.getDerivedFrom() != null) {
    for (    AbstractRelationshipType relation : this.definitions.getAllRelationshipTypes()) {
      if (relation.getId().toString().equals(this.relationshipType.getDerivedFrom().getTypeRef().toString())) {
        return relation.getTypeRef();
      }
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public QName getTypeRef(){
  if (this.relationshipType.getDerivedFrom() != null) {
    return this.relationshipType.getDerivedFrom().getTypeRef();
  }
  return null;
}"
41055,"void getRealmAuctionFileInformation(Realm realm){
  getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + realm.getRealmDetail());
  Client client=ClientBuilder.newClient();
  Files files=client.target(target + realm.getSlug()).request(MediaType.TEXT_PLAIN).get(Files.class);
  files.getFiles().forEach(auctionFile -> createAuctionFile(realm,auctionFile));
}","void getRealmAuctionFileInformation(Realm realm){
  getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + realm.getRealmDetail());
  try {
    Client client=ClientBuilder.newClient();
    Files files=client.target(target + realm.getSlug()).request(MediaType.TEXT_PLAIN).get(Files.class);
    files.getFiles().forEach(auctionFile -> createAuctionFile(realm,auctionFile));
  }
 catch (  Exception e) {
    getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + realm.getRealmDetail());
  }
}"
41056,"@Override @SuppressWarnings(""String_Node_Str"") public Object processItem(Object item) throws Exception {
  ResultSet resultSet=(ResultSet)item;
  AuctionItemStatistics auctionItemStatistics=new AuctionItemStatistics();
  auctionItemStatistics.setItemId(resultSet.getInt(1));
  auctionItemStatistics.setQuantity(resultSet.getLong(2));
  auctionItemStatistics.setBid(resultSet.getLong(3));
  auctionItemStatistics.setBuyout(resultSet.getLong(4));
  auctionItemStatistics.setMinBid(resultSet.getLong(5));
  auctionItemStatistics.setMinBuyout(resultSet.getLong(6));
  auctionItemStatistics.setMaxBid(resultSet.getLong(7));
  auctionItemStatistics.setMaxBuyout(resultSet.getLong(8));
  auctionItemStatistics.setTimestamp(getContext().getFileToProcess().getLastModified());
  auctionItemStatistics.setAvgBid((double)(auctionItemStatistics.getBid() / auctionItemStatistics.getQuantity()));
  auctionItemStatistics.setAvgBuyout((double)(auctionItemStatistics.getBuyout() / auctionItemStatistics.getQuantity()));
  auctionItemStatistics.setAuctionHouse(AuctionHouse.valueOf(auctionHouse));
  return auctionItemStatistics;
}","@Override @SuppressWarnings(""String_Node_Str"") public Object processItem(Object item) throws Exception {
  ResultSet resultSet=(ResultSet)item;
  AuctionItemStatistics auctionItemStatistics=new AuctionItemStatistics();
  auctionItemStatistics.setItemId(resultSet.getInt(1));
  auctionItemStatistics.setQuantity(resultSet.getLong(2));
  auctionItemStatistics.setBid(resultSet.getLong(3));
  auctionItemStatistics.setBuyout(resultSet.getLong(4));
  auctionItemStatistics.setMinBid(resultSet.getLong(5));
  auctionItemStatistics.setMinBuyout(resultSet.getLong(6));
  auctionItemStatistics.setMaxBid(resultSet.getLong(7));
  auctionItemStatistics.setMaxBuyout(resultSet.getLong(8));
  auctionItemStatistics.setTimestamp(getContext().getFileToProcess().getLastModified());
  auctionItemStatistics.setAvgBid((double)(auctionItemStatistics.getBid() / auctionItemStatistics.getQuantity()));
  auctionItemStatistics.setAvgBuyout((double)(auctionItemStatistics.getBuyout() / auctionItemStatistics.getQuantity()));
  auctionItemStatistics.setAuctionHouse(AuctionHouse.valueOf(auctionHouse));
  auctionItemStatistics.setRealm(getContext().getRealm());
  return auctionItemStatistics;
}"
41057,"@Override public void open(Serializable checkpoint) throws Exception {
  Connection connection=dataSource.getConnection();
  preparedStatement=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY,ResultSet.HOLD_CURSORS_OVER_COMMIT);
  preparedStatement.setLong(1,getContext().getFileToProcess().getId());
  preparedStatement.setInt(2,AuctionHouse.valueOf(auctionHouse).ordinal());
  resultSet=preparedStatement.executeQuery();
}","@Override public void open(Serializable checkpoint) throws Exception {
  Connection connection=dataSource.getConnection();
  preparedStatement=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + getContext().getFileToProcess().getId() + ""String_Node_Str""+ AuctionHouse.valueOf(auctionHouse).ordinal()+ ""String_Node_Str""+ ""String_Node_Str"",ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY,ResultSet.HOLD_CURSORS_OVER_COMMIT);
  resultSet=preparedStatement.executeQuery();
}"
41058,"@Override @GET @Path(""String_Node_Str"") public List<AuctionItemStatistics> findAuctionItemStatisticsByRealmAndItem(@QueryParam(""String_Node_Str"") Long realmId,@QueryParam(""String_Node_Str"") Integer itemId){
  return em.createNamedQuery(""String_Node_Str"").setParameter(""String_Node_Str"",itemId).getResultList();
}","@Override @GET @Path(""String_Node_Str"") public List<AuctionItemStatistics> findAuctionItemStatisticsByRealmAndItem(@QueryParam(""String_Node_Str"") Long realmId,@QueryParam(""String_Node_Str"") Integer itemId){
  return em.createNamedQuery(""String_Node_Str"").setParameter(""String_Node_Str"",realmId).setParameter(""String_Node_Str"",itemId).getResultList();
}"
41059,"private void getRealmAuctionFileInformation(Realm realm){
  getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + realm.getRealmDetail());
  Client client=ClientBuilder.newClient();
  Files files=client.target(target + realm.getSlug()).request(MediaType.TEXT_PLAIN).get(Files.class);
  files.getFiles().forEach(auctionFile -> {
    auctionFile.setRealm(realm);
    auctionFile.setFileStatus(FileStatus.LOADED);
    woWBusiness.createAuctionFile(auctionFile);
  }
);
}","private void getRealmAuctionFileInformation(Realm realm){
  getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + realm.getRealmDetail());
  Client client=ClientBuilder.newClient();
  Files files=client.target(target + realm.getSlug()).request(MediaType.TEXT_PLAIN).get(Files.class);
  files.getFiles().forEach(auctionFile -> {
    auctionFile.setRealm(realm);
    auctionFile.setFileName(""String_Node_Str"" + auctionFile.getLastModified() + ""String_Node_Str"");
    auctionFile.setFileStatus(FileStatus.LOADED);
    woWBusiness.createAuctionFile(auctionFile);
  }
);
}"
41060,"private void verifyAndCreateFolder(String folderRoot,Realm realm,FolderType folderType){
  File folder=new File(batchHome + ""String_Node_Str"" + folderRoot+ ""String_Node_Str""+ realm.getName()+ ""String_Node_Str""+ folderType);
  if (!folder.exists()) {
    try {
      getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + folder);
      FileUtils.forceMkdir(folder);
      woWBusiness.createRealmFolder(new RealmFolder(realm.getId(),folderType,folder.getPath()));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 else   if (woWBusiness.findRealmFolderById(realm.getId(),folderType) == null) {
    woWBusiness.createRealmFolder(new RealmFolder(realm.getId(),folderType,folder.getPath()));
  }
}","private void verifyAndCreateFolder(String folderRoot,Realm realm,FolderType folderType){
  File folder=new File(batchHome + ""String_Node_Str"" + folderRoot+ ""String_Node_Str""+ realm.getRegion()+ ""String_Node_Str""+ realm.getName()+ ""String_Node_Str""+ folderType);
  if (!folder.exists()) {
    try {
      getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + folder);
      FileUtils.forceMkdir(folder);
      woWBusiness.createRealmFolder(new RealmFolder(realm.getId(),folderType,folder.getPath()));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 else   if (woWBusiness.findRealmFolderById(realm.getId(),folderType) == null) {
    woWBusiness.createRealmFolder(new RealmFolder(realm.getId(),folderType,folder.getPath()));
  }
}"
41061,"@Test(timeout=20000) public void testRemotelyCloseSessionAndAttemptAsyncCompletionSendThrowsAndLeavesMessageReadable() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    JmsConnection connection=(JmsConnection)testFixture.establishConnecton(testPeer);
    final CountDownLatch sessionClosed=new CountDownLatch(1);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onSessionClosed(      Session session,      Throwable cause){
        sessionClosed.countDown();
      }
    }
);
    testPeer.expectBegin();
    testPeer.expectSenderAttach();
    testPeer.remotelyEndLastOpenedSession(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    Message message=session.createTextMessage(""String_Node_Str"");
    message.setIntProperty(""String_Node_Str"",1);
    assertNull(""String_Node_Str"",message.getJMSDestination());
    testPeer.waitForAllHandlersToComplete(100);
    assertTrue(""String_Node_Str"",sessionClosed.await(2,TimeUnit.SECONDS));
    TestJmsCompletionListener listener=new TestJmsCompletionListener();
    try {
      producer.send(message,listener);
      fail(""String_Node_Str"");
    }
 catch (    JMSException e) {
      LOG.warn(""String_Node_Str"",e.getMessage());
    }
    assertFalse(""String_Node_Str"",listener.awaitCompletion(5,TimeUnit.MILLISECONDS));
    assertNull(""String_Node_Str"",message.getJMSDestination());
    assertEquals(""String_Node_Str"",""String_Node_Str"",((TextMessage)message).getText());
    assertEquals(""String_Node_Str"",1,message.getIntProperty(""String_Node_Str""));
    testPeer.expectClose();
    connection.close();
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","@Test(timeout=20000) public void testRemotelyCloseSessionAndAttemptAsyncCompletionSendThrowsAndLeavesMessageReadable() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    JmsConnection connection=(JmsConnection)testFixture.establishConnecton(testPeer);
    final CountDownLatch sessionClosed=new CountDownLatch(1);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onSessionClosed(      Session session,      Throwable cause){
        sessionClosed.countDown();
      }
    }
);
    testPeer.expectBegin();
    testPeer.expectSenderAttach();
    testPeer.remotelyEndLastOpenedSession(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    Message message=session.createTextMessage(""String_Node_Str"");
    message.setIntProperty(""String_Node_Str"",1);
    assertNull(""String_Node_Str"",message.getJMSDestination());
    MessageProducer producer=session.createProducer(queue);
    testPeer.waitForAllHandlersToComplete(100);
    assertTrue(""String_Node_Str"",sessionClosed.await(2,TimeUnit.SECONDS));
    TestJmsCompletionListener listener=new TestJmsCompletionListener();
    try {
      producer.send(message,listener);
      fail(""String_Node_Str"");
    }
 catch (    JMSException e) {
      LOG.trace(""String_Node_Str"",e.getMessage());
    }
    assertFalse(""String_Node_Str"",listener.awaitCompletion(5,TimeUnit.MILLISECONDS));
    assertNull(""String_Node_Str"",message.getJMSDestination());
    assertEquals(""String_Node_Str"",""String_Node_Str"",((TextMessage)message).getText());
    assertEquals(""String_Node_Str"",1,message.getIntProperty(""String_Node_Str""));
    testPeer.expectClose();
    connection.close();
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41062,"@Test(timeout=20000) public void testRemotelyCloseProducerAndAttemptAsyncCompletionSendThrowsAndLeavesMessageReadable() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    JmsConnection connection=(JmsConnection)testFixture.establishConnecton(testPeer);
    final CountDownLatch producerClosed=new CountDownLatch(1);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onProducerClosed(      MessageProducer producer,      Throwable cause){
        producerClosed.countDown();
      }
    }
);
    testPeer.expectBegin();
    testPeer.expectSenderAttach();
    testPeer.remotelyDetachLastOpenedLinkOnLastOpenedSession(true,true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    Message message=session.createTextMessage(""String_Node_Str"");
    message.setIntProperty(""String_Node_Str"",1);
    assertNull(""String_Node_Str"",message.getJMSDestination());
    testPeer.waitForAllHandlersToComplete(100);
    assertTrue(""String_Node_Str"",producerClosed.await(2,TimeUnit.SECONDS));
    TestJmsCompletionListener listener=new TestJmsCompletionListener();
    try {
      producer.send(message,listener);
      fail(""String_Node_Str"");
    }
 catch (    JMSException e) {
      LOG.warn(""String_Node_Str"",e.getMessage());
    }
    assertFalse(""String_Node_Str"",listener.awaitCompletion(5,TimeUnit.MILLISECONDS));
    assertNull(""String_Node_Str"",message.getJMSDestination());
    assertEquals(""String_Node_Str"",""String_Node_Str"",((TextMessage)message).getText());
    assertEquals(""String_Node_Str"",1,message.getIntProperty(""String_Node_Str""));
    testPeer.expectClose();
    connection.close();
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","@Test(timeout=20000) public void testRemotelyCloseProducerAndAttemptAsyncCompletionSendThrowsAndLeavesMessageReadable() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    JmsConnection connection=(JmsConnection)testFixture.establishConnecton(testPeer);
    final CountDownLatch producerClosed=new CountDownLatch(1);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onProducerClosed(      MessageProducer producer,      Throwable cause){
        producerClosed.countDown();
      }
    }
);
    testPeer.expectBegin();
    testPeer.expectSenderAttach();
    testPeer.remotelyDetachLastOpenedLinkOnLastOpenedSession(true,true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    Message message=session.createTextMessage(""String_Node_Str"");
    message.setIntProperty(""String_Node_Str"",1);
    assertNull(""String_Node_Str"",message.getJMSDestination());
    MessageProducer producer=session.createProducer(queue);
    testPeer.waitForAllHandlersToComplete(100);
    assertTrue(""String_Node_Str"",producerClosed.await(2,TimeUnit.SECONDS));
    TestJmsCompletionListener listener=new TestJmsCompletionListener();
    try {
      producer.send(message,listener);
      fail(""String_Node_Str"");
    }
 catch (    JMSException e) {
      LOG.trace(""String_Node_Str"",e.getMessage());
    }
    assertFalse(""String_Node_Str"",listener.awaitCompletion(5,TimeUnit.MILLISECONDS));
    assertNull(""String_Node_Str"",message.getJMSDestination());
    assertEquals(""String_Node_Str"",""String_Node_Str"",((TextMessage)message).getText());
    assertEquals(""String_Node_Str"",1,message.getIntProperty(""String_Node_Str""));
    testPeer.expectClose();
    connection.close();
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41063,"@Override public int getPriority(){
  return PRIORITY.LOWEST.getValue();
}","@Override public int getPriority(){
  return PRIORITY.LOWER_STILL.getValue();
}"
41064,"/** 
 * Process the SASL authentication cycle until such time as an outcome is determine. This method must be called by the managing entity until the return value is true indicating a successful authentication or a JMSSecurityException is thrown indicating that the handshake failed.
 * @param authenticationRequest The request that is awaiting the result of authentication.
 * @return true if the authentication process completed.
 */
public boolean authenticate() throws JMSSecurityException {
  try {
switch (sasl.getState()) {
case PN_SASL_IDLE:
      handleSaslInit();
    break;
case PN_SASL_STEP:
  handleSaslStep();
break;
case PN_SASL_FAIL:
handleSaslFail();
break;
case PN_SASL_PASS:
authenticationRequest.onSuccess();
default :
break;
}
}
 catch (JMSSecurityException result) {
authenticationRequest.onFailure(result);
}
return authenticationRequest.isComplete();
}","/** 
 * Process the SASL authentication cycle until such time as an outcome is determine. This method must be called by the managing entity until the return value is true indicating a successful authentication or a JMSSecurityException is thrown indicating that the handshake failed.
 * @return true if the authentication process completed.
 */
public boolean authenticate() throws JMSSecurityException {
  try {
switch (sasl.getState()) {
case PN_SASL_IDLE:
      handleSaslInit();
    break;
case PN_SASL_STEP:
  handleSaslStep();
break;
case PN_SASL_FAIL:
handleSaslFail();
break;
case PN_SASL_PASS:
authenticationRequest.onSuccess();
default :
break;
}
}
 catch (JMSSecurityException result) {
authenticationRequest.onFailure(result);
}
return authenticationRequest.isComplete();
}"
41065,"/** 
 * When a redirect type exception is received this method is called to create the appropriate redirect exception type containing the error details needed.
 * @param error the Symbol that defines the redirection error type.
 * @param message the basic error message that should used or amended for the returned exception.
 * @param condition the ErrorCondition that describes the redirection.
 * @return an Exception that captures the details of the redirection error.
 */
public static Exception createRedirectException(Symbol error,String message,ErrorCondition condition){
  Exception result=null;
  Map<?,?> info=condition.getInfo();
  if (info == null) {
    result=new IOException(message + ""String_Node_Str"");
  }
 else {
    String hostname=(String)info.get(OPEN_HOSTNAME);
    String networkHost=(String)info.get(NETWORK_HOST);
    if (networkHost == null || networkHost.isEmpty()) {
      result=new IOException(message + ""String_Node_Str"");
    }
    int port=0;
    try {
      port=Integer.valueOf(info.get(PORT).toString());
    }
 catch (    Exception ex) {
      result=new IOException(message + ""String_Node_Str"");
    }
    result=new ProviderRedirectedException(message,hostname,networkHost,port);
  }
  return result;
}","/** 
 * When a redirect type exception is received this method is called to create the appropriate redirect exception type containing the error details needed.
 * @param error the Symbol that defines the redirection error type.
 * @param message the basic error message that should used or amended for the returned exception.
 * @param condition the ErrorCondition that describes the redirection.
 * @return an Exception that captures the details of the redirection error.
 */
public static Exception createRedirectException(Symbol error,String message,ErrorCondition condition){
  Exception result=null;
  Map<?,?> info=condition.getInfo();
  if (info == null) {
    result=new IOException(message + ""String_Node_Str"");
  }
 else {
    String hostname=(String)info.get(OPEN_HOSTNAME);
    String networkHost=(String)info.get(NETWORK_HOST);
    if (networkHost == null || networkHost.isEmpty()) {
      result=new IOException(message + ""String_Node_Str"");
    }
    int port=0;
    try {
      port=Integer.parseInt(info.get(PORT).toString());
    }
 catch (    Exception ex) {
      result=new IOException(message + ""String_Node_Str"");
    }
    result=new ProviderRedirectedException(message,hostname,networkHost,port);
  }
  return result;
}"
41066,"@Override public void processDeliveryUpdates(AmqpProvider provider) throws IOException {
  try {
    if (pendingDelivery != null && pendingDelivery.remotelySettled()) {
      DeliveryState state=pendingDelivery.getRemoteState();
      JmsTransactionId txId=(JmsTransactionId)pendingDelivery.getContext();
      if (state instanceof Declared) {
        LOG.debug(""String_Node_Str"",txId);
        Declared declared=(Declared)state;
        txId.setProviderHint(declared.getTxnId());
        pendingRequest.onSuccess();
      }
 else       if (state instanceof Rejected) {
        LOG.debug(""String_Node_Str"",txId);
        Rejected rejected=(Rejected)state;
        Exception cause=AmqpSupport.convertToException(getEndpoint(),rejected.getError());
        JMSException failureCause=null;
        if (txId.getProviderContext() == COMMIT_MARKER) {
          failureCause=new TransactionRolledBackException(cause.getMessage());
        }
 else {
          failureCause=new JMSException(cause.getMessage());
        }
        pendingRequest.onFailure(failureCause);
      }
 else {
        LOG.debug(""String_Node_Str"",txId);
        pendingRequest.onSuccess();
      }
      pendingDelivery.settle();
      pendingRequest=null;
      pendingDelivery=null;
      if (pendingTimeout != null) {
        pendingTimeout.cancel(false);
        pendingTimeout=null;
      }
    }
    super.processDeliveryUpdates(provider);
  }
 catch (  Exception e) {
    throw IOExceptionSupport.create(e);
  }
}","@Override public void processDeliveryUpdates(AmqpProvider provider) throws IOException {
  try {
    if (pendingDelivery != null && pendingDelivery.remotelySettled()) {
      DeliveryState state=pendingDelivery.getRemoteState();
      JmsTransactionId txId=(JmsTransactionId)pendingDelivery.getContext();
      if (state instanceof Declared) {
        LOG.debug(""String_Node_Str"",txId);
        Declared declared=(Declared)state;
        txId.setProviderHint(declared.getTxnId());
        pendingRequest.onSuccess();
      }
 else       if (state instanceof Rejected) {
        LOG.debug(""String_Node_Str"",txId);
        Rejected rejected=(Rejected)state;
        Exception cause=AmqpSupport.convertToException(getEndpoint(),rejected.getError());
        JMSException failureCause=null;
        if (txId.getProviderContext().equals(COMMIT_MARKER)) {
          failureCause=new TransactionRolledBackException(cause.getMessage());
        }
 else {
          failureCause=new JMSException(cause.getMessage());
        }
        pendingRequest.onFailure(failureCause);
      }
 else {
        LOG.debug(""String_Node_Str"",txId);
        pendingRequest.onSuccess();
      }
      pendingDelivery.settle();
      pendingRequest=null;
      pendingDelivery=null;
      if (pendingTimeout != null) {
        pendingTimeout.cancel(false);
        pendingTimeout=null;
      }
    }
    super.processDeliveryUpdates(provider);
  }
 catch (  Exception e) {
    throw IOExceptionSupport.create(e);
  }
}"
41067,"@Test(timeout=30000) public void testQueueBrowserNextElementWithNoMessage() throws IOException, Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    testPeer.expectQueueBrowserAttach();
    testPeer.expectLinkFlow();
    testPeer.expectLinkFlow(true,true,equalTo(UnsignedInteger.valueOf(1)));
    testPeer.expectDetach(true,true,true);
    QueueBrowser browser=session.createBrowser(queue);
    Enumeration<?> queueView=browser.getEnumeration();
    assertNotNull(queueView);
    assertNull(queueView.nextElement());
    browser.close();
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","@Test(timeout=30000) public void testQueueBrowserNextElementWithNoMessage() throws IOException, Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    testPeer.expectQueueBrowserAttach();
    testPeer.expectLinkFlow();
    testPeer.expectLinkFlow(true,true,equalTo(UnsignedInteger.valueOf(JmsPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH)));
    testPeer.expectDetach(true,true,true);
    QueueBrowser browser=session.createBrowser(queue);
    Enumeration<?> queueView=browser.getEnumeration();
    assertNotNull(queueView);
    assertNull(queueView.nextElement());
    browser.close();
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41068,"@Test(timeout=20000) public void testAsyncDeliveryOrder() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin();
    CoordinatorMatcher txCoordinatorMatcher=new CoordinatorMatcher();
    testPeer.expectSenderAttach(txCoordinatorMatcher,false,false);
    Session session=connection.createSession(true,Session.SESSION_TRANSACTED);
    testPeer.expectReceiverAttach();
    int messageCount=10;
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,new AmqpValueDescribedType(""String_Node_Str""),messageCount,false,false,equalTo(UnsignedInteger.valueOf(messageCount)),1,true);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageConsumer consumer=session.createConsumer(queue);
    testPeer.waitForAllHandlersToComplete(3000);
    Binary txnId=new Binary(new byte[]{(byte)5,(byte)6,(byte)7,(byte)8});
    TransferPayloadCompositeMatcher declareMatcher=new TransferPayloadCompositeMatcher();
    declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));
    testPeer.expectTransfer(declareMatcher,nullValue(),false,new Declared().setTxnId(txnId),true);
    for (int i=1; i <= messageCount; i++) {
      TransactionalStateMatcher stateMatcher=new TransactionalStateMatcher();
      stateMatcher.withTxnId(equalTo(txnId));
      stateMatcher.withOutcome(new AcceptedMatcher());
      testPeer.expectDisposition(true,stateMatcher);
    }
    final CountDownLatch done=new CountDownLatch(messageCount);
    final AtomicInteger index=new AtomicInteger(-1);
    consumer.setMessageListener(new DeliveryOrderListener(done,index));
    testPeer.waitForAllHandlersToComplete(3000);
    assertTrue(""String_Node_Str"",done.await(10,TimeUnit.SECONDS));
    assertEquals(""String_Node_Str"",messageCount - 1,index.get());
  }
 }","@Test(timeout=20000) public void testAsyncDeliveryOrder() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin();
    CoordinatorMatcher txCoordinatorMatcher=new CoordinatorMatcher();
    testPeer.expectSenderAttach(txCoordinatorMatcher,false,false);
    Session session=connection.createSession(true,Session.SESSION_TRANSACTED);
    testPeer.expectReceiverAttach();
    int messageCount=10;
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,new AmqpValueDescribedType(""String_Node_Str""),messageCount,false,false,equalTo(UnsignedInteger.valueOf(JmsPrefetchPolicy.DEFAULT_QUEUE_PREFETCH)),1,true);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageConsumer consumer=session.createConsumer(queue);
    testPeer.waitForAllHandlersToComplete(3000);
    Binary txnId=new Binary(new byte[]{(byte)5,(byte)6,(byte)7,(byte)8});
    TransferPayloadCompositeMatcher declareMatcher=new TransferPayloadCompositeMatcher();
    declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));
    testPeer.expectTransfer(declareMatcher,nullValue(),false,new Declared().setTxnId(txnId),true);
    for (int i=1; i <= messageCount; i++) {
      TransactionalStateMatcher stateMatcher=new TransactionalStateMatcher();
      stateMatcher.withTxnId(equalTo(txnId));
      stateMatcher.withOutcome(new AcceptedMatcher());
      testPeer.expectDisposition(true,stateMatcher);
    }
    final CountDownLatch done=new CountDownLatch(messageCount);
    final AtomicInteger index=new AtomicInteger(-1);
    consumer.setMessageListener(new DeliveryOrderListener(done,index));
    testPeer.waitForAllHandlersToComplete(3000);
    assertTrue(""String_Node_Str"",done.await(10,TimeUnit.SECONDS));
    assertEquals(""String_Node_Str"",messageCount - 1,index.get());
  }
 }"
41069,"@Test(timeout=20000) public void testFailoverHandlesDropAfterQueueBrowserDrain() throws Exception {
  try (TestAmqpPeer originalPeer=new TestAmqpPeer();TestAmqpPeer finalPeer=new TestAmqpPeer()){
    final CountDownLatch originalConnected=new CountDownLatch(1);
    final CountDownLatch finalConnected=new CountDownLatch(1);
    final String originalURI=createPeerURI(originalPeer);
    final String finalURI=createPeerURI(finalPeer);
    LOG.info(""String_Node_Str"",originalURI);
    LOG.info(""String_Node_Str"",finalURI);
    originalPeer.expectSaslAnonymousConnect();
    originalPeer.expectBegin();
    final JmsConnection connection=establishAnonymousConnecton(originalPeer,finalPeer);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onConnectionEstablished(      URI remoteURI){
        LOG.info(""String_Node_Str"",remoteURI);
        if (originalURI.equals(remoteURI.toString())) {
          originalConnected.countDown();
        }
      }
      @Override public void onConnectionRestored(      URI remoteURI){
        LOG.info(""String_Node_Str"",remoteURI);
        if (finalURI.equals(remoteURI.toString())) {
          finalConnected.countDown();
        }
      }
    }
);
    connection.start();
    assertTrue(""String_Node_Str"",originalConnected.await(5,TimeUnit.SECONDS));
    originalPeer.expectBegin();
    originalPeer.expectQueueBrowserAttach();
    originalPeer.expectLinkFlow();
    originalPeer.expectLinkFlowThenDrop();
    finalPeer.expectSaslAnonymousConnect();
    finalPeer.expectBegin();
    finalPeer.expectBegin();
    finalPeer.expectQueueBrowserAttach();
    finalPeer.expectLinkFlow();
    finalPeer.expectLinkFlow(true,true,equalTo(UnsignedInteger.valueOf(1)));
    finalPeer.expectDetach(true,true,true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    QueueBrowser browser=session.createBrowser(queue);
    Enumeration<?> queueView=browser.getEnumeration();
    assertNotNull(queueView);
    assertFalse(queueView.hasMoreElements());
    browser.close();
  }
 }","@Test(timeout=20000) public void testFailoverHandlesDropAfterQueueBrowserDrain() throws Exception {
  try (TestAmqpPeer originalPeer=new TestAmqpPeer();TestAmqpPeer finalPeer=new TestAmqpPeer()){
    final CountDownLatch originalConnected=new CountDownLatch(1);
    final CountDownLatch finalConnected=new CountDownLatch(1);
    final String originalURI=createPeerURI(originalPeer);
    final String finalURI=createPeerURI(finalPeer);
    LOG.info(""String_Node_Str"",originalURI);
    LOG.info(""String_Node_Str"",finalURI);
    originalPeer.expectSaslAnonymousConnect();
    originalPeer.expectBegin();
    final JmsConnection connection=establishAnonymousConnecton(originalPeer,finalPeer);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onConnectionEstablished(      URI remoteURI){
        LOG.info(""String_Node_Str"",remoteURI);
        if (originalURI.equals(remoteURI.toString())) {
          originalConnected.countDown();
        }
      }
      @Override public void onConnectionRestored(      URI remoteURI){
        LOG.info(""String_Node_Str"",remoteURI);
        if (finalURI.equals(remoteURI.toString())) {
          finalConnected.countDown();
        }
      }
    }
);
    connection.start();
    assertTrue(""String_Node_Str"",originalConnected.await(5,TimeUnit.SECONDS));
    originalPeer.expectBegin();
    originalPeer.expectQueueBrowserAttach();
    originalPeer.expectLinkFlow();
    originalPeer.expectLinkFlowThenDrop();
    finalPeer.expectSaslAnonymousConnect();
    finalPeer.expectBegin();
    finalPeer.expectBegin();
    finalPeer.expectQueueBrowserAttach();
    finalPeer.expectLinkFlow();
    finalPeer.expectLinkFlow(true,true,equalTo(UnsignedInteger.valueOf(JmsPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH)));
    finalPeer.expectDetach(true,true,true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    QueueBrowser browser=session.createBrowser(queue);
    Enumeration<?> queueView=browser.getEnumeration();
    assertNotNull(queueView);
    assertFalse(queueView.hasMoreElements());
    browser.close();
  }
 }"
41070,"public void expectLinkFlowRespondWithTransfer(final HeaderDescribedType headerDescribedType,final MessageAnnotationsDescribedType messageAnnotationsDescribedType,final PropertiesDescribedType propertiesDescribedType,ApplicationPropertiesDescribedType appPropertiesDescribedType,final DescribedType content,final int count,final boolean drain,final boolean sendDrainFlowResponse,Matcher<UnsignedInteger> creditMatcher,final Integer nextIncomingId,final boolean sendSettled,boolean addMessageNumberProperty){
  if (nextIncomingId == null && count > 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Matcher<Boolean> drainMatcher=null;
  if (drain) {
    drainMatcher=equalTo(true);
  }
 else {
    drainMatcher=Matchers.anyOf(equalTo(false),nullValue());
  }
  Matcher<UnsignedInteger> remoteNextIncomingIdMatcher=null;
  if (nextIncomingId != null) {
    remoteNextIncomingIdMatcher=Matchers.equalTo(UnsignedInteger.valueOf(nextIncomingId));
  }
 else {
    remoteNextIncomingIdMatcher=Matchers.greaterThanOrEqualTo(UnsignedInteger.ONE);
  }
  final FlowMatcher flowMatcher=new FlowMatcher().withLinkCredit(Matchers.greaterThanOrEqualTo(UnsignedInteger.valueOf(count))).withDrain(drainMatcher).withNextIncomingId(remoteNextIncomingIdMatcher);
  CompositeAmqpPeerRunnable composite=new CompositeAmqpPeerRunnable();
  boolean addComposite=false;
  if (appPropertiesDescribedType == null && addMessageNumberProperty) {
    appPropertiesDescribedType=new ApplicationPropertiesDescribedType();
  }
  for (int i=0; i < count; i++) {
    final int nextId=nextIncomingId + i;
    String tagString=""String_Node_Str"" + nextId;
    Binary dtag=new Binary(tagString.getBytes());
    if (addMessageNumberProperty) {
      appPropertiesDescribedType.setApplicationProperty(MESSAGE_NUMBER,i);
    }
    final TransferFrame transferResponse=new TransferFrame().setDeliveryId(UnsignedInteger.valueOf(nextId)).setDeliveryTag(dtag).setMessageFormat(UnsignedInteger.ZERO).setSettled(sendSettled);
    Binary payload=prepareTransferPayload(headerDescribedType,messageAnnotationsDescribedType,propertiesDescribedType,appPropertiesDescribedType,content);
    final FrameSender transferResponseSender=new FrameSender(this,FrameType.AMQP,-1,transferResponse,payload);
    transferResponseSender.setValueProvider(new ValueProvider(){
      @Override public void setValues(){
        transferResponse.setHandle(flowMatcher.getReceivedHandle());
        transferResponseSender.setChannel(flowMatcher.getActualChannel());
      }
    }
);
    addComposite=true;
    composite.add(transferResponseSender);
  }
  if (drain && sendDrainFlowResponse) {
    final FlowFrame drainResponse=new FlowFrame();
    drainResponse.setOutgoingWindow(UnsignedInteger.ZERO);
    drainResponse.setIncomingWindow(UnsignedInteger.valueOf(Integer.MAX_VALUE));
    drainResponse.setLinkCredit(UnsignedInteger.ZERO);
    drainResponse.setDrain(true);
    final FrameSender flowResponseSender=new FrameSender(this,FrameType.AMQP,-1,drainResponse,null);
    flowResponseSender.setValueProvider(new ValueProvider(){
      @Override public void setValues(){
        flowResponseSender.setChannel(flowMatcher.getActualChannel());
        drainResponse.setHandle(flowMatcher.getReceivedHandle());
        drainResponse.setDeliveryCount(calculateNewDeliveryCount(flowMatcher));
        drainResponse.setNextOutgoingId(calculateNewOutgoingId(flowMatcher,count));
        drainResponse.setNextIncomingId(flowMatcher.getReceivedNextOutgoingId());
      }
    }
);
    addComposite=true;
    composite.add(flowResponseSender);
  }
  if (addComposite) {
    flowMatcher.onCompletion(composite);
  }
  addHandler(flowMatcher);
}","public void expectLinkFlowRespondWithTransfer(final HeaderDescribedType headerDescribedType,final MessageAnnotationsDescribedType messageAnnotationsDescribedType,final PropertiesDescribedType propertiesDescribedType,ApplicationPropertiesDescribedType appPropertiesDescribedType,final DescribedType content,final int count,final boolean drain,final boolean sendDrainFlowResponse,Matcher<UnsignedInteger> creditMatcher,final Integer nextIncomingId,final boolean sendSettled,boolean addMessageNumberProperty){
  if (nextIncomingId == null && count > 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Matcher<Boolean> drainMatcher=null;
  if (drain) {
    drainMatcher=equalTo(true);
  }
 else {
    drainMatcher=Matchers.anyOf(equalTo(false),nullValue());
  }
  Matcher<UnsignedInteger> remoteNextIncomingIdMatcher=null;
  if (nextIncomingId != null) {
    remoteNextIncomingIdMatcher=Matchers.equalTo(UnsignedInteger.valueOf(nextIncomingId));
  }
 else {
    remoteNextIncomingIdMatcher=Matchers.greaterThanOrEqualTo(UnsignedInteger.ONE);
  }
  final FlowMatcher flowMatcher=new FlowMatcher().withLinkCredit(creditMatcher).withDrain(drainMatcher).withNextIncomingId(remoteNextIncomingIdMatcher);
  CompositeAmqpPeerRunnable composite=new CompositeAmqpPeerRunnable();
  boolean addComposite=false;
  if (appPropertiesDescribedType == null && addMessageNumberProperty) {
    appPropertiesDescribedType=new ApplicationPropertiesDescribedType();
  }
  for (int i=0; i < count; i++) {
    final int nextId=nextIncomingId + i;
    String tagString=""String_Node_Str"" + nextId;
    Binary dtag=new Binary(tagString.getBytes());
    if (addMessageNumberProperty) {
      appPropertiesDescribedType.setApplicationProperty(MESSAGE_NUMBER,i);
    }
    final TransferFrame transferResponse=new TransferFrame().setDeliveryId(UnsignedInteger.valueOf(nextId)).setDeliveryTag(dtag).setMessageFormat(UnsignedInteger.ZERO).setSettled(sendSettled);
    Binary payload=prepareTransferPayload(headerDescribedType,messageAnnotationsDescribedType,propertiesDescribedType,appPropertiesDescribedType,content);
    final FrameSender transferResponseSender=new FrameSender(this,FrameType.AMQP,-1,transferResponse,payload);
    transferResponseSender.setValueProvider(new ValueProvider(){
      @Override public void setValues(){
        transferResponse.setHandle(flowMatcher.getReceivedHandle());
        transferResponseSender.setChannel(flowMatcher.getActualChannel());
      }
    }
);
    addComposite=true;
    composite.add(transferResponseSender);
  }
  if (drain && sendDrainFlowResponse) {
    final FlowFrame drainResponse=new FlowFrame();
    drainResponse.setOutgoingWindow(UnsignedInteger.ZERO);
    drainResponse.setIncomingWindow(UnsignedInteger.valueOf(Integer.MAX_VALUE));
    drainResponse.setLinkCredit(UnsignedInteger.ZERO);
    drainResponse.setDrain(true);
    final FrameSender flowResponseSender=new FrameSender(this,FrameType.AMQP,-1,drainResponse,null);
    flowResponseSender.setValueProvider(new ValueProvider(){
      @Override public void setValues(){
        flowResponseSender.setChannel(flowMatcher.getActualChannel());
        drainResponse.setHandle(flowMatcher.getReceivedHandle());
        drainResponse.setDeliveryCount(calculateNewDeliveryCount(flowMatcher));
        drainResponse.setNextOutgoingId(calculateNewOutgoingId(flowMatcher,count));
        drainResponse.setNextIncomingId(flowMatcher.getReceivedNextOutgoingId());
      }
    }
);
    addComposite=true;
    composite.add(flowResponseSender);
  }
  if (addComposite) {
    flowMatcher.onCompletion(composite);
  }
  addHandler(flowMatcher);
}"
41071,"@Test(timeout=20000) public void testRemotelyCloseConnectionDuringSyncSend() throws Exception {
  final String BREAD_CRUMB=""String_Node_Str"";
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    testPeer.expectSenderAttach();
    String text=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(text));
    testPeer.expectTransfer(messageMatcher,nullValue(),false,false,null,false);
    testPeer.remotelyCloseConnection(false,AmqpError.RESOURCE_LIMIT_EXCEEDED,BREAD_CRUMB);
    Queue queue=session.createQueue(""String_Node_Str"");
    final MessageProducer producer=session.createProducer(queue);
    Message message=session.createTextMessage(text);
    try {
      producer.send(message);
      fail(""String_Node_Str"");
    }
 catch (    JMSException jmse) {
      assertNotNull(""String_Node_Str"",jmse.getMessage());
      assertTrue(""String_Node_Str"",jmse.getMessage().contains(BREAD_CRUMB));
    }
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","@Test(timeout=20000) public void testRemotelyCloseConnectionDuringSyncSend() throws Exception {
  final String BREAD_CRUMB=""String_Node_Str"";
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    testPeer.expectSenderAttach();
    String text=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(text));
    testPeer.expectTransfer(messageMatcher,nullValue(),false,false,null,false);
    testPeer.remotelyCloseConnection(true,AmqpError.RESOURCE_LIMIT_EXCEEDED,BREAD_CRUMB);
    Queue queue=session.createQueue(""String_Node_Str"");
    final MessageProducer producer=session.createProducer(queue);
    Message message=session.createTextMessage(text);
    try {
      producer.send(message);
      fail(""String_Node_Str"");
    }
 catch (    JMSException jmse) {
      assertNotNull(""String_Node_Str"",jmse.getMessage());
      assertTrue(""String_Node_Str"",jmse.getMessage().contains(BREAD_CRUMB));
    }
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41072,"/** 
 * @throws JMSException
 * @see javax.jms.MessageConsumer#close()
 */
@Override public void close() throws JMSException {
  if (!closed.get()) {
    session.getTransactionContext().addSynchronization(new JmsTxSynchronization(){
      @Override public boolean validate(      JmsTransactionContext context) throws Exception {
        if (!context.isInTransaction() || !delivered.get()) {
          doClose();
          return false;
        }
        return true;
      }
      @Override public void afterCommit() throws Exception {
        doClose();
      }
      @Override public void afterRollback() throws Exception {
        doClose();
      }
    }
);
  }
}","/** 
 * @throws JMSException
 * @see javax.jms.MessageConsumer#close()
 */
@Override public void close() throws JMSException {
  if (!closed.get()) {
    session.getTransactionContext().addSynchronization(new JmsTxSynchronization(){
      @Override public boolean validate(      JmsTransactionContext context) throws Exception {
        if (!context.isInTransaction() || !delivered.get() || isBrowser()) {
          doClose();
          return false;
        }
        return true;
      }
      @Override public void afterCommit() throws Exception {
        doClose();
      }
      @Override public void afterRollback() throws Exception {
        doClose();
      }
    }
);
  }
}"
41073,"@Override public boolean validate(JmsTransactionContext context) throws Exception {
  if (!context.isInTransaction() || !delivered.get()) {
    doClose();
    return false;
  }
  return true;
}","@Override public boolean validate(JmsTransactionContext context) throws Exception {
  if (!context.isInTransaction() || !delivered.get() || isBrowser()) {
    doClose();
    return false;
  }
  return true;
}"
41074,"/** 
 * Remove a URI from the pool if present, otherwise has no effect.
 * @param uri The URI to attempt to remove from the pool.
 * @returns true if the given URI was removed from the pool.
 */
public boolean remove(URI uri){
  if (uri == null) {
    return false;
  }
synchronized (uris) {
    for (    URI candidate : uris) {
      if (compareURIs(uri,candidate)) {
        return uris.remove(candidate);
      }
    }
  }
  return false;
}","/** 
 * Remove a URI from the pool if present, otherwise has no effect.
 * @param uri The URI to attempt to remove from the pool.
 * @return true if the given URI was removed from the pool.
 */
public boolean remove(URI uri){
  if (uri == null) {
    return false;
  }
synchronized (uris) {
    for (    URI candidate : uris) {
      if (compareURIs(uri,candidate)) {
        return uris.remove(candidate);
      }
    }
  }
  return false;
}"
41075,"/** 
 * When a redirect type exception is received this method is called to create the appropriate redirect exception type containing the error details needed.
 * @param error the Symbol that defines the redirection error type.
 * @param message the basic error message that should used or amended for the returned exception.
 * @param condition the ErrorCondition that describes the redirection.
 * @returns an Exception that captures the details of the redirection error.
 */
@SuppressWarnings(""String_Node_Str"") protected Exception createRedirectException(Symbol error,String message,ErrorCondition condition){
  Exception result=null;
  Map<String,Object> info=condition.getInfo();
  if (info == null) {
    result=new IOException(message + ""String_Node_Str"");
  }
 else {
    String hostname=(String)info.get(""String_Node_Str"");
    String networkHost=(String)info.get(""String_Node_Str"");
    if (networkHost == null || networkHost.isEmpty()) {
      result=new IOException(message + ""String_Node_Str"");
    }
    int port=0;
    try {
      port=Integer.valueOf(info.get(""String_Node_Str"").toString());
    }
 catch (    Exception ex) {
      result=new IOException(message + ""String_Node_Str"");
    }
    result=new ProviderRedirectedException(message,hostname,networkHost,port);
  }
  return result;
}","/** 
 * When a redirect type exception is received this method is called to create the appropriate redirect exception type containing the error details needed.
 * @param error the Symbol that defines the redirection error type.
 * @param message the basic error message that should used or amended for the returned exception.
 * @param condition the ErrorCondition that describes the redirection.
 * @return an Exception that captures the details of the redirection error.
 */
@SuppressWarnings(""String_Node_Str"") protected Exception createRedirectException(Symbol error,String message,ErrorCondition condition){
  Exception result=null;
  Map<String,Object> info=condition.getInfo();
  if (info == null) {
    result=new IOException(message + ""String_Node_Str"");
  }
 else {
    String hostname=(String)info.get(""String_Node_Str"");
    String networkHost=(String)info.get(""String_Node_Str"");
    if (networkHost == null || networkHost.isEmpty()) {
      result=new IOException(message + ""String_Node_Str"");
    }
    int port=0;
    try {
      port=Integer.valueOf(info.get(""String_Node_Str"").toString());
    }
 catch (    Exception ex) {
      result=new IOException(message + ""String_Node_Str"");
    }
    result=new ProviderRedirectedException(message,hostname,networkHost,port);
  }
  return result;
}"
41076,"/** 
 * Indicates if this DiscoveryAgent requires a ScheduledExecutorService in order to perform its discovery work.
 * @returns true if the agent requires that its parent provide it with a scheduler.
 */
boolean isSchedulerRequired();","/** 
 * Indicates if this DiscoveryAgent requires a ScheduledExecutorService in order to perform its discovery work.
 * @return true if the agent requires that its parent provide it with a scheduler.
 */
boolean isSchedulerRequired();"
41077,"@Test(timeout=5000) public void testCreateTemporaryTopicFailsWhenLinkRefusedAndAttachResponseWriteIsDeferred() throws Exception {
  doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(false,true);
}","@Test(timeout=5000) public void testCreateTemporaryTopicFailsWhenLinkRefusedAndAttachResponseWriteIsDeferred() throws Exception {
  doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(true,true);
}"
41078,"private void doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(boolean topic,boolean deferAttachResponseWrite) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    testPeer.expectAndRefuseTempQueueCreationAttach(AmqpError.UNAUTHORIZED_ACCESS,""String_Node_Str"",false);
    try {
      if (topic) {
        session.createTemporaryTopic();
      }
 else {
        session.createTemporaryQueue();
      }
      fail(""String_Node_Str"");
    }
 catch (    JMSSecurityException jmsse) {
    }
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }","private void doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(boolean topic,boolean deferAttachResponseWrite) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    try {
      if (topic) {
        testPeer.expectAndRefuseTempTopicCreationAttach(AmqpError.UNAUTHORIZED_ACCESS,""String_Node_Str"",false);
        session.createTemporaryTopic();
      }
 else {
        testPeer.expectAndRefuseTempQueueCreationAttach(AmqpError.UNAUTHORIZED_ACCESS,""String_Node_Str"",false);
        session.createTemporaryQueue();
      }
      fail(""String_Node_Str"");
    }
 catch (    JMSSecurityException jmsse) {
    }
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }"
41079,"@Test(timeout=5000) public void testCreateTemporaryTopicFailsWhenLinkRefusedAndAttachResponseWriteIsNotDeferred() throws Exception {
  doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(false,false);
}","@Test(timeout=5000) public void testCreateTemporaryTopicFailsWhenLinkRefusedAndAttachResponseWriteIsNotDeferred() throws Exception {
  doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(true,false);
}"
41080,"private static TrustManager[] loadTrustManagers(TransportSslOptions options) throws Exception {
  if (options.getTrustStoreLocation() == null) {
    return null;
  }
  TrustManagerFactory fact=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
  String storeLocation=options.getKeyStoreLocation();
  String storePassword=options.getKeyStorePassword();
  String storeType=options.getStoreType();
  LOG.trace(""String_Node_Str"",storeLocation,storeType);
  KeyStore trustStore=loadStore(storeLocation,storePassword,storeType);
  fact.init(trustStore);
  return fact.getTrustManagers();
}","private static TrustManager[] loadTrustManagers(TransportSslOptions options) throws Exception {
  if (options.getTrustStoreLocation() == null) {
    return null;
  }
  TrustManagerFactory fact=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
  String storeLocation=options.getTrustStoreLocation();
  String storePassword=options.getTrustStorePassword();
  String storeType=options.getStoreType();
  LOG.trace(""String_Node_Str"",storeLocation,storeType);
  KeyStore trustStore=loadStore(storeLocation,storePassword,storeType);
  fact.init(trustStore);
  return fact.getTrustManagers();
}"
41081,"public void input(final ByteBuffer input){
  TransportResult frameParsingError=null;
  int size=_size;
  ByteBuffer nextFramesInput=null;
  byte[] header=new byte[8];
  boolean transportAccepting=true;
  ByteBuffer currentInput=input;
  while (currentInput.hasRemaining() && _state != State.ERROR && transportAccepting) {
switch (_state) {
case HEADER0:
      if (currentInput.hasRemaining()) {
        byte c=currentInput.get();
        header[0]=c;
        _state=State.HEADER1;
      }
 else {
        break;
      }
case HEADER1:
    if (currentInput.hasRemaining()) {
      byte c=currentInput.get();
      header[1]=c;
      _state=State.HEADER2;
    }
 else {
      break;
    }
case HEADER2:
  if (currentInput.hasRemaining()) {
    byte c=currentInput.get();
    header[2]=c;
    _state=State.HEADER3;
  }
 else {
    break;
  }
case HEADER3:
if (currentInput.hasRemaining()) {
  byte c=currentInput.get();
  header[3]=c;
  _state=State.HEADER4;
}
 else {
  break;
}
case HEADER4:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[4]=c;
_state=State.HEADER5;
}
 else {
break;
}
case HEADER5:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[5]=c;
_state=State.HEADER6;
}
 else {
break;
}
case HEADER6:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[6]=c;
_state=State.HEADER7;
}
 else {
break;
}
case HEADER7:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[7]=c;
_peer.receiveHeader(header);
_state=State.SIZE_0;
}
 else {
break;
}
case SIZE_0:
if (!currentInput.hasRemaining()) {
break;
}
if (currentInput.remaining() >= 4) {
size=currentInput.getInt();
_state=State.PRE_PARSE;
break;
}
 else {
size=(currentInput.get() << 24) & 0xFF000000;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_1;
break;
}
}
case SIZE_1:
size|=(currentInput.get() << 16) & 0xFF0000;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_2;
break;
}
case SIZE_2:
size|=(currentInput.get() << 8) & 0xFF00;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_3;
break;
}
case SIZE_3:
size|=currentInput.get() & 0xFF;
_state=State.PRE_PARSE;
case PRE_PARSE:
;
if (size < 8) {
frameParsingError=error(""String_Node_Str"" + ""String_Node_Str"",_size,8);
_state=State.ERROR;
break;
}
if (currentInput.remaining() < size - 4) {
_frameBuffer=ByteBuffer.allocate(size - 4);
_frameBuffer.put(currentInput);
_state=State.BUFFERING;
break;
}
case BUFFERING:
if (_frameBuffer != null) {
if (currentInput.remaining() < _frameBuffer.remaining()) {
_frameBuffer.put(currentInput);
break;
}
 else {
ByteBuffer dup=currentInput.duplicate();
dup.limit(dup.position() + _frameBuffer.remaining());
currentInput.position(currentInput.position() + _frameBuffer.remaining());
_frameBuffer.put(dup);
nextFramesInput=currentInput;
_frameBuffer.flip();
currentInput=_frameBuffer;
_state=State.PARSING;
}
}
case PARSING:
int dataOffset=(currentInput.get() << 2) & 0x3FF;
if (dataOffset < 8) {
frameParsingError=error(""String_Node_Str"",dataOffset,8);
_state=State.ERROR;
break;
}
 else if (dataOffset > size) {
frameParsingError=error(""String_Node_Str"",dataOffset,_size);
_state=State.ERROR;
break;
}
int type=currentInput.get() & 0xFF;
int channel=currentInput.getShort() & 0xFF;
if (dataOffset != 8) {
currentInput.position(currentInput.position() + dataOffset - 8);
}
final int frameBodySize=size - dataOffset;
if (nextFramesInput == null) {
nextFramesInput=currentInput;
currentInput=currentInput.duplicate();
final int endPos=currentInput.position() + frameBodySize;
currentInput.limit(endPos);
nextFramesInput.position(endPos);
}
try {
if (frameBodySize > 0) {
Data data=Data.Factory.create();
data.decode(currentInput);
Data.DataType dataType=data.type();
if (dataType != Data.DataType.DESCRIBED) {
throw new IllegalArgumentException(""String_Node_Str"" + Data.DataType.DESCRIBED + ""String_Node_Str""+ dataType);
}
DescribedType describedType=data.getDescribedType();
LOGGER.debug(""String_Node_Str"",describedType);
Binary payload;
if (currentInput.hasRemaining()) {
byte[] payloadBytes=new byte[currentInput.remaining()];
currentInput.get(payloadBytes);
payload=new Binary(payloadBytes);
}
 else {
payload=null;
}
_peer.receiveFrame(type,channel,describedType,payload);
}
 else {
LOGGER.debug(""String_Node_Str"");
}
_size=0;
currentInput=nextFramesInput;
nextFramesInput=null;
_frameBuffer=null;
if (_state != State.HEADER0) {
_state=State.SIZE_0;
}
}
 catch (DecodeException ex) {
_state=State.ERROR;
frameParsingError=error(ex);
}
break;
case ERROR:
}
}
_size=size;
if (_state == State.ERROR) {
if (frameParsingError != null) {
frameParsingError.checkIsOk();
}
 else {
TransportResultFactory.error(""String_Node_Str"").checkIsOk();
}
}
}","public void input(final ByteBuffer input){
  TransportResult frameParsingError=null;
  int size=_size;
  ByteBuffer nextFramesInput=null;
  byte[] header=new byte[8];
  boolean transportAccepting=true;
  ByteBuffer currentInput=input;
  while (currentInput.hasRemaining() && _state != State.ERROR && transportAccepting) {
switch (_state) {
case HEADER0:
      if (currentInput.hasRemaining()) {
        byte c=currentInput.get();
        header[0]=c;
        _state=State.HEADER1;
      }
 else {
        break;
      }
case HEADER1:
    if (currentInput.hasRemaining()) {
      byte c=currentInput.get();
      header[1]=c;
      _state=State.HEADER2;
    }
 else {
      break;
    }
case HEADER2:
  if (currentInput.hasRemaining()) {
    byte c=currentInput.get();
    header[2]=c;
    _state=State.HEADER3;
  }
 else {
    break;
  }
case HEADER3:
if (currentInput.hasRemaining()) {
  byte c=currentInput.get();
  header[3]=c;
  _state=State.HEADER4;
}
 else {
  break;
}
case HEADER4:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[4]=c;
_state=State.HEADER5;
}
 else {
break;
}
case HEADER5:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[5]=c;
_state=State.HEADER6;
}
 else {
break;
}
case HEADER6:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[6]=c;
_state=State.HEADER7;
}
 else {
break;
}
case HEADER7:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[7]=c;
_peer.receiveHeader(header);
_state=State.SIZE_0;
}
 else {
break;
}
case SIZE_0:
if (!currentInput.hasRemaining()) {
break;
}
if (currentInput.remaining() >= 4) {
size=currentInput.getInt();
_state=State.PRE_PARSE;
break;
}
 else {
size=(currentInput.get() << 24) & 0xFF000000;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_1;
break;
}
}
case SIZE_1:
size|=(currentInput.get() << 16) & 0xFF0000;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_2;
break;
}
case SIZE_2:
size|=(currentInput.get() << 8) & 0xFF00;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_3;
break;
}
case SIZE_3:
size|=currentInput.get() & 0xFF;
_state=State.PRE_PARSE;
case PRE_PARSE:
;
if (size < 8) {
frameParsingError=error(""String_Node_Str"" + ""String_Node_Str"",_size,8);
_state=State.ERROR;
break;
}
if (currentInput.remaining() < size - 4) {
_frameBuffer=ByteBuffer.allocate(size - 4);
_frameBuffer.put(currentInput);
_state=State.BUFFERING;
break;
}
case BUFFERING:
if (_frameBuffer != null) {
if (currentInput.remaining() < _frameBuffer.remaining()) {
_frameBuffer.put(currentInput);
break;
}
 else {
ByteBuffer dup=currentInput.duplicate();
dup.limit(dup.position() + _frameBuffer.remaining());
currentInput.position(currentInput.position() + _frameBuffer.remaining());
_frameBuffer.put(dup);
nextFramesInput=currentInput;
_frameBuffer.flip();
currentInput=_frameBuffer;
_state=State.PARSING;
}
}
case PARSING:
int dataOffset=(currentInput.get() << 2) & 0x3FF;
if (dataOffset < 8) {
frameParsingError=error(""String_Node_Str"",dataOffset,8);
_state=State.ERROR;
break;
}
 else if (dataOffset > size) {
frameParsingError=error(""String_Node_Str"",dataOffset,_size);
_state=State.ERROR;
break;
}
int type=currentInput.get() & 0xFF;
int channel=currentInput.getShort() & 0xFFFF;
if (dataOffset != 8) {
currentInput.position(currentInput.position() + dataOffset - 8);
}
final int frameBodySize=size - dataOffset;
if (nextFramesInput == null) {
nextFramesInput=currentInput;
currentInput=currentInput.duplicate();
final int endPos=currentInput.position() + frameBodySize;
currentInput.limit(endPos);
nextFramesInput.position(endPos);
}
try {
if (frameBodySize > 0) {
Data data=Data.Factory.create();
data.decode(currentInput);
Data.DataType dataType=data.type();
if (dataType != Data.DataType.DESCRIBED) {
throw new IllegalArgumentException(""String_Node_Str"" + Data.DataType.DESCRIBED + ""String_Node_Str""+ dataType);
}
DescribedType describedType=data.getDescribedType();
LOGGER.debug(""String_Node_Str"",describedType);
Binary payload;
if (currentInput.hasRemaining()) {
byte[] payloadBytes=new byte[currentInput.remaining()];
currentInput.get(payloadBytes);
payload=new Binary(payloadBytes);
}
 else {
payload=null;
}
_peer.receiveFrame(type,channel,describedType,payload);
}
 else {
LOGGER.debug(""String_Node_Str"");
}
_size=0;
currentInput=nextFramesInput;
nextFramesInput=null;
_frameBuffer=null;
if (_state != State.HEADER0) {
_state=State.SIZE_0;
}
}
 catch (DecodeException ex) {
_state=State.ERROR;
frameParsingError=error(ex);
}
break;
case ERROR:
}
}
_size=size;
if (_state == State.ERROR) {
if (frameParsingError != null) {
frameParsingError.checkIsOk();
}
 else {
TransportResultFactory.error(""String_Node_Str"").checkIsOk();
}
}
}"
41082,"/** 
 * Triggers a pull request from the connected Provider.  An attempt is made to set a timeout on the pull request however some providers will not honor this value and the pull will remain active until a message is dispatched. The timeout value can be one of: < 0 to indicate that the request should expire immediately if no message. = 0 to indicate that the request should never time out. > 1 to indicate that the request should expire after the given time in milliseconds.
 * @param timeout The amount of time the pull request should remain valid.
 */
protected void sendPullCommand(long timeout) throws JMSException {
  if (messageQueue.isEmpty() && (getPrefetchSize() == 0 || isBrowser())) {
    connection.pull(getConsumerId(),timeout);
  }
}","/** 
 * Triggers a pull request from the connected Provider.  An attempt is made to set a timeout on the pull request however some providers will not honor this value and the pull will remain active until a message is dispatched. <p> The timeout value can be one of: <br>  {@literal < 0} to indicate that the request should expire immediately if no message.<br>{@literal = 0} to indicate that the request should never time out.<br>{@literal > 1} to indicate that the request should expire after the given time in milliseconds.
 * @param timeout The amount of time the pull request should remain valid.
 */
protected void sendPullCommand(long timeout) throws JMSException {
  if (messageQueue.isEmpty() && (getPrefetchSize() == 0 || isBrowser())) {
    connection.pull(getConsumerId(),timeout);
  }
}"
41083,"/** 
 * Called to indicate that the underlying connection to the Broker has been established for the first time.  For a fault tolerant provider this event should only ever be triggered once with the interruption and recovery events following on for future
 * @param ex The exception that indicates the cause of this Provider failure.
 */
void onConnectionEstablished(URI remoteURI);","/** 
 * Called to indicate that the underlying connection to the Broker has been established for the first time.  For a fault tolerant provider this event should only ever be triggered once with the interruption and recovery events following on for future
 * @param remoteURI The URI of the Broker that the client has now connected to.
 */
void onConnectionEstablished(URI remoteURI);"
41084,"/** 
 * Sets any additional Mechanism specific properties using a Map<String, Object>
 * @param options the map of additional properties that this Mechanism should utilize.
 */
void setProperties(Map<String,Object> options);","/** 
 * Sets any additional Mechanism specific properties using a   {@code Map<String, Object>}
 * @param options the map of additional properties that this Mechanism should utilize.
 */
void setProperties(Map<String,Object> options);"
41085,"/** 
 * Validates that the expression can be used in == or <> expression. Cannot not be NULL TRUE or FALSE litterals.
 * @param expr
 */
public static void checkEqualOperand(Expression expr){
  if (expr instanceof ConstantExpression) {
    Object value=((ConstantExpression)expr).getValue();
    if (value == null) {
      throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
    }
  }
}","/** 
 * Validates that the expression can be used in   {@literal == or <>} expressions. Cannotnot be NULL TRUE or FALSE literals.
 * @param expr
 */
public static void checkEqualOperand(Expression expr){
  if (expr instanceof ConstantExpression) {
    Object value=((ConstantExpression)expr).getValue();
    if (value == null) {
      throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
    }
  }
}"
41086,"/** 
 * Only Numeric expressions can be used in >, >=, < or <= expressions.s
 * @param expr
 */
public static void checkLessThanOperand(Expression expr){
  if (expr instanceof ConstantExpression) {
    Object value=((ConstantExpression)expr).getValue();
    if (value instanceof Number) {
      return;
    }
    throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
  }
  if (expr instanceof BooleanExpression) {
    throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
  }
}","/** 
 * Only Numeric expressions can be used in   {@literal >, >=, < or <=} expressions.
 * @param expr
 */
public static void checkLessThanOperand(Expression expr){
  if (expr instanceof ConstantExpression) {
    Object value=((ConstantExpression)expr).getValue();
    if (value instanceof Number) {
      return;
    }
    throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
  }
  if (expr instanceof BooleanExpression) {
    throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
  }
}"
41087,"/** 
 * Constructor for an JmsQueueBrowser - used internally
 * @param session
 * @param id
 * @param destination
 * @param selector
 * @throws javax.jms.JMSException
 */
protected JmsQueueBrowser(JmsSession session,JmsDestination destination,String selector) throws JMSException {
  this.session=session;
  this.destination=destination;
  this.selector=selector;
}","/** 
 * Constructor for an JmsQueueBrowser - used internally
 * @param session
 * @param destination
 * @param selector
 * @throws javax.jms.JMSException
 */
protected JmsQueueBrowser(JmsSession session,JmsDestination destination,String selector) throws JMSException {
  this.session=session;
  this.destination=destination;
  this.selector=selector;
}"
41088,"/** 
 * Sets a value which will be used to override any ttl value that may otherwise be set based on the expiration value when sending the underlying AMQP message. A value of 0 means to clear the ttl field rather than set it to anything.
 * @param ttl the value to use, in range 0 <= x <= 2^32 - 1
 * @throws MessageFormatException
 */
public void setAmqpTimeToLiveOverride(Long ttl) throws MessageFormatException {
  if (ttl != null) {
    if (ttl >= 0 && ttl <= UINT_MAX) {
      userSpecifiedTTL=ttl;
    }
 else {
      throw new MessageFormatException(JMS_AMQP_TTL + ""String_Node_Str"");
    }
  }
 else {
    userSpecifiedTTL=null;
  }
}","/** 
 * Sets a value which will be used to override any ttl value that may otherwise be set based on the expiration value when sending the underlying AMQP message. A value of 0 means to clear the ttl field rather than set it to anything.
 * @param ttl the value to use, in range  {@literal 0 <= x <= 2^32 - 1}
 * @throws MessageFormatException
 */
public void setAmqpTimeToLiveOverride(Long ttl) throws MessageFormatException {
  if (ttl != null) {
    if (ttl >= 0 && ttl <= UINT_MAX) {
      userSpecifiedTTL=ttl;
    }
 else {
      throw new MessageFormatException(JMS_AMQP_TTL + ""String_Node_Str"");
    }
  }
 else {
    userSpecifiedTTL=null;
  }
}"
41089,"/** 
 * Gets the current setting controlling how many Connect / Reconnect attempts must occur before a warn message is logged.  A value of   {@code <= 0} indicates that there will beno warn message logged regardless of how many reconnect attempts occur.
 * @return the current number of connection attempts before warn logging is triggered.
 */
public int getWarnAfterReconnectAttempts(){
  return warnAfterReconnectAttempts;
}","/** 
 * Gets the current setting controlling how many Connect / Reconnect attempts must occur before a warn message is logged.  A value of   {@literal <= 0} indicates that there will beno warn message logged regardless of how many reconnect attempts occur.
 * @return the current number of connection attempts before warn logging is triggered.
 */
public int getWarnAfterReconnectAttempts(){
  return warnAfterReconnectAttempts;
}"
41090,"/** 
 * Sets the number of Connect / Reconnect attempts that must occur before a warn message is logged indicating that the transport is not connected.  This can be useful when the client is running inside some container or service as it gives an indication of some problem with the client connection that might not otherwise be visible.  To disable the log messages this value should be set to a value @{code attempts <= 0}
 * @param warnAfterReconnectAttempts The number of failed connection attempts that must happen before a warning is logged.
 */
public void setWarnAfterReconnectAttempts(int warnAfterReconnectAttempts){
  this.warnAfterReconnectAttempts=warnAfterReconnectAttempts;
}","/** 
 * Sets the number of Connect / Reconnect attempts that must occur before a warn message is logged indicating that the transport is not connected.  This can be useful when the client is running inside some container or service as it gives an indication of some problem with the client connection that might not otherwise be visible.  To disable the log messages this value should be set to a value   {@literal <= 0}
 * @param warnAfterReconnectAttempts The number of failed connection attempts that must happen before a warning is logged.
 */
public void setWarnAfterReconnectAttempts(int warnAfterReconnectAttempts){
  this.warnAfterReconnectAttempts=warnAfterReconnectAttempts;
}"
41091,"/** 
 * Does a proper compare on the Id's
 * @param id1
 * @param id2
 * @return 0 if equal else a positive if id1 is > id2 ...
 */
public static int compare(String id1,String id2){
  int result=-1;
  String seed1=IdGenerator.getSeedFromId(id1);
  String seed2=IdGenerator.getSeedFromId(id2);
  if (seed1 != null && seed2 != null) {
    result=seed1.compareTo(seed2);
    if (result == 0) {
      long count1=IdGenerator.getSequenceFromId(id1);
      long count2=IdGenerator.getSequenceFromId(id2);
      result=(int)(count1 - count2);
    }
  }
  return result;
}","/** 
 * Does a proper compare on the Id's
 * @param id1
 * @param id2
 * @return 0 if equal else a positive if {@literal id1 > id2} ...
 */
public static int compare(String id1,String id2){
  int result=-1;
  String seed1=IdGenerator.getSeedFromId(id1);
  String seed2=IdGenerator.getSeedFromId(id2);
  if (seed1 != null && seed2 != null) {
    result=seed1.compareTo(seed2);
    if (result == 0) {
      long count1=IdGenerator.getSequenceFromId(id1);
      long count2=IdGenerator.getSequenceFromId(id2);
      result=(int)(count1 - count2);
    }
  }
  return result;
}"
41092,"/** 
 * Used to get an enqueued message. The amount of time this method blocks is based on the timeout value. - if timeout==-1 then it blocks until a message is received. - if timeout==0 then it it tries to not block at all, it returns a message if it is available - if timeout>0 then it blocks up to timeout amount of time. Expired messages will consumed by this method.
 * @return null if we timeout or if the consumer is closed.
 * @throws InterruptedException if the wait is interrupted.
 */
JmsInboundMessageDispatch dequeue(long timeout) throws InterruptedException ;","/** 
 * Used to get an enqueued message. The amount of time this method blocks is based on the timeout value. - if timeout==-1 then it blocks until a message is received. - if timeout==0 then it it tries to not block at all, it returns a message if it is available - if   {@literal timeout > 0} then itblocks up to timeout amount of time. Expired messages will consumed by this method.
 * @return null if we timeout or if the consumer is closed.
 * @throws InterruptedException if the wait is interrupted.
 */
JmsInboundMessageDispatch dequeue(long timeout) throws InterruptedException ;"
41093,"/** 
 * Parse properties from a named resource -eg. a URI or a simple name e.g. foo?name=""fred""&size=2
 * @param uri the URI whose parameters are to be parsed.
 * @return <Code>Map</Code> of properties
 * @throws Exception if an error occurs while parsing the query options.
 */
public static Map<String,String> parseParameters(String uri) throws Exception {
  if (uri == null) {
    return Collections.emptyMap();
  }
  return parseQuery(stripUpto(uri,'?'));
}","/** 
 * Parse properties from a named resource -eg. a URI or a simple name e.g.  {@literal foo?name=""fred""&size=2}
 * @param uri the URI whose parameters are to be parsed.
 * @return <Code>Map</Code> of properties
 * @throws Exception if an error occurs while parsing the query options.
 */
public static Map<String,String> parseParameters(String uri) throws Exception {
  if (uri == null) {
    return Collections.emptyMap();
  }
  return parseQuery(stripUpto(uri,'?'));
}"
41094,"/** 
 * @param topic
 * @param name
 * @param messageSelector
 * @param noLocal
 * @return the durable TopicSubscriber
 * @throws IllegalStateException
 * @throws JMSException
 * @see javax.jms.Session#createDurableSubscriber(javax.jms.Topic,java.lang.String,java.lang.String,boolean)
 */
@Override public TopicSubscriber createDurableSubscriber(Topic topic,String name,String messageSelector,boolean noLocal) throws IllegalStateException {
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * @param topic
 * @param name
 * @param messageSelector
 * @param noLocal
 * @return the durable TopicSubscriber
 * @throws JMSException
 * @see javax.jms.Session#createDurableSubscriber(javax.jms.Topic,java.lang.String,java.lang.String,boolean)
 */
@Override public TopicSubscriber createDurableSubscriber(Topic topic,String name,String messageSelector,boolean noLocal) throws JMSException {
  throw new IllegalStateException(""String_Node_Str"");
}"
41095,"/** 
 * @param destination
 * @param messageSelector
 * @param NoLocal
 * @return the MessageConsumer
 * @throws JMSException
 * @see javax.jms.Session#createConsumer(javax.jms.Destination,java.lang.String,boolean)
 */
@Override public MessageConsumer createConsumer(Destination destination,String messageSelector,boolean noLocal) throws JMSException {
  checkClosed();
  checkDestination(destination);
  messageSelector=checkSelector(messageSelector);
  JmsDestination dest=JmsMessageTransformation.transformDestination(connection,destination);
  JmsMessageConsumer result=new JmsMessageConsumer(getNextConsumerId(),this,dest,messageSelector,noLocal);
  result.init();
  return result;
}","/** 
 * @param destination
 * @param messageSelector
 * @param noLocal
 * @return the MessageConsumer
 * @throws JMSException
 * @see javax.jms.Session#createConsumer(javax.jms.Destination,java.lang.String,boolean)
 */
@Override public MessageConsumer createConsumer(Destination destination,String messageSelector,boolean noLocal) throws JMSException {
  checkClosed();
  checkDestination(destination);
  messageSelector=checkSelector(messageSelector);
  JmsDestination dest=JmsMessageTransformation.transformDestination(connection,destination);
  JmsMessageConsumer result=new JmsMessageConsumer(getNextConsumerId(),this,dest,messageSelector,noLocal);
  result.init();
  return result;
}"
41096,"/** 
 * Constructor
 * @param s
 * @param destination
 */
protected JmsTopicPublisher(JmsProducerId id,JmsSession session,JmsDestination destination) throws JMSException {
  super(id,session,destination);
}","/** 
 * Constructor
 * @param session
 * @param destination
 */
protected JmsTopicPublisher(JmsProducerId id,JmsSession session,JmsDestination destination) throws JMSException {
  super(id,session,destination);
}"
41097,"/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned if the property has a value and is available for a read operation. The Set returned may be manipulated by the receiver without impacting the facade, and an empty set will be returned if there are no matching properties.
 * @param message the JmsMessageFacade instance to read from
 * @param excludeStandardJMSHeaders whether the standard JMS header names should be excluded from the returned set
 * @return a Set<String> containing the names of all intercepted properties with a value.
 * @throws JMSException if an error occurs while gathering the message property names.
 */
public static Set<String> getPropertyNames(JmsMessageFacade message,boolean excludeStandardJMSHeaders) throws JMSException {
  Set<String> names=new HashSet<String>();
  for (  Entry<String,PropertyIntercepter> entry : PROPERTY_INTERCEPTERS.entrySet()) {
    if (excludeStandardJMSHeaders && STANDARD_HEADERS.contains(entry.getKey())) {
      continue;
    }
    if (entry.getValue().propertyExists(message)) {
      names.add(entry.getKey());
    }
  }
  names.addAll(message.getPropertyNames());
  return names;
}","/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned if the property has a value and is available for a read operation. The Set returned may be manipulated by the receiver without impacting the facade, and an empty set will be returned if there are no matching properties.
 * @param message the JmsMessageFacade instance to read from
 * @param excludeStandardJMSHeaders whether the standard JMS header names should be excluded from the returned set
 * @return a {@code Set<String>} containing the names of all intercepted properties with a value.
 * @throws JMSException if an error occurs while gathering the message property names.
 */
public static Set<String> getPropertyNames(JmsMessageFacade message,boolean excludeStandardJMSHeaders) throws JMSException {
  Set<String> names=new HashSet<String>();
  for (  Entry<String,PropertyIntercepter> entry : PROPERTY_INTERCEPTERS.entrySet()) {
    if (excludeStandardJMSHeaders && STANDARD_HEADERS.contains(entry.getKey())) {
      continue;
    }
    if (entry.getValue().propertyExists(message)) {
      names.add(entry.getKey());
    }
  }
  names.addAll(message.getPropertyNames());
  return names;
}"
41098,"/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned.
 * @param message the JmsMessageFacade instance to read property names from.
 * @return a Set<String> containing the names of all intercepted properties.
 * @throws JMSException if an error occurs while gathering the message property names.
 */
public static Set<String> getAllPropertyNames(JmsMessageFacade message) throws JMSException {
  Set<String> names=new HashSet<String>(PROPERTY_INTERCEPTERS.keySet());
  names.addAll(message.getPropertyNames());
  return names;
}","/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned.
 * @param message the JmsMessageFacade instance to read property names from.
 * @return a {@code Set<String>} containing the names of all intercepted properties.
 * @throws JMSException if an error occurs while gathering the message property names.
 */
public static Set<String> getAllPropertyNames(JmsMessageFacade message) throws JMSException {
  Set<String> names=new HashSet<String>(PROPERTY_INTERCEPTERS.keySet());
  names.addAll(message.getPropertyNames());
  return names;
}"
41099,"/** 
 * @param transport the transport type name to use when creating a new provider.
 */
public void setTransportType(String transportType){
  this.transportType=transportType;
}","/** 
 * @param transportType the transport type name to use when creating a new provider.
 */
public void setTransportType(String transportType){
  this.transportType=transportType;
}"
41100,"/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned if the property has a value and is available for a read operation. The Set returned may be manipulated by the receiver without impacting the facade, and an empty set will be returned if there are no matching properties.
 * @return a Set<String> containing the names of all intercepted properties with a value.
 */
public static Set<String> getPropertyNames(AmqpJmsMessageFacade message){
  Set<String> names=new HashSet<String>();
  for (  Entry<String,PropertyIntercepter> entry : PROPERTY_INTERCEPTERS.entrySet()) {
    if (entry.getValue().propertyExists(message)) {
      names.add(entry.getKey());
    }
  }
  return message.getApplicationPropertyNames(names);
}","/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned if the property has a value and is available for a read operation. The Set returned may be manipulated by the receiver without impacting the facade, and an empty set will be returned if there are no matching properties.
 * @return a {@code Set<String>} containing the names of all intercepted properties with a value.
 */
public static Set<String> getPropertyNames(AmqpJmsMessageFacade message){
  Set<String> names=new HashSet<String>();
  for (  Entry<String,PropertyIntercepter> entry : PROPERTY_INTERCEPTERS.entrySet()) {
    if (entry.getValue().propertyExists(message)) {
      names.add(entry.getKey());
    }
  }
  return message.getApplicationPropertyNames(names);
}"
41101,"/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned.
 * @return a Set<String> containing the names of all intercepted properties.
 */
public static Set<String> getAllPropertyNames(){
  return PROPERTY_INTERCEPTERS.keySet();
}","/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned.
 * @return a {@code Set<String>} containing the names of all intercepted properties.
 */
public static Set<String> getAllPropertyNames(){
  return PROPERTY_INTERCEPTERS.keySet();
}"
41102,"/** 
 * Sets the password value for this Mechanism.  The Mechanism can ignore this value if it does not utilize a password in it's authentication processing.
 * @param username The user name given.
 */
void setPassword(String value);","/** 
 * Sets the password value for this Mechanism.  The Mechanism can ignore this value if it does not utilize a password in it's authentication processing.
 * @param username The user name given.
 */
void setPassword(String username);"
41103,"/** 
 * Sets the user name value for this Mechanism.  The Mechanism can ignore this value if it does not utilize user name in it's authentication processing.
 * @param username The user name given.
 */
void setUsername(String value);","/** 
 * Sets the user name value for this Mechanism.  The Mechanism can ignore this value if it does not utilize user name in it's authentication processing.
 * @param username The user name given.
 */
void setUsername(String username);"
41104,"/** 
 * Encodes the value of string so that it looks like it would look like when it was provided in a selector.
 * @param string
 * @return the encoded String
 */
public static String encodeString(String s){
  StringBuffer b=new StringBuffer();
  b.append('\'');
  for (int i=0; i < s.length(); i++) {
    char c=s.charAt(i);
    if (c == '\'') {
      b.append(c);
    }
    b.append(c);
  }
  b.append('\'');
  return b.toString();
}","/** 
 * Encodes the value of string so that it looks like it would look like when it was provided in a selector.
 * @param s the original string
 * @return the encoded String
 */
public static String encodeString(String s){
  StringBuffer b=new StringBuffer();
  b.append('\'');
  for (int i=0; i < s.length(); i++) {
    char c=s.charAt(i);
    if (c == '\'') {
      b.append(c);
    }
    b.append(c);
  }
  b.append('\'');
  return b.toString();
}"
41105,"/** 
 * When using the   {@link java.net.InetAddress#getHostName()} method in anenvironment where neither a proper DNS lookup nor an <tt>/etc/hosts</tt> entry exists for a given host, the following exception will be thrown: <code> java.net.UnknownHostException: &lt;hostname&gt;: &lt;hostname&gt; at java.net.InetAddress.getLocalHost(InetAddress.java:1425) ... </code> Instead of just throwing an UnknownHostException and giving up, this method grabs a suitable hostname from the exception and prevents the exception from being thrown. If a suitable hostname cannot be acquired from the exception, only then is the <tt>UnknownHostException</tt> thrown.
 * @return The hostname
 * @throws UnknownHostException
 * @see {@link java.net.InetAddress#getLocalHost()}
 * @see {@link java.net.InetAddress#getHostName()}
 */
public static String getLocalHostName() throws UnknownHostException {
  try {
    return (InetAddress.getLocalHost()).getHostName();
  }
 catch (  UnknownHostException uhe) {
    String host=uhe.getMessage();
    if (host != null) {
      int colon=host.indexOf(':');
      if (colon > 0) {
        return host.substring(0,colon);
      }
    }
    throw uhe;
  }
}","/** 
 * When using the   {@link java.net.InetAddress#getHostName()} method in anenvironment where neither a proper DNS lookup nor an <tt>/etc/hosts</tt> entry exists for a given host, the following exception will be thrown: <code> java.net.UnknownHostException: &lt;hostname&gt;: &lt;hostname&gt; at java.net.InetAddress.getLocalHost(InetAddress.java:1425) ... </code> Instead of just throwing an UnknownHostException and giving up, this method grabs a suitable hostname from the exception and prevents the exception from being thrown. If a suitable hostname cannot be acquired from the exception, only then is the <tt>UnknownHostException</tt> thrown.
 * @return The hostname
 * @throws UnknownHostException
 * @see java.net.InetAddress#getLocalHost()
 * @see java.net.InetAddress#getHostName()
 */
public static String getLocalHostName() throws UnknownHostException {
  try {
    return (InetAddress.getLocalHost()).getHostName();
  }
 catch (  UnknownHostException uhe) {
    String host=uhe.getMessage();
    if (host != null) {
      int colon=host.indexOf(':');
      if (colon > 0) {
        return host.substring(0,colon);
      }
    }
    throw uhe;
  }
}"
41106,"/** 
 * Awaits the termination of the thread pool. <p/> This implementation will log every 2nd second at INFO level that we are waiting, so the end user can see we are not hanging in case it takes longer time to terminate the pool.
 * @param executorService the thread pool
 * @param shutdownAwaitTermination time in millis to use as timeout
 * @return <tt>true</tt> if the pool is terminated, or <tt>false</tt> if we timed out
 * @throws InterruptedException is thrown if we are interrupted during the waiting
 */
public static boolean awaitTermination(ExecutorService executorService,long shutdownAwaitTermination) throws InterruptedException {
  if (executorService == null) {
    return true;
  }
  StopWatch watch=new StopWatch();
  long interval=Math.min(2000,shutdownAwaitTermination);
  boolean done=false;
  while (!done && interval > 0) {
    if (executorService.awaitTermination(interval,TimeUnit.MILLISECONDS)) {
      done=true;
    }
 else {
      LOG.debug(""String_Node_Str"",TimeUtils.printDuration(watch.taken()),executorService);
      interval=Math.min(2000,shutdownAwaitTermination - watch.taken());
    }
  }
  return done;
}","/** 
 * Awaits the termination of the thread pool. <p> This implementation will log every 2nd second at INFO level that we are waiting, so the end user can see we are not hanging in case it takes longer time to terminate the pool.
 * @param executorService the thread pool
 * @param shutdownAwaitTermination time in millis to use as timeout
 * @return <tt>true</tt> if the pool is terminated, or <tt>false</tt> if we timed out
 * @throws InterruptedException is thrown if we are interrupted during the waiting
 */
public static boolean awaitTermination(ExecutorService executorService,long shutdownAwaitTermination) throws InterruptedException {
  if (executorService == null) {
    return true;
  }
  StopWatch watch=new StopWatch();
  long interval=Math.min(2000,shutdownAwaitTermination);
  boolean done=false;
  while (!done && interval > 0) {
    if (executorService.awaitTermination(interval,TimeUnit.MILLISECONDS)) {
      done=true;
    }
 else {
      LOG.debug(""String_Node_Str"",TimeUtils.printDuration(watch.taken()),executorService);
      interval=Math.min(2000,shutdownAwaitTermination - watch.taken());
    }
  }
  return done;
}"
41107,"/** 
 * Shutdown the given executor service graceful at first, and then aggressively if the await termination timeout was hit. <p/> Will try to perform an orderly shutdown by giving the running threads time to complete tasks, before going more aggressively by doing a  {@link #shutdownNow(java.util.concurrent.ExecutorService)} which forces a shutdown. Theparameter <tt>shutdownAwaitTermination</tt> is used as timeout value waiting for orderly shutdown to complete normally, before going aggressively.
 * @param executorService the executor service to shutdown
 * @param shutdownAwaitTermination timeout in millis to wait for orderly shutdown
 */
public static void shutdownGraceful(ExecutorService executorService,long shutdownAwaitTermination){
  doShutdown(executorService,shutdownAwaitTermination);
}","/** 
 * Shutdown the given executor service graceful at first, and then aggressively if the await termination timeout was hit. <p> Will try to perform an orderly shutdown by giving the running threads time to complete tasks, before going more aggressively by doing a  {@link #shutdownNow(java.util.concurrent.ExecutorService)} which forces a shutdown. Theparameter <tt>shutdownAwaitTermination</tt> is used as timeout value waiting for orderly shutdown to complete normally, before going aggressively.
 * @param executorService the executor service to shutdown
 * @param shutdownAwaitTermination timeout in millis to wait for orderly shutdown
 */
public static void shutdownGraceful(ExecutorService executorService,long shutdownAwaitTermination){
  doShutdown(executorService,shutdownAwaitTermination);
}"
41108,"/** 
 * Given a URI parse and extract any URI query options and return them as a Key / Value mapping. This method differs from the   {@link parseQuery} method in that it handles composite URItypes and will extract the URI options from the outermost composite URI.
 * @param uri The URI whose query should be extracted and processed.
 * @return A Mapping of the URI options.
 * @throws URISyntaxException
 */
public static Map<String,String> parseParameters(URI uri) throws URISyntaxException {
  if (!isCompositeURI(uri)) {
    if (uri.getQuery() == null) {
      return Collections.emptyMap();
    }
 else {
      try {
        return PropertyUtil.parseQuery(PropertyUtil.stripPrefix(uri.getQuery(),""String_Node_Str""));
      }
 catch (      Exception e) {
        throw new URISyntaxException(uri.toString(),e.getMessage());
      }
    }
  }
 else {
    CompositeData data=URISupport.parseComposite(uri);
    Map<String,String> parameters=new HashMap<String,String>();
    parameters.putAll(data.getParameters());
    if (parameters.isEmpty()) {
      parameters=Collections.emptyMap();
    }
    return parameters;
  }
}","/** 
 * Given a URI parse and extract any URI query options and return them as a Key / Value mapping. This method handles composite URI types and will extract the URI options from the outermost composite URI.
 * @param uri The URI whose query should be extracted and processed.
 * @return A Mapping of the URI options.
 * @throws URISyntaxException
 */
public static Map<String,String> parseParameters(URI uri) throws URISyntaxException {
  if (!isCompositeURI(uri)) {
    if (uri.getQuery() == null) {
      return Collections.emptyMap();
    }
 else {
      try {
        return PropertyUtil.parseQuery(PropertyUtil.stripPrefix(uri.getQuery(),""String_Node_Str""));
      }
 catch (      Exception e) {
        throw new URISyntaxException(uri.toString(),e.getMessage());
      }
    }
  }
 else {
    CompositeData data=URISupport.parseComposite(uri);
    Map<String,String> parameters=new HashMap<String,String>();
    parameters.putAll(data.getParameters());
    if (parameters.isEmpty()) {
      parameters=Collections.emptyMap();
    }
    return parameters;
  }
}"
41109,"/** 
 * @returns if the currently transaction has been marked as being failed.
 */
boolean isFailed();","/** 
 * @return if the currently transaction has been marked as being failed.
 */
boolean isFailed();"
41110,"/** 
 * Creates an instance of a basic JmsObjectMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @returns a newly created and initialized JmsObjectMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsObjectMessage createObjectMessage() throws JMSException ;","/** 
 * Creates an instance of a basic JmsObjectMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @return a newly created and initialized JmsObjectMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsObjectMessage createObjectMessage() throws JMSException ;"
41111,"/** 
 * Creates an instance of a basic JmsStreamMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @returns a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsStreamMessage createStreamMessage() throws JMSException ;","/** 
 * Creates an instance of a basic JmsStreamMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @return a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsStreamMessage createStreamMessage() throws JMSException ;"
41112,"/** 
 * Creates an instance of a basic JmsTextMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @returns a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsTextMessage createTextMessage() throws JMSException ;","/** 
 * Creates an instance of a basic JmsTextMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @return a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsTextMessage createTextMessage() throws JMSException ;"
41113,"/** 
 * Creates an instance of a basic JmsBytesMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @returns a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsBytesMessage createBytesMessage() throws JMSException ;","/** 
 * Creates an instance of a basic JmsBytesMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @return a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsBytesMessage createBytesMessage() throws JMSException ;"
41114,"/** 
 * Creates an instance of a basic JmsMapMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @returns a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsMapMessage createMapMessage() throws JMSException ;","/** 
 * Creates an instance of a basic JmsMapMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @return a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsMapMessage createMapMessage() throws JMSException ;"
41115,"/** 
 * Performs a copy of this message facade into a new instance.  Calling this method results in a call to reset() prior to the message copy meaning any in use streams will be closed on return.
 * @returns a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 */
@Override JmsBytesMessageFacade copy() throws JMSException ;","/** 
 * Performs a copy of this message facade into a new instance.  Calling this method results in a call to reset() prior to the message copy meaning any in use streams will be closed on return.
 * @return a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 */
@Override JmsBytesMessageFacade copy() throws JMSException ;"
41116,"/** 
 * Determines whether an item exists in this Map based message.
 * @returns true if the item exists in the Map, false otherwise.
 */
boolean itemExists(String key);","/** 
 * Determines whether an item exists in this Map based message.
 * @return true if the item exists in the Map, false otherwise.
 */
boolean itemExists(String key);"
41117,"/** 
 * Gets the value stored in the Map at the specified key.
 * @param key the key to use to access a value in the Map.
 * @returns the item associated with the given key, or null if not present.
 */
Object get(String key);","/** 
 * Gets the value stored in the Map at the specified key.
 * @param key the key to use to access a value in the Map.
 * @return the item associated with the given key, or null if not present.
 */
Object get(String key);"
41118,"/** 
 * @returns a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 * @throws JMSException if an error occurs while copying this message.
 */
@Override JmsMapMessageFacade copy() throws JMSException ;","/** 
 * @return a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 * @throws JMSException if an error occurs while copying this message.
 */
@Override JmsMapMessageFacade copy() throws JMSException ;"
41119,"/** 
 * Remove the mapping for this key from the map if present.  If the value is not present in the map then this method should return without error or modification to the underlying map.
 * @param key the key to be removed from the map if present.
 * @returns the object previously stored in the Map or null if none present.
 */
Object remove(String key);","/** 
 * Remove the mapping for this key from the map if present.  If the value is not present in the map then this method should return without error or modification to the underlying map.
 * @param key the key to be removed from the map if present.
 * @return the object previously stored in the Map or null if none present.
 */
Object remove(String key);"
41120,"/** 
 * @returns true if the given property exists within the message.
 * @throws JMSException if an error occurs while accessing the Message properties.
 */
boolean propertyExists(String key) throws JMSException ;","/** 
 * @return true if the given property exists within the message.
 * @throws JMSException if an error occurs while accessing the Message properties.
 */
boolean propertyExists(String key) throws JMSException ;"
41121,"/** 
 * Used to quickly check if a message has been redelivered.
 * @returns true if the message was redelivered, false otherwise.
 */
boolean isRedelivered();","/** 
 * Used to quickly check if a message has been redelivered.
 * @return true if the message was redelivered, false otherwise.
 */
boolean isRedelivered();"
41122,"/** 
 * @returns a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 * @throws JMSException if an error occurs while copying this message.
 */
@Override JmsObjectMessageFacade copy() throws JMSException ;","/** 
 * @return a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 * @throws JMSException if an error occurs while copying this message.
 */
@Override JmsObjectMessageFacade copy() throws JMSException ;"
41123,"/** 
 * @returns true if the stream contains another element beyond the current.
 */
boolean hasNext();","/** 
 * @return true if the stream contains another element beyond the current.
 */
boolean hasNext();"
41124,"/** 
 * @returns a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 */
@Override JmsStreamMessageFacade copy() throws JMSException ;","/** 
 * @return a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 */
@Override JmsStreamMessageFacade copy() throws JMSException ;"
41125,"/** 
 * Peek and return the next element in the stream.  If the stream has been fully read then this method should throw a MessageEOFException.  Multiple calls to peek should return the same element.
 * @returns the next value in the stream without removing it.
 * @throws MessageEOFException if end of message stream has been reached.
 */
Object peek() throws MessageEOFException ;","/** 
 * Peek and return the next element in the stream.  If the stream has been fully read then this method should throw a MessageEOFException.  Multiple calls to peek should return the same element.
 * @return the next value in the stream without removing it.
 * @throws MessageEOFException if end of message stream has been reached.
 */
Object peek() throws MessageEOFException ;"
41126,"/** 
 * Creates a copy of this JmsTextMessageFacade and its underlying provider message instance.
 * @returns a new JmsTextMessageFacade that wraps a duplicate message.
 */
@Override JmsTextMessageFacade copy() throws JMSException ;","/** 
 * Creates a copy of this JmsTextMessageFacade and its underlying provider message instance.
 * @return a new JmsTextMessageFacade that wraps a duplicate message.
 */
@Override JmsTextMessageFacade copy() throws JMSException ;"
41127,"/** 
 * Gets the Provider specific Message factory for use in the JMS layer when a Session is asked to create a Message type.  The Provider should implement it's own internal JmsMessage core to optimize read / write and marshal operations for the connection.
 * @returns a JmsMessageFactory instance for use by the JMS layer.
 */
JmsMessageFactory getMessageFactory();","/** 
 * Gets the Provider specific Message factory for use in the JMS layer when a Session is asked to create a Message type.  The Provider should implement it's own internal JmsMessage core to optimize read / write and marshal operations for the connection.
 * @return a JmsMessageFactory instance for use by the JMS layer.
 */
JmsMessageFactory getMessageFactory();"
41128,"/** 
 * Sends the given message
 * @param envelope The envelope that contains the message and it's targeted destination.
 * @param request The AsyncRequest that will be notified on send success or failure.
 * @returns true if the producer had credit to send or false if there was no availablecredit and the send needed to be deferred.
 * @throws IOException if an error occurs sending the message
 * @throws JMSException if an error occurs while preparing the message for send.
 */
public abstract boolean send(JmsOutboundMessageDispatch envelope,AsyncResult request) throws IOException, JMSException ;","/** 
 * Sends the given message
 * @param envelope The envelope that contains the message and it's targeted destination.
 * @param request The AsyncRequest that will be notified on send success or failure.
 * @return true if the producer had credit to send or false if there was no availablecredit and the send needed to be deferred.
 * @throws IOException if an error occurs sending the message
 * @throws JMSException if an error occurs while preparing the message for send.
 */
public abstract boolean send(JmsOutboundMessageDispatch envelope,AsyncResult request) throws IOException, JMSException ;"
41129,"/** 
 * @returns true if the remote end has sent an error
 */
boolean hasRemoteError();","/** 
 * @return true if the remote end has sent an error
 */
boolean hasRemoteError();"
41130,"/** 
 * @returns the current size of the URI pool.
 */
public int size(){
  return uris.size();
}","/** 
 * @return the current size of the URI pool.
 */
public int size(){
  return uris.size();
}"
41131,"/** 
 * @returns true if the URI pool is empty.
 */
public boolean isEmpty(){
  return uris.isEmpty();
}","/** 
 * @return true if the URI pool is empty.
 */
public boolean isEmpty(){
  return uris.isEmpty();
}"
41132,"/** 
 * Gets the currently set TransportListener instance
 * @returns the current TransportListener or null if none set.
 */
TransportListener getTransportListener();","/** 
 * Gets the currently set TransportListener instance
 * @return the current TransportListener or null if none set.
 */
TransportListener getTransportListener();"
41133,"/** 
 * @returns the URI of the remote peer that this Transport connects to.
 */
URI getRemoteLocation();","/** 
 * @return the URI of the remote peer that this Transport connects to.
 */
URI getRemoteLocation();"
41134,"/** 
 * @returns the TransportOptions instance that holds the configuration for this Transport.
 */
TransportOptions getTransportOptions();","/** 
 * @return the TransportOptions instance that holds the configuration for this Transport.
 */
TransportOptions getTransportOptions();"
41135,"@Test(timeout=10000,expected=UnsupportedOperationException.class) public void testSetDesinationOnAnonymousProducer() throws Exception {
  JmsMessageProducer producer=(JmsMessageProducer)session.createProducer(null);
  producer.setDestination(topic);
}","@Test(timeout=10000) public void testSetDesinationOnAnonymousProducer() throws Exception {
  JmsMessageProducer producer=(JmsMessageProducer)session.createProducer(null);
  producer.setDestination(topic);
}"
41136,"/** 
 * Sets the prefix used by auto-generated JMS Client ID values which are used if the JMS client does not explicitly specify on.
 * @param clientIDPrefix
 */
public synchronized void setClientIDPrefix(String clientIDPrefix){
  this.clientIDPrefix=clientIDPrefix;
}","/** 
 * Sets the prefix used by auto-generated JMS Client ID values which are used if the JMS client does not explicitly specify one.
 * @param clientIDPrefix the value to use as a prefix on auto-generated client IDs.
 */
public synchronized void setClientIDPrefix(String clientIDPrefix){
  this.clientIDPrefix=clientIDPrefix;
}"
41137,"public synchronized String getClientIDPrefix(){
  return clientIDPrefix;
}","/** 
 * @return the currently configured client ID prefix for auto-generated client IDs.
 */
public synchronized String getClientIDPrefix(){
  return clientIDPrefix;
}"
41138,"protected void readMessagesOnBroker(int count) throws Exception {
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Queue queue=session.createQueue(getDestinationName());
  MessageConsumer consumer=session.createConsumer(queue);
  for (int i=0; i < MESSAGE_COUNT; ++i) {
    Message message=consumer.receive(RECEIVE_TIMEOUT);
    assertNotNull(message);
    LOG.info(""String_Node_Str"",i,message.getClass().getSimpleName());
    String gid=message.getStringProperty(""String_Node_Str"");
    String seq=message.getStringProperty(""String_Node_Str"");
    LOG.info(""String_Node_Str"",gid);
    LOG.info(""String_Node_Str"",seq);
  }
}","protected void readMessagesOnBroker(int count) throws Exception {
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Queue queue=session.createQueue(getDestinationName());
  MessageConsumer consumer=session.createConsumer(queue);
  for (int i=0; i < MESSAGE_COUNT; ++i) {
    Message message=consumer.receive(RECEIVE_TIMEOUT);
    assertNotNull(message);
    LOG.info(""String_Node_Str"",i,message.getClass().getSimpleName());
    String gid=message.getStringProperty(""String_Node_Str"");
    String seq=message.getStringProperty(""String_Node_Str"");
    LOG.info(""String_Node_Str"",gid);
    LOG.info(""String_Node_Str"",seq);
  }
  consumer.close();
}"
41139,"protected void sendMessagesToBroker(int count) throws Exception {
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Queue queue=session.createQueue(getDestinationName());
  MessageProducer producer=session.createProducer(queue);
  byte[] buffer=new byte[MESSAGE_SIZE];
  for (count=0; count < MESSAGE_SIZE; count++) {
    String s=String.valueOf(count % 10);
    Character c=s.charAt(0);
    int value=c.charValue();
    buffer[count]=(byte)value;
  }
  LOG.debug(""String_Node_Str"",MESSAGE_COUNT,queue);
  for (int i=1; i <= MESSAGE_COUNT; i++) {
    BytesMessage message=session.createBytesMessage();
    message.setJMSDeliveryMode(DeliveryMode.PERSISTENT);
    message.setStringProperty(""String_Node_Str"",JMSX_GROUP_ID);
    message.setIntProperty(""String_Node_Str"",i);
    message.writeBytes(buffer);
    producer.send(message);
  }
  producer.close();
}","protected void sendMessagesToBroker(int count) throws Exception {
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Queue queue=session.createQueue(getDestinationName());
  MessageProducer producer=session.createProducer(queue);
  byte[] buffer=new byte[MESSAGE_SIZE];
  for (count=0; count < MESSAGE_SIZE; count++) {
    String s=String.valueOf(count % 10);
    Character c=s.charAt(0);
    int value=c.charValue();
    buffer[count]=(byte)value;
  }
  LOG.debug(""String_Node_Str"",MESSAGE_COUNT,queue);
  for (int i=1; i <= MESSAGE_COUNT; i++) {
    BytesMessage message=session.createBytesMessage();
    message.setJMSDeliveryMode(DeliveryMode.PERSISTENT);
    message.setStringProperty(""String_Node_Str"",JMSX_GROUP_ID);
    message.setIntProperty(""String_Node_Str"",++sequenceCount);
    message.writeBytes(buffer);
    producer.send(message);
  }
  producer.close();
}"
41140,"@Test public void testGroupSeqIsNeverLost() throws Exception {
  connection=createAmqpConnection();
  sendMessagesToBroker(MESSAGE_COUNT);
  readMessagesOnBroker(MESSAGE_COUNT);
  sendMessagesToBroker(MESSAGE_COUNT);
  readMessagesOnBroker(MESSAGE_COUNT);
}","@Test public void testGroupSeqIsNeverLost() throws Exception {
  connection=createAmqpConnection();
  connection.start();
  sendMessagesToBroker(MESSAGE_COUNT);
  readMessagesOnBroker(MESSAGE_COUNT);
  sendMessagesToBroker(MESSAGE_COUNT);
  readMessagesOnBroker(MESSAGE_COUNT);
}"
41141,"@Override public void onMessage(Message message){
  try {
    int msgNumProperty=message.getIntProperty(MESSAGE_NUMBER);
    if (complete) {
      LOG.info(""String_Node_Str"" + msgNumProperty);
      return;
    }
    if (msgNumProperty == 1) {
      if (!seenFirstMessage) {
        LOG.info(""String_Node_Str"");
        seenFirstMessage=true;
      }
 else {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
    }
 else     if (msgNumProperty == 2) {
      if (!seenSecondMessage) {
        seenSecondMessage=true;
        LOG.info(""String_Node_Str"");
        session.recover();
      }
 else {
        LOG.info(""String_Node_Str"");
        seenSecondMessageTwice=true;
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
      }
    }
 else {
      if (msgNumProperty != 3) {
        LOG.error(""String_Node_Str"" + msgNumProperty);
        complete(true);
      }
      if (!seenFirstMessage && !seenSecondMessageTwice) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
      if (message.getJMSRedelivered()) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
 else {
        LOG.info(""String_Node_Str"");
        complete(false);
      }
    }
  }
 catch (  JMSException e) {
    LOG.error(""String_Node_Str"",e);
    complete(true);
  }
}","@Override public void onMessage(Message message){
  try {
    int msgNumProperty=message.getIntProperty(MESSAGE_NUMBER);
    if (complete) {
      LOG.info(""String_Node_Str"" + msgNumProperty);
      return;
    }
    if (msgNumProperty == 1) {
      if (!seenFirstMessage) {
        LOG.info(""String_Node_Str"");
        seenFirstMessage=true;
      }
 else {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
    }
 else     if (msgNumProperty == 2) {
      if (!seenSecondMessage) {
        seenSecondMessage=true;
        LOG.info(""String_Node_Str"");
        session.recover();
      }
 else {
        LOG.info(""String_Node_Str"");
        seenSecondMessageTwice=true;
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
      }
    }
 else {
      if (msgNumProperty != 3) {
        LOG.error(""String_Node_Str"" + msgNumProperty);
        complete(true);
        return;
      }
      if (!(seenFirstMessage && seenSecondMessageTwice)) {
        LOG.error(""String_Node_Str"");
        complete(true);
        return;
      }
      LOG.info(""String_Node_Str"");
      if (message.getJMSRedelivered()) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
 else {
        LOG.info(""String_Node_Str"");
        complete(false);
      }
    }
  }
 catch (  JMSException e) {
    LOG.error(""String_Node_Str"",e);
    complete(true);
  }
}"
41142,"/** 
 * Test use of session recovery while using a client-ack session and a message listener. Calling recover should result in delivery of the previous messages again, followed by those that would have been received afterwards. Send three messages. Consume the first message, then recover on the second message and expect to see both again, ensure the third message is not seen until after this.
 * @throws Exception
 */
@Test(timeout=60000) public void testRecoverInOnMessage() throws Exception {
  connection=createAmqpConnection();
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  assertNotNull(session);
  Queue queue=session.createQueue(name.getMethodName());
  MessageConsumer consumer=session.createConsumer(queue);
  sendMessages(connection,queue,3);
  CountDownLatch latch=new CountDownLatch(1);
  ClientAckRecoverMsgListener listener=new ClientAckRecoverMsgListener(latch,session);
  consumer.setMessageListener(listener);
  connection.start();
  assertTrue(""String_Node_Str"",latch.await(10,TimeUnit.SECONDS));
  assertFalse(""String_Node_Str"",listener.getFailed());
}","/** 
 * Test use of session recovery while using a client-ack session and a message listener. Calling recover should result in delivery of the previous messages again, followed by those that would have been received afterwards. Send three messages. Consume the first message, then recover on the second message and expect to see both again, ensure the third message is not seen until after this.
 * @throws Exception
 */
@Test(timeout=60000) public void testRecoverInOnMessage() throws Exception {
  connection=createAmqpConnection();
  Session session=connection.createSession(false,Session.CLIENT_ACKNOWLEDGE);
  assertNotNull(session);
  Queue queue=session.createQueue(name.getMethodName());
  MessageConsumer consumer=session.createConsumer(queue);
  sendMessages(connection,queue,3);
  CountDownLatch latch=new CountDownLatch(1);
  ClientAckRecoverMsgListener listener=new ClientAckRecoverMsgListener(latch,session);
  consumer.setMessageListener(listener);
  connection.start();
  assertTrue(""String_Node_Str"",latch.await(10,TimeUnit.SECONDS));
  assertFalse(""String_Node_Str"",listener.getFailed());
}"
41143,"@Override public void onMessage(Message message){
  try {
    int msgNumProperty=message.getIntProperty(MESSAGE_NUMBER);
    if (complete) {
      LOG.info(""String_Node_Str"" + msgNumProperty);
      return;
    }
    if (msgNumProperty == 1) {
      if (!seenFirstMessage) {
        LOG.info(""String_Node_Str"");
        seenFirstMessage=true;
      }
 else {
        LOG.info(""String_Node_Str"");
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
        seenFirstMessageTwice=true;
      }
    }
 else     if (msgNumProperty == 2) {
      if (!seenSecondMessage) {
        seenSecondMessage=true;
        LOG.info(""String_Node_Str"");
        session.recover();
      }
 else {
        LOG.info(""String_Node_Str"");
        seenSecondMessageTwice=true;
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
      }
    }
 else {
      if (msgNumProperty != 3) {
        LOG.error(""String_Node_Str"" + msgNumProperty);
        complete(true);
      }
      if (!seenFirstMessageTwice && !seenSecondMessageTwice) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
      if (message.getJMSRedelivered()) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
 else {
        LOG.info(""String_Node_Str"");
        complete(false);
      }
    }
  }
 catch (  JMSException e) {
    LOG.error(""String_Node_Str"",e);
    complete(true);
  }
}","@Override public void onMessage(Message message){
  try {
    int msgNumProperty=message.getIntProperty(MESSAGE_NUMBER);
    if (complete) {
      LOG.info(""String_Node_Str"" + msgNumProperty);
      return;
    }
    if (msgNumProperty == 1) {
      if (!seenFirstMessage) {
        LOG.info(""String_Node_Str"");
        seenFirstMessage=true;
      }
 else {
        LOG.info(""String_Node_Str"");
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
        seenFirstMessageTwice=true;
      }
    }
 else     if (msgNumProperty == 2) {
      if (!seenSecondMessage) {
        seenSecondMessage=true;
        LOG.info(""String_Node_Str"");
        session.recover();
      }
 else {
        if (!seenFirstMessageTwice) {
          LOG.error(""String_Node_Str"");
          complete(true);
          return;
        }
        LOG.info(""String_Node_Str"");
        seenSecondMessageTwice=true;
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
      }
    }
 else {
      if (msgNumProperty != 3) {
        LOG.error(""String_Node_Str"" + msgNumProperty);
        complete(true);
        return;
      }
      if (!(seenFirstMessageTwice && seenSecondMessageTwice)) {
        LOG.error(""String_Node_Str"");
        complete(true);
        return;
      }
      if (message.getJMSRedelivered()) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
 else {
        LOG.info(""String_Node_Str"");
        complete(false);
      }
    }
  }
 catch (  JMSException e) {
    LOG.error(""String_Node_Str"",e);
    complete(true);
  }
}"
41144,"@Test(timeout=600000) public void testRecoverInOnMessage() throws Exception {
  connection=createAmqpConnection();
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  assertNotNull(session);
  Queue queue=session.createQueue(name.getMethodName());
  MessageConsumer consumer=session.createConsumer(queue);
  sendMessages(connection,queue,2);
  CountDownLatch latch=new CountDownLatch(1);
  AutoAckRecoverMsgListener listener=new AutoAckRecoverMsgListener(latch,session);
  consumer.setMessageListener(listener);
  connection.start();
  assertTrue(""String_Node_Str"",latch.await(500,TimeUnit.SECONDS));
  assertFalse(""String_Node_Str"",listener.getFailed());
}","@Test(timeout=60000) public void testRecoverInOnMessage() throws Exception {
  connection=createAmqpConnection();
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  assertNotNull(session);
  Queue queue=session.createQueue(name.getMethodName());
  MessageConsumer consumer=session.createConsumer(queue);
  sendMessages(connection,queue,2);
  CountDownLatch latch=new CountDownLatch(1);
  AutoAckRecoverMsgListener listener=new AutoAckRecoverMsgListener(latch,session);
  consumer.setMessageListener(listener);
  connection.start();
  assertTrue(""String_Node_Str"",latch.await(10,TimeUnit.SECONDS));
  assertFalse(""String_Node_Str"",listener.getFailed());
}"
41145,"/** 
 * @param queue
 * @return QueueSender
 * @throws JMSException
 * @see javax.jms.QueueSession#createSender(javax.jms.Queue)
 */
@Override public QueueSender createSender(Queue queue) throws JMSException {
  checkClosed();
  JmsDestination dest=JmsMessageTransformation.transformDestination(connection,queue);
  JmsQueueSender result=new JmsQueueSender(getNextProducerId(),this,dest);
  return result;
}","/** 
 * @param queue
 * @return QueueSender
 * @throws JMSException
 * @see javax.jms.QueueSession#createSender(javax.jms.Queue)
 */
@Override public QueueSender createSender(Queue queue) throws JMSException {
  checkClosed();
  JmsDestination dest=JmsMessageTransformation.transformDestination(connection,queue);
  JmsQueueSender result=new JmsQueueSender(getNextProducerId(),this,dest);
  add(result);
  return result;
}"
41146,"/** 
 * Searches for a MechanismFactory by using the scheme from the given name. The search first checks the local cache of mechanism factories before moving on to search in the classpath.
 * @param name The name of the authentication mechanism to search for..
 * @return a mechanism factory instance matching the URI's scheme.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static MechanismFactory findMechanismFactory(String name) throws IOException {
  if (name == null || name.isEmpty()) {
    throw new IOException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  MechanismFactory factory=null;
  try {
    factory=MECHANISM_FACTORY_FINDER.newInstance(name);
  }
 catch (  Throwable e) {
    throw new IOException(""String_Node_Str"" + name + ""String_Node_Str"",e);
  }
  return factory;
}","/** 
 * Searches for a MechanismFactory by using the scheme from the given name. The search first checks the local cache of mechanism factories before moving on to search in the classpath.
 * @param name The name of the authentication mechanism to search for..
 * @return a mechanism factory instance matching the URI's scheme.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static MechanismFactory findMechanismFactory(String name) throws IOException {
  if (name == null || name.isEmpty()) {
    throw new IOException(""String_Node_Str"");
  }
  MechanismFactory factory=null;
  try {
    factory=MECHANISM_FACTORY_FINDER.newInstance(name);
  }
 catch (  Throwable e) {
    throw new IOException(""String_Node_Str"" + name + ""String_Node_Str"",e);
  }
  return factory;
}"
41147,"/** 
 * Searches for a DiscoveryAgentFactory by using the scheme from the given URI. The search first checks the local cache of discovery agent factories before moving on to search in the classpath.
 * @param location The URI whose scheme will be used to locate a DiscoveryAgentFactory.
 * @return a DiscoveryAgentFactory instance matching the URI's scheme.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static DiscoveryAgentFactory findAgentFactory(URI location) throws IOException {
  String scheme=location.getScheme();
  if (scheme == null) {
    throw new IOException(""String_Node_Str"" + location + ""String_Node_Str"");
  }
  DiscoveryAgentFactory factory=null;
  if (factory == null) {
    try {
      factory=AGENT_FACTORY_FINDER.newInstance(scheme);
    }
 catch (    Throwable e) {
      throw new IOException(""String_Node_Str"" + scheme + ""String_Node_Str"",e);
    }
  }
  return factory;
}","/** 
 * Searches for a DiscoveryAgentFactory by using the scheme from the given URI. The search first checks the local cache of discovery agent factories before moving on to search in the classpath.
 * @param location The URI whose scheme will be used to locate a DiscoveryAgentFactory.
 * @return a DiscoveryAgentFactory instance matching the URI's scheme.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static DiscoveryAgentFactory findAgentFactory(URI location) throws IOException {
  String scheme=location.getScheme();
  if (scheme == null || scheme.isEmpty()) {
    throw new IOException(""String_Node_Str"");
  }
  DiscoveryAgentFactory factory=null;
  if (factory == null) {
    try {
      factory=AGENT_FACTORY_FINDER.newInstance(scheme);
    }
 catch (    Throwable e) {
      throw new IOException(""String_Node_Str"" + scheme + ""String_Node_Str"",e);
    }
  }
  return factory;
}"
41148,"@Test(timeout=5000) public void testSendBasicBytesMessageWithContent() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    byte[] content=""String_Node_Str"".getBytes();
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propertiesMatcher=new MessagePropertiesSectionMatcher(true);
    propertiesMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propertiesMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(new Binary(content)));
    testPeer.expectTransfer(messageMatcher);
    BytesMessage message=session.createBytesMessage();
    message.writeBytes(content);
    producer.send(message);
  }
 }","@Test(timeout=5000) public void testSendBasicBytesMessageWithContent() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    byte[] content=""String_Node_Str"".getBytes();
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propertiesMatcher=new MessagePropertiesSectionMatcher(true);
    propertiesMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propertiesMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(new Binary(content)));
    testPeer.expectTransfer(messageMatcher);
    BytesMessage message=session.createBytesMessage();
    message.writeBytes(content);
    producer.send(message);
  }
 }"
41149,"@Test(timeout=5000) public void testReceiveBasicBytesMessageWithContentUsingDataSection() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType properties=new PropertiesDescribedType();
    properties.setContentType(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE));
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_BYTES_MESSAGE);
    final byte[] expectedContent=""String_Node_Str"".getBytes();
    DescribedType dataContent=new DataDescribedType(new Binary(expectedContent));
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,properties,null,dataContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertTrue(receivedMessage instanceof BytesMessage);
    BytesMessage bytesMessage=(BytesMessage)receivedMessage;
    assertEquals(expectedContent.length,bytesMessage.getBodyLength());
    byte[] recievedContent=new byte[expectedContent.length];
    int readBytes=bytesMessage.readBytes(recievedContent);
    assertEquals(recievedContent.length,readBytes);
    assertTrue(Arrays.equals(expectedContent,recievedContent));
  }
 }","@Test(timeout=5000) public void testReceiveBasicBytesMessageWithContentUsingDataSection() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType properties=new PropertiesDescribedType();
    properties.setContentType(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE));
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_BYTES_MESSAGE);
    final byte[] expectedContent=""String_Node_Str"".getBytes();
    DescribedType dataContent=new DataDescribedType(new Binary(expectedContent));
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,properties,null,dataContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertTrue(receivedMessage instanceof BytesMessage);
    BytesMessage bytesMessage=(BytesMessage)receivedMessage;
    assertEquals(expectedContent.length,bytesMessage.getBodyLength());
    byte[] recievedContent=new byte[expectedContent.length];
    int readBytes=bytesMessage.readBytes(recievedContent);
    assertEquals(recievedContent.length,readBytes);
    assertTrue(Arrays.equals(expectedContent,recievedContent));
  }
 }"
41150,"/** 
 * Test that a message received from the test peer with an AmqpValue section containing Binary and no content type is returned as a BytesMessage, verify it gives the expected data values when read, and when sent to the test peer it results in an AMQP message containing a data body section and content type of  {@link AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE}
 */
@Test(timeout=5000) public void testReceiveBytesMessageWithAmqpValueAndResendResultsInData() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","/** 
 * Test that a message received from the test peer with an AmqpValue section containing Binary and no content type is returned as a BytesMessage, verify it gives the expected data values when read, and when sent to the test peer it results in an AMQP message containing a data body section and content type of  {@link AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE}
 */
@Test(timeout=5000) public void testReceiveBytesMessageWithAmqpValueAndResendResultsInData() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41151,"/** 
 * Test that a message received from the test peer with a Data section and content type of  {@link AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE} is returned as a BytesMessage, verify itgives the expected data values when read, and when reset and left mid-stream before being resent that it results in the expected AMQP data body section and properties content type being received by the test peer.
 */
@Test(timeout=5000) public void testReceiveBytesMessageAndResendAfterResetAndPartialRead() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType properties=new PropertiesDescribedType();
    Symbol contentType=Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE);
    properties.setContentType(contentType);
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_BYTES_MESSAGE);
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType dataSectionContent=new DataDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,properties,null,dataSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(contentType));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","/** 
 * Test that a message received from the test peer with a Data section and content type of  {@link AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE} is returned as a BytesMessage, verify itgives the expected data values when read, and when reset and left mid-stream before being resent that it results in the expected AMQP data body section and properties content type being received by the test peer.
 */
@Test(timeout=5000) public void testReceiveBytesMessageAndResendAfterResetAndPartialRead() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType properties=new PropertiesDescribedType();
    Symbol contentType=Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE);
    properties.setContentType(contentType);
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_BYTES_MESSAGE);
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType dataSectionContent=new DataDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,properties,null,dataSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(contentType));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41152,"@Test(timeout=10000) public void testCreateAndCloseConnection() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectClose();
    connection.close();
  }
 }","@Test(timeout=10000) public void testCreateAndCloseConnection() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectClose();
    connection.close();
  }
 }"
41153,"@Test(timeout=5000) public void testCreateTransactedSession() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    CoordinatorMatcher txCoordinatorMatcher=new CoordinatorMatcher();
    txCoordinatorMatcher.withCapabilities(arrayContaining(TxnCapability.LOCAL_TXN));
    testPeer.expectSenderAttach(txCoordinatorMatcher,false,false);
    Session session=connection.createSession(true,Session.SESSION_TRANSACTED);
    assertNotNull(""String_Node_Str"",session);
  }
 }","@Test(timeout=5000) public void testCreateTransactedSession() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    CoordinatorMatcher txCoordinatorMatcher=new CoordinatorMatcher();
    txCoordinatorMatcher.withCapabilities(arrayContaining(TxnCapability.LOCAL_TXN));
    testPeer.expectSenderAttach(txCoordinatorMatcher,false,false);
    Session session=connection.createSession(true,Session.SESSION_TRANSACTED);
    assertNotNull(""String_Node_Str"",session);
  }
 }"
41154,"@Test(timeout=5000) public void testConnectionMetaDataVersion() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    ConnectionMetaData meta=connection.getMetaData();
    assertTrue(""String_Node_Str"",meta.getProviderMajorVersion() != 0);
  }
 }","@Test(timeout=5000) public void testConnectionMetaDataVersion() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    ConnectionMetaData meta=connection.getMetaData();
    assertTrue(""String_Node_Str"",meta.getProviderMajorVersion() != 0);
  }
 }"
41155,"@Test(timeout=10000) public void testCreateAutoAckSession() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    assertNotNull(""String_Node_Str"",session);
  }
 }","@Test(timeout=10000) public void testCreateAutoAckSession() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    assertNotNull(""String_Node_Str"",session);
  }
 }"
41156,"Connection establishConnecton(TestAmqpPeer testPeer,String optionsString,Symbol[] serverCapabilities,Map<Symbol,Object> serverProperties) throws JMSException {
  testPeer.expectPlainConnect(""String_Node_Str"",""String_Node_Str"",serverCapabilities,serverProperties);
  testPeer.expectBegin(true);
  final String baseURI=""String_Node_Str"" + PORT;
  String brokerURI=baseURI;
  if (optionsString != null) {
    brokerURI=baseURI + optionsString;
  }
  ConnectionFactory factory=new JmsConnectionFactory(brokerURI);
  Connection connection=factory.createConnection(""String_Node_Str"",""String_Node_Str"");
  connection.setClientID(""String_Node_Str"");
  assertNull(testPeer.getThrowable());
  return connection;
}","Connection establishConnecton(TestAmqpPeer testPeer,String optionsString,Symbol[] serverCapabilities,Map<Symbol,Object> serverProperties) throws JMSException {
  testPeer.expectPlainConnect(""String_Node_Str"",""String_Node_Str"",serverCapabilities,serverProperties);
  testPeer.expectBegin(true);
  final String baseURI=""String_Node_Str"" + getAvailablePort();
  String brokerURI=baseURI;
  if (optionsString != null) {
    brokerURI=baseURI + optionsString;
  }
  ConnectionFactory factory=new JmsConnectionFactory(brokerURI);
  Connection connection=factory.createConnection(""String_Node_Str"",""String_Node_Str"");
  connection.setClientID(""String_Node_Str"");
  assertNull(testPeer.getThrowable());
  return connection;
}"
41157,"@Test(timeout=5000) public void testSendBasicMapMessage() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    String myBoolKey=""String_Node_Str"";
    boolean myBool=true;
    String myByteKey=""String_Node_Str"";
    byte myByte=4;
    String myBytesKey=""String_Node_Str"";
    byte[] myBytes=myBytesKey.getBytes();
    String myCharKey=""String_Node_Str"";
    char myChar='d';
    String myDoubleKey=""String_Node_Str"";
    double myDouble=1234567890123456789.1234;
    String myFloatKey=""String_Node_Str"";
    float myFloat=1.1F;
    String myIntKey=""String_Node_Str"";
    int myInt=Integer.MAX_VALUE;
    String myLongKey=""String_Node_Str"";
    long myLong=Long.MAX_VALUE;
    String myShortKey=""String_Node_Str"";
    short myShort=25;
    String myStringKey=""String_Node_Str"";
    String myString=myStringKey;
    MapMessage mapMessage=session.createMapMessage();
    mapMessage.setBoolean(myBoolKey,myBool);
    mapMessage.setByte(myByteKey,myByte);
    mapMessage.setBytes(myBytesKey,myBytes);
    mapMessage.setChar(myCharKey,myChar);
    mapMessage.setDouble(myDoubleKey,myDouble);
    mapMessage.setFloat(myFloatKey,myFloat);
    mapMessage.setInt(myIntKey,myInt);
    mapMessage.setLong(myLongKey,myLong);
    mapMessage.setShort(myShortKey,myShort);
    mapMessage.setString(myStringKey,myString);
    Map<String,Object> map=new LinkedHashMap<String,Object>();
    map.put(myBoolKey,myBool);
    map.put(myByteKey,myByte);
    map.put(myBytesKey,new Binary(myBytes));
    map.put(myCharKey,(int)myChar);
    map.put(myDoubleKey,myDouble);
    map.put(myFloatKey,myFloat);
    map.put(myIntKey,myInt);
    map.put(myLongKey,myLong);
    map.put(myShortKey,myShort);
    map.put(myStringKey,myString);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_MAP_MESSAGE));
    MessagePropertiesSectionMatcher propertiesMatcher=new MessagePropertiesSectionMatcher(true);
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propertiesMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(map));
    testPeer.expectTransfer(messageMatcher);
    producer.send(mapMessage);
  }
 }","@Test(timeout=5000) public void testSendBasicMapMessage() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    String myBoolKey=""String_Node_Str"";
    boolean myBool=true;
    String myByteKey=""String_Node_Str"";
    byte myByte=4;
    String myBytesKey=""String_Node_Str"";
    byte[] myBytes=myBytesKey.getBytes();
    String myCharKey=""String_Node_Str"";
    char myChar='d';
    String myDoubleKey=""String_Node_Str"";
    double myDouble=1234567890123456789.1234;
    String myFloatKey=""String_Node_Str"";
    float myFloat=1.1F;
    String myIntKey=""String_Node_Str"";
    int myInt=Integer.MAX_VALUE;
    String myLongKey=""String_Node_Str"";
    long myLong=Long.MAX_VALUE;
    String myShortKey=""String_Node_Str"";
    short myShort=25;
    String myStringKey=""String_Node_Str"";
    String myString=myStringKey;
    MapMessage mapMessage=session.createMapMessage();
    mapMessage.setBoolean(myBoolKey,myBool);
    mapMessage.setByte(myByteKey,myByte);
    mapMessage.setBytes(myBytesKey,myBytes);
    mapMessage.setChar(myCharKey,myChar);
    mapMessage.setDouble(myDoubleKey,myDouble);
    mapMessage.setFloat(myFloatKey,myFloat);
    mapMessage.setInt(myIntKey,myInt);
    mapMessage.setLong(myLongKey,myLong);
    mapMessage.setShort(myShortKey,myShort);
    mapMessage.setString(myStringKey,myString);
    Map<String,Object> map=new LinkedHashMap<String,Object>();
    map.put(myBoolKey,myBool);
    map.put(myByteKey,myByte);
    map.put(myBytesKey,new Binary(myBytes));
    map.put(myCharKey,(int)myChar);
    map.put(myDoubleKey,myDouble);
    map.put(myFloatKey,myFloat);
    map.put(myIntKey,myInt);
    map.put(myLongKey,myLong);
    map.put(myShortKey,myShort);
    map.put(myStringKey,myString);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_MAP_MESSAGE));
    MessagePropertiesSectionMatcher propertiesMatcher=new MessagePropertiesSectionMatcher(true);
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propertiesMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(map));
    testPeer.expectTransfer(messageMatcher);
    producer.send(mapMessage);
  }
 }"
41158,"/** 
 * Test that a message received from the test peer with an AmqpValue section containing a map which holds entries of the various supported entry types is returned as a  {@link MapMessage}, and verify the values can all be retrieved as expected.
 */
@Test(timeout=5000) public void testReceiveBasicMapMessage() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    String myBoolKey=""String_Node_Str"";
    boolean myBool=true;
    String myByteKey=""String_Node_Str"";
    byte myByte=4;
    String myBytesKey=""String_Node_Str"";
    byte[] myBytes=myBytesKey.getBytes();
    String myCharKey=""String_Node_Str"";
    char myChar='d';
    String myDoubleKey=""String_Node_Str"";
    double myDouble=1234567890123456789.1234;
    String myFloatKey=""String_Node_Str"";
    float myFloat=1.1F;
    String myIntKey=""String_Node_Str"";
    int myInt=Integer.MAX_VALUE;
    String myLongKey=""String_Node_Str"";
    long myLong=Long.MAX_VALUE;
    String myShortKey=""String_Node_Str"";
    short myShort=25;
    String myStringKey=""String_Node_Str"";
    String myString=myStringKey;
    Map<String,Object> map=new LinkedHashMap<String,Object>();
    map.put(myBoolKey,myBool);
    map.put(myByteKey,myByte);
    map.put(myBytesKey,new Binary(myBytes));
    map.put(myCharKey,myChar);
    map.put(myDoubleKey,myDouble);
    map.put(myFloatKey,myFloat);
    map.put(myIntKey,myInt);
    map.put(myLongKey,myLong);
    map.put(myShortKey,myShort);
    map.put(myStringKey,myString);
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_MAP_MESSAGE);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(map);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof MapMessage);
    MapMessage receivedMapMessage=(MapMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedMapMessage.getBoolean(myBoolKey));
    assertEquals(""String_Node_Str"",myByte,receivedMapMessage.getByte(myByteKey));
    byte[] readBytes=receivedMapMessage.getBytes(myBytesKey);
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedMapMessage.getChar(myCharKey));
    assertEquals(""String_Node_Str"",myDouble,receivedMapMessage.getDouble(myDoubleKey),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedMapMessage.getFloat(myFloatKey),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedMapMessage.getInt(myIntKey));
    assertEquals(""String_Node_Str"",myLong,receivedMapMessage.getLong(myLongKey));
    assertEquals(""String_Node_Str"",myShort,receivedMapMessage.getShort(myShortKey));
    assertEquals(""String_Node_Str"",myString,receivedMapMessage.getString(myStringKey));
  }
 }","/** 
 * Test that a message received from the test peer with an AmqpValue section containing a map which holds entries of the various supported entry types is returned as a  {@link MapMessage}, and verify the values can all be retrieved as expected.
 */
@Test(timeout=5000) public void testReceiveBasicMapMessage() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    String myBoolKey=""String_Node_Str"";
    boolean myBool=true;
    String myByteKey=""String_Node_Str"";
    byte myByte=4;
    String myBytesKey=""String_Node_Str"";
    byte[] myBytes=myBytesKey.getBytes();
    String myCharKey=""String_Node_Str"";
    char myChar='d';
    String myDoubleKey=""String_Node_Str"";
    double myDouble=1234567890123456789.1234;
    String myFloatKey=""String_Node_Str"";
    float myFloat=1.1F;
    String myIntKey=""String_Node_Str"";
    int myInt=Integer.MAX_VALUE;
    String myLongKey=""String_Node_Str"";
    long myLong=Long.MAX_VALUE;
    String myShortKey=""String_Node_Str"";
    short myShort=25;
    String myStringKey=""String_Node_Str"";
    String myString=myStringKey;
    Map<String,Object> map=new LinkedHashMap<String,Object>();
    map.put(myBoolKey,myBool);
    map.put(myByteKey,myByte);
    map.put(myBytesKey,new Binary(myBytes));
    map.put(myCharKey,myChar);
    map.put(myDoubleKey,myDouble);
    map.put(myFloatKey,myFloat);
    map.put(myIntKey,myInt);
    map.put(myLongKey,myLong);
    map.put(myShortKey,myShort);
    map.put(myStringKey,myString);
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_MAP_MESSAGE);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(map);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof MapMessage);
    MapMessage receivedMapMessage=(MapMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedMapMessage.getBoolean(myBoolKey));
    assertEquals(""String_Node_Str"",myByte,receivedMapMessage.getByte(myByteKey));
    byte[] readBytes=receivedMapMessage.getBytes(myBytesKey);
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedMapMessage.getChar(myCharKey));
    assertEquals(""String_Node_Str"",myDouble,receivedMapMessage.getDouble(myDoubleKey),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedMapMessage.getFloat(myFloatKey),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedMapMessage.getInt(myIntKey));
    assertEquals(""String_Node_Str"",myLong,receivedMapMessage.getLong(myLongKey));
    assertEquals(""String_Node_Str"",myShort,receivedMapMessage.getShort(myShortKey));
    assertEquals(""String_Node_Str"",myString,receivedMapMessage.getString(myStringKey));
  }
 }"
41159,"private void sentMessageWithCorrelationIdTestImpl(String stringCorrelationId,Object correlationIdForAmqpMessageClass,boolean appSpecific) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withCorrelationId(equalTo(correlationIdForAmqpMessageClass));
    if (appSpecific) {
      msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_APP_CORRELATION_ID),equalTo(Boolean.TRUE));
    }
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setJMSCorrelationID(stringCorrelationId);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(3000);
    if (!appSpecific) {
      assertFalse(msgAnnotationsMatcher.keyExistsInReceivedAnnotations(Symbol.valueOf(AmqpMessageSupport.JMS_APP_CORRELATION_ID)));
    }
  }
 }","private void sentMessageWithCorrelationIdTestImpl(String stringCorrelationId,Object correlationIdForAmqpMessageClass,boolean appSpecific) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withCorrelationId(equalTo(correlationIdForAmqpMessageClass));
    if (appSpecific) {
      msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_APP_CORRELATION_ID),equalTo(Boolean.TRUE));
    }
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setJMSCorrelationID(stringCorrelationId);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(3000);
    if (!appSpecific) {
      assertFalse(msgAnnotationsMatcher.keyExistsInReceivedAnnotations(Symbol.valueOf(AmqpMessageSupport.JMS_APP_CORRELATION_ID)));
    }
  }
 }"
41160,"@Test(timeout=2000) public void testReceiveMessageWithApplicationProperties() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    ApplicationPropertiesDescribedType appProperties=new ApplicationPropertiesDescribedType();
    appProperties.setApplicationProperty(STRING_PROP,STRING_PROP_VALUE);
    appProperties.setApplicationProperty(NULL_STRING_PROP,NULL_STRING_PROP_VALUE);
    appProperties.setApplicationProperty(BOOLEAN_PROP,BOOLEAN_PROP_VALUE);
    appProperties.setApplicationProperty(BYTE_PROP,BYTE_PROP_VALUE);
    appProperties.setApplicationProperty(SHORT_PROP,SHORT_PROP_VALUE);
    appProperties.setApplicationProperty(INT_PROP,INT_PROP_VALUE);
    appProperties.setApplicationProperty(LONG_PROP,LONG_PROP_VALUE);
    appProperties.setApplicationProperty(FLOAT_PROP,FLOAT_PROP_VALUE);
    appProperties.setApplicationProperty(DOUBLE_PROP,DOUBLE_PROP_VALUE);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,appProperties,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertTrue(receivedMessage.propertyExists(STRING_PROP));
    assertTrue(receivedMessage.propertyExists(NULL_STRING_PROP));
    assertTrue(receivedMessage.propertyExists(BYTE_PROP));
    assertTrue(receivedMessage.propertyExists(BOOLEAN_PROP));
    assertTrue(receivedMessage.propertyExists(SHORT_PROP));
    assertTrue(receivedMessage.propertyExists(INT_PROP));
    assertTrue(receivedMessage.propertyExists(LONG_PROP));
    assertTrue(receivedMessage.propertyExists(FLOAT_PROP));
    assertTrue(receivedMessage.propertyExists(DOUBLE_PROP));
    assertNull(receivedMessage.getStringProperty(NULL_STRING_PROP));
    assertEquals(STRING_PROP_VALUE,receivedMessage.getStringProperty(STRING_PROP));
    assertEquals(STRING_PROP_VALUE,receivedMessage.getStringProperty(STRING_PROP));
    assertEquals(BOOLEAN_PROP_VALUE,receivedMessage.getBooleanProperty(BOOLEAN_PROP));
    assertEquals(BYTE_PROP_VALUE,receivedMessage.getByteProperty(BYTE_PROP));
    assertEquals(SHORT_PROP_VALUE,receivedMessage.getShortProperty(SHORT_PROP));
    assertEquals(INT_PROP_VALUE,receivedMessage.getIntProperty(INT_PROP));
    assertEquals(LONG_PROP_VALUE,receivedMessage.getLongProperty(LONG_PROP));
    assertEquals(FLOAT_PROP_VALUE,receivedMessage.getFloatProperty(FLOAT_PROP),0.0);
    assertEquals(DOUBLE_PROP_VALUE,receivedMessage.getDoubleProperty(DOUBLE_PROP),0.0);
  }
 }","@Test(timeout=2000) public void testReceiveMessageWithApplicationProperties() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    ApplicationPropertiesDescribedType appProperties=new ApplicationPropertiesDescribedType();
    appProperties.setApplicationProperty(STRING_PROP,STRING_PROP_VALUE);
    appProperties.setApplicationProperty(NULL_STRING_PROP,NULL_STRING_PROP_VALUE);
    appProperties.setApplicationProperty(BOOLEAN_PROP,BOOLEAN_PROP_VALUE);
    appProperties.setApplicationProperty(BYTE_PROP,BYTE_PROP_VALUE);
    appProperties.setApplicationProperty(SHORT_PROP,SHORT_PROP_VALUE);
    appProperties.setApplicationProperty(INT_PROP,INT_PROP_VALUE);
    appProperties.setApplicationProperty(LONG_PROP,LONG_PROP_VALUE);
    appProperties.setApplicationProperty(FLOAT_PROP,FLOAT_PROP_VALUE);
    appProperties.setApplicationProperty(DOUBLE_PROP,DOUBLE_PROP_VALUE);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,appProperties,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertTrue(receivedMessage.propertyExists(STRING_PROP));
    assertTrue(receivedMessage.propertyExists(NULL_STRING_PROP));
    assertTrue(receivedMessage.propertyExists(BYTE_PROP));
    assertTrue(receivedMessage.propertyExists(BOOLEAN_PROP));
    assertTrue(receivedMessage.propertyExists(SHORT_PROP));
    assertTrue(receivedMessage.propertyExists(INT_PROP));
    assertTrue(receivedMessage.propertyExists(LONG_PROP));
    assertTrue(receivedMessage.propertyExists(FLOAT_PROP));
    assertTrue(receivedMessage.propertyExists(DOUBLE_PROP));
    assertNull(receivedMessage.getStringProperty(NULL_STRING_PROP));
    assertEquals(STRING_PROP_VALUE,receivedMessage.getStringProperty(STRING_PROP));
    assertEquals(STRING_PROP_VALUE,receivedMessage.getStringProperty(STRING_PROP));
    assertEquals(BOOLEAN_PROP_VALUE,receivedMessage.getBooleanProperty(BOOLEAN_PROP));
    assertEquals(BYTE_PROP_VALUE,receivedMessage.getByteProperty(BYTE_PROP));
    assertEquals(SHORT_PROP_VALUE,receivedMessage.getShortProperty(SHORT_PROP));
    assertEquals(INT_PROP_VALUE,receivedMessage.getIntProperty(INT_PROP));
    assertEquals(LONG_PROP_VALUE,receivedMessage.getLongProperty(LONG_PROP));
    assertEquals(FLOAT_PROP_VALUE,receivedMessage.getFloatProperty(FLOAT_PROP),0.0);
    assertEquals(DOUBLE_PROP_VALUE,receivedMessage.getDoubleProperty(DOUBLE_PROP),0.0);
  }
 }"
41161,"public void receivedMessageFromQueueWithoutToResultsInUseOfConsumerDestinationImpl(boolean useQueue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    String queueName=""String_Node_Str"";
    String topicName=""String_Node_Str"";
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination destination=null;
    if (useQueue) {
      destination=session.createQueue(queueName);
    }
 else {
      destination=session.createTopic(topicName);
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(destination);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSDestination();
    if (useQueue) {
      assertNotNull(""String_Node_Str"",dest);
      assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Queue);
      assertEquals(queueName,((Queue)dest).getQueueName());
    }
 else {
      assertNotNull(""String_Node_Str"",dest);
      assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Topic);
      assertEquals(topicName,((Topic)dest).getTopicName());
    }
  }
 }","public void receivedMessageFromQueueWithoutToResultsInUseOfConsumerDestinationImpl(boolean useQueue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    String queueName=""String_Node_Str"";
    String topicName=""String_Node_Str"";
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination destination=null;
    if (useQueue) {
      destination=session.createQueue(queueName);
    }
 else {
      destination=session.createTopic(topicName);
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(destination);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSDestination();
    if (useQueue) {
      assertNotNull(""String_Node_Str"",dest);
      assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Queue);
      assertEquals(queueName,((Queue)dest).getQueueName());
    }
 else {
      assertNotNull(""String_Node_Str"",dest);
      assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Topic);
      assertEquals(topicName,((Topic)dest).getTopicName());
    }
  }
 }"
41162,"private void recieveMessageIdSendCorrelationIdTestImpl(Object idForAmqpMessageClass) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(idForAmqpMessageClass);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(idForAmqpMessageClass);
    String jmsMessageID=receivedMessage.getJMSMessageID();
    assertEquals(""String_Node_Str"" + expectedBaseIdString,jmsMessageID);
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withCorrelationId(equalTo(idForAmqpMessageClass));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setJMSCorrelationID(jmsMessageID);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","private void recieveMessageIdSendCorrelationIdTestImpl(Object idForAmqpMessageClass) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(idForAmqpMessageClass);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(idForAmqpMessageClass);
    String jmsMessageID=receivedMessage.getJMSMessageID();
    assertEquals(""String_Node_Str"" + expectedBaseIdString,jmsMessageID);
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withCorrelationId(equalTo(idForAmqpMessageClass));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setJMSCorrelationID(jmsMessageID);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41163,"/** 
 * Tests that the   {@link AmqpMessageSupport#LEGACY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} set on a message toindicate its 'to' address represents a Topic results in the JMSDestination object being a Topic. Ensure the consumers destination is not used by consuming from a Queue.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithToLegacyTypeAnnotationForTopic() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.LEGACY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,AmqpMessageSupport.LEGACY_TOPIC_ATTRIBUTE);
    PropertiesDescribedType props=new PropertiesDescribedType();
    String myTopicAddress=""String_Node_Str"";
    props.setTo(myTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSDestination();
    assertNotNull(""String_Node_Str"",dest);
    assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Topic);
    assertEquals(myTopicAddress,((Topic)dest).getTopicName());
  }
 }","/** 
 * Tests that the   {@link AmqpMessageSupport#LEGACY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} set on a message toindicate its 'to' address represents a Topic results in the JMSDestination object being a Topic. Ensure the consumers destination is not used by consuming from a Queue.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithToLegacyTypeAnnotationForTopic() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.LEGACY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,AmqpMessageSupport.LEGACY_TOPIC_ATTRIBUTE);
    PropertiesDescribedType props=new PropertiesDescribedType();
    String myTopicAddress=""String_Node_Str"";
    props.setTo(myTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSDestination();
    assertNotNull(""String_Node_Str"",dest);
    assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Topic);
    assertEquals(myTopicAddress,((Topic)dest).getTopicName());
  }
 }"
41164,"/** 
 * Tests that the   {@link AmqpDestinationHelper#JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME} is set as a byte ona sent message to indicate its 'to' address represents a Topic JMSDestination.
 */
@Test(timeout=5000) public void testSentMessageContainsToTypeAnnotationByte() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String topicName=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    Symbol annotationKey=AmqpMessageSupport.getSymbol(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
    msgAnnotationsMatcher.withEntry(annotationKey,equalTo(AmqpDestinationHelper.TOPIC_TYPE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withTo(equalTo(topicName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    Topic topic=session.createTopic(topicName);
    MessageProducer producer=session.createProducer(topic);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","/** 
 * Tests that the   {@link AmqpDestinationHelper#JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME} is set as a byte ona sent message to indicate its 'to' address represents a Topic JMSDestination.
 */
@Test(timeout=5000) public void testSentMessageContainsToTypeAnnotationByte() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String topicName=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    Symbol annotationKey=AmqpMessageSupport.getSymbol(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
    msgAnnotationsMatcher.withEntry(annotationKey,equalTo(AmqpDestinationHelper.TOPIC_TYPE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withTo(equalTo(topicName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    Topic topic=session.createTopic(topicName);
    MessageProducer producer=session.createProducer(topic);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41165,"private void receivedMessageWithMessageIdTestImpl(Object underlyingAmqpMessageId) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(underlyingAmqpMessageId);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(underlyingAmqpMessageId);
    assertEquals(""String_Node_Str"" + expectedBaseIdString,receivedMessage.getJMSMessageID());
  }
 }","private void receivedMessageWithMessageIdTestImpl(Object underlyingAmqpMessageId) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(underlyingAmqpMessageId);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(underlyingAmqpMessageId);
    assertEquals(""String_Node_Str"" + expectedBaseIdString,receivedMessage.getJMSMessageID());
  }
 }"
41166,"/** 
 * Tests that lack of any destination type annotation value (via either  {@link AmqpDestinationHelper#JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME}or   {@link AmqpMessageSupport#LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME}) set on a message to indicate type of its 'reply-to' address results in it being classed as the same type as the consumer destination.
 */
@Test(timeout=2000) public void testReceivedMessageFromTopicWithReplyToWithoutTypeAnnotationResultsInUseOfConsumerDestinationType() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Topic topic=session.createTopic(""String_Node_Str"");
    String myReplyTopicAddress=""String_Node_Str"";
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setReplyTo(myReplyTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(topic);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",dest);
    assertTrue(""String_Node_Str"" + dest.getClass(),dest instanceof Topic);
    assertEquals(myReplyTopicAddress,((Topic)dest).getTopicName());
  }
 }","/** 
 * Tests that lack of any destination type annotation value (via either  {@link AmqpDestinationHelper#JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME}or   {@link AmqpMessageSupport#LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME}) set on a message to indicate type of its 'reply-to' address results in it being classed as the same type as the consumer destination.
 */
@Test(timeout=2000) public void testReceivedMessageFromTopicWithReplyToWithoutTypeAnnotationResultsInUseOfConsumerDestinationType() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Topic topic=session.createTopic(""String_Node_Str"");
    String myReplyTopicAddress=""String_Node_Str"";
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setReplyTo(myReplyTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(topic);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",dest);
    assertTrue(""String_Node_Str"" + dest.getClass(),dest instanceof Topic);
    assertEquals(myReplyTopicAddress,((Topic)dest).getTopicName());
  }
 }"
41167,"private void doReceivedMessageOnConnectionWithPrefixTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String replyName,String destAddress,String replyAddress,String annotationName,Object annotationValue,String replyAnnotationName,Object replyAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=null;
    if (destType == Topic.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else     if (destType == Queue.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix + ""String_Node_Str""+ destPrefix);
    }
    connection.start();
    if (destType == Topic.class) {
      ((JmsConnection)connection).setTopicPrefix(destPrefix);
    }
 else     if (destType == Queue.class) {
      ((JmsConnection)connection).setQueuePrefix(destPrefix);
    }
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else     if (destType == TemporaryTopic.class) {
      testPeer.expectTempTopicCreationAttach(destAddress);
      dest=session.createTemporaryTopic();
    }
 else     if (destType == TemporaryQueue.class) {
      testPeer.expectTempQueueCreationAttach(destAddress);
      dest=session.createTemporaryQueue();
    }
    MessageAnnotationsDescribedType msgAnnotations=null;
    if (annotationName != null || replyAnnotationName != null) {
      msgAnnotations=new MessageAnnotationsDescribedType();
      if (annotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(annotationName,annotationValue);
      }
      if (replyAnnotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(replyAnnotationName,replyAnnotationValue);
      }
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setTo(destAddress);
    props.setReplyTo(replyAddress);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    SourceMatcher sourceMatcher=new SourceMatcher();
    sourceMatcher.withAddress(equalTo(destAddress));
    testPeer.expectReceiverAttach(notNullValue(),sourceMatcher);
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(dest);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNotNull(receivedMessage);
    Destination jmsDest=receivedMessage.getJMSDestination();
    Destination jmsReplyTo=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",jmsDest);
    assertNotNull(""String_Node_Str"",jmsReplyTo);
    String recievedName=null;
    String recievedReplyName=null;
    if (destType == Topic.class || destType == TemporaryTopic.class) {
      recievedName=((Topic)jmsDest).getTopicName();
      recievedReplyName=((Topic)jmsReplyTo).getTopicName();
    }
 else     if (destType == Queue.class || destType == TemporaryQueue.class) {
      recievedName=((Queue)jmsDest).getQueueName();
      recievedReplyName=((Queue)jmsReplyTo).getQueueName();
    }
    assertEquals(""String_Node_Str"",destName,recievedName);
    assertEquals(""String_Node_Str"",replyName,recievedReplyName);
    if (destType == TemporaryQueue.class || destType == TemporaryTopic.class) {
      assertEquals(""String_Node_Str"",destName,destAddress);
      assertEquals(""String_Node_Str"",replyName,replyAddress);
    }
  }
 }","private void doReceivedMessageOnConnectionWithPrefixTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String replyName,String destAddress,String replyAddress,String annotationName,Object annotationValue,String replyAnnotationName,Object replyAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=null;
    if (destType == Topic.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else     if (destType == Queue.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix + ""String_Node_Str""+ destPrefix);
    }
    connection.start();
    if (destType == Topic.class) {
      ((JmsConnection)connection).setTopicPrefix(destPrefix);
    }
 else     if (destType == Queue.class) {
      ((JmsConnection)connection).setQueuePrefix(destPrefix);
    }
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else     if (destType == TemporaryTopic.class) {
      testPeer.expectTempTopicCreationAttach(destAddress);
      dest=session.createTemporaryTopic();
    }
 else     if (destType == TemporaryQueue.class) {
      testPeer.expectTempQueueCreationAttach(destAddress);
      dest=session.createTemporaryQueue();
    }
    MessageAnnotationsDescribedType msgAnnotations=null;
    if (annotationName != null || replyAnnotationName != null) {
      msgAnnotations=new MessageAnnotationsDescribedType();
      if (annotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(annotationName,annotationValue);
      }
      if (replyAnnotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(replyAnnotationName,replyAnnotationValue);
      }
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setTo(destAddress);
    props.setReplyTo(replyAddress);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    SourceMatcher sourceMatcher=new SourceMatcher();
    sourceMatcher.withAddress(equalTo(destAddress));
    testPeer.expectReceiverAttach(notNullValue(),sourceMatcher);
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(dest);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNotNull(receivedMessage);
    Destination jmsDest=receivedMessage.getJMSDestination();
    Destination jmsReplyTo=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",jmsDest);
    assertNotNull(""String_Node_Str"",jmsReplyTo);
    String recievedName=null;
    String recievedReplyName=null;
    if (destType == Topic.class || destType == TemporaryTopic.class) {
      recievedName=((Topic)jmsDest).getTopicName();
      recievedReplyName=((Topic)jmsReplyTo).getTopicName();
    }
 else     if (destType == Queue.class || destType == TemporaryQueue.class) {
      recievedName=((Queue)jmsDest).getQueueName();
      recievedReplyName=((Queue)jmsReplyTo).getQueueName();
    }
    assertEquals(""String_Node_Str"",destName,recievedName);
    assertEquals(""String_Node_Str"",replyName,recievedReplyName);
    if (destType == TemporaryQueue.class || destType == TemporaryTopic.class) {
      assertEquals(""String_Node_Str"",destName,destAddress);
      assertEquals(""String_Node_Str"",replyName,replyAddress);
    }
  }
 }"
41168,"/** 
 * Tests that when sending a message with the JMSXGroupID, JMSXGroupSeq, and JMS_AMQP_REPLY_TO_GROUP_ID properties of the JMS message set, that the expected values are included in the fields of the AMQP message emitted.
 */
@Test(timeout=2000) public void testSendMessageWithGroupRelatedPropertiesSet() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    String expectedGroupId=""String_Node_Str"";
    int expectedGroupSeq=1;
    String expectedReplyToGroupId=""String_Node_Str"";
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withGroupId(equalTo(expectedGroupId));
    propsMatcher.withReplyToGroupId(equalTo(expectedReplyToGroupId));
    propsMatcher.withGroupSequence(equalTo(UnsignedInteger.valueOf(expectedGroupSeq)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setStringProperty(JmsClientProperties.JMSXGROUPID,expectedGroupId);
    message.setIntProperty(JmsClientProperties.JMSXGROUPSEQ,expectedGroupSeq);
    message.setStringProperty(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID,expectedReplyToGroupId);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }","/** 
 * Tests that when sending a message with the JMSXGroupID, JMSXGroupSeq, and JMS_AMQP_REPLY_TO_GROUP_ID properties of the JMS message set, that the expected values are included in the fields of the AMQP message emitted.
 */
@Test(timeout=2000) public void testSendMessageWithGroupRelatedPropertiesSet() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    String expectedGroupId=""String_Node_Str"";
    int expectedGroupSeq=1;
    String expectedReplyToGroupId=""String_Node_Str"";
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withGroupId(equalTo(expectedGroupId));
    propsMatcher.withReplyToGroupId(equalTo(expectedReplyToGroupId));
    propsMatcher.withGroupSequence(equalTo(UnsignedInteger.valueOf(expectedGroupSeq)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setStringProperty(JmsClientProperties.JMSXGROUPID,expectedGroupId);
    message.setIntProperty(JmsClientProperties.JMSXGROUPSEQ,expectedGroupSeq);
    message.setStringProperty(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID,expectedReplyToGroupId);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }"
41169,"private void doSendMessageOnConnectionWithPrefixTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String destAddress,Byte destTypeAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=null;
    if (destType == Topic.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else     if (destType == Queue.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix + ""String_Node_Str""+ destPrefix);
    }
    connection.start();
    if (destType == Topic.class) {
      ((JmsConnection)connection).setTopicPrefix(destPrefix);
    }
 else     if (destType == Queue.class) {
      ((JmsConnection)connection).setQueuePrefix(destPrefix);
    }
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else     if (destType == TemporaryTopic.class) {
      testPeer.expectTempTopicCreationAttach(destAddress);
      dest=session.createTemporaryTopic();
    }
 else     if (destType == TemporaryQueue.class) {
      testPeer.expectTempQueueCreationAttach(destAddress);
      dest=session.createTemporaryQueue();
    }
    TargetMatcher targetMatcher=new TargetMatcher();
    targetMatcher.withAddress(equalTo(destAddress));
    testPeer.expectSenderAttach(targetMatcher,false,false);
    MessageProducer producer=session.createProducer(dest);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withTo(equalTo(destAddress));
    propsMatcher.withReplyTo(equalTo(destAddress));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setJMSReplyTo(dest);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","private void doSendMessageOnConnectionWithPrefixTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String destAddress,Byte destTypeAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=null;
    if (destType == Topic.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else     if (destType == Queue.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix + ""String_Node_Str""+ destPrefix);
    }
    connection.start();
    if (destType == Topic.class) {
      ((JmsConnection)connection).setTopicPrefix(destPrefix);
    }
 else     if (destType == Queue.class) {
      ((JmsConnection)connection).setQueuePrefix(destPrefix);
    }
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else     if (destType == TemporaryTopic.class) {
      testPeer.expectTempTopicCreationAttach(destAddress);
      dest=session.createTemporaryTopic();
    }
 else     if (destType == TemporaryQueue.class) {
      testPeer.expectTempQueueCreationAttach(destAddress);
      dest=session.createTemporaryQueue();
    }
    TargetMatcher targetMatcher=new TargetMatcher();
    targetMatcher.withAddress(equalTo(destAddress));
    testPeer.expectSenderAttach(targetMatcher,false,false);
    MessageProducer producer=session.createProducer(dest);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withTo(equalTo(destAddress));
    propsMatcher.withReplyTo(equalTo(destAddress));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setJMSReplyTo(dest);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41170,"@Test(timeout=2000) public void testSendMessageWithApplicationProperties() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    ApplicationPropertiesSectionMatcher appPropsMatcher=new ApplicationPropertiesSectionMatcher(true);
    appPropsMatcher.withEntry(NULL_STRING_PROP,nullValue());
    appPropsMatcher.withEntry(STRING_PROP,equalTo(STRING_PROP_VALUE));
    appPropsMatcher.withEntry(BOOLEAN_PROP,equalTo(BOOLEAN_PROP_VALUE));
    appPropsMatcher.withEntry(BYTE_PROP,equalTo(BYTE_PROP_VALUE));
    appPropsMatcher.withEntry(SHORT_PROP,equalTo(SHORT_PROP_VALUE));
    appPropsMatcher.withEntry(INT_PROP,equalTo(INT_PROP_VALUE));
    appPropsMatcher.withEntry(LONG_PROP,equalTo(LONG_PROP_VALUE));
    appPropsMatcher.withEntry(FLOAT_PROP,equalTo(FLOAT_PROP_VALUE));
    appPropsMatcher.withEntry(DOUBLE_PROP,equalTo(DOUBLE_PROP_VALUE));
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withTo(equalTo(queueName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setApplicationPropertiesMatcher(appPropsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setStringProperty(NULL_STRING_PROP,NULL_STRING_PROP_VALUE);
    message.setStringProperty(STRING_PROP,STRING_PROP_VALUE);
    message.setBooleanProperty(BOOLEAN_PROP,BOOLEAN_PROP_VALUE);
    message.setByteProperty(BYTE_PROP,BYTE_PROP_VALUE);
    message.setShortProperty(SHORT_PROP,SHORT_PROP_VALUE);
    message.setIntProperty(INT_PROP,INT_PROP_VALUE);
    message.setLongProperty(LONG_PROP,LONG_PROP_VALUE);
    message.setFloatProperty(FLOAT_PROP,FLOAT_PROP_VALUE);
    message.setDoubleProperty(DOUBLE_PROP,DOUBLE_PROP_VALUE);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }","@Test(timeout=2000) public void testSendMessageWithApplicationProperties() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    ApplicationPropertiesSectionMatcher appPropsMatcher=new ApplicationPropertiesSectionMatcher(true);
    appPropsMatcher.withEntry(NULL_STRING_PROP,nullValue());
    appPropsMatcher.withEntry(STRING_PROP,equalTo(STRING_PROP_VALUE));
    appPropsMatcher.withEntry(BOOLEAN_PROP,equalTo(BOOLEAN_PROP_VALUE));
    appPropsMatcher.withEntry(BYTE_PROP,equalTo(BYTE_PROP_VALUE));
    appPropsMatcher.withEntry(SHORT_PROP,equalTo(SHORT_PROP_VALUE));
    appPropsMatcher.withEntry(INT_PROP,equalTo(INT_PROP_VALUE));
    appPropsMatcher.withEntry(LONG_PROP,equalTo(LONG_PROP_VALUE));
    appPropsMatcher.withEntry(FLOAT_PROP,equalTo(FLOAT_PROP_VALUE));
    appPropsMatcher.withEntry(DOUBLE_PROP,equalTo(DOUBLE_PROP_VALUE));
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withTo(equalTo(queueName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setApplicationPropertiesMatcher(appPropsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setStringProperty(NULL_STRING_PROP,NULL_STRING_PROP_VALUE);
    message.setStringProperty(STRING_PROP,STRING_PROP_VALUE);
    message.setBooleanProperty(BOOLEAN_PROP,BOOLEAN_PROP_VALUE);
    message.setByteProperty(BYTE_PROP,BYTE_PROP_VALUE);
    message.setShortProperty(SHORT_PROP,SHORT_PROP_VALUE);
    message.setIntProperty(INT_PROP,INT_PROP_VALUE);
    message.setLongProperty(LONG_PROP,LONG_PROP_VALUE);
    message.setFloatProperty(FLOAT_PROP,FLOAT_PROP_VALUE);
    message.setDoubleProperty(DOUBLE_PROP,DOUBLE_PROP_VALUE);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }"
41171,"private void doSendMessageOnConnectionWithBrokerDefinedPrefixPropertiesTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String destAddress,Byte destTypeAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Map<Symbol,Object> properties=new HashMap<Symbol,Object>();
    properties.put(AmqpConnectionProperties.QUEUE_PREFIX,destPrefix);
    properties.put(AmqpConnectionProperties.TOPIC_PREFIX,destPrefix);
    Connection connection=testFixture.establishConnecton(testPeer,null,null,properties);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else {
      fail(""String_Node_Str"");
    }
    TargetMatcher targetMatcher=new TargetMatcher();
    targetMatcher.withAddress(equalTo(destAddress));
    testPeer.expectSenderAttach(targetMatcher,false,false);
    MessageProducer producer=session.createProducer(dest);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withTo(equalTo(destAddress));
    propsMatcher.withReplyTo(equalTo(destAddress));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setJMSReplyTo(dest);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","private void doSendMessageOnConnectionWithBrokerDefinedPrefixPropertiesTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String destAddress,Byte destTypeAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Map<Symbol,Object> properties=new HashMap<Symbol,Object>();
    properties.put(AmqpConnectionProperties.QUEUE_PREFIX,destPrefix);
    properties.put(AmqpConnectionProperties.TOPIC_PREFIX,destPrefix);
    Connection connection=testFixture.establishConnecton(testPeer,null,null,properties);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else {
      fail(""String_Node_Str"");
    }
    TargetMatcher targetMatcher=new TargetMatcher();
    targetMatcher.withAddress(equalTo(destAddress));
    testPeer.expectSenderAttach(targetMatcher,false,false);
    MessageProducer producer=session.createProducer(dest);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withTo(equalTo(destAddress));
    propsMatcher.withReplyTo(equalTo(destAddress));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setJMSReplyTo(dest);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41172,"/** 
 * Tests that lack of the absolute-expiry-time and ttl fields on a message results in it returning 0 for for JMSExpiration
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithNoAbsoluteExpiryOrTtlReturnsJMSExpirationZero() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertEquals(0L,receivedMessage.getJMSExpiration());
  }
 }","/** 
 * Tests that lack of the absolute-expiry-time and ttl fields on a message results in it returning 0 for for JMSExpiration
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithNoAbsoluteExpiryOrTtlReturnsJMSExpirationZero() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertEquals(0L,receivedMessage.getJMSExpiration());
  }
 }"
41173,"private void receivedMessageWithCorrelationIdTestImpl(Object correlationIdForAmqpMessageClass,boolean appSpecific) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    MessageAnnotationsDescribedType ann=null;
    props.setMessageId(""String_Node_Str"");
    props.setCorrelationId(correlationIdForAmqpMessageClass);
    if (appSpecific) {
      ann=new MessageAnnotationsDescribedType();
      ann.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID,true);
    }
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,ann,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(correlationIdForAmqpMessageClass);
    String expected=expectedBaseIdString;
    if (!appSpecific) {
      expected=""String_Node_Str"" + expected;
    }
    assertEquals(expected,receivedMessage.getJMSCorrelationID());
  }
 }","private void receivedMessageWithCorrelationIdTestImpl(Object correlationIdForAmqpMessageClass,boolean appSpecific) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    MessageAnnotationsDescribedType ann=null;
    props.setMessageId(""String_Node_Str"");
    props.setCorrelationId(correlationIdForAmqpMessageClass);
    if (appSpecific) {
      ann=new MessageAnnotationsDescribedType();
      ann.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID,true);
    }
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,ann,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(correlationIdForAmqpMessageClass);
    String expected=expectedBaseIdString;
    if (!appSpecific) {
      expected=""String_Node_Str"" + expected;
    }
    assertEquals(expected,receivedMessage.getJMSCorrelationID());
  }
 }"
41174,"/** 
 * Tests that setting a non-zero value in the absolute-expiry-time field on a message results in it returning this value for JMSExpiration
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithAbsoluteExpiryReturnsJMSExpirationNonZero() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    long timestamp=System.currentTimeMillis();
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setAbsoluteExpiryTime(new Date(timestamp));
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertEquals(timestamp,receivedMessage.getJMSExpiration());
  }
 }","/** 
 * Tests that setting a non-zero value in the absolute-expiry-time field on a message results in it returning this value for JMSExpiration
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithAbsoluteExpiryReturnsJMSExpirationNonZero() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    long timestamp=System.currentTimeMillis();
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setAbsoluteExpiryTime(new Date(timestamp));
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertEquals(timestamp,receivedMessage.getJMSExpiration());
  }
 }"
41175,"/** 
 * Tests that when receiving a message with the group-id, reply-to-group-id, and group-sequence fields of the AMQP properties section set, that the expected JMSX or JMS_AMQP properties are present, and the expected values are returned when retrieved from the JMS message.
 */
@Test(timeout=2000) public void testReceivedMessageWithGroupRelatedPropertiesSet() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    MessageAnnotationsDescribedType ann=null;
    String expectedGroupId=""String_Node_Str"";
    int expectedGroupSeq=1;
    String expectedReplyToGroupId=""String_Node_Str"";
    props.setGroupId(expectedGroupId);
    props.setGroupSequence(UnsignedInteger.valueOf(expectedGroupSeq));
    props.setReplyToGroupId(expectedReplyToGroupId);
    props.setMessageId(""String_Node_Str"");
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,ann,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    boolean foundGroupId=false;
    boolean foundGroupSeq=false;
    boolean foundReplyToGroupId=false;
    Enumeration<?> names=receivedMessage.getPropertyNames();
    assertTrue(""String_Node_Str"",names.hasMoreElements());
    while (names.hasMoreElements()) {
      Object element=names.nextElement();
      if (JmsClientProperties.JMSXGROUPID.equals(element)) {
        foundGroupId=true;
      }
      if (JmsClientProperties.JMSXGROUPSEQ.equals(element)) {
        foundGroupSeq=true;
      }
      if (AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID.equals(element)) {
        foundReplyToGroupId=true;
      }
    }
    assertTrue(""String_Node_Str"",foundGroupId);
    assertTrue(""String_Node_Str"",foundGroupSeq);
    assertTrue(""String_Node_Str"",foundReplyToGroupId);
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(JmsClientProperties.JMSXGROUPID));
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(JmsClientProperties.JMSXGROUPSEQ));
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID));
    assertEquals(""String_Node_Str"",expectedGroupId,receivedMessage.getStringProperty(JmsClientProperties.JMSXGROUPID));
    assertEquals(""String_Node_Str"",expectedGroupSeq,receivedMessage.getIntProperty(JmsClientProperties.JMSXGROUPSEQ));
    assertEquals(""String_Node_Str"",expectedReplyToGroupId,receivedMessage.getStringProperty(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID));
  }
 }","/** 
 * Tests that when receiving a message with the group-id, reply-to-group-id, and group-sequence fields of the AMQP properties section set, that the expected JMSX or JMS_AMQP properties are present, and the expected values are returned when retrieved from the JMS message.
 */
@Test(timeout=2000) public void testReceivedMessageWithGroupRelatedPropertiesSet() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    MessageAnnotationsDescribedType ann=null;
    String expectedGroupId=""String_Node_Str"";
    int expectedGroupSeq=1;
    String expectedReplyToGroupId=""String_Node_Str"";
    props.setGroupId(expectedGroupId);
    props.setGroupSequence(UnsignedInteger.valueOf(expectedGroupSeq));
    props.setReplyToGroupId(expectedReplyToGroupId);
    props.setMessageId(""String_Node_Str"");
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,ann,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    boolean foundGroupId=false;
    boolean foundGroupSeq=false;
    boolean foundReplyToGroupId=false;
    Enumeration<?> names=receivedMessage.getPropertyNames();
    assertTrue(""String_Node_Str"",names.hasMoreElements());
    while (names.hasMoreElements()) {
      Object element=names.nextElement();
      if (JmsClientProperties.JMSXGROUPID.equals(element)) {
        foundGroupId=true;
      }
      if (JmsClientProperties.JMSXGROUPSEQ.equals(element)) {
        foundGroupSeq=true;
      }
      if (AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID.equals(element)) {
        foundReplyToGroupId=true;
      }
    }
    assertTrue(""String_Node_Str"",foundGroupId);
    assertTrue(""String_Node_Str"",foundGroupSeq);
    assertTrue(""String_Node_Str"",foundReplyToGroupId);
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(JmsClientProperties.JMSXGROUPID));
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(JmsClientProperties.JMSXGROUPSEQ));
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID));
    assertEquals(""String_Node_Str"",expectedGroupId,receivedMessage.getStringProperty(JmsClientProperties.JMSXGROUPID));
    assertEquals(""String_Node_Str"",expectedGroupSeq,receivedMessage.getIntProperty(JmsClientProperties.JMSXGROUPSEQ));
    assertEquals(""String_Node_Str"",expectedReplyToGroupId,receivedMessage.getStringProperty(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID));
  }
 }"
41176,"/** 
 * Tests that lack of the reply-to set on a message results in it returning null for JMSReplyTo and not the consumer destination as happens for JMSDestination.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithNoReplyToReturnsNull() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertNull(receivedMessage.getJMSReplyTo());
  }
 }","/** 
 * Tests that lack of the reply-to set on a message results in it returning null for JMSReplyTo and not the consumer destination as happens for JMSDestination.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithNoReplyToReturnsNull() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertNull(receivedMessage.getJMSReplyTo());
  }
 }"
41177,"/** 
 * Tests that the   {@link AmqpDestinationHelper#JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} is set as a byte ona sent message to indicate its 'reply-to' address represents a Topic JMSDestination.
 */
@Test(timeout=5000) public void testSentMessageContainsReplyToTypeAnnotationByte() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    String replyTopicName=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    Symbol annotationKey=AmqpMessageSupport.getSymbol(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
    msgAnnotationsMatcher.withEntry(annotationKey,equalTo(AmqpDestinationHelper.TOPIC_TYPE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withReplyTo(equalTo(replyTopicName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Topic replyTopic=session.createTopic(replyTopicName);
    Message message=session.createMessage();
    message.setJMSReplyTo(replyTopic);
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","/** 
 * Tests that the   {@link AmqpDestinationHelper#JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} is set as a byte ona sent message to indicate its 'reply-to' address represents a Topic JMSDestination.
 */
@Test(timeout=5000) public void testSentMessageContainsReplyToTypeAnnotationByte() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    String replyTopicName=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    Symbol annotationKey=AmqpMessageSupport.getSymbol(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
    msgAnnotationsMatcher.withEntry(annotationKey,equalTo(AmqpDestinationHelper.TOPIC_TYPE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withReplyTo(equalTo(replyTopicName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Topic replyTopic=session.createTopic(replyTopicName);
    Message message=session.createMessage();
    message.setJMSReplyTo(replyTopic);
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41178,"private void doReceivedMessageOnConnectionWithBrokerDefinedPrefixPropertiesTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String replyName,String destAddress,String replyAddress,String annotationName,Object annotationValue,String replyAnnotationName,Object replyAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Map<Symbol,Object> properties=new HashMap<Symbol,Object>();
    properties.put(AmqpConnectionProperties.QUEUE_PREFIX,destPrefix);
    properties.put(AmqpConnectionProperties.TOPIC_PREFIX,destPrefix);
    Connection connection=testFixture.establishConnecton(testPeer,null,null,properties);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else {
      fail(""String_Node_Str"");
    }
    MessageAnnotationsDescribedType msgAnnotations=null;
    if (annotationName != null || replyAnnotationName != null) {
      msgAnnotations=new MessageAnnotationsDescribedType();
      if (annotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(annotationName,annotationValue);
      }
      if (replyAnnotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(replyAnnotationName,replyAnnotationValue);
      }
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setTo(destAddress);
    props.setReplyTo(replyAddress);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    SourceMatcher sourceMatcher=new SourceMatcher();
    sourceMatcher.withAddress(equalTo(destAddress));
    testPeer.expectReceiverAttach(notNullValue(),sourceMatcher);
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(dest);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNotNull(receivedMessage);
    Destination jmsDest=receivedMessage.getJMSDestination();
    Destination jmsReplyTo=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",jmsDest);
    assertNotNull(""String_Node_Str"",jmsReplyTo);
    String recievedName=null;
    String recievedReplyName=null;
    if (destType == Topic.class) {
      recievedName=((Topic)jmsDest).getTopicName();
      recievedReplyName=((Topic)jmsReplyTo).getTopicName();
    }
 else     if (destType == Queue.class) {
      recievedName=((Queue)jmsDest).getQueueName();
      recievedReplyName=((Queue)jmsReplyTo).getQueueName();
    }
    assertEquals(""String_Node_Str"",destName,recievedName);
    assertEquals(""String_Node_Str"",replyName,recievedReplyName);
  }
 }","private void doReceivedMessageOnConnectionWithBrokerDefinedPrefixPropertiesTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String replyName,String destAddress,String replyAddress,String annotationName,Object annotationValue,String replyAnnotationName,Object replyAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Map<Symbol,Object> properties=new HashMap<Symbol,Object>();
    properties.put(AmqpConnectionProperties.QUEUE_PREFIX,destPrefix);
    properties.put(AmqpConnectionProperties.TOPIC_PREFIX,destPrefix);
    Connection connection=testFixture.establishConnecton(testPeer,null,null,properties);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else {
      fail(""String_Node_Str"");
    }
    MessageAnnotationsDescribedType msgAnnotations=null;
    if (annotationName != null || replyAnnotationName != null) {
      msgAnnotations=new MessageAnnotationsDescribedType();
      if (annotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(annotationName,annotationValue);
      }
      if (replyAnnotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(replyAnnotationName,replyAnnotationValue);
      }
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setTo(destAddress);
    props.setReplyTo(replyAddress);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    SourceMatcher sourceMatcher=new SourceMatcher();
    sourceMatcher.withAddress(equalTo(destAddress));
    testPeer.expectReceiverAttach(notNullValue(),sourceMatcher);
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(dest);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNotNull(receivedMessage);
    Destination jmsDest=receivedMessage.getJMSDestination();
    Destination jmsReplyTo=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",jmsDest);
    assertNotNull(""String_Node_Str"",jmsReplyTo);
    String recievedName=null;
    String recievedReplyName=null;
    if (destType == Topic.class) {
      recievedName=((Topic)jmsDest).getTopicName();
      recievedReplyName=((Topic)jmsReplyTo).getTopicName();
    }
 else     if (destType == Queue.class) {
      recievedName=((Queue)jmsDest).getQueueName();
      recievedReplyName=((Queue)jmsReplyTo).getQueueName();
    }
    assertEquals(""String_Node_Str"",destName,recievedName);
    assertEquals(""String_Node_Str"",replyName,recievedReplyName);
  }
 }"
41179,"@Test(timeout=2000) public void testReceiveMessageWithoutMessageId() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNull(receivedMessage.getJMSMessageID());
  }
 }","@Test(timeout=2000) public void testReceiveMessageWithoutMessageId() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNull(receivedMessage.getJMSMessageID());
  }
 }"
41180,"/** 
 * Tests that the   {@link AmqpMessageSupport#LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} set on a message toindicate its 'reply-to' address represents a Topic results in the JMSReplyTo object being a Topic. Ensure the consumers destination is not used by consuming from a Queue.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithLegacyReplyToTypeAnnotationForTopic() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,AmqpMessageSupport.LEGACY_TOPIC_ATTRIBUTE);
    PropertiesDescribedType props=new PropertiesDescribedType();
    String myTopicAddress=""String_Node_Str"";
    props.setReplyTo(myTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSReplyTo();
    assertTrue(dest instanceof Topic);
    assertEquals(myTopicAddress,((Topic)dest).getTopicName());
  }
 }","/** 
 * Tests that the   {@link AmqpMessageSupport#LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} set on a message toindicate its 'reply-to' address represents a Topic results in the JMSReplyTo object being a Topic. Ensure the consumers destination is not used by consuming from a Queue.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithLegacyReplyToTypeAnnotationForTopic() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,AmqpMessageSupport.LEGACY_TOPIC_ATTRIBUTE);
    PropertiesDescribedType props=new PropertiesDescribedType();
    String myTopicAddress=""String_Node_Str"";
    props.setReplyTo(myTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSReplyTo();
    assertTrue(dest instanceof Topic);
    assertEquals(myTopicAddress,((Topic)dest).getTopicName());
  }
 }"
41181,"/** 
 * @param userName
 * @param password
 * @return a QueueConnection
 * @throws JMSException
 * @see javax.jms.QueueConnectionFactory#createQueueConnection(java.lang.String,java.lang.String)
 */
@Override public QueueConnection createQueueConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsQueueConnection result=new JmsQueueConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}","/** 
 * @param username
 * @param password
 * @return a QueueConnection
 * @throws JMSException
 * @see javax.jms.QueueConnectionFactory#createQueueConnection(java.lang.String,java.lang.String)
 */
@Override public QueueConnection createQueueConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsQueueConnection result=new JmsQueueConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}"
41182,"/** 
 * @param userName
 * @param password
 * @return a TopicConnection
 * @throws JMSException
 * @see javax.jms.TopicConnectionFactory#createTopicConnection(java.lang.String,java.lang.String)
 */
@Override public TopicConnection createTopicConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsTopicConnection result=new JmsTopicConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}","/** 
 * @param username
 * @param password
 * @return a TopicConnection
 * @throws JMSException
 * @see javax.jms.TopicConnectionFactory#createTopicConnection(java.lang.String,java.lang.String)
 */
@Override public TopicConnection createTopicConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsTopicConnection result=new JmsTopicConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}"
41183,"/** 
 * @param userName
 * @param password
 * @return Connection
 * @throws JMSException
 * @see javax.jms.ConnectionFactory#createConnection(java.lang.String,java.lang.String)
 */
@Override public Connection createConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsConnection result=new JmsConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}","/** 
 * @param username
 * @param password
 * @return Connection
 * @throws JMSException
 * @see javax.jms.ConnectionFactory#createConnection(java.lang.String,java.lang.String)
 */
@Override public Connection createConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsConnection result=new JmsConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}"
41184,"/** 
 * Adds the given Transaction synchronization to the current list.
 * @param synchronization the transaction synchronization to add.
 */
public void addSynchronization(JmsTxSynchronization s){
  if (synchronizations == null) {
    synchronizations=new ArrayList<JmsTxSynchronization>(10);
  }
  synchronizations.add(s);
}","/** 
 * Adds the given Transaction synchronization to the current list.
 * @param s the transaction synchronization to add.
 */
public void addSynchronization(JmsTxSynchronization s){
  if (synchronizations == null) {
    synchronizations=new ArrayList<JmsTxSynchronization>(10);
  }
  synchronizations.add(s);
}"
41185,"/** 
 * Called from the session when a new Message has been dispatched to this Consumer from the connection.
 * @param facade the newly arrived message.
 */
@Override public void onMessage(final JmsInboundMessageDispatch envelope){
  lock.lock();
  try {
    if (acknowledgementMode == Session.CLIENT_ACKNOWLEDGE) {
      envelope.getMessage().setAcknowledgeCallback(new Callable<Void>(){
        @Override public Void call() throws Exception {
          if (session.isClosed()) {
            throw new javax.jms.IllegalStateException(""String_Node_Str"");
          }
          session.acknowledge();
          return null;
        }
      }
);
    }
    this.messageQueue.enqueue(envelope);
  }
  finally {
    lock.unlock();
  }
  if (this.messageListener != null && this.started) {
    session.getExecutor().execute(new Runnable(){
      @Override public void run(){
        JmsInboundMessageDispatch envelope;
        while (session.isStarted() && (envelope=messageQueue.dequeueNoWait()) != null) {
          try {
            messageListener.onMessage(copy(ack(envelope)));
          }
 catch (          Exception e) {
            session.getConnection().onException(e);
          }
        }
      }
    }
);
  }
 else {
    if (availableListener != null) {
      availableListener.onMessageAvailable(this);
    }
  }
}","/** 
 * Called from the session when a new Message has been dispatched to this Consumer from the connection.
 * @param envelope the newly arrived message.
 */
@Override public void onMessage(final JmsInboundMessageDispatch envelope){
  lock.lock();
  try {
    if (acknowledgementMode == Session.CLIENT_ACKNOWLEDGE) {
      envelope.getMessage().setAcknowledgeCallback(new Callable<Void>(){
        @Override public Void call() throws Exception {
          if (session.isClosed()) {
            throw new javax.jms.IllegalStateException(""String_Node_Str"");
          }
          session.acknowledge();
          return null;
        }
      }
);
    }
    this.messageQueue.enqueue(envelope);
  }
  finally {
    lock.unlock();
  }
  if (this.messageListener != null && this.started) {
    session.getExecutor().execute(new Runnable(){
      @Override public void run(){
        JmsInboundMessageDispatch envelope;
        while (session.isStarted() && (envelope=messageQueue.dequeueNoWait()) != null) {
          try {
            messageListener.onMessage(copy(ack(envelope)));
          }
 catch (          Exception e) {
            session.getConnection().onException(e);
          }
        }
      }
    }
);
  }
 else {
    if (availableListener != null) {
      availableListener.onMessageAvailable(this);
    }
  }
}"
41186,"/** 
 * Waits for a response to some Provider requested operation.
 * @return the response from the Provider for this operation.
 * @throws IOException if an error occurs while waiting for the response.
 */
public void sync() throws IOException {
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw IOExceptionSupport.create(e);
  }
  failOnError();
}","/** 
 * Waits for a response to some Provider requested operation.
 * @throws IOException if an error occurs while waiting for the response.
 */
public void sync() throws IOException {
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw IOExceptionSupport.create(e);
  }
  failOnError();
}"
41187,"/** 
 * Creates a new AmqpTransaction instance.
 * @param session The session that owns this transaction
 * @param resource The JmsTransactionInfo that defines this Transaction.
 */
public AmqpTransactionContext(AmqpSession session){
  super(session.getJmsResource());
  this.session=session;
}","/** 
 * Creates a new AmqpTransaction instance.
 * @param session The session that owns this transaction
 */
public AmqpTransactionContext(AmqpSession session){
  super(session.getJmsResource());
  this.session=session;
}"
41188,"/** 
 * When used as a pooled cache of tags the unused tags should always be returned once the transfer has been settled.
 * @param tag a previously borrowed tag that is no longer in use.
 */
public void returnTag(byte[] data){
  if (tagPool != null && tagPool.size() < maxPoolSize) {
    tagPool.add(data);
  }
}","/** 
 * When used as a pooled cache of tags the unused tags should always be returned once the transfer has been settled.
 * @param data a previously borrowed tag that is no longer in use.
 */
public void returnTag(byte[] data){
  if (tagPool != null && tagPool.size() < maxPoolSize) {
    tagPool.add(data);
  }
}"
41189,"/** 
 * The AmqpConnection instance that is associated with this Message.
 * @return
 */
public AmqpConnection getConnection(){
  return connection;
}","/** 
 * The AmqpConnection instance that is associated with this Message.
 * @return the connection
 */
public AmqpConnection getConnection(){
  return connection;
}"
41190,"/** 
 * Returns the suffix of the given string after removing the first ""ID:"" prefix (if present).
 * @param string the string to process
 * @return the suffix, or the original String if the ""ID:"" prefix is not present
 */
public String stripMessageIdPrefix(String id){
  if (hasMessageIdPrefix(id)) {
    return strip(id,JMS_ID_PREFIX_LENGTH);
  }
 else {
    return id;
  }
}","/** 
 * Returns the suffix of the given string after removing the first ""ID:"" prefix (if present).
 * @param id the string to process
 * @return the suffix, or the original String if the ""ID:"" prefix is not present
 */
public String stripMessageIdPrefix(String id){
  if (hasMessageIdPrefix(id)) {
    return strip(id,JMS_ID_PREFIX_LENGTH);
  }
 else {
    return id;
  }
}"
41191,"/** 
 * Create an instance of the SSL transport
 * @param listener The TransportListener that will handle events from this Transport instance.
 * @param remoteLocation The location that is being connected to.
 * @param JmsSslContext The JMS Framework SslContext to use for this SSL connection.
 */
public SslTransport(TransportListener listener,URI remoteLocation,JmsSslContext context){
  super(listener,remoteLocation);
  this.context=context;
}","/** 
 * Create an instance of the SSL transport
 * @param listener The TransportListener that will handle events from this Transport instance.
 * @param remoteLocation The location that is being connected to.
 * @param context The JMS Framework SslContext to use for this SSL connection.
 */
public SslTransport(TransportListener listener,URI remoteLocation,JmsSslContext context){
  super(listener,remoteLocation);
  this.context=context;
}"
41192,"/** 
 * Given a map of properties, filter out only those prefixed with the given value, the values filtered are returned in a new Map instance.
 * @param properties The map of properties to filter.
 * @param optionPrefix The prefix value to use when filtering.
 * @return a filter map with only values that match the given prefix.
 */
public static Map<String,String> filterProperties(Map<String,String> props,String optionPrefix){
  if (props == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HashMap<String,String> rc=new HashMap<String,String>(props.size());
  for (Iterator<Entry<String,String>> iter=props.entrySet().iterator(); iter.hasNext(); ) {
    Entry<String,String> entry=iter.next();
    if (entry.getKey().startsWith(optionPrefix)) {
      String name=entry.getKey().substring(optionPrefix.length());
      rc.put(name,entry.getValue());
      iter.remove();
    }
  }
  return rc;
}","/** 
 * Given a map of properties, filter out only those prefixed with the given value, the values filtered are returned in a new Map instance.
 * @param props The map of properties to filter.
 * @param optionPrefix The prefix value to use when filtering.
 * @return a filter map with only values that match the given prefix.
 */
public static Map<String,String> filterProperties(Map<String,String> props,String optionPrefix){
  if (props == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HashMap<String,String> rc=new HashMap<String,String>(props.size());
  for (Iterator<Entry<String,String>> iter=props.entrySet().iterator(); iter.hasNext(); ) {
    Entry<String,String> entry=iter.next();
    if (entry.getKey().startsWith(optionPrefix)) {
      String name=entry.getKey().substring(optionPrefix.length());
      rc.put(name,entry.getValue());
      iter.remove();
    }
  }
  return rc;
}"
41193,"/** 
 * Creates a URI with the given query, removing an previous query value from the given URI.
 * @param uri The source URI whose existing query is replaced with the newly supplied one.
 * @param query The new URI query string that should be appended to the given URI.
 * @return a new URI that is a combination of the original URI and the given query string.
 * @throws URISyntaxException
 */
public static URI eraseQuery(URI uri) throws URISyntaxException {
  return replaceQuery(uri,(String)null);
}","/** 
 * Creates a URI with the given query, removing an previous query value from the given URI.
 * @param uri The source URI whose existing query is replaced with the newly supplied one.
 * @return a new URI that is a combination of the original URI and the given query string.
 * @throws URISyntaxException
 */
public static URI eraseQuery(URI uri) throws URISyntaxException {
  return replaceQuery(uri,(String)null);
}"
41194,"/** 
 * Test that a message received from the test peer with an AmqpValue section containing Binary and no content type is returned as a BytesMessage, verify it gives the expected data values when read, and when sent to the test peer it results in an AMQP message containing a data body section and content type of  {@link AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE}
 */
@Test(timeout=5000) public void testReceiveBytesMessageWithAmqpValueAndResendResultsInData() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","/** 
 * Test that a message received from the test peer with an AmqpValue section containing Binary and no content type is returned as a BytesMessage, verify it gives the expected data values when read, and when sent to the test peer it results in an AMQP message containing a data body section and content type of  {@link AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE}
 */
@Test(timeout=5000) public void testReceiveBytesMessageWithAmqpValueAndResendResultsInData() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41195,"/** 
 * Verify that when   {@link BytesMessage#readBytes(byte[], int))} is calledwith a length that is greater than the size of the provided array, an  {@link IndexOutOfBoundsException} is thrown.
 */
@Test(expected=IndexOutOfBoundsException.class) public void testReadBytesWithLengthGreatThanArraySizeThrowsIOOBE() throws Exception {
  JmsBytesMessage bytesMessage=factory.createBytesMessage();
  bytesMessage.reset();
  bytesMessage.readBytes(new byte[1],2);
}","/** 
 * Verify that when   {@link BytesMessage#readBytes(byte[],int)} is calledwith a length that is greater than the size of the provided array, an  {@link IndexOutOfBoundsException} is thrown.
 */
@Test(expected=IndexOutOfBoundsException.class) public void testReadBytesWithLengthGreatThanArraySizeThrowsIOOBE() throws Exception {
  JmsBytesMessage bytesMessage=factory.createBytesMessage();
  bytesMessage.reset();
  bytesMessage.readBytes(new byte[1],2);
}"
41196,"/** 
 * Verify that when   {@link BytesMessage#readBytes(byte[], int))} is calledwith a negative length that an  {@link IndexOutOfBoundsException} is thrown.
 */
@Test(expected=IndexOutOfBoundsException.class) public void testReadBytesWithNegativeLengthThrowsIOOBE() throws Exception {
  JmsBytesMessage bytesMessage=factory.createBytesMessage();
  bytesMessage.reset();
  bytesMessage.readBytes(new byte[0],-1);
}","/** 
 * Verify that when   {@link BytesMessage#readBytes(byte[],int)} is calledwith a negative length that an  {@link IndexOutOfBoundsException} is thrown.
 */
@Test(expected=IndexOutOfBoundsException.class) public void testReadBytesWithNegativeLengthThrowsIOOBE() throws Exception {
  JmsBytesMessage bytesMessage=factory.createBytesMessage();
  bytesMessage.reset();
  bytesMessage.readBytes(new byte[0],-1);
}"
41197,"/** 
 * Test that calling   {@link ObjectMessage#clearBody()} of a received messagecauses the body of the underlying  {@link AmqpObjectMessage} to be emptied.
 */
@Test public void testClearBodyOnReceivedObjectMessageClearsUnderlyingMessageBody() throws Exception {
  String content=""String_Node_Str"";
  JmsDefaultObjectMessageFacade facade=new JmsDefaultObjectMessageFacade();
  facade.setObject(content);
  JmsObjectMessage objectMessage=new JmsObjectMessage(facade);
  objectMessage.onDispatch();
  assertNotNull(""String_Node_Str"",facade.getSerializedObject());
  objectMessage.clearBody();
  assertNull(""String_Node_Str"",objectMessage.getObject());
  assertNull(""String_Node_Str"",facade.getSerializedObject());
}","/** 
 * Test that calling   {@link ObjectMessage#clearBody()} of a received messagecauses the body of the underlying message facade to be emptied.
 */
@Test public void testClearBodyOnReceivedObjectMessageClearsUnderlyingMessageBody() throws Exception {
  String content=""String_Node_Str"";
  JmsDefaultObjectMessageFacade facade=new JmsDefaultObjectMessageFacade();
  facade.setObject(content);
  JmsObjectMessage objectMessage=new JmsObjectMessage(facade);
  objectMessage.onDispatch();
  assertNotNull(""String_Node_Str"",facade.getSerializedObject());
  objectMessage.clearBody();
  assertNull(""String_Node_Str"",objectMessage.getObject());
  assertNull(""String_Node_Str"",facade.getSerializedObject());
}"
41198,"/** 
 * Test that a message with the   {@value AmqpMessageSupport#JMS_MSG_TYPE}annotation set to    {@value AmqpMessageSupport#JMS_OBJECT_MESSAGE} andcontent-type set to  {@value AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE} istreated as a  {@link JmsObjectMessage} with {@link AmqpJmsObjectMessageFacade}containing a   {@link AmqpSerializedObjectDelegate}.
 */
@Test public void testCreateObjectMessageFromMessageTypeAnnotation() throws Exception {
  createObjectMessageFromMessageTypeAnnotationTestImpl(true);
}","/** 
 * Test that a message with the   {@value AmqpMessageSupport#JMS_MSG_TYPE}annotation set to    {@value AmqpMessageSupport#JMS_OBJECT_MESSAGE} andcontent-type set to  {@value AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE} istreated as a  {@link JmsObjectMessage} with {@link AmqpJmsObjectMessageFacade}containing a   {@link AmqpSerializedObjectDelegate}.
 */
@Test public void testCreateObjectMessageFromMessageTypeAnnotation() throws Exception {
  createObjectMessageFromMessageTypeAnnotationTestImpl(true);
}"
41199,"/** 
 * Test that   {@link MessageImpl#getJMSType()} returns the expected value for a messagereceived with the  {@link ClientProperties#X_OPT_JMS_TYPE} message annotation set.
 */
@Test public void testGetJMSTypeWithReceivedMessage() throws Exception {
  String myJMSType=""String_Node_Str"";
  Message message=Proton.message();
  Map<Symbol,Object> annotationsMap=new HashMap<Symbol,Object>();
  annotationsMap.put(Symbol.valueOf(AmqpMessageSupport.JMS_TYPE),myJMSType);
  message.setMessageAnnotations(new MessageAnnotations(annotationsMap));
  AmqpJmsMessageFacade amqpMessageFacade=createReceivedMessageFacade(createMockAmqpConsumer(),message);
  assertEquals(""String_Node_Str"",myJMSType,amqpMessageFacade.getType());
}","/** 
 * Test that   {@link AmqpJmsMessageFacade#getType()} returns the expected value for a messagereceived with the  {@link AmqpMessageSupport#JMS_TYPE} message annotation set.
 */
@Test public void testGetJMSTypeWithReceivedMessage() throws Exception {
  String myJMSType=""String_Node_Str"";
  Message message=Proton.message();
  Map<Symbol,Object> annotationsMap=new HashMap<Symbol,Object>();
  annotationsMap.put(Symbol.valueOf(AmqpMessageSupport.JMS_TYPE),myJMSType);
  message.setMessageAnnotations(new MessageAnnotations(annotationsMap));
  AmqpJmsMessageFacade amqpMessageFacade=createReceivedMessageFacade(createMockAmqpConsumer(),message);
  assertEquals(""String_Node_Str"",myJMSType,amqpMessageFacade.getType());
}"
41200,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded binary when given a Binary object.
 */
@Test public void testToBaseMessageIdStringWithBinary(){
  byte[] bytes=new byte[]{(byte)0x00,(byte)0xAB,(byte)0x09,(byte)0xFF};
  Binary binary=new Binary(bytes);
  String expected=AmqpMessageIdHelper.AMQP_BINARY_PREFIX + ""String_Node_Str"";
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(binary);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded binary when given a Binary object.
 */
@Test public void testToBaseMessageIdStringWithBinary(){
  byte[] bytes=new byte[]{(byte)0x00,(byte)0xAB,(byte)0x09,(byte)0xFF};
  Binary binary=new Binary(bytes);
  String expected=AmqpMessageIdHelper.AMQP_BINARY_PREFIX + ""String_Node_Str"";
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(binary);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41201,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns the givenbasic string unchanged
 */
@Test public void testToBaseMessageIdStringWithString(){
  String stringMessageId=""String_Node_Str"";
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(stringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",stringMessageId,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns the givenbasic string unchanged
 */
@Test public void testToBaseMessageIdStringWithString(){
  String stringMessageId=""String_Node_Str"";
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(stringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",stringMessageId,baseMessageIdString);
}"
41202,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_UUID_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForUUID(){
  String uuidStringMessageId=AmqpMessageIdHelper.AMQP_UUID_PREFIX + UUID.randomUUID();
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + uuidStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uuidStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_UUID_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForUUID(){
  String uuidStringMessageId=AmqpMessageIdHelper.AMQP_UUID_PREFIX + UUID.randomUUID();
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + uuidStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uuidStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41203,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded ulong when given a UnsignedLong object.
 */
@Test public void testToBaseMessageIdStringWithUnsignedLong(){
  UnsignedLong uLongMessageId=UnsignedLong.valueOf(123456789L);
  String expected=AmqpMessageIdHelper.AMQP_ULONG_PREFIX + uLongMessageId.toString();
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uLongMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded ulong when given a UnsignedLong object.
 */
@Test public void testToBaseMessageIdStringWithUnsignedLong(){
  UnsignedLong uLongMessageId=UnsignedLong.valueOf(123456789L);
  String expected=AmqpMessageIdHelper.AMQP_ULONG_PREFIX + uLongMessageId.toString();
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uLongMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41204,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_BINARY_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForBinary(){
  String binaryStringMessageId=AmqpMessageIdHelper.AMQP_BINARY_PREFIX + ""String_Node_Str"";
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + binaryStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(binaryStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_BINARY_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForBinary(){
  String binaryStringMessageId=AmqpMessageIdHelper.AMQP_BINARY_PREFIX + ""String_Node_Str"";
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + binaryStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(binaryStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41205,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} throws an IAE if given an unexpected object type.
 */
@Test public void testToBaseMessageIdStringThrowsIAEWithUnexpectedType(){
  try {
    _messageIdHelper.toBaseMessageIdString(new Object());
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException iae) {
  }
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} throws an IAE if given an unexpected object type.
 */
@Test public void testToBaseMessageIdStringThrowsIAEWithUnexpectedType(){
  try {
    _messageIdHelper.toBaseMessageIdString(new Object());
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException iae) {
  }
}"
41206,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded UUID when given a UUID object.
 */
@Test public void testToBaseMessageIdStringWithUUID(){
  UUID uuidMessageId=UUID.randomUUID();
  String expected=AmqpMessageIdHelper.AMQP_UUID_PREFIX + uuidMessageId.toString();
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uuidMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded UUID when given a UUID object.
 */
@Test public void testToBaseMessageIdStringWithUUID(){
  UUID uuidMessageId=UUID.randomUUID();
  String expected=AmqpMessageIdHelper.AMQP_UUID_PREFIX + uuidMessageId.toString();
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uuidMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41207,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_ULONG_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForLong(){
  String longStringMessageId=AmqpMessageIdHelper.AMQP_ULONG_PREFIX + Long.valueOf(123456789L);
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + longStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(longStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_ULONG_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForLong(){
  String longStringMessageId=AmqpMessageIdHelper.AMQP_ULONG_PREFIX + Long.valueOf(123456789L);
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + longStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(longStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41208,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded string (effectively twice), when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_STRING_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForString(){
  String stringMessageId=AmqpMessageIdHelper.AMQP_STRING_PREFIX + ""String_Node_Str"";
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + stringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(stringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded string (effectively twice), when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_STRING_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForString(){
  String stringMessageId=AmqpMessageIdHelper.AMQP_STRING_PREFIX + ""String_Node_Str"";
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + stringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(stringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41209,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns null if given null
 */
@Test public void testToBaseMessageIdStringWithNull(){
  String nullString=null;
  assertNull(""String_Node_Str"",_messageIdHelper.toBaseMessageIdString(nullString));
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns null if given null
 */
@Test public void testToBaseMessageIdStringWithNull(){
  String nullString=null;
  assertNull(""String_Node_Str"",_messageIdHelper.toBaseMessageIdString(nullString));
}"
41210,"@Ignore @Test(timeout=60000) public void testAnonymousSendToTopic() throws Exception {
  connection=createAmqpConnection();
  assertNotNull(connection);
  connection.start();
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Topic topic=session.createTopic(name.getMethodName());
  assertNotNull(session);
  MessageProducer producer=session.createProducer(null);
  assertNotNull(producer);
  MessageConsumer consumer=session.createConsumer(topic);
  assertNotNull(consumer);
  Message message=session.createMessage();
  producer.send(topic,message);
  TopicViewMBean proxy=getProxyToTopic(name.getMethodName());
  assertEquals(1,proxy.getEnqueueCount());
}","@Test(timeout=60000) public void testAnonymousSendToTopic() throws Exception {
  connection=createAmqpConnection();
  assertNotNull(connection);
  connection.start();
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Topic topic=session.createTopic(name.getMethodName());
  assertNotNull(session);
  MessageProducer producer=session.createProducer(null);
  assertNotNull(producer);
  MessageConsumer consumer=session.createConsumer(topic);
  assertNotNull(consumer);
  Message message=session.createMessage();
  producer.send(topic,message);
  TopicViewMBean proxy=getProxyToTopic(name.getMethodName());
  assertEquals(1,proxy.getEnqueueCount());
}"
41211,"protected void setConnectionIdGenerator(IdGenerator connectionIdGenerator){
  this.connectionIdGenerator=connectionIdGenerator;
}","protected synchronized void setConnectionIdGenerator(IdGenerator connectionIdGenerator){
  this.connectionIdGenerator=connectionIdGenerator;
}"
41212,"protected void setClientIdGenerator(IdGenerator clientIdGenerator){
  this.clientIdGenerator=clientIdGenerator;
}","protected synchronized void setClientIdGenerator(IdGenerator clientIdGenerator){
  this.clientIdGenerator=clientIdGenerator;
}"
41213,"/** 
 * Sets the prefix used by auto-generated JMS Client ID values which are used if the JMS client does not explicitly specify on.
 * @param clientIDPrefix
 */
public void setClientIDPrefix(String clientIDPrefix){
  this.clientIDPrefix=clientIDPrefix;
}","/** 
 * Sets the prefix used by auto-generated JMS Client ID values which are used if the JMS client does not explicitly specify on.
 * @param clientIDPrefix
 */
public synchronized void setClientIDPrefix(String clientIDPrefix){
  this.clientIDPrefix=clientIDPrefix;
}"
41214,"public String getClientIDPrefix(){
  return clientIDPrefix;
}","public synchronized String getClientIDPrefix(){
  return clientIDPrefix;
}"
41215,"/** 
 * Sets the prefix used by connection id generator.
 * @param connectionIDPrefix The string prefix used on all connection Id's created by this factory.
 */
public void setConnectionIDPrefix(String connectionIDPrefix){
  this.connectionIDPrefix=connectionIDPrefix;
}","/** 
 * Sets the prefix used by connection id generator.
 * @param connectionIDPrefix The string prefix used on all connection Id's created by this factory.
 */
public synchronized void setConnectionIDPrefix(String connectionIDPrefix){
  this.connectionIDPrefix=connectionIDPrefix;
}"
41216,"@Override public void close(){
  if (closed.compareAndSet(false,true)) {
    final ProviderFuture request=new ProviderFuture();
    serializer.execute(new Runnable(){
      @Override public void run(){
        try {
          if (!transport.isConnected()) {
            request.onSuccess();
          }
          if (connection != null) {
            connection.close(request);
          }
 else {
            request.onSuccess();
          }
          pumpToProtonTransport();
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"");
        }
      }
    }
);
    try {
      if (closeTimeout < 0) {
        request.sync();
      }
 else {
        request.sync(closeTimeout,TimeUnit.MILLISECONDS);
      }
    }
 catch (    IOException e) {
      LOG.warn(""String_Node_Str"",e.getMessage());
    }
 finally {
      if (transport != null) {
        try {
          transport.close();
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"",e.getMessage());
        }
      }
      if (serializer != null) {
        serializer.shutdown();
      }
    }
  }
}","@Override public void close(){
  if (closed.compareAndSet(false,true)) {
    final ProviderFuture request=new ProviderFuture();
    serializer.execute(new Runnable(){
      @Override public void run(){
        try {
          if (!transport.isConnected()) {
            request.onSuccess();
          }
          if (connection != null) {
            connection.close(request);
          }
 else {
            request.onSuccess();
          }
          pumpToProtonTransport();
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"");
        }
      }
    }
);
    try {
      if (closeTimeout < 0) {
        request.sync();
      }
 else {
        request.sync(closeTimeout,TimeUnit.MILLISECONDS);
      }
    }
 catch (    IOException e) {
      LOG.warn(""String_Node_Str"",e.getMessage());
    }
 finally {
      if (transport != null) {
        try {
          transport.close();
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"",e.getMessage());
        }
      }
      serializer.shutdown();
    }
  }
}"
41217,"/** 
 * Get properties from a uri
 * @param uri
 * @return <Code>Map</Code> of properties
 * @throws Exception
 */
public static Map<String,String> parseQuery(String uri) throws Exception {
  if (uri != null) {
    Map<String,String> rc=new HashMap<String,String>();
    if (uri != null) {
      String[] parameters=uri.split(""String_Node_Str"");
      for (int i=0; i < parameters.length; i++) {
        int p=parameters[i].indexOf(""String_Node_Str"");
        if (p >= 0) {
          String name=URLDecoder.decode(parameters[i].substring(0,p),""String_Node_Str"");
          String value=URLDecoder.decode(parameters[i].substring(p + 1),""String_Node_Str"");
          rc.put(name,value);
        }
 else {
          rc.put(parameters[i],null);
        }
      }
    }
    return rc;
  }
  return Collections.emptyMap();
}","/** 
 * Get properties from a uri
 * @param uri
 * @return <Code>Map</Code> of properties
 * @throws Exception
 */
public static Map<String,String> parseQuery(String uri) throws Exception {
  if (uri != null) {
    Map<String,String> rc=new HashMap<String,String>();
    String[] parameters=uri.split(""String_Node_Str"");
    for (int i=0; i < parameters.length; i++) {
      int p=parameters[i].indexOf(""String_Node_Str"");
      if (p >= 0) {
        String name=URLDecoder.decode(parameters[i].substring(0,p),""String_Node_Str"");
        String value=URLDecoder.decode(parameters[i].substring(p + 1),""String_Node_Str"");
        rc.put(name,value);
      }
 else {
        rc.put(parameters[i],null);
      }
    }
    return rc;
  }
  return Collections.emptyMap();
}"
41218,"@Override public boolean equals(Object o){
  ConversionKey x=(ConversionKey)o;
  return x.from == from && x.to == to;
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || o.getClass() != this.getClass()) {
    return false;
  }
  ConversionKey x=(ConversionKey)o;
  return x.from == from && x.to == to;
}"
41219,"static public Class loadClass(Properties properties) throws ClassNotFoundException, IOException {
  String className=properties.getProperty(""String_Node_Str"");
  if (className == null) {
    throw new IOException(""String_Node_Str"");
  }
  Class clazz=null;
  ClassLoader loader=Thread.currentThread().getContextClassLoader();
  if (loader != null) {
    try {
      clazz=loader.loadClass(className);
    }
 catch (    ClassNotFoundException e) {
    }
  }
  if (clazz == null) {
    clazz=FactoryFinder.class.getClassLoader().loadClass(className);
  }
  return clazz;
}","static public Class<?> loadClass(Properties properties) throws ClassNotFoundException, IOException {
  String className=properties.getProperty(""String_Node_Str"");
  if (className == null) {
    throw new IOException(""String_Node_Str"");
  }
  Class<?> clazz=null;
  ClassLoader loader=Thread.currentThread().getContextClassLoader();
  if (loader != null) {
    try {
      clazz=loader.loadClass(className);
    }
 catch (    ClassNotFoundException e) {
    }
  }
  if (clazz == null) {
    clazz=FactoryFinder.class.getClassLoader().loadClass(className);
  }
  return clazz;
}"
41220,"@Override public Object create(final String path) throws InstantiationException, IllegalAccessException, ClassNotFoundException, IOException {
  Class clazz=classMap.get(path);
  if (clazz == null) {
    clazz=loadClass(loadProperties(path));
    classMap.put(path,clazz);
  }
  return clazz.newInstance();
}","@Override public Object create(final String path) throws InstantiationException, IllegalAccessException, ClassNotFoundException, IOException {
  Class<?> clazz=classMap.get(path);
  if (clazz == null) {
    clazz=loadClass(loadProperties(path));
    Class<?> previous=classMap.putIfAbsent(path,clazz);
    if (previous != null) {
      clazz=previous;
    }
  }
  return clazz.newInstance();
}"
41221,"/** 
 * Creates a new instance of the given key.  The method first checks the cache of previously found factory instances for one that matches the key.  If no cached version exists then the factory will be searched for using the configured ObjectFactory instance.
 * @param key is the key to add to the path to find a text file containing the factory name
 * @return a newly created instance
 * @throws IllegalAccessException if an error occurs while accessing the search path.
 * @throws InstantiationException if the factory object fails on create.
 * @throws IOException if the search encounter an IO error.
 * @throws ClassNotFoundException if the class that is to be loaded cannot be found.
 * @throws ClassCastException if the found object is not assignable to the request factory type.
 */
public T newInstance(String key) throws IllegalAccessException, InstantiationException, IOException, ClassNotFoundException, ClassCastException {
  T factory=cachedFactories.get(key);
  if (factory == null) {
    Object found=objectFactory.create(path + key);
    if (found != null && factoryType.isInstance(found)) {
      factory=factoryType.cast(found);
      cachedFactories.put(key,factory);
    }
 else {
      throw new ClassCastException(""String_Node_Str"" + found.getClass().getName() + ""String_Node_Str""+ factoryType.getName());
    }
  }
  return factory;
}","/** 
 * Creates a new instance of the given key.  The method first checks the cache of previously found factory instances for one that matches the key.  If no cached version exists then the factory will be searched for using the configured ObjectFactory instance.
 * @param key is the key to add to the path to find a text file containing the factory name
 * @return a newly created instance
 * @throws IllegalAccessException if an error occurs while accessing the search path.
 * @throws InstantiationException if the factory object fails on create.
 * @throws IOException if the search encounter an IO error.
 * @throws ClassNotFoundException if the class that is to be loaded cannot be found.
 * @throws ClassCastException if the found object is not assignable to the request factory type.
 */
public T newInstance(String key) throws IllegalAccessException, InstantiationException, IOException, ClassNotFoundException, ClassCastException {
  T factory=cachedFactories.get(key);
  if (factory == null) {
    Object found=objectFactory.create(path + key);
    if (found != null) {
      if (factoryType.isInstance(found)) {
        factory=factoryType.cast(found);
        cachedFactories.putIfAbsent(key,factory);
      }
 else {
        throw new ClassCastException(""String_Node_Str"" + found.getClass().getName() + ""String_Node_Str""+ factoryType.getName());
      }
    }
 else {
      throw new ClassNotFoundException(""String_Node_Str"" + key);
    }
  }
  return factory;
}"
41222,"static public Properties loadProperties(String uri) throws IOException {
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  if (classLoader == null) {
    classLoader=StandaloneObjectFactory.class.getClassLoader();
  }
  InputStream in=classLoader.getResourceAsStream(uri);
  if (in == null) {
    in=FactoryFinder.class.getClassLoader().getResourceAsStream(uri);
    if (in == null) {
      throw new IOException(""String_Node_Str"" + uri);
    }
  }
  BufferedInputStream reader=null;
  try {
    reader=new BufferedInputStream(in);
    Properties properties=new Properties();
    properties.load(reader);
    return properties;
  }
  finally {
    try {
      reader.close();
    }
 catch (    Exception e) {
    }
  }
}","static public Properties loadProperties(String uri) throws IOException {
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  if (classLoader == null) {
    classLoader=StandaloneObjectFactory.class.getClassLoader();
  }
  InputStream in=classLoader.getResourceAsStream(uri);
  if (in == null) {
    in=FactoryFinder.class.getClassLoader().getResourceAsStream(uri);
    if (in == null) {
      throw new IOException(""String_Node_Str"" + uri);
    }
  }
  try (BufferedInputStream reader=new BufferedInputStream(in)){
    Properties properties=new Properties();
    properties.load(reader);
    return properties;
  }
 }"
41223,"@Override public boolean equals(Object object){
  if (object instanceof JmsPrefetchPolicy) {
    JmsPrefetchPolicy other=(JmsPrefetchPolicy)object;
    return this.queuePrefetch == other.queuePrefetch && this.queueBrowserPrefetch == other.queueBrowserPrefetch && this.topicPrefetch == other.topicPrefetch && this.durableTopicPrefetch == other.durableTopicPrefetch;
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsPrefetchPolicy other=(JmsPrefetchPolicy)obj;
  return this.queuePrefetch == other.queuePrefetch && this.queueBrowserPrefetch == other.queueBrowserPrefetch && this.topicPrefetch == other.topicPrefetch && this.durableTopicPrefetch == other.durableTopicPrefetch;
}"
41224,"@Override public int hashCode(){
  return this.connectionId.hashCode();
}","@Override public int hashCode(){
  return (connectionId == null) ? super.hashCode() : connectionId.hashCode();
}"
41225,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsConnectionInfo other=(JmsConnectionInfo)obj;
  if (connectionId == null && other.connectionId != null) {
    return false;
  }
 else   if (!connectionId.equals(other.connectionId)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsConnectionInfo other=(JmsConnectionInfo)obj;
  if (connectionId != null) {
    return connectionId.equals(other.connectionId);
  }
  return false;
}"
41226,"@Override public int hashCode(){
  return (consumerId == null) ? 0 : consumerId.hashCode();
}","@Override public int hashCode(){
  return (consumerId == null) ? super.hashCode() : consumerId.hashCode();
}"
41227,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsConsumerInfo other=(JmsConsumerInfo)obj;
  if (consumerId == null && other.consumerId != null) {
    return false;
  }
 else   if (!consumerId.equals(other.consumerId)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsConsumerInfo other=(JmsConsumerInfo)obj;
  if (consumerId != null) {
    return consumerId.equals(other.consumerId);
  }
  return false;
}"
41228,"@Override public int hashCode(){
  return (producerId == null) ? 0 : producerId.hashCode();
}","@Override public int hashCode(){
  return (producerId == null) ? super.hashCode() : producerId.hashCode();
}"
41229,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsProducerInfo other=(JmsProducerInfo)obj;
  if (producerId == null && other.producerId != null) {
    return false;
  }
 else   if (!producerId.equals(other.producerId)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsProducerInfo other=(JmsProducerInfo)obj;
  if (producerId != null) {
    return producerId.equals(other.producerId);
  }
  return false;
}"
41230,"@Override public int hashCode(){
  return (transactionId == null) ? 0 : transactionId.hashCode();
}","@Override public int hashCode(){
  return (transactionId == null) ? super.hashCode() : transactionId.hashCode();
}"
41231,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsTransactionInfo other=(JmsTransactionInfo)obj;
  if (transactionId == null && other.transactionId != null) {
    return false;
  }
 else   if (!transactionId.equals(other.transactionId)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsTransactionInfo other=(JmsTransactionInfo)obj;
  if (transactionId != null) {
    return transactionId.equals(other.transactionId);
  }
  return false;
}"
41232,"/** 
 * @return clientId
 * @see javax.jms.Connection#getClientID()
 */
@Override public String getClientID() throws JMSException {
  checkClosedOrFailed();
  return this.connectionInfo.getClientId();
}","/** 
 * @return clientId
 * @see javax.jms.Connection#getClientID()
 */
@Override public synchronized String getClientID() throws JMSException {
  checkClosedOrFailed();
  return this.connectionInfo.getClientId();
}"
41233,"/** 
 * Called to free all Connection resources.
 */
protected void shutdown() throws JMSException {
  for (  JmsSession session : this.sessions) {
    session.shutdown();
  }
  if (isConnected() && !failed.get() && !closing.get()) {
    destroyResource(connectionInfo);
  }
  if (clientIdSet) {
    connectionInfo.setClientId(null);
    clientIdSet=false;
  }
  tempDestinations.clear();
  started.set(false);
  connected.set(false);
}","/** 
 * Called to free all Connection resources.
 */
protected void shutdown() throws JMSException {
  for (  JmsSession session : this.sessions) {
    session.shutdown();
  }
  if (isConnected() && !failed.get() && !closing.get()) {
    destroyResource(connectionInfo);
  }
synchronized (this) {
    if (clientIdSet) {
      connectionInfo.setClientId(null);
      clientIdSet=false;
    }
  }
  tempDestinations.clear();
  started.set(false);
  connected.set(false);
}"
41234,"@Override public byte[] getBytes(String name) throws JMSException {
  Object value=getObject(name);
  if (value == null) {
    return (byte[])value;
  }
 else   if (value instanceof byte[]) {
    byte[] original=(byte[])value;
    byte[] clone=new byte[original.length];
    System.arraycopy(original,0,clone,0,original.length);
    return clone;
  }
 else {
    throw new MessageFormatException(""String_Node_Str"" + value.getClass().getSimpleName());
  }
}","@Override public byte[] getBytes(String name) throws JMSException {
  Object value=getObject(name);
  if (value == null) {
    return null;
  }
 else   if (value instanceof byte[]) {
    byte[] original=(byte[])value;
    byte[] clone=new byte[original.length];
    System.arraycopy(original,0,clone,0,original.length);
    return clone;
  }
 else {
    throw new MessageFormatException(""String_Node_Str"" + value.getClass().getSimpleName());
  }
}"
41235,"@Override protected void doOpen(){
  JmsDestination destination=info.getDestination();
  String destnationName=session.getQualifiedName(destination);
  String sourceAddress=getProducerId().toString();
  Source source=new Source();
  source.setAddress(sourceAddress);
  Target target=new Target();
  target.setAddress(destnationName);
  String senderName=sourceAddress + ""String_Node_Str"" + destnationName != null ? destnationName : ""String_Node_Str"";
  endpoint=session.getProtonSession().sender(senderName);
  endpoint.setSource(source);
  endpoint.setTarget(target);
  if (presettle) {
    endpoint.setSenderSettleMode(SenderSettleMode.SETTLED);
  }
 else {
    endpoint.setSenderSettleMode(SenderSettleMode.UNSETTLED);
  }
  endpoint.setReceiverSettleMode(ReceiverSettleMode.FIRST);
}","@Override protected void doOpen(){
  JmsDestination destination=info.getDestination();
  String destnationName=session.getQualifiedName(destination);
  String sourceAddress=getProducerId().toString();
  Source source=new Source();
  source.setAddress(sourceAddress);
  Target target=new Target();
  target.setAddress(destnationName);
  String senderName=sourceAddress + ""String_Node_Str"" + destnationName;
  endpoint=session.getProtonSession().sender(senderName);
  endpoint.setSource(source);
  endpoint.setTarget(target);
  if (presettle) {
    endpoint.setSenderSettleMode(SenderSettleMode.SETTLED);
  }
 else {
    endpoint.setSenderSettleMode(SenderSettleMode.UNSETTLED);
  }
  endpoint.setReceiverSettleMode(ReceiverSettleMode.FIRST);
}"
41236,"private Binary getBinaryFromBody(){
  Section body=getAmqpMessage().getBody();
  Binary result=null;
  if (body == null) {
    return result;
  }
  if (body instanceof Data) {
    Binary payload=((Data)body).getValue();
    if (payload != null && payload.getLength() != 0) {
      result=payload;
    }
  }
 else   if (body instanceof AmqpValue) {
    Object value=((AmqpValue)body).getValue();
    if (value == null) {
      return result;
    }
    if (value instanceof Binary) {
      Binary payload=(Binary)value;
      if (payload != null && payload.getLength() != 0) {
        result=payload;
      }
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + value.getClass().getSimpleName());
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + body.getClass().getSimpleName());
  }
  return result;
}","private Binary getBinaryFromBody(){
  Section body=getAmqpMessage().getBody();
  Binary result=null;
  if (body == null) {
    return result;
  }
  if (body instanceof Data) {
    Binary payload=((Data)body).getValue();
    if (payload != null && payload.getLength() != 0) {
      result=payload;
    }
  }
 else   if (body instanceof AmqpValue) {
    Object value=((AmqpValue)body).getValue();
    if (value == null) {
      return result;
    }
    if (value instanceof Binary) {
      Binary payload=(Binary)value;
      if (payload.getLength() != 0) {
        result=payload;
      }
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + value.getClass().getSimpleName());
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + body.getClass().getSimpleName());
  }
  return result;
}"
41237,"@Override public void setCorrelationId(String correlationId){
  AmqpMessageIdHelper messageIdHelper=AmqpMessageIdHelper.INSTANCE;
  if (correlationId == null) {
    message.setCorrelationId(null);
  }
 else {
    boolean appSpecific=false;
    boolean hasMessageIdPrefix=messageIdHelper.hasMessageIdPrefix(correlationId);
    if (correlationId != null && !hasMessageIdPrefix) {
      appSpecific=true;
    }
    String stripped=messageIdHelper.stripMessageIdPrefix(correlationId);
    if (hasMessageIdPrefix) {
      try {
        Object idObject=messageIdHelper.toIdObject(stripped);
        message.setCorrelationId(idObject);
      }
 catch (      IdConversionException e) {
        throw new RuntimeException(e);
      }
    }
 else {
      message.setCorrelationId(stripped);
    }
    if (appSpecific) {
      setAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID,true);
    }
 else {
      removeAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID);
    }
  }
}","@Override public void setCorrelationId(String correlationId){
  AmqpMessageIdHelper messageIdHelper=AmqpMessageIdHelper.INSTANCE;
  if (correlationId == null) {
    message.setCorrelationId(null);
  }
 else {
    boolean appSpecific=false;
    boolean hasMessageIdPrefix=messageIdHelper.hasMessageIdPrefix(correlationId);
    if (!hasMessageIdPrefix) {
      appSpecific=true;
    }
    String stripped=messageIdHelper.stripMessageIdPrefix(correlationId);
    if (hasMessageIdPrefix) {
      try {
        Object idObject=messageIdHelper.toIdObject(stripped);
        message.setCorrelationId(idObject);
      }
 catch (      IdConversionException e) {
        throw new RuntimeException(e);
      }
    }
 else {
      message.setCorrelationId(stripped);
    }
    if (appSpecific) {
      setAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID,true);
    }
 else {
      removeAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID);
    }
  }
}"
41238,"/** 
 * Given a key / value mapping, create and return a URI formatted query string that is valid and can be appended to a URI.
 * @param options The Mapping that will create the new Query string.
 * @return a URI formatted query string.
 * @throws URISyntaxException
 */
public static String createQueryString(Map<String,? extends Object> options) throws URISyntaxException {
  try {
    if (options.size() > 0) {
      StringBuffer rc=new StringBuffer();
      boolean first=true;
      for (      String key : options.keySet()) {
        if (first) {
          first=false;
        }
 else {
          rc.append(""String_Node_Str"");
        }
        String value=(String)options.get(key);
        rc.append(URLEncoder.encode(key,""String_Node_Str""));
        rc.append(""String_Node_Str"");
        rc.append(URLEncoder.encode(value,""String_Node_Str""));
      }
      return rc.toString();
    }
 else {
      return ""String_Node_Str"";
    }
  }
 catch (  UnsupportedEncodingException e) {
    throw (URISyntaxException)new URISyntaxException(e.toString(),""String_Node_Str"").initCause(e);
  }
}","/** 
 * Given a key / value mapping, create and return a URI formatted query string that is valid and can be appended to a URI.
 * @param options The Mapping that will create the new Query string.
 * @return a URI formatted query string.
 * @throws URISyntaxException
 */
public static String createQueryString(Map<String,? extends Object> options) throws URISyntaxException {
  try {
    if (options.size() > 0) {
      StringBuffer rc=new StringBuffer();
      boolean first=true;
      for (      Entry<String,? extends Object> entry : options.entrySet()) {
        if (first) {
          first=false;
        }
 else {
          rc.append(""String_Node_Str"");
        }
        rc.append(URLEncoder.encode(entry.getKey(),""String_Node_Str""));
        rc.append(""String_Node_Str"");
        rc.append(URLEncoder.encode((String)entry.getValue(),""String_Node_Str""));
      }
      return rc.toString();
    }
 else {
      return ""String_Node_Str"";
    }
  }
 catch (  UnsupportedEncodingException e) {
    throw (URISyntaxException)new URISyntaxException(e.toString(),""String_Node_Str"").initCause(e);
  }
}"
41239,"/** 
 * Given a map of properties, filter out only those prefixed with the given value, the values filtered are returned in a new Map instance.
 * @param properties The map of properties to filter.
 * @param optionPrefix The prefix value to use when filtering.
 * @return a filter map with only values that match the given prefix.
 */
public static Map<String,String> filterProperties(Map<String,String> props,String optionPrefix){
  if (props == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HashMap<String,String> rc=new HashMap<String,String>(props.size());
  for (Iterator<String> iter=props.keySet().iterator(); iter.hasNext(); ) {
    String name=iter.next();
    if (name.startsWith(optionPrefix)) {
      String value=props.get(name);
      name=name.substring(optionPrefix.length());
      rc.put(name,value);
      iter.remove();
    }
  }
  return rc;
}","/** 
 * Given a map of properties, filter out only those prefixed with the given value, the values filtered are returned in a new Map instance.
 * @param properties The map of properties to filter.
 * @param optionPrefix The prefix value to use when filtering.
 * @return a filter map with only values that match the given prefix.
 */
public static Map<String,String> filterProperties(Map<String,String> props,String optionPrefix){
  if (props == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HashMap<String,String> rc=new HashMap<String,String>(props.size());
  for (Iterator<Entry<String,String>> iter=props.entrySet().iterator(); iter.hasNext(); ) {
    Entry<String,String> entry=iter.next();
    if (entry.getKey().startsWith(optionPrefix)) {
      String name=entry.getKey().substring(optionPrefix.length());
      rc.put(name,entry.getValue());
      iter.remove();
    }
  }
  return rc;
}"
41240,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static String toString(Object target,Class stopClass,Map<String,Object> overrideFields){
  LinkedHashMap<String,Object> map=new LinkedHashMap<String,Object>();
  addFields(target,target.getClass(),stopClass,map);
  if (overrideFields != null) {
    for (    String key : overrideFields.keySet()) {
      Object value=overrideFields.get(key);
      map.put(key,value);
    }
  }
  StringBuffer buffer=new StringBuffer(simpleName(target.getClass()));
  buffer.append(""String_Node_Str"");
  Set<Entry<String,Object>> entrySet=map.entrySet();
  boolean first=true;
  for (  Map.Entry<String,Object> entry : entrySet) {
    Object value=entry.getValue();
    Object key=entry.getKey();
    if (first) {
      first=false;
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    buffer.append(key);
    buffer.append(""String_Node_Str"");
    appendToString(buffer,key,value);
  }
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static String toString(Object target,Class stopClass,Map<String,Object> overrideFields){
  LinkedHashMap<String,Object> map=new LinkedHashMap<String,Object>();
  addFields(target,target.getClass(),stopClass,map);
  if (overrideFields != null) {
    for (    Entry<String,Object> entry : overrideFields.entrySet()) {
      map.put(entry.getKey(),entry.getValue());
    }
  }
  StringBuffer buffer=new StringBuffer(simpleName(target.getClass()));
  buffer.append(""String_Node_Str"");
  Set<Entry<String,Object>> entrySet=map.entrySet();
  boolean first=true;
  for (  Map.Entry<String,Object> entry : entrySet) {
    Object value=entry.getValue();
    Object key=entry.getKey();
    if (first) {
      first=false;
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    buffer.append(key);
    buffer.append(""String_Node_Str"");
    appendToString(buffer,key,value);
  }
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}"
41241,"/** 
 * Creates a new Facade around an incoming AMQP Message for dispatch to the JMS Consumer instance.
 * @param consumer the consumer that received this message.
 * @param message the incoming Message instance that is being wrapped.
 */
@SuppressWarnings(""String_Node_Str"") public AmqpJmsMessageFacade(AmqpConsumer consumer,Message message){
  this.message=message;
  this.connection=consumer.getConnection();
  this.consumerDestination=consumer.getDestination();
  annotations=message.getMessageAnnotations();
  if (annotations != null) {
    annotationsMap=annotations.getValue();
  }
  if (message.getApplicationProperties() != null) {
    applicationPropertiesMap=message.getApplicationProperties().getValue();
  }
  Long ttl=message.getTtl();
  Long absoluteExpiryTime=getAbsoluteExpiryTime();
  if (absoluteExpiryTime == null && ttl != null) {
    syntheticExpiration=System.currentTimeMillis() + ttl;
  }
}","/** 
 * Creates a new Facade around an incoming AMQP Message for dispatch to the JMS Consumer instance.
 * @param consumer the consumer that received this message.
 * @param message the incoming Message instance that is being wrapped.
 */
@SuppressWarnings(""String_Node_Str"") public AmqpJmsMessageFacade(AmqpConsumer consumer,Message message){
  this.message=message;
  this.connection=consumer.getConnection();
  this.consumerDestination=consumer.getDestination();
  annotations=message.getMessageAnnotations();
  if (annotations != null) {
    annotationsMap=annotations.getValue();
  }
  if (message.getApplicationProperties() != null) {
    applicationPropertiesMap=message.getApplicationProperties().getValue();
  }
  Long ttl=getTtl();
  Long absoluteExpiryTime=getAbsoluteExpiryTime();
  if (absoluteExpiryTime == null && ttl != null) {
    syntheticExpiration=System.currentTimeMillis() + ttl;
  }
}"
41242,"@Override public void start() throws IOException, IllegalStateException {
  if (listener == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (started.compareAndSet(false,true)) {
    if (group == null || group.length() == 0) {
      throw new IOException(""String_Node_Str"");
    }
    if (discoveryURI == null) {
      try {
        discoveryURI=new URI(DEFAULT_DISCOVERY_URI_STRING);
      }
 catch (      URISyntaxException e) {
      }
    }
    LOG.trace(""String_Node_Str"",discoveryURI);
    String myHost=discoveryURI.getHost();
    int myPort=discoveryURI.getPort();
    if (DEFAULT_HOST_STR.equals(myHost)) {
      myHost=DEFAULT_HOST_IP;
    }
    if (myPort < 0) {
      myPort=DEFAULT_PORT;
    }
    LOG.trace(""String_Node_Str"",myHost);
    LOG.trace(""String_Node_Str"",myPort);
    LOG.trace(""String_Node_Str"",group);
    LOG.trace(""String_Node_Str"",mcInterface);
    LOG.trace(""String_Node_Str"",mcNetworkInterface);
    LOG.trace(""String_Node_Str"",mcJoinNetworkInterface);
    this.inetAddress=InetAddress.getByName(myHost);
    this.sockAddress=new InetSocketAddress(this.inetAddress,myPort);
    mcast=new MulticastSocket(myPort);
    mcast.setLoopbackMode(loopBackMode);
    mcast.setTimeToLive(getTimeToLive());
    if (mcJoinNetworkInterface != null) {
      mcast.joinGroup(sockAddress,NetworkInterface.getByName(mcJoinNetworkInterface));
    }
 else {
      mcast.joinGroup(inetAddress);
    }
    mcast.setSoTimeout((int)keepAliveInterval);
    if (mcInterface != null) {
      mcast.setInterface(InetAddress.getByName(mcInterface));
    }
    if (mcNetworkInterface != null) {
      mcast.setNetworkInterface(NetworkInterface.getByName(mcNetworkInterface));
    }
    runner=new Thread(this);
    runner.setName(this.toString() + ""String_Node_Str"" + runner.getName());
    runner.setDaemon(true);
    runner.start();
  }
}","@Override public void start() throws IOException, IllegalStateException {
  if (listener == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (started.compareAndSet(false,true)) {
    if (group == null || group.length() == 0) {
      throw new IOException(""String_Node_Str"");
    }
    if (discoveryURI == null) {
      try {
        discoveryURI=new URI(DEFAULT_DISCOVERY_URI_STRING);
      }
 catch (      URISyntaxException e) {
      }
      if (discoveryURI == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
    LOG.trace(""String_Node_Str"",discoveryURI);
    String myHost=discoveryURI.getHost();
    int myPort=discoveryURI.getPort();
    if (myHost == null || DEFAULT_HOST_STR.equals(myHost)) {
      myHost=DEFAULT_HOST_IP;
    }
    if (myPort < 0) {
      myPort=DEFAULT_PORT;
    }
    LOG.trace(""String_Node_Str"",myHost);
    LOG.trace(""String_Node_Str"",myPort);
    LOG.trace(""String_Node_Str"",group);
    LOG.trace(""String_Node_Str"",mcInterface);
    LOG.trace(""String_Node_Str"",mcNetworkInterface);
    LOG.trace(""String_Node_Str"",mcJoinNetworkInterface);
    this.inetAddress=InetAddress.getByName(myHost);
    this.sockAddress=new InetSocketAddress(this.inetAddress,myPort);
    mcast=new MulticastSocket(myPort);
    mcast.setLoopbackMode(loopBackMode);
    mcast.setTimeToLive(getTimeToLive());
    if (mcJoinNetworkInterface != null) {
      mcast.joinGroup(sockAddress,NetworkInterface.getByName(mcJoinNetworkInterface));
    }
 else {
      mcast.joinGroup(inetAddress);
    }
    mcast.setSoTimeout((int)keepAliveInterval);
    if (mcInterface != null) {
      mcast.setInterface(InetAddress.getByName(mcInterface));
    }
    if (mcNetworkInterface != null) {
      mcast.setNetworkInterface(NetworkInterface.getByName(mcNetworkInterface));
    }
    runner=new Thread(this);
    runner.setName(this.toString() + ""String_Node_Str"" + runner.getName());
    runner.setDaemon(true);
    runner.start();
  }
}"
41243,"/** 
 * Searches for a PacketParserFactory by using the given key. The search first checks the local cache of packet parser factories before moving on to search in the classpath.
 * @param key The name of the PacketParserFactory that should be located.
 * @return a PacketParserFactory instance matching the given key.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static PacketParserFactory findAgentFactory(String key) throws IOException {
  if (key == null) {
    throw new IOException(""String_Node_Str"" + key + ""String_Node_Str"");
  }
  PacketParserFactory factory=null;
  if (factory == null) {
    try {
      factory=AGENT_FACTORY_FINDER.newInstance(key);
    }
 catch (    Throwable e) {
      throw new IOException(""String_Node_Str"" + key + ""String_Node_Str"",e);
    }
  }
  return factory;
}","/** 
 * Searches for a PacketParserFactory by using the given key. The search first checks the local cache of packet parser factories before moving on to search in the classpath.
 * @param key The name of the PacketParserFactory that should be located.
 * @return a PacketParserFactory instance matching the given key.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static PacketParserFactory findAgentFactory(String key) throws IOException {
  if (key == null) {
    throw new IOException(""String_Node_Str"");
  }
  PacketParserFactory factory=null;
  if (factory == null) {
    try {
      factory=AGENT_FACTORY_FINDER.newInstance(key);
    }
 catch (    Throwable e) {
      throw new IOException(""String_Node_Str"" + key + ""String_Node_Str"",e);
    }
  }
  return factory;
}"
41244,"/** 
 * Check whether the content-type field of the properties section (if present) in the given message matches the provided string (where null matches if there is no content type rpeesnt.
 * @param contentType content type string to compare against, or null if none
 * @param message the AMQP message object that is being examined.
 * @return true if content type matches
 */
public static boolean isContentType(String contentType,Message message){
  if (contentType == null) {
    return message.getContentType() == null;
  }
 else {
    return contentType.equals(message.getContentType());
  }
}","/** 
 * Check whether the content-type field of the properties section (if present) in the given message matches the provided string (where null matches if there is no content type present.
 * @param contentType content type string to compare against, or null if none
 * @param message the AMQP message object that is being examined.
 * @return true if content type matches
 */
public static boolean isContentType(String contentType,Message message){
  if (contentType == null) {
    return message.getContentType() == null;
  }
 else {
    return contentType.equals(message.getContentType());
  }
}"
41245,"public void setReplyToAddressFromDestination(AmqpJmsMessageFacade message,JmsDestination destination){
  if (destination == null) {
    return;
  }
  String replyToAddress=destination.getName();
  String typeString=toTypeAnnotation(destination);
  message.setReplyToAddress(replyToAddress);
  if (replyToAddress == null || typeString == null) {
    message.removeAnnotation(REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
  }
 else {
    message.setAnnotation(REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,typeString);
  }
}","public void setReplyToAddressFromDestination(AmqpJmsMessageFacade message,JmsDestination destination){
  String replyToAddress=destination != null ? destination.getName() : null;
  String typeString=toTypeAnnotation(destination);
  message.setReplyToAddress(replyToAddress);
  if (replyToAddress == null || typeString == null) {
    message.removeAnnotation(REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
  }
 else {
    message.setAnnotation(REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,typeString);
  }
}"
41246,"public void setToAddressFromDestination(AmqpJmsMessageFacade message,JmsDestination destination){
  if (destination == null) {
    return;
  }
  String address=destination.getName();
  String typeString=toTypeAnnotation(destination);
  message.setToAddress(address);
  if (address == null || typeString == null) {
    message.removeAnnotation(TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
  }
 else {
    message.setAnnotation(TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,typeString);
  }
}","public void setToAddressFromDestination(AmqpJmsMessageFacade message,JmsDestination destination){
  String address=destination != null ? destination.getName() : null;
  String typeString=toTypeAnnotation(destination);
  message.setToAddress(address);
  if (address == null || typeString == null) {
    message.removeAnnotation(TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
  }
 else {
    message.setAnnotation(TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,typeString);
  }
}"
41247,"@Test public void testSetToAddressFromDestinationWithNullDestination(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setToAddressFromDestination(message,null);
  Mockito.verifyZeroInteractions(message);
}","@Test public void testSetToAddressFromDestinationWithNullDestination(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setToAddressFromDestination(message,null);
  Mockito.verify(message).setToAddress(null);
  Mockito.verify(message).removeAnnotation(TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
}"
41248,"@Test public void testSetReplyToAddressFromDestinationWithNullDestinationAndNullMessage(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setReplyToAddressFromDestination(null,null);
  Mockito.verifyZeroInteractions(message);
}","@Test(expected=NullPointerException.class) public void testSetReplyToAddressFromDestinationWithNullDestinationAndNullMessage(){
  helper.setReplyToAddressFromDestination(null,null);
}"
41249,"@Test public void testSetReplyToAddressFromDestinationWithNullDestination(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setReplyToAddressFromDestination(message,null);
  Mockito.verifyZeroInteractions(message);
}","@Test public void testSetReplyToAddressFromDestinationWithNullDestination(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setReplyToAddressFromDestination(message,null);
  Mockito.verify(message).setReplyToAddress(null);
  Mockito.verify(message).removeAnnotation(REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
}"
41250,"@Test public void testSetToAddressFromDestinationWithNullDestinationAndNullMessage(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setToAddressFromDestination(null,null);
  Mockito.verifyZeroInteractions(message);
}","@Test(expected=NullPointerException.class) public void testSetToAddressFromDestinationWithNullDestinationAndNullMessage(){
  helper.setToAddressFromDestination(null,null);
}"
41251,"public InfoResultMultiPartRequest(final int requestId,final String url,final int method,final ResponseParserListener parseListener,final ILogic logic){
  super(method,url,null,new ErrorListener(){
    @Override public void onErrorResponse(    VolleyError error){
      try {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        PrintStream ps=new PrintStream(baos);
        error.printStackTrace(ps);
        String errorMsg=new String(baos.toByteArray());
        LogUtil.e(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str""+ (method == Method.GET ? ""String_Node_Str"" : ""String_Node_Str""));
        LogUtil.e(""String_Node_Str"",errorMsg);
        InfoResult infoResult=parseListener.doParse(""String_Node_Str"" + errorMsg + ""String_Node_Str"");
        infoResult.setExtraObj(error);
        logic.onResult(requestId,infoResult);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  this.parserListener=parseListener;
  this.requestId=requestId;
  this.logic=logic;
  RetryPolicy retryPolicy=new DefaultRetryPolicy(20000,0,DefaultRetryPolicy.DEFAULT_BACKOFF_MULT);
  setRetryPolicy(retryPolicy);
}","public InfoResultMultiPartRequest(final int requestId,final String url,final int method,final ResponseParserListener parseListener,final ILogic logic){
  super(method,url,null,new ErrorListener(){
    @Override public void onErrorResponse(    VolleyError error){
      try {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        PrintStream ps=new PrintStream(baos);
        error.printStackTrace(ps);
        String errorMsg=new String(baos.toByteArray());
        LogUtil.e(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str""+ (method == Method.GET ? ""String_Node_Str"" : ""String_Node_Str""));
        LogUtil.e(""String_Node_Str"",errorMsg);
        InfoResult infoResult=parseListener.doParse(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        infoResult.setExtraObj(error);
        logic.onResult(requestId,infoResult);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  this.parserListener=parseListener;
  this.requestId=requestId;
  this.logic=logic;
  RetryPolicy retryPolicy=new DefaultRetryPolicy(20000,0,DefaultRetryPolicy.DEFAULT_BACKOFF_MULT);
  setRetryPolicy(retryPolicy);
}"
41252,"@Override public void onErrorResponse(VolleyError error){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    PrintStream ps=new PrintStream(baos);
    error.printStackTrace(ps);
    String errorMsg=new String(baos.toByteArray());
    LogUtil.e(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str""+ (method == Method.GET ? ""String_Node_Str"" : ""String_Node_Str""));
    LogUtil.e(""String_Node_Str"",errorMsg);
    InfoResult infoResult=parseListener.doParse(""String_Node_Str"" + errorMsg + ""String_Node_Str"");
    infoResult.setExtraObj(error);
    logic.onResult(requestId,infoResult);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Override public void onErrorResponse(VolleyError error){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    PrintStream ps=new PrintStream(baos);
    error.printStackTrace(ps);
    String errorMsg=new String(baos.toByteArray());
    LogUtil.e(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str""+ (method == Method.GET ? ""String_Node_Str"" : ""String_Node_Str""));
    LogUtil.e(""String_Node_Str"",errorMsg);
    InfoResult infoResult=parseListener.doParse(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    infoResult.setExtraObj(error);
    logic.onResult(requestId,infoResult);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
41253,"private InfoResultRequest(final int requestId,final String url,final int method,final Map<String,Object> params,final ResponseParserListener parseListener,final ILogic logic){
  super(method,url,new ErrorListener(){
    @Override public void onErrorResponse(    VolleyError error){
      try {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        PrintStream ps=new PrintStream(baos);
        error.printStackTrace(ps);
        String errorMsg=new String(baos.toByteArray());
        LogUtil.e(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str""+ (method == Method.GET ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ params.toString());
        LogUtil.e(""String_Node_Str"",errorMsg);
        InfoResult infoResult=parseListener.doParse(""String_Node_Str"" + errorMsg + ""String_Node_Str"");
        infoResult.setExtraObj(error);
        logic.onResult(requestId,infoResult);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  this.params=params;
  this.parserListener=parseListener;
  this.requestId=requestId;
  this.logic=logic;
  RetryPolicy retryPolicy=new DefaultRetryPolicy(20000,0,DefaultRetryPolicy.DEFAULT_BACKOFF_MULT);
  setRetryPolicy(retryPolicy);
}","private InfoResultRequest(final int requestId,final String url,final int method,final Map<String,Object> params,final ResponseParserListener parseListener,final ILogic logic){
  super(method,url,new ErrorListener(){
    @Override public void onErrorResponse(    VolleyError error){
      try {
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        PrintStream ps=new PrintStream(baos);
        error.printStackTrace(ps);
        String errorMsg=new String(baos.toByteArray());
        LogUtil.e(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str""+ (method == Method.GET ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ params != null ? params.toString() : ""String_Node_Str"");
        LogUtil.e(""String_Node_Str"",errorMsg);
        InfoResult infoResult=parseListener.doParse(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        infoResult.setExtraObj(error);
        logic.onResult(requestId,infoResult);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  this.params=params;
  this.parserListener=parseListener;
  this.requestId=requestId;
  this.logic=logic;
  RetryPolicy retryPolicy=new DefaultRetryPolicy(20000,0,DefaultRetryPolicy.DEFAULT_BACKOFF_MULT);
  setRetryPolicy(retryPolicy);
}"
41254,"@Override public void onErrorResponse(VolleyError error){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    PrintStream ps=new PrintStream(baos);
    error.printStackTrace(ps);
    String errorMsg=new String(baos.toByteArray());
    LogUtil.e(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str""+ (method == Method.GET ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ params.toString());
    LogUtil.e(""String_Node_Str"",errorMsg);
    InfoResult infoResult=parseListener.doParse(""String_Node_Str"" + errorMsg + ""String_Node_Str"");
    infoResult.setExtraObj(error);
    logic.onResult(requestId,infoResult);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Override public void onErrorResponse(VolleyError error){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    PrintStream ps=new PrintStream(baos);
    error.printStackTrace(ps);
    String errorMsg=new String(baos.toByteArray());
    LogUtil.e(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str""+ (method == Method.GET ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ params != null ? params.toString() : ""String_Node_Str"");
    LogUtil.e(""String_Node_Str"",errorMsg);
    InfoResult infoResult=parseListener.doParse(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    infoResult.setExtraObj(error);
    logic.onResult(requestId,infoResult);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
41255,"@Override protected void init(){
  super.init();
  titleLay=findViewById(R.id.title_lay);
  leftBtn=(Button)findViewById(R.id.title_left_btn);
  titleTxt=(TextView)findViewById(R.id.title_txt);
  rightBtn=(Button)findViewById(R.id.title_right_btn);
  mLoadingView=(LoadingView)findViewById(R.id.loading_view);
}","@Override protected void init(){
  super.init();
  titleLay=findViewById(R.id.title_lay);
  leftBtn=(Button)findViewById(R.id.title_left_btn);
  titleTxt=(TextView)findViewById(R.id.title_txt);
  rightBtn=(Button)findViewById(R.id.title_right_btn);
  mLoadingView=(LoadingView)findViewById(R.id.loading_view);
  if (mLoadingView != null) {
    mLoadingView.register(this);
  }
}"
41256,"/** 
 * setContentView之后调用, 进行view的初始化等操作
 */
private void afterSetContentView(View v){
  mView=v;
  init(v);
}","/** 
 * setContentView之后调用, 进行view的初始化等操作
 */
private void afterSetContentView(View v){
  mView=v;
  init(v);
  if (mLoadingView != null) {
    mLoadingView.register(this);
  }
}"
41257,"private void init(){
  setOnClickListener(this);
  eventBus=new EventBus();
  eventBus.register(getContext());
}","private void init(){
  setOnClickListener(this);
  eventBus=new EventBus();
}"
41258,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  eventBus.unregister(getContext());
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  if (mSubcriber != null) {
    eventBus.unregister(mSubcriber);
  }
}"
41259,"/** 
 * EventBus订阅者事件通知的函数, UI线程
 * @param msg
 */
public void onEventMainThread(Message msg){
  onResponse(msg);
}","/** 
 * EventBus订阅者事件通知的函数, UI线程
 * @param msg
 */
public void onEventMainThread(Message msg){
  if (!isDetached() && !isRemoving()) {
    onResponse(msg);
  }
}"
41260,"/** 
 * EventBus订阅者事件通知的函数, UI线程
 * @param msg
 */
public void onEventMainThread(Message msg){
  onResponse(msg);
}","/** 
 * EventBus订阅者事件通知的函数, UI线程
 * @param msg
 */
public void onEventMainThread(Message msg){
  if (!isDestroyed && !isFinishing()) {
    onResponse(msg);
  }
}"
41261,"/** 
 * EventBus订阅者事件通知的函数, UI线程
 * @param msg
 */
public void onEventMainThread(Message msg){
  if (!isDetached() && !isRemoving()) {
    onResponse(msg);
  }
}","/** 
 * EventBus订阅者事件通知的函数, UI线程
 * @param msg
 */
public void onEventMainThread(Message msg){
  if (isAdded() && !isDetached() && !isRemoving()) {
    onResponse(msg);
  }
}"
41262,"/** 
 * 事件注解
 * @param classObj
 * @param viewFinder
 * @throws Exception 
 */
private static void injectListeners(Object classObj,ViewFinder viewFinder) throws Exception {
  Class<?> clazz=classObj.getClass();
  java.lang.reflect.Method[] methods=clazz.getDeclaredMethods();
  for (  java.lang.reflect.Method method : methods) {
    if (method.isAnnotationPresent(OnClick.class)) {
      setOnClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnLongClick.class)) {
      setOnLongClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnItemClick.class)) {
      setOnItemClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnItemLongClick.class)) {
      setOnItemLongClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnCheckedChanged.class)) {
      setOnCheckedChangeListener(classObj,viewFinder,method);
    }
  }
}","/** 
 * 事件注解
 * @param classObj
 * @param viewFinder
 * @throws Exception 
 */
private static void injectListeners(Object classObj,ViewFinder viewFinder) throws Exception {
  Class<?> clazz=classObj.getClass();
  java.lang.reflect.Method[] methods=clazz.getDeclaredMethods();
  for (  java.lang.reflect.Method method : methods) {
    try {
      if (method.isAnnotationPresent(OnClick.class)) {
        setOnClickListener(classObj,viewFinder,method);
      }
 else       if (method.isAnnotationPresent(OnLongClick.class)) {
        setOnLongClickListener(classObj,viewFinder,method);
      }
 else       if (method.isAnnotationPresent(OnItemClick.class)) {
        setOnItemClickListener(classObj,viewFinder,method);
      }
 else       if (method.isAnnotationPresent(OnItemLongClick.class)) {
        setOnItemLongClickListener(classObj,viewFinder,method);
      }
 else       if (method.isAnnotationPresent(OnCheckedChanged.class)) {
        setOnCheckedChangeListener(classObj,viewFinder,method);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}"
41263,"/** 
 * View注解
 * @param classObj
 * @param viewFinder
 * @throws IllegalArgumentException 
 * @throws IllegalAccessException 
 */
private static void injectViews(Object classObj,ViewFinder viewFinder) throws IllegalAccessException, IllegalArgumentException {
  Class<?> clazz=classObj.getClass();
  Field[] fields=clazz.getDeclaredFields();
  for (  Field field : fields) {
    if (field.isAnnotationPresent(ViewInject.class)) {
      ViewInject viewInject=field.getAnnotation(ViewInject.class);
      int id=viewInject.value();
      if (id > 0) {
        field.setAccessible(true);
        View v=viewFinder.findViewById(id);
        if (v != null) {
          field.set(classObj,v);
        }
      }
    }
  }
}","/** 
 * View注解
 * @param classObj
 * @param viewFinder
 * @throws IllegalArgumentException 
 * @throws IllegalAccessException 
 */
private static void injectViews(Object classObj,ViewFinder viewFinder) throws IllegalAccessException, IllegalArgumentException {
  Class<?> clazz=classObj.getClass();
  Field[] fields=clazz.getDeclaredFields();
  for (  Field field : fields) {
    if (field.isAnnotationPresent(ViewInject.class)) {
      ViewInject viewInject=field.getAnnotation(ViewInject.class);
      int id=viewInject.value();
      if (id > 0) {
        field.setAccessible(true);
        View v=viewFinder.findViewById(id);
        if (v != null) {
          try {
            field.set(classObj,v);
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
}"
41264,"/** 
 * 获得磁盘缓存目录 [PS：应用卸载后会被自动删除]
 * @param context
 * @return
 */
public File getDiskCacheDir(Context context){
  String cachePath;
  if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageRemovable()) {
    cachePath=context.getExternalCacheDir().getPath();
  }
 else {
    cachePath=context.getFilesDir().getPath();
  }
  return new File(cachePath);
}","/** 
 * 获得磁盘缓存目录 [PS：应用卸载后会被自动删除]
 * @param context
 * @param uniqueName
 * @return
 */
public File getDiskCacheDir(Context context,String uniqueName){
  String cachePath;
  if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageRemovable()) {
    cachePath=context.getExternalCacheDir().getPath();
  }
 else {
    cachePath=context.getFilesDir().getPath();
  }
  return new File(cachePath + File.separator + uniqueName);
}"
41265,"public BasicAdapter(Context context,List<T> data,Map<Integer,Integer> itemTypeResourceMap){
  mLayoutInflater=LayoutInflater.from(context);
  mData=data;
  mItemTypeResourceMap=itemTypeResourceMap;
}","public BasicAdapter(Context context,List<T> data,Map<Integer,Integer> itemTypeResourceMap){
  mLayoutInflater=LayoutInflater.from(context);
  mData=data;
  mItemTypeResourceMap.putAll(itemTypeResourceMap);
}"
41266,"/** 
 * setContentView之后调用, 进行view的初始化等操作
 */
private void afterSetContentView(){
  init(mView);
  if (mLoadingView != null) {
    mLoadingView.register(this);
  }
}","/** 
 * setContentView之后调用, 进行view的初始化等操作
 */
private void afterSetContentView(View view){
  mView=view;
  init(view);
  if (mLoadingView != null) {
    mLoadingView.register(this);
  }
}"
41267,"/** 
 * 从资源加载View
 * @param inflater
 * @param container
 * @param resourceId
 * @param fragment
 * @return
 */
protected View inflate(LayoutInflater inflater,ViewGroup container,int resourceId,Fragment fragment){
  mView=inflater.inflate(resourceId,container,false);
  mFragment=fragment;
  return mView;
}","/** 
 * 从资源加载View
 * @param inflater
 * @param container
 * @param resourceId
 * @param fragment
 * @return
 */
protected View inflate(LayoutInflater inflater,ViewGroup container,int resourceId,Fragment fragment){
  View view=inflater.inflate(resourceId,container,false);
  interceptTouchEvent(view,true);
  ViewUtils.inject(fragment,view);
  afterSetContentView(view);
  return view;
}"
41268,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  interceptTouchEvent(mView,true);
  ViewUtils.inject(mFragment,mView);
  afterSetContentView();
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
}"
41269,"/** 
 * 单击事件绑定
 * @param classObj
 * @param contentView
 * @param method
 */
private static void setOnClickListener(Object classObj,View contentView,Method method){
  OnClick onclick=method.getAnnotation(OnClick.class);
  int[] ids=onclick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=contentView.findViewById(id);
      view.setOnClickListener(new EventListener(classObj,method.getName()));
    }
  }
}","/** 
 * 单击事件绑定
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnClick onclick=method.getAnnotation(OnClick.class);
  int[] ids=onclick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      view.setOnClickListener(new EventListener(classObj,method.getName()));
    }
  }
}"
41270,"/** 
 * 事件注解
 * @param classObj
 * @param contentView
 * @throws Exception 
 */
private static void injectListeners(Object classObj,View contentView) throws Exception {
  Class<?> clazz=classObj.getClass();
  java.lang.reflect.Method[] methods=clazz.getDeclaredMethods();
  for (  java.lang.reflect.Method method : methods) {
    if (method.isAnnotationPresent(OnClick.class)) {
      setOnClickListener(classObj,contentView,method);
    }
 else     if (method.isAnnotationPresent(OnLongClick.class)) {
      setOnLongClickListener(classObj,contentView,method);
    }
 else     if (method.isAnnotationPresent(OnItemClick.class)) {
      setOnItemClickListener(classObj,contentView,method);
    }
 else     if (method.isAnnotationPresent(OnItemLongClick.class)) {
      setOnItemLongClickListener(classObj,contentView,method);
    }
  }
}","/** 
 * 事件注解
 * @param classObj
 * @param viewFinder
 * @throws Exception 
 */
private static void injectListeners(Object classObj,ViewFinder viewFinder) throws Exception {
  Class<?> clazz=classObj.getClass();
  java.lang.reflect.Method[] methods=clazz.getDeclaredMethods();
  for (  java.lang.reflect.Method method : methods) {
    if (method.isAnnotationPresent(OnClick.class)) {
      setOnClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnLongClick.class)) {
      setOnLongClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnItemClick.class)) {
      setOnItemClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnItemLongClick.class)) {
      setOnItemLongClickListener(classObj,viewFinder,method);
    }
  }
}"
41271,"/** 
 * Item单击事件
 * @param classObj
 * @param contentView
 * @param method
 */
private static void setOnItemClickListener(Object classObj,View contentView,Method method){
  OnItemClick onItemClick=method.getAnnotation(OnItemClick.class);
  int[] ids=onItemClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=contentView.findViewById(id);
      if (view instanceof AbsListView) {
        ((AbsListView)view).setOnItemClickListener(new EventListener(classObj,method.getName()));
      }
    }
  }
}","/** 
 * Item单击事件
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnItemClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnItemClick onItemClick=method.getAnnotation(OnItemClick.class);
  int[] ids=onItemClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      if (view instanceof AbsListView) {
        ((AbsListView)view).setOnItemClickListener(new EventListener(classObj,method.getName()));
      }
    }
  }
}"
41272,"/** 
 * 长按事件绑定
 * @param classObj
 * @param contentView
 * @param method
 */
private static void setOnLongClickListener(Object classObj,View contentView,Method method){
  OnLongClick onLongClick=method.getAnnotation(OnLongClick.class);
  int[] ids=onLongClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=contentView.findViewById(id);
      view.setOnLongClickListener(new EventListener(classObj,method.getName()));
    }
  }
}","/** 
 * 长按事件绑定
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnLongClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnLongClick onLongClick=method.getAnnotation(OnLongClick.class);
  int[] ids=onLongClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      view.setOnLongClickListener(new EventListener(classObj,method.getName()));
    }
  }
}"
41273,"/** 
 * 注解View、事件
 * @param classObj class对象
 * @param contentView 父View对象
 */
public static void inject(Object classObj,View contentView){
  try {
    injectViews(classObj,contentView);
    injectListeners(classObj,contentView);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private static void inject(Object classObj,ViewFinder finder){
  try {
    injectViews(classObj,finder);
    injectListeners(classObj,finder);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
41274,"/** 
 * View注解
 * @param classObj
 * @param contentView
 * @throws IllegalArgumentException 
 * @throws IllegalAccessException 
 */
private static void injectViews(Object classObj,View contentView) throws IllegalAccessException, IllegalArgumentException {
  Class<?> clazz=classObj.getClass();
  Field[] fields=clazz.getDeclaredFields();
  for (  Field field : fields) {
    if (field.isAnnotationPresent(ViewInject.class)) {
      ViewInject viewInject=field.getAnnotation(ViewInject.class);
      int id=viewInject.value();
      if (id > 0) {
        field.setAccessible(true);
        field.set(classObj,contentView.findViewById(id));
      }
    }
  }
}","/** 
 * View注解
 * @param classObj
 * @param viewFinder
 * @throws IllegalArgumentException 
 * @throws IllegalAccessException 
 */
private static void injectViews(Object classObj,ViewFinder viewFinder) throws IllegalAccessException, IllegalArgumentException {
  Class<?> clazz=classObj.getClass();
  Field[] fields=clazz.getDeclaredFields();
  for (  Field field : fields) {
    if (field.isAnnotationPresent(ViewInject.class)) {
      ViewInject viewInject=field.getAnnotation(ViewInject.class);
      int id=viewInject.value();
      if (id > 0) {
        field.setAccessible(true);
        field.set(classObj,viewFinder.findViewById(id));
      }
    }
  }
}"
41275,"/** 
 * Item长按事件
 * @param classObj
 * @param contentView
 * @param method
 */
private static void setOnItemLongClickListener(Object classObj,View contentView,Method method){
  OnItemLongClick onItemLongClick=method.getAnnotation(OnItemLongClick.class);
  int[] ids=onItemLongClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=contentView.findViewById(id);
      if (view instanceof AbsListView) {
        ((AbsListView)view).setOnItemLongClickListener(new EventListener(classObj,method.getName()));
      }
    }
  }
}","/** 
 * Item长按事件
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnItemLongClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnItemLongClick onItemLongClick=method.getAnnotation(OnItemLongClick.class);
  int[] ids=onItemLongClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      if (view instanceof AbsListView) {
        ((AbsListView)view).setOnItemLongClickListener(new EventListener(classObj,method.getName()));
      }
    }
  }
}"
41276,"/** 
 * 单击事件绑定
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnClick onclick=method.getAnnotation(OnClick.class);
  int[] ids=onclick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      view.setOnClickListener(new EventListener(classObj,method.getName()));
    }
  }
}","/** 
 * 单击事件绑定
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnClick onclick=method.getAnnotation(OnClick.class);
  int[] ids=onclick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      if (view != null) {
        view.setOnClickListener(new EventListener(classObj,method.getName()));
      }
    }
  }
}"
41277,"/** 
 * 事件注解
 * @param classObj
 * @param viewFinder
 * @throws Exception 
 */
private static void injectListeners(Object classObj,ViewFinder viewFinder) throws Exception {
  Class<?> clazz=classObj.getClass();
  java.lang.reflect.Method[] methods=clazz.getDeclaredMethods();
  for (  java.lang.reflect.Method method : methods) {
    if (method.isAnnotationPresent(OnClick.class)) {
      setOnClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnLongClick.class)) {
      setOnLongClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnItemClick.class)) {
      setOnItemClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnItemLongClick.class)) {
      setOnItemLongClickListener(classObj,viewFinder,method);
    }
  }
}","/** 
 * 事件注解
 * @param classObj
 * @param viewFinder
 * @throws Exception 
 */
private static void injectListeners(Object classObj,ViewFinder viewFinder) throws Exception {
  Class<?> clazz=classObj.getClass();
  java.lang.reflect.Method[] methods=clazz.getDeclaredMethods();
  for (  java.lang.reflect.Method method : methods) {
    if (method.isAnnotationPresent(OnClick.class)) {
      setOnClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnLongClick.class)) {
      setOnLongClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnItemClick.class)) {
      setOnItemClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnItemLongClick.class)) {
      setOnItemLongClickListener(classObj,viewFinder,method);
    }
 else     if (method.isAnnotationPresent(OnCheckedChanged.class)) {
      setOnCheckedChangeListener(classObj,viewFinder,method);
    }
  }
}"
41278,"/** 
 * Item单击事件
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnItemClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnItemClick onItemClick=method.getAnnotation(OnItemClick.class);
  int[] ids=onItemClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      if (view instanceof AbsListView) {
        ((AbsListView)view).setOnItemClickListener(new EventListener(classObj,method.getName()));
      }
    }
  }
}","/** 
 * Item单击事件
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnItemClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnItemClick onItemClick=method.getAnnotation(OnItemClick.class);
  int[] ids=onItemClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      if (view != null && view instanceof AbsListView) {
        ((AbsListView)view).setOnItemClickListener(new EventListener(classObj,method.getName()));
      }
    }
  }
}"
41279,"/** 
 * 长按事件绑定
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnLongClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnLongClick onLongClick=method.getAnnotation(OnLongClick.class);
  int[] ids=onLongClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      view.setOnLongClickListener(new EventListener(classObj,method.getName()));
    }
  }
}","/** 
 * 长按事件绑定
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnLongClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnLongClick onLongClick=method.getAnnotation(OnLongClick.class);
  int[] ids=onLongClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      if (view != null) {
        view.setOnLongClickListener(new EventListener(classObj,method.getName()));
      }
    }
  }
}"
41280,"/** 
 * View注解
 * @param classObj
 * @param viewFinder
 * @throws IllegalArgumentException 
 * @throws IllegalAccessException 
 */
private static void injectViews(Object classObj,ViewFinder viewFinder) throws IllegalAccessException, IllegalArgumentException {
  Class<?> clazz=classObj.getClass();
  Field[] fields=clazz.getDeclaredFields();
  for (  Field field : fields) {
    if (field.isAnnotationPresent(ViewInject.class)) {
      ViewInject viewInject=field.getAnnotation(ViewInject.class);
      int id=viewInject.value();
      if (id > 0) {
        field.setAccessible(true);
        field.set(classObj,viewFinder.findViewById(id));
      }
    }
  }
}","/** 
 * View注解
 * @param classObj
 * @param viewFinder
 * @throws IllegalArgumentException 
 * @throws IllegalAccessException 
 */
private static void injectViews(Object classObj,ViewFinder viewFinder) throws IllegalAccessException, IllegalArgumentException {
  Class<?> clazz=classObj.getClass();
  Field[] fields=clazz.getDeclaredFields();
  for (  Field field : fields) {
    if (field.isAnnotationPresent(ViewInject.class)) {
      ViewInject viewInject=field.getAnnotation(ViewInject.class);
      int id=viewInject.value();
      if (id > 0) {
        field.setAccessible(true);
        View v=viewFinder.findViewById(id);
        if (v != null) {
          field.set(classObj,v);
        }
      }
    }
  }
}"
41281,"/** 
 * Item长按事件
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnItemLongClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnItemLongClick onItemLongClick=method.getAnnotation(OnItemLongClick.class);
  int[] ids=onItemLongClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      if (view instanceof AbsListView) {
        ((AbsListView)view).setOnItemLongClickListener(new EventListener(classObj,method.getName()));
      }
    }
  }
}","/** 
 * Item长按事件
 * @param classObj
 * @param viewFinder
 * @param method
 */
private static void setOnItemLongClickListener(Object classObj,ViewFinder viewFinder,Method method){
  OnItemLongClick onItemLongClick=method.getAnnotation(OnItemLongClick.class);
  int[] ids=onItemLongClick.value();
  if (ids != null) {
    for (    int id : ids) {
      View view=viewFinder.findViewById(id);
      if (view != null && view instanceof AbsListView) {
        ((AbsListView)view).setOnItemLongClickListener(new EventListener(classObj,method.getName()));
      }
    }
  }
}"
41282,"private void executeAuth(final CallbackContext callbackContext){
  Log.d(LOGTAG,""String_Node_Str"");
  authCallbackContext=callbackContext;
  cordova.getActivity().runOnUiThread(new Runnable(){
    @Override public void run(){
      gameHelper.beginUserInitiatedSignIn();
      callbackContext.success();
    }
  }
);
}","private void executeAuth(final CallbackContext callbackContext){
  Log.d(LOGTAG,""String_Node_Str"");
  authCallbackContext=callbackContext;
  cordova.getActivity().runOnUiThread(new Runnable(){
    @Override public void run(){
      gameHelper.beginUserInitiatedSignIn();
    }
  }
);
}"
41283,"@Override public void onSignInSucceeded(){
  authCallbackContext.error(""String_Node_Str"");
}","@Override public void onSignInSucceeded(){
  authCallbackContext.success(""String_Node_Str"");
}"
41284,"@DataBoundSetter public void setWorkingDir(String workingDir){
  this.workingDir=workingDir;
}","@DataBoundSetter public void setWorkingDir(String workingDir){
  this.workingDir=Util.fixEmpty(workingDir);
}"
41285,"/** 
 * Create a Pod object from a PodTemplate
 */
public Pod build(){
  Map<String,Volume> volumes=new HashMap<>();
  Map<String,VolumeMount> volumeMounts=new HashMap<>();
  int i=0;
  for (  final PodVolume volume : template.getVolumes()) {
    final String volumeName=""String_Node_Str"" + i;
    final String mountPath=substituteEnv(Paths.get(volume.getMountPath()).normalize().toString());
    if (!volumeMounts.containsKey(mountPath)) {
      volumeMounts.put(mountPath,new VolumeMount(mountPath,volumeName,false,null));
      volumes.put(volumeName,volume.buildVolume(volumeName));
      i++;
    }
  }
  if (template.getWorkspaceVolume() != null) {
    volumes.put(WORKSPACE_VOLUME_NAME,template.getWorkspaceVolume().buildVolume(WORKSPACE_VOLUME_NAME));
  }
 else {
    volumes.put(WORKSPACE_VOLUME_NAME,new VolumeBuilder().withName(WORKSPACE_VOLUME_NAME).withNewEmptyDir().endEmptyDir().build());
  }
  Map<String,Container> containers=new HashMap<>();
  for (  ContainerTemplate containerTemplate : template.getContainers()) {
    containers.put(containerTemplate.getName(),createContainer(containerTemplate,template.getEnvVars(),volumeMounts.values()));
  }
  MetadataNested<PodBuilder> metadataBuilder=new PodBuilder().withNewMetadata();
  if (slave != null) {
    metadataBuilder.withName(substituteEnv(slave.getNodeName()));
  }
  Map<String,String> labels=new HashMap<>();
  if (slave != null) {
    labels.putAll(slave.getKubernetesCloud().getLabels());
  }
  labels.putAll(template.getLabelsMap());
  if (!labels.isEmpty()) {
    metadataBuilder.withLabels(labels);
  }
  Map<String,String> annotations=getAnnotationsMap(template.getAnnotations());
  if (!annotations.isEmpty()) {
    metadataBuilder.withAnnotations(annotations);
  }
  SpecNested<PodBuilder> builder=metadataBuilder.endMetadata().withNewSpec();
  if (template.getActiveDeadlineSeconds() > 0) {
    builder=builder.withActiveDeadlineSeconds(Long.valueOf(template.getActiveDeadlineSeconds()));
  }
  if (!volumes.isEmpty()) {
    builder.withVolumes(volumes.values().toArray(new Volume[volumes.size()]));
  }
  if (template.getServiceAccount() != null) {
    builder.withServiceAccount(substituteEnv(template.getServiceAccount()));
  }
  List<LocalObjectReference> imagePullSecrets=template.getImagePullSecrets().stream().map((x) -> x.toLocalObjectReference()).collect(Collectors.toList());
  if (!imagePullSecrets.isEmpty()) {
    builder.withImagePullSecrets(imagePullSecrets);
  }
  Map<String,String> nodeSelector=getNodeSelectorMap(template.getNodeSelector());
  if (!nodeSelector.isEmpty()) {
    builder.withNodeSelector(nodeSelector);
  }
  builder.withContainers(containers.values().toArray(new Container[containers.size()]));
  Pod pod=builder.endSpec().build();
  String yaml=template.getYaml();
  if (!StringUtils.isBlank(yaml)) {
    Pod podFromYaml=parseFromYaml(yaml);
    pod=combine(podFromYaml,pod);
  }
  if (StringUtils.isBlank(pod.getSpec().getRestartPolicy())) {
    pod.getSpec().setRestartPolicy(""String_Node_Str"");
  }
  Optional<Container> jnlpOpt=pod.getSpec().getContainers().stream().filter(c -> JNLP_NAME.equals(c.getName())).findFirst();
  Container jnlp=jnlpOpt.orElse(new ContainerBuilder().withName(JNLP_NAME).build());
  if (!jnlpOpt.isPresent()) {
    pod.getSpec().getContainers().add(jnlp);
  }
  if (StringUtils.isBlank(jnlp.getImage())) {
    jnlp.setImage(DEFAULT_JNLP_IMAGE);
  }
  Map<String,EnvVar> envVars=defaultEnvVars(slave,jnlp.getWorkingDir() != null ? jnlp.getWorkingDir() : ContainerTemplate.DEFAULT_WORKING_DIR,template.getEnvVars());
  envVars.putAll(jnlp.getEnv().stream().collect(Collectors.toMap(EnvVar::getName,Function.identity())));
  jnlp.setEnv(new ArrayList<>(envVars.values()));
  if (pod.getSpec().getVolumes().stream().noneMatch(v -> WORKSPACE_VOLUME_NAME.equals(v.getName()))) {
    pod.getSpec().getVolumes().add(new VolumeBuilder().withName(WORKSPACE_VOLUME_NAME).withNewEmptyDir().endEmptyDir().build());
  }
  pod.getSpec().getContainers().stream().filter(c -> c.getVolumeMounts().stream().noneMatch(vm -> vm.getMountPath().equals(c.getWorkingDir() != null ? c.getWorkingDir() : ContainerTemplate.DEFAULT_WORKING_DIR))).forEach(c -> c.getVolumeMounts().add(getDefaultVolumeMount(c.getWorkingDir())));
  LOGGER.log(Level.FINE,""String_Node_Str"",pod);
  return pod;
}","/** 
 * Create a Pod object from a PodTemplate
 */
public Pod build(){
  Map<String,Volume> volumes=new HashMap<>();
  Map<String,VolumeMount> volumeMounts=new HashMap<>();
  int i=0;
  for (  final PodVolume volume : template.getVolumes()) {
    final String volumeName=""String_Node_Str"" + i;
    final String mountPath=substituteEnv(Paths.get(volume.getMountPath()).normalize().toString());
    if (!volumeMounts.containsKey(mountPath)) {
      volumeMounts.put(mountPath,new VolumeMount(mountPath,volumeName,false,null));
      volumes.put(volumeName,volume.buildVolume(volumeName));
      i++;
    }
  }
  if (template.getWorkspaceVolume() != null) {
    LOGGER.log(Level.FINE,""String_Node_Str"",template.getWorkspaceVolume().toString());
    volumes.put(WORKSPACE_VOLUME_NAME,template.getWorkspaceVolume().buildVolume(WORKSPACE_VOLUME_NAME));
  }
 else {
    LOGGER.log(Level.FINE,""String_Node_Str"");
    volumes.put(WORKSPACE_VOLUME_NAME,new VolumeBuilder().withName(WORKSPACE_VOLUME_NAME).withNewEmptyDir().endEmptyDir().build());
  }
  Map<String,Container> containers=new HashMap<>();
  for (  ContainerTemplate containerTemplate : template.getContainers()) {
    containers.put(containerTemplate.getName(),createContainer(containerTemplate,template.getEnvVars(),volumeMounts.values()));
  }
  MetadataNested<PodBuilder> metadataBuilder=new PodBuilder().withNewMetadata();
  if (slave != null) {
    metadataBuilder.withName(substituteEnv(slave.getNodeName()));
  }
  Map<String,String> labels=new HashMap<>();
  if (slave != null) {
    labels.putAll(slave.getKubernetesCloud().getLabels());
  }
  labels.putAll(template.getLabelsMap());
  if (!labels.isEmpty()) {
    metadataBuilder.withLabels(labels);
  }
  Map<String,String> annotations=getAnnotationsMap(template.getAnnotations());
  if (!annotations.isEmpty()) {
    metadataBuilder.withAnnotations(annotations);
  }
  SpecNested<PodBuilder> builder=metadataBuilder.endMetadata().withNewSpec();
  if (template.getActiveDeadlineSeconds() > 0) {
    builder=builder.withActiveDeadlineSeconds(Long.valueOf(template.getActiveDeadlineSeconds()));
  }
  if (!volumes.isEmpty()) {
    builder.withVolumes(volumes.values().toArray(new Volume[volumes.size()]));
  }
  if (template.getServiceAccount() != null) {
    builder.withServiceAccount(substituteEnv(template.getServiceAccount()));
  }
  List<LocalObjectReference> imagePullSecrets=template.getImagePullSecrets().stream().map((x) -> x.toLocalObjectReference()).collect(Collectors.toList());
  if (!imagePullSecrets.isEmpty()) {
    builder.withImagePullSecrets(imagePullSecrets);
  }
  Map<String,String> nodeSelector=getNodeSelectorMap(template.getNodeSelector());
  if (!nodeSelector.isEmpty()) {
    builder.withNodeSelector(nodeSelector);
  }
  builder.withContainers(containers.values().toArray(new Container[containers.size()]));
  Pod pod=builder.endSpec().build();
  String yaml=template.getYaml();
  if (!StringUtils.isBlank(yaml)) {
    Pod podFromYaml=parseFromYaml(yaml);
    pod=combine(podFromYaml,pod);
  }
  if (StringUtils.isBlank(pod.getSpec().getRestartPolicy())) {
    pod.getSpec().setRestartPolicy(""String_Node_Str"");
  }
  Optional<Container> jnlpOpt=pod.getSpec().getContainers().stream().filter(c -> JNLP_NAME.equals(c.getName())).findFirst();
  Container jnlp=jnlpOpt.orElse(new ContainerBuilder().withName(JNLP_NAME).build());
  if (!jnlpOpt.isPresent()) {
    pod.getSpec().getContainers().add(jnlp);
  }
  if (StringUtils.isBlank(jnlp.getImage())) {
    jnlp.setImage(DEFAULT_JNLP_IMAGE);
  }
  Map<String,EnvVar> envVars=defaultEnvVars(slave,jnlp.getWorkingDir() != null ? jnlp.getWorkingDir() : ContainerTemplate.DEFAULT_WORKING_DIR,template.getEnvVars());
  envVars.putAll(jnlp.getEnv().stream().collect(Collectors.toMap(EnvVar::getName,Function.identity())));
  jnlp.setEnv(new ArrayList<>(envVars.values()));
  if (pod.getSpec().getVolumes().stream().noneMatch(v -> WORKSPACE_VOLUME_NAME.equals(v.getName()))) {
    pod.getSpec().getVolumes().add(new VolumeBuilder().withName(WORKSPACE_VOLUME_NAME).withNewEmptyDir().endEmptyDir().build());
  }
  pod.getSpec().getContainers().stream().filter(c -> c.getVolumeMounts().stream().noneMatch(vm -> vm.getMountPath().equals(c.getWorkingDir() != null ? c.getWorkingDir() : ContainerTemplate.DEFAULT_WORKING_DIR))).forEach(c -> c.getVolumeMounts().add(getDefaultVolumeMount(c.getWorkingDir())));
  LOGGER.log(Level.FINE,""String_Node_Str"",pod);
  return pod;
}"
41286,"private synchronized int readPidFromPidFile(String... commands) throws IOException, InterruptedException {
  int pid=-1;
  FilePath pidFile=ws.child(readPidFile(commands));
  for (int w=0; w < 10 && !pidFile.exists(); w++) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      Thread.interrupted();
      break;
    }
  }
  if (pidFile.exists()) {
    try {
      pid=Integer.parseInt(pidFile.readToString().trim());
    }
 catch (    NumberFormatException x) {
      throw new IOException(""String_Node_Str"" + pidFile + ""String_Node_Str""+ x,x);
    }
  }
  return pid;
}","private synchronized int readPidFromPidFile(String... commands) throws IOException, InterruptedException {
  int pid=-1;
  FilePath pidFile=ws.child(readPidFile(commands));
  for (int w=0; w < 10 && !pidFile.exists(); w++) {
    try {
      wait(1000);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
  if (pidFile.exists()) {
    try {
      pid=Integer.parseInt(pidFile.readToString().trim());
    }
 catch (    NumberFormatException x) {
      throw new IOException(""String_Node_Str"" + pidFile + ""String_Node_Str""+ x,x);
    }
  }
  return pid;
}"
41287,"@Override protected void _terminate(TaskListener listener) throws IOException, InterruptedException {
  LOGGER.log(Level.INFO,""String_Node_Str"",name);
  Computer computer=toComputer();
  if (computer == null) {
    String msg=String.format(""String_Node_Str"",name);
    LOGGER.log(Level.SEVERE,msg);
    listener.fatalError(msg);
    return;
  }
  OfflineCause offlineCause=OfflineCause.create(new Localizable(HOLDER,""String_Node_Str""));
  computer.disconnect(offlineCause);
  if (getCloudName() == null) {
    String msg=String.format(""String_Node_Str"",name);
    LOGGER.log(Level.SEVERE,msg);
    listener.fatalError(msg);
    return;
  }
  KubernetesCloud cloud;
  try {
    cloud=getKubernetesCloud();
  }
 catch (  IllegalStateException e) {
    e.printStackTrace(listener.fatalError(""String_Node_Str""));
    LOGGER.log(Level.SEVERE,String.format(""String_Node_Str"",name));
    return;
  }
  KubernetesClient client;
  try {
    client=cloud.connect();
  }
 catch (  UnrecoverableKeyException|CertificateEncodingException|NoSuchAlgorithmException|KeyStoreException e) {
    String msg=String.format(""String_Node_Str"",getCloudName());
    e.printStackTrace(listener.fatalError(msg));
    return;
  }
  String actualNamespace=getNamespace() == null ? client.getNamespace() : getNamespace();
  try {
    Boolean deleted=client.pods().inNamespace(actualNamespace).withName(name).delete();
    if (!Boolean.TRUE.equals(deleted)) {
      String msg=String.format(""String_Node_Str"",actualNamespace,name);
      LOGGER.log(Level.WARNING,msg);
      listener.error(msg);
      return;
    }
  }
 catch (  KubernetesClientException e) {
    String msg=String.format(""String_Node_Str"",actualNamespace,name,e.getMessage());
    LOGGER.log(Level.WARNING,msg,e);
    listener.error(msg);
    return;
  }
  String msg=String.format(""String_Node_Str"",actualNamespace,name);
  LOGGER.log(Level.INFO,msg);
  listener.getLogger().println(msg);
  LOGGER.log(Level.INFO,""String_Node_Str"",name);
}","@Override protected void _terminate(TaskListener listener) throws IOException, InterruptedException {
  LOGGER.log(Level.INFO,""String_Node_Str"",name);
  Computer computer=toComputer();
  if (computer == null) {
    String msg=String.format(""String_Node_Str"",name);
    LOGGER.log(Level.SEVERE,msg);
    listener.fatalError(msg);
    return;
  }
  OfflineCause offlineCause=OfflineCause.create(new Localizable(HOLDER,""String_Node_Str""));
  Future<?> disconnected=computer.disconnect(offlineCause);
  try {
    disconnected.get(DISCONNECTION_TIMEOUT,TimeUnit.SECONDS);
  }
 catch (  Exception e) {
    String msg=String.format(""String_Node_Str"",name,e.getMessage());
    LOGGER.log(Level.INFO,msg,e);
  }
  if (getCloudName() == null) {
    String msg=String.format(""String_Node_Str"",name);
    LOGGER.log(Level.SEVERE,msg);
    listener.fatalError(msg);
    return;
  }
  KubernetesCloud cloud;
  try {
    cloud=getKubernetesCloud();
  }
 catch (  IllegalStateException e) {
    e.printStackTrace(listener.fatalError(""String_Node_Str""));
    LOGGER.log(Level.SEVERE,String.format(""String_Node_Str"",name));
    return;
  }
  KubernetesClient client;
  try {
    client=cloud.connect();
  }
 catch (  UnrecoverableKeyException|CertificateEncodingException|NoSuchAlgorithmException|KeyStoreException e) {
    String msg=String.format(""String_Node_Str"",getCloudName());
    e.printStackTrace(listener.fatalError(msg));
    return;
  }
  String actualNamespace=getNamespace() == null ? client.getNamespace() : getNamespace();
  try {
    Boolean deleted=client.pods().inNamespace(actualNamespace).withName(name).delete();
    if (!Boolean.TRUE.equals(deleted)) {
      String msg=String.format(""String_Node_Str"",actualNamespace,name);
      LOGGER.log(Level.WARNING,msg);
      listener.error(msg);
      return;
    }
  }
 catch (  KubernetesClientException e) {
    String msg=String.format(""String_Node_Str"",actualNamespace,name,e.getMessage());
    LOGGER.log(Level.WARNING,msg,e);
    listener.error(msg);
    return;
  }
  String msg=String.format(""String_Node_Str"",actualNamespace,name);
  LOGGER.log(Level.INFO,msg);
  listener.getLogger().println(msg);
  LOGGER.log(Level.INFO,""String_Node_Str"",name);
}"
41288,"@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      boolean quiet=starter.quiet();
      FilePath pwd=starter.pwd();
      String[] commands=getCommands(starter);
      return doLaunch(quiet,pwd,commands);
    }
    private Proc doLaunch(    boolean quiet,    FilePath pwd,    String... commands) throws IOException {
      waitUntilContainerIsReady();
      final CountDownLatch started=new CountDownLatch(1);
      final CountDownLatch finished=new CountDownLatch(1);
      final AtomicBoolean alive=new AtomicBoolean(false);
      PrintStream printStream=launcher.getListener().getLogger();
      OutputStream stream=printStream;
      if (quiet) {
        stream=new NullOutputStream();
        printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
      }
      ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
      stream=new TeeOutputStream(exitCodeOutputStream,stream);
      String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
      LOGGER.log(Level.FINEST,msg);
      printStream.println(msg);
      Execable<String,ExecWatch> execable=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        Throwable t,        Response response){
          alive.set(false);
          t.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
      }
);
      ExecWatch watch;
      try {
        watch=execable.exec();
      }
 catch (      KubernetesClientException e) {
        if (e.getCause() instanceof InterruptedException) {
          throw new IOException(""String_Node_Str"",e);
        }
 else {
          throw e;
        }
      }
      try {
        started.await();
      }
 catch (      InterruptedException e) {
        closeWatch(watch);
        throw new IOException(""String_Node_Str"",e);
      }
      try {
        if (pwd != null) {
          watch.getInput().write(String.format(""String_Node_Str"",pwd,NEWLINE).getBytes(StandardCharsets.UTF_8));
        }
        if (environmentExpander != null) {
          EnvVars envVars=new EnvVars();
          environmentExpander.expand(envVars);
          this.setupEnvironmentVariable(envVars,watch);
        }
        doExec(watch,printStream,commands);
        ContainerExecProc proc=new ContainerExecProc(watch,alive,finished,exitCodeOutputStream::getExitCode);
        closables.add(proc);
        return proc;
      }
 catch (      InterruptedException ie) {
        throw new InterruptedIOException(ie.getMessage());
      }
catch (      Exception e) {
        closeWatch(watch);
        throw e;
      }
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      String cookie=modelEnvVars.get(COOKIE_VAR);
      int exitCode=doLaunch(true,null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + COOKIE_VAR + ""String_Node_Str""+ cookie+ ""String_Node_Str"").join();
      getListener().getLogger().println(""String_Node_Str"" + exitCode);
    }
    private void setupEnvironmentVariable(    EnvVars vars,    ExecWatch watch) throws IOException {
      for (      Map.Entry<String,String> entry : vars.entrySet()) {
        watch.getInput().write(String.format(""String_Node_Str"",entry.getKey(),entry.getValue().replace(""String_Node_Str"",""String_Node_Str"")).getBytes(StandardCharsets.UTF_8));
      }
    }
    private boolean isContainerReady(    Pod pod,    String container){
      if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
        return false;
      }
      for (      ContainerStatus info : pod.getStatus().getContainerStatuses()) {
        if (info.getName().equals(container) && info.getReady()) {
          return true;
        }
      }
      return false;
    }
    private void waitUntilContainerIsReady() throws IOException {
      try {
        client.pods().inNamespace(namespace).withName(podName).waitUntilReady(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES);
      }
 catch (      InterruptedException|KubernetesClientTimeoutException e) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"",e);
      }
    }
  }
;
}","@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      boolean quiet=starter.quiet();
      FilePath pwd=starter.pwd();
      String[] commands=getCommands(starter);
      return doLaunch(quiet,pwd,commands);
    }
    private Proc doLaunch(    boolean quiet,    FilePath pwd,    String... commands) throws IOException {
      waitUntilContainerIsReady();
      final CountDownLatch started=new CountDownLatch(1);
      final CountDownLatch finished=new CountDownLatch(1);
      final AtomicBoolean alive=new AtomicBoolean(false);
      PrintStream printStream=launcher.getListener().getLogger();
      OutputStream stream=printStream;
      if (quiet) {
        stream=new NullOutputStream();
        printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
      }
      ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
      stream=new TeeOutputStream(exitCodeOutputStream,stream);
      String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
      LOGGER.log(Level.FINEST,msg);
      printStream.println(msg);
      Execable<String,ExecWatch> execable=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        Throwable t,        Response response){
          alive.set(false);
          t.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
      }
);
      ExecWatch watch;
      try {
        watch=execable.exec();
      }
 catch (      KubernetesClientException e) {
        if (e.getCause() instanceof InterruptedException) {
          throw new IOException(""String_Node_Str"",e);
        }
 else {
          throw e;
        }
      }
      try {
        started.await();
      }
 catch (      InterruptedException e) {
        closeWatch(watch);
        throw new IOException(""String_Node_Str"",e);
      }
      try {
        if (pwd != null) {
          watch.getInput().write(String.format(""String_Node_Str"",pwd,NEWLINE).getBytes(StandardCharsets.UTF_8));
        }
        if (environmentExpander != null) {
          EnvVars envVars=new EnvVars();
          environmentExpander.expand(envVars);
          this.setupEnvironmentVariable(envVars,watch);
        }
        doExec(watch,printStream,commands);
        ContainerExecProc proc=new ContainerExecProc(watch,alive,finished,exitCodeOutputStream::getExitCode);
        closables.add(proc);
        return proc;
      }
 catch (      InterruptedException ie) {
        throw new InterruptedIOException(ie.getMessage());
      }
catch (      Exception e) {
        closeWatch(watch);
        throw e;
      }
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      String cookie=modelEnvVars.get(COOKIE_VAR);
      int exitCode=doLaunch(true,null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + COOKIE_VAR + ""String_Node_Str""+ cookie+ ""String_Node_Str"").join();
      getListener().getLogger().println(""String_Node_Str"" + exitCode);
    }
    private void setupEnvironmentVariable(    EnvVars vars,    ExecWatch watch) throws IOException {
      for (      Map.Entry<String,String> entry : vars.entrySet()) {
        watch.getInput().write(String.format(""String_Node_Str"",entry.getKey(),entry.getValue().replace(""String_Node_Str"",""String_Node_Str""),NEWLINE).getBytes(StandardCharsets.UTF_8));
      }
    }
    private boolean isContainerReady(    Pod pod,    String container){
      if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
        return false;
      }
      for (      ContainerStatus info : pod.getStatus().getContainerStatuses()) {
        if (info.getName().equals(container) && info.getReady()) {
          return true;
        }
      }
      return false;
    }
    private void waitUntilContainerIsReady() throws IOException {
      try {
        client.pods().inNamespace(namespace).withName(podName).waitUntilReady(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES);
      }
 catch (      InterruptedException|KubernetesClientTimeoutException e) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"",e);
      }
    }
  }
;
}"
41289,"private void setupEnvironmentVariable(EnvVars vars,ExecWatch watch) throws IOException {
  for (  Map.Entry<String,String> entry : vars.entrySet()) {
    watch.getInput().write(String.format(""String_Node_Str"",entry.getKey(),entry.getValue().replace(""String_Node_Str"",""String_Node_Str"")).getBytes(StandardCharsets.UTF_8));
  }
}","private void setupEnvironmentVariable(EnvVars vars,ExecWatch watch) throws IOException {
  for (  Map.Entry<String,String> entry : vars.entrySet()) {
    watch.getInput().write(String.format(""String_Node_Str"",entry.getKey(),entry.getValue().replace(""String_Node_Str"",""String_Node_Str""),NEWLINE).getBytes(StandardCharsets.UTF_8));
  }
}"
41290,"@Override public void launch(SlaveComputer computer,TaskListener listener){
  if (!(computer instanceof KubernetesComputer)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  KubernetesComputer kubernetesComputer=(KubernetesComputer)computer;
  KubernetesSlave slave=kubernetesComputer.getNode();
  KubernetesCloud cloud=slave.getCloud();
  final PodTemplate unwrappedTemplate=slave.getTemplate();
  try {
    KubernetesClient client=cloud.connect();
    Pod pod=getPodTemplate(slave,unwrappedTemplate);
    String podId=pod.getMetadata().getName();
    String namespace=StringUtils.defaultIfBlank(slave.getNamespace(),client.getNamespace());
    LOGGER.log(Level.FINE,""String_Node_Str"",new Object[]{podId,namespace});
    pod=client.pods().inNamespace(namespace).create(pod);
    LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,namespace});
    listener.getLogger().printf(""String_Node_Str"",podId,namespace);
    List<String> validStates=ImmutableList.of(""String_Node_Str"");
    int i=0;
    int j=100;
    List<ContainerStatus> containerStatuses=null;
    for (; i < j; i++) {
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,i,j});
      listener.getLogger().printf(""String_Node_Str"",podId,i,j);
      Thread.sleep(6000);
      pod=client.pods().inNamespace(namespace).withName(podId).get();
      if (pod == null) {
        throw new IllegalStateException(""String_Node_Str"" + podId);
      }
      containerStatuses=pod.getStatus().getContainerStatuses();
      List<ContainerStatus> terminatedContainers=new ArrayList<>();
      Boolean allContainersAreReady=true;
      for (      ContainerStatus info : containerStatuses) {
        if (info != null) {
          if (info.getState().getWaiting() != null) {
            LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,info.getState().getWaiting(),info.getName()});
            listener.getLogger().printf(""String_Node_Str"",podId,info.getState().getWaiting(),info.getName());
          }
          if (info.getState().getTerminated() != null) {
            terminatedContainers.add(info);
          }
 else           if (!info.getReady()) {
            allContainersAreReady=false;
          }
        }
      }
      if (!terminatedContainers.isEmpty()) {
        Map<String,Integer> errors=terminatedContainers.stream().collect(Collectors.toMap(ContainerStatus::getName,(info) -> info.getState().getTerminated().getExitCode()));
        logLastLines(terminatedContainers,podId,namespace,slave,errors,client);
        throw new IllegalStateException(""String_Node_Str"" + errors);
      }
      if (!allContainersAreReady) {
        continue;
      }
      if (validStates.contains(pod.getStatus().getPhase())) {
        break;
      }
    }
    String status=pod.getStatus().getPhase();
    if (!validStates.contains(status)) {
      throw new IllegalStateException(""String_Node_Str"" + j + ""String_Node_Str""+ status);
    }
    j=unwrappedTemplate.getSlaveConnectTimeout();
    for (; i < j; i++) {
      if (slave.getComputer() == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      if (slave.getComputer().isOnline()) {
        break;
      }
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,i,j});
      listener.getLogger().printf(""String_Node_Str"",podId,i,j);
      Thread.sleep(1000);
    }
    if (!slave.getComputer().isOnline()) {
      if (containerStatuses != null) {
        logLastLines(containerStatuses,podId,namespace,slave,null,client);
      }
      throw new IllegalStateException(""String_Node_Str"" + j + ""String_Node_Str""+ status);
    }
  }
 catch (  Throwable ex) {
    LOGGER.log(Level.WARNING,String.format(""String_Node_Str"",slave,unwrappedTemplate),ex);
    if (slave != null) {
      LOGGER.log(Level.FINER,""String_Node_Str"",slave.getNodeName());
      try {
        Jenkins.getInstance().removeNode(slave);
      }
 catch (      IOException e) {
        LOGGER.log(Level.WARNING,""String_Node_Str"",e);
      }
    }
    throw Throwables.propagate(ex);
  }
  launched=true;
}","@Override public void launch(SlaveComputer computer,TaskListener listener){
  if (!(computer instanceof KubernetesComputer)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  KubernetesComputer kubernetesComputer=(KubernetesComputer)computer;
  KubernetesSlave slave=kubernetesComputer.getNode();
  if (slave == null) {
    throw new IllegalStateException(""String_Node_Str"" + computer.getName());
  }
  KubernetesCloud cloud=slave.getCloud();
  final PodTemplate unwrappedTemplate=slave.getTemplate();
  try {
    KubernetesClient client=cloud.connect();
    Pod pod=getPodTemplate(slave,unwrappedTemplate);
    String podId=pod.getMetadata().getName();
    String namespace=StringUtils.defaultIfBlank(slave.getNamespace(),client.getNamespace());
    LOGGER.log(Level.FINE,""String_Node_Str"",new Object[]{podId,namespace});
    pod=client.pods().inNamespace(namespace).create(pod);
    LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,namespace});
    listener.getLogger().printf(""String_Node_Str"",podId,namespace);
    List<String> validStates=ImmutableList.of(""String_Node_Str"");
    int i=0;
    int j=100;
    List<ContainerStatus> containerStatuses=null;
    for (; i < j; i++) {
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,i,j});
      listener.getLogger().printf(""String_Node_Str"",podId,i,j);
      Thread.sleep(6000);
      pod=client.pods().inNamespace(namespace).withName(podId).get();
      if (pod == null) {
        throw new IllegalStateException(""String_Node_Str"" + podId);
      }
      containerStatuses=pod.getStatus().getContainerStatuses();
      List<ContainerStatus> terminatedContainers=new ArrayList<>();
      Boolean allContainersAreReady=true;
      for (      ContainerStatus info : containerStatuses) {
        if (info != null) {
          if (info.getState().getWaiting() != null) {
            LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,info.getState().getWaiting(),info.getName()});
            listener.getLogger().printf(""String_Node_Str"",podId,info.getState().getWaiting(),info.getName());
          }
          if (info.getState().getTerminated() != null) {
            terminatedContainers.add(info);
          }
 else           if (!info.getReady()) {
            allContainersAreReady=false;
          }
        }
      }
      if (!terminatedContainers.isEmpty()) {
        Map<String,Integer> errors=terminatedContainers.stream().collect(Collectors.toMap(ContainerStatus::getName,(info) -> info.getState().getTerminated().getExitCode()));
        logLastLines(terminatedContainers,podId,namespace,slave,errors,client);
        throw new IllegalStateException(""String_Node_Str"" + errors);
      }
      if (!allContainersAreReady) {
        continue;
      }
      if (validStates.contains(pod.getStatus().getPhase())) {
        break;
      }
    }
    String status=pod.getStatus().getPhase();
    if (!validStates.contains(status)) {
      throw new IllegalStateException(""String_Node_Str"" + j + ""String_Node_Str""+ status);
    }
    j=unwrappedTemplate.getSlaveConnectTimeout();
    for (; i < j; i++) {
      if (slave.getComputer() == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      if (slave.getComputer().isOnline()) {
        break;
      }
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,i,j});
      listener.getLogger().printf(""String_Node_Str"",podId,i,j);
      Thread.sleep(1000);
    }
    if (!slave.getComputer().isOnline()) {
      if (containerStatuses != null) {
        logLastLines(containerStatuses,podId,namespace,slave,null,client);
      }
      throw new IllegalStateException(""String_Node_Str"" + j + ""String_Node_Str""+ status);
    }
  }
 catch (  Throwable ex) {
    LOGGER.log(Level.WARNING,String.format(""String_Node_Str"",slave,unwrappedTemplate),ex);
    LOGGER.log(Level.FINER,""String_Node_Str"",slave.getNodeName());
    try {
      Jenkins.getInstance().removeNode(slave);
    }
 catch (    IOException e) {
      LOGGER.log(Level.WARNING,""String_Node_Str"",e);
    }
    throw Throwables.propagate(ex);
  }
  launched=true;
}"
41291,"@Override protected void _terminate(TaskListener listener) throws IOException, InterruptedException {
  LOGGER.log(Level.INFO,""String_Node_Str"",name);
  Computer computer=toComputer();
  if (computer == null) {
    String msg=String.format(""String_Node_Str"",name);
    LOGGER.log(Level.SEVERE,msg);
    listener.fatalError(msg);
    return;
  }
  if (getCloudName() == null) {
    String msg=String.format(""String_Node_Str"",name);
    LOGGER.log(Level.SEVERE,msg);
    listener.fatalError(msg);
    computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
    return;
  }
  Cloud cloud=getCloud();
  if (cloud == null) {
    String msg=String.format(""String_Node_Str"",getCloudName());
    LOGGER.log(Level.WARNING,msg);
    listener.fatalError(msg);
    computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
    return;
  }
  if (!(cloud instanceof KubernetesCloud)) {
    String msg=String.format(""String_Node_Str"",getCloudName());
    LOGGER.log(Level.SEVERE,msg);
    listener.fatalError(msg);
    computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
    return;
  }
  KubernetesClient client;
  try {
    client=((KubernetesCloud)cloud).connect();
  }
 catch (  UnrecoverableKeyException|CertificateEncodingException|NoSuchAlgorithmException|KeyStoreException e) {
    String msg=String.format(""String_Node_Str"",getCloudName());
    listener.fatalError(msg);
    computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
    return;
  }
  String actualNamespace=getNamespace() == null ? client.getNamespace() : getNamespace();
  try {
    Boolean deleted=client.pods().inNamespace(actualNamespace).withName(name).delete();
    if (!Boolean.TRUE.equals(deleted)) {
      String msg=String.format(""String_Node_Str"",actualNamespace,name);
      LOGGER.log(Level.WARNING,msg);
      listener.error(msg);
      return;
    }
  }
 catch (  KubernetesClientException e) {
    String msg=String.format(""String_Node_Str"",actualNamespace,name,e.getMessage());
    LOGGER.log(Level.WARNING,msg,e);
    listener.error(msg);
    computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
    return;
  }
  String msg=String.format(""String_Node_Str"",actualNamespace,name);
  LOGGER.log(Level.INFO,msg);
  listener.getLogger().println(msg);
  computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
  LOGGER.log(Level.INFO,""String_Node_Str"",name);
}","@Override protected void _terminate(TaskListener listener) throws IOException, InterruptedException {
  LOGGER.log(Level.INFO,""String_Node_Str"",name);
  Computer computer=toComputer();
  if (computer == null) {
    String msg=String.format(""String_Node_Str"",name);
    LOGGER.log(Level.SEVERE,msg);
    listener.fatalError(msg);
    return;
  }
  if (getCloudName() == null) {
    String msg=String.format(""String_Node_Str"",name);
    LOGGER.log(Level.SEVERE,msg);
    listener.fatalError(msg);
    computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
    return;
  }
  KubernetesCloud cloud=getCloud();
  KubernetesClient client;
  try {
    client=cloud.connect();
  }
 catch (  UnrecoverableKeyException|CertificateEncodingException|NoSuchAlgorithmException|KeyStoreException e) {
    String msg=String.format(""String_Node_Str"",getCloudName());
    listener.fatalError(msg);
    computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
    return;
  }
  String actualNamespace=getNamespace() == null ? client.getNamespace() : getNamespace();
  try {
    Boolean deleted=client.pods().inNamespace(actualNamespace).withName(name).delete();
    if (!Boolean.TRUE.equals(deleted)) {
      String msg=String.format(""String_Node_Str"",actualNamespace,name);
      LOGGER.log(Level.WARNING,msg);
      listener.error(msg);
      return;
    }
  }
 catch (  KubernetesClientException e) {
    String msg=String.format(""String_Node_Str"",actualNamespace,name,e.getMessage());
    LOGGER.log(Level.WARNING,msg,e);
    listener.error(msg);
    computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
    return;
  }
  String msg=String.format(""String_Node_Str"",actualNamespace,name);
  LOGGER.log(Level.INFO,msg);
  listener.getLogger().println(msg);
  computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
  LOGGER.log(Level.INFO,""String_Node_Str"",name);
}"
41292,"public KubernetesCloud getCloud(){
  Cloud cloud=Jenkins.getInstance().getCloud(getCloudName());
  if (cloud instanceof KubernetesCloud) {
    return (KubernetesCloud)cloud;
  }
 else {
    throw new IllegalStateException(getClass().getName() + ""String_Node_Str"" + KubernetesCloud.class.getName());
  }
}","@Nonnull public KubernetesCloud getCloud(){
  Cloud cloud=Jenkins.getInstance().getCloud(getCloudName());
  if (cloud instanceof KubernetesCloud) {
    return (KubernetesCloud)cloud;
  }
 else {
    throw new IllegalStateException(getClass().getName() + ""String_Node_Str"" + KubernetesCloud.class.getName());
  }
}"
41293,"KubernetesClient connectToCloud() throws Exception {
  Node node=context.get(Node.class);
  if (!(node instanceof KubernetesSlave)) {
    throw new AbortException(String.format(""String_Node_Str"",node != null ? node.getNodeName() : null));
  }
  KubernetesSlave slave=(KubernetesSlave)node;
  KubernetesCloud cloud=(KubernetesCloud)slave.getCloud();
  if (cloud == null) {
    throw new AbortException(String.format(""String_Node_Str"",slave.getCloudName()));
  }
  return cloud.connect();
}","KubernetesClient connectToCloud() throws Exception {
  Node node=context.get(Node.class);
  if (!(node instanceof KubernetesSlave)) {
    throw new AbortException(String.format(""String_Node_Str"",node != null ? node.getNodeName() : null));
  }
  KubernetesSlave slave=(KubernetesSlave)node;
  KubernetesCloud cloud=slave.getCloud();
  return cloud.connect();
}"
41294,"@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      boolean quiet=starter.quiet();
      FilePath pwd=starter.pwd();
      String[] commands=getCommands(starter);
      return doLaunch(quiet,pwd,commands);
    }
    private Proc doLaunch(    boolean quiet,    FilePath pwd,    String... commands) throws IOException {
      waitUntilContainerIsReady();
      final CountDownLatch started=new CountDownLatch(1);
      final CountDownLatch finished=new CountDownLatch(1);
      final AtomicBoolean alive=new AtomicBoolean(false);
      PrintStream printStream=launcher.getListener().getLogger();
      OutputStream stream=printStream;
      if (quiet) {
        stream=new NullOutputStream();
        printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
      }
      ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
      stream=new TeeOutputStream(exitCodeOutputStream,stream);
      String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
      LOGGER.log(Level.FINEST,msg);
      printStream.println(msg);
      Execable<String,ExecWatch> execable=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        Throwable t,        Response response){
          alive.set(false);
          t.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
      }
);
      ExecWatch watch;
      try {
        watch=execable.exec();
      }
 catch (      KubernetesClientException e) {
        if (e.getCause() instanceof InterruptedException) {
          throw new IOException(""String_Node_Str"",e);
        }
 else {
          throw e;
        }
      }
      try {
        started.await();
      }
 catch (      InterruptedException e) {
        closeWatch(watch);
        throw new IOException(""String_Node_Str"",e);
      }
      try {
        if (pwd != null) {
          watch.getInput().write(String.format(""String_Node_Str"",pwd,NEWLINE).getBytes(StandardCharsets.UTF_8));
        }
        if (environmentExpander != null) {
          EnvVars envVars=new EnvVars();
          environmentExpander.expand(envVars);
          for (          Map.Entry<String,String> entry : envVars.entrySet()) {
            watch.getInput().write(String.format(""String_Node_Str"",entry.getKey(),entry.getValue(),NEWLINE).getBytes(StandardCharsets.UTF_8));
          }
        }
        doExec(watch,printStream,commands);
        ContainerExecProc proc=new ContainerExecProc(watch,alive,finished,exitCodeOutputStream::getExitCode);
        closables.add(proc);
        return proc;
      }
 catch (      InterruptedException ie) {
        throw new InterruptedIOException(ie.getMessage());
      }
catch (      Exception e) {
        closeWatch(watch);
        throw e;
      }
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      String cookie=modelEnvVars.get(COOKIE_VAR);
      int exitCode=doLaunch(true,null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + COOKIE_VAR + ""String_Node_Str""+ cookie+ ""String_Node_Str"").join();
      getListener().getLogger().println(""String_Node_Str"" + exitCode);
    }
    private boolean isContainerReady(    Pod pod,    String container){
      if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
        return false;
      }
      for (      ContainerStatus info : pod.getStatus().getContainerStatuses()) {
        if (info.getName().equals(container) && info.getReady()) {
          return true;
        }
      }
      return false;
    }
    private void waitUntilContainerIsReady() throws IOException {
      try {
        client.pods().inNamespace(namespace).withName(podName).waitUntilReady(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES);
      }
 catch (      InterruptedException|KubernetesClientTimeoutException e) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"",e);
      }
    }
  }
;
}","@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      boolean quiet=starter.quiet();
      FilePath pwd=starter.pwd();
      String[] commands=getCommands(starter);
      return doLaunch(quiet,pwd,commands);
    }
    private Proc doLaunch(    boolean quiet,    FilePath pwd,    String... commands) throws IOException {
      waitUntilContainerIsReady();
      final CountDownLatch started=new CountDownLatch(1);
      final CountDownLatch finished=new CountDownLatch(1);
      final AtomicBoolean alive=new AtomicBoolean(false);
      PrintStream printStream=launcher.getListener().getLogger();
      OutputStream stream=printStream;
      if (quiet) {
        stream=new NullOutputStream();
        printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
      }
      ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
      stream=new TeeOutputStream(exitCodeOutputStream,stream);
      String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
      LOGGER.log(Level.FINEST,msg);
      printStream.println(msg);
      Execable<String,ExecWatch> execable=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        Throwable t,        Response response){
          alive.set(false);
          t.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
      }
);
      ExecWatch watch;
      try {
        watch=execable.exec();
      }
 catch (      KubernetesClientException e) {
        if (e.getCause() instanceof InterruptedException) {
          throw new IOException(""String_Node_Str"",e);
        }
 else {
          throw e;
        }
      }
      try {
        started.await();
      }
 catch (      InterruptedException e) {
        closeWatch(watch);
        throw new IOException(""String_Node_Str"",e);
      }
      try {
        if (pwd != null) {
          watch.getInput().write(String.format(""String_Node_Str"",pwd,NEWLINE).getBytes(StandardCharsets.UTF_8));
        }
        if (environmentExpander != null) {
          EnvVars envVars=new EnvVars();
          environmentExpander.expand(envVars);
          for (          Map.Entry<String,String> entry : envVars.entrySet()) {
            watch.getInput().write(String.format(""String_Node_Str"",entry.getKey(),entry.getValue(),NEWLINE).getBytes(StandardCharsets.UTF_8));
          }
        }
        doExec(watch,printStream,commands);
        ContainerExecProc proc=new ContainerExecProc(watch,alive,finished,exitCodeOutputStream::getExitCode);
        closables.add(proc);
        return proc;
      }
 catch (      InterruptedException ie) {
        throw new InterruptedIOException(ie.getMessage());
      }
catch (      Exception e) {
        closeWatch(watch);
        throw e;
      }
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      String cookie=modelEnvVars.get(COOKIE_VAR);
      int exitCode=doLaunch(true,null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + COOKIE_VAR + ""String_Node_Str""+ cookie+ ""String_Node_Str"").join();
      getListener().getLogger().println(""String_Node_Str"" + exitCode);
    }
    private void waitUntilContainerIsReady() throws IOException {
      try {
        Pod pod=client.pods().inNamespace(namespace).withName(podName).waitUntilReady(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES);
        if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
          throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
        }
        for (        ContainerStatus info : pod.getStatus().getContainerStatuses()) {
          if (info.getName().equals(containerName)) {
            if (info.getReady()) {
              return;
            }
 else {
              throw new IOException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ info.getState());
            }
          }
        }
        throw new IOException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      }
 catch (      InterruptedException|KubernetesClientTimeoutException e) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"",e);
      }
    }
  }
;
}"
41295,"private void waitUntilContainerIsReady() throws IOException {
  try {
    client.pods().inNamespace(namespace).withName(podName).waitUntilReady(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES);
  }
 catch (  InterruptedException|KubernetesClientTimeoutException e) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"",e);
  }
}","private void waitUntilContainerIsReady() throws IOException {
  try {
    Pod pod=client.pods().inNamespace(namespace).withName(podName).waitUntilReady(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES);
    if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
      throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    for (    ContainerStatus info : pod.getStatus().getContainerStatuses()) {
      if (info.getName().equals(containerName)) {
        if (info.getReady()) {
          return;
        }
 else {
          throw new IOException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ info.getState());
        }
      }
    }
    throw new IOException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
  }
 catch (  InterruptedException|KubernetesClientTimeoutException e) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"",e);
  }
}"
41296,"@Before public void configureCloud() throws Exception {
  client=setupCloud().connect();
  deletePods(client,labels,false);
  String image=""String_Node_Str"";
  Container c=new ContainerBuilder().withName(image).withImagePullPolicy(""String_Node_Str"").withImage(image).withCommand(""String_Node_Str"").withTty(true).build();
  String podName=""String_Node_Str"" + RandomStringUtils.random(5,""String_Node_Str"");
  Pod pod=client.pods().create(new PodBuilder().withNewMetadata().withName(podName).withLabels(labels).endMetadata().withNewSpec().withContainers(c).endSpec().build());
  System.out.println(""String_Node_Str"" + pod.getMetadata().getName());
  decorator=new ContainerExecDecorator(client,pod.getMetadata().getName(),image,client.getNamespace());
}","@Before public void configureCloud() throws Exception {
  client=setupCloud().connect();
  deletePods(client,labels,false);
  String image=""String_Node_Str"";
  Container c=new ContainerBuilder().withName(image).withImagePullPolicy(""String_Node_Str"").withImage(image).withCommand(""String_Node_Str"").withTty(true).build();
  String podName=""String_Node_Str"" + RandomStringUtils.random(5,""String_Node_Str"");
  pod=client.pods().create(new PodBuilder().withNewMetadata().withName(podName).withLabels(labels).endMetadata().withNewSpec().withContainers(c).endSpec().build());
  System.out.println(""String_Node_Str"" + pod.getMetadata().getName());
  decorator=new ContainerExecDecorator(client,pod.getMetadata().getName(),image,client.getNamespace());
}"
41297,"@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      boolean quiet=starter.quiet();
      FilePath pwd=starter.pwd();
      String[] commands=getCommands(starter);
      return doLaunch(quiet,pwd,commands);
    }
    private Proc doLaunch(    boolean quiet,    FilePath pwd,    String... commands) throws IOException {
      waitUntilContainerIsReady();
      final CountDownLatch started=new CountDownLatch(1);
      final CountDownLatch finished=new CountDownLatch(1);
      final AtomicBoolean alive=new AtomicBoolean(false);
      PrintStream printStream=launcher.getListener().getLogger();
      OutputStream stream=printStream;
      if (quiet) {
        stream=new NullOutputStream();
        printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
      }
      ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
      stream=new TeeOutputStream(exitCodeOutputStream,stream);
      String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
      LOGGER.log(Level.FINEST,msg);
      printStream.println(msg);
      Execable<String,ExecWatch> execable=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        Throwable t,        Response response){
          alive.set(false);
          t.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
      }
);
      ExecWatch watch;
      try {
        watch=execable.exec();
      }
 catch (      KubernetesClientException e) {
        if (e.getCause() instanceof InterruptedException) {
          throw new IOException(""String_Node_Str"",e);
        }
 else {
          throw e;
        }
      }
      try {
        started.await();
      }
 catch (      InterruptedException e) {
        closeWatch(watch);
        throw new IOException(""String_Node_Str"",e);
      }
      try {
        if (pwd != null) {
          watch.getInput().write(String.format(""String_Node_Str"",pwd,NEWLINE).getBytes(StandardCharsets.UTF_8));
        }
        if (environmentExpander != null) {
          EnvVars envVars=new EnvVars();
          environmentExpander.expand(envVars);
          for (          Map.Entry<String,String> entry : envVars.entrySet()) {
            watch.getInput().write(String.format(""String_Node_Str"",entry.getKey(),entry.getValue(),NEWLINE).getBytes(StandardCharsets.UTF_8));
          }
        }
        doExec(watch,printStream,commands);
        ContainerExecProc proc=new ContainerExecProc(watch,alive,finished,exitCodeOutputStream::getExitCode);
        closables.add(proc);
        return proc;
      }
 catch (      InterruptedException ie) {
        throw new InterruptedIOException(ie.getMessage());
      }
catch (      Exception e) {
        closeWatch(watch);
        throw e;
      }
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      String cookie=modelEnvVars.get(COOKIE_VAR);
      int exitCode=doLaunch(true,null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + COOKIE_VAR + ""String_Node_Str""+ cookie+ ""String_Node_Str"").join();
      getListener().getLogger().println(""String_Node_Str"" + exitCode);
    }
    private void waitUntilContainerIsReady() throws IOException {
      try {
        Pod pod=client.pods().inNamespace(namespace).withName(podName).waitUntilReady(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES);
        if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
          throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
        }
        for (        ContainerStatus info : pod.getStatus().getContainerStatuses()) {
          if (info.getName().equals(containerName)) {
            if (info.getReady()) {
              return;
            }
 else {
              throw new IOException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ info.getState());
            }
          }
        }
        throw new IOException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      }
 catch (      InterruptedException|KubernetesClientTimeoutException e) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"",e);
      }
    }
  }
;
}","@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      boolean quiet=starter.quiet();
      FilePath pwd=starter.pwd();
      String[] commands=getCommands(starter);
      return doLaunch(quiet,pwd,commands);
    }
    private Proc doLaunch(    boolean quiet,    FilePath pwd,    String... commands) throws IOException {
      waitUntilContainerIsReady();
      final CountDownLatch started=new CountDownLatch(1);
      final CountDownLatch finished=new CountDownLatch(1);
      final AtomicBoolean alive=new AtomicBoolean(false);
      PrintStream printStream=launcher.getListener().getLogger();
      OutputStream stream=printStream;
      if (quiet) {
        stream=new NullOutputStream();
        printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
      }
      ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
      stream=new TeeOutputStream(exitCodeOutputStream,stream);
      String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
      LOGGER.log(Level.FINEST,msg);
      printStream.println(msg);
      Execable<String,ExecWatch> execable=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        Throwable t,        Response response){
          alive.set(false);
          t.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
      }
);
      ExecWatch watch;
      try {
        watch=execable.exec(""String_Node_Str"");
      }
 catch (      KubernetesClientException e) {
        if (e.getCause() instanceof InterruptedException) {
          throw new IOException(""String_Node_Str"",e);
        }
 else {
          throw e;
        }
      }
      try {
        started.await();
      }
 catch (      InterruptedException e) {
        closeWatch(watch);
        throw new IOException(""String_Node_Str"",e);
      }
      try {
        if (pwd != null) {
          watch.getInput().write(String.format(""String_Node_Str"",pwd,NEWLINE).getBytes(StandardCharsets.UTF_8));
        }
        if (environmentExpander != null) {
          EnvVars envVars=new EnvVars();
          environmentExpander.expand(envVars);
          for (          Map.Entry<String,String> entry : envVars.entrySet()) {
            watch.getInput().write(String.format(""String_Node_Str"",entry.getKey(),entry.getValue(),NEWLINE).getBytes(StandardCharsets.UTF_8));
          }
        }
        doExec(watch,printStream,commands);
        ContainerExecProc proc=new ContainerExecProc(watch,alive,finished,exitCodeOutputStream::getExitCode);
        closables.add(proc);
        return proc;
      }
 catch (      InterruptedException ie) {
        throw new InterruptedIOException(ie.getMessage());
      }
catch (      Exception e) {
        closeWatch(watch);
        throw e;
      }
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      String cookie=modelEnvVars.get(COOKIE_VAR);
      int exitCode=doLaunch(true,null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + COOKIE_VAR + ""String_Node_Str""+ cookie+ ""String_Node_Str"").join();
      getListener().getLogger().println(""String_Node_Str"" + exitCode);
    }
    private void waitUntilContainerIsReady() throws IOException {
      try {
        Pod pod=client.pods().inNamespace(namespace).withName(podName).waitUntilReady(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES);
        if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
          throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
        }
        for (        ContainerStatus info : pod.getStatus().getContainerStatuses()) {
          if (info.getName().equals(containerName)) {
            if (info.getReady()) {
              return;
            }
 else {
              throw new IOException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ info.getState());
            }
          }
        }
        throw new IOException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      }
 catch (      InterruptedException|KubernetesClientTimeoutException e) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"",e);
      }
    }
  }
;
}"
41298,"private Proc doLaunch(boolean quiet,FilePath pwd,String... commands) throws IOException {
  waitUntilContainerIsReady();
  final CountDownLatch started=new CountDownLatch(1);
  final CountDownLatch finished=new CountDownLatch(1);
  final AtomicBoolean alive=new AtomicBoolean(false);
  PrintStream printStream=launcher.getListener().getLogger();
  OutputStream stream=printStream;
  if (quiet) {
    stream=new NullOutputStream();
    printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
  }
  ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
  stream=new TeeOutputStream(exitCodeOutputStream,stream);
  String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
  LOGGER.log(Level.FINEST,msg);
  printStream.println(msg);
  Execable<String,ExecWatch> execable=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
    @Override public void onOpen(    Response response){
      alive.set(true);
      started.countDown();
    }
    @Override public void onFailure(    Throwable t,    Response response){
      alive.set(false);
      t.printStackTrace(launcher.getListener().getLogger());
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.WARNING,""String_Node_Str"");
      }
      finished.countDown();
    }
    @Override public void onClose(    int i,    String s){
      alive.set(false);
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.WARNING,""String_Node_Str"");
      }
      finished.countDown();
    }
  }
);
  ExecWatch watch;
  try {
    watch=execable.exec();
  }
 catch (  KubernetesClientException e) {
    if (e.getCause() instanceof InterruptedException) {
      throw new IOException(""String_Node_Str"",e);
    }
 else {
      throw e;
    }
  }
  try {
    started.await();
  }
 catch (  InterruptedException e) {
    closeWatch(watch);
    throw new IOException(""String_Node_Str"",e);
  }
  try {
    if (pwd != null) {
      watch.getInput().write(String.format(""String_Node_Str"",pwd,NEWLINE).getBytes(StandardCharsets.UTF_8));
    }
    if (environmentExpander != null) {
      EnvVars envVars=new EnvVars();
      environmentExpander.expand(envVars);
      for (      Map.Entry<String,String> entry : envVars.entrySet()) {
        watch.getInput().write(String.format(""String_Node_Str"",entry.getKey(),entry.getValue(),NEWLINE).getBytes(StandardCharsets.UTF_8));
      }
    }
    doExec(watch,printStream,commands);
    ContainerExecProc proc=new ContainerExecProc(watch,alive,finished,exitCodeOutputStream::getExitCode);
    closables.add(proc);
    return proc;
  }
 catch (  InterruptedException ie) {
    throw new InterruptedIOException(ie.getMessage());
  }
catch (  Exception e) {
    closeWatch(watch);
    throw e;
  }
}","private Proc doLaunch(boolean quiet,FilePath pwd,String... commands) throws IOException {
  waitUntilContainerIsReady();
  final CountDownLatch started=new CountDownLatch(1);
  final CountDownLatch finished=new CountDownLatch(1);
  final AtomicBoolean alive=new AtomicBoolean(false);
  PrintStream printStream=launcher.getListener().getLogger();
  OutputStream stream=printStream;
  if (quiet) {
    stream=new NullOutputStream();
    printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
  }
  ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
  stream=new TeeOutputStream(exitCodeOutputStream,stream);
  String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
  LOGGER.log(Level.FINEST,msg);
  printStream.println(msg);
  Execable<String,ExecWatch> execable=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).usingListener(new ExecListener(){
    @Override public void onOpen(    Response response){
      alive.set(true);
      started.countDown();
    }
    @Override public void onFailure(    Throwable t,    Response response){
      alive.set(false);
      t.printStackTrace(launcher.getListener().getLogger());
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.WARNING,""String_Node_Str"");
      }
      finished.countDown();
    }
    @Override public void onClose(    int i,    String s){
      alive.set(false);
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.WARNING,""String_Node_Str"");
      }
      finished.countDown();
    }
  }
);
  ExecWatch watch;
  try {
    watch=execable.exec(""String_Node_Str"");
  }
 catch (  KubernetesClientException e) {
    if (e.getCause() instanceof InterruptedException) {
      throw new IOException(""String_Node_Str"",e);
    }
 else {
      throw e;
    }
  }
  try {
    started.await();
  }
 catch (  InterruptedException e) {
    closeWatch(watch);
    throw new IOException(""String_Node_Str"",e);
  }
  try {
    if (pwd != null) {
      watch.getInput().write(String.format(""String_Node_Str"",pwd,NEWLINE).getBytes(StandardCharsets.UTF_8));
    }
    if (environmentExpander != null) {
      EnvVars envVars=new EnvVars();
      environmentExpander.expand(envVars);
      for (      Map.Entry<String,String> entry : envVars.entrySet()) {
        watch.getInput().write(String.format(""String_Node_Str"",entry.getKey(),entry.getValue(),NEWLINE).getBytes(StandardCharsets.UTF_8));
      }
    }
    doExec(watch,printStream,commands);
    ContainerExecProc proc=new ContainerExecProc(watch,alive,finished,exitCodeOutputStream::getExitCode);
    closables.add(proc);
    return proc;
  }
 catch (  InterruptedException ie) {
    throw new InterruptedIOException(ie.getMessage());
  }
catch (  Exception e) {
    closeWatch(watch);
    throw e;
  }
}"
41299,"@Test public void testCommandExecutionWithNohup() throws Exception {
  ProcReturn r=execCommand(false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertFalse(""String_Node_Str"" + r.output,PID_PATTERN.matcher(r.output).find());
  assertEquals(0,r.exitCode);
  assertFalse(r.proc.isAlive());
}","@Test public void testCommandExecutionWithNohup() throws Exception {
  ProcReturn r=execCommand(false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertTrue(""String_Node_Str"" + r.output,PID_PATTERN.matcher(r.output).find());
  assertEquals(0,r.exitCode);
  assertFalse(r.proc.isAlive());
}"
41300,"@Test public void testCommandExecutionWithNohupAndError() throws Exception {
  ProcReturn r=execCommand(false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertFalse(""String_Node_Str"" + r.output,PID_PATTERN.matcher(r.output).find());
  assertEquals(127,r.exitCode);
  assertFalse(r.proc.isAlive());
}","@Test public void testCommandExecutionWithNohupAndError() throws Exception {
  ProcReturn r=execCommand(false,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(127,r.exitCode);
  assertFalse(r.proc.isAlive());
}"
41301,"@Test(timeout=10000) public void testCommandExecution() throws Exception {
  Thread[] t=new Thread[10];
  List<ProcReturn> results=new ArrayList<>(t.length);
  for (int i=0; i < t.length; i++) {
    t[i]=newThread(i,results);
  }
  for (int i=0; i < t.length; i++) {
    t[i].start();
  }
  for (int i=0; i < t.length; i++) {
    t[i].join();
  }
  assertEquals(""String_Node_Str"",t.length,results.size());
  for (  ProcReturn r : results) {
    assertTrue(""String_Node_Str"" + r.output,PID_PATTERN.matcher(r.output).find());
    assertEquals(0,r.exitCode);
    assertFalse(r.proc.isAlive());
  }
}","@Test(timeout=10000) public void testCommandExecution() throws Exception {
  Thread[] t=new Thread[10];
  List<ProcReturn> results=Collections.synchronizedList(new ArrayList<>(t.length));
  for (int i=0; i < t.length; i++) {
    t[i]=newThread(i,results);
  }
  for (int i=0; i < t.length; i++) {
    t[i].start();
  }
  for (int i=0; i < t.length; i++) {
    t[i].join();
  }
  assertEquals(""String_Node_Str"",t.length,results.size());
  for (  ProcReturn r : results) {
    assertTrue(""String_Node_Str"" + r.output,PID_PATTERN.matcher(r.output).find());
    assertEquals(0,r.exitCode);
    assertFalse(r.proc.isAlive());
  }
}"
41302,"@Test @LocalData() public void upgradeFrom_0_12(){
  KubernetesCloud cloud=r.jenkins.clouds.get(KubernetesCloud.class);
  List<PodTemplate> templates=cloud.getTemplates();
  assertPodTemplates(templates);
  assertEquals(Arrays.asList(new KeyValueEnvVar(""String_Node_Str"",""String_Node_Str""),new KeyValueEnvVar(""String_Node_Str"",""String_Node_Str"")),templates.get(0).getEnvVars());
}","@Test @LocalData() public void upgradeFrom_0_12() throws Exception {
  List<PodTemplate> templates=cloud.getTemplates();
  assertPodTemplates(templates);
  assertEquals(Arrays.asList(new KeyValueEnvVar(""String_Node_Str"",""String_Node_Str""),new KeyValueEnvVar(""String_Node_Str"",""String_Node_Str"")),templates.get(0).getEnvVars());
}"
41303,"@Test @LocalData() public void upgradeFrom_0_8(){
  KubernetesCloud cloud=r.jenkins.clouds.get(KubernetesCloud.class);
  List<PodTemplate> templates=cloud.getTemplates();
  assertPodTemplates(templates);
}","@Test @LocalData() public void upgradeFrom_0_8() throws Exception {
  List<PodTemplate> templates=cloud.getTemplates();
  assertPodTemplates(templates);
}"
41304,"@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      if (!waitUntilContainerIsReady()) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      final CountDownLatch started=new CountDownLatch(1);
      final CountDownLatch finished=new CountDownLatch(1);
      final AtomicBoolean alive=new AtomicBoolean(false);
      PrintStream printStream=launcher.getListener().getLogger();
      OutputStream stream=printStream;
      if (starter.quiet()) {
        stream=new NullOutputStream();
        printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
      }
      ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
      stream=new TeeOutputStream(exitCodeOutputStream,stream);
      String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
      LOGGER.log(Level.FINEST,msg);
      printStream.println(msg);
      watch=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        Throwable t,        Response response){
          alive.set(false);
          t.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
      }
).exec();
      waitQuietly(started);
      if (starter.pwd() != null) {
        watch.getInput().write(String.format(""String_Node_Str"",starter.pwd(),NEWLINE).getBytes(StandardCharsets.UTF_8));
      }
      doExec(watch,printStream,getCommands(starter));
      proc=new ContainerExecProc(watch,alive,finished,new Callable<Integer>(){
        @Override public Integer call(){
          return exitCodeOutputStream.getExitCode();
        }
      }
);
      return proc;
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      ContainerExecDecorator.this.close();
    }
    private boolean isContainerReady(    Pod pod,    String container){
      if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
        return false;
      }
      for (      ContainerStatus info : pod.getStatus().getContainerStatuses()) {
        if (info.getName().equals(container) && info.getReady()) {
          return true;
        }
      }
      return false;
    }
    private boolean waitUntilContainerIsReady(){
      int i=0;
      int j=10;
      Pod pod=client.pods().inNamespace(namespace).withName(podName).get();
      if (pod == null) {
        launcher.getListener().getLogger().println(""String_Node_Str"" + podName + ""String_Node_Str"");
        for (; i < j; i++) {
          LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
          pod=client.pods().inNamespace(namespace).withName(podName).get();
          if (pod != null) {
            break;
          }
          LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
          try {
            Thread.sleep(6000);
          }
 catch (          InterruptedException e) {
            return false;
          }
        }
      }
      if (pod == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      }
      if (isContainerReady(pod,containerName)) {
        return true;
      }
      launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      final CountDownLatch latch=new CountDownLatch(1);
      Watcher<Pod> podWatcher=new Watcher<Pod>(){
        @Override public void eventReceived(        Action action,        Pod resource){
switch (action) {
case MODIFIED:
            if (isContainerReady(resource,containerName)) {
              latch.countDown();
            }
          break;
default :
        break;
    }
  }
  @Override public void onClose(  KubernetesClientException cause){
  }
}
;
try (Watch watch=client.pods().inNamespace(namespace).withName(podName).watch(podWatcher)){
  if (latch.await(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES)) {
    return true;
  }
}
 catch (InterruptedException e) {
  return false;
}
return false;
}
}
;
}","@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      if (!waitUntilContainerIsReady()) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      final CountDownLatch started=new CountDownLatch(1);
      final CountDownLatch finished=new CountDownLatch(1);
      final AtomicBoolean alive=new AtomicBoolean(false);
      PrintStream printStream=launcher.getListener().getLogger();
      OutputStream stream=printStream;
      if (starter.quiet()) {
        stream=new NullOutputStream();
        printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
      }
      ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
      stream=new TeeOutputStream(exitCodeOutputStream,stream);
      String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
      LOGGER.log(Level.FINEST,msg);
      printStream.println(msg);
      ExecWatch watch=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        Throwable t,        Response response){
          alive.set(false);
          t.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
      }
).exec();
      try {
        started.await();
      }
 catch (      InterruptedException e) {
        closeWatch(watch);
        throw new IOException(""String_Node_Str"");
      }
      try {
        if (starter.pwd() != null) {
          watch.getInput().write(String.format(""String_Node_Str"",starter.pwd(),NEWLINE).getBytes(StandardCharsets.UTF_8));
        }
        doExec(watch,printStream,getCommands(starter));
        return new ContainerExecProc(watch,alive,finished,exitCodeOutputStream::getExitCode);
      }
 catch (      Exception e) {
        closeWatch(watch);
        throw e;
      }
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
    }
    private boolean isContainerReady(    Pod pod,    String container){
      if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
        return false;
      }
      for (      ContainerStatus info : pod.getStatus().getContainerStatuses()) {
        if (info.getName().equals(container) && info.getReady()) {
          return true;
        }
      }
      return false;
    }
    private boolean waitUntilContainerIsReady(){
      int i=0;
      int j=10;
      Pod pod=client.pods().inNamespace(namespace).withName(podName).get();
      if (pod == null) {
        launcher.getListener().getLogger().println(""String_Node_Str"" + podName + ""String_Node_Str"");
        for (; i < j; i++) {
          LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
          pod=client.pods().inNamespace(namespace).withName(podName).get();
          if (pod != null) {
            break;
          }
          LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
          try {
            Thread.sleep(6000);
          }
 catch (          InterruptedException e) {
            return false;
          }
        }
      }
      if (pod == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      }
      if (isContainerReady(pod,containerName)) {
        return true;
      }
      launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      final CountDownLatch latch=new CountDownLatch(1);
      Watcher<Pod> podWatcher=new Watcher<Pod>(){
        @Override public void eventReceived(        Action action,        Pod resource){
switch (action) {
case MODIFIED:
            if (isContainerReady(resource,containerName)) {
              latch.countDown();
            }
          break;
default :
        break;
    }
  }
  @Override public void onClose(  KubernetesClientException cause){
  }
}
;
try (Watch watch=client.pods().inNamespace(namespace).withName(podName).watch(podWatcher)){
  if (latch.await(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES)) {
    return true;
  }
}
 catch (InterruptedException e) {
  return false;
}
return false;
}
}
;
}"
41305,"@Override public Proc launch(ProcStarter starter) throws IOException {
  if (!waitUntilContainerIsReady()) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  final CountDownLatch started=new CountDownLatch(1);
  final CountDownLatch finished=new CountDownLatch(1);
  final AtomicBoolean alive=new AtomicBoolean(false);
  PrintStream printStream=launcher.getListener().getLogger();
  OutputStream stream=printStream;
  if (starter.quiet()) {
    stream=new NullOutputStream();
    printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
  }
  ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
  stream=new TeeOutputStream(exitCodeOutputStream,stream);
  String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
  LOGGER.log(Level.FINEST,msg);
  printStream.println(msg);
  watch=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
    @Override public void onOpen(    Response response){
      alive.set(true);
      started.countDown();
    }
    @Override public void onFailure(    Throwable t,    Response response){
      alive.set(false);
      t.printStackTrace(launcher.getListener().getLogger());
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.WARNING,""String_Node_Str"");
      }
      finished.countDown();
    }
    @Override public void onClose(    int i,    String s){
      alive.set(false);
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.WARNING,""String_Node_Str"");
      }
      finished.countDown();
    }
  }
).exec();
  waitQuietly(started);
  if (starter.pwd() != null) {
    watch.getInput().write(String.format(""String_Node_Str"",starter.pwd(),NEWLINE).getBytes(StandardCharsets.UTF_8));
  }
  doExec(watch,printStream,getCommands(starter));
  proc=new ContainerExecProc(watch,alive,finished,new Callable<Integer>(){
    @Override public Integer call(){
      return exitCodeOutputStream.getExitCode();
    }
  }
);
  return proc;
}","@Override public Proc launch(ProcStarter starter) throws IOException {
  if (!waitUntilContainerIsReady()) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  final CountDownLatch started=new CountDownLatch(1);
  final CountDownLatch finished=new CountDownLatch(1);
  final AtomicBoolean alive=new AtomicBoolean(false);
  PrintStream printStream=launcher.getListener().getLogger();
  OutputStream stream=printStream;
  if (starter.quiet()) {
    stream=new NullOutputStream();
    printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
  }
  ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
  stream=new TeeOutputStream(exitCodeOutputStream,stream);
  String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
  LOGGER.log(Level.FINEST,msg);
  printStream.println(msg);
  ExecWatch watch=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
    @Override public void onOpen(    Response response){
      alive.set(true);
      started.countDown();
    }
    @Override public void onFailure(    Throwable t,    Response response){
      alive.set(false);
      t.printStackTrace(launcher.getListener().getLogger());
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.WARNING,""String_Node_Str"");
      }
      finished.countDown();
    }
    @Override public void onClose(    int i,    String s){
      alive.set(false);
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.WARNING,""String_Node_Str"");
      }
      finished.countDown();
    }
  }
).exec();
  try {
    started.await();
  }
 catch (  InterruptedException e) {
    closeWatch(watch);
    throw new IOException(""String_Node_Str"");
  }
  try {
    if (starter.pwd() != null) {
      watch.getInput().write(String.format(""String_Node_Str"",starter.pwd(),NEWLINE).getBytes(StandardCharsets.UTF_8));
    }
    doExec(watch,printStream,getCommands(starter));
    return new ContainerExecProc(watch,alive,finished,exitCodeOutputStream::getExitCode);
  }
 catch (  Exception e) {
    closeWatch(watch);
    throw e;
  }
}"
41306,"@Override public void kill(Map<String,String> modelEnvVars) throws IOException, InterruptedException {
  getListener().getLogger().println(""String_Node_Str"");
  ContainerExecDecorator.this.close();
}","@Override public void kill(Map<String,String> modelEnvVars) throws IOException, InterruptedException {
  getListener().getLogger().println(""String_Node_Str"");
}"
41307,"@Override public int join() throws IOException, InterruptedException {
  LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
  finished.await();
  LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
  try {
    return exitCode.call();
  }
 catch (  Exception e) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",e);
    return -1;
  }
 finally {
    watch.close();
  }
}","@Override public int join() throws IOException, InterruptedException {
  try {
    LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
    finished.await();
    LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
    return exitCode.call();
  }
 catch (  Exception e) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",e);
    return -1;
  }
 finally {
    try {
      watch.close();
    }
 catch (    Exception e) {
      LOGGER.log(Level.INFO,""String_Node_Str"",e);
    }
  }
}"
41308,"@Override public void stop(Throwable cause) throws Exception {
  LOGGER.log(Level.FINE,""String_Node_Str"");
  closeQuietly(client,decorator);
}","@Override public void stop(Throwable cause) throws Exception {
  LOGGER.log(Level.FINE,""String_Node_Str"");
  closeQuietly(client);
}"
41309,"@Override public boolean start() throws Exception {
  LOGGER.log(Level.FINE,""String_Node_Str"");
  FilePath workspace=getContext().get(FilePath.class);
  String podName=workspace.child(HOSTNAME_FILE).readToString().trim();
  String namespace=workspace.child(Config.KUBERNETES_NAMESPACE_PATH).readToString().trim();
  String containerName=step.getName();
  Node node=getContext().get(Node.class);
  if (!(node instanceof KubernetesSlave)) {
    throw new AbortException(String.format(""String_Node_Str"",node.getNodeName()));
  }
  KubernetesSlave slave=(KubernetesSlave)node;
  KubernetesCloud cloud=(KubernetesCloud)slave.getCloud();
  if (cloud == null) {
    throw new AbortException(String.format(""String_Node_Str"",slave.getCloudName()));
  }
  client=cloud.connect();
  decorator=new ContainerExecDecorator(client,podName,containerName,namespace);
  getContext().newBodyInvoker().withContext(BodyInvoker.mergeLauncherDecorators(getContext().get(LauncherDecorator.class),decorator)).withCallback(new ContainerExecCallback(decorator)).start();
  return false;
}","@Override public boolean start() throws Exception {
  LOGGER.log(Level.FINE,""String_Node_Str"");
  FilePath workspace=getContext().get(FilePath.class);
  String podName=workspace.child(HOSTNAME_FILE).readToString().trim();
  String namespace=workspace.child(Config.KUBERNETES_NAMESPACE_PATH).readToString().trim();
  String containerName=step.getName();
  Node node=getContext().get(Node.class);
  if (!(node instanceof KubernetesSlave)) {
    throw new AbortException(String.format(""String_Node_Str"",node.getNodeName()));
  }
  KubernetesSlave slave=(KubernetesSlave)node;
  KubernetesCloud cloud=(KubernetesCloud)slave.getCloud();
  if (cloud == null) {
    throw new AbortException(String.format(""String_Node_Str"",slave.getCloudName()));
  }
  client=cloud.connect();
  decorator=new ContainerExecDecorator(client,podName,containerName,namespace);
  getContext().newBodyInvoker().withContext(BodyInvoker.mergeLauncherDecorators(getContext().get(LauncherDecorator.class),decorator)).withCallback(new ContainerExecCallback()).start();
  return false;
}"
41310,"private Object readResolve(){
  if ((serverCertificate != null) && !serverCertificate.startsWith(""String_Node_Str"")) {
    serverCertificate=new String(Base64.decodeBase64(serverCertificate.getBytes()));
    LOGGER.log(Level.INFO,""String_Node_Str"",serverCertificate.substring(0,80));
  }
  return this;
}","private Object readResolve(){
  if ((serverCertificate != null) && !serverCertificate.startsWith(""String_Node_Str"")) {
    serverCertificate=new String(Base64.decodeBase64(serverCertificate.getBytes(UTF_8)),UTF_8);
    LOGGER.log(Level.INFO,""String_Node_Str"",serverCertificate.substring(0,80));
  }
  return this;
}"
41311,"public KubernetesClient createClient() throws NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, IOException, CertificateEncodingException {
  ConfigBuilder builder=new ConfigBuilder().withMasterUrl(serviceAddress).withRequestTimeout(readTimeout * 1000).withConnectionTimeout(connectTimeout * 1000);
  if (!StringUtils.isBlank(namespace)) {
    builder.withNamespace(namespace);
  }
  if (credentials instanceof TokenProducer) {
    final String token=((TokenProducer)credentials).getToken(serviceAddress,caCertData,skipTlsVerify);
    builder.withOauthToken(token);
  }
 else   if (credentials instanceof UsernamePasswordCredentials) {
    UsernamePasswordCredentials usernamePassword=(UsernamePasswordCredentials)credentials;
    builder.withUsername(usernamePassword.getUsername()).withPassword(Secret.toString(usernamePassword.getPassword()));
  }
 else   if (credentials instanceof StandardCertificateCredentials) {
    StandardCertificateCredentials certificateCredentials=(StandardCertificateCredentials)credentials;
    KeyStore keyStore=certificateCredentials.getKeyStore();
    String alias=keyStore.aliases().nextElement();
    X509Certificate certificate=(X509Certificate)keyStore.getCertificate(alias);
    Key key=keyStore.getKey(alias,Secret.toString(certificateCredentials.getPassword()).toCharArray());
    builder.withClientCertData(Base64.encodeBase64String(certificate.getEncoded())).withClientKeyData(pemEncodeKey(key)).withClientKeyPassphrase(Secret.toString(certificateCredentials.getPassword()));
  }
  if (skipTlsVerify) {
    builder.withTrustCerts(true);
  }
  if (caCertData != null) {
    builder.withCaCertData(new String(Base64.encodeBase64String(caCertData.getBytes())));
  }
  LOGGER.log(Level.FINE,""String_Node_Str"",this.toString());
  return new DefaultKubernetesClient(builder.build());
}","public KubernetesClient createClient() throws NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, IOException, CertificateEncodingException {
  ConfigBuilder builder=new ConfigBuilder().withMasterUrl(serviceAddress).withRequestTimeout(readTimeout * 1000).withConnectionTimeout(connectTimeout * 1000);
  if (!StringUtils.isBlank(namespace)) {
    builder.withNamespace(namespace);
  }
  if (credentials instanceof TokenProducer) {
    final String token=((TokenProducer)credentials).getToken(serviceAddress,caCertData,skipTlsVerify);
    builder.withOauthToken(token);
  }
 else   if (credentials instanceof UsernamePasswordCredentials) {
    UsernamePasswordCredentials usernamePassword=(UsernamePasswordCredentials)credentials;
    builder.withUsername(usernamePassword.getUsername()).withPassword(Secret.toString(usernamePassword.getPassword()));
  }
 else   if (credentials instanceof StandardCertificateCredentials) {
    StandardCertificateCredentials certificateCredentials=(StandardCertificateCredentials)credentials;
    KeyStore keyStore=certificateCredentials.getKeyStore();
    String alias=keyStore.aliases().nextElement();
    X509Certificate certificate=(X509Certificate)keyStore.getCertificate(alias);
    Key key=keyStore.getKey(alias,Secret.toString(certificateCredentials.getPassword()).toCharArray());
    builder.withClientCertData(Base64.encodeBase64String(certificate.getEncoded())).withClientKeyData(pemEncodeKey(key)).withClientKeyPassphrase(Secret.toString(certificateCredentials.getPassword()));
  }
  if (skipTlsVerify) {
    builder.withTrustCerts(true);
  }
  if (caCertData != null) {
    builder.withCaCertData(Base64.encodeBase64String(caCertData.getBytes(UTF_8)));
  }
  LOGGER.log(Level.FINE,""String_Node_Str"",this.toString());
  return new DefaultKubernetesClient(builder.build());
}"
41312,"@DataBoundSetter public void setEnvVars(List<PodEnvVar> envVars){
  if (envVars != null) {
    this.envVars=new ArrayList<PodEnvVar>();
    this.addEnvVars(envVars);
  }
}","@DataBoundSetter public void setEnvVars(List<PodEnvVar> envVars){
  if (envVars != null) {
    this.envVars.clear();
    this.addEnvVars(envVars);
  }
}"
41313,"@DataBoundSetter public void setImagePullSecrets(List<PodImagePullSecret> imagePullSecrets){
  if (imagePullSecrets != null) {
    this.imagePullSecrets=new ArrayList<PodImagePullSecret>();
    this.addImagePullSecrets(imagePullSecrets);
  }
}","@DataBoundSetter public void setImagePullSecrets(List<PodImagePullSecret> imagePullSecrets){
  if (imagePullSecrets != null) {
    this.imagePullSecrets.clear();
    this.addImagePullSecrets(imagePullSecrets);
  }
}"
41314,"@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      if (!waitUntilContainerIsReady()) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      final CountDownLatch started=new CountDownLatch(1);
      final CountDownLatch finished=new CountDownLatch(1);
      final AtomicBoolean alive=new AtomicBoolean(false);
      PrintStream printStream=launcher.getListener().getLogger();
      OutputStream stream=printStream;
      if (starter.quiet()) {
        stream=new NullOutputStream();
        printStream=new PrintStream(stream);
      }
      ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
      stream=new TeeOutputStream(exitCodeOutputStream,stream);
      String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
      LOGGER.log(Level.FINEST,msg);
      printStream.println(msg);
      watch=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        Throwable t,        Response response){
          alive.set(false);
          t.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.SEVERE,""String_Node_Str"");
          }
          finished.countDown();
        }
      }
).exec();
      waitQuietly(started);
      if (starter.pwd() != null) {
        watch.getInput().write(String.format(""String_Node_Str"",starter.pwd(),NEWLINE).getBytes(StandardCharsets.UTF_8));
      }
      doExec(watch,printStream,getCommands(starter));
      proc=new ContainerExecProc(watch,alive,finished,new Callable<Integer>(){
        @Override public Integer call(){
          return exitCodeOutputStream.getExitCode();
        }
      }
);
      return proc;
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      ContainerExecDecorator.this.close();
    }
    private boolean isContainerReady(    Pod pod,    String container){
      if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
        return false;
      }
      for (      ContainerStatus info : pod.getStatus().getContainerStatuses()) {
        if (info.getName().equals(container) && info.getReady()) {
          return true;
        }
      }
      return false;
    }
    private boolean waitUntilContainerIsReady(){
      int i=0;
      int j=10;
      Pod pod=client.pods().inNamespace(namespace).withName(podName).get();
      if (pod == null) {
        launcher.getListener().getLogger().println(""String_Node_Str"" + podName + ""String_Node_Str"");
        for (; i < j; i++) {
          LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
          pod=client.pods().inNamespace(namespace).withName(podName).get();
          if (pod != null) {
            break;
          }
          LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
          try {
            Thread.sleep(6000);
          }
 catch (          InterruptedException e) {
            return false;
          }
        }
      }
      if (pod == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      }
      if (isContainerReady(pod,containerName)) {
        return true;
      }
      launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      final CountDownLatch latch=new CountDownLatch(1);
      Watcher<Pod> podWatcher=new Watcher<Pod>(){
        @Override public void eventReceived(        Action action,        Pod resource){
switch (action) {
case MODIFIED:
            if (isContainerReady(resource,containerName)) {
              latch.countDown();
            }
          break;
default :
      }
    }
    @Override public void onClose(    KubernetesClientException cause){
    }
  }
;
  try (Watch watch=client.pods().inNamespace(namespace).withName(podName).watch(podWatcher)){
    if (latch.await(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES)) {
      return true;
    }
  }
 catch (  InterruptedException e) {
    return false;
  }
  return false;
}
}
;
}","@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      if (!waitUntilContainerIsReady()) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      final CountDownLatch started=new CountDownLatch(1);
      final CountDownLatch finished=new CountDownLatch(1);
      final AtomicBoolean alive=new AtomicBoolean(false);
      PrintStream printStream=launcher.getListener().getLogger();
      OutputStream stream=printStream;
      if (starter.quiet()) {
        stream=new NullOutputStream();
        printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
      }
      ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
      stream=new TeeOutputStream(exitCodeOutputStream,stream);
      String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
      LOGGER.log(Level.FINEST,msg);
      printStream.println(msg);
      watch=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        Throwable t,        Response response){
          alive.set(false);
          t.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.WARNING,""String_Node_Str"");
          }
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
          if (finished.getCount() == 0) {
            LOGGER.log(Level.SEVERE,""String_Node_Str"");
          }
          finished.countDown();
        }
      }
).exec();
      waitQuietly(started);
      if (starter.pwd() != null) {
        watch.getInput().write(String.format(""String_Node_Str"",starter.pwd(),NEWLINE).getBytes(StandardCharsets.UTF_8));
      }
      doExec(watch,printStream,getCommands(starter));
      proc=new ContainerExecProc(watch,alive,finished,new Callable<Integer>(){
        @Override public Integer call(){
          return exitCodeOutputStream.getExitCode();
        }
      }
);
      return proc;
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      ContainerExecDecorator.this.close();
    }
    private boolean isContainerReady(    Pod pod,    String container){
      if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
        return false;
      }
      for (      ContainerStatus info : pod.getStatus().getContainerStatuses()) {
        if (info.getName().equals(container) && info.getReady()) {
          return true;
        }
      }
      return false;
    }
    private boolean waitUntilContainerIsReady(){
      int i=0;
      int j=10;
      Pod pod=client.pods().inNamespace(namespace).withName(podName).get();
      if (pod == null) {
        launcher.getListener().getLogger().println(""String_Node_Str"" + podName + ""String_Node_Str"");
        for (; i < j; i++) {
          LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
          pod=client.pods().inNamespace(namespace).withName(podName).get();
          if (pod != null) {
            break;
          }
          LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
          try {
            Thread.sleep(6000);
          }
 catch (          InterruptedException e) {
            return false;
          }
        }
      }
      if (pod == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      }
      if (isContainerReady(pod,containerName)) {
        return true;
      }
      launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      final CountDownLatch latch=new CountDownLatch(1);
      Watcher<Pod> podWatcher=new Watcher<Pod>(){
        @Override public void eventReceived(        Action action,        Pod resource){
switch (action) {
case MODIFIED:
            if (isContainerReady(resource,containerName)) {
              latch.countDown();
            }
          break;
default :
        break;
    }
  }
  @Override public void onClose(  KubernetesClientException cause){
  }
}
;
try (Watch watch=client.pods().inNamespace(namespace).withName(podName).watch(podWatcher)){
  if (latch.await(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES)) {
    return true;
  }
}
 catch (InterruptedException e) {
  return false;
}
return false;
}
}
;
}"
41315,"private boolean waitUntilContainerIsReady(){
  int i=0;
  int j=10;
  Pod pod=client.pods().inNamespace(namespace).withName(podName).get();
  if (pod == null) {
    launcher.getListener().getLogger().println(""String_Node_Str"" + podName + ""String_Node_Str"");
    for (; i < j; i++) {
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
      pod=client.pods().inNamespace(namespace).withName(podName).get();
      if (pod != null) {
        break;
      }
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
      try {
        Thread.sleep(6000);
      }
 catch (      InterruptedException e) {
        return false;
      }
    }
  }
  if (pod == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
  }
  if (isContainerReady(pod,containerName)) {
    return true;
  }
  launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  Watcher<Pod> podWatcher=new Watcher<Pod>(){
    @Override public void eventReceived(    Action action,    Pod resource){
switch (action) {
case MODIFIED:
        if (isContainerReady(resource,containerName)) {
          latch.countDown();
        }
      break;
default :
  }
}
@Override public void onClose(KubernetesClientException cause){
}
}
;
try (Watch watch=client.pods().inNamespace(namespace).withName(podName).watch(podWatcher)){
if (latch.await(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES)) {
  return true;
}
}
 catch (InterruptedException e) {
return false;
}
return false;
}","private boolean waitUntilContainerIsReady(){
  int i=0;
  int j=10;
  Pod pod=client.pods().inNamespace(namespace).withName(podName).get();
  if (pod == null) {
    launcher.getListener().getLogger().println(""String_Node_Str"" + podName + ""String_Node_Str"");
    for (; i < j; i++) {
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
      pod=client.pods().inNamespace(namespace).withName(podName).get();
      if (pod != null) {
        break;
      }
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podName,i,j});
      try {
        Thread.sleep(6000);
      }
 catch (      InterruptedException e) {
        return false;
      }
    }
  }
  if (pod == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
  }
  if (isContainerReady(pod,containerName)) {
    return true;
  }
  launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  Watcher<Pod> podWatcher=new Watcher<Pod>(){
    @Override public void eventReceived(    Action action,    Pod resource){
switch (action) {
case MODIFIED:
        if (isContainerReady(resource,containerName)) {
          latch.countDown();
        }
      break;
default :
    break;
}
}
@Override public void onClose(KubernetesClientException cause){
}
}
;
try (Watch watch=client.pods().inNamespace(namespace).withName(podName).watch(podWatcher)){
if (latch.await(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES)) {
return true;
}
}
 catch (InterruptedException e) {
return false;
}
return false;
}"
41316,"@Override public Proc launch(ProcStarter starter) throws IOException {
  if (!waitUntilContainerIsReady()) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  final CountDownLatch started=new CountDownLatch(1);
  final CountDownLatch finished=new CountDownLatch(1);
  final AtomicBoolean alive=new AtomicBoolean(false);
  PrintStream printStream=launcher.getListener().getLogger();
  OutputStream stream=printStream;
  if (starter.quiet()) {
    stream=new NullOutputStream();
    printStream=new PrintStream(stream);
  }
  ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
  stream=new TeeOutputStream(exitCodeOutputStream,stream);
  String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
  LOGGER.log(Level.FINEST,msg);
  printStream.println(msg);
  watch=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
    @Override public void onOpen(    Response response){
      alive.set(true);
      started.countDown();
    }
    @Override public void onFailure(    Throwable t,    Response response){
      alive.set(false);
      t.printStackTrace(launcher.getListener().getLogger());
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.WARNING,""String_Node_Str"");
      }
      finished.countDown();
    }
    @Override public void onClose(    int i,    String s){
      alive.set(false);
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.SEVERE,""String_Node_Str"");
      }
      finished.countDown();
    }
  }
).exec();
  waitQuietly(started);
  if (starter.pwd() != null) {
    watch.getInput().write(String.format(""String_Node_Str"",starter.pwd(),NEWLINE).getBytes(StandardCharsets.UTF_8));
  }
  doExec(watch,printStream,getCommands(starter));
  proc=new ContainerExecProc(watch,alive,finished,new Callable<Integer>(){
    @Override public Integer call(){
      return exitCodeOutputStream.getExitCode();
    }
  }
);
  return proc;
}","@Override public Proc launch(ProcStarter starter) throws IOException {
  if (!waitUntilContainerIsReady()) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  final CountDownLatch started=new CountDownLatch(1);
  final CountDownLatch finished=new CountDownLatch(1);
  final AtomicBoolean alive=new AtomicBoolean(false);
  PrintStream printStream=launcher.getListener().getLogger();
  OutputStream stream=printStream;
  if (starter.quiet()) {
    stream=new NullOutputStream();
    printStream=new PrintStream(stream,false,StandardCharsets.UTF_8.toString());
  }
  ExitCodeOutputStream exitCodeOutputStream=new ExitCodeOutputStream();
  stream=new TeeOutputStream(exitCodeOutputStream,stream);
  String msg=""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"";
  LOGGER.log(Level.FINEST,msg);
  printStream.println(msg);
  watch=client.pods().inNamespace(namespace).withName(podName).inContainer(containerName).redirectingInput().writingOutput(stream).writingError(stream).withTTY().usingListener(new ExecListener(){
    @Override public void onOpen(    Response response){
      alive.set(true);
      started.countDown();
    }
    @Override public void onFailure(    Throwable t,    Response response){
      alive.set(false);
      t.printStackTrace(launcher.getListener().getLogger());
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.WARNING,""String_Node_Str"");
      }
      finished.countDown();
    }
    @Override public void onClose(    int i,    String s){
      alive.set(false);
      started.countDown();
      LOGGER.log(Level.FINEST,""String_Node_Str"",finished);
      if (finished.getCount() == 0) {
        LOGGER.log(Level.SEVERE,""String_Node_Str"");
      }
      finished.countDown();
    }
  }
).exec();
  waitQuietly(started);
  if (starter.pwd() != null) {
    watch.getInput().write(String.format(""String_Node_Str"",starter.pwd(),NEWLINE).getBytes(StandardCharsets.UTF_8));
  }
  doExec(watch,printStream,getCommands(starter));
  proc=new ContainerExecProc(watch,alive,finished,new Callable<Integer>(){
    @Override public Integer call(){
      return exitCodeOutputStream.getExitCode();
    }
  }
);
  return proc;
}"
41317,"@Override public void write(int b) throws IOException {
  queue.add(b);
  byte[] bb=new byte[]{(byte)b};
  System.out.print(new String(bb));
}","@Override public void write(int b) throws IOException {
  queue.add(b);
  byte[] bb=new byte[]{(byte)b};
  System.out.print(new String(bb,StandardCharsets.UTF_8));
}"
41318,"@Override public void eventReceived(Action action,Pod resource){
switch (action) {
case MODIFIED:
    if (isContainerReady(resource,containerName)) {
      latch.countDown();
    }
  break;
default :
}
}","@Override public void eventReceived(Action action,Pod resource){
switch (action) {
case MODIFIED:
    if (isContainerReady(resource,containerName)) {
      latch.countDown();
    }
  break;
default :
break;
}
}"
41319,"@DataBoundSetter public void setIdleMinutes(int instanceCap){
  this.idleMinutes=idleMinutes;
}","@DataBoundSetter public void setIdleMinutes(int idleMinutes){
  this.idleMinutes=idleMinutes;
}"
41320,"@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      if (!waitUntilContainerIsReady()) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      watch=client.pods().withName(podName).inContainer(containerName).redirectingInput().writingOutput(launcher.getListener().getLogger()).writingError(launcher.getListener().getLogger()).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        IOException e,        Response response){
          alive.set(false);
          e.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          finished.countDown();
        }
      }
).exec();
      waitQuietly(started);
      watch.getInput().write((""String_Node_Str"" + path + NEWLINE).getBytes(StandardCharsets.UTF_8));
      doExec(watch,launcher.getListener().getLogger(),getCommands(starter));
      proc=new ContainerExecProc(watch,alive,finished);
      return proc;
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      ContainerExecDecorator.this.close();
    }
    private boolean isContainerReady(    Pod pod,    String container){
      if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
        return false;
      }
      for (      ContainerStatus info : pod.getStatus().getContainerStatuses()) {
        if (info.getName().equals(container) && info.getReady()) {
          return true;
        }
      }
      return false;
    }
    private boolean waitUntilContainerIsReady(){
      Pod pod=client.pods().withName(podName).get();
      if (pod == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      }
      if (isContainerReady(pod,containerName)) {
        return true;
      }
      launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      final CountDownLatch latch=new CountDownLatch(1);
      Watcher<Pod> podWatcher=new Watcher<Pod>(){
        @Override public void eventReceived(        Action action,        Pod resource){
switch (action) {
case MODIFIED:
            if (isContainerReady(resource,containerName)) {
              latch.countDown();
            }
          break;
default :
      }
    }
    @Override public void onClose(    KubernetesClientException cause){
    }
  }
;
  try (Watch watch=client.pods().withName(podName).watch(podWatcher)){
    if (latch.await(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES)) {
      return true;
    }
  }
 catch (  InterruptedException e) {
    return false;
  }
  return false;
}
}
;
}","@Override public Launcher decorate(final Launcher launcher,final Node node){
  return new Launcher.DecoratedLauncher(launcher){
    @Override public Proc launch(    ProcStarter starter) throws IOException {
      if (!waitUntilContainerIsReady()) {
        throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      watch=client.pods().withName(podName).inContainer(containerName).redirectingInput().writingOutput(launcher.getListener().getLogger()).writingError(launcher.getListener().getLogger()).withTTY().usingListener(new ExecListener(){
        @Override public void onOpen(        Response response){
          alive.set(true);
          started.countDown();
        }
        @Override public void onFailure(        IOException e,        Response response){
          alive.set(false);
          e.printStackTrace(launcher.getListener().getLogger());
          started.countDown();
          finished.countDown();
        }
        @Override public void onClose(        int i,        String s){
          alive.set(false);
          started.countDown();
          finished.countDown();
        }
      }
).exec();
      waitQuietly(started);
      watch.getInput().write(String.format(""String_Node_Str"",path,NEWLINE).getBytes(StandardCharsets.UTF_8));
      doExec(watch,launcher.getListener().getLogger(),getCommands(starter));
      proc=new ContainerExecProc(watch,alive,finished);
      return proc;
    }
    @Override public void kill(    Map<String,String> modelEnvVars) throws IOException, InterruptedException {
      getListener().getLogger().println(""String_Node_Str"");
      ContainerExecDecorator.this.close();
    }
    private boolean isContainerReady(    Pod pod,    String container){
      if (pod == null || pod.getStatus() == null || pod.getStatus().getContainerStatuses() == null) {
        return false;
      }
      for (      ContainerStatus info : pod.getStatus().getContainerStatuses()) {
        if (info.getName().equals(container) && info.getReady()) {
          return true;
        }
      }
      return false;
    }
    private boolean waitUntilContainerIsReady(){
      Pod pod=client.pods().withName(podName).get();
      if (pod == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      }
      if (isContainerReady(pod,containerName)) {
        return true;
      }
      launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
      final CountDownLatch latch=new CountDownLatch(1);
      Watcher<Pod> podWatcher=new Watcher<Pod>(){
        @Override public void eventReceived(        Action action,        Pod resource){
switch (action) {
case MODIFIED:
            if (isContainerReady(resource,containerName)) {
              latch.countDown();
            }
          break;
default :
      }
    }
    @Override public void onClose(    KubernetesClientException cause){
    }
  }
;
  try (Watch watch=client.pods().withName(podName).watch(podWatcher)){
    if (latch.await(CONTAINER_READY_TIMEOUT,TimeUnit.MINUTES)) {
      return true;
    }
  }
 catch (  InterruptedException e) {
    return false;
  }
  return false;
}
}
;
}"
41321,"@Override public Proc launch(ProcStarter starter) throws IOException {
  if (!waitUntilContainerIsReady()) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
  watch=client.pods().withName(podName).inContainer(containerName).redirectingInput().writingOutput(launcher.getListener().getLogger()).writingError(launcher.getListener().getLogger()).withTTY().usingListener(new ExecListener(){
    @Override public void onOpen(    Response response){
      alive.set(true);
      started.countDown();
    }
    @Override public void onFailure(    IOException e,    Response response){
      alive.set(false);
      e.printStackTrace(launcher.getListener().getLogger());
      started.countDown();
      finished.countDown();
    }
    @Override public void onClose(    int i,    String s){
      alive.set(false);
      started.countDown();
      finished.countDown();
    }
  }
).exec();
  waitQuietly(started);
  watch.getInput().write((""String_Node_Str"" + path + NEWLINE).getBytes(StandardCharsets.UTF_8));
  doExec(watch,launcher.getListener().getLogger(),getCommands(starter));
  proc=new ContainerExecProc(watch,alive,finished);
  return proc;
}","@Override public Proc launch(ProcStarter starter) throws IOException {
  if (!waitUntilContainerIsReady()) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  launcher.getListener().getLogger().println(""String_Node_Str"" + containerName + ""String_Node_Str""+ podName+ ""String_Node_Str"");
  watch=client.pods().withName(podName).inContainer(containerName).redirectingInput().writingOutput(launcher.getListener().getLogger()).writingError(launcher.getListener().getLogger()).withTTY().usingListener(new ExecListener(){
    @Override public void onOpen(    Response response){
      alive.set(true);
      started.countDown();
    }
    @Override public void onFailure(    IOException e,    Response response){
      alive.set(false);
      e.printStackTrace(launcher.getListener().getLogger());
      started.countDown();
      finished.countDown();
    }
    @Override public void onClose(    int i,    String s){
      alive.set(false);
      started.countDown();
      finished.countDown();
    }
  }
).exec();
  waitQuietly(started);
  watch.getInput().write(String.format(""String_Node_Str"",path,NEWLINE).getBytes(StandardCharsets.UTF_8));
  doExec(watch,launcher.getListener().getLogger(),getCommands(starter));
  proc=new ContainerExecProc(watch,alive,finished);
  return proc;
}"
41322,"@BeforeClass public static void configureCloud() throws Exception {
  assumeMiniKube();
  cloud.setServerUrl(miniKubeUrl().toExternalForm());
  cloud.setNamespace(""String_Node_Str"");
  cloud.connect();
}","private void configureCloud(JenkinsRuleNonLocalhost r) throws Exception {
  URL url=r.getURL();
  URL nonLocalhostUrl=new URL(url.getProtocol(),InetAddress.getLocalHost().getHostAddress(),url.getPort(),url.getFile());
  JenkinsLocationConfiguration.get().setUrl(nonLocalhostUrl.toString());
  r.jenkins.clouds.add(cloud);
}"
41323,"@Test public void runInPod() throws Exception {
  URL url=r.getURL();
  URL nonLocalhostUrl=new URL(url.getProtocol(),InetAddress.getLocalHost().getHostAddress(),url.getPort(),url.getFile());
  JenkinsLocationConfiguration.get().setUrl(nonLocalhostUrl.toString());
  r.jenkins.clouds.add(cloud);
  WorkflowJob p=r.jenkins.createProject(WorkflowJob.class,""String_Node_Str"");
  p.setDefinition(new CpsFlowDefinition(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",true));
  WorkflowRun b=p.scheduleBuild2(0).waitForStart();
  assertNotNull(b);
  r.assertBuildStatusSuccess(r.waitForCompletion(b));
  r.assertLogContains(""String_Node_Str"",b);
  r.assertLogContains(""String_Node_Str"",b);
  r.assertLogContains(""String_Node_Str"",b);
}","@Test public void runInPod() throws Exception {
  configureCloud(r);
  WorkflowJob p=r.jenkins.createProject(WorkflowJob.class,""String_Node_Str"");
  p.setDefinition(new CpsFlowDefinition(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",true));
  WorkflowRun b=p.scheduleBuild2(0).waitForStart();
  assertNotNull(b);
  r.assertBuildStatusSuccess(r.waitForCompletion(b));
  r.assertLogContains(""String_Node_Str"",b);
  r.assertLogContains(""String_Node_Str"",b);
  r.assertLogContains(""String_Node_Str"",b);
}"
41324,"/** 
 * Connects to Docker.
 * @return Docker client.
 * @throws CertificateEncodingException
 */
public KubernetesClient connect() throws UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException, IOException, CertificateEncodingException {
  LOGGER.log(Level.FINE,""String_Node_Str"" + name + ""String_Node_Str""+ serverUrl);
  if (client == null) {
synchronized (this) {
      if (client != null)       return client;
      client=new KubernetesFactoryAdapter(serverUrl,serverCertificate,credentialsId,skipTlsVerify).createClient();
    }
  }
  return client;
}","/** 
 * Connects to Kubernetes.
 * @return Kubernetes client.
 */
@SuppressFBWarnings({""String_Node_Str"",""String_Node_Str""}) public KubernetesClient connect() throws UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException, IOException, CertificateEncodingException {
  LOGGER.log(Level.FINE,""String_Node_Str"" + name + ""String_Node_Str""+ serverUrl);
  if (client == null) {
synchronized (this) {
      if (client == null) {
        client=new KubernetesFactoryAdapter(serverUrl,serverCertificate,credentialsId,skipTlsVerify).createClient();
      }
    }
  }
  return client;
}"
41325,"private Pod getPodTemplate(KubernetesSlave slave,Label label){
  final PodTemplate template=getTemplate(label);
  String id=getIdForLabel(label);
  List<EnvVar> env=new ArrayList<EnvVar>(3);
  env.add(new EnvVar(""String_Node_Str"",slave.getComputer().getJnlpMac(),null));
  env.add(new EnvVar(""String_Node_Str"",JenkinsLocationConfiguration.get().getUrl(),null));
  String url=StringUtils.isBlank(jenkinsUrl) ? JenkinsLocationConfiguration.get().getUrl() : jenkinsUrl;
  env.add(new EnvVar(""String_Node_Str"",url,null));
  if (!StringUtils.isBlank(jenkinsTunnel)) {
    env.add(new EnvVar(""String_Node_Str"",jenkinsTunnel,null));
  }
  url=url.endsWith(""String_Node_Str"") ? url : url + ""String_Node_Str"";
  env.add(new EnvVar(""String_Node_Str"",url + slave.getComputer().getUrl() + ""String_Node_Str"",null));
  if (template.getEnvVars() != null) {
    for (    PodEnvVar podEnvVar : template.getEnvVars()) {
      env.add(new EnvVar(podEnvVar.getKey(),podEnvVar.getValue(),null));
    }
  }
  env.add(new EnvVar(""String_Node_Str"",template.getRemoteFs(),null));
  List<Volume> volumes=new ArrayList<Volume>();
  List<VolumeMount> volumeMounts=new ArrayList<VolumeMount>();
{
    int i=0;
    for (    final PodVolumes.PodVolume volume : template.getVolumes()) {
      final String volumeName=""String_Node_Str"" + i;
      volumes.add(volume.buildVolume(volumeName));
      volumeMounts.add(new VolumeMount(volume.getMountPath(),volumeName,false));
      i++;
    }
  }
  List<LocalObjectReference> imagePullSecrets=new ArrayList<LocalObjectReference>();
  if (template.getImagePullSecrets() != null) {
    for (    PodImagePullSecret podImagePullSecret : template.getImagePullSecrets()) {
      imagePullSecrets.add(new LocalObjectReference(podImagePullSecret.getName()));
    }
  }
  return new PodBuilder().withNewMetadata().withName(slave.getNodeName()).withLabels(getLabelsFor(id)).withAnnotations(getAnnotationsMap(template.getAnnotations())).endMetadata().withNewSpec().withVolumes(volumes).withServiceAccount(template.getServiceAccount()).withImagePullSecrets(imagePullSecrets).addNewContainer().withName(CONTAINER_NAME).withImage(template.getImage()).withImagePullPolicy(template.isAlwaysPullImage() ? ""String_Node_Str"" : ""String_Node_Str"").withNewSecurityContext().withPrivileged(template.isPrivileged()).endSecurityContext().withWorkingDir(template.getRemoteFs()).withVolumeMounts(volumeMounts).withEnv(env).withCommand(parseDockerCommand(template.getCommand())).withNewResources().withRequests(getResourcesMap(template.getResourceRequestMemory(),template.getResourceRequestCpu())).withLimits(getResourcesMap(template.getResourceLimitMemory(),template.getResourceLimitCpu())).endResources().addToArgs(slave.getComputer().getJnlpMac()).addToArgs(slave.getComputer().getName()).endContainer().withNodeSelector(getNodeSelectorMap(template.getNodeSelector())).withRestartPolicy(""String_Node_Str"").endSpec().build();
}","private Pod getPodTemplate(KubernetesSlave slave,Label label){
  final PodTemplate template=getTemplate(label);
  String id=getIdForLabel(label);
  List<EnvVar> env=new ArrayList<EnvVar>(3);
  env.add(new EnvVar(""String_Node_Str"",slave.getComputer().getJnlpMac(),null));
  JenkinsLocationConfiguration locationConfiguration=JenkinsLocationConfiguration.get();
  String locationConfigurationUrl=locationConfiguration != null ? locationConfiguration.getUrl() : null;
  env.add(new EnvVar(""String_Node_Str"",locationConfigurationUrl,null));
  String url=StringUtils.isBlank(jenkinsUrl) ? locationConfigurationUrl : jenkinsUrl;
  env.add(new EnvVar(""String_Node_Str"",url,null));
  if (!StringUtils.isBlank(jenkinsTunnel)) {
    env.add(new EnvVar(""String_Node_Str"",jenkinsTunnel,null));
  }
  if (url == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  url=url.endsWith(""String_Node_Str"") ? url : url + ""String_Node_Str"";
  env.add(new EnvVar(""String_Node_Str"",url + slave.getComputer().getUrl() + ""String_Node_Str"",null));
  if (template.getEnvVars() != null) {
    for (    PodEnvVar podEnvVar : template.getEnvVars()) {
      env.add(new EnvVar(podEnvVar.getKey(),podEnvVar.getValue(),null));
    }
  }
  env.add(new EnvVar(""String_Node_Str"",template.getRemoteFs(),null));
  List<Volume> volumes=new ArrayList<Volume>();
  List<VolumeMount> volumeMounts=new ArrayList<VolumeMount>();
{
    int i=0;
    for (    final PodVolumes.PodVolume volume : template.getVolumes()) {
      final String volumeName=""String_Node_Str"" + i;
      volumes.add(volume.buildVolume(volumeName));
      volumeMounts.add(new VolumeMount(volume.getMountPath(),volumeName,false));
      i++;
    }
  }
  List<LocalObjectReference> imagePullSecrets=new ArrayList<LocalObjectReference>();
  if (template.getImagePullSecrets() != null) {
    for (    PodImagePullSecret podImagePullSecret : template.getImagePullSecrets()) {
      imagePullSecrets.add(new LocalObjectReference(podImagePullSecret.getName()));
    }
  }
  return new PodBuilder().withNewMetadata().withName(slave.getNodeName()).withLabels(getLabelsFor(id)).withAnnotations(getAnnotationsMap(template.getAnnotations())).endMetadata().withNewSpec().withVolumes(volumes).withServiceAccount(template.getServiceAccount()).withImagePullSecrets(imagePullSecrets).addNewContainer().withName(CONTAINER_NAME).withImage(template.getImage()).withImagePullPolicy(template.isAlwaysPullImage() ? ""String_Node_Str"" : ""String_Node_Str"").withNewSecurityContext().withPrivileged(template.isPrivileged()).endSecurityContext().withWorkingDir(template.getRemoteFs()).withVolumeMounts(volumeMounts).withEnv(env).withCommand(parseDockerCommand(template.getCommand())).withNewResources().withRequests(getResourcesMap(template.getResourceRequestMemory(),template.getResourceRequestCpu())).withLimits(getResourcesMap(template.getResourceLimitMemory(),template.getResourceLimitCpu())).endResources().addToArgs(slave.getComputer().getJnlpMac()).addToArgs(slave.getComputer().getName()).endContainer().withNodeSelector(getNodeSelectorMap(template.getNodeSelector())).withRestartPolicy(""String_Node_Str"").endSpec().build();
}"
41326,"public Node call() throws Exception {
  KubernetesSlave slave=null;
  try {
    slave=new KubernetesSlave(t,getIdForLabel(label),cloud,label);
    Jenkins.getInstance().addNode(slave);
    Pod pod=getPodTemplate(slave,label);
    pod=connect().pods().inNamespace(namespace).create(pod);
    String podId=pod.getMetadata().getName();
    LOGGER.log(Level.INFO,""String_Node_Str"",podId);
    ImmutableList<String> validStates=ImmutableList.of(""String_Node_Str"");
    int i=0;
    int j=100;
    for (; i < j; i++) {
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,i,j});
      Thread.sleep(6000);
      pod=connect().pods().inNamespace(namespace).withName(podId).get();
      if (pod == null) {
        throw new IllegalStateException(""String_Node_Str"" + podId);
      }
      ContainerStatus info=getContainerStatus(pod,CONTAINER_NAME);
      if (info != null) {
        if (info.getState().getWaiting() != null) {
          LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,info.getState().getWaiting()});
        }
        if (info.getState().getTerminated() != null) {
          throw new IllegalStateException(""String_Node_Str"" + info.getState().getTerminated().getExitCode());
        }
      }
      if (validStates.contains(pod.getStatus().getPhase())) {
        break;
      }
    }
    String status=pod.getStatus().getPhase();
    if (!validStates.contains(status)) {
      throw new IllegalStateException(""String_Node_Str"" + j + ""String_Node_Str""+ status);
    }
    for (; i < j; i++) {
      if (slave.getComputer() == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      if (slave.getComputer().isOnline()) {
        break;
      }
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,i,j});
      Thread.sleep(1000);
    }
    if (!slave.getComputer().isOnline()) {
      throw new IllegalStateException(""String_Node_Str"" + j + ""String_Node_Str""+ status);
    }
    return slave;
  }
 catch (  Throwable ex) {
    LOGGER.log(Level.SEVERE,""String_Node_Str"",new Object[]{slave,t});
    ex.printStackTrace();
    throw Throwables.propagate(ex);
  }
}","public Node call() throws Exception {
  KubernetesSlave slave=null;
  try {
    slave=new KubernetesSlave(t,getIdForLabel(label),cloud,label);
    Jenkins.getActiveInstance().addNode(slave);
    Pod pod=getPodTemplate(slave,label);
    pod=connect().pods().inNamespace(namespace).create(pod);
    String podId=pod.getMetadata().getName();
    LOGGER.log(Level.INFO,""String_Node_Str"",podId);
    ImmutableList<String> validStates=ImmutableList.of(""String_Node_Str"");
    int i=0;
    int j=100;
    for (; i < j; i++) {
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,i,j});
      Thread.sleep(6000);
      pod=connect().pods().inNamespace(namespace).withName(podId).get();
      if (pod == null) {
        throw new IllegalStateException(""String_Node_Str"" + podId);
      }
      ContainerStatus info=getContainerStatus(pod,CONTAINER_NAME);
      if (info != null) {
        if (info.getState().getWaiting() != null) {
          LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,info.getState().getWaiting()});
        }
        if (info.getState().getTerminated() != null) {
          throw new IllegalStateException(""String_Node_Str"" + info.getState().getTerminated().getExitCode());
        }
      }
      if (validStates.contains(pod.getStatus().getPhase())) {
        break;
      }
    }
    String status=pod.getStatus().getPhase();
    if (!validStates.contains(status)) {
      throw new IllegalStateException(""String_Node_Str"" + j + ""String_Node_Str""+ status);
    }
    for (; i < j; i++) {
      if (slave.getComputer() == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      if (slave.getComputer().isOnline()) {
        break;
      }
      LOGGER.log(Level.INFO,""String_Node_Str"",new Object[]{podId,i,j});
      Thread.sleep(1000);
    }
    if (!slave.getComputer().isOnline()) {
      throw new IllegalStateException(""String_Node_Str"" + j + ""String_Node_Str""+ status);
    }
    return slave;
  }
 catch (  Throwable ex) {
    LOGGER.log(Level.SEVERE,""String_Node_Str"",new Object[]{slave,t});
    ex.printStackTrace();
    throw Throwables.propagate(ex);
  }
}"
41327,"@Override public void taskCompleted(Executor executor,Queue.Task task,long durationMS){
  Queue.Executable executable=executor.getCurrentExecutable();
  LOGGER.log(Level.FINE,""String_Node_Str"" + this + ""String_Node_Str"");
  super.taskCompleted(executor,task,durationMS);
}","@Override public void taskCompleted(Executor executor,Queue.Task task,long durationMS){
  LOGGER.log(Level.FINE,""String_Node_Str"" + this + ""String_Node_Str"");
  super.taskCompleted(executor,task,durationMS);
}"
41328,"private static String pemEncodeKey(Key key){
  return Base64.encodeBase64String(new StringBuilder().append(""String_Node_Str"").append(Base64.encodeBase64String(key.getEncoded())).append(""String_Node_Str"").toString().getBytes());
}","private static String pemEncodeKey(Key key){
  return Base64.encodeBase64String(new StringBuilder().append(""String_Node_Str"").append(Base64.encodeBase64String(key.getEncoded())).append(""String_Node_Str"").toString().getBytes(StandardCharsets.UTF_8));
}"
41329,"@Override protected void _terminate(TaskListener listener) throws IOException, InterruptedException {
  LOGGER.log(Level.INFO,""String_Node_Str"",name);
  if (toComputer() == null) {
    LOGGER.log(Level.SEVERE,""String_Node_Str"",name);
    return;
  }
  try {
    cloud.connect().pods().inNamespace(cloud.getNamespace()).withName(name).delete();
    LOGGER.log(Level.INFO,""String_Node_Str"",name);
    toComputer().disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
    LOGGER.log(Level.INFO,""String_Node_Str"",name);
  }
 catch (  Exception e) {
    LOGGER.log(Level.SEVERE,""String_Node_Str"" + name,e);
  }
}","@Override protected void _terminate(TaskListener listener) throws IOException, InterruptedException {
  LOGGER.log(Level.INFO,""String_Node_Str"",name);
  Computer computer=toComputer();
  if (computer == null) {
    LOGGER.log(Level.SEVERE,""String_Node_Str"",name);
    return;
  }
  try {
    cloud.connect().pods().inNamespace(cloud.getNamespace()).withName(name).delete();
    LOGGER.log(Level.INFO,""String_Node_Str"",name);
    computer.disconnect(OfflineCause.create(new Localizable(HOLDER,""String_Node_Str"")));
    LOGGER.log(Level.INFO,""String_Node_Str"",name);
  }
 catch (  Exception e) {
    LOGGER.log(Level.SEVERE,""String_Node_Str"" + name,e);
  }
}"
41330,"private synchronized Token refreshToken(String serviceAddress,String caCertData,boolean skipTlsVerify) throws IOException {
  URI uri=null;
  try {
    uri=new URI(serviceAddress);
  }
 catch (  URISyntaxException e) {
    throw new IOException(""String_Node_Str"" + serviceAddress,e);
  }
  final HttpClientBuilder builder=HttpClients.custom().setRedirectStrategy(NO_REDIRECT);
  if (skipTlsVerify || caCertData != null) {
    final SSLContextBuilder sslBuilder=new SSLContextBuilder();
    HostnameVerifier hostnameVerifier=SSLConnectionSocketFactory.getDefaultHostnameVerifier();
    try {
      if (skipTlsVerify) {
        sslBuilder.loadTrustMaterial(null,ALWAYS);
        hostnameVerifier=NoopHostnameVerifier.INSTANCE;
      }
 else       if (caCertData != null) {
        KeyStore ks=KeyStore.getInstance(KeyStore.getDefaultType());
        ks.load(null);
        CertificateFactory f=CertificateFactory.getInstance(""String_Node_Str"");
        X509Certificate cert=(X509Certificate)f.generateCertificate(new Base64InputStream(new ByteArrayInputStream(caCertData.getBytes())));
        ks.setCertificateEntry(uri.getHost(),cert);
        sslBuilder.loadTrustMaterial(ks,null);
      }
      builder.setSSLSocketFactory(new SSLConnectionSocketFactory(sslBuilder.build(),hostnameVerifier));
    }
 catch (    NoSuchAlgorithmException e) {
      e.printStackTrace();
    }
catch (    KeyManagementException e) {
      e.printStackTrace();
    }
catch (    KeyStoreException e) {
      e.printStackTrace();
    }
catch (    CertificateException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
  }
  HttpGet authorize=new HttpGet(serviceAddress + ""String_Node_Str"");
  authorize.setHeader(""String_Node_Str"",""String_Node_Str"" + Base64.encodeBase64String((getUsername() + ':' + Secret.toString(getPassword())).getBytes()));
  final CloseableHttpResponse response=builder.build().execute(authorize);
  if (response.getStatusLine().getStatusCode() != 302) {
    throw new IOException(""String_Node_Str"" + response.getStatusLine().getStatusCode());
  }
  String location=response.getFirstHeader(""String_Node_Str"").getValue();
  String parameters=location.substring(location.indexOf('#') + 1);
  List<NameValuePair> pairs=URLEncodedUtils.parse(parameters,Charset.forName(""String_Node_Str""));
  Token t=new Token();
  for (  NameValuePair pair : pairs) {
    if (pair.getName().equals(""String_Node_Str"")) {
      t.value=pair.getValue();
    }
 else     if (pair.getName().equals(""String_Node_Str"")) {
      t.expire=System.currentTimeMillis() + Long.parseLong(pair.getValue()) * 1000 - 100;
    }
  }
  return t;
}","private synchronized Token refreshToken(String serviceAddress,String caCertData,boolean skipTlsVerify) throws IOException {
  URI uri=null;
  try {
    uri=new URI(serviceAddress);
  }
 catch (  URISyntaxException e) {
    throw new IOException(""String_Node_Str"" + serviceAddress,e);
  }
  final HttpClientBuilder builder=HttpClients.custom().setRedirectStrategy(NO_REDIRECT);
  if (skipTlsVerify || caCertData != null) {
    final SSLContextBuilder sslBuilder=new SSLContextBuilder();
    HostnameVerifier hostnameVerifier=SSLConnectionSocketFactory.getDefaultHostnameVerifier();
    try {
      if (skipTlsVerify) {
        sslBuilder.loadTrustMaterial(null,ALWAYS);
        hostnameVerifier=NoopHostnameVerifier.INSTANCE;
      }
 else       if (caCertData != null) {
        KeyStore ks=KeyStore.getInstance(KeyStore.getDefaultType());
        ks.load(null);
        CertificateFactory f=CertificateFactory.getInstance(""String_Node_Str"");
        X509Certificate cert=(X509Certificate)f.generateCertificate(new Base64InputStream(new ByteArrayInputStream(caCertData.getBytes(StandardCharsets.UTF_8))));
        ks.setCertificateEntry(uri.getHost(),cert);
        sslBuilder.loadTrustMaterial(ks,null);
      }
      builder.setSSLSocketFactory(new SSLConnectionSocketFactory(sslBuilder.build(),hostnameVerifier));
    }
 catch (    NoSuchAlgorithmException e) {
      e.printStackTrace();
    }
catch (    KeyManagementException e) {
      e.printStackTrace();
    }
catch (    KeyStoreException e) {
      e.printStackTrace();
    }
catch (    CertificateException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
  }
  HttpGet authorize=new HttpGet(serviceAddress + ""String_Node_Str"");
  authorize.setHeader(""String_Node_Str"",""String_Node_Str"" + Base64.encodeBase64String((getUsername() + ':' + Secret.toString(getPassword())).getBytes(StandardCharsets.UTF_8)));
  final CloseableHttpResponse response=builder.build().execute(authorize);
  if (response.getStatusLine().getStatusCode() != 302) {
    throw new IOException(""String_Node_Str"" + response.getStatusLine().getStatusCode());
  }
  String location=response.getFirstHeader(""String_Node_Str"").getValue();
  String parameters=location.substring(location.indexOf('#') + 1);
  List<NameValuePair> pairs=URLEncodedUtils.parse(parameters,StandardCharsets.UTF_8);
  Token t=new Token();
  for (  NameValuePair pair : pairs) {
    if (pair.getName().equals(""String_Node_Str"")) {
      t.value=pair.getValue();
    }
 else     if (pair.getName().equals(""String_Node_Str"")) {
      t.expire=System.currentTimeMillis() + Long.parseLong(pair.getValue()) * 1000 - 100;
    }
  }
  return t;
}"
41331,"public DescriptorImpl(){
  if (!new File(""String_Node_Str"").exists()) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","@SuppressFBWarnings(""String_Node_Str"") public DescriptorImpl(){
  if (!new File(SERVICEACCOUNT_TOKEN_PATH).exists()) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
41332,"@Override public String getToken(String serviceAddress,String caCertData,boolean skipTlsVerify){
  try {
    return FileUtils.readFileToString(new File(""String_Node_Str""));
  }
 catch (  IOException e) {
    return null;
  }
}","@Override @SuppressFBWarnings(""String_Node_Str"") public String getToken(String serviceAddress,String caCertData,boolean skipTlsVerify){
  try {
    return FileUtils.readFileToString(new File(SERVICEACCOUNT_TOKEN_PATH));
  }
 catch (  IOException e) {
    return null;
  }
}"
41333,"@Override public boolean start() throws Exception {
  Cloud cloud=Jenkins.getInstance().getCloud(step.getCloud());
  if (cloud instanceof KubernetesCloud) {
    KubernetesCloud kubernetesCloud=(KubernetesCloud)cloud;
    PodTemplate newTemplate;
    String name=String.format(NAME_FORMAT,UUID.randomUUID().toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
    PodTemplate podTemplate=StringUtils.isBlank(step.getInheritFrom()) ? null : kubernetesCloud.getTemplate(Label.get(step.getInheritFrom()));
    if (podTemplate != null) {
      newTemplate=new PodTemplate(podTemplate);
      newTemplate.getContainers().addAll(step.getContainers());
      for (      PodVolumes.PodVolume volume : step.getVolumes()) {
        String mountPath=volume.getMountPath();
        if (!PodVolumes.podVolumeExists(mountPath,podTemplate.getVolumes())) {
          newTemplate.getVolumes().add(volume);
        }
      }
    }
 else {
      newTemplate=new PodTemplate();
      newTemplate.setVolumes(step.getVolumes());
      newTemplate.setContainers(step.getContainers());
    }
    newTemplate.setLabel(step.getLabel());
    newTemplate.setName(name);
    kubernetesCloud.addTemplate(newTemplate);
    getContext().newBodyInvoker().withCallback(new PodTemplateCallback(newTemplate)).start();
    return false;
  }
 else {
    getContext().onFailure(new IllegalStateException(""String_Node_Str"" + step.getCloud() + ""String_Node_Str""));
    return true;
  }
}","@Override public boolean start() throws Exception {
  Cloud cloud=Jenkins.getActiveInstance().getCloud(step.getCloud());
  if (cloud instanceof KubernetesCloud) {
    KubernetesCloud kubernetesCloud=(KubernetesCloud)cloud;
    PodTemplate newTemplate;
    String name=String.format(NAME_FORMAT,UUID.randomUUID().toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
    PodTemplate podTemplate=StringUtils.isBlank(step.getInheritFrom()) ? null : kubernetesCloud.getTemplate(Label.get(step.getInheritFrom()));
    if (podTemplate != null) {
      newTemplate=new PodTemplate(podTemplate);
      newTemplate.getContainers().addAll(step.getContainers());
      for (      PodVolumes.PodVolume volume : step.getVolumes()) {
        String mountPath=volume.getMountPath();
        if (!PodVolumes.podVolumeExists(mountPath,podTemplate.getVolumes())) {
          newTemplate.getVolumes().add(volume);
        }
      }
    }
 else {
      newTemplate=new PodTemplate();
      newTemplate.setVolumes(step.getVolumes());
      newTemplate.setContainers(step.getContainers());
    }
    newTemplate.setLabel(step.getLabel());
    newTemplate.setName(name);
    kubernetesCloud.addTemplate(newTemplate);
    getContext().newBodyInvoker().withCallback(new PodTemplateCallback(newTemplate)).start();
    return false;
  }
 else {
    getContext().onFailure(new IllegalStateException(""String_Node_Str"" + step.getCloud() + ""String_Node_Str""));
    return true;
  }
}"
41334,"@Override protected void finished(StepContext context) throws Exception {
  Cloud cloud=Jenkins.getInstance().getCloud(step.getCloud());
  if (cloud instanceof KubernetesCloud) {
    KubernetesCloud kubernetesCloud=(KubernetesCloud)cloud;
    kubernetesCloud.removeTemplate(podTemplate);
  }
}","@Override protected void finished(StepContext context) throws Exception {
  Cloud cloud=Jenkins.getActiveInstance().getCloud(step.getCloud());
  if (cloud instanceof KubernetesCloud) {
    KubernetesCloud kubernetesCloud=(KubernetesCloud)cloud;
    kubernetesCloud.removeTemplate(podTemplate);
  }
}"
41335,"static String getSlaveName(PodTemplate template){
  String hex=Long.toHexString(System.nanoTime());
  String name=template.getName();
  if (name == null) {
    return hex;
  }
  name=template.getName().replace(""String_Node_Str"",""String_Node_Str"").toLowerCase();
  name=name.substring(0,Math.min(name.length(),256 - hex.length()));
  return String.format(""String_Node_Str"",name,hex);
}","static String getSlaveName(PodTemplate template){
  String hex=Long.toHexString(System.nanoTime());
  String name=template.getName();
  if (StringUtils.isEmpty(name)) {
    return hex;
  }
  name=template.getName().replace(""String_Node_Str"",""String_Node_Str"").toLowerCase();
  name=name.substring(0,Math.min(name.length(),256 - hex.length()));
  return String.format(""String_Node_Str"",name,hex);
}"
41336,"@DataBoundConstructor public PodTemplate(String name,String image,List<? extends PodVolume> volumes){
  Preconditions.checkArgument(!StringUtils.isBlank(image));
  this.name=name;
  this.image=image;
  this.volumes=(volumes == null) ? new ArrayList<PodVolume>() : new ArrayList<PodVolume>(volumes);
}","PodTemplate(String name,String image,List<? extends PodVolume> volumes){
  Preconditions.checkArgument(!StringUtils.isBlank(image));
  this.name=name;
  this.image=image;
  this.volumes=(volumes == null) ? new ArrayList<PodVolume>() : new ArrayList<PodVolume>(volumes);
}"
41337,"@Test public void testGetSlaveName(){
  List<? extends PodVolume> volumes=Collections.emptyList();
  assertTrue(KubernetesSlave.getSlaveName(new PodTemplate(""String_Node_Str"",volumes)).matches(""String_Node_Str""));
  assertTrue(KubernetesSlave.getSlaveName(new PodTemplate(""String_Node_Str"",""String_Node_Str"",volumes)).matches(""String_Node_Str""));
}","@Test public void testGetSlaveName(){
  List<? extends PodVolume> volumes=Collections.emptyList();
  assertTrue(KubernetesSlave.getSlaveName(new PodTemplate(""String_Node_Str"",volumes)).matches(""String_Node_Str""));
  assertTrue(KubernetesSlave.getSlaveName(new PodTemplate(""String_Node_Str"",""String_Node_Str"",volumes)).matches(""String_Node_Str""));
  assertTrue(KubernetesSlave.getSlaveName(new PodTemplate(""String_Node_Str"",""String_Node_Str"",volumes)).matches(""String_Node_Str""));
}"
41338,"public FormValidation doTestConnection(@QueryParameter URL serverUrl,@QueryParameter String username,@QueryParameter String password) throws KubernetesClientException, URISyntaxException {
  RestFactory factory=new RestFactory(KubernetesCloud.class.getClassLoader());
  KubernetesAPIClientInterface client=new KubernetesApiClient(serverUrl.toString() + ""String_Node_Str"",username,password,factory);
  client.getAllPods();
  return FormValidation.ok(""String_Node_Str"");
}","public FormValidation doTestConnection(@QueryParameter URL serverUrl,@QueryParameter String username,@QueryParameter String password) throws KubernetesClientException, URISyntaxException {
  RestFactory factory=new RestFactory(KubernetesCloud.class.getClassLoader());
  KubernetesAPIClientInterface client=new KubernetesApiClient(serverUrl.toString(),username,password,factory);
  client.getAllPods();
  return FormValidation.ok(""String_Node_Str"");
}"
41339,"private String getControllerName(){
  String entry=form.getControllerName();
  if (null == entry || entry.isEmpty()) {
    return null;
  }
  if (entry.lastIndexOf('.') <= 0) {
    return entry;
  }
 else {
    return VerifyHelper.verifyClassName(entry.substring(entry.lastIndexOf('.') + 1));
  }
}","private String getControllerName(){
  String entry=form.getControllerName();
  if (null == entry || entry.isEmpty()) {
    return null;
  }
  String className=null;
  if (entry.lastIndexOf('.') <= 0) {
    className=entry;
  }
 else {
    className=VerifyHelper.verifyClassName(entry.substring(entry.lastIndexOf('.') + 1));
  }
  if (Character.isUpperCase(className.charAt(0))) {
    return className;
  }
 else {
    return (new StringBuilder()).append(Character.toUpperCase(className.charAt(0))).append(className.substring(1)).toString();
  }
}"
41340,"public String buildUrl(boolean isTemplatized){
  StringBuilder builder=new StringBuilder(base);
  for (  PathPart path : pathParts) {
    builder.append(""String_Node_Str"");
    if (isTemplatized) {
      builder.append(path.getTemplatizedPath());
    }
 else {
      builder.append(path.getPathValue());
    }
  }
  if (pathEndsWithSlash) {
    builder.append(""String_Node_Str"");
  }
  if (queries.size() > 0) {
    builder.append(""String_Node_Str"");
    for (    Query query : queries) {
      String queryString=query.getKey() + ""String_Node_Str"" + query.getValue()+ ""String_Node_Str"";
      builder.append(queryString);
    }
    if (queries.size() > 0) {
      builder.deleteCharAt(builder.length() - 1);
    }
  }
  Logger.info(getClass(),builder.toString());
  return builder.toString();
}","public String buildUrl(boolean isTemplatized){
  StringBuilder builder=new StringBuilder(base);
  for (  PathPart path : pathParts) {
    builder.append(""String_Node_Str"");
    if (isTemplatized) {
      builder.append(path.getTemplatizedPath());
    }
 else {
      builder.append(path.getEncodedValue());
    }
  }
  if (pathEndsWithSlash) {
    builder.append(""String_Node_Str"");
  }
  if (queries.size() > 0) {
    builder.append(""String_Node_Str"");
    for (    Query query : queries) {
      String queryString=query.getEncodedKey() + ""String_Node_Str"" + query.getEncodedValue()+ ""String_Node_Str"";
      builder.append(queryString);
    }
    if (queries.size() > 0) {
      builder.deleteCharAt(builder.length() - 1);
    }
  }
  Logger.info(getClass(),builder.toString());
  return builder.toString();
}"
41341,"public String getValue(){
  try {
    return java.net.URLEncoder.encode(value,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
catch (  NullPointerException ex) {
    ex.printStackTrace();
  }
  return null;
}","public String getValue(){
  return value;
}"
41342,"public PathPartPanel(PathParamCallBack callBack,PathPart pathPart){
  this.callBack=callBack;
  this.pathPart=pathPart;
  variableNameField.setText(pathPart.getVariableName());
  isVariableCheckBox.setSelected(pathPart.isTemplatized());
  this.pathPartField.setText(pathPart.getPathValue());
}","public PathPartPanel(PathParamCallBack callBack,PathPart pathPart){
  this.callBack=callBack;
  this.pathPart=pathPart;
  variableNameField.setText(pathPart.getVariableName());
  isVariableCheckBox.setSelected(pathPart.isTemplatized());
  this.pathPartField.setText(pathPart.getValue());
}"
41343,"public PathPart getPathPartField(){
  pathPart.setPathValue(this.pathPartField.getText());
  pathPart.setVariableName(variableNameField.getText());
  pathPart.setTemplatized(isVariableCheckBox.isSelected());
  return pathPart;
}","public PathPart getPathPartField(){
  pathPart.setValue(this.pathPartField.getText());
  pathPart.setVariableName(variableNameField.getText());
  pathPart.setTemplatized(isVariableCheckBox.isSelected());
  return pathPart;
}"
41344,"public void removeQueryParam(int index){
  queries.remove(index);
}","public void removeQueryParam(int index){
  if (index > -1 && index < queries.size()) {
    queries.remove(index);
  }
}"
41345,"public void removePathParam(int index){
  pathParts.remove(index);
}","public void removePathParam(int index){
  if (index > -1 && index < pathParts.size()) {
    pathParts.remove(index);
  }
}"
41346,"private void removeAllQueries(){
  for (  QueryPanel qp : queries) {
    deleted(qp);
  }
  queries.clear();
}","private void removeAllQueries(){
  for (  QueryPanel qp : new ArrayList<QueryPanel>(queries)) {
    deleted(qp);
  }
  queries.clear();
}"
41347,"private void clearFields(){
  baseUrlField.setText(""String_Node_Str"");
  removeAllPathes();
  removeAllQueries();
}","private void clearFields(){
  baseUrlField.setText(""String_Node_Str"");
  removeAllPaths();
  removeAllQueries();
}"
41348,"public void setUrl(final String url){
  if (url == null) {
    return;
  }
  if (null == parsedUrl || !parsedUrl.buildUrl(false).equals(url)) {
    parsedUrl=UrlParser.parseUrl(url);
    clearFields();
    baseUrlField.setText(parsedUrl.getBase());
    List<PathPart> pathPartList=parsedUrl.getPathParts();
    List<Query> queries=parsedUrl.getQueries();
    for (    PathPart aPathPart : pathPartList) {
      addPath(aPathPart);
    }
    for (    Query query : queries) {
      addQuery(query);
    }
  }
}","public void setUrl(final String url){
  if (url == null) {
    return;
  }
  if (null == parsedUrl || !parsedUrl.buildUrl(false).equals(url)) {
    parsedUrl=UrlParser.parseUrl(url);
    clearFields();
    parsedUrl=UrlParser.parseUrl(url);
    baseUrlField.setText(parsedUrl.getBase());
    List<PathPart> pathPartList=parsedUrl.getPathParts();
    List<Query> queries=parsedUrl.getQueries();
    for (    PathPart aPathPart : pathPartList) {
      addPath(aPathPart);
    }
    for (    Query query : queries) {
      addQuery(query);
    }
  }
}"
41349,"public static StringBuilder getErrorMessage(List<ValidationResultEntry> errors){
  StringBuilder errorMessage=new StringBuilder();
  for (  ValidationResultEntry error : errors) {
    errorMessage.append(error.getMessage()).append(""String_Node_Str"");
  }
  return errorMessage;
}","public static StringBuilder getErrorMessage(List<ValidationResultEntry> errors){
  StringBuilder errorMessage=new StringBuilder();
  for (  ValidationResultEntry error : errors) {
    errorMessage.append(null != error.getMessage() ? error.getMessage() : error.toString()).append(""String_Node_Str"");
  }
  return errorMessage;
}"
41350,"private boolean checkResponse(){
  boolean result=true;
  for (  MethodTabPanel methodTabPanel : tabManager.getTabs()) {
    String text=methodTabPanel.getResponse();
    BodyValidationResult validationResult=JSONValidator.validateBody(text);
    if (!validationResult.isValid()) {
      int okCancelResult=Messages.showOkCancelDialog(methodTabPanel,Rest2MobileMessages.getMessage(Rest2MobileMessages.VALIDATION_WARNING_QUESTION) + ""String_Node_Str"" + JSONValidator.getErrorMessage(validationResult.getErrors()),Rest2MobileMessages.getMessage(Rest2MobileMessages.VALIDATION_WARNING_TITLE),Rest2MobileMessages.getMessage(Rest2MobileMessages.VALIDATION_WARNING_CONTINUE),Rest2MobileMessages.getMessage(Rest2MobileMessages.VALIDATION_WARNING_CANCEL),null);
      result=okCancelResult == 0;
      break;
    }
  }
  return result;
}","private boolean checkResponse(){
  boolean result=true;
  for (  MethodTabPanel methodTabPanel : tabManager.getTabs()) {
    String text=methodTabPanel.getResponse();
    BodyValidationResult validationResult=JSONValidator.validateBody(text);
    if (!validationResult.isValid()) {
      int okCancelResult=Messages.showOkCancelDialog(contentPane,Rest2MobileMessages.getMessage(Rest2MobileMessages.VALIDATION_WARNING_QUESTION) + ""String_Node_Str"" + JSONValidator.getErrorMessage(validationResult.getErrors()),Rest2MobileMessages.getMessage(Rest2MobileMessages.VALIDATION_WARNING_TITLE),Rest2MobileMessages.getMessage(Rest2MobileMessages.VALIDATION_WARNING_CONTINUE),Rest2MobileMessages.getMessage(Rest2MobileMessages.VALIDATION_WARNING_CANCEL),null);
      result=okCancelResult == 0;
      break;
    }
  }
  return result;
}"
41351,"@Override public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
  this.setText((String)value);
  this.setWrapStyleWord(true);
  this.setLineWrap(true);
  setSize(table.getColumnModel().getColumn(column).getWidth(),getPreferredSize().height);
  if (table.getRowHeight(row) != getPreferredSize().height) {
    table.setRowHeight(row,getPreferredSize().height);
  }
  if (isSelected) {
    this.setBackground((Color)UIManager.get(""String_Node_Str""));
    this.setForeground((Color)UIManager.get(""String_Node_Str""));
    this.selectAll();
  }
  return this;
}","@Override public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
  this.setText((String)value);
  this.setWrapStyleWord(true);
  this.setLineWrap(true);
  setSize(table.getColumnModel().getColumn(column).getWidth(),getPreferredSize().height);
  if (table.getRowHeight(row) != getPreferredSize().height) {
    table.setRowHeight(row,getPreferredSize().height);
  }
  if (isSelected) {
    this.setBackground((Color)UIManager.get(""String_Node_Str""));
    this.setForeground((Color)UIManager.get(""String_Node_Str""));
    this.selectAll();
  }
 else {
    this.setBackground((Color)UIManager.get(""String_Node_Str""));
    this.setForeground((Color)UIManager.get(""String_Node_Str""));
  }
  return this;
}"
41352,"private void resetService(final Map<String,String> config){
  LOG.info(""String_Node_Str"" + config);
  resetSolrClients();
}","private void resetService(final Map<String,String> config){
  LOG.info(""String_Node_Str"" + config);
}"
41353,"@Override public void handleEvent(Event event){
  if (pageIsNotIndexable(event)) {
    return;
  }
  PageEvent pageEvent=PageEvent.fromEvent(event);
  if (null == pageEvent) {
    return;
  }
  Iterator<PageModification> modifications=pageEvent.getModifications();
  while (modifications.hasNext()) {
    PageModification modification=modifications.next();
    String modificationPath=modification.getPath();
    if (pageIsNotInObservedPath(modificationPath)) {
      return;
    }
    PageModification.ModificationType type=modification.getType();
    if (type == PageModification.ModificationType.DELETED) {
      LOG.info(""String_Node_Str"",modificationPath);
      indexService.deleteTreeAndCommit(modification.getPath());
      return;
    }
 else     if (type == PageModification.ModificationType.CREATED) {
      LOG.info(""String_Node_Str"",modificationPath);
      addOrUpdatePage(modification);
    }
 else     if (type == PageModification.ModificationType.MODIFIED) {
      LOG.info(""String_Node_Str"",modificationPath);
      addOrUpdatePage(modification);
    }
 else     if (type == PageModification.ModificationType.MOVED) {
      LOG.info(""String_Node_Str"",modificationPath,modification.getDestination());
      addOrUpdatePage(modification);
      indexService.deleteTreeAndCommit(modificationPath);
    }
 else {
      LOG.info(""String_Node_Str"",type);
    }
  }
}","@Override public void handleEvent(Event event){
  if (pageIsNotIndexable(event)) {
    return;
  }
  PageEvent pageEvent=PageEvent.fromEvent(event);
  if (null == pageEvent) {
    return;
  }
  Iterator<PageModification> modifications=pageEvent.getModifications();
  while (modifications.hasNext()) {
    PageModification modification=modifications.next();
    String modificationPath=modification.getPath();
    if (pageIsNotInObservedPath(modificationPath)) {
      return;
    }
    PageModification.ModificationType type=modification.getType();
    if (type == PageModification.ModificationType.DELETED) {
      LOG.info(""String_Node_Str"",modificationPath);
      indexService.deleteTreeAndCommit(modification.getPath());
    }
 else     if (type == PageModification.ModificationType.CREATED) {
      LOG.info(""String_Node_Str"",modificationPath);
      addOrUpdatePage(modification);
    }
 else     if (type == PageModification.ModificationType.MODIFIED) {
      LOG.info(""String_Node_Str"",modificationPath);
      addOrUpdatePage(modification);
    }
 else     if (type == PageModification.ModificationType.MOVED) {
      LOG.info(""String_Node_Str"",modificationPath,modification.getDestination());
      addOrUpdatePage(modification);
      indexService.deleteTreeAndCommit(modificationPath);
    }
 else {
      LOG.info(""String_Node_Str"",type);
    }
  }
}"
41354,"@Override public void handleEvent(Event event){
  if (pageIsNotIndexable(event)) {
    return;
  }
  PageEvent pageEvent=PageEvent.fromEvent(event);
  if (null == pageEvent) {
    return;
  }
  Iterator<PageModification> modifications=pageEvent.getModifications();
  while (modifications.hasNext()) {
    PageModification modification=modifications.next();
    String modificationPath=modification.getPath();
    if (pageIsNotInObservedPath(modificationPath)) {
      return;
    }
    PageModification.ModificationType type=modification.getType();
    if (type == PageModification.ModificationType.DELETED) {
      LOG.info(""String_Node_Str"",modificationPath);
      indexService.deleteAndCommit(modification.getPath());
      return;
    }
 else     if (type == PageModification.ModificationType.CREATED) {
      LOG.info(""String_Node_Str"",modificationPath);
      addOrUpdatePage(modification);
    }
 else     if (type == PageModification.ModificationType.MODIFIED) {
      LOG.info(""String_Node_Str"",modificationPath);
      addOrUpdatePage(modification);
    }
 else {
      LOG.info(""String_Node_Str"",type);
    }
  }
}","@Override public void handleEvent(Event event){
  if (pageIsNotIndexable(event)) {
    return;
  }
  PageEvent pageEvent=PageEvent.fromEvent(event);
  if (null == pageEvent) {
    return;
  }
  Iterator<PageModification> modifications=pageEvent.getModifications();
  while (modifications.hasNext()) {
    PageModification modification=modifications.next();
    String modificationPath=modification.getPath();
    if (pageIsNotInObservedPath(modificationPath)) {
      return;
    }
    PageModification.ModificationType type=modification.getType();
    if (type == PageModification.ModificationType.DELETED) {
      LOG.info(""String_Node_Str"",modificationPath);
      indexService.deleteAndCommit(modification.getPath());
      return;
    }
 else     if (type == PageModification.ModificationType.CREATED) {
      LOG.info(""String_Node_Str"",modificationPath);
      addOrUpdatePage(modification);
    }
 else     if (type == PageModification.ModificationType.MODIFIED) {
      LOG.info(""String_Node_Str"",modificationPath);
      addOrUpdatePage(modification);
    }
 else     if (type == PageModification.ModificationType.MOVED) {
      LOG.info(""String_Node_Str"",modificationPath,modification.getDestination());
      addOrUpdatePage(modification);
      indexService.deleteAndCommit(modificationPath);
    }
 else {
      LOG.info(""String_Node_Str"",type);
    }
  }
}"
41355,"protected void addOrUpdatePage(PageModification modification){
  final String modificationPath=modification.getPath();
  if (null == resourceResolver) {
    LOG.warn(""String_Node_Str"",modificationPath);
    return;
  }
  final Resource resource=resourceResolver.getResource(modificationPath);
  if (ResourceUtil.isNonExistingResource(resource)) {
    LOG.warn(""String_Node_Str"",modificationPath);
    return;
  }
  GeometrixxMediaContentType contentPage=GeometrixxMediaContentTypeFactory.getInstance(resource);
  indexService.addAndCommit(contentPage.getSolrDoc());
}","protected void addOrUpdatePage(PageModification modification){
  final String modificationPath=(modification.getType() == PageModification.ModificationType.MOVED) ? modification.getDestination() : modification.getPath();
  if (null == resourceResolver) {
    LOG.warn(""String_Node_Str"",modificationPath);
    return;
  }
  final Resource resource=resourceResolver.getResource(modificationPath);
  if (ResourceUtil.isNonExistingResource(resource)) {
    LOG.warn(""String_Node_Str"",modificationPath);
    return;
  }
  GeometrixxMediaContentType contentPage=GeometrixxMediaContentTypeFactory.getInstance(resource);
  indexService.addAndCommit(contentPage.getSolrDoc());
}"
41356,"private void initialize(Context context,AttributeSet attrs,int defStyle){
  if (isInEditMode()) {
    return;
  }
  setFocusableInTouchMode(true);
  setFocusable(true);
  ColorStateList textColor=null;
  ColorStateList hintColor=null;
  int errorColor=Color.RED;
  int textSize=SpToPixels(context,15);
  if (attrs != null) {
    TypedArray attributes=context.obtainStyledAttributes(attrs,R.styleable.TestSwipeCardEntry,defStyle,0);
    textColor=attributes.getColorStateList(R.styleable.TestSwipeCardEntry_android_textColor);
    textSize=attributes.getDimensionPixelSize(R.styleable.TestSwipeCardEntry_android_textSize,textSize);
    hintColor=attributes.getColorStateList(R.styleable.TestSwipeCardEntry_android_textColorHint);
    attributes.recycle();
  }
  if (textColor == null) {
    textColor=ColorStateList.valueOf(0xFF000000);
  }
  if (hintColor == null) {
    textColor=ColorStateList.valueOf(0xFF7F7F7F);
  }
  setOnKeyListener(new OnKeyListener(){
    @Override public boolean onKey(    View v,    int keyCode,    KeyEvent event){
      if (event.getAction() == KeyEvent.ACTION_DOWN) {
        processKeyEvent(event.getKeyCode());
      }
      return true;
    }
  }
);
  final Resources resources=getResources();
  mTextPaint=new TextPaint();
  mTextPaint.setTextSize(textSize);
  mTextPaint.setAntiAlias(true);
  mTextPaint.setColor(textColor.getDefaultColor());
  mHintPaint=new TextPaint(mTextPaint);
  mHintPaint.setColor(hintColor.getDefaultColor());
  mErrorPaint=new TextPaint(mTextPaint);
  mErrorPaint.setColor(errorColor);
  mNumber=new SpannableStringBuilder();
  mMonth=new SpannableStringBuilder();
  mYear=new SpannableStringBuilder();
  mCVC=new SpannableStringBuilder();
  mNumberFormatted=new SpannableStringBuilder();
  mExpiryFormatted=new SpannableStringBuilder();
  mAnimator=ValueAnimator.ofFloat(0.0f,0.0f);
  mAnimator.setDuration(500);
  mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      postInvalidate();
    }
  }
);
  mBitmapPaint=new Paint();
  mBitmapPaint.setStyle(Paint.Style.FILL_AND_STROKE);
  setCardType(CardType.UNKNOWN);
  mMode=Mode.NUMBER;
}","private void initialize(Context context,AttributeSet attrs,int defStyle){
  if (isInEditMode()) {
    return;
  }
  setFocusableInTouchMode(true);
  setFocusable(true);
  ColorStateList textColor=null;
  ColorStateList hintColor=null;
  int errorColor=Color.RED;
  int textSize=SpToPixels(context,15);
  if (attrs != null) {
    TypedArray attributes=context.obtainStyledAttributes(attrs,R.styleable.TestSwipeCardEntry,defStyle,0);
    textColor=attributes.getColorStateList(R.styleable.TestSwipeCardEntry_android_textColor);
    textSize=attributes.getDimensionPixelSize(R.styleable.TestSwipeCardEntry_android_textSize,textSize);
    hintColor=attributes.getColorStateList(R.styleable.TestSwipeCardEntry_android_textColorHint);
    attributes.recycle();
  }
  if (textColor == null) {
    textColor=ColorStateList.valueOf(0xFF000000);
  }
  if (hintColor == null) {
    textColor=ColorStateList.valueOf(0xFF7F7F7F);
  }
  setOnKeyListener(new OnKeyListener(){
    @Override public boolean onKey(    View v,    int keyCode,    KeyEvent event){
      if (event.getAction() == KeyEvent.ACTION_DOWN) {
        processKeyEvent(event.getKeyCode());
      }
      return true;
    }
  }
);
  final Resources resources=getResources();
  mTextPaint=new TextPaint();
  mTextPaint.setTextSize(textSize);
  mTextPaint.setAntiAlias(true);
  mTextPaint.setColor(textColor.getDefaultColor());
  mTextPaint.setTypeface(Typeface.MONOSPACE);
  mHintPaint=new TextPaint(mTextPaint);
  mHintPaint.setColor(hintColor.getDefaultColor());
  mErrorPaint=new TextPaint(mTextPaint);
  mErrorPaint.setColor(errorColor);
  mNumber=new SpannableStringBuilder();
  mMonth=new SpannableStringBuilder();
  mYear=new SpannableStringBuilder();
  mCVC=new SpannableStringBuilder();
  mNumberFormatted=new SpannableStringBuilder();
  mExpiryFormatted=new SpannableStringBuilder();
  mAnimator=ValueAnimator.ofFloat(0.0f,0.0f);
  mAnimator.setDuration(500);
  mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      postInvalidate();
    }
  }
);
  mBitmapPaint=new Paint();
  mBitmapPaint.setStyle(Paint.Style.FILL_AND_STROKE);
  setCardType(CardType.UNKNOWN);
  mMode=Mode.NUMBER;
}"
41357,"private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        checkIsCompleted();
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth <= enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}","private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth <= enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}"
41358,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mSwipeCardEntry=(TestSwipeCardEntry)findViewById(R.id.swipecardentry);
  mPayButton=(Button)findViewById(R.id.paybutton);
  mSwipeCardEntry.setListener(new TestSwipeCardEntry.Listener(){
    @Override public void onCardEntryCompleted(    boolean completed){
      mPayButton.setEnabled(completed);
    }
  }
);
}"
41359,"private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        checkIsCompleted();
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth > enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}","private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        checkIsCompleted();
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth <= enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}"
41360,"private CardType guessCardType(CharSequence cardType){
  for (  CardType type : CardType.values()) {
    if (type.guess(cardType)) {
      return type;
    }
  }
  return CardType.MASTERCARD;
}","private CardType guessCardType(CharSequence cardType){
  for (  CardType type : CardType.values()) {
    if (type.guess(cardType)) {
      return type;
    }
  }
  return CardType.UNKNOWN;
}"
41361,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mSwipeCardEntry=(TestSwipeCardEntry)findViewById(R.id.swipecardentry);
  mPayButton=(Button)findViewById(R.id.paybutton);
  mSwipeCardEntry.setListener(new TestSwipeCardEntry.Listener(){
    @Override public void onCardEntryCompleted(    boolean completed){
      mPayButton.setEnabled(completed);
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mSwipeCardEntry=(TestSwipeCardEntry)findViewById(R.id.swipecardentry);
  mSwipeCardEntry.setNumber(""String_Node_Str"");
  mPayButton=(Button)findViewById(R.id.paybutton);
  mSwipeCardEntry.setListener(new TestSwipeCardEntry.Listener(){
    @Override public void onCardEntryCompleted(    boolean completed){
      mPayButton.setEnabled(completed);
    }
  }
);
}"
41362,"private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth <= enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}","private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
checkIsCompleted();
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth <= enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}"
41363,"void CardType(String guess,String whole,int length,int resource,int cvvResource,int[] breaks,int cvcLength){
  mPartial=Pattern.compile(guess);
  mWhole=Pattern.compile(whole);
  mLength=length;
  mResource=resource;
  mCVCResource=cvvResource;
  mBreaks=breaks;
  mCVCLength=cvcLength;
}","void CardType(String guess,String whole,int length,int resource,int cvvResource,int[] breaks,String cvcHint){
  mPartial=Pattern.compile(guess);
  mWhole=Pattern.compile(whole);
  mLength=length;
  mResource=resource;
  mCVCResource=cvvResource;
  mBreaks=breaks;
  mCVCLength=cvcHint.length();
  mCVCHint=cvcHint;
}"
41364,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  canvas.save();
  int paddingLeft=getPaddingLeft();
  float xPos=paddingLeft + mBitmap.getWidth() + (2 * IMAGE_BUFFER_PADDING);
  canvas.clipRect(xPos,0,getWidth(),getHeight());
  float offsetX=(Float)mAnimator.getAnimatedValue();
  xPos+=offsetX;
  int baseline=getPaddingTop() + mTextOffsetY - (int)mTextPaint.ascent();
  int length=mNumberFormatted.length();
  if (length == 0) {
    canvas.drawText(NUMBER_HINT,xPos,baseline,mHintPaint);
  }
 else {
    if ((mError) && (mMode == Mode.NUMBER)) {
      canvas.drawText(mNumberFormatted,0,length,xPos,baseline,mErrorPaint);
    }
 else {
      canvas.drawText(mNumberFormatted,0,length,xPos,baseline,mTextPaint);
    }
  }
  if (mMode != Mode.NUMBER) {
    if (mExpiryFormatted.length() == 0) {
      canvas.drawText(EXPIRY_HINT,mExpiryOffset + offsetX,baseline,mHintPaint);
      canvas.drawText(CVC_HINT,mCVCOffset + offsetX,baseline,mHintPaint);
    }
 else {
      if ((mError) && ((mMode == Mode.EXPIRYYEAR) || (mMode == Mode.EXPIRYMONTH))) {
        canvas.drawText(mExpiryFormatted,0,mExpiryFormatted.length(),mExpiryOffset + offsetX,baseline,mErrorPaint);
      }
 else {
        canvas.drawText(mExpiryFormatted,0,mExpiryFormatted.length(),mExpiryOffset + offsetX,baseline,mTextPaint);
      }
      if (mCVC.length() == 0) {
        canvas.drawText(CVC_HINT,mCVCOffset + offsetX,baseline,mHintPaint);
      }
 else {
        canvas.drawText(mCVC,0,mCVC.length(),mCVCOffset + offsetX,baseline,mTextPaint);
      }
    }
  }
  canvas.restore();
  if (mMode == Mode.CVC) {
    float yPos=(getMeasuredHeight() - mCVCBitmap.getHeight()) / 2;
    canvas.drawBitmap(mCVCBitmap,IMAGE_BUFFER_PADDING + paddingLeft,yPos,mBitmapPaint);
  }
 else {
    float yPos=(getMeasuredHeight() - mBitmap.getHeight()) / 2;
    canvas.drawBitmap(mBitmap,IMAGE_BUFFER_PADDING + paddingLeft,yPos,mBitmapPaint);
  }
  if (mCursorOn) {
    float cursorPosition;
switch (mMode) {
case NUMBER:
      cursorPosition=mTextPaint.measureText(mNumberFormatted,0,mNumberFormatted.length());
    cursorPosition+=xPos;
  break;
case EXPIRYMONTH:
case EXPIRYYEAR:
cursorPosition=mTextPaint.measureText(mExpiryFormatted,0,mExpiryFormatted.length());
cursorPosition+=mExpiryOffset + offsetX;
break;
default :
cursorPosition=mTextPaint.measureText(mCVC,0,mCVC.length());
cursorPosition+=mCVCOffset + offsetX;
}
Paint.FontMetrics metrics=mTextPaint.getFontMetrics();
canvas.drawRect(cursorPosition,baseline + metrics.top,cursorPosition + 1,baseline + metrics.descent,mTextPaint);
}
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  canvas.save();
  int paddingLeft=getPaddingLeft();
  float xPos=paddingLeft + mBitmap.getWidth() + (2 * IMAGE_BUFFER_PADDING);
  canvas.clipRect(xPos,0,getWidth(),getHeight());
  float offsetX=(Float)mAnimator.getAnimatedValue();
  xPos+=offsetX;
  int baseline=getPaddingTop() + mTextOffsetY - (int)mTextPaint.ascent();
  int length=mNumberFormatted.length();
  if (length == 0) {
    canvas.drawText(NUMBER_HINT,xPos,baseline,mHintPaint);
  }
 else {
    if ((mError) && (mMode == Mode.NUMBER)) {
      canvas.drawText(mNumberFormatted,0,length,xPos,baseline,mErrorPaint);
    }
 else {
      canvas.drawText(mNumberFormatted,0,length,xPos,baseline,mTextPaint);
    }
  }
  if (mMode != Mode.NUMBER) {
    if (mExpiryFormatted.length() == 0) {
      canvas.drawText(EXPIRY_HINT,mExpiryOffset + offsetX,baseline,mHintPaint);
      canvas.drawText(mCardType.mCVCHint,mCVCOffset + offsetX,baseline,mHintPaint);
    }
 else {
      if ((mError) && ((mMode == Mode.EXPIRYYEAR) || (mMode == Mode.EXPIRYMONTH))) {
        canvas.drawText(mExpiryFormatted,0,mExpiryFormatted.length(),mExpiryOffset + offsetX,baseline,mErrorPaint);
      }
 else {
        canvas.drawText(mExpiryFormatted,0,mExpiryFormatted.length(),mExpiryOffset + offsetX,baseline,mTextPaint);
      }
      if (mCVC.length() == 0) {
        canvas.drawText(mCardType.mCVCHint,mCVCOffset + offsetX,baseline,mHintPaint);
      }
 else {
        canvas.drawText(mCVC,0,mCVC.length(),mCVCOffset + offsetX,baseline,mTextPaint);
      }
    }
  }
  canvas.restore();
  if (mMode == Mode.CVC) {
    float yPos=(getMeasuredHeight() - mCVCBitmap.getHeight()) / 2;
    canvas.drawBitmap(mCVCBitmap,IMAGE_BUFFER_PADDING + paddingLeft,yPos,mBitmapPaint);
  }
 else {
    float yPos=(getMeasuredHeight() - mBitmap.getHeight()) / 2;
    canvas.drawBitmap(mBitmap,IMAGE_BUFFER_PADDING + paddingLeft,yPos,mBitmapPaint);
  }
  if (mCursorOn) {
    float cursorPosition;
switch (mMode) {
case NUMBER:
      cursorPosition=mTextPaint.measureText(mNumberFormatted,0,mNumberFormatted.length());
    cursorPosition+=xPos;
  break;
case EXPIRYMONTH:
case EXPIRYYEAR:
cursorPosition=mTextPaint.measureText(mExpiryFormatted,0,mExpiryFormatted.length());
cursorPosition+=mExpiryOffset + offsetX;
break;
default :
cursorPosition=mTextPaint.measureText(mCVC,0,mCVC.length());
cursorPosition+=mCVCOffset + offsetX;
}
Paint.FontMetrics metrics=mTextPaint.getFontMetrics();
canvas.drawRect(cursorPosition,baseline + metrics.top,cursorPosition + 1,baseline + metrics.descent,mTextPaint);
}
}"
41365,"private void validateNumber(){
  if (mCardType.validateNumber(mNumber)) {
    mMode=Mode.EXPIRYMONTH;
    mAnimator.start();
  }
 else {
    mError=true;
  }
}","private void validateNumber(){
  if (mCardType.validateNumber(mNumber)) {
    mMode=Mode.EXPIRYMONTH;
    final int numberLength=mCardType.mLength;
    final int lastBreakIndex=mCardType.mBreaks[mCardType.mBreaks.length - 1];
    final int fourNumberTextWidth=(int)mTextPaint.measureText(mNumber,lastBreakIndex,numberLength);
    final int expiryTextWidth=(int)mTextPaint.measureText(EXPIRY_HINT);
    final int cvcTextWidth=(int)mTextPaint.measureText(mCardType.mCVCHint);
    final int formattedNumberWidth=(int)mTextPaint.measureText(mNumberFormatted,0,mNumberFormatted.length());
    final int paddingLeft=getPaddingLeft();
    final int imageEndPosition=paddingLeft + mBitmap.getWidth() + (2 * IMAGE_BUFFER_PADDING);
    final int twelveNumberTextWidth=formattedNumberWidth - fourNumberTextWidth;
    final int wholeWidth=(getMeasuredWidth() + twelveNumberTextWidth) - (paddingLeft + getPaddingRight());
    mCVCOffset=wholeWidth - cvcTextWidth;
    final int leftPosition=(imageEndPosition + formattedNumberWidth);
    mExpiryOffset=(((mCVCOffset - leftPosition) - expiryTextWidth) / 2) + leftPosition;
    mAnimator.setFloatValues(0.0f,0 - twelveNumberTextWidth);
    mAnimator.start();
  }
 else {
    mError=true;
  }
}"
41366,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int verticalPadding=getPaddingTop() + getPaddingBottom();
  int horizontalPadding=getPaddingLeft() + getPaddingRight();
  int textHeight=(int)(mTextPaint.descent() - mTextPaint.ascent());
  int imageHeight=mBitmap.getHeight();
  int height=Math.max(textHeight,imageHeight);
  mTextOffsetY=(height - textHeight) / 2;
  height+=verticalPadding;
  int minimumTextWidth=(int)mTextPaint.measureText(NUMBER_HINT);
  int width=mBitmap.getWidth() + (2 * IMAGE_BUFFER_PADDING) + minimumTextWidth+ horizontalPadding;
  setMeasuredDimension(resolveSizeAndState(width,widthMeasureSpec,0),resolveSizeAndState(height,heightMeasureSpec,0));
  int fourNumberTextWidth=(int)mTextPaint.measureText(NUMBER_HINT,0,4);
  int expiryTextWidth=(int)mTextPaint.measureText(EXPIRY_HINT);
  int cvcTextWidth=(int)mTextPaint.measureText(CVC_HINT);
  mCVCOffset=minimumTextWidth - cvcTextWidth;
  int expirySpace=minimumTextWidth - (cvcTextWidth + fourNumberTextWidth);
  expirySpace=(expirySpace - expiryTextWidth) / 2;
  mExpiryOffset=expirySpace + fourNumberTextWidth;
  int twelveNumberTextWidth=minimumTextWidth - fourNumberTextWidth;
  mCVCOffset+=minimumTextWidth + expirySpace + getPaddingLeft();
  mExpiryOffset+=minimumTextWidth + expirySpace + getPaddingLeft();
  mAnimator.setFloatValues(0.0f,0 - twelveNumberTextWidth);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int verticalPadding=getPaddingTop() + getPaddingBottom();
  int horizontalPadding=getPaddingLeft() + getPaddingRight();
  int textHeight=(int)(mTextPaint.descent() - mTextPaint.ascent());
  int imageHeight=mBitmap.getHeight();
  int height=Math.max(textHeight,imageHeight);
  mTextOffsetY=(height - textHeight) / 2;
  height+=verticalPadding;
  int minimumTextWidth=(int)mTextPaint.measureText(NUMBER_HINT);
  int width=mBitmap.getWidth() + (2 * IMAGE_BUFFER_PADDING) + minimumTextWidth+ horizontalPadding;
  setMeasuredDimension(resolveSizeAndState(width,widthMeasureSpec,0),resolveSizeAndState(height,heightMeasureSpec,0));
}"
41367,"/** 
 * Clears CVC, Expiry and Number fields and sets the number to the given parameter. If this is valid then we the state will move to expiry month to fill in the rest of the details.
 * @param number the number to fill in. (Not null)
 */
public void setNumber(String number){
  mNumber.clear();
  mMonth.clear();
  mYear.clear();
  mCVC.clear();
  mNumberFormatted.clear();
  mExpiryFormatted.clear();
  mCardType=CardType.UNKNOWN;
  mMode=Mode.NUMBER;
  mNumber.append(number);
  mNumberFormatted.append(number);
  if (mNumber.length() >= 2) {
    setCardType(guessCardType(mNumber));
  }
  for (int index=mCardType.mBreaks.length; --index >= 0; ) {
    int space=mCardType.mBreaks[index];
    if (mNumberFormatted.length() > space) {
      mNumberFormatted.insert(space,""String_Node_Str"");
    }
  }
  if (mCardType.isCorrectLength(mNumber.length())) {
    validateNumber();
  }
  checkIsCompleted();
  postInvalidate();
}","/** 
 * Clears CVC, Expiry and Number fields and sets the number to the given parameter. If this is valid then we the state will move to expiry month to fill in the rest of the details.
 * @param number the number to fill in. (Not null)
 */
public void setNumber(String number){
  mNumber.clear();
  mMonth.clear();
  mYear.clear();
  mCVC.clear();
  mNumberFormatted.clear();
  mExpiryFormatted.clear();
  mCardType=CardType.UNKNOWN;
  mMode=Mode.NUMBER;
  mNumber.append(number);
  mNumberFormatted.append(number);
  if (mNumber.length() >= 2) {
    setCardType(guessCardType(mNumber.subSequence(0,2)));
  }
  for (int index=mCardType.mBreaks.length; --index >= 0; ) {
    int space=mCardType.mBreaks[index];
    if (mNumberFormatted.length() > space) {
      mNumberFormatted.insert(space,""String_Node_Str"");
    }
  }
  if (mCardType.isCorrectLength(mNumber.length())) {
    validateNumber();
  }
  checkIsCompleted();
  postInvalidate();
}"
41368,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  return contents;
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  StringBuffer buff=new StringBuffer(""String_Node_Str"");
  buff.append(contents);
  return buff.toString();
}"
41369,"/** 
 * {@inheritDoc}
 */
public SparkJobResult startJob(String data,Map<String,String> params) throws SparkJobServerClientException {
  try {
    if (params == null || params.isEmpty()) {
      throw new SparkJobServerClientException(""String_Node_Str"");
    }
    if (params.containsKey(ISparkJobServerClientConstants.PARAM_APP_NAME) && params.containsKey(ISparkJobServerClientConstants.PARAM_CLASS_PATH)) {
      StringBuffer postUrlBuff=new StringBuffer(jobServerUrl);
      postUrlBuff.append(""String_Node_Str"");
      int num=params.size();
      for (      String key : params.keySet()) {
        postUrlBuff.append(key).append('=').append(params.get(key));
        num--;
        if (num > 0) {
          postUrlBuff.append('&');
        }
      }
      HttpPost postMethod=new HttpPost(postUrlBuff.toString());
      if (data != null) {
        StringEntity strEntity=new StringEntity(data);
        strEntity.setContentEncoding(""String_Node_Str"");
        strEntity.setContentType(""String_Node_Str"");
        postMethod.setEntity(strEntity);
      }
      HttpResponse response=httpClient.execute(postMethod);
      String resContent=getResponseContent(response.getEntity());
      return parseResult(resContent);
    }
 else {
      throw new SparkJobServerClientException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    processException(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
public SparkJobResult startJob(String data,Map<String,String> params) throws SparkJobServerClientException {
  try {
    if (params == null || params.isEmpty()) {
      throw new SparkJobServerClientException(""String_Node_Str"");
    }
    if (params.containsKey(ISparkJobServerClientConstants.PARAM_APP_NAME) && params.containsKey(ISparkJobServerClientConstants.PARAM_CLASS_PATH)) {
      StringBuffer postUrlBuff=new StringBuffer(jobServerUrl);
      postUrlBuff.append(""String_Node_Str"");
      int num=params.size();
      for (      String key : params.keySet()) {
        postUrlBuff.append(key).append('=').append(params.get(key));
        num--;
        if (num > 0) {
          postUrlBuff.append('&');
        }
      }
      HttpPost postMethod=new HttpPost(postUrlBuff.toString());
      if (data != null) {
        StringEntity strEntity=new StringEntity(data);
        strEntity.setContentEncoding(""String_Node_Str"");
        strEntity.setContentType(""String_Node_Str"");
        postMethod.setEntity(strEntity);
      }
      HttpResponse response=httpClient.execute(postMethod);
      String resContent=getResponseContent(response.getEntity());
      int statusCode=response.getStatusLine().getStatusCode();
      if (statusCode == HttpStatus.SC_OK) {
        return parseResult(resContent);
      }
 else {
        logError(statusCode,resContent,true);
      }
    }
 else {
      throw new SparkJobServerClientException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    processException(""String_Node_Str"",e);
  }
  return null;
}"
41370,"/** 
 * {@inheritDoc}
 */
public SparkJobResult getJobResult(String jobId) throws SparkJobServerClientException {
  try {
    if (!isNotEmpty(jobId)) {
      throw new SparkJobServerClientException(""String_Node_Str"");
    }
    HttpGet getMethod=new HttpGet(jobServerUrl + ""String_Node_Str"" + jobId);
    HttpResponse response=httpClient.execute(getMethod);
    String resContent=getResponseContent(response.getEntity());
    return parseResult(resContent);
  }
 catch (  Exception e) {
    processException(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
public SparkJobResult getJobResult(String jobId) throws SparkJobServerClientException {
  try {
    if (!isNotEmpty(jobId)) {
      throw new SparkJobServerClientException(""String_Node_Str"");
    }
    HttpGet getMethod=new HttpGet(jobServerUrl + ""String_Node_Str"" + jobId);
    HttpResponse response=httpClient.execute(getMethod);
    String resContent=getResponseContent(response.getEntity());
    int statusCode=response.getStatusLine().getStatusCode();
    if (statusCode == HttpStatus.SC_OK) {
      return parseResult(resContent);
    }
 else     if (statusCode == HttpStatus.SC_NOT_FOUND) {
      return new SparkJobResult(resContent);
    }
 else {
      logError(statusCode,resContent,true);
    }
  }
 catch (  Exception e) {
    processException(""String_Node_Str"",e);
  }
  return null;
}"
41371,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mSwipeCardEntry=(TestSwipeCardEntry)findViewById(R.id.swipecardentry);
  mPayButton=(Button)findViewById(R.id.paybutton);
  mSwipeCardEntry.setListener(new TestSwipeCardEntry.Listener(){
    @Override public void onCardEntryCompleted(    boolean completed){
      mPayButton.setEnabled(completed);
    }
  }
);
}"
41372,"private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        checkIsCompleted();
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth > enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}","private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        checkIsCompleted();
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth <= enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}"
41373,"private CardType guessCardType(CharSequence cardType){
  for (  CardType type : CardType.values()) {
    if (type.guess(cardType)) {
      return type;
    }
  }
  return CardType.MASTERCARD;
}","private CardType guessCardType(CharSequence cardType){
  for (  CardType type : CardType.values()) {
    if (type.guess(cardType)) {
      return type;
    }
  }
  return CardType.UNKNOWN;
}"
41374,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mSwipeCardEntry=(TestSwipeCardEntry)findViewById(R.id.swipecardentry);
  mPayButton=(Button)findViewById(R.id.paybutton);
  mSwipeCardEntry.setListener(new TestSwipeCardEntry.Listener(){
    @Override public void onCardEntryCompleted(    boolean completed){
      mPayButton.setEnabled(completed);
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mSwipeCardEntry=(TestSwipeCardEntry)findViewById(R.id.swipecardentry);
  mSwipeCardEntry.setNumber(""String_Node_Str"");
  mPayButton=(Button)findViewById(R.id.paybutton);
  mSwipeCardEntry.setListener(new TestSwipeCardEntry.Listener(){
    @Override public void onCardEntryCompleted(    boolean completed){
      mPayButton.setEnabled(completed);
    }
  }
);
}"
41375,"private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth <= enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}","private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
checkIsCompleted();
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth <= enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}"
41376,"void CardType(String guess,String whole,int length,int resource,int cvvResource,int[] breaks,int cvcLength){
  mPartial=Pattern.compile(guess);
  mWhole=Pattern.compile(whole);
  mLength=length;
  mResource=resource;
  mCVCResource=cvvResource;
  mBreaks=breaks;
  mCVCLength=cvcLength;
}","void CardType(String guess,String whole,int length,int resource,int cvvResource,int[] breaks,String cvcHint){
  mPartial=Pattern.compile(guess);
  mWhole=Pattern.compile(whole);
  mLength=length;
  mResource=resource;
  mCVCResource=cvvResource;
  mBreaks=breaks;
  mCVCLength=cvcHint.length();
  mCVCHint=cvcHint;
}"
41377,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  canvas.save();
  int paddingLeft=getPaddingLeft();
  float xPos=paddingLeft + mBitmap.getWidth() + (2 * IMAGE_BUFFER_PADDING);
  canvas.clipRect(xPos,0,getWidth(),getHeight());
  float offsetX=(Float)mAnimator.getAnimatedValue();
  xPos+=offsetX;
  int baseline=getPaddingTop() + mTextOffsetY - (int)mTextPaint.ascent();
  int length=mNumberFormatted.length();
  if (length == 0) {
    canvas.drawText(NUMBER_HINT,xPos,baseline,mHintPaint);
  }
 else {
    if ((mError) && (mMode == Mode.NUMBER)) {
      canvas.drawText(mNumberFormatted,0,length,xPos,baseline,mErrorPaint);
    }
 else {
      canvas.drawText(mNumberFormatted,0,length,xPos,baseline,mTextPaint);
    }
  }
  if (mMode != Mode.NUMBER) {
    if (mExpiryFormatted.length() == 0) {
      canvas.drawText(EXPIRY_HINT,mExpiryOffset + offsetX,baseline,mHintPaint);
      canvas.drawText(CVC_HINT,mCVCOffset + offsetX,baseline,mHintPaint);
    }
 else {
      if ((mError) && ((mMode == Mode.EXPIRYYEAR) || (mMode == Mode.EXPIRYMONTH))) {
        canvas.drawText(mExpiryFormatted,0,mExpiryFormatted.length(),mExpiryOffset + offsetX,baseline,mErrorPaint);
      }
 else {
        canvas.drawText(mExpiryFormatted,0,mExpiryFormatted.length(),mExpiryOffset + offsetX,baseline,mTextPaint);
      }
      if (mCVC.length() == 0) {
        canvas.drawText(CVC_HINT,mCVCOffset + offsetX,baseline,mHintPaint);
      }
 else {
        canvas.drawText(mCVC,0,mCVC.length(),mCVCOffset + offsetX,baseline,mTextPaint);
      }
    }
  }
  canvas.restore();
  if (mMode == Mode.CVC) {
    float yPos=(getMeasuredHeight() - mCVCBitmap.getHeight()) / 2;
    canvas.drawBitmap(mCVCBitmap,IMAGE_BUFFER_PADDING + paddingLeft,yPos,mBitmapPaint);
  }
 else {
    float yPos=(getMeasuredHeight() - mBitmap.getHeight()) / 2;
    canvas.drawBitmap(mBitmap,IMAGE_BUFFER_PADDING + paddingLeft,yPos,mBitmapPaint);
  }
  if (mCursorOn) {
    float cursorPosition;
switch (mMode) {
case NUMBER:
      cursorPosition=mTextPaint.measureText(mNumberFormatted,0,mNumberFormatted.length());
    cursorPosition+=xPos;
  break;
case EXPIRYMONTH:
case EXPIRYYEAR:
cursorPosition=mTextPaint.measureText(mExpiryFormatted,0,mExpiryFormatted.length());
cursorPosition+=mExpiryOffset + offsetX;
break;
default :
cursorPosition=mTextPaint.measureText(mCVC,0,mCVC.length());
cursorPosition+=mCVCOffset + offsetX;
}
Paint.FontMetrics metrics=mTextPaint.getFontMetrics();
canvas.drawRect(cursorPosition,baseline + metrics.top,cursorPosition + 1,baseline + metrics.descent,mTextPaint);
}
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  canvas.save();
  int paddingLeft=getPaddingLeft();
  float xPos=paddingLeft + mBitmap.getWidth() + (2 * IMAGE_BUFFER_PADDING);
  canvas.clipRect(xPos,0,getWidth(),getHeight());
  float offsetX=(Float)mAnimator.getAnimatedValue();
  xPos+=offsetX;
  int baseline=getPaddingTop() + mTextOffsetY - (int)mTextPaint.ascent();
  int length=mNumberFormatted.length();
  if (length == 0) {
    canvas.drawText(NUMBER_HINT,xPos,baseline,mHintPaint);
  }
 else {
    if ((mError) && (mMode == Mode.NUMBER)) {
      canvas.drawText(mNumberFormatted,0,length,xPos,baseline,mErrorPaint);
    }
 else {
      canvas.drawText(mNumberFormatted,0,length,xPos,baseline,mTextPaint);
    }
  }
  if (mMode != Mode.NUMBER) {
    if (mExpiryFormatted.length() == 0) {
      canvas.drawText(EXPIRY_HINT,mExpiryOffset + offsetX,baseline,mHintPaint);
      canvas.drawText(mCardType.mCVCHint,mCVCOffset + offsetX,baseline,mHintPaint);
    }
 else {
      if ((mError) && ((mMode == Mode.EXPIRYYEAR) || (mMode == Mode.EXPIRYMONTH))) {
        canvas.drawText(mExpiryFormatted,0,mExpiryFormatted.length(),mExpiryOffset + offsetX,baseline,mErrorPaint);
      }
 else {
        canvas.drawText(mExpiryFormatted,0,mExpiryFormatted.length(),mExpiryOffset + offsetX,baseline,mTextPaint);
      }
      if (mCVC.length() == 0) {
        canvas.drawText(mCardType.mCVCHint,mCVCOffset + offsetX,baseline,mHintPaint);
      }
 else {
        canvas.drawText(mCVC,0,mCVC.length(),mCVCOffset + offsetX,baseline,mTextPaint);
      }
    }
  }
  canvas.restore();
  if (mMode == Mode.CVC) {
    float yPos=(getMeasuredHeight() - mCVCBitmap.getHeight()) / 2;
    canvas.drawBitmap(mCVCBitmap,IMAGE_BUFFER_PADDING + paddingLeft,yPos,mBitmapPaint);
  }
 else {
    float yPos=(getMeasuredHeight() - mBitmap.getHeight()) / 2;
    canvas.drawBitmap(mBitmap,IMAGE_BUFFER_PADDING + paddingLeft,yPos,mBitmapPaint);
  }
  if (mCursorOn) {
    float cursorPosition;
switch (mMode) {
case NUMBER:
      cursorPosition=mTextPaint.measureText(mNumberFormatted,0,mNumberFormatted.length());
    cursorPosition+=xPos;
  break;
case EXPIRYMONTH:
case EXPIRYYEAR:
cursorPosition=mTextPaint.measureText(mExpiryFormatted,0,mExpiryFormatted.length());
cursorPosition+=mExpiryOffset + offsetX;
break;
default :
cursorPosition=mTextPaint.measureText(mCVC,0,mCVC.length());
cursorPosition+=mCVCOffset + offsetX;
}
Paint.FontMetrics metrics=mTextPaint.getFontMetrics();
canvas.drawRect(cursorPosition,baseline + metrics.top,cursorPosition + 1,baseline + metrics.descent,mTextPaint);
}
}"
41378,"private void validateNumber(){
  if (mCardType.validateNumber(mNumber)) {
    mMode=Mode.EXPIRYMONTH;
    mAnimator.start();
  }
 else {
    mError=true;
  }
}","private void validateNumber(){
  if (mCardType.validateNumber(mNumber)) {
    mMode=Mode.EXPIRYMONTH;
    final int numberLength=mCardType.mLength;
    final int lastBreakIndex=mCardType.mBreaks[mCardType.mBreaks.length - 1];
    final int fourNumberTextWidth=(int)mTextPaint.measureText(mNumber,lastBreakIndex,numberLength);
    final int expiryTextWidth=(int)mTextPaint.measureText(EXPIRY_HINT);
    final int cvcTextWidth=(int)mTextPaint.measureText(mCardType.mCVCHint);
    final int formattedNumberWidth=(int)mTextPaint.measureText(mNumberFormatted,0,mNumberFormatted.length());
    final int paddingLeft=getPaddingLeft();
    final int imageEndPosition=paddingLeft + mBitmap.getWidth() + (2 * IMAGE_BUFFER_PADDING);
    final int twelveNumberTextWidth=formattedNumberWidth - fourNumberTextWidth;
    final int wholeWidth=(getMeasuredWidth() + twelveNumberTextWidth) - (paddingLeft + getPaddingRight());
    mCVCOffset=wholeWidth - cvcTextWidth;
    final int leftPosition=(imageEndPosition + formattedNumberWidth);
    mExpiryOffset=(((mCVCOffset - leftPosition) - expiryTextWidth) / 2) + leftPosition;
    mAnimator.setFloatValues(0.0f,0 - twelveNumberTextWidth);
    mAnimator.start();
  }
 else {
    mError=true;
  }
}"
41379,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int verticalPadding=getPaddingTop() + getPaddingBottom();
  int horizontalPadding=getPaddingLeft() + getPaddingRight();
  int textHeight=(int)(mTextPaint.descent() - mTextPaint.ascent());
  int imageHeight=mBitmap.getHeight();
  int height=Math.max(textHeight,imageHeight);
  mTextOffsetY=(height - textHeight) / 2;
  height+=verticalPadding;
  int minimumTextWidth=(int)mTextPaint.measureText(NUMBER_HINT);
  int width=mBitmap.getWidth() + (2 * IMAGE_BUFFER_PADDING) + minimumTextWidth+ horizontalPadding;
  setMeasuredDimension(resolveSizeAndState(width,widthMeasureSpec,0),resolveSizeAndState(height,heightMeasureSpec,0));
  int fourNumberTextWidth=(int)mTextPaint.measureText(NUMBER_HINT,0,4);
  int expiryTextWidth=(int)mTextPaint.measureText(EXPIRY_HINT);
  int cvcTextWidth=(int)mTextPaint.measureText(CVC_HINT);
  mCVCOffset=minimumTextWidth - cvcTextWidth;
  int expirySpace=minimumTextWidth - (cvcTextWidth + fourNumberTextWidth);
  expirySpace=(expirySpace - expiryTextWidth) / 2;
  mExpiryOffset=expirySpace + fourNumberTextWidth;
  int twelveNumberTextWidth=minimumTextWidth - fourNumberTextWidth;
  mCVCOffset+=minimumTextWidth + expirySpace + getPaddingLeft();
  mExpiryOffset+=minimumTextWidth + expirySpace + getPaddingLeft();
  mAnimator.setFloatValues(0.0f,0 - twelveNumberTextWidth);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int verticalPadding=getPaddingTop() + getPaddingBottom();
  int horizontalPadding=getPaddingLeft() + getPaddingRight();
  int textHeight=(int)(mTextPaint.descent() - mTextPaint.ascent());
  int imageHeight=mBitmap.getHeight();
  int height=Math.max(textHeight,imageHeight);
  mTextOffsetY=(height - textHeight) / 2;
  height+=verticalPadding;
  int minimumTextWidth=(int)mTextPaint.measureText(NUMBER_HINT);
  int width=mBitmap.getWidth() + (2 * IMAGE_BUFFER_PADDING) + minimumTextWidth+ horizontalPadding;
  setMeasuredDimension(resolveSizeAndState(width,widthMeasureSpec,0),resolveSizeAndState(height,heightMeasureSpec,0));
}"
41380,"/** 
 * Clears CVC, Expiry and Number fields and sets the number to the given parameter. If this is valid then we the state will move to expiry month to fill in the rest of the details.
 * @param number the number to fill in. (Not null)
 */
public void setNumber(String number){
  mNumber.clear();
  mMonth.clear();
  mYear.clear();
  mCVC.clear();
  mNumberFormatted.clear();
  mExpiryFormatted.clear();
  mCardType=CardType.UNKNOWN;
  mMode=Mode.NUMBER;
  mNumber.append(number);
  mNumberFormatted.append(number);
  if (mNumber.length() >= 2) {
    setCardType(guessCardType(mNumber));
  }
  for (int index=mCardType.mBreaks.length; --index >= 0; ) {
    int space=mCardType.mBreaks[index];
    if (mNumberFormatted.length() > space) {
      mNumberFormatted.insert(space,""String_Node_Str"");
    }
  }
  if (mCardType.isCorrectLength(mNumber.length())) {
    validateNumber();
  }
  checkIsCompleted();
  postInvalidate();
}","/** 
 * Clears CVC, Expiry and Number fields and sets the number to the given parameter. If this is valid then we the state will move to expiry month to fill in the rest of the details.
 * @param number the number to fill in. (Not null)
 */
public void setNumber(String number){
  mNumber.clear();
  mMonth.clear();
  mYear.clear();
  mCVC.clear();
  mNumberFormatted.clear();
  mExpiryFormatted.clear();
  mCardType=CardType.UNKNOWN;
  mMode=Mode.NUMBER;
  mNumber.append(number);
  mNumberFormatted.append(number);
  if (mNumber.length() >= 2) {
    setCardType(guessCardType(mNumber.subSequence(0,2)));
  }
  for (int index=mCardType.mBreaks.length; --index >= 0; ) {
    int space=mCardType.mBreaks[index];
    if (mNumberFormatted.length() > space) {
      mNumberFormatted.insert(space,""String_Node_Str"");
    }
  }
  if (mCardType.isCorrectLength(mNumber.length())) {
    validateNumber();
  }
  checkIsCompleted();
  postInvalidate();
}"
41381,"private void initialize(Context context,AttributeSet attrs,int defStyle){
  if (isInEditMode()) {
    return;
  }
  setFocusableInTouchMode(true);
  setFocusable(true);
  ColorStateList textColor=null;
  ColorStateList hintColor=null;
  int errorColor=Color.RED;
  int textSize=SpToPixels(context,15);
  if (attrs != null) {
    TypedArray attributes=context.obtainStyledAttributes(attrs,R.styleable.TestSwipeCardEntry,defStyle,0);
    textColor=attributes.getColorStateList(R.styleable.TestSwipeCardEntry_android_textColor);
    textSize=attributes.getDimensionPixelSize(R.styleable.TestSwipeCardEntry_android_textSize,textSize);
    hintColor=attributes.getColorStateList(R.styleable.TestSwipeCardEntry_android_textColorHint);
    attributes.recycle();
  }
  if (textColor == null) {
    textColor=ColorStateList.valueOf(0xFF000000);
  }
  if (hintColor == null) {
    textColor=ColorStateList.valueOf(0xFF7F7F7F);
  }
  setOnKeyListener(new OnKeyListener(){
    @Override public boolean onKey(    View v,    int keyCode,    KeyEvent event){
      if (event.getAction() == KeyEvent.ACTION_DOWN) {
        processKeyEvent(event.getKeyCode());
      }
      return true;
    }
  }
);
  final Resources resources=getResources();
  mTextPaint=new TextPaint();
  mTextPaint.setTextSize(textSize);
  mTextPaint.setAntiAlias(true);
  mTextPaint.setColor(textColor.getDefaultColor());
  mHintPaint=new TextPaint(mTextPaint);
  mHintPaint.setColor(hintColor.getDefaultColor());
  mErrorPaint=new TextPaint(mTextPaint);
  mErrorPaint.setColor(errorColor);
  mNumber=new SpannableStringBuilder();
  mMonth=new SpannableStringBuilder();
  mYear=new SpannableStringBuilder();
  mCVC=new SpannableStringBuilder();
  mNumberFormatted=new SpannableStringBuilder();
  mExpiryFormatted=new SpannableStringBuilder();
  mAnimator=ValueAnimator.ofFloat(0.0f,0.0f);
  mAnimator.setDuration(500);
  mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      postInvalidate();
    }
  }
);
  mBitmapPaint=new Paint();
  mBitmapPaint.setStyle(Paint.Style.FILL_AND_STROKE);
  setCardType(CardType.UNKNOWN);
  mMode=Mode.NUMBER;
}","private void initialize(Context context,AttributeSet attrs,int defStyle){
  if (isInEditMode()) {
    return;
  }
  setFocusableInTouchMode(true);
  setFocusable(true);
  ColorStateList textColor=null;
  ColorStateList hintColor=null;
  int errorColor=Color.RED;
  int textSize=SpToPixels(context,15);
  if (attrs != null) {
    TypedArray attributes=context.obtainStyledAttributes(attrs,R.styleable.TestSwipeCardEntry,defStyle,0);
    textColor=attributes.getColorStateList(R.styleable.TestSwipeCardEntry_android_textColor);
    textSize=attributes.getDimensionPixelSize(R.styleable.TestSwipeCardEntry_android_textSize,textSize);
    hintColor=attributes.getColorStateList(R.styleable.TestSwipeCardEntry_android_textColorHint);
    attributes.recycle();
  }
  if (textColor == null) {
    textColor=ColorStateList.valueOf(0xFF000000);
  }
  if (hintColor == null) {
    textColor=ColorStateList.valueOf(0xFF7F7F7F);
  }
  setOnKeyListener(new OnKeyListener(){
    @Override public boolean onKey(    View v,    int keyCode,    KeyEvent event){
      if (event.getAction() == KeyEvent.ACTION_DOWN) {
        processKeyEvent(event.getKeyCode());
      }
      return true;
    }
  }
);
  final Resources resources=getResources();
  mTextPaint=new TextPaint();
  mTextPaint.setTextSize(textSize);
  mTextPaint.setAntiAlias(true);
  mTextPaint.setColor(textColor.getDefaultColor());
  mTextPaint.setTypeface(Typeface.MONOSPACE);
  mHintPaint=new TextPaint(mTextPaint);
  mHintPaint.setColor(hintColor.getDefaultColor());
  mErrorPaint=new TextPaint(mTextPaint);
  mErrorPaint.setColor(errorColor);
  mNumber=new SpannableStringBuilder();
  mMonth=new SpannableStringBuilder();
  mYear=new SpannableStringBuilder();
  mCVC=new SpannableStringBuilder();
  mNumberFormatted=new SpannableStringBuilder();
  mExpiryFormatted=new SpannableStringBuilder();
  mAnimator=ValueAnimator.ofFloat(0.0f,0.0f);
  mAnimator.setDuration(500);
  mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      postInvalidate();
    }
  }
);
  mBitmapPaint=new Paint();
  mBitmapPaint.setStyle(Paint.Style.FILL_AND_STROKE);
  setCardType(CardType.UNKNOWN);
  mMode=Mode.NUMBER;
}"
41382,"private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        checkIsCompleted();
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth <= enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}","private void processKeyEvent(int keyCode){
  if (keyCode == KeyEvent.KEYCODE_BACK) {
    clearFocus();
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    startBlinking();
switch (mMode) {
case CVC:
      if (mCVC.length() > 0) {
        removeLastChar(mCVC);
        break;
      }
 else {
        mMode=Mode.EXPIRYYEAR;
      }
case EXPIRYYEAR:
    if (mYear.length() > 0) {
      removeLastChar(mYear);
      removeLastChar(mExpiryFormatted);
      break;
    }
 else {
      removeLastChar(mExpiryFormatted);
      mMode=Mode.EXPIRYMONTH;
    }
case EXPIRYMONTH:
  if (mMonth.length() > 0) {
    removeLastChar(mMonth);
    removeLastChar(mExpiryFormatted);
    break;
  }
 else {
    mMode=Mode.NUMBER;
    mAnimator.reverse();
  }
case NUMBER:
if (mNumber.length() > 0) {
  removeLastChar(mNumber);
  removeLastChar(mNumberFormatted);
  if (mCardType.hasBreakAt(mNumber.length() + 1)) {
    removeLastChar(mNumberFormatted);
  }
  if (mNumber.length() < 2) {
    setCardType(CardType.UNKNOWN);
  }
}
break;
}
mError=false;
}
 else if (!mError) {
startBlinking();
int number=keyCode - KeyEvent.KEYCODE_0;
if ((number >= 0) && (number <= 9)) {
String numberAsString=Integer.toString(number);
switch (mMode) {
case NUMBER:
mNumber.append(numberAsString);
mNumberFormatted.append(numberAsString);
int length=mNumber.length();
if (mCardType.hasBreakAt(length)) {
mNumberFormatted.append(' ');
}
if (length < 2) {
}
 else if (length == 2) {
setCardType(guessCardType(mNumber));
}
 else if (mCardType.isCorrectLength(length)) {
validateNumber();
}
break;
case EXPIRYMONTH:
if (mMonth.length() == 0) {
if ((number == 0) || (number == 1)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (mMonth.length() == 1) {
if (mMonth.charAt(0) == '1') {
if ((number == 0) || (number == 1) || (number == 2)) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (number != 0) {
mMonth.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
if (mMonth.length() == 2) {
int month=Integer.parseInt(mMonth.toString());
if ((month >= 1) && (month <= 12)) {
mExpiryFormatted.append('/');
mMode=Mode.EXPIRYYEAR;
}
}
}
break;
case EXPIRYYEAR:
final int yearLength=mYear.length();
if (yearLength == 0) {
if (number >= 1) {
mYear.append(numberAsString);
mExpiryFormatted.append(numberAsString);
}
}
 else if (yearLength == 1) {
mYear.append(numberAsString);
Calendar calendar=Calendar.getInstance();
int actualYear=calendar.get(Calendar.YEAR);
int enteredYear=2000 + Integer.parseInt(mYear.toString());
if (actualYear == enteredYear) {
int actualMonth=calendar.get(Calendar.MONTH) + 1;
int enteredMonth=Integer.parseInt(mMonth.toString());
if (actualMonth <= enteredMonth) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
 else if (actualYear < enteredYear) {
mExpiryFormatted.append(numberAsString);
mMode=Mode.CVC;
}
 else {
removeLastChar(mYear);
}
}
break;
case CVC:
if (mCVC.length() < mCardType.mCVCLength) {
mCVC.append(numberAsString);
checkIsCompleted();
}
break;
}
}
}
postInvalidate();
}"
41383,"@Override public boolean execute(CommandSender sender,String commandLabel,String[] args){
  if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
    if (args.length < 1) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return true;
    }
    Player player=getOnlinePlayer(args[0]);
    if (player == null) {
      sender.sendMessage(ChatColor.RED + args[0] + ""String_Node_Str"");
      return true;
    }
    if (((CraftPlayer)player).getHandle().playerConnection.networkManager.getVersion() >= 47) {
      if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        int fadeIn, stay, fadeOut;
        if (args.length < 5) {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
          return true;
        }
        if (isInteger(args[2])) {
          fadeIn=Integer.parseInt(args[2]);
        }
 else {
          sender.sendMessage(ChatColor.RED + args[2] + ""String_Node_Str"");
          return true;
        }
        if (isInteger(args[3])) {
          stay=Integer.parseInt(args[3]);
        }
 else {
          sender.sendMessage(ChatColor.RED + args[3] + ""String_Node_Str"");
          return true;
        }
        if (isInteger(args[4])) {
          fadeOut=Integer.parseInt(args[4]);
        }
 else {
          sender.sendMessage(ChatColor.RED + args[4] + ""String_Node_Str"");
          return true;
        }
        sendTimes(fadeIn,stay,fadeOut,player);
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
 else       if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        if (args.length < 3) {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
          return true;
        }
        sendTitle(args,2,player);
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
 else       if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        if (args.length < 3) {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
          return true;
        }
        sendSubtitle(args,2,player);
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
 else       if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        sendClear(player);
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
 else       if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        sendReset(player);
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
    }
 else {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
    }
    return true;
  }
  return false;
}","@Override public boolean execute(CommandSender sender,String commandLabel,String[] args){
  if (commandLabel.equalsIgnoreCase(""String_Node_Str"")) {
    if (args.length < 1) {
      sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return true;
    }
    ArrayList<Player> targets=new ArrayList<Player>();
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      targets.addAll(Bukkit.getOnlinePlayers());
    }
    Player player=getOnlinePlayer(args[0]);
    if (player == null) {
      sender.sendMessage(ChatColor.RED + args[0] + ""String_Node_Str"");
      return true;
    }
    targets.add(player);
    for (    Player target : targets) {
      if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        int fadeIn, stay, fadeOut;
        if (args.length < 5) {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
          return true;
        }
        if (isInteger(args[2])) {
          fadeIn=Integer.parseInt(args[2]);
        }
 else {
          sender.sendMessage(ChatColor.RED + args[2] + ""String_Node_Str"");
          return true;
        }
        if (isInteger(args[3])) {
          stay=Integer.parseInt(args[3]);
        }
 else {
          sender.sendMessage(ChatColor.RED + args[3] + ""String_Node_Str"");
          return true;
        }
        if (isInteger(args[4])) {
          fadeOut=Integer.parseInt(args[4]);
        }
 else {
          sender.sendMessage(ChatColor.RED + args[4] + ""String_Node_Str"");
          return true;
        }
        sendTimes(fadeIn,stay,fadeOut,target);
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
 else       if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        if (args.length < 3) {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
          return true;
        }
        sendTitle(args,2,target);
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
 else       if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        if (args.length < 3) {
          sender.sendMessage(ChatColor.RED + ""String_Node_Str"");
          return true;
        }
        sendSubtitle(args,2,target);
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
 else       if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        sendClear(target);
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
 else       if (args[1].equalsIgnoreCase(""String_Node_Str"")) {
        sendReset(target);
        sender.sendMessage(ChatColor.GREEN + ""String_Node_Str"");
      }
    }
    return true;
  }
  return false;
}"
41384,"public boolean equals(Object obj){
  if (!(obj instanceof ArmorStandPose)) {
    return false;
  }
 else {
    ArmorStandPose pose=(ArmorStandPose)obj;
    return this.x == pose.x && this.y == pose.y && this.z == pose.z;
  }
}","@Override public boolean equals(Object obj){
  if (!(obj instanceof ArmorStandPose)) {
    return false;
  }
 else {
    ArmorStandPose pose=(ArmorStandPose)obj;
    return this.x == pose.x && this.y == pose.y && this.z == pose.z;
  }
}"
41385,"@Override public GameProfile getProfile(String name){
  String playername=name.toLowerCase(Locale.ROOT);
  UserCacheEntry entry=stringToProfile.get(playername);
  if (entry != null && entry.isExpired()) {
    uuidToProfile.remove(playername);
    uuidToProfile.remove(entry.getProfile().getId());
    return null;
  }
  if (entry != null) {
    uuidToProfile.get(entry.getProfile().getId());
    return entry.getProfile();
  }
 else {
    GameProfile profile=lookupProfile(MinecraftServer.getServer(),playername);
    if (profile != null) {
      a(profile);
      return profile;
    }
    return null;
  }
}","@Override public GameProfile getProfile(String name){
  String playername=name.toLowerCase(Locale.ROOT);
  UserCacheEntry entry=stringToProfile.get(playername);
  if (entry != null && entry.isExpired()) {
    stringToProfile.remove(playername);
    uuidToProfile.remove(entry.getProfile().getId());
    return null;
  }
  if (entry != null) {
    uuidToProfile.get(entry.getProfile().getId());
    return entry.getProfile();
  }
 else {
    GameProfile profile=lookupProfile(MinecraftServer.getServer(),playername);
    if (profile != null) {
      a(profile);
      return profile;
    }
    return null;
  }
}"
41386,"@Override public void onLoad(){
  if (!Utilities.getMinecraftVersion(Bukkit.getVersion()).equals(supportedVersion)) {
    log.log(Level.WARNING,""String_Node_Str"",Bukkit.getVersion());
    Bukkit.shutdown();
    return;
  }
 else {
    log.log(Level.INFO,""String_Node_Str"",Bukkit.getVersion());
  }
  if (!Bukkit.getWorlds().isEmpty()) {
    log.log(Level.SEVERE,""String_Node_Str"",new Object[]{pluginDescriptionFile.getName(),pluginDescriptionFile.getVersion(),pluginDescriptionFile.getName()});
    if (spigotConfig.getBoolean(""String_Node_Str"")) {
      getServer().dispatchCommand(Bukkit.getConsoleSender(),""String_Node_Str"");
    }
    Bukkit.shutdown();
    return;
  }
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  try {
    DynamicEnumType.loadReflection();
    Utilities.instantiate(this);
    instrumentator=new Instrumentator(this,new File(getDataFolder(),""String_Node_Str"").getPath());
    instrumentator.instrumentate();
    injector=new Injector(this);
    injector.registerAll();
    injector.registerRecipes();
    entityGenerator.injectNewCreatures();
    if (getConfig().getBoolean(""String_Node_Str"",false)) {
      OptimizedUserCacheInjector.injectUserCache();
      if (getConfig().getBoolean(""String_Node_Str"",false)) {
        Carbon.log.log(Level.INFO,""String_Node_Str"");
      }
    }
  }
 catch (  Throwable e) {
    e.printStackTrace(System.out);
    log.warning(""String_Node_Str"");
    Bukkit.shutdown();
    return;
  }
  log.info(""String_Node_Str"");
}","@Override public void onLoad(){
  if (!Utilities.getMinecraftVersion(Bukkit.getVersion()).equals(supportedVersion)) {
    log.log(Level.WARNING,""String_Node_Str"",Bukkit.getVersion());
    Bukkit.shutdown();
    return;
  }
 else {
    log.log(Level.INFO,""String_Node_Str"",Bukkit.getVersion());
  }
  if (!Bukkit.getWorlds().isEmpty()) {
    log.log(Level.SEVERE,""String_Node_Str"",new Object[]{pluginDescriptionFile.getName(),pluginDescriptionFile.getVersion(),pluginDescriptionFile.getName()});
    if (spigotConfig.getBoolean(""String_Node_Str"")) {
      getServer().dispatchCommand(Bukkit.getConsoleSender(),""String_Node_Str"");
    }
    Bukkit.shutdown();
    return;
  }
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  try {
    Utilities.instantiate(this);
    instrumentator=new Instrumentator(this,new File(getDataFolder(),""String_Node_Str"").getPath());
    instrumentator.instrumentate();
    injector=new Injector(this);
    injector.registerAll();
    injector.registerRecipes();
    entityGenerator.injectNewCreatures();
    if (getConfig().getBoolean(""String_Node_Str"",false)) {
      OptimizedUserCacheInjector.injectUserCache();
      if (getConfig().getBoolean(""String_Node_Str"",false)) {
        Carbon.log.log(Level.INFO,""String_Node_Str"");
      }
    }
  }
 catch (  Throwable e) {
    e.printStackTrace(System.out);
    log.warning(""String_Node_Str"");
    Bukkit.shutdown();
    return;
  }
  log.info(""String_Node_Str"");
}"
41387,"@SuppressWarnings(""String_Node_Str"") public static <T extends Enum<?>>T addEnum(Class<T> enumType,String enumName,Class<?>[] paramTypes,Object[] paramValues){
  if (!Enum.class.isAssignableFrom(enumType)) {
    throw new RuntimeException(""String_Node_Str"" + enumType + ""String_Node_Str"");
  }
  Field valuesField=null;
  Field[] fields=enumType.getDeclaredFields();
  for (  Field field : fields) {
    if (field.getName().contains(""String_Node_Str"")) {
      valuesField=field;
      break;
    }
  }
  AccessibleObject.setAccessible(new Field[]{valuesField},true);
  try {
    T[] previousValues=(T[])valuesField.get(enumType);
    List<T> values=new ArrayList<T>(Arrays.asList(previousValues));
    T newValue=(T)makeEnum(enumType,enumName,values.size(),paramTypes,paramValues);
    values.add(newValue);
    setFailsafeFieldValue(valuesField,null,values.toArray((T[])Array.newInstance(enumType,0)));
    cleanEnumCache(enumType);
    return newValue;
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
    throw new RuntimeException(e.getMessage(),e);
  }
}","@SuppressWarnings(""String_Node_Str"") public static <T extends Enum<?>>T addEnum(Class<T> enumType,String enumName,Class<?>[] paramTypes,Object[] paramValues){
  if (!Enum.class.isAssignableFrom(enumType)) {
    throw new RuntimeException(""String_Node_Str"" + enumType + ""String_Node_Str"");
  }
  try {
    Field valuesField=enumType.getDeclaredField(""String_Node_Str"");
    valuesField.setAccessible(true);
    T[] previousValues=(T[])valuesField.get(enumType);
    List<T> values=new ArrayList<T>(Arrays.asList(previousValues));
    T newValue=(T)makeEnum(enumType,enumName,values.size(),paramTypes,paramValues);
    values.add(newValue);
    setField(valuesField,null,values.toArray((Enum[])Array.newInstance(enumType,0)));
    cleanEnumCache(enumType);
    return newValue;
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e.getMessage(),e);
  }
}"
41388,"private static void cleanEnumCache(Class<?> enumClass) throws NoSuchFieldException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  blankField(enumClass,""String_Node_Str"");
  blankField(enumClass,""String_Node_Str"");
}","private static void cleanEnumCache(Class<?> enumClass) throws NoSuchFieldException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException {
  setField(Class.class.getDeclaredField(""String_Node_Str""),enumClass,null);
}"
41389,"public static Object makeEnum(Class<?> enumClass,String value,int ordinal,Class<?>[] additionalTypes,Object[] additionalValues) throws Exception {
  Object[] parms=new Object[additionalValues.length + 2];
  parms[0]=value;
  parms[1]=ordinal;
  System.arraycopy(additionalValues,0,parms,2,additionalValues.length);
  return enumClass.cast(constructorAccesor.invoke(getConstructorAccessor(enumClass,additionalTypes),new Object[]{parms}));
}","public static Object makeEnum(Class<?> enumClass,String name,int ordinal,Class<?>[] paramTypes,Object[] paramValues) throws Exception {
  ArrayList<Class<?>> allParamTypes=new ArrayList<Class<?>>();
  allParamTypes.add(String.class);
  allParamTypes.add(Integer.TYPE);
  allParamTypes.addAll(Arrays.asList(paramTypes));
  ArrayList<Object> allParamValues=new ArrayList<Object>();
  allParamValues.add(name);
  allParamValues.add(Integer.valueOf(ordinal));
  allParamValues.addAll(Arrays.asList(paramValues));
  Constructor<?> enumConstructor=enumClass.getDeclaredConstructor((Class[])allParamTypes.toArray(new Class[0]));
  ConstructorAccessor constructorAccessor=ReflectionFactory.getReflectionFactory().newConstructorAccessor(enumConstructor);
  return constructorAccessor.newInstance(allParamValues.toArray(new Object[0]));
}"
41390,"@Override public void c(){
  System.out.println(""String_Node_Str"");
  ArrayList<UserCacheEntry> list=new ArrayList<UserCacheEntry>();
  int saved=0;
  for (  UserCacheEntry entry : uuidToProfile.values()) {
    if (saved > SpigotConfig.userCacheCap) {
      break;
    }
    list.add(entry);
    saved++;
  }
  System.out.println(list.size());
  String data=gson.toJson(list);
  BufferedWriter bufferedwriter=null;
  try {
    bufferedwriter=Files.newWriter(userCacheFile,Charsets.UTF_8);
    bufferedwriter.write(data);
  }
 catch (  FileNotFoundException filenotfoundexception) {
  }
catch (  IOException ioexception) {
  }
 finally {
    IOUtils.closeQuietly(bufferedwriter);
  }
}","@Override public void c(){
  ArrayList<UserCacheEntry> list=new ArrayList<UserCacheEntry>();
  int saved=0;
  for (  UserCacheEntry entry : uuidToProfile.values()) {
    if (saved > SpigotConfig.userCacheCap) {
      break;
    }
    list.add(entry);
    saved++;
  }
  String data=gson.toJson(list);
  BufferedWriter bufferedwriter=null;
  try {
    bufferedwriter=Files.newWriter(userCacheFile,Charsets.UTF_8);
    bufferedwriter.write(data);
  }
 catch (  FileNotFoundException filenotfoundexception) {
  }
catch (  IOException ioexception) {
  }
 finally {
    IOUtils.closeQuietly(bufferedwriter);
  }
}"
41391,"private Player getOnlinePlayer(String name){
  for (  Player p : Bukkit.getOnlinePlayers()) {
    if (p.getName() == name) {
      return p;
    }
  }
  return null;
}","private Player getOnlinePlayer(String name){
  for (  Player p : Bukkit.getOnlinePlayers()) {
    Bukkit.getLogger().log(Level.SEVERE,p.getName());
    if (p.getName().equalsIgnoreCase(name)) {
      return p;
    }
  }
  return null;
}"
41392,"public BlockDaylightDetector(boolean inverted){
  super();
  this.inverted=inverted;
  this.a(0.0F,0.0F,0.0F,1.0F,0.375F,1.0F);
  this.a(CreativeModeTab.d);
}","public BlockDaylightDetector(boolean inverted){
  super();
  this.inverted=inverted;
  this.a(0.0F,0.0F,0.0F,1.0F,0.375F,1.0F);
  c(0.2f);
  this.a(CreativeModeTab.d);
}"
41393,"@EventHandler public void onDaylightChange(PlayerInteractEvent evt){
  Player player=evt.getPlayer();
  if (evt.getAction() == Action.RIGHT_CLICK_BLOCK) {
    if (evt.getClickedBlock().getType() == Carbon.injector().daylightDetectorInvertedMat) {
      try {
        CraftBlock craftBlock=(CraftBlock)evt.getClickedBlock();
        craftBlock.setType(Material.DAYLIGHT_DETECTOR);
        Method method=CraftBlock.class.getDeclaredMethod(""String_Node_Str"",net.minecraft.server.v1_7_R4.Block.class);
        method.setAccessible(true);
        net.minecraft.server.v1_7_R4.Block nmsBlock=(net.minecraft.server.v1_7_R4.Block)method.invoke(craftBlock,Void.class);
        BlockDaylightDetector detector=(BlockDaylightDetector)nmsBlock;
        detector.setInverted(false);
        player.getWorld().playSound(evt.getClickedBlock().getLocation(),Sound.CLICK,1,1);
      }
 catch (      NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(BlockListener.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
 else     if (evt.getClickedBlock().getType() == Material.DAYLIGHT_DETECTOR) {
      try {
        CraftBlock craftBlock=(CraftBlock)evt.getClickedBlock();
        craftBlock.setType(Carbon.injector().daylightDetectorInvertedMat);
        Method method=CraftBlock.class.getDeclaredMethod(""String_Node_Str"",net.minecraft.server.v1_7_R4.Block.class);
        method.setAccessible(true);
        net.minecraft.server.v1_7_R4.Block nmsBlock=(net.minecraft.server.v1_7_R4.Block)method.invoke(craftBlock,Void.class);
        BlockDaylightDetector detector=(BlockDaylightDetector)nmsBlock;
        detector.setInverted(true);
        player.getWorld().playSound(evt.getClickedBlock().getLocation(),Sound.CLICK,1,1);
      }
 catch (      NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(BlockListener.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  }
}","@EventHandler public void onDaylightChange(PlayerInteractEvent evt){
  Player player=evt.getPlayer();
  if (evt.getAction() == Action.RIGHT_CLICK_BLOCK) {
    if (evt.getClickedBlock().getType() == Carbon.injector().daylightDetectorInvertedMat) {
      try {
        CraftBlock craftBlock=(CraftBlock)evt.getClickedBlock();
        craftBlock.setType(Material.DAYLIGHT_DETECTOR);
        Method method=CraftBlock.class.getDeclaredMethod(""String_Node_Str"");
        method.setAccessible(true);
        net.minecraft.server.v1_7_R4.Block nmsBlock=(net.minecraft.server.v1_7_R4.Block)method.invoke(craftBlock);
        BlockDaylightDetector detector=(BlockDaylightDetector)nmsBlock;
        detector.setInverted(false);
        player.getWorld().playSound(evt.getClickedBlock().getLocation(),Sound.CLICK,1,1);
      }
 catch (      NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(BlockListener.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
 else     if (evt.getClickedBlock().getType() == Material.DAYLIGHT_DETECTOR) {
      try {
        CraftBlock craftBlock=(CraftBlock)evt.getClickedBlock();
        craftBlock.setType(Carbon.injector().daylightDetectorInvertedMat);
        Method method=CraftBlock.class.getDeclaredMethod(""String_Node_Str"");
        method.setAccessible(true);
        net.minecraft.server.v1_7_R4.Block nmsBlock=(net.minecraft.server.v1_7_R4.Block)method.invoke(craftBlock);
        BlockDaylightDetector detector=(BlockDaylightDetector)nmsBlock;
        detector.setInverted(true);
        player.getWorld().playSound(evt.getClickedBlock().getLocation(),Sound.CLICK,1,1);
      }
 catch (      NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException ex) {
        Logger.getLogger(BlockListener.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  }
}"
41394,"@Override public void onLoad(){
  if (!Bukkit.getWorlds().isEmpty()) {
    log.log(Level.SEVERE,""String_Node_Str"",new Object[]{pluginDescriptionFile.getName(),pluginDescriptionFile.getVersion(),pluginDescriptionFile.getName()});
    if (spigotConfig.getBoolean(""String_Node_Str"")) {
      getServer().dispatchCommand(Bukkit.getConsoleSender(),""String_Node_Str"");
    }
    Bukkit.shutdown();
    return;
  }
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  try {
    DynamicEnumType.loadReflection();
    Utilities.instantiate(this);
    injector=new Injector(this);
    injector.registerAll();
    injector.registerRecipes();
    entityGenerator.injectNewCreatures();
    instrumentator=new Instrumentator(this,new File(getDataFolder(),""String_Node_Str"").getPath());
    instrumentator.instrumentate();
  }
 catch (  Exception e) {
    e.printStackTrace();
    Bukkit.shutdown();
  }
  log.info(""String_Node_Str"");
}","@Override public void onLoad(){
  if (!Bukkit.getWorlds().isEmpty()) {
    log.log(Level.SEVERE,""String_Node_Str"",new Object[]{pluginDescriptionFile.getName(),pluginDescriptionFile.getVersion(),pluginDescriptionFile.getName()});
    if (spigotConfig.getBoolean(""String_Node_Str"")) {
      getServer().dispatchCommand(Bukkit.getConsoleSender(),""String_Node_Str"");
    }
    Bukkit.shutdown();
    return;
  }
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  saveResource(""String_Node_Str"",true);
  try {
    DynamicEnumType.loadReflection();
    Utilities.instantiate(this);
    injector=new Injector(this);
    injector.registerAll();
    injector.registerRecipes();
    entityGenerator.injectNewCreatures();
    instrumentator=new Instrumentator(this,new File(getDataFolder(),""String_Node_Str"").getPath());
    instrumentator.instrumentate();
  }
 catch (  Exception e) {
    e.printStackTrace();
    log.warning(""String_Node_Str"");
    Bukkit.shutdown();
  }
  log.info(""String_Node_Str"");
}"
41395,"public void track(List<EntityPlayer> list){
  this.n=false;
  if ((!this.isMoving) || (this.tracker.e(this.q,this.r,this.s) > 16.0D)) {
    this.q=this.tracker.locX;
    this.r=this.tracker.locY;
    this.s=this.tracker.locZ;
    this.isMoving=true;
    this.n=true;
    scanPlayers(list);
  }
  if ((this.w != this.tracker.vehicle) || ((this.tracker.vehicle != null) && (this.m % 60 == 0))) {
    this.w=this.tracker.vehicle;
    broadcast(new PacketPlayOutAttachEntity(0,this.tracker,this.tracker.vehicle));
  }
  if ((this.tracker instanceof EntityItemFrame)) {
    EntityItemFrame i3=(EntityItemFrame)this.tracker;
    ItemStack i4=i3.getItem();
    if ((this.m % 10 == 0) && (i4 != null) && ((i4.getItem() instanceof ItemWorldMap))) {
      WorldMap i6=Items.MAP.getSavedMap(i4,this.tracker.world);
      Iterator<EntityPlayer> i7=this.trackedPlayers.iterator();
      while (i7.hasNext()) {
        EntityHuman i8=(EntityHuman)i7.next();
        EntityPlayer i9=(EntityPlayer)i8;
        i6.a(i9,i4);
        Packet j0=Items.MAP.c(i4,this.tracker.world,i9);
        if (j0 != null) {
          i9.playerConnection.sendPacket(j0);
        }
      }
    }
    b();
  }
 else   if ((this.m % this.c == 0) || (this.tracker.al) || (this.tracker.getDataWatcher().a())) {
    if (this.tracker.vehicle == null) {
      this.v+=1;
      int i=this.tracker.as.a(this.tracker.locX);
      int j=MathHelper.floor(this.tracker.locY * 32.0D);
      int k=this.tracker.as.a(this.tracker.locZ);
      int l=MathHelper.d(this.tracker.yaw * 256.0F / 360.0F);
      int i1=MathHelper.d(this.tracker.pitch * 256.0F / 360.0F);
      int j1=i - this.xLoc;
      int k1=j - this.yLoc;
      int l1=k - this.zLoc;
      Object object=null;
      boolean flag=(Math.abs(j1) >= 4) || (Math.abs(k1) >= 4) || (Math.abs(l1) >= 4)|| (this.m % 60 == 0);
      boolean flag1=(Math.abs(l - this.yRot) >= 4) || (Math.abs(i1 - this.xRot) >= 4);
      if (flag) {
        this.xLoc=i;
        this.yLoc=j;
        this.zLoc=k;
      }
      if (flag1) {
        this.yRot=l;
        this.xRot=i1;
      }
      if ((this.m > 0) || ((this.tracker instanceof EntityArrow))) {
        if ((j1 >= -128) && (j1 < 128) && (k1 >= -128)&& (k1 < 128)&& (l1 >= -128)&& (l1 < 128)&& (this.v <= 400)&& (!this.x)) {
          if ((flag) && (flag1)) {
            object=new PacketPlayOutRelEntityMoveLook(this.tracker.getId(),(byte)j1,(byte)k1,(byte)l1,(byte)l,(byte)i1,this.tracker.onGround);
          }
 else           if (flag) {
            object=new PacketPlayOutRelEntityMove(this.tracker.getId(),(byte)j1,(byte)k1,(byte)l1,this.tracker.onGround);
          }
 else           if (flag1) {
            object=new PacketPlayOutEntityLook(this.tracker.getId(),(byte)l,(byte)i1,this.tracker.onGround);
          }
        }
 else {
          this.v=0;
          if ((this.tracker instanceof EntityPlayer)) {
            scanPlayers(new ArrayList<EntityPlayer>(this.trackedPlayers));
          }
          object=new PacketPlayOutEntityTeleport(this.tracker.getId(),i,j,k,(byte)l,(byte)i1,this.tracker.onGround,((this.tracker instanceof EntityFallingBlock)) || ((this.tracker instanceof EntityTNTPrimed)));
        }
      }
      if (this.u) {
        double d0=this.tracker.motX - this.j;
        double d1=this.tracker.motY - this.k;
        double d2=this.tracker.motZ - this.l;
        double d3=0.02D;
        double d4=d0 * d0 + d1 * d1 + d2 * d2;
        if ((d4 > d3 * d3) || ((d4 > 0.0D) && (this.tracker.motX == 0.0D) && (this.tracker.motY == 0.0D)&& (this.tracker.motZ == 0.0D))) {
          this.j=this.tracker.motX;
          this.k=this.tracker.motY;
          this.l=this.tracker.motZ;
          broadcast(new PacketPlayOutEntityVelocity(this.tracker.getId(),this.j,this.k,this.l));
        }
      }
      if (object != null) {
        broadcast((Packet)object);
      }
      b();
      this.x=false;
    }
 else {
      i=MathHelper.d(this.tracker.yaw * 256.0F / 360.0F);
      int j=MathHelper.d(this.tracker.pitch * 256.0F / 360.0F);
      boolean flag2=(Math.abs(i - this.yRot) >= 4) || (Math.abs(j - this.xRot) >= 4);
      if (flag2) {
        broadcast(new PacketPlayOutEntityLook(this.tracker.getId(),(byte)i,(byte)j,this.tracker.onGround));
        this.yRot=i;
        this.xRot=j;
      }
      this.xLoc=this.tracker.as.a(this.tracker.locX);
      this.yLoc=MathHelper.floor(this.tracker.locY * 32.0D);
      this.zLoc=this.tracker.as.a(this.tracker.locZ);
      b();
      this.x=true;
    }
    int i=MathHelper.d(this.tracker.getHeadRotation() * 256.0F / 360.0F);
    if (Math.abs(i - this.i) >= 4) {
      broadcast(new PacketPlayOutEntityHeadRotation(this.tracker,(byte)i));
      this.i=i;
    }
    this.tracker.al=false;
  }
  this.m+=1;
  if (this.tracker.velocityChanged) {
    boolean cancelled=false;
    if ((this.tracker instanceof EntityPlayer)) {
      Player player=(Player)this.tracker.getBukkitEntity();
      Vector velocity=player.getVelocity();
      PlayerVelocityEvent event=new PlayerVelocityEvent(player,velocity);
      this.tracker.world.getServer().getPluginManager().callEvent(event);
      if (event.isCancelled()) {
        cancelled=true;
      }
 else       if (!velocity.equals(event.getVelocity())) {
        player.setVelocity(velocity);
      }
    }
    if (!cancelled) {
      broadcastIncludingSelf(new PacketPlayOutEntityVelocity(this.tracker));
    }
    this.tracker.velocityChanged=false;
  }
}","public void track(List<EntityPlayer> list){
  this.n=false;
  if ((!this.isMoving) || (this.tracker.e(this.q,this.r,this.s) > 16.0D)) {
    this.q=this.tracker.locX;
    this.r=this.tracker.locY;
    this.s=this.tracker.locZ;
    this.isMoving=true;
    this.n=true;
    scanPlayers(list);
  }
  if ((this.w != this.tracker.vehicle) || ((this.tracker.vehicle != null) && (this.m % 60 == 0))) {
    this.w=this.tracker.vehicle;
    broadcast(new PacketPlayOutAttachEntity(0,this.tracker,this.tracker.vehicle));
  }
  if ((this.tracker instanceof EntityItemFrame)) {
    EntityItemFrame i3=(EntityItemFrame)this.tracker;
    ItemStack i4=i3.getItem();
    if ((this.m % 10 == 0) && (i4 != null) && ((i4.getItem() instanceof ItemWorldMap))) {
      WorldMap i6=Items.MAP.getSavedMap(i4,this.tracker.world);
      Iterator<EntityPlayer> i7=this.trackedPlayers.iterator();
      while (i7.hasNext()) {
        EntityHuman i8=(EntityHuman)i7.next();
        EntityPlayer i9=(EntityPlayer)i8;
        i6.a(i9,i4);
        Packet j0=Items.MAP.c(i4,this.tracker.world,i9);
        if (j0 != null) {
          i9.playerConnection.sendPacket(j0);
        }
      }
    }
    b();
  }
 else   if ((this.m % this.c == 0) || (this.tracker.al) || (this.tracker.getDataWatcher().a())) {
    if (this.tracker.vehicle == null) {
      this.v+=1;
      int i=this.tracker.as.a(this.tracker.locX);
      int j=MathHelper.floor(this.tracker.locY * 32.0D);
      int k=this.tracker.as.a(this.tracker.locZ);
      int l=MathHelper.d(this.tracker.yaw * 256.0F / 360.0F);
      int i1=MathHelper.d(this.tracker.pitch * 256.0F / 360.0F);
      int j1=i - this.xLoc;
      int k1=j - this.yLoc;
      int l1=k - this.zLoc;
      Object object=null;
      boolean flag=(Math.abs(j1) >= 4) || (Math.abs(k1) >= 4) || (Math.abs(l1) >= 4)|| (this.m % 60 == 0);
      boolean flag1=(Math.abs(l - this.yRot) >= 4) || (Math.abs(i1 - this.xRot) >= 4);
      if (flag) {
        this.xLoc=i;
        this.yLoc=j;
        this.zLoc=k;
      }
      if (flag1) {
        this.yRot=l;
        this.xRot=i1;
      }
      if ((this.m > 0) || ((this.tracker instanceof EntityArrow))) {
        if ((j1 >= -128) && (j1 < 128) && (k1 >= -128)&& (k1 < 128)&& (l1 >= -128)&& (l1 < 128)&& (this.v <= 400)&& (!this.x)) {
          if ((flag) && (flag1)) {
            object=new PacketPlayOutRelEntityMoveLook(this.tracker.getId(),(byte)j1,(byte)k1,(byte)l1,(byte)l,(byte)i1,this.tracker.onGround);
          }
 else           if (flag) {
            object=new PacketPlayOutRelEntityMove(this.tracker.getId(),(byte)j1,(byte)k1,(byte)l1,this.tracker.onGround);
          }
 else           if (flag1) {
            object=new PacketPlayOutEntityLook(this.tracker.getId(),(byte)l,(byte)i1,this.tracker.onGround);
          }
        }
 else {
          this.v=0;
          if ((this.tracker instanceof EntityPlayer)) {
            scanPlayers(new ArrayList<EntityPlayer>(this.trackedPlayers));
          }
          object=new PacketPlayOutEntityTeleport(this.tracker.getId(),i,j,k,(byte)l,(byte)i1,this.tracker.onGround);
        }
      }
      if (this.u) {
        double d0=this.tracker.motX - this.j;
        double d1=this.tracker.motY - this.k;
        double d2=this.tracker.motZ - this.l;
        double d3=0.02D;
        double d4=d0 * d0 + d1 * d1 + d2 * d2;
        if ((d4 > d3 * d3) || ((d4 > 0.0D) && (this.tracker.motX == 0.0D) && (this.tracker.motY == 0.0D)&& (this.tracker.motZ == 0.0D))) {
          this.j=this.tracker.motX;
          this.k=this.tracker.motY;
          this.l=this.tracker.motZ;
          broadcast(new PacketPlayOutEntityVelocity(this.tracker.getId(),this.j,this.k,this.l));
        }
      }
      if (object != null) {
        broadcast((Packet)object);
      }
      b();
      this.x=false;
    }
 else {
      i=MathHelper.d(this.tracker.yaw * 256.0F / 360.0F);
      int j=MathHelper.d(this.tracker.pitch * 256.0F / 360.0F);
      boolean flag2=(Math.abs(i - this.yRot) >= 4) || (Math.abs(j - this.xRot) >= 4);
      if (flag2) {
        broadcast(new PacketPlayOutEntityLook(this.tracker.getId(),(byte)i,(byte)j,this.tracker.onGround));
        this.yRot=i;
        this.xRot=j;
      }
      this.xLoc=this.tracker.as.a(this.tracker.locX);
      this.yLoc=MathHelper.floor(this.tracker.locY * 32.0D);
      this.zLoc=this.tracker.as.a(this.tracker.locZ);
      b();
      this.x=true;
    }
    int i=MathHelper.d(this.tracker.getHeadRotation() * 256.0F / 360.0F);
    if (Math.abs(i - this.i) >= 4) {
      broadcast(new PacketPlayOutEntityHeadRotation(this.tracker,(byte)i));
      this.i=i;
    }
    this.tracker.al=false;
  }
  this.m+=1;
  if (this.tracker.velocityChanged) {
    boolean cancelled=false;
    if ((this.tracker instanceof EntityPlayer)) {
      Player player=(Player)this.tracker.getBukkitEntity();
      Vector velocity=player.getVelocity();
      PlayerVelocityEvent event=new PlayerVelocityEvent(player,velocity);
      this.tracker.world.getServer().getPluginManager().callEvent(event);
      if (event.isCancelled()) {
        cancelled=true;
      }
 else       if (!velocity.equals(event.getVelocity())) {
        player.setVelocity(velocity);
      }
    }
    if (!cancelled) {
      broadcastIncludingSelf(new PacketPlayOutEntityVelocity(this.tracker));
    }
    this.tracker.velocityChanged=false;
  }
}"
41396,"public ItemMeta.Spigot spigot(){
  return this.spigot;
}","public Spigot spigot(){
  return this.spigot;
}"
41397,"public void setItemValues(ItemStack itemStack){
  this.patterns=null;
  if (itemStack.hasTag() && itemStack.getTag().hasKeyOfType(""String_Node_Str"",10)) {
    NBTTagCompound compound=itemStack.getTag().getCompound(""String_Node_Str"");
    if (compound.hasKey(""String_Node_Str"")) {
      this.patterns=(NBTTagList)compound.getList(""String_Node_Str"",10).clone();
    }
    if (compound.hasKeyOfType(""String_Node_Str"",99)) {
      this.baseColor=compound.getInt(""String_Node_Str"");
    }
 else {
      this.baseColor=itemStack.getData() & 15;
    }
  }
}","public void setItemValues(ItemStack itemStack){
  this.patterns=null;
  if (itemStack.hasTag() && itemStack.getTag().hasKeyOfType(""String_Node_Str"",10)) {
    NBTTagCompound compound=itemStack.getTag().getCompound(""String_Node_Str"");
    if (compound.hasKeyOfType(""String_Node_Str"",99)) {
      this.baseColor=compound.getInt(""String_Node_Str"");
    }
 else {
      this.baseColor=itemStack.getData() & 15;
    }
    if (compound.hasKey(""String_Node_Str"")) {
      this.patterns=(NBTTagList)compound.getList(""String_Node_Str"",10).clone();
    }
    NBTTagList lorepatterns=EnumBannerPatterns.fromLoreToNBT(itemStack);
    if (lorepatterns != null) {
      for (int i=0; i < lorepatterns.size(); i++) {
        patterns.add(lorepatterns.get(i));
      }
    }
  }
 else {
    this.baseColor=itemStack.getData() & 15;
  }
}"
41398,"@Override void applyToItem(NBTTagCompound tag){
  super.applyToItem(tag);
  tag.set(""String_Node_Str"",new NBTTagCompound());
  NBTTagCompound compound=tag.getCompound(""String_Node_Str"");
  compound.setInt(""String_Node_Str"",baseColor);
  NBTTagList patterns=new NBTTagList();
  for (  Entry<String,Integer> entry : patternsData.entrySet()) {
    NBTTagCompound pattern=new NBTTagCompound();
    pattern.setString(""String_Node_Str"",entry.getKey());
    pattern.setInt(""String_Node_Str"",entry.getValue());
    patterns.add(pattern);
  }
  if (patterns.size() != 0) {
    compound.set(""String_Node_Str"",patterns);
  }
}","@Override void applyToItem(NBTTagCompound tag){
  super.applyToItem(tag);
  tag.set(""String_Node_Str"",new NBTTagCompound());
  NBTTagCompound compound=tag.getCompound(""String_Node_Str"");
  if (baseColor != -1) {
    compound.setInt(""String_Node_Str"",baseColor);
  }
  NBTTagList patterns=new NBTTagList();
  for (  Entry<String,Integer> entry : patternsData.entrySet()) {
    NBTTagCompound pattern=new NBTTagCompound();
    pattern.setString(""String_Node_Str"",entry.getKey());
    pattern.setInt(""String_Node_Str"",entry.getValue());
    patterns.add(pattern);
  }
  if (patterns.size() != 0) {
    compound.set(""String_Node_Str"",patterns);
  }
}"
41399,"@Override public void onLoad(){
  if (!Bukkit.getWorlds().isEmpty()) {
    log.log(Level.SEVERE,""String_Node_Str"",new Object[]{pluginDescriptionFile.getName(),pluginDescriptionFile.getVersion(),pluginDescriptionFile.getName()});
    if (spigot.getBoolean(""String_Node_Str"")) {
      getServer().dispatchCommand(Bukkit.getConsoleSender(),""String_Node_Str"");
    }
    Bukkit.shutdown();
    return;
  }
  try {
    DynamicEnumType.loadReflection();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  injector=new Injector();
  injector.registerAll();
  injector.registerRecipes();
  worldGenerator.populate();
  log.info(""String_Node_Str"");
}","@Override public void onLoad(){
  if (!Bukkit.getWorlds().isEmpty()) {
    log.log(Level.SEVERE,""String_Node_Str"",new Object[]{pluginDescriptionFile.getName(),pluginDescriptionFile.getVersion(),pluginDescriptionFile.getName()});
    if (spigot.getBoolean(""String_Node_Str"")) {
      getServer().dispatchCommand(Bukkit.getConsoleSender(),""String_Node_Str"");
    }
    Bukkit.shutdown();
    return;
  }
  try {
    DynamicEnumType.loadReflection();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  injector=new Injector();
  injector.registerAll();
  injector.registerRecipes();
  log.info(""String_Node_Str"");
}"
41400,"@Override public void onEnable(){
  Utilities.instantiate(this);
  saveDefaultConfig();
  if (!this.getDataFolder().exists()) {
    this.getDataFolder().mkdirs();
  }
  reloadConfig();
  getServer().getPluginManager().registerEvents(blockListener,this);
  getServer().getPluginManager().registerEvents(commandListener,this);
  getServer().getPluginManager().registerEvents(itemListener,this);
  getServer().getPluginManager().registerEvents(worldGenerator,this);
  getServer().getPluginManager().registerEvents(worldBorderListener,this);
  protocolBlocker.loadConfig();
  getServer().getPluginManager().registerEvents(protocolBlocker,this);
  if (getConfig().getDouble(""String_Node_Str"",0.0f) < localConfigVersion) {
    log.warning(""String_Node_Str"");
  }
  if (getServer().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    try {
      new ProtocolBlockListener(this).init();
      new ProtocolItemListener(this).init();
      new ProtocolEntityListener(this).init();
    }
 catch (    Throwable t) {
      t.printStackTrace();
    }
  }
 else {
    log.info(""String_Node_Str"");
  }
  try {
    Metrics metrics=new Metrics(this);
    metrics.start();
  }
 catch (  IOException e) {
  }
  log.info(""String_Node_Str"");
}","@Override public void onEnable(){
  Utilities.instantiate(this);
  saveDefaultConfig();
  if (!this.getDataFolder().exists()) {
    this.getDataFolder().mkdirs();
  }
  reloadConfig();
  getServer().getPluginManager().registerEvents(blockListener,this);
  getServer().getPluginManager().registerEvents(commandListener,this);
  getServer().getPluginManager().registerEvents(itemListener,this);
  getServer().getPluginManager().registerEvents(worldGenerator,this);
  getServer().getPluginManager().registerEvents(worldBorderListener,this);
  protocolBlocker.loadConfig();
  getServer().getPluginManager().registerEvents(protocolBlocker,this);
  worldGenerator.populate();
  if (getConfig().getDouble(""String_Node_Str"",0.0f) < localConfigVersion) {
    log.warning(""String_Node_Str"");
  }
  if (getServer().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    try {
      new ProtocolBlockListener(this).init();
      new ProtocolItemListener(this).init();
      new ProtocolEntityListener(this).init();
    }
 catch (    Throwable t) {
      t.printStackTrace();
    }
  }
 else {
    log.info(""String_Node_Str"");
  }
  try {
    Metrics metrics=new Metrics(this);
    metrics.start();
  }
 catch (  IOException e) {
  }
  log.info(""String_Node_Str"");
}"
41401,"@SuppressWarnings(""String_Node_Str"") @EventHandler(priority=EventPriority.MONITOR,ignoreCancelled=true) public void slabInteract(PlayerInteractEvent event){
  if (event.getItem() == null) {
    return;
  }
  if (event.getItem().getType().toString().equals(""String_Node_Str"")) {
    if (event.getAction() == Action.RIGHT_CLICK_BLOCK) {
      if (event.getClickedBlock().getState().getData().toString().equals(""String_Node_Str"")) {
        if (event.getBlockFace().toString().equals(""String_Node_Str"")) {
          event.getClickedBlock().setType(Carbon.injector().redSandstoneDoubleSlabMat);
          if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
            event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
          }
          event.setCancelled(true);
        }
      }
      if (event.getClickedBlock().getState().getData().toString().equals(""String_Node_Str"")) {
        if (event.getBlockFace().toString().equals(""String_Node_Str"")) {
          event.getClickedBlock().setType(Carbon.injector().redSandstoneDoubleSlabMat);
          event.getClickedBlock().setData((byte)0);
          if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
            event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
          }
          event.setCancelled(true);
        }
      }
      org.bukkit.block.Block block=event.getClickedBlock();
switch (event.getBlockFace().toString()) {
case ""String_Node_Str"":
{
          org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX(),block.getY(),block.getZ() - 1);
          if (adjacent.getType().toString().equals(""String_Node_Str"")) {
            adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
            adjacent.setData((byte)0);
            if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
              event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
            }
            event.setCancelled(true);
          }
        }
case ""String_Node_Str"":
{
        org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX(),block.getY(),block.getZ() + 1);
        if (adjacent.getType().toString().equals(""String_Node_Str"")) {
          adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
          adjacent.setData((byte)0);
          if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
            event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
          }
          event.setCancelled(true);
        }
      }
case ""String_Node_Str"":
{
      org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX() - 1,block.getY(),block.getZ());
      if (adjacent.getType().toString().equals(""String_Node_Str"")) {
        adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
        adjacent.setData((byte)0);
        if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
          event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
        }
        event.setCancelled(true);
      }
    }
case ""String_Node_Str"":
{
    org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX() + 1,block.getY(),block.getZ());
    if (adjacent.getType().toString().equals(""String_Node_Str"")) {
      adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
      adjacent.setData((byte)0);
      if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
        event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
      }
      event.setCancelled(true);
    }
  }
case ""String_Node_Str"":
{
  org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX(),block.getY() - 1,block.getZ());
  if (adjacent.getType().toString().equals(""String_Node_Str"")) {
    adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
    adjacent.setData((byte)0);
    if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
      event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
    }
    event.setCancelled(true);
  }
}
case ""String_Node_Str"":
{
org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX(),block.getY() + 1,block.getZ());
if (adjacent.getType().toString().equals(""String_Node_Str"")) {
  adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
  adjacent.setData((byte)0);
  if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
    event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
  }
  event.setCancelled(true);
}
}
}
}
}
}","@SuppressWarnings(""String_Node_Str"") @EventHandler(priority=EventPriority.MONITOR,ignoreCancelled=true) public void slabInteract(PlayerInteractEvent event){
  if (event.getItem() == null) {
    return;
  }
  if (event.getItem().getType().toString().equals(""String_Node_Str"")) {
    if (event.getAction() == Action.RIGHT_CLICK_BLOCK) {
      if (event.getClickedBlock().getState().getData().toString().equals(""String_Node_Str"")) {
        if (event.getBlockFace().toString().equals(""String_Node_Str"")) {
          event.getClickedBlock().setType(Carbon.injector().redSandstoneDoubleSlabMat);
          if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
            event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
          }
          event.setCancelled(true);
        }
      }
      if (event.getClickedBlock().getState().getData().toString().equals(""String_Node_Str"")) {
        if (event.getBlockFace().toString().equals(""String_Node_Str"")) {
          event.getClickedBlock().setType(Carbon.injector().redSandstoneDoubleSlabMat);
          event.getClickedBlock().setData((byte)0);
          if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
            event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
          }
          event.setCancelled(true);
        }
      }
      org.bukkit.block.Block block=event.getClickedBlock();
switch (event.getBlockFace().toString()) {
case ""String_Node_Str"":
{
          org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX(),block.getY(),block.getZ() - 1);
          if (adjacent.getType().toString().equals(""String_Node_Str"")) {
            adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
            adjacent.setData((byte)0);
            if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
              event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
            }
            event.setCancelled(true);
          }
          break;
        }
case ""String_Node_Str"":
{
        org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX(),block.getY(),block.getZ() + 1);
        if (adjacent.getType().toString().equals(""String_Node_Str"")) {
          adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
          adjacent.setData((byte)0);
          if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
            event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
          }
          event.setCancelled(true);
        }
        break;
      }
case ""String_Node_Str"":
{
      org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX() - 1,block.getY(),block.getZ());
      if (adjacent.getType().toString().equals(""String_Node_Str"")) {
        adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
        adjacent.setData((byte)0);
        if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
          event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
        }
        event.setCancelled(true);
      }
      break;
    }
case ""String_Node_Str"":
{
    org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX() + 1,block.getY(),block.getZ());
    if (adjacent.getType().toString().equals(""String_Node_Str"")) {
      adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
      adjacent.setData((byte)0);
      if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
        event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
      }
      event.setCancelled(true);
    }
    break;
  }
case ""String_Node_Str"":
{
  org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX(),block.getY() - 1,block.getZ());
  if (adjacent.getType().toString().equals(""String_Node_Str"")) {
    adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
    adjacent.setData((byte)0);
    if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
      event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
    }
    event.setCancelled(true);
  }
  break;
}
case ""String_Node_Str"":
{
org.bukkit.block.Block adjacent=block.getWorld().getBlockAt(block.getX(),block.getY() + 1,block.getZ());
if (adjacent.getType().toString().equals(""String_Node_Str"")) {
  adjacent.setType(Carbon.injector().redSandstoneDoubleSlabMat);
  adjacent.setData((byte)0);
  if (event.getPlayer().getGameMode() != GameMode.CREATIVE) {
    event.getPlayer().getItemInHand().setAmount(event.getPlayer().getItemInHand().getAmount() - 1);
  }
  event.setCancelled(true);
}
break;
}
}
}
}
}"
41402,"void scroll(Object contentViewCore,int yVel,int y){
  try {
    float density=mActivity.getResources().getDisplayMetrics().density + 1;
    XposedHelpers.findMethodExact(contentViewCore.getClass(),""String_Node_Str"",long.class,int.class,int.class).invoke(contentViewCore,SystemClock.uptimeMillis(),0,(int)(yVel * density));
    return;
  }
 catch (  Throwable t) {
  }
  try {
    Integer x=(Integer)Utils.callMethod(contentViewCore,""String_Node_Str"");
    ViewGroup containerView=(ViewGroup)Utils.callMethod(contentViewCore,""String_Node_Str"");
    XposedHelpers.findMethodExact(containerView.getClass(),""String_Node_Str"",int.class,int.class).invoke(containerView,x,y);
  }
 catch (  Throwable t) {
    XposedBridge.log(TAG + t);
  }
}","void scroll(Object contentViewCore,int yVel,int y){
  try {
    float density=mActivity.getResources().getDisplayMetrics().density + 1;
    Utils.callMethod(contentViewCore,""String_Node_Str"",SystemClock.uptimeMillis(),0,(int)(yVel * density));
    return;
  }
 catch (  NoSuchMethodError nsme) {
  }
  try {
    Integer x=(Integer)Utils.callMethod(contentViewCore,""String_Node_Str"");
    ViewGroup containerView=(ViewGroup)Utils.callMethod(contentViewCore,""String_Node_Str"");
    Utils.callMethod(containerView,""String_Node_Str"",x,y);
  }
 catch (  NoSuchMethodError nsme) {
    XposedBridge.log(TAG + nsme);
  }
}"
41403,"static Object callMethod(Object obj,String methodName,Object... args){
  try {
    return XposedHelpers.callMethod(obj,methodName,args);
  }
 catch (  NoSuchMethodError e) {
    throw e;
  }
catch (  NoClassDefFoundError e) {
    throw new NoSuchMethodError(""String_Node_Str"" + obj.getClass() + ""String_Node_Str""+ methodName);
  }
}","static Object callMethod(Object obj,String methodName,Object... args){
  if (obj == null) {
    throw new NoSuchMethodError(""String_Node_Str"" + methodName);
  }
  try {
    return XposedHelpers.callMethod(obj,methodName,args);
  }
 catch (  NoSuchMethodError e) {
    throw e;
  }
catch (  NoClassDefFoundError e) {
    try {
      return manualMethodFind(obj.getClass(),methodName,args).invoke(obj,args);
    }
 catch (    Throwable t) {
      throw new NoSuchMethodError(t.getMessage());
    }
  }
}"
41404,"static Object callStaticMethod(Class<?> clazz,String methodName,Object... args){
  if (clazz == null) {
    throw new NoSuchMethodError(""String_Node_Str"" + methodName);
  }
  try {
    return XposedHelpers.callStaticMethod(clazz,methodName,args);
  }
 catch (  NoSuchMethodError e) {
    throw e;
  }
catch (  NoClassDefFoundError e) {
    throw new NoSuchMethodError(""String_Node_Str"" + clazz + ""String_Node_Str""+ methodName);
  }
}","static Object callStaticMethod(Class<?> clazz,String methodName,Object... args){
  if (clazz == null) {
    throw new NoSuchMethodError(""String_Node_Str"" + methodName);
  }
  try {
    return XposedHelpers.callStaticMethod(clazz,methodName,args);
  }
 catch (  NoSuchMethodError e) {
    throw e;
  }
catch (  NoClassDefFoundError e) {
    try {
      return manualMethodFind(clazz,methodName,args).invoke(null,args);
    }
 catch (    Throwable t) {
      throw new NoSuchMethodError(t.getMessage());
    }
  }
}"
41405,"private String nameSpace(){
  String nameSpace=null;
  if (isOneToMany()) {
    nameSpace=field.getAnnotation(OneToMany.class).name();
  }
 else   if (isOneToOne()) {
    nameSpace=field.getAnnotation(OneToOne.class).name();
  }
  return nameSpace;
}","private String nameSpace(){
  String nameSpace=null;
  if (isOneToMany()) {
    nameSpace=field.getAnnotation(OneToMany.class).name().toLowerCase();
  }
 else   if (isOneToOne()) {
    nameSpace=field.getAnnotation(OneToOne.class).name().toLowerCase();
  }
  return nameSpace;
}"
41406,"/** 
 * Signals the server Fiber to stop accepting connections, and the connection fibers to stop processing new requests. Any existing requests will attempt to complete. This method should only be called after   {@link TFiberServer#serve()}.
 */
@Override @Suspendable public void stop(){
  serverFiber.interrupt();
}","/** 
 * Signals the server Fiber to stop accepting connections, and the connection fibers to stop processing new requests. Any existing requests will attempt to complete. This method should only be called after   {@link TFiberServer#serve()}.
 */
@Override @Suspendable public void stop(){
  stopped=true;
  serverFiber.interrupt();
}"
41407,"/** 
 * Uses idToken to retrieve the user account information from GITkit service.
 * @param idToken
 */
public JSONObject getAccountInfo(String idToken) throws GitkitClientException, GitkitServerException {
  try {
    JSONObject params=new JSONObject().put(""String_Node_Str"",idToken);
    return invokeGitkitApi(""String_Node_Str"",params,null);
  }
 catch (  JSONException e) {
    throw new GitkitServerException(""String_Node_Str"");
  }
}","/** 
 * Uses idToken to retrieve the user account information from GITkit service.
 * @param idToken
 */
public JSONObject getAccountInfo(String idToken) throws GitkitClientException, GitkitServerException {
  try {
    JSONObject params=new JSONObject().put(""String_Node_Str"",idToken);
    return invokeGoogle2LegOauthApi(""String_Node_Str"",params);
  }
 catch (  JSONException e) {
    throw new GitkitServerException(""String_Node_Str"");
  }
}"
41408,"@Override protected void doStop(){
  fiber.execute(() -> {
    final AtomicInteger countDown=new AtomicInteger(1);
    GenericFutureListener<? extends Future<? super Void>> listener=future -> {
      if (countDown.decrementAndGet() == 0) {
        notifyStopped();
      }
    }
;
    if (listenChannel != null) {
      countDown.incrementAndGet();
      listenChannel.close().addListener(listener);
    }
    allChannels.close().addListener(listener);
    replicatorInstances.values().forEach(ReplicatorInstance::dispose);
    replicatorInstances.clear();
    fiber.dispose();
    fiber=null;
  }
);
}","@Override protected void doStop(){
  fiber.execute(() -> {
    final AtomicInteger countDown=new AtomicInteger(1);
    GenericFutureListener<? extends Future<? super Void>> listener=future -> {
      if (countDown.decrementAndGet() == 0) {
        fiber.dispose();
        fiber=null;
        notifyStopped();
      }
    }
;
    if (listenChannel != null) {
      countDown.incrementAndGet();
      listenChannel.close().addListener(listener);
    }
    allChannels.close().addListener(listener);
    replicatorInstances.values().forEach(ReplicatorInstance::dispose);
    replicatorInstances.clear();
  }
);
}"
41409,"public QuorumConfiguration getTransitionalConfiguration(Collection<Long> newPeerCollection){
}","public QuorumConfiguration getTransitionalConfiguration(Collection<Long> newPeerCollection){
  if (isTransitional) {
    return new QuorumConfiguration(prevPeers,newPeerCollection);
  }
 else {
    return new QuorumConfiguration(allPeers,newPeerCollection);
  }
}"
41410,"@Test public void aQuorumChangeCanCompleteEvenIfARemovedPeerTimesOutDuringIt() throws Exception {
  final Set<Long> newPeerIds=smallerPeerSetWithNoneInCommonWithInitialSet();
  final QuorumConfiguration transitionalConfig=QuorumConfiguration.of(initialPeerSet()).getTransitionalConfiguration(newPeerIds);
  final QuorumConfiguration finalConfig=transitionalConfig.getCompletedConfiguration();
  havingElectedALeaderAtOrAfter(term(1));
  final long firstLeaderTerm=currentTerm();
  final long leaderId=currentLeader();
  dropAllAppendsWithThisConfigurationUntilAPreElectionPollTakesPlace(finalConfig);
  leader().changeQuorum(newPeerIds);
  sim.createAndStartReplicators(newPeerIds);
  allPeersExceptLeader((peer) -> assertThat(leader(),willSend(anAppendRequest().containingQuorumConfig(transitionalConfig).to(peer.id))));
  peers(newPeerIds).forEach((peer) -> assertThat(peer,willCommitConfiguration(transitionalConfig)));
  peersBeingRemoved(transitionalConfig).forEach(PeerController::allowToTimeout);
  waitForAnElectionTimeout();
  peersBeingRemoved(transitionalConfig).forEach((peer) -> {
    if (peer.id != leaderId) {
      assertThat(peer,willSend(aPreElectionPoll()));
    }
  }
);
  waitForALeaderWithId(isIn(newPeerIds));
  peers(newPeerIds).forEach((peer) -> assertThat(peer,willCommitConfiguration(finalConfig)));
  peersBeingRemoved(transitionalConfig).forEach((peer) -> assertThat(peer,not(wonAnElectionWithTerm(greaterThan(firstLeaderTerm)))));
}","@Test public void aQuorumChangeCanCompleteEvenIfARemovedPeerTimesOutDuringIt() throws Exception {
  final Set<Long> newPeerIds=smallerPeerSetWithNoneInCommonWithInitialSet();
  final QuorumConfiguration transitionalConfig=QuorumConfiguration.of(initialPeerSet()).getTransitionalConfiguration(newPeerIds);
  final QuorumConfiguration finalConfig=transitionalConfig.getCompletedConfiguration();
  havingElectedALeaderAtOrAfter(term(1));
  final long firstLeaderTerm=currentTerm();
  final long leaderId=currentLeader();
  dropAllAppendsWithThisConfigurationUntilAPreElectionPollTakesPlace(finalConfig);
  leader().changeQuorum(newPeerIds);
  sim.createAndStartReplicators(newPeerIds);
  allPeersExceptLeader((peer) -> assertThat(leader(),willSend(anAppendRequest().containingQuorumConfig(transitionalConfig).to(peer.id))));
  peers(newPeerIds).forEach((peer) -> assertThat(peer,willCommitConfiguration(transitionalConfig)));
  peersBeingRemoved(transitionalConfig).forEach(PeerController::allowToTimeout);
  waitForAnElectionTimeout();
  peersBeingRemoved(transitionalConfig).forEach((peer) -> {
    if (peer.id != leaderId) {
      assertThat(peer,willSend(aPreElectionPoll()));
    }
  }
);
  waitForALeaderWithId(isIn(newPeerIds));
  leader().log(someData());
  peers(newPeerIds).forEach((peer) -> assertThat(peer,willCommitConfiguration(finalConfig)));
  peersBeingRemoved(transitionalConfig).forEach((peer) -> assertThat(peer,not(wonAnElectionWithTerm(greaterThan(firstLeaderTerm)))));
}"
41411,"@Test public void aSecondQuorumChangeWillOverrideTheFirst() throws Exception {
  final Set<Long> firstPeerSet=smallerPeerSetWithOneInCommonWithInitialSet();
  final Set<Long> secondPeerSet=largerPeerSetWithSomeInCommonWithInitialSet();
  havingElectedALeaderAtOrAfter(term(1));
  leader().changeQuorum(firstPeerSet);
  sim.createAndStartReplicators(firstPeerSet);
  leader().changeQuorum(secondPeerSet);
  sim.createAndStartReplicators(secondPeerSet);
  peers(secondPeerSet).forEach((peer) -> assertThat(peer,willCommitConfiguration(QuorumConfiguration.of(secondPeerSet))));
  waitForALeaderWithId(isIn(secondPeerSet));
}","@Test public void aSecondQuorumChangeWillOverrideTheFirst() throws Exception {
  final Set<Long> firstPeerSet=smallerPeerSetWithOneInCommonWithInitialSet();
  final Set<Long> secondPeerSet=largerPeerSetWithSomeInCommonWithInitialSet();
  havingElectedALeaderAtOrAfter(term(1));
  leader().changeQuorum(firstPeerSet);
  sim.createAndStartReplicators(firstPeerSet);
  leader().changeQuorum(secondPeerSet);
  sim.createAndStartReplicators(secondPeerSet);
  waitForALeaderWithId(isIn(secondPeerSet));
  leader().log(someData());
  peers(secondPeerSet).forEach((peer) -> assertThat(peer,willCommitConfiguration(QuorumConfiguration.of(secondPeerSet))));
}"
41412,"public boolean hasAny(Matcher<? super T> matcher){
  for (  T element : messageLog) {
    if (matcher.matches(element)) {
      return true;
    }
  }
  return false;
}","public boolean hasAny(Matcher<? super T> matcher){
synchronized (messageLog) {
    for (    T element : messageLog) {
      if (matcher.matches(element)) {
        return true;
      }
    }
  }
  return false;
}"
41413,"private ListenableFuture<T> future(Matcher<? super T> matcher){
  SettableFuture<T> finished=SettableFuture.create();
  fiber.execute(() -> {
    for (    T element : messageLog) {
      if (matcher.matches(element)) {
        finished.set(element);
        return;
      }
    }
    waitingToMatch.put(matcher,finished);
  }
);
  return finished;
}","private ListenableFuture<T> future(Matcher<? super T> matcher){
  SettableFuture<T> finished=SettableFuture.create();
  fiber.execute(() -> {
synchronized (messageLog) {
      for (      T element : messageLog) {
        if (matcher.matches(element)) {
          finished.set(element);
          return;
        }
      }
    }
    waitingToMatch.put(matcher,finished);
  }
);
  return finished;
}"
41414,"private void calculateLastVisible(long majority,long lastIndexSent){
  if (lastIndexSent == lastCommittedIndex) {
    return;
  }
  HashMap<Long,Integer> bucket=new HashMap<>();
  for (  long lastAcked : peersLastAckedIndex.values()) {
    Integer p=bucket.get(lastAcked);
    if (p == null) {
      bucket.put(lastAcked,1);
    }
 else {
      bucket.put(lastAcked,p + 1);
    }
  }
  long mostAcked=0;
  for (  Map.Entry<Long,Integer> e : bucket.entrySet()) {
    if (e.getValue() >= majority) {
      if (mostAcked != 0) {
        LOG.warn(""String_Node_Str"",myId,mostAcked,e.getKey());
      }
      mostAcked=e.getKey();
    }
  }
  if (mostAcked == 0) {
    return;
  }
  if (myFirstIndexAsLeader == 0) {
    return;
  }
  if (mostAcked < myFirstIndexAsLeader) {
    LOG.warn(""String_Node_Str"",myId,mostAcked,myFirstIndexAsLeader);
    return;
  }
  if (mostAcked < lastCommittedIndex) {
    LOG.warn(""String_Node_Str"",myId,mostAcked,lastCommittedIndex);
    return;
  }
  if (mostAcked == lastCommittedIndex) {
    return;
  }
  setLastCommittedIndex(mostAcked);
  LOG.trace(""String_Node_Str"",myId,lastCommittedIndex);
}","@FiberOnly private void calculateLastVisible(int majority,long lastIndexSent){
  if (lastIndexSent == lastCommittedIndex) {
    return;
  }
  if (myFirstIndexAsLeader == 0) {
    return;
  }
  SortedMultiset<Long> committedIndexs=TreeMultiset.create(peersLastAckedIndex.values());
  committedIndexs.add(0L,peers.size() - peersLastAckedIndex.size());
  final long greatestIndexCommittedByMajority=Iterables.get(committedIndexs.descendingMultiset(),majority - 1);
  if (greatestIndexCommittedByMajority < myFirstIndexAsLeader) {
    LOG.warn(""String_Node_Str"",myId,greatestIndexCommittedByMajority,myFirstIndexAsLeader);
    return;
  }
  if (greatestIndexCommittedByMajority < lastCommittedIndex) {
    LOG.warn(""String_Node_Str"",myId,greatestIndexCommittedByMajority,lastCommittedIndex);
    return;
  }
  if (greatestIndexCommittedByMajority == lastCommittedIndex) {
    return;
  }
  setLastCommittedIndex(greatestIndexCommittedByMajority);
  LOG.trace(""String_Node_Str"",myId,lastCommittedIndex);
}"
41415,"@FiberOnly private void sendAppendEntries(long peer,long peerNextIdx,long lastIndexSent,long majority,final List<LogEntry> entries){
}","@FiberOnly private void sendAppendEntries(long peer,long peerNextIdx,long lastIndexSent,int majority,final List<LogEntry> entries){
}"
41416,"@Override public long currentTimeMillis(){
  return stopWatch.getTime() + offset;
}","@Override public synchronized long currentTimeMillis(){
  if (suspended) {
    return lastTimeMillis + offset;
  }
 else {
    return stopWatch.getTime() + offset;
  }
}"
41417,"@Override public ListenableFuture<Boolean> logEntries(List<LogEntry> entries){
  List<Log.OLogEntry> oLogEntries=new ArrayList<>();
  for (  LogEntry entry : entries) {
    long idx=getNextIdxGreaterThan(0);
    oLogEntries.add(Log.OLogEntry.newBuilder().setTombStone(false).setTerm(entry.getTerm()).setIndex(idx).setQuorumId(quorumId).setValue(ByteString.copyFrom(entry.getData())).build());
  }
  return this.log.logEntry(oLogEntries,quorumId);
}","@Override public ListenableFuture<Boolean> logEntries(List<LogEntry> entries){
  List<Log.OLogEntry> oLogEntries=new ArrayList<>();
  for (  LogEntry entry : entries) {
    long idx=getNextIdxGreaterThan(0);
    oLogEntries.add(Log.OLogEntry.newBuilder().setTombStone(false).setTerm(entry.getTerm()).setIndex(idx).setQuorumId(quorumId).setValue(ByteString.copyFrom(entry.getData())).build());
  }
  if (oLogEntries.size() > 0) {
    currentTerm=oLogEntries.get(oLogEntries.size() - 1).getTerm();
  }
  return this.log.logEntry(oLogEntries,quorumId);
}"
41418,"private void becomeLeader(){
  LOG.warn(""String_Node_Str"",myId,currentTerm);
  myState=State.LEADER;
  long myNextLog=log.getLastIndex() + 1;
  peersLastAckedIndex=new HashMap<>(peers.size());
  peersNextIndex=new HashMap<>(peers.size() - 1);
  for (  long peer : peers) {
    if (peer == myId)     continue;
    peersNextIndex.put(peer,myNextLog);
  }
  myFirstIndexAsLeader=0;
  lastCommittedIndex=0;
  stateChangeChannel.publish(new ReplicatorInstanceEvent(ReplicatorInstanceEvent.EventType.LEADER_ELECTED,this,myId,info.currentTimeMillis(),null));
  startQueueConsumer();
}","private void becomeLeader(){
  LOG.warn(""String_Node_Str"",myId,currentTerm);
  myState=State.LEADER;
  long myNextLog=log.getLastIndex() + 1;
  peersLastAckedIndex=new HashMap<>(peers.size());
  peersNextIndex=new HashMap<>(peers.size() - 1);
  for (  long peer : peers) {
    if (peer == myId)     continue;
    peersNextIndex.put(peer,myNextLog);
  }
  myFirstIndexAsLeader=0;
  stateChangeChannel.publish(new ReplicatorInstanceEvent(ReplicatorInstanceEvent.EventType.LEADER_ELECTED,this,myId,info.currentTimeMillis(),null));
  startQueueConsumer();
}"
41419,"private void calculateLastVisible(long majority,long lastIndexSent){
  if (lastIndexSent == lastCommittedIndex)   return;
  HashMap<Long,Integer> bucket=new HashMap<>();
  for (  long lastAcked : peersLastAckedIndex.values()) {
    Integer p=bucket.get(lastAcked);
    if (p == null)     bucket.put(lastAcked,1);
 else     bucket.put(lastAcked,p + 1);
  }
  long mostAcked=0;
  for (  Map.Entry<Long,Integer> e : bucket.entrySet()) {
    if (e.getValue() >= majority) {
      if (mostAcked != 0) {
        LOG.warn(""String_Node_Str"",myId,mostAcked,e.getKey());
      }
      mostAcked=e.getKey();
    }
  }
  if (mostAcked == 0)   return;
  if (myFirstIndexAsLeader == 0)   return;
  if (mostAcked < myFirstIndexAsLeader) {
    LOG.warn(""String_Node_Str"",myId,mostAcked,myFirstIndexAsLeader);
    return;
  }
  if (mostAcked < lastCommittedIndex) {
    LOG.warn(""String_Node_Str"",myId,mostAcked,lastCommittedIndex);
    return;
  }
  if (mostAcked == lastCommittedIndex) {
    return;
  }
  this.lastCommittedIndex=mostAcked;
  notifyLastCommitted();
  LOG.trace(""String_Node_Str"",myId,lastCommittedIndex);
}","private void calculateLastVisible(long majority,long lastIndexSent){
  if (lastIndexSent == lastCommittedIndex)   return;
  HashMap<Long,Integer> bucket=new HashMap<>();
  for (  long lastAcked : peersLastAckedIndex.values()) {
    Integer p=bucket.get(lastAcked);
    if (p == null)     bucket.put(lastAcked,1);
 else     bucket.put(lastAcked,p + 1);
  }
  long mostAcked=0;
  for (  Map.Entry<Long,Integer> e : bucket.entrySet()) {
    if (e.getValue() >= majority) {
      if (mostAcked != 0) {
        LOG.warn(""String_Node_Str"",myId,mostAcked,e.getKey());
      }
      mostAcked=e.getKey();
    }
  }
  if (mostAcked == 0)   return;
  if (myFirstIndexAsLeader == 0)   return;
  if (mostAcked < myFirstIndexAsLeader) {
    LOG.warn(""String_Node_Str"",myId,mostAcked,myFirstIndexAsLeader);
    return;
  }
  if (mostAcked < lastCommittedIndex) {
    LOG.warn(""String_Node_Str"",myId,mostAcked,lastCommittedIndex);
    return;
  }
  if (mostAcked == lastCommittedIndex) {
    return;
  }
  setLastCommittedIndex(mostAcked);
  LOG.trace(""String_Node_Str"",myId,lastCommittedIndex);
}"
41420,"@FiberOnly private void doAppendMessage(final Request<RpcWireRequest,RpcReply> request){
  final AppendEntries appendMessage=request.getRequest().getAppendMessage();
  if (appendMessage.getTerm() < currentTerm) {
    AppendEntriesReply m=new AppendEntriesReply(currentTerm,false,0);
    RpcReply reply=new RpcReply(m);
    request.reply(reply);
    return;
  }
  if (appendMessage.getTerm() > currentTerm) {
    setCurrentTerm(appendMessage.getTerm());
  }
  if (myState != State.FOLLOWER) {
    haltLeader();
  }
  lastRPC=info.currentTimeMillis();
  long theLeader=appendMessage.getLeaderId();
  if (whosLeader != theLeader) {
    LOG.debug(""String_Node_Str"",myId,theLeader);
    whosLeader=theLeader;
    stateChangeChannel.publish(new ReplicatorInstanceEvent(ReplicatorInstanceEvent.EventType.LEADER_ELECTED,this,whosLeader,info.currentTimeMillis(),null));
  }
  long msgPrevLogIndex=appendMessage.getPrevLogIndex();
  long msgPrevLogTerm=appendMessage.getPrevLogTerm();
  if (msgPrevLogIndex != 0 && log.getLogTerm(msgPrevLogIndex) != msgPrevLogTerm) {
    AppendEntriesReply m=new AppendEntriesReply(currentTerm,false,log.getLastIndex());
    RpcReply reply=new RpcReply(m);
    request.reply(reply);
    return;
  }
  if (appendMessage.getEntriesList().isEmpty()) {
    AppendEntriesReply m=new AppendEntriesReply(currentTerm,true,0);
    RpcReply reply=new RpcReply(m);
    request.reply(reply);
    long newCommitIndex=Math.min(appendMessage.getCommitIndex(),log.getLastIndex());
    if (newCommitIndex > lastCommittedIndex) {
      lastCommittedIndex=newCommitIndex;
      notifyLastCommitted();
    }
    return;
  }
  ListenableFuture<ArrayList<LogEntry>> entriesToCommitFuture=validateAndFixLocalLog(request,appendMessage);
  Futures.addCallback(entriesToCommitFuture,new FutureCallback<ArrayList<LogEntry>>(){
    @Override public void onSuccess(    ArrayList<LogEntry> entriesToCommit){
      ListenableFuture<Boolean> logCommitNotification=log.logEntries(entriesToCommit);
      Futures.addCallback(logCommitNotification,new FutureCallback<Boolean>(){
        @Override public void onSuccess(        Boolean result){
          AppendEntriesReply m=new AppendEntriesReply(currentTerm,true,0);
          RpcReply reply=new RpcReply(m);
          request.reply(reply);
          lastCommittedIndex=Math.min(appendMessage.getCommitIndex(),log.getLastIndex());
          notifyLastCommitted();
        }
        @Override public void onFailure(        Throwable t){
          AppendEntriesReply m=new AppendEntriesReply(currentTerm,false,0);
          RpcReply reply=new RpcReply(m);
          request.reply(reply);
        }
      }
,fiber);
    }
    @Override public void onFailure(    Throwable t){
      AppendEntriesReply m=new AppendEntriesReply(currentTerm,false,0);
      RpcReply reply=new RpcReply(m);
      request.reply(reply);
    }
  }
,fiber);
}","@FiberOnly private void doAppendMessage(final Request<RpcWireRequest,RpcReply> request){
  final AppendEntries appendMessage=request.getRequest().getAppendMessage();
  if (appendMessage.getTerm() < currentTerm) {
    AppendEntriesReply m=new AppendEntriesReply(currentTerm,false,0);
    RpcReply reply=new RpcReply(m);
    request.reply(reply);
    return;
  }
  if (appendMessage.getTerm() > currentTerm) {
    setCurrentTerm(appendMessage.getTerm());
  }
  if (myState != State.FOLLOWER) {
    haltLeader();
  }
  lastRPC=info.currentTimeMillis();
  long theLeader=appendMessage.getLeaderId();
  if (whosLeader != theLeader) {
    LOG.debug(""String_Node_Str"",myId,theLeader);
    whosLeader=theLeader;
    stateChangeChannel.publish(new ReplicatorInstanceEvent(ReplicatorInstanceEvent.EventType.LEADER_ELECTED,this,whosLeader,info.currentTimeMillis(),null));
  }
  long msgPrevLogIndex=appendMessage.getPrevLogIndex();
  long msgPrevLogTerm=appendMessage.getPrevLogTerm();
  if (msgPrevLogIndex != 0 && log.getLogTerm(msgPrevLogIndex) != msgPrevLogTerm) {
    AppendEntriesReply m=new AppendEntriesReply(currentTerm,false,log.getLastIndex());
    RpcReply reply=new RpcReply(m);
    request.reply(reply);
    return;
  }
  if (appendMessage.getEntriesList().isEmpty()) {
    AppendEntriesReply m=new AppendEntriesReply(currentTerm,true,0);
    RpcReply reply=new RpcReply(m);
    request.reply(reply);
    long newCommitIndex=Math.min(appendMessage.getCommitIndex(),log.getLastIndex());
    setLastCommittedIndex(newCommitIndex);
    return;
  }
  ListenableFuture<ArrayList<LogEntry>> entriesToCommitFuture=validateAndFixLocalLog(request,appendMessage);
  Futures.addCallback(entriesToCommitFuture,new FutureCallback<ArrayList<LogEntry>>(){
    @Override public void onSuccess(    ArrayList<LogEntry> entriesToCommit){
      ListenableFuture<Boolean> logCommitNotification=log.logEntries(entriesToCommit);
      Futures.addCallback(logCommitNotification,new FutureCallback<Boolean>(){
        @Override public void onSuccess(        Boolean result){
          AppendEntriesReply m=new AppendEntriesReply(currentTerm,true,0);
          RpcReply reply=new RpcReply(m);
          request.reply(reply);
          long newCommitIndex=Math.min(appendMessage.getCommitIndex(),log.getLastIndex());
          setLastCommittedIndex(newCommitIndex);
        }
        @Override public void onFailure(        Throwable t){
          AppendEntriesReply m=new AppendEntriesReply(currentTerm,false,0);
          RpcReply reply=new RpcReply(m);
          request.reply(reply);
        }
      }
,fiber);
    }
    @Override public void onFailure(    Throwable t){
      AppendEntriesReply m=new AppendEntriesReply(currentTerm,false,0);
      RpcReply reply=new RpcReply(m);
      request.reply(reply);
    }
  }
,fiber);
}"
41421,"@Override public void onSuccess(Boolean result){
  AppendEntriesReply m=new AppendEntriesReply(currentTerm,true,0);
  RpcReply reply=new RpcReply(m);
  request.reply(reply);
  lastCommittedIndex=Math.min(appendMessage.getCommitIndex(),log.getLastIndex());
  notifyLastCommitted();
}","@Override public void onSuccess(Boolean result){
  AppendEntriesReply m=new AppendEntriesReply(currentTerm,true,0);
  RpcReply reply=new RpcReply(m);
  request.reply(reply);
  long newCommitIndex=Math.min(appendMessage.getCommitIndex(),log.getLastIndex());
  setLastCommittedIndex(newCommitIndex);
}"
41422,"private void becomeLeader(){
  LOG.warn(""String_Node_Str"",myId);
  myState=State.LEADER;
  long myNextLog=log.getLastIndex() + 1;
  peersLastAckedIndex=new HashMap<>(peers.size());
  peersNextIndex=new HashMap<>(peers.size() - 1);
  for (  long peer : peers) {
    if (peer == myId)     continue;
    peersNextIndex.put(peer,myNextLog);
  }
  myFirstIndexAsLeader=0;
  lastCommittedIndex=0;
  startQueueConsumer();
}","private void becomeLeader(){
  LOG.warn(""String_Node_Str"",myId,currentTerm);
  myState=State.LEADER;
  long myNextLog=log.getLastIndex() + 1;
  peersLastAckedIndex=new HashMap<>(peers.size());
  peersNextIndex=new HashMap<>(peers.size() - 1);
  for (  long peer : peers) {
    if (peer == myId)     continue;
    peersNextIndex.put(peer,myNextLog);
  }
  myFirstIndexAsLeader=0;
  lastCommittedIndex=0;
  startQueueConsumer();
}"
41423,"@Override public void run(){
  consumeQueue();
}","@Override public void run(){
  try {
    consumeQueue();
  }
 catch (  Throwable t) {
    failReplicatorInstance(t);
  }
}"
41424,"@FiberOnly private void startQueueConsumer(){
  queueConsumer=fiber.scheduleAtFixedRate(new Runnable(){
    @Override public void run(){
      consumeQueue();
    }
  }
,0,info.groupCommitDelay(),TimeUnit.MILLISECONDS);
}","@FiberOnly private void startQueueConsumer(){
  queueConsumer=fiber.scheduleAtFixedRate(new Runnable(){
    @Override public void run(){
      try {
        consumeQueue();
      }
 catch (      Throwable t) {
        failReplicatorInstance(t);
      }
    }
  }
,0,info.groupCommitDelay(),TimeUnit.MILLISECONDS);
}"
41425,"@FiberOnly private void handleOutgoingMessage(final Request<RpcRequest,RpcWireReply> message){
  final RpcRequest request=message.getRequest();
  final long to=request.to;
  if (to == server.getNodeId()) {
    handleLoopBackMessage(message);
    return;
  }
  DiscoveryModule.NodeInfoRequest nodeInfoRequest=new DiscoveryModule.NodeInfoRequest(to,ModuleType.Replication);
  AsyncRequest.withOneReply(fiber,discoveryModule.getNodeInfo(),nodeInfoRequest,new Callback<DiscoveryModule.NodeInfoReply>(){
    @FiberOnly @Override public void onMessage(    DiscoveryModule.NodeInfoReply nodeInfoReply){
      if (!nodeInfoReply.found) {
        LOG.debug(""String_Node_Str"",to);
        return;
      }
      ChannelFuture channelFuture=connections.get(to);
      if (channelFuture == null) {
        LOG.trace(""String_Node_Str"",to,nodeInfoReply.addresses.get(0),nodeInfoReply.port);
        channelFuture=outgoingBootstrap.connect(nodeInfoReply.addresses.get(0),nodeInfoReply.port);
        connections.put(to,channelFuture);
      }
      channelFuture.addListener(new ChannelFutureListener(){
        @Override public void operationComplete(        ChannelFuture future) throws Exception {
          if (future.isSuccess()) {
            sendMessage0(message,future.channel());
          }
 else {
            fiber.execute(new Runnable(){
              @Override public void run(){
                ChannelFuture cf=connections.get(to);
                if (cf != null) {
                  if (cf.isDone()) {
                    LOG.trace(""String_Node_Str"",to);
                    connections.remove(to);
                  }
                }
              }
            }
);
          }
        }
      }
);
    }
  }
);
}","@FiberOnly private void handleOutgoingMessage(final Request<RpcRequest,RpcWireReply> message){
  final RpcRequest request=message.getRequest();
  final long to=request.to;
  if (to == server.getNodeId()) {
    handleLoopBackMessage(message);
    return;
  }
  Channel channel=connections.get(to);
  if (channel != null && channel.isOpen()) {
    sendMessage0(message,channel);
    return;
  }
 else   if (channel != null) {
    LOG.debug(""String_Node_Str"",to);
    connections.remove(to);
  }
  DiscoveryModule.NodeInfoRequest nodeInfoRequest=new DiscoveryModule.NodeInfoRequest(to,ModuleType.Replication);
  AsyncRequest.withOneReply(fiber,discoveryModule.getNodeInfo(),nodeInfoRequest,new Callback<DiscoveryModule.NodeInfoReply>(){
    @FiberOnly @Override public void onMessage(    DiscoveryModule.NodeInfoReply nodeInfoReply){
      if (!nodeInfoReply.found) {
        LOG.debug(""String_Node_Str"",to);
        return;
      }
      Channel channel=connections.get(to);
      if (channel != null && channel.isOpen()) {
        sendMessage0(message,channel);
        return;
      }
 else       if (channel != null) {
        LOG.debug(""String_Node_Str"",to);
        connections.remove(to);
      }
      ChannelFuture channelFuture=outgoingBootstrap.connect(nodeInfoReply.addresses.get(0),nodeInfoReply.port);
      LOG.trace(""String_Node_Str"",to,nodeInfoReply.addresses.get(0),nodeInfoReply.port);
      connections.put(to,channelFuture.channel());
      channelFuture.channel().closeFuture().addListener(new ChannelFutureListener(){
        @Override public void operationComplete(        ChannelFuture future) throws Exception {
          fiber.execute(() -> {
            connections.remove(to,future.channel());
          }
);
        }
      }
);
      channelFuture.addListener(new ChannelFutureListener(){
        @Override public void operationComplete(        ChannelFuture future) throws Exception {
          if (future.isSuccess()) {
            sendMessage0(message,future.channel());
          }
        }
      }
);
    }
  }
);
}"
41426,"@Override protected void channelRead0(final ChannelHandlerContext ctx,final RaftWireMessage msg) throws Exception {
  fiber.execute(new Runnable(){
    @Override public void run(){
      handleWireInboundMessage(ctx.channel(),msg);
    }
  }
);
}","@Override protected void channelRead0(final ChannelHandlerContext ctx,final RaftWireMessage msg) throws Exception {
  fiber.execute(() -> {
    handleWireInboundMessage(ctx.channel(),msg);
  }
);
}"
41427,"/** 
 * <p> Use Hazelcast's   {@code ReflectionHelper} to extract a field in an entry, and use this is in the comparison.</P>
 * @param o1 An entry in a map
 * @param o2 Another entry in the map
 * @return Comparison result
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public int compare(Entry<?,?> o1,Entry<?,?> o2){
  try {
    Object o1Field=ReflectionHelper.extractValue(o1.getValue(),this.attributeName);
    Object o2Field=ReflectionHelper.extractValue(o2.getValue(),this.attributeName);
    if (o1Field == null) {
      return this.direction;
    }
    if (o2Field == null) {
      return -1 * this.direction;
    }
    if (o1Field instanceof Comparable && o2Field instanceof Comparable) {
      return this.direction * ((Comparable)o1Field).compareTo((Comparable)o2Field);
    }
  }
 catch (  Exception ignore) {
    return 0;
  }
  return 0;
}","/** 
 * <p> Use Hazelcast's   {@code ReflectionHelper} to extract a field in an entry, and use this is in the comparison.</P>
 * @param o1 An entry in a map
 * @param o2 Another entry in the map
 * @return Comparison result
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public int compare(Entry<?,?> o1,Entry<?,?> o2){
  try {
    Object o1Field=ReflectionHelper.extractValue(o1.getValue(),this.attributeName);
    Object o2Field=ReflectionHelper.extractValue(o2.getValue(),this.attributeName);
    if (o1Field == o2Field) {
      return 0;
    }
    if (o1Field == null) {
      return this.direction;
    }
    if (o2Field == null) {
      return -1 * this.direction;
    }
    if (o1Field instanceof Comparable && o2Field instanceof Comparable) {
      return this.direction * ((Comparable)o1Field).compareTo(o2Field);
    }
  }
 catch (  Exception ignore) {
    return 0;
  }
  return 0;
}"
41428,"/** 
 * <P> Execute   {@code countBy*()} queries against a Hazelcast map.</P>
 * @param criteria Predicate to use, not null
 * @param keyspace The map name
 * @return Results from Hazelcast
 */
@Override public long count(final Predicate<?,?> criteria,final String keyspace){
  return this.getAdapter().getMap(keyspace).keySet(criteria).size();
}","/** 
 * <P> Execute   {@code countBy*()} queries against a Hazelcast map.</P>
 * @param criteria Predicate to use, not null
 * @param keyspace The map name
 * @return Results from Hazelcast
 */
@Override public long count(final Predicate<?,?> criteria,final String keyspace){
  final HazelcastKeyValueAdapter adapter=getAdapter();
  Assert.notNull(adapter,""String_Node_Str"");
  return adapter.getMap(keyspace).keySet(criteria).size();
}"
41429,"/** 
 * <P> Construct the final query predicate for Hazelcast to execute, from the base query plus any paging and sorting. </P> <P> Variations here allow the base query predicate to be omitted, sorting to be omitted, and paging to be omitted. </P>
 * @param criteria Search criteria, null means match everything
 * @param sort Possibly null collation
 * @param offset Start point of returned page, -1 if not used
 * @param rows Size of page, -1 if not used
 * @param keyspace The map name
 * @return Results from Hazelcast
 */
@Override public Collection<?> execute(final Predicate<?,?> criteria,final Comparator<Entry<?,?>> sort,final long offset,final int rows,final String keyspace){
  Predicate<?,?> predicateToUse=criteria;
  @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) Comparator<Entry> sortToUse=((Comparator<Entry>)(Comparator)sort);
  if (rows > 0) {
    PagingPredicate pp=new PagingPredicate(predicateToUse,sortToUse,rows);
    long x=offset / rows;
    while (x > 0) {
      pp.nextPage();
      x--;
    }
    predicateToUse=pp;
  }
 else {
    if (sortToUse != null) {
      predicateToUse=new PagingPredicate(predicateToUse,sortToUse,Integer.MAX_VALUE);
    }
  }
  if (predicateToUse == null) {
    return this.getAdapter().getMap(keyspace).values();
  }
 else {
    return this.getAdapter().getMap(keyspace).values(predicateToUse);
  }
}","/** 
 * <P> Construct the final query predicate for Hazelcast to execute, from the base query plus any paging and sorting. </P> <P> Variations here allow the base query predicate to be omitted, sorting to be omitted, and paging to be omitted. </P>
 * @param criteria Search criteria, null means match everything
 * @param sort Possibly null collation
 * @param offset Start point of returned page, -1 if not used
 * @param rows Size of page, -1 if not used
 * @param keyspace The map name
 * @return Results from Hazelcast
 */
@Override public Collection<?> execute(final Predicate<?,?> criteria,final Comparator<Entry<?,?>> sort,final long offset,final int rows,final String keyspace){
  final HazelcastKeyValueAdapter adapter=getAdapter();
  Assert.notNull(adapter,""String_Node_Str"");
  Predicate<?,?> predicateToUse=criteria;
  @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) Comparator<Entry> sortToUse=((Comparator<Entry>)(Comparator)sort);
  if (rows > 0) {
    PagingPredicate pp=new PagingPredicate(predicateToUse,sortToUse,rows);
    long x=offset / rows;
    while (x > 0) {
      pp.nextPage();
      x--;
    }
    predicateToUse=pp;
  }
 else {
    if (sortToUse != null) {
      predicateToUse=new PagingPredicate(predicateToUse,sortToUse,Integer.MAX_VALUE);
    }
  }
  if (predicateToUse == null) {
    return adapter.getMap(keyspace).values();
  }
 else {
    return adapter.getMap(keyspace).values(predicateToUse);
  }
}"
41430,"/** 
 * @param A query in Spring form
 * @return The same in Hazelcast form
 */
public Predicate<?,?> resolve(KeyValueQuery<?> query){
  if (query == null || query.getCriteria() == null) {
    return null;
  }
  if (query.getCriteria() instanceof PagingPredicate) {
    PagingPredicate pagingPredicate=(PagingPredicate)query.getCriteria();
    query.limit(pagingPredicate.getPageSize());
    return pagingPredicate.getPredicate();
  }
  if (query.getCriteria() instanceof Predicate) {
    return (Predicate<?,?>)query.getCriteria();
  }
  throw new UnsupportedOperationException(query.toString());
}","/** 
 * @param A query in Spring form
 * @return The same in Hazelcast form
 */
public Predicate<?,?> resolve(KeyValueQuery<?> query){
  if (query == null) {
    return null;
  }
  final Object criteria=query.getCriteria();
  if (criteria == null) {
    return null;
  }
  if (criteria instanceof PagingPredicate) {
    PagingPredicate pagingPredicate=(PagingPredicate)criteria;
    query.limit(pagingPredicate.getPageSize());
    return pagingPredicate.getPredicate();
  }
  if (criteria instanceof Predicate) {
    return (Predicate<?,?>)criteria;
  }
  throw new UnsupportedOperationException(query.toString());
}"
41431,"/** 
 * <P> Create the query from the bind parameters. </P>
 * @param parameters Possibly empty list of query parameters
 * @return A ready-to-use query
 */
protected KeyValueQuery<?> prepareQuery(Object[] parameters){
  PartTree tree=null;
  if (this.queryMethod.getParameters().getNumberOfParameters() > 0) {
    tree=new PartTree(getQueryMethod().getName(),getQueryMethod().getEntityInformation().getJavaType());
    this.isCount=tree.isCountProjection();
    this.isDelete=tree.isDelete();
    this.isDistinct=tree.isDistinct();
  }
 else {
    this.isCount=false;
    this.isDelete=false;
    this.isDistinct=false;
  }
  ParametersParameterAccessor accessor=this.prepareAccessor(parameters,tree);
  KeyValueQuery<?> query=createQuery(accessor);
  if (accessor.getPageable() != null) {
    query.setOffset(accessor.getPageable().getOffset());
    query.setRows(accessor.getPageable().getPageSize());
  }
 else {
    query.setOffset(-1);
    query.setRows(-1);
  }
  if (accessor.getSort() != null) {
    query.setSort(accessor.getSort());
  }
  return query;
}","/** 
 * <P> Create the query from the bind parameters. </P>
 * @param parameters Possibly empty list of query parameters
 * @return A ready-to-use query
 */
protected KeyValueQuery<?> prepareQuery(Object[] parameters){
  PartTree tree=null;
  if (this.queryMethod.getParameters().getNumberOfParameters() > 0) {
    tree=new PartTree(getQueryMethod().getName(),getQueryMethod().getEntityInformation().getJavaType());
    this.isCount=tree.isCountProjection();
    this.isDelete=tree.isDelete();
    this.isDistinct=tree.isDistinct();
  }
 else {
    this.isCount=false;
    this.isDelete=false;
    this.isDistinct=false;
  }
  ParametersParameterAccessor accessor=this.prepareAccessor(parameters,tree);
  KeyValueQuery<?> query=createQuery(accessor);
  if (accessor.getPageable() != Pageable.unpaged()) {
    query.setOffset(accessor.getPageable().getOffset());
    query.setRows(accessor.getPageable().getPageSize());
  }
 else {
    query.setOffset(-1);
    query.setRows(-1);
  }
  if (accessor.getSort() != Sort.unsorted()) {
    query.setSort(accessor.getSort());
  }
  return query;
}"
41432,"/** 
 * <P> Handle   {@code @Param}. </P> <OL> <LI><B>Without   {@code @Param}</B> <P> Arguments to the call are assumed to follow the same sequence as cited in the method name. </P> <P> Eg. <pre> findBy<U>One</U>And<U>Two</U>(String <U>one</U>, String <U>two</U>); </pre> </P> </LI> <LI><B>With   {@code @Param}</B> <P> Arguments to the call are use the   {@code @Param} to match them against the fields.<P> Eg. <pre> findBy<U>One</U>And<U>Two</U>(@Param(""two"") String <U>two</U>, @Param(""one"") String <U>one</U>); </pre> </P> </LI> </OL>
 * @param parameters Possibly empty
 * @param partTree Query tree to traverse
 * @return Paremeters in correct order
 */
private ParametersParameterAccessor prepareAccessor(final Object[] originalParameters,final PartTree partTree){
  if (!this.isRearrangeKnown) {
    this.prepareRearrange(partTree,this.queryMethod.getParameters().getBindableParameters());
    this.isRearrangeKnown=true;
  }
  Object[] parameters=originalParameters;
  if (parameters != null && this.isRearrangeRequired) {
    parameters=new Object[originalParameters.length];
    for (int i=0; i < parameters.length; i++) {
      int index=rearrangeIndex[i];
      parameters[i]=originalParameters[index];
    }
  }
  return new ParametersParameterAccessor(this.queryMethod.getParameters(),parameters);
}","/** 
 * <P> Handle   {@code @Param}. </P> <OL> <LI><B>Without   {@code @Param}</B> <P> Arguments to the call are assumed to follow the same sequence as cited in the method name. </P> <P> Eg. <pre> findBy<U>One</U>And<U>Two</U>(String <U>one</U>, String <U>two</U>); </pre> </P> </LI> <LI><B>With   {@code @Param}</B> <P> Arguments to the call are use the   {@code @Param} to match them against the fields.<P> Eg. <pre> findBy<U>One</U>And<U>Two</U>(@Param(""two"") String <U>two</U>, @Param(""one"") String <U>one</U>); </pre> </P> </LI> </OL>
 * @param originalParameters Possibly empty
 * @param partTree Query tree to traverse
 * @return Parameters in correct order
 */
private ParametersParameterAccessor prepareAccessor(final Object[] originalParameters,final PartTree partTree){
  if (!this.isRearrangeKnown) {
    this.prepareRearrange(partTree,this.queryMethod.getParameters().getBindableParameters());
    this.isRearrangeKnown=true;
  }
  Object[] parameters=originalParameters;
  Assert.notNull(parameters,""String_Node_Str"");
  if (this.isRearrangeRequired) {
    parameters=new Object[originalParameters.length];
    for (int i=0; i < parameters.length; i++) {
      int index=rearrangeIndex[i];
      parameters[i]=originalParameters[index];
    }
  }
  return new ParametersParameterAccessor(this.queryMethod.getParameters(),parameters);
}"
41433,"/** 
 * Creates a new   {@link HazelcastQueryCreator} for the given {@link PartTree} and {@link ParameterAccessor}. The latter is used to hand actual parameter values into the callback methods as well as to apply dynamic sorting via a  {@link Sort} parameter.
 * @param tree must not be {@literal null}.
 * @param parameters can be {@literal null}.
 */
public HazelcastQueryCreator(PartTree tree,ParameterAccessor parameters){
  super(tree,parameters);
  if (tree.isLimiting() && tree.getMaxResults() > 0) {
    this.limit=tree.getMaxResults();
  }
 else {
    this.limit=0;
  }
}","/** 
 * Creates a new   {@link HazelcastQueryCreator} for the given {@link PartTree} and {@link ParameterAccessor}. The latter is used to hand actual parameter values into the callback methods as well as to apply dynamic sorting via a  {@link Sort} parameter.
 * @param tree must not be {@literal null}.
 * @param parameters can be {@literal null}.
 */
public HazelcastQueryCreator(PartTree tree,ParameterAccessor parameters){
  super(tree,parameters);
  final Integer maxResults=tree.getMaxResults();
  if (tree.isLimiting() && maxResults != null && maxResults > 0) {
    this.limit=maxResults;
  }
 else {
    this.limit=0;
  }
}"
41434,"/** 
 * <P> Sort on a sequence of fields, possibly none. </P>
 * @param query If not null, will contain one of more {@link Sort.Order} objects.
 * @return A sequence of comparators or {@code null}
 */
public Comparator<Entry<?,?>> resolve(KeyValueQuery<?> query){
  if (query == null || query.getSort() == null) {
    return null;
  }
  CompoundComparator<Entry<?,?>> compoundComparator=new CompoundComparator<>();
  for (  Order order : query.getSort()) {
    if (order.getProperty().indexOf('.') > -1) {
      throw new UnsupportedOperationException(""String_Node_Str"" + order);
    }
    if (order.isIgnoreCase()) {
      throw new UnsupportedOperationException(""String_Node_Str"" + order);
    }
    if (NullHandling.NATIVE != order.getNullHandling()) {
      throw new UnsupportedOperationException(""String_Node_Str"" + order);
    }
    HazelcastPropertyComparator hazelcastPropertyComparator=new HazelcastPropertyComparator(order.getProperty(),order.isAscending());
    compoundComparator.addComparator(hazelcastPropertyComparator);
  }
  return compoundComparator;
}","/** 
 * <P> Sort on a sequence of fields, possibly none. </P>
 * @param query If not null, will contain one of more {@link Sort.Order} objects.
 * @return A sequence of comparators or {@code null}
 */
public Comparator<Entry<?,?>> resolve(KeyValueQuery<?> query){
  if (query == null || query.getSort() == Sort.unsorted()) {
    return null;
  }
  CompoundComparator<Entry<?,?>> compoundComparator=new CompoundComparator<>();
  for (  Order order : query.getSort()) {
    if (order.getProperty().indexOf('.') > -1) {
      throw new UnsupportedOperationException(""String_Node_Str"" + order);
    }
    if (order.isIgnoreCase()) {
      throw new UnsupportedOperationException(""String_Node_Str"" + order);
    }
    if (NullHandling.NATIVE != order.getNullHandling()) {
      throw new UnsupportedOperationException(""String_Node_Str"" + order);
    }
    HazelcastPropertyComparator hazelcastPropertyComparator=new HazelcastPropertyComparator(order.getProperty(),order.isAscending());
    compoundComparator.addComparator(hazelcastPropertyComparator);
  }
  return compoundComparator;
}"
41435,"@Test public void deleteShouldRemoveObjectCorrectly(){
  operations.insert(""String_Node_Str"",FOO_ONE);
  operations.delete(""String_Node_Str"",Foo.class);
  assertThat(operations.findById(""String_Node_Str"",Foo.class),nullValue());
}","@Test public void deleteShouldRemoveObjectCorrectly(){
  operations.insert(""String_Node_Str"",FOO_ONE);
  operations.delete(""String_Node_Str"",Foo.class);
  assertFalse(operations.findById(""String_Node_Str"",Foo.class).isPresent());
}"
41436,"@Test public void updateShouldReplaceExistingObject(){
  operations.insert(""String_Node_Str"",FOO_ONE);
  operations.update(""String_Node_Str"",FOO_TWO);
  assertThat(operations.findById(""String_Node_Str"",Foo.class),is(FOO_TWO));
}","@Test public void updateShouldReplaceExistingObject(){
  operations.insert(""String_Node_Str"",FOO_ONE);
  operations.update(""String_Node_Str"",FOO_TWO);
  assertThat(operations.findById(""String_Node_Str"",Foo.class),is(Optional.of(FOO_TWO)));
}"
41437,"@Test public void createShouldRespectExistingId(){
  ClassWithStringId source=new ClassWithStringId();
  source.id=""String_Node_Str"";
  operations.insert(source);
  assertThat(operations.findById(""String_Node_Str"",ClassWithStringId.class),is(source));
}","@Test public void createShouldRespectExistingId(){
  ClassWithStringId source=new ClassWithStringId();
  source.id=""String_Node_Str"";
  operations.insert(source);
  assertThat(operations.findById(""String_Node_Str"",ClassWithStringId.class),is(Optional.of(source)));
}"
41438,"@Test public void updateShouldRespectTypeInformation(){
  operations.insert(""String_Node_Str"",FOO_ONE);
  operations.update(""String_Node_Str"",BAR_ONE);
  assertThat(operations.findById(""String_Node_Str"",Foo.class),is(FOO_ONE));
}","@Test public void updateShouldRespectTypeInformation(){
  operations.insert(""String_Node_Str"",FOO_ONE);
  operations.update(""String_Node_Str"",BAR_ONE);
  assertThat(operations.findById(""String_Node_Str"",Foo.class),is(Optional.of(FOO_ONE)));
}"
41439,"@Test public void findByIdShouldReturnObjectWithMatchingIdAndType(){
  operations.insert(""String_Node_Str"",FOO_ONE);
  assertThat(operations.findById(""String_Node_Str"",Foo.class),is(FOO_ONE));
}","@Test public void findByIdShouldReturnObjectWithMatchingIdAndType(){
  operations.insert(""String_Node_Str"",FOO_ONE);
  assertThat(operations.findById(""String_Node_Str"",Foo.class),is(Optional.of(FOO_ONE)));
}"
41440,"/** 
 * Changes the endpoints of all WSDL files used by the given WS-BPEL 2.0 Process
 * @param processFiles a list of files containing the complete content of a Apache ODE WS-BPEL 2.0zip file
 * @param csarId the identifier of the CSAR where this process/plan is declared
 * @return true if every WSDL file used by the process was updated (if needed) with endpoints fromthe openTOSCA Core, else false
 */
public boolean changeEndpoints(final List<File> processFiles,final CSARID csarId){
  this.csarId=csarId;
  Map<QName,List<File>> unchangedFiles=null;
  final File deployXml=getDeployXML(processFiles);
  if (deployXml == null) {
    ODEEndpointUpdater.LOG.error(""String_Node_Str"");
    return false;
  }
  try {
    final List<QName> portsInDeployXml=getInvokedDeployXMLPorts(deployXml);
    if (!portsInDeployXml.isEmpty()) {
      for (      final QName portType : portsInDeployXml) {
        ODEEndpointUpdater.LOG.debug(""String_Node_Str"",portType);
      }
    }
 else {
      ODEEndpointUpdater.LOG.debug(""String_Node_Str"");
      return true;
    }
    final Map<QName,List<File>> changeMap=getWSDLtoChange(portsInDeployXml,getAllWSDLFiles(processFiles));
    unchangedFiles=this.updateInvokedWSDLAddresses(changeMap);
  }
 catch (  final JAXBException e) {
    ODEEndpointUpdater.LOG.error(""String_Node_Str"",e);
  }
catch (  final WSDLException e) {
    ODEEndpointUpdater.LOG.error(""String_Node_Str"",e);
  }
  try {
    final List<QName> portsInDeployXml=getProvidedDeployXMLPorts(deployXml);
    final Map<QName,List<File>> changeMap=getWSDLtoChange(portsInDeployXml,getAllWSDLFiles(processFiles));
    unchangedFiles.putAll(this.updateProvidedWSDLAddresses(changeMap));
  }
 catch (  final JAXBException e) {
    e.printStackTrace();
  }
catch (  final WSDLException e) {
    e.printStackTrace();
  }
  for (  final QName portType : unchangedFiles.keySet()) {
    ODEEndpointUpdater.LOG.warn(""String_Node_Str"",portType.toString());
    for (    final File file : unchangedFiles.get(portType)) {
      ODEEndpointUpdater.LOG.warn(""String_Node_Str"",file.toPath().toString(),portType.toString());
    }
  }
  return true;
}","/** 
 * Changes the endpoints of all WSDL files used by the given WS-BPEL 2.0 Process
 * @param processFiles a list of files containing the complete content of a Apache ODE WS-BPEL 2.0zip file
 * @param csarId the identifier of the CSAR where this process/plan is declared
 * @return true if every WSDL file used by the process was updated (if needed) with endpoints fromthe openTOSCA Core, else false
 */
public boolean changeEndpoints(final List<File> processFiles,final CSARID csarId){
  this.csarId=csarId;
  final Map<QName,List<File>> unchangedFiles=new HashMap<>();
  final File deployXml=getDeployXML(processFiles);
  if (deployXml == null) {
    ODEEndpointUpdater.LOG.error(""String_Node_Str"");
    return false;
  }
  try {
    final List<QName> portsInDeployXml=getInvokedDeployXMLPorts(deployXml);
    if (!portsInDeployXml.isEmpty()) {
      for (      final QName portType : portsInDeployXml) {
        ODEEndpointUpdater.LOG.debug(""String_Node_Str"",portType);
      }
      final Map<QName,List<File>> changeMap=getWSDLtoChange(portsInDeployXml,getAllWSDLFiles(processFiles));
      unchangedFiles.putAll(this.updateInvokedWSDLAddresses(changeMap));
    }
 else {
      ODEEndpointUpdater.LOG.debug(""String_Node_Str"");
    }
  }
 catch (  final JAXBException e) {
    ODEEndpointUpdater.LOG.error(""String_Node_Str"",e);
  }
catch (  final WSDLException e) {
    ODEEndpointUpdater.LOG.error(""String_Node_Str"",e);
  }
  try {
    final List<QName> portsInDeployXml=getProvidedDeployXMLPorts(deployXml);
    final Map<QName,List<File>> changeMap=getWSDLtoChange(portsInDeployXml,getAllWSDLFiles(processFiles));
    unchangedFiles.putAll(this.updateProvidedWSDLAddresses(changeMap));
  }
 catch (  final JAXBException e) {
    e.printStackTrace();
  }
catch (  final WSDLException e) {
    e.printStackTrace();
  }
  for (  final QName portType : unchangedFiles.keySet()) {
    ODEEndpointUpdater.LOG.warn(""String_Node_Str"",portType.toString());
    for (    final File file : unchangedFiles.get(portType)) {
      ODEEndpointUpdater.LOG.warn(""String_Node_Str"",file.toPath().toString(),portType.toString());
    }
  }
  return true;
}"
41441,"@Override public BPELPlan buildPlan(final String csarName,final AbstractDefinitions definitions,final QName serviceTemplateId){
  for (  final AbstractServiceTemplate serviceTemplate : definitions.getServiceTemplates()) {
    String namespace;
    if (serviceTemplate.getTargetNamespace() != null) {
      namespace=serviceTemplate.getTargetNamespace();
    }
 else {
      namespace=definitions.getTargetNamespace();
    }
    if (namespace.equals(serviceTemplateId.getNamespaceURI()) && serviceTemplate.getId().equals(serviceTemplateId.getLocalPart())) {
      final String processName=serviceTemplate.getId() + ""String_Node_Str"";
      final String processNamespace=serviceTemplate.getTargetNamespace() + ""String_Node_Str"";
      final AbstractPlan buildPlan=this.generatePOG(new QName(processNamespace,processName).toString(),definitions,serviceTemplate);
      LOG.debug(""String_Node_Str"");
      LOG.debug(buildPlan.toString());
      final BPELPlan newBuildPlan=this.planHandler.createEmptyBPELPlan(processNamespace,processName,buildPlan,""String_Node_Str"");
      newBuildPlan.setTOSCAInterfaceName(""String_Node_Str"");
      newBuildPlan.setTOSCAOperationname(""String_Node_Str"");
      this.planHandler.initializeBPELSkeleton(newBuildPlan,csarName);
      this.instanceInit.addInstanceURLVarToTemplatePlans(newBuildPlan);
      this.instanceInit.addInstanceIDVarToTemplatePlans(newBuildPlan);
      this.planHandler.registerExtension(""String_Node_Str"",true,newBuildPlan);
      final PropertyMap propMap=this.propertyInitializer.initializePropertiesAsVariables(newBuildPlan);
      this.propertyOutputInitializer.initializeBuildPlanOutput(definitions,newBuildPlan,propMap);
      this.serviceInstanceInitializer.initializeInstanceDataFromInput(newBuildPlan);
      this.emptyPropInit.initializeEmptyPropertiesAsInputParam(newBuildPlan,propMap);
      runPlugins(newBuildPlan,propMap);
      this.serviceInstanceInitializer.addCorrellationID(newBuildPlan);
      this.serviceInstanceInitializer.appendSetServiceInstanceState(newBuildPlan,newBuildPlan.getBpelMainFlowElement(),""String_Node_Str"");
      this.serviceInstanceInitializer.appendSetServiceInstanceState(newBuildPlan,newBuildPlan.getBpelMainSequenceOutputAssignElement(),""String_Node_Str"");
      this.finalizer.finalize(newBuildPlan);
      BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"");
      BPELBuildProcessBuilder.LOG.debug(ModelUtils.getStringFromDoc(newBuildPlan.getBpelDocument()));
      return newBuildPlan;
    }
  }
  BPELBuildProcessBuilder.LOG.warn(""String_Node_Str"",serviceTemplateId.toString(),definitions.getId(),csarName);
  return null;
}","@Override public BPELPlan buildPlan(final String csarName,final AbstractDefinitions definitions,final QName serviceTemplateId){
  for (  final AbstractServiceTemplate serviceTemplate : definitions.getServiceTemplates()) {
    String namespace;
    if (serviceTemplate.getTargetNamespace() != null) {
      namespace=serviceTemplate.getTargetNamespace();
    }
 else {
      namespace=definitions.getTargetNamespace();
    }
    if (namespace.equals(serviceTemplateId.getNamespaceURI()) && serviceTemplate.getId().equals(serviceTemplateId.getLocalPart())) {
      final String processName=ModelUtils.makeValidNCName(serviceTemplate.getId() + ""String_Node_Str"");
      final String processNamespace=serviceTemplate.getTargetNamespace() + ""String_Node_Str"";
      final AbstractPlan buildPlan=this.generatePOG(new QName(processNamespace,processName).toString(),definitions,serviceTemplate);
      LOG.debug(""String_Node_Str"");
      LOG.debug(buildPlan.toString());
      final BPELPlan newBuildPlan=this.planHandler.createEmptyBPELPlan(processNamespace,processName,buildPlan,""String_Node_Str"");
      newBuildPlan.setTOSCAInterfaceName(""String_Node_Str"");
      newBuildPlan.setTOSCAOperationname(""String_Node_Str"");
      this.planHandler.initializeBPELSkeleton(newBuildPlan,csarName);
      this.instanceInit.addInstanceURLVarToTemplatePlans(newBuildPlan);
      this.instanceInit.addInstanceIDVarToTemplatePlans(newBuildPlan);
      this.planHandler.registerExtension(""String_Node_Str"",true,newBuildPlan);
      final PropertyMap propMap=this.propertyInitializer.initializePropertiesAsVariables(newBuildPlan);
      this.propertyOutputInitializer.initializeBuildPlanOutput(definitions,newBuildPlan,propMap);
      this.serviceInstanceInitializer.initializeInstanceDataFromInput(newBuildPlan);
      this.emptyPropInit.initializeEmptyPropertiesAsInputParam(newBuildPlan,propMap);
      runPlugins(newBuildPlan,propMap);
      this.serviceInstanceInitializer.addCorrellationID(newBuildPlan);
      this.serviceInstanceInitializer.appendSetServiceInstanceState(newBuildPlan,newBuildPlan.getBpelMainFlowElement(),""String_Node_Str"");
      this.serviceInstanceInitializer.appendSetServiceInstanceState(newBuildPlan,newBuildPlan.getBpelMainSequenceOutputAssignElement(),""String_Node_Str"");
      this.finalizer.finalize(newBuildPlan);
      BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"");
      BPELBuildProcessBuilder.LOG.debug(ModelUtils.getStringFromDoc(newBuildPlan.getBpelDocument()));
      return newBuildPlan;
    }
  }
  BPELBuildProcessBuilder.LOG.warn(""String_Node_Str"",serviceTemplateId.toString(),definitions.getId(),csarName);
  return null;
}"
41442,"public List<BPELPlan> buildScalingPlans(final String csarName,final AbstractDefinitions definitions,final QName serviceTemplateId){
  final List<BPELPlan> scalingPlans=new ArrayList<>();
  final AbstractServiceTemplate serviceTemplate=getServiceTemplate(definitions,serviceTemplateId);
  if (serviceTemplate == null) {
    return scalingPlans;
  }
  final Map<String,String> tags=serviceTemplate.getTags();
  if (!tags.containsKey(""String_Node_Str"")) {
    return scalingPlans;
  }
  final List<ScalingPlanDefinition> scalingPlanDefinitions=fetchScalingPlansDefinitions(serviceTemplate.getTopologyTemplate(),tags);
  for (  final ScalingPlanDefinition scalingPlanDefinition : scalingPlanDefinitions) {
    final String processName=serviceTemplate.getId() + ""String_Node_Str"" + scalingPlanDefinition.name;
    final String processNamespace=serviceTemplate.getTargetNamespace() + ""String_Node_Str"";
    final AbstractPlan abstractScaleOutPlan=generateSOG(new QName(processNamespace,processName).toString(),definitions,serviceTemplate,scalingPlanDefinition);
    printGraph(abstractScaleOutPlan);
    final BPELPlan bpelScaleOutProcess=this.planHandler.createEmptyBPELPlan(processNamespace,processName,abstractScaleOutPlan,""String_Node_Str"");
    bpelScaleOutProcess.setTOSCAInterfaceName(scalingPlanDefinition.name);
    bpelScaleOutProcess.setTOSCAOperationname(""String_Node_Str"");
    this.planHandler.initializeBPELSkeleton(bpelScaleOutProcess,csarName);
    final PropertyMap propMap=this.propertyInitializer.initializePropertiesAsVariables(bpelScaleOutProcess);
    this.planHandler.registerExtension(""String_Node_Str"",true,bpelScaleOutProcess);
    this.serviceInstanceInitializer.addManagementPlanServiceInstanceVarHandlingFromInput(bpelScaleOutProcess);
    this.instanceInitializer.addInstanceURLVarToTemplatePlans(bpelScaleOutProcess);
    this.instanceInitializer.addInstanceIDVarToTemplatePlans(bpelScaleOutProcess);
    this.serviceInstanceInitializer.addCorrellationID(bpelScaleOutProcess);
    final List<BPELScopeActivity> provScopeActivities=new ArrayList<>();
    for (    final BPELScopeActivity act : bpelScaleOutProcess.getAbstract2BPEL().values()) {
      if (act.getNodeTemplate() != null && scalingPlanDefinition.nodeTemplates.contains(act.getNodeTemplate())) {
        provScopeActivities.add(act);
      }
 else       if (act.getRelationshipTemplate() != null && scalingPlanDefinition.relationshipTemplates.contains(act.getRelationshipTemplate())) {
        provScopeActivities.add(act);
      }
    }
    this.emptyPropInit.initializeEmptyPropertiesAsInputParam(provScopeActivities,bpelScaleOutProcess,propMap);
    this.runProvisioningLogicGeneration(bpelScaleOutProcess,propMap,scalingPlanDefinition.nodeTemplates,scalingPlanDefinition.relationshipTemplates);
    for (    final AbstractRelationshipTemplate relationshipTemplate : scalingPlanDefinition.relationshipTemplatesRecursiveSelection) {
      this.addRecursiveInstanceSelection(bpelScaleOutProcess,propMap,relationshipTemplate);
    }
    for (    final AbstractNodeTemplate nodeTemplate : scalingPlanDefinition.nodeTemplatesRecursiveSelection) {
      this.addRecursiveInstanceSelection(bpelScaleOutProcess,propMap,nodeTemplate);
    }
    for (    final AnnotatedAbstractNodeTemplate stratNodeTemplate : scalingPlanDefinition.selectionStrategy2BorderNodes) {
      final IScalingPlanBuilderSelectionPlugin selectionPlugin=findSelectionPlugin(stratNodeTemplate);
      if (selectionPlugin != null) {
        final BPELScopeActivity scope=this.planHandler.getTemplateBuildPlanById(stratNodeTemplate.getId(),bpelScaleOutProcess);
        selectionPlugin.handle(new BPELPlanContext(scope,propMap,serviceTemplate),stratNodeTemplate,new ArrayList<>(stratNodeTemplate.getAnnotations()));
      }
    }
    for (    final AbstractActivity activ : bpelScaleOutProcess.getActivites()) {
      if (activ.getType().equals(ActivityType.PROVISIONING)) {
        addInstanceIdToOutput(bpelScaleOutProcess.getAbstract2BPEL().get(activ));
      }
    }
    this.finalizer.finalize(bpelScaleOutProcess);
    scalingPlans.add(bpelScaleOutProcess);
  }
  return scalingPlans;
}","public List<BPELPlan> buildScalingPlans(final String csarName,final AbstractDefinitions definitions,final QName serviceTemplateId){
  final List<BPELPlan> scalingPlans=new ArrayList<>();
  final AbstractServiceTemplate serviceTemplate=getServiceTemplate(definitions,serviceTemplateId);
  if (serviceTemplate == null) {
    return scalingPlans;
  }
  final Map<String,String> tags=serviceTemplate.getTags();
  if (!tags.containsKey(""String_Node_Str"")) {
    return scalingPlans;
  }
  final List<ScalingPlanDefinition> scalingPlanDefinitions=fetchScalingPlansDefinitions(serviceTemplate.getTopologyTemplate(),tags);
  for (  final ScalingPlanDefinition scalingPlanDefinition : scalingPlanDefinitions) {
    final String processName=ModelUtils.makeValidNCName(serviceTemplate.getId() + ""String_Node_Str"" + scalingPlanDefinition.name);
    final String processNamespace=serviceTemplate.getTargetNamespace() + ""String_Node_Str"";
    final AbstractPlan abstractScaleOutPlan=generateSOG(new QName(processNamespace,processName).toString(),definitions,serviceTemplate,scalingPlanDefinition);
    printGraph(abstractScaleOutPlan);
    final BPELPlan bpelScaleOutProcess=this.planHandler.createEmptyBPELPlan(processNamespace,processName,abstractScaleOutPlan,""String_Node_Str"");
    bpelScaleOutProcess.setTOSCAInterfaceName(scalingPlanDefinition.name);
    bpelScaleOutProcess.setTOSCAOperationname(""String_Node_Str"");
    this.planHandler.initializeBPELSkeleton(bpelScaleOutProcess,csarName);
    final PropertyMap propMap=this.propertyInitializer.initializePropertiesAsVariables(bpelScaleOutProcess);
    this.planHandler.registerExtension(""String_Node_Str"",true,bpelScaleOutProcess);
    this.serviceInstanceInitializer.addManagementPlanServiceInstanceVarHandlingFromInput(bpelScaleOutProcess);
    this.instanceInitializer.addInstanceURLVarToTemplatePlans(bpelScaleOutProcess);
    this.instanceInitializer.addInstanceIDVarToTemplatePlans(bpelScaleOutProcess);
    this.serviceInstanceInitializer.addCorrellationID(bpelScaleOutProcess);
    final List<BPELScopeActivity> provScopeActivities=new ArrayList<>();
    for (    final BPELScopeActivity act : bpelScaleOutProcess.getAbstract2BPEL().values()) {
      if (act.getNodeTemplate() != null && scalingPlanDefinition.nodeTemplates.contains(act.getNodeTemplate())) {
        provScopeActivities.add(act);
      }
 else       if (act.getRelationshipTemplate() != null && scalingPlanDefinition.relationshipTemplates.contains(act.getRelationshipTemplate())) {
        provScopeActivities.add(act);
      }
    }
    this.emptyPropInit.initializeEmptyPropertiesAsInputParam(provScopeActivities,bpelScaleOutProcess,propMap);
    this.runProvisioningLogicGeneration(bpelScaleOutProcess,propMap,scalingPlanDefinition.nodeTemplates,scalingPlanDefinition.relationshipTemplates);
    for (    final AbstractRelationshipTemplate relationshipTemplate : scalingPlanDefinition.relationshipTemplatesRecursiveSelection) {
      this.addRecursiveInstanceSelection(bpelScaleOutProcess,propMap,relationshipTemplate);
    }
    for (    final AbstractNodeTemplate nodeTemplate : scalingPlanDefinition.nodeTemplatesRecursiveSelection) {
      this.addRecursiveInstanceSelection(bpelScaleOutProcess,propMap,nodeTemplate);
    }
    for (    final AnnotatedAbstractNodeTemplate stratNodeTemplate : scalingPlanDefinition.selectionStrategy2BorderNodes) {
      final IScalingPlanBuilderSelectionPlugin selectionPlugin=findSelectionPlugin(stratNodeTemplate);
      if (selectionPlugin != null) {
        final BPELScopeActivity scope=this.planHandler.getTemplateBuildPlanById(stratNodeTemplate.getId(),bpelScaleOutProcess);
        selectionPlugin.handle(new BPELPlanContext(scope,propMap,serviceTemplate),stratNodeTemplate,new ArrayList<>(stratNodeTemplate.getAnnotations()));
      }
    }
    for (    final AbstractActivity activ : bpelScaleOutProcess.getActivites()) {
      if (activ.getType().equals(ActivityType.PROVISIONING)) {
        addInstanceIdToOutput(bpelScaleOutProcess.getAbstract2BPEL().get(activ));
      }
    }
    this.finalizer.finalize(bpelScaleOutProcess);
    scalingPlans.add(bpelScaleOutProcess);
  }
  return scalingPlans;
}"
41443,"@Override public BPELPlan buildPlan(final String csarName,final AbstractDefinitions definitions,final QName serviceTemplateId){
  for (  final AbstractServiceTemplate serviceTemplate : definitions.getServiceTemplates()) {
    String namespace;
    if (serviceTemplate.getTargetNamespace() != null) {
      namespace=serviceTemplate.getTargetNamespace();
    }
 else {
      namespace=definitions.getTargetNamespace();
    }
    if (namespace.equals(serviceTemplateId.getNamespaceURI()) && serviceTemplate.getId().equals(serviceTemplateId.getLocalPart())) {
      final String processName=serviceTemplate.getId() + ""String_Node_Str"";
      final String processNamespace=serviceTemplate.getTargetNamespace() + ""String_Node_Str"";
      final AbstractPlan newAbstractTerminationPlan=generateTOG(new QName(processNamespace,processName).toString(),definitions,serviceTemplate);
      final BPELPlan newTerminationPlan=this.planHandler.createEmptyBPELPlan(processNamespace,processName,newAbstractTerminationPlan,""String_Node_Str"");
      newTerminationPlan.setTOSCAInterfaceName(""String_Node_Str"");
      newTerminationPlan.setTOSCAOperationname(""String_Node_Str"");
      this.planHandler.initializeBPELSkeleton(newTerminationPlan,csarName);
      this.instanceVarsHandler.addInstanceURLVarToTemplatePlans(newTerminationPlan);
      this.instanceVarsHandler.addInstanceIDVarToTemplatePlans(newTerminationPlan);
      final PropertyMap propMap=this.propertyInitializer.initializePropertiesAsVariables(newTerminationPlan);
      this.planHandler.registerExtension(""String_Node_Str"",true,newTerminationPlan);
      this.serviceInstanceVarsHandler.addManagementPlanServiceInstanceVarHandlingFromInput(newTerminationPlan);
      this.serviceInstanceVarsHandler.initPropertyVariablesFromInstanceData(newTerminationPlan,propMap);
      this.instanceVarsHandler.addNodeInstanceFindLogic(newTerminationPlan,""String_Node_Str"");
      this.instanceVarsHandler.addPropertyVariableUpdateBasedOnNodeInstanceID(newTerminationPlan,propMap);
      final List<BPELScopeActivity> changedActivities=runPlugins(newTerminationPlan,propMap);
      this.serviceInstanceVarsHandler.appendSetServiceInstanceState(newTerminationPlan,newTerminationPlan.getBpelMainSequenceOutputAssignElement(),""String_Node_Str"");
      this.serviceInstanceVarsHandler.addCorrellationID(newTerminationPlan);
      this.finalizer.finalize(newTerminationPlan);
      for (      final BPELScopeActivity activ : changedActivities) {
        if (activ.getNodeTemplate() != null) {
          final BPELPlanContext context=new BPELPlanContext(activ,propMap,newTerminationPlan.getServiceTemplate());
          this.instanceVarsHandler.appendCountInstancesLogic(context,activ.getNodeTemplate(),""String_Node_Str"");
        }
      }
      BPELTerminationProcessBuilder.LOG.debug(""String_Node_Str"");
      BPELTerminationProcessBuilder.LOG.debug(ModelUtils.getStringFromDoc(newTerminationPlan.getBpelDocument()));
      return newTerminationPlan;
    }
  }
  BPELTerminationProcessBuilder.LOG.warn(""String_Node_Str"",serviceTemplateId.toString(),definitions.getId(),csarName);
  return null;
}","@Override public BPELPlan buildPlan(final String csarName,final AbstractDefinitions definitions,final QName serviceTemplateId){
  for (  final AbstractServiceTemplate serviceTemplate : definitions.getServiceTemplates()) {
    String namespace;
    if (serviceTemplate.getTargetNamespace() != null) {
      namespace=serviceTemplate.getTargetNamespace();
    }
 else {
      namespace=definitions.getTargetNamespace();
    }
    if (namespace.equals(serviceTemplateId.getNamespaceURI()) && serviceTemplate.getId().equals(serviceTemplateId.getLocalPart())) {
      final String processName=ModelUtils.makeValidNCName(serviceTemplate.getId() + ""String_Node_Str"");
      final String processNamespace=serviceTemplate.getTargetNamespace() + ""String_Node_Str"";
      final AbstractPlan newAbstractTerminationPlan=generateTOG(new QName(processNamespace,processName).toString(),definitions,serviceTemplate);
      final BPELPlan newTerminationPlan=this.planHandler.createEmptyBPELPlan(processNamespace,processName,newAbstractTerminationPlan,""String_Node_Str"");
      newTerminationPlan.setTOSCAInterfaceName(""String_Node_Str"");
      newTerminationPlan.setTOSCAOperationname(""String_Node_Str"");
      this.planHandler.initializeBPELSkeleton(newTerminationPlan,csarName);
      this.instanceVarsHandler.addInstanceURLVarToTemplatePlans(newTerminationPlan);
      this.instanceVarsHandler.addInstanceIDVarToTemplatePlans(newTerminationPlan);
      final PropertyMap propMap=this.propertyInitializer.initializePropertiesAsVariables(newTerminationPlan);
      this.planHandler.registerExtension(""String_Node_Str"",true,newTerminationPlan);
      this.serviceInstanceVarsHandler.addManagementPlanServiceInstanceVarHandlingFromInput(newTerminationPlan);
      this.serviceInstanceVarsHandler.initPropertyVariablesFromInstanceData(newTerminationPlan,propMap);
      this.instanceVarsHandler.addNodeInstanceFindLogic(newTerminationPlan,""String_Node_Str"");
      this.instanceVarsHandler.addPropertyVariableUpdateBasedOnNodeInstanceID(newTerminationPlan,propMap);
      final List<BPELScopeActivity> changedActivities=runPlugins(newTerminationPlan,propMap);
      this.serviceInstanceVarsHandler.appendSetServiceInstanceState(newTerminationPlan,newTerminationPlan.getBpelMainSequenceOutputAssignElement(),""String_Node_Str"");
      this.serviceInstanceVarsHandler.addCorrellationID(newTerminationPlan);
      this.finalizer.finalize(newTerminationPlan);
      for (      final BPELScopeActivity activ : changedActivities) {
        if (activ.getNodeTemplate() != null) {
          final BPELPlanContext context=new BPELPlanContext(activ,propMap,newTerminationPlan.getServiceTemplate());
          this.instanceVarsHandler.appendCountInstancesLogic(context,activ.getNodeTemplate(),""String_Node_Str"");
        }
      }
      BPELTerminationProcessBuilder.LOG.debug(""String_Node_Str"");
      BPELTerminationProcessBuilder.LOG.debug(ModelUtils.getStringFromDoc(newTerminationPlan.getBpelDocument()));
      return newTerminationPlan;
    }
  }
  BPELTerminationProcessBuilder.LOG.warn(""String_Node_Str"",serviceTemplateId.toString(),definitions.getId(),csarName);
  return null;
}"
41444,"public String findInstanceIDVar(final String templateId,final boolean isNode){
  final String instanceURLVarName=(isNode ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + templateId.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
  final List<String> varNames=getMainVariableNames();
  for (  final String varName : varNames) {
    if (varName.contains(instanceURLVarName)) {
      return varName;
    }
  }
  return null;
}","public String findInstanceIDVar(final String templateId,final boolean isNode){
  final String instanceURLVarName=(isNode ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + ModelUtils.makeValidNCName(templateId)+ ""String_Node_Str"";
  final List<String> varNames=getMainVariableNames();
  for (  final String varName : varNames) {
    if (varName.contains(instanceURLVarName)) {
      return varName;
    }
  }
  return null;
}"
41445,"public String findInstanceURLVar(final String templateId,final boolean isNode){
  final String instanceURLVarName=(isNode ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + templateId.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
  for (  final String varName : getMainVariableNames()) {
    if (varName.contains(instanceURLVarName)) {
      return varName;
    }
  }
  return null;
}","public String findInstanceURLVar(final String templateId,final boolean isNode){
  final String instanceURLVarName=(isNode ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + ModelUtils.makeValidNCName(templateId)+ ""String_Node_Str"";
  for (  final String varName : getMainVariableNames()) {
    if (varName.contains(instanceURLVarName)) {
      return varName;
    }
  }
  return null;
}"
41446,"public boolean addInstanceIDVarToTemplatePlan(final BPELScopeActivity templatePlan){
  final String xsdPrefix=""String_Node_Str"" + System.currentTimeMillis();
  final String xsdNamespace=""String_Node_Str"";
  this.bpelProcessHandler.addNamespaceToBPELDoc(xsdPrefix,xsdNamespace,templatePlan.getBuildPlan());
  String templateId=""String_Node_Str"";
  String prefix=""String_Node_Str"";
  if (templatePlan.getNodeTemplate() != null) {
    templateId=templatePlan.getNodeTemplate().getId();
    prefix=""String_Node_Str"";
  }
 else {
    templateId=templatePlan.getRelationshipTemplate().getId();
    prefix=""String_Node_Str"";
  }
  final String instanceIdVarName=prefix + InstanceIDVarKeyword + ""String_Node_Str""+ templateId.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ System.currentTimeMillis();
  return this.bpelProcessHandler.addVariable(instanceIdVarName,VariableType.TYPE,new QName(xsdNamespace,""String_Node_Str"",xsdPrefix),templatePlan.getBuildPlan());
}","public boolean addInstanceIDVarToTemplatePlan(final BPELScopeActivity templatePlan){
  final String xsdPrefix=""String_Node_Str"" + System.currentTimeMillis();
  final String xsdNamespace=""String_Node_Str"";
  this.bpelProcessHandler.addNamespaceToBPELDoc(xsdPrefix,xsdNamespace,templatePlan.getBuildPlan());
  String templateId=""String_Node_Str"";
  String prefix=""String_Node_Str"";
  if (templatePlan.getNodeTemplate() != null) {
    templateId=templatePlan.getNodeTemplate().getId();
    prefix=""String_Node_Str"";
  }
 else {
    templateId=templatePlan.getRelationshipTemplate().getId();
    prefix=""String_Node_Str"";
  }
  final String instanceIdVarName=prefix + InstanceIDVarKeyword + ""String_Node_Str""+ ModelUtils.makeValidNCName(templateId)+ ""String_Node_Str""+ System.currentTimeMillis();
  return this.bpelProcessHandler.addVariable(instanceIdVarName,VariableType.TYPE,new QName(xsdNamespace,""String_Node_Str"",xsdPrefix),templatePlan.getBuildPlan());
}"
41447,"private String findInstanceIdVarName(final List<String> varNames,final String templateId,final boolean isNode){
  final String instanceURLVarName=(isNode ? ""String_Node_Str"" : ""String_Node_Str"") + InstanceURLVarKeyword + ""String_Node_Str""+ templateId.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
  for (  final String varName : varNames) {
    if (varName.contains(instanceURLVarName)) {
      return varName;
    }
  }
  return null;
}","private String findInstanceIdVarName(final List<String> varNames,final String templateId,final boolean isNode){
  final String instanceURLVarName=(isNode ? ""String_Node_Str"" : ""String_Node_Str"") + InstanceURLVarKeyword + ""String_Node_Str""+ ModelUtils.makeValidNCName(templateId)+ ""String_Node_Str"";
  for (  final String varName : varNames) {
    if (varName.contains(instanceURLVarName)) {
      return varName;
    }
  }
  return null;
}"
41448,"/** 
 * Adds a NodeInstanceID Variable to the given TemplatePlan
 * @param templatePlan a TemplatePlan
 * @return true iff adding a NodeInstanceID Var was successful
 */
public boolean addInstanceURLVarToTemplatePlan(final BPELScopeActivity templatePlan){
  final String xsdPrefix=""String_Node_Str"" + System.currentTimeMillis();
  final String xsdNamespace=""String_Node_Str"";
  this.bpelProcessHandler.addNamespaceToBPELDoc(xsdPrefix,xsdNamespace,templatePlan.getBuildPlan());
  String templateId=""String_Node_Str"";
  String prefix=""String_Node_Str"";
  if (templatePlan.getNodeTemplate() != null) {
    templateId=templatePlan.getNodeTemplate().getId();
    prefix=""String_Node_Str"";
  }
 else {
    templateId=templatePlan.getRelationshipTemplate().getId();
    prefix=""String_Node_Str"";
  }
  final String instanceIdVarName=prefix + InstanceURLVarKeyword + ""String_Node_Str""+ templateId.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ System.currentTimeMillis();
  return this.bpelProcessHandler.addVariable(instanceIdVarName,VariableType.TYPE,new QName(xsdNamespace,""String_Node_Str"",xsdPrefix),templatePlan.getBuildPlan());
}","/** 
 * Adds a NodeInstanceID Variable to the given TemplatePlan
 * @param templatePlan a TemplatePlan
 * @return true iff adding a NodeInstanceID Var was successful
 */
public boolean addInstanceURLVarToTemplatePlan(final BPELScopeActivity templatePlan){
  final String xsdPrefix=""String_Node_Str"" + System.currentTimeMillis();
  final String xsdNamespace=""String_Node_Str"";
  this.bpelProcessHandler.addNamespaceToBPELDoc(xsdPrefix,xsdNamespace,templatePlan.getBuildPlan());
  String templateId=""String_Node_Str"";
  String prefix=""String_Node_Str"";
  if (templatePlan.getNodeTemplate() != null) {
    templateId=templatePlan.getNodeTemplate().getId();
    prefix=""String_Node_Str"";
  }
 else {
    templateId=templatePlan.getRelationshipTemplate().getId();
    prefix=""String_Node_Str"";
  }
  final String instanceIdVarName=prefix + InstanceURLVarKeyword + ""String_Node_Str""+ ModelUtils.makeValidNCName(templateId)+ ""String_Node_Str""+ System.currentTimeMillis();
  return this.bpelProcessHandler.addVariable(instanceIdVarName,VariableType.TYPE,new QName(xsdNamespace,""String_Node_Str"",xsdPrefix),templatePlan.getBuildPlan());
}"
41449,"/** 
 * Initializes Property variables and mappings for a TemplateBuildPlan which handles a RelationshipTemplate
 * @param map the PropertyMap to save the result to
 * @param templatePlan a TemplateBuildPlan which handles a RelationshipTemplate
 */
private void initPropsAsVarsInRelationship(final PropertyMap map,final BPELScopeActivity templatePlan){
  final AbstractRelationshipTemplate relationshipTemplate=templatePlan.getRelationshipTemplate();
  if (relationshipTemplate.getProperties() != null) {
    final Element propertyElement=relationshipTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      final String propName=propertyElement.getChildNodes().item(i).getLocalName();
      final String propVarName=relationshipTemplate.getId().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(relationshipTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      if (!value.trim().isEmpty() && !value.trim().equals(""String_Node_Str"")) {
        this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
      }
    }
  }
}","/** 
 * Initializes Property variables and mappings for a TemplateBuildPlan which handles a RelationshipTemplate
 * @param map the PropertyMap to save the result to
 * @param templatePlan a TemplateBuildPlan which handles a RelationshipTemplate
 */
private void initPropsAsVarsInRelationship(final PropertyMap map,final BPELScopeActivity templatePlan){
  final AbstractRelationshipTemplate relationshipTemplate=templatePlan.getRelationshipTemplate();
  if (relationshipTemplate.getProperties() != null) {
    final Element propertyElement=relationshipTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      final String propName=propertyElement.getChildNodes().item(i).getLocalName();
      final String propVarName=ModelUtils.makeValidNCName(relationshipTemplate.getId()) + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(relationshipTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      if (!value.trim().isEmpty() && !value.trim().equals(""String_Node_Str"")) {
        this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
      }
    }
  }
}"
41450,"/** 
 * Initializes Property variables for the given TemplateBuildPlan which handles a NodeTemplate
 * @param map a PropertyMap to save the result/mappings to
 * @param templatePlan a TemplateBuildPlan which handles a NodeTemplate
 */
private void initPropsAsVarsInNode(final PropertyMap map,final BPELScopeActivity templatePlan){
  final AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
  if (nodeTemplate.getProperties() != null) {
    final Element propertyElement=nodeTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      final String propName=propertyElement.getChildNodes().item(i).getLocalName();
      final String propVarName=nodeTemplate.getId().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(nodeTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
    }
  }
}","/** 
 * Initializes Property variables for the given TemplateBuildPlan which handles a NodeTemplate
 * @param map a PropertyMap to save the result/mappings to
 * @param templatePlan a TemplateBuildPlan which handles a NodeTemplate
 */
private void initPropsAsVarsInNode(final PropertyMap map,final BPELScopeActivity templatePlan){
  final AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
  if (nodeTemplate.getProperties() != null) {
    final Element propertyElement=nodeTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      final String propName=propertyElement.getChildNodes().item(i).getLocalName();
      final String propVarName=ModelUtils.makeValidNCName(nodeTemplate.getId()) + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(nodeTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
    }
  }
}"
41451,"public String createInstanceIDVar(final BPELPlanContext context,final String templateId){
  final String instanceURLVarName=(context.getRelationshipTemplate() == null ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + templateId.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ context.getIdForNames();
  final QName stringTypeDeclId=context.importQName(new QName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (!context.addGlobalVariable(instanceURLVarName,BPELPlan.VariableType.TYPE,stringTypeDeclId)) {
    return null;
  }
  return instanceURLVarName;
}","public String createInstanceIDVar(final BPELPlanContext context,final String templateId){
  final String instanceURLVarName=(context.getRelationshipTemplate() == null ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + ModelUtils.makeValidNCName(templateId)+ ""String_Node_Str""+ context.getIdForNames();
  final QName stringTypeDeclId=context.importQName(new QName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (!context.addGlobalVariable(instanceURLVarName,BPELPlan.VariableType.TYPE,stringTypeDeclId)) {
    return null;
  }
  return instanceURLVarName;
}"
41452,"public String createInstanceURLVar(final BPELPlanContext context,final String templateId){
  final String instanceURLVarName=(context.getRelationshipTemplate() == null ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + templateId.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ context.getIdForNames();
  final QName stringTypeDeclId=context.importQName(new QName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (!context.addGlobalVariable(instanceURLVarName,BPELPlan.VariableType.TYPE,stringTypeDeclId)) {
    return null;
  }
  return instanceURLVarName;
}","public String createInstanceURLVar(final BPELPlanContext context,final String templateId){
  final String instanceURLVarName=(context.getRelationshipTemplate() == null ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + ModelUtils.makeValidNCName(templateId)+ ""String_Node_Str""+ context.getIdForNames();
  final QName stringTypeDeclId=context.importQName(new QName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (!context.addGlobalVariable(instanceURLVarName,BPELPlan.VariableType.TYPE,stringTypeDeclId)) {
    return null;
  }
  return instanceURLVarName;
}"
41453,"private String createStateVar(final BPELPlanContext context,final String templateId){
  final String stateVarName=templateId.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + context.getIdForNames();
  final QName stringTypeDeclId=context.importQName(new QName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (!context.addGlobalVariable(stateVarName,BPELPlan.VariableType.TYPE,stringTypeDeclId)) {
    return null;
  }
  return stateVarName;
}","private String createStateVar(final BPELPlanContext context,final String templateId){
  final String stateVarName=ModelUtils.makeValidNCName(templateId) + ""String_Node_Str"" + context.getIdForNames();
  final QName stringTypeDeclId=context.importQName(new QName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (!context.addGlobalVariable(stateVarName,BPELPlan.VariableType.TYPE,stringTypeDeclId)) {
    return null;
  }
  return stateVarName;
}"
41454,"@Override public void run(){
  LOG.debug(""String_Node_Str"");
  this.state.currentState=PlanGenerationState.PlanGenerationStates.CSARDOWNLOADING;
  final IHTTPService openToscaHttpService=ServiceRegistry.getHTTPService();
  if (openToscaHttpService == null) {
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.error(""String_Node_Str"");
    return;
  }
  CSARID csarId=null;
  InputStream csarInputStream=null;
  try {
    LOG.debug(""String_Node_Str"" + this.state.getCsarUrl());
    final Map<String,String> headers=new HashMap<>();
    headers.put(""String_Node_Str"",""String_Node_Str"");
    final HttpResponse csarResponse=openToscaHttpService.Get(this.state.getCsarUrl().toString(),headers);
    csarInputStream=csarResponse.getEntity().getContent();
    String fileName=null;
    for (    final org.apache.http.Header header : csarResponse.getAllHeaders()) {
      if (header.getName().contains(""String_Node_Str"")) {
        for (        final HeaderElement elem : header.getElements()) {
          if (elem.getName().equals(""String_Node_Str"")) {
            for (            final NameValuePair nameValuePair : elem.getParameters()) {
              if (nameValuePair.getName().equals(""String_Node_Str"")) {
                fileName=nameValuePair.getValue();
              }
            }
          }
        }
      }
    }
    if (fileName == null) {
      fileName=this.state.getCsarUrl().toString().replace(""String_Node_Str"",""String_Node_Str"");
      if (fileName.endsWith(""String_Node_Str"")) {
        fileName=fileName.substring(0,fileName.length() - 1);
      }
      fileName=fileName.substring(fileName.lastIndexOf(""String_Node_Str"") + 1);
    }
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.debug(""String_Node_Str"");
    if (fileName == null) {
      LOG.debug(""String_Node_Str"");
      this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
      this.state.currentMessage=""String_Node_Str"";
      return;
    }
    fileName=fileName.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str"";
    LOG.debug(""String_Node_Str"");
    csarId=Util.storeCSAR(fileName,csarInputStream);
  }
 catch (  final ClientProtocolException e) {
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.error(""String_Node_Str"");
    return;
  }
catch (  final IOException e) {
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.error(""String_Node_Str"");
    return;
  }
  if (csarInputStream == null) {
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.error(""String_Node_Str"");
    return;
  }
  if (csarId != null) {
    this.state.currentState=PlanGenerationStates.PLANGENERATING;
    this.state.currentMessage=""String_Node_Str"";
    LOG.debug(""String_Node_Str"");
  }
 else {
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.error(""String_Node_Str"");
    Util.deleteCSAR(csarId);
    return;
  }
  final List<AbstractPlan> buildPlans=Util.startPlanBuilder(csarId);
  if (buildPlans.size() <= 0) {
    this.state.currentState=PlanGenerationStates.PLANGENERATIONFAILED;
    this.state.currentMessage=""String_Node_Str"";
    Util.deleteCSAR(csarId);
    LOG.error(""String_Node_Str"");
    return;
  }
  this.state.currentState=PlanGenerationStates.PLANSGENERATED;
  this.state.currentMessage=""String_Node_Str"";
  LOG.debug(""String_Node_Str"");
  final Map<BPELPlan,File> plansToUpload=new HashMap<>();
  for (  final AbstractPlan buildPlan : buildPlans) {
    final File planTmpFile=Util.writePlan2TmpFolder((BPELPlan)buildPlan);
    plansToUpload.put((BPELPlan)buildPlan,planTmpFile);
  }
  LOG.debug(""String_Node_Str"" + buildPlans.size());
  for (  final AbstractPlan buildPlan : plansToUpload.keySet()) {
    final File planTmpFile=plansToUpload.get(buildPlan);
    final List<String> inputParameters=((BPELPlan)buildPlan).getWsdl().getInputMessageLocalNames();
    final List<String> outputParameters=((BPELPlan)buildPlan).getWsdl().getOuputMessageLocalNames();
    final JSONObject obj=new JSONObject();
    obj.put(""String_Node_Str"",buildPlan.getId());
    obj.put(""String_Node_Str"",buildPlan.getType().getString());
    obj.put(""String_Node_Str"",((BPELPlan)buildPlan).bpelNamespace);
    final HttpEntity ent=EntityBuilder.create().setText(obj.toJSONString()).setContentType(ContentType.APPLICATION_JSON).build();
    HttpResponse createPlanResponse=null;
    try {
      createPlanResponse=openToscaHttpService.Post(getState().getPostUrl().toString(),ent);
    }
 catch (    final ClientProtocolException e2) {
      this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
      this.state.currentMessage=""String_Node_Str"" + createPlanResponse.getStatusLine().getStatusCode();
      Util.deleteCSAR(csarId);
      LOG.error(""String_Node_Str"" + createPlanResponse.getStatusLine().getStatusCode());
      return;
    }
catch (    final IOException e2) {
      this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
      this.state.currentMessage=""String_Node_Str"" + createPlanResponse.getStatusLine().getStatusCode();
      Util.deleteCSAR(csarId);
      LOG.error(""String_Node_Str"" + createPlanResponse.getStatusLine().getStatusCode());
      return;
    }
    final org.apache.http.Header planLocationHeader=createPlanResponse.getHeaders(""String_Node_Str"")[0];
    final String planLocation=planLocationHeader.getValue();
    try {
      this.state.currentState=PlanGenerationStates.PLANSENDING;
      this.state.currentMessage=""String_Node_Str"";
      LOG.debug(""String_Node_Str"");
      for (      final String inputParam : inputParameters) {
        final String inputParamPostUrl=planLocation + ""String_Node_Str"";
        final List<NameValuePair> params=new ArrayList<>();
        params.add(Util.createNameValuePair(""String_Node_Str"",inputParam));
        params.add(Util.createNameValuePair(""String_Node_Str"",""String_Node_Str""));
        params.add(Util.createNameValuePair(""String_Node_Str"",""String_Node_Str""));
        final UrlEncodedFormEntity encodedForm=new UrlEncodedFormEntity(params);
        final HttpResponse inputParamPostResponse=openToscaHttpService.Post(inputParamPostUrl,encodedForm);
        if (inputParamPostResponse.getStatusLine().getStatusCode() >= 300) {
          this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
          this.state.currentMessage=""String_Node_Str"" + inputParamPostUrl + ""String_Node_Str""+ inputParam+ ""String_Node_Str""+ inputParamPostResponse.getStatusLine().getStatusCode();
          Util.deleteCSAR(csarId);
          LOG.error(""String_Node_Str"" + inputParamPostUrl + ""String_Node_Str""+ inputParam+ ""String_Node_Str""+ inputParamPostResponse.getStatusLine().getStatusCode());
          return;
        }
        LOG.debug(""String_Node_Str"" + inputParam);
      }
      for (      final String outputParam : outputParameters) {
        final String outputParamPostUrl=planLocation + ""String_Node_Str"";
        final List<NameValuePair> params=new ArrayList<>();
        params.add(Util.createNameValuePair(""String_Node_Str"",outputParam));
        params.add(Util.createNameValuePair(""String_Node_Str"",""String_Node_Str""));
        params.add(Util.createNameValuePair(""String_Node_Str"",""String_Node_Str""));
        final UrlEncodedFormEntity encodedForm=new UrlEncodedFormEntity(params);
        final HttpResponse outputParamPostResponse=openToscaHttpService.Post(outputParamPostUrl,encodedForm);
        if (outputParamPostResponse.getStatusLine().getStatusCode() >= 300) {
          this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
          this.state.currentMessage=""String_Node_Str"" + outputParamPostUrl + ""String_Node_Str""+ outputParam+ ""String_Node_Str""+ outputParamPostResponse.getStatusLine().getStatusCode();
          Util.deleteCSAR(csarId);
          LOG.error(""String_Node_Str"" + outputParamPostUrl + ""String_Node_Str""+ outputParam+ ""String_Node_Str""+ outputParamPostResponse.getStatusLine().getStatusCode());
          return;
        }
        LOG.debug(""String_Node_Str"" + outputParam);
      }
      final MultipartEntity mpEntity=new MultipartEntity();
      final FileBody bin=new FileBody(planTmpFile);
      final ContentBody cb=bin;
      mpEntity.addPart(""String_Node_Str"",cb);
      final HttpResponse uploadResponse=openToscaHttpService.Put(planLocation + ""String_Node_Str"",mpEntity);
      if (uploadResponse.getStatusLine().getStatusCode() >= 300) {
        this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
        this.state.currentMessage=""String_Node_Str"" + uploadResponse.getStatusLine().getStatusCode();
        Util.deleteCSAR(csarId);
        LOG.error(""String_Node_Str"" + uploadResponse.getStatusLine().getStatusCode());
        return;
      }
      try {
        LOG.debug(""String_Node_Str"");
        this.state.currentState=PlanGenerationStates.OPTIONSENDING;
        this.state.currentMessage=""String_Node_Str"";
        final URL optionsUrl=new URL(this.state.getCsarUrl(),""String_Node_Str"");
        LOG.debug(""String_Node_Str"" + optionsUrl.toString());
        final SelfServiceOptionWrapper option=Util.generateSelfServiceOption((BPELPlan)buildPlan);
        LOG.debug(""String_Node_Str"" + option.toString());
        final MultipartEntity mpOptionEntity=new MultipartEntity();
        try {
          mpOptionEntity.addPart(""String_Node_Str"",new StringBody(option.option.getName()));
          mpOptionEntity.addPart(""String_Node_Str"",new StringBody(option.option.getDescription()));
          mpOptionEntity.addPart(""String_Node_Str"",new StringBody(option.option.getPlanServiceName()));
          mpOptionEntity.addPart(""String_Node_Str"",new StringBody(FileUtils.readFileToString(option.planInputMessageFile)));
        }
 catch (        final UnsupportedEncodingException e1) {
          this.state.currentState=PlanGenerationStates.OPTIONSENDINGFAILED;
          this.state.currentMessage=""String_Node_Str"";
          Util.deleteCSAR(csarId);
          LOG.error(""String_Node_Str"" + optionsUrl.toString());
          return;
        }
        final FileBody fileBody=new FileBody(option.planInputMessageFile);
        final ContentBody contentBody=fileBody;
        mpOptionEntity.addPart(""String_Node_Str"",contentBody);
        final HttpResponse optionsResponse=openToscaHttpService.Post(optionsUrl.toString(),mpOptionEntity);
        if (optionsResponse.getStatusLine().getStatusCode() >= 300) {
          this.state.currentState=PlanGenerationStates.OPTIONSENDINGFAILED;
          this.state.currentMessage=""String_Node_Str"" + optionsResponse.getStatusLine().getStatusCode() + ""String_Node_Str""+ optionsResponse.getStatusLine().getReasonPhrase();
          Util.deleteCSAR(csarId);
          return;
        }
 else {
          this.state.currentState=PlanGenerationStates.OPTIONSENT;
          this.state.currentMessage=""String_Node_Str"";
        }
      }
 catch (      final MalformedURLException e) {
        this.state.currentState=PlanGenerationStates.OPTIONSENDINGFAILED;
        this.state.currentMessage=""String_Node_Str"";
        Util.deleteCSAR(csarId);
        return;
      }
catch (      final IOException e) {
        this.state.currentState=PlanGenerationStates.OPTIONSENDINGFAILED;
        this.state.currentMessage=""String_Node_Str"";
        Util.deleteCSAR(csarId);
        return;
      }
      this.state.currentState=PlanGenerationStates.PLANSSENT;
      this.state.currentMessage=""String_Node_Str"";
      LOG.debug(""String_Node_Str"");
    }
 catch (    final ClientProtocolException e) {
      this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
      this.state.currentMessage=""String_Node_Str"";
      Util.deleteCSAR(csarId);
      LOG.error(""String_Node_Str"");
      return;
    }
catch (    final IOException e) {
      this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
      this.state.currentMessage=""String_Node_Str"";
      Util.deleteCSAR(csarId);
      LOG.error(""String_Node_Str"");
      return;
    }
    this.state.currentState=PlanGenerationStates.FINISHED;
    this.state.currentMessage=""String_Node_Str"";
    Util.deleteCSAR(csarId);
  }
}","@Override public void run(){
  LOG.debug(""String_Node_Str"");
  this.state.currentState=PlanGenerationState.PlanGenerationStates.CSARDOWNLOADING;
  final IHTTPService openToscaHttpService=ServiceRegistry.getHTTPService();
  if (openToscaHttpService == null) {
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.error(""String_Node_Str"");
    return;
  }
  CSARID csarId=null;
  InputStream csarInputStream=null;
  try {
    LOG.debug(""String_Node_Str"" + this.state.getCsarUrl());
    final Map<String,String> headers=new HashMap<>();
    headers.put(""String_Node_Str"",""String_Node_Str"");
    final HttpResponse csarResponse=openToscaHttpService.Get(this.state.getCsarUrl().toString(),headers);
    csarInputStream=csarResponse.getEntity().getContent();
    String fileName=null;
    for (    final org.apache.http.Header header : csarResponse.getAllHeaders()) {
      if (header.getName().contains(""String_Node_Str"")) {
        for (        final HeaderElement elem : header.getElements()) {
          if (elem.getName().equals(""String_Node_Str"")) {
            for (            final NameValuePair nameValuePair : elem.getParameters()) {
              if (nameValuePair.getName().equals(""String_Node_Str"")) {
                fileName=nameValuePair.getValue();
              }
            }
          }
        }
      }
    }
    if (fileName == null) {
      fileName=this.state.getCsarUrl().toString().replace(""String_Node_Str"",""String_Node_Str"");
      if (fileName.endsWith(""String_Node_Str"")) {
        fileName=fileName.substring(0,fileName.length() - 1);
      }
      fileName=fileName.substring(fileName.lastIndexOf(""String_Node_Str"") + 1);
    }
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.debug(""String_Node_Str"");
    if (fileName == null) {
      LOG.debug(""String_Node_Str"");
      this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
      this.state.currentMessage=""String_Node_Str"";
      return;
    }
    fileName=fileName.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str"";
    LOG.debug(""String_Node_Str"");
    csarId=Util.storeCSAR(fileName,csarInputStream);
  }
 catch (  final ClientProtocolException e) {
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.error(""String_Node_Str"");
    return;
  }
catch (  final IOException e) {
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.error(""String_Node_Str"");
    return;
  }
  if (csarInputStream == null) {
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.error(""String_Node_Str"");
    return;
  }
  if (csarId != null) {
    this.state.currentState=PlanGenerationStates.PLANGENERATING;
    this.state.currentMessage=""String_Node_Str"";
    LOG.debug(""String_Node_Str"");
  }
 else {
    this.state.currentState=PlanGenerationStates.CSARDOWNLOADFAILED;
    this.state.currentMessage=""String_Node_Str"";
    LOG.error(""String_Node_Str"");
    Util.deleteCSAR(csarId);
    return;
  }
  final List<AbstractPlan> buildPlans=Util.startPlanBuilder(csarId);
  if (buildPlans.size() <= 0) {
    this.state.currentState=PlanGenerationStates.PLANGENERATIONFAILED;
    this.state.currentMessage=""String_Node_Str"";
    Util.deleteCSAR(csarId);
    LOG.error(""String_Node_Str"");
    return;
  }
  this.state.currentState=PlanGenerationStates.PLANSGENERATED;
  this.state.currentMessage=""String_Node_Str"";
  LOG.debug(""String_Node_Str"");
  final Map<BPELPlan,File> plansToUpload=new HashMap<>();
  for (  final AbstractPlan buildPlan : buildPlans) {
    final File planTmpFile=Util.writePlan2TmpFolder((BPELPlan)buildPlan);
    plansToUpload.put((BPELPlan)buildPlan,planTmpFile);
  }
  LOG.debug(""String_Node_Str"" + buildPlans.size());
  for (  final AbstractPlan buildPlan : plansToUpload.keySet()) {
    final File planTmpFile=plansToUpload.get(buildPlan);
    final List<String> inputParameters=((BPELPlan)buildPlan).getWsdl().getInputMessageLocalNames();
    final List<String> outputParameters=((BPELPlan)buildPlan).getWsdl().getOuputMessageLocalNames();
    final JSONObject obj=new JSONObject();
    obj.put(""String_Node_Str"",buildPlan.getId());
    obj.put(""String_Node_Str"",buildPlan.getType().getString());
    obj.put(""String_Node_Str"",((BPELPlan)buildPlan).bpelNamespace);
    final HttpEntity ent=EntityBuilder.create().setText(obj.toJSONString()).setContentType(ContentType.APPLICATION_JSON).build();
    HttpResponse createPlanResponse=null;
    try {
      createPlanResponse=openToscaHttpService.Post(getState().getPostUrl().toString(),ent);
    }
 catch (    final ClientProtocolException e2) {
      this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
      this.state.currentMessage=""String_Node_Str"" + createPlanResponse.getStatusLine().getStatusCode();
      Util.deleteCSAR(csarId);
      LOG.error(""String_Node_Str"" + createPlanResponse.getStatusLine().getStatusCode());
      return;
    }
catch (    final IOException e2) {
      this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
      this.state.currentMessage=""String_Node_Str"" + createPlanResponse.getStatusLine().getStatusCode();
      Util.deleteCSAR(csarId);
      LOG.error(""String_Node_Str"" + createPlanResponse.getStatusLine().getStatusCode());
      return;
    }
    final org.apache.http.Header planLocationHeader=createPlanResponse.getHeaders(""String_Node_Str"")[0];
    final String planLocation=planLocationHeader.getValue();
    try {
      this.state.currentState=PlanGenerationStates.PLANSENDING;
      this.state.currentMessage=""String_Node_Str"";
      LOG.debug(""String_Node_Str"");
      for (      final String inputParam : inputParameters) {
        final String inputParamPostUrl=planLocation + ""String_Node_Str"";
        final List<NameValuePair> params=new ArrayList<>();
        params.add(Util.createNameValuePair(""String_Node_Str"",inputParam));
        params.add(Util.createNameValuePair(""String_Node_Str"",""String_Node_Str""));
        params.add(Util.createNameValuePair(""String_Node_Str"",""String_Node_Str""));
        final UrlEncodedFormEntity encodedForm=new UrlEncodedFormEntity(params);
        final HttpResponse inputParamPostResponse=openToscaHttpService.Post(inputParamPostUrl,encodedForm);
        if (inputParamPostResponse.getStatusLine().getStatusCode() >= 300) {
          this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
          this.state.currentMessage=""String_Node_Str"" + inputParamPostUrl + ""String_Node_Str""+ inputParam+ ""String_Node_Str""+ inputParamPostResponse.getStatusLine().getStatusCode();
          Util.deleteCSAR(csarId);
          LOG.error(""String_Node_Str"" + inputParamPostUrl + ""String_Node_Str""+ inputParam+ ""String_Node_Str""+ inputParamPostResponse.getStatusLine().getStatusCode());
          return;
        }
        LOG.debug(""String_Node_Str"" + inputParam);
      }
      for (      final String outputParam : outputParameters) {
        final String outputParamPostUrl=planLocation + ""String_Node_Str"";
        final List<NameValuePair> params=new ArrayList<>();
        params.add(Util.createNameValuePair(""String_Node_Str"",outputParam));
        params.add(Util.createNameValuePair(""String_Node_Str"",""String_Node_Str""));
        params.add(Util.createNameValuePair(""String_Node_Str"",""String_Node_Str""));
        final UrlEncodedFormEntity encodedForm=new UrlEncodedFormEntity(params);
        final HttpResponse outputParamPostResponse=openToscaHttpService.Post(outputParamPostUrl,encodedForm);
        if (outputParamPostResponse.getStatusLine().getStatusCode() >= 300) {
          this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
          this.state.currentMessage=""String_Node_Str"" + outputParamPostUrl + ""String_Node_Str""+ outputParam+ ""String_Node_Str""+ outputParamPostResponse.getStatusLine().getStatusCode();
          Util.deleteCSAR(csarId);
          LOG.error(""String_Node_Str"" + outputParamPostUrl + ""String_Node_Str""+ outputParam+ ""String_Node_Str""+ outputParamPostResponse.getStatusLine().getStatusCode());
          return;
        }
        LOG.debug(""String_Node_Str"" + outputParam);
      }
      final MultipartEntity mpEntity=new MultipartEntity();
      final FileBody bin=new FileBody(planTmpFile);
      final ContentBody cb=bin;
      mpEntity.addPart(""String_Node_Str"",cb);
      final HttpResponse uploadResponse=openToscaHttpService.Put(planLocation + ""String_Node_Str"",mpEntity);
      if (uploadResponse.getStatusLine().getStatusCode() >= 300) {
        this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
        this.state.currentMessage=""String_Node_Str"" + uploadResponse.getStatusLine().getStatusCode();
        Util.deleteCSAR(csarId);
        LOG.error(""String_Node_Str"" + uploadResponse.getStatusLine().getStatusCode());
        return;
      }
      try {
        LOG.debug(""String_Node_Str"");
        this.state.currentState=PlanGenerationStates.OPTIONSENDING;
        this.state.currentMessage=""String_Node_Str"";
        final URL optionsUrl=new URL(this.state.getCsarUrl(),""String_Node_Str"");
        LOG.debug(""String_Node_Str"" + optionsUrl.toString());
        final SelfServiceOptionWrapper option=Util.generateSelfServiceOption((BPELPlan)buildPlan);
        LOG.debug(""String_Node_Str"" + option.toString());
        final MultipartEntity mpOptionEntity=new MultipartEntity();
        try {
          mpOptionEntity.addPart(""String_Node_Str"",new StringBody(option.option.getName()));
          mpOptionEntity.addPart(""String_Node_Str"",new StringBody(option.option.getDescription()));
          mpOptionEntity.addPart(""String_Node_Str"",new StringBody(option.option.getPlanServiceName()));
          mpOptionEntity.addPart(""String_Node_Str"",new StringBody(FileUtils.readFileToString(option.planInputMessageFile)));
        }
 catch (        final UnsupportedEncodingException e1) {
          this.state.currentState=PlanGenerationStates.OPTIONSENDINGFAILED;
          this.state.currentMessage=""String_Node_Str"";
          Util.deleteCSAR(csarId);
          LOG.error(""String_Node_Str"" + optionsUrl.toString());
          return;
        }
        final FileBody fileBody=new FileBody(option.planInputMessageFile);
        final ContentBody contentBody=fileBody;
        mpOptionEntity.addPart(""String_Node_Str"",contentBody);
        final HttpResponse optionsResponse=openToscaHttpService.Post(optionsUrl.toString(),mpOptionEntity);
        if (optionsResponse.getStatusLine().getStatusCode() >= 300) {
          this.state.currentState=PlanGenerationStates.OPTIONSENDINGFAILED;
          this.state.currentMessage=""String_Node_Str"" + optionsResponse.getStatusLine().getStatusCode() + ""String_Node_Str""+ optionsResponse.getStatusLine().getReasonPhrase();
          Util.deleteCSAR(csarId);
          return;
        }
 else {
          this.state.currentState=PlanGenerationStates.OPTIONSENT;
          this.state.currentMessage=""String_Node_Str"";
        }
      }
 catch (      final MalformedURLException e) {
        this.state.currentState=PlanGenerationStates.OPTIONSENDINGFAILED;
        this.state.currentMessage=""String_Node_Str"";
        Util.deleteCSAR(csarId);
        return;
      }
catch (      final IOException e) {
        this.state.currentState=PlanGenerationStates.OPTIONSENDINGFAILED;
        this.state.currentMessage=""String_Node_Str"";
        Util.deleteCSAR(csarId);
        return;
      }
      this.state.currentState=PlanGenerationStates.PLANSSENT;
      this.state.currentMessage=""String_Node_Str"";
      LOG.debug(""String_Node_Str"");
    }
 catch (    final ClientProtocolException e) {
      this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
      this.state.currentMessage=""String_Node_Str"";
      Util.deleteCSAR(csarId);
      LOG.error(""String_Node_Str"");
      return;
    }
catch (    final IOException e) {
      this.state.currentState=PlanGenerationStates.PLANSENDINGFAILED;
      this.state.currentMessage=""String_Node_Str"";
      Util.deleteCSAR(csarId);
      LOG.error(""String_Node_Str"");
      return;
    }
  }
  this.state.currentState=PlanGenerationStates.FINISHED;
  this.state.currentMessage=""String_Node_Str"";
  Util.deleteCSAR(csarId);
}"
41455,"public static SelfServiceOptionWrapper generateSelfServiceOption(final BPELPlan buildPlan) throws IOException {
  final String id=String.valueOf(System.currentTimeMillis());
  final ApplicationOption option=new ApplicationOption();
  final File tmpDir=new File(System.getProperty(""String_Node_Str"") + System.getProperty(""String_Node_Str"") + Long.toString(System.currentTimeMillis()));
  tmpDir.mkdir();
  final File planInputMessageFile=new File(tmpDir,""String_Node_Str"" + id + ""String_Node_Str"");
  option.setName(""String_Node_Str"");
  option.setId(id);
  option.setIconUrl(""String_Node_Str"");
  option.setDescription(""String_Node_Str"");
  option.setPlanServiceName(Util.getBuildPlanServiceName(buildPlan.getDeploymentDeskriptor()).getLocalPart());
  option.setPlanInputMessageUrl(""String_Node_Str"" + id + ""String_Node_Str"");
  Util.writePlanInputMessageInstance(buildPlan,planInputMessageFile);
  return new SelfServiceOptionWrapper(option,planInputMessageFile);
}","public static SelfServiceOptionWrapper generateSelfServiceOption(final BPELPlan buildPlan) throws IOException {
  final String id=String.valueOf(System.currentTimeMillis());
  final ApplicationOption option=new ApplicationOption();
  final File tmpDir=new File(System.getProperty(""String_Node_Str"") + System.getProperty(""String_Node_Str"") + Long.toString(System.currentTimeMillis()));
  tmpDir.mkdir();
  final File planInputMessageFile=new File(tmpDir,""String_Node_Str"" + id + ""String_Node_Str"");
  option.setName(Util.getBuildPlanServiceName(buildPlan.getDeploymentDeskriptor()).getLocalPart());
  option.setId(id);
  option.setIconUrl(""String_Node_Str"");
  option.setDescription(""String_Node_Str"");
  option.setPlanServiceName(Util.getBuildPlanServiceName(buildPlan.getDeploymentDeskriptor()).getLocalPart());
  option.setPlanInputMessageUrl(""String_Node_Str"" + id + ""String_Node_Str"");
  Util.writePlanInputMessageInstance(buildPlan,planInputMessageFile);
  return new SelfServiceOptionWrapper(option,planInputMessageFile);
}"
41456,"@GET @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response getDeploymentTests(@PathParam(""String_Node_Str"") final String csar,@PathParam(""String_Node_Str"") final String servicetemplate,@PathParam(""String_Node_Str"") final Integer id){
  final CSARContent csarContent=this.csarService.findById(csar);
  if (!this.csarService.hasServiceTemplate(csarContent.getCSARID(),servicetemplate)) {
    logger.info(""String_Node_Str"" + servicetemplate + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + servicetemplate + ""String_Node_Str"");
  }
  final ServiceTemplateInstance sti=new ServiceTemplateInstanceRepository().find(Long.valueOf(id)).orElse(null);
  if (sti == null) {
    logger.info(""String_Node_Str"" + id + ""String_Node_Str""+ servicetemplate+ ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str""+ servicetemplate+ ""String_Node_Str"");
  }
  final List<ResourceDecorator> items=sti.getDeploymentTests().stream().map(v -> {
    final ResourceDecorator decorator=new ResourceDecorator();
    decorator.setObject(v);
    decorator.add(Link.fromUri(UriUtil.encode(this.uriInfo.getAbsolutePathBuilder().path(String.valueOf(v.getId())).build())).rel(""String_Node_Str"").build());
    return decorator;
  }
).collect(Collectors.toList());
  final ResourceDecorator response=new ResourceDecorator();
  response.setObject(items);
  response.add(Link.fromUri(UriUtil.encode(this.uriInfo.getAbsolutePath())).rel(""String_Node_Str"").build());
  return Response.ok(response).build();
}","@GET @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response getDeploymentTests(@PathParam(""String_Node_Str"") final Integer id){
  final CSARContent csarContent=this.csarService.findById(this.csarId);
  if (!this.csarService.hasServiceTemplate(csarContent.getCSARID(),this.serviceTemplateId)) {
    logger.info(""String_Node_Str"" + this.serviceTemplateId + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + this.serviceTemplateId + ""String_Node_Str"");
  }
  final ServiceTemplateInstance sti=new ServiceTemplateInstanceRepository().find(Long.valueOf(id)).orElse(null);
  if (sti == null) {
    logger.info(""String_Node_Str"" + id + ""String_Node_Str""+ this.serviceTemplateId+ ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str""+ this.serviceTemplateId+ ""String_Node_Str"");
  }
  final List<ResourceDecorator> items=sti.getDeploymentTests().stream().map(v -> {
    final ResourceDecorator decorator=new ResourceDecorator();
    decorator.setObject(v);
    decorator.add(Link.fromUri(UriUtil.encode(this.uriInfo.getAbsolutePathBuilder().path(String.valueOf(v.getId())).build())).rel(""String_Node_Str"").build());
    return decorator;
  }
).collect(Collectors.toList());
  final ResourceDecorator response=new ResourceDecorator();
  response.setObject(items);
  response.add(Link.fromUri(UriUtil.encode(this.uriInfo.getAbsolutePath())).rel(""String_Node_Str"").build());
  return Response.ok(response).build();
}"
41457,"@GET @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response getDeploymentTest(@PathParam(""String_Node_Str"") final String csar,@PathParam(""String_Node_Str"") final String servicetemplate,@PathParam(""String_Node_Str"") final Integer id,@PathParam(""String_Node_Str"") final Integer deploymenttest){
  final CSARContent csarContent=this.csarService.findById(csar);
  if (!this.csarService.hasServiceTemplate(csarContent.getCSARID(),servicetemplate)) {
    logger.info(""String_Node_Str"" + servicetemplate + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + servicetemplate + ""String_Node_Str"");
  }
  final ServiceTemplateInstance sti=new ServiceTemplateInstanceRepository().find(Long.valueOf(id)).orElse(null);
  if (sti == null) {
    logger.info(""String_Node_Str"" + id + ""String_Node_Str""+ servicetemplate+ ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str""+ servicetemplate+ ""String_Node_Str"");
  }
  final DeploymentTest object=new DeploymentTestRepository().find(Long.valueOf(deploymenttest)).orElse(null);
  if (object == null) {
    throw new NotFoundException();
  }
  final ResourceDecorator response=new ResourceDecorator();
  response.setObject(object);
  response.add(Link.fromUri(UriUtil.encode(this.uriInfo.getAbsolutePath())).rel(""String_Node_Str"").build());
  return Response.ok(response).build();
}","@GET @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response getDeploymentTest(@PathParam(""String_Node_Str"") final Integer id,@PathParam(""String_Node_Str"") final Integer deploymenttest){
  final CSARContent csarContent=this.csarService.findById(this.csarId);
  if (!this.csarService.hasServiceTemplate(csarContent.getCSARID(),this.serviceTemplateId)) {
    logger.info(""String_Node_Str"" + this.serviceTemplateId + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + this.serviceTemplateId + ""String_Node_Str"");
  }
  final ServiceTemplateInstance sti=new ServiceTemplateInstanceRepository().find(Long.valueOf(id)).orElse(null);
  if (sti == null) {
    logger.info(""String_Node_Str"" + id + ""String_Node_Str""+ this.serviceTemplateId+ ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str""+ this.serviceTemplateId+ ""String_Node_Str"");
  }
  final DeploymentTest object=new DeploymentTestRepository().find(Long.valueOf(deploymenttest)).orElse(null);
  if (object == null) {
    throw new NotFoundException();
  }
  final ResourceDecorator response=new ResourceDecorator();
  response.setObject(object);
  response.add(Link.fromUri(UriUtil.encode(this.uriInfo.getAbsolutePath())).rel(""String_Node_Str"").build());
  return Response.ok(response).build();
}"
41458,"@POST @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response createDeploymentTest(@PathParam(""String_Node_Str"") final String csar,@PathParam(""String_Node_Str"") final String servicetemplate,@PathParam(""String_Node_Str"") final Integer id){
  final CSARContent csarContent=this.csarService.findById(csar);
  if (!this.csarService.hasServiceTemplate(csarContent.getCSARID(),servicetemplate)) {
    logger.info(""String_Node_Str"" + servicetemplate + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + servicetemplate + ""String_Node_Str"");
  }
  final ServiceTemplateInstance sti=new ServiceTemplateInstanceRepository().find(Long.valueOf(id)).orElse(null);
  if (sti == null) {
    logger.info(""String_Node_Str"" + id + ""String_Node_Str""+ servicetemplate+ ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str""+ servicetemplate+ ""String_Node_Str"");
  }
  final DeploymentTest result=this.deploymentTestService.run(csarContent.getCSARID(),sti);
  final URI location=this.uriInfo.getAbsolutePathBuilder().path(String.valueOf(result.getId())).build();
  return Response.created(UriUtil.encode(location)).build();
}","@POST @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response createDeploymentTest(@PathParam(""String_Node_Str"") final Integer id){
  final CSARContent csarContent=this.csarService.findById(this.csarId);
  if (!this.csarService.hasServiceTemplate(csarContent.getCSARID(),this.serviceTemplateId)) {
    logger.info(""String_Node_Str"" + this.serviceTemplateId + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + this.serviceTemplateId + ""String_Node_Str"");
  }
  final ServiceTemplateInstance sti=new ServiceTemplateInstanceRepository().find(Long.valueOf(id)).orElse(null);
  if (sti == null) {
    logger.info(""String_Node_Str"" + id + ""String_Node_Str""+ this.serviceTemplateId+ ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str""+ this.serviceTemplateId+ ""String_Node_Str"");
  }
  final DeploymentTest result=this.deploymentTestService.run(csarContent.getCSARID(),sti);
  final URI location=this.uriInfo.getAbsolutePathBuilder().path(String.valueOf(result.getId())).build();
  return Response.created(UriUtil.encode(location)).build();
}"
41459,"/** 
 * Appends BPEL Code that updates InstanceData for the given NodeTemplate. Needs initialization code on the global level in the plan. This will be checked and appended if needed.
 * @param context the TemplateContext of the NodeTemplate
 * @param nodeTemplate the NodeTemplate to handle
 * @return true iff appending all BPEL code was successful
 */
public boolean handleBuild(final BPELPlanContext context,final AbstractNodeTemplate nodeTemplate){
  final boolean hasProps=checkProperties(nodeTemplate.getProperties());
  final String serviceInstanceVarName=context.getServiceInstanceURLVarName();
  if (serviceInstanceVarName == null) {
    return false;
  }
  final String serviceInstanceIDVarName=context.getServiceInstanceIDVarName();
  if (serviceInstanceIDVarName == null) {
    return false;
  }
  final String instanceDataAPIVarName=context.getServiceTemplateURLVar();
  if (instanceDataAPIVarName == null) {
    return false;
  }
  final String restCallResponseVarName=createRESTResponseVar(context);
  if (restCallResponseVarName == null) {
    return false;
  }
  final String stateVarName=createStateVar(context,context.getNodeTemplate().getId());
  if (stateVarName == null) {
    return false;
  }
  try {
    final String bpelString=this.fragments.generateBPEL4RESTLightNodeInstancePOST(instanceDataAPIVarName,serviceInstanceIDVarName,context.getNodeTemplate().getId(),restCallResponseVarName);
    Node createNodeInstanceExActiv=ModelUtils.string2dom(bpelString);
    createNodeInstanceExActiv=context.importNode(createNodeInstanceExActiv);
    context.getPrePhaseElement().appendChild(createNodeInstanceExActiv);
  }
 catch (  final IOException e2) {
    e2.printStackTrace();
  }
catch (  final SAXException e) {
    e.printStackTrace();
  }
catch (  final ParserConfigurationException e) {
    e.printStackTrace();
  }
  String nodeInstanceURLVarName=""String_Node_Str"";
  if (context.findInstanceURLVar(context.getNodeTemplate().getId(),true) == null) {
    nodeInstanceURLVarName=createInstanceURLVar(context,context.getNodeTemplate().getId());
  }
 else {
    nodeInstanceURLVarName=context.findInstanceURLVar(context.getNodeTemplate().getId(),true);
  }
  if (nodeInstanceURLVarName == null) {
    return false;
  }
  String nodeInstanceIDVarName=""String_Node_Str"";
  if (context.findInstanceIDVar(context.getNodeTemplate().getId(),true) == null) {
    nodeInstanceIDVarName=createInstanceIDVar(context,context.getNodeTemplate().getId());
  }
 else {
    nodeInstanceIDVarName=context.findInstanceIDVar(context.getNodeTemplate().getId(),true);
  }
  if (nodeInstanceIDVarName == null) {
    return false;
  }
  try {
    final String bpelString=this.fragments.generateAssignFromNodeInstancePOSTResponseToStringVar(nodeInstanceURLVarName,nodeInstanceIDVarName,restCallResponseVarName);
    Node assignNodeInstanceUrl=ModelUtils.string2dom(bpelString);
    assignNodeInstanceUrl=context.importNode(assignNodeInstanceUrl);
    context.getPrePhaseElement().appendChild(assignNodeInstanceUrl);
  }
 catch (  final IOException e2) {
    e2.printStackTrace();
  }
catch (  final SAXException e) {
    e.printStackTrace();
  }
catch (  final ParserConfigurationException e) {
    e.printStackTrace();
  }
  try {
    final BPELProcessFragments frag=new BPELProcessFragments();
    Node assignNode=frag.createAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"",stateVarName);
    assignNode=context.importNode(assignNode);
    context.getPrePhaseElement().appendChild(assignNode);
    final String bpelString=this.fragments.generateBPEL4RESTLightPUTInstanceState(nodeInstanceURLVarName,stateVarName);
    Node extActiv=ModelUtils.string2dom(bpelString);
    extActiv=context.importNode(extActiv);
    context.getPrePhaseElement().appendChild(extActiv);
  }
 catch (  final IOException e2) {
    e2.printStackTrace();
  }
catch (  final SAXException e) {
    e.printStackTrace();
  }
catch (  final ParserConfigurationException e) {
    e.printStackTrace();
  }
  String lastSetState=""String_Node_Str"";
  final Element provisioningPhaseElement=context.getProvisioningPhaseElement();
  final List<Element> assignContentElements=fetchInvokerCallAssigns(provisioningPhaseElement);
  final List<String> operationNames=new ArrayList<>();
  for (  final Element assignContentElement : assignContentElements) {
    final String operationName=fetchOperationName(assignContentElement);
    operationNames.add(operationName);
    final String preState=InstanceStates.getOperationPreState(operationName);
    final String postState=InstanceStates.getOperationPostState(operationName);
    if (preState != null) {
      try {
        final BPELProcessFragments frag=new BPELProcessFragments();
        Node assignNode=frag.createAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + operationName + ""String_Node_Str""+ System.currentTimeMillis(),""String_Node_Str"" + preState + ""String_Node_Str"",stateVarName);
        assignNode=context.importNode(assignNode);
        lastSetState=preState;
        final Node bpelAssignNode=assignContentElement.getParentNode().getParentNode().getParentNode().getParentNode();
        bpelAssignNode.getParentNode().insertBefore(assignNode,bpelAssignNode);
        final String bpelString=this.fragments.generateBPEL4RESTLightPUTInstanceState(nodeInstanceURLVarName,stateVarName);
        Node extActiv=ModelUtils.string2dom(bpelString);
        extActiv=context.importNode(extActiv);
        bpelAssignNode.getParentNode().insertBefore(extActiv,bpelAssignNode);
      }
 catch (      final IOException e2) {
        e2.printStackTrace();
      }
catch (      final SAXException e) {
        e.printStackTrace();
      }
catch (      final ParserConfigurationException e) {
        e.printStackTrace();
      }
    }
    if (postState != null) {
      try {
        final BPELProcessFragments frag=new BPELProcessFragments();
        Node assignNode=frag.createAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + operationName + ""String_Node_Str""+ System.currentTimeMillis(),""String_Node_Str"" + postState + ""String_Node_Str"",stateVarName);
        assignNode=context.importNode(assignNode);
        lastSetState=postState;
        final Node bpelAssignNode=assignContentElement.getParentNode().getParentNode().getParentNode().getParentNode();
        final String reqVarName=fetchRequestVarNameFromInvokerAssign(assignContentElement);
        final Element invokerReceiveElement=fetchInvokerReceive((Element)bpelAssignNode,reqVarName);
        assignNode=invokerReceiveElement.getParentNode().insertBefore(assignNode,invokerReceiveElement.getNextSibling());
        final String bpelString=this.fragments.generateBPEL4RESTLightPUTInstanceState(nodeInstanceURLVarName,stateVarName);
        Node extActiv=ModelUtils.string2dom(bpelString);
        extActiv=context.importNode(extActiv);
        final Element afterElement=(Element)invokerReceiveElement.getParentNode().insertBefore(extActiv,assignNode.getNextSibling());
        appendUpdateProperties(context,nodeTemplate,nodeInstanceURLVarName,restCallResponseVarName,afterElement.getParentNode());
      }
 catch (      final IOException e2) {
        e2.printStackTrace();
      }
catch (      final SAXException e) {
        e.printStackTrace();
      }
catch (      final ParserConfigurationException e) {
        e.printStackTrace();
      }
    }
  }
  if (lastSetState.equals(""String_Node_Str"")) {
    try {
      String nextState=InstanceStates.getNextStableOperationState(lastSetState);
      if (operationNames.isEmpty()) {
        nextState=""String_Node_Str"";
      }
      final BPELProcessFragments frag=new BPELProcessFragments();
      Node assignNode=frag.createAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"" + nextState + ""String_Node_Str"",stateVarName);
      assignNode=context.importNode(assignNode);
      final String bpelString=this.fragments.generateBPEL4RESTLightPUTInstanceState(nodeInstanceURLVarName,stateVarName);
      Node extActiv=ModelUtils.string2dom(bpelString);
      extActiv=context.importNode(extActiv);
      context.getPostPhaseElement().appendChild(assignNode);
      context.getPostPhaseElement().appendChild(extActiv);
    }
 catch (    final IOException e2) {
      e2.printStackTrace();
    }
catch (    final SAXException e) {
      e.printStackTrace();
    }
catch (    final ParserConfigurationException e) {
      e.printStackTrace();
    }
  }
  if (hasProps) {
    final Element postPhaseElement=context.getPostPhaseElement();
    appendUpdateProperties(context,nodeTemplate,nodeInstanceURLVarName,restCallResponseVarName,postPhaseElement);
  }
  return true;
}","/** 
 * Appends BPEL Code that updates InstanceData for the given NodeTemplate. Needs initialization code on the global level in the plan. This will be checked and appended if needed.
 * @param context the TemplateContext of the NodeTemplate
 * @param nodeTemplate the NodeTemplate to handle
 * @return true iff appending all BPEL code was successful
 */
public boolean handleBuild(final BPELPlanContext context,final AbstractNodeTemplate nodeTemplate){
  final boolean hasProps=checkProperties(nodeTemplate.getProperties());
  final String serviceInstanceVarName=context.getServiceInstanceURLVarName();
  if (serviceInstanceVarName == null) {
    return false;
  }
  final String serviceInstanceIDVarName=context.getServiceInstanceIDVarName();
  if (serviceInstanceIDVarName == null) {
    return false;
  }
  final String instanceDataAPIVarName=context.getServiceTemplateURLVar();
  if (instanceDataAPIVarName == null) {
    return false;
  }
  final String restCallResponseVarName=createRESTResponseVar(context);
  if (restCallResponseVarName == null) {
    return false;
  }
  final String stateVarName=createStateVar(context,context.getNodeTemplate().getId());
  if (stateVarName == null) {
    return false;
  }
  try {
    final String bpelString=this.fragments.generateBPEL4RESTLightNodeInstancePOST(instanceDataAPIVarName,serviceInstanceIDVarName,context.getNodeTemplate().getId(),restCallResponseVarName);
    Node createNodeInstanceExActiv=ModelUtils.string2dom(bpelString);
    createNodeInstanceExActiv=context.importNode(createNodeInstanceExActiv);
    context.getPrePhaseElement().appendChild(createNodeInstanceExActiv);
  }
 catch (  final IOException e2) {
    e2.printStackTrace();
  }
catch (  final SAXException e) {
    e.printStackTrace();
  }
catch (  final ParserConfigurationException e) {
    e.printStackTrace();
  }
  String nodeInstanceURLVarName=""String_Node_Str"";
  if (context.findInstanceURLVar(context.getNodeTemplate().getId(),true) == null) {
    nodeInstanceURLVarName=createInstanceURLVar(context,context.getNodeTemplate().getId());
  }
 else {
    nodeInstanceURLVarName=context.findInstanceURLVar(context.getNodeTemplate().getId(),true);
  }
  if (nodeInstanceURLVarName == null) {
    return false;
  }
  String nodeInstanceIDVarName=""String_Node_Str"";
  if (context.findInstanceIDVar(context.getNodeTemplate().getId(),true) == null) {
    nodeInstanceIDVarName=createInstanceIDVar(context,context.getNodeTemplate().getId());
  }
 else {
    nodeInstanceIDVarName=context.findInstanceIDVar(context.getNodeTemplate().getId(),true);
  }
  if (nodeInstanceIDVarName == null) {
    return false;
  }
  try {
    final String bpelString=this.fragments.generateAssignFromNodeInstancePOSTResponseToStringVar(nodeInstanceURLVarName,nodeInstanceIDVarName,restCallResponseVarName);
    Node assignNodeInstanceUrl=ModelUtils.string2dom(bpelString);
    assignNodeInstanceUrl=context.importNode(assignNodeInstanceUrl);
    context.getPrePhaseElement().appendChild(assignNodeInstanceUrl);
  }
 catch (  final IOException e2) {
    e2.printStackTrace();
  }
catch (  final SAXException e) {
    e.printStackTrace();
  }
catch (  final ParserConfigurationException e) {
    e.printStackTrace();
  }
  try {
    final BPELProcessFragments frag=new BPELProcessFragments();
    Node assignNode=frag.createAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"",stateVarName);
    assignNode=context.importNode(assignNode);
    context.getPrePhaseElement().appendChild(assignNode);
    final String bpelString=this.fragments.generateBPEL4RESTLightPUTInstanceState(nodeInstanceURLVarName,stateVarName);
    Node extActiv=ModelUtils.string2dom(bpelString);
    extActiv=context.importNode(extActiv);
    context.getPrePhaseElement().appendChild(extActiv);
  }
 catch (  final IOException e2) {
    e2.printStackTrace();
  }
catch (  final SAXException e) {
    e.printStackTrace();
  }
catch (  final ParserConfigurationException e) {
    e.printStackTrace();
  }
  String lastSetState=""String_Node_Str"";
  final Element provisioningPhaseElement=context.getProvisioningPhaseElement();
  final List<Element> assignContentElements=fetchInvokerCallAssigns(provisioningPhaseElement);
  final List<String> operationNames=new ArrayList<>();
  for (  final Element assignContentElement : assignContentElements) {
    final String operationName=fetchOperationName(assignContentElement);
    operationNames.add(operationName);
    final String preState=InstanceStates.getOperationPreState(operationName);
    final String postState=InstanceStates.getOperationPostState(operationName);
    if (preState != null) {
      try {
        final BPELProcessFragments frag=new BPELProcessFragments();
        Node assignNode=frag.createAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + operationName + ""String_Node_Str""+ System.currentTimeMillis(),""String_Node_Str"" + preState + ""String_Node_Str"",stateVarName);
        assignNode=context.importNode(assignNode);
        lastSetState=preState;
        final Node bpelAssignNode=assignContentElement.getParentNode().getParentNode().getParentNode().getParentNode();
        bpelAssignNode.getParentNode().insertBefore(assignNode,bpelAssignNode);
        final String bpelString=this.fragments.generateBPEL4RESTLightPUTInstanceState(nodeInstanceURLVarName,stateVarName);
        Node extActiv=ModelUtils.string2dom(bpelString);
        extActiv=context.importNode(extActiv);
        bpelAssignNode.getParentNode().insertBefore(extActiv,bpelAssignNode);
      }
 catch (      final IOException e2) {
        e2.printStackTrace();
      }
catch (      final SAXException e) {
        e.printStackTrace();
      }
catch (      final ParserConfigurationException e) {
        e.printStackTrace();
      }
    }
    if (postState != null) {
      try {
        final BPELProcessFragments frag=new BPELProcessFragments();
        Node assignNode=frag.createAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + operationName + ""String_Node_Str""+ System.currentTimeMillis(),""String_Node_Str"" + postState + ""String_Node_Str"",stateVarName);
        assignNode=context.importNode(assignNode);
        lastSetState=postState;
        final Node bpelAssignNode=assignContentElement.getParentNode().getParentNode().getParentNode().getParentNode();
        final String reqVarName=fetchRequestVarNameFromInvokerAssign(assignContentElement);
        final Element invokerReceiveElement=fetchInvokerReceive((Element)bpelAssignNode,reqVarName);
        assignNode=invokerReceiveElement.getParentNode().insertBefore(assignNode,invokerReceiveElement.getNextSibling());
        final String bpelString=this.fragments.generateBPEL4RESTLightPUTInstanceState(nodeInstanceURLVarName,stateVarName);
        Node extActiv=ModelUtils.string2dom(bpelString);
        extActiv=context.importNode(extActiv);
        final Element afterElement=(Element)invokerReceiveElement.getParentNode().insertBefore(extActiv,assignNode.getNextSibling());
        if (hasProps) {
          appendUpdateProperties(context,nodeTemplate,nodeInstanceURLVarName,restCallResponseVarName,afterElement.getParentNode());
        }
      }
 catch (      final IOException e2) {
        e2.printStackTrace();
      }
catch (      final SAXException e) {
        e.printStackTrace();
      }
catch (      final ParserConfigurationException e) {
        e.printStackTrace();
      }
    }
  }
  if (lastSetState.equals(""String_Node_Str"")) {
    try {
      String nextState=InstanceStates.getNextStableOperationState(lastSetState);
      if (operationNames.isEmpty()) {
        nextState=""String_Node_Str"";
      }
      final BPELProcessFragments frag=new BPELProcessFragments();
      Node assignNode=frag.createAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"" + nextState + ""String_Node_Str"",stateVarName);
      assignNode=context.importNode(assignNode);
      final String bpelString=this.fragments.generateBPEL4RESTLightPUTInstanceState(nodeInstanceURLVarName,stateVarName);
      Node extActiv=ModelUtils.string2dom(bpelString);
      extActiv=context.importNode(extActiv);
      context.getPostPhaseElement().appendChild(assignNode);
      context.getPostPhaseElement().appendChild(extActiv);
    }
 catch (    final IOException e2) {
      e2.printStackTrace();
    }
catch (    final SAXException e) {
      e.printStackTrace();
    }
catch (    final ParserConfigurationException e) {
      e.printStackTrace();
    }
  }
  if (hasProps) {
    final Element postPhaseElement=context.getPostPhaseElement();
    appendUpdateProperties(context,nodeTemplate,nodeInstanceURLVarName,restCallResponseVarName,postPhaseElement);
  }
  return true;
}"
41460,"private boolean isRunning(final BPELPlanContext context,final AbstractNodeTemplate nodeTemplate){
  final Variable state=context.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  if (BPELPlanContext.getVariableContent(state,context).equals(""String_Node_Str"")) {
    return true;
  }
 else {
    return false;
  }
}","private boolean isRunning(final BPELPlanContext context,final AbstractNodeTemplate nodeTemplate){
  final Variable state=context.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  if (state != null) {
    if (BPELPlanContext.getVariableContent(state,context).equals(""String_Node_Str"")) {
      return true;
    }
  }
  return false;
}"
41461,"/** 
 * Constructor
 * @param nodeTemplate a JAXB TNodeTemplate
 * @param definitions a DefinitionsImpl
 */
public NodeTemplateImpl(final TNodeTemplate nodeTemplate,final DefinitionsImpl definitions){
  this.nodeTemplate=nodeTemplate;
  this.definitions=definitions;
  this.ingoingRelations=new ArrayList<>();
  this.outgoingRelations=new ArrayList<>();
  this.requirements=new ArrayList<>();
  this.capabilities=new ArrayList<>();
  this.das=new ArrayList<>();
  this.policies=new ArrayList<>();
  if (this.nodeTemplate.getProperties() != null) {
    this.properties=new PropertiesImpl(this.nodeTemplate.getProperties().getAny());
  }
  setUpCapabilities();
  setUpRequirements();
  setUpDeploymentArtifacts();
  setUpPolicies();
}","/** 
 * Constructor
 * @param nodeTemplate a JAXB TNodeTemplate
 * @param definitions a DefinitionsImpl
 */
public NodeTemplateImpl(final TNodeTemplate nodeTemplate,final DefinitionsImpl definitions){
  this.nodeTemplate=nodeTemplate;
  this.definitions=definitions;
  this.ingoingRelations=new ArrayList<>();
  this.outgoingRelations=new ArrayList<>();
  this.requirements=new ArrayList<>();
  this.capabilities=new ArrayList<>();
  this.das=new ArrayList<>();
  this.policies=new ArrayList<>();
  if (this.nodeTemplate.getProperties() != null && this.nodeTemplate.getProperties().getAny() != null) {
    this.properties=new PropertiesImpl(this.nodeTemplate.getProperties().getAny());
  }
  setUpCapabilities();
  setUpRequirements();
  setUpDeploymentArtifacts();
  setUpPolicies();
}"
41462,"/** 
 * Constructor
 * @param properties an Object of class ElementNSImpl
 */
public PropertiesImpl(final Object properties){
  this.props=properties;
  if (properties.getClass().getName().equals(""String_Node_Str"")) {
    this.isDOM=true;
  }
}","/** 
 * Constructor
 * @param properties an Object of class ElementNSImpl
 */
public PropertiesImpl(final Object properties){
  if (properties == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  this.props=properties;
  if (properties.getClass().getName().equals(""String_Node_Str"")) {
    this.isDOM=true;
  }
}"
41463,"/** 
 * <p> This method assigns plugins to the already initialized BuildPlan and its TemplateBuildPlans. First there will be checked if any generic plugin can handle a template of the TopologyTemplate </p>
 * @param buildPlan a BuildPlan which is alread initialized
 * @param map a PropertyMap which contains mappings from Template to Property and to variable nameof inside the BuidlPlan
 */
private void runPlugins(final BPELPlan buildPlan,final PropertyMap map){
  for (  final BPELScopeActivity templatePlan : buildPlan.getTemplateBuildPlans()) {
    final BPELPlanContext context=new BPELPlanContext(templatePlan,map,buildPlan.getServiceTemplate());
    if (templatePlan.getNodeTemplate() != null && !isRunning(context,templatePlan.getNodeTemplate())) {
      final AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
      BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"" + nodeTemplate.getId());
      final IPlanBuilderTypePlugin plugin=this.findTypePlugin(nodeTemplate);
      if (plugin == null) {
        BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"",nodeTemplate.getId());
        final OperationChain chain=BPELScopeBuilder.createOperationChain(nodeTemplate);
        if (chain == null) {
          BPELBuildProcessBuilder.LOG.warn(""String_Node_Str"",nodeTemplate.getId());
        }
 else {
          BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"",nodeTemplate.getId());
          chain.executeIAProvisioning(context);
          chain.executeDAProvisioning(context);
          chain.executeOperationProvisioning(context,this.opNames);
        }
      }
 else {
        BPELBuildProcessBuilder.LOG.info(""String_Node_Str"",nodeTemplate.getId());
        plugin.handle(context);
      }
      for (      final IPlanBuilderPostPhasePlugin postPhasePlugin : this.pluginRegistry.getPostPlugins()) {
        if (postPhasePlugin.canHandle(nodeTemplate)) {
          postPhasePlugin.handle(context,nodeTemplate);
        }
      }
    }
 else {
      final AbstractRelationshipTemplate relationshipTemplate=templatePlan.getRelationshipTemplate();
      if (!canGenericPluginHandle(relationshipTemplate)) {
        BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"",relationshipTemplate.getId());
        final OperationChain sourceChain=BPELScopeBuilder.createOperationChain(relationshipTemplate,true);
        final OperationChain targetChain=BPELScopeBuilder.createOperationChain(relationshipTemplate,false);
        if (targetChain != null) {
          BPELBuildProcessBuilder.LOG.warn(""String_Node_Str"",relationshipTemplate.getId());
          targetChain.executeIAProvisioning(context);
          targetChain.executeOperationProvisioning(context,this.opNames);
        }
        if (sourceChain != null) {
          BPELBuildProcessBuilder.LOG.warn(""String_Node_Str"",relationshipTemplate.getId());
          sourceChain.executeIAProvisioning(context);
          sourceChain.executeOperationProvisioning(context,this.opNames);
        }
      }
 else {
        BPELBuildProcessBuilder.LOG.info(""String_Node_Str"",relationshipTemplate.getId());
        handleWithTypePlugin(context,relationshipTemplate);
      }
      for (      final IPlanBuilderPostPhasePlugin postPhasePlugin : this.pluginRegistry.getPostPlugins()) {
        if (postPhasePlugin.canHandle(relationshipTemplate)) {
          postPhasePlugin.handle(context,relationshipTemplate);
        }
      }
    }
  }
}","/** 
 * <p> This method assigns plugins to the already initialized BuildPlan and its TemplateBuildPlans. First there will be checked if any generic plugin can handle a template of the TopologyTemplate </p>
 * @param buildPlan a BuildPlan which is alread initialized
 * @param map a PropertyMap which contains mappings from Template to Property and to variable nameof inside the BuidlPlan
 */
private void runPlugins(final BPELPlan buildPlan,final PropertyMap map){
  for (  final BPELScopeActivity templatePlan : buildPlan.getTemplateBuildPlans()) {
    final BPELPlanContext context=new BPELPlanContext(templatePlan,map,buildPlan.getServiceTemplate());
    if (templatePlan.getNodeTemplate() != null) {
      if (isRunning(context,templatePlan.getNodeTemplate())) {
        BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"" + templatePlan.getNodeTemplate().getId() + ""String_Node_Str"");
        for (        final IPlanBuilderPostPhasePlugin postPhasePlugin : this.pluginRegistry.getPostPlugins()) {
          if (postPhasePlugin.canHandle(templatePlan.getNodeTemplate())) {
            postPhasePlugin.handle(context,templatePlan.getNodeTemplate());
          }
        }
        continue;
      }
      final AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
      BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"" + nodeTemplate.getId());
      final IPlanBuilderTypePlugin plugin=this.findTypePlugin(nodeTemplate);
      if (plugin == null) {
        BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"",nodeTemplate.getId());
        final OperationChain chain=BPELScopeBuilder.createOperationChain(nodeTemplate);
        if (chain == null) {
          BPELBuildProcessBuilder.LOG.warn(""String_Node_Str"",nodeTemplate.getId());
        }
 else {
          BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"",nodeTemplate.getId());
          chain.executeIAProvisioning(context);
          chain.executeDAProvisioning(context);
          chain.executeOperationProvisioning(context,this.opNames);
        }
      }
 else {
        BPELBuildProcessBuilder.LOG.info(""String_Node_Str"",nodeTemplate.getId());
        plugin.handle(context);
      }
      for (      final IPlanBuilderPostPhasePlugin postPhasePlugin : this.pluginRegistry.getPostPlugins()) {
        if (postPhasePlugin.canHandle(templatePlan.getNodeTemplate())) {
          postPhasePlugin.handle(context,templatePlan.getNodeTemplate());
        }
      }
    }
 else     if (templatePlan.getRelationshipTemplate() != null) {
      final AbstractRelationshipTemplate relationshipTemplate=templatePlan.getRelationshipTemplate();
      if (!canGenericPluginHandle(relationshipTemplate)) {
        BPELBuildProcessBuilder.LOG.debug(""String_Node_Str"",relationshipTemplate.getId());
        final OperationChain sourceChain=BPELScopeBuilder.createOperationChain(relationshipTemplate,true);
        final OperationChain targetChain=BPELScopeBuilder.createOperationChain(relationshipTemplate,false);
        if (targetChain != null) {
          BPELBuildProcessBuilder.LOG.warn(""String_Node_Str"",relationshipTemplate.getId());
          targetChain.executeIAProvisioning(context);
          targetChain.executeOperationProvisioning(context,this.opNames);
        }
        if (sourceChain != null) {
          BPELBuildProcessBuilder.LOG.warn(""String_Node_Str"",relationshipTemplate.getId());
          sourceChain.executeIAProvisioning(context);
          sourceChain.executeOperationProvisioning(context,this.opNames);
        }
      }
 else {
        BPELBuildProcessBuilder.LOG.info(""String_Node_Str"",relationshipTemplate.getId());
        handleWithTypePlugin(context,relationshipTemplate);
      }
      for (      final IPlanBuilderPostPhasePlugin postPhasePlugin : this.pluginRegistry.getPostPlugins()) {
        if (postPhasePlugin.canHandle(templatePlan.getRelationshipTemplate())) {
          postPhasePlugin.handle(context,templatePlan.getRelationshipTemplate());
        }
      }
    }
  }
}"
41464,"public boolean addInstanceIDVarToTemplatePlan(final BPELScopeActivity templatePlan){
  final String xsdPrefix=""String_Node_Str"" + System.currentTimeMillis();
  final String xsdNamespace=""String_Node_Str"";
  this.bpelProcessHandler.addNamespaceToBPELDoc(xsdPrefix,xsdNamespace,templatePlan.getBuildPlan());
  String templateId=""String_Node_Str"";
  String prefix=""String_Node_Str"";
  if (templatePlan.getNodeTemplate() != null) {
    templateId=templatePlan.getNodeTemplate().getId();
    prefix=""String_Node_Str"";
  }
 else {
    templateId=templatePlan.getRelationshipTemplate().getId();
    prefix=""String_Node_Str"";
  }
  final String instanceIdVarName=prefix + InstanceIDVarKeyword + ""String_Node_Str""+ templateId+ ""String_Node_Str""+ System.currentTimeMillis();
  return this.bpelProcessHandler.addVariable(instanceIdVarName,VariableType.TYPE,new QName(xsdNamespace,""String_Node_Str"",xsdPrefix),templatePlan.getBuildPlan());
}","public boolean addInstanceIDVarToTemplatePlan(final BPELScopeActivity templatePlan){
  final String xsdPrefix=""String_Node_Str"" + System.currentTimeMillis();
  final String xsdNamespace=""String_Node_Str"";
  this.bpelProcessHandler.addNamespaceToBPELDoc(xsdPrefix,xsdNamespace,templatePlan.getBuildPlan());
  String templateId=""String_Node_Str"";
  String prefix=""String_Node_Str"";
  if (templatePlan.getNodeTemplate() != null) {
    templateId=templatePlan.getNodeTemplate().getId();
    prefix=""String_Node_Str"";
  }
 else {
    templateId=templatePlan.getRelationshipTemplate().getId();
    prefix=""String_Node_Str"";
  }
  final String instanceIdVarName=prefix + InstanceIDVarKeyword + ""String_Node_Str""+ templateId.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ System.currentTimeMillis();
  return this.bpelProcessHandler.addVariable(instanceIdVarName,VariableType.TYPE,new QName(xsdNamespace,""String_Node_Str"",xsdPrefix),templatePlan.getBuildPlan());
}"
41465,"private String findInstanceIdVarName(final List<String> varNames,final String templateId,final boolean isNode){
  final String instanceURLVarName=(isNode ? ""String_Node_Str"" : ""String_Node_Str"") + InstanceURLVarKeyword + ""String_Node_Str""+ templateId+ ""String_Node_Str"";
  for (  final String varName : varNames) {
    if (varName.contains(instanceURLVarName)) {
      return varName;
    }
  }
  return null;
}","private String findInstanceIdVarName(final List<String> varNames,final String templateId,final boolean isNode){
  final String instanceURLVarName=(isNode ? ""String_Node_Str"" : ""String_Node_Str"") + InstanceURLVarKeyword + ""String_Node_Str""+ templateId.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
  for (  final String varName : varNames) {
    if (varName.contains(instanceURLVarName)) {
      return varName;
    }
  }
  return null;
}"
41466,"/** 
 * Adds a NodeInstanceID Variable to the given TemplatePlan
 * @param templatePlan a TemplatePlan
 * @return true iff adding a NodeInstanceID Var was successful
 */
public boolean addInstanceURLVarToTemplatePlan(final BPELScopeActivity templatePlan){
  final String xsdPrefix=""String_Node_Str"" + System.currentTimeMillis();
  final String xsdNamespace=""String_Node_Str"";
  this.bpelProcessHandler.addNamespaceToBPELDoc(xsdPrefix,xsdNamespace,templatePlan.getBuildPlan());
  String templateId=""String_Node_Str"";
  String prefix=""String_Node_Str"";
  if (templatePlan.getNodeTemplate() != null) {
    templateId=templatePlan.getNodeTemplate().getId();
    prefix=""String_Node_Str"";
  }
 else {
    templateId=templatePlan.getRelationshipTemplate().getId();
    prefix=""String_Node_Str"";
  }
  final String instanceIdVarName=prefix + InstanceURLVarKeyword + ""String_Node_Str""+ templateId+ ""String_Node_Str""+ System.currentTimeMillis();
  return this.bpelProcessHandler.addVariable(instanceIdVarName,VariableType.TYPE,new QName(xsdNamespace,""String_Node_Str"",xsdPrefix),templatePlan.getBuildPlan());
}","/** 
 * Adds a NodeInstanceID Variable to the given TemplatePlan
 * @param templatePlan a TemplatePlan
 * @return true iff adding a NodeInstanceID Var was successful
 */
public boolean addInstanceURLVarToTemplatePlan(final BPELScopeActivity templatePlan){
  final String xsdPrefix=""String_Node_Str"" + System.currentTimeMillis();
  final String xsdNamespace=""String_Node_Str"";
  this.bpelProcessHandler.addNamespaceToBPELDoc(xsdPrefix,xsdNamespace,templatePlan.getBuildPlan());
  String templateId=""String_Node_Str"";
  String prefix=""String_Node_Str"";
  if (templatePlan.getNodeTemplate() != null) {
    templateId=templatePlan.getNodeTemplate().getId();
    prefix=""String_Node_Str"";
  }
 else {
    templateId=templatePlan.getRelationshipTemplate().getId();
    prefix=""String_Node_Str"";
  }
  final String instanceIdVarName=prefix + InstanceURLVarKeyword + ""String_Node_Str""+ templateId.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ System.currentTimeMillis();
  return this.bpelProcessHandler.addVariable(instanceIdVarName,VariableType.TYPE,new QName(xsdNamespace,""String_Node_Str"",xsdPrefix),templatePlan.getBuildPlan());
}"
41467,"/** 
 * Initializes Property variables and mappings for a TemplateBuildPlan which handles a RelationshipTemplate
 * @param map the PropertyMap to save the result to
 * @param templatePlan a TemplateBuildPlan which handles a RelationshipTemplate
 */
private void initPropsAsVarsInRelationship(final PropertyMap map,final BPELScopeActivity templatePlan){
  final AbstractRelationshipTemplate relationshipTemplate=templatePlan.getRelationshipTemplate();
  if (relationshipTemplate.getProperties() != null) {
    final Element propertyElement=relationshipTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      final String propName=propertyElement.getChildNodes().item(i).getLocalName();
      final String propVarName=relationshipTemplate.getId() + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(relationshipTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      if (!value.trim().isEmpty() && !value.trim().equals(""String_Node_Str"")) {
        this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
      }
    }
  }
}","/** 
 * Initializes Property variables and mappings for a TemplateBuildPlan which handles a RelationshipTemplate
 * @param map the PropertyMap to save the result to
 * @param templatePlan a TemplateBuildPlan which handles a RelationshipTemplate
 */
private void initPropsAsVarsInRelationship(final PropertyMap map,final BPELScopeActivity templatePlan){
  final AbstractRelationshipTemplate relationshipTemplate=templatePlan.getRelationshipTemplate();
  if (relationshipTemplate.getProperties() != null) {
    final Element propertyElement=relationshipTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      final String propName=propertyElement.getChildNodes().item(i).getLocalName();
      final String propVarName=relationshipTemplate.getId().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(relationshipTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      if (!value.trim().isEmpty() && !value.trim().equals(""String_Node_Str"")) {
        this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
      }
    }
  }
}"
41468,"/** 
 * Initializes Property variables for the given TemplateBuildPlan which handles a NodeTemplate
 * @param map a PropertyMap to save the result/mappings to
 * @param templatePlan a TemplateBuildPlan which handles a NodeTemplate
 */
private void initPropsAsVarsInNode(final PropertyMap map,final BPELScopeActivity templatePlan){
  final AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
  if (nodeTemplate.getProperties() != null) {
    final Element propertyElement=nodeTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      final String propName=propertyElement.getChildNodes().item(i).getLocalName();
      final String propVarName=nodeTemplate.getId() + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(nodeTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
    }
  }
}","/** 
 * Initializes Property variables for the given TemplateBuildPlan which handles a NodeTemplate
 * @param map a PropertyMap to save the result/mappings to
 * @param templatePlan a TemplateBuildPlan which handles a NodeTemplate
 */
private void initPropsAsVarsInNode(final PropertyMap map,final BPELScopeActivity templatePlan){
  final AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
  if (nodeTemplate.getProperties() != null) {
    final Element propertyElement=nodeTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      final String propName=propertyElement.getChildNodes().item(i).getLocalName();
      final String propVarName=nodeTemplate.getId().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(nodeTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
    }
  }
}"
41469,"/** 
 * Initializes Properties inside the given PropertyMap of the given TemplateBuildPlan
 * @param map a PropertyMap to save the mappings to
 * @param templatePlan the TemplateBuildPlan to initialize its properties
 */
public void initializePropertiesAsVariables(final PropertyMap map,final BPELScopeActivity templatePlan){
  if (templatePlan.getRelationshipTemplate() != null) {
    this.initPropsAsVarsInRelationship(map,templatePlan);
  }
 else {
    this.initPropsAsVarsInNode(map,templatePlan);
  }
}","/** 
 * Initializes Properties inside the given PropertyMap of the given TemplateBuildPlan
 * @param map a PropertyMap to save the mappings to
 * @param templatePlan the TemplateBuildPlan to initialize its properties
 */
public void initializePropertiesAsVariables(final PropertyMap map,final BPELScopeActivity templatePlan){
  if (templatePlan.getRelationshipTemplate() != null) {
    initPropsAsVarsInRelationship(map,templatePlan);
  }
 else {
    initPropsAsVarsInNode(map,templatePlan);
  }
}"
41470,"@Override public void start(final BundleContext bundleContext) throws Exception {
  logger.info(""String_Node_Str"",bundleContext.getBundle().getSymbolicName(),bundleContext.getBundle().getVersion());
  context=bundleContext;
  this.services.add(bundleContext.registerService(RootController.class,new RootController(),null));
  configurator(bundleContext);
  this.services.add(bundleContext.registerService(ApplicationConfiguration.class,this,null));
  this.services.add(bundleContext.registerService(CorsFilter.class,new CorsFilter(),null));
  this.services.add(bundleContext.registerService(PlainTextMessageBodyWriter.class,new PlainTextMessageBodyWriter(),null));
  this.services.add(bundleContext.registerService(ObjectMapperProvider.class,new ObjectMapperProvider(),null));
  this.services.add(bundleContext.registerService(JacksonFeature.class,new JacksonFeature(),null));
  this.services.add(bundleContext.registerService(MultiPartFeature.class,new MultiPartFeature(),null));
  this.services.add(bundleContext.registerService(JAXBContextProvider.class,new JAXBContextProvider(),null));
}","@Override public void start(final BundleContext bundleContext) throws Exception {
  logger.info(""String_Node_Str"",bundleContext.getBundle().getSymbolicName(),bundleContext.getBundle().getVersion());
  context=bundleContext;
  this.services.add(bundleContext.registerService(RootController.class,new RootController(),null));
  configurator(bundleContext);
  this.services.add(bundleContext.registerService(ApplicationConfiguration.class,this,null));
  this.services.add(bundleContext.registerService(CorsFilter.class,new CorsFilter(),null));
  this.services.add(bundleContext.registerService(PlainTextMessageBodyWriter.class,new PlainTextMessageBodyWriter(),null));
  this.services.add(bundleContext.registerService(URI2XMLMessageBodyWriter.class,new URI2XMLMessageBodyWriter(),null));
  this.services.add(bundleContext.registerService(ObjectMapperProvider.class,new ObjectMapperProvider(),null));
  this.services.add(bundleContext.registerService(JacksonFeature.class,new JacksonFeature(),null));
  this.services.add(bundleContext.registerService(MultiPartFeature.class,new MultiPartFeature(),null));
  this.services.add(bundleContext.registerService(JAXBContextProvider.class,new JAXBContextProvider(),null));
}"
41471,"public Response invokePlan(final String plan,final UriInfo uriInfo,final List<TParameter> parameters,final CSARID csarId,final QName serviceTemplate,final Long serviceTemplateInstanceId,final PlanTypes... planTypes){
  if (parameters == null) {
    return Response.status(Status.BAD_REQUEST).build();
  }
  if (!hasPlan(csarId,planTypes,plan)) {
    logger.info(""String_Node_Str"" + plan + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + plan + ""String_Node_Str"");
  }
  logger.info(""String_Node_Str"",plan,serviceTemplate,csarId);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",JsonUtil.writeValueAsString(parameters));
  }
  if (serviceTemplateInstanceId != null) {
    String url=Settings.CONTAINER_INSTANCEDATA_API + serviceTemplateInstanceId;
    url=url.replace(""String_Node_Str"",csarId.getFileName());
    url=url.replace(""String_Node_Str"",UriComponent.encode(serviceTemplate.toString(),UriComponent.Type.PATH_SEGMENT));
    final URI uri=UriUtil.encode(URI.create(url));
    final TParameter param=new TParameter();
    param.setName(""String_Node_Str"");
    param.setRequired(TBoolean.fromValue(""String_Node_Str""));
    param.setType(""String_Node_Str"");
    param.setValue(uri.toString());
    parameters.add(param);
  }
  final TPlan p=getPlan(plan,csarId);
  final String correlationId=invokePlan(csarId,serviceTemplate,serviceTemplateInstanceId,p,parameters);
  final URI location=UriUtil.encode(uriInfo.getAbsolutePathBuilder().path(correlationId).build());
  return Response.created(location).build();
}","public Response invokePlan(final String plan,final UriInfo uriInfo,final List<TParameter> parameters,final CSARID csarId,final QName serviceTemplate,final Long serviceTemplateInstanceId,final PlanTypes... planTypes){
  if (parameters == null) {
    return Response.status(Status.BAD_REQUEST).build();
  }
  if (!hasPlan(csarId,planTypes,plan)) {
    logger.info(""String_Node_Str"" + plan + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + plan + ""String_Node_Str"");
  }
  logger.info(""String_Node_Str"",plan,serviceTemplate,csarId);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",JsonUtil.writeValueAsString(parameters));
  }
  if (serviceTemplateInstanceId != null) {
    String url=Settings.CONTAINER_INSTANCEDATA_API + ""String_Node_Str"" + serviceTemplateInstanceId;
    url=url.replace(""String_Node_Str"",csarId.getFileName());
    url=url.replace(""String_Node_Str"",UriComponent.encode(serviceTemplate.toString(),UriComponent.Type.PATH_SEGMENT));
    final URI uri=UriUtil.encode(URI.create(url));
    final TParameter param=new TParameter();
    param.setName(""String_Node_Str"");
    param.setRequired(TBoolean.fromValue(""String_Node_Str""));
    param.setType(""String_Node_Str"");
    param.setValue(uri.toString());
    parameters.add(param);
  }
  final TPlan p=getPlan(plan,csarId);
  final String correlationId=invokePlan(csarId,serviceTemplate,serviceTemplateInstanceId,p,parameters);
  final URI location=UriUtil.encode(uriInfo.getAbsolutePathBuilder().path(correlationId).build());
  return Response.created(location).build();
}"
41472,"@Path(""String_Node_Str"") public NodeTemplateInstanceController getInstances(@ApiParam(hidden=true) @PathParam(""String_Node_Str"") final String nodeTemplateId){
  if (!this.nodeTemplateService.hasNodeTemplate(csarId,serviceTemplateId,nodeTemplateId)) {
    logger.info(""String_Node_Str"" + nodeTemplateId + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + nodeTemplateId + ""String_Node_Str"");
  }
  NodeTemplateInstanceController child=new NodeTemplateInstanceController(instanceService);
  this.resourceContext.initResource(child);
  return child;
}","@Path(""String_Node_Str"") public NodeTemplateInstanceController getInstances(@ApiParam(hidden=true) @PathParam(""String_Node_Str"") final String nodeTemplateId){
  if (!this.nodeTemplateService.hasNodeTemplate(csarId,QName.valueOf(serviceTemplateId),QName.valueOf(nodeTemplateId))) {
    logger.info(""String_Node_Str"" + nodeTemplateId + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + nodeTemplateId + ""String_Node_Str"");
  }
  NodeTemplateInstanceController child=new NodeTemplateInstanceController(instanceService);
  this.resourceContext.initResource(child);
  return child;
}"
41473,"@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @ApiOperation(value=""String_Node_Str"",response=NodeTemplateDTO.class) public Response getNodeTemplate(@PathParam(""String_Node_Str"") final String nodeTemplateId) throws NotFoundException {
  final NodeTemplateDTO result=this.nodeTemplateService.getNodeTemplateById(csarId,serviceTemplateId,nodeTemplateId);
  result.add(UriUtils.generateSubResourceLink(uriInfo,""String_Node_Str"",false,""String_Node_Str""));
  result.add(UriUtils.generateSelfLink(uriInfo));
  return Response.ok(result).build();
}","@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @ApiOperation(value=""String_Node_Str"",response=NodeTemplateDTO.class) public Response getNodeTemplate(@PathParam(""String_Node_Str"") final String nodeTemplateId) throws NotFoundException {
  final NodeTemplateDTO result=this.nodeTemplateService.getNodeTemplateById(csarId,QName.valueOf(serviceTemplateId),QName.valueOf(nodeTemplateId));
  result.add(UriUtils.generateSubResourceLink(uriInfo,""String_Node_Str"",false,""String_Node_Str""));
  result.add(UriUtils.generateSelfLink(uriInfo));
  return Response.ok(result).build();
}"
41474,"public Collection<NodeTemplateInstance> getNodeTemplateInstances(final QName nodeTemplate){
  logger.debug(""String_Node_Str"",nodeTemplate);
  return this.nodeTemplateInstanceRepository.findByTemplateId(nodeTemplate);
}","public Collection<NodeTemplateInstance> getNodeTemplateInstances(final QName nodeTemplateQName){
  logger.debug(""String_Node_Str"",nodeTemplateQName);
  return this.nodeTemplateInstanceRepository.findByTemplateId(nodeTemplateQName);
}"
41475,"/** 
 * Gets the node template specified by its id
 * @param csarId The id of the CSAR
 * @param serviceTemplateId The id of the service template within the given CSAR
 * @param nodeTemplateId The id of the node template we want to get and that belongs to the specified service template
 * @return The node template specified by the given id
 * @throws NotFoundException If the service template does not contain the specified node template
 */
public NodeTemplateDTO getNodeTemplateById(String csarId,String serviceTemplateId,String nodeTemplateId) throws NotFoundException {
  final CSARContent csarContent=this.csarService.findById(csarId);
  final CSARID idOfCsar=csarContent.getCSARID();
  final QName serviceTemplateQName=QName.valueOf(serviceTemplateId);
  if (!this.toscaEngineService.getNodeTemplatesOfServiceTemplate(idOfCsar,serviceTemplateQName).contains(nodeTemplateId)) {
    logger.info(""String_Node_Str"" + nodeTemplateId + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + nodeTemplateId + ""String_Node_Str"");
  }
  return createNodeTemplate(idOfCsar,serviceTemplateQName,nodeTemplateId);
}","/** 
 * Gets the node template specified by its id
 * @param csarId The id of the CSAR
 * @param serviceTemplateQName The QName of the service template within the given CSAR
 * @param nodeTemplateQName The QName of the node template we want to get and that belongs to the specified service template
 * @return The node template specified by the given id
 * @throws NotFoundException If the service template does not contain the specified node template
 */
public NodeTemplateDTO getNodeTemplateById(String csarId,QName serviceTemplateQName,QName nodeTemplateQName) throws NotFoundException {
  final CSARContent csarContent=this.csarService.findById(csarId);
  final CSARID idOfCsar=csarContent.getCSARID();
  if (!this.toscaEngineService.getNodeTemplatesOfServiceTemplate(idOfCsar,serviceTemplateQName).contains(nodeTemplateQName.getLocalPart())) {
    logger.info(""String_Node_Str"" + nodeTemplateQName + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + nodeTemplateQName + ""String_Node_Str"");
  }
  return createNodeTemplate(idOfCsar,serviceTemplateQName,nodeTemplateQName);
}"
41476,"/** 
 * Gets a collection of node templates associated to a given service template.
 * @param csarId The id of the CSAR
 * @param serviceTemplateId The id of the service template within the given CSAR
 * @return A collection of node templates stored within the given servicetemplate.
 */
public List<NodeTemplateDTO> getNodeTemplatesOfServiceTemplate(String csarId,String serviceTemplateId){
  final CSARContent csarContent=this.csarService.findById(csarId);
  final List<String> nodeTemplateIds=toscaEngineService.getNodeTemplatesOfServiceTemplate(csarContent.getCSARID(),QName.valueOf(serviceTemplateId));
  final List<NodeTemplateDTO> nodeTemplates=Lists.newArrayList();
  NodeTemplateDTO currentNodeTemplate;
  for (  final String id : nodeTemplateIds) {
    currentNodeTemplate=createNodeTemplate(csarContent.getCSARID(),QName.valueOf(serviceTemplateId),id);
    nodeTemplates.add(currentNodeTemplate);
  }
  return nodeTemplates;
}","/** 
 * Gets a collection of node templates associated to a given service template.
 * @param csarId The id of the CSAR
 * @param serviceTemplateQName The QName of the service template within the given CSAR
 * @return A collection of node templates stored within the given servicetemplate.
 */
public List<NodeTemplateDTO> getNodeTemplatesOfServiceTemplate(String csarId,String serviceTemplateQName){
  final CSARContent csarContent=this.csarService.findById(csarId);
  final List<String> nodeTemplateIds=toscaEngineService.getNodeTemplatesOfServiceTemplate(csarContent.getCSARID(),QName.valueOf(serviceTemplateQName));
  final List<NodeTemplateDTO> nodeTemplates=Lists.newArrayList();
  NodeTemplateDTO currentNodeTemplate;
  for (  final String id : nodeTemplateIds) {
    currentNodeTemplate=createNodeTemplate(csarContent.getCSARID(),QName.valueOf(serviceTemplateQName),id);
    nodeTemplates.add(currentNodeTemplate);
  }
  return nodeTemplates;
}"
41477,"/** 
 * Checks whether the specified service template contains a given node template.
 * @param csarId The id of the CSAR
 * @param serviceTemplateId the id of the service template
 * @param nodeTemplateId the id of the node template to check for
 * @return <code>true</code> when the CSAR contains the service template and theservice template contains the node template, otherwise <code>false</code>
 */
public boolean hasNodeTemplate(String csarId,String serviceTemplateId,String nodeTemplateId){
  return this.getNodeTemplateIdsOfServiceTemplate(csarId,serviceTemplateId).contains(nodeTemplateId);
}","/** 
 * Checks whether the specified service template contains a given node template.
 * @param csarId The id of the CSAR
 * @param serviceTemplateQName the QName of the service template
 * @param nodeTemplateId the QName of the node template to check for
 * @return <code>true</code> when the CSAR contains the service template and theservice template contains the node template, otherwise <code>false</code>
 */
public boolean hasNodeTemplate(String csarId,QName serviceTemplateQName,QName nodeTemplateQName){
  return this.getNodeTemplateIdsOfServiceTemplate(csarId,serviceTemplateQName.toString()).contains(nodeTemplateQName.getLocalPart());
}"
41478,"private NodeTemplateDTO createNodeTemplate(CSARID csarId,QName serviceTemplateId,String nodeTemplateId){
  final NodeTemplateDTO currentNodeTemplate=new NodeTemplateDTO();
  currentNodeTemplate.setId(nodeTemplateId);
  currentNodeTemplate.setName(nodeTemplateId);
  currentNodeTemplate.setNodeType(this.toscaEngineService.getNodeTypeOfNodeTemplate(csarId,serviceTemplateId,nodeTemplateId).toString());
  return currentNodeTemplate;
}","/** 
 * Creates a new instance of the NodeTemplateDTO class. It fetches the qualified name of node type of the node template.
 * @param csarId
 * @param serviceTemplateQName
 * @param nodeTemplateQName
 * @return
 */
private NodeTemplateDTO createNodeTemplate(CSARID csarId,QName serviceTemplateQName,QName nodeTemplateQName){
  final NodeTemplateDTO currentNodeTemplate=new NodeTemplateDTO();
  currentNodeTemplate.setId(nodeTemplateQName.toString());
  currentNodeTemplate.setName(nodeTemplateQName.toString());
  currentNodeTemplate.setNodeType(this.toscaEngineService.getNodeTypeOfNodeTemplate(csarId,serviceTemplateQName,nodeTemplateQName.getLocalPart()).toString());
  return currentNodeTemplate;
}"
41479,"/** 
 * Gets a collection of node template ids associated to a given service template.
 * @param csarId The id of the CSAR
 * @param serviceTemplateId the id of the service template within the given CSAR
 * @return A collection of node template ids stored within the given servicetemplate.
 */
private List<String> getNodeTemplateIdsOfServiceTemplate(String csarId,String serviceTemplateId){
  final CSARContent csarContent=this.csarService.findById(csarId);
  return toscaEngineService.getNodeTemplatesOfServiceTemplate(csarContent.getCSARID(),QName.valueOf(serviceTemplateId));
}","/** 
 * Gets a collection of node template ids associated to a given service template.
 * @param csarId The id of the CSAR
 * @param serviceTemplateQName the QName of the service template within the given CSAR
 * @return A collection of node template ids stored within the given servicetemplate.
 */
private List<String> getNodeTemplateIdsOfServiceTemplate(String csarId,String serviceTemplateQName){
  final CSARContent csarContent=this.csarService.findById(csarId);
  return toscaEngineService.getNodeTemplatesOfServiceTemplate(csarContent.getCSARID(),QName.valueOf(serviceTemplateQName));
}"
41480,"@Override public void start(final BundleContext bundleContext) throws Exception {
  logger.info(""String_Node_Str"",bundleContext.getBundle().getSymbolicName(),bundleContext.getBundle().getVersion());
  context=bundleContext;
  this.services.add(bundleContext.registerService(RootController.class,new RootController(),null));
  this.configurator(bundleContext);
  this.configureSwagger(bundleContext);
  this.services.add(bundleContext.registerService(ApplicationConfiguration.class,this,null));
  this.services.add(bundleContext.registerService(CorsFilter.class,new CorsFilter(),null));
  this.services.add(bundleContext.registerService(PlainTextMessageBodyWriter.class,new PlainTextMessageBodyWriter(),null));
  this.services.add(bundleContext.registerService(ObjectMapperProvider.class,new ObjectMapperProvider(),null));
  this.services.add(bundleContext.registerService(JacksonFeature.class,new JacksonFeature(),null));
  this.services.add(bundleContext.registerService(MultiPartFeature.class,new MultiPartFeature(),null));
  this.services.add(bundleContext.registerService(JAXBContextProvider.class,new JAXBContextProvider(),null));
}","@Override public void start(final BundleContext bundleContext) throws Exception {
  logger.info(""String_Node_Str"",bundleContext.getBundle().getSymbolicName(),bundleContext.getBundle().getVersion());
  context=bundleContext;
  this.services.add(bundleContext.registerService(RootController.class,new RootController(),null));
  this.configurator(bundleContext);
  this.services.add(bundleContext.registerService(ApplicationConfiguration.class,this,null));
  this.services.add(bundleContext.registerService(CorsFilter.class,new CorsFilter(),null));
  this.services.add(bundleContext.registerService(PlainTextMessageBodyWriter.class,new PlainTextMessageBodyWriter(),null));
  this.services.add(bundleContext.registerService(ObjectMapperProvider.class,new ObjectMapperProvider(),null));
  this.services.add(bundleContext.registerService(JacksonFeature.class,new JacksonFeature(),null));
  this.services.add(bundleContext.registerService(MultiPartFeature.class,new MultiPartFeature(),null));
  this.services.add(bundleContext.registerService(JAXBContextProvider.class,new JAXBContextProvider(),null));
}"
41481,"@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @ApiOperation(value=""String_Node_Str"",response=PlanInstanceEventDTO.class,responseContainer=""String_Node_Str"") @ApiResponses(@ApiResponse(code=404,message=""String_Node_Str"")) public Response getBuildPlanInstanceLogs(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String instance,@Context final UriInfo uriInfo){
  return this.planService.getPlanInstanceLogs(plan,instance,uriInfo,csarId,serviceTemplate,serviceTemplateInstanceId,PLAN_TYPE);
}","@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @ApiOperation(value=""String_Node_Str"",response=PlanInstanceEventDTO.class,responseContainer=""String_Node_Str"") @ApiResponses(@ApiResponse(code=404,message=""String_Node_Str"")) public Response getBuildPlanInstanceLogs(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String instance,@Context final UriInfo uriInfo){
  return this.planService.getPlanInstanceLogs(plan,instance,uriInfo,csarId,serviceTemplate,null,PLAN_TYPE);
}"
41482,"@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @Produces({MediaType.APPLICATION_JSON,MediaType.TEXT_PLAIN}) @ApiOperation(value=""String_Node_Str"") @ApiResponses({@ApiResponse(code=400,message=""String_Node_Str""),@ApiResponse(code=200,message=""String_Node_Str"",response=URI.class)}) public Response invokeBuildPlan(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@Context final UriInfo uriInfo,@ApiParam(required=true,value=""String_Node_Str"") final List<TParameter> parameters){
  return this.planService.invokePlan(plan,uriInfo,parameters,csarId,serviceTemplate,serviceTemplateInstanceId,PLAN_TYPE);
}","@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @Produces({MediaType.APPLICATION_JSON,MediaType.TEXT_PLAIN}) @ApiOperation(value=""String_Node_Str"") @ApiResponses({@ApiResponse(code=400,message=""String_Node_Str""),@ApiResponse(code=200,message=""String_Node_Str"",response=URI.class)}) public Response invokeBuildPlan(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@Context final UriInfo uriInfo,@ApiParam(required=true,value=""String_Node_Str"") final List<TParameter> parameters){
  return this.planService.invokePlan(plan,uriInfo,parameters,csarId,serviceTemplate,-1L,PLAN_TYPE);
}"
41483,"@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @ApiOperation(value=""String_Node_Str"",response=PlanInstanceDTO.class,responseContainer=""String_Node_Str"") @ApiResponses(@ApiResponse(code=404,message=""String_Node_Str"")) public Response getBuildPlanInstance(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String instance,@Context final UriInfo uriInfo){
  return this.planService.getPlanInstance(plan,instance,uriInfo,csarId,serviceTemplate,serviceTemplateInstanceId,PLAN_TYPE);
}","@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @ApiOperation(value=""String_Node_Str"",response=PlanInstanceDTO.class,responseContainer=""String_Node_Str"") @ApiResponses(@ApiResponse(code=404,message=""String_Node_Str"")) public Response getBuildPlanInstance(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String instance,@Context final UriInfo uriInfo){
  return this.planService.getPlanInstance(plan,instance,uriInfo,csarId,serviceTemplate,null,PLAN_TYPE);
}"
41484,"@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @ApiOperation(value=""String_Node_Str"",response=PlanInstanceDTO.class,responseContainer=""String_Node_Str"") public Response getBuildPlanInstances(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@Context final UriInfo uriInfo){
  return this.planService.getPlanInstances(plan,uriInfo,csarId,serviceTemplate,serviceTemplateInstanceId,PLAN_TYPE);
}","@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @ApiOperation(value=""String_Node_Str"",response=PlanInstanceDTO.class,responseContainer=""String_Node_Str"") public Response getBuildPlanInstances(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@Context final UriInfo uriInfo){
  return this.planService.getPlanInstances(plan,uriInfo,csarId,serviceTemplate,null,PLAN_TYPE);
}"
41485,"@PUT @Path(""String_Node_Str"") @Consumes({MediaType.TEXT_PLAIN}) @ApiOperation(value=""String_Node_Str"") @ApiResponses({@ApiResponse(code=404,message=""String_Node_Str""),@ApiResponse(code=400,message=""String_Node_Str""),@ApiResponse(code=200,message=""String_Node_Str"")}) public Response changeBuildPlanInstanceState(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String instance,@Context final UriInfo uriInfo,@ApiParam(required=true,value=""String_Node_Str"") String request){
  return this.planService.changePlanInstanceState(request,plan,instance,uriInfo,csarId,serviceTemplate,serviceTemplateInstanceId,PLAN_TYPE);
}","@PUT @Path(""String_Node_Str"") @Consumes({MediaType.TEXT_PLAIN}) @ApiOperation(value=""String_Node_Str"") @ApiResponses({@ApiResponse(code=404,message=""String_Node_Str""),@ApiResponse(code=400,message=""String_Node_Str""),@ApiResponse(code=200,message=""String_Node_Str"")}) public Response changeBuildPlanInstanceState(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String instance,@Context final UriInfo uriInfo,@ApiParam(required=true,value=""String_Node_Str"") String request){
  return this.planService.changePlanInstanceState(request,plan,instance,uriInfo,csarId,serviceTemplate,null,PLAN_TYPE);
}"
41486,"public BuildPlanController(final CSARID csarId,final QName serviceTemplate,final Long serviceTemplateInstanceId,final PlanService planService){
  this.csarId=csarId;
  this.serviceTemplate=serviceTemplate;
  this.serviceTemplateInstanceId=serviceTemplateInstanceId;
  this.planService=planService;
}","public BuildPlanController(final CSARID csarId,final QName serviceTemplate,final PlanService planService){
  this.csarId=csarId;
  this.serviceTemplate=serviceTemplate;
  this.planService=planService;
}"
41487,"@GET @Path(""String_Node_Str"") @Produces({MediaType.TEXT_PLAIN}) @ApiOperation(value=""String_Node_Str"",response=String.class) @ApiResponses(@ApiResponse(code=404,message=""String_Node_Str"")) public Response getBuildPlanInstanceState(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String instance,@Context final UriInfo uriInfo){
  return this.planService.getPlanInstanceState(plan,instance,uriInfo,csarId,serviceTemplate,serviceTemplateInstanceId,PLAN_TYPE);
}","@GET @Path(""String_Node_Str"") @Produces({MediaType.TEXT_PLAIN}) @ApiOperation(value=""String_Node_Str"",response=String.class) @ApiResponses(@ApiResponse(code=404,message=""String_Node_Str"")) public Response getBuildPlanInstanceState(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String instance,@Context final UriInfo uriInfo){
  return this.planService.getPlanInstanceState(plan,instance,uriInfo,csarId,serviceTemplate,null,PLAN_TYPE);
}"
41488,"@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @ApiOperation(value=""String_Node_Str"") @ApiResponses({@ApiResponse(code=400,message=""String_Node_Str""),@ApiResponse(code=404,message=""String_Node_Str""),@ApiResponse(code=200,message=""String_Node_Str"",response=URI.class)}) public Response addBuildPlanLogEntry(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String instance,@Context final UriInfo uriInfo,@ApiParam(required=true,value=""String_Node_Str"") final CreatePlanInstanceLogEntryRequest logEntry){
  return this.planService.addLogToPlanInstance(logEntry,plan,instance,uriInfo,csarId,serviceTemplate,serviceTemplateInstanceId,PLAN_TYPE);
}","@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @ApiOperation(value=""String_Node_Str"") @ApiResponses({@ApiResponse(code=400,message=""String_Node_Str""),@ApiResponse(code=404,message=""String_Node_Str""),@ApiResponse(code=200,message=""String_Node_Str"",response=URI.class)}) public Response addBuildPlanLogEntry(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String plan,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String instance,@Context final UriInfo uriInfo,@ApiParam(required=true,value=""String_Node_Str"") final CreatePlanInstanceLogEntryRequest logEntry){
  return this.planService.addLogToPlanInstance(logEntry,plan,instance,uriInfo,csarId,serviceTemplate,null,PLAN_TYPE);
}"
41489,"@Path(""String_Node_Str"") public BuildPlanController getBuildPlans(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String csar,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String serviceTemplateId){
  final CSARID csarId=this.serviceTemplateService.checkServiceTemplateExistence(csar,serviceTemplateId);
  return new BuildPlanController(csarId,QName.valueOf(serviceTemplateId),null,this.planService);
}","@Path(""String_Node_Str"") public BuildPlanController getBuildPlans(@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String csar,@ApiParam(""String_Node_Str"") @PathParam(""String_Node_Str"") final String serviceTemplateId){
  final CSARID csarId=this.serviceTemplateService.checkServiceTemplateExistence(csar,serviceTemplateId);
  return new BuildPlanController(csarId,QName.valueOf(serviceTemplateId),this.planService);
}"
41490,"public Response invokePlan(final String plan,final UriInfo uriInfo,final List<TParameter> parameters,final CSARID csarId,final QName serviceTemplate,final Long serviceTemplateInstanceId,final PlanTypes... planTypes){
  if (parameters == null) {
    return Response.status(Status.BAD_REQUEST).build();
  }
  if (!hasPlan(csarId,planTypes,plan)) {
    logger.info(""String_Node_Str"" + plan + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + plan + ""String_Node_Str"");
  }
  logger.info(""String_Node_Str"",plan,serviceTemplate,csarId);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",JsonUtil.writeValueAsString(parameters));
  }
  if (serviceTemplateInstanceId != null) {
    String url=Settings.CONTAINER_INSTANCEDATA_API + serviceTemplateInstanceId;
    url=url.replace(""String_Node_Str"",csarId.getFileName());
    url=url.replace(""String_Node_Str"",UriComponent.encode(serviceTemplate.toString(),UriComponent.Type.PATH_SEGMENT));
    final URI uri=UriUtil.encode(URI.create(url));
    final TParameter param=new TParameter();
    param.setName(""String_Node_Str"");
    param.setRequired(TBoolean.fromValue(""String_Node_Str""));
    param.setType(""String_Node_Str"");
    param.setValue(uri.toString());
    parameters.add(param);
  }
  final TPlan p=getPlan(plan,csarId);
  final String correlationId=invokePlan(csarId,serviceTemplate,p,parameters);
  final URI location=UriUtil.encode(uriInfo.getAbsolutePathBuilder().path(correlationId).build());
  return Response.created(location).build();
}","public Response invokePlan(final String plan,final UriInfo uriInfo,final List<TParameter> parameters,final CSARID csarId,final QName serviceTemplate,final Long serviceTemplateInstanceId,final PlanTypes... planTypes){
  if (parameters == null) {
    return Response.status(Status.BAD_REQUEST).build();
  }
  if (!hasPlan(csarId,planTypes,plan)) {
    logger.info(""String_Node_Str"" + plan + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + plan + ""String_Node_Str"");
  }
  logger.info(""String_Node_Str"",plan,serviceTemplate,csarId);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",JsonUtil.writeValueAsString(parameters));
  }
  if (serviceTemplateInstanceId != null) {
    String url=Settings.CONTAINER_INSTANCEDATA_API + serviceTemplateInstanceId;
    url=url.replace(""String_Node_Str"",csarId.getFileName());
    url=url.replace(""String_Node_Str"",UriComponent.encode(serviceTemplate.toString(),UriComponent.Type.PATH_SEGMENT));
    final URI uri=UriUtil.encode(URI.create(url));
    final TParameter param=new TParameter();
    param.setName(""String_Node_Str"");
    param.setRequired(TBoolean.fromValue(""String_Node_Str""));
    param.setType(""String_Node_Str"");
    param.setValue(uri.toString());
    parameters.add(param);
  }
  final TPlan p=getPlan(plan,csarId);
  final String correlationId=invokePlan(csarId,serviceTemplate,serviceTemplateInstanceId,p,parameters);
  final URI location=UriUtil.encode(uriInfo.getAbsolutePathBuilder().path(correlationId).build());
  return Response.created(location).build();
}"
41491,"/** 
 */
public Response getPlanInstances(final String plan,final UriInfo uriInfo,final CSARID csarId,final QName serviceTemplate,final Long serviceTemplateInstanceId,final PlanTypes... planTypes){
  if (!hasPlan(csarId,planTypes,plan)) {
    logger.info(""String_Node_Str"" + plan + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + plan + ""String_Node_Str"");
  }
  ServiceTemplateInstanceRepository repo=new ServiceTemplateInstanceRepository();
  final Collection<ServiceTemplateInstance> serviceInstances;
  if (serviceTemplateInstanceId != null) {
    serviceInstances=Lists.newArrayList();
    serviceInstances.add(repo.find(serviceTemplateInstanceId).get());
  }
 else {
    serviceInstances=repo.findByCsarId(csarId);
  }
  final List<PlanInstanceDTO> planInstances=Lists.newArrayList();
  for (  ServiceTemplateInstance sti : serviceInstances) {
    List<PlanInstanceDTO> foo=sti.getPlanInstances().stream().filter(p -> Arrays.asList(planTypes).contains(PlanTypes.isPlanTypeURI(p.getType().toString()))).map(p -> PlanInstanceDTO.Converter.convert(p)).collect(Collectors.toList());
    planInstances.addAll(foo);
  }
  for (  final PlanInstanceDTO pi : planInstances) {
    final Long id=pi.getServiceTemplateInstanceId();
    if (id != null) {
      final URI uri=uriInfo.getBaseUriBuilder().path(""String_Node_Str"").build(csarId.toString(),serviceTemplate.toString(),String.valueOf(id));
      pi.add(Link.fromUri(UriUtil.encode(uri)).rel(""String_Node_Str"").build());
    }
    pi.add(UriUtil.generateSubResourceLink(uriInfo,pi.getCorrelationId(),true,""String_Node_Str""));
  }
  final PlanInstanceListDTO list=new PlanInstanceListDTO();
  list.add(planInstances);
  list.add(UriUtil.generateSelfLink(uriInfo));
  return Response.ok(list).build();
}","/** 
 */
public Response getPlanInstances(final String plan,final UriInfo uriInfo,final CSARID csarId,final QName serviceTemplate,final Long serviceTemplateInstanceId,final PlanTypes... planTypes){
  if (!hasPlan(csarId,planTypes,plan)) {
    logger.info(""String_Node_Str"" + plan + ""String_Node_Str"");
    throw new NotFoundException(""String_Node_Str"" + plan + ""String_Node_Str"");
  }
  ServiceTemplateInstanceRepository repo=new ServiceTemplateInstanceRepository();
  final Collection<ServiceTemplateInstance> serviceInstances;
  if (serviceTemplateInstanceId != null) {
    serviceInstances=Lists.newArrayList();
    serviceInstances.add(repo.find(serviceTemplateInstanceId).get());
  }
 else {
    serviceInstances=repo.findByCsarId(csarId);
  }
  final List<PlanInstanceDTO> planInstances=Lists.newArrayList();
  for (  ServiceTemplateInstance sti : serviceInstances) {
    List<PlanInstanceDTO> foo=sti.getPlanInstances().stream().filter(p -> {
      PlanTypes currType=PlanTypes.isPlanTypeURI(p.getType().toString());
      return Arrays.asList(planTypes).contains(currType);
    }
).map(p -> PlanInstanceDTO.Converter.convert(p)).collect(Collectors.toList());
    planInstances.addAll(foo);
  }
  for (  final PlanInstanceDTO pi : planInstances) {
    final Long id=pi.getServiceTemplateInstanceId();
    if (id != null) {
      final URI uri=uriInfo.getBaseUriBuilder().path(""String_Node_Str"").build(csarId.toString(),serviceTemplate.toString(),String.valueOf(id));
      pi.add(Link.fromUri(UriUtil.encode(uri)).rel(""String_Node_Str"").build());
    }
    pi.add(UriUtil.generateSubResourceLink(uriInfo,pi.getCorrelationId(),true,""String_Node_Str""));
  }
  final PlanInstanceListDTO list=new PlanInstanceListDTO();
  list.add(planInstances);
  list.add(UriUtil.generateSelfLink(uriInfo));
  return Response.ok(list).build();
}"
41492,"/** 
 * Invokes the a process described due the parameter PublicPlan for the given CSAR.
 * @param csarID the ID of the CSAR
 * @param csarInstanceID the instance id, or -1 if the plan is a build plan
 * @param plan which containes the data which with the process is invoked(including the message values).
 * @return
 * @throws UnsupportedEncodingException
 */
public String invokePlanInvocation(CSARID csarID,QName serviceTemplateId,int csarInstanceID,TPlanDTO plan) throws UnsupportedEncodingException ;","/** 
 * Invokes the a process described due the parameter PublicPlan for the given CSAR.
 * @param csarID the ID of the CSAR
 * @param serviceTemplateInstanceID the instance id, or -1 if the plan is a build plan
 * @param plan which containes the data which with the process is invoked(including the message values).
 * @return
 * @throws UnsupportedEncodingException
 */
public String invokePlanInvocation(CSARID csarID,QName serviceTemplateId,long serviceTemplateInstanceID,TPlanDTO plan) throws UnsupportedEncodingException ;"
41493,"/** 
 * {@inheritDoc}
 * @throws UnsupportedEncodingException
 */
@Override public String invokePlanInvocation(final CSARID csarID,final QName serviceTemplateId,final int csarInstanceID,final TPlanDTO plan) throws UnsupportedEncodingException {
  this.LOG.info(""String_Node_Str"");
  final String correlationID=OpenToscaControlServiceImpl.planInvocationEngine.invokePlan(csarID,serviceTemplateId,csarInstanceID,plan);
  if (null != correlationID) {
    this.LOG.info(""String_Node_Str"");
  }
 else {
    this.LOG.error(""String_Node_Str"");
  }
  return correlationID;
}","/** 
 * {@inheritDoc}
 * @throws UnsupportedEncodingException
 */
@Override public String invokePlanInvocation(final CSARID csarID,final QName serviceTemplateId,final long csarInstanceID,final TPlanDTO plan) throws UnsupportedEncodingException {
  this.LOG.info(""String_Node_Str"");
  final String correlationID=OpenToscaControlServiceImpl.planInvocationEngine.invokePlan(csarID,serviceTemplateId,csarInstanceID,plan);
  if (null != correlationID) {
    this.LOG.info(""String_Node_Str"");
  }
 else {
    this.LOG.error(""String_Node_Str"");
  }
  return correlationID;
}"
41494,"/** 
 * {@inheritDoc}
 * @throws UnsupportedEncodingException
 */
@Override public String invokePlan(final CSARID csarID,final QName serviceTemplateId,int serviceTemplateInstanceID,final TPlanDTO givenPlan) throws UnsupportedEncodingException {
  final TPlan storedPlan=ServiceProxy.toscaReferenceMapper.getPlanForCSARIDAndPlanID(csarID,givenPlan.getId());
  if ((null == storedPlan)) {
    this.LOG.error(""String_Node_Str"" + givenPlan.getId() + ""String_Node_Str""+ givenPlan.getName()+ ""String_Node_Str"");
    return null;
  }
  if (!storedPlan.getId().equals(givenPlan.getId().getLocalPart())) {
    this.LOG.error(""String_Node_Str"" + givenPlan.getId() + ""String_Node_Str""+ givenPlan.getName()+ ""String_Node_Str""+ storedPlan.getId()+ ""String_Node_Str"");
    return null;
  }
  givenPlan.setName(storedPlan.getName());
  givenPlan.setPlanLanguage(storedPlan.getPlanLanguage());
  givenPlan.setPlanType(storedPlan.getPlanType());
  givenPlan.setOutputParameters(storedPlan.getOutputParameters());
  final PlanInvocationEvent planEvent=new PlanInvocationEvent();
  this.LOG.info(""String_Node_Str"" + givenPlan.getId() + ""String_Node_Str""+ givenPlan.getPlanType()+ ""String_Node_Str""+ csarID+ ""String_Node_Str"");
  final Map<QName,TPlan> publicPlanMap=ServiceProxy.toscaReferenceMapper.getCSARIDToPlans(csarID).get(PlanTypes.isPlanTypeURI(givenPlan.getPlanType()));
  if (null == publicPlanMap) {
    this.LOG.error(""String_Node_Str"" + givenPlan.getPlanType() + ""String_Node_Str"");
    return null;
  }
  planEvent.setCSARID(csarID.toString());
  planEvent.setInputMessageID(ServiceProxy.toscaReferenceMapper.getPlanInputMessageID(csarID,givenPlan.getId()));
  planEvent.setInterfaceName(ServiceProxy.toscaReferenceMapper.getIntferaceNameOfPlan(csarID,givenPlan.getId()));
  planEvent.setOperationName(ServiceProxy.toscaReferenceMapper.getOperationNameOfPlan(csarID,givenPlan.getId()));
  planEvent.setPlanLanguage(storedPlan.getPlanLanguage());
  planEvent.setPlanType(storedPlan.getPlanType());
  planEvent.setPlanID(givenPlan.getId());
  planEvent.setIsActive(true);
  planEvent.setHasFailed(false);
  for (  final TParameter temp : storedPlan.getInputParameters().getInputParameter()) {
    boolean found=false;
    this.LOG.trace(""String_Node_Str"",temp.getName());
    final List<TParameterDTO> params=givenPlan.getInputParameters().getInputParameter();
    for (    final TParameterDTO param : params) {
      if (param.getName().equals(temp.getName())) {
        final TParameterDTO dto=param;
        found=true;
        planEvent.getInputParameter().add(dto);
        String value=dto.getValue();
        if (value == null) {
          value=""String_Node_Str"";
        }
        value=value.replace(""String_Node_Str"",""String_Node_Str"");
        value=value.replace(""String_Node_Str"",""String_Node_Str"");
        value=value.replace(""String_Node_Str"",""String_Node_Str"");
        dto.setValue(value);
        this.LOG.trace(""String_Node_Str"",param.getName(),param.getValue());
      }
    }
    if (!found) {
      this.LOG.trace(""String_Node_Str"",temp.getName());
      final TParameterDTO newParam=new TParameterDTO();
      newParam.setName(temp.getName());
      newParam.setType(temp.getType());
      newParam.setRequired(temp.getRequired());
      planEvent.getInputParameter().add(newParam);
    }
  }
  for (  final TParameter temp : storedPlan.getOutputParameters().getOutputParameter()) {
    final TParameterDTO param=new TParameterDTO();
    param.setName(temp.getName());
    param.setRequired(temp.getRequired());
    param.setType(temp.getType());
    planEvent.getOutputParameter().add(param);
  }
  String correlationID;
  if (serviceTemplateInstanceID == -1) {
    serviceTemplateInstanceID=1000 + (int)(Math.random() * (Integer.MAX_VALUE - 1000));
    correlationID=ServiceProxy.correlationHandler.getNewCorrelationID(csarID,serviceTemplateId,serviceTemplateInstanceID,planEvent,true);
  }
 else {
    correlationID=ServiceProxy.correlationHandler.getNewCorrelationID(csarID,serviceTemplateId,serviceTemplateInstanceID,planEvent,false);
  }
  ServiceTemplateInstanceID instanceID;
  if (PlanTypes.isPlanTypeURI(planEvent.getPlanType()).equals(PlanTypes.BUILD)) {
    instanceID=ServiceProxy.csarInstanceManagement.createNewInstance(csarID,serviceTemplateId);
    planEvent.setCSARInstanceID(instanceID.getInstanceID());
  }
 else {
    instanceID=new ServiceTemplateInstanceID(csarID,serviceTemplateId,serviceTemplateInstanceID);
  }
  ServiceProxy.csarInstanceManagement.correlateCSARInstanceWithPlanInstance(instanceID,correlationID);
  ServiceProxy.csarInstanceManagement.setCorrelationAsActive(csarID,correlationID);
  ServiceProxy.csarInstanceManagement.correlateCorrelationIdToPlan(correlationID,planEvent);
  final Map<String,Object> eventValues=new Hashtable<>();
  eventValues.put(""String_Node_Str"",csarID);
  eventValues.put(""String_Node_Str"",planEvent.getPlanID());
  eventValues.put(""String_Node_Str"",planEvent.getPlanLanguage());
  eventValues.put(""String_Node_Str"",planEvent.getOperationName());
  this.LOG.debug(""String_Node_Str"",givenPlan.getId());
  final Map<String,String> message=this.createRequest(csarID,serviceTemplateId,ServiceProxy.toscaReferenceMapper.getPlanInputMessageID(csarID,givenPlan.getId()),planEvent.getInputParameter(),correlationID);
  if (null == message) {
    this.LOG.error(""String_Node_Str"",givenPlan.getId(),givenPlan.getPlanLanguage());
    return null;
  }
  final StringBuilder builder=new StringBuilder(""String_Node_Str"");
  for (  final String key : message.keySet()) {
    builder.append(""String_Node_Str"" + key + ""String_Node_Str""+ message.get(key)+ ""String_Node_Str"");
  }
  this.LOG.trace(builder.toString());
  eventValues.put(""String_Node_Str"",message);
  if (null == ServiceProxy.toscaReferenceMapper.isPlanAsynchronous(csarID,givenPlan.getId())) {
    this.LOG.warn(""String_Node_Str"");
    eventValues.put(""String_Node_Str"",true);
  }
 else   if (ServiceProxy.toscaReferenceMapper.isPlanAsynchronous(csarID,givenPlan.getId())) {
    eventValues.put(""String_Node_Str"",true);
  }
 else {
    eventValues.put(""String_Node_Str"",false);
  }
  eventValues.put(""String_Node_Str"",correlationID);
  ServiceProxy.csarInstanceManagement.storePublicPlanToHistory(correlationID,planEvent);
  PlanInstanceRepository repository=new PlanInstanceRepository();
  PlanInstance pi=new PlanInstance();
  pi.setCorrelationId(correlationID);
  LOG.debug(""String_Node_Str"",storedPlan.getPlanLanguage());
  pi.setLanguage(PlanLanguage.fromString(storedPlan.getPlanLanguage()));
  LOG.debug(""String_Node_Str"",storedPlan.getPlanType());
  pi.setType(PlanType.fromString(storedPlan.getPlanType()));
  pi.setState(PlanInstanceState.RUNNING);
  pi.setTemplateId(givenPlan.getId());
  stiRepo.find(Long.valueOf(serviceTemplateInstanceID)).ifPresent(serviceTemplateInstance -> pi.setServiceTemplateInstance(serviceTemplateInstance));
  planEvent.getInputParameter().stream().forEach(p -> {
    new PlanInstanceInput(p.getName(),p.getValue(),p.getType()).setPlanInstance(pi);
  }
);
  repository.add(pi);
  final Event event=new Event(""String_Node_Str"",eventValues);
  this.LOG.debug(""String_Node_Str"",correlationID);
  ServiceProxy.eventAdmin.sendEvent(event);
  return correlationID;
}","/** 
 * {@inheritDoc}
 * @throws UnsupportedEncodingException
 */
@Override public String invokePlan(final CSARID csarID,final QName serviceTemplateId,long serviceTemplateInstanceID,final TPlanDTO givenPlan) throws UnsupportedEncodingException {
  final TPlan storedPlan=ServiceProxy.toscaReferenceMapper.getPlanForCSARIDAndPlanID(csarID,givenPlan.getId());
  if ((null == storedPlan)) {
    this.LOG.error(""String_Node_Str"" + givenPlan.getId() + ""String_Node_Str""+ givenPlan.getName()+ ""String_Node_Str"");
    return null;
  }
  if (!storedPlan.getId().equals(givenPlan.getId().getLocalPart())) {
    this.LOG.error(""String_Node_Str"" + givenPlan.getId() + ""String_Node_Str""+ givenPlan.getName()+ ""String_Node_Str""+ storedPlan.getId()+ ""String_Node_Str"");
    return null;
  }
  givenPlan.setName(storedPlan.getName());
  givenPlan.setPlanLanguage(storedPlan.getPlanLanguage());
  givenPlan.setPlanType(storedPlan.getPlanType());
  givenPlan.setOutputParameters(storedPlan.getOutputParameters());
  final PlanInvocationEvent planEvent=new PlanInvocationEvent();
  this.LOG.info(""String_Node_Str"" + givenPlan.getId() + ""String_Node_Str""+ givenPlan.getPlanType()+ ""String_Node_Str""+ csarID+ ""String_Node_Str"");
  final Map<QName,TPlan> publicPlanMap=ServiceProxy.toscaReferenceMapper.getCSARIDToPlans(csarID).get(PlanTypes.isPlanTypeURI(givenPlan.getPlanType()));
  if (null == publicPlanMap) {
    this.LOG.error(""String_Node_Str"" + givenPlan.getPlanType() + ""String_Node_Str"");
    return null;
  }
  planEvent.setCSARID(csarID.toString());
  planEvent.setInputMessageID(ServiceProxy.toscaReferenceMapper.getPlanInputMessageID(csarID,givenPlan.getId()));
  planEvent.setInterfaceName(ServiceProxy.toscaReferenceMapper.getIntferaceNameOfPlan(csarID,givenPlan.getId()));
  planEvent.setOperationName(ServiceProxy.toscaReferenceMapper.getOperationNameOfPlan(csarID,givenPlan.getId()));
  planEvent.setPlanLanguage(storedPlan.getPlanLanguage());
  planEvent.setPlanType(storedPlan.getPlanType());
  planEvent.setPlanID(givenPlan.getId());
  planEvent.setIsActive(true);
  planEvent.setHasFailed(false);
  for (  final TParameter temp : storedPlan.getInputParameters().getInputParameter()) {
    boolean found=false;
    this.LOG.trace(""String_Node_Str"",temp.getName());
    final List<TParameterDTO> params=givenPlan.getInputParameters().getInputParameter();
    for (    final TParameterDTO param : params) {
      if (param.getName().equals(temp.getName())) {
        final TParameterDTO dto=param;
        found=true;
        planEvent.getInputParameter().add(dto);
        String value=dto.getValue();
        if (value == null) {
          value=""String_Node_Str"";
        }
        value=value.replace(""String_Node_Str"",""String_Node_Str"");
        value=value.replace(""String_Node_Str"",""String_Node_Str"");
        value=value.replace(""String_Node_Str"",""String_Node_Str"");
        dto.setValue(value);
        this.LOG.trace(""String_Node_Str"",param.getName(),param.getValue());
      }
    }
    if (!found) {
      this.LOG.trace(""String_Node_Str"",temp.getName());
      final TParameterDTO newParam=new TParameterDTO();
      newParam.setName(temp.getName());
      newParam.setType(temp.getType());
      newParam.setRequired(temp.getRequired());
      planEvent.getInputParameter().add(newParam);
    }
  }
  for (  final TParameter temp : storedPlan.getOutputParameters().getOutputParameter()) {
    final TParameterDTO param=new TParameterDTO();
    param.setName(temp.getName());
    param.setRequired(temp.getRequired());
    param.setType(temp.getType());
    planEvent.getOutputParameter().add(param);
  }
  String correlationID;
  if (serviceTemplateInstanceID == -1) {
    serviceTemplateInstanceID=1000 + (int)(Math.random() * (Integer.MAX_VALUE - 1000));
    correlationID=ServiceProxy.correlationHandler.getNewCorrelationID(csarID,serviceTemplateId,(int)serviceTemplateInstanceID,planEvent,true);
  }
 else {
    correlationID=ServiceProxy.correlationHandler.getNewCorrelationID(csarID,serviceTemplateId,(int)serviceTemplateInstanceID,planEvent,false);
  }
  ServiceTemplateInstanceID instanceID;
  if (PlanTypes.isPlanTypeURI(planEvent.getPlanType()).equals(PlanTypes.BUILD)) {
    instanceID=ServiceProxy.csarInstanceManagement.createNewInstance(csarID,serviceTemplateId);
    planEvent.setCSARInstanceID(instanceID.getInstanceID());
  }
 else {
    instanceID=new ServiceTemplateInstanceID(csarID,serviceTemplateId,(int)serviceTemplateInstanceID);
  }
  ServiceProxy.csarInstanceManagement.correlateCSARInstanceWithPlanInstance(instanceID,correlationID);
  ServiceProxy.csarInstanceManagement.setCorrelationAsActive(csarID,correlationID);
  ServiceProxy.csarInstanceManagement.correlateCorrelationIdToPlan(correlationID,planEvent);
  final Map<String,Object> eventValues=new Hashtable<>();
  eventValues.put(""String_Node_Str"",csarID);
  eventValues.put(""String_Node_Str"",planEvent.getPlanID());
  eventValues.put(""String_Node_Str"",planEvent.getPlanLanguage());
  eventValues.put(""String_Node_Str"",planEvent.getOperationName());
  this.LOG.debug(""String_Node_Str"",givenPlan.getId());
  final Map<String,String> message=this.createRequest(csarID,serviceTemplateId,ServiceProxy.toscaReferenceMapper.getPlanInputMessageID(csarID,givenPlan.getId()),planEvent.getInputParameter(),correlationID);
  if (null == message) {
    this.LOG.error(""String_Node_Str"",givenPlan.getId(),givenPlan.getPlanLanguage());
    return null;
  }
  final StringBuilder builder=new StringBuilder(""String_Node_Str"");
  for (  final String key : message.keySet()) {
    builder.append(""String_Node_Str"" + key + ""String_Node_Str""+ message.get(key)+ ""String_Node_Str"");
  }
  this.LOG.trace(builder.toString());
  eventValues.put(""String_Node_Str"",message);
  if (null == ServiceProxy.toscaReferenceMapper.isPlanAsynchronous(csarID,givenPlan.getId())) {
    this.LOG.warn(""String_Node_Str"");
    eventValues.put(""String_Node_Str"",true);
  }
 else   if (ServiceProxy.toscaReferenceMapper.isPlanAsynchronous(csarID,givenPlan.getId())) {
    eventValues.put(""String_Node_Str"",true);
  }
 else {
    eventValues.put(""String_Node_Str"",false);
  }
  eventValues.put(""String_Node_Str"",correlationID);
  ServiceProxy.csarInstanceManagement.storePublicPlanToHistory(correlationID,planEvent);
  PlanInstanceRepository repository=new PlanInstanceRepository();
  PlanInstance pi=new PlanInstance();
  pi.setCorrelationId(correlationID);
  LOG.debug(""String_Node_Str"",storedPlan.getPlanLanguage());
  pi.setLanguage(PlanLanguage.fromString(storedPlan.getPlanLanguage()));
  LOG.debug(""String_Node_Str"",storedPlan.getPlanType());
  pi.setType(PlanType.fromString(storedPlan.getPlanType()));
  pi.setState(PlanInstanceState.RUNNING);
  pi.setTemplateId(givenPlan.getId());
  stiRepo.find(serviceTemplateInstanceID).ifPresent(serviceTemplateInstance -> pi.setServiceTemplateInstance(serviceTemplateInstance));
  planEvent.getInputParameter().stream().forEach(p -> {
    new PlanInstanceInput(p.getName(),p.getValue(),p.getType()).setPlanInstance(pi);
  }
);
  repository.add(pi);
  final Event event=new Event(""String_Node_Str"",eventValues);
  this.LOG.debug(""String_Node_Str"",correlationID);
  ServiceProxy.eventAdmin.sendEvent(event);
  return correlationID;
}"
41495,"/** 
 * Invoke a PublicPlan for a CSAR. If this PublicPlan is of Type OTHERMANAGEMENT or TERMINATION, the information about the CSARInstance is stored inside the PublicPlan.
 * @param csarID
 * @param instance ID of a CSAR instance
 * @param publicPlan
 * @return boolean about success
 * @throws UnsupportedEncodingException
 */
public String invokePlan(CSARID csarID,QName serviceTemplateId,int csarInstanceID,TPlanDTO plan) throws UnsupportedEncodingException ;","/** 
 * Invoke a PublicPlan for a CSAR. If this PublicPlan is of Type OTHERMANAGEMENT or TERMINATION, the information about the CSARInstance is stored inside the PublicPlan.
 * @param csarID
 * @param instance ID of a CSAR instance
 * @param publicPlan
 * @return boolean about success
 * @throws UnsupportedEncodingException
 */
public String invokePlan(CSARID csarID,QName serviceTemplateId,long serviceTemplateInstanceID,TPlanDTO plan) throws UnsupportedEncodingException ;"
41496,"@Override public void start(BundleContext bundleContext) throws Exception {
  Activator.context=bundleContext;
  this.plugin=new Plugin();
  this.registration=Activator.context.registerService(IPlanBuilderPostPhasePlugin.class.getName(),this.plugin,null);
  this.registration2=Activator.context.registerService(IPlanBuilderPolicyAwarePrePhasePlugin.class.getName(),this.plugin,null);
}","@Override public void start(BundleContext bundleContext) throws Exception {
  Activator.context=bundleContext;
  this.plugin=new BPELInstanceDataPlugin();
  this.registration=Activator.context.registerService(IPlanBuilderPostPhasePlugin.class.getName(),this.plugin,null);
  this.registration2=Activator.context.registerService(IPlanBuilderPolicyAwarePrePhasePlugin.class.getName(),this.plugin,null);
}"
41497,"@Override public boolean handle(BPELPlanContext context,AbstractRelationshipTemplate relationshipTemplate){
  return this.handler.handle(context,relationshipTemplate);
}","@Override public boolean handle(BPELPlanContext context,AbstractNodeTemplate nodeTemplate,AbstractPolicy policy){
  return this.handler.handlePasswordCheck(context,nodeTemplate);
}"
41498,"@Override public boolean handle(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate,List<String> selectionStrategies){
  String inputFieldName=nodeTemplate.getId() + ""String_Node_Str"";
  context.addStringValueToPlanRequest(inputFieldName);
  String nodeInstanceVarName=this.findInstanceVar(context,nodeTemplate.getId(),true);
  try {
    Node assignFromInputToNodeInstanceIdVar=new BPELProcessFragments().generateAssignFromInputMessageToStringVariableAsNode(inputFieldName,nodeInstanceVarName);
    assignFromInputToNodeInstanceIdVar=context.importNode(assignFromInputToNodeInstanceIdVar);
    context.getPrePhaseElement().appendChild(assignFromInputToNodeInstanceIdVar);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
  return false;
}","@Override public boolean handle(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate,List<String> selectionStrategies){
  String inputFieldName=nodeTemplate.getId() + ""String_Node_Str"";
  context.addStringValueToPlanRequest(inputFieldName);
  String nodeInstanceVarName=this.findInstanceVar(context,nodeTemplate.getId(),true);
  try {
    Node assignFromInputToNodeInstanceIdVar=new BPELProcessFragments().generateAssignFromInputMessageToStringVariableAsNode(inputFieldName,nodeInstanceVarName);
    assignFromInputToNodeInstanceIdVar=context.importNode(assignFromInputToNodeInstanceIdVar);
    context.getPrePhaseElement().appendChild(assignFromInputToNodeInstanceIdVar);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
  try {
    new NodeInstanceInitializer(new BPELPlanHandler()).addPropertyVariableUpdateBasedOnNodeInstanceID(context,nodeTemplate);
  }
 catch (  ParserConfigurationException e) {
    e.printStackTrace();
  }
  return true;
}"
41499,"private void rewriteServices(Map<QName,QName> servicesToRewrite,WSDLWriter writer,WSDLReader reader,final List<File> referencedFiles) throws WSDLException, FileNotFoundException {
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + referencedFiles);
  LOG.debug(""String_Node_Str"" + servicesToRewrite);
  for (  final QName serviceName : servicesToRewrite.keySet()) {
    for (    final File file : referencedFiles) {
      if (!file.getAbsolutePath().endsWith(""String_Node_Str"")) {
        continue;
      }
      final Definition def=reader.readWSDL(file.getAbsolutePath());
      final List<QName> servicesToRemove=new ArrayList<>();
      for (      final Object obj : def.getAllServices().values()) {
        final Service service=(Service)obj;
        if (serviceName.equals(service.getQName())) {
          servicesToRemove.add(service.getQName());
          final Service newService=new ServiceImpl();
          for (          final Object o : service.getPorts().values()) {
            final Port port=(Port)o;
            newService.addPort(port);
          }
          newService.setQName(servicesToRewrite.get(serviceName));
          def.addService(newService);
        }
      }
      for (      final QName serviceToRemove : servicesToRemove) {
        def.removeService(serviceToRemove);
      }
      writer.writeWSDL(def,new FileOutputStream(file));
    }
  }
}","private void rewriteServices(Set<Mapping> servicesToRewrite,WSDLWriter writer,WSDLReader reader,final List<File> referencedFiles) throws WSDLException, FileNotFoundException {
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + referencedFiles);
  LOG.debug(""String_Node_Str"" + servicesToRewrite);
  for (  final Mapping service : servicesToRewrite) {
    final QName serviceName=service.key;
    for (    final File file : referencedFiles) {
      if (!file.getAbsolutePath().endsWith(""String_Node_Str"")) {
        continue;
      }
      final Definition def=reader.readWSDL(file.getAbsolutePath());
      final List<QName> servicesToRemove=new ArrayList<>();
      boolean foundMatch=false;
      for (      final Object obj : def.getAllServices().values()) {
        final Service serviceA=(Service)obj;
        if (serviceName.equals(serviceA.getQName())) {
          servicesToRemove.add(serviceA.getQName());
          final Service newService=new ServiceImpl();
          for (          final Object o : serviceA.getPorts().values()) {
            final Port port=(Port)o;
            newService.addPort(port);
          }
          newService.setQName(service.val);
          def.addService(newService);
          foundMatch=true;
        }
      }
      if (foundMatch) {
        for (        final QName serviceToRemove : servicesToRemove) {
          def.removeService(serviceToRemove);
        }
        writer.writeWSDL(def,new FileOutputStream(file));
        break;
      }
    }
  }
}"
41500,"/** 
 * Writes the given DOM Document to the location denoted by the given File
 * @param destination a File denoting the location to export to
 * @param doc the Document to export
 * @throws TransformerException is thrown when initializing aTransformerFactory or writing the Document fails
 * @throws FileNotFoundException is thrown when the File denoted by the FileObject doesn't exist
 */
private void writeBPELDocToFile(final File destination,final Document doc) throws TransformerException, FileNotFoundException {
  final TransformerFactory tFactory=TransformerFactory.newInstance();
  final Transformer transformer=tFactory.newTransformer();
  transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,""String_Node_Str"");
  transformer.setOutputProperty(OutputKeys.METHOD,""String_Node_Str"");
  transformer.setOutputProperty(OutputKeys.INDENT,""String_Node_Str"");
  transformer.setOutputProperty(OutputKeys.ENCODING,""String_Node_Str"");
  transformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
  final DOMSource source=new DOMSource(doc);
  final StreamResult result=new StreamResult(new FileOutputStream(destination));
  transformer.transform(source,result);
}","/** 
 * Writes the given DOM Document to the location denoted by the given File
 * @param destination a File denoting the location to export to
 * @param doc the Document to export
 * @throws TransformerException is thrown when initializing a TransformerFactory or writing the Document fails
 * @throws FileNotFoundException is thrown when the File denoted by the File Object doesn't exist
 */
private void writeBPELDocToFile(final File destination,final Document doc) throws TransformerException, FileNotFoundException {
  final TransformerFactory tFactory=TransformerFactory.newInstance();
  final Transformer transformer=tFactory.newTransformer();
  transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,""String_Node_Str"");
  transformer.setOutputProperty(OutputKeys.METHOD,""String_Node_Str"");
  transformer.setOutputProperty(OutputKeys.INDENT,""String_Node_Str"");
  transformer.setOutputProperty(OutputKeys.ENCODING,""String_Node_Str"");
  transformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
  final DOMSource source=new DOMSource(doc);
  final StreamResult result=new StreamResult(new FileOutputStream(destination));
  transformer.transform(source,result);
}"
41501,"private void rewriteServiceNames(final Deploy deploy,final List<File> referencedFiles,final String csarName) throws WSDLException, FileNotFoundException {
  final WSDLFactory factory=WSDLFactory.newInstance();
  final WSDLReader reader=factory.newWSDLReader();
  final WSDLWriter writer=factory.newWSDLWriter();
  final List<TInvoke> invokes=deploy.getProcess().get(0).getInvoke();
  final List<TProvide> provides=deploy.getProcess().get(0).getProvide();
  final Map<QName,QName> invokedServicesToRewrite=new HashMap<>();
  final Map<QName,QName> providedServicesToRewrite=new HashMap<>();
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  for (  final TInvoke invoke : invokes) {
    if (invoke.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    final TService service=invoke.getService();
    final QName serviceName=service.getName();
    final QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart() + System.currentTimeMillis());
    LOG.debug(""String_Node_Str"" + serviceName + ""String_Node_Str""+ renamedServiceName);
    invokedServicesToRewrite.put(serviceName,renamedServiceName);
    service.setName(renamedServiceName);
    invoke.setService(service);
  }
  LOG.debug(""String_Node_Str"");
  for (  final TProvide provide : provides) {
    if (provide.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    final TService service=provide.getService();
    final QName serviceName=service.getName();
    final QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart() + System.currentTimeMillis());
    LOG.debug(""String_Node_Str"" + serviceName + ""String_Node_Str""+ renamedServiceName);
    providedServicesToRewrite.put(serviceName,renamedServiceName);
    service.setName(renamedServiceName);
    provide.setService(service);
  }
  this.rewriteServices(invokedServicesToRewrite,writer,reader,referencedFiles);
  this.rewriteServices(providedServicesToRewrite,writer,reader,referencedFiles);
}","private void rewriteServiceNames(final Deploy deploy,final List<File> referencedFiles,final String csarName) throws WSDLException, FileNotFoundException {
  final WSDLFactory factory=WSDLFactory.newInstance();
  final WSDLReader reader=factory.newWSDLReader();
  final WSDLWriter writer=factory.newWSDLWriter();
  final List<TInvoke> invokes=deploy.getProcess().get(0).getInvoke();
  final List<TProvide> provides=deploy.getProcess().get(0).getProvide();
  final Set<Mapping> invokedServicesToRewrite=new HashSet<>();
  final Set<Mapping> providedServicesToRewrite=new HashSet<>();
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  for (  final TInvoke invoke : invokes) {
    if (invoke.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    final TService service=invoke.getService();
    final QName serviceName=service.getName();
    final QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart() + System.currentTimeMillis());
    LOG.debug(""String_Node_Str"" + serviceName + ""String_Node_Str""+ renamedServiceName);
    invokedServicesToRewrite.add(new Mapping(serviceName,renamedServiceName));
    service.setName(renamedServiceName);
    invoke.setService(service);
  }
  LOG.debug(""String_Node_Str"");
  for (  final TProvide provide : provides) {
    if (provide.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    final TService service=provide.getService();
    final QName serviceName=service.getName();
    final QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart() + System.currentTimeMillis());
    LOG.debug(""String_Node_Str"" + serviceName + ""String_Node_Str""+ renamedServiceName);
    providedServicesToRewrite.add(new Mapping(serviceName,renamedServiceName));
    service.setName(renamedServiceName);
    provide.setService(service);
  }
  this.rewriteServices(invokedServicesToRewrite,writer,reader,referencedFiles);
  this.rewriteServices(providedServicesToRewrite,writer,reader,referencedFiles);
}"
41502,"public References getRefs(final UriInfo uriInfo,String state){
  final References refs=new References();
  final IInstanceDataService service=InstanceDataServiceHandler.getInstanceDataService();
  final URI serviceInstanceIDtoURI=IdConverter.serviceInstanceIDtoURI(this.serviceTemplateInstanceId);
  try {
    final List<SimpleXLink> serviceInstanceLinks=new LinkedList<>();
    serviceInstanceLinks.add(LinkBuilder.selfLink(uriInfo));
    final List<ServiceInstance> serviceInstances=service.getServiceInstances(serviceInstanceIDtoURI,null,null);
    final ServiceInstance serviceInstance=serviceInstances.get(0);
    final List<NodeInstance> nodeInstances=service.getNodeInstances(null,null,null,serviceInstanceIDtoURI);
    final List<SimpleXLink> nodeInstanceLinks=new LinkedList<>();
    for (    final NodeInstance nodeInstance : nodeInstances) {
      if (state != null && !nodeInstance.getState().equals(State.Node.valueOf(state))) {
        continue;
      }
      final QName nodeId=nodeInstance.getNodeTemplateID();
      final int nodeInstanceId=nodeInstance.getId();
      if (this.nodeTemplateID.toString().equalsIgnoreCase(nodeId.toString()) || this.nodeTemplateID.toString().equalsIgnoreCase(nodeId.getLocalPart())) {
        final Reference ref=new Reference(Utilities.buildURI(uriInfo,String.valueOf(nodeInstanceId)),XLinkConstants.SIMPLE,String.valueOf(nodeInstanceId));
        refs.getReference().add(ref);
        this.log.debug(""String_Node_Str"",ref.getXhref());
      }
 else {
        this.log.debug(""String_Node_Str"",nodeInstanceId,nodeId);
      }
    }
    final NodeInstanceList nil=new NodeInstanceList(null,nodeInstanceLinks);
    final ServiceInstanceEntry sie=new ServiceInstanceEntry(serviceInstance,serviceInstanceLinks,nil);
    refs.getReference().add(new Reference(uriInfo.getAbsolutePath().toString(),XLinkConstants.SIMPLE,XLinkConstants.SELF));
    return refs;
  }
 catch (  final Exception e) {
    e.printStackTrace();
    return null;
  }
}","public References getRefs(final UriInfo uriInfo,String state){
  final References refs=new References();
  final IInstanceDataService service=InstanceDataServiceHandler.getInstanceDataService();
  final URI serviceInstanceIDtoURI=IdConverter.serviceInstanceIDtoURI(this.serviceTemplateInstanceId);
  List<String> states=new ArrayList<>();
  if (state != null && !state.isEmpty()) {
    if (state.contains(""String_Node_Str"")) {
      for (      String split : state.split(""String_Node_Str"")) {
        if (!split.trim().isEmpty()) {
          states.add(split.trim());
        }
      }
    }
 else     if (!state.isEmpty()) {
      states.add(state);
    }
  }
  try {
    final List<SimpleXLink> serviceInstanceLinks=new LinkedList<>();
    serviceInstanceLinks.add(LinkBuilder.selfLink(uriInfo));
    final List<ServiceInstance> serviceInstances=service.getServiceInstances(serviceInstanceIDtoURI,null,null);
    final ServiceInstance serviceInstance=serviceInstances.get(0);
    final List<NodeInstance> nodeInstances=service.getNodeInstances(null,null,null,serviceInstanceIDtoURI);
    final List<SimpleXLink> nodeInstanceLinks=new LinkedList<>();
    for (    final NodeInstance nodeInstance : nodeInstances) {
      if (!states.isEmpty() && !states.contains(nodeInstance.getState().toString())) {
        continue;
      }
      final QName nodeId=nodeInstance.getNodeTemplateID();
      final int nodeInstanceId=nodeInstance.getId();
      if (this.nodeTemplateID.toString().equalsIgnoreCase(nodeId.toString()) || this.nodeTemplateID.toString().equalsIgnoreCase(nodeId.getLocalPart())) {
        final Reference ref=new Reference(Utilities.buildURI(uriInfo,String.valueOf(nodeInstanceId)),XLinkConstants.SIMPLE,String.valueOf(nodeInstanceId));
        refs.getReference().add(ref);
        this.log.debug(""String_Node_Str"",ref.getXhref());
      }
 else {
        this.log.debug(""String_Node_Str"",nodeInstanceId,nodeId);
      }
    }
    final NodeInstanceList nil=new NodeInstanceList(null,nodeInstanceLinks);
    final ServiceInstanceEntry sie=new ServiceInstanceEntry(serviceInstance,serviceInstanceLinks,nil);
    refs.getReference().add(new Reference(uriInfo.getAbsolutePath().toString(),XLinkConstants.SIMPLE,XLinkConstants.SELF));
    return refs;
  }
 catch (  final Exception e) {
    e.printStackTrace();
    return null;
  }
}"
41503,"/** 
 * Checks whether the given Node is an infrastructure nodeType that can be handled by the set of plugins used by the PlanBuilder.
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if the given nodeType is an infrastructurenodeType
 */
public static boolean isSupportedInfrastructureNodeType(final QName nodeType){
  if (nodeType.equals(Types.ubuntuNodeType)) {
    return true;
  }
  final String nodeTypeNS=nodeType.getNamespaceURI();
  final String nodeTypeLN=nodeType.getLocalPart();
  if (nodeTypeNS.equals(""String_Node_Str"") && Utils.isProperUbuntuLocalName(nodeTypeLN)) {
    return true;
  }
  if (nodeType.equals(Types.ubuntu1404ServerVmNodeType) || nodeType.equals(Types.ubuntu1404ServerVmNodeType2)) {
    return true;
  }
  if (nodeType.equals(Types.raspbianJessieOSNodeType)) {
    return true;
  }
  if (nodeType.equals(Types.dockerContainerNodeType)) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given Node is an infrastructure nodeType that can be handled by the set of plugins used by the PlanBuilder.
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if the given nodeType is an infrastructurenodeType
 */
public static boolean isSupportedInfrastructureNodeType(final QName nodeType){
  if (nodeType.equals(Types.ubuntuNodeType)) {
    return true;
  }
  final String nodeTypeNS=nodeType.getNamespaceURI();
  final String nodeTypeLN=nodeType.getLocalPart();
  if (nodeTypeNS.equals(""String_Node_Str"") && Utils.isProperUbuntuLocalName(nodeTypeLN)) {
    return true;
  }
  if (nodeType.equals(Types.ubuntu1404ServerVmNodeType) || nodeType.equals(Types.ubuntu1404ServerVmNodeType2)) {
    return true;
  }
  if (nodeType.equals(Types.raspbianJessieOSNodeType)) {
    return true;
  }
  if (nodeType.equals(Types.dockerContainerNodeType)) {
    return true;
  }
  if (nodeType.equals(Types.dockerEngineNodeType)) {
    return true;
  }
  return false;
}"
41504,"public Map<AbstractActivity,AbstractActivity> getLinks(){
  return links;
}","public Set<Link> getLinks(){
  return links;
}"
41505,"public AbstractPlan(final String id,final PlanType type,final AbstractDefinitions definitions,final AbstractServiceTemplate serviceTemplate,final Collection<AbstractActivity> activities,final Map<AbstractActivity,AbstractActivity> links){
  this.id=id;
  this.type=type;
  this.definitions=definitions;
  this.serviceTemplate=serviceTemplate;
  this.activites=activities;
  this.links=links;
}","public AbstractPlan(final String id,final PlanType type,final AbstractDefinitions definitions,final AbstractServiceTemplate serviceTemplate,final Collection<AbstractActivity> activities,final Set<Link> links){
  this.id=id;
  this.type=type;
  this.definitions=definitions;
  this.serviceTemplate=serviceTemplate;
  this.activites=activities;
  this.links=links;
}"
41506,"public BPELPlan(String id,PlanType type,AbstractDefinitions definitions,AbstractServiceTemplate serviceTemplate,Collection<AbstractActivity> activities,Map<AbstractActivity,AbstractActivity> links){
  super(id,type,definitions,serviceTemplate,activities,links);
}","public BPELPlan(String id,PlanType type,AbstractDefinitions definitions,AbstractServiceTemplate serviceTemplate,Collection<AbstractActivity> activities,Set<Link> links){
  super(id,type,definitions,serviceTemplate,activities,links);
}"
41507,"/** 
 * Executes the connectTo operation on the given connectToNode NodeTemplate, the parameters for the operation will be searched starting from the given parametersRootNode Node Template E.g.: For a MQTT Client to connect to a MQTT topic it uses the properties from the topology stack given by the topic itself. These properties are then mapped to the parameters of the MQTT client connectTo operation.
 * @param templateContext the context of this operation call
 * @param connectToNode a Node Template with a connectTo operation
 * @param parametersRootNode a Node Template, which should be used as thestarting node for parameter search
 */
private boolean executeConnectsTo(final TemplatePlanContext templateContext,final AbstractNodeTemplate connectToNode,final AbstractNodeTemplate parametersRootNode){
  AbstractInterface connectsToIface=null;
  AbstractOperation connectsToOp=null;
  for (  final AbstractInterface iface : connectToNode.getType().getInterfaces()) {
    for (    final AbstractOperation op : iface.getOperations()) {
      if (op.getName().equals(""String_Node_Str"")) {
        connectsToIface=iface;
        connectsToOp=op;
        break;
      }
    }
    if (connectsToOp != null) {
      break;
    }
  }
  final Map<AbstractParameter,Variable> param2propertyMapping=new HashMap<>();
  for (  final AbstractParameter param : connectsToOp.getInputParameters()) {
    boolean ambiParam=false;
    Variable var=templateContext.getPropertyVariable(templateContext.getRelationshipTemplate(),param.getName());
    if (var != null) {
      param2propertyMapping.put(param,var);
    }
    if (org.opentosca.container.core.tosca.convention.Utils.isSupportedVirtualMachineIPProperty(param.getName())) {
      ambiParam=true;
    }
    if (!ambiParam) {
      AbstractNodeTemplate currentNode=parametersRootNode;
      while (currentNode != null) {
        final Variable property=templateContext.getPropertyVariable(currentNode,param.getName());
        if (property != null) {
          param2propertyMapping.put(param,property);
          break;
        }
 else {
          currentNode=this.fetchNodeConnectedWithHostedOn(currentNode);
        }
      }
    }
 else {
      for (      final String paramName : org.opentosca.container.core.tosca.convention.Utils.getSupportedVirtualMachineIPPropertyNames()) {
        boolean found=false;
        AbstractNodeTemplate currentNode=parametersRootNode;
        while (currentNode != null) {
          final Variable property=templateContext.getPropertyVariable(currentNode,paramName);
          if (property != null) {
            param2propertyMapping.put(param,property);
            found=true;
            break;
          }
 else {
            currentNode=this.fetchNodeConnectedWithHostedOn(currentNode);
          }
        }
        if (found) {
          break;
        }
      }
    }
  }
  if (param2propertyMapping.size() != connectsToOp.getInputParameters().size()) {
    Handler.LOG.error(""String_Node_Str"");
    return false;
  }
  for (  final AbstractNodeTypeImplementation nodeImpl : connectToNode.getImplementations()) {
    for (    final AbstractImplementationArtifact ia : nodeImpl.getImplementationArtifacts()) {
      if (ia.getInterfaceName().equals(connectsToIface.getName()) && (ia.getOperationName() != null) && ia.getOperationName().equals(connectsToOp.getName())) {
        templateContext.executeOperation(connectToNode,connectsToIface.getName(),connectsToOp.getName(),param2propertyMapping);
      }
    }
  }
  return true;
}","/** 
 * Executes the connectTo operation on the given connectToNode NodeTemplate, the parameters for the operation will be searched starting from the given parametersRootNode Node Template E.g.: For a MQTT Client to connect to a MQTT topic it uses the properties from the topology stack given by the topic itself. These properties are then mapped to the parameters of the MQTT client connectTo operation.
 * @param templateContext the context of this operation call
 * @param connectToNode a Node Template with a connectTo operation
 * @param parametersRootNode a Node Template, which should be used as thestarting node for parameter search
 */
private boolean executeConnectsTo(final TemplatePlanContext templateContext,final AbstractNodeTemplate connectToNode,final AbstractNodeTemplate parametersRootNode){
  AbstractInterface connectsToIface=null;
  AbstractOperation connectsToOp=null;
  for (  final AbstractInterface iface : connectToNode.getType().getInterfaces()) {
    for (    final AbstractOperation op : iface.getOperations()) {
      if (op.getName().equals(""String_Node_Str"")) {
        connectsToIface=iface;
        connectsToOp=op;
        break;
      }
    }
    if (connectsToOp != null) {
      break;
    }
  }
  final Map<AbstractParameter,Variable> param2propertyMapping=new HashMap<>();
  for (  final AbstractParameter param : connectsToOp.getInputParameters()) {
    boolean ambiParam=false;
    Variable var=templateContext.getPropertyVariable(templateContext.getRelationshipTemplate(),param.getName());
    if (var != null) {
      param2propertyMapping.put(param,var);
    }
    if (org.opentosca.container.core.tosca.convention.Utils.isSupportedVirtualMachineIPProperty(param.getName())) {
      ambiParam=true;
    }
    if (!ambiParam) {
      AbstractNodeTemplate currentNode=parametersRootNode;
      while (currentNode != null) {
        final Variable property=templateContext.getPropertyVariable(currentNode,param.getName());
        if (property != null) {
          param2propertyMapping.put(param,property);
          break;
        }
 else {
          currentNode=this.fetchNodeConnectedWithHostedOn(currentNode);
        }
      }
    }
 else {
      for (      final String paramName : org.opentosca.container.core.tosca.convention.Utils.getSupportedVirtualMachineIPPropertyNames()) {
        boolean found=false;
        AbstractNodeTemplate currentNode=parametersRootNode;
        while (currentNode != null) {
          final Variable property=templateContext.getPropertyVariable(currentNode,paramName);
          if (property != null) {
            param2propertyMapping.put(param,property);
            found=true;
            break;
          }
 else {
            currentNode=this.fetchNodeConnectedWithHostedOn(currentNode);
          }
        }
        if (found) {
          break;
        }
      }
    }
  }
  if (param2propertyMapping.size() != connectsToOp.getInputParameters().size()) {
    Handler.LOG.error(""String_Node_Str"");
    return false;
  }
  templateContext.executeOperation(connectToNode,connectsToIface.getName(),connectsToOp.getName(),param2propertyMapping);
  return true;
}"
41508,"public Response handleCSAR(final String fileName,final InputStream uploadedInputStream) throws IOException, URISyntaxException, UserException, SystemException {
  File uploadFile=this.storeTemporaryFile(fileName,uploadedInputStream);
  CSARID csarID=this.fileHandler.storeCSAR(uploadFile.toPath());
  this.control.invokeTOSCAProcessing(csarID);
  if (ModelUtils.hasOpenRequirements(csarID)) {
    WineryConnector winCon=new WineryConnector();
    if (winCon.isWineryRepositoryAvailable()) {
      QName serviceTemplate=winCon.uploadCSAR(uploadFile);
      this.control.deleteCSAR(csarID);
      return Response.status(Response.Status.NOT_ACCEPTABLE).entity(""String_Node_Str"" + winCon.getServiceTemplateURI(serviceTemplate).toString() + ""String_Node_Str"").build();
    }
 else {
      this.fileHandler.deleteCSAR(csarID);
      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
  }
  if (!ModelUtils.hasBuildPlan(csarID) | !ModelUtils.hasTerminationPlan(csarID)) {
    this.control.deleteCSAR(csarID);
    csarID=this.fileHandler.storeCSAR(uploadFile.toPath());
    csarID=this.startPlanBuilder(csarID);
  }
  this.processTOSCA(csarID,true);
  if (csarID != null) {
    CSARsResource.LOG.info(""String_Node_Str"",csarID.toString());
    final String path=Utilities.buildURI(this.uriInfo.getAbsolutePath().toString(),csarID.toString());
    final JsonObject retObj=new JsonObject();
    retObj.addProperty(""String_Node_Str"",path);
    return Response.created(URI.create(path)).entity(retObj.toString()).build();
  }
 else {
    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
  }
}","public Response handleCSAR(final String fileName,final InputStream uploadedInputStream) throws IOException, URISyntaxException, UserException, SystemException {
  File uploadFile=this.storeTemporaryFile(fileName,uploadedInputStream);
  CSARID csarID=this.fileHandler.storeCSAR(uploadFile.toPath());
  this.control.invokeTOSCAProcessing(csarID);
  boolean toscaProcessed=true;
  if (ModelUtils.hasOpenRequirements(csarID)) {
    WineryConnector winCon=new WineryConnector();
    if (winCon.isWineryRepositoryAvailable()) {
      QName serviceTemplate=winCon.uploadCSAR(uploadFile);
      this.control.deleteCSAR(csarID);
      return Response.status(Response.Status.NOT_ACCEPTABLE).entity(""String_Node_Str"" + winCon.getServiceTemplateURI(serviceTemplate).toString() + ""String_Node_Str"").build();
    }
 else {
      this.fileHandler.deleteCSAR(csarID);
      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
  }
  if (!ModelUtils.hasBuildPlan(csarID) | !ModelUtils.hasTerminationPlan(csarID)) {
    this.control.deleteCSAR(csarID);
    csarID=this.fileHandler.storeCSAR(uploadFile.toPath());
    csarID=this.startPlanBuilder(csarID);
    toscaProcessed=false;
  }
  this.processTOSCA(csarID,toscaProcessed);
  if (csarID != null) {
    CSARsResource.LOG.info(""String_Node_Str"",csarID.toString());
    final String path=Utilities.buildURI(this.uriInfo.getAbsolutePath().toString(),csarID.toString());
    final JsonObject retObj=new JsonObject();
    retObj.addProperty(""String_Node_Str"",path);
    return Response.created(URI.create(path)).entity(retObj.toString()).build();
  }
 else {
    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
  }
}"
41509,"public static boolean hasTerminationPlan(CSARID csarId) throws UserException, SystemException {
  QName serviceTemplateId=ModelUtils.getEntryServiceTemplate(csarId);
  Map<PlanTypes,LinkedHashMap<QName,TPlan>> plans=ToscaServiceHandler.getToscaEngineService().getToscaReferenceMapper().getCSARIDToPlans(csarId);
  return plans.containsKey(PlanTypes.TERMINATION);
}","public static boolean hasTerminationPlan(CSARID csarId) throws UserException, SystemException {
  Map<PlanTypes,LinkedHashMap<QName,TPlan>> plans=ToscaServiceHandler.getToscaEngineService().getToscaReferenceMapper().getCSARIDToPlans(csarId);
  if (plans == null)   return false;
  return (plans.containsKey(PlanTypes.TERMINATION) & !plans.get(PlanTypes.TERMINATION).isEmpty()) ? true : false;
}"
41510,"public static boolean hasBuildPlan(CSARID csarId) throws UserException, SystemException {
  QName serviceTemplateId=ModelUtils.getEntryServiceTemplate(csarId);
  Map<PlanTypes,LinkedHashMap<QName,TPlan>> plans=ToscaServiceHandler.getToscaEngineService().getToscaReferenceMapper().getCSARIDToPlans(csarId);
  if (plans == null)   return false;
  return plans.containsKey(PlanTypes.BUILD);
}","public static boolean hasBuildPlan(CSARID csarId) throws UserException, SystemException {
  Map<PlanTypes,LinkedHashMap<QName,TPlan>> plans=ToscaServiceHandler.getToscaEngineService().getToscaReferenceMapper().getCSARIDToPlans(csarId);
  if (plans == null)   return false;
  return (plans.containsKey(PlanTypes.BUILD) & !plans.get(PlanTypes.BUILD).isEmpty()) ? true : false;
}"
41511,"/** 
 * Updates the input parameters. If instance data are available the provided input parameters will be overwritten with them.
 * @param inputParams
 * @param csarID
 * @param serviceTemplateID
 * @param nodeTypeID
 * @param nodeTemplateID
 * @param neededInterface
 * @param neededOperation
 * @param serviceInstanceID
 * @return the updated input parameters.
 */
private HashMap<String,String> updateInputParams(final HashMap<String,String> inputParams,final CSARID csarID,final QName serviceTemplateID,QName nodeTypeID,final String nodeTemplateID,final String neededInterface,final String neededOperation,final URI serviceInstanceID){
  ManagementBusServiceImpl.LOG.debug(""String_Node_Str"",inputParams.size(),neededOperation,inputParams.toString());
  nodeTypeID=ServiceHandler.toscaEngineService.getNodeTypeOfNodeTemplate(csarID,serviceTemplateID,nodeTemplateID);
  final List<String> expectedParams=this.getExpectedInputParams(csarID,nodeTypeID,neededInterface,neededOperation);
  ManagementBusServiceImpl.LOG.debug(""String_Node_Str"",neededOperation,expectedParams.size(),expectedParams.toString());
  if (!expectedParams.isEmpty()) {
    if ((serviceInstanceID != null) && (!serviceInstanceID.toString().equals(""String_Node_Str""))) {
      ManagementBusServiceImpl.LOG.debug(""String_Node_Str"",serviceInstanceID);
      final HashMap<String,String> propertiesMap=MBUtils.getInstanceDataProperties(csarID,serviceTemplateID,nodeTemplateID.trim(),serviceInstanceID);
      ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
      for (      final String key : propertiesMap.keySet()) {
        ManagementBusServiceImpl.LOG.debug(""String_Node_Str"" + key + ""String_Node_Str""+ propertiesMap.get(key));
      }
      if (propertiesMap != null) {
        final List<String> supportedIPPropertyNames=Utils.getSupportedVirtualMachineIPPropertyNames();
        final List<String> supportedInstanceIdPropertyNames=Utils.getSupportedVirtualMachineInstanceIdPropertyNames();
        final List<String> supportedPasswordPropertyNames=Utils.getSupportedVirtualMachineLoginPasswordPropertyNames();
        final List<String> supportedUsernamePropertyNames=Utils.getSupportedVirtualMachineLoginUserNamePropertyNames();
        ManagementBusServiceImpl.LOG.debug(""String_Node_Str"",serviceInstanceID,nodeTemplateID,propertiesMap.toString());
        String prop;
        for (        final String expectedParam : expectedParams) {
          if (supportedIPPropertyNames.contains(expectedParam)) {
            ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
            prop=this.getSupportedProperty(supportedIPPropertyNames,propertiesMap);
            if (prop != null) {
              inputParams.put(expectedParam,prop);
            }
          }
 else           if (supportedInstanceIdPropertyNames.contains(expectedParam)) {
            ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
            prop=this.getSupportedProperty(supportedInstanceIdPropertyNames,propertiesMap);
            if (prop != null) {
              inputParams.put(expectedParam,prop);
            }
          }
 else           if (supportedPasswordPropertyNames.contains(expectedParam)) {
            ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
            prop=this.getSupportedProperty(supportedPasswordPropertyNames,propertiesMap);
            if (prop != null) {
              inputParams.put(expectedParam,prop);
            }
          }
 else           if (supportedUsernamePropertyNames.contains(expectedParam)) {
            ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
            prop=this.getSupportedProperty(supportedUsernamePropertyNames,propertiesMap);
            if (prop != null) {
              inputParams.put(expectedParam,prop);
            }
          }
 else {
            for (            final String propName : propertiesMap.keySet()) {
              if (expectedParam.equals(propName)) {
                inputParams.put(expectedParam,propertiesMap.get(propName));
              }
            }
          }
        }
        ManagementBusServiceImpl.LOG.debug(""String_Node_Str"",inputParams.size(),neededOperation,inputParams.toString());
      }
 else {
        ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
      }
    }
 else {
      ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
    }
  }
  return inputParams;
}","/** 
 * Updates the input parameters. If instance data are available the provided input parameters will be overwritten with them.
 * @param inputParams
 * @param csarID
 * @param serviceTemplateID
 * @param nodeTypeID
 * @param nodeTemplateID
 * @param neededInterface
 * @param neededOperation
 * @param serviceInstanceID
 * @return the updated input parameters.
 */
private HashMap<String,String> updateInputParams(final HashMap<String,String> inputParams,final CSARID csarID,final QName serviceTemplateID,QName nodeTypeID,final String nodeTemplateID,final String neededInterface,final String neededOperation,final URI serviceInstanceID){
  ManagementBusServiceImpl.LOG.debug(""String_Node_Str"",inputParams.size(),neededOperation,inputParams.toString());
  nodeTypeID=ServiceHandler.toscaEngineService.getNodeTypeOfNodeTemplate(csarID,serviceTemplateID,nodeTemplateID);
  final List<String> expectedParams=this.getExpectedInputParams(csarID,nodeTypeID,neededInterface,neededOperation);
  ManagementBusServiceImpl.LOG.debug(""String_Node_Str"",neededOperation,expectedParams.size(),expectedParams.toString());
  if (!expectedParams.isEmpty()) {
    if ((serviceInstanceID != null) && (!serviceInstanceID.toString().equals(""String_Node_Str""))) {
      ManagementBusServiceImpl.LOG.debug(""String_Node_Str"",serviceInstanceID);
      final HashMap<String,String> propertiesMap=MBUtils.getInstanceDataProperties(csarID,serviceTemplateID,nodeTemplateID.trim(),serviceInstanceID);
      ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
      for (      final String key : propertiesMap.keySet()) {
        ManagementBusServiceImpl.LOG.debug(""String_Node_Str"" + key + ""String_Node_Str""+ propertiesMap.get(key));
      }
      if (propertiesMap != null) {
        final List<String> supportedIPPropertyNames=Utils.getSupportedVirtualMachineIPPropertyNames();
        final List<String> supportedInstanceIdPropertyNames=Utils.getSupportedVirtualMachineInstanceIdPropertyNames();
        final List<String> supportedPasswordPropertyNames=Utils.getSupportedVirtualMachineLoginPasswordPropertyNames();
        final List<String> supportedUsernamePropertyNames=Utils.getSupportedVirtualMachineLoginUserNamePropertyNames();
        ManagementBusServiceImpl.LOG.debug(""String_Node_Str"",serviceInstanceID,nodeTemplateID,propertiesMap.toString());
        String prop;
        for (        final String expectedParam : expectedParams) {
          if (supportedIPPropertyNames.contains(expectedParam)) {
            ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
            prop=this.getSupportedProperty(supportedIPPropertyNames,propertiesMap);
            if (prop != null) {
              this.putOnlyIfNotSet(inputParams,expectedParam,prop);
            }
          }
 else           if (supportedInstanceIdPropertyNames.contains(expectedParam)) {
            ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
            prop=this.getSupportedProperty(supportedInstanceIdPropertyNames,propertiesMap);
            if (prop != null) {
              this.putOnlyIfNotSet(inputParams,expectedParam,prop);
            }
          }
 else           if (supportedPasswordPropertyNames.contains(expectedParam)) {
            ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
            prop=this.getSupportedProperty(supportedPasswordPropertyNames,propertiesMap);
            if (prop != null) {
              this.putOnlyIfNotSet(inputParams,expectedParam,prop);
            }
          }
 else           if (supportedUsernamePropertyNames.contains(expectedParam)) {
            ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
            prop=this.getSupportedProperty(supportedUsernamePropertyNames,propertiesMap);
            if (prop != null) {
              this.putOnlyIfNotSet(inputParams,expectedParam,prop);
            }
          }
 else {
            for (            final String propName : propertiesMap.keySet()) {
              if (expectedParam.equals(propName)) {
                this.putOnlyIfNotSet(inputParams,expectedParam,propertiesMap.get(propName));
              }
            }
          }
        }
        ManagementBusServiceImpl.LOG.debug(""String_Node_Str"",inputParams.size(),neededOperation,inputParams.toString());
      }
 else {
        ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
      }
    }
 else {
      ManagementBusServiceImpl.LOG.debug(""String_Node_Str"");
    }
  }
  return inputParams;
}"
41512,"/** 
 * This function deletes all stored references of a certain CSAR.
 * @param csarID
 * @return true for success, false for an error
 */
public boolean clearCSARContent(final CSARID csarID){
  this.LOG.debug(""String_Node_Str"" + csarID + ""String_Node_Str"");
  this.setup();
  this.referenceMap.remove(csarID);
  this.documentMap.remove(csarID);
  this.mapCSARIDToDefinitions.remove(csarID);
  this.mapCSARIDToServiceTemplateIDs.remove(csarID);
  this.csarIDToPlanTypeToIntegerToPlan.remove(csarID);
  this.csarIDToWSDLDocuments.remove(csarID);
  this.csarIDToServiceTemplateIDToPlanID.remove(csarID);
  this.csarIDToPlanIDToSynchronousBoolean.remove(csarID);
  this.csarIDToExportedInterface.remove(csarID);
  this.csarIDToPolicies.remove(csarID);
  this.mapDefinitionsIDToLocationString.remove(csarID);
  this.mapElementIDToDefinitionsID.remove(csarID);
  if (this.containsCSARData(csarID)) {
    return false;
  }
  return true;
}","/** 
 * This function deletes all stored references of a certain CSAR.
 * @param csarID
 * @return true for success, false for an error
 */
public boolean clearCSARContent(final CSARID csarID){
  this.LOG.debug(""String_Node_Str"" + csarID + ""String_Node_Str"");
  this.setup();
  this.referenceMap.remove(csarID);
  this.documentMap.remove(csarID);
  this.mapCSARIDToDefinitions.remove(csarID);
  this.mapCSARIDToServiceTemplateIDs.remove(csarID);
  this.csarIDToPlanTypeToIntegerToPlan.remove(csarID);
  this.csarIDToWSDLDocuments.remove(csarID);
  this.csarIDToServiceTemplateIDToPlanID.remove(csarID);
  this.csarIDToPlanIDToSynchronousBoolean.remove(csarID);
  this.csarIDToExportedInterface.remove(csarID);
  this.csarIDToPolicies.remove(csarID);
  this.mapDefinitionsIDToLocationString.remove(csarID);
  this.mapElementIDToDefinitionsID.remove(csarID);
  this.mapCSARIDToServiceTemplateIdToInterfaceToOperationToPlan.remove(csarID);
  this.mapCSARIDToServiceTemplateQNameToNodeTemplateID.remove(csarID);
  this.mapCSARIDToServiceTemplateQNameToRelationshipTemplateID.remove(csarID);
  this.serviceTemplatePropertiesContent.remove(csarID);
  this.serviceTemplatePropertyMappings.remove(csarID);
  if (this.containsCSARData(csarID)) {
    return false;
  }
  return true;
}"
41513,"/** 
 * Adds BPEL code to the given TemplateContext which installs an PhpModule to an Apache HTTP Server
 * @param templateContext the TemplateContext the code should be added to
 * @return true iff appending all BPEL code was successful
 */
public boolean handle(final TemplatePlanContext templateContext){
  if (templateContext.getNodeTemplate() == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  final AbstractNodeTemplate nodeTemplate=templateContext.getNodeTemplate();
  final Variable containerPortVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  final Variable portVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  if ((containerPortVar == null) | (portVar == null)) {
    Handler.LOG.error(""String_Node_Str"");
    return false;
  }
  final String containerPortVal=this.fetchValueFromProperty(nodeTemplate,""String_Node_Str"");
  final String portVal=this.fetchValueFromProperty(nodeTemplate,""String_Node_Str"");
  final String portMapping=containerPortVal + ""String_Node_Str"" + portVal;
  final Variable portMappingVar=templateContext.createGlobalStringVariable(""String_Node_Str"" + System.currentTimeMillis(),portMapping);
  final Variable sshPortVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  final Variable containerIpVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  Variable containerIdVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  final AbstractNodeTemplate dockerEngineNode=this.getDockerEngineNode(nodeTemplate);
  if (dockerEngineNode == null) {
    Handler.LOG.error(""String_Node_Str"");
    return false;
  }
  final Variable dockerEngineUrlVar=templateContext.getPropertyVariable(dockerEngineNode,""String_Node_Str"");
  final Variable containerImageVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  if ((containerImageVar == null) || Utils.isVariableValueEmpty(containerImageVar,templateContext)) {
    final AbstractDeploymentArtifact da=this.fetchFirstDockerContainerDA(nodeTemplate);
    this.handleWithDA(templateContext,dockerEngineNode,da,portMappingVar,dockerEngineUrlVar,sshPortVar,containerIpVar,containerIdVar);
  }
 else {
    return this.handleWithImageId(templateContext,dockerEngineNode,containerImageVar,portMappingVar,dockerEngineUrlVar,sshPortVar,containerIpVar,containerIdVar);
  }
  return true;
}","/** 
 * Adds BPEL code to the given TemplateContext which installs an PhpModule to an Apache HTTP Server
 * @param templateContext the TemplateContext the code should be added to
 * @return true iff appending all BPEL code was successful
 */
public boolean handle(final TemplatePlanContext templateContext){
  if (templateContext.getNodeTemplate() == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  final AbstractNodeTemplate nodeTemplate=templateContext.getNodeTemplate();
  final Variable containerPortVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  final Variable portVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  if ((containerPortVar == null) | (portVar == null)) {
    Handler.LOG.error(""String_Node_Str"");
    return false;
  }
  final Variable portMappingVar=templateContext.createGlobalStringVariable(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
  try {
    Node assignContainerPortsNode=this.planBuilderFragments.createAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"",""String_Node_Str"" + containerPortVar.getName() + ""String_Node_Str""+ portVar.getName()+ ""String_Node_Str"",portMappingVar.getName());
    assignContainerPortsNode=templateContext.importNode(assignContainerPortsNode);
    templateContext.getProvisioningPhaseElement().appendChild(assignContainerPortsNode);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  SAXException e) {
    e.printStackTrace();
  }
  final Variable sshPortVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  final Variable containerIpVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  Variable containerIdVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  final AbstractNodeTemplate dockerEngineNode=this.getDockerEngineNode(nodeTemplate);
  if (dockerEngineNode == null) {
    Handler.LOG.error(""String_Node_Str"");
    return false;
  }
  final Variable dockerEngineUrlVar=templateContext.getPropertyVariable(dockerEngineNode,""String_Node_Str"");
  final Variable containerImageVar=templateContext.getPropertyVariable(nodeTemplate,""String_Node_Str"");
  if ((containerImageVar == null) || Utils.isVariableValueEmpty(containerImageVar,templateContext)) {
    final AbstractDeploymentArtifact da=this.fetchFirstDockerContainerDA(nodeTemplate);
    this.handleWithDA(templateContext,dockerEngineNode,da,portMappingVar,dockerEngineUrlVar,sshPortVar,containerIpVar,containerIdVar);
  }
 else {
    return this.handleWithImageId(templateContext,dockerEngineNode,containerImageVar,portMappingVar,dockerEngineUrlVar,sshPortVar,containerIpVar,containerIdVar);
  }
  return true;
}"
41514,"public Response handleCSAR(final String fileName,final InputStream uploadedInputStream) throws IOException, URISyntaxException, UserException, SystemException {
  File uploadFile=this.storeTemporaryFile(fileName,uploadedInputStream);
  CSARID csarID=this.fileHandler.storeCSAR(uploadFile.toPath());
  this.control.invokeTOSCAProcessing(csarID);
  if (ModelUtils.hasOpenRequirements(csarID)) {
    WineryConnector winCon=new WineryConnector();
    if (winCon.isWineryRepositoryAvailable()) {
      QName serviceTemplate=winCon.uploadCSAR(uploadFile);
      this.fileHandler.deleteCSAR(csarID);
      return Response.status(Response.Status.NOT_ACCEPTABLE).entity(""String_Node_Str"" + winCon.getServiceTemplateURI(serviceTemplate).toString() + ""String_Node_Str"").build();
    }
 else {
      this.fileHandler.deleteCSAR(csarID);
      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
  }
  ToscaServiceHandler.getToscaEngineService().clearCSARContent(csarID);
  csarID=this.startPlanBuilder(csarID);
  this.processTOSCA(csarID);
  if (csarID != null) {
    CSARsResource.LOG.info(""String_Node_Str"",csarID.toString());
    final String path=Utilities.buildURI(this.uriInfo.getAbsolutePath().toString(),csarID.toString());
    final JsonObject retObj=new JsonObject();
    retObj.addProperty(""String_Node_Str"",path);
    return Response.created(URI.create(path)).entity(retObj.toString()).build();
  }
 else {
    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
  }
}","public Response handleCSAR(final String fileName,final InputStream uploadedInputStream) throws IOException, URISyntaxException, UserException, SystemException {
  File uploadFile=this.storeTemporaryFile(fileName,uploadedInputStream);
  CSARID csarID=this.fileHandler.storeCSAR(uploadFile.toPath());
  this.control.invokeTOSCAProcessing(csarID);
  if (ModelUtils.hasOpenRequirements(csarID)) {
    WineryConnector winCon=new WineryConnector();
    if (winCon.isWineryRepositoryAvailable()) {
      QName serviceTemplate=winCon.uploadCSAR(uploadFile);
      this.control.deleteCSAR(csarID);
      return Response.status(Response.Status.NOT_ACCEPTABLE).entity(""String_Node_Str"" + winCon.getServiceTemplateURI(serviceTemplate).toString() + ""String_Node_Str"").build();
    }
 else {
      this.fileHandler.deleteCSAR(csarID);
      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
  }
  this.control.deleteCSAR(csarID);
  csarID=this.fileHandler.storeCSAR(uploadFile.toPath());
  csarID=this.startPlanBuilder(csarID);
  this.processTOSCA(csarID);
  if (csarID != null) {
    CSARsResource.LOG.info(""String_Node_Str"",csarID.toString());
    final String path=Utilities.buildURI(this.uriInfo.getAbsolutePath().toString(),csarID.toString());
    final JsonObject retObj=new JsonObject();
    retObj.addProperty(""String_Node_Str"",path);
    return Response.created(URI.create(path)).entity(retObj.toString()).build();
  }
 else {
    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
  }
}"
41515,"private String generatePropertyValueFromConcatQuery(String targetPropertyRef,List<NodeInstance> nodeInstance){
  String testQuery=targetPropertyRef.trim();
  if (!testQuery.endsWith(""String_Node_Str"")) {
    return null;
  }
  int functionOpeningBracket=testQuery.indexOf(""String_Node_Str"");
  String functionString=testQuery.substring(0,functionOpeningBracket);
  if (!functionString.equals(""String_Node_Str"")) {
    return null;
  }
  String functionContent=testQuery.substring(functionOpeningBracket + 1,testQuery.lastIndexOf(""String_Node_Str"")).trim();
  String[] functionParts=functionContent.split(""String_Node_Str"");
  List<String> augmentedFunctionParts=new ArrayList<String>();
  for (  String functionPart : functionParts) {
    if (functionPart.trim().startsWith(""String_Node_Str"")) {
      augmentedFunctionParts.add(functionPart.trim());
    }
 else     if (functionPart.trim().split(""String_Node_Str"").length == 3) {
      String[] queryParts=functionPart.trim().split(""String_Node_Str"");
      if (!queryParts[1].equals(""String_Node_Str"")) {
        return null;
      }
      String nodeTemplateName=queryParts[0];
      String propertyName=queryParts[2];
      String propValue=fetchPropertyValueFromNodeInstance(getNodeInstanceWithName(nodeInstance,nodeTemplateName),propertyName);
      augmentedFunctionParts.add(""String_Node_Str"" + propValue + ""String_Node_Str"");
    }
  }
  String resultString=""String_Node_Str"";
  for (  String functionPart : augmentedFunctionParts) {
    resultString+=functionPart.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return resultString;
}","private String generatePropertyValueFromConcatQuery(String targetPropertyRef,List<NodeInstance> nodeInstance){
  String testQuery=targetPropertyRef.trim();
  if (!testQuery.endsWith(""String_Node_Str"")) {
    return null;
  }
  int functionOpeningBracket=testQuery.indexOf(""String_Node_Str"");
  String functionString=testQuery.substring(0,functionOpeningBracket);
  if (!functionString.equals(""String_Node_Str"")) {
    return null;
  }
  String functionContent=testQuery.substring(functionOpeningBracket + 1,testQuery.lastIndexOf(""String_Node_Str"")).trim();
  String[] functionParts=functionContent.split(""String_Node_Str"");
  List<String> augmentedFunctionParts=new ArrayList<String>();
  for (  String functionPart : functionParts) {
    if (functionPart.trim().startsWith(""String_Node_Str"")) {
      augmentedFunctionParts.add(functionPart.trim());
    }
 else     if (functionPart.trim().split(""String_Node_Str"").length == 3) {
      String[] queryParts=functionPart.trim().split(""String_Node_Str"");
      if (!queryParts[1].equals(""String_Node_Str"")) {
        return null;
      }
      String nodeTemplateName=queryParts[0];
      String propertyName=queryParts[2];
      if (getNodeInstanceWithName(nodeInstance,nodeTemplateName) != null) {
        String propValue=fetchPropertyValueFromNodeInstance(getNodeInstanceWithName(nodeInstance,nodeTemplateName),propertyName);
        augmentedFunctionParts.add(""String_Node_Str"" + propValue + ""String_Node_Str"");
      }
    }
  }
  String resultString=""String_Node_Str"";
  for (  String functionPart : augmentedFunctionParts) {
    resultString+=functionPart.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return resultString;
}"
41516,"private String fetchPropertyValueFromNodeInstance(NodeInstance nodeInstance,String propertyLocalName){
  NodeList childNodes=nodeInstance.getProperties().getFirstChild().getChildNodes();
  for (int index=0; index < childNodes.getLength(); index++) {
    Node childNode=childNodes.item(index);
    if ((childNode.getNodeType() == Node.ELEMENT_NODE) && childNode.getLocalName().equals(propertyLocalName)) {
      return childNode.getTextContent();
    }
  }
  return null;
}","private String fetchPropertyValueFromNodeInstance(NodeInstance nodeInstance,String propertyLocalName){
  if (nodeInstance.getProperties() == null) {
    return null;
  }
  NodeList childNodes=nodeInstance.getProperties().getFirstChild().getChildNodes();
  for (int index=0; index < childNodes.getLength(); index++) {
    Node childNode=childNodes.item(index);
    if ((childNode.getNodeType() == Node.ELEMENT_NODE) && childNode.getLocalName().equals(propertyLocalName)) {
      return childNode.getTextContent();
    }
  }
  return null;
}"
41517,"@POST @Consumes(MediaType.APPLICATION_XML) @Produces({MediaType.APPLICATION_XML,MediaType.TEXT_XML}) public Response createServiceInstance(@Context UriInfo uriInfo,String xml){
  log.debug(""String_Node_Str"",csarId,serviceTemplateID);
  IInstanceDataService service=InstanceDataServiceHandler.getInstanceDataService();
  try {
    ServiceInstance createdServiceInstance=service.createServiceInstance(csarId,serviceTemplateID);
    String corr=xml.substring(xml.indexOf(""String_Node_Str"") + 1,xml.indexOf(""String_Node_Str""));
    int serviceTemplateInstanceId=createdServiceInstance.getDBId();
    String instanceURL=createdServiceInstance.getServiceInstanceID().toString();
    log.debug(corr + ""String_Node_Str"" + corr+ ""String_Node_Str""+ instanceURL);
{
      BuildCorrelationToInstanceMapping.instance.correlateCorrelationIdToServiceTemplateInstanceId(corr,serviceTemplateInstanceId);
      PlanInvocationEngineHandler.planInvocationEngine.correctCorrelationToServiceTemplateInstanceIdMapping(csarId,serviceTemplateID,corr,serviceTemplateInstanceId);
    }
    SimpleXLink response=new SimpleXLink(uriInfo.getAbsolutePath().toString() + ""String_Node_Str"" + serviceTemplateInstanceId,""String_Node_Str"");
    log.debug(""String_Node_Str"" + response.getHref());
    return Response.ok(response).build();
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new GenericRestException(Status.INTERNAL_SERVER_ERROR,e.getMessage());
  }
}","@POST @Consumes(MediaType.APPLICATION_XML) @Produces({MediaType.APPLICATION_XML,MediaType.TEXT_XML}) public Response createServiceInstance(@Context UriInfo uriInfo,String xml){
  log.debug(""String_Node_Str"",csarId,serviceTemplateID);
  IInstanceDataService service=InstanceDataServiceHandler.getInstanceDataService();
  try {
    ServiceInstance createdServiceInstance=service.createServiceInstance(csarId,serviceTemplateID);
    String corr=xml.substring(xml.indexOf(""String_Node_Str"") + 1,xml.indexOf(""String_Node_Str""));
    int serviceTemplateInstanceId=createdServiceInstance.getDBId();
    String instanceURL=createdServiceInstance.getServiceInstanceID().toString();
    log.debug(corr + ""String_Node_Str"" + corr+ ""String_Node_Str""+ instanceURL);
{
      BuildCorrelationToInstanceMapping.instance.correlateCorrelationIdToServiceTemplateInstanceId(corr,serviceTemplateInstanceId);
      PlanInvocationEngineHandler.planInvocationEngine.correctCorrelationToServiceTemplateInstanceIdMapping(csarId,serviceTemplateID,corr,serviceTemplateInstanceId);
    }
    SimpleXLink response=new SimpleXLink(uriInfo.getAbsolutePath().toString() + serviceTemplateInstanceId,""String_Node_Str"");
    log.debug(""String_Node_Str"" + response.getHref());
    return Response.ok(response).build();
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new GenericRestException(Status.INTERNAL_SERVER_ERROR,e.getMessage());
  }
}"
41518,"@POST @Consumes(MediaType.MULTIPART_FORM_DATA) public Response createFromArtefact(@FormDataParam(""String_Node_Str"") InputStream uploadedInputStream,@FormDataParam(""String_Node_Str"") FormDataContentDisposition fileDetail,@FormDataParam(""String_Node_Str"") FormDataBodyPart body,@FormDataParam(""String_Node_Str"") QName artifactType,@FormDataParam(""String_Node_Str"") Set<QName> nodeTypes,@FormDataParam(""String_Node_Str"") QName infrastructureNodeType,@FormDataParam(""String_Node_Str"") Set<String> tags,@Context UriInfo uriInfo) throws IllegalArgumentException, JAXBException, IOException {
  if (this.connector.isWineryRepositoryAvailable()) {
    return Response.status(Status.SERVICE_UNAVAILABLE).build();
  }
  File tempFile=this.inputStream2File(uploadedInputStream,fileDetail.getFileName());
  try {
    QName xaasServiceTemplate=this.connector.createServiceTemplateFromXaaSPackage(tempFile,artifactType,nodeTypes,infrastructureNodeType,this.createTagMapFromTagSet(tags));
    String redirectUrl=Utilities.buildURI(this.uriInfo.getAbsolutePath().toString(),""String_Node_Str"" + Utilities.URLencode(xaasServiceTemplate.toString())).replace(""String_Node_Str"",""String_Node_Str"");
    return Response.created(URI.create(redirectUrl)).build();
  }
 catch (  URISyntaxException e) {
    e.printStackTrace();
  }
  return Response.serverError().build();
}","@POST @Consumes(MediaType.MULTIPART_FORM_DATA) public Response createFromArtefact(@FormDataParam(""String_Node_Str"") InputStream uploadedInputStream,@FormDataParam(""String_Node_Str"") FormDataContentDisposition fileDetail,@FormDataParam(""String_Node_Str"") FormDataBodyPart body,@FormDataParam(""String_Node_Str"") QName artifactType,@FormDataParam(""String_Node_Str"") Set<QName> nodeTypes,@FormDataParam(""String_Node_Str"") QName infrastructureNodeType,@FormDataParam(""String_Node_Str"") Set<String> tags,@Context UriInfo uriInfo) throws IllegalArgumentException, JAXBException, IOException {
  if (!this.connector.isWineryRepositoryAvailable()) {
    return Response.status(Status.SERVICE_UNAVAILABLE).build();
  }
  File tempFile=this.inputStream2File(uploadedInputStream,fileDetail.getFileName());
  try {
    QName xaasServiceTemplate=this.connector.createServiceTemplateFromXaaSPackage(tempFile,artifactType,nodeTypes,infrastructureNodeType,this.createTagMapFromTagSet(tags));
    String redirectUrl=Utilities.buildURI(this.uriInfo.getAbsolutePath().toString(),""String_Node_Str"" + Utilities.URLencode(xaasServiceTemplate.toString())).replace(""String_Node_Str"",""String_Node_Str"");
    return Response.created(URI.create(redirectUrl)).build();
  }
 catch (  URISyntaxException e) {
    e.printStackTrace();
  }
  return Response.serverError().build();
}"
41519,"public boolean isWineryRepositoryAvailable(){
  HttpGet get=new HttpGet();
  get.setHeader(""String_Node_Str"",""String_Node_Str"");
  try {
    get.setURI(new URI(this.wineryPath + ""String_Node_Str""));
    HttpResponse resp=this.client.execute(get);
    if (resp.getStatusLine().getStatusCode() < 400) {
      return true;
    }
  }
 catch (  URISyntaxException e) {
    e.printStackTrace();
  }
catch (  ClientProtocolException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  return false;
}","public boolean isWineryRepositoryAvailable(){
  HttpGet get=new HttpGet();
  get.setHeader(""String_Node_Str"",""String_Node_Str"");
  try {
    get.setURI(new URI(this.wineryPath + ""String_Node_Str""));
    HttpResponse resp=this.client.execute(get);
    EntityUtils.consume(resp.getEntity());
    if (resp.getStatusLine().getStatusCode() < 400) {
      return true;
    }
  }
 catch (  URISyntaxException e) {
    e.printStackTrace();
  }
catch (  ClientProtocolException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  return false;
}"
41520,"@POST @Consumes(MediaType.APPLICATION_XML) @Produces({MediaType.APPLICATION_XML,MediaType.TEXT_XML}) public Response createServiceInstance(@Context UriInfo uriInfo,String xml){
  log.debug(""String_Node_Str"",csarId,serviceTemplateID);
  IInstanceDataService service=InstanceDataServiceHandler.getInstanceDataService();
  try {
    ServiceInstance createdServiceInstance=service.createServiceInstance(csarId,serviceTemplateID);
    String corr=xml.substring(xml.indexOf(""String_Node_Str"") + 1,xml.indexOf(""String_Node_Str""));
    int serviceTemplateInstanceId=createdServiceInstance.getDBId();
    String instanceURL=createdServiceInstance.getServiceInstanceID().toString();
    log.debug(corr + ""String_Node_Str"" + corr+ ""String_Node_Str""+ instanceURL);
{
      BuildCorrelationToInstanceMapping.instance.correlateCorrelationIdToServiceTemplateInstanceId(corr,serviceTemplateInstanceId);
      PlanInvocationEngineHandler.planInvocationEngine.correctCorrelationToServiceTemplateInstanceIdMapping(csarId,serviceTemplateID,corr,serviceTemplateInstanceId);
    }
    SimpleXLink response=new SimpleXLink(uriInfo.getAbsolutePath().toString() + ""String_Node_Str"" + serviceTemplateInstanceId,""String_Node_Str"");
    log.debug(""String_Node_Str"" + response.getHref());
    return Response.ok(response).build();
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new GenericRestException(Status.INTERNAL_SERVER_ERROR,e.getMessage());
  }
}","@POST @Consumes(MediaType.APPLICATION_XML) @Produces({MediaType.APPLICATION_XML,MediaType.TEXT_XML}) public Response createServiceInstance(@Context UriInfo uriInfo,String xml){
}"
41521,"/** 
 * <p> This method assigns plugins to the already initialized BuildPlan and its TemplateBuildPlans. First there will be checked if any generic plugin can handle a template of the TopologyTemplate </p>
 * @param buildPlan a BuildPlan which is alread initialized
 * @param serviceTemplateName the name of the ServiceTemplate the BuildPlanbelongs to
 * @param map a PropertyMap which contains mappings from Template toProperty and to variable name of inside the BuidlPlan
 */
private void runPlugins(BuildPlan buildPlan,QName serviceTemplateId,PropertyMap map){
  for (  TemplateBuildPlan templatePlan : buildPlan.getTemplateBuildPlans()) {
    if (templatePlan.getNodeTemplate() != null) {
      AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
      PlanBuilder.LOG.debug(""String_Node_Str"" + nodeTemplate.getId());
      TemplatePlanContext context=new TemplatePlanContext(templatePlan,map,serviceTemplateId);
      IPlanBuilderTypePlugin plugin=this.canGenericPluginHandle(nodeTemplate);
      if (plugin == null) {
        PlanBuilder.LOG.debug(""String_Node_Str"",nodeTemplate.getId());
        ProvisioningChain chain=TemplatePlanBuilder.createProvisioningChain(nodeTemplate);
        if (chain == null) {
          PlanBuilder.LOG.warn(""String_Node_Str"",nodeTemplate.getId());
          continue;
        }
        chain.executeIAProvisioning(context);
        chain.executeDAProvisioning(context);
        chain.executeOperationProvisioning(context,this.opNames);
      }
 else {
        PlanBuilder.LOG.info(""String_Node_Str"",nodeTemplate.getId());
        plugin.handle(context);
      }
      for (      IPlanBuilderPostPhasePlugin postPhasePlugin : PluginRegistry.getPostPlugins()) {
        if (postPhasePlugin.canHandle(nodeTemplate)) {
          postPhasePlugin.handle(context,nodeTemplate);
        }
      }
    }
 else {
      AbstractRelationshipTemplate relationshipTemplate=templatePlan.getRelationshipTemplate();
      TemplatePlanContext context=new TemplatePlanContext(templatePlan,map,serviceTemplateId);
      if (!this.canGenericPluginHandle(relationshipTemplate)) {
        PlanBuilder.LOG.debug(""String_Node_Str"",relationshipTemplate.getId());
        ProvisioningChain sourceChain=TemplatePlanBuilder.createProvisioningChain(relationshipTemplate,true);
        ProvisioningChain targetChain=TemplatePlanBuilder.createProvisioningChain(relationshipTemplate,false);
        if (targetChain != null) {
          PlanBuilder.LOG.warn(""String_Node_Str"",relationshipTemplate.getId());
          targetChain.executeIAProvisioning(context);
          targetChain.executeOperationProvisioning(context,this.opNames);
        }
        if (sourceChain != null) {
          PlanBuilder.LOG.warn(""String_Node_Str"",relationshipTemplate.getId());
          sourceChain.executeIAProvisioning(context);
          sourceChain.executeOperationProvisioning(context,this.opNames);
        }
      }
 else {
        PlanBuilder.LOG.info(""String_Node_Str"",relationshipTemplate.getId());
        this.handleWithGenericPlugin(context,relationshipTemplate);
      }
      for (      IPlanBuilderPostPhasePlugin postPhasePlugin : PluginRegistry.getPostPlugins()) {
        if (postPhasePlugin.canHandle(relationshipTemplate)) {
          postPhasePlugin.handle(context,relationshipTemplate);
        }
      }
    }
  }
}","/** 
 * <p> This method assigns plugins to the already initialized BuildPlan and its TemplateBuildPlans. First there will be checked if any generic plugin can handle a template of the TopologyTemplate </p>
 * @param buildPlan a BuildPlan which is alread initialized
 * @param serviceTemplateName the name of the ServiceTemplate the BuildPlanbelongs to
 * @param map a PropertyMap which contains mappings from Template toProperty and to variable name of inside the BuidlPlan
 */
private void runPlugins(BuildPlan buildPlan,QName serviceTemplateId,PropertyMap map){
  for (  TemplateBuildPlan templatePlan : buildPlan.getTemplateBuildPlans()) {
    if (templatePlan.getNodeTemplate() != null) {
      AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
      PlanBuilder.LOG.debug(""String_Node_Str"" + nodeTemplate.getId());
      TemplatePlanContext context=new TemplatePlanContext(templatePlan,map,serviceTemplateId);
      IPlanBuilderTypePlugin plugin=this.canGenericPluginHandle(nodeTemplate);
      if (plugin == null) {
        PlanBuilder.LOG.debug(""String_Node_Str"",nodeTemplate.getId());
        ProvisioningChain chain=TemplatePlanBuilder.createProvisioningChain(nodeTemplate);
        if (chain == null) {
          PlanBuilder.LOG.warn(""String_Node_Str"",nodeTemplate.getId());
        }
 else {
          PlanBuilder.LOG.debug(""String_Node_Str"",nodeTemplate.getId());
          chain.executeIAProvisioning(context);
          chain.executeDAProvisioning(context);
          chain.executeOperationProvisioning(context,this.opNames);
        }
      }
 else {
        PlanBuilder.LOG.info(""String_Node_Str"",nodeTemplate.getId());
        plugin.handle(context);
      }
      for (      IPlanBuilderPostPhasePlugin postPhasePlugin : PluginRegistry.getPostPlugins()) {
        if (postPhasePlugin.canHandle(nodeTemplate)) {
          postPhasePlugin.handle(context,nodeTemplate);
        }
      }
    }
 else {
      AbstractRelationshipTemplate relationshipTemplate=templatePlan.getRelationshipTemplate();
      TemplatePlanContext context=new TemplatePlanContext(templatePlan,map,serviceTemplateId);
      if (!this.canGenericPluginHandle(relationshipTemplate)) {
        PlanBuilder.LOG.debug(""String_Node_Str"",relationshipTemplate.getId());
        ProvisioningChain sourceChain=TemplatePlanBuilder.createProvisioningChain(relationshipTemplate,true);
        ProvisioningChain targetChain=TemplatePlanBuilder.createProvisioningChain(relationshipTemplate,false);
        if (targetChain != null) {
          PlanBuilder.LOG.warn(""String_Node_Str"",relationshipTemplate.getId());
          targetChain.executeIAProvisioning(context);
          targetChain.executeOperationProvisioning(context,this.opNames);
        }
        if (sourceChain != null) {
          PlanBuilder.LOG.warn(""String_Node_Str"",relationshipTemplate.getId());
          sourceChain.executeIAProvisioning(context);
          sourceChain.executeOperationProvisioning(context,this.opNames);
        }
      }
 else {
        PlanBuilder.LOG.info(""String_Node_Str"",relationshipTemplate.getId());
        this.handleWithGenericPlugin(context,relationshipTemplate);
      }
      for (      IPlanBuilderPostPhasePlugin postPhasePlugin : PluginRegistry.getPostPlugins()) {
        if (postPhasePlugin.canHandle(relationshipTemplate)) {
          postPhasePlugin.handle(context,relationshipTemplate);
        }
      }
    }
  }
}"
41522,"@Override @WebMethod(exclude=true) public Document getServiceInstanceProperties(URI serviceInstanceID,List<QName> propertiesList) throws ReferenceNotFoundException {
  List<ServiceInstance> serviceInstances=this.getServiceInstances(serviceInstanceID,null,null);
  if ((serviceInstances == null) || (serviceInstances.size() != 1)) {
    String msg=String.format(""String_Node_Str"",serviceInstanceID);
    InstanceDataServiceImpl.LOG.warn(msg);
    throw new ReferenceNotFoundException(msg);
  }
  ServiceInstance serviceInstance=serviceInstances.get(0);
  return serviceInstance.getProperties();
}","@Override @WebMethod(exclude=true) public Document getServiceInstanceProperties(URI serviceInstanceID,List<QName> propertiesList) throws ReferenceNotFoundException {
  List<ServiceInstance> serviceInstances=this.getServiceInstances(serviceInstanceID,null,null);
  if ((serviceInstances == null) || (serviceInstances.size() != 1)) {
    String msg=String.format(""String_Node_Str"",serviceInstanceID);
    InstanceDataServiceImpl.LOG.warn(msg);
    throw new ReferenceNotFoundException(msg);
  }
  ServiceInstance serviceInstance=serviceInstances.get(0);
  this.updateServiceInstanceProperties(serviceInstance);
  return serviceInstance.getProperties();
}"
41523,"private NodeInstance getNodeInstanceFromMappingObject(ServiceInstance serviceInstance,Object obj){
  if (obj instanceof TNodeTemplate) {
    TNodeTemplate template=(TNodeTemplate)obj;
    List<NodeInstance> nodeInstances=serviceInstance.getNodeInstances();
    for (    NodeInstance nodeInstance : nodeInstances) {
      if (nodeInstance.getNodeTemplateID().getLocalPart().equals(template.getId())) {
        return nodeInstance;
      }
    }
  }
  return null;
}","private NodeInstance getNodeInstanceFromMappingObject(ServiceInstance serviceInstance,Object obj){
  if (obj instanceof TNodeTemplate) {
    TNodeTemplate template=(TNodeTemplate)obj;
    List<NodeInstance> nodeInstances=this.getNodeInstances(null,null,null,serviceInstance.getServiceInstanceID());
    if (nodeInstances == null) {
      return null;
    }
    for (    NodeInstance nodeInstance : nodeInstances) {
      if (nodeInstance.getNodeTemplateID().getLocalPart().equals(template.getId())) {
        return nodeInstance;
      }
    }
  }
  return null;
}"
41524,"@WebMethod(exclude=true) private void updateServiceInstanceProperties(ServiceInstance serviceInstance){
  if (serviceInstance.getProperties() == null) {
    return;
  }
  TBoundaryDefinitions boundaryDefs=InstanceDataServiceImpl.toscaEngineService.getBoundaryDefinitionsOfServiceTemplate(serviceInstance.getCSAR_ID(),serviceInstance.getServiceTemplateID());
  if ((boundaryDefs == null) || (boundaryDefs.getProperties() == null) || (boundaryDefs.getProperties().getPropertyMappings() == null)) {
    return;
  }
  Element properties=(Element)serviceInstance.getProperties().getFirstChild();
  for (  TPropertyMapping mapping : boundaryDefs.getProperties().getPropertyMappings().getPropertyMapping()) {
    String serviceTemplatePropertyQuery=mapping.getServiceTemplatePropertyRef();
    List<Element> serviceTemplatePropertyElements=this.queryElementList(properties,serviceTemplatePropertyQuery);
    if (serviceTemplatePropertyElements.size() != 1) {
      continue;
    }
    if (this.isConcatQuery(mapping.getTargetPropertyRef())) {
      String propertyValue=this.generatePropertyValueFromConcatQuery(mapping.getTargetPropertyRef(),this.getNodeInstances(null,null,null,serviceInstance.getServiceInstanceID()));
      serviceTemplatePropertyElements.get(0).setTextContent(propertyValue);
    }
 else {
      NodeInstance nodeInstance=this.getNodeInstanceFromMappingObject(serviceInstance,mapping.getTargetObjectRef());
      Document nodeProperties=nodeInstance.getProperties();
      if (nodeProperties == null) {
        continue;
      }
      Element nodePropertiesRoot=(Element)nodeProperties.getFirstChild();
      String nodeTemplatePropertyQuery=mapping.getTargetPropertyRef();
      List<Element> nodePropertyElements=this.queryElementList(nodePropertiesRoot,nodeTemplatePropertyQuery);
      if (nodePropertyElements.size() != 1) {
        continue;
      }
      serviceTemplatePropertyElements.get(0).setTextContent(nodePropertyElements.get(0).getTextContent());
    }
  }
  serviceInstance.setProperties(properties.getOwnerDocument());
  this.siDAO.storeServiceInstance(serviceInstance);
}","@WebMethod(exclude=true) private void updateServiceInstanceProperties(ServiceInstance serviceInstance){
  if (serviceInstance.getProperties() == null) {
    return;
  }
  TBoundaryDefinitions boundaryDefs=InstanceDataServiceImpl.toscaEngineService.getBoundaryDefinitionsOfServiceTemplate(serviceInstance.getCSAR_ID(),serviceInstance.getServiceTemplateID());
  if ((boundaryDefs == null) || (boundaryDefs.getProperties() == null) || (boundaryDefs.getProperties().getPropertyMappings() == null)) {
    return;
  }
  Element properties=(Element)serviceInstance.getProperties().getFirstChild();
  for (  TPropertyMapping mapping : boundaryDefs.getProperties().getPropertyMappings().getPropertyMapping()) {
    String serviceTemplatePropertyQuery=mapping.getServiceTemplatePropertyRef();
    List<Element> serviceTemplatePropertyElements=this.queryElementList(properties,serviceTemplatePropertyQuery);
    if (serviceTemplatePropertyElements.size() != 1) {
      continue;
    }
    if (this.isConcatQuery(mapping.getTargetPropertyRef())) {
      String propertyValue=this.generatePropertyValueFromConcatQuery(mapping.getTargetPropertyRef(),this.getNodeInstances(null,null,null,serviceInstance.getServiceInstanceID()));
      serviceTemplatePropertyElements.get(0).setTextContent(propertyValue);
    }
 else {
      NodeInstance nodeInstance=this.getNodeInstanceFromMappingObject(serviceInstance,mapping.getTargetObjectRef());
      if (nodeInstance == null) {
        continue;
      }
      Document nodeProperties=nodeInstance.getProperties();
      if (nodeProperties == null) {
        continue;
      }
      Element nodePropertiesRoot=(Element)nodeProperties.getFirstChild();
      String nodeTemplatePropertyQuery=mapping.getTargetPropertyRef();
      List<Element> nodePropertyElements=this.queryElementList(nodePropertiesRoot,nodeTemplatePropertyQuery);
      if (nodePropertyElements.size() != 1) {
        continue;
      }
      serviceTemplatePropertyElements.get(0).setTextContent(nodePropertyElements.get(0).getTextContent());
    }
  }
  serviceInstance.setProperties(properties.getOwnerDocument());
  this.siDAO.storeServiceInstance(serviceInstance);
}"
41525,"@Override public void process(Exchange exchange) throws Exception {
  Set<String> messageIDs=ManagementBusPluginSoapHttpServiceImpl.getMessageIDs();
  CallbackProcessor.LOG.debug(""String_Node_Str"",messageIDs.toString());
  @SuppressWarnings(""String_Node_Str"") List<SoapHeader> soapHeaders=(List<SoapHeader>)exchange.getIn().getHeader(Header.HEADER_LIST);
  Element element;
  if (soapHeaders != null) {
    for (    SoapHeader header : soapHeaders) {
      element=(Element)header.getObject();
      exchange.getIn().setHeader(element.getLocalName(),element.getTextContent());
    }
  }
  String message=exchange.getIn().getBody(String.class);
  Map<String,Object> headers=exchange.getIn().getHeaders();
  CallbackProcessor.LOG.debug(""String_Node_Str"");
  for (  String messageID : messageIDs) {
    if (message.contains(messageID) || headers.containsValue(messageID)) {
      CallbackProcessor.LOG.debug(""String_Node_Str"",messageID);
      MessageFactory messageFactory=MessageFactory.newInstance();
      InputStream inputStream=new ByteArrayInputStream(message.getBytes(""String_Node_Str""));
      SOAPMessage soapMessage=messageFactory.createMessage(null,inputStream);
      exchange.getIn().setHeader(""String_Node_Str"",messageID);
      exchange.getIn().setHeader(""String_Node_Str"",""String_Node_Str"");
      Document doc;
      try {
        doc=soapMessage.getSOAPBody().extractContentAsDocument();
        exchange.getIn().setBody(doc);
      }
 catch (      SOAPException e) {
        doc=soapMessage.getSOAPPart().getEnvelope().getOwnerDocument();
        CallbackProcessor.LOG.warn(""String_Node_Str"");
        exchange.getIn().setBody(doc);
      }
      break;
    }
  }
}","@Override public void process(Exchange exchange) throws Exception {
  Set<String> messageIDs=ManagementBusPluginSoapHttpServiceImpl.getMessageIDs();
  CallbackProcessor.LOG.debug(""String_Node_Str"",messageIDs.toString());
  @SuppressWarnings(""String_Node_Str"") List<SoapHeader> soapHeaders=(List<SoapHeader>)exchange.getIn().getHeader(Header.HEADER_LIST);
  Element element;
  if (soapHeaders != null) {
    for (    SoapHeader header : soapHeaders) {
      element=(Element)header.getObject();
      exchange.getIn().setHeader(element.getLocalName(),element.getTextContent());
    }
  }
  String message=exchange.getIn().getBody(String.class);
  Map<String,Object> headers=exchange.getIn().getHeaders();
  CallbackProcessor.LOG.debug(""String_Node_Str"");
  for (  String messageID : messageIDs) {
    if (message.contains(""String_Node_Str"" + messageID + ""String_Node_Str"") || headers.containsValue(messageID)) {
      CallbackProcessor.LOG.debug(""String_Node_Str"",messageID);
      MessageFactory messageFactory=MessageFactory.newInstance();
      InputStream inputStream=new ByteArrayInputStream(message.getBytes(""String_Node_Str""));
      SOAPMessage soapMessage=messageFactory.createMessage(null,inputStream);
      exchange.getIn().setHeader(""String_Node_Str"",messageID);
      exchange.getIn().setHeader(""String_Node_Str"",""String_Node_Str"");
      Document doc;
      try {
        doc=soapMessage.getSOAPBody().extractContentAsDocument();
        exchange.getIn().setBody(doc);
      }
 catch (      SOAPException e) {
        doc=soapMessage.getSOAPPart().getEnvelope().getOwnerDocument();
        CallbackProcessor.LOG.warn(""String_Node_Str"");
        exchange.getIn().setBody(doc);
      }
      break;
    }
  }
}"
41526,"private Response storeCSAR(String fileName,InputStream uploadedInputStream){
  File tmpDir=new File(System.getProperty(""String_Node_Str"") + System.getProperty(""String_Node_Str"") + Long.toString(System.currentTimeMillis()));
  tmpDir.mkdir();
  File uploadFile=new File(tmpDir.getAbsoluteFile() + System.getProperty(""String_Node_Str"") + fileName);
  OutputStream out;
  try {
    out=new FileOutputStream(uploadFile);
    int read=0;
    byte[] bytes=new byte[1024];
    while ((read=uploadedInputStream.read(bytes)) != -1) {
      out.write(bytes,0,read);
    }
    uploadedInputStream.close();
    CSARsResource.LOG.debug(""String_Node_Str"" + uploadFile.getAbsolutePath() + ""String_Node_Str""+ uploadFile.getTotalSpace());
    out.flush();
    out.close();
    CSARID csarID=null;
    csarID=fileHandler.storeCSAR(uploadFile.toPath());
    csarID=startPlanBuilder(csarID);
    if (csarID != null) {
      CSARsResource.LOG.info(""String_Node_Str"",csarID.toString());
      CSARsResource.LOG.trace(""String_Node_Str"" + (null != control));
      control.setDeploymentProcessStateStored(csarID);
      if (control.invokeTOSCAProcessing(csarID)) {
        List<QName> serviceTemplates=ToscaServiceHandler.getToscaEngineService().getToscaReferenceMapper().getServiceTemplateIDsContainedInCSAR(csarID);
        for (        QName serviceTemplate : serviceTemplates) {
          CSARsResource.LOG.debug(""String_Node_Str"" + serviceTemplate + ""String_Node_Str""+ csarID+ ""String_Node_Str"");
          if (!control.invokeIADeployment(csarID,serviceTemplate)) {
            break;
          }
          CSARsResource.LOG.debug(""String_Node_Str"" + serviceTemplate + ""String_Node_Str""+ csarID+ ""String_Node_Str"");
          CSARsResource.LOG.debug(""String_Node_Str"");
          if (!control.invokePlanDeployment(csarID,serviceTemplate)) {
            break;
          }
        }
        return Response.created(URI.create(Utilities.buildURI(uriInfo.getAbsolutePath().toString(),csarID.toString()))).build();
      }
    }
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  UserException e) {
    e.printStackTrace();
  }
catch (  SystemException e) {
    e.printStackTrace();
  }
  CSARsResource.LOG.error(""String_Node_Str"",uploadFile.getAbsolutePath());
  return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
}","private Response storeCSAR(String fileName,InputStream uploadedInputStream){
  File tmpDir=FileAccessServiceHandler.getFileAccessService().getTemp();
  tmpDir.mkdir();
  File uploadFile=new File(tmpDir.getAbsoluteFile() + System.getProperty(""String_Node_Str"") + fileName);
  OutputStream out;
  try {
    out=new FileOutputStream(uploadFile);
    int read=0;
    byte[] bytes=new byte[1024];
    while ((read=uploadedInputStream.read(bytes)) != -1) {
      out.write(bytes,0,read);
    }
    uploadedInputStream.close();
    CSARsResource.LOG.debug(""String_Node_Str"" + uploadFile.getAbsolutePath() + ""String_Node_Str""+ uploadFile.getTotalSpace());
    out.flush();
    out.close();
    CSARID csarID=null;
    csarID=fileHandler.storeCSAR(uploadFile.toPath());
    csarID=startPlanBuilder(csarID);
    if (csarID != null) {
      CSARsResource.LOG.info(""String_Node_Str"",csarID.toString());
      CSARsResource.LOG.trace(""String_Node_Str"" + (null != control));
      control.setDeploymentProcessStateStored(csarID);
      if (control.invokeTOSCAProcessing(csarID)) {
        List<QName> serviceTemplates=ToscaServiceHandler.getToscaEngineService().getToscaReferenceMapper().getServiceTemplateIDsContainedInCSAR(csarID);
        for (        QName serviceTemplate : serviceTemplates) {
          CSARsResource.LOG.debug(""String_Node_Str"" + serviceTemplate + ""String_Node_Str""+ csarID+ ""String_Node_Str"");
          if (!control.invokeIADeployment(csarID,serviceTemplate)) {
            break;
          }
          CSARsResource.LOG.debug(""String_Node_Str"" + serviceTemplate + ""String_Node_Str""+ csarID+ ""String_Node_Str"");
          CSARsResource.LOG.debug(""String_Node_Str"");
          if (!control.invokePlanDeployment(csarID,serviceTemplate)) {
            break;
          }
        }
        return Response.created(URI.create(Utilities.buildURI(uriInfo.getAbsolutePath().toString(),csarID.toString()))).build();
      }
    }
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  UserException e) {
    e.printStackTrace();
  }
catch (  SystemException e) {
    e.printStackTrace();
  }
  CSARsResource.LOG.error(""String_Node_Str"",uploadFile.getAbsolutePath());
  return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
}"
41527,"/** 
 * Exports the given BuildPlan to the given URI location
 * @param destination the URI to export to
 * @param buildPlan the BuildPlan to export
 * @return true iff exporting the BuildPlan was successful
 * @throws IOException is thrown when reading/writing the file fails
 * @throws JAXBException is thrown when writing with JAXB fails
 */
public boolean export(URI destination,BuildPlan buildPlan) throws IOException, JAXBException {
  if (!new File(destination).getName().contains(""String_Node_Str"")) {
    return false;
  }
  List<File> importedFiles=buildPlan.getImportedFiles();
  SimpleFileExporter.LOG.debug(""String_Node_Str"");
  for (  File file : importedFiles) {
    SimpleFileExporter.LOG.debug(file.getAbsolutePath());
  }
  List<Element> importElements=buildPlan.getBpelImportElements();
  SimpleFileExporter.LOG.debug(""String_Node_Str"");
  for (  Element element : importElements) {
    SimpleFileExporter.LOG.debug(""String_Node_Str"" + element.getLocalName());
    SimpleFileExporter.LOG.debug(""String_Node_Str"" + element.getAttribute(""String_Node_Str""));
  }
  GenericWsdlWrapper wsdl=buildPlan.getWsdl();
  File tempDir=FileUtils.getTempDirectory();
  SimpleFileExporter.LOG.debug(""String_Node_Str"" + tempDir.getAbsolutePath());
  File tempFolder=new File(tempDir,Long.toString(System.currentTimeMillis()));
  tempFolder.mkdir();
  SimpleFileExporter.LOG.debug(""String_Node_Str"" + tempFolder.getAbsolutePath());
  List<File> exportedFiles=new ArrayList<File>();
  for (  File importedFile : importedFiles) {
    for (    Element importElement : importElements) {
      String filePath=importedFile.getAbsolutePath();
      String locationPath=importElement.getAttribute(""String_Node_Str"");
      SimpleFileExporter.LOG.debug(""String_Node_Str"");
      SimpleFileExporter.LOG.debug(filePath);
      SimpleFileExporter.LOG.debug(""String_Node_Str"");
      SimpleFileExporter.LOG.debug(locationPath);
      if (importedFile.getAbsolutePath().trim().equals(importElement.getAttribute(""String_Node_Str"").trim())) {
        String fileName=importedFile.getName();
        SimpleFileExporter.LOG.debug(""String_Node_Str"" + fileName);
        importElement.setAttribute(""String_Node_Str"",fileName);
        File fileLocationInDir=new File(tempFolder,fileName);
        FileUtils.copyFile(importedFile,fileLocationInDir);
        exportedFiles.add(fileLocationInDir);
      }
    }
  }
  SimpleFileExporter.LOG.debug(""String_Node_Str"");
  Deploy deployment=buildPlan.getDeploymentDeskriptor();
  try {
    this.rewriteServiceNames(deployment,exportedFiles,buildPlan.getCsarName());
  }
 catch (  WSDLException e) {
    LOG.warn(""String_Node_Str"",e);
  }
catch (  FileNotFoundException e) {
    LOG.warn(""String_Node_Str"",e);
  }
  File deployXmlFile=new File(tempFolder,""String_Node_Str"");
  deployXmlFile.createNewFile();
  JAXBContext jaxbContext=JAXBContext.newInstance(Deploy.class);
  Marshaller m=jaxbContext.createMarshaller();
  m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
  m.marshal(deployment,deployXmlFile);
  File wsdlFile=new File(tempFolder,wsdl.getFileName());
  FileUtils.writeStringToFile(wsdlFile,wsdl.getFinalizedWsdlAsString());
  File bpelFile=new File(tempFolder,wsdl.getFileName().replace(""String_Node_Str"",""String_Node_Str""));
  try {
    this.writeBPELDocToFile(bpelFile,buildPlan.getBpelDocument());
  }
 catch (  TransformerException e) {
    SimpleFileExporter.LOG.error(""String_Node_Str"",e);
    return false;
  }
  ServiceReference<?> servRef=FrameworkUtil.getBundle(this.getClass()).getBundleContext().getServiceReference(IFileAccessService.class.getName());
  IFileAccessService service=(IFileAccessService)FrameworkUtil.getBundle(this.getClass()).getBundleContext().getService(servRef);
  service.zip(tempFolder,new File(destination));
  return true;
}","/** 
 * Exports the given BuildPlan to the given URI location
 * @param destination the URI to export to
 * @param buildPlan the BuildPlan to export
 * @return true iff exporting the BuildPlan was successful
 * @throws IOException is thrown when reading/writing the file fails
 * @throws JAXBException is thrown when writing with JAXB fails
 */
public boolean export(URI destination,BuildPlan buildPlan) throws IOException, JAXBException {
  if (!new File(destination).getName().contains(""String_Node_Str"")) {
    return false;
  }
  List<File> importedFiles=buildPlan.getImportedFiles();
  SimpleFileExporter.LOG.debug(""String_Node_Str"");
  for (  File file : importedFiles) {
    SimpleFileExporter.LOG.debug(file.getAbsolutePath());
  }
  List<Element> importElements=buildPlan.getBpelImportElements();
  SimpleFileExporter.LOG.debug(""String_Node_Str"");
  for (  Element element : importElements) {
    SimpleFileExporter.LOG.debug(""String_Node_Str"" + element.getLocalName());
    SimpleFileExporter.LOG.debug(""String_Node_Str"" + element.getAttribute(""String_Node_Str""));
  }
  GenericWsdlWrapper wsdl=buildPlan.getWsdl();
  File tempDir=this.getFileAccessService().getTemp();
  SimpleFileExporter.LOG.debug(""String_Node_Str"" + tempDir.getAbsolutePath());
  File tempFolder=new File(tempDir,Long.toString(System.currentTimeMillis()));
  tempFolder.mkdir();
  SimpleFileExporter.LOG.debug(""String_Node_Str"" + tempFolder.getAbsolutePath());
  List<File> exportedFiles=new ArrayList<File>();
  for (  File importedFile : importedFiles) {
    for (    Element importElement : importElements) {
      String filePath=importedFile.getAbsolutePath();
      String locationPath=importElement.getAttribute(""String_Node_Str"");
      SimpleFileExporter.LOG.debug(""String_Node_Str"");
      SimpleFileExporter.LOG.debug(filePath);
      SimpleFileExporter.LOG.debug(""String_Node_Str"");
      SimpleFileExporter.LOG.debug(locationPath);
      if (importedFile.getAbsolutePath().trim().equals(importElement.getAttribute(""String_Node_Str"").trim())) {
        String fileName=importedFile.getName();
        SimpleFileExporter.LOG.debug(""String_Node_Str"" + fileName);
        importElement.setAttribute(""String_Node_Str"",fileName);
        File fileLocationInDir=new File(tempFolder,fileName);
        FileUtils.copyFile(importedFile,fileLocationInDir);
        exportedFiles.add(fileLocationInDir);
      }
    }
  }
  SimpleFileExporter.LOG.debug(""String_Node_Str"");
  Deploy deployment=buildPlan.getDeploymentDeskriptor();
  try {
    this.rewriteServiceNames(deployment,exportedFiles,buildPlan.getCsarName());
  }
 catch (  WSDLException e) {
    LOG.warn(""String_Node_Str"",e);
  }
catch (  FileNotFoundException e) {
    LOG.warn(""String_Node_Str"",e);
  }
  File deployXmlFile=new File(tempFolder,""String_Node_Str"");
  deployXmlFile.createNewFile();
  JAXBContext jaxbContext=JAXBContext.newInstance(Deploy.class);
  Marshaller m=jaxbContext.createMarshaller();
  m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
  m.marshal(deployment,deployXmlFile);
  File wsdlFile=new File(tempFolder,wsdl.getFileName());
  FileUtils.writeStringToFile(wsdlFile,wsdl.getFinalizedWsdlAsString());
  File bpelFile=new File(tempFolder,wsdl.getFileName().replace(""String_Node_Str"",""String_Node_Str""));
  try {
    this.writeBPELDocToFile(bpelFile,buildPlan.getBpelDocument());
  }
 catch (  TransformerException e) {
    SimpleFileExporter.LOG.error(""String_Node_Str"",e);
    return false;
  }
  ServiceReference<?> servRef=FrameworkUtil.getBundle(this.getClass()).getBundleContext().getServiceReference(IFileAccessService.class.getName());
  IFileAccessService service=(IFileAccessService)FrameworkUtil.getBundle(this.getClass()).getBundleContext().getService(servRef);
  service.zip(tempFolder,new File(destination));
  return true;
}"
41528,"private String injectBPELVariables(String targetPropertyRef,PropertyMap propMap){
  String testQuery=targetPropertyRef.trim();
  if (!testQuery.endsWith(""String_Node_Str"")) {
    return null;
  }
  int functionOpeningBracket=testQuery.indexOf(""String_Node_Str"");
  String functionString=testQuery.substring(0,functionOpeningBracket);
  if (!functionString.equals(""String_Node_Str"")) {
    return null;
  }
  String functionContent=testQuery.substring(functionOpeningBracket + 1,testQuery.lastIndexOf(""String_Node_Str"")).trim();
  String[] functionParts=functionContent.split(""String_Node_Str"");
  List<String> augmentedFunctionParts=new ArrayList<String>();
  for (  String functionPart : functionParts) {
    if (functionPart.startsWith(""String_Node_Str"")) {
      augmentedFunctionParts.add(functionPart);
    }
 else     if (functionPart.split(""String_Node_Str"").length == 3) {
      String[] queryParts=functionPart.split(""String_Node_Str"");
      if (!queryParts[1].equals(""String_Node_Str"")) {
        return null;
      }
      String nodeTemplateName=queryParts[0];
      String propertyName=queryParts[2];
      Map<String,String> propertyName2BPELVarMap=propMap.getPropertyMappingMap(nodeTemplateName);
      if (propertyName2BPELVarMap == null) {
        return null;
      }
 else       if (propertyName2BPELVarMap.isEmpty()) {
        return null;
      }
      String bpelVarName=propertyName2BPELVarMap.get(propertyName);
      if (bpelVarName == null) {
        return null;
      }
      augmentedFunctionParts.add(""String_Node_Str"" + bpelVarName);
    }
  }
  String resultString=functionString + ""String_Node_Str"";
  for (  String functionPart : augmentedFunctionParts) {
    resultString+=functionPart + ""String_Node_Str"";
  }
  resultString=resultString.substring(0,resultString.length() - 1) + ""String_Node_Str"";
  return resultString;
}","private String injectBPELVariables(String targetPropertyRef,PropertyMap propMap){
  String testQuery=targetPropertyRef.trim();
  if (!testQuery.endsWith(""String_Node_Str"")) {
    return null;
  }
  int functionOpeningBracket=testQuery.indexOf(""String_Node_Str"");
  String functionString=testQuery.substring(0,functionOpeningBracket);
  if (!functionString.equals(""String_Node_Str"")) {
    return null;
  }
  String functionContent=testQuery.substring(functionOpeningBracket + 1,testQuery.lastIndexOf(""String_Node_Str"")).trim();
  String[] functionParts=functionContent.split(""String_Node_Str"");
  List<String> augmentedFunctionParts=new ArrayList<String>();
  for (  String functionPart : functionParts) {
    if (functionPart.trim().startsWith(""String_Node_Str"")) {
      augmentedFunctionParts.add(functionPart);
    }
 else     if (functionPart.trim().split(""String_Node_Str"").length == 3) {
      String[] queryParts=functionPart.trim().split(""String_Node_Str"");
      if (!queryParts[1].equals(""String_Node_Str"")) {
        return null;
      }
      String nodeTemplateName=queryParts[0];
      String propertyName=queryParts[2];
      Map<String,String> propertyName2BPELVarMap=propMap.getPropertyMappingMap(nodeTemplateName);
      if (propertyName2BPELVarMap == null) {
        return null;
      }
 else       if (propertyName2BPELVarMap.isEmpty()) {
        return null;
      }
      String bpelVarName=propertyName2BPELVarMap.get(propertyName);
      if (bpelVarName == null) {
        return null;
      }
      augmentedFunctionParts.add(""String_Node_Str"" + bpelVarName);
    }
  }
  String resultString=functionString + ""String_Node_Str"";
  for (  String functionPart : augmentedFunctionParts) {
    resultString+=functionPart + ""String_Node_Str"";
  }
  resultString=resultString.substring(0,resultString.length() - 1) + ""String_Node_Str"";
  return resultString;
}"
41529,"private Variable appendBPELAssignOperationShScript(TemplatePlanContext templateContext,AbstractOperation operation,AbstractArtifactReference reference,AbstractImplementationArtifact ia){
  Map<String,Variable> inputMappings=new HashMap<String,Variable>();
  String runShScriptString=""String_Node_Str"" + templateContext.getCSARFileName() + ""String_Node_Str""+ templateContext.getCSARFileName()+ ""String_Node_Str""+ reference.getReference()+ ""String_Node_Str""+ this.createDANamePathMapEnvVar(templateContext,ia);
  String runShScriptStringVarName=""String_Node_Str"" + templateContext.getIdForNames();
  String xpathQueryPrefix=""String_Node_Str"";
  String xpathQuerySuffix=""String_Node_Str"";
  for (  AbstractParameter parameter : operation.getInputParameters()) {
    Variable var=templateContext.getPropertyVariable(parameter.getName());
    if (var == null) {
      var=templateContext.getPropertyVariable(parameter.getName(),true);
      if (var == null) {
        var=templateContext.getPropertyVariable(parameter.getName(),false);
      }
    }
    inputMappings.put(parameter.getName(),var);
    runShScriptString+=parameter.getName() + ""String_Node_Str"" + parameter.getName()+ ""String_Node_Str"";
    xpathQueryPrefix+=""String_Node_Str"";
    xpathQuerySuffix+=""String_Node_Str"" + parameter.getName() + ""String_Node_Str"";
    if (var == null) {
      xpathQuerySuffix+=""String_Node_Str"" + templateContext.getPlanRequestMessageName() + ""String_Node_Str""+ parameter.getName()+ ""String_Node_Str"";
    }
 else {
      xpathQuerySuffix+=""String_Node_Str"" + var.getName() + ""String_Node_Str"";
    }
  }
  runShScriptString+=""String_Node_Str"" + templateContext.getCSARFileName() + ""String_Node_Str""+ reference.getReference();
  String logFilePath=""String_Node_Str"" + templateContext.getCSARFileName() + ""String_Node_Str""+ templateContext.getTemplateBuildPlanName()+ ""String_Node_Str"";
  runShScriptString+=""String_Node_Str"" + logFilePath;
  runShScriptString+=""String_Node_Str"" + logFilePath;
  Variable runShScriptStringVar=templateContext.createGlobalStringVariable(runShScriptStringVarName,runShScriptString);
  try {
    String xpathQuery=xpathQueryPrefix + ""String_Node_Str"" + runShScriptStringVar.getName()+ xpathQuerySuffix;
    Node assignNode=this.loadAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"",xpathQuery,runShScriptStringVar.getName());
    assignNode=templateContext.importNode(assignNode);
    templateContext.getProvisioningPhaseElement().appendChild(assignNode);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  SAXException e) {
    LOG.error(""String_Node_Str"",e);
  }
  return runShScriptStringVar;
}","private Variable appendBPELAssignOperationShScript(TemplatePlanContext templateContext,AbstractOperation operation,AbstractArtifactReference reference,AbstractImplementationArtifact ia,Map<AbstractParameter,Variable> inputMappings){
  String runShScriptString=""String_Node_Str"" + templateContext.getCSARFileName() + ""String_Node_Str""+ templateContext.getCSARFileName()+ ""String_Node_Str""+ reference.getReference()+ ""String_Node_Str""+ this.createDANamePathMapEnvVar(templateContext,ia);
  String runShScriptStringVarName=""String_Node_Str"" + templateContext.getIdForNames();
  String xpathQueryPrefix=""String_Node_Str"";
  String xpathQuerySuffix=""String_Node_Str"";
  for (  AbstractParameter parameter : operation.getInputParameters()) {
    Variable var=inputMappings.get(parameter);
    runShScriptString+=parameter.getName() + ""String_Node_Str"" + parameter.getName()+ ""String_Node_Str"";
    xpathQueryPrefix+=""String_Node_Str"";
    xpathQuerySuffix+=""String_Node_Str"" + parameter.getName() + ""String_Node_Str"";
    if (var == null) {
      xpathQuerySuffix+=""String_Node_Str"" + templateContext.getPlanRequestMessageName() + ""String_Node_Str""+ parameter.getName()+ ""String_Node_Str"";
    }
 else {
      xpathQuerySuffix+=""String_Node_Str"" + var.getName() + ""String_Node_Str"";
    }
  }
  runShScriptString+=""String_Node_Str"" + templateContext.getCSARFileName() + ""String_Node_Str""+ reference.getReference();
  String logFilePath=""String_Node_Str"" + templateContext.getCSARFileName() + ""String_Node_Str""+ templateContext.getTemplateBuildPlanName()+ ""String_Node_Str"";
  runShScriptString+=""String_Node_Str"" + logFilePath;
  runShScriptString+=""String_Node_Str"" + logFilePath;
  Variable runShScriptStringVar=templateContext.createGlobalStringVariable(runShScriptStringVarName,runShScriptString);
  try {
    String xpathQuery=xpathQueryPrefix + ""String_Node_Str"" + runShScriptStringVar.getName()+ xpathQuerySuffix;
    Node assignNode=this.loadAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"",xpathQuery,runShScriptStringVar.getName());
    assignNode=templateContext.importNode(assignNode);
    templateContext.getProvisioningPhaseElement().appendChild(assignNode);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  SAXException e) {
    LOG.error(""String_Node_Str"",e);
  }
  return runShScriptStringVar;
}"
41530,"public boolean handle(TemplatePlanContext templateContext,AbstractOperation operation,AbstractImplementationArtifact ia,Map<AbstractParameter,Variable> param2propertyMapping){
  AbstractNodeTemplate infrastructureNodeTemplate=this.findInfrastructureNode(templateContext.getInfrastructureNodes());
  if (infrastructureNodeTemplate == null) {
    return false;
  }
  Variable runShScriptStringVar=null;
  AbstractArtifactReference scriptRef=this.fetchScriptRefFromIA(ia);
  if (scriptRef == null) {
    return false;
  }
  runShScriptStringVar=this.appendBPELAssignOperationShScript(templateContext,operation,scriptRef,ia);
  Variable ipStringVariable=null;
  for (  String serverIp : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineIPPropertyNames()) {
    ipStringVariable=templateContext.getPropertyVariable(infrastructureNodeTemplate,serverIp);
    if (ipStringVariable == null) {
      ipStringVariable=templateContext.getPropertyVariable(serverIp,true);
      if (ipStringVariable == null) {
        ipStringVariable=templateContext.getPropertyVariable(serverIp,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  Variable userStringVariable=null;
  for (  String vmUserName : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    userStringVariable=templateContext.getPropertyVariable(infrastructureNodeTemplate,vmUserName);
    if (userStringVariable == null) {
      userStringVariable=templateContext.getPropertyVariable(vmUserName,true);
      if (userStringVariable == null) {
        userStringVariable=templateContext.getPropertyVariable(vmUserName,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  Variable passwdStringVariable=null;
  for (  String vmUserPassword : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    passwdStringVariable=templateContext.getPropertyVariable(infrastructureNodeTemplate,vmUserPassword);
    if (passwdStringVariable == null) {
      passwdStringVariable=templateContext.getPropertyVariable(vmUserPassword,true);
      if (passwdStringVariable == null) {
        passwdStringVariable=templateContext.getPropertyVariable(vmUserPassword,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (this.isNull(runShScriptStringVar,ipStringVariable,userStringVariable,passwdStringVariable)) {
    return false;
  }
  Map<String,Variable> payloadVariableMapping=new HashMap<String,Variable>();
  for (  AbstractParameter param : param2propertyMapping.keySet()) {
    payloadVariableMapping.put(param.getName(),param2propertyMapping.get(param));
  }
  return this.appendExecuteScript(templateContext,infrastructureNodeTemplate.getId(),runShScriptStringVar,userStringVariable,passwdStringVariable,ipStringVariable,payloadVariableMapping);
}","public boolean handle(TemplatePlanContext templateContext,AbstractOperation operation,AbstractImplementationArtifact ia,Map<AbstractParameter,Variable> param2propertyMapping){
  if (operation.getInputParameters().size() != param2propertyMapping.size()) {
    return false;
  }
  AbstractNodeTemplate infrastructureNodeTemplate=this.findInfrastructureNode(templateContext.getInfrastructureNodes());
  if (infrastructureNodeTemplate == null) {
    return false;
  }
  Variable runShScriptStringVar=null;
  AbstractArtifactReference scriptRef=this.fetchScriptRefFromIA(ia);
  if (scriptRef == null) {
    return false;
  }
  runShScriptStringVar=this.appendBPELAssignOperationShScript(templateContext,operation,scriptRef,ia,param2propertyMapping);
  Variable ipStringVariable=null;
  for (  String serverIp : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineIPPropertyNames()) {
    ipStringVariable=templateContext.getPropertyVariable(infrastructureNodeTemplate,serverIp);
    if (ipStringVariable == null) {
      ipStringVariable=templateContext.getPropertyVariable(serverIp,true);
      if (ipStringVariable == null) {
        ipStringVariable=templateContext.getPropertyVariable(serverIp,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  Variable userStringVariable=null;
  for (  String vmUserName : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    userStringVariable=templateContext.getPropertyVariable(infrastructureNodeTemplate,vmUserName);
    if (userStringVariable == null) {
      userStringVariable=templateContext.getPropertyVariable(vmUserName,true);
      if (userStringVariable == null) {
        userStringVariable=templateContext.getPropertyVariable(vmUserName,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  Variable passwdStringVariable=null;
  for (  String vmUserPassword : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    passwdStringVariable=templateContext.getPropertyVariable(infrastructureNodeTemplate,vmUserPassword);
    if (passwdStringVariable == null) {
      passwdStringVariable=templateContext.getPropertyVariable(vmUserPassword,true);
      if (passwdStringVariable == null) {
        passwdStringVariable=templateContext.getPropertyVariable(vmUserPassword,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (this.isNull(runShScriptStringVar,ipStringVariable,userStringVariable,passwdStringVariable)) {
    return false;
  }
  return this.appendExecuteScript(templateContext,infrastructureNodeTemplate.getId(),runShScriptStringVar,userStringVariable,passwdStringVariable,ipStringVariable);
}"
41531,"/** 
 * Append logic for executing a script on a remote machine with the invoker plugin
 * @param templateContext the context with a bpel templateBuildPlan
 * @param templateId the id of the template inside the context
 * @param runShScriptStringVar the bpel variable containing the script call
 * @param sshUserVariable the user name for the remote machine as a bpel variable
 * @param sshKeyVariable the pass for the remote machine as a bpel variable
 * @param serverIpPropWrapper the ip of the remote machine as a bpel variable
 * @param runScriptRequestInputParams a mapping from parameter names to bpel variables
 * @return true if appending the bpel logic was successful else false
 */
private boolean appendExecuteScript(TemplatePlanContext templateContext,String templateId,Variable runShScriptStringVar,Variable sshUserVariable,Variable sshKeyVariable,Variable serverIpPropWrapper,Map<String,Variable> runScriptRequestInputParams){
  String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
    runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
default :
return false;
}
return true;
}","/** 
 * Append logic for executing a script on a remote machine with the invoker plugin
 * @param templateContext the context with a bpel templateBuildPlan
 * @param templateId the id of the template inside the context
 * @param runShScriptStringVar the bpel variable containing the script call
 * @param sshUserVariable the user name for the remote machine as a bpel variable
 * @param sshKeyVariable the pass for the remote machine as a bpel variable
 * @param serverIpPropWrapper the ip of the remote machine as a bpel variable
 * @return true if appending the bpel logic was successful else false
 */
private boolean appendExecuteScript(TemplatePlanContext templateContext,String templateId,Variable runShScriptStringVar,Variable sshUserVariable,Variable sshKeyVariable,Variable serverIpPropWrapper){
  Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
  String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
    runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
default :
return false;
}
return true;
}"
41532,"/** 
 * {@inheritDoc}
 */
@Override public boolean handle(TemplatePlanContext templateContext){
  AbstractNodeTemplate nodeTemplate=templateContext.getNodeTemplate();
  if (nodeTemplate == null) {
    return false;
  }
  if (Utils.isSupportedVMNodeType(nodeTemplate.getType().getId())) {
    return true;
  }
  if (Utils.isSupportedInfrastructureNodeType(nodeTemplate.getType().getId())) {
    return true;
  }
  if (Utils.isSupportedCloudProviderNodeType(nodeTemplate.getType().getId())) {
    if (nodeTemplate.getType().getId().equals(Types.openStackLiberty12NodeType) | nodeTemplate.getType().getId().equals(Types.vmWareVsphere55NodeType)) {
      return this.handler.handleWithCloudProviderInterface(templateContext,nodeTemplate);
    }
 else {
      return this.handler.handle(templateContext,nodeTemplate);
    }
  }
 else {
    return false;
  }
}","/** 
 * {@inheritDoc}
 */
@Override public boolean handle(TemplatePlanContext templateContext){
  AbstractNodeTemplate nodeTemplate=templateContext.getNodeTemplate();
  if (nodeTemplate == null) {
    return false;
  }
  LOG.debug(""String_Node_Str"" + nodeTemplate.getId() + ""String_Node_Str"");
  if (Utils.isSupportedCloudProviderNodeType(nodeTemplate.getType().getId())) {
    return true;
  }
  if (Utils.isSupportedVMNodeType(nodeTemplate.getType().getId()) | Utils.isSupportedInfrastructureNodeType(nodeTemplate.getType().getId())) {
    for (    AbstractRelationshipTemplate relation : nodeTemplate.getOutgoingRelations()) {
      if (Utils.isSupportedCloudProviderNodeType(relation.getTarget().getType().getId())) {
        if (relation.getTarget().getType().getId().equals(Types.openStackLiberty12NodeType) | relation.getTarget().getType().getId().equals(Types.vmWareVsphere55NodeType)) {
          return this.handler.handleWithCloudProviderInterface(templateContext,nodeTemplate);
        }
 else {
          return this.handler.handle(templateContext,nodeTemplate);
        }
      }
    }
    return true;
  }
  return false;
}"
41533,"public boolean handleWithCloudProviderInterface(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate){
  AbstractNodeTemplate ubuntuNodeTemplate=this.findUbuntuNode(nodeTemplate);
  Variable ubuntuAMIIdVar=null;
  if (ubuntuNodeTemplate == null) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  if (this.isUbuntuNodeTypeWithImplicitImage(ubuntuNodeTemplate.getType().getId())) {
    ubuntuAMIIdVar=context.createGlobalStringVariable(""String_Node_Str"",this.createUbuntuImageStringFromNodeType(ubuntuNodeTemplate.getType().getId()));
  }
  LOG.debug(""String_Node_Str"" + ubuntuNodeTemplate.getId() + ""String_Node_Str""+ ubuntuNodeTemplate.getType().getId().toString());
  Variable instanceIdPropWrapper=null;
  for (  String instanceIdName : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineInstanceIdPropertyNames()) {
    instanceIdPropWrapper=context.getPropertyVariable(ubuntuNodeTemplate,instanceIdName);
    if (instanceIdPropWrapper == null) {
      instanceIdPropWrapper=context.getPropertyVariable(instanceIdName,true);
    }
 else {
      break;
    }
  }
  if (instanceIdPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String vmIpName : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=context.getPropertyVariable(ubuntuNodeTemplate,vmIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=context.getPropertyVariable(vmIpName,true);
    }
 else {
      break;
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String userName : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=context.getPropertyVariable(ubuntuNodeTemplate,userName);
    if (sshUserVariable == null) {
      sshUserVariable=context.getPropertyVariable(userName,true);
    }
 else {
      break;
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,context)) {
      LOG.debug(""String_Node_Str"");
      context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
      context.addAssignFromInput2VariableToMainAssign(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME,sshUserVariable);
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String passwordName : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=context.getPropertyVariable(ubuntuNodeTemplate,passwordName);
    if (sshKeyVariable == null) {
      sshKeyVariable=context.getPropertyVariable(passwordName,true);
    }
 else {
      break;
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,context)) {
      LOG.debug(""String_Node_Str"");
      context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
      context.addAssignFromInput2VariableToMainAssign(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD,sshKeyVariable);
      sshKeyVariable=null;
    }
  }
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  Map<String,Variable> createEC2InternalExternalPropsInput=new HashMap<String,Variable>();
  for (  String externalParameter : Handler.createVMInstanceExternalInputParams) {
    Variable variable=context.getPropertyVariable(ubuntuNodeTemplate,externalParameter);
    if (variable == null) {
      variable=context.getPropertyVariable(externalParameter,true);
    }
    if (externalParameter.equals(""String_Node_Str"") && ubuntuAMIIdVar != null) {
      createEC2InternalExternalPropsInput.put(externalParameter,ubuntuAMIIdVar);
      continue;
    }
    if (variable == null) {
      Handler.LOG.warn(""String_Node_Str"" + externalParameter);
      return false;
    }
 else {
      Handler.LOG.debug(""String_Node_Str"" + externalParameter);
    }
    if (Utils.isVariableValueEmpty(variable,context)) {
      Handler.LOG.debug(""String_Node_Str"");
      createEC2InternalExternalPropsInput.put(externalParameter,null);
    }
 else {
      createEC2InternalExternalPropsInput.put(externalParameter,variable);
    }
  }
  Map<String,Variable> createEC2InternalExternalPropsOutput=new HashMap<String,Variable>();
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMINSTANCEID,instanceIdPropWrapper);
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP,serverIpPropWrapper);
  context.addStringValueToPlanRequest(""String_Node_Str"");
  this.invokerOpPlugin.handle(context,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER_CREATEVM,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER,""String_Node_Str"",createEC2InternalExternalPropsInput,createEC2InternalExternalPropsOutput);
  Map<String,Variable> startRequestInputParams=new HashMap<String,Variable>();
  Map<String,Variable> startRequestOutputParams=new HashMap<String,Variable>();
  startRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  startRequestInputParams.put(""String_Node_Str"",sshUserVariable);
  startRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
  startRequestOutputParams.put(""String_Node_Str"",context.createGlobalStringVariable(""String_Node_Str"",""String_Node_Str""));
  this.invokerOpPlugin.handle(context,ubuntuNodeTemplate.getId(),true,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM_WAITFORAVAIL,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",startRequestInputParams,startRequestOutputParams,false);
  return true;
}","public boolean handleWithCloudProviderInterface(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate){
  AbstractNodeTemplate cloudProviderNodeTemplate=this.findCloudProviderNode(nodeTemplate);
  if (cloudProviderNodeTemplate == null) {
    return false;
  }
  AbstractNodeTemplate ubuntuNodeTemplate=this.findUbuntuNode(nodeTemplate);
  Variable ubuntuAMIIdVar=null;
  if (ubuntuNodeTemplate == null) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  if (this.isUbuntuNodeTypeWithImplicitImage(ubuntuNodeTemplate.getType().getId())) {
    ubuntuAMIIdVar=context.createGlobalStringVariable(""String_Node_Str"",this.createUbuntuImageStringFromNodeType(ubuntuNodeTemplate.getType().getId()));
  }
  LOG.debug(""String_Node_Str"" + ubuntuNodeTemplate.getId() + ""String_Node_Str""+ ubuntuNodeTemplate.getType().getId().toString());
  Variable instanceIdPropWrapper=null;
  for (  String instanceIdName : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineInstanceIdPropertyNames()) {
    instanceIdPropWrapper=context.getPropertyVariable(ubuntuNodeTemplate,instanceIdName);
    if (instanceIdPropWrapper == null) {
      instanceIdPropWrapper=context.getPropertyVariable(instanceIdName,true);
    }
 else {
      break;
    }
  }
  if (instanceIdPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String vmIpName : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=context.getPropertyVariable(ubuntuNodeTemplate,vmIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=context.getPropertyVariable(vmIpName,true);
    }
 else {
      break;
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String userName : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=context.getPropertyVariable(ubuntuNodeTemplate,userName);
    if (sshUserVariable == null) {
      sshUserVariable=context.getPropertyVariable(userName,true);
    }
 else {
      break;
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,context)) {
      LOG.debug(""String_Node_Str"");
      context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
      context.addAssignFromInput2VariableToMainAssign(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME,sshUserVariable);
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String passwordName : org.opentosca.model.tosca.conventions.Utils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=context.getPropertyVariable(ubuntuNodeTemplate,passwordName);
    if (sshKeyVariable == null) {
      sshKeyVariable=context.getPropertyVariable(passwordName,true);
    }
 else {
      break;
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,context)) {
      LOG.debug(""String_Node_Str"");
      context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
      context.addAssignFromInput2VariableToMainAssign(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD,sshKeyVariable);
      sshKeyVariable=null;
    }
  }
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  Map<String,Variable> createEC2InternalExternalPropsInput=new HashMap<String,Variable>();
  for (  String externalParameter : Handler.createVMInstanceExternalInputParams) {
    Variable variable=context.getPropertyVariable(ubuntuNodeTemplate,externalParameter);
    if (variable == null) {
      variable=context.getPropertyVariable(externalParameter,true);
    }
    if (externalParameter.equals(""String_Node_Str"") && ubuntuAMIIdVar != null) {
      createEC2InternalExternalPropsInput.put(externalParameter,ubuntuAMIIdVar);
      continue;
    }
    if (variable == null) {
      Handler.LOG.warn(""String_Node_Str"" + externalParameter);
      return false;
    }
 else {
      Handler.LOG.debug(""String_Node_Str"" + externalParameter);
    }
    if (Utils.isVariableValueEmpty(variable,context)) {
      Handler.LOG.debug(""String_Node_Str"");
      createEC2InternalExternalPropsInput.put(externalParameter,null);
    }
 else {
      createEC2InternalExternalPropsInput.put(externalParameter,variable);
    }
  }
  Map<String,Variable> createEC2InternalExternalPropsOutput=new HashMap<String,Variable>();
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMINSTANCEID,instanceIdPropWrapper);
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP,serverIpPropWrapper);
  context.addStringValueToPlanRequest(""String_Node_Str"");
  this.invokerOpPlugin.handle(context,cloudProviderNodeTemplate.getId(),true,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER_CREATEVM,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER,""String_Node_Str"",createEC2InternalExternalPropsInput,createEC2InternalExternalPropsOutput,false);
  Map<String,Variable> startRequestInputParams=new HashMap<String,Variable>();
  Map<String,Variable> startRequestOutputParams=new HashMap<String,Variable>();
  startRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  startRequestInputParams.put(""String_Node_Str"",sshUserVariable);
  startRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
  startRequestOutputParams.put(""String_Node_Str"",context.createGlobalStringVariable(""String_Node_Str"",""String_Node_Str""));
  this.invokerOpPlugin.handle(context,ubuntuNodeTemplate.getId(),true,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM_WAITFORAVAIL,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",startRequestInputParams,startRequestOutputParams,false);
  return true;
}"
41534,"/** 
 * Search from the given NodeTemplate for an Ubuntu NodeTemplate
 * @param nodeTemplate an AbstractNodeTemplate
 * @return an Ubuntu NodeTemplate, may be null
 */
private AbstractNodeTemplate findUbuntuNode(AbstractNodeTemplate nodeTemplate){
  for (  AbstractRelationshipTemplate relationTemplate : nodeTemplate.getIngoingRelations()) {
    if (org.opentosca.model.tosca.conventions.Utils.isSupportedInfrastructureNodeType(relationTemplate.getSource().getType().getId())) {
      return relationTemplate.getSource();
    }
    for (    AbstractRelationshipTemplate relationTemplate2 : relationTemplate.getSource().getIngoingRelations()) {
      if (org.opentosca.model.tosca.conventions.Utils.isSupportedInfrastructureNodeType(relationTemplate2.getSource().getType().getId())) {
        return relationTemplate2.getSource();
      }
    }
  }
  return null;
}","/** 
 * Search from the given NodeTemplate for an Ubuntu NodeTemplate
 * @param nodeTemplate an AbstractNodeTemplate
 * @return an Ubuntu NodeTemplate, may be null
 */
private AbstractNodeTemplate findUbuntuNode(AbstractNodeTemplate nodeTemplate){
  if (org.opentosca.model.tosca.conventions.Utils.isSupportedInfrastructureNodeType(nodeTemplate.getType().getId())) {
    return nodeTemplate;
  }
  for (  AbstractRelationshipTemplate relationTemplate : nodeTemplate.getIngoingRelations()) {
    if (org.opentosca.model.tosca.conventions.Utils.isSupportedInfrastructureNodeType(relationTemplate.getSource().getType().getId())) {
      return relationTemplate.getSource();
    }
    for (    AbstractRelationshipTemplate relationTemplate2 : relationTemplate.getSource().getIngoingRelations()) {
      if (org.opentosca.model.tosca.conventions.Utils.isSupportedInfrastructureNodeType(relationTemplate2.getSource().getType().getId())) {
        return relationTemplate2.getSource();
      }
    }
  }
  return null;
}"
41535,"/** 
 * Creates a string representing an ubuntu image id on a cloud provider
 * @param nodeType a QName of an Ubuntu ImplicitImage NodeType
 * @return a String containing an ubuntuImageId, if given QName is notpresenting an Ubuntu image then null
 */
private String createUbuntuImageStringFromNodeType(QName nodeType){
  if (!PluginUtils.isSupportedUbuntuVMNodeType(nodeType)) {
    return null;
  }
  String localName=nodeType.getLocalPart();
  String[] dotSplit=localName.split(""String_Node_Str"");
  if (dotSplit.length != 2) {
    return null;
  }
  String[] leftDashSplit=dotSplit[0].split(""String_Node_Str"");
  String[] rightDashSplit=dotSplit[1].split(""String_Node_Str"");
  if (leftDashSplit.length != 2 && rightDashSplit.length != 2) {
    return null;
  }
  if (!leftDashSplit[0].equals(""String_Node_Str"")) {
    return null;
  }
  int majorVers;
  try {
    majorVers=Integer.parseInt(leftDashSplit[1]);
  }
 catch (  NumberFormatException e) {
    return null;
  }
  if (!rightDashSplit[1].equals(""String_Node_Str"")) {
    return null;
  }
  int minorVers;
  try {
    minorVers=Integer.parseInt(rightDashSplit[0]);
  }
 catch (  NumberFormatException e) {
    return null;
  }
  String ubuntuAMIId=""String_Node_Str"" + majorVers + ""String_Node_Str""+ minorVers+ ""String_Node_Str"";
  return ubuntuAMIId;
}","/** 
 * Creates a string representing an ubuntu image id on a cloud provider
 * @param nodeType a QName of an Ubuntu ImplicitImage NodeType
 * @return a String containing an ubuntuImageId, if given QName is notpresenting an Ubuntu image then null
 */
private String createUbuntuImageStringFromNodeType(QName nodeType){
  if (!PluginUtils.isSupportedUbuntuVMNodeType(nodeType)) {
    return null;
  }
  String localName=nodeType.getLocalPart();
  String[] dotSplit=localName.split(""String_Node_Str"");
  if (dotSplit.length != 2) {
    return null;
  }
  String[] leftDashSplit=dotSplit[0].split(""String_Node_Str"");
  String[] rightDashSplit=dotSplit[1].split(""String_Node_Str"");
  if (leftDashSplit.length != 2 && rightDashSplit.length != 2) {
    return null;
  }
  if (!leftDashSplit[0].equals(""String_Node_Str"")) {
    return null;
  }
  int majorVers;
  try {
    majorVers=Integer.parseInt(leftDashSplit[1]);
  }
 catch (  NumberFormatException e) {
    return null;
  }
  if (!rightDashSplit[1].equals(""String_Node_Str"")) {
    return null;
  }
  int minorVers;
  String minorVersString;
  try {
    minorVers=Integer.parseInt(rightDashSplit[0]);
    minorVersString=String.valueOf(minorVers).trim();
    if (minorVersString.length() != 2) {
      minorVersString=""String_Node_Str"" + minorVersString;
    }
  }
 catch (  NumberFormatException e) {
    return null;
  }
  String ubuntuAMIId=""String_Node_Str"" + majorVers + ""String_Node_Str""+ minorVersString+ ""String_Node_Str"";
  return ubuntuAMIId;
}"
41536,"/** 
 * {@inheritDoc}
 */
@Override public boolean handle(TemplatePlanContext templateContext){
  AbstractNodeTemplate nodeTemplate=templateContext.getNodeTemplate();
  if (nodeTemplate == null) {
    return false;
  }
  if (PluginUtils.isSupportedVMNodeType(nodeTemplate.getType().getId())) {
    return true;
  }
  if (PluginUtils.isSupportedUbuntuVMNodeType(nodeTemplate.getType().getId())) {
    return true;
  }
  if (PluginUtils.isSupportedCloudProviderNodeType(nodeTemplate.getType().getId())) {
    return this.handler.handle(templateContext,nodeTemplate);
  }
 else {
    return false;
  }
}","/** 
 * {@inheritDoc}
 */
@Override public boolean handle(TemplatePlanContext templateContext){
  AbstractNodeTemplate nodeTemplate=templateContext.getNodeTemplate();
  if (nodeTemplate == null) {
    return false;
  }
  if (PluginUtils.isSupportedVMNodeType(nodeTemplate.getType().getId())) {
    return true;
  }
  if (PluginUtils.isSupportedUbuntuVMNodeType(nodeTemplate.getType().getId())) {
    return true;
  }
  if (PluginUtils.isSupportedCloudProviderNodeType(nodeTemplate.getType().getId())) {
    if (nodeTemplate.getType().getId().equals(Types.openStackLiberty12NodeType)) {
      return this.handler.handleOpenStackLiberty12WithUbuntu1404(templateContext,nodeTemplate);
    }
 else {
      return this.handler.handle(templateContext,nodeTemplate);
    }
  }
 else {
    return false;
  }
}"
41537,"/** 
 * Creates a string representing an ubuntu image id on a cloud provider
 * @param nodeType a QName of an Ubuntu ImplicitImage NodeType
 * @return a String containing an ubuntuImageId, if given QName is notpresenting an Ubuntu image then null
 */
private String createUbuntuImageStringFromNodeType(QName nodeType){
  if (!PluginUtils.isSupportedUbuntuVMNodeType(nodeType)) {
    return null;
  }
  String localName=nodeType.getLocalPart();
  String[] dotSplit=localName.split(""String_Node_Str"");
  if (dotSplit.length != 2) {
    return null;
  }
  String[] leftDashSplit=dotSplit[0].split(""String_Node_Str"");
  String[] rightDashSplit=dotSplit[1].split(""String_Node_Str"");
  if (leftDashSplit.length != 2 && rightDashSplit.length != 2) {
    return null;
  }
  if (!leftDashSplit[0].equals(""String_Node_Str"")) {
    return null;
  }
  int majorVers;
  try {
    majorVers=Integer.parseInt(leftDashSplit[1]);
  }
 catch (  NumberFormatException e) {
    return null;
  }
  if (!rightDashSplit[1].equals(""String_Node_Str"")) {
    return null;
  }
  int minorVers;
  String minorVersString;
  try {
    minorVers=Integer.parseInt(rightDashSplit[0]);
    minorVersString=String.valueOf(minorVers).trim();
    if (minorVersString.length() != 2) {
      minorVersString=""String_Node_Str"" + minorVersString;
    }
  }
 catch (  NumberFormatException e) {
    return null;
  }
  String ubuntuAMIId=""String_Node_Str"" + majorVers + ""String_Node_Str""+ minorVersString+ ""String_Node_Str"";
  return ubuntuAMIId;
}","/** 
 * Creates a string representing an ubuntu image id on a cloud provider
 * @param nodeType a QName of an Ubuntu ImplicitImage NodeType
 * @return a String containing an ubuntuImageId, if given QName is notpresenting an Ubuntu image then null
 */
private String createUbuntuImageStringFromNodeType(QName nodeType){
  if (!PluginUtils.isSupportedUbuntuVMNodeType(nodeType)) {
    return null;
  }
  String localName=nodeType.getLocalPart();
  String[] dotSplit=localName.split(""String_Node_Str"");
  if (dotSplit.length != 2) {
    return null;
  }
  String[] leftDashSplit=dotSplit[0].split(""String_Node_Str"");
  String[] rightDashSplit=dotSplit[1].split(""String_Node_Str"");
  if (leftDashSplit.length != 2 && rightDashSplit.length != 2) {
    return null;
  }
  if (!leftDashSplit[0].equals(""String_Node_Str"")) {
    return null;
  }
  int majorVers;
  try {
    majorVers=Integer.parseInt(leftDashSplit[1]);
  }
 catch (  NumberFormatException e) {
    return null;
  }
  if (!rightDashSplit[1].equals(""String_Node_Str"") & !rightDashSplit[1].equals(""String_Node_Str"")) {
    return null;
  }
  int minorVers;
  String minorVersString;
  try {
    minorVers=Integer.parseInt(rightDashSplit[0]);
    minorVersString=String.valueOf(minorVers).trim();
    if (minorVersString.length() != 2) {
      minorVersString=""String_Node_Str"" + minorVersString;
    }
  }
 catch (  NumberFormatException e) {
    return null;
  }
  String ubuntuAMIId=""String_Node_Str"" + majorVers + ""String_Node_Str""+ minorVersString+ ""String_Node_Str"";
  return ubuntuAMIId;
}"
41538,"/** 
 * Adds necessary BPEL logic through the given Context, to deploy the given ArtifactReferences unto the specified InfrastructureNode
 * @param context a TemplateContext
 * @param refs the ArtifactReferences to deploy
 * @param artifactName the name of the artifact, where the references originate from
 * @param nodeTemplate a NodeTemplate which is a InfrastructureNode to deploy the AbstractReferences on
 * @return true iff adding the logic was successful
 */
private boolean handle(TemplatePlanContext templateContext,List<AbstractArtifactReference> refs,String artifactName,AbstractNodeTemplate nodeTemplate){
  Variable serverIpPropWrapper=null;
  for (  String serverIpName : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmLoginName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(vmLoginName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmLoginName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmLoginName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmLoginPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
LOG.debug(""String_Node_Str"");
String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
default :
return false;
}
}
String templateId=nodeTemplate.getId();
if (templateId.equals(""String_Node_Str"")) {
Handler.LOG.warn(""String_Node_Str"");
return false;
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
for (AbstractArtifactReference ref : refs) {
this.invokerPlugin.handleArtifactReferenceUpload(ref,templateContext,serverIpPropWrapper,sshUserVariable,sshKeyVariable,templateId);
}
return true;
}","/** 
 * Adds necessary BPEL logic through the given Context, to deploy the given ArtifactReferences unto the specified InfrastructureNode
 * @param context a TemplateContext
 * @param refs the ArtifactReferences to deploy
 * @param artifactName the name of the artifact, where the references originate from
 * @param nodeTemplate a NodeTemplate which is a InfrastructureNode to deploy the AbstractReferences on
 * @return true iff adding the logic was successful
 */
private boolean handle(TemplatePlanContext templateContext,List<AbstractArtifactReference> refs,String artifactName,AbstractNodeTemplate nodeTemplate){
  Variable serverIpPropWrapper=null;
  for (  String serverIpName : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(nodeTemplate,serverIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmLoginName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(nodeTemplate,vmLoginName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmLoginName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmLoginName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmLoginPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(nodeTemplate,vmLoginPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
LOG.debug(""String_Node_Str"");
String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
default :
return false;
}
}
String templateId=nodeTemplate.getId();
if (templateId.equals(""String_Node_Str"")) {
Handler.LOG.warn(""String_Node_Str"");
return false;
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
for (AbstractArtifactReference ref : refs) {
this.invokerPlugin.handleArtifactReferenceUpload(ref,templateContext,serverIpPropWrapper,sshUserVariable,sshKeyVariable,templateId);
}
return true;
}"
41539,"/** 
 * Adds logic to the BuildPlan to call a Script on a remote machine
 * @param context the TemplatePlanContext where the logical provisioning operation is called
 * @param operation the operation to call
 * @param ia the ia that implements the operation
 * @return true iff adding BPEL Fragment was successful
 */
public boolean handle(TemplatePlanContext templateContext,AbstractOperation operation,AbstractImplementationArtifact ia){
  AbstractArtifactReference scriptRef=this.fetchScriptRefFromIA(ia);
  if (scriptRef == null) {
    return false;
  }
  if (templateContext.getNodeTemplate() == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String serverIp : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(serverIp);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmUserName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(vmUserName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmUserName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmUserName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmUserPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
default :
return false;
}
}
String templateId=""String_Node_Str"";
for (AbstractNodeTemplate nodeTemplate : templateContext.getNodeTemplates()) {
if (PluginUtils.isSupportedUbuntuVMNodeType(nodeTemplate.getType().getId())) {
templateId=nodeTemplate.getId();
}
}
if (templateId.equals(""String_Node_Str"")) {
Handler.LOG.warn(""String_Node_Str"");
return false;
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
Variable runShScriptStringVar=this.appendBPELAssignOperationShScript(templateContext,operation,scriptRef,ia);
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
default :
return false;
}
return true;
}","/** 
 * Adds logic to the BuildPlan to call a Script on a remote machine
 * @param context the TemplatePlanContext where the logical provisioning operation is called
 * @param operation the operation to call
 * @param ia the ia that implements the operation
 * @return true iff adding BPEL Fragment was successful
 */
public boolean handle(TemplatePlanContext templateContext,AbstractOperation operation,AbstractImplementationArtifact ia){
  AbstractArtifactReference scriptRef=this.fetchScriptRefFromIA(ia);
  if (scriptRef == null) {
    return false;
  }
  List<AbstractNodeTemplate> nodes=new ArrayList<AbstractNodeTemplate>();
  Utils.getNodesFromNodeToSink(templateContext.getNodeTemplate(),nodes);
  nodes.add(templateContext.getNodeTemplate());
  AbstractNodeTemplate ubuntuNodeTemplate=null;
  String templateId=""String_Node_Str"";
  for (  AbstractNodeTemplate nodeTemplate : nodes) {
    if (PluginUtils.isSupportedUbuntuVMNodeType(nodeTemplate.getType().getId())) {
      ubuntuNodeTemplate=nodeTemplate;
      templateId=nodeTemplate.getId();
    }
  }
  if (templateId.equals(""String_Node_Str"")) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  if (templateContext.getNodeTemplate() == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String serverIp : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(ubuntuNodeTemplate,serverIp);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmUserName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmUserName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmUserName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmUserPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
default :
return false;
}
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
Variable runShScriptStringVar=this.appendBPELAssignOperationShScript(templateContext,operation,scriptRef,ia);
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
default :
return false;
}
return true;
}"
41540,"public boolean handleOpenStackLiberty12WithUbuntu1404(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate){
  AbstractNodeTemplate ubuntuNodeTemplate=this.findUbuntuNode(nodeTemplate);
  Variable ubuntuAMIIdVar=null;
  if (ubuntuNodeTemplate == null) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  if (this.isUbuntuNodeTypeWithImplicitImage(ubuntuNodeTemplate.getType().getId())) {
    ubuntuAMIIdVar=context.createGlobalStringVariable(""String_Node_Str"",this.createUbuntuImageStringFromNodeType(ubuntuNodeTemplate.getType().getId()));
  }
  LOG.debug(""String_Node_Str"" + ubuntuNodeTemplate.getId() + ""String_Node_Str""+ ubuntuNodeTemplate.getType().getId().toString());
  Variable instanceIdPropWrapper=null;
  for (  String instanceIdName : PluginUtils.getSupportedVirtualMachineInstanceIdPropertyNames()) {
    instanceIdPropWrapper=context.getPropertyVariable(instanceIdName);
    if (instanceIdPropWrapper == null) {
      instanceIdPropWrapper=context.getPropertyVariable(instanceIdName,true);
      if (instanceIdPropWrapper == null) {
        instanceIdPropWrapper=context.getPropertyVariable(instanceIdName,false);
      }
    }
  }
  if (instanceIdPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String vmIpName : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=context.getPropertyVariable(vmIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=context.getPropertyVariable(vmIpName,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=context.getPropertyVariable(vmIpName,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String userName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=context.getPropertyVariable(userName);
    if (sshUserVariable == null) {
      sshUserVariable=context.getPropertyVariable(userName,true);
      if (sshUserVariable == null) {
        sshUserVariable=context.getPropertyVariable(userName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,context)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String passwordName : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=context.getPropertyVariable(passwordName);
    if (sshKeyVariable == null) {
      sshKeyVariable=context.getPropertyVariable(passwordName,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=context.getPropertyVariable(passwordName,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,context)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
  }
  if (sshKeyVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
  }
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  Map<String,Variable> createEC2InternalExternalPropsInput=new HashMap<String,Variable>();
  for (  String externalParameter : Handler.createVMInstanceExternalInputParams) {
    Variable variable=context.getPropertyVariable(externalParameter);
    if (variable == null) {
      variable=context.getPropertyVariable(externalParameter,true);
      if (variable == null) {
        variable=context.getPropertyVariable(externalParameter,false);
      }
    }
    if (externalParameter.equals(""String_Node_Str"") && ubuntuAMIIdVar != null) {
      createEC2InternalExternalPropsInput.put(externalParameter,ubuntuAMIIdVar);
      continue;
    }
    if (variable == null) {
      Handler.LOG.warn(""String_Node_Str"" + externalParameter);
      return false;
    }
 else {
      Handler.LOG.debug(""String_Node_Str"" + externalParameter);
    }
    if (Utils.isVariableValueEmpty(variable,context)) {
      Handler.LOG.debug(""String_Node_Str"");
      createEC2InternalExternalPropsInput.put(externalParameter,null);
    }
 else {
      createEC2InternalExternalPropsInput.put(externalParameter,variable);
    }
  }
  Map<String,Variable> createEC2InternalExternalPropsOutput=new HashMap<String,Variable>();
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMINSTANCEID,instanceIdPropWrapper);
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP,serverIpPropWrapper);
  context.addStringValueToPlanRequest(""String_Node_Str"");
  this.invokerOpPlugin.handle(context,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER_CREATEVM,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER,""String_Node_Str"",createEC2InternalExternalPropsInput,createEC2InternalExternalPropsOutput);
  Map<String,Variable> startRequestInputParams=new HashMap<String,Variable>();
  startRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  startRequestInputParams.put(""String_Node_Str"",sshUserVariable);
  startRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
  this.invokerOpPlugin.handle(context,ubuntuNodeTemplate.getId(),true,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM_WAITFORAVAIL,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",startRequestInputParams,new HashMap<String,Variable>(),false);
  return true;
}","public boolean handleOpenStackLiberty12WithUbuntu1404(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate){
  AbstractNodeTemplate ubuntuNodeTemplate=this.findUbuntuNode(nodeTemplate);
  Variable ubuntuAMIIdVar=null;
  if (ubuntuNodeTemplate == null) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  if (this.isUbuntuNodeTypeWithImplicitImage(ubuntuNodeTemplate.getType().getId())) {
    ubuntuAMIIdVar=context.createGlobalStringVariable(""String_Node_Str"",this.createUbuntuImageStringFromNodeType(ubuntuNodeTemplate.getType().getId()));
  }
  LOG.debug(""String_Node_Str"" + ubuntuNodeTemplate.getId() + ""String_Node_Str""+ ubuntuNodeTemplate.getType().getId().toString());
  Variable instanceIdPropWrapper=null;
  for (  String instanceIdName : PluginUtils.getSupportedVirtualMachineInstanceIdPropertyNames()) {
    instanceIdPropWrapper=context.getPropertyVariable(ubuntuNodeTemplate,instanceIdName);
    if (instanceIdPropWrapper == null) {
      instanceIdPropWrapper=context.getPropertyVariable(instanceIdName,true);
    }
  }
  if (instanceIdPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String vmIpName : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=context.getPropertyVariable(ubuntuNodeTemplate,vmIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=context.getPropertyVariable(vmIpName,true);
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String userName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=context.getPropertyVariable(ubuntuNodeTemplate,userName);
    if (sshUserVariable == null) {
      sshUserVariable=context.getPropertyVariable(userName,true);
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,context)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String passwordName : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=context.getPropertyVariable(ubuntuNodeTemplate,passwordName);
    if (sshKeyVariable == null) {
      sshKeyVariable=context.getPropertyVariable(passwordName,true);
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,context)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
  }
  if (sshKeyVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
  }
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  Map<String,Variable> createEC2InternalExternalPropsInput=new HashMap<String,Variable>();
  for (  String externalParameter : Handler.createVMInstanceExternalInputParams) {
    Variable variable=context.getPropertyVariable(ubuntuNodeTemplate,externalParameter);
    if (variable == null) {
      variable=context.getPropertyVariable(externalParameter,true);
    }
    if (externalParameter.equals(""String_Node_Str"") && ubuntuAMIIdVar != null) {
      createEC2InternalExternalPropsInput.put(externalParameter,ubuntuAMIIdVar);
      continue;
    }
    if (variable == null) {
      Handler.LOG.warn(""String_Node_Str"" + externalParameter);
      return false;
    }
 else {
      Handler.LOG.debug(""String_Node_Str"" + externalParameter);
    }
    if (Utils.isVariableValueEmpty(variable,context)) {
      Handler.LOG.debug(""String_Node_Str"");
      createEC2InternalExternalPropsInput.put(externalParameter,null);
    }
 else {
      createEC2InternalExternalPropsInput.put(externalParameter,variable);
    }
  }
  Map<String,Variable> createEC2InternalExternalPropsOutput=new HashMap<String,Variable>();
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMINSTANCEID,instanceIdPropWrapper);
  createEC2InternalExternalPropsOutput.put(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP,serverIpPropWrapper);
  context.addStringValueToPlanRequest(""String_Node_Str"");
  this.invokerOpPlugin.handle(context,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER_CREATEVM,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_CLOUDPROVIDER,""String_Node_Str"",createEC2InternalExternalPropsInput,createEC2InternalExternalPropsOutput);
  Map<String,Variable> startRequestInputParams=new HashMap<String,Variable>();
  startRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  startRequestInputParams.put(""String_Node_Str"",sshUserVariable);
  startRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
  this.invokerOpPlugin.handle(context,ubuntuNodeTemplate.getId(),true,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM_WAITFORAVAIL,Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",startRequestInputParams,new HashMap<String,Variable>(),false);
  return true;
}"
41541,"/** 
 * Adds fragments to provision a VM
 * @param context a TemplatePlanContext for a EC2, VM or Ubuntu Node
 * @param nodeTemplate the NodeTemplate on which the fragments are used
 * @return true iff adding the fragments was successful
 */
public boolean handle(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate){
  AbstractNodeTemplate ubuntuNodeTemplate=this.findUbuntuNode(nodeTemplate);
  Variable ubuntuAMIIdVar=null;
  if (ubuntuNodeTemplate == null) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  if (this.isUbuntuNodeTypeWithImplicitImage(ubuntuNodeTemplate.getType().getId())) {
    ubuntuAMIIdVar=context.createGlobalStringVariable(""String_Node_Str"",this.createUbuntuImageStringFromNodeType(ubuntuNodeTemplate.getType().getId()));
  }
  LOG.debug(""String_Node_Str"" + ubuntuNodeTemplate.getId() + ""String_Node_Str""+ ubuntuNodeTemplate.getType().getId().toString());
  Variable instanceIdPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_INSTANCEID);
  if (instanceIdPropWrapper == null) {
    instanceIdPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_INSTANCEID,true);
    if (instanceIdPropWrapper == null) {
      instanceIdPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_INSTANCEID,false);
    }
  }
  if (instanceIdPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP);
  if (serverIpPropWrapper == null) {
    serverIpPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP,true);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP,false);
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=context.getPropertyVariable(""String_Node_Str"");
  if (sshUserVariable == null) {
    sshUserVariable=context.getPropertyVariable(""String_Node_Str"",true);
    if (sshUserVariable == null) {
      sshUserVariable=context.getPropertyVariable(""String_Node_Str"",false);
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,context)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=context.getPropertyVariable(""String_Node_Str"");
  if (sshKeyVariable == null) {
    sshKeyVariable=context.getPropertyVariable(""String_Node_Str"",true);
    if (sshKeyVariable == null) {
      sshKeyVariable=context.getPropertyVariable(""String_Node_Str"",false);
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,context)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(""String_Node_Str"");
  }
  if (sshKeyVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(""String_Node_Str"");
  }
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  Map<String,Variable> createEC2InternalExternalPropsInput=new HashMap<String,Variable>();
  for (  String externalParameter : Handler.createEC2InstanceExternalInputParams) {
    Variable variable=context.getPropertyVariable(externalParameter);
    if (variable == null) {
      variable=context.getPropertyVariable(externalParameter,true);
      if (variable == null) {
        variable=context.getPropertyVariable(externalParameter,false);
      }
    }
    if (externalParameter.equals(""String_Node_Str"") && ubuntuAMIIdVar != null) {
      createEC2InternalExternalPropsInput.put(externalParameter,ubuntuAMIIdVar);
      continue;
    }
    if (variable == null) {
      Handler.LOG.warn(""String_Node_Str"" + externalParameter);
      return false;
    }
 else {
      Handler.LOG.debug(""String_Node_Str"" + externalParameter);
    }
    if (Utils.isVariableValueEmpty(variable,context)) {
      Handler.LOG.debug(""String_Node_Str"");
      createEC2InternalExternalPropsInput.put(externalParameter,null);
    }
 else {
      createEC2InternalExternalPropsInput.put(externalParameter,variable);
    }
  }
  Map<String,Variable> createEC2InternalExternalPropsOutput=new HashMap<String,Variable>();
  createEC2InternalExternalPropsOutput.put(""String_Node_Str"",instanceIdPropWrapper);
  createEC2InternalExternalPropsOutput.put(""String_Node_Str"",serverIpPropWrapper);
  context.addStringValueToPlanRequest(""String_Node_Str"");
  this.invokerOpPlugin.handle(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",createEC2InternalExternalPropsInput,createEC2InternalExternalPropsOutput);
  Map<String,Variable> startRequestInputParams=new HashMap<String,Variable>();
  startRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  startRequestInputParams.put(""String_Node_Str"",sshUserVariable);
  startRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
  this.invokerOpPlugin.handle(context,ubuntuNodeTemplate.getId(),true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",startRequestInputParams,new HashMap<String,Variable>(),false);
  return true;
}","/** 
 * Adds fragments to provision a VM
 * @param context a TemplatePlanContext for a EC2, VM or Ubuntu Node
 * @param nodeTemplate the NodeTemplate on which the fragments are used
 * @return true iff adding the fragments was successful
 */
public boolean handle(TemplatePlanContext context,AbstractNodeTemplate nodeTemplate){
  AbstractNodeTemplate ubuntuNodeTemplate=this.findUbuntuNode(nodeTemplate);
  Variable ubuntuAMIIdVar=null;
  if (ubuntuNodeTemplate == null) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  if (this.isUbuntuNodeTypeWithImplicitImage(ubuntuNodeTemplate.getType().getId())) {
    ubuntuAMIIdVar=context.createGlobalStringVariable(""String_Node_Str"",this.createUbuntuImageStringFromNodeType(ubuntuNodeTemplate.getType().getId()));
  }
  LOG.debug(""String_Node_Str"" + ubuntuNodeTemplate.getId() + ""String_Node_Str""+ ubuntuNodeTemplate.getType().getId().toString());
  Variable instanceIdPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_INSTANCEID,true);
  if (instanceIdPropWrapper == null) {
    instanceIdPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_INSTANCEID);
  }
  if (instanceIdPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP,true);
  if (serverIpPropWrapper == null) {
    serverIpPropWrapper=context.getPropertyVariable(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP);
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=context.getPropertyVariable(""String_Node_Str"",true);
  if (sshUserVariable == null) {
    sshUserVariable=context.getPropertyVariable(""String_Node_Str"");
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,context)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=context.getPropertyVariable(""String_Node_Str"",true);
  if (sshKeyVariable == null) {
    sshKeyVariable=context.getPropertyVariable(""String_Node_Str"");
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,context)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(""String_Node_Str"");
  }
  if (sshKeyVariable == null) {
    LOG.debug(""String_Node_Str"");
    context.addStringValueToPlanRequest(""String_Node_Str"");
  }
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  context.addStringValueToPlanRequest(""String_Node_Str"");
  Map<String,Variable> createEC2InternalExternalPropsInput=new HashMap<String,Variable>();
  for (  String externalParameter : Handler.createEC2InstanceExternalInputParams) {
    Variable variable=context.getPropertyVariable(externalParameter,true);
    if (variable == null) {
      variable=context.getPropertyVariable(externalParameter);
    }
    if (externalParameter.equals(""String_Node_Str"") && ubuntuAMIIdVar != null) {
      createEC2InternalExternalPropsInput.put(externalParameter,ubuntuAMIIdVar);
      continue;
    }
    if (variable == null) {
      Handler.LOG.warn(""String_Node_Str"" + externalParameter);
      return false;
    }
 else {
      Handler.LOG.debug(""String_Node_Str"" + externalParameter);
    }
    if (Utils.isVariableValueEmpty(variable,context)) {
      Handler.LOG.debug(""String_Node_Str"");
      createEC2InternalExternalPropsInput.put(externalParameter,null);
    }
 else {
      createEC2InternalExternalPropsInput.put(externalParameter,variable);
    }
  }
  Map<String,Variable> createEC2InternalExternalPropsOutput=new HashMap<String,Variable>();
  createEC2InternalExternalPropsOutput.put(""String_Node_Str"",instanceIdPropWrapper);
  createEC2InternalExternalPropsOutput.put(""String_Node_Str"",serverIpPropWrapper);
  context.addStringValueToPlanRequest(""String_Node_Str"");
  this.invokerOpPlugin.handle(context,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",createEC2InternalExternalPropsInput,createEC2InternalExternalPropsOutput);
  Map<String,Variable> startRequestInputParams=new HashMap<String,Variable>();
  startRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
  startRequestInputParams.put(""String_Node_Str"",sshUserVariable);
  startRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
  this.invokerOpPlugin.handle(context,ubuntuNodeTemplate.getId(),true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",startRequestInputParams,new HashMap<String,Variable>(),false);
  return true;
}"
41542,"/** 
 * Checks whether this Plugin can handle deploying artifacts of the given artfiactType to a given InfrastructureNode of the given infrastructureNodeType
 * @param scriptArtifactType a QName denoting an scriptArtifactType
 * @param infrastructureNodeType a QName denoting an infrastructureNodeType
 * @return a Boolean. True if given pair of QName's denotes a pair whichthis plugin can handle
 */
private boolean isSupportedDeploymentPair(QName artifactType,QName infrastructureNodeType){
  boolean isSupportedInfrastructureNode=false;
  isSupportedInfrastructureNode|=PluginUtils.isSupportedUbuntuVMNodeType(infrastructureNodeType);
  isSupportedInfrastructureNode|=infrastructureNodeType.equals(Utils.externalResourceNodeType);
  if (!isSupportedInfrastructureNode) {
    return false;
  }
  boolean isSupportedArtifactType=false;
  if (this.archiveArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.scriptArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.warArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.bpelArchiveArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.sqlArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  return isSupportedArtifactType;
}","/** 
 * Checks whether this Plugin can handle deploying artifacts of the given artfiactType to a given InfrastructureNode of the given infrastructureNodeType
 * @param scriptArtifactType a QName denoting an scriptArtifactType
 * @param infrastructureNodeType a QName denoting an infrastructureNodeType
 * @param isDA indicates whether this check is on an IA or DA with the given artifactType
 * @return a Boolean. True if given pair of QName's denotes a pair whichthis plugin can handle
 */
private boolean isSupportedDeploymentPair(QName artifactType,QName infrastructureNodeType,boolean isDA){
  if (!isDA && this.warArtifactType.equals(artifactType) && infrastructureNodeType.equals(new QName(""String_Node_Str"",""String_Node_Str""))) {
    return true;
  }
  boolean isSupportedArtifactType=false;
  if (this.archiveArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.scriptArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.bpelArchiveArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.warArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.sqlArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (!PluginUtils.isSupportedUbuntuVMNodeType(infrastructureNodeType)) {
    return false;
  }
  return isSupportedArtifactType;
}"
41543,"@Override public boolean canHandle(AbstractImplementationArtifact ia,AbstractNodeType infrastructureNodeType){
  QName type=ia.getArtifactType();
  PrePhasePlugin.LOG.debug(""String_Node_Str"" + type.toString() + ""String_Node_Str""+ infrastructureNodeType.getId().toString()+ ""String_Node_Str"");
  return this.isSupportedDeploymentPair(type,infrastructureNodeType.getId());
}","@Override public boolean canHandle(AbstractImplementationArtifact ia,AbstractNodeType infrastructureNodeType){
  QName type=ia.getArtifactType();
  PrePhasePlugin.LOG.debug(""String_Node_Str"" + type.toString() + ""String_Node_Str""+ infrastructureNodeType.getId().toString()+ ""String_Node_Str"");
  return this.isSupportedDeploymentPair(type,infrastructureNodeType.getId(),false);
}"
41544,"/** 
 * Adds necessary BPEL logic through the given Context, to deploy the given ArtifactReferences unto the specified InfrastructureNode
 * @param context a TemplateContext
 * @param refs the ArtifactReferences to deploy
 * @param artifactName the name of the artifact, where the references originate from
 * @param nodeTemplate a NodeTemplate which is a InfrastructureNode to deploy the AbstractReferences on
 * @return true iff adding the logic was successful
 */
private boolean handle(TemplatePlanContext templateContext,List<AbstractArtifactReference> refs,String artifactName,AbstractNodeTemplate nodeTemplate){
  Variable serverIpPropWrapper=null;
  for (  String serverIpName : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(nodeTemplate,serverIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmLoginName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(nodeTemplate,vmLoginName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmLoginName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmLoginName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmLoginPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(nodeTemplate,vmLoginPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
LOG.debug(""String_Node_Str"");
String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
default :
return false;
}
}
String templateId=nodeTemplate.getId();
if (templateId.equals(""String_Node_Str"")) {
Handler.LOG.warn(""String_Node_Str"");
return false;
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
for (AbstractArtifactReference ref : refs) {
this.invokerPlugin.handleArtifactReferenceUpload(ref,templateContext,serverIpPropWrapper,sshUserVariable,sshKeyVariable,templateId);
}
return true;
}","/** 
 * Adds necessary BPEL logic through the given Context, to deploy the given ArtifactReferences unto the specified InfrastructureNode
 * @param context a TemplateContext
 * @param refs the ArtifactReferences to deploy
 * @param artifactName the name of the artifact, where the references originate from
 * @param nodeTemplate a NodeTemplate which is a InfrastructureNode to deploy the AbstractReferences on
 * @return true iff adding the logic was successful
 */
private boolean handle(TemplatePlanContext templateContext,List<AbstractArtifactReference> refs,String artifactName,AbstractNodeTemplate nodeTemplate){
  Variable serverIpPropWrapper=null;
  for (  String serverIpName : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(nodeTemplate,serverIpName);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIpName,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmLoginName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(nodeTemplate,vmLoginName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmLoginName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmLoginName,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmLoginPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(nodeTemplate,vmLoginPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmLoginPassword,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANUSER);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
LOG.debug(""String_Node_Str"");
String cleanName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANPASSWD);
break;
default :
return false;
}
}
String templateId=nodeTemplate.getId();
if (templateId.equals(""String_Node_Str"")) {
Handler.LOG.warn(""String_Node_Str"");
return false;
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
for (AbstractArtifactReference ref : refs) {
this.invokerPlugin.handleArtifactReferenceUpload(ref,templateContext,serverIpPropWrapper,sshUserVariable,sshKeyVariable,templateId);
}
return true;
}"
41545,"public boolean handleArtifactReferenceUpload(AbstractArtifactReference ref,TemplatePlanContext templateContext,Variable serverIp,Variable sshUser,Variable sshKey,String templateId,boolean appendToPrePhase) throws IOException {
  LOG.debug(""String_Node_Str"" + ref.getReference());
  String ubuntuFilePath=""String_Node_Str"" + templateContext.getCSARFileName() + ""String_Node_Str""+ ref.getReference();
  String ubuntuFilePathVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable ubuntuFilePathVar=templateContext.createGlobalStringVariable(ubuntuFilePathVarName,ubuntuFilePath);
  String ubuntuFolderPathScript=""String_Node_Str"" + this.fileReferenceToFolder(ubuntuFilePath);
  String containerAPIAbsoluteURIXPathQuery=this.createXPathQueryForURLRemoteFilePath(ref.getReference());
  String containerAPIAbsoluteURIVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable containerAPIAbsoluteURIVar=templateContext.createGlobalStringVariable(containerAPIAbsoluteURIVarName,""String_Node_Str"");
  try {
    Node assignNode=this.loadAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + templateContext.getIdForNames(),containerAPIAbsoluteURIXPathQuery,containerAPIAbsoluteURIVar.getName());
    assignNode=templateContext.importNode(assignNode);
    if (appendToPrePhase) {
      templateContext.getPrePhaseElement().appendChild(assignNode);
    }
 else {
      templateContext.getProvisioningPhaseElement().appendChild(assignNode);
    }
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
    return false;
  }
catch (  SAXException e) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
  String mkdirScriptVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable mkdirScriptVar=templateContext.createGlobalStringVariable(mkdirScriptVarName,ubuntuFolderPathScript);
  String cleanName=serverIp.getName().substring(serverIp.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
    runScriptRequestInputParams.put(""String_Node_Str"",serverIp);
  runScriptRequestInputParams.put(""String_Node_Str"",sshKey);
runScriptRequestInputParams.put(""String_Node_Str"",sshUser);
runScriptRequestInputParams.put(""String_Node_Str"",mkdirScriptVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIp);
runScriptRequestInputParams.put(""String_Node_Str"",sshUser);
runScriptRequestInputParams.put(""String_Node_Str"",sshKey);
runScriptRequestInputParams.put(""String_Node_Str"",mkdirScriptVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
default :
return false;
}
Map<String,Variable> transferFileRequestInputParams=new HashMap<String,Variable>();
String cleanName2=serverIp.getName().substring(serverIp.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName2) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
transferFileRequestInputParams.put(""String_Node_Str"",serverIp);
transferFileRequestInputParams.put(""String_Node_Str"",sshUser);
transferFileRequestInputParams.put(""String_Node_Str"",sshKey);
transferFileRequestInputParams.put(""String_Node_Str"",ubuntuFilePathVar);
transferFileRequestInputParams.put(""String_Node_Str"",containerAPIAbsoluteURIVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",transferFileRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
transferFileRequestInputParams.put(""String_Node_Str"",serverIp);
transferFileRequestInputParams.put(""String_Node_Str"",sshUser);
transferFileRequestInputParams.put(""String_Node_Str"",sshKey);
transferFileRequestInputParams.put(""String_Node_Str"",ubuntuFilePathVar);
transferFileRequestInputParams.put(""String_Node_Str"",containerAPIAbsoluteURIVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",transferFileRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
default :
return false;
}
return true;
}","public boolean handleArtifactReferenceUpload(AbstractArtifactReference ref,TemplatePlanContext templateContext,Variable serverIp,Variable sshUser,Variable sshKey,String templateId,boolean appendToPrePhase) throws IOException {
  LOG.debug(""String_Node_Str"" + ref.getReference());
  String ubuntuFilePath=""String_Node_Str"" + templateContext.getCSARFileName() + ""String_Node_Str""+ ref.getReference();
  String ubuntuFilePathVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable ubuntuFilePathVar=templateContext.createGlobalStringVariable(ubuntuFilePathVarName,ubuntuFilePath);
  String ubuntuFolderPathScript=""String_Node_Str"" + this.fileReferenceToFolder(ubuntuFilePath);
  String containerAPIAbsoluteURIXPathQuery=this.createXPathQueryForURLRemoteFilePath(ref.getReference());
  String containerAPIAbsoluteURIVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable containerAPIAbsoluteURIVar=templateContext.createGlobalStringVariable(containerAPIAbsoluteURIVarName,""String_Node_Str"");
  try {
    Node assignNode=this.loadAssignXpathQueryToStringVarFragmentAsNode(""String_Node_Str"" + templateContext.getIdForNames(),containerAPIAbsoluteURIXPathQuery,containerAPIAbsoluteURIVar.getName());
    assignNode=templateContext.importNode(assignNode);
    if (appendToPrePhase) {
      templateContext.getPrePhaseElement().appendChild(assignNode);
    }
 else {
      templateContext.getProvisioningPhaseElement().appendChild(assignNode);
    }
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
    return false;
  }
catch (  SAXException e) {
    LOG.error(""String_Node_Str"");
    return false;
  }
  Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
  String mkdirScriptVarName=""String_Node_Str"" + templateContext.getIdForNames();
  Variable mkdirScriptVar=templateContext.createGlobalStringVariable(mkdirScriptVarName,ubuntuFolderPathScript);
  String cleanName=serverIp.getName().substring(serverIp.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
    runScriptRequestInputParams.put(""String_Node_Str"",serverIp);
  runScriptRequestInputParams.put(""String_Node_Str"",sshKey);
runScriptRequestInputParams.put(""String_Node_Str"",sshUser);
runScriptRequestInputParams.put(""String_Node_Str"",mkdirScriptVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIp);
runScriptRequestInputParams.put(""String_Node_Str"",sshUser);
runScriptRequestInputParams.put(""String_Node_Str"",sshKey);
runScriptRequestInputParams.put(""String_Node_Str"",mkdirScriptVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
default :
return false;
}
Map<String,Variable> transferFileRequestInputParams=new HashMap<String,Variable>();
String cleanName2=serverIp.getName().substring(serverIp.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanName2) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
transferFileRequestInputParams.put(""String_Node_Str"",serverIp);
transferFileRequestInputParams.put(""String_Node_Str"",sshUser);
transferFileRequestInputParams.put(""String_Node_Str"",sshKey);
transferFileRequestInputParams.put(""String_Node_Str"",ubuntuFilePathVar);
transferFileRequestInputParams.put(""String_Node_Str"",containerAPIAbsoluteURIVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",transferFileRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
transferFileRequestInputParams.put(""String_Node_Str"",serverIp);
transferFileRequestInputParams.put(""String_Node_Str"",sshUser);
transferFileRequestInputParams.put(""String_Node_Str"",sshKey);
transferFileRequestInputParams.put(""String_Node_Str"",ubuntuFilePathVar);
transferFileRequestInputParams.put(""String_Node_Str"",containerAPIAbsoluteURIVar);
this.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",transferFileRequestInputParams,new HashMap<String,Variable>(),appendToPrePhase);
break;
default :
return false;
}
return true;
}"
41546,"/** 
 * Adds logic to the BuildPlan to call a Script on a remote machine
 * @param context the TemplatePlanContext where the logical provisioning operation is called
 * @param operation the operation to call
 * @param ia the ia that implements the operation
 * @return true iff adding BPEL Fragment was successful
 */
public boolean handle(TemplatePlanContext templateContext,AbstractOperation operation,AbstractImplementationArtifact ia){
  AbstractArtifactReference scriptRef=this.fetchScriptRefFromIA(ia);
  if (scriptRef == null) {
    return false;
  }
  List<AbstractNodeTemplate> nodes=new ArrayList<AbstractNodeTemplate>();
  Utils.getInfrastructureNodes(templateContext.getNodeTemplate(),nodes);
  nodes.add(templateContext.getNodeTemplate());
  AbstractNodeTemplate ubuntuNodeTemplate=null;
  String templateId=""String_Node_Str"";
  for (  AbstractNodeTemplate nodeTemplate : nodes) {
    if (PluginUtils.isSupportedUbuntuVMNodeType(nodeTemplate.getType().getId())) {
      ubuntuNodeTemplate=nodeTemplate;
      templateId=nodeTemplate.getId();
    }
  }
  if (templateId.equals(""String_Node_Str"")) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  if (templateContext.getNodeTemplate() == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String serverIp : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(ubuntuNodeTemplate,serverIp);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,false);
      }
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmUserName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmUserName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmUserName,false);
      }
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmUserPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,false);
      }
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
default :
return false;
}
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
Variable runShScriptStringVar=this.appendBPELAssignOperationShScript(templateContext,operation,scriptRef,ia);
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
default :
return false;
}
return true;
}","/** 
 * Adds logic to the BuildPlan to call a Script on a remote machine
 * @param context the TemplatePlanContext where the logical provisioning operation is called
 * @param operation the operation to call
 * @param ia the ia that implements the operation
 * @return true iff adding BPEL Fragment was successful
 */
public boolean handle(TemplatePlanContext templateContext,AbstractOperation operation,AbstractImplementationArtifact ia){
  AbstractArtifactReference scriptRef=this.fetchScriptRefFromIA(ia);
  if (scriptRef == null) {
    return false;
  }
  List<AbstractNodeTemplate> nodes=templateContext.getInfrastructureNodes();
  nodes.add(templateContext.getNodeTemplate());
  AbstractNodeTemplate ubuntuNodeTemplate=null;
  String templateId=""String_Node_Str"";
  for (  AbstractNodeTemplate nodeTemplate : nodes) {
    if (PluginUtils.isSupportedUbuntuVMNodeType(nodeTemplate.getType().getId())) {
      ubuntuNodeTemplate=nodeTemplate;
      templateId=nodeTemplate.getId();
    }
  }
  if (templateId.equals(""String_Node_Str"")) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  if (templateContext.getNodeTemplate() == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable serverIpPropWrapper=null;
  for (  String serverIp : PluginUtils.getSupportedVirtualMachineIPPropertyNames()) {
    serverIpPropWrapper=templateContext.getPropertyVariable(ubuntuNodeTemplate,serverIp);
    if (serverIpPropWrapper == null) {
      serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,true);
      if (serverIpPropWrapper == null) {
        serverIpPropWrapper=templateContext.getPropertyVariable(serverIp,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (serverIpPropWrapper == null) {
    Handler.LOG.warn(""String_Node_Str"");
    return false;
  }
  Variable sshUserVariable=null;
  for (  String vmUserName : PluginUtils.getSupportedVirtualMachineLoginUserNamePropertyNames()) {
    sshUserVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserName);
    if (sshUserVariable == null) {
      sshUserVariable=templateContext.getPropertyVariable(vmUserName,true);
      if (sshUserVariable == null) {
        sshUserVariable=templateContext.getPropertyVariable(vmUserName,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (sshUserVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshUserVariable,templateContext)) {
      sshUserVariable=null;
    }
  }
  Variable sshKeyVariable=null;
  for (  String vmUserPassword : PluginUtils.getSupportedVirtualMachineLoginPasswordPropertyNames()) {
    sshKeyVariable=templateContext.getPropertyVariable(ubuntuNodeTemplate,vmUserPassword);
    if (sshKeyVariable == null) {
      sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,true);
      if (sshKeyVariable == null) {
        sshKeyVariable=templateContext.getPropertyVariable(vmUserPassword,false);
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (sshKeyVariable == null) {
    return false;
  }
 else {
    if (Utils.isVariableValueEmpty(sshKeyVariable,templateContext)) {
      sshKeyVariable=null;
    }
  }
  if (sshUserVariable == null) {
    String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
      LOG.debug(""String_Node_Str"");
    templateContext.addStringValueToPlanRequest(""String_Node_Str"");
  break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINNAME);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANUSER);
break;
default :
return false;
}
}
if (sshKeyVariable == null) {
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMLOGINPASSWORD);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANPASSWD);
break;
default :
return false;
}
}
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
LOG.debug(""String_Node_Str"");
templateContext.addStringValueToPlanRequest(""String_Node_Str"");
Map<String,Variable> runScriptRequestInputParams=new HashMap<String,Variable>();
Variable runShScriptStringVar=this.appendBPELAssignOperationShScript(templateContext,operation,scriptRef,ia);
String cleanPropName=serverIpPropWrapper.getName().substring(serverIpPropWrapper.getName().lastIndexOf(""String_Node_Str"") + 1);
switch (cleanPropName) {
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_SERVERIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_VMIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
case Properties.OPENTOSCA_DECLARATIVE_PROPERTYNAME_RASPBIANIP:
runScriptRequestInputParams.put(""String_Node_Str"",serverIpPropWrapper);
runScriptRequestInputParams.put(""String_Node_Str"",sshKeyVariable);
runScriptRequestInputParams.put(""String_Node_Str"",sshUserVariable);
runScriptRequestInputParams.put(""String_Node_Str"",runShScriptStringVar);
this.invokerPlugin.handle(templateContext,templateId,true,""String_Node_Str"",Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM,""String_Node_Str"",runScriptRequestInputParams,new HashMap<String,Variable>(),false);
break;
default :
return false;
}
return true;
}"
41547,"/** 
 * Exports the given BuildPlans repackaged with the CSAR denoted by the given CSARID
 * @param buildPlans the BuildPlans to export
 * @param csarId the CSARID of a CSAR
 * @return a File denoting the absolute Path to the exported CSAR
 */
public File export(List<BuildPlan> buildPlans,CSARID csarId){
  CSARContent csarContent=null;
  try {
    csarContent=this.handler.getCSARContentForID(csarId);
  }
 catch (  UserException e1) {
    Exporter.LOG.error(""String_Node_Str"",e1);
  }
  if (csarContent == null) {
    return null;
  }
  String csarName=csarId.getFileName();
  IFileAccessService service=this.getFileAccessService();
  File tempDir=service.getTemp();
  File pathToRepackagedCsar=service.getTemp();
  File repackagedCsar=new File(pathToRepackagedCsar,csarName);
  try {
    Set<AbstractFile> files=csarContent.getFilesRecursively();
    AbstractFile mainDefFile=csarContent.getRootTOSCA();
    File rootDefFile=mainDefFile.getFile().toFile();
    Definitions defs=this.parseDefinitionsFile(rootDefFile);
    List<TServiceTemplate> servTemps=this.getServiceTemplates(defs);
    List<BuildPlan> plansToExport=new ArrayList<BuildPlan>();
    for (    BuildPlan buildPlan : buildPlans) {
      for (      TServiceTemplate serviceTemplate : servTemps) {
        if (buildPlan.getServiceTemplate().toString().equals(this.buildQName(defs,serviceTemplate).toString())) {
          TPlans plans=serviceTemplate.getPlans();
          if (plans == null) {
            plans=this.toscaFactory.createTPlans();
            serviceTemplate.setPlans(plans);
          }
          List<TPlan> planList=plans.getPlan();
          planList.add(this.generateTPlanElement(buildPlan));
          plansToExport.add(buildPlan);
        }
      }
    }
    for (    AbstractFile file : files) {
      if (file.getFile().toFile().toString().equals(rootDefFile.toString())) {
        continue;
      }
      File newLocation=new File(tempDir,file.getPath());
      Exporter.LOG.debug(newLocation.getAbsolutePath());
      Exporter.LOG.debug(file.getFile().toString());
      if (newLocation.isDirectory()) {
        FileUtils.copyDirectory(file.getFile().toFile(),newLocation);
      }
 else {
        FileUtils.copyFile(file.getFile().toFile(),newLocation);
      }
    }
    File newDefsFile=new File(tempDir,mainDefFile.getPath());
    newDefsFile.createNewFile();
    JAXBContext jaxbContext=JAXBContext.newInstance(Definitions.class);
    Marshaller m=jaxbContext.createMarshaller();
    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
    m.marshal(defs,newDefsFile);
    for (    BuildPlan plan : plansToExport) {
      File planPath=new File(tempDir,this.generateRelativePlanPath(plan));
      Exporter.LOG.debug(planPath.toString());
      planPath.getParentFile().mkdirs();
      planPath.createNewFile();
      this.simpleExporter.export(planPath.toURI(),plan);
    }
    File selfServiceDir=new File(tempDir,""String_Node_Str"");
    File selfServiceDataXml=new File(selfServiceDir,""String_Node_Str"");
    JAXBContext jaxbContextWineryApplication=JAXBContext.newInstance(Application.class);
    if (selfServiceDir.exists() && selfServiceDataXml.exists()) {
      Unmarshaller u=jaxbContextWineryApplication.createUnmarshaller();
      Application appDesc=(Application)u.unmarshal(selfServiceDataXml);
      if (appDesc.getOptions() != null) {
        for (        ApplicationOption option : appDesc.getOptions().getOption()) {
          for (          BuildPlan plan : plansToExport) {
            if (option.getPlanServiceName().equals(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart())) {
              if (!new File(selfServiceDir,option.getPlanInputMessageUrl()).exists()) {
                File planInputFile=new File(selfServiceDir,option.getPlanInputMessageUrl());
                this.writePlanInputMessageInstance(plan,planInputFile);
              }
            }
          }
        }
      }
 else {
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
 else {
      if (selfServiceDir.mkdirs() && selfServiceDataXml.createNewFile()) {
        Application appDesc=new Application();
        appDesc.setDisplayName(csarName);
        appDesc.setDescription(""String_Node_Str"");
        appDesc.setIconUrl(""String_Node_Str"");
        appDesc.setImageUrl(""String_Node_Str"");
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
  }
 catch (  IOException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  JAXBException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  SystemException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
  service.zip(tempDir,repackagedCsar);
  Exporter.LOG.debug(repackagedCsar.toString());
  return repackagedCsar;
}","/** 
 * Exports the given BuildPlans repackaged with the CSAR denoted by the given CSARID
 * @param buildPlans the BuildPlans to export
 * @param csarId the CSARID of a CSAR
 * @return a File denoting the absolute Path to the exported CSAR
 */
public File export(List<BuildPlan> buildPlans,CSARID csarId){
  CSARContent csarContent=null;
  try {
    csarContent=this.handler.getCSARContentForID(csarId);
  }
 catch (  UserException e1) {
    Exporter.LOG.error(""String_Node_Str"",e1);
  }
  if (csarContent == null) {
    return null;
  }
  String csarName=csarId.getFileName();
  IFileAccessService service=this.getFileAccessService();
  File tempDir=service.getTemp();
  File pathToRepackagedCsar=service.getTemp();
  File repackagedCsar=new File(pathToRepackagedCsar,csarName);
  try {
    Set<AbstractFile> files=csarContent.getFilesRecursively();
    AbstractFile mainDefFile=csarContent.getRootTOSCA();
    File rootDefFile=mainDefFile.getFile().toFile();
    Definitions defs=this.parseDefinitionsFile(rootDefFile);
    List<TServiceTemplate> servTemps=this.getServiceTemplates(defs);
    List<BuildPlan> plansToExport=new ArrayList<BuildPlan>();
    for (    BuildPlan buildPlan : buildPlans) {
      for (      TServiceTemplate serviceTemplate : servTemps) {
        if (buildPlan.getServiceTemplate().equals(this.buildQName(defs,serviceTemplate))) {
          TPlans plans=serviceTemplate.getPlans();
          if (plans == null) {
            plans=this.toscaFactory.createTPlans();
            serviceTemplate.setPlans(plans);
          }
          List<TPlan> planList=plans.getPlan();
          planList.add(this.generateTPlanElement(buildPlan));
          plansToExport.add(buildPlan);
        }
      }
    }
    for (    AbstractFile file : files) {
      if (file.getFile().toFile().toString().equals(rootDefFile.toString())) {
        continue;
      }
      File newLocation=new File(tempDir,file.getPath());
      Exporter.LOG.debug(newLocation.getAbsolutePath());
      Exporter.LOG.debug(file.getFile().toString());
      if (newLocation.isDirectory()) {
        FileUtils.copyDirectory(file.getFile().toFile(),newLocation);
      }
 else {
        FileUtils.copyFile(file.getFile().toFile(),newLocation);
      }
    }
    File newDefsFile=new File(tempDir,mainDefFile.getPath());
    newDefsFile.createNewFile();
    JAXBContext jaxbContext=JAXBContext.newInstance(Definitions.class);
    Marshaller m=jaxbContext.createMarshaller();
    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
    m.marshal(defs,newDefsFile);
    for (    BuildPlan plan : plansToExport) {
      File planPath=new File(tempDir,this.generateRelativePlanPath(plan));
      Exporter.LOG.debug(planPath.toString());
      planPath.getParentFile().mkdirs();
      planPath.createNewFile();
      this.simpleExporter.export(planPath.toURI(),plan);
    }
    File selfServiceDir=new File(tempDir,""String_Node_Str"");
    File selfServiceDataXml=new File(selfServiceDir,""String_Node_Str"");
    JAXBContext jaxbContextWineryApplication=JAXBContext.newInstance(Application.class);
    if (selfServiceDir.exists() && selfServiceDataXml.exists()) {
      Unmarshaller u=jaxbContextWineryApplication.createUnmarshaller();
      Application appDesc=(Application)u.unmarshal(selfServiceDataXml);
      if (appDesc.getOptions() != null) {
        for (        ApplicationOption option : appDesc.getOptions().getOption()) {
          for (          BuildPlan plan : plansToExport) {
            if (option.getPlanServiceName().equals(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart())) {
              if (!new File(selfServiceDir,option.getPlanInputMessageUrl()).exists()) {
                File planInputFile=new File(selfServiceDir,option.getPlanInputMessageUrl());
                this.writePlanInputMessageInstance(plan,planInputFile);
              }
            }
          }
        }
      }
 else {
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
 else {
      if (selfServiceDir.mkdirs() && selfServiceDataXml.createNewFile()) {
        Application appDesc=new Application();
        appDesc.setDisplayName(csarName);
        appDesc.setDescription(""String_Node_Str"");
        appDesc.setIconUrl(""String_Node_Str"");
        appDesc.setImageUrl(""String_Node_Str"");
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
  }
 catch (  IOException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  JAXBException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  SystemException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
  service.zip(tempDir,repackagedCsar);
  Exporter.LOG.debug(repackagedCsar.toString());
  return repackagedCsar;
}"
41548,"private void rewriteServiceNames(Deploy deploy,List<File> referencedFiles,String csarName) throws WSDLException, FileNotFoundException {
  WSDLFactory factory=WSDLFactory.newInstance();
  WSDLReader reader=factory.newWSDLReader();
  WSDLWriter writer=factory.newWSDLWriter();
  List<TInvoke> invokes=deploy.getProcess().get(0).getInvoke();
  List<TProvide> provides=deploy.getProcess().get(0).getProvide();
  List<QName> servicesToRewrite=new ArrayList<QName>();
  for (  TInvoke invoke : invokes) {
    if (invoke.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    TService service=invoke.getService();
    QName serviceName=service.getName();
    servicesToRewrite.add(serviceName);
    QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart());
    service.setName(renamedServiceName);
    invoke.setService(service);
  }
  for (  TProvide provide : provides) {
    if (provide.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    TService service=provide.getService();
    QName serviceName=service.getName();
    servicesToRewrite.add(serviceName);
    QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart());
    service.setName(renamedServiceName);
    provide.setService(service);
  }
  for (  QName serviceName : servicesToRewrite) {
    for (    File file : referencedFiles) {
      if (!file.getAbsolutePath().endsWith(""String_Node_Str"")) {
        continue;
      }
      Definition def=reader.readWSDL(file.getAbsolutePath());
      List<QName> servicesToRemove=new ArrayList<QName>();
      for (      Object obj : def.getAllServices().values()) {
        Service service=(Service)obj;
        if (serviceName.toString().equals(service.getQName().toString())) {
          servicesToRemove.add(service.getQName());
          Service newService=new ServiceImpl();
          for (          Object o : service.getPorts().values()) {
            Port port=(Port)o;
            newService.addPort(port);
          }
          newService.setQName(new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart()));
          def.addService(newService);
        }
      }
      for (      QName serviceToRemove : servicesToRemove) {
        def.removeService(serviceToRemove);
      }
      writer.writeWSDL(def,new FileOutputStream(file));
    }
  }
}","private void rewriteServiceNames(Deploy deploy,List<File> referencedFiles,String csarName) throws WSDLException, FileNotFoundException {
  WSDLFactory factory=WSDLFactory.newInstance();
  WSDLReader reader=factory.newWSDLReader();
  WSDLWriter writer=factory.newWSDLWriter();
  List<TInvoke> invokes=deploy.getProcess().get(0).getInvoke();
  List<TProvide> provides=deploy.getProcess().get(0).getProvide();
  List<QName> servicesToRewrite=new ArrayList<QName>();
  for (  TInvoke invoke : invokes) {
    if (invoke.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    TService service=invoke.getService();
    QName serviceName=service.getName();
    servicesToRewrite.add(serviceName);
    QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart());
    service.setName(renamedServiceName);
    invoke.setService(service);
  }
  for (  TProvide provide : provides) {
    if (provide.getPartnerLink().equals(""String_Node_Str"")) {
      continue;
    }
    TService service=provide.getService();
    QName serviceName=service.getName();
    servicesToRewrite.add(serviceName);
    QName renamedServiceName=new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart());
    service.setName(renamedServiceName);
    provide.setService(service);
  }
  for (  QName serviceName : servicesToRewrite) {
    for (    File file : referencedFiles) {
      if (!file.getAbsolutePath().endsWith(""String_Node_Str"")) {
        continue;
      }
      Definition def=reader.readWSDL(file.getAbsolutePath());
      List<QName> servicesToRemove=new ArrayList<QName>();
      for (      Object obj : def.getAllServices().values()) {
        Service service=(Service)obj;
        if (serviceName.equals(service.getQName())) {
          servicesToRemove.add(service.getQName());
          Service newService=new ServiceImpl();
          for (          Object o : service.getPorts().values()) {
            Port port=(Port)o;
            newService.addPort(port);
          }
          newService.setQName(new QName(serviceName.getNamespaceURI(),csarName + serviceName.getLocalPart()));
          def.addService(newService);
        }
      }
      for (      QName serviceToRemove : servicesToRemove) {
        def.removeService(serviceToRemove);
      }
      writer.writeWSDL(def,new FileOutputStream(file));
    }
  }
}"
41549,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  DeploymentArtifactImpl other=(DeploymentArtifactImpl)obj;
  if (artifact == null) {
    if (other.artifact != null)     return false;
  }
 else   if (!artifact.equals(other.artifact))   return false;
  if (def == null) {
    if (other.def != null)     return false;
  }
 else   if (!def.equals(other.def))   return false;
  if (!other.getArtifactType().toString().equals(this.getArtifactType().toString())) {
    return false;
  }
  if (!this.getName().equals(other.getName())) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  DeploymentArtifactImpl other=(DeploymentArtifactImpl)obj;
  if (artifact == null) {
    if (other.artifact != null)     return false;
  }
 else   if (!artifact.equals(other.artifact))   return false;
  if (def == null) {
    if (other.def != null)     return false;
  }
 else   if (!def.equals(other.def))   return false;
  if (!other.getArtifactType().equals(this.getArtifactType())) {
    return false;
  }
  if (!this.getName().equals(other.getName())) {
    return false;
  }
  return true;
}"
41550,"/** 
 * {@inheritDoc}
 */
@Override public List<AbstractNodeTypeImplementation> getImplementations(){
  List<AbstractNodeTypeImplementation> impls=new ArrayList<AbstractNodeTypeImplementation>();
  List<AbstractNodeTypeImplementation> foundImpls=this.findNodeTypeImpls(this.definitions);
  for (  AbstractNodeTypeImplementation impl : foundImpls) {
    if (impl == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (impl.getNodeType() == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (this.nodeTemplate == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (this.nodeTemplate.getType() == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    NodeTemplateImpl.LOG.debug(""String_Node_Str"" + impl.getName() + ""String_Node_Str""+ this.nodeTemplate.getId());
    if (impl.getNodeType().getId().toString().equals(this.nodeTemplate.getType().toString())) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"" + this.nodeTemplate.getId() + ""String_Node_Str""+ impl.getName());
      impls.add(impl);
    }
  }
  return impls;
}","/** 
 * {@inheritDoc}
 */
@Override public List<AbstractNodeTypeImplementation> getImplementations(){
  List<AbstractNodeTypeImplementation> impls=new ArrayList<AbstractNodeTypeImplementation>();
  List<AbstractNodeTypeImplementation> foundImpls=this.findNodeTypeImpls(this.definitions);
  for (  AbstractNodeTypeImplementation impl : foundImpls) {
    if (impl == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (impl.getNodeType() == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (this.nodeTemplate == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    if (this.nodeTemplate.getType() == null) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"");
    }
    NodeTemplateImpl.LOG.debug(""String_Node_Str"" + impl.getName() + ""String_Node_Str""+ this.nodeTemplate.getId());
    if (impl.getNodeType().getId().equals(this.nodeTemplate.getType())) {
      NodeTemplateImpl.LOG.debug(""String_Node_Str"" + this.nodeTemplate.getId() + ""String_Node_Str""+ impl.getName());
      impls.add(impl);
    }
  }
  return impls;
}"
41551,"/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getType(){
  if (this.nodeTemplate == null) {
    NodeTemplateImpl.LOG.debug(""String_Node_Str"");
  }
  if (this.nodeTemplate.getType() == null) {
    NodeTemplateImpl.LOG.debug(""String_Node_Str"");
  }
  for (  AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
    if (nodeType.getId().toString().equals(this.nodeTemplate.getType().toString())) {
      return nodeType;
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getType(){
  if (this.nodeTemplate == null) {
    NodeTemplateImpl.LOG.debug(""String_Node_Str"");
  }
  if (this.nodeTemplate.getType() == null) {
    NodeTemplateImpl.LOG.debug(""String_Node_Str"");
  }
  for (  AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
    if (nodeType.getId().equals(this.nodeTemplate.getType())) {
      return nodeType;
    }
  }
  return null;
}"
41552,"/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getTypeRef(){
  if (this.nodeType.getDerivedFrom() != null) {
    for (    AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
      if (nodeType.getId().toString().equals(this.nodeType.getDerivedFrom().getTypeRef().toString())) {
        return nodeType;
      }
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getTypeRef(){
  if (this.nodeType.getDerivedFrom() != null) {
    for (    AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
      if (nodeType.getId().equals(this.nodeType.getDerivedFrom().getTypeRef())) {
        return nodeType;
      }
    }
  }
  return null;
}"
41553,"/** 
 * {@inheritDoc}
 */
@Override public QName getId(){
  String namespace;
  if ((this.getTargetNamespace() != null) && !this.getTargetNamespace().equals(""String_Node_Str"")) {
    namespace=this.getTargetNamespace();
  }
 else {
    namespace=this.definitions.getTargetNamespace();
  }
  return new QName(""String_Node_Str"" + namespace + ""String_Node_Str""+ this.getName());
}","/** 
 * {@inheritDoc}
 */
@Override public QName getId(){
  String namespace;
  if ((this.getTargetNamespace() != null) && !this.getTargetNamespace().equals(""String_Node_Str"")) {
    namespace=this.getTargetNamespace();
  }
 else {
    namespace=this.definitions.getTargetNamespace();
  }
  return new QName(namespace,this.getName());
}"
41554,"/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getNodeType(){
  if (this.nodeTypeImpl.getNodeType() == null) {
    NodeTypeImplementationImpl.LOG.error(""String_Node_Str"",""String_Node_Str"" + this.getTargetNamespace() + ""String_Node_Str""+ this.getName());
  }
  for (  AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
    if (nodeType.getId().toString().equals(this.nodeTypeImpl.getNodeType().toString())) {
      return nodeType;
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractNodeType getNodeType(){
  if (this.nodeTypeImpl.getNodeType() == null) {
    NodeTypeImplementationImpl.LOG.error(""String_Node_Str"",""String_Node_Str"" + this.getTargetNamespace() + ""String_Node_Str""+ this.getName());
  }
  for (  AbstractNodeType nodeType : this.definitions.getAllNodeTypes()) {
    if (nodeType.getId().equals(this.nodeTypeImpl.getNodeType())) {
      return nodeType;
    }
  }
  return null;
}"
41555,"/** 
 * {@inheritDoc}
 */
@Override public List<AbstractRelationshipTypeImplementation> getImplementations(){
  List<AbstractRelationshipTypeImplementation> impls=new ArrayList<AbstractRelationshipTypeImplementation>();
  for (  AbstractRelationshipTypeImplementation impl : this.findRelationshipTypeImpls(this.definitions)) {
    if (impl.getRelationshipType().getId().equals(this.relationshipTemplate.getType().getLocalPart())) {
      impls.add(impl);
    }
  }
  return impls;
}","/** 
 * {@inheritDoc}
 */
@Override public List<AbstractRelationshipTypeImplementation> getImplementations(){
  List<AbstractRelationshipTypeImplementation> impls=new ArrayList<AbstractRelationshipTypeImplementation>();
  for (  AbstractRelationshipTypeImplementation impl : this.findRelationshipTypeImpls(this.definitions)) {
    if (impl.getRelationshipType().getId().equals(this.relationshipTemplate.getType())) {
      impls.add(impl);
    }
  }
  return impls;
}"
41556,"/** 
 * {@inheritDoc}
 */
@Override public AbstractRelationshipType getReferencedType(){
  if (this.getTypeRef() != null) {
    for (    AbstractRelationshipType relation : this.definitions.getAllRelationshipTypes()) {
      if (relation.getId().toString().equals(this.getTypeRef().toString())) {
        return relation;
      }
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractRelationshipType getReferencedType(){
  if (this.getTypeRef() != null) {
    for (    AbstractRelationshipType relation : this.definitions.getAllRelationshipTypes()) {
      if (relation.getId().equals(this.getTypeRef())) {
        return relation;
      }
    }
  }
  return null;
}"
41557,"/** 
 * {@inheritDoc}
 */
@Override public AbstractRelationshipType getRelationshipType(){
  for (  AbstractRelationshipType relation : this.defs.getAllRelationshipTypes()) {
    if (relation.getId().toString().equals(this.relationshipTypeImpl.getRelationshipType().toString())) {
      return relation;
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractRelationshipType getRelationshipType(){
  for (  AbstractRelationshipType relation : this.defs.getAllRelationshipTypes()) {
    if (relation.getId().equals(this.relationshipTypeImpl.getRelationshipType())) {
      return relation;
    }
  }
  return null;
}"
41558,"/** 
 * Returns a RelationshipType for the given QName. This method looks trough the whole Definitions space, which means the search looks trough the imported Definitions of this Definitions.
 * @param relationshipTypeId a QName
 * @return an AbstractRelationshipType, if nothing was found null
 */
public AbstractRelationshipType getRelationshipType(QName relationshipTypeId){
  for (  AbstractRelationshipType relationshipType : this.getRelationshipTypes()) {
    if (relationshipType.getId().toString().equals(relationshipTypeId.toString())) {
      return relationshipType;
    }
  }
  return null;
}","/** 
 * Returns a RelationshipType for the given QName. This method looks trough the whole Definitions space, which means the search looks trough the imported Definitions of this Definitions.
 * @param relationshipTypeId a QName
 * @return an AbstractRelationshipType, if nothing was found null
 */
public AbstractRelationshipType getRelationshipType(QName relationshipTypeId){
  for (  AbstractRelationshipType relationshipType : this.getRelationshipTypes()) {
    if (relationshipType.getId().equals(relationshipTypeId)) {
      return relationshipType;
    }
  }
  return null;
}"
41559,"/** 
 * Returns a NodeType for the given QName, This method looks trough the whole Definitions space, which means the search looks trough the imported Definitions of this Definitions
 * @param nodeTypeId a QName
 * @return an AbstractNodeType, if nothing was found null
 */
public AbstractNodeType getNodeType(QName nodeTypeId){
  for (  AbstractNodeType nodeType : this.getNodeTypes()) {
    if (nodeType.getId().toString().equals(nodeTypeId.toString())) {
      return nodeType;
    }
  }
  return null;
}","/** 
 * Returns a NodeType for the given QName, This method looks trough the whole Definitions space, which means the search looks trough the imported Definitions of this Definitions
 * @param nodeTypeId a QName
 * @return an AbstractNodeType, if nothing was found null
 */
public AbstractNodeType getNodeType(QName nodeTypeId){
  for (  AbstractNodeType nodeType : this.getNodeTypes()) {
    if (nodeType.getId().equals(nodeTypeId)) {
      return nodeType;
    }
  }
  return null;
}"
41560,"/** 
 * Checks whether the given Node is an ubuntu nodeType that can be handled by the set of plugins used by the PlanBuilder.
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if the given nodeType is an ubuntu nodeType
 */
public static boolean isSupportedUbuntuVMNodeType(QName nodeType){
  if (nodeType.toString().equals(Types.ubuntuNodeType.toString())) {
    return true;
  }
  String nodeTypeNS=nodeType.getNamespaceURI();
  String nodeTypeLN=nodeType.getLocalPart();
  if (nodeTypeNS.equals(""String_Node_Str"") && PluginUtils.isProperUbuntuLocalName(nodeTypeLN)) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given Node is an ubuntu nodeType that can be handled by the set of plugins used by the PlanBuilder.
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if the given nodeType is an ubuntu nodeType
 */
public static boolean isSupportedUbuntuVMNodeType(QName nodeType){
  if (nodeType.equals(Types.ubuntuNodeType)) {
    return true;
  }
  String nodeTypeNS=nodeType.getNamespaceURI();
  String nodeTypeLN=nodeType.getLocalPart();
  if (nodeTypeNS.equals(""String_Node_Str"") && PluginUtils.isProperUbuntuLocalName(nodeTypeLN)) {
    return true;
  }
  return false;
}"
41561,"/** 
 * Checks whether the given NodeType is a cloud provider nodeType that can be handled by the set of plugins used by the PlanBuilder.
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if the given nodeType is a cloud providernodeType
 */
public static boolean isSupportedCloudProviderNodeType(QName nodeType){
  if (nodeType.toString().equals(Types.ec2NodeType.toString()) | nodeType.toString().equals(Types.openStackNodeType.toString())) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given NodeType is a cloud provider nodeType that can be handled by the set of plugins used by the PlanBuilder.
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if the given nodeType is a cloud providernodeType
 */
public static boolean isSupportedCloudProviderNodeType(QName nodeType){
  if (nodeType.equals(Types.ec2NodeType) | nodeType.equals(Types.openStackNodeType)) {
    return true;
  }
  return false;
}"
41562,"/** 
 * Checks whether the given Node is a virtual machine nodeType that can by handled by the set of plugins used by the PlanBuilder
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if given nodeType is a virtual machine nodeType
 */
public static boolean isSupportedVMNodeType(QName nodeType){
  if (nodeType.toString().equals(Types.vmNodeType.toString())) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given Node is a virtual machine nodeType that can by handled by the set of plugins used by the PlanBuilder
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if given nodeType is a virtual machine nodeType
 */
public static boolean isSupportedVMNodeType(QName nodeType){
  if (nodeType.equals(Types.vmNodeType)) {
    return true;
  }
  return false;
}"
41563,"private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().toString().equals(this.zipArtifactType.toString())) {
    return true;
  }
 else {
    return false;
  }
}","private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().equals(this.zipArtifactType)) {
    return true;
  }
 else {
    return false;
  }
}"
41564,"private AbstractArtifactReference fetchPhpAppDA(List<AbstractDeploymentArtifact> das){
  for (  AbstractDeploymentArtifact da : das) {
    if (da.getArtifactType().toString().equals(this.zipArtifactType.toString())) {
      for (      AbstractArtifactReference ref : da.getArtifactRef().getArtifactReferences()) {
        if (ref.getReference().endsWith(""String_Node_Str"")) {
          return ref;
        }
      }
    }
  }
  return null;
}","private AbstractArtifactReference fetchPhpAppDA(List<AbstractDeploymentArtifact> das){
  for (  AbstractDeploymentArtifact da : das) {
    if (da.getArtifactType().equals(this.zipArtifactType)) {
      for (      AbstractArtifactReference ref : da.getArtifactRef().getArtifactReferences()) {
        if (ref.getReference().endsWith(""String_Node_Str"")) {
          return ref;
        }
      }
    }
  }
  return null;
}"
41565,"/** 
 * Checks whether this Plugin can handle deploying artifacts of the given artfiactType to a given InfrastructureNode of the given infrastructureNodeType
 * @param scriptArtifactType a QName denoting an scriptArtifactType
 * @param infrastructureNodeType a QName denoting an infrastructureNodeType
 * @return a Boolean. True if given pair of QName's denotes a pair whichthis plugin can handle
 */
private boolean isSupportedDeploymentPair(QName artifactType,QName infrastructureNodeType){
  if (!PluginUtils.isSupportedUbuntuVMNodeType(infrastructureNodeType)) {
    return false;
  }
  boolean isSupportedArtifactType=false;
  if (this.archiveArtifactType.toString().equals(artifactType.toString())) {
    isSupportedArtifactType|=true;
  }
  if (this.scriptArtifactType.toString().equals(artifactType.toString())) {
    isSupportedArtifactType|=true;
  }
  if (this.warArtifactType.toString().equals(artifactType.toString())) {
    isSupportedArtifactType|=true;
  }
  return isSupportedArtifactType;
}","/** 
 * Checks whether this Plugin can handle deploying artifacts of the given artfiactType to a given InfrastructureNode of the given infrastructureNodeType
 * @param scriptArtifactType a QName denoting an scriptArtifactType
 * @param infrastructureNodeType a QName denoting an infrastructureNodeType
 * @return a Boolean. True if given pair of QName's denotes a pair whichthis plugin can handle
 */
private boolean isSupportedDeploymentPair(QName artifactType,QName infrastructureNodeType){
  if (!PluginUtils.isSupportedUbuntuVMNodeType(infrastructureNodeType)) {
    return false;
  }
  boolean isSupportedArtifactType=false;
  if (this.archiveArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.scriptArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  if (this.warArtifactType.equals(artifactType)) {
    isSupportedArtifactType|=true;
  }
  return isSupportedArtifactType;
}"
41566,"/** 
 * {@inheritDoc}
 */
@Override public boolean canHandle(QName artifactType){
  return artifactType.toString().equals(this.baseTypeScriptArtifact.toString());
}","/** 
 * {@inheritDoc}
 */
@Override public boolean canHandle(QName artifactType){
  return artifactType.equals(this.baseTypeScriptArtifact);
}"
41567,"/** 
 * {@inheritDoc}
 */
@Override public boolean canHandle(QName artifactType){
  return artifactType.toString().equals(this.openTOSCAWar.toString());
}","/** 
 * {@inheritDoc}
 */
@Override public boolean canHandle(QName artifactType){
  return artifactType.equals(this.openTOSCAWar);
}"
41568,"/** 
 * Checks whether the given QName represents a Apache Web Server NodeType compatible with this plugin
 * @param nodeTypeId a QName denoting a TOSCA NodeType
 * @return true iff the given QName is a NodeType this plugin can handle
 */
public static boolean isApacheNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.toString().equals(Plugin.apacheNodeType.toString())) {
    return true;
  }
  if (nodeTypeId.toString().equals(Plugin.apacheNodeTypeTOSCASpecificType.toString())) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given QName represents a Apache Web Server NodeType compatible with this plugin
 * @param nodeTypeId a QName denoting a TOSCA NodeType
 * @return true iff the given QName is a NodeType this plugin can handle
 */
public static boolean isApacheNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.equals(Plugin.apacheNodeType)) {
    return true;
  }
  if (nodeTypeId.equals(Plugin.apacheNodeTypeTOSCASpecificType)) {
    return true;
  }
  return false;
}"
41569,"public static boolean isSqlScriptArtifact(AbstractDeploymentArtifact da){
  if (da.getArtifactType().toString().equals(Constants.sqlScriptArtifactType.toString())) {
    return true;
  }
  return false;
}","public static boolean isSqlScriptArtifact(AbstractDeploymentArtifact da){
  if (da.getArtifactType().equals(Constants.sqlScriptArtifactType)) {
    return true;
  }
  return false;
}"
41570,"/** 
 * Checks whether the given QName represents a MySQL Server NodeType understood by this plugin
 * @param nodeTypeId a QName
 * @return true iff the QName represents a MySQL NodeType
 */
public static boolean isCompatibleMySQLServerNodeType(QName nodeTypeId){
  return Plugin.mySqlServerNodeType.toString().equals(nodeTypeId.toString());
}","/** 
 * Checks whether the given QName represents a MySQL Server NodeType understood by this plugin
 * @param nodeTypeId a QName
 * @return true iff the QName represents a MySQL NodeType
 */
public static boolean isCompatibleMySQLServerNodeType(QName nodeTypeId){
  return Plugin.mySqlServerNodeType.equals(nodeTypeId);
}"
41571,"/** 
 * Checks whether the given QName is accepted as an ApacheWebServer Node
 * @param nodeTypeId a QName
 * @return true iff the QName represents an ApacheWebServer
 */
private boolean isApacheWebServerNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.toString().equals(this.apacheNodeType.toString())) {
    return true;
  }
  if (nodeTypeId.toString().equals(this.apacheNodeTypeTOSCASpecificType.toString())) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given QName is accepted as an ApacheWebServer Node
 * @param nodeTypeId a QName
 * @return true iff the QName represents an ApacheWebServer
 */
private boolean isApacheWebServerNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.equals(this.apacheNodeType)) {
    return true;
  }
  if (nodeTypeId.equals(this.apacheNodeTypeTOSCASpecificType)) {
    return true;
  }
  return false;
}"
41572,"/** 
 * Checks whether the given QName is accepted as an PhpModule Node
 * @param nodeTypeId a QName
 * @return true iff the QName represents an PhpModule
 */
private boolean isPhpModuleNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.toString().equals(this.phpModule.toString())) {
    return true;
  }
  if (nodeTypeId.toString().equals(this.phpModuleTOSCASpecificType.toString())) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given QName is accepted as an PhpModule Node
 * @param nodeTypeId a QName
 * @return true iff the QName represents an PhpModule
 */
private boolean isPhpModuleNodeTypeCompatible(QName nodeTypeId){
  if (nodeTypeId.equals(this.phpModule)) {
    return true;
  }
  if (nodeTypeId.equals(this.phpModuleTOSCASpecificType)) {
    return true;
  }
  return false;
}"
41573,"private boolean isCompatiblePhpAppNodeType(AbstractNodeType nodeType){
  if (nodeType.getId().toString().equals(this.phpApp.toString())) {
    return true;
  }
  if (nodeType.getId().toString().equals(this.phpAppNodeTypePlanBuilder.toString())) {
    return true;
  }
  QName test=nodeType.getId();
  List<QName> typesInHierarchy=Utils.getNodeTypeHierarchy(nodeType);
  for (  QName hierarchyType : typesInHierarchy) {
    if (hierarchyType.toString().equals(this.phpApp.toString()) | hierarchyType.toString().equals(this.phpAppNodeTypePlanBuilder.toString())) {
      return true;
    }
  }
  return false;
}","private boolean isCompatiblePhpAppNodeType(AbstractNodeType nodeType){
  if (nodeType.getId().equals(this.phpApp)) {
    return true;
  }
  if (nodeType.getId().equals(this.phpAppNodeTypePlanBuilder)) {
    return true;
  }
  QName test=nodeType.getId();
  List<QName> typesInHierarchy=Utils.getNodeTypeHierarchy(nodeType);
  for (  QName hierarchyType : typesInHierarchy) {
    if (hierarchyType.equals(this.phpApp) | hierarchyType.equals(this.phpAppNodeTypePlanBuilder)) {
      return true;
    }
  }
  return false;
}"
41574,"private boolean hasZipArtfiactReference(AbstractDeploymentArtifact da){
  if (da.getArtifactType().toString().equals(this.zipArtifactType.toString())) {
    for (    AbstractArtifactReference ref : da.getArtifactRef().getArtifactReferences()) {
      if (ref.getReference().endsWith(""String_Node_Str"")) {
        return true;
      }
    }
  }
  return false;
}","private boolean hasZipArtfiactReference(AbstractDeploymentArtifact da){
  if (da.getArtifactType().equals(this.zipArtifactType)) {
    for (    AbstractArtifactReference ref : da.getArtifactRef().getArtifactReferences()) {
      if (ref.getReference().endsWith(""String_Node_Str"")) {
        return true;
      }
    }
  }
  return false;
}"
41575,"private boolean isCompatiblePhpModuleNodeType(QName nodeTypeId){
  if (nodeTypeId.toString().equals(this.phpModule.toString())) {
    return true;
  }
  if (nodeTypeId.toString().equals(this.phpModuleNodeTypeTOSCASpecificType.toString())) {
    return true;
  }
  return false;
}","private boolean isCompatiblePhpModuleNodeType(QName nodeTypeId){
  if (nodeTypeId.equals(this.phpModule)) {
    return true;
  }
  if (nodeTypeId.equals(this.phpModuleNodeTypeTOSCASpecificType)) {
    return true;
  }
  return false;
}"
41576,"private boolean isCompatibleApacheWebServerNodeType(QName nodeTypeId){
  if (nodeTypeId.toString().equals(this.apacheWebServer.toString())) {
    return true;
  }
  if (nodeTypeId.toString().equals(this.apacheWebServerNodeTypeTOSCASpecificType.toString())) {
    return true;
  }
  return false;
}","private boolean isCompatibleApacheWebServerNodeType(QName nodeTypeId){
  if (nodeTypeId.equals(this.apacheWebServer)) {
    return true;
  }
  if (nodeTypeId.equals(this.apacheWebServerNodeTypeTOSCASpecificType)) {
    return true;
  }
  return false;
}"
41577,"private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().toString().equals(this.zipArtifactType.toString())) {
    return true;
  }
 else {
    return false;
  }
}","private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().equals(this.zipArtifactType)) {
    return true;
  }
 else {
    return false;
  }
}"
41578,"private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().toString().equals(this.zipArtifactType.toString())) {
    return true;
  }
 else {
    return false;
  }
}","private boolean isZipArtifact(AbstractDeploymentArtifact artifact){
  if (artifact.getArtifactType().equals(this.zipArtifactType)) {
    return true;
  }
 else {
    return false;
  }
}"
41579,"/** 
 * {@inheritDoc}
 */
@Override public QName getId(){
  String namespace;
  if ((this.getTargetNamespace() != null) && !this.getTargetNamespace().equals(""String_Node_Str"")) {
    namespace=this.getTargetNamespace();
  }
 else {
    namespace=this.definitions.getTargetNamespace();
  }
  QName id=new QName(""String_Node_Str"" + namespace + ""String_Node_Str""+ this.relationshipType.getName());
  return id;
}","/** 
 * {@inheritDoc}
 */
@Override public QName getId(){
  String namespace;
  if ((this.getTargetNamespace() != null) && !this.getTargetNamespace().equals(""String_Node_Str"")) {
    namespace=this.getTargetNamespace();
  }
 else {
    namespace=this.definitions.getTargetNamespace();
  }
  QName id=new QName(namespace,this.relationshipType.getName());
  return id;
}"
41580,"public void _endpoint_show_wsdl(CommandInterpreter commandInterpreter){
  this.em.getTransaction().begin();
  Query query=this.em.createQuery(""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") List<WSDLEndpoint> queryResults=query.getResultList();
  for (  WSDLEndpoint e : queryResults) {
    commandInterpreter.println(""String_Node_Str"" + e.getCSARId());
    commandInterpreter.println(""String_Node_Str"" + e.getPortType().toString());
    commandInterpreter.println(""String_Node_Str"" + (e.getPlanId() == null ? ""String_Node_Str"" : e.getPlanId().toString()));
    commandInterpreter.println(""String_Node_Str"" + (e.getNodeTypeImplementation() == null ? ""String_Node_Str"" : e.getNodeTypeImplementation().toString()));
    commandInterpreter.println(""String_Node_Str"" + (e.getIaName() == null ? ""String_Node_Str"" : e.getIaName()));
    commandInterpreter.println(""String_Node_Str"" + e.getURI().toString());
    commandInterpreter.println(""String_Node_Str"");
  }
  this.em.getTransaction().commit();
}","public void _endpoint_show_wsdl(CommandInterpreter commandInterpreter){
  this.em.getTransaction().begin();
  Query query=this.em.createQuery(""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") List<WSDLEndpoint> queryResults=query.getResultList();
  for (  WSDLEndpoint e : queryResults) {
    commandInterpreter.println(""String_Node_Str"" + e.getCSARId());
    if (e.getPortType() != null) {
      commandInterpreter.println(""String_Node_Str"" + e.getPortType().toString());
    }
    commandInterpreter.println(""String_Node_Str"" + (e.getPlanId() == null ? ""String_Node_Str"" : e.getPlanId().toString()));
    commandInterpreter.println(""String_Node_Str"" + (e.getNodeTypeImplementation() == null ? ""String_Node_Str"" : e.getNodeTypeImplementation().toString()));
    commandInterpreter.println(""String_Node_Str"" + (e.getIaName() == null ? ""String_Node_Str"" : e.getIaName()));
    commandInterpreter.println(""String_Node_Str"" + e.getURI().toString());
    commandInterpreter.println(""String_Node_Str"");
  }
  this.em.getTransaction().commit();
}"
41581,"/** 
 * Checks whether the given Node is a virtual machine nodeType that can by handled by the set of plugins used by the PlanBuilder
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if given nodeType is a virtual machine nodeType
 */
public static boolean isSupportedVMNodeType(QName nodeType){
  if (nodeType.toString().equals(Types.vmNodeType)) {
    return true;
  }
  return false;
}","/** 
 * Checks whether the given Node is a virtual machine nodeType that can by handled by the set of plugins used by the PlanBuilder
 * @param nodeType a QName denoting some nodeType
 * @return a boolean. True if given nodeType is a virtual machine nodeType
 */
public static boolean isSupportedVMNodeType(QName nodeType){
  if (nodeType.toString().equals(Types.vmNodeType.toString())) {
    return true;
  }
  return false;
}"
41582,"/** 
 * Generates BuildPlans for ServiceTemplates which don't have a BuildPlan defined inside the given Definitions document
 * @param defs an AbstractDefinitions
 * @param csarName the FileName of the CSAR the given Definitions iscontained in
 * @return a List of BuildPlans
 */
protected List<BuildPlan> buildPlans(AbstractDefinitions defs,String csarName){
  PlanBuilder planBuilder=new PlanBuilder();
  return planBuilder.buildPlans(csarName,defs);
}","/** 
 * Generates BuildPlans for ServiceTemplates, which haven't a BuildPlan defined, inside the given Definitions document
 * @param defs an AbstractDefinitions
 * @param csarName the FileName of the CSAR the given Definitions iscontained in
 * @return a List of BuildPlans
 */
public List<BuildPlan> buildPlans(AbstractDefinitions defs,String csarName){
  PlanBuilder planBuilder=new PlanBuilder();
  return planBuilder.buildPlans(csarName,defs);
}"
41583,"/** 
 * Creates a BuildPlan for the given ServiceTemplate
 * @param defs an AbstractDefinitions
 * @param csarName the File name of the CSAR the Definitions document isdefined in
 * @param serviceTemplate a QName representing a ServiceTemplate inside thegiven Definitions Document
 * @return a BuildPlan if generating a BuildPlan was successful, else null
 */
protected BuildPlan buildPlan(AbstractDefinitions defs,String csarName,QName serviceTemplate){
  PlanBuilder planBuilder=new PlanBuilder();
  return planBuilder.buildPlan(csarName,defs,serviceTemplate);
}","/** 
 * Creates a BuildPlan for the given ServiceTemplate
 * @param defs an AbstractDefinitions
 * @param csarName the File name of the CSAR the Definitions document isdefined in
 * @param serviceTemplate a QName representing a ServiceTemplate inside thegiven Definitions Document
 * @return a BuildPlan if generating a BuildPlan was successful, else null
 */
public BuildPlan buildPlan(AbstractDefinitions defs,String csarName,QName serviceTemplate){
  PlanBuilder planBuilder=new PlanBuilder();
  return planBuilder.buildPlan(csarName,defs,serviceTemplate);
}"
41584,"/** 
 * Stores a CSAR given as file object
 * @param file File referencing a CSAR
 * @return an Object representing an ID of the stored CSAR, if somethingwent wrong null is returned instead
 * @throws SystemException
 * @throws UserException
 */
public Object storeCSAR(File file) throws UserException, SystemException {
  CSARHandler.LOG.debug(""String_Node_Str"");
  BundleContext bundleContext=FrameworkUtil.getBundle(this.getClass()).getBundleContext();
  CSARHandler.LOG.debug(""String_Node_Str"");
  ServiceReference<?> fileServiceRef=bundleContext.getServiceReference(ICoreFileService.class.getName());
  CSARHandler.LOG.debug(""String_Node_Str"");
  ICoreFileService fileService=(ICoreFileService)bundleContext.getService(fileServiceRef);
  CSARHandler.LOG.debug(""String_Node_Str"");
  CSARID csarId=fileService.storeCSAR(file.toPath());
  if (csarId == null) {
    CSARHandler.LOG.warn(""String_Node_Str"");
    return null;
  }
  CSARHandler.LOG.info(""String_Node_Str"");
  return csarId;
}","/** 
 * Stores a CSAR given as file object
 * @param file File referencing a CSAR
 * @return an Object representing an ID of the stored CSAR, if somethingwent wrong null is returned instead
 * @throws SystemException
 * @throws UserException
 */
public Object storeCSAR(File file) throws UserException, SystemException {
  CSARHandler.LOG.debug(""String_Node_Str"");
  ICoreFileService fileService=this.fetchCoreFileService();
  CSARID csarId=fileService.storeCSAR(file.toPath());
  if (csarId == null) {
    CSARHandler.LOG.warn(""String_Node_Str"");
    return null;
  }
  CSARHandler.LOG.info(""String_Node_Str"");
  return csarId;
}"
41585,"/** 
 * Returns a CSARContent Object for the given CSARID
 * @param id a CSARID
 * @return the CSARContent for the given CSARID
 * @throws UserException is thrown when something inside the OpenTOSCA Corefails
 */
public CSARContent getCSARContentForID(CSARID id) throws UserException {
  CSARHandler.LOG.debug(""String_Node_Str"");
  BundleContext bundleContext=FrameworkUtil.getBundle(this.getClass()).getBundleContext();
  CSARHandler.LOG.debug(""String_Node_Str"");
  ServiceReference<?> fileServiceRef=bundleContext.getServiceReference(ICoreFileService.class.getName());
  CSARHandler.LOG.debug(""String_Node_Str"");
  ICoreFileService fileService=(ICoreFileService)bundleContext.getService(fileServiceRef);
  return fileService.getCSAR(id);
}","/** 
 * Returns a CSARContent Object for the given CSARID
 * @param id a CSARID
 * @return the CSARContent for the given CSARID
 * @throws UserException is thrown when something inside the OpenTOSCA Core fails
 */
public CSARContent getCSARContentForID(CSARID id) throws UserException {
  LOG.debug(""String_Node_Str"");
  return this.fetchCoreFileService().getCSAR(id);
}"
41586,"/** 
 * Deletes all CSARs in the OpenTOSCA Core
 */
public void deleteAllCsars(){
  CSARHandler.LOG.debug(""String_Node_Str"");
  BundleContext bundleContext=FrameworkUtil.getBundle(this.getClass()).getBundleContext();
  CSARHandler.LOG.debug(""String_Node_Str"");
  ServiceReference<?> fileServiceRef=bundleContext.getServiceReference(ICoreFileService.class.getName());
  CSARHandler.LOG.debug(""String_Node_Str"");
  ICoreFileService fileService=(ICoreFileService)bundleContext.getService(fileServiceRef);
  CSARHandler.LOG.info(""String_Node_Str"");
  try {
    fileService.deleteCSARs();
  }
 catch (  SystemException e) {
  }
}","/** 
 * Deletes all CSARs in the OpenTOSCA Core
 */
public void deleteAllCsars(){
  CSARHandler.LOG.info(""String_Node_Str"");
  ICoreFileService fileService=this.fetchCoreFileService();
  try {
    fileService.deleteCSARs();
  }
 catch (  SystemException e) {
  }
}"
41587,"/** 
 * Adds a copy from a String variable to the specified Element inside the output message of the given BuildPlan
 * @param variableName the variableName of the given BuildPlan the valueshould be assigned from
 * @param outputElementName the Element LocalName inside the outputMessageof the BuildPlan
 * @param buildPlan the BuildPlan to add the copy to
 * @return true if adding the copy was successful, else false
 */
public boolean assginOutputWithVariableValue(String variableName,String outputElementName,BuildPlan buildPlan){
  BPELProcessHandler.LOG.debug(""String_Node_Str"",variableName,outputElementName,buildPlan.getBpelProcessElement().getAttribute(""String_Node_Str""));
  Element outputAssignElement=buildPlan.getBpelMainSequenceOutputAssignElement();
  Element copyElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element fromElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element toElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element queryElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  CDATASection cdataSection=buildPlan.getBpelDocument().createCDATASection(""String_Node_Str"" + outputElementName);
  fromElement.setAttribute(""String_Node_Str"",variableName);
  toElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  toElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  queryElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  queryElement.appendChild(cdataSection);
  toElement.appendChild(cdataSection);
  copyElement.appendChild(fromElement);
  copyElement.appendChild(toElement);
  outputAssignElement.appendChild(copyElement);
  BPELProcessHandler.LOG.debug(""String_Node_Str"");
  return true;
}","/** 
 * Adds a copy from a String variable to the specified Element inside the output message of the given BuildPlan
 * @param variableName the variableName of the given BuildPlan the valueshould be assigned from
 * @param outputElementName the Element LocalName inside the outputMessageof the BuildPlan
 * @param buildPlan the BuildPlan to add the copy to
 * @return true if adding the copy was successful, else false
 */
public boolean assginOutputWithVariableValue(String variableName,String outputElementName,BuildPlan buildPlan){
  BPELProcessHandler.LOG.debug(""String_Node_Str"",variableName,outputElementName,buildPlan.getBpelProcessElement().getAttribute(""String_Node_Str""));
  Element outputAssignElement=buildPlan.getBpelMainSequenceOutputAssignElement();
  Element copyElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element fromElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element toElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  Element queryElement=buildPlan.getBpelDocument().createElementNS(BuildPlan.bpelNamespace,""String_Node_Str"");
  CDATASection cdataSection=buildPlan.getBpelDocument().createCDATASection(""String_Node_Str"" + outputElementName);
  fromElement.setAttribute(""String_Node_Str"",variableName);
  toElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  toElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  queryElement.setAttribute(""String_Node_Str"",""String_Node_Str"");
  queryElement.appendChild(cdataSection);
  toElement.appendChild(queryElement);
  copyElement.appendChild(fromElement);
  copyElement.appendChild(toElement);
  outputAssignElement.appendChild(copyElement);
  BPELProcessHandler.LOG.debug(""String_Node_Str"");
  return true;
}"
41588,"/** 
 * Initializes Property variables for the given TemplateBuildPlan which handles a NodeTemplate
 * @param map a PropertyMap to save the result/mappings to
 * @param templatePlan a TemplateBuildPlan which handles a NodeTemplate
 */
private void initPropsAsVarsInNode(PropertyMap map,TemplateBuildPlan templatePlan){
  AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
  if (nodeTemplate.getProperties() != null) {
    Element propertyElement=nodeTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      String propName=propertyElement.getChildNodes().item(i).getLocalName();
      String propVarName=nodeTemplate.getId() + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(nodeTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      if (!value.trim().isEmpty() && !value.trim().equals(""String_Node_Str"")) {
        this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
      }
    }
  }
}","/** 
 * Initializes Property variables for the given TemplateBuildPlan which handles a NodeTemplate
 * @param map a PropertyMap to save the result/mappings to
 * @param templatePlan a TemplateBuildPlan which handles a NodeTemplate
 */
private void initPropsAsVarsInNode(PropertyMap map,TemplateBuildPlan templatePlan){
  AbstractNodeTemplate nodeTemplate=templatePlan.getNodeTemplate();
  if (nodeTemplate.getProperties() != null) {
    Element propertyElement=nodeTemplate.getProperties().getDOMElement();
    for (int i=0; i < propertyElement.getChildNodes().getLength(); i++) {
      if (propertyElement.getChildNodes().item(i).getNodeType() == Node.TEXT_NODE) {
        continue;
      }
      String propName=propertyElement.getChildNodes().item(i).getLocalName();
      String propVarName=nodeTemplate.getId() + ""String_Node_Str"" + propertyElement.getChildNodes().item(i).getLocalName();
      map.addPropertyMapping(nodeTemplate.getId(),propName,""String_Node_Str"" + propVarName);
      String value=""String_Node_Str"";
      for (int j=0; j < propertyElement.getChildNodes().item(i).getChildNodes().getLength(); j++) {
        if (propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {
          value+=propertyElement.getChildNodes().item(i).getChildNodes().item(j).getNodeValue();
        }
      }
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + propVarName);
      PropertyVariableInitializer.LOG.debug(""String_Node_Str"" + value);
      this.planHandler.addPropertyVariable(propVarName,templatePlan.getBuildPlan());
      this.planHandler.initializePropertyVariable(propVarName,value,templatePlan.getBuildPlan());
    }
  }
}"
41589,"/** 
 * {@inheritDoc}
 */
@Override public AbstractProperties getProperties(){
  return new PropertiesImpl(this.properties.getAny());
}","/** 
 * {@inheritDoc}
 */
@Override public AbstractProperties getProperties(){
  if (this.properties.getAny() != null) {
    return new PropertiesImpl(this.properties.getAny());
  }
 else {
    return null;
  }
}"
41590,"/** 
 * Exports the given BuildPlans repackaged with the CSAR denoted by the given CSARID
 * @param buildPlans the BuildPlans to export
 * @param csarId the CSARID of a CSAR
 * @return a File denoting the absolute Path to the exported CSAR
 */
public File export(List<BuildPlan> buildPlans,CSARID csarId){
  CSARContent csarContent=null;
  try {
    csarContent=this.handler.getCSARContentForID(csarId);
  }
 catch (  UserException e1) {
    Exporter.LOG.error(""String_Node_Str"",e1);
  }
  if (csarContent == null) {
    return null;
  }
  String csarName=csarId.getFileName();
  IFileAccessService service=this.getFileAccessService();
  File tempDir=service.getTemp();
  File pathToRepackagedCsar=service.getTemp();
  File repackagedCsar=new File(pathToRepackagedCsar,csarName);
  try {
    Set<AbstractFile> files=csarContent.getFilesRecursively();
    AbstractFile mainDefFile=csarContent.getRootTOSCA();
    File rootDefFile=mainDefFile.getFile().toFile();
    Definitions defs=this.parseDefinitionsFile(rootDefFile);
    List<TServiceTemplate> servTemps=this.getServiceTemplates(defs);
    List<BuildPlan> plansToExport=new ArrayList<BuildPlan>();
    for (    BuildPlan buildPlan : buildPlans) {
      for (      TServiceTemplate serviceTemplate : servTemps) {
        if (buildPlan.getServiceTemplate().toString().equals(this.buildQName(defs,serviceTemplate).toString())) {
          TPlans plans=serviceTemplate.getPlans();
          if (plans == null) {
            plans=this.toscaFactory.createTPlans();
            serviceTemplate.setPlans(plans);
          }
          List<TPlan> planList=plans.getPlan();
          planList.add(this.generateTPlanElement(buildPlan));
          plansToExport.add(buildPlan);
        }
      }
    }
    for (    AbstractFile file : files) {
      if (file.getFile().toFile().toString().equals(rootDefFile.toString())) {
        continue;
      }
      File newLocation=new File(tempDir,file.getPath());
      Exporter.LOG.debug(newLocation.getAbsolutePath());
      Exporter.LOG.debug(file.getFile().toString());
      if (newLocation.isDirectory()) {
        FileUtils.copyDirectory(file.getFile().toFile(),newLocation);
      }
 else {
        FileUtils.copyFile(file.getFile().toFile(),newLocation);
      }
    }
    File newDefsFile=new File(tempDir,mainDefFile.getPath());
    newDefsFile.createNewFile();
    JAXBContext jaxbContext=JAXBContext.newInstance(Definitions.class);
    Marshaller m=jaxbContext.createMarshaller();
    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
    m.marshal(defs,newDefsFile);
    for (    BuildPlan plan : plansToExport) {
      File planPath=new File(tempDir,this.generateRelativePlanPath(plan));
      Exporter.LOG.debug(planPath.toString());
      planPath.getParentFile().mkdirs();
      planPath.createNewFile();
      this.simpleExporter.export(planPath.toURI(),plan);
    }
    File selfServiceDir=new File(tempDir,""String_Node_Str"");
    File selfServiceDataXml=new File(selfServiceDir,""String_Node_Str"");
    JAXBContext jaxbContextWineryApplication=JAXBContext.newInstance(Application.class);
    if (selfServiceDir.exists() && selfServiceDataXml.exists()) {
      Unmarshaller u=jaxbContextWineryApplication.createUnmarshaller();
      Application appDesc=(Application)u.unmarshal(selfServiceDataXml);
      for (      ApplicationOption option : appDesc.getOptions().getOption()) {
        for (        BuildPlan plan : plansToExport) {
          if (option.getPlanServiceName().equals(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart())) {
            if (!new File(selfServiceDir,option.getPlanInputMessageUrl()).exists()) {
              File planInputFile=new File(selfServiceDir,option.getPlanInputMessageUrl());
              this.writePlanInputMessageInstance(plan,planInputFile);
            }
          }
        }
      }
    }
 else {
      if (selfServiceDir.mkdirs() && selfServiceDataXml.createNewFile()) {
        Application appDesc=new Application();
        appDesc.setDisplayName(csarName);
        appDesc.setDescription(""String_Node_Str"");
        appDesc.setIconUrl(""String_Node_Str"");
        appDesc.setImageUrl(""String_Node_Str"");
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
  }
 catch (  IOException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  JAXBException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  SystemException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
  service.zip(tempDir,repackagedCsar);
  Exporter.LOG.debug(repackagedCsar.toString());
  return repackagedCsar;
}","/** 
 * Exports the given BuildPlans repackaged with the CSAR denoted by the given CSARID
 * @param buildPlans the BuildPlans to export
 * @param csarId the CSARID of a CSAR
 * @return a File denoting the absolute Path to the exported CSAR
 */
public File export(List<BuildPlan> buildPlans,CSARID csarId){
  CSARContent csarContent=null;
  try {
    csarContent=this.handler.getCSARContentForID(csarId);
  }
 catch (  UserException e1) {
    Exporter.LOG.error(""String_Node_Str"",e1);
  }
  if (csarContent == null) {
    return null;
  }
  String csarName=csarId.getFileName();
  IFileAccessService service=this.getFileAccessService();
  File tempDir=service.getTemp();
  File pathToRepackagedCsar=service.getTemp();
  File repackagedCsar=new File(pathToRepackagedCsar,csarName);
  try {
    Set<AbstractFile> files=csarContent.getFilesRecursively();
    AbstractFile mainDefFile=csarContent.getRootTOSCA();
    File rootDefFile=mainDefFile.getFile().toFile();
    Definitions defs=this.parseDefinitionsFile(rootDefFile);
    List<TServiceTemplate> servTemps=this.getServiceTemplates(defs);
    List<BuildPlan> plansToExport=new ArrayList<BuildPlan>();
    for (    BuildPlan buildPlan : buildPlans) {
      for (      TServiceTemplate serviceTemplate : servTemps) {
        if (buildPlan.getServiceTemplate().toString().equals(this.buildQName(defs,serviceTemplate).toString())) {
          TPlans plans=serviceTemplate.getPlans();
          if (plans == null) {
            plans=this.toscaFactory.createTPlans();
            serviceTemplate.setPlans(plans);
          }
          List<TPlan> planList=plans.getPlan();
          planList.add(this.generateTPlanElement(buildPlan));
          plansToExport.add(buildPlan);
        }
      }
    }
    for (    AbstractFile file : files) {
      if (file.getFile().toFile().toString().equals(rootDefFile.toString())) {
        continue;
      }
      File newLocation=new File(tempDir,file.getPath());
      Exporter.LOG.debug(newLocation.getAbsolutePath());
      Exporter.LOG.debug(file.getFile().toString());
      if (newLocation.isDirectory()) {
        FileUtils.copyDirectory(file.getFile().toFile(),newLocation);
      }
 else {
        FileUtils.copyFile(file.getFile().toFile(),newLocation);
      }
    }
    File newDefsFile=new File(tempDir,mainDefFile.getPath());
    newDefsFile.createNewFile();
    JAXBContext jaxbContext=JAXBContext.newInstance(Definitions.class);
    Marshaller m=jaxbContext.createMarshaller();
    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
    m.marshal(defs,newDefsFile);
    for (    BuildPlan plan : plansToExport) {
      File planPath=new File(tempDir,this.generateRelativePlanPath(plan));
      Exporter.LOG.debug(planPath.toString());
      planPath.getParentFile().mkdirs();
      planPath.createNewFile();
      this.simpleExporter.export(planPath.toURI(),plan);
    }
    File selfServiceDir=new File(tempDir,""String_Node_Str"");
    File selfServiceDataXml=new File(selfServiceDir,""String_Node_Str"");
    JAXBContext jaxbContextWineryApplication=JAXBContext.newInstance(Application.class);
    if (selfServiceDir.exists() && selfServiceDataXml.exists()) {
      Unmarshaller u=jaxbContextWineryApplication.createUnmarshaller();
      Application appDesc=(Application)u.unmarshal(selfServiceDataXml);
      if (appDesc.getOptions() != null) {
        for (        ApplicationOption option : appDesc.getOptions().getOption()) {
          for (          BuildPlan plan : plansToExport) {
            if (option.getPlanServiceName().equals(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart())) {
              if (!new File(selfServiceDir,option.getPlanInputMessageUrl()).exists()) {
                File planInputFile=new File(selfServiceDir,option.getPlanInputMessageUrl());
                this.writePlanInputMessageInstance(plan,planInputFile);
              }
            }
          }
        }
      }
 else {
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
 else {
      if (selfServiceDir.mkdirs() && selfServiceDataXml.createNewFile()) {
        Application appDesc=new Application();
        appDesc.setDisplayName(csarName);
        appDesc.setDescription(""String_Node_Str"");
        appDesc.setIconUrl(""String_Node_Str"");
        appDesc.setImageUrl(""String_Node_Str"");
        int optionCounter=1;
        Application.Options options=new Application.Options();
        for (        BuildPlan plan : plansToExport) {
          ApplicationOption option=new ApplicationOption();
          option.setName(""String_Node_Str"" + optionCounter);
          option.setId(String.valueOf(optionCounter));
          option.setIconUrl(""String_Node_Str"");
          option.setDescription(""String_Node_Str"");
          option.setPlanServiceName(this.getBuildPlanServiceName(plan.getDeploymentDeskriptor()).getLocalPart());
          option.setPlanInputMessageUrl(""String_Node_Str"" + optionCounter + ""String_Node_Str"");
          this.writePlanInputMessageInstance(plan,new File(selfServiceDir,""String_Node_Str"" + optionCounter + ""String_Node_Str""));
          optionCounter++;
          options.getOption().add(option);
        }
        appDesc.setOptions(options);
        Marshaller wineryAppMarshaller=jaxbContextWineryApplication.createMarshaller();
        wineryAppMarshaller.marshal(appDesc,selfServiceDataXml);
      }
    }
  }
 catch (  IOException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  JAXBException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
catch (  SystemException e) {
    Exporter.LOG.error(""String_Node_Str"",e);
  }
  service.zip(tempDir,repackagedCsar);
  Exporter.LOG.debug(repackagedCsar.toString());
  return repackagedCsar;
}"
41591,"/** 
 * Initializes the internal IAs
 */
private void initIas(){
  for (  TImplementationArtifact artifact : this.nodeTypeImpl.getImplementationArtifacts().getImplementationArtifact()) {
    this.ias.add(new ImplementationArtifactImpl(artifact,this.definitions));
  }
}","/** 
 * Initializes the internal IAs
 */
private void initIas(){
  if (this.nodeTypeImpl.getImplementationArtifacts() != null) {
    for (    TImplementationArtifact artifact : this.nodeTypeImpl.getImplementationArtifacts().getImplementationArtifact()) {
      this.ias.add(new ImplementationArtifactImpl(artifact,this.definitions));
    }
  }
}"
41592,"/** 
 * {@inheritDoc}
 */
@Override public QName getTypeRef(){
  if (this.relationshipType.getDerivedFrom() != null) {
    for (    AbstractRelationshipType relation : this.definitions.getAllRelationshipTypes()) {
      if (relation.getId().toString().equals(this.relationshipType.getDerivedFrom().getTypeRef().toString())) {
        return relation.getTypeRef();
      }
    }
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public QName getTypeRef(){
  if (this.relationshipType.getDerivedFrom() != null) {
    return this.relationshipType.getDerivedFrom().getTypeRef();
  }
  return null;
}"
41593,"void getRealmAuctionFileInformation(Realm realm){
  getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + realm.getRealmDetail());
  Client client=ClientBuilder.newClient();
  Files files=client.target(target + realm.getSlug()).request(MediaType.TEXT_PLAIN).get(Files.class);
  files.getFiles().forEach(auctionFile -> createAuctionFile(realm,auctionFile));
}","void getRealmAuctionFileInformation(Realm realm){
  getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + realm.getRealmDetail());
  try {
    Client client=ClientBuilder.newClient();
    Files files=client.target(target + realm.getSlug()).request(MediaType.TEXT_PLAIN).get(Files.class);
    files.getFiles().forEach(auctionFile -> createAuctionFile(realm,auctionFile));
  }
 catch (  Exception e) {
    getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + realm.getRealmDetail());
  }
}"
41594,"@Override @SuppressWarnings(""String_Node_Str"") public Object processItem(Object item) throws Exception {
  ResultSet resultSet=(ResultSet)item;
  AuctionItemStatistics auctionItemStatistics=new AuctionItemStatistics();
  auctionItemStatistics.setItemId(resultSet.getInt(1));
  auctionItemStatistics.setQuantity(resultSet.getLong(2));
  auctionItemStatistics.setBid(resultSet.getLong(3));
  auctionItemStatistics.setBuyout(resultSet.getLong(4));
  auctionItemStatistics.setMinBid(resultSet.getLong(5));
  auctionItemStatistics.setMinBuyout(resultSet.getLong(6));
  auctionItemStatistics.setMaxBid(resultSet.getLong(7));
  auctionItemStatistics.setMaxBuyout(resultSet.getLong(8));
  auctionItemStatistics.setTimestamp(getContext().getFileToProcess().getLastModified());
  auctionItemStatistics.setAvgBid((double)(auctionItemStatistics.getBid() / auctionItemStatistics.getQuantity()));
  auctionItemStatistics.setAvgBuyout((double)(auctionItemStatistics.getBuyout() / auctionItemStatistics.getQuantity()));
  auctionItemStatistics.setAuctionHouse(AuctionHouse.valueOf(auctionHouse));
  return auctionItemStatistics;
}","@Override @SuppressWarnings(""String_Node_Str"") public Object processItem(Object item) throws Exception {
  ResultSet resultSet=(ResultSet)item;
  AuctionItemStatistics auctionItemStatistics=new AuctionItemStatistics();
  auctionItemStatistics.setItemId(resultSet.getInt(1));
  auctionItemStatistics.setQuantity(resultSet.getLong(2));
  auctionItemStatistics.setBid(resultSet.getLong(3));
  auctionItemStatistics.setBuyout(resultSet.getLong(4));
  auctionItemStatistics.setMinBid(resultSet.getLong(5));
  auctionItemStatistics.setMinBuyout(resultSet.getLong(6));
  auctionItemStatistics.setMaxBid(resultSet.getLong(7));
  auctionItemStatistics.setMaxBuyout(resultSet.getLong(8));
  auctionItemStatistics.setTimestamp(getContext().getFileToProcess().getLastModified());
  auctionItemStatistics.setAvgBid((double)(auctionItemStatistics.getBid() / auctionItemStatistics.getQuantity()));
  auctionItemStatistics.setAvgBuyout((double)(auctionItemStatistics.getBuyout() / auctionItemStatistics.getQuantity()));
  auctionItemStatistics.setAuctionHouse(AuctionHouse.valueOf(auctionHouse));
  auctionItemStatistics.setRealm(getContext().getRealm());
  return auctionItemStatistics;
}"
41595,"@Override public void open(Serializable checkpoint) throws Exception {
  Connection connection=dataSource.getConnection();
  preparedStatement=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY,ResultSet.HOLD_CURSORS_OVER_COMMIT);
  preparedStatement.setLong(1,getContext().getFileToProcess().getId());
  preparedStatement.setInt(2,AuctionHouse.valueOf(auctionHouse).ordinal());
  resultSet=preparedStatement.executeQuery();
}","@Override public void open(Serializable checkpoint) throws Exception {
  Connection connection=dataSource.getConnection();
  preparedStatement=connection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + getContext().getFileToProcess().getId() + ""String_Node_Str""+ AuctionHouse.valueOf(auctionHouse).ordinal()+ ""String_Node_Str""+ ""String_Node_Str"",ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY,ResultSet.HOLD_CURSORS_OVER_COMMIT);
  resultSet=preparedStatement.executeQuery();
}"
41596,"@Override @GET @Path(""String_Node_Str"") public List<AuctionItemStatistics> findAuctionItemStatisticsByRealmAndItem(@QueryParam(""String_Node_Str"") Long realmId,@QueryParam(""String_Node_Str"") Integer itemId){
  return em.createNamedQuery(""String_Node_Str"").setParameter(""String_Node_Str"",itemId).getResultList();
}","@Override @GET @Path(""String_Node_Str"") public List<AuctionItemStatistics> findAuctionItemStatisticsByRealmAndItem(@QueryParam(""String_Node_Str"") Long realmId,@QueryParam(""String_Node_Str"") Integer itemId){
  return em.createNamedQuery(""String_Node_Str"").setParameter(""String_Node_Str"",realmId).setParameter(""String_Node_Str"",itemId).getResultList();
}"
41597,"private void getRealmAuctionFileInformation(Realm realm){
  getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + realm.getRealmDetail());
  Client client=ClientBuilder.newClient();
  Files files=client.target(target + realm.getSlug()).request(MediaType.TEXT_PLAIN).get(Files.class);
  files.getFiles().forEach(auctionFile -> {
    auctionFile.setRealm(realm);
    auctionFile.setFileStatus(FileStatus.LOADED);
    woWBusiness.createAuctionFile(auctionFile);
  }
);
}","private void getRealmAuctionFileInformation(Realm realm){
  getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + realm.getRealmDetail());
  Client client=ClientBuilder.newClient();
  Files files=client.target(target + realm.getSlug()).request(MediaType.TEXT_PLAIN).get(Files.class);
  files.getFiles().forEach(auctionFile -> {
    auctionFile.setRealm(realm);
    auctionFile.setFileName(""String_Node_Str"" + auctionFile.getLastModified() + ""String_Node_Str"");
    auctionFile.setFileStatus(FileStatus.LOADED);
    woWBusiness.createAuctionFile(auctionFile);
  }
);
}"
41598,"private void verifyAndCreateFolder(String folderRoot,Realm realm,FolderType folderType){
  File folder=new File(batchHome + ""String_Node_Str"" + folderRoot+ ""String_Node_Str""+ realm.getName()+ ""String_Node_Str""+ folderType);
  if (!folder.exists()) {
    try {
      getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + folder);
      FileUtils.forceMkdir(folder);
      woWBusiness.createRealmFolder(new RealmFolder(realm.getId(),folderType,folder.getPath()));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 else   if (woWBusiness.findRealmFolderById(realm.getId(),folderType) == null) {
    woWBusiness.createRealmFolder(new RealmFolder(realm.getId(),folderType,folder.getPath()));
  }
}","private void verifyAndCreateFolder(String folderRoot,Realm realm,FolderType folderType){
  File folder=new File(batchHome + ""String_Node_Str"" + folderRoot+ ""String_Node_Str""+ realm.getRegion()+ ""String_Node_Str""+ realm.getName()+ ""String_Node_Str""+ folderType);
  if (!folder.exists()) {
    try {
      getLogger(this.getClass().getName()).log(Level.INFO,""String_Node_Str"" + folder);
      FileUtils.forceMkdir(folder);
      woWBusiness.createRealmFolder(new RealmFolder(realm.getId(),folderType,folder.getPath()));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 else   if (woWBusiness.findRealmFolderById(realm.getId(),folderType) == null) {
    woWBusiness.createRealmFolder(new RealmFolder(realm.getId(),folderType,folder.getPath()));
  }
}"
41599,"@Test(timeout=20000) public void testRemotelyCloseSessionAndAttemptAsyncCompletionSendThrowsAndLeavesMessageReadable() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    JmsConnection connection=(JmsConnection)testFixture.establishConnecton(testPeer);
    final CountDownLatch sessionClosed=new CountDownLatch(1);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onSessionClosed(      Session session,      Throwable cause){
        sessionClosed.countDown();
      }
    }
);
    testPeer.expectBegin();
    testPeer.expectSenderAttach();
    testPeer.remotelyEndLastOpenedSession(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    Message message=session.createTextMessage(""String_Node_Str"");
    message.setIntProperty(""String_Node_Str"",1);
    assertNull(""String_Node_Str"",message.getJMSDestination());
    testPeer.waitForAllHandlersToComplete(100);
    assertTrue(""String_Node_Str"",sessionClosed.await(2,TimeUnit.SECONDS));
    TestJmsCompletionListener listener=new TestJmsCompletionListener();
    try {
      producer.send(message,listener);
      fail(""String_Node_Str"");
    }
 catch (    JMSException e) {
      LOG.warn(""String_Node_Str"",e.getMessage());
    }
    assertFalse(""String_Node_Str"",listener.awaitCompletion(5,TimeUnit.MILLISECONDS));
    assertNull(""String_Node_Str"",message.getJMSDestination());
    assertEquals(""String_Node_Str"",""String_Node_Str"",((TextMessage)message).getText());
    assertEquals(""String_Node_Str"",1,message.getIntProperty(""String_Node_Str""));
    testPeer.expectClose();
    connection.close();
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","@Test(timeout=20000) public void testRemotelyCloseSessionAndAttemptAsyncCompletionSendThrowsAndLeavesMessageReadable() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    JmsConnection connection=(JmsConnection)testFixture.establishConnecton(testPeer);
    final CountDownLatch sessionClosed=new CountDownLatch(1);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onSessionClosed(      Session session,      Throwable cause){
        sessionClosed.countDown();
      }
    }
);
    testPeer.expectBegin();
    testPeer.expectSenderAttach();
    testPeer.remotelyEndLastOpenedSession(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    Message message=session.createTextMessage(""String_Node_Str"");
    message.setIntProperty(""String_Node_Str"",1);
    assertNull(""String_Node_Str"",message.getJMSDestination());
    MessageProducer producer=session.createProducer(queue);
    testPeer.waitForAllHandlersToComplete(100);
    assertTrue(""String_Node_Str"",sessionClosed.await(2,TimeUnit.SECONDS));
    TestJmsCompletionListener listener=new TestJmsCompletionListener();
    try {
      producer.send(message,listener);
      fail(""String_Node_Str"");
    }
 catch (    JMSException e) {
      LOG.trace(""String_Node_Str"",e.getMessage());
    }
    assertFalse(""String_Node_Str"",listener.awaitCompletion(5,TimeUnit.MILLISECONDS));
    assertNull(""String_Node_Str"",message.getJMSDestination());
    assertEquals(""String_Node_Str"",""String_Node_Str"",((TextMessage)message).getText());
    assertEquals(""String_Node_Str"",1,message.getIntProperty(""String_Node_Str""));
    testPeer.expectClose();
    connection.close();
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41600,"@Test(timeout=20000) public void testRemotelyCloseProducerAndAttemptAsyncCompletionSendThrowsAndLeavesMessageReadable() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    JmsConnection connection=(JmsConnection)testFixture.establishConnecton(testPeer);
    final CountDownLatch producerClosed=new CountDownLatch(1);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onProducerClosed(      MessageProducer producer,      Throwable cause){
        producerClosed.countDown();
      }
    }
);
    testPeer.expectBegin();
    testPeer.expectSenderAttach();
    testPeer.remotelyDetachLastOpenedLinkOnLastOpenedSession(true,true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    Message message=session.createTextMessage(""String_Node_Str"");
    message.setIntProperty(""String_Node_Str"",1);
    assertNull(""String_Node_Str"",message.getJMSDestination());
    testPeer.waitForAllHandlersToComplete(100);
    assertTrue(""String_Node_Str"",producerClosed.await(2,TimeUnit.SECONDS));
    TestJmsCompletionListener listener=new TestJmsCompletionListener();
    try {
      producer.send(message,listener);
      fail(""String_Node_Str"");
    }
 catch (    JMSException e) {
      LOG.warn(""String_Node_Str"",e.getMessage());
    }
    assertFalse(""String_Node_Str"",listener.awaitCompletion(5,TimeUnit.MILLISECONDS));
    assertNull(""String_Node_Str"",message.getJMSDestination());
    assertEquals(""String_Node_Str"",""String_Node_Str"",((TextMessage)message).getText());
    assertEquals(""String_Node_Str"",1,message.getIntProperty(""String_Node_Str""));
    testPeer.expectClose();
    connection.close();
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","@Test(timeout=20000) public void testRemotelyCloseProducerAndAttemptAsyncCompletionSendThrowsAndLeavesMessageReadable() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    JmsConnection connection=(JmsConnection)testFixture.establishConnecton(testPeer);
    final CountDownLatch producerClosed=new CountDownLatch(1);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onProducerClosed(      MessageProducer producer,      Throwable cause){
        producerClosed.countDown();
      }
    }
);
    testPeer.expectBegin();
    testPeer.expectSenderAttach();
    testPeer.remotelyDetachLastOpenedLinkOnLastOpenedSession(true,true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    Message message=session.createTextMessage(""String_Node_Str"");
    message.setIntProperty(""String_Node_Str"",1);
    assertNull(""String_Node_Str"",message.getJMSDestination());
    MessageProducer producer=session.createProducer(queue);
    testPeer.waitForAllHandlersToComplete(100);
    assertTrue(""String_Node_Str"",producerClosed.await(2,TimeUnit.SECONDS));
    TestJmsCompletionListener listener=new TestJmsCompletionListener();
    try {
      producer.send(message,listener);
      fail(""String_Node_Str"");
    }
 catch (    JMSException e) {
      LOG.trace(""String_Node_Str"",e.getMessage());
    }
    assertFalse(""String_Node_Str"",listener.awaitCompletion(5,TimeUnit.MILLISECONDS));
    assertNull(""String_Node_Str"",message.getJMSDestination());
    assertEquals(""String_Node_Str"",""String_Node_Str"",((TextMessage)message).getText());
    assertEquals(""String_Node_Str"",1,message.getIntProperty(""String_Node_Str""));
    testPeer.expectClose();
    connection.close();
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41601,"@Override public int getPriority(){
  return PRIORITY.LOWEST.getValue();
}","@Override public int getPriority(){
  return PRIORITY.LOWER_STILL.getValue();
}"
41602,"/** 
 * Process the SASL authentication cycle until such time as an outcome is determine. This method must be called by the managing entity until the return value is true indicating a successful authentication or a JMSSecurityException is thrown indicating that the handshake failed.
 * @param authenticationRequest The request that is awaiting the result of authentication.
 * @return true if the authentication process completed.
 */
public boolean authenticate() throws JMSSecurityException {
  try {
switch (sasl.getState()) {
case PN_SASL_IDLE:
      handleSaslInit();
    break;
case PN_SASL_STEP:
  handleSaslStep();
break;
case PN_SASL_FAIL:
handleSaslFail();
break;
case PN_SASL_PASS:
authenticationRequest.onSuccess();
default :
break;
}
}
 catch (JMSSecurityException result) {
authenticationRequest.onFailure(result);
}
return authenticationRequest.isComplete();
}","/** 
 * Process the SASL authentication cycle until such time as an outcome is determine. This method must be called by the managing entity until the return value is true indicating a successful authentication or a JMSSecurityException is thrown indicating that the handshake failed.
 * @return true if the authentication process completed.
 */
public boolean authenticate() throws JMSSecurityException {
  try {
switch (sasl.getState()) {
case PN_SASL_IDLE:
      handleSaslInit();
    break;
case PN_SASL_STEP:
  handleSaslStep();
break;
case PN_SASL_FAIL:
handleSaslFail();
break;
case PN_SASL_PASS:
authenticationRequest.onSuccess();
default :
break;
}
}
 catch (JMSSecurityException result) {
authenticationRequest.onFailure(result);
}
return authenticationRequest.isComplete();
}"
41603,"/** 
 * When a redirect type exception is received this method is called to create the appropriate redirect exception type containing the error details needed.
 * @param error the Symbol that defines the redirection error type.
 * @param message the basic error message that should used or amended for the returned exception.
 * @param condition the ErrorCondition that describes the redirection.
 * @return an Exception that captures the details of the redirection error.
 */
public static Exception createRedirectException(Symbol error,String message,ErrorCondition condition){
  Exception result=null;
  Map<?,?> info=condition.getInfo();
  if (info == null) {
    result=new IOException(message + ""String_Node_Str"");
  }
 else {
    String hostname=(String)info.get(OPEN_HOSTNAME);
    String networkHost=(String)info.get(NETWORK_HOST);
    if (networkHost == null || networkHost.isEmpty()) {
      result=new IOException(message + ""String_Node_Str"");
    }
    int port=0;
    try {
      port=Integer.valueOf(info.get(PORT).toString());
    }
 catch (    Exception ex) {
      result=new IOException(message + ""String_Node_Str"");
    }
    result=new ProviderRedirectedException(message,hostname,networkHost,port);
  }
  return result;
}","/** 
 * When a redirect type exception is received this method is called to create the appropriate redirect exception type containing the error details needed.
 * @param error the Symbol that defines the redirection error type.
 * @param message the basic error message that should used or amended for the returned exception.
 * @param condition the ErrorCondition that describes the redirection.
 * @return an Exception that captures the details of the redirection error.
 */
public static Exception createRedirectException(Symbol error,String message,ErrorCondition condition){
  Exception result=null;
  Map<?,?> info=condition.getInfo();
  if (info == null) {
    result=new IOException(message + ""String_Node_Str"");
  }
 else {
    String hostname=(String)info.get(OPEN_HOSTNAME);
    String networkHost=(String)info.get(NETWORK_HOST);
    if (networkHost == null || networkHost.isEmpty()) {
      result=new IOException(message + ""String_Node_Str"");
    }
    int port=0;
    try {
      port=Integer.parseInt(info.get(PORT).toString());
    }
 catch (    Exception ex) {
      result=new IOException(message + ""String_Node_Str"");
    }
    result=new ProviderRedirectedException(message,hostname,networkHost,port);
  }
  return result;
}"
41604,"@Override public void processDeliveryUpdates(AmqpProvider provider) throws IOException {
  try {
    if (pendingDelivery != null && pendingDelivery.remotelySettled()) {
      DeliveryState state=pendingDelivery.getRemoteState();
      JmsTransactionId txId=(JmsTransactionId)pendingDelivery.getContext();
      if (state instanceof Declared) {
        LOG.debug(""String_Node_Str"",txId);
        Declared declared=(Declared)state;
        txId.setProviderHint(declared.getTxnId());
        pendingRequest.onSuccess();
      }
 else       if (state instanceof Rejected) {
        LOG.debug(""String_Node_Str"",txId);
        Rejected rejected=(Rejected)state;
        Exception cause=AmqpSupport.convertToException(getEndpoint(),rejected.getError());
        JMSException failureCause=null;
        if (txId.getProviderContext() == COMMIT_MARKER) {
          failureCause=new TransactionRolledBackException(cause.getMessage());
        }
 else {
          failureCause=new JMSException(cause.getMessage());
        }
        pendingRequest.onFailure(failureCause);
      }
 else {
        LOG.debug(""String_Node_Str"",txId);
        pendingRequest.onSuccess();
      }
      pendingDelivery.settle();
      pendingRequest=null;
      pendingDelivery=null;
      if (pendingTimeout != null) {
        pendingTimeout.cancel(false);
        pendingTimeout=null;
      }
    }
    super.processDeliveryUpdates(provider);
  }
 catch (  Exception e) {
    throw IOExceptionSupport.create(e);
  }
}","@Override public void processDeliveryUpdates(AmqpProvider provider) throws IOException {
  try {
    if (pendingDelivery != null && pendingDelivery.remotelySettled()) {
      DeliveryState state=pendingDelivery.getRemoteState();
      JmsTransactionId txId=(JmsTransactionId)pendingDelivery.getContext();
      if (state instanceof Declared) {
        LOG.debug(""String_Node_Str"",txId);
        Declared declared=(Declared)state;
        txId.setProviderHint(declared.getTxnId());
        pendingRequest.onSuccess();
      }
 else       if (state instanceof Rejected) {
        LOG.debug(""String_Node_Str"",txId);
        Rejected rejected=(Rejected)state;
        Exception cause=AmqpSupport.convertToException(getEndpoint(),rejected.getError());
        JMSException failureCause=null;
        if (txId.getProviderContext().equals(COMMIT_MARKER)) {
          failureCause=new TransactionRolledBackException(cause.getMessage());
        }
 else {
          failureCause=new JMSException(cause.getMessage());
        }
        pendingRequest.onFailure(failureCause);
      }
 else {
        LOG.debug(""String_Node_Str"",txId);
        pendingRequest.onSuccess();
      }
      pendingDelivery.settle();
      pendingRequest=null;
      pendingDelivery=null;
      if (pendingTimeout != null) {
        pendingTimeout.cancel(false);
        pendingTimeout=null;
      }
    }
    super.processDeliveryUpdates(provider);
  }
 catch (  Exception e) {
    throw IOExceptionSupport.create(e);
  }
}"
41605,"@Test(timeout=30000) public void testQueueBrowserNextElementWithNoMessage() throws IOException, Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    testPeer.expectQueueBrowserAttach();
    testPeer.expectLinkFlow();
    testPeer.expectLinkFlow(true,true,equalTo(UnsignedInteger.valueOf(1)));
    testPeer.expectDetach(true,true,true);
    QueueBrowser browser=session.createBrowser(queue);
    Enumeration<?> queueView=browser.getEnumeration();
    assertNotNull(queueView);
    assertNull(queueView.nextElement());
    browser.close();
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","@Test(timeout=30000) public void testQueueBrowserNextElementWithNoMessage() throws IOException, Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    testPeer.expectQueueBrowserAttach();
    testPeer.expectLinkFlow();
    testPeer.expectLinkFlow(true,true,equalTo(UnsignedInteger.valueOf(JmsPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH)));
    testPeer.expectDetach(true,true,true);
    QueueBrowser browser=session.createBrowser(queue);
    Enumeration<?> queueView=browser.getEnumeration();
    assertNotNull(queueView);
    assertNull(queueView.nextElement());
    browser.close();
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41606,"@Test(timeout=20000) public void testAsyncDeliveryOrder() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin();
    CoordinatorMatcher txCoordinatorMatcher=new CoordinatorMatcher();
    testPeer.expectSenderAttach(txCoordinatorMatcher,false,false);
    Session session=connection.createSession(true,Session.SESSION_TRANSACTED);
    testPeer.expectReceiverAttach();
    int messageCount=10;
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,new AmqpValueDescribedType(""String_Node_Str""),messageCount,false,false,equalTo(UnsignedInteger.valueOf(messageCount)),1,true);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageConsumer consumer=session.createConsumer(queue);
    testPeer.waitForAllHandlersToComplete(3000);
    Binary txnId=new Binary(new byte[]{(byte)5,(byte)6,(byte)7,(byte)8});
    TransferPayloadCompositeMatcher declareMatcher=new TransferPayloadCompositeMatcher();
    declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));
    testPeer.expectTransfer(declareMatcher,nullValue(),false,new Declared().setTxnId(txnId),true);
    for (int i=1; i <= messageCount; i++) {
      TransactionalStateMatcher stateMatcher=new TransactionalStateMatcher();
      stateMatcher.withTxnId(equalTo(txnId));
      stateMatcher.withOutcome(new AcceptedMatcher());
      testPeer.expectDisposition(true,stateMatcher);
    }
    final CountDownLatch done=new CountDownLatch(messageCount);
    final AtomicInteger index=new AtomicInteger(-1);
    consumer.setMessageListener(new DeliveryOrderListener(done,index));
    testPeer.waitForAllHandlersToComplete(3000);
    assertTrue(""String_Node_Str"",done.await(10,TimeUnit.SECONDS));
    assertEquals(""String_Node_Str"",messageCount - 1,index.get());
  }
 }","@Test(timeout=20000) public void testAsyncDeliveryOrder() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin();
    CoordinatorMatcher txCoordinatorMatcher=new CoordinatorMatcher();
    testPeer.expectSenderAttach(txCoordinatorMatcher,false,false);
    Session session=connection.createSession(true,Session.SESSION_TRANSACTED);
    testPeer.expectReceiverAttach();
    int messageCount=10;
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,new AmqpValueDescribedType(""String_Node_Str""),messageCount,false,false,equalTo(UnsignedInteger.valueOf(JmsPrefetchPolicy.DEFAULT_QUEUE_PREFETCH)),1,true);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageConsumer consumer=session.createConsumer(queue);
    testPeer.waitForAllHandlersToComplete(3000);
    Binary txnId=new Binary(new byte[]{(byte)5,(byte)6,(byte)7,(byte)8});
    TransferPayloadCompositeMatcher declareMatcher=new TransferPayloadCompositeMatcher();
    declareMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(new Declare()));
    testPeer.expectTransfer(declareMatcher,nullValue(),false,new Declared().setTxnId(txnId),true);
    for (int i=1; i <= messageCount; i++) {
      TransactionalStateMatcher stateMatcher=new TransactionalStateMatcher();
      stateMatcher.withTxnId(equalTo(txnId));
      stateMatcher.withOutcome(new AcceptedMatcher());
      testPeer.expectDisposition(true,stateMatcher);
    }
    final CountDownLatch done=new CountDownLatch(messageCount);
    final AtomicInteger index=new AtomicInteger(-1);
    consumer.setMessageListener(new DeliveryOrderListener(done,index));
    testPeer.waitForAllHandlersToComplete(3000);
    assertTrue(""String_Node_Str"",done.await(10,TimeUnit.SECONDS));
    assertEquals(""String_Node_Str"",messageCount - 1,index.get());
  }
 }"
41607,"@Test(timeout=20000) public void testFailoverHandlesDropAfterQueueBrowserDrain() throws Exception {
  try (TestAmqpPeer originalPeer=new TestAmqpPeer();TestAmqpPeer finalPeer=new TestAmqpPeer()){
    final CountDownLatch originalConnected=new CountDownLatch(1);
    final CountDownLatch finalConnected=new CountDownLatch(1);
    final String originalURI=createPeerURI(originalPeer);
    final String finalURI=createPeerURI(finalPeer);
    LOG.info(""String_Node_Str"",originalURI);
    LOG.info(""String_Node_Str"",finalURI);
    originalPeer.expectSaslAnonymousConnect();
    originalPeer.expectBegin();
    final JmsConnection connection=establishAnonymousConnecton(originalPeer,finalPeer);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onConnectionEstablished(      URI remoteURI){
        LOG.info(""String_Node_Str"",remoteURI);
        if (originalURI.equals(remoteURI.toString())) {
          originalConnected.countDown();
        }
      }
      @Override public void onConnectionRestored(      URI remoteURI){
        LOG.info(""String_Node_Str"",remoteURI);
        if (finalURI.equals(remoteURI.toString())) {
          finalConnected.countDown();
        }
      }
    }
);
    connection.start();
    assertTrue(""String_Node_Str"",originalConnected.await(5,TimeUnit.SECONDS));
    originalPeer.expectBegin();
    originalPeer.expectQueueBrowserAttach();
    originalPeer.expectLinkFlow();
    originalPeer.expectLinkFlowThenDrop();
    finalPeer.expectSaslAnonymousConnect();
    finalPeer.expectBegin();
    finalPeer.expectBegin();
    finalPeer.expectQueueBrowserAttach();
    finalPeer.expectLinkFlow();
    finalPeer.expectLinkFlow(true,true,equalTo(UnsignedInteger.valueOf(1)));
    finalPeer.expectDetach(true,true,true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    QueueBrowser browser=session.createBrowser(queue);
    Enumeration<?> queueView=browser.getEnumeration();
    assertNotNull(queueView);
    assertFalse(queueView.hasMoreElements());
    browser.close();
  }
 }","@Test(timeout=20000) public void testFailoverHandlesDropAfterQueueBrowserDrain() throws Exception {
  try (TestAmqpPeer originalPeer=new TestAmqpPeer();TestAmqpPeer finalPeer=new TestAmqpPeer()){
    final CountDownLatch originalConnected=new CountDownLatch(1);
    final CountDownLatch finalConnected=new CountDownLatch(1);
    final String originalURI=createPeerURI(originalPeer);
    final String finalURI=createPeerURI(finalPeer);
    LOG.info(""String_Node_Str"",originalURI);
    LOG.info(""String_Node_Str"",finalURI);
    originalPeer.expectSaslAnonymousConnect();
    originalPeer.expectBegin();
    final JmsConnection connection=establishAnonymousConnecton(originalPeer,finalPeer);
    connection.addConnectionListener(new JmsDefaultConnectionListener(){
      @Override public void onConnectionEstablished(      URI remoteURI){
        LOG.info(""String_Node_Str"",remoteURI);
        if (originalURI.equals(remoteURI.toString())) {
          originalConnected.countDown();
        }
      }
      @Override public void onConnectionRestored(      URI remoteURI){
        LOG.info(""String_Node_Str"",remoteURI);
        if (finalURI.equals(remoteURI.toString())) {
          finalConnected.countDown();
        }
      }
    }
);
    connection.start();
    assertTrue(""String_Node_Str"",originalConnected.await(5,TimeUnit.SECONDS));
    originalPeer.expectBegin();
    originalPeer.expectQueueBrowserAttach();
    originalPeer.expectLinkFlow();
    originalPeer.expectLinkFlowThenDrop();
    finalPeer.expectSaslAnonymousConnect();
    finalPeer.expectBegin();
    finalPeer.expectBegin();
    finalPeer.expectQueueBrowserAttach();
    finalPeer.expectLinkFlow();
    finalPeer.expectLinkFlow(true,true,equalTo(UnsignedInteger.valueOf(JmsPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH)));
    finalPeer.expectDetach(true,true,true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    QueueBrowser browser=session.createBrowser(queue);
    Enumeration<?> queueView=browser.getEnumeration();
    assertNotNull(queueView);
    assertFalse(queueView.hasMoreElements());
    browser.close();
  }
 }"
41608,"public void expectLinkFlowRespondWithTransfer(final HeaderDescribedType headerDescribedType,final MessageAnnotationsDescribedType messageAnnotationsDescribedType,final PropertiesDescribedType propertiesDescribedType,ApplicationPropertiesDescribedType appPropertiesDescribedType,final DescribedType content,final int count,final boolean drain,final boolean sendDrainFlowResponse,Matcher<UnsignedInteger> creditMatcher,final Integer nextIncomingId,final boolean sendSettled,boolean addMessageNumberProperty){
  if (nextIncomingId == null && count > 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Matcher<Boolean> drainMatcher=null;
  if (drain) {
    drainMatcher=equalTo(true);
  }
 else {
    drainMatcher=Matchers.anyOf(equalTo(false),nullValue());
  }
  Matcher<UnsignedInteger> remoteNextIncomingIdMatcher=null;
  if (nextIncomingId != null) {
    remoteNextIncomingIdMatcher=Matchers.equalTo(UnsignedInteger.valueOf(nextIncomingId));
  }
 else {
    remoteNextIncomingIdMatcher=Matchers.greaterThanOrEqualTo(UnsignedInteger.ONE);
  }
  final FlowMatcher flowMatcher=new FlowMatcher().withLinkCredit(Matchers.greaterThanOrEqualTo(UnsignedInteger.valueOf(count))).withDrain(drainMatcher).withNextIncomingId(remoteNextIncomingIdMatcher);
  CompositeAmqpPeerRunnable composite=new CompositeAmqpPeerRunnable();
  boolean addComposite=false;
  if (appPropertiesDescribedType == null && addMessageNumberProperty) {
    appPropertiesDescribedType=new ApplicationPropertiesDescribedType();
  }
  for (int i=0; i < count; i++) {
    final int nextId=nextIncomingId + i;
    String tagString=""String_Node_Str"" + nextId;
    Binary dtag=new Binary(tagString.getBytes());
    if (addMessageNumberProperty) {
      appPropertiesDescribedType.setApplicationProperty(MESSAGE_NUMBER,i);
    }
    final TransferFrame transferResponse=new TransferFrame().setDeliveryId(UnsignedInteger.valueOf(nextId)).setDeliveryTag(dtag).setMessageFormat(UnsignedInteger.ZERO).setSettled(sendSettled);
    Binary payload=prepareTransferPayload(headerDescribedType,messageAnnotationsDescribedType,propertiesDescribedType,appPropertiesDescribedType,content);
    final FrameSender transferResponseSender=new FrameSender(this,FrameType.AMQP,-1,transferResponse,payload);
    transferResponseSender.setValueProvider(new ValueProvider(){
      @Override public void setValues(){
        transferResponse.setHandle(flowMatcher.getReceivedHandle());
        transferResponseSender.setChannel(flowMatcher.getActualChannel());
      }
    }
);
    addComposite=true;
    composite.add(transferResponseSender);
  }
  if (drain && sendDrainFlowResponse) {
    final FlowFrame drainResponse=new FlowFrame();
    drainResponse.setOutgoingWindow(UnsignedInteger.ZERO);
    drainResponse.setIncomingWindow(UnsignedInteger.valueOf(Integer.MAX_VALUE));
    drainResponse.setLinkCredit(UnsignedInteger.ZERO);
    drainResponse.setDrain(true);
    final FrameSender flowResponseSender=new FrameSender(this,FrameType.AMQP,-1,drainResponse,null);
    flowResponseSender.setValueProvider(new ValueProvider(){
      @Override public void setValues(){
        flowResponseSender.setChannel(flowMatcher.getActualChannel());
        drainResponse.setHandle(flowMatcher.getReceivedHandle());
        drainResponse.setDeliveryCount(calculateNewDeliveryCount(flowMatcher));
        drainResponse.setNextOutgoingId(calculateNewOutgoingId(flowMatcher,count));
        drainResponse.setNextIncomingId(flowMatcher.getReceivedNextOutgoingId());
      }
    }
);
    addComposite=true;
    composite.add(flowResponseSender);
  }
  if (addComposite) {
    flowMatcher.onCompletion(composite);
  }
  addHandler(flowMatcher);
}","public void expectLinkFlowRespondWithTransfer(final HeaderDescribedType headerDescribedType,final MessageAnnotationsDescribedType messageAnnotationsDescribedType,final PropertiesDescribedType propertiesDescribedType,ApplicationPropertiesDescribedType appPropertiesDescribedType,final DescribedType content,final int count,final boolean drain,final boolean sendDrainFlowResponse,Matcher<UnsignedInteger> creditMatcher,final Integer nextIncomingId,final boolean sendSettled,boolean addMessageNumberProperty){
  if (nextIncomingId == null && count > 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Matcher<Boolean> drainMatcher=null;
  if (drain) {
    drainMatcher=equalTo(true);
  }
 else {
    drainMatcher=Matchers.anyOf(equalTo(false),nullValue());
  }
  Matcher<UnsignedInteger> remoteNextIncomingIdMatcher=null;
  if (nextIncomingId != null) {
    remoteNextIncomingIdMatcher=Matchers.equalTo(UnsignedInteger.valueOf(nextIncomingId));
  }
 else {
    remoteNextIncomingIdMatcher=Matchers.greaterThanOrEqualTo(UnsignedInteger.ONE);
  }
  final FlowMatcher flowMatcher=new FlowMatcher().withLinkCredit(creditMatcher).withDrain(drainMatcher).withNextIncomingId(remoteNextIncomingIdMatcher);
  CompositeAmqpPeerRunnable composite=new CompositeAmqpPeerRunnable();
  boolean addComposite=false;
  if (appPropertiesDescribedType == null && addMessageNumberProperty) {
    appPropertiesDescribedType=new ApplicationPropertiesDescribedType();
  }
  for (int i=0; i < count; i++) {
    final int nextId=nextIncomingId + i;
    String tagString=""String_Node_Str"" + nextId;
    Binary dtag=new Binary(tagString.getBytes());
    if (addMessageNumberProperty) {
      appPropertiesDescribedType.setApplicationProperty(MESSAGE_NUMBER,i);
    }
    final TransferFrame transferResponse=new TransferFrame().setDeliveryId(UnsignedInteger.valueOf(nextId)).setDeliveryTag(dtag).setMessageFormat(UnsignedInteger.ZERO).setSettled(sendSettled);
    Binary payload=prepareTransferPayload(headerDescribedType,messageAnnotationsDescribedType,propertiesDescribedType,appPropertiesDescribedType,content);
    final FrameSender transferResponseSender=new FrameSender(this,FrameType.AMQP,-1,transferResponse,payload);
    transferResponseSender.setValueProvider(new ValueProvider(){
      @Override public void setValues(){
        transferResponse.setHandle(flowMatcher.getReceivedHandle());
        transferResponseSender.setChannel(flowMatcher.getActualChannel());
      }
    }
);
    addComposite=true;
    composite.add(transferResponseSender);
  }
  if (drain && sendDrainFlowResponse) {
    final FlowFrame drainResponse=new FlowFrame();
    drainResponse.setOutgoingWindow(UnsignedInteger.ZERO);
    drainResponse.setIncomingWindow(UnsignedInteger.valueOf(Integer.MAX_VALUE));
    drainResponse.setLinkCredit(UnsignedInteger.ZERO);
    drainResponse.setDrain(true);
    final FrameSender flowResponseSender=new FrameSender(this,FrameType.AMQP,-1,drainResponse,null);
    flowResponseSender.setValueProvider(new ValueProvider(){
      @Override public void setValues(){
        flowResponseSender.setChannel(flowMatcher.getActualChannel());
        drainResponse.setHandle(flowMatcher.getReceivedHandle());
        drainResponse.setDeliveryCount(calculateNewDeliveryCount(flowMatcher));
        drainResponse.setNextOutgoingId(calculateNewOutgoingId(flowMatcher,count));
        drainResponse.setNextIncomingId(flowMatcher.getReceivedNextOutgoingId());
      }
    }
);
    addComposite=true;
    composite.add(flowResponseSender);
  }
  if (addComposite) {
    flowMatcher.onCompletion(composite);
  }
  addHandler(flowMatcher);
}"
41609,"@Test(timeout=20000) public void testRemotelyCloseConnectionDuringSyncSend() throws Exception {
  final String BREAD_CRUMB=""String_Node_Str"";
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    testPeer.expectSenderAttach();
    String text=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(text));
    testPeer.expectTransfer(messageMatcher,nullValue(),false,false,null,false);
    testPeer.remotelyCloseConnection(false,AmqpError.RESOURCE_LIMIT_EXCEEDED,BREAD_CRUMB);
    Queue queue=session.createQueue(""String_Node_Str"");
    final MessageProducer producer=session.createProducer(queue);
    Message message=session.createTextMessage(text);
    try {
      producer.send(message);
      fail(""String_Node_Str"");
    }
 catch (    JMSException jmse) {
      assertNotNull(""String_Node_Str"",jmse.getMessage());
      assertTrue(""String_Node_Str"",jmse.getMessage().contains(BREAD_CRUMB));
    }
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","@Test(timeout=20000) public void testRemotelyCloseConnectionDuringSyncSend() throws Exception {
  final String BREAD_CRUMB=""String_Node_Str"";
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    testPeer.expectSenderAttach();
    String text=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(text));
    testPeer.expectTransfer(messageMatcher,nullValue(),false,false,null,false);
    testPeer.remotelyCloseConnection(true,AmqpError.RESOURCE_LIMIT_EXCEEDED,BREAD_CRUMB);
    Queue queue=session.createQueue(""String_Node_Str"");
    final MessageProducer producer=session.createProducer(queue);
    Message message=session.createTextMessage(text);
    try {
      producer.send(message);
      fail(""String_Node_Str"");
    }
 catch (    JMSException jmse) {
      assertNotNull(""String_Node_Str"",jmse.getMessage());
      assertTrue(""String_Node_Str"",jmse.getMessage().contains(BREAD_CRUMB));
    }
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41610,"/** 
 * @throws JMSException
 * @see javax.jms.MessageConsumer#close()
 */
@Override public void close() throws JMSException {
  if (!closed.get()) {
    session.getTransactionContext().addSynchronization(new JmsTxSynchronization(){
      @Override public boolean validate(      JmsTransactionContext context) throws Exception {
        if (!context.isInTransaction() || !delivered.get()) {
          doClose();
          return false;
        }
        return true;
      }
      @Override public void afterCommit() throws Exception {
        doClose();
      }
      @Override public void afterRollback() throws Exception {
        doClose();
      }
    }
);
  }
}","/** 
 * @throws JMSException
 * @see javax.jms.MessageConsumer#close()
 */
@Override public void close() throws JMSException {
  if (!closed.get()) {
    session.getTransactionContext().addSynchronization(new JmsTxSynchronization(){
      @Override public boolean validate(      JmsTransactionContext context) throws Exception {
        if (!context.isInTransaction() || !delivered.get() || isBrowser()) {
          doClose();
          return false;
        }
        return true;
      }
      @Override public void afterCommit() throws Exception {
        doClose();
      }
      @Override public void afterRollback() throws Exception {
        doClose();
      }
    }
);
  }
}"
41611,"@Override public boolean validate(JmsTransactionContext context) throws Exception {
  if (!context.isInTransaction() || !delivered.get()) {
    doClose();
    return false;
  }
  return true;
}","@Override public boolean validate(JmsTransactionContext context) throws Exception {
  if (!context.isInTransaction() || !delivered.get() || isBrowser()) {
    doClose();
    return false;
  }
  return true;
}"
41612,"/** 
 * Remove a URI from the pool if present, otherwise has no effect.
 * @param uri The URI to attempt to remove from the pool.
 * @returns true if the given URI was removed from the pool.
 */
public boolean remove(URI uri){
  if (uri == null) {
    return false;
  }
synchronized (uris) {
    for (    URI candidate : uris) {
      if (compareURIs(uri,candidate)) {
        return uris.remove(candidate);
      }
    }
  }
  return false;
}","/** 
 * Remove a URI from the pool if present, otherwise has no effect.
 * @param uri The URI to attempt to remove from the pool.
 * @return true if the given URI was removed from the pool.
 */
public boolean remove(URI uri){
  if (uri == null) {
    return false;
  }
synchronized (uris) {
    for (    URI candidate : uris) {
      if (compareURIs(uri,candidate)) {
        return uris.remove(candidate);
      }
    }
  }
  return false;
}"
41613,"/** 
 * When a redirect type exception is received this method is called to create the appropriate redirect exception type containing the error details needed.
 * @param error the Symbol that defines the redirection error type.
 * @param message the basic error message that should used or amended for the returned exception.
 * @param condition the ErrorCondition that describes the redirection.
 * @returns an Exception that captures the details of the redirection error.
 */
@SuppressWarnings(""String_Node_Str"") protected Exception createRedirectException(Symbol error,String message,ErrorCondition condition){
  Exception result=null;
  Map<String,Object> info=condition.getInfo();
  if (info == null) {
    result=new IOException(message + ""String_Node_Str"");
  }
 else {
    String hostname=(String)info.get(""String_Node_Str"");
    String networkHost=(String)info.get(""String_Node_Str"");
    if (networkHost == null || networkHost.isEmpty()) {
      result=new IOException(message + ""String_Node_Str"");
    }
    int port=0;
    try {
      port=Integer.valueOf(info.get(""String_Node_Str"").toString());
    }
 catch (    Exception ex) {
      result=new IOException(message + ""String_Node_Str"");
    }
    result=new ProviderRedirectedException(message,hostname,networkHost,port);
  }
  return result;
}","/** 
 * When a redirect type exception is received this method is called to create the appropriate redirect exception type containing the error details needed.
 * @param error the Symbol that defines the redirection error type.
 * @param message the basic error message that should used or amended for the returned exception.
 * @param condition the ErrorCondition that describes the redirection.
 * @return an Exception that captures the details of the redirection error.
 */
@SuppressWarnings(""String_Node_Str"") protected Exception createRedirectException(Symbol error,String message,ErrorCondition condition){
  Exception result=null;
  Map<String,Object> info=condition.getInfo();
  if (info == null) {
    result=new IOException(message + ""String_Node_Str"");
  }
 else {
    String hostname=(String)info.get(""String_Node_Str"");
    String networkHost=(String)info.get(""String_Node_Str"");
    if (networkHost == null || networkHost.isEmpty()) {
      result=new IOException(message + ""String_Node_Str"");
    }
    int port=0;
    try {
      port=Integer.valueOf(info.get(""String_Node_Str"").toString());
    }
 catch (    Exception ex) {
      result=new IOException(message + ""String_Node_Str"");
    }
    result=new ProviderRedirectedException(message,hostname,networkHost,port);
  }
  return result;
}"
41614,"/** 
 * Indicates if this DiscoveryAgent requires a ScheduledExecutorService in order to perform its discovery work.
 * @returns true if the agent requires that its parent provide it with a scheduler.
 */
boolean isSchedulerRequired();","/** 
 * Indicates if this DiscoveryAgent requires a ScheduledExecutorService in order to perform its discovery work.
 * @return true if the agent requires that its parent provide it with a scheduler.
 */
boolean isSchedulerRequired();"
41615,"@Test(timeout=5000) public void testCreateTemporaryTopicFailsWhenLinkRefusedAndAttachResponseWriteIsDeferred() throws Exception {
  doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(false,true);
}","@Test(timeout=5000) public void testCreateTemporaryTopicFailsWhenLinkRefusedAndAttachResponseWriteIsDeferred() throws Exception {
  doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(true,true);
}"
41616,"private void doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(boolean topic,boolean deferAttachResponseWrite) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    testPeer.expectAndRefuseTempQueueCreationAttach(AmqpError.UNAUTHORIZED_ACCESS,""String_Node_Str"",false);
    try {
      if (topic) {
        session.createTemporaryTopic();
      }
 else {
        session.createTemporaryQueue();
      }
      fail(""String_Node_Str"");
    }
 catch (    JMSSecurityException jmsse) {
    }
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }","private void doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(boolean topic,boolean deferAttachResponseWrite) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer()){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    try {
      if (topic) {
        testPeer.expectAndRefuseTempTopicCreationAttach(AmqpError.UNAUTHORIZED_ACCESS,""String_Node_Str"",false);
        session.createTemporaryTopic();
      }
 else {
        testPeer.expectAndRefuseTempQueueCreationAttach(AmqpError.UNAUTHORIZED_ACCESS,""String_Node_Str"",false);
        session.createTemporaryQueue();
      }
      fail(""String_Node_Str"");
    }
 catch (    JMSSecurityException jmsse) {
    }
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }"
41617,"@Test(timeout=5000) public void testCreateTemporaryTopicFailsWhenLinkRefusedAndAttachResponseWriteIsNotDeferred() throws Exception {
  doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(false,false);
}","@Test(timeout=5000) public void testCreateTemporaryTopicFailsWhenLinkRefusedAndAttachResponseWriteIsNotDeferred() throws Exception {
  doCreateTemporaryDestinationFailsWhenLinkRefusedTestImpl(true,false);
}"
41618,"private static TrustManager[] loadTrustManagers(TransportSslOptions options) throws Exception {
  if (options.getTrustStoreLocation() == null) {
    return null;
  }
  TrustManagerFactory fact=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
  String storeLocation=options.getKeyStoreLocation();
  String storePassword=options.getKeyStorePassword();
  String storeType=options.getStoreType();
  LOG.trace(""String_Node_Str"",storeLocation,storeType);
  KeyStore trustStore=loadStore(storeLocation,storePassword,storeType);
  fact.init(trustStore);
  return fact.getTrustManagers();
}","private static TrustManager[] loadTrustManagers(TransportSslOptions options) throws Exception {
  if (options.getTrustStoreLocation() == null) {
    return null;
  }
  TrustManagerFactory fact=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
  String storeLocation=options.getTrustStoreLocation();
  String storePassword=options.getTrustStorePassword();
  String storeType=options.getStoreType();
  LOG.trace(""String_Node_Str"",storeLocation,storeType);
  KeyStore trustStore=loadStore(storeLocation,storePassword,storeType);
  fact.init(trustStore);
  return fact.getTrustManagers();
}"
41619,"public void input(final ByteBuffer input){
  TransportResult frameParsingError=null;
  int size=_size;
  ByteBuffer nextFramesInput=null;
  byte[] header=new byte[8];
  boolean transportAccepting=true;
  ByteBuffer currentInput=input;
  while (currentInput.hasRemaining() && _state != State.ERROR && transportAccepting) {
switch (_state) {
case HEADER0:
      if (currentInput.hasRemaining()) {
        byte c=currentInput.get();
        header[0]=c;
        _state=State.HEADER1;
      }
 else {
        break;
      }
case HEADER1:
    if (currentInput.hasRemaining()) {
      byte c=currentInput.get();
      header[1]=c;
      _state=State.HEADER2;
    }
 else {
      break;
    }
case HEADER2:
  if (currentInput.hasRemaining()) {
    byte c=currentInput.get();
    header[2]=c;
    _state=State.HEADER3;
  }
 else {
    break;
  }
case HEADER3:
if (currentInput.hasRemaining()) {
  byte c=currentInput.get();
  header[3]=c;
  _state=State.HEADER4;
}
 else {
  break;
}
case HEADER4:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[4]=c;
_state=State.HEADER5;
}
 else {
break;
}
case HEADER5:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[5]=c;
_state=State.HEADER6;
}
 else {
break;
}
case HEADER6:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[6]=c;
_state=State.HEADER7;
}
 else {
break;
}
case HEADER7:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[7]=c;
_peer.receiveHeader(header);
_state=State.SIZE_0;
}
 else {
break;
}
case SIZE_0:
if (!currentInput.hasRemaining()) {
break;
}
if (currentInput.remaining() >= 4) {
size=currentInput.getInt();
_state=State.PRE_PARSE;
break;
}
 else {
size=(currentInput.get() << 24) & 0xFF000000;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_1;
break;
}
}
case SIZE_1:
size|=(currentInput.get() << 16) & 0xFF0000;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_2;
break;
}
case SIZE_2:
size|=(currentInput.get() << 8) & 0xFF00;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_3;
break;
}
case SIZE_3:
size|=currentInput.get() & 0xFF;
_state=State.PRE_PARSE;
case PRE_PARSE:
;
if (size < 8) {
frameParsingError=error(""String_Node_Str"" + ""String_Node_Str"",_size,8);
_state=State.ERROR;
break;
}
if (currentInput.remaining() < size - 4) {
_frameBuffer=ByteBuffer.allocate(size - 4);
_frameBuffer.put(currentInput);
_state=State.BUFFERING;
break;
}
case BUFFERING:
if (_frameBuffer != null) {
if (currentInput.remaining() < _frameBuffer.remaining()) {
_frameBuffer.put(currentInput);
break;
}
 else {
ByteBuffer dup=currentInput.duplicate();
dup.limit(dup.position() + _frameBuffer.remaining());
currentInput.position(currentInput.position() + _frameBuffer.remaining());
_frameBuffer.put(dup);
nextFramesInput=currentInput;
_frameBuffer.flip();
currentInput=_frameBuffer;
_state=State.PARSING;
}
}
case PARSING:
int dataOffset=(currentInput.get() << 2) & 0x3FF;
if (dataOffset < 8) {
frameParsingError=error(""String_Node_Str"",dataOffset,8);
_state=State.ERROR;
break;
}
 else if (dataOffset > size) {
frameParsingError=error(""String_Node_Str"",dataOffset,_size);
_state=State.ERROR;
break;
}
int type=currentInput.get() & 0xFF;
int channel=currentInput.getShort() & 0xFF;
if (dataOffset != 8) {
currentInput.position(currentInput.position() + dataOffset - 8);
}
final int frameBodySize=size - dataOffset;
if (nextFramesInput == null) {
nextFramesInput=currentInput;
currentInput=currentInput.duplicate();
final int endPos=currentInput.position() + frameBodySize;
currentInput.limit(endPos);
nextFramesInput.position(endPos);
}
try {
if (frameBodySize > 0) {
Data data=Data.Factory.create();
data.decode(currentInput);
Data.DataType dataType=data.type();
if (dataType != Data.DataType.DESCRIBED) {
throw new IllegalArgumentException(""String_Node_Str"" + Data.DataType.DESCRIBED + ""String_Node_Str""+ dataType);
}
DescribedType describedType=data.getDescribedType();
LOGGER.debug(""String_Node_Str"",describedType);
Binary payload;
if (currentInput.hasRemaining()) {
byte[] payloadBytes=new byte[currentInput.remaining()];
currentInput.get(payloadBytes);
payload=new Binary(payloadBytes);
}
 else {
payload=null;
}
_peer.receiveFrame(type,channel,describedType,payload);
}
 else {
LOGGER.debug(""String_Node_Str"");
}
_size=0;
currentInput=nextFramesInput;
nextFramesInput=null;
_frameBuffer=null;
if (_state != State.HEADER0) {
_state=State.SIZE_0;
}
}
 catch (DecodeException ex) {
_state=State.ERROR;
frameParsingError=error(ex);
}
break;
case ERROR:
}
}
_size=size;
if (_state == State.ERROR) {
if (frameParsingError != null) {
frameParsingError.checkIsOk();
}
 else {
TransportResultFactory.error(""String_Node_Str"").checkIsOk();
}
}
}","public void input(final ByteBuffer input){
  TransportResult frameParsingError=null;
  int size=_size;
  ByteBuffer nextFramesInput=null;
  byte[] header=new byte[8];
  boolean transportAccepting=true;
  ByteBuffer currentInput=input;
  while (currentInput.hasRemaining() && _state != State.ERROR && transportAccepting) {
switch (_state) {
case HEADER0:
      if (currentInput.hasRemaining()) {
        byte c=currentInput.get();
        header[0]=c;
        _state=State.HEADER1;
      }
 else {
        break;
      }
case HEADER1:
    if (currentInput.hasRemaining()) {
      byte c=currentInput.get();
      header[1]=c;
      _state=State.HEADER2;
    }
 else {
      break;
    }
case HEADER2:
  if (currentInput.hasRemaining()) {
    byte c=currentInput.get();
    header[2]=c;
    _state=State.HEADER3;
  }
 else {
    break;
  }
case HEADER3:
if (currentInput.hasRemaining()) {
  byte c=currentInput.get();
  header[3]=c;
  _state=State.HEADER4;
}
 else {
  break;
}
case HEADER4:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[4]=c;
_state=State.HEADER5;
}
 else {
break;
}
case HEADER5:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[5]=c;
_state=State.HEADER6;
}
 else {
break;
}
case HEADER6:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[6]=c;
_state=State.HEADER7;
}
 else {
break;
}
case HEADER7:
if (currentInput.hasRemaining()) {
byte c=currentInput.get();
header[7]=c;
_peer.receiveHeader(header);
_state=State.SIZE_0;
}
 else {
break;
}
case SIZE_0:
if (!currentInput.hasRemaining()) {
break;
}
if (currentInput.remaining() >= 4) {
size=currentInput.getInt();
_state=State.PRE_PARSE;
break;
}
 else {
size=(currentInput.get() << 24) & 0xFF000000;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_1;
break;
}
}
case SIZE_1:
size|=(currentInput.get() << 16) & 0xFF0000;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_2;
break;
}
case SIZE_2:
size|=(currentInput.get() << 8) & 0xFF00;
if (!currentInput.hasRemaining()) {
_state=State.SIZE_3;
break;
}
case SIZE_3:
size|=currentInput.get() & 0xFF;
_state=State.PRE_PARSE;
case PRE_PARSE:
;
if (size < 8) {
frameParsingError=error(""String_Node_Str"" + ""String_Node_Str"",_size,8);
_state=State.ERROR;
break;
}
if (currentInput.remaining() < size - 4) {
_frameBuffer=ByteBuffer.allocate(size - 4);
_frameBuffer.put(currentInput);
_state=State.BUFFERING;
break;
}
case BUFFERING:
if (_frameBuffer != null) {
if (currentInput.remaining() < _frameBuffer.remaining()) {
_frameBuffer.put(currentInput);
break;
}
 else {
ByteBuffer dup=currentInput.duplicate();
dup.limit(dup.position() + _frameBuffer.remaining());
currentInput.position(currentInput.position() + _frameBuffer.remaining());
_frameBuffer.put(dup);
nextFramesInput=currentInput;
_frameBuffer.flip();
currentInput=_frameBuffer;
_state=State.PARSING;
}
}
case PARSING:
int dataOffset=(currentInput.get() << 2) & 0x3FF;
if (dataOffset < 8) {
frameParsingError=error(""String_Node_Str"",dataOffset,8);
_state=State.ERROR;
break;
}
 else if (dataOffset > size) {
frameParsingError=error(""String_Node_Str"",dataOffset,_size);
_state=State.ERROR;
break;
}
int type=currentInput.get() & 0xFF;
int channel=currentInput.getShort() & 0xFFFF;
if (dataOffset != 8) {
currentInput.position(currentInput.position() + dataOffset - 8);
}
final int frameBodySize=size - dataOffset;
if (nextFramesInput == null) {
nextFramesInput=currentInput;
currentInput=currentInput.duplicate();
final int endPos=currentInput.position() + frameBodySize;
currentInput.limit(endPos);
nextFramesInput.position(endPos);
}
try {
if (frameBodySize > 0) {
Data data=Data.Factory.create();
data.decode(currentInput);
Data.DataType dataType=data.type();
if (dataType != Data.DataType.DESCRIBED) {
throw new IllegalArgumentException(""String_Node_Str"" + Data.DataType.DESCRIBED + ""String_Node_Str""+ dataType);
}
DescribedType describedType=data.getDescribedType();
LOGGER.debug(""String_Node_Str"",describedType);
Binary payload;
if (currentInput.hasRemaining()) {
byte[] payloadBytes=new byte[currentInput.remaining()];
currentInput.get(payloadBytes);
payload=new Binary(payloadBytes);
}
 else {
payload=null;
}
_peer.receiveFrame(type,channel,describedType,payload);
}
 else {
LOGGER.debug(""String_Node_Str"");
}
_size=0;
currentInput=nextFramesInput;
nextFramesInput=null;
_frameBuffer=null;
if (_state != State.HEADER0) {
_state=State.SIZE_0;
}
}
 catch (DecodeException ex) {
_state=State.ERROR;
frameParsingError=error(ex);
}
break;
case ERROR:
}
}
_size=size;
if (_state == State.ERROR) {
if (frameParsingError != null) {
frameParsingError.checkIsOk();
}
 else {
TransportResultFactory.error(""String_Node_Str"").checkIsOk();
}
}
}"
41620,"/** 
 * Triggers a pull request from the connected Provider.  An attempt is made to set a timeout on the pull request however some providers will not honor this value and the pull will remain active until a message is dispatched. The timeout value can be one of: < 0 to indicate that the request should expire immediately if no message. = 0 to indicate that the request should never time out. > 1 to indicate that the request should expire after the given time in milliseconds.
 * @param timeout The amount of time the pull request should remain valid.
 */
protected void sendPullCommand(long timeout) throws JMSException {
  if (messageQueue.isEmpty() && (getPrefetchSize() == 0 || isBrowser())) {
    connection.pull(getConsumerId(),timeout);
  }
}","/** 
 * Triggers a pull request from the connected Provider.  An attempt is made to set a timeout on the pull request however some providers will not honor this value and the pull will remain active until a message is dispatched. <p> The timeout value can be one of: <br>  {@literal < 0} to indicate that the request should expire immediately if no message.<br>{@literal = 0} to indicate that the request should never time out.<br>{@literal > 1} to indicate that the request should expire after the given time in milliseconds.
 * @param timeout The amount of time the pull request should remain valid.
 */
protected void sendPullCommand(long timeout) throws JMSException {
  if (messageQueue.isEmpty() && (getPrefetchSize() == 0 || isBrowser())) {
    connection.pull(getConsumerId(),timeout);
  }
}"
41621,"/** 
 * Called to indicate that the underlying connection to the Broker has been established for the first time.  For a fault tolerant provider this event should only ever be triggered once with the interruption and recovery events following on for future
 * @param ex The exception that indicates the cause of this Provider failure.
 */
void onConnectionEstablished(URI remoteURI);","/** 
 * Called to indicate that the underlying connection to the Broker has been established for the first time.  For a fault tolerant provider this event should only ever be triggered once with the interruption and recovery events following on for future
 * @param remoteURI The URI of the Broker that the client has now connected to.
 */
void onConnectionEstablished(URI remoteURI);"
41622,"/** 
 * Sets any additional Mechanism specific properties using a Map<String, Object>
 * @param options the map of additional properties that this Mechanism should utilize.
 */
void setProperties(Map<String,Object> options);","/** 
 * Sets any additional Mechanism specific properties using a   {@code Map<String, Object>}
 * @param options the map of additional properties that this Mechanism should utilize.
 */
void setProperties(Map<String,Object> options);"
41623,"/** 
 * Validates that the expression can be used in == or <> expression. Cannot not be NULL TRUE or FALSE litterals.
 * @param expr
 */
public static void checkEqualOperand(Expression expr){
  if (expr instanceof ConstantExpression) {
    Object value=((ConstantExpression)expr).getValue();
    if (value == null) {
      throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
    }
  }
}","/** 
 * Validates that the expression can be used in   {@literal == or <>} expressions. Cannotnot be NULL TRUE or FALSE literals.
 * @param expr
 */
public static void checkEqualOperand(Expression expr){
  if (expr instanceof ConstantExpression) {
    Object value=((ConstantExpression)expr).getValue();
    if (value == null) {
      throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
    }
  }
}"
41624,"/** 
 * Only Numeric expressions can be used in >, >=, < or <= expressions.s
 * @param expr
 */
public static void checkLessThanOperand(Expression expr){
  if (expr instanceof ConstantExpression) {
    Object value=((ConstantExpression)expr).getValue();
    if (value instanceof Number) {
      return;
    }
    throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
  }
  if (expr instanceof BooleanExpression) {
    throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
  }
}","/** 
 * Only Numeric expressions can be used in   {@literal >, >=, < or <=} expressions.
 * @param expr
 */
public static void checkLessThanOperand(Expression expr){
  if (expr instanceof ConstantExpression) {
    Object value=((ConstantExpression)expr).getValue();
    if (value instanceof Number) {
      return;
    }
    throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
  }
  if (expr instanceof BooleanExpression) {
    throw new RuntimeException(""String_Node_Str"" + expr + ""String_Node_Str"");
  }
}"
41625,"/** 
 * Constructor for an JmsQueueBrowser - used internally
 * @param session
 * @param id
 * @param destination
 * @param selector
 * @throws javax.jms.JMSException
 */
protected JmsQueueBrowser(JmsSession session,JmsDestination destination,String selector) throws JMSException {
  this.session=session;
  this.destination=destination;
  this.selector=selector;
}","/** 
 * Constructor for an JmsQueueBrowser - used internally
 * @param session
 * @param destination
 * @param selector
 * @throws javax.jms.JMSException
 */
protected JmsQueueBrowser(JmsSession session,JmsDestination destination,String selector) throws JMSException {
  this.session=session;
  this.destination=destination;
  this.selector=selector;
}"
41626,"/** 
 * Sets a value which will be used to override any ttl value that may otherwise be set based on the expiration value when sending the underlying AMQP message. A value of 0 means to clear the ttl field rather than set it to anything.
 * @param ttl the value to use, in range 0 <= x <= 2^32 - 1
 * @throws MessageFormatException
 */
public void setAmqpTimeToLiveOverride(Long ttl) throws MessageFormatException {
  if (ttl != null) {
    if (ttl >= 0 && ttl <= UINT_MAX) {
      userSpecifiedTTL=ttl;
    }
 else {
      throw new MessageFormatException(JMS_AMQP_TTL + ""String_Node_Str"");
    }
  }
 else {
    userSpecifiedTTL=null;
  }
}","/** 
 * Sets a value which will be used to override any ttl value that may otherwise be set based on the expiration value when sending the underlying AMQP message. A value of 0 means to clear the ttl field rather than set it to anything.
 * @param ttl the value to use, in range  {@literal 0 <= x <= 2^32 - 1}
 * @throws MessageFormatException
 */
public void setAmqpTimeToLiveOverride(Long ttl) throws MessageFormatException {
  if (ttl != null) {
    if (ttl >= 0 && ttl <= UINT_MAX) {
      userSpecifiedTTL=ttl;
    }
 else {
      throw new MessageFormatException(JMS_AMQP_TTL + ""String_Node_Str"");
    }
  }
 else {
    userSpecifiedTTL=null;
  }
}"
41627,"/** 
 * Gets the current setting controlling how many Connect / Reconnect attempts must occur before a warn message is logged.  A value of   {@code <= 0} indicates that there will beno warn message logged regardless of how many reconnect attempts occur.
 * @return the current number of connection attempts before warn logging is triggered.
 */
public int getWarnAfterReconnectAttempts(){
  return warnAfterReconnectAttempts;
}","/** 
 * Gets the current setting controlling how many Connect / Reconnect attempts must occur before a warn message is logged.  A value of   {@literal <= 0} indicates that there will beno warn message logged regardless of how many reconnect attempts occur.
 * @return the current number of connection attempts before warn logging is triggered.
 */
public int getWarnAfterReconnectAttempts(){
  return warnAfterReconnectAttempts;
}"
41628,"/** 
 * Sets the number of Connect / Reconnect attempts that must occur before a warn message is logged indicating that the transport is not connected.  This can be useful when the client is running inside some container or service as it gives an indication of some problem with the client connection that might not otherwise be visible.  To disable the log messages this value should be set to a value @{code attempts <= 0}
 * @param warnAfterReconnectAttempts The number of failed connection attempts that must happen before a warning is logged.
 */
public void setWarnAfterReconnectAttempts(int warnAfterReconnectAttempts){
  this.warnAfterReconnectAttempts=warnAfterReconnectAttempts;
}","/** 
 * Sets the number of Connect / Reconnect attempts that must occur before a warn message is logged indicating that the transport is not connected.  This can be useful when the client is running inside some container or service as it gives an indication of some problem with the client connection that might not otherwise be visible.  To disable the log messages this value should be set to a value   {@literal <= 0}
 * @param warnAfterReconnectAttempts The number of failed connection attempts that must happen before a warning is logged.
 */
public void setWarnAfterReconnectAttempts(int warnAfterReconnectAttempts){
  this.warnAfterReconnectAttempts=warnAfterReconnectAttempts;
}"
41629,"/** 
 * Does a proper compare on the Id's
 * @param id1
 * @param id2
 * @return 0 if equal else a positive if id1 is > id2 ...
 */
public static int compare(String id1,String id2){
  int result=-1;
  String seed1=IdGenerator.getSeedFromId(id1);
  String seed2=IdGenerator.getSeedFromId(id2);
  if (seed1 != null && seed2 != null) {
    result=seed1.compareTo(seed2);
    if (result == 0) {
      long count1=IdGenerator.getSequenceFromId(id1);
      long count2=IdGenerator.getSequenceFromId(id2);
      result=(int)(count1 - count2);
    }
  }
  return result;
}","/** 
 * Does a proper compare on the Id's
 * @param id1
 * @param id2
 * @return 0 if equal else a positive if {@literal id1 > id2} ...
 */
public static int compare(String id1,String id2){
  int result=-1;
  String seed1=IdGenerator.getSeedFromId(id1);
  String seed2=IdGenerator.getSeedFromId(id2);
  if (seed1 != null && seed2 != null) {
    result=seed1.compareTo(seed2);
    if (result == 0) {
      long count1=IdGenerator.getSequenceFromId(id1);
      long count2=IdGenerator.getSequenceFromId(id2);
      result=(int)(count1 - count2);
    }
  }
  return result;
}"
41630,"/** 
 * Used to get an enqueued message. The amount of time this method blocks is based on the timeout value. - if timeout==-1 then it blocks until a message is received. - if timeout==0 then it it tries to not block at all, it returns a message if it is available - if timeout>0 then it blocks up to timeout amount of time. Expired messages will consumed by this method.
 * @return null if we timeout or if the consumer is closed.
 * @throws InterruptedException if the wait is interrupted.
 */
JmsInboundMessageDispatch dequeue(long timeout) throws InterruptedException ;","/** 
 * Used to get an enqueued message. The amount of time this method blocks is based on the timeout value. - if timeout==-1 then it blocks until a message is received. - if timeout==0 then it it tries to not block at all, it returns a message if it is available - if   {@literal timeout > 0} then itblocks up to timeout amount of time. Expired messages will consumed by this method.
 * @return null if we timeout or if the consumer is closed.
 * @throws InterruptedException if the wait is interrupted.
 */
JmsInboundMessageDispatch dequeue(long timeout) throws InterruptedException ;"
41631,"/** 
 * Parse properties from a named resource -eg. a URI or a simple name e.g. foo?name=""fred""&size=2
 * @param uri the URI whose parameters are to be parsed.
 * @return <Code>Map</Code> of properties
 * @throws Exception if an error occurs while parsing the query options.
 */
public static Map<String,String> parseParameters(String uri) throws Exception {
  if (uri == null) {
    return Collections.emptyMap();
  }
  return parseQuery(stripUpto(uri,'?'));
}","/** 
 * Parse properties from a named resource -eg. a URI or a simple name e.g.  {@literal foo?name=""fred""&size=2}
 * @param uri the URI whose parameters are to be parsed.
 * @return <Code>Map</Code> of properties
 * @throws Exception if an error occurs while parsing the query options.
 */
public static Map<String,String> parseParameters(String uri) throws Exception {
  if (uri == null) {
    return Collections.emptyMap();
  }
  return parseQuery(stripUpto(uri,'?'));
}"
41632,"/** 
 * @param topic
 * @param name
 * @param messageSelector
 * @param noLocal
 * @return the durable TopicSubscriber
 * @throws IllegalStateException
 * @throws JMSException
 * @see javax.jms.Session#createDurableSubscriber(javax.jms.Topic,java.lang.String,java.lang.String,boolean)
 */
@Override public TopicSubscriber createDurableSubscriber(Topic topic,String name,String messageSelector,boolean noLocal) throws IllegalStateException {
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * @param topic
 * @param name
 * @param messageSelector
 * @param noLocal
 * @return the durable TopicSubscriber
 * @throws JMSException
 * @see javax.jms.Session#createDurableSubscriber(javax.jms.Topic,java.lang.String,java.lang.String,boolean)
 */
@Override public TopicSubscriber createDurableSubscriber(Topic topic,String name,String messageSelector,boolean noLocal) throws JMSException {
  throw new IllegalStateException(""String_Node_Str"");
}"
41633,"/** 
 * @param destination
 * @param messageSelector
 * @param NoLocal
 * @return the MessageConsumer
 * @throws JMSException
 * @see javax.jms.Session#createConsumer(javax.jms.Destination,java.lang.String,boolean)
 */
@Override public MessageConsumer createConsumer(Destination destination,String messageSelector,boolean noLocal) throws JMSException {
  checkClosed();
  checkDestination(destination);
  messageSelector=checkSelector(messageSelector);
  JmsDestination dest=JmsMessageTransformation.transformDestination(connection,destination);
  JmsMessageConsumer result=new JmsMessageConsumer(getNextConsumerId(),this,dest,messageSelector,noLocal);
  result.init();
  return result;
}","/** 
 * @param destination
 * @param messageSelector
 * @param noLocal
 * @return the MessageConsumer
 * @throws JMSException
 * @see javax.jms.Session#createConsumer(javax.jms.Destination,java.lang.String,boolean)
 */
@Override public MessageConsumer createConsumer(Destination destination,String messageSelector,boolean noLocal) throws JMSException {
  checkClosed();
  checkDestination(destination);
  messageSelector=checkSelector(messageSelector);
  JmsDestination dest=JmsMessageTransformation.transformDestination(connection,destination);
  JmsMessageConsumer result=new JmsMessageConsumer(getNextConsumerId(),this,dest,messageSelector,noLocal);
  result.init();
  return result;
}"
41634,"/** 
 * Constructor
 * @param s
 * @param destination
 */
protected JmsTopicPublisher(JmsProducerId id,JmsSession session,JmsDestination destination) throws JMSException {
  super(id,session,destination);
}","/** 
 * Constructor
 * @param session
 * @param destination
 */
protected JmsTopicPublisher(JmsProducerId id,JmsSession session,JmsDestination destination) throws JMSException {
  super(id,session,destination);
}"
41635,"/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned if the property has a value and is available for a read operation. The Set returned may be manipulated by the receiver without impacting the facade, and an empty set will be returned if there are no matching properties.
 * @param message the JmsMessageFacade instance to read from
 * @param excludeStandardJMSHeaders whether the standard JMS header names should be excluded from the returned set
 * @return a Set<String> containing the names of all intercepted properties with a value.
 * @throws JMSException if an error occurs while gathering the message property names.
 */
public static Set<String> getPropertyNames(JmsMessageFacade message,boolean excludeStandardJMSHeaders) throws JMSException {
  Set<String> names=new HashSet<String>();
  for (  Entry<String,PropertyIntercepter> entry : PROPERTY_INTERCEPTERS.entrySet()) {
    if (excludeStandardJMSHeaders && STANDARD_HEADERS.contains(entry.getKey())) {
      continue;
    }
    if (entry.getValue().propertyExists(message)) {
      names.add(entry.getKey());
    }
  }
  names.addAll(message.getPropertyNames());
  return names;
}","/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned if the property has a value and is available for a read operation. The Set returned may be manipulated by the receiver without impacting the facade, and an empty set will be returned if there are no matching properties.
 * @param message the JmsMessageFacade instance to read from
 * @param excludeStandardJMSHeaders whether the standard JMS header names should be excluded from the returned set
 * @return a {@code Set<String>} containing the names of all intercepted properties with a value.
 * @throws JMSException if an error occurs while gathering the message property names.
 */
public static Set<String> getPropertyNames(JmsMessageFacade message,boolean excludeStandardJMSHeaders) throws JMSException {
  Set<String> names=new HashSet<String>();
  for (  Entry<String,PropertyIntercepter> entry : PROPERTY_INTERCEPTERS.entrySet()) {
    if (excludeStandardJMSHeaders && STANDARD_HEADERS.contains(entry.getKey())) {
      continue;
    }
    if (entry.getValue().propertyExists(message)) {
      names.add(entry.getKey());
    }
  }
  names.addAll(message.getPropertyNames());
  return names;
}"
41636,"/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned.
 * @param message the JmsMessageFacade instance to read property names from.
 * @return a Set<String> containing the names of all intercepted properties.
 * @throws JMSException if an error occurs while gathering the message property names.
 */
public static Set<String> getAllPropertyNames(JmsMessageFacade message) throws JMSException {
  Set<String> names=new HashSet<String>(PROPERTY_INTERCEPTERS.keySet());
  names.addAll(message.getPropertyNames());
  return names;
}","/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned.
 * @param message the JmsMessageFacade instance to read property names from.
 * @return a {@code Set<String>} containing the names of all intercepted properties.
 * @throws JMSException if an error occurs while gathering the message property names.
 */
public static Set<String> getAllPropertyNames(JmsMessageFacade message) throws JMSException {
  Set<String> names=new HashSet<String>(PROPERTY_INTERCEPTERS.keySet());
  names.addAll(message.getPropertyNames());
  return names;
}"
41637,"/** 
 * @param transport the transport type name to use when creating a new provider.
 */
public void setTransportType(String transportType){
  this.transportType=transportType;
}","/** 
 * @param transportType the transport type name to use when creating a new provider.
 */
public void setTransportType(String transportType){
  this.transportType=transportType;
}"
41638,"/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned if the property has a value and is available for a read operation. The Set returned may be manipulated by the receiver without impacting the facade, and an empty set will be returned if there are no matching properties.
 * @return a Set<String> containing the names of all intercepted properties with a value.
 */
public static Set<String> getPropertyNames(AmqpJmsMessageFacade message){
  Set<String> names=new HashSet<String>();
  for (  Entry<String,PropertyIntercepter> entry : PROPERTY_INTERCEPTERS.entrySet()) {
    if (entry.getValue().propertyExists(message)) {
      names.add(entry.getKey());
    }
  }
  return message.getApplicationPropertyNames(names);
}","/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned if the property has a value and is available for a read operation. The Set returned may be manipulated by the receiver without impacting the facade, and an empty set will be returned if there are no matching properties.
 * @return a {@code Set<String>} containing the names of all intercepted properties with a value.
 */
public static Set<String> getPropertyNames(AmqpJmsMessageFacade message){
  Set<String> names=new HashSet<String>();
  for (  Entry<String,PropertyIntercepter> entry : PROPERTY_INTERCEPTERS.entrySet()) {
    if (entry.getValue().propertyExists(message)) {
      names.add(entry.getKey());
    }
  }
  return message.getApplicationPropertyNames(names);
}"
41639,"/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned.
 * @return a Set<String> containing the names of all intercepted properties.
 */
public static Set<String> getAllPropertyNames(){
  return PROPERTY_INTERCEPTERS.keySet();
}","/** 
 * For each of the currently configured message property intercepter instance a string key value is inserted into an Set and returned.
 * @return a {@code Set<String>} containing the names of all intercepted properties.
 */
public static Set<String> getAllPropertyNames(){
  return PROPERTY_INTERCEPTERS.keySet();
}"
41640,"/** 
 * Sets the password value for this Mechanism.  The Mechanism can ignore this value if it does not utilize a password in it's authentication processing.
 * @param username The user name given.
 */
void setPassword(String value);","/** 
 * Sets the password value for this Mechanism.  The Mechanism can ignore this value if it does not utilize a password in it's authentication processing.
 * @param username The user name given.
 */
void setPassword(String username);"
41641,"/** 
 * Sets the user name value for this Mechanism.  The Mechanism can ignore this value if it does not utilize user name in it's authentication processing.
 * @param username The user name given.
 */
void setUsername(String value);","/** 
 * Sets the user name value for this Mechanism.  The Mechanism can ignore this value if it does not utilize user name in it's authentication processing.
 * @param username The user name given.
 */
void setUsername(String username);"
41642,"/** 
 * Encodes the value of string so that it looks like it would look like when it was provided in a selector.
 * @param string
 * @return the encoded String
 */
public static String encodeString(String s){
  StringBuffer b=new StringBuffer();
  b.append('\'');
  for (int i=0; i < s.length(); i++) {
    char c=s.charAt(i);
    if (c == '\'') {
      b.append(c);
    }
    b.append(c);
  }
  b.append('\'');
  return b.toString();
}","/** 
 * Encodes the value of string so that it looks like it would look like when it was provided in a selector.
 * @param s the original string
 * @return the encoded String
 */
public static String encodeString(String s){
  StringBuffer b=new StringBuffer();
  b.append('\'');
  for (int i=0; i < s.length(); i++) {
    char c=s.charAt(i);
    if (c == '\'') {
      b.append(c);
    }
    b.append(c);
  }
  b.append('\'');
  return b.toString();
}"
41643,"/** 
 * When using the   {@link java.net.InetAddress#getHostName()} method in anenvironment where neither a proper DNS lookup nor an <tt>/etc/hosts</tt> entry exists for a given host, the following exception will be thrown: <code> java.net.UnknownHostException: &lt;hostname&gt;: &lt;hostname&gt; at java.net.InetAddress.getLocalHost(InetAddress.java:1425) ... </code> Instead of just throwing an UnknownHostException and giving up, this method grabs a suitable hostname from the exception and prevents the exception from being thrown. If a suitable hostname cannot be acquired from the exception, only then is the <tt>UnknownHostException</tt> thrown.
 * @return The hostname
 * @throws UnknownHostException
 * @see {@link java.net.InetAddress#getLocalHost()}
 * @see {@link java.net.InetAddress#getHostName()}
 */
public static String getLocalHostName() throws UnknownHostException {
  try {
    return (InetAddress.getLocalHost()).getHostName();
  }
 catch (  UnknownHostException uhe) {
    String host=uhe.getMessage();
    if (host != null) {
      int colon=host.indexOf(':');
      if (colon > 0) {
        return host.substring(0,colon);
      }
    }
    throw uhe;
  }
}","/** 
 * When using the   {@link java.net.InetAddress#getHostName()} method in anenvironment where neither a proper DNS lookup nor an <tt>/etc/hosts</tt> entry exists for a given host, the following exception will be thrown: <code> java.net.UnknownHostException: &lt;hostname&gt;: &lt;hostname&gt; at java.net.InetAddress.getLocalHost(InetAddress.java:1425) ... </code> Instead of just throwing an UnknownHostException and giving up, this method grabs a suitable hostname from the exception and prevents the exception from being thrown. If a suitable hostname cannot be acquired from the exception, only then is the <tt>UnknownHostException</tt> thrown.
 * @return The hostname
 * @throws UnknownHostException
 * @see java.net.InetAddress#getLocalHost()
 * @see java.net.InetAddress#getHostName()
 */
public static String getLocalHostName() throws UnknownHostException {
  try {
    return (InetAddress.getLocalHost()).getHostName();
  }
 catch (  UnknownHostException uhe) {
    String host=uhe.getMessage();
    if (host != null) {
      int colon=host.indexOf(':');
      if (colon > 0) {
        return host.substring(0,colon);
      }
    }
    throw uhe;
  }
}"
41644,"/** 
 * Awaits the termination of the thread pool. <p/> This implementation will log every 2nd second at INFO level that we are waiting, so the end user can see we are not hanging in case it takes longer time to terminate the pool.
 * @param executorService the thread pool
 * @param shutdownAwaitTermination time in millis to use as timeout
 * @return <tt>true</tt> if the pool is terminated, or <tt>false</tt> if we timed out
 * @throws InterruptedException is thrown if we are interrupted during the waiting
 */
public static boolean awaitTermination(ExecutorService executorService,long shutdownAwaitTermination) throws InterruptedException {
  if (executorService == null) {
    return true;
  }
  StopWatch watch=new StopWatch();
  long interval=Math.min(2000,shutdownAwaitTermination);
  boolean done=false;
  while (!done && interval > 0) {
    if (executorService.awaitTermination(interval,TimeUnit.MILLISECONDS)) {
      done=true;
    }
 else {
      LOG.debug(""String_Node_Str"",TimeUtils.printDuration(watch.taken()),executorService);
      interval=Math.min(2000,shutdownAwaitTermination - watch.taken());
    }
  }
  return done;
}","/** 
 * Awaits the termination of the thread pool. <p> This implementation will log every 2nd second at INFO level that we are waiting, so the end user can see we are not hanging in case it takes longer time to terminate the pool.
 * @param executorService the thread pool
 * @param shutdownAwaitTermination time in millis to use as timeout
 * @return <tt>true</tt> if the pool is terminated, or <tt>false</tt> if we timed out
 * @throws InterruptedException is thrown if we are interrupted during the waiting
 */
public static boolean awaitTermination(ExecutorService executorService,long shutdownAwaitTermination) throws InterruptedException {
  if (executorService == null) {
    return true;
  }
  StopWatch watch=new StopWatch();
  long interval=Math.min(2000,shutdownAwaitTermination);
  boolean done=false;
  while (!done && interval > 0) {
    if (executorService.awaitTermination(interval,TimeUnit.MILLISECONDS)) {
      done=true;
    }
 else {
      LOG.debug(""String_Node_Str"",TimeUtils.printDuration(watch.taken()),executorService);
      interval=Math.min(2000,shutdownAwaitTermination - watch.taken());
    }
  }
  return done;
}"
41645,"/** 
 * Shutdown the given executor service graceful at first, and then aggressively if the await termination timeout was hit. <p/> Will try to perform an orderly shutdown by giving the running threads time to complete tasks, before going more aggressively by doing a  {@link #shutdownNow(java.util.concurrent.ExecutorService)} which forces a shutdown. Theparameter <tt>shutdownAwaitTermination</tt> is used as timeout value waiting for orderly shutdown to complete normally, before going aggressively.
 * @param executorService the executor service to shutdown
 * @param shutdownAwaitTermination timeout in millis to wait for orderly shutdown
 */
public static void shutdownGraceful(ExecutorService executorService,long shutdownAwaitTermination){
  doShutdown(executorService,shutdownAwaitTermination);
}","/** 
 * Shutdown the given executor service graceful at first, and then aggressively if the await termination timeout was hit. <p> Will try to perform an orderly shutdown by giving the running threads time to complete tasks, before going more aggressively by doing a  {@link #shutdownNow(java.util.concurrent.ExecutorService)} which forces a shutdown. Theparameter <tt>shutdownAwaitTermination</tt> is used as timeout value waiting for orderly shutdown to complete normally, before going aggressively.
 * @param executorService the executor service to shutdown
 * @param shutdownAwaitTermination timeout in millis to wait for orderly shutdown
 */
public static void shutdownGraceful(ExecutorService executorService,long shutdownAwaitTermination){
  doShutdown(executorService,shutdownAwaitTermination);
}"
41646,"/** 
 * Given a URI parse and extract any URI query options and return them as a Key / Value mapping. This method differs from the   {@link parseQuery} method in that it handles composite URItypes and will extract the URI options from the outermost composite URI.
 * @param uri The URI whose query should be extracted and processed.
 * @return A Mapping of the URI options.
 * @throws URISyntaxException
 */
public static Map<String,String> parseParameters(URI uri) throws URISyntaxException {
  if (!isCompositeURI(uri)) {
    if (uri.getQuery() == null) {
      return Collections.emptyMap();
    }
 else {
      try {
        return PropertyUtil.parseQuery(PropertyUtil.stripPrefix(uri.getQuery(),""String_Node_Str""));
      }
 catch (      Exception e) {
        throw new URISyntaxException(uri.toString(),e.getMessage());
      }
    }
  }
 else {
    CompositeData data=URISupport.parseComposite(uri);
    Map<String,String> parameters=new HashMap<String,String>();
    parameters.putAll(data.getParameters());
    if (parameters.isEmpty()) {
      parameters=Collections.emptyMap();
    }
    return parameters;
  }
}","/** 
 * Given a URI parse and extract any URI query options and return them as a Key / Value mapping. This method handles composite URI types and will extract the URI options from the outermost composite URI.
 * @param uri The URI whose query should be extracted and processed.
 * @return A Mapping of the URI options.
 * @throws URISyntaxException
 */
public static Map<String,String> parseParameters(URI uri) throws URISyntaxException {
  if (!isCompositeURI(uri)) {
    if (uri.getQuery() == null) {
      return Collections.emptyMap();
    }
 else {
      try {
        return PropertyUtil.parseQuery(PropertyUtil.stripPrefix(uri.getQuery(),""String_Node_Str""));
      }
 catch (      Exception e) {
        throw new URISyntaxException(uri.toString(),e.getMessage());
      }
    }
  }
 else {
    CompositeData data=URISupport.parseComposite(uri);
    Map<String,String> parameters=new HashMap<String,String>();
    parameters.putAll(data.getParameters());
    if (parameters.isEmpty()) {
      parameters=Collections.emptyMap();
    }
    return parameters;
  }
}"
41647,"/** 
 * @returns if the currently transaction has been marked as being failed.
 */
boolean isFailed();","/** 
 * @return if the currently transaction has been marked as being failed.
 */
boolean isFailed();"
41648,"/** 
 * Creates an instance of a basic JmsObjectMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @returns a newly created and initialized JmsObjectMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsObjectMessage createObjectMessage() throws JMSException ;","/** 
 * Creates an instance of a basic JmsObjectMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @return a newly created and initialized JmsObjectMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsObjectMessage createObjectMessage() throws JMSException ;"
41649,"/** 
 * Creates an instance of a basic JmsStreamMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @returns a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsStreamMessage createStreamMessage() throws JMSException ;","/** 
 * Creates an instance of a basic JmsStreamMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @return a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsStreamMessage createStreamMessage() throws JMSException ;"
41650,"/** 
 * Creates an instance of a basic JmsTextMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @returns a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsTextMessage createTextMessage() throws JMSException ;","/** 
 * Creates an instance of a basic JmsTextMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @return a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsTextMessage createTextMessage() throws JMSException ;"
41651,"/** 
 * Creates an instance of a basic JmsBytesMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @returns a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsBytesMessage createBytesMessage() throws JMSException ;","/** 
 * Creates an instance of a basic JmsBytesMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @return a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsBytesMessage createBytesMessage() throws JMSException ;"
41652,"/** 
 * Creates an instance of a basic JmsMapMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @returns a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsMapMessage createMapMessage() throws JMSException ;","/** 
 * Creates an instance of a basic JmsMapMessage object.  The provider may either create the Message with the default generic internal message implementation or create a Provider specific instance that optimizes the access and marshaling of the message.
 * @return a newly created and initialized JmsTextMessage instance.
 * @throws JMSException if the provider cannot create the message for some reason.
 */
JmsMapMessage createMapMessage() throws JMSException ;"
41653,"/** 
 * Performs a copy of this message facade into a new instance.  Calling this method results in a call to reset() prior to the message copy meaning any in use streams will be closed on return.
 * @returns a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 */
@Override JmsBytesMessageFacade copy() throws JMSException ;","/** 
 * Performs a copy of this message facade into a new instance.  Calling this method results in a call to reset() prior to the message copy meaning any in use streams will be closed on return.
 * @return a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 */
@Override JmsBytesMessageFacade copy() throws JMSException ;"
41654,"/** 
 * Determines whether an item exists in this Map based message.
 * @returns true if the item exists in the Map, false otherwise.
 */
boolean itemExists(String key);","/** 
 * Determines whether an item exists in this Map based message.
 * @return true if the item exists in the Map, false otherwise.
 */
boolean itemExists(String key);"
41655,"/** 
 * Gets the value stored in the Map at the specified key.
 * @param key the key to use to access a value in the Map.
 * @returns the item associated with the given key, or null if not present.
 */
Object get(String key);","/** 
 * Gets the value stored in the Map at the specified key.
 * @param key the key to use to access a value in the Map.
 * @return the item associated with the given key, or null if not present.
 */
Object get(String key);"
41656,"/** 
 * @returns a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 * @throws JMSException if an error occurs while copying this message.
 */
@Override JmsMapMessageFacade copy() throws JMSException ;","/** 
 * @return a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 * @throws JMSException if an error occurs while copying this message.
 */
@Override JmsMapMessageFacade copy() throws JMSException ;"
41657,"/** 
 * Remove the mapping for this key from the map if present.  If the value is not present in the map then this method should return without error or modification to the underlying map.
 * @param key the key to be removed from the map if present.
 * @returns the object previously stored in the Map or null if none present.
 */
Object remove(String key);","/** 
 * Remove the mapping for this key from the map if present.  If the value is not present in the map then this method should return without error or modification to the underlying map.
 * @param key the key to be removed from the map if present.
 * @return the object previously stored in the Map or null if none present.
 */
Object remove(String key);"
41658,"/** 
 * @returns true if the given property exists within the message.
 * @throws JMSException if an error occurs while accessing the Message properties.
 */
boolean propertyExists(String key) throws JMSException ;","/** 
 * @return true if the given property exists within the message.
 * @throws JMSException if an error occurs while accessing the Message properties.
 */
boolean propertyExists(String key) throws JMSException ;"
41659,"/** 
 * Used to quickly check if a message has been redelivered.
 * @returns true if the message was redelivered, false otherwise.
 */
boolean isRedelivered();","/** 
 * Used to quickly check if a message has been redelivered.
 * @return true if the message was redelivered, false otherwise.
 */
boolean isRedelivered();"
41660,"/** 
 * @returns a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 * @throws JMSException if an error occurs while copying this message.
 */
@Override JmsObjectMessageFacade copy() throws JMSException ;","/** 
 * @return a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 * @throws JMSException if an error occurs while copying this message.
 */
@Override JmsObjectMessageFacade copy() throws JMSException ;"
41661,"/** 
 * @returns true if the stream contains another element beyond the current.
 */
boolean hasNext();","/** 
 * @return true if the stream contains another element beyond the current.
 */
boolean hasNext();"
41662,"/** 
 * @returns a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 */
@Override JmsStreamMessageFacade copy() throws JMSException ;","/** 
 * @return a deep copy of this Message Facade including a complete copyof the byte contents of the wrapped message.
 */
@Override JmsStreamMessageFacade copy() throws JMSException ;"
41663,"/** 
 * Peek and return the next element in the stream.  If the stream has been fully read then this method should throw a MessageEOFException.  Multiple calls to peek should return the same element.
 * @returns the next value in the stream without removing it.
 * @throws MessageEOFException if end of message stream has been reached.
 */
Object peek() throws MessageEOFException ;","/** 
 * Peek and return the next element in the stream.  If the stream has been fully read then this method should throw a MessageEOFException.  Multiple calls to peek should return the same element.
 * @return the next value in the stream without removing it.
 * @throws MessageEOFException if end of message stream has been reached.
 */
Object peek() throws MessageEOFException ;"
41664,"/** 
 * Creates a copy of this JmsTextMessageFacade and its underlying provider message instance.
 * @returns a new JmsTextMessageFacade that wraps a duplicate message.
 */
@Override JmsTextMessageFacade copy() throws JMSException ;","/** 
 * Creates a copy of this JmsTextMessageFacade and its underlying provider message instance.
 * @return a new JmsTextMessageFacade that wraps a duplicate message.
 */
@Override JmsTextMessageFacade copy() throws JMSException ;"
41665,"/** 
 * Gets the Provider specific Message factory for use in the JMS layer when a Session is asked to create a Message type.  The Provider should implement it's own internal JmsMessage core to optimize read / write and marshal operations for the connection.
 * @returns a JmsMessageFactory instance for use by the JMS layer.
 */
JmsMessageFactory getMessageFactory();","/** 
 * Gets the Provider specific Message factory for use in the JMS layer when a Session is asked to create a Message type.  The Provider should implement it's own internal JmsMessage core to optimize read / write and marshal operations for the connection.
 * @return a JmsMessageFactory instance for use by the JMS layer.
 */
JmsMessageFactory getMessageFactory();"
41666,"/** 
 * Sends the given message
 * @param envelope The envelope that contains the message and it's targeted destination.
 * @param request The AsyncRequest that will be notified on send success or failure.
 * @returns true if the producer had credit to send or false if there was no availablecredit and the send needed to be deferred.
 * @throws IOException if an error occurs sending the message
 * @throws JMSException if an error occurs while preparing the message for send.
 */
public abstract boolean send(JmsOutboundMessageDispatch envelope,AsyncResult request) throws IOException, JMSException ;","/** 
 * Sends the given message
 * @param envelope The envelope that contains the message and it's targeted destination.
 * @param request The AsyncRequest that will be notified on send success or failure.
 * @return true if the producer had credit to send or false if there was no availablecredit and the send needed to be deferred.
 * @throws IOException if an error occurs sending the message
 * @throws JMSException if an error occurs while preparing the message for send.
 */
public abstract boolean send(JmsOutboundMessageDispatch envelope,AsyncResult request) throws IOException, JMSException ;"
41667,"/** 
 * @returns true if the remote end has sent an error
 */
boolean hasRemoteError();","/** 
 * @return true if the remote end has sent an error
 */
boolean hasRemoteError();"
41668,"/** 
 * @returns the current size of the URI pool.
 */
public int size(){
  return uris.size();
}","/** 
 * @return the current size of the URI pool.
 */
public int size(){
  return uris.size();
}"
41669,"/** 
 * @returns true if the URI pool is empty.
 */
public boolean isEmpty(){
  return uris.isEmpty();
}","/** 
 * @return true if the URI pool is empty.
 */
public boolean isEmpty(){
  return uris.isEmpty();
}"
41670,"/** 
 * Gets the currently set TransportListener instance
 * @returns the current TransportListener or null if none set.
 */
TransportListener getTransportListener();","/** 
 * Gets the currently set TransportListener instance
 * @return the current TransportListener or null if none set.
 */
TransportListener getTransportListener();"
41671,"/** 
 * @returns the URI of the remote peer that this Transport connects to.
 */
URI getRemoteLocation();","/** 
 * @return the URI of the remote peer that this Transport connects to.
 */
URI getRemoteLocation();"
41672,"/** 
 * @returns the TransportOptions instance that holds the configuration for this Transport.
 */
TransportOptions getTransportOptions();","/** 
 * @return the TransportOptions instance that holds the configuration for this Transport.
 */
TransportOptions getTransportOptions();"
41673,"@Test(timeout=10000,expected=UnsupportedOperationException.class) public void testSetDesinationOnAnonymousProducer() throws Exception {
  JmsMessageProducer producer=(JmsMessageProducer)session.createProducer(null);
  producer.setDestination(topic);
}","@Test(timeout=10000) public void testSetDesinationOnAnonymousProducer() throws Exception {
  JmsMessageProducer producer=(JmsMessageProducer)session.createProducer(null);
  producer.setDestination(topic);
}"
41674,"/** 
 * Sets the prefix used by auto-generated JMS Client ID values which are used if the JMS client does not explicitly specify on.
 * @param clientIDPrefix
 */
public synchronized void setClientIDPrefix(String clientIDPrefix){
  this.clientIDPrefix=clientIDPrefix;
}","/** 
 * Sets the prefix used by auto-generated JMS Client ID values which are used if the JMS client does not explicitly specify one.
 * @param clientIDPrefix the value to use as a prefix on auto-generated client IDs.
 */
public synchronized void setClientIDPrefix(String clientIDPrefix){
  this.clientIDPrefix=clientIDPrefix;
}"
41675,"public synchronized String getClientIDPrefix(){
  return clientIDPrefix;
}","/** 
 * @return the currently configured client ID prefix for auto-generated client IDs.
 */
public synchronized String getClientIDPrefix(){
  return clientIDPrefix;
}"
41676,"protected void readMessagesOnBroker(int count) throws Exception {
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Queue queue=session.createQueue(getDestinationName());
  MessageConsumer consumer=session.createConsumer(queue);
  for (int i=0; i < MESSAGE_COUNT; ++i) {
    Message message=consumer.receive(RECEIVE_TIMEOUT);
    assertNotNull(message);
    LOG.info(""String_Node_Str"",i,message.getClass().getSimpleName());
    String gid=message.getStringProperty(""String_Node_Str"");
    String seq=message.getStringProperty(""String_Node_Str"");
    LOG.info(""String_Node_Str"",gid);
    LOG.info(""String_Node_Str"",seq);
  }
}","protected void readMessagesOnBroker(int count) throws Exception {
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Queue queue=session.createQueue(getDestinationName());
  MessageConsumer consumer=session.createConsumer(queue);
  for (int i=0; i < MESSAGE_COUNT; ++i) {
    Message message=consumer.receive(RECEIVE_TIMEOUT);
    assertNotNull(message);
    LOG.info(""String_Node_Str"",i,message.getClass().getSimpleName());
    String gid=message.getStringProperty(""String_Node_Str"");
    String seq=message.getStringProperty(""String_Node_Str"");
    LOG.info(""String_Node_Str"",gid);
    LOG.info(""String_Node_Str"",seq);
  }
  consumer.close();
}"
41677,"protected void sendMessagesToBroker(int count) throws Exception {
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Queue queue=session.createQueue(getDestinationName());
  MessageProducer producer=session.createProducer(queue);
  byte[] buffer=new byte[MESSAGE_SIZE];
  for (count=0; count < MESSAGE_SIZE; count++) {
    String s=String.valueOf(count % 10);
    Character c=s.charAt(0);
    int value=c.charValue();
    buffer[count]=(byte)value;
  }
  LOG.debug(""String_Node_Str"",MESSAGE_COUNT,queue);
  for (int i=1; i <= MESSAGE_COUNT; i++) {
    BytesMessage message=session.createBytesMessage();
    message.setJMSDeliveryMode(DeliveryMode.PERSISTENT);
    message.setStringProperty(""String_Node_Str"",JMSX_GROUP_ID);
    message.setIntProperty(""String_Node_Str"",i);
    message.writeBytes(buffer);
    producer.send(message);
  }
  producer.close();
}","protected void sendMessagesToBroker(int count) throws Exception {
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Queue queue=session.createQueue(getDestinationName());
  MessageProducer producer=session.createProducer(queue);
  byte[] buffer=new byte[MESSAGE_SIZE];
  for (count=0; count < MESSAGE_SIZE; count++) {
    String s=String.valueOf(count % 10);
    Character c=s.charAt(0);
    int value=c.charValue();
    buffer[count]=(byte)value;
  }
  LOG.debug(""String_Node_Str"",MESSAGE_COUNT,queue);
  for (int i=1; i <= MESSAGE_COUNT; i++) {
    BytesMessage message=session.createBytesMessage();
    message.setJMSDeliveryMode(DeliveryMode.PERSISTENT);
    message.setStringProperty(""String_Node_Str"",JMSX_GROUP_ID);
    message.setIntProperty(""String_Node_Str"",++sequenceCount);
    message.writeBytes(buffer);
    producer.send(message);
  }
  producer.close();
}"
41678,"@Test public void testGroupSeqIsNeverLost() throws Exception {
  connection=createAmqpConnection();
  sendMessagesToBroker(MESSAGE_COUNT);
  readMessagesOnBroker(MESSAGE_COUNT);
  sendMessagesToBroker(MESSAGE_COUNT);
  readMessagesOnBroker(MESSAGE_COUNT);
}","@Test public void testGroupSeqIsNeverLost() throws Exception {
  connection=createAmqpConnection();
  connection.start();
  sendMessagesToBroker(MESSAGE_COUNT);
  readMessagesOnBroker(MESSAGE_COUNT);
  sendMessagesToBroker(MESSAGE_COUNT);
  readMessagesOnBroker(MESSAGE_COUNT);
}"
41679,"@Override public void onMessage(Message message){
  try {
    int msgNumProperty=message.getIntProperty(MESSAGE_NUMBER);
    if (complete) {
      LOG.info(""String_Node_Str"" + msgNumProperty);
      return;
    }
    if (msgNumProperty == 1) {
      if (!seenFirstMessage) {
        LOG.info(""String_Node_Str"");
        seenFirstMessage=true;
      }
 else {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
    }
 else     if (msgNumProperty == 2) {
      if (!seenSecondMessage) {
        seenSecondMessage=true;
        LOG.info(""String_Node_Str"");
        session.recover();
      }
 else {
        LOG.info(""String_Node_Str"");
        seenSecondMessageTwice=true;
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
      }
    }
 else {
      if (msgNumProperty != 3) {
        LOG.error(""String_Node_Str"" + msgNumProperty);
        complete(true);
      }
      if (!seenFirstMessage && !seenSecondMessageTwice) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
      if (message.getJMSRedelivered()) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
 else {
        LOG.info(""String_Node_Str"");
        complete(false);
      }
    }
  }
 catch (  JMSException e) {
    LOG.error(""String_Node_Str"",e);
    complete(true);
  }
}","@Override public void onMessage(Message message){
  try {
    int msgNumProperty=message.getIntProperty(MESSAGE_NUMBER);
    if (complete) {
      LOG.info(""String_Node_Str"" + msgNumProperty);
      return;
    }
    if (msgNumProperty == 1) {
      if (!seenFirstMessage) {
        LOG.info(""String_Node_Str"");
        seenFirstMessage=true;
      }
 else {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
    }
 else     if (msgNumProperty == 2) {
      if (!seenSecondMessage) {
        seenSecondMessage=true;
        LOG.info(""String_Node_Str"");
        session.recover();
      }
 else {
        LOG.info(""String_Node_Str"");
        seenSecondMessageTwice=true;
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
      }
    }
 else {
      if (msgNumProperty != 3) {
        LOG.error(""String_Node_Str"" + msgNumProperty);
        complete(true);
        return;
      }
      if (!(seenFirstMessage && seenSecondMessageTwice)) {
        LOG.error(""String_Node_Str"");
        complete(true);
        return;
      }
      LOG.info(""String_Node_Str"");
      if (message.getJMSRedelivered()) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
 else {
        LOG.info(""String_Node_Str"");
        complete(false);
      }
    }
  }
 catch (  JMSException e) {
    LOG.error(""String_Node_Str"",e);
    complete(true);
  }
}"
41680,"/** 
 * Test use of session recovery while using a client-ack session and a message listener. Calling recover should result in delivery of the previous messages again, followed by those that would have been received afterwards. Send three messages. Consume the first message, then recover on the second message and expect to see both again, ensure the third message is not seen until after this.
 * @throws Exception
 */
@Test(timeout=60000) public void testRecoverInOnMessage() throws Exception {
  connection=createAmqpConnection();
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  assertNotNull(session);
  Queue queue=session.createQueue(name.getMethodName());
  MessageConsumer consumer=session.createConsumer(queue);
  sendMessages(connection,queue,3);
  CountDownLatch latch=new CountDownLatch(1);
  ClientAckRecoverMsgListener listener=new ClientAckRecoverMsgListener(latch,session);
  consumer.setMessageListener(listener);
  connection.start();
  assertTrue(""String_Node_Str"",latch.await(10,TimeUnit.SECONDS));
  assertFalse(""String_Node_Str"",listener.getFailed());
}","/** 
 * Test use of session recovery while using a client-ack session and a message listener. Calling recover should result in delivery of the previous messages again, followed by those that would have been received afterwards. Send three messages. Consume the first message, then recover on the second message and expect to see both again, ensure the third message is not seen until after this.
 * @throws Exception
 */
@Test(timeout=60000) public void testRecoverInOnMessage() throws Exception {
  connection=createAmqpConnection();
  Session session=connection.createSession(false,Session.CLIENT_ACKNOWLEDGE);
  assertNotNull(session);
  Queue queue=session.createQueue(name.getMethodName());
  MessageConsumer consumer=session.createConsumer(queue);
  sendMessages(connection,queue,3);
  CountDownLatch latch=new CountDownLatch(1);
  ClientAckRecoverMsgListener listener=new ClientAckRecoverMsgListener(latch,session);
  consumer.setMessageListener(listener);
  connection.start();
  assertTrue(""String_Node_Str"",latch.await(10,TimeUnit.SECONDS));
  assertFalse(""String_Node_Str"",listener.getFailed());
}"
41681,"@Override public void onMessage(Message message){
  try {
    int msgNumProperty=message.getIntProperty(MESSAGE_NUMBER);
    if (complete) {
      LOG.info(""String_Node_Str"" + msgNumProperty);
      return;
    }
    if (msgNumProperty == 1) {
      if (!seenFirstMessage) {
        LOG.info(""String_Node_Str"");
        seenFirstMessage=true;
      }
 else {
        LOG.info(""String_Node_Str"");
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
        seenFirstMessageTwice=true;
      }
    }
 else     if (msgNumProperty == 2) {
      if (!seenSecondMessage) {
        seenSecondMessage=true;
        LOG.info(""String_Node_Str"");
        session.recover();
      }
 else {
        LOG.info(""String_Node_Str"");
        seenSecondMessageTwice=true;
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
      }
    }
 else {
      if (msgNumProperty != 3) {
        LOG.error(""String_Node_Str"" + msgNumProperty);
        complete(true);
      }
      if (!seenFirstMessageTwice && !seenSecondMessageTwice) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
      if (message.getJMSRedelivered()) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
 else {
        LOG.info(""String_Node_Str"");
        complete(false);
      }
    }
  }
 catch (  JMSException e) {
    LOG.error(""String_Node_Str"",e);
    complete(true);
  }
}","@Override public void onMessage(Message message){
  try {
    int msgNumProperty=message.getIntProperty(MESSAGE_NUMBER);
    if (complete) {
      LOG.info(""String_Node_Str"" + msgNumProperty);
      return;
    }
    if (msgNumProperty == 1) {
      if (!seenFirstMessage) {
        LOG.info(""String_Node_Str"");
        seenFirstMessage=true;
      }
 else {
        LOG.info(""String_Node_Str"");
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
        seenFirstMessageTwice=true;
      }
    }
 else     if (msgNumProperty == 2) {
      if (!seenSecondMessage) {
        seenSecondMessage=true;
        LOG.info(""String_Node_Str"");
        session.recover();
      }
 else {
        if (!seenFirstMessageTwice) {
          LOG.error(""String_Node_Str"");
          complete(true);
          return;
        }
        LOG.info(""String_Node_Str"");
        seenSecondMessageTwice=true;
        if (message.getJMSRedelivered()) {
          LOG.info(""String_Node_Str"");
        }
 else {
          LOG.error(""String_Node_Str"");
          complete(true);
        }
      }
    }
 else {
      if (msgNumProperty != 3) {
        LOG.error(""String_Node_Str"" + msgNumProperty);
        complete(true);
        return;
      }
      if (!(seenFirstMessageTwice && seenSecondMessageTwice)) {
        LOG.error(""String_Node_Str"");
        complete(true);
        return;
      }
      if (message.getJMSRedelivered()) {
        LOG.error(""String_Node_Str"");
        complete(true);
      }
 else {
        LOG.info(""String_Node_Str"");
        complete(false);
      }
    }
  }
 catch (  JMSException e) {
    LOG.error(""String_Node_Str"",e);
    complete(true);
  }
}"
41682,"@Test(timeout=600000) public void testRecoverInOnMessage() throws Exception {
  connection=createAmqpConnection();
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  assertNotNull(session);
  Queue queue=session.createQueue(name.getMethodName());
  MessageConsumer consumer=session.createConsumer(queue);
  sendMessages(connection,queue,2);
  CountDownLatch latch=new CountDownLatch(1);
  AutoAckRecoverMsgListener listener=new AutoAckRecoverMsgListener(latch,session);
  consumer.setMessageListener(listener);
  connection.start();
  assertTrue(""String_Node_Str"",latch.await(500,TimeUnit.SECONDS));
  assertFalse(""String_Node_Str"",listener.getFailed());
}","@Test(timeout=60000) public void testRecoverInOnMessage() throws Exception {
  connection=createAmqpConnection();
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  assertNotNull(session);
  Queue queue=session.createQueue(name.getMethodName());
  MessageConsumer consumer=session.createConsumer(queue);
  sendMessages(connection,queue,2);
  CountDownLatch latch=new CountDownLatch(1);
  AutoAckRecoverMsgListener listener=new AutoAckRecoverMsgListener(latch,session);
  consumer.setMessageListener(listener);
  connection.start();
  assertTrue(""String_Node_Str"",latch.await(10,TimeUnit.SECONDS));
  assertFalse(""String_Node_Str"",listener.getFailed());
}"
41683,"/** 
 * @param queue
 * @return QueueSender
 * @throws JMSException
 * @see javax.jms.QueueSession#createSender(javax.jms.Queue)
 */
@Override public QueueSender createSender(Queue queue) throws JMSException {
  checkClosed();
  JmsDestination dest=JmsMessageTransformation.transformDestination(connection,queue);
  JmsQueueSender result=new JmsQueueSender(getNextProducerId(),this,dest);
  return result;
}","/** 
 * @param queue
 * @return QueueSender
 * @throws JMSException
 * @see javax.jms.QueueSession#createSender(javax.jms.Queue)
 */
@Override public QueueSender createSender(Queue queue) throws JMSException {
  checkClosed();
  JmsDestination dest=JmsMessageTransformation.transformDestination(connection,queue);
  JmsQueueSender result=new JmsQueueSender(getNextProducerId(),this,dest);
  add(result);
  return result;
}"
41684,"/** 
 * Searches for a MechanismFactory by using the scheme from the given name. The search first checks the local cache of mechanism factories before moving on to search in the classpath.
 * @param name The name of the authentication mechanism to search for..
 * @return a mechanism factory instance matching the URI's scheme.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static MechanismFactory findMechanismFactory(String name) throws IOException {
  if (name == null || name.isEmpty()) {
    throw new IOException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  MechanismFactory factory=null;
  try {
    factory=MECHANISM_FACTORY_FINDER.newInstance(name);
  }
 catch (  Throwable e) {
    throw new IOException(""String_Node_Str"" + name + ""String_Node_Str"",e);
  }
  return factory;
}","/** 
 * Searches for a MechanismFactory by using the scheme from the given name. The search first checks the local cache of mechanism factories before moving on to search in the classpath.
 * @param name The name of the authentication mechanism to search for..
 * @return a mechanism factory instance matching the URI's scheme.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static MechanismFactory findMechanismFactory(String name) throws IOException {
  if (name == null || name.isEmpty()) {
    throw new IOException(""String_Node_Str"");
  }
  MechanismFactory factory=null;
  try {
    factory=MECHANISM_FACTORY_FINDER.newInstance(name);
  }
 catch (  Throwable e) {
    throw new IOException(""String_Node_Str"" + name + ""String_Node_Str"",e);
  }
  return factory;
}"
41685,"/** 
 * Searches for a DiscoveryAgentFactory by using the scheme from the given URI. The search first checks the local cache of discovery agent factories before moving on to search in the classpath.
 * @param location The URI whose scheme will be used to locate a DiscoveryAgentFactory.
 * @return a DiscoveryAgentFactory instance matching the URI's scheme.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static DiscoveryAgentFactory findAgentFactory(URI location) throws IOException {
  String scheme=location.getScheme();
  if (scheme == null) {
    throw new IOException(""String_Node_Str"" + location + ""String_Node_Str"");
  }
  DiscoveryAgentFactory factory=null;
  if (factory == null) {
    try {
      factory=AGENT_FACTORY_FINDER.newInstance(scheme);
    }
 catch (    Throwable e) {
      throw new IOException(""String_Node_Str"" + scheme + ""String_Node_Str"",e);
    }
  }
  return factory;
}","/** 
 * Searches for a DiscoveryAgentFactory by using the scheme from the given URI. The search first checks the local cache of discovery agent factories before moving on to search in the classpath.
 * @param location The URI whose scheme will be used to locate a DiscoveryAgentFactory.
 * @return a DiscoveryAgentFactory instance matching the URI's scheme.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static DiscoveryAgentFactory findAgentFactory(URI location) throws IOException {
  String scheme=location.getScheme();
  if (scheme == null || scheme.isEmpty()) {
    throw new IOException(""String_Node_Str"");
  }
  DiscoveryAgentFactory factory=null;
  if (factory == null) {
    try {
      factory=AGENT_FACTORY_FINDER.newInstance(scheme);
    }
 catch (    Throwable e) {
      throw new IOException(""String_Node_Str"" + scheme + ""String_Node_Str"",e);
    }
  }
  return factory;
}"
41686,"@Test(timeout=5000) public void testSendBasicBytesMessageWithContent() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    byte[] content=""String_Node_Str"".getBytes();
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propertiesMatcher=new MessagePropertiesSectionMatcher(true);
    propertiesMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propertiesMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(new Binary(content)));
    testPeer.expectTransfer(messageMatcher);
    BytesMessage message=session.createBytesMessage();
    message.writeBytes(content);
    producer.send(message);
  }
 }","@Test(timeout=5000) public void testSendBasicBytesMessageWithContent() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    byte[] content=""String_Node_Str"".getBytes();
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propertiesMatcher=new MessagePropertiesSectionMatcher(true);
    propertiesMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propertiesMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(new Binary(content)));
    testPeer.expectTransfer(messageMatcher);
    BytesMessage message=session.createBytesMessage();
    message.writeBytes(content);
    producer.send(message);
  }
 }"
41687,"@Test(timeout=5000) public void testReceiveBasicBytesMessageWithContentUsingDataSection() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType properties=new PropertiesDescribedType();
    properties.setContentType(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE));
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_BYTES_MESSAGE);
    final byte[] expectedContent=""String_Node_Str"".getBytes();
    DescribedType dataContent=new DataDescribedType(new Binary(expectedContent));
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,properties,null,dataContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertTrue(receivedMessage instanceof BytesMessage);
    BytesMessage bytesMessage=(BytesMessage)receivedMessage;
    assertEquals(expectedContent.length,bytesMessage.getBodyLength());
    byte[] recievedContent=new byte[expectedContent.length];
    int readBytes=bytesMessage.readBytes(recievedContent);
    assertEquals(recievedContent.length,readBytes);
    assertTrue(Arrays.equals(expectedContent,recievedContent));
  }
 }","@Test(timeout=5000) public void testReceiveBasicBytesMessageWithContentUsingDataSection() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType properties=new PropertiesDescribedType();
    properties.setContentType(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE));
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_BYTES_MESSAGE);
    final byte[] expectedContent=""String_Node_Str"".getBytes();
    DescribedType dataContent=new DataDescribedType(new Binary(expectedContent));
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,properties,null,dataContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertTrue(receivedMessage instanceof BytesMessage);
    BytesMessage bytesMessage=(BytesMessage)receivedMessage;
    assertEquals(expectedContent.length,bytesMessage.getBodyLength());
    byte[] recievedContent=new byte[expectedContent.length];
    int readBytes=bytesMessage.readBytes(recievedContent);
    assertEquals(recievedContent.length,readBytes);
    assertTrue(Arrays.equals(expectedContent,recievedContent));
  }
 }"
41688,"/** 
 * Test that a message received from the test peer with an AmqpValue section containing Binary and no content type is returned as a BytesMessage, verify it gives the expected data values when read, and when sent to the test peer it results in an AMQP message containing a data body section and content type of  {@link AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE}
 */
@Test(timeout=5000) public void testReceiveBytesMessageWithAmqpValueAndResendResultsInData() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","/** 
 * Test that a message received from the test peer with an AmqpValue section containing Binary and no content type is returned as a BytesMessage, verify it gives the expected data values when read, and when sent to the test peer it results in an AMQP message containing a data body section and content type of  {@link AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE}
 */
@Test(timeout=5000) public void testReceiveBytesMessageWithAmqpValueAndResendResultsInData() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41689,"/** 
 * Test that a message received from the test peer with a Data section and content type of  {@link AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE} is returned as a BytesMessage, verify itgives the expected data values when read, and when reset and left mid-stream before being resent that it results in the expected AMQP data body section and properties content type being received by the test peer.
 */
@Test(timeout=5000) public void testReceiveBytesMessageAndResendAfterResetAndPartialRead() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType properties=new PropertiesDescribedType();
    Symbol contentType=Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE);
    properties.setContentType(contentType);
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_BYTES_MESSAGE);
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType dataSectionContent=new DataDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,properties,null,dataSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(contentType));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","/** 
 * Test that a message received from the test peer with a Data section and content type of  {@link AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE} is returned as a BytesMessage, verify itgives the expected data values when read, and when reset and left mid-stream before being resent that it results in the expected AMQP data body section and properties content type being received by the test peer.
 */
@Test(timeout=5000) public void testReceiveBytesMessageAndResendAfterResetAndPartialRead() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType properties=new PropertiesDescribedType();
    Symbol contentType=Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE);
    properties.setContentType(contentType);
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_BYTES_MESSAGE);
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType dataSectionContent=new DataDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,properties,null,dataSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(contentType));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41690,"@Test(timeout=10000) public void testCreateAndCloseConnection() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectClose();
    connection.close();
  }
 }","@Test(timeout=10000) public void testCreateAndCloseConnection() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectClose();
    connection.close();
  }
 }"
41691,"@Test(timeout=5000) public void testCreateTransactedSession() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    CoordinatorMatcher txCoordinatorMatcher=new CoordinatorMatcher();
    txCoordinatorMatcher.withCapabilities(arrayContaining(TxnCapability.LOCAL_TXN));
    testPeer.expectSenderAttach(txCoordinatorMatcher,false,false);
    Session session=connection.createSession(true,Session.SESSION_TRANSACTED);
    assertNotNull(""String_Node_Str"",session);
  }
 }","@Test(timeout=5000) public void testCreateTransactedSession() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    CoordinatorMatcher txCoordinatorMatcher=new CoordinatorMatcher();
    txCoordinatorMatcher.withCapabilities(arrayContaining(TxnCapability.LOCAL_TXN));
    testPeer.expectSenderAttach(txCoordinatorMatcher,false,false);
    Session session=connection.createSession(true,Session.SESSION_TRANSACTED);
    assertNotNull(""String_Node_Str"",session);
  }
 }"
41692,"@Test(timeout=5000) public void testConnectionMetaDataVersion() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    ConnectionMetaData meta=connection.getMetaData();
    assertTrue(""String_Node_Str"",meta.getProviderMajorVersion() != 0);
  }
 }","@Test(timeout=5000) public void testConnectionMetaDataVersion() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    ConnectionMetaData meta=connection.getMetaData();
    assertTrue(""String_Node_Str"",meta.getProviderMajorVersion() != 0);
  }
 }"
41693,"@Test(timeout=10000) public void testCreateAutoAckSession() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    assertNotNull(""String_Node_Str"",session);
  }
 }","@Test(timeout=10000) public void testCreateAutoAckSession() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    assertNotNull(""String_Node_Str"",session);
  }
 }"
41694,"Connection establishConnecton(TestAmqpPeer testPeer,String optionsString,Symbol[] serverCapabilities,Map<Symbol,Object> serverProperties) throws JMSException {
  testPeer.expectPlainConnect(""String_Node_Str"",""String_Node_Str"",serverCapabilities,serverProperties);
  testPeer.expectBegin(true);
  final String baseURI=""String_Node_Str"" + PORT;
  String brokerURI=baseURI;
  if (optionsString != null) {
    brokerURI=baseURI + optionsString;
  }
  ConnectionFactory factory=new JmsConnectionFactory(brokerURI);
  Connection connection=factory.createConnection(""String_Node_Str"",""String_Node_Str"");
  connection.setClientID(""String_Node_Str"");
  assertNull(testPeer.getThrowable());
  return connection;
}","Connection establishConnecton(TestAmqpPeer testPeer,String optionsString,Symbol[] serverCapabilities,Map<Symbol,Object> serverProperties) throws JMSException {
  testPeer.expectPlainConnect(""String_Node_Str"",""String_Node_Str"",serverCapabilities,serverProperties);
  testPeer.expectBegin(true);
  final String baseURI=""String_Node_Str"" + getAvailablePort();
  String brokerURI=baseURI;
  if (optionsString != null) {
    brokerURI=baseURI + optionsString;
  }
  ConnectionFactory factory=new JmsConnectionFactory(brokerURI);
  Connection connection=factory.createConnection(""String_Node_Str"",""String_Node_Str"");
  connection.setClientID(""String_Node_Str"");
  assertNull(testPeer.getThrowable());
  return connection;
}"
41695,"@Test(timeout=5000) public void testSendBasicMapMessage() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    String myBoolKey=""String_Node_Str"";
    boolean myBool=true;
    String myByteKey=""String_Node_Str"";
    byte myByte=4;
    String myBytesKey=""String_Node_Str"";
    byte[] myBytes=myBytesKey.getBytes();
    String myCharKey=""String_Node_Str"";
    char myChar='d';
    String myDoubleKey=""String_Node_Str"";
    double myDouble=1234567890123456789.1234;
    String myFloatKey=""String_Node_Str"";
    float myFloat=1.1F;
    String myIntKey=""String_Node_Str"";
    int myInt=Integer.MAX_VALUE;
    String myLongKey=""String_Node_Str"";
    long myLong=Long.MAX_VALUE;
    String myShortKey=""String_Node_Str"";
    short myShort=25;
    String myStringKey=""String_Node_Str"";
    String myString=myStringKey;
    MapMessage mapMessage=session.createMapMessage();
    mapMessage.setBoolean(myBoolKey,myBool);
    mapMessage.setByte(myByteKey,myByte);
    mapMessage.setBytes(myBytesKey,myBytes);
    mapMessage.setChar(myCharKey,myChar);
    mapMessage.setDouble(myDoubleKey,myDouble);
    mapMessage.setFloat(myFloatKey,myFloat);
    mapMessage.setInt(myIntKey,myInt);
    mapMessage.setLong(myLongKey,myLong);
    mapMessage.setShort(myShortKey,myShort);
    mapMessage.setString(myStringKey,myString);
    Map<String,Object> map=new LinkedHashMap<String,Object>();
    map.put(myBoolKey,myBool);
    map.put(myByteKey,myByte);
    map.put(myBytesKey,new Binary(myBytes));
    map.put(myCharKey,(int)myChar);
    map.put(myDoubleKey,myDouble);
    map.put(myFloatKey,myFloat);
    map.put(myIntKey,myInt);
    map.put(myLongKey,myLong);
    map.put(myShortKey,myShort);
    map.put(myStringKey,myString);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_MAP_MESSAGE));
    MessagePropertiesSectionMatcher propertiesMatcher=new MessagePropertiesSectionMatcher(true);
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propertiesMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(map));
    testPeer.expectTransfer(messageMatcher);
    producer.send(mapMessage);
  }
 }","@Test(timeout=5000) public void testSendBasicMapMessage() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageProducer producer=session.createProducer(queue);
    String myBoolKey=""String_Node_Str"";
    boolean myBool=true;
    String myByteKey=""String_Node_Str"";
    byte myByte=4;
    String myBytesKey=""String_Node_Str"";
    byte[] myBytes=myBytesKey.getBytes();
    String myCharKey=""String_Node_Str"";
    char myChar='d';
    String myDoubleKey=""String_Node_Str"";
    double myDouble=1234567890123456789.1234;
    String myFloatKey=""String_Node_Str"";
    float myFloat=1.1F;
    String myIntKey=""String_Node_Str"";
    int myInt=Integer.MAX_VALUE;
    String myLongKey=""String_Node_Str"";
    long myLong=Long.MAX_VALUE;
    String myShortKey=""String_Node_Str"";
    short myShort=25;
    String myStringKey=""String_Node_Str"";
    String myString=myStringKey;
    MapMessage mapMessage=session.createMapMessage();
    mapMessage.setBoolean(myBoolKey,myBool);
    mapMessage.setByte(myByteKey,myByte);
    mapMessage.setBytes(myBytesKey,myBytes);
    mapMessage.setChar(myCharKey,myChar);
    mapMessage.setDouble(myDoubleKey,myDouble);
    mapMessage.setFloat(myFloatKey,myFloat);
    mapMessage.setInt(myIntKey,myInt);
    mapMessage.setLong(myLongKey,myLong);
    mapMessage.setShort(myShortKey,myShort);
    mapMessage.setString(myStringKey,myString);
    Map<String,Object> map=new LinkedHashMap<String,Object>();
    map.put(myBoolKey,myBool);
    map.put(myByteKey,myByte);
    map.put(myBytesKey,new Binary(myBytes));
    map.put(myCharKey,(int)myChar);
    map.put(myDoubleKey,myDouble);
    map.put(myFloatKey,myFloat);
    map.put(myIntKey,myInt);
    map.put(myLongKey,myLong);
    map.put(myShortKey,myShort);
    map.put(myStringKey,myString);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_MAP_MESSAGE));
    MessagePropertiesSectionMatcher propertiesMatcher=new MessagePropertiesSectionMatcher(true);
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propertiesMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(map));
    testPeer.expectTransfer(messageMatcher);
    producer.send(mapMessage);
  }
 }"
41696,"/** 
 * Test that a message received from the test peer with an AmqpValue section containing a map which holds entries of the various supported entry types is returned as a  {@link MapMessage}, and verify the values can all be retrieved as expected.
 */
@Test(timeout=5000) public void testReceiveBasicMapMessage() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    String myBoolKey=""String_Node_Str"";
    boolean myBool=true;
    String myByteKey=""String_Node_Str"";
    byte myByte=4;
    String myBytesKey=""String_Node_Str"";
    byte[] myBytes=myBytesKey.getBytes();
    String myCharKey=""String_Node_Str"";
    char myChar='d';
    String myDoubleKey=""String_Node_Str"";
    double myDouble=1234567890123456789.1234;
    String myFloatKey=""String_Node_Str"";
    float myFloat=1.1F;
    String myIntKey=""String_Node_Str"";
    int myInt=Integer.MAX_VALUE;
    String myLongKey=""String_Node_Str"";
    long myLong=Long.MAX_VALUE;
    String myShortKey=""String_Node_Str"";
    short myShort=25;
    String myStringKey=""String_Node_Str"";
    String myString=myStringKey;
    Map<String,Object> map=new LinkedHashMap<String,Object>();
    map.put(myBoolKey,myBool);
    map.put(myByteKey,myByte);
    map.put(myBytesKey,new Binary(myBytes));
    map.put(myCharKey,myChar);
    map.put(myDoubleKey,myDouble);
    map.put(myFloatKey,myFloat);
    map.put(myIntKey,myInt);
    map.put(myLongKey,myLong);
    map.put(myShortKey,myShort);
    map.put(myStringKey,myString);
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_MAP_MESSAGE);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(map);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof MapMessage);
    MapMessage receivedMapMessage=(MapMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedMapMessage.getBoolean(myBoolKey));
    assertEquals(""String_Node_Str"",myByte,receivedMapMessage.getByte(myByteKey));
    byte[] readBytes=receivedMapMessage.getBytes(myBytesKey);
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedMapMessage.getChar(myCharKey));
    assertEquals(""String_Node_Str"",myDouble,receivedMapMessage.getDouble(myDoubleKey),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedMapMessage.getFloat(myFloatKey),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedMapMessage.getInt(myIntKey));
    assertEquals(""String_Node_Str"",myLong,receivedMapMessage.getLong(myLongKey));
    assertEquals(""String_Node_Str"",myShort,receivedMapMessage.getShort(myShortKey));
    assertEquals(""String_Node_Str"",myString,receivedMapMessage.getString(myStringKey));
  }
 }","/** 
 * Test that a message received from the test peer with an AmqpValue section containing a map which holds entries of the various supported entry types is returned as a  {@link MapMessage}, and verify the values can all be retrieved as expected.
 */
@Test(timeout=5000) public void testReceiveBasicMapMessage() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    String myBoolKey=""String_Node_Str"";
    boolean myBool=true;
    String myByteKey=""String_Node_Str"";
    byte myByte=4;
    String myBytesKey=""String_Node_Str"";
    byte[] myBytes=myBytesKey.getBytes();
    String myCharKey=""String_Node_Str"";
    char myChar='d';
    String myDoubleKey=""String_Node_Str"";
    double myDouble=1234567890123456789.1234;
    String myFloatKey=""String_Node_Str"";
    float myFloat=1.1F;
    String myIntKey=""String_Node_Str"";
    int myInt=Integer.MAX_VALUE;
    String myLongKey=""String_Node_Str"";
    long myLong=Long.MAX_VALUE;
    String myShortKey=""String_Node_Str"";
    short myShort=25;
    String myStringKey=""String_Node_Str"";
    String myString=myStringKey;
    Map<String,Object> map=new LinkedHashMap<String,Object>();
    map.put(myBoolKey,myBool);
    map.put(myByteKey,myByte);
    map.put(myBytesKey,new Binary(myBytes));
    map.put(myCharKey,myChar);
    map.put(myDoubleKey,myDouble);
    map.put(myFloatKey,myFloat);
    map.put(myIntKey,myInt);
    map.put(myLongKey,myLong);
    map.put(myShortKey,myShort);
    map.put(myStringKey,myString);
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_MSG_TYPE,AmqpMessageSupport.JMS_MAP_MESSAGE);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(map);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof MapMessage);
    MapMessage receivedMapMessage=(MapMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedMapMessage.getBoolean(myBoolKey));
    assertEquals(""String_Node_Str"",myByte,receivedMapMessage.getByte(myByteKey));
    byte[] readBytes=receivedMapMessage.getBytes(myBytesKey);
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedMapMessage.getChar(myCharKey));
    assertEquals(""String_Node_Str"",myDouble,receivedMapMessage.getDouble(myDoubleKey),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedMapMessage.getFloat(myFloatKey),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedMapMessage.getInt(myIntKey));
    assertEquals(""String_Node_Str"",myLong,receivedMapMessage.getLong(myLongKey));
    assertEquals(""String_Node_Str"",myShort,receivedMapMessage.getShort(myShortKey));
    assertEquals(""String_Node_Str"",myString,receivedMapMessage.getString(myStringKey));
  }
 }"
41697,"private void sentMessageWithCorrelationIdTestImpl(String stringCorrelationId,Object correlationIdForAmqpMessageClass,boolean appSpecific) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withCorrelationId(equalTo(correlationIdForAmqpMessageClass));
    if (appSpecific) {
      msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_APP_CORRELATION_ID),equalTo(Boolean.TRUE));
    }
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setJMSCorrelationID(stringCorrelationId);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(3000);
    if (!appSpecific) {
      assertFalse(msgAnnotationsMatcher.keyExistsInReceivedAnnotations(Symbol.valueOf(AmqpMessageSupport.JMS_APP_CORRELATION_ID)));
    }
  }
 }","private void sentMessageWithCorrelationIdTestImpl(String stringCorrelationId,Object correlationIdForAmqpMessageClass,boolean appSpecific) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withCorrelationId(equalTo(correlationIdForAmqpMessageClass));
    if (appSpecific) {
      msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_APP_CORRELATION_ID),equalTo(Boolean.TRUE));
    }
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setJMSCorrelationID(stringCorrelationId);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(3000);
    if (!appSpecific) {
      assertFalse(msgAnnotationsMatcher.keyExistsInReceivedAnnotations(Symbol.valueOf(AmqpMessageSupport.JMS_APP_CORRELATION_ID)));
    }
  }
 }"
41698,"@Test(timeout=2000) public void testReceiveMessageWithApplicationProperties() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    ApplicationPropertiesDescribedType appProperties=new ApplicationPropertiesDescribedType();
    appProperties.setApplicationProperty(STRING_PROP,STRING_PROP_VALUE);
    appProperties.setApplicationProperty(NULL_STRING_PROP,NULL_STRING_PROP_VALUE);
    appProperties.setApplicationProperty(BOOLEAN_PROP,BOOLEAN_PROP_VALUE);
    appProperties.setApplicationProperty(BYTE_PROP,BYTE_PROP_VALUE);
    appProperties.setApplicationProperty(SHORT_PROP,SHORT_PROP_VALUE);
    appProperties.setApplicationProperty(INT_PROP,INT_PROP_VALUE);
    appProperties.setApplicationProperty(LONG_PROP,LONG_PROP_VALUE);
    appProperties.setApplicationProperty(FLOAT_PROP,FLOAT_PROP_VALUE);
    appProperties.setApplicationProperty(DOUBLE_PROP,DOUBLE_PROP_VALUE);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,appProperties,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertTrue(receivedMessage.propertyExists(STRING_PROP));
    assertTrue(receivedMessage.propertyExists(NULL_STRING_PROP));
    assertTrue(receivedMessage.propertyExists(BYTE_PROP));
    assertTrue(receivedMessage.propertyExists(BOOLEAN_PROP));
    assertTrue(receivedMessage.propertyExists(SHORT_PROP));
    assertTrue(receivedMessage.propertyExists(INT_PROP));
    assertTrue(receivedMessage.propertyExists(LONG_PROP));
    assertTrue(receivedMessage.propertyExists(FLOAT_PROP));
    assertTrue(receivedMessage.propertyExists(DOUBLE_PROP));
    assertNull(receivedMessage.getStringProperty(NULL_STRING_PROP));
    assertEquals(STRING_PROP_VALUE,receivedMessage.getStringProperty(STRING_PROP));
    assertEquals(STRING_PROP_VALUE,receivedMessage.getStringProperty(STRING_PROP));
    assertEquals(BOOLEAN_PROP_VALUE,receivedMessage.getBooleanProperty(BOOLEAN_PROP));
    assertEquals(BYTE_PROP_VALUE,receivedMessage.getByteProperty(BYTE_PROP));
    assertEquals(SHORT_PROP_VALUE,receivedMessage.getShortProperty(SHORT_PROP));
    assertEquals(INT_PROP_VALUE,receivedMessage.getIntProperty(INT_PROP));
    assertEquals(LONG_PROP_VALUE,receivedMessage.getLongProperty(LONG_PROP));
    assertEquals(FLOAT_PROP_VALUE,receivedMessage.getFloatProperty(FLOAT_PROP),0.0);
    assertEquals(DOUBLE_PROP_VALUE,receivedMessage.getDoubleProperty(DOUBLE_PROP),0.0);
  }
 }","@Test(timeout=2000) public void testReceiveMessageWithApplicationProperties() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    ApplicationPropertiesDescribedType appProperties=new ApplicationPropertiesDescribedType();
    appProperties.setApplicationProperty(STRING_PROP,STRING_PROP_VALUE);
    appProperties.setApplicationProperty(NULL_STRING_PROP,NULL_STRING_PROP_VALUE);
    appProperties.setApplicationProperty(BOOLEAN_PROP,BOOLEAN_PROP_VALUE);
    appProperties.setApplicationProperty(BYTE_PROP,BYTE_PROP_VALUE);
    appProperties.setApplicationProperty(SHORT_PROP,SHORT_PROP_VALUE);
    appProperties.setApplicationProperty(INT_PROP,INT_PROP_VALUE);
    appProperties.setApplicationProperty(LONG_PROP,LONG_PROP_VALUE);
    appProperties.setApplicationProperty(FLOAT_PROP,FLOAT_PROP_VALUE);
    appProperties.setApplicationProperty(DOUBLE_PROP,DOUBLE_PROP_VALUE);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,appProperties,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertTrue(receivedMessage.propertyExists(STRING_PROP));
    assertTrue(receivedMessage.propertyExists(NULL_STRING_PROP));
    assertTrue(receivedMessage.propertyExists(BYTE_PROP));
    assertTrue(receivedMessage.propertyExists(BOOLEAN_PROP));
    assertTrue(receivedMessage.propertyExists(SHORT_PROP));
    assertTrue(receivedMessage.propertyExists(INT_PROP));
    assertTrue(receivedMessage.propertyExists(LONG_PROP));
    assertTrue(receivedMessage.propertyExists(FLOAT_PROP));
    assertTrue(receivedMessage.propertyExists(DOUBLE_PROP));
    assertNull(receivedMessage.getStringProperty(NULL_STRING_PROP));
    assertEquals(STRING_PROP_VALUE,receivedMessage.getStringProperty(STRING_PROP));
    assertEquals(STRING_PROP_VALUE,receivedMessage.getStringProperty(STRING_PROP));
    assertEquals(BOOLEAN_PROP_VALUE,receivedMessage.getBooleanProperty(BOOLEAN_PROP));
    assertEquals(BYTE_PROP_VALUE,receivedMessage.getByteProperty(BYTE_PROP));
    assertEquals(SHORT_PROP_VALUE,receivedMessage.getShortProperty(SHORT_PROP));
    assertEquals(INT_PROP_VALUE,receivedMessage.getIntProperty(INT_PROP));
    assertEquals(LONG_PROP_VALUE,receivedMessage.getLongProperty(LONG_PROP));
    assertEquals(FLOAT_PROP_VALUE,receivedMessage.getFloatProperty(FLOAT_PROP),0.0);
    assertEquals(DOUBLE_PROP_VALUE,receivedMessage.getDoubleProperty(DOUBLE_PROP),0.0);
  }
 }"
41699,"public void receivedMessageFromQueueWithoutToResultsInUseOfConsumerDestinationImpl(boolean useQueue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    String queueName=""String_Node_Str"";
    String topicName=""String_Node_Str"";
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination destination=null;
    if (useQueue) {
      destination=session.createQueue(queueName);
    }
 else {
      destination=session.createTopic(topicName);
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(destination);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSDestination();
    if (useQueue) {
      assertNotNull(""String_Node_Str"",dest);
      assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Queue);
      assertEquals(queueName,((Queue)dest).getQueueName());
    }
 else {
      assertNotNull(""String_Node_Str"",dest);
      assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Topic);
      assertEquals(topicName,((Topic)dest).getTopicName());
    }
  }
 }","public void receivedMessageFromQueueWithoutToResultsInUseOfConsumerDestinationImpl(boolean useQueue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    String queueName=""String_Node_Str"";
    String topicName=""String_Node_Str"";
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination destination=null;
    if (useQueue) {
      destination=session.createQueue(queueName);
    }
 else {
      destination=session.createTopic(topicName);
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(destination);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSDestination();
    if (useQueue) {
      assertNotNull(""String_Node_Str"",dest);
      assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Queue);
      assertEquals(queueName,((Queue)dest).getQueueName());
    }
 else {
      assertNotNull(""String_Node_Str"",dest);
      assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Topic);
      assertEquals(topicName,((Topic)dest).getTopicName());
    }
  }
 }"
41700,"private void recieveMessageIdSendCorrelationIdTestImpl(Object idForAmqpMessageClass) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(idForAmqpMessageClass);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(idForAmqpMessageClass);
    String jmsMessageID=receivedMessage.getJMSMessageID();
    assertEquals(""String_Node_Str"" + expectedBaseIdString,jmsMessageID);
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withCorrelationId(equalTo(idForAmqpMessageClass));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setJMSCorrelationID(jmsMessageID);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","private void recieveMessageIdSendCorrelationIdTestImpl(Object idForAmqpMessageClass) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(idForAmqpMessageClass);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(idForAmqpMessageClass);
    String jmsMessageID=receivedMessage.getJMSMessageID();
    assertEquals(""String_Node_Str"" + expectedBaseIdString,jmsMessageID);
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withCorrelationId(equalTo(idForAmqpMessageClass));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setJMSCorrelationID(jmsMessageID);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41701,"/** 
 * Tests that the   {@link AmqpMessageSupport#LEGACY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} set on a message toindicate its 'to' address represents a Topic results in the JMSDestination object being a Topic. Ensure the consumers destination is not used by consuming from a Queue.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithToLegacyTypeAnnotationForTopic() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.LEGACY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,AmqpMessageSupport.LEGACY_TOPIC_ATTRIBUTE);
    PropertiesDescribedType props=new PropertiesDescribedType();
    String myTopicAddress=""String_Node_Str"";
    props.setTo(myTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSDestination();
    assertNotNull(""String_Node_Str"",dest);
    assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Topic);
    assertEquals(myTopicAddress,((Topic)dest).getTopicName());
  }
 }","/** 
 * Tests that the   {@link AmqpMessageSupport#LEGACY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} set on a message toindicate its 'to' address represents a Topic results in the JMSDestination object being a Topic. Ensure the consumers destination is not used by consuming from a Queue.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithToLegacyTypeAnnotationForTopic() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.LEGACY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,AmqpMessageSupport.LEGACY_TOPIC_ATTRIBUTE);
    PropertiesDescribedType props=new PropertiesDescribedType();
    String myTopicAddress=""String_Node_Str"";
    props.setTo(myTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSDestination();
    assertNotNull(""String_Node_Str"",dest);
    assertTrue(""String_Node_Str"" + dest.getClass().getName(),dest instanceof Topic);
    assertEquals(myTopicAddress,((Topic)dest).getTopicName());
  }
 }"
41702,"/** 
 * Tests that the   {@link AmqpDestinationHelper#JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME} is set as a byte ona sent message to indicate its 'to' address represents a Topic JMSDestination.
 */
@Test(timeout=5000) public void testSentMessageContainsToTypeAnnotationByte() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String topicName=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    Symbol annotationKey=AmqpMessageSupport.getSymbol(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
    msgAnnotationsMatcher.withEntry(annotationKey,equalTo(AmqpDestinationHelper.TOPIC_TYPE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withTo(equalTo(topicName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    Topic topic=session.createTopic(topicName);
    MessageProducer producer=session.createProducer(topic);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","/** 
 * Tests that the   {@link AmqpDestinationHelper#JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME} is set as a byte ona sent message to indicate its 'to' address represents a Topic JMSDestination.
 */
@Test(timeout=5000) public void testSentMessageContainsToTypeAnnotationByte() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String topicName=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    Symbol annotationKey=AmqpMessageSupport.getSymbol(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
    msgAnnotationsMatcher.withEntry(annotationKey,equalTo(AmqpDestinationHelper.TOPIC_TYPE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withTo(equalTo(topicName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    Topic topic=session.createTopic(topicName);
    MessageProducer producer=session.createProducer(topic);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41703,"private void receivedMessageWithMessageIdTestImpl(Object underlyingAmqpMessageId) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(underlyingAmqpMessageId);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(underlyingAmqpMessageId);
    assertEquals(""String_Node_Str"" + expectedBaseIdString,receivedMessage.getJMSMessageID());
  }
 }","private void receivedMessageWithMessageIdTestImpl(Object underlyingAmqpMessageId) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(underlyingAmqpMessageId);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(underlyingAmqpMessageId);
    assertEquals(""String_Node_Str"" + expectedBaseIdString,receivedMessage.getJMSMessageID());
  }
 }"
41704,"/** 
 * Tests that lack of any destination type annotation value (via either  {@link AmqpDestinationHelper#JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME}or   {@link AmqpMessageSupport#LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME}) set on a message to indicate type of its 'reply-to' address results in it being classed as the same type as the consumer destination.
 */
@Test(timeout=2000) public void testReceivedMessageFromTopicWithReplyToWithoutTypeAnnotationResultsInUseOfConsumerDestinationType() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Topic topic=session.createTopic(""String_Node_Str"");
    String myReplyTopicAddress=""String_Node_Str"";
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setReplyTo(myReplyTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(topic);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",dest);
    assertTrue(""String_Node_Str"" + dest.getClass(),dest instanceof Topic);
    assertEquals(myReplyTopicAddress,((Topic)dest).getTopicName());
  }
 }","/** 
 * Tests that lack of any destination type annotation value (via either  {@link AmqpDestinationHelper#JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME}or   {@link AmqpMessageSupport#LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME}) set on a message to indicate type of its 'reply-to' address results in it being classed as the same type as the consumer destination.
 */
@Test(timeout=2000) public void testReceivedMessageFromTopicWithReplyToWithoutTypeAnnotationResultsInUseOfConsumerDestinationType() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Topic topic=session.createTopic(""String_Node_Str"");
    String myReplyTopicAddress=""String_Node_Str"";
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setReplyTo(myReplyTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(topic);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",dest);
    assertTrue(""String_Node_Str"" + dest.getClass(),dest instanceof Topic);
    assertEquals(myReplyTopicAddress,((Topic)dest).getTopicName());
  }
 }"
41705,"private void doReceivedMessageOnConnectionWithPrefixTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String replyName,String destAddress,String replyAddress,String annotationName,Object annotationValue,String replyAnnotationName,Object replyAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=null;
    if (destType == Topic.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else     if (destType == Queue.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix + ""String_Node_Str""+ destPrefix);
    }
    connection.start();
    if (destType == Topic.class) {
      ((JmsConnection)connection).setTopicPrefix(destPrefix);
    }
 else     if (destType == Queue.class) {
      ((JmsConnection)connection).setQueuePrefix(destPrefix);
    }
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else     if (destType == TemporaryTopic.class) {
      testPeer.expectTempTopicCreationAttach(destAddress);
      dest=session.createTemporaryTopic();
    }
 else     if (destType == TemporaryQueue.class) {
      testPeer.expectTempQueueCreationAttach(destAddress);
      dest=session.createTemporaryQueue();
    }
    MessageAnnotationsDescribedType msgAnnotations=null;
    if (annotationName != null || replyAnnotationName != null) {
      msgAnnotations=new MessageAnnotationsDescribedType();
      if (annotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(annotationName,annotationValue);
      }
      if (replyAnnotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(replyAnnotationName,replyAnnotationValue);
      }
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setTo(destAddress);
    props.setReplyTo(replyAddress);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    SourceMatcher sourceMatcher=new SourceMatcher();
    sourceMatcher.withAddress(equalTo(destAddress));
    testPeer.expectReceiverAttach(notNullValue(),sourceMatcher);
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(dest);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNotNull(receivedMessage);
    Destination jmsDest=receivedMessage.getJMSDestination();
    Destination jmsReplyTo=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",jmsDest);
    assertNotNull(""String_Node_Str"",jmsReplyTo);
    String recievedName=null;
    String recievedReplyName=null;
    if (destType == Topic.class || destType == TemporaryTopic.class) {
      recievedName=((Topic)jmsDest).getTopicName();
      recievedReplyName=((Topic)jmsReplyTo).getTopicName();
    }
 else     if (destType == Queue.class || destType == TemporaryQueue.class) {
      recievedName=((Queue)jmsDest).getQueueName();
      recievedReplyName=((Queue)jmsReplyTo).getQueueName();
    }
    assertEquals(""String_Node_Str"",destName,recievedName);
    assertEquals(""String_Node_Str"",replyName,recievedReplyName);
    if (destType == TemporaryQueue.class || destType == TemporaryTopic.class) {
      assertEquals(""String_Node_Str"",destName,destAddress);
      assertEquals(""String_Node_Str"",replyName,replyAddress);
    }
  }
 }","private void doReceivedMessageOnConnectionWithPrefixTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String replyName,String destAddress,String replyAddress,String annotationName,Object annotationValue,String replyAnnotationName,Object replyAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=null;
    if (destType == Topic.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else     if (destType == Queue.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix + ""String_Node_Str""+ destPrefix);
    }
    connection.start();
    if (destType == Topic.class) {
      ((JmsConnection)connection).setTopicPrefix(destPrefix);
    }
 else     if (destType == Queue.class) {
      ((JmsConnection)connection).setQueuePrefix(destPrefix);
    }
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else     if (destType == TemporaryTopic.class) {
      testPeer.expectTempTopicCreationAttach(destAddress);
      dest=session.createTemporaryTopic();
    }
 else     if (destType == TemporaryQueue.class) {
      testPeer.expectTempQueueCreationAttach(destAddress);
      dest=session.createTemporaryQueue();
    }
    MessageAnnotationsDescribedType msgAnnotations=null;
    if (annotationName != null || replyAnnotationName != null) {
      msgAnnotations=new MessageAnnotationsDescribedType();
      if (annotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(annotationName,annotationValue);
      }
      if (replyAnnotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(replyAnnotationName,replyAnnotationValue);
      }
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setTo(destAddress);
    props.setReplyTo(replyAddress);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    SourceMatcher sourceMatcher=new SourceMatcher();
    sourceMatcher.withAddress(equalTo(destAddress));
    testPeer.expectReceiverAttach(notNullValue(),sourceMatcher);
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(dest);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNotNull(receivedMessage);
    Destination jmsDest=receivedMessage.getJMSDestination();
    Destination jmsReplyTo=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",jmsDest);
    assertNotNull(""String_Node_Str"",jmsReplyTo);
    String recievedName=null;
    String recievedReplyName=null;
    if (destType == Topic.class || destType == TemporaryTopic.class) {
      recievedName=((Topic)jmsDest).getTopicName();
      recievedReplyName=((Topic)jmsReplyTo).getTopicName();
    }
 else     if (destType == Queue.class || destType == TemporaryQueue.class) {
      recievedName=((Queue)jmsDest).getQueueName();
      recievedReplyName=((Queue)jmsReplyTo).getQueueName();
    }
    assertEquals(""String_Node_Str"",destName,recievedName);
    assertEquals(""String_Node_Str"",replyName,recievedReplyName);
    if (destType == TemporaryQueue.class || destType == TemporaryTopic.class) {
      assertEquals(""String_Node_Str"",destName,destAddress);
      assertEquals(""String_Node_Str"",replyName,replyAddress);
    }
  }
 }"
41706,"/** 
 * Tests that when sending a message with the JMSXGroupID, JMSXGroupSeq, and JMS_AMQP_REPLY_TO_GROUP_ID properties of the JMS message set, that the expected values are included in the fields of the AMQP message emitted.
 */
@Test(timeout=2000) public void testSendMessageWithGroupRelatedPropertiesSet() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    String expectedGroupId=""String_Node_Str"";
    int expectedGroupSeq=1;
    String expectedReplyToGroupId=""String_Node_Str"";
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withGroupId(equalTo(expectedGroupId));
    propsMatcher.withReplyToGroupId(equalTo(expectedReplyToGroupId));
    propsMatcher.withGroupSequence(equalTo(UnsignedInteger.valueOf(expectedGroupSeq)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setStringProperty(JmsClientProperties.JMSXGROUPID,expectedGroupId);
    message.setIntProperty(JmsClientProperties.JMSXGROUPSEQ,expectedGroupSeq);
    message.setStringProperty(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID,expectedReplyToGroupId);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }","/** 
 * Tests that when sending a message with the JMSXGroupID, JMSXGroupSeq, and JMS_AMQP_REPLY_TO_GROUP_ID properties of the JMS message set, that the expected values are included in the fields of the AMQP message emitted.
 */
@Test(timeout=2000) public void testSendMessageWithGroupRelatedPropertiesSet() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    String expectedGroupId=""String_Node_Str"";
    int expectedGroupSeq=1;
    String expectedReplyToGroupId=""String_Node_Str"";
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withGroupId(equalTo(expectedGroupId));
    propsMatcher.withReplyToGroupId(equalTo(expectedReplyToGroupId));
    propsMatcher.withGroupSequence(equalTo(UnsignedInteger.valueOf(expectedGroupSeq)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedAmqpValueMatcher(null));
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createTextMessage();
    message.setStringProperty(JmsClientProperties.JMSXGROUPID,expectedGroupId);
    message.setIntProperty(JmsClientProperties.JMSXGROUPSEQ,expectedGroupSeq);
    message.setStringProperty(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID,expectedReplyToGroupId);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }"
41707,"private void doSendMessageOnConnectionWithPrefixTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String destAddress,Byte destTypeAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=null;
    if (destType == Topic.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else     if (destType == Queue.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix + ""String_Node_Str""+ destPrefix);
    }
    connection.start();
    if (destType == Topic.class) {
      ((JmsConnection)connection).setTopicPrefix(destPrefix);
    }
 else     if (destType == Queue.class) {
      ((JmsConnection)connection).setQueuePrefix(destPrefix);
    }
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else     if (destType == TemporaryTopic.class) {
      testPeer.expectTempTopicCreationAttach(destAddress);
      dest=session.createTemporaryTopic();
    }
 else     if (destType == TemporaryQueue.class) {
      testPeer.expectTempQueueCreationAttach(destAddress);
      dest=session.createTemporaryQueue();
    }
    TargetMatcher targetMatcher=new TargetMatcher();
    targetMatcher.withAddress(equalTo(destAddress));
    testPeer.expectSenderAttach(targetMatcher,false,false);
    MessageProducer producer=session.createProducer(dest);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withTo(equalTo(destAddress));
    propsMatcher.withReplyTo(equalTo(destAddress));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setJMSReplyTo(dest);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","private void doSendMessageOnConnectionWithPrefixTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String destAddress,Byte destTypeAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=null;
    if (destType == Topic.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else     if (destType == Queue.class) {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix);
    }
 else {
      connection=testFixture.establishConnecton(testPeer,""String_Node_Str"" + destPrefix + ""String_Node_Str""+ destPrefix);
    }
    connection.start();
    if (destType == Topic.class) {
      ((JmsConnection)connection).setTopicPrefix(destPrefix);
    }
 else     if (destType == Queue.class) {
      ((JmsConnection)connection).setQueuePrefix(destPrefix);
    }
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else     if (destType == TemporaryTopic.class) {
      testPeer.expectTempTopicCreationAttach(destAddress);
      dest=session.createTemporaryTopic();
    }
 else     if (destType == TemporaryQueue.class) {
      testPeer.expectTempQueueCreationAttach(destAddress);
      dest=session.createTemporaryQueue();
    }
    TargetMatcher targetMatcher=new TargetMatcher();
    targetMatcher.withAddress(equalTo(destAddress));
    testPeer.expectSenderAttach(targetMatcher,false,false);
    MessageProducer producer=session.createProducer(dest);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withTo(equalTo(destAddress));
    propsMatcher.withReplyTo(equalTo(destAddress));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setJMSReplyTo(dest);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41708,"@Test(timeout=2000) public void testSendMessageWithApplicationProperties() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    ApplicationPropertiesSectionMatcher appPropsMatcher=new ApplicationPropertiesSectionMatcher(true);
    appPropsMatcher.withEntry(NULL_STRING_PROP,nullValue());
    appPropsMatcher.withEntry(STRING_PROP,equalTo(STRING_PROP_VALUE));
    appPropsMatcher.withEntry(BOOLEAN_PROP,equalTo(BOOLEAN_PROP_VALUE));
    appPropsMatcher.withEntry(BYTE_PROP,equalTo(BYTE_PROP_VALUE));
    appPropsMatcher.withEntry(SHORT_PROP,equalTo(SHORT_PROP_VALUE));
    appPropsMatcher.withEntry(INT_PROP,equalTo(INT_PROP_VALUE));
    appPropsMatcher.withEntry(LONG_PROP,equalTo(LONG_PROP_VALUE));
    appPropsMatcher.withEntry(FLOAT_PROP,equalTo(FLOAT_PROP_VALUE));
    appPropsMatcher.withEntry(DOUBLE_PROP,equalTo(DOUBLE_PROP_VALUE));
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withTo(equalTo(queueName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setApplicationPropertiesMatcher(appPropsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setStringProperty(NULL_STRING_PROP,NULL_STRING_PROP_VALUE);
    message.setStringProperty(STRING_PROP,STRING_PROP_VALUE);
    message.setBooleanProperty(BOOLEAN_PROP,BOOLEAN_PROP_VALUE);
    message.setByteProperty(BYTE_PROP,BYTE_PROP_VALUE);
    message.setShortProperty(SHORT_PROP,SHORT_PROP_VALUE);
    message.setIntProperty(INT_PROP,INT_PROP_VALUE);
    message.setLongProperty(LONG_PROP,LONG_PROP_VALUE);
    message.setFloatProperty(FLOAT_PROP,FLOAT_PROP_VALUE);
    message.setDoubleProperty(DOUBLE_PROP,DOUBLE_PROP_VALUE);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }","@Test(timeout=2000) public void testSendMessageWithApplicationProperties() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    ApplicationPropertiesSectionMatcher appPropsMatcher=new ApplicationPropertiesSectionMatcher(true);
    appPropsMatcher.withEntry(NULL_STRING_PROP,nullValue());
    appPropsMatcher.withEntry(STRING_PROP,equalTo(STRING_PROP_VALUE));
    appPropsMatcher.withEntry(BOOLEAN_PROP,equalTo(BOOLEAN_PROP_VALUE));
    appPropsMatcher.withEntry(BYTE_PROP,equalTo(BYTE_PROP_VALUE));
    appPropsMatcher.withEntry(SHORT_PROP,equalTo(SHORT_PROP_VALUE));
    appPropsMatcher.withEntry(INT_PROP,equalTo(INT_PROP_VALUE));
    appPropsMatcher.withEntry(LONG_PROP,equalTo(LONG_PROP_VALUE));
    appPropsMatcher.withEntry(FLOAT_PROP,equalTo(FLOAT_PROP_VALUE));
    appPropsMatcher.withEntry(DOUBLE_PROP,equalTo(DOUBLE_PROP_VALUE));
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withTo(equalTo(queueName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setApplicationPropertiesMatcher(appPropsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setStringProperty(NULL_STRING_PROP,NULL_STRING_PROP_VALUE);
    message.setStringProperty(STRING_PROP,STRING_PROP_VALUE);
    message.setBooleanProperty(BOOLEAN_PROP,BOOLEAN_PROP_VALUE);
    message.setByteProperty(BYTE_PROP,BYTE_PROP_VALUE);
    message.setShortProperty(SHORT_PROP,SHORT_PROP_VALUE);
    message.setIntProperty(INT_PROP,INT_PROP_VALUE);
    message.setLongProperty(LONG_PROP,LONG_PROP_VALUE);
    message.setFloatProperty(FLOAT_PROP,FLOAT_PROP_VALUE);
    message.setDoubleProperty(DOUBLE_PROP,DOUBLE_PROP_VALUE);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(1000);
  }
 }"
41709,"private void doSendMessageOnConnectionWithBrokerDefinedPrefixPropertiesTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String destAddress,Byte destTypeAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Map<Symbol,Object> properties=new HashMap<Symbol,Object>();
    properties.put(AmqpConnectionProperties.QUEUE_PREFIX,destPrefix);
    properties.put(AmqpConnectionProperties.TOPIC_PREFIX,destPrefix);
    Connection connection=testFixture.establishConnecton(testPeer,null,null,properties);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else {
      fail(""String_Node_Str"");
    }
    TargetMatcher targetMatcher=new TargetMatcher();
    targetMatcher.withAddress(equalTo(destAddress));
    testPeer.expectSenderAttach(targetMatcher,false,false);
    MessageProducer producer=session.createProducer(dest);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withTo(equalTo(destAddress));
    propsMatcher.withReplyTo(equalTo(destAddress));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setJMSReplyTo(dest);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","private void doSendMessageOnConnectionWithBrokerDefinedPrefixPropertiesTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String destAddress,Byte destTypeAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Map<Symbol,Object> properties=new HashMap<Symbol,Object>();
    properties.put(AmqpConnectionProperties.QUEUE_PREFIX,destPrefix);
    properties.put(AmqpConnectionProperties.TOPIC_PREFIX,destPrefix);
    Connection connection=testFixture.establishConnecton(testPeer,null,null,properties);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else {
      fail(""String_Node_Str"");
    }
    TargetMatcher targetMatcher=new TargetMatcher();
    targetMatcher.withAddress(equalTo(destAddress));
    testPeer.expectSenderAttach(targetMatcher,false,false);
    MessageProducer producer=session.createProducer(dest);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_DEST_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME),equalTo(destTypeAnnotationValue));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withTo(equalTo(destAddress));
    propsMatcher.withReplyTo(equalTo(destAddress));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Message message=session.createMessage();
    message.setJMSReplyTo(dest);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41710,"/** 
 * Tests that lack of the absolute-expiry-time and ttl fields on a message results in it returning 0 for for JMSExpiration
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithNoAbsoluteExpiryOrTtlReturnsJMSExpirationZero() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertEquals(0L,receivedMessage.getJMSExpiration());
  }
 }","/** 
 * Tests that lack of the absolute-expiry-time and ttl fields on a message results in it returning 0 for for JMSExpiration
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithNoAbsoluteExpiryOrTtlReturnsJMSExpirationZero() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertEquals(0L,receivedMessage.getJMSExpiration());
  }
 }"
41711,"private void receivedMessageWithCorrelationIdTestImpl(Object correlationIdForAmqpMessageClass,boolean appSpecific) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    MessageAnnotationsDescribedType ann=null;
    props.setMessageId(""String_Node_Str"");
    props.setCorrelationId(correlationIdForAmqpMessageClass);
    if (appSpecific) {
      ann=new MessageAnnotationsDescribedType();
      ann.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID,true);
    }
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,ann,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(correlationIdForAmqpMessageClass);
    String expected=expectedBaseIdString;
    if (!appSpecific) {
      expected=""String_Node_Str"" + expected;
    }
    assertEquals(expected,receivedMessage.getJMSCorrelationID());
  }
 }","private void receivedMessageWithCorrelationIdTestImpl(Object correlationIdForAmqpMessageClass,boolean appSpecific) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    MessageAnnotationsDescribedType ann=null;
    props.setMessageId(""String_Node_Str"");
    props.setCorrelationId(correlationIdForAmqpMessageClass);
    if (appSpecific) {
      ann=new MessageAnnotationsDescribedType();
      ann.setSymbolKeyedAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID,true);
    }
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,ann,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    String expectedBaseIdString=new AmqpMessageIdHelper().toBaseMessageIdString(correlationIdForAmqpMessageClass);
    String expected=expectedBaseIdString;
    if (!appSpecific) {
      expected=""String_Node_Str"" + expected;
    }
    assertEquals(expected,receivedMessage.getJMSCorrelationID());
  }
 }"
41712,"/** 
 * Tests that setting a non-zero value in the absolute-expiry-time field on a message results in it returning this value for JMSExpiration
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithAbsoluteExpiryReturnsJMSExpirationNonZero() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    long timestamp=System.currentTimeMillis();
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setAbsoluteExpiryTime(new Date(timestamp));
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertEquals(timestamp,receivedMessage.getJMSExpiration());
  }
 }","/** 
 * Tests that setting a non-zero value in the absolute-expiry-time field on a message results in it returning this value for JMSExpiration
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithAbsoluteExpiryReturnsJMSExpirationNonZero() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    long timestamp=System.currentTimeMillis();
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setAbsoluteExpiryTime(new Date(timestamp));
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertEquals(timestamp,receivedMessage.getJMSExpiration());
  }
 }"
41713,"/** 
 * Tests that when receiving a message with the group-id, reply-to-group-id, and group-sequence fields of the AMQP properties section set, that the expected JMSX or JMS_AMQP properties are present, and the expected values are returned when retrieved from the JMS message.
 */
@Test(timeout=2000) public void testReceivedMessageWithGroupRelatedPropertiesSet() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    MessageAnnotationsDescribedType ann=null;
    String expectedGroupId=""String_Node_Str"";
    int expectedGroupSeq=1;
    String expectedReplyToGroupId=""String_Node_Str"";
    props.setGroupId(expectedGroupId);
    props.setGroupSequence(UnsignedInteger.valueOf(expectedGroupSeq));
    props.setReplyToGroupId(expectedReplyToGroupId);
    props.setMessageId(""String_Node_Str"");
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,ann,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    boolean foundGroupId=false;
    boolean foundGroupSeq=false;
    boolean foundReplyToGroupId=false;
    Enumeration<?> names=receivedMessage.getPropertyNames();
    assertTrue(""String_Node_Str"",names.hasMoreElements());
    while (names.hasMoreElements()) {
      Object element=names.nextElement();
      if (JmsClientProperties.JMSXGROUPID.equals(element)) {
        foundGroupId=true;
      }
      if (JmsClientProperties.JMSXGROUPSEQ.equals(element)) {
        foundGroupSeq=true;
      }
      if (AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID.equals(element)) {
        foundReplyToGroupId=true;
      }
    }
    assertTrue(""String_Node_Str"",foundGroupId);
    assertTrue(""String_Node_Str"",foundGroupSeq);
    assertTrue(""String_Node_Str"",foundReplyToGroupId);
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(JmsClientProperties.JMSXGROUPID));
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(JmsClientProperties.JMSXGROUPSEQ));
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID));
    assertEquals(""String_Node_Str"",expectedGroupId,receivedMessage.getStringProperty(JmsClientProperties.JMSXGROUPID));
    assertEquals(""String_Node_Str"",expectedGroupSeq,receivedMessage.getIntProperty(JmsClientProperties.JMSXGROUPSEQ));
    assertEquals(""String_Node_Str"",expectedReplyToGroupId,receivedMessage.getStringProperty(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID));
  }
 }","/** 
 * Tests that when receiving a message with the group-id, reply-to-group-id, and group-sequence fields of the AMQP properties section set, that the expected JMSX or JMS_AMQP properties are present, and the expected values are returned when retrieved from the JMS message.
 */
@Test(timeout=2000) public void testReceivedMessageWithGroupRelatedPropertiesSet() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    MessageAnnotationsDescribedType ann=null;
    String expectedGroupId=""String_Node_Str"";
    int expectedGroupSeq=1;
    String expectedReplyToGroupId=""String_Node_Str"";
    props.setGroupId(expectedGroupId);
    props.setGroupSequence(UnsignedInteger.valueOf(expectedGroupSeq));
    props.setReplyToGroupId(expectedReplyToGroupId);
    props.setMessageId(""String_Node_Str"");
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,ann,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    boolean foundGroupId=false;
    boolean foundGroupSeq=false;
    boolean foundReplyToGroupId=false;
    Enumeration<?> names=receivedMessage.getPropertyNames();
    assertTrue(""String_Node_Str"",names.hasMoreElements());
    while (names.hasMoreElements()) {
      Object element=names.nextElement();
      if (JmsClientProperties.JMSXGROUPID.equals(element)) {
        foundGroupId=true;
      }
      if (JmsClientProperties.JMSXGROUPSEQ.equals(element)) {
        foundGroupSeq=true;
      }
      if (AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID.equals(element)) {
        foundReplyToGroupId=true;
      }
    }
    assertTrue(""String_Node_Str"",foundGroupId);
    assertTrue(""String_Node_Str"",foundGroupSeq);
    assertTrue(""String_Node_Str"",foundReplyToGroupId);
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(JmsClientProperties.JMSXGROUPID));
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(JmsClientProperties.JMSXGROUPSEQ));
    assertTrue(""String_Node_Str"",receivedMessage.propertyExists(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID));
    assertEquals(""String_Node_Str"",expectedGroupId,receivedMessage.getStringProperty(JmsClientProperties.JMSXGROUPID));
    assertEquals(""String_Node_Str"",expectedGroupSeq,receivedMessage.getIntProperty(JmsClientProperties.JMSXGROUPSEQ));
    assertEquals(""String_Node_Str"",expectedReplyToGroupId,receivedMessage.getStringProperty(AmqpMessageSupport.JMS_AMQP_REPLY_TO_GROUP_ID));
  }
 }"
41714,"/** 
 * Tests that lack of the reply-to set on a message results in it returning null for JMSReplyTo and not the consumer destination as happens for JMSDestination.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithNoReplyToReturnsNull() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertNull(receivedMessage.getJMSReplyTo());
  }
 }","/** 
 * Tests that lack of the reply-to set on a message results in it returning null for JMSReplyTo and not the consumer destination as happens for JMSDestination.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithNoReplyToReturnsNull() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    assertNull(receivedMessage.getJMSReplyTo());
  }
 }"
41715,"/** 
 * Tests that the   {@link AmqpDestinationHelper#JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} is set as a byte ona sent message to indicate its 'reply-to' address represents a Topic JMSDestination.
 */
@Test(timeout=5000) public void testSentMessageContainsReplyToTypeAnnotationByte() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    String replyTopicName=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    Symbol annotationKey=AmqpMessageSupport.getSymbol(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
    msgAnnotationsMatcher.withEntry(annotationKey,equalTo(AmqpDestinationHelper.TOPIC_TYPE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withReplyTo(equalTo(replyTopicName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Topic replyTopic=session.createTopic(replyTopicName);
    Message message=session.createMessage();
    message.setJMSReplyTo(replyTopic);
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }","/** 
 * Tests that the   {@link AmqpDestinationHelper#JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} is set as a byte ona sent message to indicate its 'reply-to' address represents a Topic JMSDestination.
 */
@Test(timeout=5000) public void testSentMessageContainsReplyToTypeAnnotationByte() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    testPeer.expectBegin(true);
    testPeer.expectSenderAttach();
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    String queueName=""String_Node_Str"";
    String replyTopicName=""String_Node_Str"";
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true).withDurable(equalTo(true));
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    Symbol annotationKey=AmqpMessageSupport.getSymbol(AmqpDestinationHelper.JMS_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
    msgAnnotationsMatcher.withEntry(annotationKey,equalTo(AmqpDestinationHelper.TOPIC_TYPE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true).withReplyTo(equalTo(replyTopicName));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    testPeer.expectTransfer(messageMatcher);
    Topic replyTopic=session.createTopic(replyTopicName);
    Message message=session.createMessage();
    message.setJMSReplyTo(replyTopic);
    Queue queue=session.createQueue(queueName);
    MessageProducer producer=session.createProducer(queue);
    producer.send(message);
    testPeer.waitForAllHandlersToComplete(2000);
  }
 }"
41716,"private void doReceivedMessageOnConnectionWithBrokerDefinedPrefixPropertiesTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String replyName,String destAddress,String replyAddress,String annotationName,Object annotationValue,String replyAnnotationName,Object replyAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Map<Symbol,Object> properties=new HashMap<Symbol,Object>();
    properties.put(AmqpConnectionProperties.QUEUE_PREFIX,destPrefix);
    properties.put(AmqpConnectionProperties.TOPIC_PREFIX,destPrefix);
    Connection connection=testFixture.establishConnecton(testPeer,null,null,properties);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else {
      fail(""String_Node_Str"");
    }
    MessageAnnotationsDescribedType msgAnnotations=null;
    if (annotationName != null || replyAnnotationName != null) {
      msgAnnotations=new MessageAnnotationsDescribedType();
      if (annotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(annotationName,annotationValue);
      }
      if (replyAnnotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(replyAnnotationName,replyAnnotationValue);
      }
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setTo(destAddress);
    props.setReplyTo(replyAddress);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    SourceMatcher sourceMatcher=new SourceMatcher();
    sourceMatcher.withAddress(equalTo(destAddress));
    testPeer.expectReceiverAttach(notNullValue(),sourceMatcher);
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(dest);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNotNull(receivedMessage);
    Destination jmsDest=receivedMessage.getJMSDestination();
    Destination jmsReplyTo=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",jmsDest);
    assertNotNull(""String_Node_Str"",jmsReplyTo);
    String recievedName=null;
    String recievedReplyName=null;
    if (destType == Topic.class) {
      recievedName=((Topic)jmsDest).getTopicName();
      recievedReplyName=((Topic)jmsReplyTo).getTopicName();
    }
 else     if (destType == Queue.class) {
      recievedName=((Queue)jmsDest).getQueueName();
      recievedReplyName=((Queue)jmsReplyTo).getQueueName();
    }
    assertEquals(""String_Node_Str"",destName,recievedName);
    assertEquals(""String_Node_Str"",replyName,recievedReplyName);
  }
 }","private void doReceivedMessageOnConnectionWithBrokerDefinedPrefixPropertiesTestImpl(Class<? extends Destination> destType,String destPrefix,String destName,String replyName,String destAddress,String replyAddress,String annotationName,Object annotationValue,String replyAnnotationName,Object replyAnnotationValue) throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Map<Symbol,Object> properties=new HashMap<Symbol,Object>();
    properties.put(AmqpConnectionProperties.QUEUE_PREFIX,destPrefix);
    properties.put(AmqpConnectionProperties.TOPIC_PREFIX,destPrefix);
    Connection connection=testFixture.establishConnecton(testPeer,null,null,properties);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Destination dest=null;
    if (destType == Topic.class) {
      dest=session.createTopic(destName);
    }
 else     if (destType == Queue.class) {
      dest=session.createQueue(destName);
    }
 else {
      fail(""String_Node_Str"");
    }
    MessageAnnotationsDescribedType msgAnnotations=null;
    if (annotationName != null || replyAnnotationName != null) {
      msgAnnotations=new MessageAnnotationsDescribedType();
      if (annotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(annotationName,annotationValue);
      }
      if (replyAnnotationName != null) {
        msgAnnotations.setSymbolKeyedAnnotation(replyAnnotationName,replyAnnotationValue);
      }
    }
    PropertiesDescribedType props=new PropertiesDescribedType();
    props.setTo(destAddress);
    props.setReplyTo(replyAddress);
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    SourceMatcher sourceMatcher=new SourceMatcher();
    sourceMatcher.withAddress(equalTo(destAddress));
    testPeer.expectReceiverAttach(notNullValue(),sourceMatcher);
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(dest);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNotNull(receivedMessage);
    Destination jmsDest=receivedMessage.getJMSDestination();
    Destination jmsReplyTo=receivedMessage.getJMSReplyTo();
    assertNotNull(""String_Node_Str"",jmsDest);
    assertNotNull(""String_Node_Str"",jmsReplyTo);
    String recievedName=null;
    String recievedReplyName=null;
    if (destType == Topic.class) {
      recievedName=((Topic)jmsDest).getTopicName();
      recievedReplyName=((Topic)jmsReplyTo).getTopicName();
    }
 else     if (destType == Queue.class) {
      recievedName=((Queue)jmsDest).getQueueName();
      recievedReplyName=((Queue)jmsReplyTo).getQueueName();
    }
    assertEquals(""String_Node_Str"",destName,recievedName);
    assertEquals(""String_Node_Str"",replyName,recievedReplyName);
  }
 }"
41717,"@Test(timeout=2000) public void testReceiveMessageWithoutMessageId() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNull(receivedMessage.getJMSMessageID());
  }
 }","@Test(timeout=2000) public void testReceiveMessageWithoutMessageId() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(2000);
    assertNull(receivedMessage.getJMSMessageID());
  }
 }"
41718,"/** 
 * Tests that the   {@link AmqpMessageSupport#LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} set on a message toindicate its 'reply-to' address represents a Topic results in the JMSReplyTo object being a Topic. Ensure the consumers destination is not used by consuming from a Queue.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithLegacyReplyToTypeAnnotationForTopic() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,AmqpMessageSupport.LEGACY_TOPIC_ATTRIBUTE);
    PropertiesDescribedType props=new PropertiesDescribedType();
    String myTopicAddress=""String_Node_Str"";
    props.setReplyTo(myTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSReplyTo();
    assertTrue(dest instanceof Topic);
    assertEquals(myTopicAddress,((Topic)dest).getTopicName());
  }
 }","/** 
 * Tests that the   {@link AmqpMessageSupport#LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME} set on a message toindicate its 'reply-to' address represents a Topic results in the JMSReplyTo object being a Topic. Ensure the consumers destination is not used by consuming from a Queue.
 */
@Test(timeout=2000) public void testReceivedMessageFromQueueWithLegacyReplyToTypeAnnotationForTopic() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(testFixture.getAvailablePort())){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    MessageAnnotationsDescribedType msgAnnotations=new MessageAnnotationsDescribedType();
    msgAnnotations.setSymbolKeyedAnnotation(AmqpMessageSupport.LEGACY_REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,AmqpMessageSupport.LEGACY_TOPIC_ATTRIBUTE);
    PropertiesDescribedType props=new PropertiesDescribedType();
    String myTopicAddress=""String_Node_Str"";
    props.setReplyTo(myTopicAddress);
    props.setMessageId(""String_Node_Str"");
    DescribedType amqpValueNullContent=new AmqpValueDescribedType(null);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,msgAnnotations,props,null,amqpValueNullContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(receivedMessage);
    Destination dest=receivedMessage.getJMSReplyTo();
    assertTrue(dest instanceof Topic);
    assertEquals(myTopicAddress,((Topic)dest).getTopicName());
  }
 }"
41719,"/** 
 * @param userName
 * @param password
 * @return a QueueConnection
 * @throws JMSException
 * @see javax.jms.QueueConnectionFactory#createQueueConnection(java.lang.String,java.lang.String)
 */
@Override public QueueConnection createQueueConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsQueueConnection result=new JmsQueueConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}","/** 
 * @param username
 * @param password
 * @return a QueueConnection
 * @throws JMSException
 * @see javax.jms.QueueConnectionFactory#createQueueConnection(java.lang.String,java.lang.String)
 */
@Override public QueueConnection createQueueConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsQueueConnection result=new JmsQueueConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}"
41720,"/** 
 * @param userName
 * @param password
 * @return a TopicConnection
 * @throws JMSException
 * @see javax.jms.TopicConnectionFactory#createTopicConnection(java.lang.String,java.lang.String)
 */
@Override public TopicConnection createTopicConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsTopicConnection result=new JmsTopicConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}","/** 
 * @param username
 * @param password
 * @return a TopicConnection
 * @throws JMSException
 * @see javax.jms.TopicConnectionFactory#createTopicConnection(java.lang.String,java.lang.String)
 */
@Override public TopicConnection createTopicConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsTopicConnection result=new JmsTopicConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}"
41721,"/** 
 * @param userName
 * @param password
 * @return Connection
 * @throws JMSException
 * @see javax.jms.ConnectionFactory#createConnection(java.lang.String,java.lang.String)
 */
@Override public Connection createConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsConnection result=new JmsConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}","/** 
 * @param username
 * @param password
 * @return Connection
 * @throws JMSException
 * @see javax.jms.ConnectionFactory#createConnection(java.lang.String,java.lang.String)
 */
@Override public Connection createConnection(String username,String password) throws JMSException {
  try {
    String connectionId=getConnectionIdGenerator().generateId();
    Provider provider=createProvider(brokerURI);
    JmsConnection result=new JmsConnection(connectionId,provider,getClientIdGenerator());
    return configureConnection(result,username,password);
  }
 catch (  Exception e) {
    throw JmsExceptionSupport.create(e);
  }
}"
41722,"/** 
 * Adds the given Transaction synchronization to the current list.
 * @param synchronization the transaction synchronization to add.
 */
public void addSynchronization(JmsTxSynchronization s){
  if (synchronizations == null) {
    synchronizations=new ArrayList<JmsTxSynchronization>(10);
  }
  synchronizations.add(s);
}","/** 
 * Adds the given Transaction synchronization to the current list.
 * @param s the transaction synchronization to add.
 */
public void addSynchronization(JmsTxSynchronization s){
  if (synchronizations == null) {
    synchronizations=new ArrayList<JmsTxSynchronization>(10);
  }
  synchronizations.add(s);
}"
41723,"/** 
 * Called from the session when a new Message has been dispatched to this Consumer from the connection.
 * @param facade the newly arrived message.
 */
@Override public void onMessage(final JmsInboundMessageDispatch envelope){
  lock.lock();
  try {
    if (acknowledgementMode == Session.CLIENT_ACKNOWLEDGE) {
      envelope.getMessage().setAcknowledgeCallback(new Callable<Void>(){
        @Override public Void call() throws Exception {
          if (session.isClosed()) {
            throw new javax.jms.IllegalStateException(""String_Node_Str"");
          }
          session.acknowledge();
          return null;
        }
      }
);
    }
    this.messageQueue.enqueue(envelope);
  }
  finally {
    lock.unlock();
  }
  if (this.messageListener != null && this.started) {
    session.getExecutor().execute(new Runnable(){
      @Override public void run(){
        JmsInboundMessageDispatch envelope;
        while (session.isStarted() && (envelope=messageQueue.dequeueNoWait()) != null) {
          try {
            messageListener.onMessage(copy(ack(envelope)));
          }
 catch (          Exception e) {
            session.getConnection().onException(e);
          }
        }
      }
    }
);
  }
 else {
    if (availableListener != null) {
      availableListener.onMessageAvailable(this);
    }
  }
}","/** 
 * Called from the session when a new Message has been dispatched to this Consumer from the connection.
 * @param envelope the newly arrived message.
 */
@Override public void onMessage(final JmsInboundMessageDispatch envelope){
  lock.lock();
  try {
    if (acknowledgementMode == Session.CLIENT_ACKNOWLEDGE) {
      envelope.getMessage().setAcknowledgeCallback(new Callable<Void>(){
        @Override public Void call() throws Exception {
          if (session.isClosed()) {
            throw new javax.jms.IllegalStateException(""String_Node_Str"");
          }
          session.acknowledge();
          return null;
        }
      }
);
    }
    this.messageQueue.enqueue(envelope);
  }
  finally {
    lock.unlock();
  }
  if (this.messageListener != null && this.started) {
    session.getExecutor().execute(new Runnable(){
      @Override public void run(){
        JmsInboundMessageDispatch envelope;
        while (session.isStarted() && (envelope=messageQueue.dequeueNoWait()) != null) {
          try {
            messageListener.onMessage(copy(ack(envelope)));
          }
 catch (          Exception e) {
            session.getConnection().onException(e);
          }
        }
      }
    }
);
  }
 else {
    if (availableListener != null) {
      availableListener.onMessageAvailable(this);
    }
  }
}"
41724,"/** 
 * Waits for a response to some Provider requested operation.
 * @return the response from the Provider for this operation.
 * @throws IOException if an error occurs while waiting for the response.
 */
public void sync() throws IOException {
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw IOExceptionSupport.create(e);
  }
  failOnError();
}","/** 
 * Waits for a response to some Provider requested operation.
 * @throws IOException if an error occurs while waiting for the response.
 */
public void sync() throws IOException {
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    throw IOExceptionSupport.create(e);
  }
  failOnError();
}"
41725,"/** 
 * Creates a new AmqpTransaction instance.
 * @param session The session that owns this transaction
 * @param resource The JmsTransactionInfo that defines this Transaction.
 */
public AmqpTransactionContext(AmqpSession session){
  super(session.getJmsResource());
  this.session=session;
}","/** 
 * Creates a new AmqpTransaction instance.
 * @param session The session that owns this transaction
 */
public AmqpTransactionContext(AmqpSession session){
  super(session.getJmsResource());
  this.session=session;
}"
41726,"/** 
 * When used as a pooled cache of tags the unused tags should always be returned once the transfer has been settled.
 * @param tag a previously borrowed tag that is no longer in use.
 */
public void returnTag(byte[] data){
  if (tagPool != null && tagPool.size() < maxPoolSize) {
    tagPool.add(data);
  }
}","/** 
 * When used as a pooled cache of tags the unused tags should always be returned once the transfer has been settled.
 * @param data a previously borrowed tag that is no longer in use.
 */
public void returnTag(byte[] data){
  if (tagPool != null && tagPool.size() < maxPoolSize) {
    tagPool.add(data);
  }
}"
41727,"/** 
 * The AmqpConnection instance that is associated with this Message.
 * @return
 */
public AmqpConnection getConnection(){
  return connection;
}","/** 
 * The AmqpConnection instance that is associated with this Message.
 * @return the connection
 */
public AmqpConnection getConnection(){
  return connection;
}"
41728,"/** 
 * Returns the suffix of the given string after removing the first ""ID:"" prefix (if present).
 * @param string the string to process
 * @return the suffix, or the original String if the ""ID:"" prefix is not present
 */
public String stripMessageIdPrefix(String id){
  if (hasMessageIdPrefix(id)) {
    return strip(id,JMS_ID_PREFIX_LENGTH);
  }
 else {
    return id;
  }
}","/** 
 * Returns the suffix of the given string after removing the first ""ID:"" prefix (if present).
 * @param id the string to process
 * @return the suffix, or the original String if the ""ID:"" prefix is not present
 */
public String stripMessageIdPrefix(String id){
  if (hasMessageIdPrefix(id)) {
    return strip(id,JMS_ID_PREFIX_LENGTH);
  }
 else {
    return id;
  }
}"
41729,"/** 
 * Create an instance of the SSL transport
 * @param listener The TransportListener that will handle events from this Transport instance.
 * @param remoteLocation The location that is being connected to.
 * @param JmsSslContext The JMS Framework SslContext to use for this SSL connection.
 */
public SslTransport(TransportListener listener,URI remoteLocation,JmsSslContext context){
  super(listener,remoteLocation);
  this.context=context;
}","/** 
 * Create an instance of the SSL transport
 * @param listener The TransportListener that will handle events from this Transport instance.
 * @param remoteLocation The location that is being connected to.
 * @param context The JMS Framework SslContext to use for this SSL connection.
 */
public SslTransport(TransportListener listener,URI remoteLocation,JmsSslContext context){
  super(listener,remoteLocation);
  this.context=context;
}"
41730,"/** 
 * Given a map of properties, filter out only those prefixed with the given value, the values filtered are returned in a new Map instance.
 * @param properties The map of properties to filter.
 * @param optionPrefix The prefix value to use when filtering.
 * @return a filter map with only values that match the given prefix.
 */
public static Map<String,String> filterProperties(Map<String,String> props,String optionPrefix){
  if (props == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HashMap<String,String> rc=new HashMap<String,String>(props.size());
  for (Iterator<Entry<String,String>> iter=props.entrySet().iterator(); iter.hasNext(); ) {
    Entry<String,String> entry=iter.next();
    if (entry.getKey().startsWith(optionPrefix)) {
      String name=entry.getKey().substring(optionPrefix.length());
      rc.put(name,entry.getValue());
      iter.remove();
    }
  }
  return rc;
}","/** 
 * Given a map of properties, filter out only those prefixed with the given value, the values filtered are returned in a new Map instance.
 * @param props The map of properties to filter.
 * @param optionPrefix The prefix value to use when filtering.
 * @return a filter map with only values that match the given prefix.
 */
public static Map<String,String> filterProperties(Map<String,String> props,String optionPrefix){
  if (props == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HashMap<String,String> rc=new HashMap<String,String>(props.size());
  for (Iterator<Entry<String,String>> iter=props.entrySet().iterator(); iter.hasNext(); ) {
    Entry<String,String> entry=iter.next();
    if (entry.getKey().startsWith(optionPrefix)) {
      String name=entry.getKey().substring(optionPrefix.length());
      rc.put(name,entry.getValue());
      iter.remove();
    }
  }
  return rc;
}"
41731,"/** 
 * Creates a URI with the given query, removing an previous query value from the given URI.
 * @param uri The source URI whose existing query is replaced with the newly supplied one.
 * @param query The new URI query string that should be appended to the given URI.
 * @return a new URI that is a combination of the original URI and the given query string.
 * @throws URISyntaxException
 */
public static URI eraseQuery(URI uri) throws URISyntaxException {
  return replaceQuery(uri,(String)null);
}","/** 
 * Creates a URI with the given query, removing an previous query value from the given URI.
 * @param uri The source URI whose existing query is replaced with the newly supplied one.
 * @return a new URI that is a combination of the original URI and the given query string.
 * @throws URISyntaxException
 */
public static URI eraseQuery(URI uri) throws URISyntaxException {
  return replaceQuery(uri,(String)null);
}"
41732,"/** 
 * Test that a message received from the test peer with an AmqpValue section containing Binary and no content type is returned as a BytesMessage, verify it gives the expected data values when read, and when sent to the test peer it results in an AMQP message containing a data body section and content type of  {@link AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE}
 */
@Test(timeout=5000) public void testReceiveBytesMessageWithAmqpValueAndResendResultsInData() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }","/** 
 * Test that a message received from the test peer with an AmqpValue section containing Binary and no content type is returned as a BytesMessage, verify it gives the expected data values when read, and when sent to the test peer it results in an AMQP message containing a data body section and content type of  {@link AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE}
 */
@Test(timeout=5000) public void testReceiveBytesMessageWithAmqpValueAndResendResultsInData() throws Exception {
  try (TestAmqpPeer testPeer=new TestAmqpPeer(IntegrationTestFixture.PORT)){
    Connection connection=testFixture.establishConnecton(testPeer);
    connection.start();
    testPeer.expectBegin(true);
    Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
    Queue queue=session.createQueue(""String_Node_Str"");
    boolean myBool=true;
    byte myByte=4;
    byte[] myBytes=""String_Node_Str"".getBytes();
    char myChar='d';
    double myDouble=1234567890123456789.1234;
    float myFloat=1.1F;
    int myInt=Integer.MAX_VALUE;
    long myLong=Long.MAX_VALUE;
    short myShort=25;
    String myUTF=""String_Node_Str"";
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeBoolean(myBool);
    dos.writeByte(myByte);
    dos.write(myBytes);
    dos.writeChar(myChar);
    dos.writeDouble(myDouble);
    dos.writeFloat(myFloat);
    dos.writeInt(myInt);
    dos.writeLong(myLong);
    dos.writeShort(myShort);
    dos.writeUTF(myUTF);
    byte[] bytesPayload=baos.toByteArray();
    Binary binaryPayload=new Binary(bytesPayload);
    DescribedType amqpValueSectionContent=new AmqpValueDescribedType(binaryPayload);
    testPeer.expectReceiverAttach();
    testPeer.expectLinkFlowRespondWithTransfer(null,null,null,null,amqpValueSectionContent);
    testPeer.expectDispositionThatIsAcceptedAndSettled();
    MessageConsumer messageConsumer=session.createConsumer(queue);
    Message receivedMessage=messageConsumer.receive(1000);
    testPeer.waitForAllHandlersToComplete(3000);
    assertNotNull(""String_Node_Str"",receivedMessage);
    assertTrue(""String_Node_Str"",receivedMessage instanceof BytesMessage);
    BytesMessage receivedBytesMessage=(BytesMessage)receivedMessage;
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    assertEquals(""String_Node_Str"",myByte,receivedBytesMessage.readByte());
    byte[] readBytes=new byte[myBytes.length];
    assertEquals(""String_Node_Str"",myBytes.length,receivedBytesMessage.readBytes(readBytes));
    assertTrue(""String_Node_Str"" + Arrays.toString(readBytes),Arrays.equals(myBytes,readBytes));
    assertEquals(""String_Node_Str"",myChar,receivedBytesMessage.readChar());
    assertEquals(""String_Node_Str"",myDouble,receivedBytesMessage.readDouble(),0.0);
    assertEquals(""String_Node_Str"",myFloat,receivedBytesMessage.readFloat(),0.0);
    assertEquals(""String_Node_Str"",myInt,receivedBytesMessage.readInt());
    assertEquals(""String_Node_Str"",myLong,receivedBytesMessage.readLong());
    assertEquals(""String_Node_Str"",myShort,receivedBytesMessage.readShort());
    assertEquals(""String_Node_Str"",myUTF,receivedBytesMessage.readUTF());
    receivedBytesMessage.reset();
    assertEquals(""String_Node_Str"",myBool,receivedBytesMessage.readBoolean());
    testPeer.expectSenderAttach();
    MessageProducer producer=session.createProducer(queue);
    MessageHeaderSectionMatcher headersMatcher=new MessageHeaderSectionMatcher(true);
    MessageAnnotationsSectionMatcher msgAnnotationsMatcher=new MessageAnnotationsSectionMatcher(true);
    msgAnnotationsMatcher.withEntry(Symbol.valueOf(AmqpMessageSupport.JMS_MSG_TYPE),equalTo(AmqpMessageSupport.JMS_BYTES_MESSAGE));
    MessagePropertiesSectionMatcher propsMatcher=new MessagePropertiesSectionMatcher(true);
    propsMatcher.withContentType(equalTo(Symbol.valueOf(AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE)));
    TransferPayloadCompositeMatcher messageMatcher=new TransferPayloadCompositeMatcher();
    messageMatcher.setHeadersMatcher(headersMatcher);
    messageMatcher.setMessageAnnotationsMatcher(msgAnnotationsMatcher);
    messageMatcher.setPropertiesMatcher(propsMatcher);
    messageMatcher.setMessageContentMatcher(new EncodedDataMatcher(binaryPayload));
    testPeer.expectTransfer(messageMatcher);
    producer.send(receivedBytesMessage);
    testPeer.waitForAllHandlersToComplete(3000);
  }
 }"
41733,"/** 
 * Verify that when   {@link BytesMessage#readBytes(byte[], int))} is calledwith a length that is greater than the size of the provided array, an  {@link IndexOutOfBoundsException} is thrown.
 */
@Test(expected=IndexOutOfBoundsException.class) public void testReadBytesWithLengthGreatThanArraySizeThrowsIOOBE() throws Exception {
  JmsBytesMessage bytesMessage=factory.createBytesMessage();
  bytesMessage.reset();
  bytesMessage.readBytes(new byte[1],2);
}","/** 
 * Verify that when   {@link BytesMessage#readBytes(byte[],int)} is calledwith a length that is greater than the size of the provided array, an  {@link IndexOutOfBoundsException} is thrown.
 */
@Test(expected=IndexOutOfBoundsException.class) public void testReadBytesWithLengthGreatThanArraySizeThrowsIOOBE() throws Exception {
  JmsBytesMessage bytesMessage=factory.createBytesMessage();
  bytesMessage.reset();
  bytesMessage.readBytes(new byte[1],2);
}"
41734,"/** 
 * Verify that when   {@link BytesMessage#readBytes(byte[], int))} is calledwith a negative length that an  {@link IndexOutOfBoundsException} is thrown.
 */
@Test(expected=IndexOutOfBoundsException.class) public void testReadBytesWithNegativeLengthThrowsIOOBE() throws Exception {
  JmsBytesMessage bytesMessage=factory.createBytesMessage();
  bytesMessage.reset();
  bytesMessage.readBytes(new byte[0],-1);
}","/** 
 * Verify that when   {@link BytesMessage#readBytes(byte[],int)} is calledwith a negative length that an  {@link IndexOutOfBoundsException} is thrown.
 */
@Test(expected=IndexOutOfBoundsException.class) public void testReadBytesWithNegativeLengthThrowsIOOBE() throws Exception {
  JmsBytesMessage bytesMessage=factory.createBytesMessage();
  bytesMessage.reset();
  bytesMessage.readBytes(new byte[0],-1);
}"
41735,"/** 
 * Test that calling   {@link ObjectMessage#clearBody()} of a received messagecauses the body of the underlying  {@link AmqpObjectMessage} to be emptied.
 */
@Test public void testClearBodyOnReceivedObjectMessageClearsUnderlyingMessageBody() throws Exception {
  String content=""String_Node_Str"";
  JmsDefaultObjectMessageFacade facade=new JmsDefaultObjectMessageFacade();
  facade.setObject(content);
  JmsObjectMessage objectMessage=new JmsObjectMessage(facade);
  objectMessage.onDispatch();
  assertNotNull(""String_Node_Str"",facade.getSerializedObject());
  objectMessage.clearBody();
  assertNull(""String_Node_Str"",objectMessage.getObject());
  assertNull(""String_Node_Str"",facade.getSerializedObject());
}","/** 
 * Test that calling   {@link ObjectMessage#clearBody()} of a received messagecauses the body of the underlying message facade to be emptied.
 */
@Test public void testClearBodyOnReceivedObjectMessageClearsUnderlyingMessageBody() throws Exception {
  String content=""String_Node_Str"";
  JmsDefaultObjectMessageFacade facade=new JmsDefaultObjectMessageFacade();
  facade.setObject(content);
  JmsObjectMessage objectMessage=new JmsObjectMessage(facade);
  objectMessage.onDispatch();
  assertNotNull(""String_Node_Str"",facade.getSerializedObject());
  objectMessage.clearBody();
  assertNull(""String_Node_Str"",objectMessage.getObject());
  assertNull(""String_Node_Str"",facade.getSerializedObject());
}"
41736,"/** 
 * Test that a message with the   {@value AmqpMessageSupport#JMS_MSG_TYPE}annotation set to    {@value AmqpMessageSupport#JMS_OBJECT_MESSAGE} andcontent-type set to  {@value AmqpMessageSupport.OCTET_STREAM_CONTENT_TYPE} istreated as a  {@link JmsObjectMessage} with {@link AmqpJmsObjectMessageFacade}containing a   {@link AmqpSerializedObjectDelegate}.
 */
@Test public void testCreateObjectMessageFromMessageTypeAnnotation() throws Exception {
  createObjectMessageFromMessageTypeAnnotationTestImpl(true);
}","/** 
 * Test that a message with the   {@value AmqpMessageSupport#JMS_MSG_TYPE}annotation set to    {@value AmqpMessageSupport#JMS_OBJECT_MESSAGE} andcontent-type set to  {@value AmqpMessageSupport#OCTET_STREAM_CONTENT_TYPE} istreated as a  {@link JmsObjectMessage} with {@link AmqpJmsObjectMessageFacade}containing a   {@link AmqpSerializedObjectDelegate}.
 */
@Test public void testCreateObjectMessageFromMessageTypeAnnotation() throws Exception {
  createObjectMessageFromMessageTypeAnnotationTestImpl(true);
}"
41737,"/** 
 * Test that   {@link MessageImpl#getJMSType()} returns the expected value for a messagereceived with the  {@link ClientProperties#X_OPT_JMS_TYPE} message annotation set.
 */
@Test public void testGetJMSTypeWithReceivedMessage() throws Exception {
  String myJMSType=""String_Node_Str"";
  Message message=Proton.message();
  Map<Symbol,Object> annotationsMap=new HashMap<Symbol,Object>();
  annotationsMap.put(Symbol.valueOf(AmqpMessageSupport.JMS_TYPE),myJMSType);
  message.setMessageAnnotations(new MessageAnnotations(annotationsMap));
  AmqpJmsMessageFacade amqpMessageFacade=createReceivedMessageFacade(createMockAmqpConsumer(),message);
  assertEquals(""String_Node_Str"",myJMSType,amqpMessageFacade.getType());
}","/** 
 * Test that   {@link AmqpJmsMessageFacade#getType()} returns the expected value for a messagereceived with the  {@link AmqpMessageSupport#JMS_TYPE} message annotation set.
 */
@Test public void testGetJMSTypeWithReceivedMessage() throws Exception {
  String myJMSType=""String_Node_Str"";
  Message message=Proton.message();
  Map<Symbol,Object> annotationsMap=new HashMap<Symbol,Object>();
  annotationsMap.put(Symbol.valueOf(AmqpMessageSupport.JMS_TYPE),myJMSType);
  message.setMessageAnnotations(new MessageAnnotations(annotationsMap));
  AmqpJmsMessageFacade amqpMessageFacade=createReceivedMessageFacade(createMockAmqpConsumer(),message);
  assertEquals(""String_Node_Str"",myJMSType,amqpMessageFacade.getType());
}"
41738,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded binary when given a Binary object.
 */
@Test public void testToBaseMessageIdStringWithBinary(){
  byte[] bytes=new byte[]{(byte)0x00,(byte)0xAB,(byte)0x09,(byte)0xFF};
  Binary binary=new Binary(bytes);
  String expected=AmqpMessageIdHelper.AMQP_BINARY_PREFIX + ""String_Node_Str"";
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(binary);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded binary when given a Binary object.
 */
@Test public void testToBaseMessageIdStringWithBinary(){
  byte[] bytes=new byte[]{(byte)0x00,(byte)0xAB,(byte)0x09,(byte)0xFF};
  Binary binary=new Binary(bytes);
  String expected=AmqpMessageIdHelper.AMQP_BINARY_PREFIX + ""String_Node_Str"";
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(binary);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41739,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns the givenbasic string unchanged
 */
@Test public void testToBaseMessageIdStringWithString(){
  String stringMessageId=""String_Node_Str"";
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(stringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",stringMessageId,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns the givenbasic string unchanged
 */
@Test public void testToBaseMessageIdStringWithString(){
  String stringMessageId=""String_Node_Str"";
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(stringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",stringMessageId,baseMessageIdString);
}"
41740,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_UUID_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForUUID(){
  String uuidStringMessageId=AmqpMessageIdHelper.AMQP_UUID_PREFIX + UUID.randomUUID();
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + uuidStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uuidStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_UUID_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForUUID(){
  String uuidStringMessageId=AmqpMessageIdHelper.AMQP_UUID_PREFIX + UUID.randomUUID();
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + uuidStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uuidStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41741,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded ulong when given a UnsignedLong object.
 */
@Test public void testToBaseMessageIdStringWithUnsignedLong(){
  UnsignedLong uLongMessageId=UnsignedLong.valueOf(123456789L);
  String expected=AmqpMessageIdHelper.AMQP_ULONG_PREFIX + uLongMessageId.toString();
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uLongMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded ulong when given a UnsignedLong object.
 */
@Test public void testToBaseMessageIdStringWithUnsignedLong(){
  UnsignedLong uLongMessageId=UnsignedLong.valueOf(123456789L);
  String expected=AmqpMessageIdHelper.AMQP_ULONG_PREFIX + uLongMessageId.toString();
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uLongMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41742,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_BINARY_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForBinary(){
  String binaryStringMessageId=AmqpMessageIdHelper.AMQP_BINARY_PREFIX + ""String_Node_Str"";
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + binaryStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(binaryStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_BINARY_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForBinary(){
  String binaryStringMessageId=AmqpMessageIdHelper.AMQP_BINARY_PREFIX + ""String_Node_Str"";
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + binaryStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(binaryStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41743,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} throws an IAE if given an unexpected object type.
 */
@Test public void testToBaseMessageIdStringThrowsIAEWithUnexpectedType(){
  try {
    _messageIdHelper.toBaseMessageIdString(new Object());
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException iae) {
  }
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} throws an IAE if given an unexpected object type.
 */
@Test public void testToBaseMessageIdStringThrowsIAEWithUnexpectedType(){
  try {
    _messageIdHelper.toBaseMessageIdString(new Object());
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException iae) {
  }
}"
41744,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded UUID when given a UUID object.
 */
@Test public void testToBaseMessageIdStringWithUUID(){
  UUID uuidMessageId=UUID.randomUUID();
  String expected=AmqpMessageIdHelper.AMQP_UUID_PREFIX + uuidMessageId.toString();
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uuidMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded UUID when given a UUID object.
 */
@Test public void testToBaseMessageIdStringWithUUID(){
  UUID uuidMessageId=UUID.randomUUID();
  String expected=AmqpMessageIdHelper.AMQP_UUID_PREFIX + uuidMessageId.toString();
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(uuidMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41745,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_ULONG_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForLong(){
  String longStringMessageId=AmqpMessageIdHelper.AMQP_ULONG_PREFIX + Long.valueOf(123456789L);
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + longStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(longStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded string, when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_ULONG_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForLong(){
  String longStringMessageId=AmqpMessageIdHelper.AMQP_ULONG_PREFIX + Long.valueOf(123456789L);
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + longStringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(longStringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41746,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns a stringindicating an AMQP encoded string (effectively twice), when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_STRING_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForString(){
  String stringMessageId=AmqpMessageIdHelper.AMQP_STRING_PREFIX + ""String_Node_Str"";
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + stringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(stringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns a stringindicating an AMQP encoded string (effectively twice), when the given string happens to already begin with the  {@link AmqpMessageIdHelper#AMQP_STRING_PREFIX}.
 */
@Test public void testToBaseMessageIdStringWithStringBeginningWithEncodingPrefixForString(){
  String stringMessageId=AmqpMessageIdHelper.AMQP_STRING_PREFIX + ""String_Node_Str"";
  String expected=AmqpMessageIdHelper.AMQP_STRING_PREFIX + stringMessageId;
  String baseMessageIdString=_messageIdHelper.toBaseMessageIdString(stringMessageId);
  assertNotNull(""String_Node_Str"",baseMessageIdString);
  assertEquals(""String_Node_Str"",expected,baseMessageIdString);
}"
41747,"/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(String)} returns null if given null
 */
@Test public void testToBaseMessageIdStringWithNull(){
  String nullString=null;
  assertNull(""String_Node_Str"",_messageIdHelper.toBaseMessageIdString(nullString));
}","/** 
 * Test that   {@link AmqpMessageIdHelper#toBaseMessageIdString(Object)} returns null if given null
 */
@Test public void testToBaseMessageIdStringWithNull(){
  String nullString=null;
  assertNull(""String_Node_Str"",_messageIdHelper.toBaseMessageIdString(nullString));
}"
41748,"@Ignore @Test(timeout=60000) public void testAnonymousSendToTopic() throws Exception {
  connection=createAmqpConnection();
  assertNotNull(connection);
  connection.start();
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Topic topic=session.createTopic(name.getMethodName());
  assertNotNull(session);
  MessageProducer producer=session.createProducer(null);
  assertNotNull(producer);
  MessageConsumer consumer=session.createConsumer(topic);
  assertNotNull(consumer);
  Message message=session.createMessage();
  producer.send(topic,message);
  TopicViewMBean proxy=getProxyToTopic(name.getMethodName());
  assertEquals(1,proxy.getEnqueueCount());
}","@Test(timeout=60000) public void testAnonymousSendToTopic() throws Exception {
  connection=createAmqpConnection();
  assertNotNull(connection);
  connection.start();
  Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Topic topic=session.createTopic(name.getMethodName());
  assertNotNull(session);
  MessageProducer producer=session.createProducer(null);
  assertNotNull(producer);
  MessageConsumer consumer=session.createConsumer(topic);
  assertNotNull(consumer);
  Message message=session.createMessage();
  producer.send(topic,message);
  TopicViewMBean proxy=getProxyToTopic(name.getMethodName());
  assertEquals(1,proxy.getEnqueueCount());
}"
41749,"protected void setConnectionIdGenerator(IdGenerator connectionIdGenerator){
  this.connectionIdGenerator=connectionIdGenerator;
}","protected synchronized void setConnectionIdGenerator(IdGenerator connectionIdGenerator){
  this.connectionIdGenerator=connectionIdGenerator;
}"
41750,"protected void setClientIdGenerator(IdGenerator clientIdGenerator){
  this.clientIdGenerator=clientIdGenerator;
}","protected synchronized void setClientIdGenerator(IdGenerator clientIdGenerator){
  this.clientIdGenerator=clientIdGenerator;
}"
41751,"/** 
 * Sets the prefix used by auto-generated JMS Client ID values which are used if the JMS client does not explicitly specify on.
 * @param clientIDPrefix
 */
public void setClientIDPrefix(String clientIDPrefix){
  this.clientIDPrefix=clientIDPrefix;
}","/** 
 * Sets the prefix used by auto-generated JMS Client ID values which are used if the JMS client does not explicitly specify on.
 * @param clientIDPrefix
 */
public synchronized void setClientIDPrefix(String clientIDPrefix){
  this.clientIDPrefix=clientIDPrefix;
}"
41752,"public String getClientIDPrefix(){
  return clientIDPrefix;
}","public synchronized String getClientIDPrefix(){
  return clientIDPrefix;
}"
41753,"/** 
 * Sets the prefix used by connection id generator.
 * @param connectionIDPrefix The string prefix used on all connection Id's created by this factory.
 */
public void setConnectionIDPrefix(String connectionIDPrefix){
  this.connectionIDPrefix=connectionIDPrefix;
}","/** 
 * Sets the prefix used by connection id generator.
 * @param connectionIDPrefix The string prefix used on all connection Id's created by this factory.
 */
public synchronized void setConnectionIDPrefix(String connectionIDPrefix){
  this.connectionIDPrefix=connectionIDPrefix;
}"
41754,"@Override public void close(){
  if (closed.compareAndSet(false,true)) {
    final ProviderFuture request=new ProviderFuture();
    serializer.execute(new Runnable(){
      @Override public void run(){
        try {
          if (!transport.isConnected()) {
            request.onSuccess();
          }
          if (connection != null) {
            connection.close(request);
          }
 else {
            request.onSuccess();
          }
          pumpToProtonTransport();
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"");
        }
      }
    }
);
    try {
      if (closeTimeout < 0) {
        request.sync();
      }
 else {
        request.sync(closeTimeout,TimeUnit.MILLISECONDS);
      }
    }
 catch (    IOException e) {
      LOG.warn(""String_Node_Str"",e.getMessage());
    }
 finally {
      if (transport != null) {
        try {
          transport.close();
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"",e.getMessage());
        }
      }
      if (serializer != null) {
        serializer.shutdown();
      }
    }
  }
}","@Override public void close(){
  if (closed.compareAndSet(false,true)) {
    final ProviderFuture request=new ProviderFuture();
    serializer.execute(new Runnable(){
      @Override public void run(){
        try {
          if (!transport.isConnected()) {
            request.onSuccess();
          }
          if (connection != null) {
            connection.close(request);
          }
 else {
            request.onSuccess();
          }
          pumpToProtonTransport();
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"");
        }
      }
    }
);
    try {
      if (closeTimeout < 0) {
        request.sync();
      }
 else {
        request.sync(closeTimeout,TimeUnit.MILLISECONDS);
      }
    }
 catch (    IOException e) {
      LOG.warn(""String_Node_Str"",e.getMessage());
    }
 finally {
      if (transport != null) {
        try {
          transport.close();
        }
 catch (        Exception e) {
          LOG.debug(""String_Node_Str"",e.getMessage());
        }
      }
      serializer.shutdown();
    }
  }
}"
41755,"/** 
 * Get properties from a uri
 * @param uri
 * @return <Code>Map</Code> of properties
 * @throws Exception
 */
public static Map<String,String> parseQuery(String uri) throws Exception {
  if (uri != null) {
    Map<String,String> rc=new HashMap<String,String>();
    if (uri != null) {
      String[] parameters=uri.split(""String_Node_Str"");
      for (int i=0; i < parameters.length; i++) {
        int p=parameters[i].indexOf(""String_Node_Str"");
        if (p >= 0) {
          String name=URLDecoder.decode(parameters[i].substring(0,p),""String_Node_Str"");
          String value=URLDecoder.decode(parameters[i].substring(p + 1),""String_Node_Str"");
          rc.put(name,value);
        }
 else {
          rc.put(parameters[i],null);
        }
      }
    }
    return rc;
  }
  return Collections.emptyMap();
}","/** 
 * Get properties from a uri
 * @param uri
 * @return <Code>Map</Code> of properties
 * @throws Exception
 */
public static Map<String,String> parseQuery(String uri) throws Exception {
  if (uri != null) {
    Map<String,String> rc=new HashMap<String,String>();
    String[] parameters=uri.split(""String_Node_Str"");
    for (int i=0; i < parameters.length; i++) {
      int p=parameters[i].indexOf(""String_Node_Str"");
      if (p >= 0) {
        String name=URLDecoder.decode(parameters[i].substring(0,p),""String_Node_Str"");
        String value=URLDecoder.decode(parameters[i].substring(p + 1),""String_Node_Str"");
        rc.put(name,value);
      }
 else {
        rc.put(parameters[i],null);
      }
    }
    return rc;
  }
  return Collections.emptyMap();
}"
41756,"@Override public boolean equals(Object o){
  ConversionKey x=(ConversionKey)o;
  return x.from == from && x.to == to;
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || o.getClass() != this.getClass()) {
    return false;
  }
  ConversionKey x=(ConversionKey)o;
  return x.from == from && x.to == to;
}"
41757,"static public Class loadClass(Properties properties) throws ClassNotFoundException, IOException {
  String className=properties.getProperty(""String_Node_Str"");
  if (className == null) {
    throw new IOException(""String_Node_Str"");
  }
  Class clazz=null;
  ClassLoader loader=Thread.currentThread().getContextClassLoader();
  if (loader != null) {
    try {
      clazz=loader.loadClass(className);
    }
 catch (    ClassNotFoundException e) {
    }
  }
  if (clazz == null) {
    clazz=FactoryFinder.class.getClassLoader().loadClass(className);
  }
  return clazz;
}","static public Class<?> loadClass(Properties properties) throws ClassNotFoundException, IOException {
  String className=properties.getProperty(""String_Node_Str"");
  if (className == null) {
    throw new IOException(""String_Node_Str"");
  }
  Class<?> clazz=null;
  ClassLoader loader=Thread.currentThread().getContextClassLoader();
  if (loader != null) {
    try {
      clazz=loader.loadClass(className);
    }
 catch (    ClassNotFoundException e) {
    }
  }
  if (clazz == null) {
    clazz=FactoryFinder.class.getClassLoader().loadClass(className);
  }
  return clazz;
}"
41758,"@Override public Object create(final String path) throws InstantiationException, IllegalAccessException, ClassNotFoundException, IOException {
  Class clazz=classMap.get(path);
  if (clazz == null) {
    clazz=loadClass(loadProperties(path));
    classMap.put(path,clazz);
  }
  return clazz.newInstance();
}","@Override public Object create(final String path) throws InstantiationException, IllegalAccessException, ClassNotFoundException, IOException {
  Class<?> clazz=classMap.get(path);
  if (clazz == null) {
    clazz=loadClass(loadProperties(path));
    Class<?> previous=classMap.putIfAbsent(path,clazz);
    if (previous != null) {
      clazz=previous;
    }
  }
  return clazz.newInstance();
}"
41759,"/** 
 * Creates a new instance of the given key.  The method first checks the cache of previously found factory instances for one that matches the key.  If no cached version exists then the factory will be searched for using the configured ObjectFactory instance.
 * @param key is the key to add to the path to find a text file containing the factory name
 * @return a newly created instance
 * @throws IllegalAccessException if an error occurs while accessing the search path.
 * @throws InstantiationException if the factory object fails on create.
 * @throws IOException if the search encounter an IO error.
 * @throws ClassNotFoundException if the class that is to be loaded cannot be found.
 * @throws ClassCastException if the found object is not assignable to the request factory type.
 */
public T newInstance(String key) throws IllegalAccessException, InstantiationException, IOException, ClassNotFoundException, ClassCastException {
  T factory=cachedFactories.get(key);
  if (factory == null) {
    Object found=objectFactory.create(path + key);
    if (found != null && factoryType.isInstance(found)) {
      factory=factoryType.cast(found);
      cachedFactories.put(key,factory);
    }
 else {
      throw new ClassCastException(""String_Node_Str"" + found.getClass().getName() + ""String_Node_Str""+ factoryType.getName());
    }
  }
  return factory;
}","/** 
 * Creates a new instance of the given key.  The method first checks the cache of previously found factory instances for one that matches the key.  If no cached version exists then the factory will be searched for using the configured ObjectFactory instance.
 * @param key is the key to add to the path to find a text file containing the factory name
 * @return a newly created instance
 * @throws IllegalAccessException if an error occurs while accessing the search path.
 * @throws InstantiationException if the factory object fails on create.
 * @throws IOException if the search encounter an IO error.
 * @throws ClassNotFoundException if the class that is to be loaded cannot be found.
 * @throws ClassCastException if the found object is not assignable to the request factory type.
 */
public T newInstance(String key) throws IllegalAccessException, InstantiationException, IOException, ClassNotFoundException, ClassCastException {
  T factory=cachedFactories.get(key);
  if (factory == null) {
    Object found=objectFactory.create(path + key);
    if (found != null) {
      if (factoryType.isInstance(found)) {
        factory=factoryType.cast(found);
        cachedFactories.putIfAbsent(key,factory);
      }
 else {
        throw new ClassCastException(""String_Node_Str"" + found.getClass().getName() + ""String_Node_Str""+ factoryType.getName());
      }
    }
 else {
      throw new ClassNotFoundException(""String_Node_Str"" + key);
    }
  }
  return factory;
}"
41760,"static public Properties loadProperties(String uri) throws IOException {
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  if (classLoader == null) {
    classLoader=StandaloneObjectFactory.class.getClassLoader();
  }
  InputStream in=classLoader.getResourceAsStream(uri);
  if (in == null) {
    in=FactoryFinder.class.getClassLoader().getResourceAsStream(uri);
    if (in == null) {
      throw new IOException(""String_Node_Str"" + uri);
    }
  }
  BufferedInputStream reader=null;
  try {
    reader=new BufferedInputStream(in);
    Properties properties=new Properties();
    properties.load(reader);
    return properties;
  }
  finally {
    try {
      reader.close();
    }
 catch (    Exception e) {
    }
  }
}","static public Properties loadProperties(String uri) throws IOException {
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  if (classLoader == null) {
    classLoader=StandaloneObjectFactory.class.getClassLoader();
  }
  InputStream in=classLoader.getResourceAsStream(uri);
  if (in == null) {
    in=FactoryFinder.class.getClassLoader().getResourceAsStream(uri);
    if (in == null) {
      throw new IOException(""String_Node_Str"" + uri);
    }
  }
  try (BufferedInputStream reader=new BufferedInputStream(in)){
    Properties properties=new Properties();
    properties.load(reader);
    return properties;
  }
 }"
41761,"@Override public boolean equals(Object object){
  if (object instanceof JmsPrefetchPolicy) {
    JmsPrefetchPolicy other=(JmsPrefetchPolicy)object;
    return this.queuePrefetch == other.queuePrefetch && this.queueBrowserPrefetch == other.queueBrowserPrefetch && this.topicPrefetch == other.topicPrefetch && this.durableTopicPrefetch == other.durableTopicPrefetch;
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsPrefetchPolicy other=(JmsPrefetchPolicy)obj;
  return this.queuePrefetch == other.queuePrefetch && this.queueBrowserPrefetch == other.queueBrowserPrefetch && this.topicPrefetch == other.topicPrefetch && this.durableTopicPrefetch == other.durableTopicPrefetch;
}"
41762,"@Override public int hashCode(){
  return this.connectionId.hashCode();
}","@Override public int hashCode(){
  return (connectionId == null) ? super.hashCode() : connectionId.hashCode();
}"
41763,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsConnectionInfo other=(JmsConnectionInfo)obj;
  if (connectionId == null && other.connectionId != null) {
    return false;
  }
 else   if (!connectionId.equals(other.connectionId)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsConnectionInfo other=(JmsConnectionInfo)obj;
  if (connectionId != null) {
    return connectionId.equals(other.connectionId);
  }
  return false;
}"
41764,"@Override public int hashCode(){
  return (consumerId == null) ? 0 : consumerId.hashCode();
}","@Override public int hashCode(){
  return (consumerId == null) ? super.hashCode() : consumerId.hashCode();
}"
41765,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsConsumerInfo other=(JmsConsumerInfo)obj;
  if (consumerId == null && other.consumerId != null) {
    return false;
  }
 else   if (!consumerId.equals(other.consumerId)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsConsumerInfo other=(JmsConsumerInfo)obj;
  if (consumerId != null) {
    return consumerId.equals(other.consumerId);
  }
  return false;
}"
41766,"@Override public int hashCode(){
  return (producerId == null) ? 0 : producerId.hashCode();
}","@Override public int hashCode(){
  return (producerId == null) ? super.hashCode() : producerId.hashCode();
}"
41767,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsProducerInfo other=(JmsProducerInfo)obj;
  if (producerId == null && other.producerId != null) {
    return false;
  }
 else   if (!producerId.equals(other.producerId)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsProducerInfo other=(JmsProducerInfo)obj;
  if (producerId != null) {
    return producerId.equals(other.producerId);
  }
  return false;
}"
41768,"@Override public int hashCode(){
  return (transactionId == null) ? 0 : transactionId.hashCode();
}","@Override public int hashCode(){
  return (transactionId == null) ? super.hashCode() : transactionId.hashCode();
}"
41769,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsTransactionInfo other=(JmsTransactionInfo)obj;
  if (transactionId == null && other.transactionId != null) {
    return false;
  }
 else   if (!transactionId.equals(other.transactionId)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  JmsTransactionInfo other=(JmsTransactionInfo)obj;
  if (transactionId != null) {
    return transactionId.equals(other.transactionId);
  }
  return false;
}"
41770,"/** 
 * @return clientId
 * @see javax.jms.Connection#getClientID()
 */
@Override public String getClientID() throws JMSException {
  checkClosedOrFailed();
  return this.connectionInfo.getClientId();
}","/** 
 * @return clientId
 * @see javax.jms.Connection#getClientID()
 */
@Override public synchronized String getClientID() throws JMSException {
  checkClosedOrFailed();
  return this.connectionInfo.getClientId();
}"
41771,"/** 
 * Called to free all Connection resources.
 */
protected void shutdown() throws JMSException {
  for (  JmsSession session : this.sessions) {
    session.shutdown();
  }
  if (isConnected() && !failed.get() && !closing.get()) {
    destroyResource(connectionInfo);
  }
  if (clientIdSet) {
    connectionInfo.setClientId(null);
    clientIdSet=false;
  }
  tempDestinations.clear();
  started.set(false);
  connected.set(false);
}","/** 
 * Called to free all Connection resources.
 */
protected void shutdown() throws JMSException {
  for (  JmsSession session : this.sessions) {
    session.shutdown();
  }
  if (isConnected() && !failed.get() && !closing.get()) {
    destroyResource(connectionInfo);
  }
synchronized (this) {
    if (clientIdSet) {
      connectionInfo.setClientId(null);
      clientIdSet=false;
    }
  }
  tempDestinations.clear();
  started.set(false);
  connected.set(false);
}"
41772,"@Override public byte[] getBytes(String name) throws JMSException {
  Object value=getObject(name);
  if (value == null) {
    return (byte[])value;
  }
 else   if (value instanceof byte[]) {
    byte[] original=(byte[])value;
    byte[] clone=new byte[original.length];
    System.arraycopy(original,0,clone,0,original.length);
    return clone;
  }
 else {
    throw new MessageFormatException(""String_Node_Str"" + value.getClass().getSimpleName());
  }
}","@Override public byte[] getBytes(String name) throws JMSException {
  Object value=getObject(name);
  if (value == null) {
    return null;
  }
 else   if (value instanceof byte[]) {
    byte[] original=(byte[])value;
    byte[] clone=new byte[original.length];
    System.arraycopy(original,0,clone,0,original.length);
    return clone;
  }
 else {
    throw new MessageFormatException(""String_Node_Str"" + value.getClass().getSimpleName());
  }
}"
41773,"@Override protected void doOpen(){
  JmsDestination destination=info.getDestination();
  String destnationName=session.getQualifiedName(destination);
  String sourceAddress=getProducerId().toString();
  Source source=new Source();
  source.setAddress(sourceAddress);
  Target target=new Target();
  target.setAddress(destnationName);
  String senderName=sourceAddress + ""String_Node_Str"" + destnationName != null ? destnationName : ""String_Node_Str"";
  endpoint=session.getProtonSession().sender(senderName);
  endpoint.setSource(source);
  endpoint.setTarget(target);
  if (presettle) {
    endpoint.setSenderSettleMode(SenderSettleMode.SETTLED);
  }
 else {
    endpoint.setSenderSettleMode(SenderSettleMode.UNSETTLED);
  }
  endpoint.setReceiverSettleMode(ReceiverSettleMode.FIRST);
}","@Override protected void doOpen(){
  JmsDestination destination=info.getDestination();
  String destnationName=session.getQualifiedName(destination);
  String sourceAddress=getProducerId().toString();
  Source source=new Source();
  source.setAddress(sourceAddress);
  Target target=new Target();
  target.setAddress(destnationName);
  String senderName=sourceAddress + ""String_Node_Str"" + destnationName;
  endpoint=session.getProtonSession().sender(senderName);
  endpoint.setSource(source);
  endpoint.setTarget(target);
  if (presettle) {
    endpoint.setSenderSettleMode(SenderSettleMode.SETTLED);
  }
 else {
    endpoint.setSenderSettleMode(SenderSettleMode.UNSETTLED);
  }
  endpoint.setReceiverSettleMode(ReceiverSettleMode.FIRST);
}"
41774,"private Binary getBinaryFromBody(){
  Section body=getAmqpMessage().getBody();
  Binary result=null;
  if (body == null) {
    return result;
  }
  if (body instanceof Data) {
    Binary payload=((Data)body).getValue();
    if (payload != null && payload.getLength() != 0) {
      result=payload;
    }
  }
 else   if (body instanceof AmqpValue) {
    Object value=((AmqpValue)body).getValue();
    if (value == null) {
      return result;
    }
    if (value instanceof Binary) {
      Binary payload=(Binary)value;
      if (payload != null && payload.getLength() != 0) {
        result=payload;
      }
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + value.getClass().getSimpleName());
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + body.getClass().getSimpleName());
  }
  return result;
}","private Binary getBinaryFromBody(){
  Section body=getAmqpMessage().getBody();
  Binary result=null;
  if (body == null) {
    return result;
  }
  if (body instanceof Data) {
    Binary payload=((Data)body).getValue();
    if (payload != null && payload.getLength() != 0) {
      result=payload;
    }
  }
 else   if (body instanceof AmqpValue) {
    Object value=((AmqpValue)body).getValue();
    if (value == null) {
      return result;
    }
    if (value instanceof Binary) {
      Binary payload=(Binary)value;
      if (payload.getLength() != 0) {
        result=payload;
      }
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + value.getClass().getSimpleName());
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + body.getClass().getSimpleName());
  }
  return result;
}"
41775,"@Override public void setCorrelationId(String correlationId){
  AmqpMessageIdHelper messageIdHelper=AmqpMessageIdHelper.INSTANCE;
  if (correlationId == null) {
    message.setCorrelationId(null);
  }
 else {
    boolean appSpecific=false;
    boolean hasMessageIdPrefix=messageIdHelper.hasMessageIdPrefix(correlationId);
    if (correlationId != null && !hasMessageIdPrefix) {
      appSpecific=true;
    }
    String stripped=messageIdHelper.stripMessageIdPrefix(correlationId);
    if (hasMessageIdPrefix) {
      try {
        Object idObject=messageIdHelper.toIdObject(stripped);
        message.setCorrelationId(idObject);
      }
 catch (      IdConversionException e) {
        throw new RuntimeException(e);
      }
    }
 else {
      message.setCorrelationId(stripped);
    }
    if (appSpecific) {
      setAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID,true);
    }
 else {
      removeAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID);
    }
  }
}","@Override public void setCorrelationId(String correlationId){
  AmqpMessageIdHelper messageIdHelper=AmqpMessageIdHelper.INSTANCE;
  if (correlationId == null) {
    message.setCorrelationId(null);
  }
 else {
    boolean appSpecific=false;
    boolean hasMessageIdPrefix=messageIdHelper.hasMessageIdPrefix(correlationId);
    if (!hasMessageIdPrefix) {
      appSpecific=true;
    }
    String stripped=messageIdHelper.stripMessageIdPrefix(correlationId);
    if (hasMessageIdPrefix) {
      try {
        Object idObject=messageIdHelper.toIdObject(stripped);
        message.setCorrelationId(idObject);
      }
 catch (      IdConversionException e) {
        throw new RuntimeException(e);
      }
    }
 else {
      message.setCorrelationId(stripped);
    }
    if (appSpecific) {
      setAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID,true);
    }
 else {
      removeAnnotation(AmqpMessageSupport.JMS_APP_CORRELATION_ID);
    }
  }
}"
41776,"/** 
 * Given a key / value mapping, create and return a URI formatted query string that is valid and can be appended to a URI.
 * @param options The Mapping that will create the new Query string.
 * @return a URI formatted query string.
 * @throws URISyntaxException
 */
public static String createQueryString(Map<String,? extends Object> options) throws URISyntaxException {
  try {
    if (options.size() > 0) {
      StringBuffer rc=new StringBuffer();
      boolean first=true;
      for (      String key : options.keySet()) {
        if (first) {
          first=false;
        }
 else {
          rc.append(""String_Node_Str"");
        }
        String value=(String)options.get(key);
        rc.append(URLEncoder.encode(key,""String_Node_Str""));
        rc.append(""String_Node_Str"");
        rc.append(URLEncoder.encode(value,""String_Node_Str""));
      }
      return rc.toString();
    }
 else {
      return ""String_Node_Str"";
    }
  }
 catch (  UnsupportedEncodingException e) {
    throw (URISyntaxException)new URISyntaxException(e.toString(),""String_Node_Str"").initCause(e);
  }
}","/** 
 * Given a key / value mapping, create and return a URI formatted query string that is valid and can be appended to a URI.
 * @param options The Mapping that will create the new Query string.
 * @return a URI formatted query string.
 * @throws URISyntaxException
 */
public static String createQueryString(Map<String,? extends Object> options) throws URISyntaxException {
  try {
    if (options.size() > 0) {
      StringBuffer rc=new StringBuffer();
      boolean first=true;
      for (      Entry<String,? extends Object> entry : options.entrySet()) {
        if (first) {
          first=false;
        }
 else {
          rc.append(""String_Node_Str"");
        }
        rc.append(URLEncoder.encode(entry.getKey(),""String_Node_Str""));
        rc.append(""String_Node_Str"");
        rc.append(URLEncoder.encode((String)entry.getValue(),""String_Node_Str""));
      }
      return rc.toString();
    }
 else {
      return ""String_Node_Str"";
    }
  }
 catch (  UnsupportedEncodingException e) {
    throw (URISyntaxException)new URISyntaxException(e.toString(),""String_Node_Str"").initCause(e);
  }
}"
41777,"/** 
 * Given a map of properties, filter out only those prefixed with the given value, the values filtered are returned in a new Map instance.
 * @param properties The map of properties to filter.
 * @param optionPrefix The prefix value to use when filtering.
 * @return a filter map with only values that match the given prefix.
 */
public static Map<String,String> filterProperties(Map<String,String> props,String optionPrefix){
  if (props == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HashMap<String,String> rc=new HashMap<String,String>(props.size());
  for (Iterator<String> iter=props.keySet().iterator(); iter.hasNext(); ) {
    String name=iter.next();
    if (name.startsWith(optionPrefix)) {
      String value=props.get(name);
      name=name.substring(optionPrefix.length());
      rc.put(name,value);
      iter.remove();
    }
  }
  return rc;
}","/** 
 * Given a map of properties, filter out only those prefixed with the given value, the values filtered are returned in a new Map instance.
 * @param properties The map of properties to filter.
 * @param optionPrefix The prefix value to use when filtering.
 * @return a filter map with only values that match the given prefix.
 */
public static Map<String,String> filterProperties(Map<String,String> props,String optionPrefix){
  if (props == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HashMap<String,String> rc=new HashMap<String,String>(props.size());
  for (Iterator<Entry<String,String>> iter=props.entrySet().iterator(); iter.hasNext(); ) {
    Entry<String,String> entry=iter.next();
    if (entry.getKey().startsWith(optionPrefix)) {
      String name=entry.getKey().substring(optionPrefix.length());
      rc.put(name,entry.getValue());
      iter.remove();
    }
  }
  return rc;
}"
41778,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static String toString(Object target,Class stopClass,Map<String,Object> overrideFields){
  LinkedHashMap<String,Object> map=new LinkedHashMap<String,Object>();
  addFields(target,target.getClass(),stopClass,map);
  if (overrideFields != null) {
    for (    String key : overrideFields.keySet()) {
      Object value=overrideFields.get(key);
      map.put(key,value);
    }
  }
  StringBuffer buffer=new StringBuffer(simpleName(target.getClass()));
  buffer.append(""String_Node_Str"");
  Set<Entry<String,Object>> entrySet=map.entrySet();
  boolean first=true;
  for (  Map.Entry<String,Object> entry : entrySet) {
    Object value=entry.getValue();
    Object key=entry.getKey();
    if (first) {
      first=false;
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    buffer.append(key);
    buffer.append(""String_Node_Str"");
    appendToString(buffer,key,value);
  }
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static String toString(Object target,Class stopClass,Map<String,Object> overrideFields){
  LinkedHashMap<String,Object> map=new LinkedHashMap<String,Object>();
  addFields(target,target.getClass(),stopClass,map);
  if (overrideFields != null) {
    for (    Entry<String,Object> entry : overrideFields.entrySet()) {
      map.put(entry.getKey(),entry.getValue());
    }
  }
  StringBuffer buffer=new StringBuffer(simpleName(target.getClass()));
  buffer.append(""String_Node_Str"");
  Set<Entry<String,Object>> entrySet=map.entrySet();
  boolean first=true;
  for (  Map.Entry<String,Object> entry : entrySet) {
    Object value=entry.getValue();
    Object key=entry.getKey();
    if (first) {
      first=false;
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    buffer.append(key);
    buffer.append(""String_Node_Str"");
    appendToString(buffer,key,value);
  }
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}"
41779,"/** 
 * Creates a new Facade around an incoming AMQP Message for dispatch to the JMS Consumer instance.
 * @param consumer the consumer that received this message.
 * @param message the incoming Message instance that is being wrapped.
 */
@SuppressWarnings(""String_Node_Str"") public AmqpJmsMessageFacade(AmqpConsumer consumer,Message message){
  this.message=message;
  this.connection=consumer.getConnection();
  this.consumerDestination=consumer.getDestination();
  annotations=message.getMessageAnnotations();
  if (annotations != null) {
    annotationsMap=annotations.getValue();
  }
  if (message.getApplicationProperties() != null) {
    applicationPropertiesMap=message.getApplicationProperties().getValue();
  }
  Long ttl=message.getTtl();
  Long absoluteExpiryTime=getAbsoluteExpiryTime();
  if (absoluteExpiryTime == null && ttl != null) {
    syntheticExpiration=System.currentTimeMillis() + ttl;
  }
}","/** 
 * Creates a new Facade around an incoming AMQP Message for dispatch to the JMS Consumer instance.
 * @param consumer the consumer that received this message.
 * @param message the incoming Message instance that is being wrapped.
 */
@SuppressWarnings(""String_Node_Str"") public AmqpJmsMessageFacade(AmqpConsumer consumer,Message message){
  this.message=message;
  this.connection=consumer.getConnection();
  this.consumerDestination=consumer.getDestination();
  annotations=message.getMessageAnnotations();
  if (annotations != null) {
    annotationsMap=annotations.getValue();
  }
  if (message.getApplicationProperties() != null) {
    applicationPropertiesMap=message.getApplicationProperties().getValue();
  }
  Long ttl=getTtl();
  Long absoluteExpiryTime=getAbsoluteExpiryTime();
  if (absoluteExpiryTime == null && ttl != null) {
    syntheticExpiration=System.currentTimeMillis() + ttl;
  }
}"
41780,"@Override public void start() throws IOException, IllegalStateException {
  if (listener == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (started.compareAndSet(false,true)) {
    if (group == null || group.length() == 0) {
      throw new IOException(""String_Node_Str"");
    }
    if (discoveryURI == null) {
      try {
        discoveryURI=new URI(DEFAULT_DISCOVERY_URI_STRING);
      }
 catch (      URISyntaxException e) {
      }
    }
    LOG.trace(""String_Node_Str"",discoveryURI);
    String myHost=discoveryURI.getHost();
    int myPort=discoveryURI.getPort();
    if (DEFAULT_HOST_STR.equals(myHost)) {
      myHost=DEFAULT_HOST_IP;
    }
    if (myPort < 0) {
      myPort=DEFAULT_PORT;
    }
    LOG.trace(""String_Node_Str"",myHost);
    LOG.trace(""String_Node_Str"",myPort);
    LOG.trace(""String_Node_Str"",group);
    LOG.trace(""String_Node_Str"",mcInterface);
    LOG.trace(""String_Node_Str"",mcNetworkInterface);
    LOG.trace(""String_Node_Str"",mcJoinNetworkInterface);
    this.inetAddress=InetAddress.getByName(myHost);
    this.sockAddress=new InetSocketAddress(this.inetAddress,myPort);
    mcast=new MulticastSocket(myPort);
    mcast.setLoopbackMode(loopBackMode);
    mcast.setTimeToLive(getTimeToLive());
    if (mcJoinNetworkInterface != null) {
      mcast.joinGroup(sockAddress,NetworkInterface.getByName(mcJoinNetworkInterface));
    }
 else {
      mcast.joinGroup(inetAddress);
    }
    mcast.setSoTimeout((int)keepAliveInterval);
    if (mcInterface != null) {
      mcast.setInterface(InetAddress.getByName(mcInterface));
    }
    if (mcNetworkInterface != null) {
      mcast.setNetworkInterface(NetworkInterface.getByName(mcNetworkInterface));
    }
    runner=new Thread(this);
    runner.setName(this.toString() + ""String_Node_Str"" + runner.getName());
    runner.setDaemon(true);
    runner.start();
  }
}","@Override public void start() throws IOException, IllegalStateException {
  if (listener == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (started.compareAndSet(false,true)) {
    if (group == null || group.length() == 0) {
      throw new IOException(""String_Node_Str"");
    }
    if (discoveryURI == null) {
      try {
        discoveryURI=new URI(DEFAULT_DISCOVERY_URI_STRING);
      }
 catch (      URISyntaxException e) {
      }
      if (discoveryURI == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
    LOG.trace(""String_Node_Str"",discoveryURI);
    String myHost=discoveryURI.getHost();
    int myPort=discoveryURI.getPort();
    if (myHost == null || DEFAULT_HOST_STR.equals(myHost)) {
      myHost=DEFAULT_HOST_IP;
    }
    if (myPort < 0) {
      myPort=DEFAULT_PORT;
    }
    LOG.trace(""String_Node_Str"",myHost);
    LOG.trace(""String_Node_Str"",myPort);
    LOG.trace(""String_Node_Str"",group);
    LOG.trace(""String_Node_Str"",mcInterface);
    LOG.trace(""String_Node_Str"",mcNetworkInterface);
    LOG.trace(""String_Node_Str"",mcJoinNetworkInterface);
    this.inetAddress=InetAddress.getByName(myHost);
    this.sockAddress=new InetSocketAddress(this.inetAddress,myPort);
    mcast=new MulticastSocket(myPort);
    mcast.setLoopbackMode(loopBackMode);
    mcast.setTimeToLive(getTimeToLive());
    if (mcJoinNetworkInterface != null) {
      mcast.joinGroup(sockAddress,NetworkInterface.getByName(mcJoinNetworkInterface));
    }
 else {
      mcast.joinGroup(inetAddress);
    }
    mcast.setSoTimeout((int)keepAliveInterval);
    if (mcInterface != null) {
      mcast.setInterface(InetAddress.getByName(mcInterface));
    }
    if (mcNetworkInterface != null) {
      mcast.setNetworkInterface(NetworkInterface.getByName(mcNetworkInterface));
    }
    runner=new Thread(this);
    runner.setName(this.toString() + ""String_Node_Str"" + runner.getName());
    runner.setDaemon(true);
    runner.start();
  }
}"
41781,"/** 
 * Searches for a PacketParserFactory by using the given key. The search first checks the local cache of packet parser factories before moving on to search in the classpath.
 * @param key The name of the PacketParserFactory that should be located.
 * @return a PacketParserFactory instance matching the given key.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static PacketParserFactory findAgentFactory(String key) throws IOException {
  if (key == null) {
    throw new IOException(""String_Node_Str"" + key + ""String_Node_Str"");
  }
  PacketParserFactory factory=null;
  if (factory == null) {
    try {
      factory=AGENT_FACTORY_FINDER.newInstance(key);
    }
 catch (    Throwable e) {
      throw new IOException(""String_Node_Str"" + key + ""String_Node_Str"",e);
    }
  }
  return factory;
}","/** 
 * Searches for a PacketParserFactory by using the given key. The search first checks the local cache of packet parser factories before moving on to search in the classpath.
 * @param key The name of the PacketParserFactory that should be located.
 * @return a PacketParserFactory instance matching the given key.
 * @throws IOException if an error occurs while locating the factory.
 */
protected static PacketParserFactory findAgentFactory(String key) throws IOException {
  if (key == null) {
    throw new IOException(""String_Node_Str"");
  }
  PacketParserFactory factory=null;
  if (factory == null) {
    try {
      factory=AGENT_FACTORY_FINDER.newInstance(key);
    }
 catch (    Throwable e) {
      throw new IOException(""String_Node_Str"" + key + ""String_Node_Str"",e);
    }
  }
  return factory;
}"
41782,"/** 
 * Check whether the content-type field of the properties section (if present) in the given message matches the provided string (where null matches if there is no content type rpeesnt.
 * @param contentType content type string to compare against, or null if none
 * @param message the AMQP message object that is being examined.
 * @return true if content type matches
 */
public static boolean isContentType(String contentType,Message message){
  if (contentType == null) {
    return message.getContentType() == null;
  }
 else {
    return contentType.equals(message.getContentType());
  }
}","/** 
 * Check whether the content-type field of the properties section (if present) in the given message matches the provided string (where null matches if there is no content type present.
 * @param contentType content type string to compare against, or null if none
 * @param message the AMQP message object that is being examined.
 * @return true if content type matches
 */
public static boolean isContentType(String contentType,Message message){
  if (contentType == null) {
    return message.getContentType() == null;
  }
 else {
    return contentType.equals(message.getContentType());
  }
}"
41783,"public void setReplyToAddressFromDestination(AmqpJmsMessageFacade message,JmsDestination destination){
  if (destination == null) {
    return;
  }
  String replyToAddress=destination.getName();
  String typeString=toTypeAnnotation(destination);
  message.setReplyToAddress(replyToAddress);
  if (replyToAddress == null || typeString == null) {
    message.removeAnnotation(REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
  }
 else {
    message.setAnnotation(REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,typeString);
  }
}","public void setReplyToAddressFromDestination(AmqpJmsMessageFacade message,JmsDestination destination){
  String replyToAddress=destination != null ? destination.getName() : null;
  String typeString=toTypeAnnotation(destination);
  message.setReplyToAddress(replyToAddress);
  if (replyToAddress == null || typeString == null) {
    message.removeAnnotation(REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
  }
 else {
    message.setAnnotation(REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,typeString);
  }
}"
41784,"public void setToAddressFromDestination(AmqpJmsMessageFacade message,JmsDestination destination){
  if (destination == null) {
    return;
  }
  String address=destination.getName();
  String typeString=toTypeAnnotation(destination);
  message.setToAddress(address);
  if (address == null || typeString == null) {
    message.removeAnnotation(TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
  }
 else {
    message.setAnnotation(TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,typeString);
  }
}","public void setToAddressFromDestination(AmqpJmsMessageFacade message,JmsDestination destination){
  String address=destination != null ? destination.getName() : null;
  String typeString=toTypeAnnotation(destination);
  message.setToAddress(address);
  if (address == null || typeString == null) {
    message.removeAnnotation(TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
  }
 else {
    message.setAnnotation(TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME,typeString);
  }
}"
41785,"@Test public void testSetToAddressFromDestinationWithNullDestination(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setToAddressFromDestination(message,null);
  Mockito.verifyZeroInteractions(message);
}","@Test public void testSetToAddressFromDestinationWithNullDestination(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setToAddressFromDestination(message,null);
  Mockito.verify(message).setToAddress(null);
  Mockito.verify(message).removeAnnotation(TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
}"
41786,"@Test public void testSetReplyToAddressFromDestinationWithNullDestinationAndNullMessage(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setReplyToAddressFromDestination(null,null);
  Mockito.verifyZeroInteractions(message);
}","@Test(expected=NullPointerException.class) public void testSetReplyToAddressFromDestinationWithNullDestinationAndNullMessage(){
  helper.setReplyToAddressFromDestination(null,null);
}"
41787,"@Test public void testSetReplyToAddressFromDestinationWithNullDestination(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setReplyToAddressFromDestination(message,null);
  Mockito.verifyZeroInteractions(message);
}","@Test public void testSetReplyToAddressFromDestinationWithNullDestination(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setReplyToAddressFromDestination(message,null);
  Mockito.verify(message).setReplyToAddress(null);
  Mockito.verify(message).removeAnnotation(REPLY_TO_TYPE_MSG_ANNOTATION_SYMBOL_NAME);
}"
41788,"@Test public void testSetToAddressFromDestinationWithNullDestinationAndNullMessage(){
  AmqpJmsMessageFacade message=Mockito.mock(AmqpJmsMessageFacade.class);
  helper.setToAddressFromDestination(null,null);
  Mockito.verifyZeroInteractions(message);
}","@Test(expected=NullPointerException.class) public void testSetToAddressFromDestinationWithNullDestinationAndNullMessage(){
  helper.setToAddressFromDestination(null,null);
}"
41789,"@Override public void finish(){
  super.finish();
  int length=~(int)(positionAddr - startAddr);
  NativeBytes.UNSAFE.putOrderedInt(null,startAddr - 4,length);
  int offset=(int)(startAddr - dataBytes.address());
  long dataOffset=dataBytes.index() * config.dataBlockSize() + offset;
  long indexValue=((long)appenderThreadId << INDEX_DATA_OFFSET_BITS) + dataOffset;
  lastWrittenIndex=indexValue;
  try {
    if (!VanillaIndexCache.append(indexBytes,indexValue,nextSynchronous)) {
      if (indexBytes != null) {
        indexBytes.release();
        indexBytes=null;
      }
      indexBytes=indexCache.append(appenderCycle,indexValue,nextSynchronous);
    }
  }
 catch (  IOException e) {
    throw new AssertionError(e);
  }
  dataBytes.positionAddr(positionAddr);
  dataBytes.alignPositionAddr(4);
  if (nextSynchronous) {
    dataBytes.force();
  }
}","@Override public void finish(){
  super.finish();
  int length=~(int)(positionAddr - startAddr);
  NativeBytes.UNSAFE.putOrderedInt(null,startAddr - 4,length);
  int offset=(int)(startAddr - dataBytes.address());
  long dataOffset=dataBytes.index() * config.dataBlockSize() + offset;
  long indexValue=((long)appenderThreadId << INDEX_DATA_OFFSET_BITS) + dataOffset;
  try {
    long position=VanillaIndexCache.append(indexBytes,indexValue,nextSynchronous);
    if (position < 0) {
      if (indexBytes != null) {
        indexBytes.release();
        indexBytes=null;
      }
      indexBytes=indexCache.append(appenderCycle,indexValue,nextSynchronous,positionArr);
      setLastWrittenIndex(indexFrom(appenderCycle,positionArr[0]));
    }
 else {
      setLastWrittenIndex(indexFrom(appenderCycle,position));
    }
  }
 catch (  IOException e) {
    throw new AssertionError(e);
  }
  setIndex(lastWrittenIndex() + 1);
  dataBytes.positionAddr(positionAddr);
  dataBytes.alignPositionAddr(4);
  if (nextSynchronous) {
    dataBytes.force();
  }
}"
41790,"/** 
 * Return the last index written by the appender. This may not be the actual last index in the Chronicle which can be found from lastIndex().
 */
@Override public long lastWrittenIndex(){
  return VanillaChronicle.this.lastWrittenIndex();
}","/** 
 * Return the last index written by the appender. This may not be the actual last index in the Chronicle which can be found from lastIndex().
 */
@Override public long lastWrittenIndex(){
  return lastWrittenIndex;
}"
41791,"public static boolean append(final VanillaMappedBytes bytes,final long indexValue,final boolean synchronous){
  if (bytes != null) {
    boolean endOfFile=false;
    while (!endOfFile) {
      final long position=bytes.position();
      endOfFile=(bytes.limit() - position) < 8;
      if (!endOfFile) {
        if (bytes.compareAndSwapLong(position,0L,indexValue)) {
          if (synchronous) {
            bytes.force();
          }
          return true;
        }
        bytes.position(position + 8);
      }
    }
  }
  return false;
}","public static long append(final VanillaMappedBytes bytes,final long indexValue,final boolean synchronous){
  if (bytes != null) {
    boolean endOfFile=false;
    while (!endOfFile) {
      final long position=bytes.position();
      endOfFile=(bytes.limit() - position) < 8;
      if (!endOfFile) {
        if (bytes.compareAndSwapLong(position,0L,indexValue)) {
          if (synchronous) {
            bytes.force();
          }
          return position;
        }
        bytes.position(position + 8);
      }
    }
  }
  return -1;
}"
41792,"@Override public Void call() throws Exception {
  long counter=startValue;
  while (counter < endValue) {
    final VanillaMappedBytes vmb=cache.append(cycle,counter,false);
    if (vmb != null) {
      vmb.release();
    }
    counter++;
  }
  return null;
}","@Override public Void call() throws Exception {
  long counter=startValue;
  while (counter < endValue) {
    final VanillaMappedBytes vmb=cache.append(cycle,counter,false,new long[1]);
    if (vmb != null) {
      vmb.release();
    }
    counter++;
  }
  return null;
}"
41793,"private Callable<Void> createAppendTask(final VanillaIndexCache cache,final int cycle,final long startValue,final long endValue){
  return new Callable<Void>(){
    @Override public Void call() throws Exception {
      long counter=startValue;
      while (counter < endValue) {
        final VanillaMappedBytes vmb=cache.append(cycle,counter,false);
        if (vmb != null) {
          vmb.release();
        }
        counter++;
      }
      return null;
    }
  }
;
}","private Callable<Void> createAppendTask(final VanillaIndexCache cache,final int cycle,final long startValue,final long endValue){
  return new Callable<Void>(){
    @Override public Void call() throws Exception {
      long counter=startValue;
      while (counter < endValue) {
        final VanillaMappedBytes vmb=cache.append(cycle,counter,false,new long[1]);
        if (vmb != null) {
          vmb.release();
        }
        counter++;
      }
      return null;
    }
  }
;
}"
41794,"@Override public void finish(){
  super.finish();
  if (dataBytes != null) {
    int length=~(int)(positionAddr - startAddr);
    NativeBytes.UNSAFE.putOrderedInt(null,startAddr - 4,length);
    long indexValue=((long)appenderThreadId << INDEX_DATA_OFFSET_BITS) + dataOffset;
    try {
      long position=VanillaIndexCache.append(indexBytes,indexValue,nextSynchronous);
      if (position < 0) {
        if (indexBytes != null) {
          indexBytes.release();
          indexBytes=null;
        }
        indexBytes=indexCache.append(appenderCycle,indexValue,nextSynchronous,positionArr);
        setLastWrittenIndex(indexFrom(appenderCycle,positionArr[0]));
      }
 else {
        setLastWrittenIndex(indexFrom(appenderCycle,position));
      }
    }
 catch (    IOException e) {
      throw new AssertionError(e);
    }
    setIndex(lastWrittenIndex() + 1);
    dataBytes.positionAddr(positionAddr);
    dataBytes.alignPositionAddr(4);
    if (nextSynchronous) {
      dataBytes.force();
    }
  }
}","@Override public void finish(){
  super.finish();
  if (dataBytes == null)   return;
  int length=~(int)(positionAddr - startAddr);
  NativeBytes.UNSAFE.putOrderedInt(null,startAddr - 4,length);
  int offset=(int)(startAddr - dataBytes.address());
  long dataOffset=dataBytes.index() * config.dataBlockSize() + offset;
  long indexValue=((long)appenderThreadId << INDEX_DATA_OFFSET_BITS) + dataOffset;
  try {
    long position=VanillaIndexCache.append(indexBytes,indexValue,nextSynchronous);
    if (position < 0) {
      if (indexBytes != null) {
        indexBytes.release();
        indexBytes=null;
      }
      indexBytes=indexCache.append(appenderCycle,indexValue,nextSynchronous,positionArr);
      setLastWrittenIndex(indexFrom(appenderCycle,positionArr[0]));
    }
 else {
      setLastWrittenIndex(indexFrom(appenderCycle,position));
    }
  }
 catch (  IOException e) {
    throw new AssertionError(e);
  }
  setIndex(lastWrittenIndex() + 1);
  dataBytes.positionAddr(positionAddr);
  dataBytes.alignPositionAddr(4);
  if (nextSynchronous) {
    dataBytes.force();
  }
}"
41795,"public VanillaFile(String basePath,String cycleStr,String name,int indexCount,long size,boolean forAppend) throws IOException {
  logger=Logger.getLogger(VanillaFile.class.getName() + ""String_Node_Str"" + name);
  File dir=new File(basePath,cycleStr);
  this.indexCount=indexCount;
  if (!dir.isDirectory()) {
    boolean created=dir.mkdirs();
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + dir + ""String_Node_Str""+ created);
  }
  file=new File(dir,name);
  if (file.exists()) {
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + file);
  }
 else   if (forAppend) {
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + file);
  }
 else {
    throw new FileNotFoundException(file.getAbsolutePath());
  }
  fc=new RandomAccessFile(file,""String_Node_Str"").getChannel();
  map=fc.map(FileChannel.MapMode.READ_WRITE,0,size);
  map.order(ByteOrder.nativeOrder());
  baseAddr=((DirectBuffer)map).address();
  bytes=new NativeBytes(null,baseAddr,baseAddr + size,usage);
}","public VanillaFile(String basePath,String cycleStr,String name,int indexCount,long size,boolean forAppend) throws IOException {
  logger=Logger.getLogger(VanillaFile.class.getName() + ""String_Node_Str"" + name);
  File dir=new File(basePath,cycleStr);
  this.indexCount=indexCount;
  if (!forAppend) {
    File f=new File(dir,name);
    if (!f.exists()) {
      throw new FileNotFoundException(f.getAbsolutePath());
    }
  }
  if (!dir.isDirectory()) {
    boolean created=dir.mkdirs();
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + dir + ""String_Node_Str""+ created);
  }
  file=new File(dir,name);
  if (file.exists()) {
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + file);
  }
 else   if (forAppend) {
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + file);
  }
 else {
    throw new FileNotFoundException(file.getAbsolutePath());
  }
  fc=new RandomAccessFile(file,""String_Node_Str"").getChannel();
  map=fc.map(FileChannel.MapMode.READ_WRITE,0,size);
  map.order(ByteOrder.nativeOrder());
  baseAddr=((DirectBuffer)map).address();
  bytes=new NativeBytes(null,baseAddr,baseAddr + size,usage);
}"
41796,"private boolean readNextExcerpt(@NotNull SocketChannel sc){
  try {
    if (closed)     return false;
    if (readBuffer.remaining() < (scFirst ? TcpUtil.HEADER_SIZE : 4)) {
      if (readBuffer.remaining() == 0)       readBuffer.clear();
 else       readBuffer.compact();
      int minSize=scFirst ? 8 + 4 + 8 : 4 + 8;
      while (readBuffer.position() < minSize) {
        if (sc.read(readBuffer) < 0) {
          sc.close();
          return false;
        }
      }
      readBuffer.flip();
    }
    if (scFirst) {
      long scIndex=readBuffer.getLong();
      if (scIndex != chronicle.size())       scFirst=false;
    }
    int size=readBuffer.getInt();
    if (size > 128 << 20 || size < 0)     throw new StreamCorruptedException(""String_Node_Str"" + size);
    excerpt.startExcerpt(size);
    long remaining=size;
    int limit=readBuffer.limit();
    int size2=(int)Math.min(readBuffer.remaining(),remaining);
    remaining-=size2;
    readBuffer.limit(readBuffer.position() + size2);
    excerpt.write(readBuffer);
    readBuffer.limit(limit);
    while (remaining > 0) {
      readBuffer.clear();
      int size3=(int)Math.min(readBuffer.capacity(),remaining);
      readBuffer.limit(size3);
      if (sc.read(readBuffer) < 0)       throw new EOFException();
      readBuffer.flip();
      remaining-=readBuffer.remaining();
      excerpt.write(readBuffer);
    }
    excerpt.finish();
  }
 catch (  IOException e) {
    if (logger.isLoggable(Level.FINE))     logger.log(Level.FINE,""String_Node_Str"" + address + ""String_Node_Str"",e);
 else     if (logger.isLoggable(Level.INFO))     logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ e);
    try {
      sc.close();
    }
 catch (    IOException ignored) {
    }
  }
  return true;
}","private boolean readNextExcerpt(@NotNull SocketChannel sc){
  try {
    if (closed)     return false;
    if (readBuffer.remaining() < (scFirst ? TcpUtil.HEADER_SIZE : 4)) {
      if (readBuffer.remaining() == 0)       readBuffer.clear();
 else       readBuffer.compact();
      int minSize=scFirst ? 8 + 4 + 8 : 4 + 8;
      while (readBuffer.position() < minSize) {
        if (sc.read(readBuffer) < 0) {
          sc.close();
          return false;
        }
      }
      readBuffer.flip();
    }
    if (scFirst) {
      long scIndex=readBuffer.getLong();
      if (scIndex != chronicle.size())       scFirst=false;
    }
    int size=readBuffer.getInt();
switch (size) {
case VanillaChronicleSource.IN_SYNC_LEN:
      return false;
default :
    break;
}
if (size > 128 << 20 || size < 0) throw new StreamCorruptedException(""String_Node_Str"" + size);
excerpt.startExcerpt(size);
long remaining=size;
int limit=readBuffer.limit();
int size2=(int)Math.min(readBuffer.remaining(),remaining);
remaining-=size2;
readBuffer.limit(readBuffer.position() + size2);
excerpt.write(readBuffer);
readBuffer.limit(limit);
while (remaining > 0) {
  readBuffer.clear();
  int size3=(int)Math.min(readBuffer.capacity(),remaining);
  readBuffer.limit(size3);
  if (sc.read(readBuffer) < 0)   throw new EOFException();
  readBuffer.flip();
  remaining-=readBuffer.remaining();
  excerpt.write(readBuffer);
}
excerpt.finish();
}
 catch (IOException e) {
if (logger.isLoggable(Level.FINE)) logger.log(Level.FINE,""String_Node_Str"" + address + ""String_Node_Str"",e);
 else if (logger.isLoggable(Level.INFO)) logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ e);
try {
  sc.close();
}
 catch (IOException ignored) {
}
}
return true;
}"
41797,"@Override public void run(){
  try {
    long index=readIndex(socket);
    ExcerptTailer excerpt=chronicle.createTailer();
    ByteBuffer bb=TcpUtil.createBuffer(1,ByteOrder.nativeOrder());
    long sendInSync=0;
    boolean first=true;
    OUTER:     while (!closed) {
      while (!excerpt.nextIndex()) {
        long now=System.currentTimeMillis();
        if (excerpt.wasPadding()) {
          if (index >= 0) {
            bb.clear();
            if (first) {
              bb.putLong(excerpt.index());
              first=false;
            }
            bb.putInt(PADDED_LEN);
            bb.flip();
            TcpUtil.writeAll(socket,bb);
            sendInSync=now + HEARTBEAT_INTERVAL_MS;
          }
          index++;
          continue;
        }
        if (sendInSync <= now && !first) {
          bb.clear();
          bb.putInt(IN_SYNC_LEN);
          bb.flip();
          TcpUtil.writeAll(socket,bb);
          sendInSync=now + HEARTBEAT_INTERVAL_MS;
        }
        pause();
        if (closed)         break OUTER;
      }
      pauseReset();
      final long size=excerpt.capacity();
      long remaining;
      bb.clear();
      if (first) {
        bb.putLong(excerpt.index());
        first=false;
        remaining=size + TcpUtil.HEADER_SIZE;
      }
 else {
        remaining=size + 4;
      }
      bb.putInt((int)size);
      if (size > bb.capacity() / 2) {
        while (remaining > 0) {
          int size2=(int)Math.min(remaining,bb.capacity());
          bb.limit(size2);
          excerpt.read(bb);
          bb.flip();
          remaining-=bb.remaining();
          TcpUtil.writeAll(socket,bb);
        }
      }
 else {
        bb.limit((int)remaining);
        excerpt.read(bb);
        int count=1;
        while (count++ < MAX_MESSAGE) {
          if (excerpt.nextIndex()) {
            if (excerpt.wasPadding()) {
              index++;
              continue;
            }
            if (excerpt.remaining() + 4 >= bb.capacity() - bb.position())             break;
            int size2=(int)excerpt.capacity();
            bb.limit(bb.position() + size2 + 4);
            bb.putInt(size2);
            excerpt.read(bb);
            index++;
          }
        }
        bb.flip();
        TcpUtil.writeAll(socket,bb);
      }
      if (bb.remaining() > 0)       throw new EOFException(""String_Node_Str"" + index);
      index++;
      sendInSync=0;
    }
  }
 catch (  Exception e) {
    if (!closed) {
      String msg=e.getMessage();
      if (msg != null && (msg.contains(""String_Node_Str"") || msg.contains(""String_Node_Str"") || msg.contains(""String_Node_Str"")))       logger.log(Level.INFO,""String_Node_Str"" + socket + ""String_Node_Str""+ e);
 else       logger.log(Level.INFO,""String_Node_Str"" + socket + ""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  try {
    long index=readIndex(socket);
    ExcerptTailer excerpt=chronicle.createTailer();
    ByteBuffer bb=TcpUtil.createBuffer(1,ByteOrder.nativeOrder());
    long sendInSync=0;
    boolean first=true;
    OUTER:     while (!closed) {
      while (!excerpt.nextIndex()) {
        long now=System.currentTimeMillis();
        if (excerpt.wasPadding()) {
          if (index >= 0) {
            bb.clear();
            if (first) {
              bb.putLong(excerpt.index());
              first=false;
            }
            bb.putInt(PADDED_LEN);
            bb.flip();
            TcpUtil.writeAll(socket,bb);
            sendInSync=now + HEARTBEAT_INTERVAL_MS;
          }
          index++;
          continue;
        }
        pause();
        if (closed)         break OUTER;
      }
      pauseReset();
      final long size=excerpt.capacity();
      long remaining;
      bb.clear();
      if (first) {
        bb.putLong(excerpt.index());
        first=false;
        remaining=size + TcpUtil.HEADER_SIZE;
      }
 else {
        remaining=size + 4;
      }
      bb.putInt((int)size);
      if (size > bb.capacity() / 2) {
        while (remaining > 0) {
          int size2=(int)Math.min(remaining,bb.capacity());
          bb.limit(size2);
          excerpt.read(bb);
          bb.flip();
          remaining-=bb.remaining();
          TcpUtil.writeAll(socket,bb);
        }
      }
 else {
        bb.limit((int)remaining);
        excerpt.read(bb);
        int count=1;
        while (count++ < MAX_MESSAGE) {
          if (excerpt.nextIndex()) {
            if (excerpt.wasPadding()) {
              index++;
              continue;
            }
            if (excerpt.remaining() + 4 >= bb.capacity() - bb.position())             break;
            int size2=(int)excerpt.capacity();
            bb.limit(bb.position() + size2 + 4);
            bb.putInt(size2);
            excerpt.read(bb);
            index++;
          }
        }
        bb.flip();
        TcpUtil.writeAll(socket,bb);
      }
      if (bb.remaining() > 0)       throw new EOFException(""String_Node_Str"" + index);
      index++;
      sendInSync=0;
    }
  }
 catch (  Exception e) {
    if (!closed) {
      String msg=e.getMessage();
      if (msg != null && (msg.contains(""String_Node_Str"") || msg.contains(""String_Node_Str"") || msg.contains(""String_Node_Str"")))       logger.log(Level.INFO,""String_Node_Str"" + socket + ""String_Node_Str""+ e);
 else       logger.log(Level.INFO,""String_Node_Str"" + socket + ""String_Node_Str"",e);
    }
  }
}"
41798,"@Test public void testReplication() throws IOException {
  int RUNS=100;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str""),0);
  int localPort=chronicle.getLocalPort();
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str""),""String_Node_Str"",localPort);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      tailer.nextIndex();
      assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ tailer.remaining(),tailer.remaining() > 0);
      assertEquals(""String_Node_Str"" + i,value,tailer.parseLong());
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.clear();
  }
}","@Test public void testReplication() throws IOException {
  int RUNS=100;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str""),0);
  int localPort=chronicle.getLocalPort();
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str""),""String_Node_Str"",localPort);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      boolean nextIndex=tailer.nextIndex();
      long val=tailer.parseLong();
      System.out.println(val);
      assertEquals(""String_Node_Str"" + i,value,val);
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.close();
    chronicle2.clear();
    chronicle.clear();
  }
}"
41799,"@Test public void testReplicationWithRolling() throws Exception {
  int RUNS=500;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleConfig config=new VanillaChronicleConfig();
  config.cycleLength(1000);
  config.cycleFormat(""String_Node_Str"");
  config.entriesPerCycle(1L << 20);
  config.indexBlockSize(16L << 10);
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str"",config),0);
  int localPort=chronicle.getLocalPort();
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str"",config),""String_Node_Str"",localPort);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      Thread.sleep(10);
      tailer.nextIndex();
      assertEquals(""String_Node_Str"" + i,value,tailer.parseLong());
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.clear();
  }
}","@Test public void testReplicationWithRolling() throws Exception {
  int RUNS=500;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleConfig config=new VanillaChronicleConfig();
  config.cycleLength(1000);
  config.cycleFormat(""String_Node_Str"");
  config.entriesPerCycle(1L << 20);
  config.indexBlockSize(16L << 10);
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str"",config),0);
  int localPort=chronicle.getLocalPort();
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str"",config),""String_Node_Str"",localPort);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      Thread.sleep(10);
      tailer.nextIndex();
      assertEquals(""String_Node_Str"" + i,value,tailer.parseLong());
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.close();
    chronicle2.clear();
    chronicle.clear();
  }
}"
41800,"@Test public void testReplicationWithRolling2() throws Exception {
  int RUNS=100;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleConfig config=new VanillaChronicleConfig();
  config.cycleLength(1000);
  config.cycleFormat(""String_Node_Str"");
  config.entriesPerCycle(1L << 20);
  config.indexBlockSize(16L << 10);
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str"",config),55555);
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str"",config),""String_Node_Str"",55555);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      Thread.sleep(100);
      tailer.nextIndex();
      long val=tailer.parseLong();
      assertEquals(""String_Node_Str"" + i,value,val);
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.clear();
  }
}","@Test public void testReplicationWithRolling2() throws Exception {
  int RUNS=100;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleConfig config=new VanillaChronicleConfig();
  config.cycleLength(1000);
  config.cycleFormat(""String_Node_Str"");
  config.entriesPerCycle(1L << 20);
  config.indexBlockSize(16L << 10);
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str"",config),55555);
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str"",config),""String_Node_Str"",55555);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      Thread.sleep(100);
      tailer.nextIndex();
      long val=tailer.parseLong();
      assertEquals(""String_Node_Str"" + i,value,val);
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.close();
    chronicle2.clear();
    chronicle.clear();
  }
}"
41801,"@Override public void report(@NotNull MetaData metaData,SmallReport smallReport){
  if (metaData.sourceId != gwId)   return;
  int count=reportCount.getAndIncrement();
  if (!throughputTest) {
    times[Math.abs(count)]=(metaData.inReadTimestamp - metaData.inWriteTimestamp);
  }
}","@Override public void report(@NotNull MetaData metaData,SmallReport smallReport){
  if (metaData.sourceId != gwId)   return;
  int count=reportCount.getAndIncrement();
  if (!throughputTest) {
    times[Math.abs(count)]=(metaData.outReadTimestamp - metaData.inWriteTimestamp);
  }
}"
41802,"public static void main(@NotNull String... args) throws IOException, InterruptedException {
  if (args.length < 2) {
    System.err.print(""String_Node_Str"" + GWMain.class.getName() + ""String_Node_Str"");
    System.exit(-1);
  }
  ChronicleTools.warmup();
  final int gwId=Integer.parseInt(args[0]);
  final boolean throughputTest=Boolean.parseBoolean(args[1]);
  String tmp=System.getProperty(""String_Node_Str"");
  String gw2pePath=tmp + ""String_Node_Str"" + gwId;
  String pePath=tmp + ""String_Node_Str"";
  ChronicleConfig config=ChronicleConfig.DEFAULT.clone();
  IndexedChronicle gw2pe=new IndexedChronicle(gw2pePath,config);
  Gw2PeEvents gw2PeWriter=new Gw2PeWriter(gw2pe.createAppender());
  IndexedChronicle pe2gw=new IndexedChronicle(pePath,config);
  final long[] times=new long[ORDERS];
  final AtomicInteger reportCount=new AtomicInteger(-WARMUP);
  Pe2GwEvents listener=new Pe2GwEvents(){
    @Override public void report(    @NotNull MetaData metaData,    SmallReport smallReport){
      if (metaData.sourceId != gwId)       return;
      int count=reportCount.getAndIncrement();
      if (!throughputTest) {
        times[Math.abs(count)]=(metaData.inReadTimestamp - metaData.inWriteTimestamp);
      }
    }
  }
;
  final Pe2GwReader pe2GwReader=new Pe2GwReader(gwId,pe2gw.createTailer(),listener);
  if (gwId > 1) {
    int startTime=(int)((System.currentTimeMillis() / 1000 - 5) % 10) + 5;
    System.out.println(""String_Node_Str"");
    for (int i=startTime; i > 0; i--) {
      System.out.print(i + ""String_Node_Str"");
      System.out.flush();
      Thread.sleep(1000);
    }
  }
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      AffinitySupport.setAffinity(1L << 3);
      while (reportCount.get() < ORDERS) {
        pe2GwReader.readOne();
      }
    }
  }
);
  t.start();
  Thread t2=new Thread(new Runnable(){
    @Override public void run(){
      int n=0;
      while (reportCount.get() < ORDERS) {
        while (reportCount.get() < n)         try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
          throw new AssertionError(e);
        }
        int count=reportCount.get();
        System.out.println(""String_Node_Str"" + count);
        n+=1000000;
      }
    }
  }
);
  t2.start();
  AffinitySupport.setAffinity(1L << 1);
  SmallCommand command=new SmallCommand();
  @SuppressWarnings(""String_Node_Str"") StringBuilder clientOrderId=command.clientOrderId;
  System.out.println(""String_Node_Str"");
  long start=System.nanoTime();
  for (int i=0; i < ORDERS + WARMUP; i++) {
    if (i == WARMUP)     start=System.nanoTime();
    clientOrderId.setLength(0);
    clientOrderId.append(""String_Node_Str"");
    clientOrderId.append(gwId);
    clientOrderId.append('-');
    clientOrderId.append(i);
    command.instrument=""String_Node_Str"";
    command.price=1209.41;
    command.quantity=1000;
    command.side=(i & 1) == 0 ? Side.BUY : Side.SELL;
    if (!throughputTest) {
      long expectedTime=start + i * EVENT_SPACING - 30;
      while (System.nanoTime() < expectedTime) {
      }
    }
    gw2PeWriter.small(null,command);
  }
  System.out.println(""String_Node_Str"" + reportCount.get());
  t.join();
  long time=System.nanoTime() - start;
  Arrays.sort(times);
  System.out.printf(""String_Node_Str"",ORDERS,time / 1e9);
  if (!throughputTest) {
    System.out.printf(""String_Node_Str"",times[ORDERS / 2] / 1e3,times[ORDERS * 9 / 10] / 1e3,times[ORDERS - ORDERS / 100] / 1e3,times[ORDERS - ORDERS / 1000] / 1000,times[ORDERS - ORDERS / 10000] / 1000,times[ORDERS - 1] / 1000);
  }
  gw2pe.close();
  pe2gw.close();
}","public static void main(@NotNull String... args) throws IOException, InterruptedException {
  if (args.length < 2) {
    System.err.print(""String_Node_Str"" + GWMain.class.getName() + ""String_Node_Str"");
    System.exit(-1);
  }
  ChronicleTools.warmup();
  final int gwId=Integer.parseInt(args[0]);
  final boolean throughputTest=Boolean.parseBoolean(args[1]);
  String tmp=System.getProperty(""String_Node_Str"");
  String gw2pePath=tmp + ""String_Node_Str"" + gwId;
  String pePath=tmp + ""String_Node_Str"";
  ChronicleConfig config=ChronicleConfig.DEFAULT.clone();
  IndexedChronicle gw2pe=new IndexedChronicle(gw2pePath,config);
  Gw2PeEvents gw2PeWriter=new Gw2PeWriter(gw2pe.createAppender());
  IndexedChronicle pe2gw=new IndexedChronicle(pePath,config);
  final long[] times=new long[ORDERS];
  final AtomicInteger reportCount=new AtomicInteger(-WARMUP);
  Pe2GwEvents listener=new Pe2GwEvents(){
    @Override public void report(    @NotNull MetaData metaData,    SmallReport smallReport){
      if (metaData.sourceId != gwId)       return;
      int count=reportCount.getAndIncrement();
      if (!throughputTest) {
        times[Math.abs(count)]=(metaData.outReadTimestamp - metaData.inWriteTimestamp);
      }
    }
  }
;
  final Pe2GwReader pe2GwReader=new Pe2GwReader(gwId,pe2gw.createTailer(),listener);
  if (gwId > 1) {
    int startTime=(int)((System.currentTimeMillis() / 1000 - 5) % 10) + 5;
    System.out.println(""String_Node_Str"");
    for (int i=startTime; i > 0; i--) {
      System.out.print(i + ""String_Node_Str"");
      System.out.flush();
      Thread.sleep(1000);
    }
  }
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      AffinitySupport.setAffinity(1L << 3);
      while (reportCount.get() < ORDERS) {
        pe2GwReader.readOne();
      }
    }
  }
);
  t.start();
  Thread t2=new Thread(new Runnable(){
    @Override public void run(){
      int n=0;
      while (reportCount.get() < ORDERS) {
        while (reportCount.get() < n)         try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
          throw new AssertionError(e);
        }
        int count=reportCount.get();
        System.out.println(""String_Node_Str"" + count);
        n+=1000000;
      }
    }
  }
);
  t2.start();
  AffinitySupport.setAffinity(1L << 1);
  SmallCommand command=new SmallCommand();
  @SuppressWarnings(""String_Node_Str"") StringBuilder clientOrderId=command.clientOrderId;
  System.out.println(""String_Node_Str"");
  long start=System.nanoTime();
  for (int i=0; i < ORDERS + WARMUP; i++) {
    if (i == WARMUP)     start=System.nanoTime();
    clientOrderId.setLength(0);
    clientOrderId.append(""String_Node_Str"");
    clientOrderId.append(gwId);
    clientOrderId.append('-');
    clientOrderId.append(i);
    command.instrument=""String_Node_Str"";
    command.price=1209.41;
    command.quantity=1000;
    command.side=(i & 1) == 0 ? Side.BUY : Side.SELL;
    if (!throughputTest) {
      long expectedTime=start + i * EVENT_SPACING - 30;
      while (System.nanoTime() < expectedTime) {
      }
    }
    gw2PeWriter.small(null,command);
  }
  System.out.println(""String_Node_Str"" + reportCount.get());
  t.join();
  long time=System.nanoTime() - start;
  Arrays.sort(times);
  System.out.printf(""String_Node_Str"",ORDERS,time / 1e9);
  if (!throughputTest) {
    System.out.printf(""String_Node_Str"",times[ORDERS / 2] / 1e3,times[ORDERS * 9 / 10] / 1e3,times[ORDERS - ORDERS / 100] / 1e3,times[ORDERS - ORDERS / 1000] / 1000,times[ORDERS - ORDERS / 10000] / 1000,times[ORDERS - 1] / 1000);
  }
  gw2pe.close();
  pe2gw.close();
}"
41803,"protected boolean indexForRead(long l){
  if (l < 0) {
    padding=true;
    return false;
  }
  long indexLookup=l / indexEntriesPerBlock;
  indexBuffer=chronicle.indexFileCache.acquireBuffer(indexLookup,true);
  indexStartAddr=((DirectBuffer)indexBuffer).address();
  long indexLookupMod=l % indexEntriesPerBlock;
  int indexLineEntry=(int)(indexLookupMod % indexEntriesPerLine);
  int indexLineStart=(int)(indexLookupMod / indexEntriesPerLine * cacheLineSize);
  int inLine=(indexLineEntry << 2) + 8;
  int dataOffsetEnd=UNSAFE.getInt(indexStartAddr + indexLineStart + inLine);
  indexBaseForLine=UNSAFE.getLong(indexStartAddr + indexLineStart);
  indexPositionAddr=indexStartAddr + indexLineStart + inLine;
  long dataOffsetStart=inLine == 0 ? indexBaseForLine : (indexBaseForLine + Math.abs(UNSAFE.getInt(indexPositionAddr - 4)));
  long dataLookup=dataOffsetStart / dataBlockSize;
  long dataLookupMod=dataOffsetStart % dataBlockSize;
  MappedByteBuffer dataMBB=chronicle.dataFileCache.acquireBuffer(dataLookup,true);
  long dataAddr=((DirectBuffer)dataMBB).address();
  startAddr=positionAddr=dataAddr + dataLookupMod;
  index=l;
  if (dataOffsetEnd > 0) {
    limitAddr=dataAddr + (indexBaseForLine + dataOffsetEnd - dataLookup * dataBlockSize);
    indexPositionAddr+=4;
    padding=false;
    return true;
  }
 else   if (dataOffsetEnd == 0) {
    limitAddr=startAddr;
    padding=false;
    return false;
  }
 else {
    padding=true;
    return false;
  }
}","protected boolean indexForRead(long l){
  if (l < 0) {
    indexBuffer=chronicle.indexFileCache.acquireBuffer(0,true);
    indexStartAddr=((DirectBuffer)indexBuffer).address();
    indexPositionAddr=indexStartAddr;
    index=-1;
    padding=true;
    return false;
  }
  long indexLookup=l / indexEntriesPerBlock;
  indexBuffer=chronicle.indexFileCache.acquireBuffer(indexLookup,true);
  indexStartAddr=((DirectBuffer)indexBuffer).address();
  long indexLookupMod=l % indexEntriesPerBlock;
  int indexLineEntry=(int)(indexLookupMod % indexEntriesPerLine);
  int indexLineStart=(int)(indexLookupMod / indexEntriesPerLine * cacheLineSize);
  int inLine=(indexLineEntry << 2) + 8;
  int dataOffsetEnd=UNSAFE.getInt(indexStartAddr + indexLineStart + inLine);
  indexBaseForLine=UNSAFE.getLong(indexStartAddr + indexLineStart);
  indexPositionAddr=indexStartAddr + indexLineStart + inLine;
  long dataOffsetStart=inLine == 0 ? indexBaseForLine : (indexBaseForLine + Math.abs(UNSAFE.getInt(indexPositionAddr - 4)));
  long dataLookup=dataOffsetStart / dataBlockSize;
  long dataLookupMod=dataOffsetStart % dataBlockSize;
  MappedByteBuffer dataMBB=chronicle.dataFileCache.acquireBuffer(dataLookup,true);
  long dataAddr=((DirectBuffer)dataMBB).address();
  startAddr=positionAddr=dataAddr + dataLookupMod;
  index=l;
  if (dataOffsetEnd > 0) {
    limitAddr=dataAddr + (indexBaseForLine + dataOffsetEnd - dataLookup * dataBlockSize);
    indexPositionAddr+=4;
    padding=false;
    return true;
  }
 else   if (dataOffsetEnd == 0) {
    limitAddr=startAddr;
    padding=false;
    return false;
  }
 else {
    padding=true;
    return false;
  }
}"
41804,"@Test public void testWasPadding() throws IOException {
  final String basePath=TMP + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(basePath);
  ChronicleConfig config=ChronicleConfig.TEST.clone();
  config.dataBlockSize(128);
  config.indexBlockSize(128);
  IndexedChronicle chronicle1=new IndexedChronicle(basePath,config);
  ExcerptAppender appender=chronicle1.createAppender();
  IndexedChronicle chronicle2=new IndexedChronicle(basePath,config);
  ExcerptTailer tailer=chronicle2.createTailer();
  assertEquals(-1,tailer.index());
  assertTrue(tailer.wasPadding());
  assertFalse(tailer.index(-1));
  assertTrue(tailer.wasPadding());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(0,tailer.index());
  assertTrue(tailer.index(0));
  assertFalse(tailer.wasPadding());
  assertFalse(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(0,tailer.index());
  assertFalse(tailer.index(1));
  assertFalse(tailer.wasPadding());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(1));
  assertFalse(tailer.wasPadding());
  assertEquals(1,tailer.index());
  assertFalse(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(1,tailer.index());
  assertFalse(tailer.index(2));
  assertFalse(tailer.wasPadding());
  assertEquals(2,tailer.index());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertFalse(tailer.index(2));
  assertTrue(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(1));
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(3,tailer.index());
  assertFalse(tailer.index(2));
  assertTrue(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(3));
  assertFalse(tailer.wasPadding());
  assertEquals(3,tailer.index());
  assertFalse(tailer.index(4));
  assertFalse(tailer.wasPadding());
  assertEquals(4,tailer.index());
  chronicle1.close();
  chronicle2.close();
}","@Test public void testWasPadding() throws IOException {
  final String basePath=TMP + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(basePath);
  ChronicleConfig config=ChronicleConfig.TEST.clone();
  config.dataBlockSize(128);
  config.indexBlockSize(128);
  IndexedChronicle chronicle1=new IndexedChronicle(basePath,config);
  ExcerptAppender appender=chronicle1.createAppender();
  IndexedChronicle chronicle2=new IndexedChronicle(basePath,config);
  ExcerptTailer tailer=chronicle2.createTailer();
  assertEquals(-1,tailer.index());
  assertTrue(tailer.wasPadding());
  assertFalse(tailer.index(-1));
  assertTrue(tailer.wasPadding());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(0,tailer.index());
  assertTrue(tailer.index(0));
  assertFalse(tailer.wasPadding());
  assertFalse(tailer.index(-1));
  assertEquals(-1,tailer.index());
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(0,tailer.index());
  assertFalse(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(0,tailer.index());
  assertFalse(tailer.index(1));
  assertFalse(tailer.wasPadding());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(1));
  assertFalse(tailer.wasPadding());
  assertEquals(1,tailer.index());
  assertFalse(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(1,tailer.index());
  assertFalse(tailer.index(2));
  assertFalse(tailer.wasPadding());
  assertEquals(2,tailer.index());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertFalse(tailer.index(2));
  assertTrue(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(1));
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(3,tailer.index());
  assertFalse(tailer.index(2));
  assertTrue(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(3));
  assertFalse(tailer.wasPadding());
  assertEquals(3,tailer.index());
  assertFalse(tailer.index(4));
  assertFalse(tailer.wasPadding());
  assertEquals(4,tailer.index());
  chronicle1.close();
  chronicle2.close();
}"
41805,"private long findTheLastIndex0(){
  long size=indexFileCache.size();
  if (size <= 0) {
    return -1;
  }
  int indexBlockSize=config.indexBlockSize();
  for (long block=size / indexBlockSize; block >= 0; block--) {
    MappedByteBuffer mbb=indexFileCache.acquireBuffer(block,false);
    if (block > 0 && mbb.getLong(0) == 0) {
      continue;
    }
    int cacheLineSize=config.cacheLineSize();
    for (int pos=0; pos < indexBlockSize; pos+=cacheLineSize) {
      if (mbb.getLong(pos + cacheLineSize) == 0) {
        int pos2=8;
        for (pos2=8; pos2 < cacheLineSize - 4; pos+=4) {
          if (mbb.getInt(pos + pos2) == 0)           break;
        }
        return (block * indexBlockSize + pos) / cacheLineSize * (cacheLineSize / 4 - 2) + pos / 4 - 1;
      }
    }
    return (block + 1) * indexBlockSize / cacheLineSize * (cacheLineSize / 4 - 2);
  }
  return -1;
}","private long findTheLastIndex0(){
  long size=indexFileCache.size();
  if (size <= 0) {
    return -1;
  }
  int indexBlockSize=config.indexBlockSize();
  for (long block=size / indexBlockSize; block >= 0; block--) {
    MappedByteBuffer mbb=indexFileCache.acquireBuffer(block,false);
    mbb.order(ByteOrder.nativeOrder());
    if (block > 0 && mbb.getLong(0) == 0) {
      continue;
    }
    int cacheLineSize=config.cacheLineSize();
    for (int pos=0; pos < indexBlockSize; pos+=cacheLineSize) {
      if (pos + cacheLineSize >= indexBlockSize || mbb.getLong(pos + cacheLineSize) == 0) {
        int pos2=8;
        for (pos2=8; pos2 < cacheLineSize; pos2+=4) {
          if (mbb.getInt(pos + pos2) == 0)           break;
        }
        return (block * indexBlockSize + pos) / cacheLineSize * (cacheLineSize / 4 - 2) + pos2 / 4 - 3;
      }
    }
    return (block + 1) * indexBlockSize / cacheLineSize * (cacheLineSize / 4 - 2);
  }
  return -1;
}"
41806,"public static void main(String... args) throws IOException {
  int zeros=0;
  FileChannel fc;
  try {
    fc=new FileInputStream(args[0]).getChannel();
  }
 catch (  FileNotFoundException e) {
    System.err.println(e);
    return;
  }
  ByteBuffer buffer=ByteBuffer.allocateDirect(4096).order(ByteOrder.nativeOrder());
  while (fc.read(buffer) > 0) {
    for (int i=0; i < buffer.capacity(); i+=4 * 16) {
      long indexStart=buffer.getLong(i);
      if (indexStart == 0 && zeros++ > 2) {
        continue;
      }
      System.out.print(HEX ? Long.toHexString(indexStart) : ""String_Node_Str"" + indexStart);
      for (int j=i + 8; j < i + 64; j+=4) {
        System.out.print(' ');
        int offset=buffer.getInt(j);
        System.out.print(HEX ? Integer.toHexString(offset) : ""String_Node_Str"" + offset);
      }
      System.out.println();
    }
    buffer.clear();
  }
  fc.close();
}","public static void main(String... args) throws IOException {
  int zeros=0;
  FileChannel fc;
  try {
    fc=new FileInputStream(args[0]).getChannel();
  }
 catch (  FileNotFoundException e) {
    System.err.println(e);
    return;
  }
  ByteBuffer buffer=ByteBuffer.allocateDirect(4096).order(ByteOrder.nativeOrder());
  while (fc.read(buffer) > 0) {
    for (int i=0; i < buffer.capacity(); i+=4 * 16) {
      long indexStart=buffer.getLong(i);
      if (indexStart == 0 && zeros++ > 2) {
        continue;
      }
      System.out.print(HEX ? Long.toHexString(indexStart) : String.valueOf(indexStart));
      for (int j=i + 8; j < i + 64; j+=4) {
        System.out.print(' ');
        int offset=buffer.getInt(j);
        System.out.print(HEX ? Integer.toHexString(offset) : String.valueOf(offset));
      }
      System.out.println();
    }
    buffer.clear();
  }
  fc.close();
}"
41807,"@Test @Ignore public void testAppending() throws IOException {
  int counter=0;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  ChronicleTools.deleteDirOnExit(basePath);
  for (int k=0; k < 15; k++) {
    RollingChronicle rc=new RollingChronicle(basePath,ChronicleConfig.TEST);
    ExcerptAppender appender=rc.createAppender();
    assertEquals(""String_Node_Str"" + k,(long)counter,appender.size());
    for (int i=0; i < 1; i++) {
      appender.startExcerpt(4);
      appender.writeInt(counter++);
      appender.finish();
      assertEquals(""String_Node_Str"" + k + ""String_Node_Str""+ i,(long)counter,appender.size());
    }
    appender.close();
    rc.close();
  }
  RollingChronicle rc=new RollingChronicle(basePath,ChronicleConfig.TEST);
  ExcerptTailer tailer=rc.createTailer();
  for (int i=0; i < counter; i++) {
    assertTrue(""String_Node_Str"" + i,tailer.nextIndex());
    assertEquals(i,tailer.readInt());
    tailer.finish();
  }
  rc.close();
}","@Test @Ignore public void testAppending() throws IOException {
  int counter=0;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  ChronicleTools.deleteDirOnExit(basePath);
  for (int k=0; k < 15; k++) {
    RollingChronicle rc=new RollingChronicle(basePath,ChronicleConfig.TEST);
    ExcerptAppender appender=rc.createAppender();
    assertEquals(""String_Node_Str"" + k,(long)counter,appender.size());
    for (int i=0; i < ChronicleConfig.TEST.indexFileExcerpts() * 2 / 7; i++) {
      appender.startExcerpt(4);
      appender.writeInt(counter++);
      appender.finish();
      assertEquals(""String_Node_Str"" + k + ""String_Node_Str""+ i,(long)counter,appender.size());
    }
    appender.close();
    rc.close();
  }
  RollingChronicle rc=new RollingChronicle(basePath,ChronicleConfig.TEST);
  ExcerptTailer tailer=rc.createTailer();
  for (int i=0; i < counter; i++) {
    assertTrue(""String_Node_Str"" + i,tailer.nextIndex());
    assertEquals(i,tailer.readInt());
    tailer.finish();
  }
  rc.close();
}"
41808,"public static void main(String... ignored) throws IOException {
  ChronicleTools.warmup();
  if (GWMain.WITH_BINDING)   PosixJNAAffinity.INSTANCE.setAffinity(1L << 5);
  String tmp=System.getProperty(""String_Node_Str"");
  ChronicleConfig config=ChronicleConfig.DEFAULT.clone();
  String pePath=tmp + ""String_Node_Str"";
  IndexedChronicle pe2gw=new IndexedChronicle(pePath,config);
  ExcerptAppender excerpt=pe2gw.createAppender();
  final Pe2GwWriter pe2GwWriter=new Pe2GwWriter(excerpt);
  Gw2PeEvents listener=new PEEvents(pe2GwWriter);
  Gw2PeReader[] readers=new Gw2PeReader[1];
  IndexedChronicle[] gw2pe=new IndexedChronicle[readers.length];
  for (int i=0; i < readers.length; i++) {
    int sourceId=i + 1;
    String gw2pePath=tmp + ""String_Node_Str"" + sourceId;
    gw2pe[i]=new IndexedChronicle(gw2pePath,config);
    readers[i]=new Gw2PeReader(sourceId,gw2pe[i].createTailer(),listener);
  }
  long prevProcessed=0, count=0;
  do {
    boolean readOne=false;
    for (    Gw2PeReader reader : readers) {
      readOne|=reader.readOne();
    }
    if (readOne) {
      count=0;
    }
 else     if (count++ > 1000000) {
      long processed=excerpt.index() + 1;
      if (prevProcessed != processed) {
        System.out.printf(""String_Node_Str"",processed);
        prevProcessed=processed;
      }
    }
  }
 while (true);
}","public static void main(String... ignored) throws IOException {
  ChronicleTools.warmup();
  if (GWMain.WITH_BINDING)   PosixJNAAffinity.INSTANCE.setAffinity(1L << 5);
  String tmp=System.getProperty(""String_Node_Str"");
  ChronicleConfig config=ChronicleConfig.DEFAULT.clone();
  String pePath=tmp + ""String_Node_Str"";
  ChronicleTools.deleteDirOnExit(pePath);
  IndexedChronicle pe2gw=new IndexedChronicle(pePath,config);
  ExcerptAppender excerpt=pe2gw.createAppender();
  final Pe2GwWriter pe2GwWriter=new Pe2GwWriter(excerpt);
  Gw2PeEvents listener=new PEEvents(pe2GwWriter);
  Gw2PeReader[] readers=new Gw2PeReader[1];
  IndexedChronicle[] gw2pe=new IndexedChronicle[readers.length];
  for (int i=0; i < readers.length; i++) {
    int sourceId=i + 1;
    String gw2pePath=tmp + ""String_Node_Str"" + sourceId;
    ChronicleTools.deleteDirOnExit(gw2pePath);
    gw2pe[i]=new IndexedChronicle(gw2pePath,config);
    readers[i]=new Gw2PeReader(sourceId,gw2pe[i].createTailer(),listener);
  }
  long prevProcessed=0, count=0;
  do {
    boolean readOne=false;
    for (    Gw2PeReader reader : readers) {
      readOne|=reader.readOne();
    }
    if (readOne) {
      count=0;
    }
 else     if (count++ > 1000000) {
      long processed=excerpt.index() + 1;
      if (prevProcessed != processed) {
        System.out.printf(""String_Node_Str"",processed);
        prevProcessed=processed;
      }
    }
  }
 while (true);
}"
41809,"@Override public void addPaddedEntry(){
  if (index != lastWrittenIndex()) {
    toEnd();
  }
  checkNewIndexLine();
  writePaddedEntry();
  loadNextDataBuffer();
  checkNewIndexLine();
  finished=true;
}","@Override public void addPaddedEntry(){
  if (index != lastWrittenIndex()) {
    toEnd();
  }
  if (index == 322)   Thread.yield();
  checkNewIndexLine();
  writePaddedEntry();
  loadNextDataBuffer();
  checkNewIndexLine();
  finished=true;
}"
41810,"void checkNewIndexLine2(){
  if ((indexPositionAddr & cacheLineMask) == 8) {
    indexBaseForLine=UNSAFE.getLongVolatile(null,indexPositionAddr - 8);
    setLmitAddr(0);
  }
}","void checkNewIndexLine2(){
}"
41811,"public boolean nextIndex(){
  return nextIndex0() || nextIndex0();
}","public boolean nextIndex(){
  checkNextLine();
  long offset=UNSAFE.getInt(null,indexPositionAddr);
  if (offset == 0)   offset=UNSAFE.getIntVolatile(null,indexPositionAddr);
  if (offset == 0) {
    return false;
  }
  index++;
  return nextIndex0(offset) || nextIndex1();
}"
41812,"private boolean readNextExcerpt(@NotNull SocketChannel sc){
  try {
    if (closed)     return false;
    if (readBuffer.remaining() < (scFirst ? TcpUtil.HEADER_SIZE : 4)) {
      if (readBuffer.remaining() == 0)       readBuffer.clear();
 else       readBuffer.compact();
      int minSize=scFirst ? 8 + 4 + 8 : 4 + 8;
      while (readBuffer.position() < minSize) {
        if (sc.read(readBuffer) < 0) {
          sc.close();
          return false;
        }
      }
      readBuffer.flip();
    }
    if (scFirst) {
      long scIndex=readBuffer.getLong();
      if (scIndex != chronicle.size())       throw new StreamCorruptedException(""String_Node_Str"" + chronicle.size() + ""String_Node_Str""+ scIndex);
      scFirst=false;
    }
    int size=readBuffer.getInt();
switch (size) {
case InProcessChronicleSource.IN_SYNC_LEN:
      return false;
case InProcessChronicleSource.PADDED_LEN:
    excerpt.addPaddedEntry();
  return true;
default :
break;
}
if (size > 128 << 20 || size < 0) throw new StreamCorruptedException(""String_Node_Str"" + size);
excerpt.startExcerpt(size);
long remaining=size;
int limit=readBuffer.limit();
int size2=(int)Math.min(readBuffer.remaining(),remaining);
remaining-=size2;
readBuffer.limit(readBuffer.position() + size2);
excerpt.write(readBuffer);
readBuffer.limit(limit);
while (remaining > 0) {
readBuffer.clear();
int size3=(int)Math.min(readBuffer.capacity(),remaining);
readBuffer.limit(size3);
if (sc.read(readBuffer) < 0) throw new EOFException();
readBuffer.flip();
remaining-=readBuffer.remaining();
excerpt.write(readBuffer);
}
excerpt.finish();
}
 catch (IOException e) {
if (logger.isLoggable(Level.FINE)) logger.log(Level.FINE,""String_Node_Str"" + address + ""String_Node_Str"",e);
 else if (logger.isLoggable(Level.INFO)) logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ e);
try {
sc.close();
}
 catch (IOException ignored) {
}
}
return true;
}","private boolean readNextExcerpt(@NotNull SocketChannel sc){
  try {
    if (closed)     return false;
    if (readBuffer.remaining() < (scFirst ? TcpUtil.HEADER_SIZE : 4)) {
      if (readBuffer.remaining() == 0)       readBuffer.clear();
 else       readBuffer.compact();
      int minSize=scFirst ? 8 + 4 + 8 : 4 + 8;
      while (readBuffer.position() < minSize) {
        if (sc.read(readBuffer) < 0) {
          sc.close();
          return false;
        }
      }
      readBuffer.flip();
    }
    if (scFirst) {
      long scIndex=readBuffer.getLong();
      if (scIndex != chronicle.size())       throw new StreamCorruptedException(""String_Node_Str"" + chronicle.size() + ""String_Node_Str""+ scIndex);
      scFirst=false;
    }
    int size=readBuffer.getInt();
switch (size) {
case InProcessChronicleSource.IN_SYNC_LEN:
      return false;
case InProcessChronicleSource.PADDED_LEN:
    excerpt.startExcerpt(chronicle.config().dataBlockSize() - 1);
  return true;
default :
break;
}
if (size > 128 << 20 || size < 0) throw new StreamCorruptedException(""String_Node_Str"" + size);
excerpt.startExcerpt(size);
long remaining=size;
int limit=readBuffer.limit();
int size2=(int)Math.min(readBuffer.remaining(),remaining);
remaining-=size2;
readBuffer.limit(readBuffer.position() + size2);
excerpt.write(readBuffer);
readBuffer.limit(limit);
while (remaining > 0) {
readBuffer.clear();
int size3=(int)Math.min(readBuffer.capacity(),remaining);
readBuffer.limit(size3);
if (sc.read(readBuffer) < 0) throw new EOFException();
readBuffer.flip();
remaining-=readBuffer.remaining();
excerpt.write(readBuffer);
}
excerpt.finish();
}
 catch (IOException e) {
if (logger.isLoggable(Level.FINE)) logger.log(Level.FINE,""String_Node_Str"" + address + ""String_Node_Str"",e);
 else if (logger.isLoggable(Level.INFO)) logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ e);
try {
sc.close();
}
 catch (IOException ignored) {
}
}
return true;
}"
41813,"@Test @Ignore public void testOverTCP() throws IOException, InterruptedException {
  String baseDir=System.getProperty(""String_Node_Str"");
  String srcBasePath=baseDir + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(srcBasePath);
  final int messages=2000;
  ChronicleConfig config=ChronicleConfig.TEST.clone();
  final Chronicle source=new InProcessChronicleSource(new IndexedChronicle(srcBasePath,config),PORT + 1);
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      try {
        ExcerptAppender excerpt=source.createAppender();
        for (int i=1; i <= messages; i++) {
          excerpt.startExcerpt(19);
          excerpt.writeLong(i);
          excerpt.append(' ');
          excerpt.append(i);
          excerpt.append('\n');
          excerpt.finish();
        }
        System.out.println(System.currentTimeMillis() + ""String_Node_Str"");
      }
 catch (      Exception e) {
        throw new AssertionError(e);
      }
    }
  }
);
  String snkBasePath=baseDir + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(snkBasePath);
  Chronicle sink=new InProcessChronicleSink(new IndexedChronicle(snkBasePath),""String_Node_Str"",PORT + 1);
  long start=System.nanoTime();
  t.start();
  ExcerptTailer excerpt=sink.createTailer();
  int count=0;
  for (int i=1; i <= messages; i++) {
    while (!excerpt.nextIndex())     count++;
    long n=excerpt.readLong();
    String text=excerpt.parseUTF(StopCharTesters.CONTROL_STOP);
    if (i != n)     assertEquals('\'' + text + '\'',i,n);
    excerpt.finish();
  }
  sink.close();
  System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
  t.join();
  source.close();
  long time=System.nanoTime() - start;
  System.out.printf(""String_Node_Str"",(int)(messages * 1e9 / time));
}","@Test public void testOverTCP() throws IOException, InterruptedException {
  String baseDir=System.getProperty(""String_Node_Str"");
  String srcBasePath=baseDir + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(srcBasePath);
  final int messages=2 * 1000 * 1000;
  ChronicleConfig config=ChronicleConfig.DEFAULT.clone();
  final Chronicle source=new InProcessChronicleSource(new IndexedChronicle(srcBasePath,config),PORT + 1);
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      try {
        ExcerptAppender excerpt=source.createAppender();
        for (int i=1; i <= messages; i++) {
          excerpt.startExcerpt(19);
          excerpt.writeLong(i);
          excerpt.append(' ');
          excerpt.append(i);
          excerpt.append('\n');
          excerpt.finish();
        }
        System.out.println(System.currentTimeMillis() + ""String_Node_Str"");
      }
 catch (      Exception e) {
        throw new AssertionError(e);
      }
    }
  }
);
  String snkBasePath=baseDir + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(snkBasePath);
  Chronicle sink=new InProcessChronicleSink(new IndexedChronicle(snkBasePath,config),""String_Node_Str"",PORT + 1);
  long start=System.nanoTime();
  t.start();
  ExcerptTailer excerpt=sink.createTailer();
  int count=0;
  for (int i=1; i <= messages; i++) {
    while (!excerpt.nextIndex())     count++;
    long n=excerpt.readLong();
    String text=excerpt.parseUTF(StopCharTesters.CONTROL_STOP);
    if (i != n)     assertEquals('\'' + text + '\'',i,n);
    excerpt.finish();
  }
  sink.close();
  System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
  t.join();
  source.close();
  long time=System.nanoTime() - start;
  System.out.printf(""String_Node_Str"",(int)(messages * 1e9 / time));
}"
41814,"@Test public void testCAD() throws Exception {
  String key=""String_Node_Str"";
  EtcdResponse result;
  result=this.client.set(key,""String_Node_Str"");
  result=this.client.get(key);
  Assert.assertEquals(""String_Node_Str"",result.node.value);
  Map<String,String> params=new HashMap<String,String>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  result=this.client.cad(key,params);
  Assert.assertEquals(true,result.isError());
  result=this.client.get(key);
  Assert.assertEquals(""String_Node_Str"",result.node.value);
}","@Test public void testCAD() throws Exception {
  String key=""String_Node_Str"";
  EtcdResponse result;
  result=this.client.set(key,""String_Node_Str"");
  result=this.client.get(key);
  Assert.assertEquals(""String_Node_Str"",result.node.value);
  Map<String,String> params=new HashMap<String,String>();
  params.put(""String_Node_Str"",""String_Node_Str"");
  result=this.client.cad(key,params);
  Assert.assertEquals(true,result.isError());
  result=this.client.get(key);
  Assert.assertEquals(""String_Node_Str"",result.node.value);
  params.clear();
  params.put(""String_Node_Str"",""String_Node_Str"");
  result=this.client.cad(key,params);
  Assert.assertEquals(""String_Node_Str"",result.action);
}"
41815,"@Test public void testDeleteDir() throws Exception {
  String key=prefix + ""String_Node_Str"";
  EtcdResponse result;
  result=this.client.set(key,""String_Node_Str"");
  Assert.assertEquals(result.node.key,key);
  Assert.assertEquals(result.node.value,""String_Node_Str"");
  result=this.client.deleteDir(prefix + ""String_Node_Str"",false);
  Assert.assertTrue(result.isError());
  result=this.client.deleteDir(prefix + ""String_Node_Str"",true);
  Assert.assertEquals(result.action,""String_Node_Str"");
  Assert.assertNotNull(result.prevNode);
  key=prefix + ""String_Node_Str"";
  result=this.client.createDir(key,null,null);
  Assert.assertEquals(key,result.node.key);
  Assert.assertTrue(result.node.dir);
  result=this.client.deleteDir(key,false);
  Assert.assertEquals(result.action,""String_Node_Str"");
}","@Test public void testDeleteDir() throws Exception {
  String key=prefix + ""String_Node_Str"";
  EtcdResponse result;
  result=this.client.set(key,""String_Node_Str"");
  Assert.assertEquals(result.node.key,key);
  Assert.assertEquals(result.node.value,""String_Node_Str"");
  try {
    result=this.client.deleteDir(prefix + ""String_Node_Str"",false);
    Assert.fail();
  }
 catch (  EtcdClientException e) {
    Assert.assertTrue(e.isEtcdError());
  }
  result=this.client.deleteDir(prefix + ""String_Node_Str"",true);
  Assert.assertEquals(result.action,""String_Node_Str"");
  Assert.assertNotNull(result.prevNode);
  key=prefix + ""String_Node_Str"";
  result=this.client.createDir(key,null,null);
  Assert.assertEquals(key,result.node.key);
  Assert.assertTrue(result.node.dir);
  result=this.client.deleteDir(key,false);
  Assert.assertEquals(result.action,""String_Node_Str"");
}"
41816,"@Test public void testListDir() throws Exception {
  String key=prefix + ""String_Node_Str"";
  EtcdResponse result;
  result=this.client.set(key,""String_Node_Str"",null);
  String keyTwo=prefix + ""String_Node_Str"";
  result=this.client.set(keyTwo,""String_Node_Str"",null);
  List<EtcdNode> nodes=this.client.listDir(key,true);
  Assert.assertEquals((long)nodes.size(),(long)2);
  this.client.deleteDir(key,true);
}","@Test public void testListDir() throws Exception {
  String key=prefix + ""String_Node_Str"";
  EtcdResponse result;
  result=this.client.set(key,""String_Node_Str"",null);
  String keyTwo=prefix + ""String_Node_Str"";
  result=this.client.set(keyTwo,""String_Node_Str"",null);
  List<EtcdNode> nodes=this.client.listDir(prefix + ""String_Node_Str"",true);
  Assert.assertEquals((long)nodes.size(),(long)2);
  this.client.deleteDir(key,true);
}"
41817,"@Override public HttpUriRequest getRedirect(HttpRequest httpRequest,HttpResponse httpResponse,HttpContext httpContext) throws ProtocolException {
  String redirectUrl=httpResponse.getFirstHeader(""String_Node_Str"").getValue();
  HttpUriRequest uriRequest;
  if (httpRequest instanceof HttpPut) {
    uriRequest=new HttpPut(redirectUrl);
    ((HttpPut)uriRequest).setEntity(((HttpPut)httpRequest).getEntity());
  }
 else   if (httpRequest instanceof HttpPost) {
    uriRequest=new HttpPost(redirectUrl);
    ((HttpPost)uriRequest).setEntity(((HttpPost)httpRequest).getEntity());
  }
 else   if (httpRequest instanceof HttpDelete) {
    uriRequest=new HttpDelete(redirectUrl);
  }
 else {
    uriRequest=new HttpGet(redirectUrl);
  }
  return uriRequest;
}","@Override public HttpUriRequest getRedirect(HttpRequest httpRequest,HttpResponse httpResponse,HttpContext httpContext) throws ProtocolException {
  String redirectUrl=httpResponse.getFirstHeader(""String_Node_Str"").getValue();
  HttpRequestWrapper requestWrapper=(HttpRequestWrapper)httpRequest;
  HttpUriRequest uriRequest;
  HttpRequest origin=requestWrapper.getOriginal();
  if (origin instanceof HttpPut) {
    uriRequest=new HttpPut(redirectUrl);
    ((HttpPut)uriRequest).setEntity(((HttpPut)origin).getEntity());
  }
 else   if (origin instanceof HttpPost) {
    uriRequest=new HttpPost(redirectUrl);
    ((HttpPost)uriRequest).setEntity(((HttpPost)origin).getEntity());
  }
 else   if (origin instanceof HttpDelete) {
    uriRequest=new HttpDelete(redirectUrl);
  }
 else {
    uriRequest=new HttpGet(redirectUrl);
  }
  return uriRequest;
}"
41818,"private EtcdResponse execute(HttpUriRequest request) throws EtcdClientException {
  try {
    return httpClient.execute(request,new JsonResponseHandler());
  }
 catch (  IOException e) {
    throw new EtcdClientException(""String_Node_Str"",e);
  }
}","/** 
 * Execute the specific HttpUriRequest
 * @param request request instance
 * @return EtcdResponse
 * @throws EtcdClientException
 */
private EtcdResponse execute(HttpUriRequest request) throws EtcdClientException {
  try {
    return httpClient.execute(request,new JsonResponseHandler());
  }
 catch (  IOException e) {
    throw unwrap(e);
  }
}"
41819,"/** 
 * Get the value of the key
 * @param key the key
 * @return the corresponding response
 */
public EtcdResponse get(String key) throws EtcdClientException {
  URI uri=buildUriWithKeyAndParams(key,null);
  HttpGet httpGet=new HttpGet(uri);
  EtcdResponse response=execute(httpGet);
  if (response.isError()) {
    if (response.errorCode == 100) {
      return null;
    }
  }
  return response;
}","/** 
 * Get the value of the key
 * @param key the key
 * @return the corresponding response
 */
public EtcdResponse get(String key) throws EtcdClientException {
  URI uri=buildUriWithKeyAndParams(key,null);
  HttpGet httpGet;
  httpGet=new HttpGet(uri);
  return execute(httpGet);
}"
41820,"private static EtcdResponse parseResponse(String json) throws EtcdClientException {
  EtcdResponse response;
  try {
    response=gson.fromJson(json,EtcdResponse.class);
  }
 catch (  JsonParseException e) {
    throw new EtcdClientException(""String_Node_Str"",e);
  }
  return response;
}","private static EtcdResponse parseResponse(String json) throws EtcdClientException {
  EtcdResponse response;
  try {
    response=gson.fromJson(json,EtcdResponse.class);
    if (response.isError()) {
      throw new EtcdClientException(""String_Node_Str"",response);
    }
  }
 catch (  JsonParseException e) {
    throw new EtcdClientException(""String_Node_Str"",e);
  }
  return response;
}"
41821,"public EtcdClientException(String message,int httpStatusCode){
  super(message + ""String_Node_Str"" + httpStatusCode+ ""String_Node_Str"");
  this.httpStatusCode=httpStatusCode;
}","public EtcdClientException(String message,EtcdResponse response){
  super(message);
  this.httpStatusCode=null;
  this.response=response;
}"
41822,"@Before public void setUp() throws Exception {
  client=new EtcdClient(new URI(""String_Node_Str""));
}","@Before public void setUp() throws Exception {
  client=new EtcdClient(new URI(""String_Node_Str""));
  prefix=""String_Node_Str"" + UUID.randomUUID().toString();
}"
41823,"@Override public void create(){
  assets=new AssetManager();
  String model=""String_Node_Str"";
  assets.load(model,Model.class);
  assets.finishLoading();
  modelInstance=new ModelInstance(assets.get(model,Model.class));
  DefaultShader.Config config=new Config();
  config.defaultCullFace=GL20.GL_NONE;
  ShaderProvider shaderProvider=new DefaultShaderProvider(config);
  modelBatch=new ModelBatch(shaderProvider);
  camera=new PerspectiveCamera();
  cameraController=new CameraInputController(camera);
  camera.position.set(10,10,10);
  camera.lookAt(0,0,0);
  Gdx.input.setInputProcessor(cameraController);
  viewport=new ScreenViewport(camera);
  ModelBuilder builder=new ModelBuilder();
  float groundSize=1000f;
  ground=new ModelInstance(builder.createRect(-groundSize,0,groundSize,groundSize,0,groundSize,groundSize,0,-groundSize,-groundSize,0,-groundSize,0,1,0,new Material(),Usage.Position | Usage.Normal),new Matrix4().setToTranslation(0,-0.01f,0));
  environment=new Environment();
  environment.set(new ColorAttribute(ColorAttribute.AmbientLight,0.4f,0.4f,0.4f,1f));
  environment.add(new DirectionalLight().set(0.8f,0.8f,0.8f,-1f,-0.8f,-0.2f));
  VirtualReality.renderer.listeners.add(this);
  VirtualReality.head.setCyclops(true);
}","@Override public void create(){
  assets=new AssetManager();
  String model=""String_Node_Str"";
  assets.load(model,Model.class);
  assets.finishLoading();
  modelInstance=new ModelInstance(assets.get(model,Model.class));
  DefaultShader.Config config=new Config();
  config.defaultCullFace=GL20.GL_NONE;
  ShaderProvider shaderProvider=new DefaultShaderProvider(config);
  modelBatch=new ModelBatch(shaderProvider);
  camera=new PerspectiveCamera();
  cameraController=new CameraInputController(camera);
  camera.position.set(10,10,10);
  camera.lookAt(0,0,0);
  Gdx.input.setInputProcessor(cameraController);
  viewport=new ScreenViewport(camera);
  ModelBuilder builder=new ModelBuilder();
  float groundSize=1000f;
  ground=new ModelInstance(builder.createRect(-groundSize,0,groundSize,groundSize,0,groundSize,groundSize,0,-groundSize,-groundSize,0,-groundSize,0,1,0,new Material(),Usage.Position | Usage.Normal),new Matrix4().setToTranslation(0,-0.01f,0));
  environment=new Environment();
  environment.set(new ColorAttribute(ColorAttribute.AmbientLight,0.4f,0.4f,0.4f,1f));
  environment.add(new DirectionalLight().set(0.8f,0.8f,0.8f,-1f,-0.8f,-0.2f));
  VirtualReality.renderer.listeners.add(this);
}"
41824,"/** 
 * Updates the viewport at (row, column) and sets it as the currently active one. The top left sub viewport is (0, 0).
 * @param row The index of the row with the viewport to be activated. Starts at 0.
 * @param column The index of the column with the viewport to be activated. Starts at 0.
 * @param centerCamera Whether the subView should center the camera or not.
 */
public void activateSubViewport(int row,int column,boolean centerCamera){
  validateCoordinates(row,column);
  Array<SubView> rowMap=subViews.get(row);
  Viewport viewport=rowMap.get(column).viewport;
  calculateSubViewportArea(row,column,subViewportArea);
  viewport.update((int)subViewportArea.width,(int)subViewportArea.height,centerCamera);
  float originalWorldWidth=viewport.getWorldWidth();
  float originalWorldHeight=viewport.getWorldHeight();
  if (viewport.getScreenWidth() > subViewportArea.width) {
    float offcutWidth=viewport.getScreenWidth() - subViewportArea.width;
    viewport.setScreenWidth((int)subViewportArea.width);
    viewport.setWorldWidth(viewport.getWorldWidth() - offcutWidth);
    viewport.setScreenX((int)(viewport.getScreenX() + offcutWidth / 2));
  }
  if (viewport.getScreenHeight() > subViewportArea.height) {
    float offcutHeight=viewport.getScreenHeight() - subViewportArea.height;
    viewport.setScreenHeight((int)subViewportArea.height);
    viewport.setWorldHeight(viewport.getWorldHeight() - offcutHeight);
    viewport.setScreenY((int)(viewport.getScreenY() + offcutHeight / 2));
  }
  viewport.setScreenX((int)(viewport.getScreenX() + subViewportArea.x));
  viewport.setScreenY((int)(viewport.getScreenX() + subViewportArea.y));
  viewport.apply();
  viewport.setWorldWidth(originalWorldWidth);
  viewport.setWorldHeight(originalWorldHeight);
  activeViewport=viewport;
}","/** 
 * Updates the viewport at (row, column) and sets it as the currently active one. The top left sub viewport is (0, 0).
 * @param row The index of the row with the viewport to be activated. Starts at 0.
 * @param column The index of the column with the viewport to be activated. Starts at 0.
 * @param centerCamera Whether the subView should center the camera or not.
 */
public void activateSubViewport(int row,int column,boolean centerCamera){
  validateCoordinates(row,column);
  Array<SubView> rowMap=subViews.get(row);
  Viewport viewport=rowMap.get(column).viewport;
  calculateSubViewportArea(row,column,subViewportArea);
  viewport.update((int)subViewportArea.width,(int)subViewportArea.height,centerCamera);
  float originalWorldWidth=viewport.getWorldWidth();
  float originalWorldHeight=viewport.getWorldHeight();
  if (viewport.getScreenWidth() > subViewportArea.width) {
    float offcutWidth=viewport.getScreenWidth() - subViewportArea.width;
    viewport.setScreenWidth((int)subViewportArea.width);
    viewport.setWorldWidth(viewport.getWorldWidth() - offcutWidth);
    viewport.setScreenX((int)(viewport.getScreenX() + offcutWidth / 2));
  }
  if (viewport.getScreenHeight() > subViewportArea.height) {
    float offcutHeight=viewport.getScreenHeight() - subViewportArea.height;
    viewport.setScreenHeight((int)subViewportArea.height);
    viewport.setWorldHeight(viewport.getWorldHeight() - offcutHeight);
    viewport.setScreenY((int)(viewport.getScreenY() + offcutHeight / 2));
  }
  viewport.setScreenX((int)(viewport.getScreenX() + subViewportArea.x));
  viewport.setScreenY((int)(viewport.getScreenY() + subViewportArea.y));
  viewport.apply();
  viewport.setWorldWidth(originalWorldWidth);
  viewport.setWorldHeight(originalWorldHeight);
  activeViewport=viewport;
}"
41825,"public void render(){
  for (  VirtualRealityRenderListener listener : listeners) {
    listener.frameStarted();
  }
  if (VirtualReality.head.isCyclops()) {
    renderEye(VirtualReality.head.getCyclopsEye(),new Vector3());
  }
 else {
    renderEye(VirtualReality.head.getLeftEye(),new Vector3(-VirtualReality.head.getInterpupillaryDistance() / 2f,0,0));
    renderEye(VirtualReality.head.getRightEye(),new Vector3(VirtualReality.head.getInterpupillaryDistance() / 2f,0,0));
  }
  for (  VirtualRealityRenderListener listener : listeners) {
    listener.frameEnded();
  }
}","public void render(){
  for (  VirtualRealityRenderListener listener : listeners) {
    listener.frameStarted();
  }
  int screenWidth=Gdx.graphics.getWidth();
  int screenHeight=Gdx.graphics.getHeight();
  if (VirtualReality.head.isCyclops()) {
    VirtualReality.head.getCyclopsEye().update(screenWidth,screenHeight);
    renderEye(VirtualReality.head.getCyclopsEye(),new Vector3());
  }
 else {
    splitViewport.update(screenWidth,screenHeight);
    splitViewport.activateSubViewport(0,0,false);
    renderEye(VirtualReality.head.getLeftEye(),new Vector3(-VirtualReality.head.getInterpupillaryDistance() / 2f,0,0));
    splitViewport.activateSubViewport(0,1,false);
    renderEye(VirtualReality.head.getRightEye(),new Vector3(VirtualReality.head.getInterpupillaryDistance() / 2f,0,0));
  }
  for (  VirtualRealityRenderListener listener : listeners) {
    listener.frameEnded();
  }
}"
41826,"private void renderEye(Viewport eye,Vector3 eyeOffset){
  int screenWidth=Gdx.graphics.getWidth();
  int screenHeight=Gdx.graphics.getHeight();
  eye.update(screenWidth,screenHeight);
  Camera camera=eye.getCamera();
  Vector3 eyePosition=camera.position;
  eyePosition.set(VirtualReality.body.position);
  eyePosition.add(VirtualReality.body.headOffset);
  Quaternion eyeOrientation=new Quaternion();
  eyeOrientation.set(VirtualReality.head.getOrientation());
  eyeOrientation.mul(VirtualReality.body.rotation);
  eyeOffset.mul(eyeOrientation);
  eyePosition.add(eyeOffset);
  Vector3 eyeDirection=new Vector3(0,0,-1);
  eyeDirection.mul(eyeOrientation);
  Vector3 eyeUp=new Vector3(0,1,0);
  eyeUp.mul(eyeOrientation);
  camera.position.set(eyePosition);
  camera.direction.set(eyeDirection);
  camera.up.set(eyeUp);
  camera.update(true);
  for (  VirtualRealityRenderListener listener : listeners) {
    listener.render(camera);
  }
}","private void renderEye(Viewport eye,Vector3 eyeOffset){
  Camera camera=eye.getCamera();
  Vector3 eyePosition=camera.position;
  eyePosition.set(VirtualReality.body.position);
  eyePosition.add(VirtualReality.body.headOffset);
  Quaternion eyeOrientation=new Quaternion();
  eyeOrientation.set(VirtualReality.head.getOrientation());
  eyeOrientation.mul(VirtualReality.body.orientation);
  eyeOffset.mul(eyeOrientation);
  eyePosition.add(eyeOffset);
  Vector3 eyeDirection=new Vector3(0,0,-1);
  eyeDirection.mul(eyeOrientation);
  Vector3 eyeUp=new Vector3(0,1,0);
  eyeUp.mul(eyeOrientation);
  camera.position.set(eyePosition);
  camera.direction.set(eyeDirection);
  camera.up.set(eyeUp);
  camera.update(true);
  for (  VirtualRealityRenderListener listener : listeners) {
    listener.render(camera);
  }
}"
41827,"/** 
 * The default constructor 
 */
private AIController(){
  Log.v(TAG,""String_Node_Str"");
  HoxApp.getApp().getAiEngine().initGame();
}","/** 
 * The default constructor 
 */
private AIController(){
  Log.v(TAG,""String_Node_Str"");
  HoxApp.getApp().getAiEngine().initGame();
  final TimeInfo initialTime=new TimeInfo(Enums.DEFAULT_INITIAL_GAME_TIMES);
  timeTracker_.setInitialColor(Enums.ColorEnum.COLOR_RED);
  timeTracker_.setInitialTime(initialTime);
  timeTracker_.setBlackTime(initialTime);
  timeTracker_.setRedTime(initialTime);
  playerTracker_.setRedInfo(HoxApp.getApp().getString(R.string.you_label),""String_Node_Str"");
  playerTracker_.setBlackInfo(HoxApp.getApp().getString(R.string.ai_label),""String_Node_Str"");
}"
41828,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (DEBUG_LIFE_CYCLE)   Log.v(TAG,""String_Node_Str"");
  setContentView(R.layout.activity_ai_table);
  Toolbar toolbar=(Toolbar)findViewById(R.id.my_toolbar);
  setSupportActionBar(toolbar);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  if (findViewById(R.id.board_container) != null) {
    if (savedInstanceState == null) {
      BoardFragment boardFragment=BoardFragment.newInstance(""String_Node_Str"");
      getSupportFragmentManager().beginTransaction().add(R.id.board_container,boardFragment).commit();
    }
  }
  aiController_.setBoardController(this);
  setupNewTable();
  setVolumeControlStream(SoundManager.getInstance().getStreamType());
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (DEBUG_LIFE_CYCLE)   Log.v(TAG,""String_Node_Str"");
  setContentView(R.layout.activity_ai_table);
  Toolbar toolbar=(Toolbar)findViewById(R.id.my_toolbar);
  setSupportActionBar(toolbar);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  if (findViewById(R.id.board_container) != null) {
    if (savedInstanceState == null) {
      BoardFragment boardFragment=BoardFragment.newInstance(""String_Node_Str"");
      getSupportFragmentManager().beginTransaction().add(R.id.board_container,boardFragment).commit();
    }
  }
  aiController_.setBoardController(this);
  prepareTableOnCreate();
  setVolumeControlStream(SoundManager.getInstance().getStreamType());
}"
41829,"private void restoreHistoryMoves(BoardFragment boardFragment){
  List<Piece.Move> historyMoves=aiController_.getHistoryMoves();
  if (historyMoves.size() > 0) {
    Log.d(TAG,""String_Node_Str"" + historyMoves.size());
    for (    Piece.Move move : historyMoves) {
      referee_.validateMove(move.fromPosition.row,move.fromPosition.column,move.toPosition.row,move.toPosition.column);
    }
    int lastGameStatus=referee_.getGameStatus();
    boardFragment.restoreMoveHistory(historyMoves,lastGameStatus);
  }
}","private void restoreHistoryMoves(BoardFragment boardFragment){
  List<Piece.Move> historyMoves=aiController_.getHistoryMoves();
  if (historyMoves.size() > 0) {
    Log.d(TAG,""String_Node_Str"" + historyMoves.size());
    for (    Piece.Move move : historyMoves) {
      referee_.validateMove(move.fromPosition.row,move.fromPosition.column,move.toPosition.row,move.toPosition.column);
    }
    int lastGameStatus=referee_.getGameStatus();
    boardFragment.restoreMoveHistory(historyMoves,lastGameStatus);
    timeTracker_.start();
  }
}"
41830,"@Override public void updateBoardWithNewTableInfo(TableInfo tableInfo){
  Log.d(TAG,""String_Node_Str"");
  tableId_=tableInfo.tableId;
  setAndShowTitle(tableInfo.tableId);
  invalidateOptionsMenu();
  referee_.resetGame();
  BoardFragment boardFragment=myBoardFragment_.get();
  if (boardFragment != null) {
    boardFragment.resetBoard();
  }
  PlayersFragment playersFragment=myPlayersFragment_.get();
  if (playersFragment != null) {
    playersFragment.refreshPlayersIfNeeded();
  }
}","@Override public void updateBoardWithNewTableInfo(TableInfo tableInfo){
  Log.d(TAG,""String_Node_Str"");
  tableId_=tableInfo.tableId;
  setAndShowTitle(tableId_);
  invalidateOptionsMenu();
  referee_.resetGame();
  BoardFragment boardFragment=myBoardFragment_.get();
  if (boardFragment != null) {
    boardFragment.resetBoard();
  }
  PlayersFragment playersFragment=myPlayersFragment_.get();
  if (playersFragment != null) {
    playersFragment.refreshPlayersIfNeeded();
  }
}"
41831,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Log.v(TAG,""String_Node_Str"");
  setContentView(R.layout.activity_network_table);
  Toolbar toolbar=(Toolbar)findViewById(R.id.my_toolbar);
  setSupportActionBar(toolbar);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  MainPagerAdapter pagerAdapter=new MainPagerAdapter(this,getSupportFragmentManager());
  viewPager_=(ViewPager)findViewById(R.id.network_table_view_pager);
  viewPager_.setAdapter(pagerAdapter);
  viewPager_.setOffscreenPageLimit(2);
  viewPager_.addOnPageChangeListener(this);
  tableController_.setBoardController(this);
  timeTracker_=tableController_.getTimeTracker();
  playerTracker_=tableController_.getPlayerTracker();
  tableId_=getIntent().getStringExtra(EXTRA_TABLE_ID);
  Log.d(TAG,""String_Node_Str"" + tableId_ + ""String_Node_Str"");
  if (TextUtils.isEmpty(tableId_)) {
    NetworkController.getInstance().sendRequestToOpenNewTable();
  }
 else {
    NetworkController.getInstance().handleTableSelection(tableId_);
  }
  setVolumeControlStream(SoundManager.getInstance().getStreamType());
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Log.v(TAG,""String_Node_Str"");
  setContentView(R.layout.activity_network_table);
  Toolbar toolbar=(Toolbar)findViewById(R.id.my_toolbar);
  setSupportActionBar(toolbar);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  MainPagerAdapter pagerAdapter=new MainPagerAdapter(this,getSupportFragmentManager());
  viewPager_=(ViewPager)findViewById(R.id.network_table_view_pager);
  viewPager_.setAdapter(pagerAdapter);
  viewPager_.setOffscreenPageLimit(2);
  viewPager_.addOnPageChangeListener(this);
  tableController_.setBoardController(this);
  if (savedInstanceState == null) {
    tableId_=getIntent().getStringExtra(EXTRA_TABLE_ID);
    Log.d(TAG,""String_Node_Str"" + tableId_ + ""String_Node_Str"");
    if (TextUtils.isEmpty(tableId_)) {
      NetworkController.getInstance().sendRequestToOpenNewTable();
    }
 else {
      NetworkController.getInstance().handleTableSelection(tableId_);
    }
  }
 else {
    tableId_=NetworkController.getInstance().getMyTableId();
    Log.d(TAG,""String_Node_Str"" + tableId_ + ""String_Node_Str"");
    setAndShowTitle(tableId_);
  }
  setVolumeControlStream(SoundManager.getInstance().getStreamType());
}"
41832,"public void loginServer(){
  loadPreferences_Account();
  networkController_.setLoginInfo(pid_,password_);
  networkController_.connectToServer();
}","public void loginServer(){
  networkController_.setLoginInfo(pid_,password_);
  networkController_.connectToServer();
}"
41833,"private void openNotificationView(){
  Log.d(TAG,""String_Node_Str"");
  Intent intent=new Intent(this,ChatBubbleActivity.class);
  startActivity(intent);
  notifCount_=0;
  invalidateOptionsMenu();
}","private void openNotificationView(){
  Log.d(TAG,""String_Node_Str"");
  startActivity(new Intent(this,ChatBubbleActivity.class));
  invalidateOptionsMenu();
}"
41834,"@Override protected void onResume(){
  super.onResume();
  if (DEBUG_LIFE_CYCLE)   Log.v(TAG,""String_Node_Str"");
  MessageManager.getInstance().addListener(this);
  adjustScreenOnFlagBasedOnGameStatus();
}","@Override protected void onResume(){
  super.onResume();
  if (DEBUG_LIFE_CYCLE)   Log.v(TAG,""String_Node_Str"");
  if (notificationMenuItem_ != null) {
    BadgeDrawable.setBadgeCount(this,notificationMenuItem_,MessageManager.getInstance().getNotificationCount());
  }
  MessageManager.getInstance().addListener(this);
  adjustScreenOnFlagBasedOnGameStatus();
}"
41835,"@Override public void onMessageReceived(MessageInfo messageInfo){
  Log.d(TAG,""String_Node_Str"" + messageInfo.getId() + ""String_Node_Str""+ messageInfo+ ""String_Node_Str"");
  if (messageInfo.type == MessageInfo.MessageType.MESSAGE_TYPE_INVITE_TO_PLAY || messageInfo.type == MessageInfo.MessageType.MESSAGE_TYPE_CHAT_PRIVATE) {
    notifCount_++;
    invalidateOptionsMenu();
  }
}","@Override public void onMessageReceived(MessageInfo messageInfo){
  Log.d(TAG,""String_Node_Str"" + messageInfo.getId() + ""String_Node_Str""+ messageInfo+ ""String_Node_Str"");
  if (MessageManager.getInstance().isNotificationType(messageInfo.type)) {
    invalidateOptionsMenu();
  }
}"
41836,"@Override public boolean onCreateOptionsMenu(Menu menu){
  Log.d(TAG,""String_Node_Str"");
  getMenuInflater().inflate(R.menu.main_activity_actions,menu);
  MenuItem item=menu.findItem(R.id.action_notifications);
  LayerDrawable icon=(LayerDrawable)item.getIcon();
  BadgeDrawable.setBadgeCount(this,icon,notifCount_);
  return super.onCreateOptionsMenu(menu);
}","@Override public boolean onCreateOptionsMenu(Menu menu){
  Log.d(TAG,""String_Node_Str"");
  getMenuInflater().inflate(R.menu.main_activity_actions,menu);
  notificationMenuItem_=menu.findItem(R.id.action_notifications);
  BadgeDrawable.setBadgeCount(this,notificationMenuItem_,MessageManager.getInstance().getNotificationCount());
  return super.onCreateOptionsMenu(menu);
}"
41837,"/** 
 * A helper function to update LayerDrawable's BadgeDrawable
 */
public static void setBadgeCount(Context context,LayerDrawable icon,int count){
  BadgeDrawable badge;
  Drawable reuse=icon.findDrawableByLayerId(R.id.ic_badge);
  if (reuse != null && reuse instanceof BadgeDrawable) {
    badge=(BadgeDrawable)reuse;
  }
 else {
    badge=new BadgeDrawable(context);
  }
  badge.setCount(count);
  icon.mutate();
  icon.setDrawableByLayerId(R.id.ic_badge,badge);
}","public static void setBadgeCount(Context context,MenuItem menuItem,int count){
  if (menuItem != null) {
    LayerDrawable icon=(LayerDrawable)menuItem.getIcon();
    BadgeDrawable.setBadgeCount(context,icon,count);
  }
}"
41838,"@Override protected void onPause(){
  super.onPause();
  Log.d(TAG,""String_Node_Str"");
  NetworkController.getInstance().removeListener(this);
  MessageManager.getInstance().removeListener(this);
}","@Override protected void onPause(){
  super.onPause();
  Log.d(TAG,""String_Node_Str"");
  MessageManager.getInstance().removeListener(this);
  NetworkController.getInstance().removeListener(this);
}"
41839,"@Override public boolean onOptionsItemSelected(MenuItem item){
  Log.d(TAG,""String_Node_Str"");
  if (drawerToggle_.onOptionsItemSelected(item)) {
    return true;
  }
switch (item.getItemId()) {
case R.id.action_notifications:
    openChatView();
  return true;
default :
return super.onOptionsItemSelected(item);
}
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  Log.d(TAG,""String_Node_Str"");
  if (drawerToggle_.onOptionsItemSelected(item)) {
    return true;
  }
switch (item.getItemId()) {
case R.id.action_notifications:
    openNotificationView();
  return true;
default :
return super.onOptionsItemSelected(item);
}
}"
41840,"@Override protected void onResume(){
  super.onResume();
  Log.d(TAG,""String_Node_Str"");
  NetworkController.getInstance().addListener(this);
  MessageManager.getInstance().addListener(this);
}","@Override protected void onResume(){
  super.onResume();
  Log.d(TAG,""String_Node_Str"");
  if (notificationMenuItem_ != null) {
    BadgeDrawable.setBadgeCount(this,notificationMenuItem_,MessageManager.getInstance().getNotificationCount());
  }
  MessageManager.getInstance().addListener(this);
  NetworkController.getInstance().addListener(this);
}"
41841,"@Override public void onMessageReceived(MessageInfo messageInfo){
  Log.d(TAG,""String_Node_Str"" + messageInfo.getId() + ""String_Node_Str""+ messageInfo+ ""String_Node_Str"");
  if (messageInfo.type == MessageInfo.MessageType.MESSAGE_TYPE_INVITE_TO_PLAY || messageInfo.type == MessageInfo.MessageType.MESSAGE_TYPE_CHAT_PRIVATE) {
    notifCount_++;
    invalidateOptionsMenu();
  }
}","@Override public void onMessageReceived(MessageInfo messageInfo){
  Log.d(TAG,""String_Node_Str"" + messageInfo.getId() + ""String_Node_Str""+ messageInfo+ ""String_Node_Str"");
  if (MessageManager.getInstance().isNotificationType(messageInfo.type)) {
    invalidateOptionsMenu();
  }
}"
41842,"@Override public boolean onCreateOptionsMenu(Menu menu){
  Log.d(TAG,""String_Node_Str"");
  getMenuInflater().inflate(R.menu.main_activity_actions,menu);
  MenuItem item=menu.findItem(R.id.action_notifications);
  LayerDrawable icon=(LayerDrawable)item.getIcon();
  BadgeDrawable.setBadgeCount(this,icon,notifCount_);
  return super.onCreateOptionsMenu(menu);
}","@Override public boolean onCreateOptionsMenu(Menu menu){
  Log.d(TAG,""String_Node_Str"");
  getMenuInflater().inflate(R.menu.main_activity_actions,menu);
  notificationMenuItem_=menu.findItem(R.id.action_notifications);
  BadgeDrawable.setBadgeCount(this,notificationMenuItem_,MessageManager.getInstance().getNotificationCount());
  return super.onCreateOptionsMenu(menu);
}"
41843,"private void openNotificationView(){
  Log.d(TAG,""String_Node_Str"");
  Intent intent=new Intent(this,ChatBubbleActivity.class);
  startActivity(intent);
  notifCount_=0;
  invalidateOptionsMenu();
}","private void openNotificationView(){
  Log.d(TAG,""String_Node_Str"");
  startActivity(new Intent(this,ChatBubbleActivity.class));
  invalidateOptionsMenu();
}"
41844,"@Override protected void onResume(){
  super.onResume();
  Log.d(TAG,""String_Node_Str"");
  MessageManager.getInstance().addListener(this);
  adjustScreenOnFlagBasedOnGameStatus();
}","@Override protected void onResume(){
  super.onResume();
  Log.d(TAG,""String_Node_Str"");
  if (notificationMenuItem_ != null) {
    BadgeDrawable.setBadgeCount(this,notificationMenuItem_,MessageManager.getInstance().getNotificationCount());
  }
  MessageManager.getInstance().addListener(this);
  adjustScreenOnFlagBasedOnGameStatus();
}"
41845,"@Override public void onMessageReceived(MessageInfo messageInfo){
  Log.d(TAG,""String_Node_Str"" + messageInfo.getId() + ""String_Node_Str""+ messageInfo+ ""String_Node_Str"");
  if (messageInfo.type == MessageInfo.MessageType.MESSAGE_TYPE_INVITE_TO_PLAY || messageInfo.type == MessageInfo.MessageType.MESSAGE_TYPE_CHAT_PRIVATE) {
    notifCount_++;
    invalidateOptionsMenu();
  }
 else   if (messageInfo.type == MessageInfo.MessageType.MESSAGE_TYPE_CHAT_IN_TABLE) {
    if (chatSheet_ != null) {
      chatSheet_.addNewMessage(messageInfo);
      messageInfo.markRead();
      return;
    }
    int currentPageIndex=viewPager_.getCurrentItem();
    if (currentPageIndex == MainPagerAdapter.POSITION_BOARD) {
      BoardFragment boardFragment=myBoardFragment_.get();
      if (boardFragment != null) {
        int unreadCount=MessageManager.getInstance().getUnreadCount(MessageInfo.MessageType.MESSAGE_TYPE_CHAT_IN_TABLE);
        Log.d(TAG,""String_Node_Str"" + unreadCount);
        boardFragment.setTableMessageCount(unreadCount);
      }
    }
  }
}","@Override public void onMessageReceived(MessageInfo messageInfo){
  Log.d(TAG,""String_Node_Str"" + messageInfo.getId() + ""String_Node_Str""+ messageInfo+ ""String_Node_Str"");
  if (MessageManager.getInstance().isNotificationType(messageInfo.type)) {
    invalidateOptionsMenu();
  }
 else   if (messageInfo.type == MessageInfo.MessageType.MESSAGE_TYPE_CHAT_IN_TABLE) {
    if (chatSheet_ != null) {
      chatSheet_.addNewMessage(messageInfo);
      messageInfo.markRead();
      return;
    }
    int currentPageIndex=viewPager_.getCurrentItem();
    if (currentPageIndex == MainPagerAdapter.POSITION_BOARD) {
      BoardFragment boardFragment=myBoardFragment_.get();
      if (boardFragment != null) {
        int unreadCount=MessageManager.getInstance().getUnreadCount(MessageInfo.MessageType.MESSAGE_TYPE_CHAT_IN_TABLE);
        Log.d(TAG,""String_Node_Str"" + unreadCount);
        boardFragment.setTableMessageCount(unreadCount);
      }
    }
  }
}"
41846,"@Override public boolean onCreateOptionsMenu(Menu menu){
  Log.d(TAG,""String_Node_Str"");
  getMenuInflater().inflate(R.menu.main_activity_actions,menu);
  MenuItem item=menu.findItem(R.id.action_notifications);
  LayerDrawable icon=(LayerDrawable)item.getIcon();
  BadgeDrawable.setBadgeCount(this,icon,notifCount_);
  return super.onCreateOptionsMenu(menu);
}","@Override public boolean onCreateOptionsMenu(Menu menu){
  Log.d(TAG,""String_Node_Str"");
  getMenuInflater().inflate(R.menu.main_activity_actions,menu);
  notificationMenuItem_=menu.findItem(R.id.action_notifications);
  BadgeDrawable.setBadgeCount(this,notificationMenuItem_,MessageManager.getInstance().getNotificationCount());
  return super.onCreateOptionsMenu(menu);
}"
41847,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  if (DEBUG_LIFE_CYCLE)   Log.d(TAG,""String_Node_Str"" + boardType_ + ""String_Node_Str""+ savedInstanceState);
  final View view=inflater.inflate(R.layout.fragment_main,container,false);
  boardView_=(BoardView)view.findViewById(R.id.board_view);
  messageBadgeText_=(TextView)view.findViewById(R.id.message_badge_text);
  topPlayerLabel=(TextView)view.findViewById(R.id.top_player_label);
  bottomPlayerLabel=(TextView)view.findViewById(R.id.bottom_player_label);
  topPlayerButton=(Button)view.findViewById(R.id.top_button);
  bottomPlayerButton=(Button)view.findViewById(R.id.bottom_button);
  topGameTimeView=(TextView)view.findViewById(R.id.top_game_time);
  topMoveTimeView=(TextView)view.findViewById(R.id.top_move_time);
  bottomGameTimeView=(TextView)view.findViewById(R.id.bottom_game_time);
  bottomMoveTimeView=(TextView)view.findViewById(R.id.bottom_move_time);
  if (HoxApp.getApp().isGameOver()) {
    final Enums.GameStatus gameStatus=HoxApp.getApp().getGameStatus();
    Log.d(TAG,""String_Node_Str"" + gameStatus);
    boardView_.onGameEnded(gameStatus);
  }
  boardView_.invalidate();
  setOnClickHandlers(view);
  listener_.onBoardFragment_CreateView(this);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  if (DEBUG_LIFE_CYCLE)   Log.d(TAG,""String_Node_Str"" + boardType_ + ""String_Node_Str""+ savedInstanceState);
  final View view=inflater.inflate(R.layout.fragment_main,container,false);
  boardView_=(BoardView)view.findViewById(R.id.board_view);
  messageBadgeText_=(TextView)view.findViewById(R.id.message_badge_text);
  topPlayerLabel=(TextView)view.findViewById(R.id.top_player_label);
  bottomPlayerLabel=(TextView)view.findViewById(R.id.bottom_player_label);
  topPlayerButton=(Button)view.findViewById(R.id.top_button);
  bottomPlayerButton=(Button)view.findViewById(R.id.bottom_button);
  topGameTimeView=(TextView)view.findViewById(R.id.top_game_time);
  topMoveTimeView=(TextView)view.findViewById(R.id.top_move_time);
  bottomGameTimeView=(TextView)view.findViewById(R.id.bottom_game_time);
  bottomMoveTimeView=(TextView)view.findViewById(R.id.bottom_move_time);
  boardView_.invalidate();
  setOnClickHandlers(view);
  listener_.onBoardFragment_CreateView(this);
  return view;
}"
41848,"private void onGameOver(Canvas canvas){
  canvas.drawText(this.getContext().getString(R.string.game_over_text),startP_ + cellSize_ * 2.5f,startP_ + cellSize_ * 4.7f,noticePaint_);
}","private void onGameOver(Canvas canvas){
  canvas.drawText(getContext().getString(R.string.game_over_text),startP_ + cellSize_ * 2.5f,startP_ + cellSize_ * 4.7f,noticePaint_);
}"
41849,"private void drawReplayStatus(Canvas canvas){
  canvas.drawText(HoxApp.getApp().getString(R.string.replay_text,historyIndex_ + 1,historyMoves_.size()),startP_ + cellSize_ * 2.5f,startP_ + cellSize_ * 4.7f,noticePaint_);
}","private void drawReplayStatus(Canvas canvas){
  canvas.drawText(getContext().getString(R.string.replay_text,historyIndex_ + 1,historyMoves_.size()),startP_ + cellSize_ * 2.5f,startP_ + cellSize_ * 4.7f,noticePaint_);
}"
41850,"@Override public void onBoardFragment_CreateView(BoardFragment fragment){
  Log.d(TAG,""String_Node_Str"");
  myBoardFragment_=new WeakReference<BoardFragment>(fragment);
  BoardFragment boardFragment=myBoardFragment_.get();
  if (boardFragment != null) {
    boardFragment.setBoardEventListener(this);
    boardFragment.setupUIForTimeTracker(timeTracker_);
    boardFragment.setupUIForPlayerTracker(playerTracker_);
    timeTracker_.syncUI();
    playerTracker_.syncUI();
    restoreHistoryMoves(boardFragment);
  }
}","@Override public void onBoardFragment_CreateView(BoardFragment fragment){
  Log.d(TAG,""String_Node_Str"");
  myBoardFragment_=new WeakReference<BoardFragment>(fragment);
  BoardFragment boardFragment=myBoardFragment_.get();
  if (boardFragment != null) {
    boardFragment.setBoardEventListener(this);
    boardFragment.setupUIForTimeTracker(timeTracker_);
    boardFragment.setupUIForPlayerTracker(playerTracker_);
    timeTracker_.syncUI();
    playerTracker_.syncUI();
    restoreHistoryMoves(boardFragment);
    if (HoxApp.getApp().getNetworkController().isGameOver()) {
      final Enums.GameStatus gameStatus=HoxApp.getApp().getGameStatus();
      Log.d(TAG,""String_Node_Str"" + Utils.gameStatusToString(gameStatus));
      boardFragment.onGameEnded(gameStatus);
    }
  }
}"
41851,"private void restoreHistoryMoves(BoardFragment boardFragment){
  List<Piece.Move> historyMoves=referee_.getHistoryMoves();
  if (historyMoves.size() > 0) {
    Log.d(TAG,""String_Node_Str"" + historyMoves.size());
    Piece.Move[] moves=historyMoves.toArray(new Piece.Move[historyMoves.size()]);
    for (    Piece.Move move : moves) {
      referee_.validateMove(move.fromPosition.row,move.fromPosition.column,move.toPosition.row,move.toPosition.column);
    }
    int lastGameStatus=referee_.getGameStatus();
    boardFragment.restoreMoveHistory(historyMoves,lastGameStatus);
  }
}","private void restoreHistoryMoves(BoardFragment boardFragment){
  List<Piece.Move> historyMoves=referee_.getHistoryMoves();
  if (historyMoves.size() > 0) {
    Log.d(TAG,""String_Node_Str"" + historyMoves.size());
    Piece.Move[] moves=historyMoves.toArray(new Piece.Move[historyMoves.size()]);
    referee_.resetGame();
    for (    Piece.Move move : moves) {
      referee_.validateMove(move.fromPosition.row,move.fromPosition.column,move.toPosition.row,move.toPosition.column);
    }
    int lastGameStatus=referee_.getGameStatus();
    boardFragment.restoreMoveHistory(historyMoves,lastGameStatus);
  }
}"
41852,"public void reverseView(){
  Log.d(TAG,""String_Node_Str"");
  isBlackOnTop_=!isBlackOnTop_;
  boardView_.reverseView();
  HoxApp.getApp().getTimeTracker().reverseView();
  HoxApp.getApp().getPlayerTracker().reverseView();
}","private void reverseView(){
  Log.d(TAG,""String_Node_Str"" + isBlackOnTop_);
  boardView_.reverseView();
  HoxApp.getApp().getTimeTracker().reverseView();
  HoxApp.getApp().getPlayerTracker().reverseView();
}"
41853,"private void setOnClickHandlers(View view){
  ImageButton reverseViewButton=(ImageButton)view.findViewById(R.id.reverse_view);
  if (reverseViewButton != null) {
    reverseViewButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        reverseView();
      }
    }
);
  }
  ImageButton resetButton=(ImageButton)view.findViewById(R.id.action_reset);
  if (resetButton != null) {
    resetButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        if (listener_ != null) {
          listener_.onResetViewClick(v);
        }
      }
    }
);
  }
  Button topPlayerButton=(Button)view.findViewById(R.id.top_button);
  if (topPlayerButton != null) {
    topPlayerButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        Enums.ColorEnum clickedColor=(isBlackOnTop_ ? Enums.ColorEnum.COLOR_BLACK : Enums.ColorEnum.COLOR_RED);
        if (listener_ != null) {
          listener_.onChangeRoleRequest(clickedColor);
        }
      }
    }
);
  }
  Button bottomPlayerButton=(Button)view.findViewById(R.id.bottom_button);
  if (bottomPlayerButton != null) {
    bottomPlayerButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        Enums.ColorEnum clickedColor=(isBlackOnTop_ ? Enums.ColorEnum.COLOR_RED : Enums.ColorEnum.COLOR_BLACK);
        if (listener_ != null) {
          listener_.onChangeRoleRequest(clickedColor);
        }
      }
    }
);
  }
  ImageButton previousButton=(ImageButton)view.findViewById(R.id.replay_previous);
  if (previousButton != null) {
    previousButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        boardView_.onReplay_PREV(true);
      }
    }
);
    previousButton.setOnLongClickListener(new View.OnLongClickListener(){
      @Override public boolean onLongClick(      View v){
        boardView_.onReplay_BEGIN();
        return true;
      }
    }
);
  }
  ImageButton nextButton=(ImageButton)view.findViewById(R.id.replay_next);
  if (nextButton != null) {
    nextButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        boardView_.onReplay_NEXT(true);
      }
    }
);
    nextButton.setOnLongClickListener(new View.OnLongClickListener(){
      @Override public boolean onLongClick(      View v){
        boardView_.onReplay_END();
        return true;
      }
    }
);
  }
}","private void setOnClickHandlers(View view){
  ImageButton reverseViewButton=(ImageButton)view.findViewById(R.id.reverse_view);
  if (reverseViewButton != null) {
    reverseViewButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        isBlackOnTop_=!isBlackOnTop_;
        reverseView();
      }
    }
);
  }
  ImageButton resetButton=(ImageButton)view.findViewById(R.id.action_reset);
  if (resetButton != null) {
    resetButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        if (listener_ != null) {
          listener_.onResetViewClick(v);
        }
      }
    }
);
  }
  Button topPlayerButton=(Button)view.findViewById(R.id.top_button);
  if (topPlayerButton != null) {
    topPlayerButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        Log.d(TAG,""String_Node_Str"" + isBlackOnTop_);
        Enums.ColorEnum clickedColor=(isBlackOnTop_ ? Enums.ColorEnum.COLOR_BLACK : Enums.ColorEnum.COLOR_RED);
        if (listener_ != null) {
          listener_.onChangeRoleRequest(clickedColor);
        }
      }
    }
);
  }
  Button bottomPlayerButton=(Button)view.findViewById(R.id.bottom_button);
  if (bottomPlayerButton != null) {
    bottomPlayerButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        Log.d(TAG,""String_Node_Str"" + isBlackOnTop_);
        Enums.ColorEnum clickedColor=(isBlackOnTop_ ? Enums.ColorEnum.COLOR_RED : Enums.ColorEnum.COLOR_BLACK);
        if (listener_ != null) {
          listener_.onChangeRoleRequest(clickedColor);
        }
      }
    }
);
  }
  ImageButton previousButton=(ImageButton)view.findViewById(R.id.replay_previous);
  if (previousButton != null) {
    previousButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        boardView_.onReplay_PREV(true);
      }
    }
);
    previousButton.setOnLongClickListener(new View.OnLongClickListener(){
      @Override public boolean onLongClick(      View v){
        boardView_.onReplay_BEGIN();
        return true;
      }
    }
);
  }
  ImageButton nextButton=(ImageButton)view.findViewById(R.id.replay_next);
  if (nextButton != null) {
    nextButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        boardView_.onReplay_NEXT(true);
      }
    }
);
    nextButton.setOnLongClickListener(new View.OnLongClickListener(){
      @Override public boolean onLongClick(      View v){
        boardView_.onReplay_END();
        return true;
      }
    }
);
  }
}"
41854,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (DEBUG_LIFE_CYCLE)   Log.v(TAG,""String_Node_Str"");
  if (getArguments() != null) {
    boardType_=getArguments().getString(ARG_BOARD_TYPE);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (DEBUG_LIFE_CYCLE)   Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + savedInstanceState);
  if (getArguments() != null) {
    boardType_=getArguments().getString(ARG_BOARD_TYPE);
  }
}"
41855,"public void onLocalPlayerJoined(Enums.ColorEnum myColor){
  if ((myColor == Enums.ColorEnum.COLOR_RED && !isBlackOnTop_) || (myColor == Enums.ColorEnum.COLOR_BLACK && isBlackOnTop_)) {
    reverseView();
  }
}","public void onLocalPlayerJoined(Enums.ColorEnum myColor){
  Log.d(TAG,""String_Node_Str"" + myColor + ""String_Node_Str""+ isBlackOnTop_);
  if ((myColor == Enums.ColorEnum.COLOR_RED && !isBlackOnTop_) || (myColor == Enums.ColorEnum.COLOR_BLACK && isBlackOnTop_)) {
    isBlackOnTop_=!isBlackOnTop_;
    reverseView();
  }
}"
41856,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  if (DEBUG_LIFE_CYCLE)   Log.v(TAG,""String_Node_Str"");
  if (savedInstanceState != null) {
    boolean isBlackOnTop=savedInstanceState.getBoolean(STATE_IS_BLACK_ON_TOP,isBlackOnTop_);
    if (!isBlackOnTop) {
      reverseView();
    }
  }
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  if (DEBUG_LIFE_CYCLE)   Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + savedInstanceState);
  if (savedInstanceState != null) {
    isBlackOnTop_=savedInstanceState.getBoolean(STATE_IS_BLACK_ON_TOP,isBlackOnTop_);
    Log.d(TAG,""String_Node_Str"" + isBlackOnTop_);
  }
  if (!isBlackOnTop_) {
    reverseView();
  }
}"
41857,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  if (DEBUG_LIFE_CYCLE)   Log.d(TAG,""String_Node_Str"" + boardType_);
  final View view=inflater.inflate(R.layout.fragment_main,container,false);
  boardView_=(BoardView)view.findViewById(R.id.board_view);
  TextView topPlayerLabel=(TextView)view.findViewById(R.id.top_player_label);
  TextView bottomPlayerLabel=(TextView)view.findViewById(R.id.bottom_player_label);
  Button topPlayerButton=(Button)view.findViewById(R.id.top_button);
  Button bottomPlayerButton=(Button)view.findViewById(R.id.bottom_button);
  TextView topGameTimeView=(TextView)view.findViewById(R.id.top_game_time);
  TextView topMoveTimeView=(TextView)view.findViewById(R.id.top_move_time);
  TextView bottomGameTimeView=(TextView)view.findViewById(R.id.bottom_game_time);
  TextView bottomMoveTimeView=(TextView)view.findViewById(R.id.bottom_move_time);
  TableTimeTracker timeTracker=HoxApp.getApp().getTimeTracker();
  timeTracker.setUITextViews(topGameTimeView,topMoveTimeView,bottomGameTimeView,bottomMoveTimeView);
  timeTracker.reset();
  TablePlayerTracker playerTracker=HoxApp.getApp().getPlayerTracker();
  playerTracker.setUIViews(topPlayerLabel,topPlayerButton,bottomPlayerLabel,bottomPlayerButton);
  List<Piece.Move> historyMoves=HoxApp.getApp().getReferee().getHistoryMoves();
  int moveCount=historyMoves.size();
  int moveIndex=0;
  for (  Piece.Move move : historyMoves) {
    Log.d(TAG,""String_Node_Str"" + move.fromPosition + ""String_Node_Str""+ move.toPosition);
    final boolean isLastMove=(moveIndex == (moveCount - 1));
    boardView_.restoreMove(move.fromPosition,move.toPosition,isLastMove);
    ++moveIndex;
  }
  if (HoxApp.getApp().isGameOver()) {
    final Enums.GameStatus gameStatus=HoxApp.getApp().getGameStatus();
    Log.d(TAG,""String_Node_Str"" + gameStatus);
    boardView_.onGameEnded(gameStatus);
  }
  boardView_.invalidate();
  setOnClickHandlers(view);
  listener_.onBoardFragment_CreateView(this);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  if (DEBUG_LIFE_CYCLE)   Log.d(TAG,""String_Node_Str"" + boardType_ + ""String_Node_Str""+ savedInstanceState);
  final View view=inflater.inflate(R.layout.fragment_main,container,false);
  boardView_=(BoardView)view.findViewById(R.id.board_view);
  TextView topPlayerLabel=(TextView)view.findViewById(R.id.top_player_label);
  TextView bottomPlayerLabel=(TextView)view.findViewById(R.id.bottom_player_label);
  Button topPlayerButton=(Button)view.findViewById(R.id.top_button);
  Button bottomPlayerButton=(Button)view.findViewById(R.id.bottom_button);
  TextView topGameTimeView=(TextView)view.findViewById(R.id.top_game_time);
  TextView topMoveTimeView=(TextView)view.findViewById(R.id.top_move_time);
  TextView bottomGameTimeView=(TextView)view.findViewById(R.id.bottom_game_time);
  TextView bottomMoveTimeView=(TextView)view.findViewById(R.id.bottom_move_time);
  TableTimeTracker timeTracker=HoxApp.getApp().getTimeTracker();
  timeTracker.setUITextViews(topGameTimeView,topMoveTimeView,bottomGameTimeView,bottomMoveTimeView);
  timeTracker.reset();
  TablePlayerTracker playerTracker=HoxApp.getApp().getPlayerTracker();
  playerTracker.setUIViews(topPlayerLabel,topPlayerButton,bottomPlayerLabel,bottomPlayerButton);
  List<Piece.Move> historyMoves=HoxApp.getApp().getReferee().getHistoryMoves();
  int moveCount=historyMoves.size();
  int moveIndex=0;
  for (  Piece.Move move : historyMoves) {
    Log.d(TAG,""String_Node_Str"" + move.fromPosition + ""String_Node_Str""+ move.toPosition);
    final boolean isLastMove=(moveIndex == (moveCount - 1));
    boardView_.restoreMove(move.fromPosition,move.toPosition,isLastMove);
    ++moveIndex;
  }
  if (HoxApp.getApp().isGameOver()) {
    final Enums.GameStatus gameStatus=HoxApp.getApp().getGameStatus();
    Log.d(TAG,""String_Node_Str"" + gameStatus);
    boardView_.onGameEnded(gameStatus);
  }
  boardView_.invalidate();
  setOnClickHandlers(view);
  listener_.onBoardFragment_CreateView(this);
  return view;
}"
41858,"public void onPlayerLeave(String pid){
  final String myPid=HoxApp.getApp().getMyPid();
  if (myPid.equals(pid)) {
  }
 else {
    if (blackPlayer_.hasPid(pid)) {
      blackPlayer_=new PlayerInfo();
    }
 else     if (redPlayer_.hasPid(pid)) {
      redPlayer_=new PlayerInfo();
    }
  }
}","public void onPlayerLeave(String pid){
  final String myPid=HoxApp.getApp().getMyPid();
  if (myPid.equals(pid)) {
  }
 else {
    if (blackPlayer_.hasPid(pid)) {
      blackPlayer_=new PlayerInfo();
    }
 else     if (redPlayer_.hasPid(pid)) {
      redPlayer_=new PlayerInfo();
    }
 else {
      observers_.remove(pid);
    }
  }
}"
41859,"public void onPlayerJoin(String pid,String rating,Enums.ColorEnum playerColor){
  if (blackPlayer_.hasPid(pid)) {
    blackPlayer_=new PlayerInfo();
  }
 else   if (redPlayer_.hasPid(pid)) {
    redPlayer_=new PlayerInfo();
  }
switch (playerColor) {
case COLOR_BLACK:
    blackPlayer_=new PlayerInfo(pid,rating);
  break;
case COLOR_RED:
redPlayer_=new PlayerInfo(pid,rating);
break;
case COLOR_NONE:
default :
break;
}
}","public void onPlayerJoin(String pid,String rating,Enums.ColorEnum playerColor){
  if (blackPlayer_.hasPid(pid)) {
    blackPlayer_=new PlayerInfo();
  }
 else   if (redPlayer_.hasPid(pid)) {
    redPlayer_=new PlayerInfo();
  }
switch (playerColor) {
case COLOR_BLACK:
    blackPlayer_=new PlayerInfo(pid,rating);
  observers_.remove(pid);
break;
case COLOR_RED:
redPlayer_=new PlayerInfo(pid,rating);
observers_.remove(pid);
break;
case COLOR_NONE:
observers_.put(pid,new PlayerInfo(pid,rating));
break;
default :
break;
}
}"
41860,"public void setObservers(List<String> observers){
  observers_.clear();
  for (  String observer : observers) {
    observers_.put(observer,new PlayerInfo(observer,""String_Node_Str""));
  }
}","public void setObservers(List<String> observers){
  observers_.clear();
  for (  String pid : observers) {
    observers_.put(pid,new PlayerInfo(pid,""String_Node_Str""));
  }
}"
41861,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  View view=inflater.inflate(R.layout.activity_chat,container,false);
  buttonSend=(Button)view.findViewById(R.id.buttonSend);
  listView=(ListView)view.findViewById(R.id.listView);
  listView.setEmptyView(view.findViewById(R.id.emptyView));
  inputLayout=view.findViewById(R.id.input_layout);
  chatArrayAdapter=new ChatArrayAdapter(getActivity(),R.layout.activity_chat_singlemessage);
  listView.setAdapter(chatArrayAdapter);
  chatText=(EditText)view.findViewById(R.id.chatText);
  chatText.setOnKeyListener(new View.OnKeyListener(){
    public boolean onKey(    View v,    int keyCode,    KeyEvent event){
      if ((event.getAction() == KeyEvent.ACTION_DOWN) && (keyCode == KeyEvent.KEYCODE_ENTER)) {
        return sendChatMessage();
      }
      return false;
    }
  }
);
  buttonSend.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View arg0){
      sendChatMessage();
    }
  }
);
  listView.setTranscriptMode(AbsListView.TRANSCRIPT_MODE_ALWAYS_SCROLL);
  listView.setAdapter(chatArrayAdapter);
  chatArrayAdapter.registerDataSetObserver(new DataSetObserver(){
    @Override public void onChanged(){
      super.onChanged();
      listView.setSelection(chatArrayAdapter.getCount() - 1);
    }
  }
);
  syncWithNewMessages();
  chatArrayAdapter.add(new ChatMessage(true,""String_Node_Str""));
  chatArrayAdapter.add(new ChatMessage(true,""String_Node_Str""));
  inputLayout.setVisibility(View.VISIBLE);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  View view=inflater.inflate(R.layout.activity_chat,container,false);
  buttonSend=(Button)view.findViewById(R.id.buttonSend);
  listView=(ListView)view.findViewById(R.id.listView);
  listView.setEmptyView(view.findViewById(R.id.emptyView));
  inputLayout=view.findViewById(R.id.input_layout);
  chatArrayAdapter=new ChatArrayAdapter(getActivity(),R.layout.activity_chat_singlemessage);
  listView.setAdapter(chatArrayAdapter);
  chatText=(EditText)view.findViewById(R.id.chatText);
  chatText.setOnKeyListener(new View.OnKeyListener(){
    public boolean onKey(    View v,    int keyCode,    KeyEvent event){
      if ((event.getAction() == KeyEvent.ACTION_DOWN) && (keyCode == KeyEvent.KEYCODE_ENTER)) {
        return sendChatMessage();
      }
      return false;
    }
  }
);
  buttonSend.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View arg0){
      sendChatMessage();
    }
  }
);
  listView.setTranscriptMode(AbsListView.TRANSCRIPT_MODE_ALWAYS_SCROLL);
  listView.setAdapter(chatArrayAdapter);
  chatArrayAdapter.registerDataSetObserver(new DataSetObserver(){
    @Override public void onChanged(){
      super.onChanged();
      listView.setSelection(chatArrayAdapter.getCount() - 1);
    }
  }
);
  syncWithNewMessages();
  inputLayout.setVisibility(View.VISIBLE);
  return view;
}"
41862,"@Override public Fragment getItem(int position){
switch (position) {
case 0:
    return new PlaceholderFragment();
case 1:
{
    ChatFragment newFragment=new ChatFragment();
    chatFragment_=new WeakReference<ChatFragment>(newFragment);
    return newFragment;
  }
default :
return new PlayersFragment();
}
}","@Override public Fragment getItem(int position){
switch (position) {
case 0:
    return new PlaceholderFragment();
case 1:
  return new ChatFragment();
default :
return new PlayersFragment();
}
}"
41863,"/** 
 * Make the current table an EMPTY one.
 */
public void clearTable(){
  Log.d(TAG,""String_Node_Str"");
  if (getSupportActionBar() != null) {
    getSupportActionBar().setDisplayOptions(0,ActionBar.DISPLAY_SHOW_TITLE);
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
  invalidateOptionsMenu();
  boardView_.resetBoard();
  ChatFragment chatFragment=pagerAdapter_.getChatFragment();
  if (chatFragment != null) {
    chatFragment.clearAll();
  }
  adjustScreenOnFlagBasedOnGameStatus();
}","/** 
 * Make the current table an EMPTY one.
 */
public void clearTable(){
  Log.d(TAG,""String_Node_Str"");
  if (getSupportActionBar() != null) {
    getSupportActionBar().setDisplayOptions(0,ActionBar.DISPLAY_SHOW_TITLE);
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
  invalidateOptionsMenu();
  boardView_.resetBoard();
  ChatFragment chatFragment=myChatFragment_.get();
  if (chatFragment != null) {
    chatFragment.clearAll();
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
  adjustScreenOnFlagBasedOnGameStatus();
}"
41864,"private void adjustBoardParameters(int finalWidth,final int finalHeight){
  int configuration=getContext().getResources().getConfiguration().orientation;
  Log.i(TAG,""String_Node_Str"" + finalWidth + ""String_Node_Str""+ finalHeight+ ""String_Node_Str""+ Utils.orientationToString(configuration));
  if (configuration == Configuration.ORIENTATION_LANDSCAPE) {
    final int EXTRA_MARGIN=20;
    finalWidth=(int)((finalHeight / 9.0) * 8) - EXTRA_MARGIN;
    Log.i(TAG,""String_Node_Str"" + finalWidth);
    getLayoutParams().width=finalWidth;
    requestLayout();
  }
  final int boardWidth=Math.min(finalWidth,finalHeight);
  cellSize_=(boardWidth - 2 * offset_) / 9;
  pieceSize_=(int)(cellSize_ * 0.8f);
  if ((pieceSize_ % 2) == 1) {
    --pieceSize_;
  }
  startP_=offset_ + cellSize_ / 2;
  Log.d(TAG,""String_Node_Str"" + cellSize_ + ""String_Node_Str""+ pieceSize_+ ""String_Node_Str""+ startP_);
}","private void adjustBoardParameters(int finalWidth,final int finalHeight){
  int configuration=getContext().getResources().getConfiguration().orientation;
  Log.i(TAG,""String_Node_Str"" + finalWidth + ""String_Node_Str""+ finalHeight+ ""String_Node_Str""+ Utils.orientationToString(configuration));
  if (configuration == Configuration.ORIENTATION_LANDSCAPE) {
    final int EXTRA_MARGIN=20;
    finalWidth=(int)((finalHeight / 9.0) * 8) - EXTRA_MARGIN;
    Log.i(TAG,""String_Node_Str"" + finalWidth);
    getLayoutParams().width=finalWidth;
    requestLayout();
  }
 else   if (finalWidth > finalHeight) {
    final int cellSizeByHeight=(finalHeight - 2 * offset_) / 10;
    finalWidth=(cellSizeByHeight * 9) + 2 * offset_;
    Log.i(TAG,""String_Node_Str"" + finalWidth);
    getLayoutParams().width=finalWidth;
    requestLayout();
  }
  final int boardWidth=Math.min(finalWidth,finalHeight);
  cellSize_=(boardWidth - 2 * offset_) / 9;
  pieceSize_=(int)(cellSize_ * 0.8f);
  if ((pieceSize_ % 2) == 1) {
    --pieceSize_;
  }
  startP_=offset_ + cellSize_ / 2;
  Log.d(TAG,""String_Node_Str"" + cellSize_ + ""String_Node_Str""+ pieceSize_+ ""String_Node_Str""+ startP_);
}"
41865,"public void updateBoardWithNewTableInfo(TableInfo tableInfo){
  Log.d(TAG,""String_Node_Str"");
  setAndShowTitle(tableInfo.tableId);
  if (getSupportActionBar() != null) {
    getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
  invalidateOptionsMenu();
  boardView_.resetBoard();
}","public void updateBoardWithNewTableInfo(TableInfo tableInfo){
  Log.d(TAG,""String_Node_Str"");
  setAndShowTitle(tableInfo.tableId);
  invalidateOptionsMenu();
  boardView_.resetBoard();
}"
41866,"private void setAndShowTitle(String title){
  if (getSupportActionBar() != null) {
    getSupportActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_TITLE,ActionBar.DISPLAY_SHOW_TITLE);
    getSupportActionBar().setTitle(getString(R.string.title_table,title));
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
}","private void setAndShowTitle(String title){
  if (getSupportActionBar() != null) {
    getSupportActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_TITLE,ActionBar.DISPLAY_SHOW_TITLE);
    getSupportActionBar().setTitle(getString(R.string.title_table,title));
    getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
}"
41867,"private void handleNetworkEvent_LIST(String content){
  Log.d(TAG,""String_Node_Str"");
  MainActivity mainActivity=mainActivity_.get();
  if (mainActivity != null) {
    mainActivity.startActvityToListTables(content);
  }
}","private void handleNetworkEvent_LIST(String content){
  Log.d(TAG,""String_Node_Str"");
  MainActivity mainActivity=mainActivity_.get();
  if (mainActivity != null) {
    mainActivity.startActivityToListTables(content);
  }
}"
41868,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  View rootView=inflater.inflate(R.layout.fragment_main,container,false);
  return rootView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  return inflater.inflate(R.layout.fragment_main,container,false);
}"
41869,"public void resetBoard(){
  Log.d(TAG,""String_Node_Str"");
  referee_.resetGame();
  Piece piece;
  for (int i=0; i < 16; i++) {
    piece=redPieces_[i];
    piece.setCapture(false);
    piece.setPosition(piece.getInitialPosition());
    piece=blackPieces_[i];
    piece.setCapture(false);
    piece.setPosition(piece.getInitialPosition());
  }
  selectedPiece_=null;
  selectedPosition_=null;
  recentPiece_=null;
  gameStatus_=Referee.hoxGAME_STATUS_READY;
  historyMoves_.clear();
  historyIndex_=HISTORY_INDEX_END;
  captureStack_.clear();
  this.invalidate();
}","public void resetBoard(){
  Log.d(TAG,""String_Node_Str"");
  if (animator_ != null && animator_.isRunning()) {
    Log.i(TAG,""String_Node_Str"");
    animator_.end();
  }
  referee_.resetGame();
  Piece piece;
  for (int i=0; i < 16; i++) {
    piece=redPieces_[i];
    piece.setCapture(false);
    piece.setPosition(piece.getInitialPosition());
    piece=blackPieces_[i];
    piece.setCapture(false);
    piece.setPosition(piece.getInitialPosition());
  }
  selectedPiece_=null;
  selectedPosition_=null;
  recentPiece_=null;
  gameStatus_=Referee.hoxGAME_STATUS_READY;
  historyMoves_.clear();
  historyIndex_=HISTORY_INDEX_END;
  captureStack_.clear();
  this.invalidate();
}"
41870,"public void restoreMove(Position fromPos,Position toPos,boolean isLastMove){
  Log.d(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos+ ""String_Node_Str""+ isLastMove);
  Piece capture=tryCapturePieceAtPostion(toPos);
  addMoveToHistory(fromPos,toPos,capture);
  Piece fromPiece=getPieceAtViewPosition(fromPos);
  if (fromPiece == null) {
    Log.e(TAG,""String_Node_Str"" + fromPos);
    return;
  }
  fromPiece.setPosition(toPos);
  recentPiece_=fromPiece;
  if (isLastMove) {
    gameStatus_=referee_.getGameStatus();
  }
  if (capture != null) {
    captureStack_.add(capture);
  }
}","public void restoreMove(Position fromPos,Position toPos,boolean isLastMove){
  Log.d(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos+ ""String_Node_Str""+ isLastMove);
  Piece capture=tryCapturePieceAtPosition(toPos);
  addMoveToHistory(fromPos,toPos,capture);
  Piece fromPiece=getPieceAtViewPosition(fromPos);
  if (fromPiece == null) {
    Log.e(TAG,""String_Node_Str"" + fromPos);
    return;
  }
  fromPiece.setPosition(toPos);
  recentPiece_=fromPiece;
  if (isLastMove) {
    gameStatus_=referee_.getGameStatus();
  }
  if (capture != null) {
    captureStack_.add(capture);
  }
}"
41871,"private void drawBoard(Canvas canvas,int bgColor_UNUSED,int lineColor_UNUSED){
  final int boardW=getMeasuredWidth();
  final int boardH=getMeasuredHeight();
  Log.d(TAG,""String_Node_Str"" + boardW + ""String_Node_Str""+ boardH+ ""String_Node_Str""+ isBlackOnTop_);
  for (int i=0; i < 10; i++) {
    canvas.drawLine(offset_,offset_ + i * cellSize_,offset_ + 8 * cellSize_,offset_ + i * cellSize_,linePaint_);
  }
  for (int i=0; i < 9; i++) {
    if (i == 0 || i == 8) {
      canvas.drawLine(offset_ + i * cellSize_,offset_,offset_ + i * cellSize_,offset_ + cellSize_ * 9,linePaint_);
    }
 else {
      canvas.drawLine(offset_ + i * cellSize_,offset_,offset_ + i * cellSize_,offset_ + cellSize_ * 4,linePaint_);
      canvas.drawLine(offset_ + i * cellSize_,offset_ + 5 * cellSize_,offset_ + i * cellSize_,offset_ + 5 * cellSize_ + cellSize_ * 4,linePaint_);
    }
  }
  canvas.drawLine(offset_ + 3 * cellSize_,offset_,offset_ + 3 * cellSize_ + 2 * cellSize_,offset_ + 2 * cellSize_,linePaint_);
  canvas.drawLine(offset_ + 5 * cellSize_,offset_,offset_ + 5 * cellSize_ - 2 * cellSize_,offset_ + cellSize_ * 2,linePaint_);
  canvas.drawLine(offset_ + 3 * cellSize_,offset_ + 7 * cellSize_,offset_ + 3 * cellSize_ + 2 * cellSize_,offset_ + 7 * cellSize_ + 2 * cellSize_,linePaint_);
  canvas.drawLine(offset_ + 5 * cellSize_,offset_ + 7 * cellSize_,offset_ + 5 * cellSize_ - 2 * cellSize_,offset_ + 7 * cellSize_ + 2 * cellSize_,linePaint_);
  final boolean bDescending=(!isBlackOnTop_);
  final int imageRadius=(int)(pieceSize_ / 2);
  drawHeaderRow(canvas,offset_ - imageRadius - 10,offset_,true);
  drawHeaderRow(canvas,offset_ + cellSize_ * 8 + imageRadius,offset_,true);
  drawHeaderColumn(canvas,offset_,offset_,bDescending);
  drawHeaderColumn(canvas,offset_,offset_ + 10 * cellSize_ + 20,bDescending);
  final int nSize=cellSize_ / 7;
  final int nSpace=3;
  int[][] mirrors=new int[][]{{1,2},{7,2},{2,3},{4,3},{6,3},{8,3},{2,6},{4,6},{6,6},{8,6},{1,7},{7,7}};
  for (  int[] m : mirrors) {
    int[] point=new int[]{offset_ + m[0] * cellSize_,offset_ + m[1] * cellSize_};
    canvas.drawLine(point[0] - nSpace,point[1] - nSpace,point[0] - nSpace - nSize,point[1] - nSpace,linePaint_);
    canvas.drawLine(point[0] - nSpace,point[1] - nSpace,point[0] - nSpace,point[1] - nSpace - nSize,linePaint_);
    canvas.drawLine(point[0] - nSpace,point[1] + nSpace,point[0] - nSpace - nSize,point[1] + nSpace,linePaint_);
    canvas.drawLine(point[0] - nSpace,point[1] + nSpace,point[0] - nSpace,point[1] + nSpace + nSize,linePaint_);
  }
  mirrors=new int[][]{{1,2},{7,2},{0,3},{2,3},{4,3},{6,3},{0,6},{2,6},{4,6},{6,6},{1,7},{7,7}};
  for (  int[] m : mirrors) {
    int[] point={offset_ + m[0] * cellSize_,offset_ + m[1] * cellSize_};
    canvas.drawLine(point[0] + nSpace,point[1] - nSpace,point[0] + nSpace + nSize,point[1] - nSpace,linePaint_);
    canvas.drawLine(point[0] + nSpace,point[1] - nSpace,point[0] + nSpace,point[1] - nSpace - nSize,linePaint_);
    canvas.drawLine(point[0] + nSpace,point[1] + nSpace,point[0] + nSpace + nSize,point[1] + nSpace,linePaint_);
    canvas.drawLine(point[0] + nSpace,point[1] + nSpace,point[0] + nSpace,point[1] + nSpace + nSize,linePaint_);
  }
}","private void drawBoard(Canvas canvas,int bgColor_UNUSED,int lineColor_UNUSED){
  final int boardW=getMeasuredWidth();
  final int boardH=getMeasuredHeight();
  Log.v(TAG,""String_Node_Str"" + boardW + ""String_Node_Str""+ boardH+ ""String_Node_Str""+ isBlackOnTop_);
  for (int i=0; i < 10; i++) {
    canvas.drawLine(offset_,offset_ + i * cellSize_,offset_ + 8 * cellSize_,offset_ + i * cellSize_,linePaint_);
  }
  for (int i=0; i < 9; i++) {
    if (i == 0 || i == 8) {
      canvas.drawLine(offset_ + i * cellSize_,offset_,offset_ + i * cellSize_,offset_ + cellSize_ * 9,linePaint_);
    }
 else {
      canvas.drawLine(offset_ + i * cellSize_,offset_,offset_ + i * cellSize_,offset_ + cellSize_ * 4,linePaint_);
      canvas.drawLine(offset_ + i * cellSize_,offset_ + 5 * cellSize_,offset_ + i * cellSize_,offset_ + 5 * cellSize_ + cellSize_ * 4,linePaint_);
    }
  }
  canvas.drawLine(offset_ + 3 * cellSize_,offset_,offset_ + 3 * cellSize_ + 2 * cellSize_,offset_ + 2 * cellSize_,linePaint_);
  canvas.drawLine(offset_ + 5 * cellSize_,offset_,offset_ + 5 * cellSize_ - 2 * cellSize_,offset_ + cellSize_ * 2,linePaint_);
  canvas.drawLine(offset_ + 3 * cellSize_,offset_ + 7 * cellSize_,offset_ + 3 * cellSize_ + 2 * cellSize_,offset_ + 7 * cellSize_ + 2 * cellSize_,linePaint_);
  canvas.drawLine(offset_ + 5 * cellSize_,offset_ + 7 * cellSize_,offset_ + 5 * cellSize_ - 2 * cellSize_,offset_ + 7 * cellSize_ + 2 * cellSize_,linePaint_);
  final boolean bDescending=(!isBlackOnTop_);
  final int imageRadius=(int)(pieceSize_ / 2);
  drawHeaderRow(canvas,offset_ - imageRadius - 10,offset_,true);
  drawHeaderRow(canvas,offset_ + cellSize_ * 8 + imageRadius,offset_,true);
  drawHeaderColumn(canvas,offset_,offset_,bDescending);
  drawHeaderColumn(canvas,offset_,offset_ + 10 * cellSize_ + 20,bDescending);
  final int nSize=cellSize_ / 7;
  final int nSpace=3;
  int[][] mirrors=new int[][]{{1,2},{7,2},{2,3},{4,3},{6,3},{8,3},{2,6},{4,6},{6,6},{8,6},{1,7},{7,7}};
  for (  int[] m : mirrors) {
    int[] point=new int[]{offset_ + m[0] * cellSize_,offset_ + m[1] * cellSize_};
    canvas.drawLine(point[0] - nSpace,point[1] - nSpace,point[0] - nSpace - nSize,point[1] - nSpace,linePaint_);
    canvas.drawLine(point[0] - nSpace,point[1] - nSpace,point[0] - nSpace,point[1] - nSpace - nSize,linePaint_);
    canvas.drawLine(point[0] - nSpace,point[1] + nSpace,point[0] - nSpace - nSize,point[1] + nSpace,linePaint_);
    canvas.drawLine(point[0] - nSpace,point[1] + nSpace,point[0] - nSpace,point[1] + nSpace + nSize,linePaint_);
  }
  mirrors=new int[][]{{1,2},{7,2},{0,3},{2,3},{4,3},{6,3},{0,6},{2,6},{4,6},{6,6},{1,7},{7,7}};
  for (  int[] m : mirrors) {
    int[] point={offset_ + m[0] * cellSize_,offset_ + m[1] * cellSize_};
    canvas.drawLine(point[0] + nSpace,point[1] - nSpace,point[0] + nSpace + nSize,point[1] - nSpace,linePaint_);
    canvas.drawLine(point[0] + nSpace,point[1] - nSpace,point[0] + nSpace,point[1] - nSpace - nSize,linePaint_);
    canvas.drawLine(point[0] + nSpace,point[1] + nSpace,point[0] + nSpace + nSize,point[1] + nSpace,linePaint_);
    canvas.drawLine(point[0] + nSpace,point[1] + nSpace,point[0] + nSpace,point[1] + nSpace + nSize,linePaint_);
  }
}"
41872,"private void drawPiece(Canvas canvas,Piece piece,PieceDrawMode drawMode){
  if (piece.isAnimated()) {
    final PointF point=piece.getPointF();
    drawPieceAtPoint(canvas,piece,point);
    return;
  }
  final int imageRadius=pieceSize_ / 2;
  Bitmap bitmap=piece.getBitmap();
  Position viewPos=getViewPosition(piece.getPosition());
  final float left=offset_ - imageRadius + viewPos.column * cellSize_;
  final float top=offset_ - imageRadius + viewPos.row * cellSize_;
  if (drawMode == PieceDrawMode.PIECE_DRAW_MODE_SELECTED) {
    Log.d(TAG,""String_Node_Str"");
    canvas.drawRect(left - 3,top - 3,left + pieceSize_ + 3,top + pieceSize_ + 3,selectPaint_);
  }
 else   if (drawMode == PieceDrawMode.PIECE_DRAW_MODE_RECENT) {
    Log.d(TAG,""String_Node_Str"");
    canvas.drawCircle(left + imageRadius,top + imageRadius,imageRadius + 6,recentPaint_);
  }
  canvas.drawBitmap(bitmap,null,new RectF(left,top,left + pieceSize_,top + pieceSize_),null);
}","private void drawPiece(Canvas canvas,Piece piece,PieceDrawMode drawMode){
  if (piece.isAnimated()) {
    final PointF point=piece.getPointF();
    drawPieceAtPoint(canvas,piece,point);
    return;
  }
  final int imageRadius=pieceSize_ / 2;
  Bitmap bitmap=piece.getBitmap();
  Position viewPos=getViewPosition(piece.getPosition());
  final float left=offset_ - imageRadius + viewPos.column * cellSize_;
  final float top=offset_ - imageRadius + viewPos.row * cellSize_;
  if (drawMode == PieceDrawMode.PIECE_DRAW_MODE_SELECTED) {
    Log.d(TAG,""String_Node_Str"");
    canvas.drawRect(left - 3,top - 3,left + pieceSize_ + 3,top + pieceSize_ + 3,selectPaint_);
  }
 else   if (drawMode == PieceDrawMode.PIECE_DRAW_MODE_RECENT) {
    Log.v(TAG,""String_Node_Str"");
    canvas.drawCircle(left + imageRadius,top + imageRadius,imageRadius + 6,recentPaint_);
  }
  canvas.drawBitmap(bitmap,null,new RectF(left,top,left + pieceSize_,top + pieceSize_),null);
}"
41873,"public void makeMove(final Position fromPos,final Position toPos,boolean animated){
  Log.d(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos);
  final int status=referee_.validateMove(fromPos.row,fromPos.column,toPos.row,toPos.column);
  Log.d(TAG,""String_Node_Str"" + status);
  if (status == Referee.hoxGAME_STATUS_UNKNOWN) {
    Log.e(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos+ ""String_Node_Str"");
    return;
  }
  if (isBoardInReviewMode()) {
    addMoveToHistory(fromPos,toPos,null);
    return;
  }
  final Piece fromPiece=getPieceAtViewPosition(fromPos);
  Assert.assertNotNull(""String_Node_Str"" + fromPos,fromPiece);
  final Piece capture=tryCapturePieceAtPostion(toPos);
  if (animated) {
    Animator.AnimatorListener listener=new AnimatorListenerAdapter(){
      public void onAnimationEnd(      Animator animation){
        fromPiece.setPosition(toPos);
        fromPiece.setIsAnimated(false);
        recentPiece_=fromPiece;
        addMoveToHistory(fromPos,toPos,capture);
        didMoveOccur(fromPos,toPos,capture,status);
        BoardView.this.invalidate();
      }
    }
;
    movePieceToPositionWithAnimation(fromPiece,fromPos,toPos,listener);
  }
 else {
    fromPiece.setPosition(toPos);
    recentPiece_=fromPiece;
    addMoveToHistory(fromPos,toPos,capture);
    didMoveOccur(fromPos,toPos,capture,status);
  }
}","public void makeMove(final Position fromPos,final Position toPos,boolean animated){
  Log.d(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos);
  final int status=referee_.validateMove(fromPos.row,fromPos.column,toPos.row,toPos.column);
  Log.d(TAG,""String_Node_Str"" + status);
  if (status == Referee.hoxGAME_STATUS_UNKNOWN) {
    Log.e(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos+ ""String_Node_Str"");
    return;
  }
  if (isBoardInReviewMode()) {
    addMoveToHistory(fromPos,toPos,null);
    return;
  }
  final Piece fromPiece=getPieceAtViewPosition(fromPos);
  Assert.assertNotNull(""String_Node_Str"" + fromPos,fromPiece);
  final Piece capture=tryCapturePieceAtPosition(toPos);
  if (animated) {
    Animator.AnimatorListener listener=new AnimatorListenerAdapter(){
      public void onAnimationEnd(      Animator animation){
        fromPiece.setPosition(toPos);
        fromPiece.setIsAnimated(false);
        recentPiece_=fromPiece;
        addMoveToHistory(fromPos,toPos,capture);
        didMoveOccur(fromPos,toPos,capture,status);
        BoardView.this.invalidate();
      }
    }
;
    movePieceToPositionWithAnimation(fromPiece,fromPos,toPos,listener);
  }
 else {
    fromPiece.setPosition(toPos);
    recentPiece_=fromPiece;
    addMoveToHistory(fromPos,toPos,capture);
    didMoveOccur(fromPos,toPos,capture,status);
  }
}"
41874,"public void run(){
  final String aiMove=aiEngine_.generateMove();
  Log.d(TAG,""String_Node_Str"" + aiMove + ""String_Node_Str"");
  messageHandler_.sendMessage(messageHandler_.obtainMessage(MSG_AI_MOVE_READY,aiMove));
}","public void run(){
  aiRequest_=null;
  final String aiMove=aiEngine.generateMove();
  Log.d(TAG,""String_Node_Str"" + aiMove + ""String_Node_Str"");
  sendMessage(obtainMessage(MSG_AI_MOVE_READY,aiMove));
}"
41875,"public void handleRequestToResetTable(){
  Log.i(TAG,""String_Node_Str"");
  TableType tableType=playerTracker_.getTableType();
  if (tableType == TableType.TABLE_TYPE_LOCAL) {
    playerTracker_.syncUI();
    myColor_=ColorEnum.COLOR_RED;
    aiEngine_.initGame();
    timeTracker_.stop();
    timeTracker_.reset();
    MainActivity mainActivity=mainActivity_.get();
    if (mainActivity != null) {
      mainActivity.openNewPracticeTable();
    }
  }
 else   if (tableType == TableType.TABLE_TYPE_NETWORK) {
    if (!myTable_.isValid()) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
    networkPlayer_.sendRequest_RESET(myTable_.tableId);
  }
}","public void handleRequestToResetTable(){
  Log.i(TAG,""String_Node_Str"");
  TableType tableType=playerTracker_.getTableType();
  if (tableType == TableType.TABLE_TYPE_LOCAL) {
    messageHandler_.cancelAnyAIRequest();
    playerTracker_.syncUI();
    myColor_=ColorEnum.COLOR_RED;
    aiEngine_.initGame();
    timeTracker_.stop();
    timeTracker_.reset();
    MainActivity mainActivity=mainActivity_.get();
    if (mainActivity != null) {
      mainActivity.openNewPracticeTable();
    }
  }
 else   if (tableType == TableType.TABLE_TYPE_NETWORK) {
    if (!myTable_.isValid()) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
    networkPlayer_.sendRequest_RESET(myTable_.tableId);
  }
}"
41876,"@SuppressLint(""String_Node_Str"") public void handleLocalMove(Position fromPos,Position toPos){
  Log.i(TAG,""String_Node_Str"" + referee_.getMoveCount());
  timeTracker_.nextColor();
  if (referee_.getMoveCount() == 2) {
    timeTracker_.start();
    MainActivity mainActivity=mainActivity_.get();
    if (mainActivity != null) {
      mainActivity.onGameStatusChanged();
    }
  }
  if (referee_.getMoveCount() > 1) {
    playerTracker_.syncUI();
  }
  if (!myTable_.isValid()) {
    aiEngine_.onHumanMove(fromPos.row,fromPos.column,toPos.row,toPos.column);
    if (!referee_.isGameInProgress()) {
      Log.i(TAG,""String_Node_Str"");
      onGameEnded();
      return;
    }
    Log.d(TAG,""String_Node_Str"");
    messageHandler_.postDelayed(new Runnable(){
      public void run(){
        final String aiMove=aiEngine_.generateMove();
        Log.d(TAG,""String_Node_Str"" + aiMove + ""String_Node_Str"");
        messageHandler_.sendMessage(messageHandler_.obtainMessage(MSG_AI_MOVE_READY,aiMove));
      }
    }
,2000);
  }
 else {
    final String move=String.format(""String_Node_Str"",fromPos.column,fromPos.row,toPos.column,toPos.row);
    Log.i(TAG,""String_Node_Str"" + move + ""String_Node_Str"");
    networkPlayer_.sendRequest_MOVE(myTable_.tableId,move);
  }
}","@SuppressLint(""String_Node_Str"") public void handleLocalMove(Position fromPos,Position toPos){
  Log.i(TAG,""String_Node_Str"" + referee_.getMoveCount());
  timeTracker_.nextColor();
  if (referee_.getMoveCount() == 2) {
    timeTracker_.start();
    MainActivity mainActivity=mainActivity_.get();
    if (mainActivity != null) {
      mainActivity.onGameStatusChanged();
    }
  }
  if (referee_.getMoveCount() > 1) {
    playerTracker_.syncUI();
  }
  if (!myTable_.isValid()) {
    aiEngine_.onHumanMove(fromPos.row,fromPos.column,toPos.row,toPos.column);
    if (!referee_.isGameInProgress()) {
      Log.i(TAG,""String_Node_Str"");
      onGameEnded();
      return;
    }
    final long delayMillis=2000;
    Log.d(TAG,""String_Node_Str"" + delayMillis);
    messageHandler_.postAIRequest(aiEngine_,delayMillis);
  }
 else {
    final String move=String.format(""String_Node_Str"",fromPos.column,fromPos.row,toPos.column,toPos.row);
    Log.i(TAG,""String_Node_Str"" + move + ""String_Node_Str"");
    networkPlayer_.sendRequest_MOVE(myTable_.tableId,move);
  }
}"
41877,"public void onReverseView(View view){
  boardView_.reverseView();
}","public void onReverseView(View view){
  reverseView();
}"
41878,"private void onLocalMoveMade(Position fromPos,Position toPos,Piece capture,int gameStatus){
  Log.d(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos);
  addMoveToHistory(fromPos,toPos,capture);
  didMoveOccur(fromPos,toPos,capture,gameStatus);
  if (!isGameInProgress()) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  HoxApp.getApp().handleLocalMove(fromPos,toPos);
  if (tableType_ == TableType.TABLE_TYPE_LOCAL) {
    aiEngine_.onHumanMove(fromPos.row,fromPos.column,toPos.row,toPos.column);
    Log.d(TAG,""String_Node_Str"");
    new Thread(new Runnable(){
      public void run(){
        String aiMove=aiEngine_.generateMove();
        Log.d(TAG,""String_Node_Str"" + aiMove + ""String_Node_Str"");
        messageHandler_.sendMessage(messageHandler_.obtainMessage(MSG_AI_MOVE_READY,aiMove));
      }
    }
).start();
  }
 else   if (tableType_ == TableType.TABLE_TYPE_NETWORK) {
    Log.d(TAG,""String_Node_Str"");
  }
}","private void onLocalMoveMade(Position fromPos,Position toPos,Piece capture,int gameStatus){
  Log.d(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos);
  addMoveToHistory(fromPos,toPos,capture);
  didMoveOccur(fromPos,toPos,capture,gameStatus);
  HoxApp.getApp().handleLocalMove(fromPos,toPos);
  if (tableType_ == TableType.TABLE_TYPE_LOCAL) {
    aiEngine_.onHumanMove(fromPos.row,fromPos.column,toPos.row,toPos.column);
    if (!isGameInProgress()) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
    Log.d(TAG,""String_Node_Str"");
    new Thread(new Runnable(){
      public void run(){
        String aiMove=aiEngine_.generateMove();
        Log.d(TAG,""String_Node_Str"" + aiMove + ""String_Node_Str"");
        messageHandler_.sendMessage(messageHandler_.obtainMessage(MSG_AI_MOVE_READY,aiMove));
      }
    }
).start();
  }
 else   if (tableType_ == TableType.TABLE_TYPE_NETWORK) {
    Log.d(TAG,""String_Node_Str"");
  }
}"
41879,"public void onAIMoveMade(Position fromPos,Position toPos){
  Log.d(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos);
  final int status=nativeValidateMove(fromPos.row,fromPos.column,toPos.row,toPos.column);
  Log.d(TAG,""String_Node_Str"" + status);
  if (status == hoxGAME_STATUS_UNKNOWN) {
    Log.e(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos+ ""String_Node_Str"");
    return;
  }
  if (isBoardInReviewMode()) {
    addMoveToHistory(fromPos,toPos,null);
    return;
  }
  Piece capture=tryCapturePieceAtPostion(toPos);
  addMoveToHistory(fromPos,toPos,capture);
  Piece fromPiece=getPieceAtViewPosition(fromPos);
  if (fromPiece == null) {
    Log.e(TAG,""String_Node_Str"" + fromPos);
    return;
  }
  fromPiece.setPosition(toPos);
  recentPiece_=fromPiece;
  HoxApp.getApp().handleAIMove(fromPos,toPos);
  didMoveOccur(fromPos,toPos,capture,status);
}","private void onAIMoveMade(Position fromPos,Position toPos){
  Log.d(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos);
  final int status=nativeValidateMove(fromPos.row,fromPos.column,toPos.row,toPos.column);
  Log.d(TAG,""String_Node_Str"" + status);
  if (status == hoxGAME_STATUS_UNKNOWN) {
    Log.e(TAG,""String_Node_Str"" + fromPos + ""String_Node_Str""+ toPos+ ""String_Node_Str"");
    return;
  }
  if (isBoardInReviewMode()) {
    addMoveToHistory(fromPos,toPos,null);
    return;
  }
  Piece capture=tryCapturePieceAtPostion(toPos);
  addMoveToHistory(fromPos,toPos,capture);
  Piece fromPiece=getPieceAtViewPosition(fromPos);
  if (fromPiece == null) {
    Log.e(TAG,""String_Node_Str"" + fromPos);
    return;
  }
  fromPiece.setPosition(toPos);
  recentPiece_=fromPiece;
  didMoveOccur(fromPos,toPos,capture,status);
  if (tableType_ == TableType.TABLE_TYPE_LOCAL) {
    HoxApp.getApp().handleAIMove(fromPos,toPos);
  }
}"
41880,"public void handleAIMove(Position fromPos,Position toPos){
  Log.i(TAG,""String_Node_Str"");
  if (myTable_.isValid()) {
    Log.i(TAG,""String_Node_Str"");
    return;
  }
  timeTracker_.nextColor();
}","public void handleAIMove(Position fromPos,Position toPos){
  Log.i(TAG,""String_Node_Str"" + moveCount_);
  ++moveCount_;
  timeTracker_.nextColor();
  if (moveCount_ == 2) {
    timeTracker_.start();
  }
}"
41881,"private void handleNetworkEvent_I_TABLE(String content){
  Log.d(TAG,""String_Node_Str"");
  MainActivity mainActivity=mainActivity_.get();
  if (mainActivity == null) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  isGameOver_=false;
  myTable_=new TableInfo(content);
  if (pid_.equals(myTable_.blackId)) {
    myColor_=ColorEnum.COLOR_BLACK;
  }
 else   if (pid_.equals(myTable_.redId)) {
    myColor_=ColorEnum.COLOR_RED;
  }
 else {
    myColor_=ColorEnum.COLOR_NONE;
  }
  Log.i(TAG,""String_Node_Str"" + myTable_.tableId + ""String_Node_Str""+ myColor_);
  timeTracker_.stop();
  timeTracker_.setInitialTime(new TimeInfo(myTable_.itimes));
  timeTracker_.setBlackTime(new TimeInfo(myTable_.blackTimes));
  timeTracker_.setRedTime(new TimeInfo(myTable_.redTimes));
  timeTracker_.syncUI();
  mainActivity.updateBoardWithNewTableInfo(myTable_);
}","private void handleNetworkEvent_I_TABLE(String content){
  Log.d(TAG,""String_Node_Str"");
  MainActivity mainActivity=mainActivity_.get();
  if (mainActivity == null) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  isGameOver_=false;
  myTable_=new TableInfo(content);
  if (pid_.equals(myTable_.blackId)) {
    myColor_=ColorEnum.COLOR_BLACK;
  }
 else   if (pid_.equals(myTable_.redId)) {
    myColor_=ColorEnum.COLOR_RED;
  }
 else {
    myColor_=ColorEnum.COLOR_NONE;
  }
  Log.i(TAG,""String_Node_Str"" + myTable_.tableId + ""String_Node_Str""+ myColor_);
  timeTracker_.stop();
  timeTracker_.setInitialColor(ColorEnum.COLOR_RED);
  timeTracker_.setInitialTime(new TimeInfo(myTable_.itimes));
  timeTracker_.setBlackTime(new TimeInfo(myTable_.blackTimes));
  timeTracker_.setRedTime(new TimeInfo(myTable_.redTimes));
  timeTracker_.syncUI();
  mainActivity.updateBoardWithNewTableInfo(myTable_);
}"
41882,"@SuppressLint(""String_Node_Str"") public void handleLocalMove(Position fromPos,Position toPos){
  Log.i(TAG,""String_Node_Str"");
  if (myTable_.isValid()) {
    final String move=String.format(""String_Node_Str"",fromPos.column,fromPos.row,toPos.column,toPos.row);
    Log.i(TAG,""String_Node_Str"" + move + ""String_Node_Str"");
    networkPlayer_.sendRequest_MOVE(myTable_.tableId,move);
  }
  timeTracker_.nextColor();
}","@SuppressLint(""String_Node_Str"") public void handleLocalMove(Position fromPos,Position toPos){
  Log.i(TAG,""String_Node_Str"" + moveCount_);
  ++moveCount_;
  timeTracker_.nextColor();
  if (moveCount_ == 2) {
    timeTracker_.start();
  }
  if (myTable_.isValid()) {
    final String move=String.format(""String_Node_Str"",fromPos.column,fromPos.row,toPos.column,toPos.row);
    Log.i(TAG,""String_Node_Str"" + move + ""String_Node_Str"");
    networkPlayer_.sendRequest_MOVE(myTable_.tableId,move);
  }
}"
41883,"private void reverseView(){
  isBlackOnTop_=!isBlackOnTop_;
  boardView_.reverseView();
  CharSequence savedText=topPlayerLabel_.getText();
  topPlayerLabel_.setText(bottomPlayerLabel_.getText());
  bottomPlayerLabel_.setText(savedText);
  savedText=topPlayerButton_.getText();
  topPlayerButton_.setText(bottomPlayerButton_.getText());
  bottomPlayerButton_.setText(savedText);
}","private void reverseView(){
  isBlackOnTop_=!isBlackOnTop_;
  boardView_.reverseView();
  CharSequence savedText=topPlayerLabel_.getText();
  topPlayerLabel_.setText(bottomPlayerLabel_.getText());
  bottomPlayerLabel_.setText(savedText);
  savedText=topPlayerButton_.getText();
  topPlayerButton_.setText(bottomPlayerButton_.getText());
  bottomPlayerButton_.setText(savedText);
  HoxApp.getApp().getTimeTracker().reverseView();
}"
41884,"private void onBoardViewCreated(){
  boardView_=(BoardView)placeholderFragment_.getView().findViewById(R.id.board_view);
  if (boardView_ == null) {
    Log.e(TAG,""String_Node_Str"");
  }
  topPlayerLabel_=(TextView)placeholderFragment_.getView().findViewById(R.id.top_player_label);
  if (topPlayerLabel_ == null) {
    Log.e(TAG,""String_Node_Str"");
  }
  bottomPlayerLabel_=(TextView)placeholderFragment_.getView().findViewById(R.id.bottom_player_label);
  if (bottomPlayerLabel_ == null) {
    Log.e(TAG,""String_Node_Str"");
  }
  topPlayerButton_=(Button)placeholderFragment_.getView().findViewById(R.id.top_button);
  if (topPlayerButton_ == null) {
    Log.e(TAG,""String_Node_Str"");
  }
  bottomPlayerButton_=(Button)placeholderFragment_.getView().findViewById(R.id.bottom_button);
  if (bottomPlayerButton_ == null) {
    Log.e(TAG,""String_Node_Str"");
  }
  TextView topGameTimeView=(TextView)placeholderFragment_.getView().findViewById(R.id.top_game_time);
  TextView topMoveTimeView=(TextView)placeholderFragment_.getView().findViewById(R.id.top_move_time);
  TextView bottomGameTimeView=(TextView)placeholderFragment_.getView().findViewById(R.id.bottom_game_time);
  TextView bottomMoveTimeView=(TextView)placeholderFragment_.getView().findViewById(R.id.bottom_move_time);
  TableTimeTracker timeTracker=HoxApp.getApp().getTimeTracker();
  timeTracker.setUITextViews(topGameTimeView,topMoveTimeView,bottomGameTimeView,bottomMoveTimeView);
  timeTracker.reset();
  timeTracker.start();
  final int aiLevel=HoxApp.getApp().loadAILevelPreferences();
  updateAILabel(aiLevel);
  updateAILevelOfBoard(aiLevel);
}","private void onBoardViewCreated(){
  boardView_=(BoardView)placeholderFragment_.getView().findViewById(R.id.board_view);
  if (boardView_ == null) {
    Log.e(TAG,""String_Node_Str"");
  }
  topPlayerLabel_=(TextView)placeholderFragment_.getView().findViewById(R.id.top_player_label);
  if (topPlayerLabel_ == null) {
    Log.e(TAG,""String_Node_Str"");
  }
  bottomPlayerLabel_=(TextView)placeholderFragment_.getView().findViewById(R.id.bottom_player_label);
  if (bottomPlayerLabel_ == null) {
    Log.e(TAG,""String_Node_Str"");
  }
  topPlayerButton_=(Button)placeholderFragment_.getView().findViewById(R.id.top_button);
  if (topPlayerButton_ == null) {
    Log.e(TAG,""String_Node_Str"");
  }
  bottomPlayerButton_=(Button)placeholderFragment_.getView().findViewById(R.id.bottom_button);
  if (bottomPlayerButton_ == null) {
    Log.e(TAG,""String_Node_Str"");
  }
  TextView topGameTimeView=(TextView)placeholderFragment_.getView().findViewById(R.id.top_game_time);
  TextView topMoveTimeView=(TextView)placeholderFragment_.getView().findViewById(R.id.top_move_time);
  TextView bottomGameTimeView=(TextView)placeholderFragment_.getView().findViewById(R.id.bottom_game_time);
  TextView bottomMoveTimeView=(TextView)placeholderFragment_.getView().findViewById(R.id.bottom_move_time);
  TableTimeTracker timeTracker=HoxApp.getApp().getTimeTracker();
  timeTracker.setUITextViews(topGameTimeView,topMoveTimeView,bottomGameTimeView,bottomMoveTimeView);
  timeTracker.reset();
  final int aiLevel=HoxApp.getApp().loadAILevelPreferences();
  updateAILabel(aiLevel);
  updateAILevelOfBoard(aiLevel);
}"
41885,"public void resetBoardWithNewMoves(String[] moves){
  Log.d(TAG,""String_Node_Str"");
  for (  String move : moves) {
    Log.d(TAG,""String_Node_Str"" + move + ""String_Node_Str"");
    int row1=move.charAt(1) - '0';
    int col1=move.charAt(0) - '0';
    int row2=move.charAt(3) - '0';
    int col2=move.charAt(2) - '0';
    Log.i(TAG,""String_Node_Str"" + row1 + ""String_Node_Str""+ col1+ ""String_Node_Str""+ row2+ ""String_Node_Str""+ col2+ ""String_Node_Str"");
    boardView_.onAIMoveMade(new Position(row1,col1),new Position(row2,col2));
  }
  boardView_.invalidate();
  final ColorEnum nextColor=boardView_.getNextColor();
  TableTimeTracker timeTracker=HoxApp.getApp().getTimeTracker();
  timeTracker.setInitialColor(nextColor);
  timeTracker.start();
}","public void resetBoardWithNewMoves(String[] moves){
  Log.d(TAG,""String_Node_Str"");
  for (  String move : moves) {
    Log.d(TAG,""String_Node_Str"" + move + ""String_Node_Str"");
    int row1=move.charAt(1) - '0';
    int col1=move.charAt(0) - '0';
    int row2=move.charAt(3) - '0';
    int col2=move.charAt(2) - '0';
    Log.i(TAG,""String_Node_Str"" + row1 + ""String_Node_Str""+ col1+ ""String_Node_Str""+ row2+ ""String_Node_Str""+ col2+ ""String_Node_Str"");
    boardView_.onNetworkMoveMade(new Position(row1,col1),new Position(row2,col2));
  }
  boardView_.invalidate();
  final ColorEnum nextColor=boardView_.getNextColor();
  TableTimeTracker timeTracker=HoxApp.getApp().getTimeTracker();
  timeTracker.setInitialColor(nextColor);
  timeTracker.start();
}"
41886,"public void updateBoardWithNewMove(String move){
  Log.d(TAG,""String_Node_Str"" + move + ""String_Node_Str"");
  int row1=move.charAt(1) - '0';
  int col1=move.charAt(0) - '0';
  int row2=move.charAt(3) - '0';
  int col2=move.charAt(2) - '0';
  Log.i(TAG,""String_Node_Str"" + row1 + ""String_Node_Str""+ col1+ ""String_Node_Str""+ row2+ ""String_Node_Str""+ col2+ ""String_Node_Str"");
  boardView_.onAIMoveMade(new Position(row1,col1),new Position(row2,col2));
  boardView_.invalidate();
}","public void updateBoardWithNewMove(String move){
  Log.d(TAG,""String_Node_Str"" + move + ""String_Node_Str"");
  int row1=move.charAt(1) - '0';
  int col1=move.charAt(0) - '0';
  int row2=move.charAt(3) - '0';
  int col2=move.charAt(2) - '0';
  Log.i(TAG,""String_Node_Str"" + row1 + ""String_Node_Str""+ col1+ ""String_Node_Str""+ row2+ ""String_Node_Str""+ col2+ ""String_Node_Str"");
  boardView_.onNetworkMoveMade(new Position(row1,col1),new Position(row2,col2));
  boardView_.invalidate();
}"
41887,"public void start(){
  if (!isRunning) {
    isRunning=true;
  }
}","public void start(){
  if (!isRunning) {
    Log.i(TAG,""String_Node_Str"");
    isRunning=true;
  }
}"
41888,"private String formatTime(int timeInSeconds){
  final int minutes=timeInSeconds / 60;
  final int seconds=timeInSeconds % 60;
  return String.format(""String_Node_Str"",minutes,seconds);
}","private static String formatTime(int timeInSeconds){
  final int minutes=timeInSeconds / 60;
  final int seconds=timeInSeconds % 60;
  return String.format(""String_Node_Str"",minutes,seconds);
}"
41889,"public void reset(){
  blackTime_.initWith(initialTime_);
  redTime_.initWith(initialTime_);
  syncUI();
}","public void reset(){
  nextColor_=ColorEnum.COLOR_RED;
  blackTime_.initWith(initialTime_);
  redTime_.initWith(initialTime_);
  syncUI();
}"
41890,"/** 
 * Registers the partition resolver associated with the database link
 * @throws DocumentClientException 
 */
@Deprecated public void registerPartitionResolver(String databaseLink,PartitionResolver partitionResolver) throws DocumentClientException {
  if (StringUtils.isEmpty(databaseLink)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (partitionResolver == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.partitionResolvers.put(Utils.trimBeginingAndEndingSlashes(databaseLink),partitionResolver);
}","/** 
 * Registers the partition resolver associated with the database link.
 * @param databaseLink the database link
 * @param partitionResolver the partition resolver
 * @throws DocumentClientException the DocumentClientException
 */
@Deprecated public void registerPartitionResolver(String databaseLink,PartitionResolver partitionResolver) throws DocumentClientException {
  if (StringUtils.isEmpty(databaseLink)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (partitionResolver == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.partitionResolvers.put(Utils.trimBeginingAndEndingSlashes(databaseLink),partitionResolver);
}"
41891,"/** 
 * Gets the partition resolver associated with the database link on the client
 */
@Deprecated protected PartitionResolver getPartitionResolver(String databaseLink){
  if (StringUtils.isEmpty(databaseLink)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return this.partitionResolvers.get(Utils.trimBeginingAndEndingSlashes(databaseLink));
}","/** 
 * Gets the partition resolver associated with the database link on the client.
 * @param databaseLink the database link
 * @return the partition resolver
 */
@Deprecated protected PartitionResolver getPartitionResolver(String databaseLink){
  if (StringUtils.isEmpty(databaseLink)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return this.partitionResolvers.get(Utils.trimBeginingAndEndingSlashes(databaseLink));
}"
41892,"/** 
 * Gets the default service endpoint as passed in by the  user during construction.
 */
public URI getServiceEndpoint(){
  return this.serviceEndpoint;
}","/** 
 * Gets the default service endpoint as passed in by the user during construction.
 * @return the default service endpoint
 */
public URI getServiceEndpoint(){
  return this.serviceEndpoint;
}"
41893,"/** 
 * Gets the current read endpoint chosen based on availability and preference.
 */
public URI getReadEndpoint(){
  return this.globalEndpointManager.getReadEndpoint();
}","/** 
 * Gets the current read endpoint chosen based on availability and preference.
 * @return the current read endpoint
 */
public URI getReadEndpoint(){
  return this.globalEndpointManager.getReadEndpoint();
}"
41894,"/** 
 * Gets the current write endpoint chosen based on availability and preference.
 */
public URI getWriteEndpoint(){
  return this.globalEndpointManager.getWriteEndpoint();
}","/** 
 * Gets the current write endpoint chosen based on availability and preference.
 * @return the  current write endpoint
 */
public URI getWriteEndpoint(){
  return this.globalEndpointManager.getWriteEndpoint();
}"
41895,"/** 
 * Creates a new instance of the DocumentClientException class.
 * @param statusCode the http status code of the response.
 * @param errorResource the error resource object.
 * @param responseHeaders the response headers.
 */
public DocumentClientException(String resourceAddress,int statusCode,Error errorResource,Map<String,String> responseHeaders){
  super(errorResource.getMessage());
  this.resourceAddress=resourceAddress;
  this.statusCode=statusCode;
  this.error=errorResource;
  this.responseHeaders=responseHeaders;
}","/** 
 * Creates a new instance of the DocumentClientException class.
 * @param resourceAddress the resource address
 * @param statusCode the http status code of the response
 * @param errorResource the error resource object
 * @param responseHeaders the response headers
 */
public DocumentClientException(String resourceAddress,int statusCode,Error errorResource,Map<String,String> responseHeaders){
  super(errorResource.getMessage());
  this.resourceAddress=resourceAddress;
  this.statusCode=statusCode;
  this.error=errorResource;
  this.responseHeaders=responseHeaders;
}"
41896,"/** 
 * Constructor.
 * @param jsonObject the json object that represents the index.
 */
protected Index(JSONObject jsonObject,IndexKind indexKind){
  super(jsonObject);
  this.setKind(indexKind);
}","/** 
 * Creates a new instance of the Index class.
 * @param jsonObject the json object that represents the index.
 * @param indexKind the index kind {@link IndexKind}
 */
protected Index(JSONObject jsonObject,IndexKind indexKind){
  super(jsonObject);
  this.setKind(indexKind);
}"
41897,"/** 
 * QueryIterable constructor taking in the individual parameters for creating a DocumentServiceRequest This constructor is used for partitioning scenarios when multiple DocumentServiceRequests need to be created
 */
@SuppressWarnings(""String_Node_Str"") protected QueryIterable(DocumentClient client,String databaseOrDocumentCollectionLink,SqlQuerySpec querySpec,FeedOptions options,Object partitionKey,ReadType readType,Class<T> classT){
  this.initialize(client,readType,classT);
  this.querySpec=querySpec;
  if (Utils.isDatabaseLink(databaseOrDocumentCollectionLink)) {
    PartitionResolver partitionResolver=this.client.getPartitionResolver(databaseOrDocumentCollectionLink);
    if (partitionResolver != null) {
      for (      String collectionLink : partitionResolver.resolveForRead(partitionKey)) {
        this.documentCollectionLinks.add(collectionLink);
      }
    }
 else {
      throw new IllegalArgumentException(DocumentClient.PartitionResolverErrorMessage);
    }
  }
 else {
    this.documentCollectionLinks.add(databaseOrDocumentCollectionLink);
  }
  if (this.documentCollectionLinks != null && this.documentCollectionLinks.size() > 0) {
    String path=Utils.joinPath(this.documentCollectionLinks.get(this.currentCollectionIndex),Paths.DOCUMENTS_PATH_SEGMENT);
    this.currentCollectionIndex++;
    this.requestHeaders=this.client.getFeedHeaders(options);
    this.request=DocumentServiceRequest.create(ResourceType.Document,path,this.querySpec,this.client.queryCompatibilityMode,this.requestHeaders);
    this.initializeContinuationToken();
  }
  this.reset();
}","/** 
 * Creates a new instance of the QueryIterable class. <p> QueryIterable constructor taking in the individual parameters for creating a DocumentServiceRequest This constructor is used for partitioning scenarios when multiple DocumentServiceRequests need to be created
 * @param client the document client
 * @param databaseOrDocumentCollectionLink the database or document collection link
 * @param querySpec the query spec
 * @param options the feed options
 * @param partitionKey the partition key
 * @param readType the read type
 * @param classT the class type
 */
@SuppressWarnings(""String_Node_Str"") protected QueryIterable(DocumentClient client,String databaseOrDocumentCollectionLink,SqlQuerySpec querySpec,FeedOptions options,Object partitionKey,ReadType readType,Class<T> classT){
  this.initialize(client,readType,classT);
  this.querySpec=querySpec;
  if (Utils.isDatabaseLink(databaseOrDocumentCollectionLink)) {
    PartitionResolver partitionResolver=this.client.getPartitionResolver(databaseOrDocumentCollectionLink);
    if (partitionResolver != null) {
      for (      String collectionLink : partitionResolver.resolveForRead(partitionKey)) {
        this.documentCollectionLinks.add(collectionLink);
      }
    }
 else {
      throw new IllegalArgumentException(DocumentClient.PartitionResolverErrorMessage);
    }
  }
 else {
    this.documentCollectionLinks.add(databaseOrDocumentCollectionLink);
  }
  if (this.documentCollectionLinks != null && this.documentCollectionLinks.size() > 0) {
    String path=Utils.joinPath(this.documentCollectionLinks.get(this.currentCollectionIndex),Paths.DOCUMENTS_PATH_SEGMENT);
    this.currentCollectionIndex++;
    this.requestHeaders=this.client.getFeedHeaders(options);
    this.request=DocumentServiceRequest.create(ResourceType.Document,path,this.querySpec,this.client.queryCompatibilityMode,this.requestHeaders);
    this.initializeContinuationToken();
  }
  this.reset();
}"
41898,"/** 
 * Initialize the common fields to both QueryIterable constructors
 */
private void initialize(DocumentClient client,ReadType readType,Class<T> classT){
  this.client=client;
  this.readType=readType;
  this.classT=classT;
}","/** 
 * Initialize the common fields to both QueryIterable constructors.
 * @param client the document client
 * @param readType the read type
 * @param classT the class type
 */
private void initialize(DocumentClient client,ReadType readType,Class<T> classT){
  this.client=client;
  this.readType=readType;
  this.classT=classT;
}"
41899,"/** 
 * Gets the value of the parameter. 
 * @param c the class of the parameter value.
 * @return the value of the parameter.
 */
public <T extends Object>Object getValue(Class<T> c){
  return super.getObject(""String_Node_Str"",c);
}","/** 
 * Gets the value of the parameter.
 * @param c the class of the parameter value.
 * @param < T > the parameter type
 * @return the value of the parameter.
 */
public <T extends Object>Object getValue(Class<T> c){
  return super.getObject(""String_Node_Str"",c);
}"
41900,"/** 
 * Constructor. Create a new instance of the Undefined object.
 */
private Undefined(){
}","/** 
 * Creates a new instance of the Undefined class.
 */
private Undefined(){
}"
41901,"/** 
 * Returns the singleton value of Undfined.
 */
public static Undefined Value(){
  return value;
}","/** 
 * @return the singleton value of Undfined.
 */
public static Undefined Value(){
  return value;
}"
41902,"/** 
 * Returns the string representation of Undfined.
 */
public String toString(){
  return ""String_Node_Str"";
}","/** 
 * @return the string representation of Undfined.
 */
public String toString(){
  return ""String_Node_Str"";
}"
41903,"@Test public void testJsonSerialization(){
  Document document=new Document();
  document.set(""String_Node_Str"",null);
  document.set(""String_Node_Str"",""String_Node_Str"");
  Document childDocument=new Document(""String_Node_Str"");
  document.set(""String_Node_Str"",childDocument);
  document.set(""String_Node_Str"",new JSONObject(""String_Node_Str""));
  document.set(""String_Node_Str"",new StaticPOJOForTest());
  Collection<Integer> collection1=new ArrayList<Integer>();
  collection1.add(101);
  collection1.add(102);
  document.set(""String_Node_Str"",collection1);
  Collection<Document> collection2=new ArrayList<Document>();
  collection2.add(new Document(""String_Node_Str""));
  document.set(""String_Node_Str"",collection2);
  Collection<StaticPOJOForTest> collection3=new ArrayList<StaticPOJOForTest>();
  collection3.add(new StaticPOJOForTest());
  document.set(""String_Node_Str"",collection3);
  Collection<Collection<Collection<String>>> collection4=new ArrayList<Collection<Collection<String>>>();
  Collection<Collection<String>> collection5=new ArrayList<Collection<String>>();
  Collection<String> collection6=new ArrayList<String>();
  collection6.add(""String_Node_Str"");
  collection5.add(collection6);
  collection4.add(collection5);
  document.set(""String_Node_Str"",collection4);
  Document expectedDocument=new Document(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Assert.assertEquals(expectedDocument.toString(),document.toString());
  Assert.assertEquals(""String_Node_Str"",document.getObject(""String_Node_Str"",StaticPOJOForTest.class).pojoProp);
  Assert.assertEquals(""String_Node_Str"",document.getCollection(""String_Node_Str"",StaticPOJOForTest.class).iterator().next().pojoProp);
  document=new Document(""String_Node_Str"");
  StaticPOJOForTest pojo=document.toObject(StaticPOJOForTest.class);
  Assert.assertEquals(""String_Node_Str"",pojo.pojoProp);
  JSONObject jsonObject=document.toObject(JSONObject.class);
  Assert.assertEquals(""String_Node_Str"",jsonObject.getString(""String_Node_Str""));
}","@Test public void testJsonSerialization(){
  Document document=new Document();
  document.set(""String_Node_Str"",null);
  document.set(""String_Node_Str"",""String_Node_Str"");
  Document childDocument=new Document(""String_Node_Str"");
  document.set(""String_Node_Str"",childDocument);
  document.set(""String_Node_Str"",new JSONObject(""String_Node_Str""));
  document.set(""String_Node_Str"",new StaticPOJOForTest());
  document.set(""String_Node_Str"",new AnotherPOJO());
  Collection<Integer> collection1=new ArrayList<Integer>();
  collection1.add(101);
  collection1.add(102);
  document.set(""String_Node_Str"",collection1);
  Collection<Document> collection2=new ArrayList<Document>();
  collection2.add(new Document(""String_Node_Str""));
  document.set(""String_Node_Str"",collection2);
  Collection<StaticPOJOForTest> collection3=new ArrayList<StaticPOJOForTest>();
  collection3.add(new StaticPOJOForTest());
  document.set(""String_Node_Str"",collection3);
  Collection<Collection<Collection<String>>> collection4=new ArrayList<Collection<Collection<String>>>();
  Collection<Collection<String>> collection5=new ArrayList<Collection<String>>();
  Collection<String> collection6=new ArrayList<String>();
  collection6.add(""String_Node_Str"");
  collection5.add(collection6);
  collection4.add(collection5);
  document.set(""String_Node_Str"",collection4);
  Document expectedDocument=new Document(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Assert.assertEquals(expectedDocument.toString(),document.toString());
  Assert.assertEquals(""String_Node_Str"",document.getObject(""String_Node_Str"",StaticPOJOForTest.class).pojoProp);
  Assert.assertEquals(""String_Node_Str"",document.getObject(""String_Node_Str"",AnotherPOJO.class).pojoProp);
  Assert.assertEquals(""String_Node_Str"",document.getCollection(""String_Node_Str"",StaticPOJOForTest.class).iterator().next().pojoProp);
  document=new Document(""String_Node_Str"");
  StaticPOJOForTest pojo=document.toObject(StaticPOJOForTest.class);
  Assert.assertEquals(""String_Node_Str"",pojo.pojoProp);
  JSONObject jsonObject=document.toObject(JSONObject.class);
  Assert.assertEquals(""String_Node_Str"",jsonObject.getString(""String_Node_Str""));
}"
41904,"/** 
 * Sets the connection mode used in the client. Currently only Gateway in supported.
 * @param connectionMode the connection mode.
 */
public void setConnectionMode(ConnectionMode connectionMode){
  this.connectionMode=connectionMode;
}","/** 
 * Sets the connection mode used in the client. Currently only Gateway is supported.
 * @param connectionMode the connection mode.
 */
public void setConnectionMode(ConnectionMode connectionMode){
  this.connectionMode=connectionMode;
}"
41905,"/** 
 * Gets the connection mode used in the client. Currently only Gateway in supported.
 * @return the connection mode.
 */
public ConnectionMode getConnectionMode(){
  return this.connectionMode;
}","/** 
 * Gets the connection mode used in the client. Currently only Gateway is supported.
 * @return the connection mode.
 */
public ConnectionMode getConnectionMode(){
  return this.connectionMode;
}"
41906,"private void initialize(URI serviceEndpoint,ConnectionPolicy connectionPolicy,ConsistencyLevel desiredConsistencyLevel){
  this.serviceEndpoint=serviceEndpoint;
  if (connectionPolicy != null) {
    this.connectionPolicy=connectionPolicy;
  }
 else {
    this.connectionPolicy=new ConnectionPolicy();
  }
  this.retryPolicy=RetryPolicy.getDefault();
  this.sessionContainer=new SessionContainer(this.serviceEndpoint.getHost());
  this.desiredConsistencyLevel=desiredConsistencyLevel;
  UserAgentContainer userAgentContainer=new UserAgentContainer();
  String userAgentSuffix=connectionPolicy.getUserAgentSuffix();
  if (userAgentSuffix != null && userAgentSuffix.length() > 0) {
    userAgentContainer.setSuffix(userAgentSuffix);
  }
  this.gatewayProxy=new GatewayProxy(this.serviceEndpoint,this.connectionPolicy,desiredConsistencyLevel,this.queryCompatibilityMode,this.masterKey,this.resourceTokens,userAgentContainer);
}","private void initialize(URI serviceEndpoint,ConnectionPolicy connectionPolicy,ConsistencyLevel desiredConsistencyLevel){
  this.serviceEndpoint=serviceEndpoint;
  if (connectionPolicy != null) {
    this.connectionPolicy=connectionPolicy;
  }
 else {
    this.connectionPolicy=new ConnectionPolicy();
  }
  this.retryPolicy=RetryPolicy.getDefault();
  this.sessionContainer=new SessionContainer(this.serviceEndpoint.getHost());
  this.desiredConsistencyLevel=desiredConsistencyLevel;
  UserAgentContainer userAgentContainer=new UserAgentContainer();
  String userAgentSuffix=this.connectionPolicy.getUserAgentSuffix();
  if (userAgentSuffix != null && userAgentSuffix.length() > 0) {
    userAgentContainer.setSuffix(userAgentSuffix);
  }
  this.gatewayProxy=new GatewayProxy(this.serviceEndpoint,this.connectionPolicy,desiredConsistencyLevel,this.queryCompatibilityMode,this.masterKey,this.resourceTokens,userAgentContainer);
}"
41907,"/** 
 * Max Quota.
 * @return the document size quota.
 */
public long getCollectionSizeQuota(){
  return this.getMaxQuotaHeader(Constants.Quota.COLLECTION_SIZE);
}","/** 
 * Max Quota.
 * @return the collection size quota.
 */
public long getCollectionSizeQuota(){
  return this.getMaxQuotaHeader(Constants.Quota.COLLECTION_SIZE);
}"
41908,"/** 
 * Current Usage.
 * @return the current document size usage.
 */
public long getCollectionSizeUsage(){
  return this.getCurrentQuotaHeader(Constants.Quota.COLLECTION_SIZE);
}","/** 
 * Current Usage.
 * @return the current collection size usage.
 */
public long getCollectionSizeUsage(){
  return this.getCurrentQuotaHeader(Constants.Quota.COLLECTION_SIZE);
}"
41909,"@Test public void testDocumentCrud() throws DocumentClientException {
  DocumentClient client=new DocumentClient(HOST,MASTER_KEY,ConnectionPolicy.GetDefault(),ConsistencyLevel.Session);
  List<Document> documents=client.readDocuments(this.collectionForTest.getSelfLink(),null).getQueryIterable().toList();
  Assert.assertEquals(0,documents.size());
  Document documentDefinition=new Document(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  try {
    client.createDocument(this.collectionForTest.getSelfLink(),documentDefinition,null,true);
    Assert.fail(""String_Node_Str"");
  }
 catch (  DocumentClientException e) {
    Assert.assertEquals(400,e.getStatusCode());
    Assert.assertEquals(""String_Node_Str"",e.getError().getCode());
  }
  Document document=client.createDocument(this.collectionForTest.getSelfLink(),documentDefinition,null,false).getResource();
  Assert.assertEquals(documentDefinition.getString(""String_Node_Str""),document.getString(""String_Node_Str""));
  Assert.assertNotNull(document.getId());
  documents=client.readDocuments(this.collectionForTest.getSelfLink(),null).getQueryIterable().toList();
  Assert.assertEquals(1,documents.size());
  documents=client.queryDocuments(this.collectionForTest.getSelfLink(),new SqlQuerySpec(""String_Node_Str"",new SqlParameterCollection(new SqlParameter(""String_Node_Str"",documentDefinition.getString(""String_Node_Str"")))),null).getQueryIterable().toList();
  Assert.assertEquals(1,documents.size());
  document.set(""String_Node_Str"",""String_Node_Str"");
  document.set(""String_Node_Str"",""String_Node_Str"");
  Document replacedDocument=client.replaceDocument(document,null).getResource();
  Assert.assertEquals(""String_Node_Str"",replacedDocument.getString(""String_Node_Str""));
  Assert.assertEquals(""String_Node_Str"",replacedDocument.getString(""String_Node_Str""));
  Assert.assertEquals(document.getId(),replacedDocument.getId());
  Document oneDocumentFromRead=client.readDocument(replacedDocument.getSelfLink(),null).getResource();
  Assert.assertEquals(replacedDocument.getId(),oneDocumentFromRead.getId());
  AccessCondition accessCondition=new AccessCondition();
  accessCondition.setCondition(oneDocumentFromRead.getETag());
  accessCondition.setType(AccessConditionType.IfNoneMatch);
  RequestOptions options=new RequestOptions();
  options.setAccessCondition(accessCondition);
  ResourceResponse<Document> rr=client.readDocument(oneDocumentFromRead.getSelfLink(),options);
  Assert.assertEquals(rr.getStatusCode(),HttpStatus.SC_NOT_MODIFIED);
  client.deleteDocument(replacedDocument.getSelfLink(),null).close();
  try {
    client.readDocument(replacedDocument.getSelfLink(),null).close();
    Assert.fail(""String_Node_Str"");
  }
 catch (  DocumentClientException e) {
    Assert.assertEquals(404,e.getStatusCode());
    Assert.assertEquals(""String_Node_Str"",e.getError().getCode());
  }
}","@Test public void testDocumentCrud() throws DocumentClientException {
  DocumentClient client=new DocumentClient(HOST,MASTER_KEY,ConnectionPolicy.GetDefault(),ConsistencyLevel.Session);
  List<Document> documents=client.readDocuments(this.collectionForTest.getSelfLink(),null).getQueryIterable().toList();
  Assert.assertEquals(0,documents.size());
  Document documentDefinition=new Document(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  try {
    client.createDocument(this.collectionForTest.getSelfLink(),documentDefinition,null,true);
    Assert.fail(""String_Node_Str"");
  }
 catch (  DocumentClientException e) {
    Assert.assertEquals(400,e.getStatusCode());
    Assert.assertEquals(""String_Node_Str"",e.getError().getCode());
  }
  Document document=client.createDocument(this.collectionForTest.getSelfLink(),documentDefinition,null,false).getResource();
  Assert.assertEquals(documentDefinition.getString(""String_Node_Str""),document.getString(""String_Node_Str""));
  Assert.assertEquals(documentDefinition.getString(""String_Node_Str""),document.getString(""String_Node_Str""));
  Assert.assertEquals(documentDefinition.getString(""String_Node_Str""),document.getString(""String_Node_Str""));
  Assert.assertNotNull(document.getId());
  documents=client.readDocuments(this.collectionForTest.getSelfLink(),null).getQueryIterable().toList();
  Assert.assertEquals(1,documents.size());
  documents=client.queryDocuments(this.collectionForTest.getSelfLink(),new SqlQuerySpec(""String_Node_Str"",new SqlParameterCollection(new SqlParameter(""String_Node_Str"",documentDefinition.getString(""String_Node_Str"")))),null).getQueryIterable().toList();
  Assert.assertEquals(1,documents.size());
  document.set(""String_Node_Str"",""String_Node_Str"");
  document.set(""String_Node_Str"",""String_Node_Str"");
  Document replacedDocument=client.replaceDocument(document,null).getResource();
  Assert.assertEquals(""String_Node_Str"",replacedDocument.getString(""String_Node_Str""));
  Assert.assertEquals(""String_Node_Str"",replacedDocument.getString(""String_Node_Str""));
  Assert.assertEquals(document.getId(),replacedDocument.getId());
  Document oneDocumentFromRead=client.readDocument(replacedDocument.getSelfLink(),null).getResource();
  Assert.assertEquals(replacedDocument.getId(),oneDocumentFromRead.getId());
  AccessCondition accessCondition=new AccessCondition();
  accessCondition.setCondition(oneDocumentFromRead.getETag());
  accessCondition.setType(AccessConditionType.IfNoneMatch);
  RequestOptions options=new RequestOptions();
  options.setAccessCondition(accessCondition);
  ResourceResponse<Document> rr=client.readDocument(oneDocumentFromRead.getSelfLink(),options);
  Assert.assertEquals(rr.getStatusCode(),HttpStatus.SC_NOT_MODIFIED);
  client.deleteDocument(replacedDocument.getSelfLink(),null).close();
  try {
    client.readDocument(replacedDocument.getSelfLink(),null).close();
    Assert.fail(""String_Node_Str"");
  }
 catch (  DocumentClientException e) {
    Assert.assertEquals(404,e.getStatusCode());
    Assert.assertEquals(""String_Node_Str"",e.getError().getCode());
  }
}"
41910,"private void putMoreContentIntoDocumentServiceRequest(DocumentServiceRequest request,String httpMethod){
  if (this.masterKey != null) {
    final Date currentTime=new Date();
    final SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
    sdf.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
    String xDate=sdf.format(currentTime);
    request.getHeaders().put(HttpConstants.HttpHeaders.X_DATE,xDate);
  }
  if (this.masterKey != null || this.resourceTokens != null) {
    String authorization=this.getAuthorizationToken(request.getResourceId(),request.getPath(),request.getResourceType(),httpMethod,request.getHeaders(),this.masterKey,this.resourceTokens);
    try {
      authorization=URLEncoder.encode(authorization,""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      throw new IllegalStateException(""String_Node_Str"",e);
    }
    request.getHeaders().put(HttpConstants.HttpHeaders.AUTHORIZATION,authorization);
  }
  if ((httpMethod == HttpConstants.HttpMethods.POST || httpMethod == HttpConstants.HttpMethods.PUT) && !request.getHeaders().containsKey(HttpConstants.HttpHeaders.CONTENT_TYPE)) {
    request.getHeaders().put(HttpConstants.HttpHeaders.CONTENT_TYPE,RuntimeConstants.MediaTypes.JSON);
  }
  if (!request.getHeaders().containsKey(HttpConstants.HttpHeaders.ACCEPT)) {
    request.getHeaders().put(HttpConstants.HttpHeaders.ACCEPT,RuntimeConstants.MediaTypes.JSON);
  }
}","private void putMoreContentIntoDocumentServiceRequest(DocumentServiceRequest request,String httpMethod){
  if (this.masterKey != null) {
    final Date currentTime=new Date();
    final SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"",Locale.US);
    sdf.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
    String xDate=sdf.format(currentTime);
    request.getHeaders().put(HttpConstants.HttpHeaders.X_DATE,xDate);
  }
  if (this.masterKey != null || this.resourceTokens != null) {
    String authorization=this.getAuthorizationToken(request.getResourceId(),request.getPath(),request.getResourceType(),httpMethod,request.getHeaders(),this.masterKey,this.resourceTokens);
    try {
      authorization=URLEncoder.encode(authorization,""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      throw new IllegalStateException(""String_Node_Str"",e);
    }
    request.getHeaders().put(HttpConstants.HttpHeaders.AUTHORIZATION,authorization);
  }
  if ((httpMethod == HttpConstants.HttpMethods.POST || httpMethod == HttpConstants.HttpMethods.PUT) && !request.getHeaders().containsKey(HttpConstants.HttpHeaders.CONTENT_TYPE)) {
    request.getHeaders().put(HttpConstants.HttpHeaders.CONTENT_TYPE,RuntimeConstants.MediaTypes.JSON);
  }
  if (!request.getHeaders().containsKey(HttpConstants.HttpHeaders.ACCEPT)) {
    request.getHeaders().put(HttpConstants.HttpHeaders.ACCEPT,RuntimeConstants.MediaTypes.JSON);
  }
}"
41911,"/** 
 * Only one instance is created for the httpClient for optimization. A PoolingClientConnectionManager is used with the Http client  to be able to reuse connections and execute requests concurrently. A timeout for closing each connection is set so that connections don't leak. A timeout is set for requests to avoid deadlocks.
 * @return the created HttpClient
 */
private HttpClient createHttpClient(boolean isForMedia){
  HttpClient httpClient=new DefaultHttpClient(this.connectionManager);
  HttpParams httpParams=httpClient.getParams();
  if (isForMedia) {
    HttpConnectionParams.setConnectionTimeout(httpParams,this.connectionPolicy.getMediaRequestTimeout() * 1000);
    HttpConnectionParams.setSoTimeout(httpParams,this.connectionPolicy.getMediaRequestTimeout() * 1000);
  }
 else {
    HttpConnectionParams.setConnectionTimeout(httpParams,this.connectionPolicy.getRequestTimeout() * 1000);
    HttpConnectionParams.setSoTimeout(httpParams,this.connectionPolicy.getRequestTimeout() * 1000);
  }
  return httpClient;
}","/** 
 * Only one instance is created for the httpClient for optimization. A PoolingClientConnectionManager is used with the Http client to be able to reuse connections and execute requests concurrently. A timeout for closing each connection is set so that connections don't leak. A timeout is set for requests to avoid deadlocks.
 * @return the created HttpClient
 */
private HttpClient createHttpClient(boolean isForMedia){
  HttpClient httpClient=new DefaultHttpClient(this.connectionManager);
  HttpParams httpParams=httpClient.getParams();
  if (isForMedia) {
    HttpConnectionParams.setConnectionTimeout(httpParams,this.connectionPolicy.getMediaRequestTimeout() * 1000);
    HttpConnectionParams.setSoTimeout(httpParams,this.connectionPolicy.getMediaRequestTimeout() * 1000);
  }
 else {
    HttpConnectionParams.setConnectionTimeout(httpParams,this.connectionPolicy.getRequestTimeout() * 1000);
    HttpConnectionParams.setSoTimeout(httpParams,this.connectionPolicy.getRequestTimeout() * 1000);
  }
  return httpClient;
}"
41912,"/** 
 * Gets the continuation token to be used for continuing the enumeration.
 * @return the response continuation.
 */
public String getResponseContinuation(){
  return this.responseHeaders.get(HttpConstants.HttpHeaders.CONTINUATION);
}","/** 
 * Gets the continuation token to be used for continuing the enumeration.
 * @return the response continuation.
 */
public String getResponseContinuation(){
  return this.inner.getContinuation();
}"
41913,"QueryIterable(DocumentClient client,DocumentServiceRequest request,ReadType readType,Class<T> classT){
  this.client=client;
  this.retryPolicy=new ResourceThrottleRetryPolicy(client.getRetryPolicy().getMaxRetryAttemptsOnQuery());
  this.request=request;
  this.readType=readType;
  this.classT=classT;
}","QueryIterable(DocumentClient client,DocumentServiceRequest request,ReadType readType,Class<T> classT){
  this.client=client;
  this.retryPolicy=new ResourceThrottleRetryPolicy(client.getRetryPolicy().getMaxRetryAttemptsOnQuery());
  this.request=request;
  this.readType=readType;
  this.classT=classT;
  if (this.request != null && this.request.getHeaders() != null) {
    String continuationToken=this.request.getHeaders().get(HttpConstants.HttpHeaders.CONTINUATION);
    if (!StringUtils.isBlank(continuationToken)) {
      this.continuation=continuationToken;
    }
  }
}"
41914,"@Test public void testQueryIterableCrud() throws DocumentClientException {
  DocumentClient client=new DocumentClient(HOST,MASTER_KEY,ConnectionPolicy.GetDefault(),ConsistencyLevel.Session);
  List<Document> documents=client.readDocuments(this.collectionForTest.getSelfLink(),null).getQueryIterable().toList();
  int beforeCreateDocumentsCount=documents.size();
  for (int i=0; i < 20; ++i) {
    Document documentDefinition=new Document(""String_Node_Str"");
    client.createDocument(this.collectionForTest.getSelfLink(),documentDefinition,null,false);
  }
  FeedOptions fo=new FeedOptions();
  fo.setPageSize(1);
  documents=client.readDocuments(this.collectionForTest.getSelfLink(),null).getQueryIterable().toList();
  Assert.assertEquals(beforeCreateDocumentsCount + 20,documents.size());
}","@Test public void testQueryIterableCrud() throws DocumentClientException {
  DocumentClient client=new DocumentClient(HOST,MASTER_KEY,ConnectionPolicy.GetDefault(),ConsistencyLevel.Session);
  List<Document> documents=client.readDocuments(this.collectionForTest.getSelfLink(),null).getQueryIterable().toList();
  int beforeCreateDocumentsCount=documents.size();
  int noOfDocuments=10;
  for (int i=0; i < noOfDocuments; ++i) {
    Document documentDefinition=new Document(""String_Node_Str"");
    client.createDocument(this.collectionForTest.getSelfLink(),documentDefinition,null,false);
  }
  int noOfDocumentsPerPage=noOfDocuments / 5;
  FeedOptions fo=new FeedOptions();
  fo.setPageSize(noOfDocumentsPerPage);
  FeedResponse<Document> feedResponse;
  Iterator<Document> iterator;
  int i=0;
  String continuationToken=null;
  List<String> currentPage=new ArrayList<String>();
  List<String> previousPage=new ArrayList<String>();
  do {
    currentPage.clear();
    fo.setRequestContinuation(continuationToken);
    feedResponse=client.readDocuments(this.collectionForTest.getSelfLink(),fo);
    iterator=feedResponse.getQueryIterator();
    i=0;
    while (iterator.hasNext()) {
      i++;
      Document document=iterator.next();
      currentPage.add(document.getId());
      if (i == noOfDocumentsPerPage) {
        break;
      }
    }
    continuationToken=feedResponse.getResponseContinuation();
    for (    String idFromCurrentPage : currentPage) {
      if (previousPage.contains(idFromCurrentPage)) {
        Assert.fail(""String_Node_Str"" + idFromCurrentPage);
      }
    }
    previousPage.clear();
    previousPage.addAll(currentPage);
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
 while (continuationToken != null);
  documents=client.readDocuments(this.collectionForTest.getSelfLink(),null).getQueryIterable().toList();
  Assert.assertEquals(beforeCreateDocumentsCount + noOfDocuments,documents.size());
}"
41915,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.fragment_profile);
  final GridView gridView=(GridView)findViewById(R.id.gridview);
  Intent intent=getIntent();
  String personid=intent.getStringExtra(""String_Node_Str"");
  final TextView profileName=(TextView)findViewById(R.id.profile_text_1);
  AbelanaClient client=new AbelanaClient();
  client.mFProfile.fProfile(Data.aTok,personid,""String_Node_Str"",new Callback<AbelanaClient.Timeline>(){
    @Override public void success(    AbelanaClient.Timeline timeline,    Response response){
      Data.mFollowingProfileUrls=new ArrayList<String>();
      profileName.setText(timeline.entries[0].name + ""String_Node_Str"");
      if (timeline.entries != null) {
        for (        AbelanaClient.TimelineEntry e : timeline.entries) {
          Data.mFollowingProfileUrls.add(AbelanaThings.getImage(e.photoid));
        }
        gridView.setAdapter(new FriendProfileAdapter(getApplicationContext()));
      }
    }
    @Override public void failure(    RetrofitError error){
      error.printStackTrace();
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.fragment_profile);
  final GridView gridView=(GridView)findViewById(R.id.gridview);
  Intent intent=getIntent();
  String personid=intent.getStringExtra(""String_Node_Str"");
  final TextView profileName=(TextView)findViewById(R.id.profile_text_1);
  AbelanaClient client=new AbelanaClient();
  client.mFProfile.fProfile(Data.aTok,personid,""String_Node_Str"",new Callback<AbelanaClient.Timeline>(){
    @Override public void success(    AbelanaClient.Timeline timeline,    Response response){
      Data.mFollowingProfileUrls=new ArrayList<String>();
      if (timeline.entries != null) {
        profileName.setText(timeline.entries[0].name + ""String_Node_Str"");
        for (        AbelanaClient.TimelineEntry e : timeline.entries) {
          Data.mFollowingProfileUrls.add(AbelanaThings.getImage(e.photoid));
        }
        gridView.setAdapter(new FriendProfileAdapter(getApplicationContext()));
      }
    }
    @Override public void failure(    RetrofitError error){
      error.printStackTrace();
    }
  }
);
}"
41916,"@Override public void success(AbelanaClient.Timeline timeline,Response response){
  Data.mFollowingProfileUrls=new ArrayList<String>();
  profileName.setText(timeline.entries[0].name + ""String_Node_Str"");
  if (timeline.entries != null) {
    for (    AbelanaClient.TimelineEntry e : timeline.entries) {
      Data.mFollowingProfileUrls.add(AbelanaThings.getImage(e.photoid));
    }
    gridView.setAdapter(new FriendProfileAdapter(getApplicationContext()));
  }
}","@Override public void success(AbelanaClient.Timeline timeline,Response response){
  Data.mFollowingProfileUrls=new ArrayList<String>();
  if (timeline.entries != null) {
    profileName.setText(timeline.entries[0].name + ""String_Node_Str"");
    for (    AbelanaClient.TimelineEntry e : timeline.entries) {
      Data.mFollowingProfileUrls.add(AbelanaThings.getImage(e.photoid));
    }
    gridView.setAdapter(new FriendProfileAdapter(getApplicationContext()));
  }
}"
41917,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.fragment_profile);
  final GridView gridView=(GridView)findViewById(R.id.gridview);
  Intent intent=getIntent();
  String personid=intent.getStringExtra(""String_Node_Str"");
  final TextView profileName=(TextView)findViewById(R.id.profile_text_1);
  AbelanaClient client=new AbelanaClient();
  client.mFProfile.fProfile(Data.aTok,personid,""String_Node_Str"",new Callback<AbelanaClient.Timeline>(){
    @Override public void success(    AbelanaClient.Timeline timeline,    Response response){
      Data.mFollowingProfileUrls=new ArrayList<String>();
      if (timeline.entries != null) {
        profileName.setText(timeline.entries[0].name + ""String_Node_Str"");
        for (        AbelanaClient.TimelineEntry e : timeline.entries) {
          Data.mFollowingProfileUrls.add(AbelanaThings.getImage(e.photoid));
        }
        gridView.setAdapter(new FriendProfileAdapter(getApplicationContext()));
      }
    }
    @Override public void failure(    RetrofitError error){
      error.printStackTrace();
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.fragment_profile);
  final GridView gridView=(GridView)findViewById(R.id.gridview);
  Intent intent=getIntent();
  String personid=intent.getStringExtra(""String_Node_Str"");
  String personName=intent.getStringExtra(""String_Node_Str"");
  TextView profileName=(TextView)findViewById(R.id.profile_text_1);
  profileName.setText(personName + ""String_Node_Str"");
  AbelanaClient client=new AbelanaClient();
  client.mFProfile.fProfile(Data.aTok,personid,""String_Node_Str"",new Callback<AbelanaClient.Timeline>(){
    @Override public void success(    AbelanaClient.Timeline timeline,    Response response){
      Data.mFollowingProfileUrls=new ArrayList<String>();
      if (timeline.entries != null) {
        for (        AbelanaClient.TimelineEntry e : timeline.entries) {
          Data.mFollowingProfileUrls.add(AbelanaThings.getImage(e.photoid));
        }
        gridView.setAdapter(new FriendProfileAdapter(getApplicationContext()));
      }
    }
    @Override public void failure(    RetrofitError error){
      error.printStackTrace();
    }
  }
);
}"
41918,"@Override public void success(AbelanaClient.Timeline timeline,Response response){
  Data.mFollowingProfileUrls=new ArrayList<String>();
  if (timeline.entries != null) {
    profileName.setText(timeline.entries[0].name + ""String_Node_Str"");
    for (    AbelanaClient.TimelineEntry e : timeline.entries) {
      Data.mFollowingProfileUrls.add(AbelanaThings.getImage(e.photoid));
    }
    gridView.setAdapter(new FriendProfileAdapter(getApplicationContext()));
  }
}","@Override public void success(AbelanaClient.Timeline timeline,Response response){
  Data.mFollowingProfileUrls=new ArrayList<String>();
  if (timeline.entries != null) {
    for (    AbelanaClient.TimelineEntry e : timeline.entries) {
      Data.mFollowingProfileUrls.add(AbelanaThings.getImage(e.photoid));
    }
    gridView.setAdapter(new FriendProfileAdapter(getApplicationContext()));
  }
}"
41919,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_friends,container,false);
  final ListView listView=(ListView)rootView.findViewById(R.id.listview_friends);
  setHasOptionsMenu(true);
  AbelanaClient client=new AbelanaClient();
  client.mGetFollowing.getFollowing(Data.aTok,new Callback<AbelanaClient.Persons>(){
    @Override public void success(    AbelanaClient.Persons persons,    Response response){
      Data.mFollowingNames=new ArrayList<String>();
      Data.mFollowingIds=new ArrayList<String>();
      if (persons.persons != null) {
        for (        AbelanaClient.Person p : persons.persons) {
          Data.mFollowingNames.add(p.name);
          Data.mFollowingIds.add(p.personid);
        }
        listView.setAdapter(new FriendsAdapter(getActivity()));
      }
    }
    @Override public void failure(    RetrofitError error){
    }
  }
);
  listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> adapterView,    View view,    int position,    long id){
      String personId=Data.mFollowingIds.get(position);
      Log.v(LOG_TAG,""String_Node_Str"" + personId);
      Intent intent=new Intent(getActivity(),FriendProfileActivity.class);
      intent.putExtra(""String_Node_Str"",personId);
      startActivity(intent);
    }
  }
);
  return rootView;
}","@Override public View onCreateView(final LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_friends,container,false);
  final ListView listView=(ListView)rootView.findViewById(R.id.listview_friends);
  setHasOptionsMenu(true);
  AbelanaClient client=new AbelanaClient();
  client.mGetFollowing.getFollowing(Data.aTok,new Callback<AbelanaClient.Persons>(){
    @Override public void success(    AbelanaClient.Persons persons,    Response response){
      Data.mFollowingNames=new ArrayList<String>();
      Data.mFollowingIds=new ArrayList<String>();
      if (persons.persons != null) {
        for (        AbelanaClient.Person p : persons.persons) {
          Data.mFollowingNames.add(p.name);
          Data.mFollowingIds.add(p.personid);
        }
        listView.setAdapter(new FriendsAdapter(getActivity()));
      }
    }
    @Override public void failure(    RetrofitError error){
      error.printStackTrace();
    }
  }
);
  listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> adapterView,    View view,    int position,    long id){
      String personId=Data.mFollowingIds.get(position);
      String personName=Data.mFollowingNames.get(position);
      Log.v(LOG_TAG,""String_Node_Str"" + personId);
      Intent intent=new Intent(getActivity(),FriendProfileActivity.class);
      intent.putExtra(""String_Node_Str"",personId);
      intent.putExtra(""String_Node_Str"",personName);
      startActivity(intent);
    }
  }
);
  return rootView;
}"
41920,"@Override public void onItemClick(AdapterView<?> adapterView,View view,int position,long id){
  String personId=Data.mFollowingIds.get(position);
  Log.v(LOG_TAG,""String_Node_Str"" + personId);
  Intent intent=new Intent(getActivity(),FriendProfileActivity.class);
  intent.putExtra(""String_Node_Str"",personId);
  startActivity(intent);
}","@Override public void onItemClick(AdapterView<?> adapterView,View view,int position,long id){
  String personId=Data.mFollowingIds.get(position);
  String personName=Data.mFollowingNames.get(position);
  Log.v(LOG_TAG,""String_Node_Str"" + personId);
  Intent intent=new Intent(getActivity(),FriendProfileActivity.class);
  intent.putExtra(""String_Node_Str"",personId);
  intent.putExtra(""String_Node_Str"",personName);
  startActivity(intent);
}"
41921,"@Override public View getView(int position,View convertView,ViewGroup parent){
  ViewHolder holder;
  if (convertView == null) {
    convertView=mInflater.inflate(R.layout.dua_detail_item_card,parent,false);
    holder=new ViewHolder();
    holder.tvDuaNumber=(TextView)convertView.findViewById(R.id.txtDuaNumber);
    holder.tvDuaArabic=(TextView)convertView.findViewById(R.id.txtDuaArabic);
    holder.tvDuaArabic.setTypeface(sCachedTypeface);
    holder.tvDuaArabic.setTextSize(prefArabicFontSize);
    holder.tvDuaTranslation=(TextView)convertView.findViewById(R.id.txtDuaTranslation);
    holder.tvDuaReference=(TextView)convertView.findViewById(R.id.txtDuaReference);
    holder.tvDuaReference.setTextSize(prefOtherFontSize);
    convertView.setTag(holder);
  }
  holder=(ViewHolder)convertView.getTag();
  Dua p=getItem(position);
  if (p != null) {
    holder.tvDuaNumber.setText(""String_Node_Str"" + p.getReference());
    holder.tvDuaArabic.setText(Html.fromHtml(p.getArabic()));
    final Spannable translation=new SpannableString(p.getTranslation());
    holder.tvDuaTranslation.setText(translation);
    if (p.getBook_reference() != null)     holder.tvDuaReference.setText(Html.fromHtml(p.getBook_reference()));
 else     holder.tvDuaReference.setText(""String_Node_Str"");
  }
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  ViewHolder holder;
  if (convertView == null) {
    convertView=mInflater.inflate(R.layout.dua_detail_item_card,parent,false);
    holder=new ViewHolder();
    holder.tvDuaNumber=(TextView)convertView.findViewById(R.id.txtDuaNumber);
    holder.tvDuaArabic=(TextView)convertView.findViewById(R.id.txtDuaArabic);
    holder.tvDuaArabic.setTypeface(sCachedTypeface);
    holder.tvDuaArabic.setTextSize(prefArabicFontSize);
    holder.tvDuaTranslation=(TextView)convertView.findViewById(R.id.txtDuaTranslation);
    holder.tvDuaTranslation.setTextSize(prefOtherFontSize);
    holder.tvDuaReference=(TextView)convertView.findViewById(R.id.txtDuaReference);
    holder.tvDuaReference.setTextSize(prefOtherFontSize);
    convertView.setTag(holder);
  }
  holder=(ViewHolder)convertView.getTag();
  Dua p=getItem(position);
  if (p != null) {
    holder.tvDuaNumber.setText(""String_Node_Str"" + p.getReference());
    holder.tvDuaArabic.setText(Html.fromHtml(p.getArabic()));
    final Spannable translation=new SpannableString(p.getTranslation());
    holder.tvDuaTranslation.setText(translation);
    if (p.getBook_reference() != null)     holder.tvDuaReference.setText(Html.fromHtml(p.getBook_reference()));
 else     holder.tvDuaReference.setText(""String_Node_Str"");
  }
  return convertView;
}"
41922,"public void enable(){
  PlotMeCoreManager.getInstance().setPlugin(this);
  configFile=new ConfigAccessor(getServerBridge().getDataFolder(),""String_Node_Str"");
  setupConfigFiles();
  setupSQL();
  serverBridge.setupHooks();
  if (getConfig().getInt(""String_Node_Str"") > 0) {
    serverBridge.runTaskTimerAsynchronously(new PlotExpireCleanup(this),20L * 60 * 30,20L * 60 * getConfig().getInt(""String_Node_Str""));
  }
}","public void enable(){
  PlotMeCoreManager.getInstance().setPlugin(this);
  configFile=new ConfigAccessor(getServerBridge().getDataFolder(),""String_Node_Str"");
  setupConfigFiles();
  setupSQL();
  serverBridge.setupHooks();
  if (getConfig().getBoolean(""String_Node_Str"")) {
    serverBridge.runTaskTimerAsynchronously(new PlotExpireCleanup(this),20L * 60 * 30,20L * 60 * getConfig().getInt(""String_Node_Str""));
  }
}"
41923,"public boolean execute(ICommandSender player,String[] args){
  int page=1;
  if (args.length > 1) {
    try {
      page=Integer.parseInt(args[1]);
      if (page < 1) {
        page=1;
      }
    }
 catch (    NumberFormatException ignored) {
    }
  }
  List<String> allowed_commands=new ArrayList<>();
  allowed_commands.add(""String_Node_Str"");
  if (player.hasPermission(PermissionNames.USER_CLAIM)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(""String_Node_Str"")) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_AUTO)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_HOME)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_INFO)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_LIST)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_BIOME)) {
    allowed_commands.add(""String_Node_Str"");
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_DONE) || player.hasPermission(PermissionNames.ADMIN_DONE)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_TP)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_CLEAR) || player.hasPermission(PermissionNames.ADMIN_CLEAR)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_DISPOSE) || player.hasPermission(PermissionNames.USER_DISPOSE)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_RESET)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_ADD) || player.hasPermission(PermissionNames.ADMIN_ADD)) {
    allowed_commands.add(""String_Node_Str"");
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_DENY) || player.hasPermission(PermissionNames.ADMIN_DENY)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_SETOWNER)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_MOVE)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_WEANYWHERE)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_EXPIRED)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_ADDTIME)) {
    allowed_commands.add(""String_Node_Str"");
  }
  PlotMapInfo pmi=manager.getMap((IPlayer)player);
  boolean economyEnabled=manager.isEconomyEnabled(pmi);
  if (manager.isPlotWorld((IPlayer)player) && economyEnabled) {
    if (player.hasPermission(PermissionNames.USER_BUY)) {
      allowed_commands.add(""String_Node_Str"");
    }
    if (player.hasPermission(PermissionNames.USER_SELL)) {
      allowed_commands.add(""String_Node_Str"");
    }
  }
  int maxPage=(int)Math.ceil(allowed_commands.size() / 4);
  page=Math.min(maxPage,Math.max(1,page));
  player.sendMessage(C(""String_Node_Str"",page,maxPage));
  for (int ctr=(page - 1) * 4; ctr < (page * 4) && ctr < allowed_commands.size(); ctr++) {
    String allowedCommand=allowed_commands.get(ctr);
    if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      int plotLimit=getPlotLimit((IPlayer)player);
      if (manager.isPlotWorld((IPlayer)player)) {
        IWorld world=((IPlayer)player).getWorld();
        int ownedPlots=manager.getOwnedPlotCount(((IPlayer)player).getUniqueId(),world);
        if (plotLimit == -1) {
          player.sendMessage(C(""String_Node_Str""));
        }
 else {
          player.sendMessage(C(""String_Node_Str"",ownedPlots,plotLimit));
        }
      }
 else       if (plugin.getConfig().getBoolean(""String_Node_Str"")) {
        IWorld world=manager.getFirstWorld();
        int ownedPlots=manager.getOwnedPlotCount(((IPlayer)player).getUniqueId(),world);
        if (plotLimit == -1) {
          player.sendMessage(C(""String_Node_Str""));
        }
 else {
          player.sendMessage(C(""String_Node_Str"",ownedPlots,plotLimit));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getClaimPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getClaimPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(""String_Node_Str"");
      if (economyEnabled && pmi.getClaimPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getClaimPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      if (plugin.getConfig().getBoolean(""String_Node_Str"")) {
        player.sendMessage(""String_Node_Str"");
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
      if (economyEnabled && pmi.getClaimPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getClaimPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getPlotHomePrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getPlotHomePrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getBiomeChangePrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getBiomeChangePrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(""String_Node_Str"");
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      if (plugin.getConfig().getBoolean(""String_Node_Str"")) {
        player.sendMessage(C(""String_Node_Str""));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getClearPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getClearPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getAddPlayerPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getAddPlayerPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getRemovePlayerPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getRemovePlayerPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getDenyPlayerPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getDenyPlayerPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getUndenyPlayerPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getUndenyPlayerPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      int days=pmi.getDaysToExpiration();
      if (days != 0) {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getDisposePrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getDisposePrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
  }
  return true;
}","public boolean execute(ICommandSender player,String[] args){
  int page=1;
  if (args.length > 1) {
    try {
      page=Integer.parseInt(args[1]);
      if (page < 1) {
        page=1;
      }
    }
 catch (    NumberFormatException ignored) {
    }
  }
  List<String> allowed_commands=new ArrayList<>();
  allowed_commands.add(""String_Node_Str"");
  if (player.hasPermission(PermissionNames.USER_CLAIM)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(""String_Node_Str"")) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_AUTO)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_HOME)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_INFO)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_LIST)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_BIOME)) {
    allowed_commands.add(""String_Node_Str"");
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_DONE) || player.hasPermission(PermissionNames.ADMIN_DONE)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_TP)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_CLEAR) || player.hasPermission(PermissionNames.ADMIN_CLEAR)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_DISPOSE) || player.hasPermission(PermissionNames.USER_DISPOSE)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_RESET)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_ADD) || player.hasPermission(PermissionNames.ADMIN_ADD)) {
    allowed_commands.add(""String_Node_Str"");
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.USER_DENY) || player.hasPermission(PermissionNames.ADMIN_DENY)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_SETOWNER)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_MOVE)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_WEANYWHERE)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_EXPIRED)) {
    allowed_commands.add(""String_Node_Str"");
  }
  if (player.hasPermission(PermissionNames.ADMIN_ADDTIME)) {
    allowed_commands.add(""String_Node_Str"");
  }
  PlotMapInfo pmi=manager.getMap((IPlayer)player);
  boolean economyEnabled=manager.isEconomyEnabled(pmi);
  if (manager.isPlotWorld((IPlayer)player) && economyEnabled) {
    if (player.hasPermission(PermissionNames.USER_BUY)) {
      allowed_commands.add(""String_Node_Str"");
    }
    if (player.hasPermission(PermissionNames.USER_SELL)) {
      allowed_commands.add(""String_Node_Str"");
    }
  }
  int maxPage=(int)Math.ceil(allowed_commands.size() / 4);
  page=Math.min(maxPage,Math.max(1,page));
  player.sendMessage(C(""String_Node_Str"",page,maxPage));
  for (int ctr=(page - 1) * 4; ctr < (page * 4) && ctr < allowed_commands.size(); ctr++) {
    String allowedCommand=allowed_commands.get(ctr);
    if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      int plotLimit=getPlotLimit((IPlayer)player);
      if (manager.isPlotWorld((IPlayer)player)) {
        IWorld world=((IPlayer)player).getWorld();
        int ownedPlots=manager.getOwnedPlotCount(((IPlayer)player).getUniqueId(),world);
        if (plotLimit == -1) {
          player.sendMessage(C(""String_Node_Str""));
        }
 else {
          player.sendMessage(C(""String_Node_Str"",ownedPlots,plotLimit));
        }
      }
 else       if (plugin.getConfig().getBoolean(""String_Node_Str"")) {
        IWorld world=manager.getFirstWorld();
        int ownedPlots=manager.getOwnedPlotCount(((IPlayer)player).getUniqueId(),world);
        if (plotLimit == -1) {
          player.sendMessage(C(""String_Node_Str""));
        }
 else {
          player.sendMessage(C(""String_Node_Str"",ownedPlots,plotLimit));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getClaimPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getClaimPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getClaimPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getClaimPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      if (plugin.getConfig().getBoolean(""String_Node_Str"")) {
        player.sendMessage(C(""String_Node_Str""));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
      if (economyEnabled && pmi.getClaimPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getClaimPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getPlotHomePrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getPlotHomePrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getBiomeChangePrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getBiomeChangePrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      if (plugin.getConfig().getBoolean(""String_Node_Str"")) {
        player.sendMessage(C(""String_Node_Str""));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getClearPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getClearPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getAddPlayerPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getAddPlayerPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getRemovePlayerPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getRemovePlayerPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getDenyPlayerPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getDenyPlayerPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getUndenyPlayerPrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getUndenyPlayerPrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      int days=pmi.getDaysToExpiration();
      if (days != 0) {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      if (economyEnabled && pmi.getDisposePrice() != 0) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ Math.round(pmi.getDisposePrice()));
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(allowedCommand)) {
      player.sendMessage(C(""String_Node_Str""));
      player.sendMessage(C(""String_Node_Str""));
    }
  }
  return true;
}"
41924,"/** 
 * Get the plot home location of a plot
 * @param id    plot id to get home of
 * @param world
 * @return an ILocation of the plot home location
 */
public Location getPlotHome(PlotId id,IWorld world){
  Location plotHome=getGenManager(world).getPlotHome(id);
  plugin.getLogger().info(plotHome.toString());
  return plotHome;
}","/** 
 * Get the plot home location of a plot
 * @param id    plot id to get home of
 * @param world
 * @return an ILocation of the plot home location
 */
public Location getPlotHome(PlotId id,IWorld world){
  return getGenManager(world).getPlotHome(id);
}"
41925,"@Override public void run(){
  ClearEntry first=clearList.getFirst();
  IPlotMe_GeneratorManager genmanager=PlotMeCoreManager.getInstance().getGenManager(first.getPlot().getWorld());
  genmanager.clear(first.getPlot().getPlotBottomLoc(),first.getPlot().getPlotTopLoc(),first.getPlot().getId(),first);
  if (first.chunkqueue.isEmpty()) {
    if (first.getReason().equals(ClearReason.Clear)) {
      genmanager.adjustPlotFor(first.getPlot(),true,false,false);
    }
 else {
      genmanager.adjustPlotFor(first.getPlot(),false,false,false);
    }
    clearList.removeFirst();
    if (first.getSender() != null) {
      first.getSender().sendMessage(plugin.C(""String_Node_Str"") + ""String_Node_Str"" + first.getPlot().getId().getID()+ ""String_Node_Str""+ plugin.C(""String_Node_Str""));
    }
  }
 else {
    first.chunkqueue.poll().run();
  }
}","@Override public void run(){
  if (clearList.isEmpty()) {
    return;
  }
  ClearEntry first=clearList.getFirst();
  IPlotMe_GeneratorManager genmanager=PlotMeCoreManager.getInstance().getGenManager(first.getPlot().getWorld());
  genmanager.clear(first.getPlot().getPlotBottomLoc(),first.getPlot().getPlotTopLoc(),first.getPlot().getId(),first);
  if (first.chunkqueue.isEmpty()) {
    if (first.getReason().equals(ClearReason.Clear)) {
      genmanager.adjustPlotFor(first.getPlot(),true,false,false);
    }
 else {
      genmanager.adjustPlotFor(first.getPlot(),false,false,false);
    }
    clearList.removeFirst();
    if (first.getSender() != null) {
      first.getSender().sendMessage(plugin.C(""String_Node_Str"") + ""String_Node_Str"" + first.getPlot().getId().getID()+ ""String_Node_Str""+ plugin.C(""String_Node_Str""));
    }
  }
 else {
    first.chunkqueue.poll().run();
  }
}"
41926,"public void loadPlotsAsynchronously(final IWorld world){
  plugin.getServerBridge().runTaskAsynchronously(new Runnable(){
    @Override public void run(){
      plugin.getLogger().info(""String_Node_Str"" + world.getName());
      HashMap<PlotId,Plot> plots2=getPlots(world);
      plots.get(world).putAll(plots2);
      PlotWorldLoadEvent eventWorld=new PlotWorldLoadEvent(world,plots2.size());
      plugin.getEventBus().post(eventWorld);
      for (      Plot plot : plots2.values()) {
        PlotLoadEvent event=new PlotLoadEvent(plot);
        plugin.getEventBus().post(event);
      }
    }
    private HashMap<PlotId,Plot> getPlots(    IWorld world){
      HashMap<PlotId,Plot> ret=new HashMap<>();
      Connection connection=getConnection();
      try (PreparedStatement statementPlot=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementAllowed=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementDenied=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementLikes=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementMetadata=connection.prepareStatement(""String_Node_Str"")){
        statementPlot.setString(1,world.getName().toLowerCase());
        try (ResultSet setPlots=statementPlot.executeQuery()){
          while (setPlots.next()) {
            long internalID=setPlots.getLong(""String_Node_Str"");
            PlotId id=new PlotId(setPlots.getInt(""String_Node_Str""),setPlots.getInt(""String_Node_Str""));
            String owner=setPlots.getString(""String_Node_Str"");
            UUID ownerId=UUID.fromString(setPlots.getString(""String_Node_Str""));
            String biome=setPlots.getString(""String_Node_Str"");
            Date expiredDate=setPlots.getDate(""String_Node_Str"");
            boolean finished=setPlots.getBoolean(""String_Node_Str"");
            String finishedDate=setPlots.getString(""String_Node_Str"");
            String createdDate=setPlots.getString(""String_Node_Str"");
            double price=setPlots.getDouble(""String_Node_Str"");
            boolean forSale=setPlots.getBoolean(""String_Node_Str"");
            boolean protect=setPlots.getBoolean(""String_Node_Str"");
            String plotName=setPlots.getString(""String_Node_Str"");
            int plotLikes=setPlots.getInt(""String_Node_Str"");
            com.worldcretornica.plotme_core.api.Vector topLoc=new com.worldcretornica.plotme_core.api.Vector(setPlots.getInt(""String_Node_Str""),255,setPlots.getInt(""String_Node_Str""));
            com.worldcretornica.plotme_core.api.Vector bottomLoc=new com.worldcretornica.plotme_core.api.Vector(setPlots.getInt(""String_Node_Str""),0,setPlots.getInt(""String_Node_Str""));
            HashMap<String,Map<String,String>> metadata=new HashMap<>();
            HashMap<String,Plot.AccessLevel> allowed=new HashMap<>();
            HashSet<String> denied=new HashSet<>();
            HashSet<UUID> likers=new HashSet<>();
            statementAllowed.setLong(1,internalID);
            try (ResultSet setAllowed=statementAllowed.executeQuery()){
              while (setAllowed.next()) {
                allowed.put(setAllowed.getString(""String_Node_Str""),Plot.AccessLevel.getAccessLevel(setAllowed.getInt(""String_Node_Str"")));
              }
            }
             statementDenied.setLong(1,internalID);
            try (ResultSet setDenied=statementDenied.executeQuery()){
              while (setDenied.next()) {
                denied.add(setDenied.getString(""String_Node_Str""));
              }
            }
             statementLikes.setLong(1,internalID);
            try (ResultSet setLikes=statementLikes.executeQuery()){
              while (setLikes.next()) {
                likers.add(UUID.fromString(setLikes.getString(""String_Node_Str"")));
              }
            }
             statementMetadata.setLong(1,internalID);
            try (ResultSet setMetadata=statementMetadata.executeQuery()){
              while (setMetadata.next()) {
                String pluginname=setMetadata.getString(""String_Node_Str"");
                String propertyname=setMetadata.getString(""String_Node_Str"");
                String propertyvalue=setMetadata.getString(""String_Node_Str"");
                if (!metadata.containsKey(pluginname)) {
                  metadata.put(pluginname,new HashMap<String,String>());
                }
                metadata.get(pluginname).put(propertyname,propertyvalue);
              }
            }
             Plot plot=new Plot(internalID,owner,ownerId,world,biome,expiredDate,allowed,denied,likers,id,price,forSale,finished,finishedDate,protect,metadata,plotLikes,plotName,topLoc,bottomLoc,createdDate);
            ret.put(plot.getId(),plot);
          }
        }
       }
 catch (      SQLException ex) {
        plugin.getLogger().severe(""String_Node_Str"");
        plugin.getLogger().severe(ex.getMessage());
      }
      return ret;
    }
  }
);
}","public void loadPlotsAsynchronously(final IWorld world){
  plugin.getServerBridge().runTaskAsynchronously(new Runnable(){
    @Override public void run(){
      plugin.getLogger().info(""String_Node_Str"" + world.getName());
      HashMap<PlotId,Plot> plots2=getPlots(world);
      plots.put(world,plots2);
      PlotWorldLoadEvent eventWorld=new PlotWorldLoadEvent(world,plots2.size());
      plugin.getEventBus().post(eventWorld);
      for (      Plot plot : plots2.values()) {
        PlotLoadEvent event=new PlotLoadEvent(plot);
        plugin.getEventBus().post(event);
      }
    }
    private HashMap<PlotId,Plot> getPlots(    IWorld world){
      HashMap<PlotId,Plot> ret=new HashMap<>();
      Connection connection=getConnection();
      try (PreparedStatement statementPlot=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementAllowed=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementDenied=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementLikes=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementMetadata=connection.prepareStatement(""String_Node_Str"")){
        statementPlot.setString(1,world.getName().toLowerCase());
        try (ResultSet setPlots=statementPlot.executeQuery()){
          while (setPlots.next()) {
            long internalID=setPlots.getLong(""String_Node_Str"");
            PlotId id=new PlotId(setPlots.getInt(""String_Node_Str""),setPlots.getInt(""String_Node_Str""));
            String owner=setPlots.getString(""String_Node_Str"");
            UUID ownerId=UUID.fromString(setPlots.getString(""String_Node_Str""));
            String biome=setPlots.getString(""String_Node_Str"");
            Date expiredDate=setPlots.getDate(""String_Node_Str"");
            boolean finished=setPlots.getBoolean(""String_Node_Str"");
            String finishedDate=setPlots.getString(""String_Node_Str"");
            String createdDate=setPlots.getString(""String_Node_Str"");
            double price=setPlots.getDouble(""String_Node_Str"");
            boolean forSale=setPlots.getBoolean(""String_Node_Str"");
            boolean protect=setPlots.getBoolean(""String_Node_Str"");
            String plotName=setPlots.getString(""String_Node_Str"");
            int plotLikes=setPlots.getInt(""String_Node_Str"");
            com.worldcretornica.plotme_core.api.Vector topLoc=new com.worldcretornica.plotme_core.api.Vector(setPlots.getInt(""String_Node_Str""),255,setPlots.getInt(""String_Node_Str""));
            com.worldcretornica.plotme_core.api.Vector bottomLoc=new com.worldcretornica.plotme_core.api.Vector(setPlots.getInt(""String_Node_Str""),0,setPlots.getInt(""String_Node_Str""));
            HashMap<String,Map<String,String>> metadata=new HashMap<>();
            HashMap<String,Plot.AccessLevel> allowed=new HashMap<>();
            HashSet<String> denied=new HashSet<>();
            HashSet<UUID> likers=new HashSet<>();
            statementAllowed.setLong(1,internalID);
            try (ResultSet setAllowed=statementAllowed.executeQuery()){
              while (setAllowed.next()) {
                allowed.put(setAllowed.getString(""String_Node_Str""),Plot.AccessLevel.getAccessLevel(setAllowed.getInt(""String_Node_Str"")));
              }
            }
             statementDenied.setLong(1,internalID);
            try (ResultSet setDenied=statementDenied.executeQuery()){
              while (setDenied.next()) {
                denied.add(setDenied.getString(""String_Node_Str""));
              }
            }
             statementLikes.setLong(1,internalID);
            try (ResultSet setLikes=statementLikes.executeQuery()){
              while (setLikes.next()) {
                likers.add(UUID.fromString(setLikes.getString(""String_Node_Str"")));
              }
            }
             statementMetadata.setLong(1,internalID);
            try (ResultSet setMetadata=statementMetadata.executeQuery()){
              while (setMetadata.next()) {
                String pluginname=setMetadata.getString(""String_Node_Str"");
                String propertyname=setMetadata.getString(""String_Node_Str"");
                String propertyvalue=setMetadata.getString(""String_Node_Str"");
                if (!metadata.containsKey(pluginname)) {
                  metadata.put(pluginname,new HashMap<String,String>());
                }
                metadata.get(pluginname).put(propertyname,propertyvalue);
              }
            }
             Plot plot=new Plot(internalID,owner,ownerId,world,biome,expiredDate,allowed,denied,likers,id,price,forSale,finished,finishedDate,protect,metadata,plotLikes,plotName,topLoc,bottomLoc,createdDate);
            ret.put(plot.getId(),plot);
          }
        }
       }
 catch (      SQLException ex) {
        plugin.getLogger().severe(""String_Node_Str"");
        plugin.getLogger().severe(ex.getMessage());
      }
      return ret;
    }
  }
);
}"
41927,"@Override public boolean onCommand(CommandSender sender,Command command,String label,String[] args){
  if (sender instanceof Player) {
    if (args.length == 0) {
      return commandMap.get(""String_Node_Str"").execute(plugin.wrapPlayer((Player)sender),args);
    }
    if (args[0] == null || args == null) {
      api.getLogger().severe(""String_Node_Str"");
      return false;
    }
    PlotCommand _command=commandMap.get(args[0]);
    if (_command == null) {
      sender.sendMessage(""String_Node_Str"");
      return true;
    }
 else {
      return _command.execute(plugin.wrapPlayer((Player)sender),args);
    }
  }
 else {
    return handleConsoleCommands(sender,args);
  }
}","@Override public boolean onCommand(CommandSender sender,Command command,String label,String[] args){
  if (sender instanceof Player) {
    if (args.length == 0) {
      return commandMap.get(""String_Node_Str"").execute(plugin.wrapPlayer((Player)sender),args);
    }
    PlotCommand _command=commandMap.get(args[0].toLowerCase());
    if (_command == null) {
      sender.sendMessage(""String_Node_Str"");
      return true;
    }
 else {
      return _command.execute(plugin.wrapPlayer((Player)sender),args);
    }
  }
 else {
    return handleConsoleCommands(sender,args);
  }
}"
41928,"@Override public void run(){
  setOwnerSign(plot);
}","@Override public void run(){
  LWC lwc=LWC.getInstance();
  List<Protection> protections=lwc.getPhysicalDatabase().loadProtections(plot.getWorld().getName(),x1,x2,0,256,z1,z2);
  for (  Protection protection : protections) {
    protection.remove();
  }
}"
41929,"public void UpdatePlayerNameFromId(final UUID uuid,final String name){
  plugin.getServerBridge().runTaskAsynchronously(new Runnable(){
    @Override public void run(){
      for (      final Plot plot : plugin.getSqlManager().getPlayerPlots(uuid)) {
        plot.setOwner(name);
        plugin.getSqlManager().savePlot(plot);
        plugin.getServerBridge().runTask(new Runnable(){
          @Override public void run(){
            setOwnerSign(plot);
          }
        }
);
      }
    }
  }
);
}","public void UpdatePlayerNameFromId(final UUID uuid,final String name){
  for (  final Plot plot : plugin.getSqlManager().getPlayerPlots(uuid)) {
    setOwnerSign(plot);
  }
}"
41930,"public boolean execute(ICommandSender sender,String[] args){
  if (args.length > 1) {
    sender.sendMessage(getUsage());
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_INFO)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      player.sendMessage(""String_Node_Str"" + plot.getInternalID());
      player.sendMessage(""String_Node_Str"" + plot.getId().getID() + ""String_Node_Str""+ C(""String_Node_Str"",plot.getOwner())+ ""String_Node_Str""+ C(""String_Node_Str"",plot.getBiome()));
      player.sendMessage(""String_Node_Str"" + plot.getLikes());
      player.sendMessage(""String_Node_Str"" + plot.getCreatedDate());
      final String neverExpire=C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"");
      if (plot.getExpiredDate() == null) {
        if (plot.isFinished()) {
          if (plot.isProtected()) {
            player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
 else {
            player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
        }
 else {
          if (plot.isProtected()) {
            player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
 else {
            player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
        }
      }
 else       if (plot.isProtected()) {
        if (plot.isFinished()) {
          player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
 else {
          player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else       if (plot.isFinished()) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getExpiredDate()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getExpiredDate()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
      if (!plot.getMembers().isEmpty()) {
        StringBuilder builder=new StringBuilder(""String_Node_Str"");
        if (!plot.getMembers().containsKey(""String_Node_Str"")) {
          for (          Map.Entry<String,Plot.AccessLevel> member : plot.getMembers().entrySet()) {
            builder.append(plugin.getServerBridge().getOfflinePlayer(UUID.fromString(member.getKey())).getName()).append(""String_Node_Str"").append(member.getValue().toString()).append(""String_Node_Str"");
          }
        }
 else {
          builder.append(""String_Node_Str"");
        }
        player.sendMessage(builder.toString());
      }
      if (!plot.getDenied().isEmpty()) {
        StringBuilder builder=new StringBuilder(C(""String_Node_Str""));
        builder.append(""String_Node_Str"");
        if (!plot.getDenied().contains(""String_Node_Str"")) {
          for (          String s : plot.getDenied()) {
            builder.append(plugin.getServerBridge().getOfflinePlayer(UUID.fromString(s)).getName()).append(""String_Node_Str"");
          }
        }
 else {
          builder.append('*');
        }
        player.sendMessage(builder.toString());
      }
      if (manager.isEconomyEnabled(world)) {
        if (plot.isForSale()) {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getPrice());
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str""));
        }
      }
      player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getPlotBottomLoc().toString());
      player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getPlotTopLoc());
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args){
  if (args.length > 1) {
    sender.sendMessage(getUsage());
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_INFO)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      player.sendMessage(""String_Node_Str"" + plot.getInternalID());
      player.sendMessage(""String_Node_Str"" + plot.getId().getID() + ""String_Node_Str""+ C(""String_Node_Str"",serverBridge.getOfflinePlayer(plot.getOwnerId()).getName())+ ""String_Node_Str""+ C(""String_Node_Str"",plot.getBiome()));
      player.sendMessage(""String_Node_Str"" + plot.getLikes());
      player.sendMessage(""String_Node_Str"" + plot.getCreatedDate());
      final String neverExpire=C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"");
      if (plot.getExpiredDate() == null) {
        if (plot.isFinished()) {
          if (plot.isProtected()) {
            player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
 else {
            player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
        }
 else {
          if (plot.isProtected()) {
            player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
 else {
            player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
        }
      }
 else       if (plot.isProtected()) {
        if (plot.isFinished()) {
          player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
 else {
          player.sendMessage(neverExpire + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else       if (plot.isFinished()) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getExpiredDate()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getExpiredDate()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
      if (!plot.getMembers().isEmpty()) {
        StringBuilder builder=new StringBuilder(""String_Node_Str"");
        if (!plot.getMembers().containsKey(""String_Node_Str"")) {
          for (          Map.Entry<String,Plot.AccessLevel> member : plot.getMembers().entrySet()) {
            builder.append(plugin.getServerBridge().getOfflinePlayer(UUID.fromString(member.getKey())).getName()).append(""String_Node_Str"").append(member.getValue().toString()).append(""String_Node_Str"");
          }
        }
 else {
          builder.append(""String_Node_Str"");
        }
        player.sendMessage(builder.toString());
      }
      if (!plot.getDenied().isEmpty()) {
        StringBuilder builder=new StringBuilder(C(""String_Node_Str""));
        builder.append(""String_Node_Str"");
        if (!plot.getDenied().contains(""String_Node_Str"")) {
          for (          String s : plot.getDenied()) {
            builder.append(plugin.getServerBridge().getOfflinePlayer(UUID.fromString(s)).getName()).append(""String_Node_Str"");
          }
        }
 else {
          builder.append('*');
        }
        player.sendMessage(builder.toString());
      }
      if (manager.isEconomyEnabled(world)) {
        if (plot.isForSale()) {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getPrice());
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str""));
        }
      }
      player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getPlotBottomLoc().toString());
      player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getPlotTopLoc().toString());
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41931,"private HashMap<PlotId,Plot> getPlots(IWorld world){
  HashMap<PlotId,Plot> ret=new HashMap<>();
  Connection connection=getConnection();
  try (PreparedStatement statementPlot=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementAllowed=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementDenied=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementLikes=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementMetadata=connection.prepareStatement(""String_Node_Str"")){
    statementPlot.setString(1,world.getName().toLowerCase());
    try (ResultSet setPlots=statementPlot.executeQuery()){
      while (setPlots.next()) {
        long internalID=setPlots.getLong(""String_Node_Str"");
        PlotId id=new PlotId(setPlots.getInt(""String_Node_Str""),setPlots.getInt(""String_Node_Str""));
        String owner=setPlots.getString(""String_Node_Str"");
        UUID ownerId=UUID.fromString(setPlots.getString(""String_Node_Str""));
        String biome=setPlots.getString(""String_Node_Str"");
        Date expiredDate=setPlots.getDate(""String_Node_Str"");
        boolean finished=setPlots.getBoolean(""String_Node_Str"");
        String finishedDate=setPlots.getString(""String_Node_Str"");
        String createdDate=setPlots.getString(""String_Node_Str"");
        double price=setPlots.getDouble(""String_Node_Str"");
        boolean forSale=setPlots.getBoolean(""String_Node_Str"");
        boolean protect=setPlots.getBoolean(""String_Node_Str"");
        String plotName=setPlots.getString(""String_Node_Str"");
        int plotLikes=setPlots.getInt(""String_Node_Str"");
        com.worldcretornica.plotme_core.api.Vector topLoc=new com.worldcretornica.plotme_core.api.Vector(setPlots.getInt(""String_Node_Str""),255,setPlots.getInt(""String_Node_Str""));
        com.worldcretornica.plotme_core.api.Vector bottomLoc=new com.worldcretornica.plotme_core.api.Vector(setPlots.getInt(""String_Node_Str""),0,setPlots.getInt(""String_Node_Str""));
        HashMap<String,Map<String,String>> metadata=new HashMap<>();
        HashMap<String,Plot.AccessLevel> allowed=new HashMap<>();
        HashSet<String> denied=new HashSet<>();
        HashSet<UUID> likers=new HashSet<>();
        statementAllowed.setLong(1,internalID);
        try (ResultSet setAllowed=statementAllowed.executeQuery()){
          while (setAllowed.next()) {
            allowed.put(setAllowed.getString(""String_Node_Str""),Plot.AccessLevel.getAccessLevel(setAllowed.getInt(""String_Node_Str"")));
          }
        }
         statementDenied.setLong(1,internalID);
        try (ResultSet setDenied=statementDenied.executeQuery()){
          while (setDenied.next()) {
            denied.add(setDenied.getString(""String_Node_Str""));
          }
        }
         statementLikes.setLong(1,internalID);
        try (ResultSet setLikes=statementLikes.executeQuery()){
          while (setLikes.next()) {
            likers.add(UUID.fromString(setLikes.getString(""String_Node_Str"")));
          }
        }
         statementMetadata.setLong(1,internalID);
        try (ResultSet setMetadata=statementMetadata.executeQuery()){
          while (setMetadata.next()) {
            String pluginname=setMetadata.getString(""String_Node_Str"");
            String propertyname=setMetadata.getString(""String_Node_Str"");
            String propertyvalue=setMetadata.getString(""String_Node_Str"");
            if (!metadata.containsKey(pluginname)) {
              metadata.put(pluginname,new HashMap<String,String>());
            }
            metadata.get(pluginname).put(propertyname,propertyvalue);
          }
        }
         Plot plot=new Plot(internalID,owner,ownerId,world,biome,expiredDate,allowed,denied,likers,id,price,forSale,finished,finishedDate,protect,metadata,plotLikes,plotName,topLoc,bottomLoc,createdDate);
        ret.put(plot.getId(),plot);
      }
    }
   }
 catch (  SQLException ex) {
    plugin.getLogger().severe(""String_Node_Str"");
    plugin.getLogger().severe(ex.getMessage());
    plugin.getLogger().severe(""String_Node_Str"" + ex.getMessage());
    plugin.getLogger().severe(""String_Node_Str"" + ex.getErrorCode());
    plugin.getLogger().severe(""String_Node_Str"" + ex.getSQLState());
  }
  return ret;
}","private HashMap<PlotId,Plot> getPlots(IWorld world){
  HashMap<PlotId,Plot> ret=new HashMap<>();
  Connection connection=getConnection();
  try (PreparedStatement statementPlot=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementAllowed=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementDenied=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementLikes=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementMetadata=connection.prepareStatement(""String_Node_Str"")){
    statementPlot.setString(1,world.getName().toLowerCase());
    try (ResultSet setPlots=statementPlot.executeQuery()){
      while (setPlots.next()) {
        long internalID=setPlots.getLong(""String_Node_Str"");
        PlotId id=new PlotId(setPlots.getInt(""String_Node_Str""),setPlots.getInt(""String_Node_Str""));
        String owner=setPlots.getString(""String_Node_Str"");
        UUID ownerId=UUID.fromString(setPlots.getString(""String_Node_Str""));
        String biome=setPlots.getString(""String_Node_Str"");
        Date expiredDate=setPlots.getDate(""String_Node_Str"");
        boolean finished=setPlots.getBoolean(""String_Node_Str"");
        String finishedDate=setPlots.getString(""String_Node_Str"");
        String createdDate=setPlots.getString(""String_Node_Str"");
        double price=setPlots.getDouble(""String_Node_Str"");
        boolean forSale=setPlots.getBoolean(""String_Node_Str"");
        boolean protect=setPlots.getBoolean(""String_Node_Str"");
        String plotName=setPlots.getString(""String_Node_Str"");
        int plotLikes=setPlots.getInt(""String_Node_Str"");
        com.worldcretornica.plotme_core.api.Vector topLoc=PlotMeCoreManager.getInstance().getPlotTopLoc(world,id);
        com.worldcretornica.plotme_core.api.Vector bottomLoc=PlotMeCoreManager.getInstance().getPlotBottomLoc(world,id);
        HashMap<String,Map<String,String>> metadata=new HashMap<>();
        HashMap<String,Plot.AccessLevel> allowed=new HashMap<>();
        HashSet<String> denied=new HashSet<>();
        HashSet<UUID> likers=new HashSet<>();
        statementAllowed.setLong(1,internalID);
        try (ResultSet setAllowed=statementAllowed.executeQuery()){
          while (setAllowed.next()) {
            allowed.put(setAllowed.getString(""String_Node_Str""),Plot.AccessLevel.getAccessLevel(setAllowed.getInt(""String_Node_Str"")));
          }
        }
         statementDenied.setLong(1,internalID);
        try (ResultSet setDenied=statementDenied.executeQuery()){
          while (setDenied.next()) {
            denied.add(setDenied.getString(""String_Node_Str""));
          }
        }
         statementLikes.setLong(1,internalID);
        try (ResultSet setLikes=statementLikes.executeQuery()){
          while (setLikes.next()) {
            likers.add(UUID.fromString(setLikes.getString(""String_Node_Str"")));
          }
        }
         statementMetadata.setLong(1,internalID);
        try (ResultSet setMetadata=statementMetadata.executeQuery()){
          while (setMetadata.next()) {
            String pluginname=setMetadata.getString(""String_Node_Str"");
            String propertyname=setMetadata.getString(""String_Node_Str"");
            String propertyvalue=setMetadata.getString(""String_Node_Str"");
            if (!metadata.containsKey(pluginname)) {
              metadata.put(pluginname,new HashMap<String,String>());
            }
            metadata.get(pluginname).put(propertyname,propertyvalue);
          }
        }
         Plot plot=new Plot(internalID,owner,ownerId,world,biome,expiredDate,allowed,denied,likers,id,price,forSale,finished,finishedDate,protect,metadata,plotLikes,plotName,topLoc,bottomLoc,createdDate);
        ret.put(plot.getId(),plot);
      }
    }
   }
 catch (  SQLException ex) {
    plugin.getLogger().severe(""String_Node_Str"");
    plugin.getLogger().severe(ex.getMessage());
    plugin.getLogger().severe(""String_Node_Str"" + ex.getMessage());
    plugin.getLogger().severe(""String_Node_Str"" + ex.getErrorCode());
    plugin.getLogger().severe(""String_Node_Str"" + ex.getSQLState());
  }
  return ret;
}"
41932,"private void writePlotToStorage(final Plot plot){
  deletePlotFromStorage(plot);
  plugin.getServerBridge().runTaskAsynchronously(new Runnable(){
    @Override public void run(){
      try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"")){
        ps.setLong(1,plot.getInternalID());
        ps.setInt(2,plot.getId().getX());
        ps.setInt(3,plot.getId().getZ());
        ps.setString(4,plot.getWorld().getName().toLowerCase());
        ps.setString(5,plot.getOwnerId().toString());
        ps.setString(6,plot.getOwner());
        ps.setString(7,plot.getBiome());
        ps.setBoolean(8,plot.isFinished());
        ps.setString(9,plot.getFinishedDate());
        ps.setBoolean(10,plot.isForSale());
        ps.setDouble(11,plot.getPrice());
        ps.setBoolean(12,plot.isProtected());
        ps.setDate(13,plot.getExpiredDate());
        ps.setInt(14,plot.getTopX());
        ps.setInt(15,plot.getTopZ());
        ps.setInt(16,plot.getBottomX());
        ps.setInt(17,plot.getBottomZ());
        ps.setInt(18,plot.getLikes());
        ps.setString(19,plot.getCreatedDate());
        ps.executeUpdate();
        getConnection().commit();
      }
 catch (      SQLException e) {
        plugin.getLogger().severe(""String_Node_Str"");
        plugin.getLogger().severe(e.getMessage());
        plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
        plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
        plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
      }
      for (      String denied : plot.getDenied()) {
        try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"")){
          ps.setLong(1,plot.getInternalID());
          ps.setString(2,denied);
          ps.execute();
          getConnection().commit();
        }
 catch (        SQLException e) {
          plugin.getLogger().severe(""String_Node_Str"" + plot.getInternalID());
          plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
          plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
          plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
          e.printStackTrace();
        }
      }
      for (      Map.Entry<String,Plot.AccessLevel> member : plot.getMembers().entrySet()) {
        try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"")){
          ps.setLong(1,plot.getInternalID());
          ps.setString(2,member.getKey());
          ps.setInt(3,member.getValue().getLevel());
          ps.execute();
          getConnection().commit();
        }
 catch (        SQLException e) {
          plugin.getLogger().severe(""String_Node_Str"" + plot.getInternalID());
          plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
          plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
          plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
          e.printStackTrace();
        }
      }
      for (      UUID player : plot.getLikers()) {
        try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"")){
          ps.setLong(1,plot.getInternalID());
          ps.setString(2,player.toString());
          ps.execute();
          getConnection().commit();
        }
 catch (        SQLException e) {
          plugin.getLogger().severe(""String_Node_Str"" + plot.getInternalID());
          plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
          plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
          plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
          e.printStackTrace();
        }
      }
      for (      Map.Entry<String,Map<String,String>> metadata : plot.getAllPlotProperties().entrySet()) {
        for (        Map.Entry<String,String> stringStringEntry : metadata.getValue().entrySet()) {
          try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"" + ""String_Node_Str"")){
            ps.setLong(1,plot.getInternalID());
            ps.setString(2,metadata.getKey());
            ps.setString(3,stringStringEntry.getKey());
            ps.setString(4,stringStringEntry.getValue());
          }
 catch (          SQLException e) {
            plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
            plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
            plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
            e.printStackTrace();
          }
        }
      }
    }
  }
);
}","private void writePlotToStorage(final Plot plot){
  deletePlotFromStorage(plot);
  try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"")){
    ps.setLong(1,plot.getInternalID());
    ps.setInt(2,plot.getId().getX());
    ps.setInt(3,plot.getId().getZ());
    ps.setString(4,plot.getWorld().getName().toLowerCase());
    ps.setString(5,plot.getOwnerId().toString());
    ps.setString(6,plot.getOwner());
    ps.setString(7,plot.getBiome());
    ps.setBoolean(8,plot.isFinished());
    ps.setString(9,plot.getFinishedDate());
    ps.setBoolean(10,plot.isForSale());
    ps.setDouble(11,plot.getPrice());
    ps.setBoolean(12,plot.isProtected());
    ps.setDate(13,plot.getExpiredDate());
    ps.setInt(14,plot.getTopX());
    ps.setInt(15,plot.getTopZ());
    ps.setInt(16,plot.getBottomX());
    ps.setInt(17,plot.getBottomZ());
    ps.setInt(18,plot.getLikes());
    ps.setString(19,plot.getCreatedDate());
    ps.executeUpdate();
    getConnection().commit();
  }
 catch (  SQLException e) {
    plugin.getLogger().severe(""String_Node_Str"");
    plugin.getLogger().severe(e.getMessage());
    plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
    plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
    plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
  }
  for (  String denied : plot.getDenied()) {
    try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"")){
      ps.setLong(1,plot.getInternalID());
      ps.setString(2,denied);
      ps.execute();
      getConnection().commit();
    }
 catch (    SQLException e) {
      plugin.getLogger().severe(""String_Node_Str"" + plot.getInternalID());
      plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
      plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
      plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
      e.printStackTrace();
    }
  }
  for (  Map.Entry<String,Plot.AccessLevel> member : plot.getMembers().entrySet()) {
    try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"")){
      ps.setLong(1,plot.getInternalID());
      ps.setString(2,member.getKey());
      ps.setInt(3,member.getValue().getLevel());
      ps.execute();
      getConnection().commit();
    }
 catch (    SQLException e) {
      plugin.getLogger().severe(""String_Node_Str"" + plot.getInternalID());
      plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
      plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
      plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
      e.printStackTrace();
    }
  }
  for (  UUID player : plot.getLikers()) {
    try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"")){
      ps.setLong(1,plot.getInternalID());
      ps.setString(2,player.toString());
      ps.execute();
      getConnection().commit();
    }
 catch (    SQLException e) {
      plugin.getLogger().severe(""String_Node_Str"" + plot.getInternalID());
      plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
      plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
      plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
      e.printStackTrace();
    }
  }
  for (  Map.Entry<String,Map<String,String>> metadata : plot.getAllPlotProperties().entrySet()) {
    for (    Map.Entry<String,String> stringStringEntry : metadata.getValue().entrySet()) {
      try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"" + ""String_Node_Str"")){
        ps.setLong(1,plot.getInternalID());
        ps.setString(2,metadata.getKey());
        ps.setString(3,stringStringEntry.getKey());
        ps.setString(4,stringStringEntry.getValue());
      }
 catch (      SQLException e) {
        plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
        plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
        plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
        e.printStackTrace();
      }
    }
  }
}"
41933,"@Override public void run(){
  try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"")){
    ps.setLong(1,plot.getInternalID());
    ps.setInt(2,plot.getId().getX());
    ps.setInt(3,plot.getId().getZ());
    ps.setString(4,plot.getWorld().getName().toLowerCase());
    ps.setString(5,plot.getOwnerId().toString());
    ps.setString(6,plot.getOwner());
    ps.setString(7,plot.getBiome());
    ps.setBoolean(8,plot.isFinished());
    ps.setString(9,plot.getFinishedDate());
    ps.setBoolean(10,plot.isForSale());
    ps.setDouble(11,plot.getPrice());
    ps.setBoolean(12,plot.isProtected());
    ps.setDate(13,plot.getExpiredDate());
    ps.setInt(14,plot.getTopX());
    ps.setInt(15,plot.getTopZ());
    ps.setInt(16,plot.getBottomX());
    ps.setInt(17,plot.getBottomZ());
    ps.setInt(18,plot.getLikes());
    ps.setString(19,plot.getCreatedDate());
    ps.executeUpdate();
    getConnection().commit();
  }
 catch (  SQLException e) {
    plugin.getLogger().severe(""String_Node_Str"");
    plugin.getLogger().severe(e.getMessage());
    plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
    plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
    plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
  }
  for (  String denied : plot.getDenied()) {
    try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"")){
      ps.setLong(1,plot.getInternalID());
      ps.setString(2,denied);
      ps.execute();
      getConnection().commit();
    }
 catch (    SQLException e) {
      plugin.getLogger().severe(""String_Node_Str"" + plot.getInternalID());
      plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
      plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
      plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
      e.printStackTrace();
    }
  }
  for (  Map.Entry<String,Plot.AccessLevel> member : plot.getMembers().entrySet()) {
    try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"")){
      ps.setLong(1,plot.getInternalID());
      ps.setString(2,member.getKey());
      ps.setInt(3,member.getValue().getLevel());
      ps.execute();
      getConnection().commit();
    }
 catch (    SQLException e) {
      plugin.getLogger().severe(""String_Node_Str"" + plot.getInternalID());
      plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
      plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
      plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
      e.printStackTrace();
    }
  }
  for (  UUID player : plot.getLikers()) {
    try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"")){
      ps.setLong(1,plot.getInternalID());
      ps.setString(2,player.toString());
      ps.execute();
      getConnection().commit();
    }
 catch (    SQLException e) {
      plugin.getLogger().severe(""String_Node_Str"" + plot.getInternalID());
      plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
      plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
      plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
      e.printStackTrace();
    }
  }
  for (  Map.Entry<String,Map<String,String>> metadata : plot.getAllPlotProperties().entrySet()) {
    for (    Map.Entry<String,String> stringStringEntry : metadata.getValue().entrySet()) {
      try (PreparedStatement ps=getConnection().prepareStatement(""String_Node_Str"" + ""String_Node_Str"")){
        ps.setLong(1,plot.getInternalID());
        ps.setString(2,metadata.getKey());
        ps.setString(3,stringStringEntry.getKey());
        ps.setString(4,stringStringEntry.getValue());
      }
 catch (      SQLException e) {
        plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
        plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
        plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
        e.printStackTrace();
      }
    }
  }
}","@Override public void run(){
  plugin.getLogger().info(""String_Node_Str"" + world.getName());
  HashMap<PlotId,Plot> plots2=getPlots(world);
  plots.put(world,plots2);
  PlotWorldLoadEvent eventWorld=new PlotWorldLoadEvent(world,plots2.size());
  plugin.getEventBus().post(eventWorld);
  for (  Plot plot : plots2.values()) {
    PlotLoadEvent event=new PlotLoadEvent(plot);
    plugin.getEventBus().post(event);
  }
}"
41934,"public void loadPlotsAsynchronously(final IWorld world){
  plugin.getServerBridge().runTaskAsynchronously(new Runnable(){
    @Override public void run(){
      plugin.getLogger().info(""String_Node_Str"" + world.getName());
      HashMap<PlotId,Plot> plots2=getPlots(world);
      plots.put(world,plots2);
      PlotWorldLoadEvent eventWorld=new PlotWorldLoadEvent(world,plots2.size());
      plugin.getEventBus().post(eventWorld);
      for (      Plot plot : plots2.values()) {
        PlotLoadEvent event=new PlotLoadEvent(plot);
        plugin.getEventBus().post(event);
      }
    }
    private HashMap<PlotId,Plot> getPlots(    IWorld world){
      HashMap<PlotId,Plot> ret=new HashMap<>();
      Connection connection=getConnection();
      try (PreparedStatement statementPlot=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementAllowed=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementDenied=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementLikes=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementMetadata=connection.prepareStatement(""String_Node_Str"")){
        statementPlot.setString(1,world.getName().toLowerCase());
        try (ResultSet setPlots=statementPlot.executeQuery()){
          while (setPlots.next()) {
            long internalID=setPlots.getLong(""String_Node_Str"");
            PlotId id=new PlotId(setPlots.getInt(""String_Node_Str""),setPlots.getInt(""String_Node_Str""));
            String owner=setPlots.getString(""String_Node_Str"");
            UUID ownerId=UUID.fromString(setPlots.getString(""String_Node_Str""));
            String biome=setPlots.getString(""String_Node_Str"");
            Date expiredDate=setPlots.getDate(""String_Node_Str"");
            boolean finished=setPlots.getBoolean(""String_Node_Str"");
            String finishedDate=setPlots.getString(""String_Node_Str"");
            String createdDate=setPlots.getString(""String_Node_Str"");
            double price=setPlots.getDouble(""String_Node_Str"");
            boolean forSale=setPlots.getBoolean(""String_Node_Str"");
            boolean protect=setPlots.getBoolean(""String_Node_Str"");
            String plotName=setPlots.getString(""String_Node_Str"");
            int plotLikes=setPlots.getInt(""String_Node_Str"");
            com.worldcretornica.plotme_core.api.Vector topLoc=new com.worldcretornica.plotme_core.api.Vector(setPlots.getInt(""String_Node_Str""),255,setPlots.getInt(""String_Node_Str""));
            com.worldcretornica.plotme_core.api.Vector bottomLoc=new com.worldcretornica.plotme_core.api.Vector(setPlots.getInt(""String_Node_Str""),0,setPlots.getInt(""String_Node_Str""));
            HashMap<String,Map<String,String>> metadata=new HashMap<>();
            HashMap<String,Plot.AccessLevel> allowed=new HashMap<>();
            HashSet<String> denied=new HashSet<>();
            HashSet<UUID> likers=new HashSet<>();
            statementAllowed.setLong(1,internalID);
            try (ResultSet setAllowed=statementAllowed.executeQuery()){
              while (setAllowed.next()) {
                allowed.put(setAllowed.getString(""String_Node_Str""),Plot.AccessLevel.getAccessLevel(setAllowed.getInt(""String_Node_Str"")));
              }
            }
             statementDenied.setLong(1,internalID);
            try (ResultSet setDenied=statementDenied.executeQuery()){
              while (setDenied.next()) {
                denied.add(setDenied.getString(""String_Node_Str""));
              }
            }
             statementLikes.setLong(1,internalID);
            try (ResultSet setLikes=statementLikes.executeQuery()){
              while (setLikes.next()) {
                likers.add(UUID.fromString(setLikes.getString(""String_Node_Str"")));
              }
            }
             statementMetadata.setLong(1,internalID);
            try (ResultSet setMetadata=statementMetadata.executeQuery()){
              while (setMetadata.next()) {
                String pluginname=setMetadata.getString(""String_Node_Str"");
                String propertyname=setMetadata.getString(""String_Node_Str"");
                String propertyvalue=setMetadata.getString(""String_Node_Str"");
                if (!metadata.containsKey(pluginname)) {
                  metadata.put(pluginname,new HashMap<String,String>());
                }
                metadata.get(pluginname).put(propertyname,propertyvalue);
              }
            }
             Plot plot=new Plot(internalID,owner,ownerId,world,biome,expiredDate,allowed,denied,likers,id,price,forSale,finished,finishedDate,protect,metadata,plotLikes,plotName,topLoc,bottomLoc,createdDate);
            ret.put(plot.getId(),plot);
          }
        }
       }
 catch (      SQLException ex) {
        plugin.getLogger().severe(""String_Node_Str"");
        plugin.getLogger().severe(ex.getMessage());
        plugin.getLogger().severe(""String_Node_Str"" + ex.getMessage());
        plugin.getLogger().severe(""String_Node_Str"" + ex.getErrorCode());
        plugin.getLogger().severe(""String_Node_Str"" + ex.getSQLState());
      }
      return ret;
    }
  }
);
}","public void loadPlotsAsynchronously(final IWorld world){
  plugin.getServerBridge().runTaskAsynchronously(new Runnable(){
    @Override public void run(){
      plugin.getLogger().info(""String_Node_Str"" + world.getName());
      HashMap<PlotId,Plot> plots2=getPlots(world);
      plots.put(world,plots2);
      PlotWorldLoadEvent eventWorld=new PlotWorldLoadEvent(world,plots2.size());
      plugin.getEventBus().post(eventWorld);
      for (      Plot plot : plots2.values()) {
        PlotLoadEvent event=new PlotLoadEvent(plot);
        plugin.getEventBus().post(event);
      }
    }
    private HashMap<PlotId,Plot> getPlots(    IWorld world){
      HashMap<PlotId,Plot> ret=new HashMap<>();
      Connection connection=getConnection();
      try (PreparedStatement statementPlot=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementAllowed=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementDenied=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementLikes=connection.prepareStatement(""String_Node_Str"");PreparedStatement statementMetadata=connection.prepareStatement(""String_Node_Str"")){
        statementPlot.setString(1,world.getName().toLowerCase());
        try (ResultSet setPlots=statementPlot.executeQuery()){
          while (setPlots.next()) {
            long internalID=setPlots.getLong(""String_Node_Str"");
            PlotId id=new PlotId(setPlots.getInt(""String_Node_Str""),setPlots.getInt(""String_Node_Str""));
            String owner=setPlots.getString(""String_Node_Str"");
            UUID ownerId=UUID.fromString(setPlots.getString(""String_Node_Str""));
            String biome=setPlots.getString(""String_Node_Str"");
            Date expiredDate=setPlots.getDate(""String_Node_Str"");
            boolean finished=setPlots.getBoolean(""String_Node_Str"");
            String finishedDate=setPlots.getString(""String_Node_Str"");
            String createdDate=setPlots.getString(""String_Node_Str"");
            double price=setPlots.getDouble(""String_Node_Str"");
            boolean forSale=setPlots.getBoolean(""String_Node_Str"");
            boolean protect=setPlots.getBoolean(""String_Node_Str"");
            String plotName=setPlots.getString(""String_Node_Str"");
            int plotLikes=setPlots.getInt(""String_Node_Str"");
            com.worldcretornica.plotme_core.api.Vector topLoc=PlotMeCoreManager.getInstance().getPlotTopLoc(world,id);
            com.worldcretornica.plotme_core.api.Vector bottomLoc=PlotMeCoreManager.getInstance().getPlotBottomLoc(world,id);
            HashMap<String,Map<String,String>> metadata=new HashMap<>();
            HashMap<String,Plot.AccessLevel> allowed=new HashMap<>();
            HashSet<String> denied=new HashSet<>();
            HashSet<UUID> likers=new HashSet<>();
            statementAllowed.setLong(1,internalID);
            try (ResultSet setAllowed=statementAllowed.executeQuery()){
              while (setAllowed.next()) {
                allowed.put(setAllowed.getString(""String_Node_Str""),Plot.AccessLevel.getAccessLevel(setAllowed.getInt(""String_Node_Str"")));
              }
            }
             statementDenied.setLong(1,internalID);
            try (ResultSet setDenied=statementDenied.executeQuery()){
              while (setDenied.next()) {
                denied.add(setDenied.getString(""String_Node_Str""));
              }
            }
             statementLikes.setLong(1,internalID);
            try (ResultSet setLikes=statementLikes.executeQuery()){
              while (setLikes.next()) {
                likers.add(UUID.fromString(setLikes.getString(""String_Node_Str"")));
              }
            }
             statementMetadata.setLong(1,internalID);
            try (ResultSet setMetadata=statementMetadata.executeQuery()){
              while (setMetadata.next()) {
                String pluginname=setMetadata.getString(""String_Node_Str"");
                String propertyname=setMetadata.getString(""String_Node_Str"");
                String propertyvalue=setMetadata.getString(""String_Node_Str"");
                if (!metadata.containsKey(pluginname)) {
                  metadata.put(pluginname,new HashMap<String,String>());
                }
                metadata.get(pluginname).put(propertyname,propertyvalue);
              }
            }
             Plot plot=new Plot(internalID,owner,ownerId,world,biome,expiredDate,allowed,denied,likers,id,price,forSale,finished,finishedDate,protect,metadata,plotLikes,plotName,topLoc,bottomLoc,createdDate);
            ret.put(plot.getId(),plot);
          }
        }
       }
 catch (      SQLException ex) {
        plugin.getLogger().severe(""String_Node_Str"");
        plugin.getLogger().severe(ex.getMessage());
        plugin.getLogger().severe(""String_Node_Str"" + ex.getMessage());
        plugin.getLogger().severe(""String_Node_Str"" + ex.getErrorCode());
        plugin.getLogger().severe(""String_Node_Str"" + ex.getSQLState());
      }
      return ret;
    }
  }
);
}"
41935,"public void setNextPlotId(final long id){
  this.nextPlotId=id;
  plugin.getServerBridge().runTaskAsynchronously(new Runnable(){
    @Override public void run(){
      try (Statement statement=getConnection().createStatement()){
        statement.execute(""String_Node_Str"");
        statement.execute(""String_Node_Str"" + id + ""String_Node_Str"");
      }
 catch (      SQLException e) {
        plugin.getLogger().severe(""String_Node_Str"");
        plugin.getLogger().severe(e.getMessage());
      }
    }
  }
);
}","public void setNextPlotId(final long id){
  this.nextPlotId=id;
  try (Statement statement=getConnection().createStatement()){
    statement.execute(""String_Node_Str"");
    statement.execute(""String_Node_Str"" + id + ""String_Node_Str"");
  }
 catch (  SQLException e) {
    plugin.getLogger().severe(""String_Node_Str"");
    plugin.getLogger().severe(e.getMessage());
  }
}"
41936,"public void deleteAllFrom(final long internalID,final String table){
  plugin.getServerBridge().runTaskAsynchronously(new Runnable(){
    @Override public void run(){
      try (Statement statement=getConnection().createStatement()){
        statement.execute(""String_Node_Str"" + table + ""String_Node_Str""+ internalID);
        getConnection().commit();
      }
 catch (      SQLException e) {
        plugin.getLogger().severe(""String_Node_Str"" + internalID + ""String_Node_Str""+ table);
        plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
        plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
        plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
      }
    }
  }
);
}","public void deleteAllFrom(final long internalID,final String table){
  try (Statement statement=getConnection().createStatement()){
    statement.execute(""String_Node_Str"" + table + ""String_Node_Str""+ internalID);
    getConnection().commit();
  }
 catch (  SQLException e) {
    plugin.getLogger().severe(""String_Node_Str"" + internalID + ""String_Node_Str""+ table);
    plugin.getLogger().severe(""String_Node_Str"" + e.getMessage());
    plugin.getLogger().severe(""String_Node_Str"" + e.getErrorCode());
    plugin.getLogger().severe(""String_Node_Str"" + e.getSQLState());
  }
}"
41937,"/** 
 * Get the plot home location of a plot
 * @param id    plot id to get home of
 * @param world
 * @return an ILocation of the plot home location
 */
public Location getPlotHome(PlotId id,IWorld world){
  return getGenManager(world).getPlotHome(id);
}","/** 
 * Get the plot home location of a plot
 * @param id    plot id to get home of
 * @param world
 * @return an ILocation of the plot home location
 */
public Location getPlotHome(PlotId id,IWorld world){
  Location plotHome=getGenManager(world).getPlotHome(id);
  plugin.getLogger().info(plotHome.toString());
  return plotHome;
}"
41938,"@Override public String toString(){
  return ""String_Node_Str"" + y + ""String_Node_Str""+ y+ ""String_Node_Str""+ z;
}","@Override public String toString(){
  return ""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ z;
}"
41939,"@Override public boolean onCommand(CommandSender sender,Command command,String label,String[] args){
  if (sender instanceof Player) {
    if (args.length == 0) {
      return commandMap.get(""String_Node_Str"").execute(plugin.wrapPlayer((Player)sender),args);
    }
    if (args[0] == null) {
      api.getLogger().severe(""String_Node_Str"");
      return false;
    }
    PlotCommand _command=commandMap.get(args[0]);
    if (_command == null) {
      sender.sendMessage(""String_Node_Str"");
      return true;
    }
 else {
      return _command.execute(new BukkitPlayer((Player)sender),args);
    }
  }
 else {
    return handleConsoleCommands(sender,args);
  }
}","@Override public boolean onCommand(CommandSender sender,Command command,String label,String[] args){
  if (sender instanceof Player) {
    if (args.length == 0) {
      return commandMap.get(""String_Node_Str"").execute(plugin.wrapPlayer((Player)sender),args);
    }
    if (args[0] == null || args == null) {
      api.getLogger().severe(""String_Node_Str"");
      return false;
    }
    PlotCommand _command=commandMap.get(args[0]);
    if (_command == null) {
      sender.sendMessage(""String_Node_Str"");
      return true;
    }
 else {
      return _command.execute(new BukkitPlayer((Player)sender),args);
    }
  }
 else {
    return handleConsoleCommands(sender,args);
  }
}"
41940,"public boolean execute(ICommandSender sender,String[] args){
  if (args.length < 2 && args.length >= 3) {
    sender.sendMessage(getUsage());
    return true;
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(C(""String_Node_Str""));
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_ADD) || player.hasPermission(PermissionNames.USER_ADD)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(player)) {
      PlotMapInfo pmi=manager.getMap(world);
      Plot plot=manager.getPlot(player);
      if (plot != null) {
        String allowed;
        if (""String_Node_Str"".equals(args[1])) {
          allowed=""String_Node_Str"";
        }
 else {
          if (serverBridge.getPlayer(args[1]) != null) {
            allowed=serverBridge.getPlayer(args[1]).getUniqueId().toString();
          }
 else {
            player.sendMessage(String.format(""String_Node_Str"",args[1]));
            return true;
          }
        }
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_ADD)) {
          if (plot.isMember(allowed).isPresent()) {
            player.sendMessage(C(""String_Node_Str"",args[1]));
          }
 else {
            PlotAddTrustedEvent event=new PlotAddTrustedEvent(plot,player,allowed);
            plugin.getEventBus().post(event);
            double price=0.0;
            if (manager.isEconomyEnabled(pmi)) {
              price=pmi.getAddPlayerPrice();
              if (serverBridge.has(player,pmi.getAddPlayerPrice())) {
                player.sendMessage(""String_Node_Str"" + serverBridge.getEconomy().get().format(price) + ""String_Node_Str""+ ""String_Node_Str"");
                return true;
              }
 else               if (!event.isCancelled()) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
            }
            if (!event.isCancelled()) {
              plot.addMember(allowed,Plot.AccessLevel.ALLOWED);
              plot.removeDenied(allowed);
              plugin.getSqlManager().savePlot(plot);
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + allowed+ ""String_Node_Str""+ C(""String_Node_Str""));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId());
                }
 else {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args){
  if (args.length < 2 && args.length >= 3) {
    sender.sendMessage(getUsage());
    return true;
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(C(""String_Node_Str""));
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_ADD) || player.hasPermission(PermissionNames.USER_ADD)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(player)) {
      PlotMapInfo pmi=manager.getMap(world);
      Plot plot=manager.getPlot(player);
      if (plot != null) {
        String allowed;
        if (""String_Node_Str"".equals(args[1])) {
          allowed=""String_Node_Str"";
        }
 else {
          if (serverBridge.getPlayer(args[1]) != null) {
            allowed=serverBridge.getPlayer(args[1]).getUniqueId().toString();
          }
 else {
            player.sendMessage(String.format(""String_Node_Str"",args[1]));
            return true;
          }
        }
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_ADD)) {
          if (plot.isMember(allowed).isPresent()) {
            player.sendMessage(C(""String_Node_Str"",args[1]));
          }
 else {
            PlotAddTrustedEvent event=new PlotAddTrustedEvent(plot,player,allowed);
            plugin.getEventBus().post(event);
            double price=0.0;
            if (manager.isEconomyEnabled(pmi)) {
              price=pmi.getAddPlayerPrice();
              if (serverBridge.has(player,pmi.getAddPlayerPrice())) {
                player.sendMessage(""String_Node_Str"" + serverBridge.getEconomy().get().format(price) + ""String_Node_Str""+ ""String_Node_Str"");
                return true;
              }
 else               if (!event.isCancelled()) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
            }
            if (!event.isCancelled()) {
              plot.addMember(allowed,Plot.AccessLevel.ALLOWED);
              plot.removeDenied(allowed);
              plugin.getSqlManager().savePlot(plot);
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId());
                }
 else {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
  }
 else {
    return false;
  }
  return true;
}"
41941,"public boolean execute(ICommandSender sender,String[] args){
  IPlayer player=(IPlayer)sender;
  if (manager.isPlotWorld(player)) {
    if (player.hasPermission(PermissionNames.USER_BIOME)) {
      int page=1;
      List<List<String>> partition=Lists.partition(serverBridge.getBiomes(),10);
      if (args.length == 2) {
        page=Integer.parseInt(args[1]);
      }
      player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + page+ ""String_Node_Str""+ partition.size()+ ""String_Node_Str"");
      for (      String s : partition.get(page)) {
        player.sendMessage(s);
      }
    }
 else {
      return false;
    }
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args){
  IPlayer player=(IPlayer)sender;
  if (manager.isPlotWorld(player)) {
    if (player.hasPermission(PermissionNames.USER_BIOME)) {
      int page=1;
      List<List<String>> partition=Lists.partition(serverBridge.getBiomes(),10);
      if (args.length == 2) {
        page=Integer.parseInt(args[1]);
      }
      player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + page+ ""String_Node_Str""+ partition.size()+ ""String_Node_Str"");
      for (      String s : partition.get(page - 1)) {
        player.sendMessage(s);
      }
    }
 else {
      return false;
    }
  }
  return true;
}"
41942,"public boolean execute(ICommandSender sender,String[] args){
  if (args.length != 2) {
    sender.sendMessage(getUsage());
    return true;
  }
  if (args[1].length() > 16) {
    sender.sendMessage(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(C(""String_Node_Str""));
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_DENY) || player.hasPermission(PermissionNames.USER_DENY)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      PlotMapInfo pmi=manager.getMap(world);
      String denied;
      IPlayer deniedPlayer=serverBridge.getPlayer(args[1]);
      if (""String_Node_Str"".equals(args[1])) {
        denied=""String_Node_Str"";
      }
 else       if (deniedPlayer == null) {
        player.sendMessage(args[1] + ""String_Node_Str"");
        return true;
      }
 else {
        denied=deniedPlayer.getUniqueId().toString();
      }
      if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_DENY)) {
        if (!""String_Node_Str"".equals(denied)) {
          if (plot.getOwnerId().equals(deniedPlayer.getUniqueId())) {
            player.sendMessage(C(""String_Node_Str""));
            return true;
          }
        }
        if (plot.isDenied(denied)) {
          player.sendMessage(C(""String_Node_Str"",args[1]));
        }
 else {
          double price=0.0;
          PlotAddDeniedEvent event=new PlotAddDeniedEvent(world,plot,player,denied);
          if (manager.isEconomyEnabled(pmi)) {
            price=pmi.getDenyPlayerPrice();
            if (serverBridge.has(player,price)) {
              plugin.getEventBus().post(event);
              if (event.isCancelled()) {
                return true;
              }
              EconomyResponse er=serverBridge.withdrawPlayer(player,price);
              if (!er.transactionSuccess()) {
                player.sendMessage(er.errorMessage);
                plugin.getLogger().warning(er.errorMessage);
                return true;
              }
            }
 else {
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
              return true;
            }
          }
 else {
            plugin.getEventBus().post(event);
          }
          if (!event.isCancelled()) {
            plot.addDenied(denied);
            plot.removeMember(denied);
            if (""String_Node_Str"".equals(denied)) {
              List<IPlayer> playersInPlot=manager.getPlayersInPlot(plot.getId(),world);
              for (              IPlayer iPlayer : playersInPlot) {
                if (plot.isMember(iPlayer.getUniqueId()).isPresent()) {
                  continue;
                }
                iPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
              }
              player.sendMessage(denied + ""String_Node_Str"" + C(""String_Node_Str"",""String_Node_Str""));
            }
 else             if (deniedPlayer != null && deniedPlayer.getWorld().equals(world)) {
              PlotId plotId=manager.getPlotId(deniedPlayer);
              if (plot.getId().equals(plotId)) {
                deniedPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
              }
              player.sendMessage(denied + ""String_Node_Str"" + C(""String_Node_Str"",deniedPlayer.getName()));
            }
            if (isAdvancedLogging()) {
              plugin.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().getID());
            }
          }
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId().getID()+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args){
  if (args.length != 2) {
    sender.sendMessage(getUsage());
    return true;
  }
  if (args[1].length() > 16) {
    sender.sendMessage(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(C(""String_Node_Str""));
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_DENY) || player.hasPermission(PermissionNames.USER_DENY)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      PlotMapInfo pmi=manager.getMap(world);
      String denied;
      IPlayer deniedPlayer=serverBridge.getPlayer(args[1]);
      if (""String_Node_Str"".equals(args[1])) {
        denied=""String_Node_Str"";
      }
 else       if (deniedPlayer == null) {
        player.sendMessage(args[1] + ""String_Node_Str"");
        return true;
      }
 else {
        denied=deniedPlayer.getUniqueId().toString();
      }
      if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_DENY)) {
        if (!""String_Node_Str"".equals(denied)) {
          if (plot.getOwnerId().equals(deniedPlayer.getUniqueId())) {
            player.sendMessage(C(""String_Node_Str""));
            return true;
          }
        }
        if (plot.isDenied(denied)) {
          player.sendMessage(C(""String_Node_Str"",args[1]));
        }
 else {
          double price=0.0;
          PlotAddDeniedEvent event=new PlotAddDeniedEvent(world,plot,player,denied);
          if (manager.isEconomyEnabled(pmi)) {
            price=pmi.getDenyPlayerPrice();
            if (serverBridge.has(player,price)) {
              plugin.getEventBus().post(event);
              if (event.isCancelled()) {
                return true;
              }
              EconomyResponse er=serverBridge.withdrawPlayer(player,price);
              if (!er.transactionSuccess()) {
                player.sendMessage(er.errorMessage);
                plugin.getLogger().warning(er.errorMessage);
                return true;
              }
            }
 else {
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
              return true;
            }
          }
 else {
            plugin.getEventBus().post(event);
          }
          if (!event.isCancelled()) {
            plot.addDenied(denied);
            plot.removeMember(denied);
            if (""String_Node_Str"".equals(denied)) {
              List<IPlayer> playersInPlot=manager.getPlayersInPlot(plot.getId(),world);
              for (              IPlayer iPlayer : playersInPlot) {
                if (plot.isMember(iPlayer.getUniqueId()).isPresent()) {
                  continue;
                }
                iPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
              }
              player.sendMessage(denied + ""String_Node_Str"" + C(""String_Node_Str"",""String_Node_Str""));
            }
 else             if (deniedPlayer != null && deniedPlayer.getWorld().equals(world)) {
              PlotId plotId=manager.getPlotId(deniedPlayer);
              if (plot.getId().equals(plotId)) {
                deniedPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
              }
              player.sendMessage(C(""String_Node_Str"",args[1]));
            }
            if (isAdvancedLogging()) {
              plugin.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().getID());
            }
          }
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId().getID()+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41943,"public boolean execute(ICommandSender sender,String[] args){
  IPlayer player=(IPlayer)sender;
  if (manager.isPlotWorld(player)) {
    if (player.hasPermission(PermissionNames.ADMIN_DONE) || player.hasPermission(PermissionNames.USER_DONE)) {
      int page=1;
      if (args.length == 2) {
        page=Integer.parseInt(args[1]);
      }
      List<List<Plot>> partition=Lists.partition(plugin.getSqlManager().getFinishedPlots(player.getWorld()),10);
      if (partition.isEmpty()) {
        player.sendMessage(C(""String_Node_Str""));
      }
 else {
        player.sendMessage(C(""String_Node_Str"",page,partition.size()));
        for (        Plot plot : partition.get(page)) {
          player.sendMessage(plot.getId() + ""String_Node_Str"" + plot.getOwner()+ ""String_Node_Str""+ plot.getFinishedDate());
        }
      }
    }
 else {
      return false;
    }
  }
 else {
    player.sendMessage(C(""String_Node_Str""));
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args){
  IPlayer player=(IPlayer)sender;
  if (manager.isPlotWorld(player)) {
    if (player.hasPermission(PermissionNames.ADMIN_DONE) || player.hasPermission(PermissionNames.USER_DONE)) {
      int page=1;
      if (args.length == 2) {
        page=Integer.parseInt(args[1]);
      }
      List<List<Plot>> partition=Lists.partition(plugin.getSqlManager().getFinishedPlots(player.getWorld()),10);
      if (partition.isEmpty()) {
        player.sendMessage(C(""String_Node_Str""));
      }
 else {
        player.sendMessage(C(""String_Node_Str"",page,partition.size()));
        for (        Plot plot : partition.get(page - 1)) {
          player.sendMessage(plot.getId() + ""String_Node_Str"" + plot.getOwner()+ ""String_Node_Str""+ plot.getFinishedDate());
        }
      }
    }
 else {
      return false;
    }
  }
 else {
    player.sendMessage(C(""String_Node_Str""));
  }
  return true;
}"
41944,"public boolean execute(ICommandSender sender,String[] args){
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_LIST)) {
    if (manager.isPlotWorld(player)) {
      UUID uuid;
      int page=1;
      if (args.length > 2) {
        IOfflinePlayer offlinePlayer=serverBridge.getOfflinePlayer(args[1]);
        if (offlinePlayer == null) {
          player.sendMessage(""String_Node_Str"");
          return true;
        }
        uuid=offlinePlayer.getUniqueId();
        if (args.length == 3) {
          page=Integer.parseInt(args[2]);
        }
      }
 else {
        uuid=player.getUniqueId();
      }
      List<List<Plot>> partition=Lists.partition(plugin.getSqlManager().getPlayerPlots(uuid),5);
      player.sendMessage(""String_Node_Str"" + ""String_Node_Str"" + page + ""String_Node_Str""+ partition.size()+ ""String_Node_Str"");
      for (      Plot plot : partition.get(page)) {
        player.sendMessage(""String_Node_Str"" + plot.getId().getID() + ""String_Node_Str""+ plot.getWorld().getName());
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args){
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_LIST)) {
    if (manager.isPlotWorld(player)) {
      UUID uuid;
      int page=1;
      if (args.length > 2) {
        IOfflinePlayer offlinePlayer=serverBridge.getOfflinePlayer(args[1]);
        if (offlinePlayer == null) {
          player.sendMessage(""String_Node_Str"");
          return true;
        }
        uuid=offlinePlayer.getUniqueId();
        if (args.length == 3) {
          page=Integer.parseInt(args[2]);
        }
      }
 else {
        uuid=player.getUniqueId();
      }
      List<List<Plot>> partition=Lists.partition(plugin.getSqlManager().getPlayerPlots(uuid),5);
      player.sendMessage(""String_Node_Str"" + ""String_Node_Str"" + page + ""String_Node_Str""+ partition.size()+ ""String_Node_Str"");
      for (      Plot plot : partition.get(page - 1)) {
        player.sendMessage(""String_Node_Str"" + plot.getId().getID() + ""String_Node_Str""+ plot.getWorld().getName());
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41945,"public boolean execute(ICommandSender sender,String[] args){
  if (args.length < 2 && args.length >= 3 || args[1].length() > 16) {
    sender.sendMessage(getUsage());
    return true;
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_ADD) || player.hasPermission(PermissionNames.USER_ADD) || player.hasPermission(PermissionNames.ADMIN_TRUST)|| player.hasPermission(PermissionNames.USER_TRUST)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      PlotMapInfo pmi=manager.getMap(world);
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
 else {
        UUID playerUniqueId=player.getUniqueId();
        String allowed;
        if (plot.getOwnerId().equals(playerUniqueId) || player.hasPermission(PermissionNames.ADMIN_TRUST) || player.hasPermission(PermissionNames.ADMIN_ADD)) {
          if (args[1].equals(""String_Node_Str"")) {
            allowed=""String_Node_Str"";
          }
 else {
            IOfflinePlayer offlinePlayer=serverBridge.getOfflinePlayer(args[1]);
            if (offlinePlayer == null) {
              player.sendMessage(""String_Node_Str"" + args[1]);
              return true;
            }
 else {
              allowed=offlinePlayer.getUniqueId().toString();
            }
          }
          if (plot.isMember(allowed).isPresent()) {
            double price=0.0;
            PlotRemoveAllowedEvent event=new PlotRemoveAllowedEvent(plot,player,allowed);
            plugin.getEventBus().post(event);
            if (manager.isEconomyEnabled(pmi) && !event.isCancelled()) {
              price=pmi.getRemovePlayerPrice();
              if (serverBridge.has(player,price)) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
 else {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
                return true;
              }
            }
            if (!event.isCancelled()) {
              if (""String_Node_Str"".equals(allowed)) {
                plot.removeAllMembers();
              }
 else {
                plot.removeMembers(allowed);
              }
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(allowed + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId());
                }
 else {
                  serverBridge.getLogger().info(allowed + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
 else {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args){
  if (args.length < 2 && args.length >= 3 || args[1].length() > 16) {
    sender.sendMessage(getUsage());
    return true;
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_ADD) || player.hasPermission(PermissionNames.USER_ADD) || player.hasPermission(PermissionNames.ADMIN_TRUST)|| player.hasPermission(PermissionNames.USER_TRUST)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      PlotMapInfo pmi=manager.getMap(world);
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
 else {
        UUID playerUniqueId=player.getUniqueId();
        String allowed;
        if (plot.getOwnerId().equals(playerUniqueId) || player.hasPermission(PermissionNames.ADMIN_TRUST) || player.hasPermission(PermissionNames.ADMIN_ADD)) {
          if (args[1].equals(""String_Node_Str"")) {
            allowed=""String_Node_Str"";
          }
 else {
            IOfflinePlayer offlinePlayer=serverBridge.getOfflinePlayer(args[1]);
            if (offlinePlayer == null) {
              player.sendMessage(""String_Node_Str"" + args[1]);
              return true;
            }
 else {
              allowed=offlinePlayer.getUniqueId().toString();
            }
          }
          if (plot.isMember(allowed).isPresent()) {
            double price=0.0;
            PlotRemoveAllowedEvent event=new PlotRemoveAllowedEvent(plot,player,allowed);
            plugin.getEventBus().post(event);
            if (manager.isEconomyEnabled(pmi) && !event.isCancelled()) {
              price=pmi.getRemovePlayerPrice();
              if (serverBridge.has(player,price)) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
 else {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
                return true;
              }
            }
            if (!event.isCancelled()) {
              if (""String_Node_Str"".equals(allowed)) {
                plot.removeAllMembers();
              }
 else {
                plot.removeMembers(allowed);
              }
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(args[1] + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId());
                }
 else {
                  serverBridge.getLogger().info(args[1] + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
 else {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41946,"public boolean execute(ICommandSender sender,String[] args){
  if (args.length < 2 && args.length >= 3) {
    sender.sendMessage(getUsage());
    return true;
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(C(""String_Node_Str""));
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_ADD) || player.hasPermission(PermissionNames.USER_ADD)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(player)) {
      PlotMapInfo pmi=manager.getMap(world);
      Plot plot=manager.getPlot(player);
      if (plot != null) {
        String allowed;
        if (""String_Node_Str"".equals(args[1])) {
          allowed=""String_Node_Str"";
        }
 else {
          if (serverBridge.getPlayer(args[1]) != null) {
            allowed=serverBridge.getPlayer(args[1]).getUniqueId().toString();
          }
 else {
            player.sendMessage(args[1] + ""String_Node_Str"");
            return true;
          }
        }
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_ADD)) {
          if (plot.isMember(allowed).isPresent()) {
            player.sendMessage(C(""String_Node_Str"",args[1]));
          }
 else {
            PlotAddAllowedEvent event=new PlotAddAllowedEvent(plot,player,allowed);
            plugin.getEventBus().post(event);
            double price=0.0;
            if (manager.isEconomyEnabled(pmi)) {
              price=pmi.getAddPlayerPrice();
              if (serverBridge.has(player,pmi.getAddPlayerPrice())) {
                player.sendMessage(""String_Node_Str"" + serverBridge.getEconomy().get().format(price) + ""String_Node_Str""+ ""String_Node_Str"");
                return true;
              }
 else               if (!event.isCancelled()) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
            }
            if (!event.isCancelled()) {
              plot.addMember(allowed,Plot.AccessLevel.TRUSTED);
              plot.removeDenied(allowed);
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + allowed+ ""String_Node_Str""+ C(""String_Node_Str""));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId());
                }
 else {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args){
  if (args.length < 2 && args.length >= 3) {
    sender.sendMessage(getUsage());
    return true;
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(C(""String_Node_Str""));
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_ADD) || player.hasPermission(PermissionNames.USER_ADD)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(player)) {
      PlotMapInfo pmi=manager.getMap(world);
      Plot plot=manager.getPlot(player);
      if (plot != null) {
        String allowed;
        if (""String_Node_Str"".equals(args[1])) {
          allowed=""String_Node_Str"";
        }
 else {
          if (serverBridge.getPlayer(args[1]) != null) {
            allowed=serverBridge.getPlayer(args[1]).getUniqueId().toString();
          }
 else {
            player.sendMessage(args[1] + ""String_Node_Str"");
            return true;
          }
        }
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_ADD)) {
          if (plot.isMember(allowed).isPresent()) {
            player.sendMessage(C(""String_Node_Str"",args[1]));
          }
 else {
            PlotAddAllowedEvent event=new PlotAddAllowedEvent(plot,player,allowed);
            plugin.getEventBus().post(event);
            double price=0.0;
            if (manager.isEconomyEnabled(pmi)) {
              price=pmi.getAddPlayerPrice();
              if (serverBridge.has(player,pmi.getAddPlayerPrice())) {
                player.sendMessage(""String_Node_Str"" + serverBridge.getEconomy().get().format(price) + ""String_Node_Str""+ ""String_Node_Str"");
                return true;
              }
 else               if (!event.isCancelled()) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
            }
            if (!event.isCancelled()) {
              plot.addMember(allowed,Plot.AccessLevel.TRUSTED);
              plot.removeDenied(allowed);
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId());
                }
 else {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
  }
 else {
    return false;
  }
  return true;
}"
41947,"public boolean execute(ICommandSender sender,String[] args){
  if (args.length < 2 && args.length >= 3) {
    sender.sendMessage(getUsage());
    return true;
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_DENY) || player.hasPermission(PermissionNames.USER_DENY)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      PlotMapInfo pmi=manager.getMap(world);
      String denied=args[1];
      if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_DENY)) {
        if (""String_Node_Str"".equals(denied)) {
          return undenyAll(plot,player,pmi);
        }
        IOfflinePlayer offlinePlayer=serverBridge.getOfflinePlayer(denied);
        if (offlinePlayer == null) {
          player.sendMessage(""String_Node_Str"" + denied);
          return true;
        }
 else {
          denied=offlinePlayer.getUniqueId().toString();
        }
        if (plot.isDenied(denied)) {
          double price=0.0;
          PlotRemoveDeniedEvent event=new PlotRemoveDeniedEvent(plot,player,denied);
          if (manager.isEconomyEnabled(pmi)) {
            price=pmi.getUndenyPlayerPrice();
            if (serverBridge.has(player,price)) {
              plugin.getEventBus().post(event);
              if (event.isCancelled()) {
                return true;
              }
 else {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
            }
 else {
              player.sendMessage(""String_Node_Str"" + serverBridge.getEconomy().get().format(price) + ""String_Node_Str""+ ""String_Node_Str"");
              return true;
            }
          }
 else {
            plugin.getEventBus().post(event);
          }
          if (!event.isCancelled()) {
            plot.removeDenied(denied);
            plugin.getSqlManager().savePlot(plot);
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
            if (isAdvancedLogging()) {
              if (price != 0) {
                serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().getID()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
              }
 else {
                serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().getID());
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId().getID()+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args){
  if (args.length < 2 && args.length >= 3) {
    sender.sendMessage(getUsage());
    return true;
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_DENY) || player.hasPermission(PermissionNames.USER_DENY)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      PlotMapInfo pmi=manager.getMap(world);
      String denied=args[1];
      if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_DENY)) {
        if (""String_Node_Str"".equals(denied)) {
          return undenyAll(plot,player,pmi);
        }
        IOfflinePlayer offlinePlayer=serverBridge.getOfflinePlayer(denied);
        if (offlinePlayer == null) {
          player.sendMessage(""String_Node_Str"" + args[1]);
          return true;
        }
 else {
          denied=offlinePlayer.getUniqueId().toString();
        }
        if (plot.isDenied(denied)) {
          double price=0.0;
          PlotRemoveDeniedEvent event=new PlotRemoveDeniedEvent(plot,player,denied);
          if (manager.isEconomyEnabled(pmi)) {
            price=pmi.getUndenyPlayerPrice();
            if (serverBridge.has(player,price)) {
              plugin.getEventBus().post(event);
              if (event.isCancelled()) {
                return true;
              }
 else {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
            }
 else {
              player.sendMessage(""String_Node_Str"" + serverBridge.getEconomy().get().format(price) + ""String_Node_Str""+ ""String_Node_Str"");
              return true;
            }
          }
 else {
            plugin.getEventBus().post(event);
          }
          if (!event.isCancelled()) {
            plot.removeDenied(denied);
            plugin.getSqlManager().savePlot(plot);
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
            if (isAdvancedLogging()) {
              if (price != 0) {
                serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().getID()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
              }
 else {
                serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().getID());
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId().getID()+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41948,"public boolean execute(ICommandSender sender,String[] args){
  final IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_AUTO)) {
    if (manager.isPlotWorld(player) || plugin.getConfig().getBoolean(""String_Node_Str"")) {
      final IWorld world;
      if (!manager.isPlotWorld(player) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
        if (args.length == 2) {
          world=manager.getWorld(args[1]);
        }
 else {
          world=manager.getFirstWorld();
        }
        if (world == null) {
          player.sendMessage(C(""String_Node_Str""));
          return true;
        }
        if (!manager.isPlotWorld(world)) {
          player.sendMessage(C(""String_Node_Str"",world));
          return true;
        }
      }
 else {
        world=player.getWorld();
      }
      int playerLimit=getPlotLimit(player);
      int plotsOwned=manager.getOwnedPlotCount(player.getUniqueId(),world);
      if (playerLimit != -1 && plotsOwned >= playerLimit && !player.hasPermission(""String_Node_Str"")) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plotsOwned+ ""String_Node_Str""+ playerLimit+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
        return true;
      }
      final PlotMapInfo pmi=manager.getMap(world);
      serverBridge.runTaskAsynchronously(new Runnable(){
        @Override public void run(){
          loop:           for (int i=0; i < 50000; i++) {
            for (int x=-i; x <= i; x++) {
              for (int z=-i; z <= i; z++) {
                final PlotId id=new PlotId(x,z);
                if (manager.isPlotAvailable(id,world)) {
                  final String name=player.getName();
                  final UUID uuid=player.getUniqueId();
                  if (manager.isEconomyEnabled(world)) {
                    double price=pmi.getClaimPrice();
                    if (serverBridge.has(player,price)) {
                      EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                      if (!er.transactionSuccess()) {
                        player.sendMessage(er.errorMessage);
                      }
                    }
 else {
                      player.sendMessage(""String_Node_Str"");
                    }
                  }
                  plugin.getServerBridge().runTask(new Runnable(){
                    @Override public void run(){
                      manager.createPlot(id,world,name,uuid,pmi);
                    }
                  }
);
                  player.teleport(manager.getPlotHome(id,world));
                  player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
                  break loop;
                }
              }
            }
          }
        }
      }
);
      player.sendMessage(C(""String_Node_Str""));
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args){
  final IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_AUTO)) {
    if (manager.isPlotWorld(player) || plugin.getConfig().getBoolean(""String_Node_Str"")) {
      final IWorld world;
      if (!manager.isPlotWorld(player) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
        if (args.length == 2) {
          world=manager.getWorld(args[1]);
        }
 else {
          world=manager.getFirstWorld();
        }
        if (world == null) {
          player.sendMessage(C(""String_Node_Str""));
          return true;
        }
        if (!manager.isPlotWorld(world)) {
          player.sendMessage(C(""String_Node_Str"",world));
          return true;
        }
      }
 else {
        world=player.getWorld();
      }
      int playerLimit=getPlotLimit(player);
      int plotsOwned=manager.getOwnedPlotCount(player.getUniqueId(),world);
      if (playerLimit != -1 && plotsOwned >= playerLimit && !player.hasPermission(""String_Node_Str"")) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plotsOwned+ ""String_Node_Str""+ playerLimit+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
        return true;
      }
      final PlotMapInfo pmi=manager.getMap(world);
      serverBridge.runTaskAsynchronously(new Runnable(){
        @Override public void run(){
          loop:           for (int i=0; i < 50000; i++) {
            for (int x=-i; x <= i; x++) {
              for (int z=-i; z <= i; z++) {
                final PlotId id=new PlotId(x,z);
                if (manager.isPlotAvailable(id,world)) {
                  final String name=player.getName();
                  final UUID uuid=player.getUniqueId();
                  if (manager.isEconomyEnabled(world)) {
                    double price=pmi.getClaimPrice();
                    if (serverBridge.has(player,price)) {
                      EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                      if (!er.transactionSuccess()) {
                        player.sendMessage(er.errorMessage);
                      }
                    }
 else {
                      player.sendMessage(""String_Node_Str"");
                    }
                  }
                  plugin.getServerBridge().runTask(new Runnable(){
                    @Override public void run(){
                      manager.createPlot(id,world,name,uuid,pmi);
                    }
                  }
);
                  player.teleport(manager.getPlotHome(id,world));
                  player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ C(""String_Node_Str""));
                  break loop;
                }
              }
            }
          }
        }
      }
);
      player.sendMessage(C(""String_Node_Str""));
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41949,"@Override public void onEnable(){
  INSTANCE=this;
  getLogger().info(""String_Node_Str"");
  serverObjectBuilder=new BukkitServerBridge(getLogger());
  plotme=new PlotMe_Core(serverObjectBuilder);
  getAPI().enable();
  doMetric();
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvents(new BukkitPlotListener(),this);
  pm.registerEvents(new BukkitPlotDenyListener(),this);
  this.getCommand(""String_Node_Str"").setExecutor(new BukkitCommand(this));
}","@Override public void onEnable(){
  INSTANCE=this;
  getLogger().info(""String_Node_Str"");
  serverObjectBuilder=new BukkitServerBridge(getLogger());
  plotme=new PlotMe_Core();
  plotme.registerServerBridge(serverObjectBuilder);
  getAPI().enable();
  doMetric();
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvents(new BukkitPlotListener(),this);
  pm.registerEvents(new BukkitPlotDenyListener(),this);
  this.getCommand(""String_Node_Str"").setExecutor(new BukkitCommand(this));
}"
41950,"@Override public List<IEntity> getEntities(){
  List<IEntity> bukkitEntites=new ArrayList<>(world.getEntities().size());
  for (  Entity entity : world.getEntities()) {
    bukkitEntites.add(new BukkitEntity(entity));
  }
  return bukkitEntites;
}","@Override public List<IEntity> getEntities(){
  List<IEntity> bukkitEntites=new ArrayList<>(world.getEntities().size());
  for (  Entity entity : world.getEntities()) {
    bukkitEntites.add(BukkitUtil.adapt(entity));
  }
  return bukkitEntites;
}"
41951,"/** 
 * Setup SQL Database
 */
private void setupSQL(){
  FileConfiguration config=getConfig();
  if (config.getBoolean(""String_Node_Str"",false)) {
    String url=config.getString(""String_Node_Str"");
    String user=config.getString(""String_Node_Str"");
    String pass=config.getString(""String_Node_Str"");
    setSqlManager(new MySQLConnector(this,url,user,pass));
  }
 else {
    setSqlManager(new SQLiteConnector(this));
  }
  getSqlManager().startConnection();
}","/** 
 * Setup SQL Database
 */
private void setupSQL(){
  FileConfiguration config=getConfig();
  if (config.getBoolean(""String_Node_Str"",false)) {
    String url=config.getString(""String_Node_Str"");
    String user=config.getString(""String_Node_Str"");
    String pass=config.getString(""String_Node_Str"");
    setSqlManager(new MySQLConnector(this,url,user,pass));
  }
 else {
    setSqlManager(new SQLiteConnector(this));
  }
}"
41952,"public PlotMe_Core(IServerBridge serverObjectBuilder){
  this.serverBridge=serverObjectBuilder;
  this.schematicutil=new SchematicUtil(this);
}","public PlotMe_Core(){
}"
41953,"/** 
 * Get the home   {@link ILocation} of the plot
 * @return internal home location of the plot
 */
public Vector getLocation(){
  return location;
}","/** 
 * Get the home   {@link ILocation} of the plot
 * @return internal home location of the plot
 */
public ILocation getLocation(){
  return location;
}"
41954,"public PlotTeleportEvent(IWorld world,Plot plot,IPlayer player,Vector location,PlotId plotId){
  super(plot,world);
  this.player=player;
  this.location=location;
  this.plotId=plotId;
}","public PlotTeleportEvent(Plot plot,IPlayer player,ILocation location,PlotId plotId){
  super(plot,location.getWorld());
  this.player=player;
  this.location=location;
  this.plotId=plotId;
}"
41955,"public PlotTeleportHomeEvent(IWorld world,Plot plot,IPlayer player,ILocation location){
  super(world,plot,player,location,plot.getId());
}","public PlotTeleportHomeEvent(Plot plot,IPlayer player,ILocation location){
  super(plot,player,location,plot.getId());
}"
41956,"public PlotTeleportMiddleEvent(IWorld world,Plot plot,IPlayer player,Vector middlelocation){
  super(world,plot,player,middlelocation,plot.getId());
}","public PlotTeleportMiddleEvent(Plot plot,IPlayer player,ILocation middlelocation){
  super(plot,player,middlelocation,plot.getId());
}"
41957,"@Override public void run(){
  for (int i=0; i < 50000; i++) {
    for (int x=-i; x <= i; x++) {
      for (int z=-i; z <= i; z++) {
        PlotId id=new PlotId(x,z);
        if (manager.isPlotAvailable(id,world)) {
          String name=player.getName();
          UUID uuid=player.getUniqueId();
          if (manager.isEconomyEnabled(world)) {
            double price=pmi.getClaimPrice();
            if (serverBridge.has(player,price)) {
              EconomyResponse er=serverBridge.withdrawPlayer(player,price);
              if (!er.transactionSuccess()) {
                player.sendMessage(er.errorMessage);
              }
            }
 else {
              player.sendMessage(""String_Node_Str"");
            }
          }
          manager.createPlot(id,world,name,uuid,pmi);
          player.teleport(manager.getPlotHome(id,world));
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
    }
  }
}","@Override public void run(){
  loop:   for (int i=0; i < 50000; i++) {
    for (int x=-i; x <= i; x++) {
      for (int z=-i; z <= i; z++) {
        PlotId id=new PlotId(x,z);
        if (manager.isPlotAvailable(id,world)) {
          String name=player.getName();
          UUID uuid=player.getUniqueId();
          if (manager.isEconomyEnabled(world)) {
            double price=pmi.getClaimPrice();
            if (serverBridge.has(player,price)) {
              EconomyResponse er=serverBridge.withdrawPlayer(player,price);
              if (!er.transactionSuccess()) {
                player.sendMessage(er.errorMessage);
              }
            }
 else {
              player.sendMessage(""String_Node_Str"");
            }
          }
          manager.createPlot(id,world,name,uuid,pmi);
          player.teleport(manager.getPlotHome(id,world));
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
          break loop;
        }
      }
    }
  }
}"
41958,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  final IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_AUTO)) {
    if (manager.isPlotWorld(player) || plugin.getConfig().getBoolean(""String_Node_Str"")) {
      final IWorld world;
      if (!manager.isPlotWorld(player) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
        if (args.length == 2) {
          world=manager.getWorld(args[1]);
        }
 else {
          world=manager.getFirstWorld();
        }
        if (world == null) {
          player.sendMessage(C(""String_Node_Str""));
          return true;
        }
        if (!manager.isPlotWorld(world)) {
          player.sendMessage(world + ""String_Node_Str"" + C(""String_Node_Str""));
          return true;
        }
      }
 else {
        world=player.getWorld();
      }
      int playerLimit=getPlotLimit(player);
      int plotsOwned=manager.getOwnedPlotCount(player.getUniqueId(),world);
      if (playerLimit != -1 && plotsOwned >= playerLimit && !player.hasPermission(""String_Node_Str"")) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plotsOwned+ ""String_Node_Str""+ playerLimit+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
        return true;
      }
      final PlotMapInfo pmi=manager.getMap(world);
      serverBridge.runTaskAsynchronously(new Runnable(){
        @Override public void run(){
          for (int i=0; i < 50000; i++) {
            for (int x=-i; x <= i; x++) {
              for (int z=-i; z <= i; z++) {
                PlotId id=new PlotId(x,z);
                if (manager.isPlotAvailable(id,world)) {
                  String name=player.getName();
                  UUID uuid=player.getUniqueId();
                  if (manager.isEconomyEnabled(world)) {
                    double price=pmi.getClaimPrice();
                    if (serverBridge.has(player,price)) {
                      EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                      if (!er.transactionSuccess()) {
                        player.sendMessage(er.errorMessage);
                      }
                    }
 else {
                      player.sendMessage(""String_Node_Str"");
                    }
                  }
                  manager.createPlot(id,world,name,uuid,pmi);
                  player.teleport(manager.getPlotHome(id,world));
                  player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
                }
              }
            }
          }
        }
      }
);
      player.sendMessage(C(""String_Node_Str""));
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  final IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_AUTO)) {
    if (manager.isPlotWorld(player) || plugin.getConfig().getBoolean(""String_Node_Str"")) {
      final IWorld world;
      if (!manager.isPlotWorld(player) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
        if (args.length == 2) {
          world=manager.getWorld(args[1]);
        }
 else {
          world=manager.getFirstWorld();
        }
        if (world == null) {
          player.sendMessage(C(""String_Node_Str""));
          return true;
        }
        if (!manager.isPlotWorld(world)) {
          player.sendMessage(world + ""String_Node_Str"" + C(""String_Node_Str""));
          return true;
        }
      }
 else {
        world=player.getWorld();
      }
      int playerLimit=getPlotLimit(player);
      int plotsOwned=manager.getOwnedPlotCount(player.getUniqueId(),world);
      if (playerLimit != -1 && plotsOwned >= playerLimit && !player.hasPermission(""String_Node_Str"")) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plotsOwned+ ""String_Node_Str""+ playerLimit+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
        return true;
      }
      final PlotMapInfo pmi=manager.getMap(world);
      serverBridge.runTaskAsynchronously(new Runnable(){
        @Override public void run(){
          loop:           for (int i=0; i < 50000; i++) {
            for (int x=-i; x <= i; x++) {
              for (int z=-i; z <= i; z++) {
                PlotId id=new PlotId(x,z);
                if (manager.isPlotAvailable(id,world)) {
                  String name=player.getName();
                  UUID uuid=player.getUniqueId();
                  if (manager.isEconomyEnabled(world)) {
                    double price=pmi.getClaimPrice();
                    if (serverBridge.has(player,price)) {
                      EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                      if (!er.transactionSuccess()) {
                        player.sendMessage(er.errorMessage);
                      }
                    }
 else {
                      player.sendMessage(""String_Node_Str"");
                    }
                  }
                  manager.createPlot(id,world,name,uuid,pmi);
                  player.teleport(manager.getPlotHome(id,world));
                  player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
                  break loop;
                }
              }
            }
          }
        }
      }
);
      player.sendMessage(C(""String_Node_Str""));
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41959,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length > 4) {
    throw new BadUsageException(getUsage());
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_BIOME)) {
    IWorld world=player.getWorld();
    PlotMapInfo pmi=manager.getMap(world);
    if (manager.isPlotWorld(world)) {
      Plot plot=manager.getPlot(player);
      if (plot != null) {
        Optional<String> biome=Optional.absent();
        if (args.length == 2) {
          biome=serverBridge.getBiome(args[1]);
        }
 else         if (args.length == 3) {
          biome=serverBridge.getBiome(args[1] + ""String_Node_Str"" + args[2]);
        }
 else         if (args.length == 4) {
          biome=serverBridge.getBiome(args[1] + ""String_Node_Str"" + args[2]+ ""String_Node_Str""+ args[3]);
        }
        if (!biome.isPresent()) {
          player.sendMessage(biome.get() + ""String_Node_Str"" + C(""String_Node_Str""));
          return true;
        }
        String playerName=player.getName();
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(""String_Node_Str"")) {
          double price=0.0;
          PlotBiomeChangeEvent event=new PlotBiomeChangeEvent(world,plot,player,biome.get());
          plugin.getEventBus().post(event);
          if (manager.isEconomyEnabled(pmi)) {
            price=pmi.getBiomeChangePrice();
            if (serverBridge.has(player,price)) {
              player.sendMessage(""String_Node_Str"" + serverBridge.getEconomy().get().format(price) + ""String_Node_Str"");
              return true;
            }
 else             if (!event.isCancelled()) {
              EconomyResponse er=serverBridge.withdrawPlayer(player,price);
              if (!er.transactionSuccess()) {
                player.sendMessage(er.errorMessage);
                serverBridge.getLogger().warning(er.errorMessage);
                return true;
              }
            }
 else {
              return true;
            }
          }
          if (!event.isCancelled()) {
            plot.setBiome(biome.get());
            manager.setBiome(plot);
            plugin.getSqlManager().savePlot(plot);
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + biome.get()+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
            if (isAdvancedLogging()) {
              if (price == 0) {
                serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ biome.get());
              }
 else {
                serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ biome.get()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length > 4) {
    throw new BadUsageException(getUsage());
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_BIOME)) {
    IWorld world=player.getWorld();
    PlotMapInfo pmi=manager.getMap(world);
    if (manager.isPlotWorld(world)) {
      Plot plot=manager.getPlot(player);
      if (plot != null) {
        Optional<String> biome=Optional.absent();
        if (args.length == 2) {
          biome=serverBridge.getBiome(args[1]);
        }
 else         if (args.length == 3) {
          biome=serverBridge.getBiome(args[1] + ""String_Node_Str"" + args[2]);
        }
 else         if (args.length == 4) {
          biome=serverBridge.getBiome(args[1] + ""String_Node_Str"" + args[2]+ ""String_Node_Str""+ args[3]);
        }
        if (!biome.isPresent()) {
          player.sendMessage(biome.get() + ""String_Node_Str"" + C(""String_Node_Str""));
          return true;
        }
        String playerName=player.getName();
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(""String_Node_Str"")) {
          double price=0.0;
          PlotBiomeChangeEvent event=new PlotBiomeChangeEvent(world,plot,player,biome.get());
          plugin.getEventBus().post(event);
          if (manager.isEconomyEnabled(pmi)) {
            price=pmi.getBiomeChangePrice();
            if (serverBridge.has(player,price)) {
              player.sendMessage(""String_Node_Str"" + serverBridge.getEconomy().get().format(price) + ""String_Node_Str"");
              return true;
            }
 else             if (!event.isCancelled()) {
              EconomyResponse er=serverBridge.withdrawPlayer(player,price);
              if (!er.transactionSuccess()) {
                player.sendMessage(er.errorMessage);
                serverBridge.getLogger().warning(er.errorMessage);
                return true;
              }
            }
 else {
              return true;
            }
          }
          if (!event.isCancelled()) {
            plot.setBiome(biome.get());
            manager.setBiome(plot);
            plugin.getSqlManager().savePlot(plot);
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + biome.get());
            if (isAdvancedLogging()) {
              if (price == 0) {
                serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ biome.get());
              }
 else {
                serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ biome.get()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
  }
 else {
    return false;
  }
  return true;
}"
41960,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches()) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_DENY) || player.hasPermission(PermissionNames.USER_DENY)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      PlotMapInfo pmi=manager.getMap(world);
      String denied;
      IPlayer deniedPlayer=serverBridge.getPlayer(args[1]);
      if (""String_Node_Str"".equals(args[1])) {
        denied=""String_Node_Str"";
      }
 else       if (deniedPlayer != null) {
        denied=deniedPlayer.getUniqueId().toString();
      }
 else {
        player.sendMessage(args[1] + ""String_Node_Str"");
        return true;
      }
      if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_DENY)) {
        if (!""String_Node_Str"".equals(denied)) {
          if (plot.getOwnerId().equals(deniedPlayer.getUniqueId())) {
            player.sendMessage(C(""String_Node_Str""));
            return true;
          }
        }
        if (plot.isDeniedConsulting(denied)) {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
 else {
          double price=0.0;
          PlotAddDeniedEvent event=new PlotAddDeniedEvent(world,plot,player,denied);
          if (manager.isEconomyEnabled(pmi)) {
            price=pmi.getDenyPlayerPrice();
            if (serverBridge.has(player,price)) {
              plugin.getEventBus().post(event);
              if (event.isCancelled()) {
                return true;
              }
              EconomyResponse er=serverBridge.withdrawPlayer(player,price);
              if (!er.transactionSuccess()) {
                player.sendMessage(er.errorMessage);
                serverBridge.getLogger().warning(er.errorMessage);
                return true;
              }
            }
 else {
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
              return true;
            }
          }
 else {
            plugin.getEventBus().post(event);
          }
          if (!event.isCancelled()) {
            plot.addDenied(denied);
            plot.removeMember(denied);
            if (""String_Node_Str"".equals(denied)) {
              List<IPlayer> playersInPlot=manager.getPlayersInPlot(plot.getId(),world);
              for (              IPlayer iPlayer : playersInPlot) {
                if (!plot.isAllowed(iPlayer.getUniqueId())) {
                  iPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
                }
              }
            }
 else {
              if (deniedPlayer != null && deniedPlayer.getWorld().equals(world)) {
                PlotId plotId=manager.getPlotId(deniedPlayer);
                if (plot.getId().equals(plotId)) {
                  deniedPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
                }
              }
            }
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
            if (isAdvancedLogging()) {
              if (price == 0) {
                serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().getID());
              }
 else {
                serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().getID()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
              }
            }
          }
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId().getID()+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches()) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_DENY) || player.hasPermission(PermissionNames.USER_DENY)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      PlotMapInfo pmi=manager.getMap(world);
      String denied;
      IPlayer deniedPlayer=serverBridge.getPlayer(args[1]);
      if (""String_Node_Str"".equals(args[1])) {
        denied=""String_Node_Str"";
      }
 else       if (deniedPlayer != null) {
        denied=deniedPlayer.getUniqueId().toString();
      }
 else {
        player.sendMessage(args[1] + ""String_Node_Str"");
        return true;
      }
      if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_DENY)) {
        if (!""String_Node_Str"".equals(denied)) {
          if (plot.getOwnerId().equals(deniedPlayer.getUniqueId())) {
            player.sendMessage(C(""String_Node_Str""));
            return true;
          }
        }
        if (plot.isDeniedConsulting(denied)) {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
 else {
          double price=0.0;
          PlotAddDeniedEvent event=new PlotAddDeniedEvent(world,plot,player,denied);
          if (manager.isEconomyEnabled(pmi)) {
            price=pmi.getDenyPlayerPrice();
            if (serverBridge.has(player,price)) {
              plugin.getEventBus().post(event);
              if (event.isCancelled()) {
                return true;
              }
              EconomyResponse er=serverBridge.withdrawPlayer(player,price);
              if (!er.transactionSuccess()) {
                player.sendMessage(er.errorMessage);
                serverBridge.getLogger().warning(er.errorMessage);
                return true;
              }
            }
 else {
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
              return true;
            }
          }
 else {
            plugin.getEventBus().post(event);
          }
          if (!event.isCancelled()) {
            plot.addDenied(denied);
            plot.removeMember(denied);
            if (""String_Node_Str"".equals(denied)) {
              List<IPlayer> playersInPlot=manager.getPlayersInPlot(plot.getId(),world);
              for (              IPlayer iPlayer : playersInPlot) {
                if (!plot.isAllowed(iPlayer.getUniqueId())) {
                  iPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
                }
              }
            }
 else {
              if (deniedPlayer != null && deniedPlayer.getWorld().equals(world)) {
                PlotId plotId=manager.getPlotId(deniedPlayer);
                if (plot.getId().equals(plotId)) {
                  deniedPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
                }
              }
            }
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + denied+ ""String_Node_Str""+ C(""String_Node_Str""));
            if (isAdvancedLogging()) {
              if (price == 0) {
                serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().getID());
              }
 else {
                serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().getID()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
              }
            }
          }
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId().getID()+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41961,"public static Vector locationToVector(Location location){
  return new Vector(location.getX(),location.getY(),location.getZ());
}","public static Vector locationToVector(org.bukkit.Location location){
  return new Vector(location.getX(),location.getY(),location.getZ());
}"
41962,"@Override public boolean setBlock(Vector location,BaseBlock block) throws WorldEditException {
  if (manager.isPlayerIgnoringWELimit(player)) {
    return extent.setBlock(location,block);
  }
 else {
    ILocation loc=new ILocation(player.getWorld(),location.getX(),location.getY(),location.getZ());
    Plot plot=manager.getPlot(loc);
    return plot != null && plot.isAllowed(actor.getUniqueId()) && extent.setBlock(location,block);
  }
}","@Override public boolean setBlock(Vector location,BaseBlock block) throws WorldEditException {
  if (manager.isPlayerIgnoringWELimit(player)) {
    return extent.setBlock(location,block);
  }
 else {
    Location loc=new Location(player.getWorld(),location.getX(),location.getY(),location.getZ());
    Plot plot=manager.getPlot(loc);
    return plot != null && plot.isAllowed(actor.getUniqueId()) && extent.setBlock(location,block);
  }
}"
41963,"@Override public boolean setBiome(Vector2D position,BaseBiome biome){
  if (manager.isPlayerIgnoringWELimit(player)) {
    return extent.setBiome(position,biome);
  }
 else {
    ILocation loc=new ILocation(player.getWorld(),position.getX(),0,position.getZ());
    Plot plot=manager.getPlot(loc);
    return plot != null && plot.isAllowed(actor.getUniqueId()) && extent.setBiome(position,biome);
  }
}","@Override public boolean setBiome(Vector2D position,BaseBiome biome){
  if (manager.isPlayerIgnoringWELimit(player)) {
    return extent.setBiome(position,biome);
  }
 else {
    Location loc=new Location(player.getWorld(),position.getX(),0,position.getZ());
    Plot plot=manager.getPlot(loc);
    return plot != null && plot.isAllowed(actor.getUniqueId()) && extent.setBiome(position,biome);
  }
}"
41964,"@SuppressWarnings(""String_Node_Str"") public Schematic createCompiledSchematic(IWorld world,com.worldcretornica.plotme_core.api.Vector loc1,com.worldcretornica.plotme_core.api.Vector loc2){
  Schematic schem;
  int minX=Math.min(loc1.getBlockX(),loc2.getBlockX());
  int maxX=Math.max(loc1.getBlockX(),loc2.getBlockX());
  int minY=Math.min(loc1.getBlockY(),loc2.getBlockY());
  int maxY=Math.max(loc1.getBlockY(),loc2.getBlockY());
  int minZ=Math.min(loc1.getBlockZ(),loc2.getBlockZ());
  int maxZ=Math.max(loc1.getBlockZ(),loc2.getBlockZ());
  short length=(short)(maxZ - minZ + 1);
  short width=(short)(maxX - minX + 1);
  short height=(short)(maxY - minY + 1);
  int[] blocks=new int[length * width * height];
  byte[] blockData=new byte[length * width * height];
  List<Entity> entities=new ArrayList<>();
  List<TileEntity> tileentities=new ArrayList<>();
  for (int x=0; x < width; ++x) {
    for (int z=0; z < length; ++z) {
      for (int y=0; y < height; ++y) {
        int index=y * width * length + z * width + x;
        IBlock block=world.getBlockAt(x + minX,y + minY,z + minZ);
        blocks[index]=block.getTypeId();
        blockData[index]=block.getData();
        boolean isTileEntity=false;
        BlockState bs=block.getState();
        byte rot=0;
        byte skulltype=0;
        byte note=0;
        int record=0;
        int outputsignal=0;
        int transfercooldown=0;
        int levels=0;
        int primary=0;
        int secondary=0;
        int base=0;
        RecordItem recorditem=null;
        short delay=0;
        short maxnearbyentities=0;
        short maxspawndelay=0;
        short minspawndelay=0;
        short requiredplayerrange=0;
        short spawncount=0;
        short spawnrange=0;
        short burntime=0;
        short cooktime=0;
        short brewtime=0;
        String entityid=null;
        String customname=null;
        String id=null;
        String text1=null;
        String text2=null;
        String text3=null;
        String text4=null;
        String command=null;
        List<Item> items=null;
        List<Pattern> patterns=null;
        if (bs instanceof Skull) {
          Skull skull=(Skull)bs;
switch (skull.getRotation()) {
case NORTH:
            rot=0;
          break;
case NORTH_NORTH_EAST:
        rot=1;
      break;
case UP:
    break;
case DOWN:
  break;
case NORTH_EAST:
rot=2;
break;
case EAST_NORTH_EAST:
rot=3;
break;
case EAST:
rot=4;
break;
case EAST_SOUTH_EAST:
rot=5;
break;
case SOUTH_EAST:
rot=6;
break;
case SOUTH_SOUTH_EAST:
rot=7;
break;
case SOUTH:
rot=8;
break;
case SOUTH_SOUTH_WEST:
rot=9;
break;
case SOUTH_WEST:
rot=10;
break;
case WEST_SOUTH_WEST:
rot=11;
break;
case WEST:
rot=12;
break;
case WEST_NORTH_WEST:
rot=13;
break;
case NORTH_WEST:
rot=14;
break;
case NORTH_NORTH_WEST:
rot=15;
break;
case SELF:
break;
default :
rot=0;
break;
}
skulltype=(byte)skull.getSkullType().ordinal();
isTileEntity=true;
}
if (bs instanceof CreatureSpawner) {
CreatureSpawner spawner=(CreatureSpawner)bs;
entityid=spawner.getCreatureTypeName();
delay=(short)spawner.getDelay();
isTileEntity=true;
}
if (bs instanceof Furnace) {
Furnace furnace=(Furnace)bs;
burntime=furnace.getBurnTime();
cooktime=furnace.getCookTime();
isTileEntity=true;
}
if (bs instanceof Sign) {
Sign sign=(Sign)bs;
text1=sign.getLine(0);
text2=sign.getLine(1);
text3=sign.getLine(2);
text4=sign.getLine(3);
isTileEntity=true;
}
if (bs instanceof CommandBlock) {
CommandBlock cb=(CommandBlock)bs;
command=cb.getCommand();
isTileEntity=true;
}
if (bs instanceof BrewingStand) {
BrewingStand brew=(BrewingStand)bs;
brewtime=(short)brew.getBrewingTime();
isTileEntity=true;
}
if (bs instanceof Jukebox) {
Jukebox jb=(Jukebox)bs;
record=jb.getPlaying().getId();
isTileEntity=true;
}
if (bs instanceof NoteBlock) {
NoteBlock nb=(NoteBlock)bs;
note=nb.getRawNote();
isTileEntity=true;
}
if (bs instanceof InventoryHolder) {
InventoryHolder ih=(InventoryHolder)bs;
Inventory inventory=ih.getInventory();
if (inventory.getSize() > 0) {
items=new ArrayList<>();
for (byte slot=0; slot < inventory.getSize(); slot++) {
ItemStack is=inventory.getItem(slot);
if (is != null) {
Item item=getItem(is,slot);
items.add(item);
}
}
}
isTileEntity=true;
}
if (bs instanceof Banner) {
Banner banner=(Banner)bs;
patterns=new ArrayList<>();
base=(int)banner.getBaseColor().getDyeData();
for (org.bukkit.block.banner.Pattern pattern : banner.getPatterns()) {
patterns.add(new Pattern((int)pattern.getColor().getDyeData(),pattern.getPattern().getIdentifier()));
}
isTileEntity=true;
}
if (isTileEntity) {
TileEntity te=new TileEntity(x,y,z,customname,id,items,rot,skulltype,delay,maxnearbyentities,maxspawndelay,minspawndelay,requiredplayerrange,spawncount,spawnrange,entityid,burntime,cooktime,text1,text2,text3,text4,note,record,recorditem,brewtime,command,outputsignal,transfercooldown,levels,primary,secondary,patterns,base);
tileentities.add(te);
}
}
}
}
for (IEntity bukkitentity : world.getEntities()) {
ILocation entloc=bukkitentity.getLocation();
if (entloc.getX() >= minX && entloc.getX() <= maxX && entloc.getY() >= minY && entloc.getY() <= maxY && entloc.getZ() >= minZ && entloc.getZ() <= maxZ && !(bukkitentity instanceof Player)) {
entities.add(getEntity(bukkitentity,minX,minY,minZ));
}
}
schem=new Schematic(blocks,blockData,""String_Node_Str"",width,length,height,entities,tileentities,0,0,0);
return schem;
}","@SuppressWarnings(""String_Node_Str"") public Schematic createCompiledSchematic(IWorld world,com.worldcretornica.plotme_core.api.Vector loc1,com.worldcretornica.plotme_core.api.Vector loc2){
  Schematic schem;
  int minX=Math.min(loc1.getBlockX(),loc2.getBlockX());
  int maxX=Math.max(loc1.getBlockX(),loc2.getBlockX());
  int minY=Math.min(loc1.getBlockY(),loc2.getBlockY());
  int maxY=Math.max(loc1.getBlockY(),loc2.getBlockY());
  int minZ=Math.min(loc1.getBlockZ(),loc2.getBlockZ());
  int maxZ=Math.max(loc1.getBlockZ(),loc2.getBlockZ());
  short length=(short)(maxZ - minZ + 1);
  short width=(short)(maxX - minX + 1);
  short height=(short)(maxY - minY + 1);
  int[] blocks=new int[length * width * height];
  byte[] blockData=new byte[length * width * height];
  List<Entity> entities=new ArrayList<>();
  List<TileEntity> tileentities=new ArrayList<>();
  for (int x=0; x < width; ++x) {
    for (int z=0; z < length; ++z) {
      for (int y=0; y < height; ++y) {
        int index=y * width * length + z * width + x;
        IBlock block=world.getBlockAt(x + minX,y + minY,z + minZ);
        blocks[index]=block.getTypeId();
        blockData[index]=block.getData();
        boolean isTileEntity=false;
        BlockState bs=block.getState();
        byte rot=0;
        byte skulltype=0;
        byte note=0;
        int record=0;
        int outputsignal=0;
        int transfercooldown=0;
        int levels=0;
        int primary=0;
        int secondary=0;
        int base=0;
        RecordItem recorditem=null;
        short delay=0;
        short maxnearbyentities=0;
        short maxspawndelay=0;
        short minspawndelay=0;
        short requiredplayerrange=0;
        short spawncount=0;
        short spawnrange=0;
        short burntime=0;
        short cooktime=0;
        short brewtime=0;
        String entityid=null;
        String customname=null;
        String id=null;
        String text1=null;
        String text2=null;
        String text3=null;
        String text4=null;
        String command=null;
        List<Item> items=null;
        List<Pattern> patterns=null;
        if (bs instanceof Skull) {
          Skull skull=(Skull)bs;
switch (skull.getRotation()) {
case NORTH:
            rot=0;
          break;
case NORTH_NORTH_EAST:
        rot=1;
      break;
case UP:
    break;
case DOWN:
  break;
case NORTH_EAST:
rot=2;
break;
case EAST_NORTH_EAST:
rot=3;
break;
case EAST:
rot=4;
break;
case EAST_SOUTH_EAST:
rot=5;
break;
case SOUTH_EAST:
rot=6;
break;
case SOUTH_SOUTH_EAST:
rot=7;
break;
case SOUTH:
rot=8;
break;
case SOUTH_SOUTH_WEST:
rot=9;
break;
case SOUTH_WEST:
rot=10;
break;
case WEST_SOUTH_WEST:
rot=11;
break;
case WEST:
rot=12;
break;
case WEST_NORTH_WEST:
rot=13;
break;
case NORTH_WEST:
rot=14;
break;
case NORTH_NORTH_WEST:
rot=15;
break;
case SELF:
break;
default :
rot=0;
break;
}
skulltype=(byte)skull.getSkullType().ordinal();
isTileEntity=true;
}
if (bs instanceof CreatureSpawner) {
CreatureSpawner spawner=(CreatureSpawner)bs;
entityid=spawner.getCreatureTypeName();
delay=(short)spawner.getDelay();
isTileEntity=true;
}
if (bs instanceof Furnace) {
Furnace furnace=(Furnace)bs;
burntime=furnace.getBurnTime();
cooktime=furnace.getCookTime();
isTileEntity=true;
}
if (bs instanceof Sign) {
Sign sign=(Sign)bs;
text1=sign.getLine(0);
text2=sign.getLine(1);
text3=sign.getLine(2);
text4=sign.getLine(3);
isTileEntity=true;
}
if (bs instanceof CommandBlock) {
CommandBlock cb=(CommandBlock)bs;
command=cb.getCommand();
isTileEntity=true;
}
if (bs instanceof BrewingStand) {
BrewingStand brew=(BrewingStand)bs;
brewtime=(short)brew.getBrewingTime();
isTileEntity=true;
}
if (bs instanceof Jukebox) {
Jukebox jb=(Jukebox)bs;
record=jb.getPlaying().getId();
isTileEntity=true;
}
if (bs instanceof NoteBlock) {
NoteBlock nb=(NoteBlock)bs;
note=nb.getRawNote();
isTileEntity=true;
}
if (bs instanceof InventoryHolder) {
InventoryHolder ih=(InventoryHolder)bs;
Inventory inventory=ih.getInventory();
if (inventory.getSize() > 0) {
items=new ArrayList<>();
for (byte slot=0; slot < inventory.getSize(); slot++) {
ItemStack is=inventory.getItem(slot);
if (is != null) {
Item item=getItem(is,slot);
items.add(item);
}
}
}
isTileEntity=true;
}
if (bs instanceof Banner) {
Banner banner=(Banner)bs;
patterns=new ArrayList<>();
base=(int)banner.getBaseColor().getDyeData();
for (org.bukkit.block.banner.Pattern pattern : banner.getPatterns()) {
patterns.add(new Pattern((int)pattern.getColor().getDyeData(),pattern.getPattern().getIdentifier()));
}
isTileEntity=true;
}
if (isTileEntity) {
TileEntity te=new TileEntity(x,y,z,customname,id,items,rot,skulltype,delay,maxnearbyentities,maxspawndelay,minspawndelay,requiredplayerrange,spawncount,spawnrange,entityid,burntime,cooktime,text1,text2,text3,text4,note,record,recorditem,brewtime,command,outputsignal,transfercooldown,levels,primary,secondary,patterns,base);
tileentities.add(te);
}
}
}
}
for (IEntity bukkitentity : world.getEntities()) {
Location entloc=bukkitentity.getLocation();
if (entloc.getX() >= minX && entloc.getX() <= maxX && entloc.getY() >= minY && entloc.getY() <= maxY && entloc.getZ() >= minZ && entloc.getZ() <= maxZ && !(bukkitentity instanceof Player)) {
entities.add(getEntity(bukkitentity,minX,minY,minZ));
}
}
schem=new Schematic(blocks,blockData,""String_Node_Str"",width,length,height,entities,tileentities,0,0,0);
return schem;
}"
41965,"private org.bukkit.entity.Entity createEntity(IWorld world,Entity e,com.worldcretornica.plotme_core.api.Vector loc,int originX,int originY,int originZ){
  try {
    @SuppressWarnings(""String_Node_Str"") EntityType entitytype=EntityType.fromName(e.getId());
    org.bukkit.entity.Entity ent=null;
    if (entitytype != null && e.getPos() != null && e.getPos().size() == 3) {
      List<Double> positions=e.getPos();
      double x=positions.get(0) - originX;
      double y=positions.get(1) - originY;
      double z=positions.get(2) - originZ;
      Byte dir=e.getDir();
      byte onground=e.getOnGround();
      byte canpickuploot=e.getCanPickupLoot();
      byte color=e.getColor();
      byte customnamevisible=e.getCustomNameVisible();
      byte persistencerequired=e.getPersistenceRequired();
      byte sheared=e.getSheared();
      byte skeletontype=e.getSkeletonType();
      byte isbaby=e.getIsBaby();
      byte itemrotation=e.getItemRotation();
      byte agelocked=e.getAgeLocked();
      byte invisible=e.getInvisible();
      byte nobaseplate=e.getNoBasePlate();
      byte nogravity=e.getNoGravity();
      byte showarms=e.getShowArms();
      byte small=e.getSmall();
      byte elder=e.getElder();
      byte chestedhorse=e.getChestedHorse();
      byte tame=e.getTame();
      byte facing=e.getFacing();
      Entity riding=e.getRiding();
      float falldistance=e.getFallDistance();
      float healf=e.getHealF();
      int age=e.getAge();
      int hurtbytimestamp=e.getHurtByTimestamp();
      int rabbittype=e.getRabbitType();
      int temper=e.getTemper();
      int type=e.getType();
      int variant=e.getVariant();
      Item item=e.getItem();
      Leash leash=e.getLeash();
      Pose pose=e.getPose();
      short air=e.getAir();
      short fire=e.getFire();
      String motive=e.getMotive();
      String customname=e.getCustomName();
      String owneruuid=e.getOwnerUUID();
      List<Double> motion=e.getMotion();
      List<Attribute> attributes=e.getAttributes();
      Item itemheld=e.getItemHeld();
      Item feetarmor=e.getFeetArmor();
      Item legarmor=e.getLegArmor();
      Item chestarmor=e.getChestArmor();
      Item headarmor=e.getHeadArmor();
      List<Item> items=e.getItems();
      Location etloc=new Location(((BukkitWorld)world).getWorld(),x + loc.getBlockX(),y + loc.getBlockY(),z + loc.getBlockZ());
      if (entitytype == EntityType.ITEM_FRAME) {
        etloc.setX(Math.floor(etloc.getX()));
        etloc.setY(Math.floor(etloc.getY()));
        etloc.setZ(Math.floor(etloc.getZ()));
        ent=world.spawnEntity(etloc,EntityType.ITEM_FRAME);
      }
 else       if (entitytype == EntityType.PAINTING) {
        etloc.setX(Math.floor(etloc.getX()));
        etloc.setY(Math.floor(etloc.getY()));
        etloc.setZ(Math.floor(etloc.getZ()));
        ent=world.spawnEntity(etloc,EntityType.PAINTING);
        Painting painting=(Painting)ent;
        BlockFace bf=BlockFace.SOUTH;
switch (facing) {
case 0:
          bf=BlockFace.SOUTH;
        break;
case 1:
      bf=BlockFace.WEST;
    break;
case 2:
  bf=BlockFace.NORTH;
break;
case 3:
bf=BlockFace.EAST;
break;
}
painting.setArt(Art.getByName(motive),true);
painting.setFacingDirection(bf,true);
}
 else if (entitytype == EntityType.LEASH_HITCH) {
return null;
}
 else if (entitytype == EntityType.DROPPED_ITEM) {
if (item == null) {
return null;
}
 else {
@SuppressWarnings(""String_Node_Str"") ItemStack is=new ItemStack(item.getId(),item.getCount());
ItemTag itemtag=item.getTag();
if (itemtag != null) {
setTag(is,itemtag);
}
ent=((BukkitWorld)world).getWorld().dropItem(etloc,is);
}
}
 else {
ent=world.spawnEntity(etloc,entitytype);
}
if (riding != null) {
ent.setPassenger(createEntity(world,riding,loc,originX,originY,originZ));
}
ent.setFallDistance(falldistance);
ent.setFireTicks(fire);
ent.setTicksLived(age);
if (motion != null && motion.size() == 3) {
Vector velocity=new Vector(motion.get(0),motion.get(1),motion.get(2));
ent.setVelocity(velocity);
}
if (ent instanceof InventoryHolder) {
InventoryHolder ih=(InventoryHolder)ent;
Set<ItemStack> newitems=new HashSet<>();
if (items != null && !items.isEmpty()) {
for (Item newitem : items) {
ItemStack is=getItemStack(newitem);
ItemTag itemtag=newitem.getTag();
if (itemtag != null) {
setTag(is,itemtag);
}
newitems.add(is);
}
}
ih.getInventory().setContents(newitems.toArray(new ItemStack[newitems.size()]));
}
if (ent instanceof ItemFrame) {
ItemFrame itemframe=(ItemFrame)ent;
itemframe.setRotation(Rotation.values()[itemrotation]);
ItemStack is=getItemStack(item);
ItemTag itemtag=item.getTag();
if (itemtag != null) {
setTag(is,itemtag);
}
itemframe.setItem(is);
}
if (ent instanceof LivingEntity) {
LivingEntity livingentity=(LivingEntity)ent;
livingentity.setCanPickupItems(canpickuploot != 0);
if (customname != null) {
livingentity.setCustomName(customname);
}
livingentity.setCustomNameVisible(customnamevisible != 0);
livingentity.setRemainingAir(air);
livingentity.setRemoveWhenFarAway(persistencerequired == 0);
if (leash != null) {
org.bukkit.entity.Entity leashentity=getLeash(world,leash,loc,originX,originY,originZ);
if (leashentity != null) {
livingentity.setLeashHolder(leashentity);
}
}
livingentity.setNoDamageTicks(hurtbytimestamp);
if (livingentity.getMaxHealth() < healf) {
livingentity.setMaxHealth(healf);
}
livingentity.setHealth(healf);
EntityEquipment entityequipment=livingentity.getEquipment();
if (itemheld != null) {
entityequipment.setItemInHand(getItemStack(itemheld));
}
if (feetarmor != null) {
entityequipment.setBoots(getItemStack(feetarmor));
}
if (legarmor != null) {
entityequipment.setLeggings(getItemStack(legarmor));
}
if (chestarmor != null) {
entityequipment.setChestplate(getItemStack(chestarmor));
}
if (headarmor != null) {
entityequipment.setHelmet(getItemStack(headarmor));
}
if (livingentity instanceof Ageable) {
Ageable ageable=(Ageable)livingentity;
ageable.setAge(age);
ageable.setAgeLock(agelocked != 0);
if (isbaby != 0) {
ageable.setBaby();
}
 else {
ageable.setAdult();
}
}
if (livingentity instanceof Tameable) {
Tameable tameable=(Tameable)livingentity;
if (owneruuid != null) {
tameable.setOwner(Bukkit.getOfflinePlayer(UUID.fromString(owneruuid)));
}
tameable.setTamed(tame != 0);
}
if (livingentity instanceof Skeleton) {
Skeleton skeleton=(Skeleton)livingentity;
SkeletonType st;
if (skeletontype == 0) {
st=SkeletonType.NORMAL;
}
 else {
st=SkeletonType.WITHER;
}
skeleton.setSkeletonType(st);
}
 else if (livingentity instanceof Rabbit) {
Rabbit rabbit=(Rabbit)livingentity;
switch (rabbittype) {
case 0:
rabbit.setRabbitType(Rabbit.Type.BROWN);
break;
case 1:
rabbit.setRabbitType(Rabbit.Type.WHITE);
break;
case 2:
rabbit.setRabbitType(Rabbit.Type.BLACK);
break;
case 3:
rabbit.setRabbitType(Rabbit.Type.BLACK_AND_WHITE);
break;
case 4:
rabbit.setRabbitType(Rabbit.Type.GOLD);
break;
case 5:
rabbit.setRabbitType(Rabbit.Type.SALT_AND_PEPPER);
break;
case 99:
rabbit.setRabbitType(Rabbit.Type.THE_KILLER_BUNNY);
break;
}
}
 else if (livingentity instanceof ArmorStand) {
ArmorStand armorstand=(ArmorStand)livingentity;
armorstand.setArms(showarms != 0);
armorstand.setBasePlate(nobaseplate == 0);
armorstand.setVisible(invisible == 0);
armorstand.setGravity(nogravity == 0);
armorstand.setSmall(small != 0);
if (pose != null) {
List<Float> body=pose.getBody();
List<Float> head=pose.getHead();
List<Float> leftarm=pose.getLeftArm();
List<Float> rightarm=pose.getRightArm();
List<Float> leftleg=pose.getLeftLeg();
List<Float> rightleg=pose.getRightLeg();
if (body != null && body.size() == 3) {
armorstand.setBodyPose(new EulerAngle(body.get(0),body.get(1),body.get(2)));
}
if (head != null && head.size() == 3) {
armorstand.setHeadPose(new EulerAngle(head.get(0),head.get(1),head.get(2)));
}
if (leftarm != null && leftarm.size() == 3) {
armorstand.setLeftArmPose(new EulerAngle(leftarm.get(0),leftarm.get(1),leftarm.get(2)));
}
if (rightarm != null && rightarm.size() == 3) {
armorstand.setRightArmPose(new EulerAngle(rightarm.get(0),rightarm.get(1),rightarm.get(2)));
}
if (leftleg != null && leftleg.size() == 3) {
armorstand.setLeftLegPose(new EulerAngle(leftleg.get(0),leftleg.get(1),leftleg.get(2)));
}
if (rightleg != null && rightleg.size() == 3) {
armorstand.setRightLegPose(new EulerAngle(rightleg.get(0),rightleg.get(1),rightleg.get(2)));
}
}
}
 else if (livingentity instanceof Guardian) {
Guardian guardian=(Guardian)livingentity;
guardian.setElder(elder != 0);
}
 else if (livingentity instanceof Sheep) {
Sheep sheep=(Sheep)livingentity;
sheep.setSheared(sheared != 0);
@SuppressWarnings(""String_Node_Str"") DyeColor dyecolor=DyeColor.getByWoolData(color);
if (dyecolor != null) {
sheep.setColor(dyecolor);
}
}
 else if (livingentity instanceof Horse) {
Horse horse=(Horse)livingentity;
if (attributes != null) {
for (Attribute attribute : attributes) {
if (""String_Node_Str"".equalsIgnoreCase(attribute.getName())) {
horse.setJumpStrength(attribute.getBase());
}
}
}
horse.setCarryingChest(chestedhorse != 0);
horse.setDomestication(temper);
switch (variant) {
case 0:
horse.setVariant(Variant.HORSE);
break;
case 1:
horse.setVariant(Variant.DONKEY);
break;
case 2:
horse.setVariant(Variant.MULE);
break;
case 3:
horse.setVariant(Variant.UNDEAD_HORSE);
break;
case 4:
horse.setVariant(Variant.SKELETON_HORSE);
break;
}
if (type < 256) {
horse.setStyle(Style.NONE);
}
 else if (type < 512) {
horse.setStyle(Style.WHITE);
}
 else if (type < 768) {
horse.setStyle(Style.WHITEFIELD);
}
 else if (type < 1024) {
horse.setStyle(Style.WHITE_DOTS);
}
 else {
horse.setStyle(Style.BLACK_DOTS);
}
switch ((int)((double)type) % 256) {
case 0:
horse.setColor(Horse.Color.WHITE);
break;
case 1:
horse.setColor(Horse.Color.CREAMY);
break;
case 2:
horse.setColor(Horse.Color.CHESTNUT);
break;
case 3:
horse.setColor(Horse.Color.BROWN);
break;
case 4:
horse.setColor(Horse.Color.BLACK);
break;
case 5:
horse.setColor(Horse.Color.GRAY);
break;
case 6:
horse.setColor(Horse.Color.DARK_BROWN);
break;
}
}
}
}
if (ent == null) {
plugin.getLogger().info(""String_Node_Str"");
}
return ent;
}
 catch (IllegalArgumentException ex) {
plugin.getLogger().info(""String_Node_Str"");
ex.printStackTrace();
return null;
}
}","private org.bukkit.entity.Entity createEntity(IWorld world,Entity e,com.worldcretornica.plotme_core.api.Vector loc,int originX,int originY,int originZ){
  try {
    @SuppressWarnings(""String_Node_Str"") EntityType entitytype=EntityType.fromName(e.getId());
    org.bukkit.entity.Entity ent=null;
    if (entitytype != null && e.getPos() != null && e.getPos().size() == 3) {
      List<Double> positions=e.getPos();
      double x=positions.get(0) - originX;
      double y=positions.get(1) - originY;
      double z=positions.get(2) - originZ;
      Byte dir=e.getDir();
      byte onground=e.getOnGround();
      byte canpickuploot=e.getCanPickupLoot();
      byte color=e.getColor();
      byte customnamevisible=e.getCustomNameVisible();
      byte persistencerequired=e.getPersistenceRequired();
      byte sheared=e.getSheared();
      byte skeletontype=e.getSkeletonType();
      byte isbaby=e.getIsBaby();
      byte itemrotation=e.getItemRotation();
      byte agelocked=e.getAgeLocked();
      byte invisible=e.getInvisible();
      byte nobaseplate=e.getNoBasePlate();
      byte nogravity=e.getNoGravity();
      byte showarms=e.getShowArms();
      byte small=e.getSmall();
      byte elder=e.getElder();
      byte chestedhorse=e.getChestedHorse();
      byte tame=e.getTame();
      byte facing=e.getFacing();
      Entity riding=e.getRiding();
      float falldistance=e.getFallDistance();
      float healf=e.getHealF();
      int age=e.getAge();
      int hurtbytimestamp=e.getHurtByTimestamp();
      int rabbittype=e.getRabbitType();
      int temper=e.getTemper();
      int type=e.getType();
      int variant=e.getVariant();
      Item item=e.getItem();
      Leash leash=e.getLeash();
      Pose pose=e.getPose();
      short air=e.getAir();
      short fire=e.getFire();
      String motive=e.getMotive();
      String customname=e.getCustomName();
      String owneruuid=e.getOwnerUUID();
      List<Double> motion=e.getMotion();
      List<Attribute> attributes=e.getAttributes();
      Item itemheld=e.getItemHeld();
      Item feetarmor=e.getFeetArmor();
      Item legarmor=e.getLegArmor();
      Item chestarmor=e.getChestArmor();
      Item headarmor=e.getHeadArmor();
      List<Item> items=e.getItems();
      org.bukkit.Location etloc=new org.bukkit.Location(((BukkitWorld)world).getWorld(),x + loc.getBlockX(),y + loc.getBlockY(),z + loc.getBlockZ());
      if (entitytype == EntityType.ITEM_FRAME) {
        etloc.setX(Math.floor(etloc.getX()));
        etloc.setY(Math.floor(etloc.getY()));
        etloc.setZ(Math.floor(etloc.getZ()));
        ent=world.spawnEntity(etloc,EntityType.ITEM_FRAME);
      }
 else       if (entitytype == EntityType.PAINTING) {
        etloc.setX(Math.floor(etloc.getX()));
        etloc.setY(Math.floor(etloc.getY()));
        etloc.setZ(Math.floor(etloc.getZ()));
        ent=world.spawnEntity(etloc,EntityType.PAINTING);
        Painting painting=(Painting)ent;
        BlockFace bf=BlockFace.SOUTH;
switch (facing) {
case 0:
          bf=BlockFace.SOUTH;
        break;
case 1:
      bf=BlockFace.WEST;
    break;
case 2:
  bf=BlockFace.NORTH;
break;
case 3:
bf=BlockFace.EAST;
break;
}
painting.setArt(Art.getByName(motive),true);
painting.setFacingDirection(bf,true);
}
 else if (entitytype == EntityType.LEASH_HITCH) {
return null;
}
 else if (entitytype == EntityType.DROPPED_ITEM) {
if (item == null) {
return null;
}
 else {
@SuppressWarnings(""String_Node_Str"") ItemStack is=new ItemStack(item.getId(),item.getCount());
ItemTag itemtag=item.getTag();
if (itemtag != null) {
setTag(is,itemtag);
}
ent=((BukkitWorld)world).getWorld().dropItem(etloc,is);
}
}
 else {
ent=world.spawnEntity(etloc,entitytype);
}
if (riding != null) {
ent.setPassenger(createEntity(world,riding,loc,originX,originY,originZ));
}
ent.setFallDistance(falldistance);
ent.setFireTicks(fire);
ent.setTicksLived(age);
if (motion != null && motion.size() == 3) {
Vector velocity=new Vector(motion.get(0),motion.get(1),motion.get(2));
ent.setVelocity(velocity);
}
if (ent instanceof InventoryHolder) {
InventoryHolder ih=(InventoryHolder)ent;
Set<ItemStack> newitems=new HashSet<>();
if (items != null && !items.isEmpty()) {
for (Item newitem : items) {
ItemStack is=getItemStack(newitem);
ItemTag itemtag=newitem.getTag();
if (itemtag != null) {
setTag(is,itemtag);
}
newitems.add(is);
}
}
ih.getInventory().setContents(newitems.toArray(new ItemStack[newitems.size()]));
}
if (ent instanceof ItemFrame) {
ItemFrame itemframe=(ItemFrame)ent;
itemframe.setRotation(Rotation.values()[itemrotation]);
ItemStack is=getItemStack(item);
ItemTag itemtag=item.getTag();
if (itemtag != null) {
setTag(is,itemtag);
}
itemframe.setItem(is);
}
if (ent instanceof LivingEntity) {
LivingEntity livingentity=(LivingEntity)ent;
livingentity.setCanPickupItems(canpickuploot != 0);
if (customname != null) {
livingentity.setCustomName(customname);
}
livingentity.setCustomNameVisible(customnamevisible != 0);
livingentity.setRemainingAir(air);
livingentity.setRemoveWhenFarAway(persistencerequired == 0);
if (leash != null) {
org.bukkit.entity.Entity leashentity=getLeash(world,leash,loc,originX,originY,originZ);
if (leashentity != null) {
livingentity.setLeashHolder(leashentity);
}
}
livingentity.setNoDamageTicks(hurtbytimestamp);
if (livingentity.getMaxHealth() < healf) {
livingentity.setMaxHealth(healf);
}
livingentity.setHealth(healf);
EntityEquipment entityequipment=livingentity.getEquipment();
if (itemheld != null) {
entityequipment.setItemInHand(getItemStack(itemheld));
}
if (feetarmor != null) {
entityequipment.setBoots(getItemStack(feetarmor));
}
if (legarmor != null) {
entityequipment.setLeggings(getItemStack(legarmor));
}
if (chestarmor != null) {
entityequipment.setChestplate(getItemStack(chestarmor));
}
if (headarmor != null) {
entityequipment.setHelmet(getItemStack(headarmor));
}
if (livingentity instanceof Ageable) {
Ageable ageable=(Ageable)livingentity;
ageable.setAge(age);
ageable.setAgeLock(agelocked != 0);
if (isbaby != 0) {
ageable.setBaby();
}
 else {
ageable.setAdult();
}
}
if (livingentity instanceof Tameable) {
Tameable tameable=(Tameable)livingentity;
if (owneruuid != null) {
tameable.setOwner(Bukkit.getOfflinePlayer(UUID.fromString(owneruuid)));
}
tameable.setTamed(tame != 0);
}
if (livingentity instanceof Skeleton) {
Skeleton skeleton=(Skeleton)livingentity;
SkeletonType st;
if (skeletontype == 0) {
st=SkeletonType.NORMAL;
}
 else {
st=SkeletonType.WITHER;
}
skeleton.setSkeletonType(st);
}
 else if (livingentity instanceof Rabbit) {
Rabbit rabbit=(Rabbit)livingentity;
switch (rabbittype) {
case 0:
rabbit.setRabbitType(Rabbit.Type.BROWN);
break;
case 1:
rabbit.setRabbitType(Rabbit.Type.WHITE);
break;
case 2:
rabbit.setRabbitType(Rabbit.Type.BLACK);
break;
case 3:
rabbit.setRabbitType(Rabbit.Type.BLACK_AND_WHITE);
break;
case 4:
rabbit.setRabbitType(Rabbit.Type.GOLD);
break;
case 5:
rabbit.setRabbitType(Rabbit.Type.SALT_AND_PEPPER);
break;
case 99:
rabbit.setRabbitType(Rabbit.Type.THE_KILLER_BUNNY);
break;
}
}
 else if (livingentity instanceof ArmorStand) {
ArmorStand armorstand=(ArmorStand)livingentity;
armorstand.setArms(showarms != 0);
armorstand.setBasePlate(nobaseplate == 0);
armorstand.setVisible(invisible == 0);
armorstand.setGravity(nogravity == 0);
armorstand.setSmall(small != 0);
if (pose != null) {
List<Float> body=pose.getBody();
List<Float> head=pose.getHead();
List<Float> leftarm=pose.getLeftArm();
List<Float> rightarm=pose.getRightArm();
List<Float> leftleg=pose.getLeftLeg();
List<Float> rightleg=pose.getRightLeg();
if (body != null && body.size() == 3) {
armorstand.setBodyPose(new EulerAngle(body.get(0),body.get(1),body.get(2)));
}
if (head != null && head.size() == 3) {
armorstand.setHeadPose(new EulerAngle(head.get(0),head.get(1),head.get(2)));
}
if (leftarm != null && leftarm.size() == 3) {
armorstand.setLeftArmPose(new EulerAngle(leftarm.get(0),leftarm.get(1),leftarm.get(2)));
}
if (rightarm != null && rightarm.size() == 3) {
armorstand.setRightArmPose(new EulerAngle(rightarm.get(0),rightarm.get(1),rightarm.get(2)));
}
if (leftleg != null && leftleg.size() == 3) {
armorstand.setLeftLegPose(new EulerAngle(leftleg.get(0),leftleg.get(1),leftleg.get(2)));
}
if (rightleg != null && rightleg.size() == 3) {
armorstand.setRightLegPose(new EulerAngle(rightleg.get(0),rightleg.get(1),rightleg.get(2)));
}
}
}
 else if (livingentity instanceof Guardian) {
Guardian guardian=(Guardian)livingentity;
guardian.setElder(elder != 0);
}
 else if (livingentity instanceof Sheep) {
Sheep sheep=(Sheep)livingentity;
sheep.setSheared(sheared != 0);
@SuppressWarnings(""String_Node_Str"") DyeColor dyecolor=DyeColor.getByWoolData(color);
if (dyecolor != null) {
sheep.setColor(dyecolor);
}
}
 else if (livingentity instanceof Horse) {
Horse horse=(Horse)livingentity;
if (attributes != null) {
for (Attribute attribute : attributes) {
if (""String_Node_Str"".equalsIgnoreCase(attribute.getName())) {
horse.setJumpStrength(attribute.getBase());
}
}
}
horse.setCarryingChest(chestedhorse != 0);
horse.setDomestication(temper);
switch (variant) {
case 0:
horse.setVariant(Variant.HORSE);
break;
case 1:
horse.setVariant(Variant.DONKEY);
break;
case 2:
horse.setVariant(Variant.MULE);
break;
case 3:
horse.setVariant(Variant.UNDEAD_HORSE);
break;
case 4:
horse.setVariant(Variant.SKELETON_HORSE);
break;
}
if (type < 256) {
horse.setStyle(Style.NONE);
}
 else if (type < 512) {
horse.setStyle(Style.WHITE);
}
 else if (type < 768) {
horse.setStyle(Style.WHITEFIELD);
}
 else if (type < 1024) {
horse.setStyle(Style.WHITE_DOTS);
}
 else {
horse.setStyle(Style.BLACK_DOTS);
}
switch ((int)((double)type) % 256) {
case 0:
horse.setColor(Horse.Color.WHITE);
break;
case 1:
horse.setColor(Horse.Color.CREAMY);
break;
case 2:
horse.setColor(Horse.Color.CHESTNUT);
break;
case 3:
horse.setColor(Horse.Color.BROWN);
break;
case 4:
horse.setColor(Horse.Color.BLACK);
break;
case 5:
horse.setColor(Horse.Color.GRAY);
break;
case 6:
horse.setColor(Horse.Color.DARK_BROWN);
break;
}
}
}
}
if (ent == null) {
plugin.getLogger().info(""String_Node_Str"");
}
return ent;
}
 catch (IllegalArgumentException ex) {
plugin.getLogger().info(""String_Node_Str"");
ex.printStackTrace();
return null;
}
}"
41966,"@Override public ILocation getLocation(){
  return new ILocation(getWorld(),getPosition());
}","@Override public Location getLocation(){
  return new Location(getWorld(),getPosition());
}"
41967,"@Override public ILocation getLocation(){
  return new ILocation(getWorld(),getPosition());
}","@Override public Location getLocation(){
  return new Location(getWorld(),getPosition());
}"
41968,"@Override public void setLocation(ILocation location){
  entity.teleport(new Location(((BukkitWorld)location.getWorld()).getWorld(),location.getX(),location.getY(),location.getZ()));
}","@Override public void setLocation(Location location){
  entity.teleport(new org.bukkit.Location(((BukkitWorld)location.getWorld()).getWorld(),location.getX(),location.getY(),location.getZ()));
}"
41969,"@Override public void teleport(ILocation location){
  PlotMe_CorePlugin.getInstance().getServerObjectBuilder().runTaskLater(new TeleportRunnable(this,location),PlotMe_CorePlugin.getInstance().getAPI().getConfig().getInt(""String_Node_Str""));
}","@Override public void teleport(Location location){
  PlotMe_CorePlugin.getInstance().getServerObjectBuilder().runTaskLater(new TeleportRunnable(this,location),PlotMe_CorePlugin.getInstance().getAPI().getConfig().getInt(""String_Node_Str""));
}"
41970,"@Override public ILocation getLocation(){
  return new ILocation(getWorld(),getPosition());
}","@Override public Location getLocation(){
  return new Location(getWorld(),getPosition());
}"
41971,"@Override public void setLocation(ILocation location){
  player.teleport(new Location(((BukkitWorld)location.getWorld()).getWorld(),location.getX(),location.getY(),location.getZ()));
}","@Override public void setLocation(Location location){
  player.teleport(new org.bukkit.Location(((BukkitWorld)location.getWorld()).getWorld(),location.getX(),location.getY(),location.getZ()));
}"
41972,"/** 
 * Uses the code that allows a delay while ""Teleporting"" or moving the entity
 * @param location new location
 */
@Override public void teleport(ILocation location){
  final int delay=PlotMe_CorePlugin.getInstance().getAPI().getConfig().getInt(""String_Node_Str"");
  player.sendMessage(String.format(""String_Node_Str"",delay));
  PlotMe_CorePlugin.getInstance().getServerObjectBuilder().runTaskLater(new TeleportRunnable(this,location),delay);
}","/** 
 * Uses the code that allows a delay while ""Teleporting"" or moving the entity
 * @param location new location
 */
@Override public void teleport(Location location){
  final int delay=PlotMe_CorePlugin.getInstance().getAPI().getConfig().getInt(""String_Node_Str"");
  player.sendMessage(String.format(""String_Node_Str"",delay));
  PlotMe_CorePlugin.getInstance().getServerObjectBuilder().runTaskLater(new TeleportRunnable(this,location),delay);
}"
41973,"@EventHandler(priority=EventPriority.HIGH) public void onPlayerMove(PlayerMoveEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  if (manager.isPlotWorld(player) && !player.hasPermission(PermissionNames.ADMIN_BYPASSDENY)) {
    ILocation to=new ILocation(player.getWorld(),BukkitUtil.locationToVector(event.getTo()));
    Plot plot=manager.getPlot(to);
    if (plot != null && plot.isDenied(player.getUniqueId())) {
      event.setTo(event.getFrom());
    }
  }
}","@EventHandler(priority=EventPriority.HIGH) public void onPlayerMove(PlayerMoveEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  if (manager.isPlotWorld(player) && !player.hasPermission(PermissionNames.ADMIN_BYPASSDENY)) {
    Location to=new Location(player.getWorld(),BukkitUtil.locationToVector(event.getTo()));
    Plot plot=manager.getPlot(to);
    if (plot != null && plot.isDenied(player.getUniqueId())) {
      event.setTo(event.getFrom());
    }
  }
}"
41974,"@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onBlockPistonExtend(BlockPistonExtendEvent event){
  BukkitWorld world=BukkitUtil.adapt(event.getBlock().getWorld());
  if (manager.isPlotWorld(world)) {
    BlockFace face=event.getDirection();
    for (    Block block : event.getBlocks()) {
      PlotId id=manager.getPlotId(new ILocation(world,BukkitUtil.locationToVector(block.getLocation().add(face.getModX(),face.getModY(),face.getModZ()))));
      if (id == null) {
        event.setCancelled(true);
      }
    }
  }
}","@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onBlockPistonExtend(BlockPistonExtendEvent event){
  BukkitWorld world=BukkitUtil.adapt(event.getBlock().getWorld());
  if (manager.isPlotWorld(world)) {
    BlockFace face=event.getDirection();
    for (    Block block : event.getBlocks()) {
      PlotId id=manager.getPlotId(new Location(world,BukkitUtil.locationToVector(block.getLocation().add(face.getModX(),face.getModY(),face.getModZ()))));
      if (id == null) {
        event.setCancelled(true);
      }
    }
  }
}"
41975,"@EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onBlockBreak(BlockBreakEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  Location bloc=event.getBlock().getLocation();
  ILocation location=new ILocation(player.getWorld(),bloc.getX(),bloc.getY(),bloc.getZ());
  if (manager.isPlotWorld(location)) {
    if (player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE)) {
      return;
    }
    Plot plot=manager.getPlot(location);
    if (plot == null || !plot.isAllowed(player.getUniqueId())) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else     if (api.isPlotLocked(plot)) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else {
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
  }
}","@EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onBlockBreak(BlockBreakEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  org.bukkit.Location bloc=event.getBlock().getLocation();
  Location location=new Location(player.getWorld(),bloc.getX(),bloc.getY(),bloc.getZ());
  if (manager.isPlotWorld(location)) {
    if (player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE)) {
      return;
    }
    Plot plot=manager.getPlot(location);
    if (plot == null || !plot.isAllowed(player.getUniqueId())) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else     if (api.isPlotLocked(plot)) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else {
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
  }
}"
41976,"@EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onStructureGrow(StructureGrowEvent event){
  BukkitWorld world=new BukkitWorld(event.getWorld());
  if (manager.isPlotWorld(world)) {
    for (int i=0; i < event.getBlocks().size(); i++) {
      PlotId id=manager.getPlotId(new ILocation(world,BukkitUtil.locationToVector(event.getBlocks().get(i).getLocation())));
      if (id == null) {
        event.getBlocks().remove(i);
        i--;
      }
    }
  }
}","@EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onStructureGrow(StructureGrowEvent event){
  BukkitWorld world=new BukkitWorld(event.getWorld());
  if (manager.isPlotWorld(world)) {
    for (int i=0; i < event.getBlocks().size(); i++) {
      PlotId id=manager.getPlotId(new Location(world,BukkitUtil.locationToVector(event.getBlocks().get(i).getLocation())));
      if (id == null) {
        event.getBlocks().remove(i);
        i--;
      }
    }
  }
}"
41977,"@EventHandler(priority=EventPriority.HIGHEST) public void onSignEdit(SignChangeEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  ILocation location=new ILocation(player.getWorld(),event.getBlock().getX(),event.getBlock().getY(),event.getBlock().getZ());
  if (manager.isPlotWorld(location)) {
    Plot plot=manager.getPlot(location);
    if (plot == null || !plot.isAllowed(player.getUniqueId())) {
      if (!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE)) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
 else     if (api.isPlotLocked(plot)) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else {
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
  }
}","@EventHandler(priority=EventPriority.HIGHEST) public void onSignEdit(SignChangeEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  Location location=new Location(player.getWorld(),event.getBlock().getX(),event.getBlock().getY(),event.getBlock().getZ());
  if (manager.isPlotWorld(location)) {
    Plot plot=manager.getPlot(location);
    if (plot == null || !plot.isAllowed(player.getUniqueId())) {
      if (!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE)) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
 else     if (api.isPlotLocked(plot)) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else {
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
  }
}"
41978,"@EventHandler(priority=EventPriority.HIGH) public void onBlockPlace(BlockPlaceEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  Location bloc=event.getBlockPlaced().getLocation();
  ILocation location=new ILocation(player.getWorld(),bloc.getX(),bloc.getY(),bloc.getZ());
  if (manager.isPlotWorld(location)) {
    Plot plot=manager.getPlot(location);
    if (plot == null || !plot.isAllowed(player.getUniqueId())) {
      if (!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE)) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
 else     if (api.isPlotLocked(plot)) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else {
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
  }
}","@EventHandler(priority=EventPriority.HIGH) public void onBlockPlace(BlockPlaceEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  org.bukkit.Location bloc=event.getBlockPlaced().getLocation();
  Location location=new Location(player.getWorld(),bloc.getX(),bloc.getY(),bloc.getZ());
  if (manager.isPlotWorld(location)) {
    Plot plot=manager.getPlot(location);
    if (plot == null || !plot.isAllowed(player.getUniqueId())) {
      if (!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE)) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
 else     if (api.isPlotLocked(plot)) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else {
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
  }
}"
41979,"@EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onBucketFillEvent(PlayerBucketFillEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  Location bloc=event.getBlockClicked().getLocation();
  ILocation location=new ILocation(player.getWorld(),bloc.getX(),bloc.getY(),bloc.getZ());
  if (manager.isPlotWorld(location) && !player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE)) {
    Plot plot=manager.getPlot(location);
    if (plot == null) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else     if (!plot.isAllowed(player.getUniqueId())) {
      if (api.isPlotLocked(plot)) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
 else {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
  }
}","@EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onBucketFillEvent(PlayerBucketFillEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  org.bukkit.Location bloc=event.getBlockClicked().getLocation();
  Location location=new Location(player.getWorld(),bloc.getX(),bloc.getY(),bloc.getZ());
  if (manager.isPlotWorld(location) && !player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE)) {
    Plot plot=manager.getPlot(location);
    if (plot == null) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else     if (!plot.isAllowed(player.getUniqueId())) {
      if (api.isPlotLocked(plot)) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
 else {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
  }
}"
41980,"@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onBlockPistonRetract(BlockPistonRetractEvent event){
  BukkitWorld world=BukkitUtil.adapt(event.getBlock().getWorld());
  if (manager.isPlotWorld(world)) {
    List<Block> blocks=event.getBlocks();
    for (    Block moved : blocks) {
      PlotId id=manager.getPlotId(new ILocation(world,BukkitUtil.locationToVector(moved.getLocation())));
      if (id == null) {
        event.setCancelled(true);
      }
    }
  }
}","@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onBlockPistonRetract(BlockPistonRetractEvent event){
  BukkitWorld world=BukkitUtil.adapt(event.getBlock().getWorld());
  if (manager.isPlotWorld(world)) {
    List<Block> blocks=event.getBlocks();
    for (    Block moved : blocks) {
      PlotId id=manager.getPlotId(new Location(world,BukkitUtil.locationToVector(moved.getLocation())));
      if (id == null) {
        event.setCancelled(true);
      }
    }
  }
}"
41981,"@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onHangingPlace(HangingPlaceEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  ILocation location=new ILocation(player.getWorld(),BukkitUtil.locationToVector(event.getBlock().getLocation()));
  if (manager.isPlotWorld(location.getWorld())) {
    Plot plot=manager.getPlot(location);
    boolean canBuild=!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE);
    if (plot == null || !plot.isAllowed(player.getUniqueId())) {
      if (canBuild) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
 else {
      if (api.isPlotLocked(plot)) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
  }
}","@EventHandler(priority=EventPriority.NORMAL,ignoreCancelled=true) public void onHangingPlace(HangingPlaceEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  Location location=new Location(player.getWorld(),BukkitUtil.locationToVector(event.getBlock().getLocation()));
  if (manager.isPlotWorld(location.getWorld())) {
    Plot plot=manager.getPlot(location);
    boolean canBuild=!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE);
    if (plot == null || !plot.isAllowed(player.getUniqueId())) {
      if (canBuild) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
 else {
      if (api.isPlotLocked(plot)) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
  }
}"
41982,"@SuppressWarnings(""String_Node_Str"") @EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onPlayerInteract(PlayerInteractEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  ILocation location=new ILocation(player.getWorld(),BukkitUtil.locationToVector(event.getClickedBlock().getLocation()));
  if (manager.isPlotWorld(location)) {
    Plot plot=manager.getPlot(location);
    boolean canBuild=!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE);
    PlotMapInfo pmi=manager.getMap(location);
    if (event.isBlockInHand() && event.getAction() == Action.RIGHT_CLICK_BLOCK) {
      if (plot == null || !plot.isAllowed(player.getUniqueId())) {
        if (canBuild) {
          player.sendMessage(api.C(""String_Node_Str""));
          event.setCancelled(true);
        }
      }
 else {
        plot.resetExpire(pmi.getDaysToExpiration());
      }
    }
 else {
      boolean blocked=false;
      if (pmi.isProtectedBlock(event.getClickedBlock().getTypeId()) && !player.hasPermission(""String_Node_Str"" + event.getClickedBlock().getTypeId())) {
        blocked=true;
      }
      ItemStack item=event.getItem();
      if (event.getAction() == Action.RIGHT_CLICK_BLOCK && item != null) {
        int itemId=item.getType().getId();
        byte itemData=item.getData().getData();
        if ((pmi.isPreventedItem(String.valueOf(itemId)) || pmi.isPreventedItem(itemId + ""String_Node_Str"" + itemData)) && !player.hasPermission(""String_Node_Str"" + itemId) || item.getType().equals(Material.MONSTER_EGG)) {
          blocked=true;
        }
      }
      if (blocked && (plot == null || !plot.isAllowed(player.getUniqueId())) && canBuild) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onPlayerInteract(PlayerInteractEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  Location location=new Location(player.getWorld(),BukkitUtil.locationToVector(event.getClickedBlock().getLocation()));
  if (manager.isPlotWorld(location)) {
    Plot plot=manager.getPlot(location);
    boolean canBuild=!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE);
    PlotMapInfo pmi=manager.getMap(location);
    if (event.isBlockInHand() && event.getAction() == Action.RIGHT_CLICK_BLOCK) {
      if (plot == null || !plot.isAllowed(player.getUniqueId())) {
        if (canBuild) {
          player.sendMessage(api.C(""String_Node_Str""));
          event.setCancelled(true);
        }
      }
 else {
        plot.resetExpire(pmi.getDaysToExpiration());
      }
    }
 else {
      boolean blocked=false;
      if (pmi.isProtectedBlock(event.getClickedBlock().getTypeId()) && !player.hasPermission(""String_Node_Str"" + event.getClickedBlock().getTypeId())) {
        blocked=true;
      }
      ItemStack item=event.getItem();
      if (event.getAction() == Action.RIGHT_CLICK_BLOCK && item != null) {
        int itemId=item.getType().getId();
        byte itemData=item.getData().getData();
        if ((pmi.isPreventedItem(String.valueOf(itemId)) || pmi.isPreventedItem(itemId + ""String_Node_Str"" + itemData)) && !player.hasPermission(""String_Node_Str"" + itemId) || item.getType().equals(Material.MONSTER_EGG)) {
          blocked=true;
        }
      }
      if (blocked && (plot == null || !plot.isAllowed(player.getUniqueId())) && canBuild) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
  }
}"
41983,"@EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onBucketEmptyEvent(PlayerBucketEmptyEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  ILocation location=new ILocation(player.getWorld(),BukkitUtil.locationToVector(event.getBlockClicked().getLocation()));
  if (!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE) && manager.isPlotWorld(location)) {
    Plot plot=manager.getPlot(location.add(event.getBlockFace().getModX(),event.getBlockFace().getModY(),event.getBlockFace().getModZ()));
    if (plot == null) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else     if (!plot.isAllowed(player.getUniqueId())) {
      if (api.isPlotLocked(plot)) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
 else {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
  }
}","@EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onBucketEmptyEvent(PlayerBucketEmptyEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  Location location=new Location(player.getWorld(),BukkitUtil.locationToVector(event.getBlockClicked().getLocation()));
  if (!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE) && manager.isPlotWorld(location)) {
    Plot plot=manager.getPlot(location.add(event.getBlockFace().getModX(),event.getBlockFace().getModY(),event.getBlockFace().getModZ()));
    if (plot == null) {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
 else     if (!plot.isAllowed(player.getUniqueId())) {
      if (api.isPlotLocked(plot)) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
 else {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
  }
}"
41984,"@EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onPlayerInteractEntity(PlayerInteractEntityEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  Location clickLoc=event.getRightClicked().getLocation();
  ILocation location=new ILocation(player.getWorld(),clickLoc.getX(),clickLoc.getY(),clickLoc.getZ());
  if (manager.isPlotWorld(location)) {
    if (event.getRightClicked().hasMetadata(""String_Node_Str"") && event.getRightClicked().getMetadata(""String_Node_Str"").get(0).asBoolean()) {
      return;
    }
    boolean cannotBuildAnywhere=!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE);
    Plot plot=manager.getPlot(location);
    if (plot == null) {
      if (cannotBuildAnywhere) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
 else     if (plot.isAllowed(player.getUniqueId())) {
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
 else {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
  }
}","@EventHandler(priority=EventPriority.HIGH,ignoreCancelled=true) public void onPlayerInteractEntity(PlayerInteractEntityEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  org.bukkit.Location clickLoc=event.getRightClicked().getLocation();
  Location location=new Location(player.getWorld(),clickLoc.getX(),clickLoc.getY(),clickLoc.getZ());
  if (manager.isPlotWorld(location)) {
    if (event.getRightClicked().hasMetadata(""String_Node_Str"") && event.getRightClicked().getMetadata(""String_Node_Str"").get(0).asBoolean()) {
      return;
    }
    boolean cannotBuildAnywhere=!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE);
    Plot plot=manager.getPlot(location);
    if (plot == null) {
      if (cannotBuildAnywhere) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
 else     if (plot.isAllowed(player.getUniqueId())) {
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
 else {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
  }
}"
41985,"@EventHandler public void onArmorStand(PlayerArmorStandManipulateEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  ILocation location=new ILocation(player.getWorld(),BukkitUtil.locationToVector(event.getRightClicked().getLocation()));
  if (manager.isPlotWorld(location)) {
    boolean cannotBuildAnywhere=!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE);
    Plot plot=manager.getPlot(location);
    if (plot == null) {
      if (cannotBuildAnywhere) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
 else     if (plot.isAllowed(player.getUniqueId())) {
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
 else {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
  }
}","@EventHandler public void onArmorStand(PlayerArmorStandManipulateEvent event){
  IPlayer player=plugin.wrapPlayer(event.getPlayer());
  Location location=new Location(player.getWorld(),BukkitUtil.locationToVector(event.getRightClicked().getLocation()));
  if (manager.isPlotWorld(location)) {
    boolean cannotBuildAnywhere=!player.hasPermission(PermissionNames.ADMIN_BUILDANYWHERE);
    Plot plot=manager.getPlot(location);
    if (plot == null) {
      if (cannotBuildAnywhere) {
        player.sendMessage(api.C(""String_Node_Str""));
        event.setCancelled(true);
      }
    }
 else     if (plot.isAllowed(player.getUniqueId())) {
      plot.resetExpire(manager.getMap(location).getDaysToExpiration());
    }
 else {
      player.sendMessage(api.C(""String_Node_Str""));
      event.setCancelled(true);
    }
  }
}"
41986,"@EventHandler(ignoreCancelled=true) public void onSandCannon(EntityChangeBlockEvent event){
  BukkitEntity entity=new BukkitEntity(event.getEntity());
  if (manager.isPlotWorld(entity) && event.getEntityType().equals(EntityType.FALLING_BLOCK)) {
    if (event.getTo().equals(Material.AIR)) {
      entity.setMetadata(""String_Node_Str"",new FixedMetadataValue(plugin,event.getBlock().getLocation()));
    }
 else {
      List<MetadataValue> values=entity.getMetadata(""String_Node_Str"");
      if (!values.isEmpty()) {
        Location spawn=(Location)(values.get(0).value());
        Location createdNew=event.getBlock().getLocation();
        if (spawn.getBlockX() != createdNew.getBlockX() || spawn.getBlockZ() != createdNew.getBlockZ()) {
          event.setCancelled(true);
        }
      }
    }
  }
}","@EventHandler(ignoreCancelled=true) public void onSandCannon(EntityChangeBlockEvent event){
  BukkitEntity entity=new BukkitEntity(event.getEntity());
  if (manager.isPlotWorld(entity) && event.getEntityType().equals(EntityType.FALLING_BLOCK)) {
    if (event.getTo().equals(Material.AIR)) {
      entity.setMetadata(""String_Node_Str"",new FixedMetadataValue(plugin,event.getBlock().getLocation()));
    }
 else {
      List<MetadataValue> values=entity.getMetadata(""String_Node_Str"");
      if (!values.isEmpty()) {
        org.bukkit.Location spawn=(org.bukkit.Location)(values.get(0).value());
        org.bukkit.Location createdNew=event.getBlock().getLocation();
        if (spawn.getBlockX() != createdNew.getBlockX() || spawn.getBlockZ() != createdNew.getBlockZ()) {
          event.setCancelled(true);
        }
      }
    }
  }
}"
41987,"public boolean isAllowedConsulting(String name){
  if (""String_Node_Str"".equalsIgnoreCase(name)) {
    return isAllowedInternal(name);
  }
  UUID player=PlotMeCoreManager.getInstance().getOfflinePlayer(name).getUniqueId();
  return player != null && isAllowedInternal(name);
}","public boolean isAllowedConsulting(String name){
  if (""String_Node_Str"".equals(name)) {
    return isAllowedInternal(name);
  }
  UUID player=PlotMeCoreManager.getInstance().getOfflinePlayer(name).getUniqueId();
  return player != null && isAllowedInternal(name);
}"
41988,"private boolean isAllowedInternal(String name){
  if (getAllowed().containsKey(name)) {
    AccessLevel accessLevel=getAllowed().get(name);
    if (accessLevel == AccessLevel.ALLOWED) {
      return true;
    }
 else     if (!""String_Node_Str"".equalsIgnoreCase(name)) {
      if (accessLevel == AccessLevel.TRUSTED) {
        return PlotMeCoreManager.getInstance().getOfflinePlayer(name).isOnline();
      }
    }
  }
 else {
    return getAllowed().containsKey(""String_Node_Str"");
  }
  return false;
}","private boolean isAllowedInternal(String name){
  if (getAllowed().containsKey(name)) {
    AccessLevel accessLevel=getAllowed().get(name);
    if (accessLevel == AccessLevel.ALLOWED) {
      return true;
    }
 else     if (!""String_Node_Str"".equals(name)) {
      if (accessLevel == AccessLevel.TRUSTED) {
        return PlotMeCoreManager.getInstance().getOfflinePlayer(name).isOnline();
      }
    }
  }
 else {
    return getAllowed().containsKey(""String_Node_Str"");
  }
  return false;
}"
41989,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches()) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equalsIgnoreCase(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_ADD) || player.hasPermission(PermissionNames.USER_ADD)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(player)) {
      PlotMapInfo pmi=manager.getMap(world);
      Plot plot=manager.getPlot(player);
      if (plot != null) {
        IOfflinePlayer allowed=resolvePlayerByName(args[1]);
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_ADD)) {
          if (plot.isAllowedConsulting(allowed.getUniqueId())) {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + allowed+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
 else {
            PlotAddAllowedEvent event=new PlotAddAllowedEvent(world,plot,player,allowed);
            serverBridge.getEventBus().post(event);
            double price=0.0;
            if (manager.isEconomyEnabled(pmi)) {
              price=pmi.getAddPlayerPrice();
              if (serverBridge.has(player,pmi.getAddPlayerPrice())) {
                player.sendMessage(""String_Node_Str"" + serverBridge.getEconomy().get().format(price) + ""String_Node_Str""+ ""String_Node_Str"");
                return true;
              }
 else               if (!event.isCancelled()) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
            }
            if (!event.isCancelled()) {
              IPlayer allowed2=plugin.getServerBridge().getPlayer(allowed);
              if (allowed2 != null) {
                plot.addAllowed(allowed2.getUniqueId().toString());
                plot.removeDenied(allowed2.getUniqueId().toString());
              }
 else {
                plot.addAllowed(allowed);
                plot.removeDenied(allowed);
              }
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + allowed+ ""String_Node_Str""+ C(""String_Node_Str""));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId());
                }
 else {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches()) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_ADD) || player.hasPermission(PermissionNames.USER_ADD)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(player)) {
      PlotMapInfo pmi=manager.getMap(world);
      Plot plot=manager.getPlot(player);
      if (plot != null) {
        IOfflinePlayer allowed=resolvePlayerByName(args[1]);
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_ADD)) {
          if (plot.isAllowedConsulting(allowed.getUniqueId())) {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + allowed+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
 else {
            PlotAddAllowedEvent event=new PlotAddAllowedEvent(world,plot,player,allowed);
            serverBridge.getEventBus().post(event);
            double price=0.0;
            if (manager.isEconomyEnabled(pmi)) {
              price=pmi.getAddPlayerPrice();
              if (serverBridge.has(player,pmi.getAddPlayerPrice())) {
                player.sendMessage(""String_Node_Str"" + serverBridge.getEconomy().get().format(price) + ""String_Node_Str""+ ""String_Node_Str"");
                return true;
              }
 else               if (!event.isCancelled()) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
            }
            if (!event.isCancelled()) {
              IPlayer allowed2=plugin.getServerBridge().getPlayer(allowed);
              if (allowed2 != null) {
                plot.addAllowed(allowed2.getUniqueId().toString());
                plot.removeDenied(allowed2.getUniqueId().toString());
              }
 else {
                plot.addAllowed(allowed);
                plot.removeDenied(allowed);
              }
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + allowed+ ""String_Node_Str""+ C(""String_Node_Str""));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId());
                }
 else {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
  }
 else {
    return false;
  }
  return true;
}"
41990,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length > 1) {
    throw new BadUsageException(getUsage());
  }
  IPlayer player=(IPlayer)sender;
  IWorld world=player.getWorld();
  if (manager.isPlotWorld(world)) {
    if (manager.isEconomyEnabled(world)) {
      if (player.hasPermission(PermissionNames.USER_BUY)) {
        Plot plot=manager.getPlot(player.getLocation());
        if (plot != null) {
          if (plot.isForSale()) {
            String buyer=player.getName();
            if (player.getUniqueId().equals(plot.getOwnerId())) {
              player.sendMessage(C(""String_Node_Str""));
            }
 else {
              int plotLimit=getPlotLimit(player);
              int plotsOwned=manager.getOwnedPlotCount(player.getUniqueId(),world.getName());
              if (plotLimit != -1 && plotsOwned >= plotLimit) {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plotsOwned+ ""String_Node_Str""+ getPlotLimit(player)+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
              }
 else {
                double cost=plot.getPrice();
                if (serverBridge.has(player,cost)) {
                  player.sendMessage(C(""String_Node_Str""));
                }
 else {
                  PlotBuyEvent event=new PlotBuyEvent(world,plot,player,cost);
                  serverBridge.getEventBus().post(event);
                  if (!event.isCancelled()) {
                    EconomyResponse er=serverBridge.withdrawPlayer(player,cost);
                    if (er.transactionSuccess()) {
                      String oldOwner=plot.getOwner();
                      IOfflinePlayer currBuyer=serverBridge.getOfflinePlayer(plot.getOwnerId());
                      if (currBuyer != null) {
                        EconomyResponse er2=serverBridge.depositPlayer(currBuyer,cost);
                        if (er2.transactionSuccess()) {
                          for (                          IPlayer onlinePlayers : serverBridge.getOnlinePlayers()) {
                            if (onlinePlayers.getName().equalsIgnoreCase(oldOwner)) {
                              onlinePlayers.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ buyer+ ""String_Node_Str""+ serverBridge.getEconomy().format(cost));
                              break;
                            }
                          }
                        }
 else {
                          player.sendMessage(er2.errorMessage);
                          serverBridge.getLogger().warning(er2.errorMessage);
                        }
                      }
                      plot.setOwner(buyer);
                      plot.setOwnerId(player.getUniqueId());
                      plot.setPrice(0.0);
                      plot.setForSale(false);
                      plot.updateField(""String_Node_Str"",buyer);
                      plot.updateField(""String_Node_Str"",player.getUniqueId());
                      plot.updateField(""String_Node_Str"",0);
                      plot.updateField(""String_Node_Str"",false);
                      manager.adjustWall(plot,world,true);
                      manager.removeSellSign(plot,world);
                      manager.setOwnerSign(world,plot);
                      player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + serverBridge.getEconomy().format(cost));
                      if (isAdvancedLogging()) {
                        plugin.getLogger().info(buyer + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().toString()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ cost);
                      }
                    }
 else {
                      player.sendMessage(er.errorMessage);
                      serverBridge.getLogger().warning(er.errorMessage);
                    }
                  }
                }
              }
            }
          }
 else {
            player.sendMessage(C(""String_Node_Str""));
          }
        }
 else {
          player.sendMessage(""String_Node_Str"");
        }
      }
 else {
        return false;
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length > 1) {
    throw new BadUsageException(getUsage());
  }
  IPlayer player=(IPlayer)sender;
  IWorld world=player.getWorld();
  if (manager.isPlotWorld(world)) {
    if (manager.isEconomyEnabled(world)) {
      if (player.hasPermission(PermissionNames.USER_BUY)) {
        Plot plot=manager.getPlot(player.getLocation());
        if (plot != null) {
          if (plot.isForSale()) {
            String buyer=player.getName();
            if (player.getUniqueId().equals(plot.getOwnerId())) {
              player.sendMessage(C(""String_Node_Str""));
            }
 else {
              int plotLimit=getPlotLimit(player);
              int plotsOwned=manager.getOwnedPlotCount(player.getUniqueId(),world.getName());
              if (plotLimit != -1 && plotsOwned >= plotLimit) {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plotsOwned+ ""String_Node_Str""+ getPlotLimit(player)+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
              }
 else {
                double cost=plot.getPrice();
                if (serverBridge.has(player,cost)) {
                  player.sendMessage(C(""String_Node_Str""));
                }
 else {
                  PlotBuyEvent event=new PlotBuyEvent(world,plot,player,cost);
                  serverBridge.getEventBus().post(event);
                  if (!event.isCancelled()) {
                    EconomyResponse er=serverBridge.withdrawPlayer(player,cost);
                    if (er.transactionSuccess()) {
                      String oldOwner=plot.getOwner();
                      IOfflinePlayer currBuyer=serverBridge.getOfflinePlayer(plot.getOwnerId());
                      if (currBuyer != null) {
                        EconomyResponse er2=serverBridge.depositPlayer(currBuyer,cost);
                        if (er2.transactionSuccess()) {
                          for (                          IPlayer onlinePlayers : serverBridge.getOnlinePlayers()) {
                            if (onlinePlayers.getName().equals(oldOwner)) {
                              onlinePlayers.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ buyer+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(cost));
                              break;
                            }
                          }
                        }
 else {
                          player.sendMessage(er2.errorMessage);
                          serverBridge.getLogger().warning(er2.errorMessage);
                        }
                      }
                      plot.setOwner(buyer);
                      plot.setOwnerId(player.getUniqueId());
                      plot.setPrice(0.0);
                      plot.setForSale(false);
                      plot.updateField(""String_Node_Str"",buyer);
                      plot.updateField(""String_Node_Str"",player.getUniqueId());
                      plot.updateField(""String_Node_Str"",0);
                      plot.updateField(""String_Node_Str"",false);
                      manager.adjustWall(plot,world,true);
                      manager.removeSellSign(plot,world);
                      manager.setOwnerSign(world,plot);
                      player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + serverBridge.getEconomy().get().format(cost));
                      if (isAdvancedLogging()) {
                        plugin.getLogger().info(buyer + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId().toString()+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ cost);
                      }
                    }
 else {
                      player.sendMessage(er.errorMessage);
                      serverBridge.getLogger().warning(er.errorMessage);
                    }
                  }
                }
              }
            }
          }
 else {
            player.sendMessage(C(""String_Node_Str""));
          }
        }
 else {
          player.sendMessage(""String_Node_Str"");
        }
      }
 else {
        return false;
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
  return true;
}"
41991,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_CLAIM) || player.hasPermission(PermissionNames.ADMIN_CLAIM_OTHER)) {
    IWorld world=player.getWorld();
    PlotMapInfo pmi=manager.getMap(world);
    if (manager.isPlotWorld(world)) {
      PlotId id=manager.getPlotId(player);
      if (id == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      if (!manager.isPlotAvailable(id,pmi)) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      String playerName=player.getName();
      UUID playerUniqueId=player.getUniqueId();
      if (args.length == 2 && player.hasPermission(PermissionNames.ADMIN_CLAIM_OTHER)) {
        if (args[1].length() > 16 || !validUserPattern2.matcher(args[1]).matches()) {
          throw new IllegalArgumentException(C(""String_Node_Str""));
        }
        IOfflinePlayer offlinePlayer=serverBridge.getOfflinePlayer(args[1]);
        playerName=args[1];
        playerUniqueId=offlinePlayer.getUniqueId();
      }
      int plotLimit=getPlotLimit(player);
      int plotsOwned=manager.getOwnedPlotCount(player.getUniqueId(),world.getName().toLowerCase());
      if (playerName.equals(player.getName()) && plotLimit != -1 && plotsOwned >= plotLimit) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plotsOwned+ ""String_Node_Str""+ getPlotLimit(player)+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
 else {
        double price=0.0;
        PlotCreateEvent event=new PlotCreateEvent(world,id,player);
        if (manager.isEconomyEnabled(pmi)) {
          price=pmi.getClaimPrice();
          if (serverBridge.has(player,price)) {
            serverBridge.getEventBus().post(event);
            if (event.isCancelled()) {
              return true;
            }
            EconomyResponse er=serverBridge.withdrawPlayer(player,price);
            if (!er.transactionSuccess()) {
              player.sendMessage(er.errorMessage);
              serverBridge.getLogger().warning(er.errorMessage);
              return true;
            }
          }
 else {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
            return true;
          }
        }
 else {
          serverBridge.getEventBus().post(event);
        }
        if (!event.isCancelled()) {
          Plot plot=manager.createPlot(id,world,playerName,playerUniqueId,pmi);
          if (playerName.equalsIgnoreCase(player.getName())) {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
          }
 else {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + playerName+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
          }
          if (isAdvancedLogging()) {
            if (price == 0) {
              serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id);
            }
 else {
              serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
            }
          }
        }
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_CLAIM) || player.hasPermission(PermissionNames.ADMIN_CLAIM_OTHER)) {
    IWorld world=player.getWorld();
    PlotMapInfo pmi=manager.getMap(world);
    if (manager.isPlotWorld(world)) {
      PlotId id=manager.getPlotId(player);
      if (id == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      if (!manager.isPlotAvailable(id,pmi)) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      String playerName=player.getName();
      UUID playerUniqueId=player.getUniqueId();
      if (args.length == 2 && player.hasPermission(PermissionNames.ADMIN_CLAIM_OTHER)) {
        if (args[1].length() > 16 || !validUserPattern2.matcher(args[1]).matches()) {
          throw new IllegalArgumentException(C(""String_Node_Str""));
        }
        IOfflinePlayer offlinePlayer=serverBridge.getOfflinePlayer(args[1]);
        playerName=args[1];
        playerUniqueId=offlinePlayer.getUniqueId();
      }
      int plotLimit=getPlotLimit(player);
      int plotsOwned=manager.getOwnedPlotCount(player.getUniqueId(),world.getName().toLowerCase());
      if (playerName.equals(player.getName()) && plotLimit != -1 && plotsOwned >= plotLimit) {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plotsOwned+ ""String_Node_Str""+ getPlotLimit(player)+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
 else {
        double price=0.0;
        PlotCreateEvent event=new PlotCreateEvent(world,id,player);
        if (manager.isEconomyEnabled(pmi)) {
          price=pmi.getClaimPrice();
          if (serverBridge.has(player,price)) {
            serverBridge.getEventBus().post(event);
            if (event.isCancelled()) {
              return true;
            }
            EconomyResponse er=serverBridge.withdrawPlayer(player,price);
            if (!er.transactionSuccess()) {
              player.sendMessage(er.errorMessage);
              serverBridge.getLogger().warning(er.errorMessage);
              return true;
            }
          }
 else {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
            return true;
          }
        }
 else {
          serverBridge.getEventBus().post(event);
        }
        if (!event.isCancelled()) {
          Plot plot=manager.createPlot(id,world,playerName,playerUniqueId,pmi);
          if (playerName.equals(player.getName())) {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
          }
 else {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + playerName+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
          }
          if (isAdvancedLogging()) {
            if (price == 0) {
              serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id);
            }
 else {
              serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
            }
          }
        }
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41992,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length > 1) {
    throw new BadUsageException(getUsage());
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_CLEAR) || player.hasPermission(PermissionNames.USER_CLEAR)) {
    IWorld world=player.getWorld();
    PlotMapInfo pmi=manager.getMap(world);
    if (manager.isPlotWorld(world)) {
      PlotId id=manager.getPlotId(player);
      if (id == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
 else       if (!manager.isPlotAvailable(id,pmi)) {
        Plot plot=manager.getPlotById(id,pmi);
        if (plot.isProtected()) {
          player.sendMessage(C(""String_Node_Str""));
        }
 else {
          String playerName=player.getName();
          if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_CLEAR)) {
            double price=0.0;
            PlotClearEvent event=new PlotClearEvent(world,plot,player);
            if (manager.isEconomyEnabled(pmi)) {
              price=pmi.getClearPrice();
              if (serverBridge.has(player,price)) {
                serverBridge.getEventBus().post(event);
                if (event.isCancelled()) {
                  return true;
                }
 else {
                  EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                  if (!er.transactionSuccess()) {
                    player.sendMessage(er.errorMessage);
                    serverBridge.getLogger().warning(er.errorMessage);
                    return true;
                  }
                }
              }
 else {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
                return true;
              }
            }
 else {
              serverBridge.getEventBus().post(event);
            }
            if (!event.isCancelled()) {
              manager.clear(plot,world,player,ClearReason.Clear);
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id);
                }
 else {
                  serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
 else {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length > 1) {
    throw new BadUsageException(getUsage());
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_CLEAR) || player.hasPermission(PermissionNames.USER_CLEAR)) {
    IWorld world=player.getWorld();
    PlotMapInfo pmi=manager.getMap(world);
    if (manager.isPlotWorld(world)) {
      PlotId id=manager.getPlotId(player);
      if (id == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
 else       if (!manager.isPlotAvailable(id,pmi)) {
        Plot plot=manager.getPlotById(id,pmi);
        if (plot.isProtected()) {
          player.sendMessage(C(""String_Node_Str""));
        }
 else {
          String playerName=player.getName();
          if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_CLEAR)) {
            double price=0.0;
            PlotClearEvent event=new PlotClearEvent(world,plot,player);
            if (manager.isEconomyEnabled(pmi)) {
              price=pmi.getClearPrice();
              if (serverBridge.has(player,price)) {
                serverBridge.getEventBus().post(event);
                if (event.isCancelled()) {
                  return true;
                }
 else {
                  EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                  if (!er.transactionSuccess()) {
                    player.sendMessage(er.errorMessage);
                    serverBridge.getLogger().warning(er.errorMessage);
                    return true;
                  }
                }
              }
 else {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
                return true;
              }
            }
 else {
              serverBridge.getEventBus().post(event);
            }
            if (!event.isCancelled()) {
              manager.clear(plot,world,player,ClearReason.Clear);
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id);
                }
 else {
                  serverBridge.getLogger().info(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
 else {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41993,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches()) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equalsIgnoreCase(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_DENY) || player.hasPermission(PermissionNames.USER_DENY)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      PlotId id=manager.getPlotId(player);
      if (id == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      PlotMapInfo pmi=manager.getMap(world);
      if (!manager.isPlotAvailable(id,pmi)) {
        Plot plot=manager.getPlotById(id,pmi);
        String denied=args[1];
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_DENY)) {
          if (plot.getOwner().equalsIgnoreCase(denied)) {
            player.sendMessage(C(""String_Node_Str""));
            return true;
          }
          if (plot.isDeniedConsulting(denied)) {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
 else {
            double price=0.0;
            PlotAddDeniedEvent event=new PlotAddDeniedEvent(world,plot,player,denied);
            if (manager.isEconomyEnabled(pmi)) {
              price=pmi.getDenyPlayerPrice();
              if (serverBridge.has(player,price)) {
                serverBridge.getEventBus().post(event);
                if (event.isCancelled()) {
                  return true;
                }
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
 else {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
                return true;
              }
            }
 else {
              serverBridge.getEventBus().post(event);
            }
            if (!event.isCancelled()) {
              plot.addDenied(denied);
              plot.removeAllowed(denied);
              if (""String_Node_Str"".equals(denied)) {
                List<IPlayer> playersInPlot=manager.getPlayersInPlot(id,world);
                for (                IPlayer iPlayer : playersInPlot) {
                  if (!plot.isAllowed(iPlayer.getUniqueId())) {
                    iPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
                  }
                }
              }
 else {
                IPlayer deniedPlayer=serverBridge.getPlayer(denied);
                if (deniedPlayer != null && deniedPlayer.getWorld().equals(world)) {
                  PlotId plotId=manager.getPlotId(deniedPlayer);
                  if (plotId.equals(id)) {
                    deniedPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
                  }
                }
              }
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ id);
                }
 else {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ id+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches()) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_DENY) || player.hasPermission(PermissionNames.USER_DENY)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      PlotId id=manager.getPlotId(player);
      if (id == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
      PlotMapInfo pmi=manager.getMap(world);
      if (!manager.isPlotAvailable(id,pmi)) {
        Plot plot=manager.getPlotById(id,pmi);
        String denied=args[1];
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_DENY)) {
          if (plot.getOwner().equals(denied)) {
            player.sendMessage(C(""String_Node_Str""));
            return true;
          }
          if (plot.isDeniedConsulting(denied)) {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
 else {
            double price=0.0;
            PlotAddDeniedEvent event=new PlotAddDeniedEvent(world,plot,player,denied);
            if (manager.isEconomyEnabled(pmi)) {
              price=pmi.getDenyPlayerPrice();
              if (serverBridge.has(player,price)) {
                serverBridge.getEventBus().post(event);
                if (event.isCancelled()) {
                  return true;
                }
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
 else {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
                return true;
              }
            }
 else {
              serverBridge.getEventBus().post(event);
            }
            if (!event.isCancelled()) {
              plot.addDenied(denied);
              plot.removeAllowed(denied);
              if (""String_Node_Str"".equals(denied)) {
                List<IPlayer> playersInPlot=manager.getPlayersInPlot(id,world);
                for (                IPlayer iPlayer : playersInPlot) {
                  if (!plot.isAllowed(iPlayer.getUniqueId())) {
                    iPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
                  }
                }
              }
 else {
                IPlayer deniedPlayer=serverBridge.getPlayer(denied);
                if (deniedPlayer != null && deniedPlayer.getWorld().equals(world)) {
                  PlotId plotId=manager.getPlotId(deniedPlayer);
                  if (plotId.equals(id)) {
                    deniedPlayer.setLocation(manager.getPlotHome(plot.getId(),player.getWorld()));
                  }
                }
              }
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ id);
                }
 else {
                  serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ denied+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ id+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41994,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_HOME)) {
    if (manager.isPlotWorld(player) || plugin.getConfig().getBoolean(""String_Node_Str"")) {
      UUID uuid=player.getUniqueId();
      IWorld world;
      if (manager.isPlotWorld(player)) {
        world=player.getWorld();
      }
 else {
        world=manager.getFirstWorld();
      }
      String worldName=world.getName();
      int nb=1;
      if (args[1].contains(""String_Node_Str"")) {
        if (args[1].split(""String_Node_Str"").length == 1 || args[0].split(""String_Node_Str"")[1].isEmpty()) {
          player.sendMessage(getUsage());
          return true;
        }
        try {
          nb=Integer.parseInt(args[1].split(""String_Node_Str"")[1]);
        }
 catch (        NumberFormatException e) {
          player.sendMessage(getUsage());
          return true;
        }
      }
      String playerName=player.getName();
      if (args.length == 2) {
        if (serverBridge.getWorld(args[1]) == null) {
          playerName=args[1];
          uuid=null;
        }
 else {
          world=serverBridge.getWorld(args[1]);
        }
      }
      if (args.length == 3) {
        if (serverBridge.getWorld(args[2]) == null) {
          player.sendMessage(args[2] + C(""String_Node_Str""));
          return true;
        }
        world=serverBridge.getWorld(args[2]);
        worldName=args[2];
      }
      if (world == null) {
        return true;
      }
      PlotMapInfo pmi=manager.getMap(world);
      if (manager.isPlotWorld(world)) {
        int i=nb - 1;
        for (        Plot plot : plugin.getSqlManager().getOwnedPlots(world.getName(),uuid)) {
          ILocation location;
          if (uuid == null) {
            if (plot.getOwner().equalsIgnoreCase(playerName)) {
              if (i == 0) {
                double price=0.0;
                location=manager.getPlotHome(plot.getId(),player.getWorld());
                PlotTeleportHomeEvent event=new PlotTeleportHomeEvent(world,plot,player,location);
                if (manager.isEconomyEnabled(pmi)) {
                  price=pmi.getPlotHomePrice();
                  if (serverBridge.has(player,price)) {
                    serverBridge.getEventBus().post(event);
                    if (event.isCancelled()) {
                      return true;
                    }
                    EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                    if (!er.transactionSuccess()) {
                      player.sendMessage(er.errorMessage);
                      return true;
                    }
                  }
 else {
                    player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
                    return true;
                  }
                }
 else {
                  serverBridge.getEventBus().post(event);
                }
                if (!event.isCancelled()) {
                  player.setLocation(event.getHomeLocation());
                  if (price != 0) {
                    player.sendMessage(serverBridge.getEconomy().format(price));
                  }
                }
                return true;
              }
              i--;
            }
          }
 else           if (plot.getOwnerId().equals(uuid)) {
            if (i == 0) {
              double price=0.0;
              location=manager.getPlotHome(plot.getId(),player.getWorld());
              PlotTeleportHomeEvent event=new PlotTeleportHomeEvent(world,plot,player,location);
              if (manager.isEconomyEnabled(pmi)) {
                price=pmi.getPlotHomePrice();
                if (serverBridge.has(player,price)) {
                  serverBridge.getEventBus().post(event);
                  if (!event.isCancelled()) {
                    EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                    if (!er.transactionSuccess()) {
                      player.sendMessage(er.errorMessage);
                      return true;
                    }
                  }
                }
 else {
                  player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
                  return true;
                }
              }
 else {
                serverBridge.getEventBus().post(event);
              }
              if (!event.isCancelled()) {
                player.setLocation(event.getHomeLocation());
                if (price != 0) {
                  player.sendMessage(serverBridge.getEconomy().format(price));
                }
              }
              return true;
            }
            i--;
          }
        }
        if (nb > 0) {
          if (playerName.equalsIgnoreCase(player.getName())) {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + nb);
          }
 else {
            player.sendMessage(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ nb);
          }
        }
 else         if (!playerName.equalsIgnoreCase(player.getName())) {
          player.sendMessage(playerName + ""String_Node_Str"" + C(""String_Node_Str""));
        }
 else {
          player.sendMessage(C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(worldName + C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_HOME)) {
    if (manager.isPlotWorld(player) || plugin.getConfig().getBoolean(""String_Node_Str"")) {
      UUID uuid=player.getUniqueId();
      IWorld world;
      if (manager.isPlotWorld(player)) {
        world=player.getWorld();
      }
 else {
        world=manager.getFirstWorld();
      }
      String worldName=world.getName();
      int nb=1;
      if (args[1].contains(""String_Node_Str"")) {
        if (args[1].split(""String_Node_Str"").length == 1 || args[0].split(""String_Node_Str"")[1].isEmpty()) {
          player.sendMessage(getUsage());
          return true;
        }
        try {
          nb=Integer.parseInt(args[1].split(""String_Node_Str"")[1]);
        }
 catch (        NumberFormatException e) {
          player.sendMessage(getUsage());
          return true;
        }
      }
      String playerName=player.getName();
      if (args.length == 2) {
        if (serverBridge.getWorld(args[1]) == null) {
          playerName=args[1];
          uuid=null;
        }
 else {
          world=serverBridge.getWorld(args[1]);
        }
      }
      if (args.length == 3) {
        if (serverBridge.getWorld(args[2]) == null) {
          player.sendMessage(args[2] + C(""String_Node_Str""));
          return true;
        }
        world=serverBridge.getWorld(args[2]);
        worldName=args[2];
      }
      if (world == null) {
        return true;
      }
      PlotMapInfo pmi=manager.getMap(world);
      if (manager.isPlotWorld(world)) {
        int i=nb - 1;
        for (        Plot plot : plugin.getSqlManager().getOwnedPlots(world.getName(),uuid)) {
          ILocation location;
          if (uuid == null) {
            if (plot.getOwner().equals(playerName)) {
              if (i == 0) {
                double price=0.0;
                location=manager.getPlotHome(plot.getId(),player.getWorld());
                PlotTeleportHomeEvent event=new PlotTeleportHomeEvent(world,plot,player,location);
                if (manager.isEconomyEnabled(pmi)) {
                  price=pmi.getPlotHomePrice();
                  if (serverBridge.has(player,price)) {
                    serverBridge.getEventBus().post(event);
                    if (event.isCancelled()) {
                      return true;
                    }
                    EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                    if (!er.transactionSuccess()) {
                      player.sendMessage(er.errorMessage);
                      return true;
                    }
                  }
 else {
                    player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
                    return true;
                  }
                }
 else {
                  serverBridge.getEventBus().post(event);
                }
                if (!event.isCancelled()) {
                  player.setLocation(event.getHomeLocation());
                  if (price != 0) {
                    player.sendMessage(serverBridge.getEconomy().format(price));
                  }
                }
                return true;
              }
              i--;
            }
          }
 else           if (plot.getOwnerId().equals(uuid)) {
            if (i == 0) {
              double price=0.0;
              location=manager.getPlotHome(plot.getId(),player.getWorld());
              PlotTeleportHomeEvent event=new PlotTeleportHomeEvent(world,plot,player,location);
              if (manager.isEconomyEnabled(pmi)) {
                price=pmi.getPlotHomePrice();
                if (serverBridge.has(player,price)) {
                  serverBridge.getEventBus().post(event);
                  if (!event.isCancelled()) {
                    EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                    if (!er.transactionSuccess()) {
                      player.sendMessage(er.errorMessage);
                      return true;
                    }
                  }
                }
 else {
                  player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
                  return true;
                }
              }
 else {
                serverBridge.getEventBus().post(event);
              }
              if (!event.isCancelled()) {
                player.setLocation(event.getHomeLocation());
                if (price != 0) {
                  player.sendMessage(serverBridge.getEconomy().format(price));
                }
              }
              return true;
            }
            i--;
          }
        }
        if (nb > 0) {
          if (playerName.equals(player.getName())) {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + nb);
          }
 else {
            player.sendMessage(playerName + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ nb);
          }
        }
 else         if (!playerName.equals(player.getName())) {
          player.sendMessage(playerName + ""String_Node_Str"" + C(""String_Node_Str""));
        }
 else {
          player.sendMessage(C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(worldName + C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41995,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_LIST)) {
    if (manager.isPlotWorld(player)) {
      String name;
      UUID uuid;
      if (args.length == 2) {
        name=args[1];
        uuid=null;
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + name+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
 else {
        name=player.getName();
        uuid=player.getUniqueId();
        player.sendMessage(C(""String_Node_Str""));
      }
      String oldWorld=""String_Node_Str"";
      for (      Plot plot : plugin.getSqlManager().getPlayerPlots(uuid)) {
        IWorld world=serverBridge.getWorld(plot.getWorld());
        if (world != null) {
          manager.getMap(world).addPlot(plot.getId(),plot);
        }
        StringBuilder addition=new StringBuilder();
        if (!oldWorld.equalsIgnoreCase(plot.getWorld())) {
          oldWorld=plot.getWorld();
          player.sendMessage(""String_Node_Str"" + plot.getWorld());
        }
        if (plot.getExpiredDate() != null) {
          Date expiredDate=plot.getExpiredDate();
          if (expiredDate.before(Calendar.getInstance().getTime())) {
            addition.append(""String_Node_Str"" + plot.getExpiredDate());
          }
 else {
            addition.append(""String_Node_Str"" + plot.getExpiredDate());
          }
        }
        if (plot.isForSale()) {
          addition.append(C(""String_Node_Str"") + ""String_Node_Str"" + Math.round(plot.getPrice()));
        }
        if (plot.getOwner().equalsIgnoreCase(name)) {
          if (plot.getAllowed().size() == 0) {
            if (name.equalsIgnoreCase(player.getName())) {
              player.sendMessage(plot.getId() + ""String_Node_Str"" + C(""String_Node_Str"")+ addition);
            }
 else {
              player.sendMessage(plot.getId() + ""String_Node_Str"" + plot.getOwner()+ addition);
            }
          }
 else           if (plot.getOwner().equalsIgnoreCase(player.getName())) {
            player.sendMessage(plot.getId() + ""String_Node_Str"" + C(""String_Node_Str"")+ addition+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getAllowed().toString());
          }
 else {
            player.sendMessage(plot.getId() + ""String_Node_Str"" + plot.getOwner()+ addition+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getAllowed().toString());
          }
        }
 else         if (plot.isAllowedConsulting(name)) {
          StringBuilder helpers=new StringBuilder();
          for (          String allowed : plot.getAllowed().keySet()) {
            if (player.getName().equalsIgnoreCase(allowed)) {
              if (name.equalsIgnoreCase(player.getName())) {
                helpers.append(""String_Node_Str"").append(""String_Node_Str"");
              }
 else {
                helpers.append(args[1]).append(""String_Node_Str"");
              }
            }
 else {
              helpers.append(allowed).append(""String_Node_Str"");
            }
          }
          if (helpers.length() > 2) {
            helpers.delete(helpers.length() - 2,helpers.length());
          }
          if (plot.getOwner().equalsIgnoreCase(player.getName())) {
            player.sendMessage(plot.getId() + ""String_Node_Str"" + C(""String_Node_Str"")+ addition+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ helpers);
          }
 else {
            player.sendMessage(plot.getId() + ""String_Node_Str"" + plot.getOwner()+ C(""String_Node_Str"")+ addition+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ helpers);
          }
        }
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.USER_LIST)) {
    if (manager.isPlotWorld(player)) {
      String name;
      UUID uuid;
      if (args.length == 2) {
        name=args[1];
        uuid=null;
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + name+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
 else {
        name=player.getName();
        uuid=player.getUniqueId();
        player.sendMessage(C(""String_Node_Str""));
      }
      String oldWorld=""String_Node_Str"";
      for (      Plot plot : plugin.getSqlManager().getPlayerPlots(uuid)) {
        IWorld world=serverBridge.getWorld(plot.getWorld());
        if (world != null) {
          manager.getMap(world).addPlot(plot.getId(),plot);
        }
        StringBuilder addition=new StringBuilder();
        if (!oldWorld.equalsIgnoreCase(plot.getWorld())) {
          oldWorld=plot.getWorld();
          player.sendMessage(""String_Node_Str"" + plot.getWorld());
        }
        if (plot.getExpiredDate() != null) {
          Date expiredDate=plot.getExpiredDate();
          if (expiredDate.before(Calendar.getInstance().getTime())) {
            addition.append(""String_Node_Str"" + plot.getExpiredDate());
          }
 else {
            addition.append(""String_Node_Str"" + plot.getExpiredDate());
          }
        }
        if (plot.isForSale()) {
          addition.append(C(""String_Node_Str"") + ""String_Node_Str"" + Math.round(plot.getPrice()));
        }
        if (plot.getOwner().equals(name)) {
          if (plot.getAllowed().size() == 0) {
            if (name.equals(player.getName())) {
              player.sendMessage(plot.getId() + ""String_Node_Str"" + C(""String_Node_Str"")+ addition);
            }
 else {
              player.sendMessage(plot.getId() + ""String_Node_Str"" + plot.getOwner()+ addition);
            }
          }
 else           if (plot.getOwner().equals(player.getName())) {
            player.sendMessage(plot.getId() + ""String_Node_Str"" + C(""String_Node_Str"")+ addition+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getAllowed().toString());
          }
 else {
            player.sendMessage(plot.getId() + ""String_Node_Str"" + plot.getOwner()+ addition+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getAllowed().toString());
          }
        }
 else         if (plot.isAllowedConsulting(name)) {
          StringBuilder helpers=new StringBuilder();
          for (          String allowed : plot.getAllowed().keySet()) {
            if (player.getName().equals(allowed)) {
              if (name.equals(player.getName())) {
                helpers.append(""String_Node_Str"").append(""String_Node_Str"");
              }
 else {
                helpers.append(args[1]).append(""String_Node_Str"");
              }
            }
 else {
              helpers.append(allowed).append(""String_Node_Str"");
            }
          }
          if (helpers.length() > 2) {
            helpers.delete(helpers.length() - 2,helpers.length());
          }
          if (plot.getOwner().equals(player.getName())) {
            player.sendMessage(plot.getId() + ""String_Node_Str"" + C(""String_Node_Str"")+ addition+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ helpers);
          }
 else {
            player.sendMessage(plot.getId() + ""String_Node_Str"" + plot.getOwner()+ C(""String_Node_Str"")+ addition+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ helpers);
          }
        }
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41996,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length > 1) {
    throw new BadUsageException(getUsage());
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_PROTECT) || player.hasPermission(PermissionNames.USER_PROTECT)) {
    IWorld world=player.getWorld();
    PlotMapInfo pmi=manager.getMap(world);
    if (manager.isPlotWorld(world)) {
      PlotId id=manager.getPlotId(player);
      if (id == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
 else       if (!manager.isPlotAvailable(id,pmi)) {
        Plot plot=manager.getPlotById(id,pmi);
        String name=player.getName();
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_PROTECT)) {
          PlotProtectChangeEvent event;
          if (plot.isProtected()) {
            event=new PlotProtectChangeEvent(world,plot,player,false);
            serverBridge.getEventBus().post(event);
            if (!event.isCancelled()) {
              plot.setProtected(false);
              manager.adjustWall(player);
              plot.updateField(""String_Node_Str"",false);
              player.sendMessage(C(""String_Node_Str""));
              if (isAdvancedLogging()) {
                serverBridge.getLogger().info(name + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id);
              }
            }
          }
 else {
            double cost=pmi.getProtectPrice();
            if (manager.isEconomyEnabled(pmi)) {
              if (serverBridge.has(player,cost)) {
                player.sendMessage(C(""String_Node_Str""));
                return true;
              }
 else {
                event=new PlotProtectChangeEvent(world,plot,player,true);
                serverBridge.getEventBus().post(event);
                if (!event.isCancelled()) {
                  EconomyResponse er=serverBridge.withdrawPlayer(player,cost);
                  if (!er.transactionSuccess()) {
                    player.sendMessage(er.errorMessage);
                    serverBridge.getLogger().warning(er.errorMessage);
                    return true;
                  }
                }
 else {
                  return true;
                }
              }
            }
 else {
              event=new PlotProtectChangeEvent(world,plot,player,true);
              serverBridge.getEventBus().post(event);
            }
            if (!event.isCancelled()) {
              plot.setProtected(true);
              manager.adjustWall(player);
              plot.updateField(""String_Node_Str"",true);
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + serverBridge.getEconomy().format(cost));
              if (isAdvancedLogging()) {
                serverBridge.getLogger().info(name + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id);
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length > 1) {
    throw new BadUsageException(getUsage());
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_PROTECT) || player.hasPermission(PermissionNames.USER_PROTECT)) {
    IWorld world=player.getWorld();
    PlotMapInfo pmi=manager.getMap(world);
    if (manager.isPlotWorld(world)) {
      PlotId id=manager.getPlotId(player);
      if (id == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
 else       if (!manager.isPlotAvailable(id,pmi)) {
        Plot plot=manager.getPlotById(id,pmi);
        String name=player.getName();
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_PROTECT)) {
          PlotProtectChangeEvent event;
          if (plot.isProtected()) {
            event=new PlotProtectChangeEvent(world,plot,player,false);
            serverBridge.getEventBus().post(event);
            if (!event.isCancelled()) {
              plot.setProtected(false);
              manager.adjustWall(player);
              plot.updateField(""String_Node_Str"",false);
              player.sendMessage(C(""String_Node_Str""));
              if (isAdvancedLogging()) {
                serverBridge.getLogger().info(name + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id);
              }
            }
          }
 else {
            double cost=pmi.getProtectPrice();
            if (manager.isEconomyEnabled(pmi)) {
              if (serverBridge.has(player,cost)) {
                player.sendMessage(C(""String_Node_Str""));
                return true;
              }
 else {
                event=new PlotProtectChangeEvent(world,plot,player,true);
                serverBridge.getEventBus().post(event);
                if (!event.isCancelled()) {
                  EconomyResponse er=serverBridge.withdrawPlayer(player,cost);
                  if (!er.transactionSuccess()) {
                    player.sendMessage(er.errorMessage);
                    serverBridge.getLogger().warning(er.errorMessage);
                    return true;
                  }
                }
 else {
                  return true;
                }
              }
            }
 else {
              event=new PlotProtectChangeEvent(world,plot,player,true);
              serverBridge.getEventBus().post(event);
            }
            if (!event.isCancelled()) {
              plot.setProtected(true);
              manager.adjustWall(player);
              plot.updateField(""String_Node_Str"",true);
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + serverBridge.getEconomy().get().format(cost));
              if (isAdvancedLogging()) {
                serverBridge.getLogger().info(name + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ id);
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
  }
 else {
    return false;
  }
  return true;
}"
41997,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches()) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equalsIgnoreCase(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_REMOVE) || player.hasPermission(PermissionNames.USER_REMOVE)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      PlotMapInfo pmi=manager.getMap(world);
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
 else {
        UUID playerUniqueId=player.getUniqueId();
        String allowed=args[1];
        if (plot.getOwnerId().equals(playerUniqueId) || player.hasPermission(PermissionNames.ADMIN_REMOVE)) {
          if (plot.isAllowedConsulting(allowed)) {
            double price=0.0;
            PlotRemoveAllowedEvent event=new PlotRemoveAllowedEvent(world,plot,player,allowed);
            serverBridge.getEventBus().post(event);
            if (manager.isEconomyEnabled(pmi) && !event.isCancelled()) {
              price=pmi.getRemovePlayerPrice();
              if (serverBridge.has(player,price)) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
 else {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
                return true;
              }
            }
            if (!event.isCancelled()) {
              if (""String_Node_Str"".equalsIgnoreCase(allowed)) {
                plot.removeAllAllowed();
              }
 else {
                plot.removeAllowed(allowed);
              }
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(allowed + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId());
                }
 else {
                  serverBridge.getLogger().info(allowed + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
 else {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches()) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_REMOVE) || player.hasPermission(PermissionNames.USER_REMOVE)) {
    IWorld world=player.getWorld();
    if (manager.isPlotWorld(world)) {
      PlotMapInfo pmi=manager.getMap(world);
      Plot plot=manager.getPlot(player);
      if (plot == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
 else {
        UUID playerUniqueId=player.getUniqueId();
        String allowed=args[1];
        if (plot.getOwnerId().equals(playerUniqueId) || player.hasPermission(PermissionNames.ADMIN_REMOVE)) {
          if (plot.isAllowedConsulting(allowed)) {
            double price=0.0;
            PlotRemoveAllowedEvent event=new PlotRemoveAllowedEvent(world,plot,player,allowed);
            serverBridge.getEventBus().post(event);
            if (manager.isEconomyEnabled(pmi) && !event.isCancelled()) {
              price=pmi.getRemovePlayerPrice();
              if (serverBridge.has(player,price)) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
 else {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
                return true;
              }
            }
            if (!event.isCancelled()) {
              if (""String_Node_Str"".equals(allowed)) {
                plot.removeAllAllowed();
              }
 else {
                plot.removeAllowed(allowed);
              }
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
              if (isAdvancedLogging()) {
                if (price == 0) {
                  serverBridge.getLogger().info(allowed + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId());
                }
 else {
                  serverBridge.getLogger().info(allowed + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ allowed+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ plot.getId()+ (""String_Node_Str"" + C(""String_Node_Str"") + ""String_Node_Str""+ price));
                }
              }
            }
          }
 else {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + args[1]+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + plot.getId()+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
41998,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches()) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  IPlayer player=(IPlayer)sender;
  IWorld world=player.getWorld();
  if (player.hasPermission(PermissionNames.ADMIN_SETOWNER) && manager.isPlotWorld(world)) {
    PlotMapInfo pmi=manager.getMap(world);
    Plot plot=manager.getPlot(player);
    if (plot == null) {
      player.sendMessage(""String_Node_Str"");
      return true;
    }
    String newOwner=null;
    UUID newOwnerId=null;
    for (    IPlayer online : serverBridge.getOnlinePlayers()) {
      if (online.getName().equalsIgnoreCase(args[1])) {
        newOwner=online.getName();
        newOwnerId=online.getUniqueId();
        break;
      }
    }
    if (newOwnerId == null || newOwner == null) {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
    UUID oldowner=plot.getOwnerId();
    if (!oldowner.equals(newOwnerId)) {
      PlotOwnerChangeEvent event=new PlotOwnerChangeEvent(world,plot,player,newOwner);
      serverBridge.getEventBus().post(event);
      if (!event.isCancelled()) {
        plot.setForSale(false);
        manager.removeSellSign(plot,world);
        plot.resetExpire(pmi.getDaysToExpiration());
        plot.updateField(""String_Node_Str"",false);
        plot.setOwner(newOwner);
        plot.setOwnerId(newOwnerId);
        manager.setOwnerSign(world,plot);
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + newOwner);
      }
    }
 else {
      player.sendMessage(""String_Node_Str"");
    }
    return true;
  }
 else {
    return false;
  }
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches()) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  IPlayer player=(IPlayer)sender;
  IWorld world=player.getWorld();
  if (player.hasPermission(PermissionNames.ADMIN_SETOWNER) && manager.isPlotWorld(world)) {
    PlotMapInfo pmi=manager.getMap(world);
    Plot plot=manager.getPlot(player);
    if (plot == null) {
      player.sendMessage(""String_Node_Str"");
      return true;
    }
    String newOwner=null;
    UUID newOwnerId=null;
    for (    IPlayer online : serverBridge.getOnlinePlayers()) {
      if (online.getName().equals(args[1])) {
        newOwner=online.getName();
        newOwnerId=online.getUniqueId();
        break;
      }
    }
    if (newOwnerId == null) {
      player.sendMessage(C(""String_Node_Str""));
      return true;
    }
    UUID oldowner=plot.getOwnerId();
    if (!oldowner.equals(newOwnerId)) {
      PlotOwnerChangeEvent event=new PlotOwnerChangeEvent(world,plot,player,newOwner);
      serverBridge.getEventBus().post(event);
      if (!event.isCancelled()) {
        plot.setForSale(false);
        manager.removeSellSign(plot,world);
        plot.resetExpire(pmi.getDaysToExpiration());
        plot.updateField(""String_Node_Str"",false);
        plot.setOwner(newOwner);
        plot.setOwnerId(newOwnerId);
        manager.setOwnerSign(world,plot);
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + newOwner);
      }
    }
 else {
      player.sendMessage(""String_Node_Str"");
    }
    return true;
  }
 else {
    return false;
  }
}"
41999,"public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches() || ""String_Node_Str"".equalsIgnoreCase(args[1])) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equalsIgnoreCase(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_TRUST) || player.hasPermission(PermissionNames.USER_TRUST)) {
    IWorld world=player.getWorld();
    PlotMapInfo pmi=manager.getMap(world);
    if (manager.isPlotWorld(world)) {
      PlotId id=manager.getPlotId(player);
      if (id == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
 else       if (!manager.isPlotAvailable(id,pmi)) {
        Plot plot=manager.getPlotById(id,pmi);
        if (plot == null) {
          return true;
        }
        String trust=args[1];
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_TRUST)) {
          if (plot.isAllowedConsulting(trust)) {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + trust+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
 else {
            PlotAddTrustedEvent event=new PlotAddTrustedEvent(world,plot,player,trust);
            serverBridge.getEventBus().post(event);
            serverBridge.getEventBus().post(event);
            if (manager.isEconomyEnabled(pmi)) {
              double price=pmi.getAddPlayerPrice();
              if (serverBridge.has(player,price)) {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().format(price));
                return true;
              }
 else               if (!event.isCancelled()) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
 else {
                return true;
              }
            }
            if (!event.isCancelled()) {
              IPlayer allowed2=plugin.getServerBridge().getPlayer(trust);
              if (allowed2 != null) {
                plot.addAllowed(allowed2.getUniqueId().toString());
                plot.removeDenied(allowed2.getUniqueId().toString());
              }
 else {
                plot.addAllowed(trust);
                plot.removeDenied(trust);
              }
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + trust+ ""String_Node_Str""+ C(""String_Node_Str""));
              if (isAdvancedLogging()) {
                serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ trust+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ id);
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean execute(ICommandSender sender,String[] args) throws Exception {
  if (args.length < 2 && args.length >= 3) {
    throw new BadUsageException(getUsage());
  }
  if (args[1].length() > 16 || !validUserPattern.matcher(args[1]).matches() || ""String_Node_Str"".equalsIgnoreCase(args[1])) {
    throw new IllegalArgumentException(C(""String_Node_Str""));
  }
  if (""String_Node_Str"".equals(args[1]) && plugin.getConfig().getBoolean(""String_Node_Str"")) {
    sender.sendMessage(""String_Node_Str"");
    return true;
  }
  IPlayer player=(IPlayer)sender;
  if (player.hasPermission(PermissionNames.ADMIN_TRUST) || player.hasPermission(PermissionNames.USER_TRUST)) {
    IWorld world=player.getWorld();
    PlotMapInfo pmi=manager.getMap(world);
    if (manager.isPlotWorld(world)) {
      PlotId id=manager.getPlotId(player);
      if (id == null) {
        player.sendMessage(C(""String_Node_Str""));
        return true;
      }
 else       if (!manager.isPlotAvailable(id,pmi)) {
        Plot plot=manager.getPlotById(id,pmi);
        if (plot == null) {
          return true;
        }
        String trust=args[1];
        if (player.getUniqueId().equals(plot.getOwnerId()) || player.hasPermission(PermissionNames.ADMIN_TRUST)) {
          if (plot.isAllowedConsulting(trust)) {
            player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + trust+ ""String_Node_Str""+ C(""String_Node_Str""));
          }
 else {
            PlotAddTrustedEvent event=new PlotAddTrustedEvent(world,plot,player,trust);
            serverBridge.getEventBus().post(event);
            serverBridge.getEventBus().post(event);
            if (manager.isEconomyEnabled(pmi)) {
              double price=pmi.getAddPlayerPrice();
              if (serverBridge.has(player,price)) {
                player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ serverBridge.getEconomy().get().format(price));
                return true;
              }
 else               if (!event.isCancelled()) {
                EconomyResponse er=serverBridge.withdrawPlayer(player,price);
                if (!er.transactionSuccess()) {
                  player.sendMessage(er.errorMessage);
                  serverBridge.getLogger().warning(er.errorMessage);
                  return true;
                }
              }
 else {
                return true;
              }
            }
            if (!event.isCancelled()) {
              IPlayer allowed2=plugin.getServerBridge().getPlayer(trust);
              if (allowed2 != null) {
                plot.addTrusted(allowed2.getUniqueId().toString());
                plot.removeDenied(allowed2.getUniqueId().toString());
              }
 else {
                plot.addTrusted(trust);
                plot.removeDenied(trust);
              }
              player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + trust+ ""String_Node_Str""+ C(""String_Node_Str""));
              if (isAdvancedLogging()) {
                serverBridge.getLogger().info(player.getName() + ""String_Node_Str"" + C(""String_Node_Str"")+ ""String_Node_Str""+ trust+ ""String_Node_Str""+ C(""String_Node_Str"")+ ""String_Node_Str""+ id);
              }
            }
          }
        }
 else {
          player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
        }
      }
 else {
        player.sendMessage(C(""String_Node_Str"") + ""String_Node_Str"" + id+ ""String_Node_Str""+ C(""String_Node_Str""));
      }
    }
 else {
      player.sendMessage(C(""String_Node_Str""));
    }
  }
 else {
    return false;
  }
  return true;
}"
42000,"private boolean handleConsoleCommands(CommandSender sender,String[] args){
  if (args.length == 0) {
    PlotCommand command=commandMap.get(""String_Node_Str"");
    if (command != null) {
      try {
        return command.execute(new BukkitCommandSender(sender),args);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
 else {
    if (""String_Node_Str"".equalsIgnoreCase(args[0])) {
      PlotCommand command=commandMap.get(""String_Node_Str"");
      if (command != null) {
        try {
          return command.execute(new BukkitCommandSender(sender),args);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
  return false;
}","private boolean handleConsoleCommands(CommandSender sender,String[] args){
  if (args.length == 0) {
    PlotCommand command=commandMap.get(""String_Node_Str"");
    if (command != null) {
      return command.execute(new BukkitCommandSender(sender),args);
    }
  }
 else {
    if (""String_Node_Str"".equalsIgnoreCase(args[0])) {
      PlotCommand command=commandMap.get(""String_Node_Str"");
      if (command != null) {
        return command.execute(new BukkitCommandSender(sender),args);
      }
    }
  }
  return false;
}"
