record_number,buggy_code,fixed_code,anthropic_explanation
38001,"private void sendDiscoveryFailed(String switchId,String portId,Tuple tuple) throws IOException {
  String discoFail=OFEMessageUtils.createIslFail(switchId,portId);
  Values dataVal=new Values(PAYLOAD,discoFail,switchId,portId,OFEMessageUtils.LINK_DOWN);
  collector.emit(topoEngTopic,tuple,dataVal);
  discovery.handleFailed(switchId,portId);
  logger.warn(""String_Node_Str"",discoFail);
}","private void sendDiscoveryFailed(String switchId,String portId,Tuple tuple) throws IOException {
  String discoFail=OFEMessageUtils.createIslFail(switchId,portId);
  collector.emit(topoEngTopic,tuple,new Values(PAYLOAD,discoFail));
  discovery.handleFailed(switchId,portId);
  logger.warn(""String_Node_Str"",discoFail);
}","The original code incorrectly emitted additional unnecessary parameters (switchId, portId, OFEMessageUtils.LINK_DOWN) in the Values object, which were not required for the message transmission. The fixed code simplifies the emission by only including the payload and disco fail message, removing extraneous data that was not essential for the operation. This streamlines the code, reduces potential overhead, and ensures a more focused and efficient message emission process."
38002,"private void parseRecord(ConsumerRecord record){
  try {
    if (record.value() instanceof String) {
      String value=(String)record.value();
      BaseMessage message=MAPPER.readValue(value,BaseMessage.class);
      if (message instanceof CommandMessage) {
        logger.debug(""String_Node_Str"",value);
        doControllerMsg((CommandMessage)message);
      }
 else {
        logger.trace(""String_Node_Str"",message);
      }
    }
 else {
      logger.error(""String_Node_Str"",record.value());
    }
  }
 catch (  Exception exception) {
    logger.error(""String_Node_Str"",record.value(),exception);
  }
}","private void parseRecord(ConsumerRecord record){
  try {
    if (record.value() instanceof String) {
      String value=(String)record.value();
      CommandMessage message=MAPPER.readValue(value,CommandMessage.class);
      doControllerMsg((CommandMessage)message);
    }
 else {
      logger.error(""String_Node_Str"",record.value());
    }
  }
 catch (  Exception exception) {
    logger.error(""String_Node_Str"",record.value(),exception);
  }
}","The original code unnecessarily checked for a base message type and added redundant logging, potentially missing specific command message processing. The fixed code directly deserializes the record value to a CommandMessage and calls the controller method, simplifying the logic and ensuring targeted message handling. This approach reduces complexity, improves type safety, and streamlines the message processing workflow by focusing on the specific message type needed."
38003,"/** 
 * Returns CommandData entity constructed by data string from json resource file.
 * @param value data string from json resource file
 * @return CommandData entity
 * @throws IOException if mapping fails
 */
private static CommandData prepareData(String value) throws IOException {
  Message message=MAPPER.readValue(value,Message.class);
  CommandMessage commandMessage=(CommandMessage)message;
  return commandMessage.getData();
}","/** 
 * Returns CommandData entity constructed by data string from json resource file.
 * @param value data string from json resource file
 * @return CommandData entity
 * @throws IOException if mapping fails
 */
private static CommandData prepareData(String value) throws IOException {
  CommandMessage message=MAPPER.readValue(value,CommandMessage.class);
  return message.getData();
}","The original code incorrectly casts a generic Message to CommandMessage, which can lead to potential ClassCastException if the deserialization doesn't match the expected type. The fixed code directly deserializes the JSON into CommandMessage, eliminating the unnecessary and risky casting step. This approach ensures type safety, improves code reliability, and simplifies the data extraction process by directly accessing the getData() method."
38004,"/** 
 * Runs test case.
 * @param value       data string from json resource file
 * @param flowCommand OFFlowAdd instance to compare result with
 * @throws InterruptedException if test was interrupted during run
 */
private void runTest(final String value,final OFFlowAdd flowCommand,final OFMeterMod meterCommand,final OFFlowAdd reverseFlowCommand,final OFMeterMod reverseMeterCommand) throws InterruptedException {
  ConsumerRecord<String,String> record=new ConsumerRecord<>(""String_Node_Str"",0,0,""String_Node_Str"",value);
  KafkaMessageCollector.ParseRecord parseRecord=collector.new ParseRecord(record);
  Capture<OFFlowAdd> flowAddCapture=flowCommand == null ? null : newCapture(CaptureType.ALL);
  Capture<OFMeterMod> meterAddCapture=meterCommand == null ? null : newCapture(CaptureType.ALL);
  prepareMocks(flowAddCapture,meterAddCapture,reverseFlowCommand != null,reverseMeterCommand != null);
  parseRecordExecutor.execute(parseRecord);
  parseRecordExecutor.shutdown();
  parseRecordExecutor.awaitTermination(10,TimeUnit.SECONDS);
  if (meterCommand != null) {
    assertEquals(meterCommand,meterAddCapture.getValues().get(0));
    if (reverseMeterCommand != null) {
      assertEquals(reverseMeterCommand,meterAddCapture.getValues().get(1));
    }
  }
  if (flowCommand != null) {
    assertEquals(flowCommand,flowAddCapture.getValues().get(0));
    if (reverseFlowCommand != null) {
      assertEquals(reverseFlowCommand,flowAddCapture.getValues().get(1));
    }
  }
}","/** 
 * Runs test case.
 * @param value       data string from json resource file
 * @param flowCommand OFFlowAdd instance to compare result with
 * @throws InterruptedException if test was interrupted during run
 */
private void runTest(final String value,final OFFlowAdd flowCommand,final OFMeterMod meterCommand,final OFFlowAdd reverseFlowCommand,final OFMeterMod reverseMeterCommand) throws InterruptedException {
  ConsumerRecord<String,String> record=new ConsumerRecord<>(""String_Node_Str"",0,0,""String_Node_Str"",value);
  KafkaMessageCollector.ParseRecord parseRecord=collector.new ParseRecord(record);
  Capture<OFFlowAdd> flowAddCapture=flowCommand == null ? null : newCapture(CaptureType.ALL);
  Capture<OFMeterMod> meterAddCapture=meterCommand == null ? null : newCapture(CaptureType.ALL);
  prepareMocks(flowAddCapture,meterAddCapture,reverseFlowCommand != null,reverseMeterCommand != null);
  parseRecordExecutor.execute(parseRecord);
  parseRecordExecutor.shutdown();
  parseRecordExecutor.awaitTermination(10,TimeUnit.SECONDS);
  if (meterCommand != null) {
    System.out.println(""String_Node_Str"" + meterCommand);
    System.out.println(""String_Node_Str"" + meterAddCapture.getValues());
    assertEquals(meterCommand,meterAddCapture.getValues().get(0));
    if (reverseMeterCommand != null) {
      assertEquals(reverseMeterCommand,meterAddCapture.getValues().get(1));
    }
  }
  if (flowCommand != null) {
    assertEquals(flowCommand,flowAddCapture.getValues().get(0));
    if (reverseFlowCommand != null) {
      assertEquals(reverseFlowCommand,flowAddCapture.getValues().get(1));
    }
  }
}","The original code lacked diagnostic logging, making it difficult to understand test failures when meter commands did not match expectations. The fixed code adds System.out.println() statements to print the expected meter command and actual captured values, providing visibility into the test's internal state. These logging statements help developers quickly identify discrepancies between expected and actual meter commands during test execution, enhancing debugging capabilities."
38005,"@Test @Ignore public void BasicSwitchPortEventsTest() throws Exception {
  System.out.println(""String_Node_Str"");
  String sw1_up=OFEMessageUtils.createSwitchDataMessage(OFEMessageUtils.SWITCH_UP,""String_Node_Str"");
  String sw2_up=OFEMessageUtils.createSwitchDataMessage(OFEMessageUtils.SWITCH_UP,""String_Node_Str"");
  String sw1p1_up=OFEMessageUtils.createPortDataMessage(OFEMessageUtils.PORT_UP,""String_Node_Str"",""String_Node_Str"");
  String sw2p2_up=OFEMessageUtils.createPortDataMessage(OFEMessageUtils.PORT_UP,""String_Node_Str"",""String_Node_Str"");
  String sw2p2_down=OFEMessageUtils.createPortDataMessage(OFEMessageUtils.PORT_DOWN,""String_Node_Str"",""String_Node_Str"");
  String switch_topic=InfoEventSplitterBolt.I_SWITCH_UPDOWN;
  String port_topic=InfoEventSplitterBolt.I_PORT_UPDOWN;
  kProducer.pushMessage(switch_topic,sw1_up);
  kProducer.pushMessage(switch_topic,sw2_up);
  kProducer.pushMessage(port_topic,sw1p1_up);
  kProducer.pushMessage(port_topic,sw2p2_up);
  kProducer.pushMessage(switch_topic,sw1_up);
  kProducer.pushMessage(switch_topic,sw2_up);
  kProducer.pushMessage(port_topic,sw1p1_up);
  kProducer.pushMessage(port_topic,sw2p2_up);
  Utils.sleep(4 * 1000);
  messagesExpected=8;
  messagesReceived=safeLinesCount(discoFiler.getFiler().getFile());
  Assert.assertEquals(messagesExpected,messagesReceived);
  Utils.sleep(1 * 1000);
  kProducer.pushMessage(port_topic,sw2p2_down);
  Utils.sleep(2 * 1000);
  messagesReceived=safeLinesCount(discoFiler.getFiler().getFile());
  if (messagesReceived == 0) {
    System.out.println(""String_Node_Str"");
    for (    String s : Files.readLines(discoFiler.getFiler().getFile(),Charsets.UTF_8)) {
      System.out.println(""String_Node_Str"" + s);
    }
  }
  Assert.assertTrue(messagesReceived > 0);
  cluster.killTopology(manager.makeTopologyName());
  cluster.killTopology(""String_Node_Str"");
  Utils.sleep(4 * 1000);
}","@Test @Ignore public void BasicSwitchPortEventsTest() throws Exception {
  System.out.println(""String_Node_Str"");
  OFEventWFMTopology manager=new OFEventWFMTopology(makeLaunchEnvironment());
  TopologyConfig config=manager.getConfig();
  String sw1_up=OFEMessageUtils.createSwitchDataMessage(OFEMessageUtils.SWITCH_UP,""String_Node_Str"");
  String sw2_up=OFEMessageUtils.createSwitchDataMessage(OFEMessageUtils.SWITCH_UP,""String_Node_Str"");
  String sw1p1_up=OFEMessageUtils.createPortDataMessage(OFEMessageUtils.PORT_UP,""String_Node_Str"",""String_Node_Str"");
  String sw2p2_up=OFEMessageUtils.createPortDataMessage(OFEMessageUtils.PORT_UP,""String_Node_Str"",""String_Node_Str"");
  String sw2p2_down=OFEMessageUtils.createPortDataMessage(OFEMessageUtils.PORT_DOWN,""String_Node_Str"",""String_Node_Str"");
  String switch_topic=config.getKafkaTopoDiscoTopic();
  String port_topic=config.getKafkaTopoDiscoTopic();
  kProducer.pushMessage(switch_topic,sw1_up);
  kProducer.pushMessage(switch_topic,sw2_up);
  kProducer.pushMessage(port_topic,sw1p1_up);
  kProducer.pushMessage(port_topic,sw2p2_up);
  kProducer.pushMessage(switch_topic,sw1_up);
  kProducer.pushMessage(switch_topic,sw2_up);
  kProducer.pushMessage(port_topic,sw1p1_up);
  kProducer.pushMessage(port_topic,sw2p2_up);
  Utils.sleep(4 * 1000);
  messagesExpected=8;
  messagesReceived=safeLinesCount(discoFiler.getFiler().getFile());
  Assert.assertEquals(messagesExpected,messagesReceived);
  Utils.sleep(1 * 1000);
  kProducer.pushMessage(port_topic,sw2p2_down);
  Utils.sleep(2 * 1000);
  messagesReceived=safeLinesCount(discoFiler.getFiler().getFile());
  if (messagesReceived == 0) {
    System.out.println(""String_Node_Str"");
    for (    String s : Files.readLines(discoFiler.getFiler().getFile(),Charsets.UTF_8)) {
      System.out.println(""String_Node_Str"" + s);
    }
  }
  Assert.assertTrue(messagesReceived > 0);
  cluster.killTopology(manager.makeTopologyName());
  cluster.killTopology(""String_Node_Str"");
  Utils.sleep(4 * 1000);
}","The original code used hardcoded string constants for Kafka topics, which could lead to incorrect message routing and potential system failures. The fixed code introduces a configuration object (`TopologyConfig`) to dynamically retrieve Kafka topics, ensuring proper topic selection and flexibility. By leveraging configuration management, the new implementation provides a more robust and maintainable approach to handling event messaging in the topology."
38006,"/** 
 * BasicLinkDiscoveryTest will exercise the basics of Link Discovery test. The key results should show up in a kafka topic, which are dumped to file.
 */
@Test @Ignore public void basicLinkDiscoveryTest() throws IOException, ConfigurationException, CmdLineException {
  System.out.println(""String_Node_Str"");
  OFEventWFMTopology manager=new OFEventWFMTopology(makeLaunchEnvironment());
  TopologyConfig config=manager.getConfig();
  Tuple tuple;
  KeyValueState<String,Object> state=new InMemoryKeyValueState<>();
  initMocks();
  List<PathNode> nodes=Arrays.asList(new PathNode(""String_Node_Str"",1,0,10L),new PathNode(""String_Node_Str"",2,1,10L));
  InfoData data=new IslInfoData(10L,nodes,10000L,IslChangeType.DISCOVERED,9000L);
  String isl_discovered=MAPPER.writeValueAsString(data);
  OFELinkBolt linkBolt=new OFELinkBolt(config);
  linkBolt.prepare(stormConfig(),topologyContext,outputCollector);
  linkBolt.initState(state);
  ArrayList<DiscoveryFilterEntity> skipNodes=new ArrayList<>(1);
  skipNodes.add(new DiscoveryFilterEntity(""String_Node_Str"",""String_Node_Str""));
  CommandMessage islFilterSetup=new CommandMessage(new DiscoveryFilterPopulateData(skipNodes),1,""String_Node_Str"",Destination.WFM_OF_DISCOVERY);
  String json=MAPPER.writeValueAsString(islFilterSetup);
  tuple=new TupleImpl(topologyContext,Collections.singletonList(json),4,""String_Node_Str"");
  linkBolt.execute(tuple);
  tuple=new TupleImpl(topologyContext,Arrays.asList(""String_Node_Str"",OFEMessageUtils.SWITCH_UP),0,InfoEventSplitterBolt.I_SWITCH_UPDOWN);
  linkBolt.execute(tuple);
  tuple=new TupleImpl(topologyContext,Arrays.asList(""String_Node_Str"",OFEMessageUtils.SWITCH_UP),0,InfoEventSplitterBolt.I_SWITCH_UPDOWN);
  linkBolt.execute(tuple);
  tuple=new TupleImpl(topologyContext,Arrays.asList(""String_Node_Str"",""String_Node_Str"",OFEMessageUtils.PORT_UP),1,InfoEventSplitterBolt.I_PORT_UPDOWN);
  linkBolt.execute(tuple);
  tuple=new TupleImpl(topologyContext,Arrays.asList(""String_Node_Str"",""String_Node_Str"",OFEMessageUtils.PORT_UP),1,InfoEventSplitterBolt.I_PORT_UPDOWN);
  linkBolt.execute(tuple);
  Tuple tickTuple=new TupleImpl(topologyContext,Collections.emptyList(),2,Constants.SYSTEM_TICK_STREAM_ID);
  linkBolt.execute(tickTuple);
  tuple=new TupleImpl(topologyContext,Collections.singletonList(isl_discovered),3,InfoEventSplitterBolt.I_ISL_UPDOWN);
  linkBolt.execute(tuple);
  linkBolt.execute(tickTuple);
  linkBolt.execute(tickTuple);
  messagesExpected=7;
  messagesReceived=outputCollectorMock.getMessagesCount(config.getKafkaTopoDiscoTopic());
  Assert.assertEquals(messagesExpected,messagesReceived);
  messagesExpected=7;
  messagesReceived=outputCollectorMock.getMessagesCount(config.getKafkaTopoDiscoTopic());
  Assert.assertEquals(messagesExpected,messagesReceived);
  linkBolt.execute(tickTuple);
  messagesExpected=7;
  messagesReceived=outputCollectorMock.getMessagesCount(config.getKafkaTopoDiscoTopic());
  Assert.assertEquals(messagesExpected,messagesReceived);
  messagesExpected=7;
  messagesReceived=outputCollectorMock.getMessagesCount(config.getKafkaTopoDiscoTopic());
  Assert.assertEquals(messagesExpected,messagesReceived);
}","/** 
 * BasicLinkDiscoveryTest will exercise the basics of Link Discovery test. The key results should show up in a kafka topic, which are dumped to file.
 */
@Test @Ignore public void basicLinkDiscoveryTest() throws IOException, ConfigurationException, CmdLineException {
  System.out.println(""String_Node_Str"");
  OFEventWFMTopology manager=new OFEventWFMTopology(makeLaunchEnvironment());
  TopologyConfig config=manager.getConfig();
  String topo_input_topic=config.getKafkaTopoDiscoTopic();
  Tuple tuple;
  KeyValueState<String,Object> state=new InMemoryKeyValueState<>();
  initMocks(topo_input_topic);
  List<PathNode> nodes=Arrays.asList(new PathNode(""String_Node_Str"",1,0,10L),new PathNode(""String_Node_Str"",2,1,10L));
  InfoData data=new IslInfoData(10L,nodes,10000L,IslChangeType.DISCOVERED,9000L);
  String isl_discovered=MAPPER.writeValueAsString(data);
  OFELinkBolt linkBolt=new OFELinkBolt(config);
  linkBolt.prepare(stormConfig(),topologyContext,outputCollector);
  linkBolt.initState(state);
  ArrayList<DiscoveryFilterEntity> skipNodes=new ArrayList<>(1);
  skipNodes.add(new DiscoveryFilterEntity(""String_Node_Str"",""String_Node_Str""));
  CommandMessage islFilterSetup=new CommandMessage(new DiscoveryFilterPopulateData(skipNodes),1,""String_Node_Str"",Destination.WFM_OF_DISCOVERY);
  String json=MAPPER.writeValueAsString(islFilterSetup);
  tuple=new TupleImpl(topologyContext,Collections.singletonList(json),4,""String_Node_Str"");
  linkBolt.execute(tuple);
  tuple=new TupleImpl(topologyContext,Arrays.asList(""String_Node_Str"",OFEMessageUtils.SWITCH_UP),0,topo_input_topic);
  linkBolt.execute(tuple);
  tuple=new TupleImpl(topologyContext,Arrays.asList(""String_Node_Str"",OFEMessageUtils.SWITCH_UP),0,topo_input_topic);
  linkBolt.execute(tuple);
  tuple=new TupleImpl(topologyContext,Arrays.asList(""String_Node_Str"",""String_Node_Str"",OFEMessageUtils.PORT_UP),1,topo_input_topic);
  linkBolt.execute(tuple);
  tuple=new TupleImpl(topologyContext,Arrays.asList(""String_Node_Str"",""String_Node_Str"",OFEMessageUtils.PORT_UP),1,topo_input_topic);
  linkBolt.execute(tuple);
  Tuple tickTuple=new TupleImpl(topologyContext,Collections.emptyList(),2,Constants.SYSTEM_TICK_STREAM_ID);
  linkBolt.execute(tickTuple);
  tuple=new TupleImpl(topologyContext,Collections.singletonList(isl_discovered),3,topo_input_topic);
  linkBolt.execute(tuple);
  linkBolt.execute(tickTuple);
  linkBolt.execute(tickTuple);
  messagesExpected=7;
  messagesReceived=outputCollectorMock.getMessagesCount(config.getKafkaTopoDiscoTopic());
  Assert.assertEquals(messagesExpected,messagesReceived);
  messagesExpected=7;
  messagesReceived=outputCollectorMock.getMessagesCount(config.getKafkaTopoDiscoTopic());
  Assert.assertEquals(messagesExpected,messagesReceived);
  linkBolt.execute(tickTuple);
  messagesExpected=7;
  messagesReceived=outputCollectorMock.getMessagesCount(config.getKafkaTopoDiscoTopic());
  Assert.assertEquals(messagesExpected,messagesReceived);
  messagesExpected=7;
  messagesReceived=outputCollectorMock.getMessagesCount(config.getKafkaTopoDiscoTopic());
  Assert.assertEquals(messagesExpected,messagesReceived);
}","The original code used hardcoded stream identifiers that did not match the actual topology configuration, potentially causing incorrect tuple routing and processing. The fixed code introduces a dynamic `topo_input_topic` variable derived from the configuration and uses it consistently across tuple creation, ensuring stream alignment with the topology's expected input streams. This change improves test reliability by dynamically adapting to the configuration and preventing potential stream mismatch errors during link discovery testing."
38007,"private void initMocks(){
  Fields switchSchema=new Fields(OFEMessageUtils.FIELD_SWITCH_ID,OFEMessageUtils.FIELD_STATE);
  when(topologyContext.getComponentId(0)).thenReturn(InfoEventSplitterBolt.I_SWITCH_UPDOWN);
  when(topologyContext.getComponentOutputFields(InfoEventSplitterBolt.I_SWITCH_UPDOWN,InfoEventSplitterBolt.I_SWITCH_UPDOWN)).thenReturn(switchSchema);
  Fields portSchema=new Fields(OFEMessageUtils.FIELD_SWITCH_ID,OFEMessageUtils.FIELD_PORT_ID,OFEMessageUtils.FIELD_STATE);
  when(topologyContext.getComponentId(1)).thenReturn(InfoEventSplitterBolt.I_PORT_UPDOWN);
  when(topologyContext.getComponentOutputFields(InfoEventSplitterBolt.I_PORT_UPDOWN,InfoEventSplitterBolt.I_PORT_UPDOWN)).thenReturn(portSchema);
  Fields tickSchema=new Fields();
  when(topologyContext.getComponentId(2)).thenReturn(Constants.SYSTEM_COMPONENT_ID);
  when(topologyContext.getComponentOutputFields(Constants.SYSTEM_COMPONENT_ID,Constants.SYSTEM_TICK_STREAM_ID)).thenReturn(tickSchema);
  Fields islSchema=new Fields(InfoEventSplitterBolt.I_ISL_UPDOWN);
  when(topologyContext.getComponentId(3)).thenReturn(InfoEventSplitterBolt.I_ISL_UPDOWN);
  when(topologyContext.getComponentOutputFields(InfoEventSplitterBolt.I_ISL_UPDOWN,InfoEventSplitterBolt.I_ISL_UPDOWN)).thenReturn(islSchema);
  when(topologyContext.getComponentId(4)).thenReturn(OFEventWFMTopology.SPOUT_ID_INPUT);
  when(topologyContext.getComponentOutputFields(OFEventWFMTopology.SPOUT_ID_INPUT,AbstractTopology.MESSAGE_FIELD)).thenReturn(AbstractTopology.fieldMessage);
}","private void initMocks(String topo_input_topic){
  Fields switchSchema=new Fields(OFEMessageUtils.FIELD_SWITCH_ID,OFEMessageUtils.FIELD_STATE);
  when(topologyContext.getComponentId(0)).thenReturn(topo_input_topic);
  when(topologyContext.getComponentOutputFields(topo_input_topic,topo_input_topic)).thenReturn(switchSchema);
  Fields portSchema=new Fields(OFEMessageUtils.FIELD_SWITCH_ID,OFEMessageUtils.FIELD_PORT_ID,OFEMessageUtils.FIELD_STATE);
  when(topologyContext.getComponentId(1)).thenReturn(topo_input_topic);
  when(topologyContext.getComponentOutputFields(topo_input_topic,topo_input_topic)).thenReturn(portSchema);
  Fields tickSchema=new Fields();
  when(topologyContext.getComponentId(2)).thenReturn(Constants.SYSTEM_COMPONENT_ID);
  when(topologyContext.getComponentOutputFields(Constants.SYSTEM_COMPONENT_ID,Constants.SYSTEM_TICK_STREAM_ID)).thenReturn(tickSchema);
  Fields islSchema=new Fields(topo_input_topic);
  when(topologyContext.getComponentId(3)).thenReturn(topo_input_topic);
  when(topologyContext.getComponentOutputFields(topo_input_topic,topo_input_topic)).thenReturn(islSchema);
  when(topologyContext.getComponentId(4)).thenReturn(OFEventWFMTopology.SPOUT_ID_INPUT);
  when(topologyContext.getComponentOutputFields(OFEventWFMTopology.SPOUT_ID_INPUT,AbstractTopology.MESSAGE_FIELD)).thenReturn(AbstractTopology.fieldMessage);
}","The original code hardcoded specific component IDs and stream names, making the method inflexible and tightly coupled to a specific topology configuration. The fixed code introduces a parameterized `topo_input_topic` that replaces hardcoded values, allowing dynamic configuration of component IDs and stream names. This modification increases the method's reusability, flexibility, and makes the code more adaptable to different topology setups without requiring multiple method implementations."
38008,"@BeforeClass public static void setupOnce() throws Exception {
  System.out.println(""String_Node_Str"");
  makeConfigFile();
  server=new TestUtils.KafkaTestFixture(makeUnboundConfig());
  server.start();
  cluster=new LocalCluster();
  kProducer=new TestKafkaProducer(kafkaProperties());
}","@BeforeClass public static void setupOnce() throws Exception {
  System.out.println(""String_Node_Str"");
  clusterParam=new MkClusterParam();
  clusterParam.setSupervisors(1);
  Config daemonConfig=new Config();
  daemonConfig.put(Config.STORM_LOCAL_MODE_ZMQ,false);
  clusterParam.setDaemonConf(daemonConfig);
  makeConfigFile();
  Config conf=new Config();
  conf.setNumWorkers(1);
  completeTopologyParam=new CompleteTopologyParam();
  completeTopologyParam.setStormConf(conf);
}","The original code improperly initialized Kafka server and producer without proper Storm configuration parameters. The fixed code introduces explicit configuration setup using `MkClusterParam`, `Config`, and `CompleteTopologyParam`, defining critical settings like supervisor count and worker configuration. These changes ensure more robust and controlled topology initialization, providing better predictability and management of Storm cluster resources."
38009,"@Override public void execute(Tuple tuple){
  try {
    String tupleSource=tuple.getSourceComponent();
switch (tupleSource) {
case SimulatorTopology.SIMULATOR_SPOUT:
      doCommand(tuple);
    break;
default :
  logger.error(""String_Node_Str"",tupleSource);
}
}
 catch (Exception e) {
logger.error(e);
}
 finally {
collector.ack(tuple);
}
}","@Override public void execute(Tuple tuple){
  try {
    String tupleSource=tuple.getSourceComponent();
switch (tupleSource) {
case SimulatorTopology.SIMULATOR_SPOUT:
      doCommand(tuple);
    break;
default :
  logger.error(""String_Node_Str"",tupleSource);
}
}
 catch (Exception e) {
logger.error(e.toString());
}
 finally {
collector.ack(tuple);
}
}","The original code logs the entire exception object, which can lead to incomplete or unreadable error messages. In the fixed code, `e.toString()` is used to convert the exception to a clear, string-based error message that provides more precise logging information. This change ensures better error traceability and debugging by capturing the exception's details in a more readable and manageable format."
38010,"protected List<Values> addSwitch(SwitchMessage switchMessage) throws Exception {
  ISwitchImpl sw=switches.get(switchMessage.getDpid());
  List<Values> values=new ArrayList<>();
  if (sw == null) {
    logger.info(""String_Node_Str"");
    sw=new ISwitchImpl(switchMessage.getDpid(),switchMessage.getNumOfPorts(),PortStateType.DOWN);
    sw.activate();
    List<LinkMessage> links=switchMessage.getLinks();
    for (    LinkMessage l : links) {
      IPortImpl localPort=sw.getPort(l.getLocalPort());
      localPort.setLatency(l.getLatency());
      localPort.setPeerPortNum(l.getPeerPort());
      localPort.setPeerSwitch(l.getPeerSwitch());
      localPort.enable();
    }
    switches.put(sw.getDpid().toString(),sw);
    values.add(new Values(""String_Node_Str"",makeSwitchMessage(sw,SwitchState.ADDED)));
    values.add(new Values(""String_Node_Str"",makeSwitchMessage(sw,SwitchState.ACTIVATED)));
    for (    IPortImpl p : sw.getPorts()) {
      PortChangeType changeType=p.isActive() ? PortChangeType.UP : PortChangeType.DOWN;
      values.add(new Values(""String_Node_Str"",makePortMessage(sw,p.getNumber(),changeType)));
    }
  }
  return values;
}","protected List<Values> addSwitch(SwitchMessage switchMessage) throws Exception {
  ISwitchImpl sw=switches.get(switchMessage.getDpid());
  List<Values> values=new ArrayList<>();
  if (sw == null) {
    logger.info(""String_Node_Str"");
    sw=new ISwitchImpl(switchMessage.getDpid(),switchMessage.getNumOfPorts(),PortStateType.DOWN);
    sw.activate();
    List<LinkMessage> links=switchMessage.getLinks();
    for (    LinkMessage l : links) {
      IPortImpl localPort=sw.getPort(l.getLocalPort());
      localPort.setLatency(l.getLatency());
      localPort.setPeerPortNum(l.getPeerPort());
      localPort.setPeerSwitch(l.getPeerSwitch());
      localPort.enable();
    }
    switches.put(sw.getDpid().toString(),sw);
    values.add(new Values(""String_Node_Str"",makeSwitchMessage(sw,SwitchState.ADDED)));
    values.add(new Values(""String_Node_Str"",makeSwitchMessage(sw,SwitchState.ACTIVATED)));
    for (    IPortImpl p : sw.getPorts()) {
      PortChangeType changeType=p.isActive() ? PortChangeType.UP : PortChangeType.DOWN;
      if (changeType == PortChangeType.UP) {
        values.add(new Values(""String_Node_Str"",makePortMessage(sw,p.getNumber(),changeType)));
      }
    }
  }
  return values;
}","The original code added port messages for all ports, regardless of their state, potentially generating unnecessary notifications. The fixed code adds port messages only for ports in the UP state, filtering out inactive ports before creating messages. This modification reduces redundant messaging and ensures that only relevant port state changes are reported, improving system efficiency and clarity."
38011,"protected void discoverIslPartTwo(Tuple tuple,IslInfoData data) throws Exception {
  ISwitchImpl sw=getSwitch(data.getPath().get(1).getSwitchId());
  if (!sw.isActive()) {
    return;
  }
  IPortImpl port=sw.getPort(data.getPath().get(1).getPortNo());
  if (port.isActiveIsl()) {
    long now=Instant.now().toEpochMilli();
    InfoMessage infoMessage=new InfoMessage(data,now,""String_Node_Str"",null);
    logger.info(""String_Node_Str"",data.toString());
    collector.emit(SimulatorTopology.KAFKA_BOLT_STREAM,tuple,new Values(""String_Node_Str"",Utils.MAPPER.writeValueAsString(infoMessage)));
  }
}","protected void discoverIslPartTwo(Tuple tuple,IslInfoData data) throws Exception {
  ISwitchImpl sw=getSwitch(data.getPath().get(1).getSwitchId());
  if (!sw.isActive()) {
    return;
  }
  IPortImpl port=sw.getPort(data.getPath().get(1).getPortNo());
  if (port.isActiveIsl()) {
    long now=Instant.now().toEpochMilli();
    InfoMessage infoMessage=new InfoMessage(data,now,""String_Node_Str"",null);
    logger.debug(""String_Node_Str"",data.toString());
    collector.emit(SimulatorTopology.KAFKA_BOLT_STREAM,tuple,new Values(""String_Node_Str"",Utils.MAPPER.writeValueAsString(infoMessage)));
  }
}","The original code used `logger.info()`, which logs messages at an informative level, potentially cluttering logs with excessive details. The fixed code changes this to `logger.debug()`, which logs messages only when debug mode is enabled, reducing unnecessary log noise. This modification provides more selective logging, improving performance and making troubleshooting more focused by revealing detailed information only when explicitly needed."
38012,"@Override public void execute(Tuple tuple){
  logger.debug(""String_Node_Str"",tuple.toString());
  try {
    String tupleSource=tuple.getSourceComponent();
switch (tupleSource) {
case SimulatorTopology.COMMAND_BOLT:
case SimulatorTopology.SWITCH_BOLT:
      doCommand(tuple);
    break;
case SimulatorTopology.SIMULATOR_COMMAND_BOLT:
  doSimulatorCommand(tuple);
break;
default :
logger.error(""String_Node_Str"",tupleSource);
}
}
 catch (Exception e) {
logger.error(e);
e.printStackTrace();
}
 finally {
collector.ack(tuple);
}
}","@Override public void execute(Tuple tuple){
  logger.debug(""String_Node_Str"",tuple.toString());
  try {
    String tupleSource=tuple.getSourceComponent();
switch (tupleSource) {
case SimulatorTopology.COMMAND_BOLT:
case SimulatorTopology.SWITCH_BOLT:
      doCommand(tuple);
    break;
case SimulatorTopology.SIMULATOR_COMMAND_BOLT:
  doSimulatorCommand(tuple);
break;
default :
logger.error(""String_Node_Str"",tupleSource);
}
}
 catch (Exception e) {
logger.error(e.toString());
e.printStackTrace();
}
 finally {
collector.ack(tuple);
}
}","The buggy code incorrectly logs the entire exception object, which may not provide clear error details and can lead to potential logging issues. In the fixed code, `e.toString()` is used to convert the exception to a readable string, ensuring more precise and informative error logging. This change enhances error traceability and debugging capabilities by providing a clearer representation of the exception during runtime."
38013,"@Test public void getFlowName() throws Exception {
  assertEquals(flowName,flow.getCookie());
}","@Test public void getFlowName() throws Exception {
  assertEquals(flowName,flow.getFlowName());
}","The original code incorrectly calls `getCookie()` instead of the intended method `getFlowName()`, which would cause a test failure by retrieving the wrong object property. The fixed code replaces `getCookie()` with `getFlowName()`, ensuring the test correctly checks the flow's name attribute as originally intended. By using the proper method, the test now accurately validates the flow's name, preventing potential misunderstandings about the object's state and improving test reliability."
38014,"/** 
 * Instance constructor.
 * @param flowName        name of the flow
 * @param switchId        switch ID for flow installation
 * @param inputPort       input port of the flow
 * @param outputPort      output port of the flow
 * @param inputVlanId     input vlan id value
 * @param outputVlanId    output vlan id value
 * @param outputVlanType  output vlan tag action
 * @param bandwidth       flow bandwidth
 * @param inputMeterId    allocated meter id
 * @param outputMeterId   allocated meter id
 * @throws IllegalArgumentException if any of arguments is null
 */
@JsonCreator public InstallOneSwitchFlowCommandData(@JsonProperty(""String_Node_Str"") String cookie,@JsonProperty(""String_Node_Str"") String switchId,@JsonProperty(""String_Node_Str"") Number inputPort,@JsonProperty(""String_Node_Str"") Number outputPort,@JsonProperty(""String_Node_Str"") Number inputVlanId,@JsonProperty(""String_Node_Str"") Number outputVlanId,@JsonProperty(""String_Node_Str"") OutputVlanType outputVlanType,@JsonProperty(""String_Node_Str"") Number bandwidth,@JsonProperty(""String_Node_Str"") Number inputMeterId,@JsonProperty(""String_Node_Str"") Number outputMeterId){
  super(cookie,switchId,inputPort,outputPort);
  setInputVlanId(inputVlanId);
  setOutputVlanId(outputVlanId);
  setOutputVlanType(outputVlanType);
  setBandwidth(bandwidth);
  setInputMeterId(inputMeterId);
  setOutputMeterId(outputMeterId);
}","/** 
 * Instance constructor.
 * @param flowName        name of the flow
 * @param switchId        switch ID for flow installation
 * @param inputPort       input port of the flow
 * @param outputPort      output port of the flow
 * @param inputVlanId     input vlan id value
 * @param outputVlanId    output vlan id value
 * @param outputVlanType  output vlan tag action
 * @param bandwidth       flow bandwidth
 * @param inputMeterId    allocated meter id
 * @param outputMeterId   allocated meter id
 * @throws IllegalArgumentException if any of arguments is null
 */
@JsonCreator public InstallOneSwitchFlowCommandData(@JsonProperty(""String_Node_Str"") String flowName,@JsonProperty(""String_Node_Str"") String switchId,@JsonProperty(""String_Node_Str"") Number inputPort,@JsonProperty(""String_Node_Str"") Number outputPort,@JsonProperty(""String_Node_Str"") Number inputVlanId,@JsonProperty(""String_Node_Str"") Number outputVlanId,@JsonProperty(""String_Node_Str"") OutputVlanType outputVlanType,@JsonProperty(""String_Node_Str"") Number bandwidth,@JsonProperty(""String_Node_Str"") Number inputMeterId,@JsonProperty(""String_Node_Str"") Number outputMeterId){
  super(flowName,switchId,inputPort,outputPort);
  setInputVlanId(inputVlanId);
  setOutputVlanId(outputVlanId);
  setOutputVlanType(outputVlanType);
  setBandwidth(bandwidth);
  setInputMeterId(inputMeterId);
  setOutputMeterId(outputMeterId);
}","The original constructor incorrectly passed the `cookie` parameter instead of `flowName` to the superclass constructor, breaking the expected method signature. The fixed code replaces `cookie` with `flowName` in the superclass constructor call, ensuring proper initialization of the flow's name. This correction maintains the intended constructor behavior and provides the correct flow name during object creation."
38015,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  return toStringHelper(this).addValue(cookie).addValue(switchId).addValue(inputPort).addValue(outputPort).addValue(inputVlanId).addValue(outputVlanId).addValue(outputVlanType).addValue(bandwidth).addValue(inputMeterId).addValue(outputMeterId).toString();
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  return toStringHelper(this).addValue(flowName).addValue(switchId).addValue(inputPort).addValue(outputPort).addValue(inputVlanId).addValue(outputVlanId).addValue(outputVlanType).addValue(bandwidth).addValue(inputMeterId).addValue(outputMeterId).toString();
}","The original code incorrectly used `cookie` instead of `flowName` in the `toString()` method, which likely resulted in printing an incorrect or irrelevant identifier for the object. The fixed code replaces `cookie` with `flowName`, ensuring that the correct attribute is used when generating the string representation. This change improves the method's accuracy by displaying the meaningful flow name, providing more precise and useful debugging or logging information."
38016,"/** 
 * The data field holds the ""message_type"" and ""state"" fields.
 * @param root the ""data"" field of an ""INFO"" message
 */
private void splitInfoMessage(Map<String,?> root,Tuple tuple) throws JsonProcessingException {
  Values dataVal=new Values(""String_Node_Str"",new ObjectMapper().writeValueAsString(root));
  String key=((String)root.get(""String_Node_Str"")).toLowerCase();
  String state=(String)root.get(""String_Node_Str"");
switch (key) {
case ""String_Node_Str"":
    _collector.emit(I_SWITCH,tuple,dataVal);
  logger.debug(""String_Node_Str"",I_SWITCH,dataVal);
if (state.equals(""String_Node_Str"") || state.equals(""String_Node_Str"")) {
  _collector.emit(I_SWITCH_UPDOWN,tuple,dataVal);
  logger.debug(""String_Node_Str"",I_SWITCH_UPDOWN,dataVal);
}
 else {
  _collector.emit(I_SWITCH_OTHER,tuple,dataVal);
  logger.debug(""String_Node_Str"",I_SWITCH_OTHER,dataVal);
}
break;
case ""String_Node_Str"":
_collector.emit(I_PORT,tuple,dataVal);
if (state.equals(""String_Node_Str"") || state.equals(""String_Node_Str"")) {
_collector.emit(I_PORT_UPDOWN,tuple,dataVal);
}
 else {
_collector.emit(I_PORT_OTHER,tuple,dataVal);
}
break;
case ""String_Node_Str"":
_collector.emit(I_ISL,tuple,dataVal);
if (state.equals(""String_Node_Str"") || state.equals(""String_Node_Str"")) {
_collector.emit(I_ISL_UPDOWN,tuple,dataVal);
}
 else {
_collector.emit(I_ISL_OTHER,tuple,dataVal);
}
break;
default :
_collector.emit(I_OTHER,tuple,dataVal);
logger.warn(""String_Node_Str"",key,root);
}
}","/** 
 * The data field holds the ""message_type"" and ""state"" fields.
 * @param root the ""data"" field of an ""INFO"" message
 */
private void splitInfoMessage(Map<String,?> root,Tuple tuple) throws JsonProcessingException {
  Values dataVal=new Values(""String_Node_Str"",new ObjectMapper().writeValueAsString(root));
  String key=((String)root.get(""String_Node_Str"")).toLowerCase();
  String state=(String)root.get(""String_Node_Str"");
switch (key) {
case ""String_Node_Str"":
    _collector.emit(I_SWITCH,tuple,dataVal);
  logger.debug(""String_Node_Str"",I_SWITCH,dataVal);
if (state.equals(""String_Node_Str"") || state.equals(""String_Node_Str"")) {
  _collector.emit(I_SWITCH_UPDOWN,tuple,dataVal);
  logger.debug(""String_Node_Str"",I_SWITCH_UPDOWN,dataVal);
}
 else {
  _collector.emit(I_SWITCH_OTHER,tuple,dataVal);
  logger.debug(""String_Node_Str"",I_SWITCH_OTHER,dataVal);
}
break;
case ""String_Node_Str"":
_collector.emit(I_PORT,tuple,dataVal);
logger.debug(""String_Node_Str"",I_PORT,dataVal);
if (state.equals(""String_Node_Str"") || state.equals(""String_Node_Str"")) {
_collector.emit(I_PORT_UPDOWN,tuple,dataVal);
}
 else {
_collector.emit(I_PORT_OTHER,tuple,dataVal);
}
break;
case ""String_Node_Str"":
_collector.emit(I_ISL,tuple,dataVal);
logger.debug(""String_Node_Str"",I_ISL,dataVal);
if (state != null && (state.equals(""String_Node_Str"") || state.equals(""String_Node_Str""))) {
_collector.emit(I_ISL_UPDOWN,tuple,dataVal);
}
 else {
_collector.emit(I_ISL_OTHER,tuple,dataVal);
}
break;
default :
_collector.emit(I_OTHER,tuple,dataVal);
logger.warn(""String_Node_Str"",key,root);
}
}","The original code lacked proper logging for some switch cases and risked potential null pointer exceptions due to unchecked state comparisons. The fixed code adds missing debug logging statements and includes a null check for the state variable before comparison, preventing potential runtime errors. These modifications enhance code robustness by ensuring comprehensive logging and safer state evaluations across different message processing scenarios."
38017,"/** 
 * This will create all of the topics passed in. - Currently doesn't check to see if they already exist.
 */
public void createTopics(String[] topics,int partitions,int replication){
  int sessionTimeoutMs=5 * 1000;
  int connectionTimeoutMs=5 * 1000;
  ZkClient zkClient=new ZkClient(zookeeperHost,sessionTimeoutMs,connectionTimeoutMs,ZKStringSerializer$.MODULE$);
  boolean isSecureKafkaCluster=false;
  ZkUtils zkUtils=new ZkUtils(zkClient,new ZkConnection(zookeeperHost),isSecureKafkaCluster);
  Properties topicConfig=new Properties();
  for (  String topic : topics) {
    AdminUtils.createTopic(zkUtils,topic,partitions,replication,topicConfig,RackAwareMode.Disabled$.MODULE$);
  }
  zkClient.close();
}","/** 
 * Create the topic, using the default setting for Partitions and Replication
 */
public void createTopics(String[] topics){
  createTopics(topics,1,1);
}","The original code lacks error handling for existing topics and requires complex parameters for topic creation. The fixed code introduces a simplified overloaded method with default partition and replication values, providing a more user-friendly interface for creating topics. By offering a default implementation, the new method reduces complexity and makes topic creation more straightforward for developers with minimal configuration needs."
38018,"public void primeKafkaTopic(String topic){
  kProducer.send(new ProducerRecord<>(topic,""String_Node_Str"",""String_Node_Str""));
}","public void primeKafkaTopic(String topic){
  if (!kutils.topicExists(topic)) {
    kutils.createTopics(new String[]{topic});
  }
}","The original code blindly attempts to send a message to a Kafka topic without first verifying its existence, which could lead to potential runtime errors or topic creation failures. The fixed code introduces a pre-send check using `kutils.topicExists()` and proactively creates the topic if it doesn't exist, ensuring reliable message production. This approach prevents potential messaging disruptions and provides a more robust method for handling Kafka topic interactions."
38019,"public StormTopology createTopology(){
  logger.debug(""String_Node_Str"" + this.getClass().getSimpleName());
  TopologyBuilder builder=new TopologyBuilder();
  BoltDeclarer kbolt=builder.setBolt(kafkaOutputTopic + ""String_Node_Str"",kutils.createKafkaBolt(kafkaOutputTopic),parallelism);
  BoltDeclarer[] tbolt=new BoltDeclarer[bolts.length];
  for (int i=0; i < topics.length; i++) {
    String topic=topics[i];
    String spoutName=topic + ""String_Node_Str"";
    String boltName=topic + ""String_Node_Str"";
    builder.setSpout(spoutName,kutils.createKafkaSpout(topic));
    tbolt[i]=builder.setBolt(boltName,bolts[i],parallelism).shuffleGrouping(spoutName);
    kbolt=kbolt.shuffleGrouping(boltName,kafkaOutputTopic);
  }
  tbolt[2].shuffleGrouping(topics[0] + ""String_Node_Str"",kafkaOutputTopic).shuffleGrouping(topics[1] + ""String_Node_Str"",kafkaOutputTopic);
  String discoTopic=((OFELinkBolt)bolts[2]).islDiscoTopic;
  builder.setBolt(""String_Node_Str"",kutils.createKafkaBolt(discoTopic),parallelism).shuffleGrouping(topics[2] + ""String_Node_Str"",discoTopic);
  return builder.createTopology();
}","public StormTopology createTopology(){
  logger.debug(""String_Node_Str"" + this.getClass().getSimpleName());
  TopologyBuilder builder=new TopologyBuilder();
  primeTopic(kafkaOutputTopic);
  BoltDeclarer kbolt=builder.setBolt(kafkaOutputTopic + ""String_Node_Str"",kutils.createKafkaBolt(kafkaOutputTopic),parallelism);
  BoltDeclarer[] tbolt=new BoltDeclarer[bolts.length];
  for (int i=0; i < topics.length; i++) {
    String topic=topics[i];
    String spoutName=topic + ""String_Node_Str"";
    String boltName=topic + ""String_Node_Str"";
    primeTopic(topic);
    builder.setSpout(spoutName,kutils.createKafkaSpout(topic));
    tbolt[i]=builder.setBolt(boltName,bolts[i],parallelism).shuffleGrouping(spoutName);
    kbolt=kbolt.shuffleGrouping(boltName,kafkaOutputTopic);
  }
  tbolt[2].shuffleGrouping(topics[0] + ""String_Node_Str"",kafkaOutputTopic).shuffleGrouping(topics[1] + ""String_Node_Str"",kafkaOutputTopic);
  String discoTopic=((OFELinkBolt)bolts[2]).islDiscoTopic;
  builder.setBolt(""String_Node_Str"",kutils.createKafkaBolt(discoTopic),parallelism).shuffleGrouping(topics[2] + ""String_Node_Str"",discoTopic);
  return builder.createTopology();
}","The original code lacks topic initialization, which could lead to potential Kafka-related configuration or connection issues before topology creation. The fixed code introduces a `primeTopic()` method call for both the Kafka output topic and individual input topics, ensuring proper topic setup before spout and bolt creation. This proactive topic priming enhances reliability and prevents potential runtime errors during Storm topology initialization."
38020,"@Test public void KafkaSplitterTest() throws IOException {
  Properties kprops=new Properties();
  kprops.put(""String_Node_Str"",TestUtils.kafkaUrl);
  OFEventSplitterTopology splitter=new OFEventSplitterTopology().withKafkaProps(kprops);
  splitter.kutils=kutils;
  LocalCluster cluster=new LocalCluster();
  cluster.submitTopology(splitter.defaultTopoName,stormConfig(),splitter.createTopology());
  KafkaFilerTopology kfiler=new KafkaFilerTopology();
  cluster.submitTopology(""String_Node_Str"",stormConfig(),kfiler.createTopology(InfoEventSplitterBolt.I_SWITCH_UPDOWN,server.tempDir.getAbsolutePath(),TestUtils.zookeeperUrl));
  Utils.sleep(4 * 1000);
  SendMessages(splitter.topic);
  Utils.sleep(8 * 1000);
  long messagesExpected=4;
  long messagesReceived=Files.readLines(kfiler.filer.getFile(),Charsets.UTF_8).size();
  Assert.assertEquals(messagesExpected,messagesReceived);
  Utils.sleep(2 * 1000);
  cluster.killTopology(splitter.defaultTopoName);
}","@Test public void KafkaSplitterTest() throws IOException {
  Properties kprops=new Properties();
  kprops.put(""String_Node_Str"",TestUtils.kafkaUrl);
  OFEventSplitterTopology splitter=new OFEventSplitterTopology().withKafkaProps(kprops);
  splitter.kutils=kutils;
  LocalCluster cluster=new LocalCluster();
  cluster.submitTopology(splitter.defaultTopoName,stormConfig(),splitter.createTopology());
  KafkaFilerTopology kfiler=new KafkaFilerTopology();
  cluster.submitTopology(""String_Node_Str"",stormConfig(),kfiler.createTopology(InfoEventSplitterBolt.I_SWITCH_UPDOWN,server.tempDir.getAbsolutePath(),TestUtils.zookeeperUrl));
  Utils.sleep(4 * 1000);
  SendMessages(splitter.topic);
  Utils.sleep(8 * 1000);
  long messagesExpected=3;
  long messagesReceived=Files.readLines(kfiler.filer.getFile(),Charsets.UTF_8).size();
  Assert.assertEquals(messagesExpected,messagesReceived);
  Utils.sleep(2 * 1000);
  cluster.killTopology(splitter.defaultTopoName);
}","The original code incorrectly expected 4 messages, which did not match the actual number of messages processed by the system. In the fixed code, the expected message count was changed from 4 to 3, aligning with the actual number of messages received during the test. This correction ensures the test accurately validates the Kafka message splitter's performance by matching the expected and received message counts."
38021,"public Observer<QuoteModel> getQuoteObserver(){
  return new Observer<QuoteModel>(){
    @Override public void onSubscribe(    Disposable d){
      compositeDisposable.add(d);
    }
    @Override public void onNext(    QuoteModel quoteModel){
      quoteTV.setText(quoteModel.getResult().getQuote());
      authorTV.setText(quoteModel.getResult().getAuthor());
      mBottomSheetBehavior.setState(BottomSheetBehavior.STATE_EXPANDED);
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onComplete(){
    }
  }
;
}","public Observer<QuoteModel> getQuoteObserver(){
  return new Observer<QuoteModel>(){
    @Override public void onSubscribe(    Disposable d){
      compositeDisposable.add(d);
    }
    @Override public void onNext(    QuoteModel quoteModel){
      String quote=quoteModel.getResult().getQuote();
      if (quote.length() > 224) {
        setQuoteToBottomSheet(getQuoteObservableFromPresenter());
      }
 else {
        quoteTV.setText(quoteModel.getResult().getQuote());
        authorTV.setText(quoteModel.getResult().getAuthor());
        mBottomSheetBehavior.setState(BottomSheetBehavior.STATE_EXPANDED);
      }
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onComplete(){
    }
  }
;
}","The original code lacked quote length validation, potentially causing UI issues with excessively long quotes. The fixed code adds a length check that triggers an alternative quote retrieval method when a quote exceeds 224 characters, ensuring proper display and user experience. By implementing this conditional logic, the code now gracefully handles variable quote lengths and prevents potential text truncation or layout problems."
38022,"@Override public void onNext(QuoteModel quoteModel){
  quoteTV.setText(quoteModel.getResult().getQuote());
  authorTV.setText(quoteModel.getResult().getAuthor());
  mBottomSheetBehavior.setState(BottomSheetBehavior.STATE_EXPANDED);
}","@Override public void onNext(QuoteModel quoteModel){
  String quote=quoteModel.getResult().getQuote();
  if (quote.length() > 224) {
    setQuoteToBottomSheet(getQuoteObservableFromPresenter());
  }
 else {
    quoteTV.setText(quoteModel.getResult().getQuote());
    authorTV.setText(quoteModel.getResult().getAuthor());
    mBottomSheetBehavior.setState(BottomSheetBehavior.STATE_EXPANDED);
  }
}","The original code directly sets quote and author text without checking quote length, which could cause UI issues with extremely long quotes. The fixed code introduces a length check that triggers an alternative method (setQuoteToBottomSheet) for quotes exceeding 224 characters, preventing potential text overflow or display problems. By implementing this conditional logic, the code ensures better text rendering and maintains a consistent user interface across different quote lengths."
38023,"@Override public void onCreate(@Nullable Bundle savedInstanceState){
  DaggerArchiveFragmentComponent.builder().rVAdapterModule(new RVAdapterModule(getContext())).build().injectFragment(this);
  ;
  super.onCreate(savedInstanceState);
}","@Override public void onCreate(@Nullable Bundle savedInstanceState){
  DaggerArchiveFragmentComponent.builder().rVAdapterModule(new RVAdapterModule(getContext())).build().injectFragment(this);
  super.onCreate(savedInstanceState);
}","The original code contains an unnecessary semicolon after the dependency injection, which could potentially disrupt the method's execution flow. The fixed code removes the extra semicolon, ensuring that the dependency injection and superclass method call are executed in the correct sequence. This correction guarantees proper initialization of the fragment with its dependencies and maintains the standard Android lifecycle method implementation."
38024,"public void setOnItemClickListenerToAdapter(){
  rvAdapter.setOnItemClickListener((view,position,data) -> {
    popupMenu=new PopupMenu(view.getContext(),view);
    popupMenu.getMenuInflater().inflate(R.menu.popup_menu,popupMenu.getMenu());
    popupMenu.setOnMenuItemClickListener(item -> {
      if (item.getItemId() == R.id.delete) {
        final QuoteDb quoteDb=QuoteDb.getQuoteDb(getContext());
        rvAdapter.quoteList.remove(position);
        quoteDb.quoteDao().deleteOne(rvAdapter.quoteList.get(position));
        rvAdapter.notifyItemRemoved(position);
        return true;
      }
      if (item.getItemId() == R.id.share) {
        Intent intent=new Intent();
        intent.setAction(Intent.ACTION_SEND);
        intent.setType(""String_Node_Str"");
        intent.putExtra(Intent.EXTRA_TEXT,rvAdapter.quoteList.get(position).getQuote());
        view.getContext().startActivity(Intent.createChooser(intent,""String_Node_Str""));
        return true;
      }
      return true;
    }
);
    popupMenu.show();
  }
);
}","public void setOnItemClickListenerToAdapter(){
  rvAdapter.setOnItemClickListener((view,position,data) -> {
    popupMenu=new PopupMenu(view.getContext(),view);
    popupMenu.getMenuInflater().inflate(R.menu.popup_menu,popupMenu.getMenu());
    popupMenu.setOnMenuItemClickListener(item -> {
      if (item.getItemId() == R.id.delete) {
        final QuoteDb quoteDb=QuoteDb.getQuoteDb(getContext());
        quoteDb.quoteDao().deleteOne(rvAdapter.quoteList.get(position));
        rvAdapter.quoteList.remove(position);
        rvAdapter.notifyItemRemoved(position);
        return true;
      }
      if (item.getItemId() == R.id.share) {
        Intent intent=new Intent();
        intent.setAction(Intent.ACTION_SEND);
        intent.setType(""String_Node_Str"");
        intent.putExtra(Intent.EXTRA_TEXT,rvAdapter.quoteList.get(position).getQuote());
        view.getContext().startActivity(Intent.createChooser(intent,""String_Node_Str""));
        return true;
      }
      return true;
    }
);
    popupMenu.show();
  }
);
}","The original code attempted to delete an item from the list after accessing its position, which would cause an index out of bounds error. In the fixed code, the database deletion and list removal order are swapped, ensuring the correct item is deleted from both the database and the list before updating the adapter. This modification prevents potential runtime exceptions and maintains data consistency by performing operations in the correct sequence."
38025,"@Override public void onResponse(Call<QuoteModel> call,Response<QuoteModel> response){
  if (response.isSuccessful()) {
    Toast.makeText(getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
 else {
    String code=String.valueOf(response.code());
    Toast.makeText(getContext(),response.message() + code,Toast.LENGTH_SHORT).show();
  }
}","@Override public void onResponse(Call<QuoteModel> call,Response<QuoteModel> response){
  if (response.isSuccessful()) {
    Toast.makeText(getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
 else {
    try {
      Toast.makeText(getContext(),response.errorBody().string(),Toast.LENGTH_SHORT).show();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","The original code only displays the HTTP response code, which provides limited error information and doesn't reveal the actual error details from the server. The fixed code uses `response.errorBody().string()` to extract and display the complete error message from the server's response body, wrapped in a try-catch block to handle potential IOException. This approach provides more meaningful and detailed error feedback, helping developers diagnose API call failures more effectively."
38026,"@Override public void onClick(View v){
  QuoteProvider QProvider=new QuoteProvider();
  QuoteClient QService=QProvider.getmQService();
  JSONObject josonBody=new JSONObject();
  try {
    josonBody.put(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  JSONException e) {
    e.printStackTrace();
  }
  String api_key=josonBody.toString();
  Call<QuoteModel> call=QService.getQuote(api_key);
  call.enqueue(new Callback<QuoteModel>(){
    @Override public void onResponse(    Call<QuoteModel> call,    Response<QuoteModel> response){
      if (response.isSuccessful()) {
        Toast.makeText(getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
 else {
        String code=String.valueOf(response.code());
        Toast.makeText(getContext(),response.message() + code,Toast.LENGTH_SHORT).show();
      }
    }
    @Override public void onFailure(    Call<QuoteModel> call,    Throwable t){
      Toast.makeText(getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      t.printStackTrace();
    }
  }
);
}","@Override public void onClick(View v){
  String api_token=ClientConfig.api_token;
  QuoteProvider QProvider=new QuoteProvider();
  QuoteClient QService=QProvider.getmQService();
  Call<QuoteModel> call=QService.getQuote(api_token);
  call.enqueue(new Callback<QuoteModel>(){
    @Override public void onResponse(    Call<QuoteModel> call,    Response<QuoteModel> response){
      if (response.isSuccessful()) {
        Toast.makeText(getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
 else {
        try {
          Toast.makeText(getContext(),response.errorBody().string(),Toast.LENGTH_SHORT).show();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    @Override public void onFailure(    Call<QuoteModel> call,    Throwable t){
      Toast.makeText(getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      t.printStackTrace();
    }
  }
);
}","The original code incorrectly created a redundant JSON object and used its toString() method as an API key, which would likely cause authentication failures. The fixed code replaces this with a direct API token from a configuration class, simplifying the authentication process and ensuring a valid token is passed. By using a predefined API token and handling error responses more robustly with error body parsing, the code becomes more reliable and provides better error feedback."
38027,"@Override public void onViewCreated(View view,@Nullable Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  mButton=(Button)getView().findViewById(R.id.fetchButton);
  mButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      QuoteProvider QProvider=new QuoteProvider();
      QuoteClient QService=QProvider.getmQService();
      JSONObject josonBody=new JSONObject();
      try {
        josonBody.put(""String_Node_Str"",""String_Node_Str"");
      }
 catch (      JSONException e) {
        e.printStackTrace();
      }
      String api_key=josonBody.toString();
      Call<QuoteModel> call=QService.getQuote(api_key);
      call.enqueue(new Callback<QuoteModel>(){
        @Override public void onResponse(        Call<QuoteModel> call,        Response<QuoteModel> response){
          if (response.isSuccessful()) {
            Toast.makeText(getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
          }
 else {
            String code=String.valueOf(response.code());
            Toast.makeText(getContext(),response.message() + code,Toast.LENGTH_SHORT).show();
          }
        }
        @Override public void onFailure(        Call<QuoteModel> call,        Throwable t){
          Toast.makeText(getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
          t.printStackTrace();
        }
      }
);
    }
  }
);
}","@Override public void onViewCreated(View view,@Nullable Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  mButton=(Button)getView().findViewById(R.id.fetchButton);
  mButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      String api_token=ClientConfig.api_token;
      QuoteProvider QProvider=new QuoteProvider();
      QuoteClient QService=QProvider.getmQService();
      Call<QuoteModel> call=QService.getQuote(api_token);
      call.enqueue(new Callback<QuoteModel>(){
        @Override public void onResponse(        Call<QuoteModel> call,        Response<QuoteModel> response){
          if (response.isSuccessful()) {
            Toast.makeText(getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
          }
 else {
            try {
              Toast.makeText(getContext(),response.errorBody().string(),Toast.LENGTH_SHORT).show();
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
        @Override public void onFailure(        Call<QuoteModel> call,        Throwable t){
          Toast.makeText(getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
          t.printStackTrace();
        }
      }
);
    }
  }
);
}","The original code incorrectly created a redundant JSONObject and used its toString() method as an API token, which would likely cause authentication failures. In the fixed code, a direct API token is retrieved from a configuration class, simplifying the token retrieval process and ensuring a valid authentication method. This modification improves error handling by directly using the correct token and provides a more robust approach to making API calls with proper authentication."
38028,"@POST(""String_Node_Str"") Call<QuoteModel> getQuote(@Body String api_key);","@FormUrlEncoded @POST(""String_Node_Str"") Call<QuoteModel> getQuote(@Field(""String_Node_Str"") String api_token);","The original code incorrectly used @Body annotation with a raw String parameter, which is not the proper way to send an API key in a Retrofit network request. The fixed code uses @FormUrlEncoded and @Field annotations, which properly encapsulate the API token as a form-encoded parameter within the request body. This modification ensures correct API key transmission, improves request formatting, and follows Retrofit's recommended method for sending form-encoded data."
38029,"public void bind(HasText text){
  setBadgeComponent(text);
  addNotificationsChangeListener(new NotificationsChangeListener(){
    @Override public void onNotificationChanges(    NotificationHolder holder){
      updateBadgeCaption();
    }
  }
);
}","public void bind(HasText text){
  addBadgeHolderComponent(text);
  addNotificationsChangeListener(new NotificationsChangeListener(){
    @Override public void onNotificationChanges(    NotificationHolder holder){
      updateBadgeCaptions();
    }
  }
);
}","The original code incorrectly used `setBadgeComponent()`, which likely does not properly handle badge component attachment. The fixed code replaces this with `addBadgeHolderComponent(text)`, which correctly integrates the text component and ensures proper badge holder management. By also correcting the method call to `updateBadgeCaptions()`, the code now provides a more robust mechanism for updating badge notifications and maintaining component synchronization."
38030,"private void updateBadgeCaption(){
  if (text != null) {
    int unread=getUnreadNotifications();
    String value;
    if (unread < 1) {
      value=String.valueOf(0);
    }
 else     if (unread < 10) {
      value=String.valueOf(unread);
    }
 else {
      value=""String_Node_Str"";
    }
    text.setText(value);
    if (text instanceof Component) {
      ((Component)text).setVisible(unread > 0);
    }
  }
}","private void updateBadgeCaption(HasText hasText){
  if (hasText != null) {
    int unread=getUnreadNotifications();
    String value;
    if (unread < 1) {
      value=String.valueOf(0);
    }
 else     if (unread < 10) {
      value=String.valueOf(unread);
    }
 else {
      value=""String_Node_Str"";
    }
    hasText.setText(value);
    if (hasText instanceof Component) {
      ((Component)hasText).setVisible(unread > 0);
    }
  }
}","The original code relies on a hardcoded `text` field, which limits method flexibility and creates tight coupling. The fixed code introduces a `HasText` parameter, enabling more generic text-setting behavior and improving method reusability across different component types. By accepting an interface instead of a specific implementation, the method becomes more adaptable and follows better object-oriented design principles."
38031,"private void reloadNotifications(){
  if (currentThread != null && !currentThread.isInterrupted()) {
    currentThread.interrupt();
  }
  badge.clearCount();
  notificationHolder.clearNotifications();
  currentThread=new Thread(() -> {
    try {
      Thread.sleep(1000);
      for (int i=0; i < 3; i++) {
        addNotification(MEDIUM);
      }
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
);
  currentThread.start();
}","private void reloadNotifications(){
  if (currentThread != null && !currentThread.isInterrupted()) {
    currentThread.interrupt();
  }
  badge.clearCount();
  notificationHolder.clearNotifications();
  currentThread=new Thread(() -> {
    try {
      Thread.sleep(1000);
      for (int i=0; i < 3; i++) {
        addNotification(MEDIUM);
        badge.increase();
      }
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
);
  currentThread.start();
}","The original code failed to update the badge count when adding notifications, leaving the visual indicator of new notifications incomplete. In the fixed code, `badge.increase()` is added within the loop, ensuring that each notification increments the badge count dynamically. This change provides a more accurate representation of new notifications, synchronizing the badge display with the actual number of notifications added."
38032,"public void increase(){
  count++;
  listeners.forEach(listener -> listener.onChange(this));
}","public void increase(){
  count++;
  listeners.forEach(listener -> listener.onChange(this));
  updateBadgeCaptions();
}","The original code lacks a crucial method call to update badge captions after incrementing the count, potentially leaving UI elements out of sync. The fixed code adds an `updateBadgeCaptions()` method call immediately after notifying listeners, ensuring that visual representations are synchronized with the internal state change. This enhancement guarantees that all dependent UI components reflect the most recent count value accurately and immediately."
38033,"public void decrease(){
  if (count > 0) {
    count--;
  }
  listeners.forEach(listener -> listener.onChange(this));
}","public void decrease(){
  if (count > 0) {
    count--;
  }
  listeners.forEach(listener -> listener.onChange(this));
  updateBadgeCaptions();
}","The original code lacks a crucial method call `updateBadgeCaptions()` after modifying the count, potentially leaving UI elements out of sync with the underlying data state. The fixed code adds the `updateBadgeCaptions()` method call after notifying listeners, ensuring that visual representations are immediately updated when the count changes. This enhancement guarantees consistent user interface feedback and prevents potential visual discrepancies between the data model and its visual representation."
38034,"public void setCount(int count){
  this.count=count;
  listeners.forEach(listener -> listener.onChange(this));
}","public void setCount(int count){
  this.count=count;
  listeners.forEach(listener -> listener.onChange(this));
  updateBadgeCaptions();
}","The original code lacks a crucial method call to update badge captions after changing the count, potentially leaving UI elements out of sync. The fixed code adds `updateBadgeCaptions()` after notifying listeners, ensuring that all related visual elements are refreshed when the count changes. This improvement guarantees consistent state representation across the user interface, preventing potential visual discrepancies."
38035,"public void bind(HasText text){
  addBadgeHolderComponent(text);
  addNotificationsChangeListener(new NotificationsChangeListener(){
    @Override public void onNotificationChanges(    NotificationHolder holder){
      updateBadgeCaptions();
    }
  }
);
}","public void bind(HasText text){
  addBadgeHolderComponent(text);
  updateBadgeCaptions();
}","The original code unnecessarily adds a notifications change listener that only calls updateBadgeCaptions(), creating redundant and inefficient event handling. The fixed code directly calls updateBadgeCaptions() during the bind method, eliminating the unnecessary listener and simplifying the implementation. By removing the extra listener, the code becomes more straightforward, reduces potential memory overhead, and directly achieves the desired result of updating badge captions."
38036,"public void addNotification(T notification){
  recentNotification=notification;
  notifications.add(notification);
  notifyListeners();
  notifyAddListeners(notification);
}","public void addNotification(T notification){
  recentNotification=notification;
  notifications.add(notification);
  notifyListeners();
  notifyAddListeners(notification);
  updateBadgeCaptions();
}","The original code lacked a crucial method call to update badge captions after adding a notification, potentially leaving user interfaces out of sync. The fixed code adds the `updateBadgeCaptions()` method, ensuring that visual indicators are immediately refreshed when a new notification is added. This enhancement guarantees real-time UI consistency and provides immediate visual feedback to users about new notifications."
38037,"public void removeNotification(T notification){
  notifications.remove(notification);
  notifyListeners();
  notifyRemoveListeners(notification);
}","public void removeNotification(T notification){
  notifications.remove(notification);
  notifyListeners();
  notifyRemoveListeners(notification);
  updateBadgeCaptions();
}","The original code omitted calling `updateBadgeCaptions()`, which is likely responsible for synchronizing visual badge notifications after removing an item. The fixed code adds the `updateBadgeCaptions()` method call, ensuring that the user interface reflects the current state of notifications after removal. This change guarantees consistent visual representation and prevents potential synchronization issues between the data model and user interface."
38038,"public void clearNotifications(){
  notifications.clear();
  notifyListeners();
}","public void clearNotifications(){
  notifications.clear();
  notifyListeners();
  updateBadgeCaptions();
}","The original code fails to update badge captions after clearing notifications, potentially leaving the user interface out of sync with the actual notification state. The fixed code adds a call to `updateBadgeCaptions()`, ensuring that visual indicators accurately reflect the current number of notifications. This enhancement provides a more consistent and responsive user experience by synchronizing the UI with the underlying notification data."
38039,"private void addNotification(Priority priority){
  getUI().ifPresent(ui -> ui.accessSynchronously(() -> {
    badge.increase();
    notificationHolder.addNotification(new DefaultNotification(""String_Node_Str"" + badge.getCount(),""String_Node_Str"" + badge.getCount(),priority));
  }
));
}","private void addNotification(Priority priority){
  notificationHolder.addNotification(new DefaultNotification(""String_Node_Str"" + badgeHolder.getCount(),""String_Node_Str"" + badgeHolder.getCount(),priority));
}","The original code unnecessarily used UI synchronization and accessed a badge object, which could lead to potential threading and UI-related performance issues. The fixed code removes the synchronous UI access and directly uses a badgeHolder to create the notification, simplifying the method and reducing potential concurrency complexities. By eliminating the UI-specific wrapper, the code becomes more straightforward, efficient, and less prone to synchronization-related errors."
38040,"@Override public AppLayout getAppLayout(){
  if (variant == null) {
    variant=Behaviour.LEFT_RESPONSIVE;
    notificationHolder=new DefaultNotificationHolder(newStatus -> {
    }
);
    badge=new DefaultBadgeHolder();
  }
  reloadNotifications();
  if (!variant.isTop()) {
    LeftNavigationComponent home=new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.HOME.create(),View1.class);
    notificationHolder.bind(home.getBadge());
    return AppLayoutBuilder.get(variant).withTitle(""String_Node_Str"").withIcon(""String_Node_Str"").withAppBar(AppBarBuilder.get().add(new AppBarNotificationButton(VaadinIcon.BELL.create(),notificationHolder)).build()).withDesign(AppLayoutDesign.MATERIAL).withAppMenu(LeftAppMenuBuilder.get().addToSection(new MenuHeaderComponent(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),HEADER).addToSection(new LeftClickableComponent(""String_Node_Str"",VaadinIcon.COG.create(),clickEvent -> openModeSelector(variant)),HEADER).add(home).add(LeftSubMenuBuilder.get(""String_Node_Str"",VaadinIcon.PLUS.create()).add(LeftSubMenuBuilder.get(""String_Node_Str"",VaadinIcon.PLUS.create()).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.SPLINE_CHART.create(),View2.class)).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.CONNECT.create(),View3.class)).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.COG.create(),View4.class)).build()).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.CONNECT.create(),View5.class)).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.COG.create(),View6.class)).build()).add(LeftSubMenuBuilder.get(""String_Node_Str"",VaadinIcon.PLUS.create()).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.CONNECT.create(),View7.class)).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.COG.create(),View8.class)).build()).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.MENU.create(),View9.class)).addToSection(new LeftClickableComponent(""String_Node_Str"",VaadinIcon.COG.create(),clickEvent -> openModeSelector(variant)),FOOTER).build()).build();
  }
 else {
    return AppLayoutBuilder.get(variant).withTitle(""String_Node_Str"").withAppBar(AppBarBuilder.get().add(new AppBarNotificationButton(VaadinIcon.BELL.create(),notificationHolder)).build()).withDesign(AppLayoutDesign.MATERIAL).withAppMenu(TopAppMenuBuilder.get().addToSection(new TopClickableComponent(""String_Node_Str"",VaadinIcon.COG.create(),clickEvent -> openModeSelector(variant)),HEADER).add(new TopNavigationComponent(""String_Node_Str"",VaadinIcon.HOME.create(),View1.class)).add(new TopNavigationComponent(""String_Node_Str"",VaadinIcon.SPLINE_CHART.create(),View2.class)).addToSection(new TopClickableComponent(""String_Node_Str"",VaadinIcon.COG.create(),clickEvent -> openModeSelector(variant)),FOOTER).addToSection(new TopNavigationComponent(""String_Node_Str"",VaadinIcon.CONNECT.create(),View3.class),FOOTER).build()).build();
  }
}","@Override public AppLayout getAppLayout(){
  if (variant == null) {
    variant=Behaviour.LEFT_RESPONSIVE;
    notificationHolder=new DefaultNotificationHolder(newStatus -> {
    }
);
    badgeHolder=new DefaultBadgeHolder();
  }
  reloadNotifications();
  if (!variant.isTop()) {
    LeftNavigationComponent home=new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.HOME.create(),View1.class);
    LeftNavigationComponent menu=new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.MENU.create(),View9.class);
    notificationHolder.bind(home.getBadge());
    badgeHolder.bind(menu.getBadge());
    return AppLayoutBuilder.get(variant).withTitle(""String_Node_Str"").withIcon(""String_Node_Str"").withAppBar(AppBarBuilder.get().add(new AppBarNotificationButton(VaadinIcon.BELL.create(),notificationHolder)).build()).withDesign(AppLayoutDesign.MATERIAL).withAppMenu(LeftAppMenuBuilder.get().addToSection(new MenuHeaderComponent(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),HEADER).addToSection(new LeftClickableComponent(""String_Node_Str"",VaadinIcon.COG.create(),clickEvent -> openModeSelector(variant)),HEADER).add(home).add(LeftSubMenuBuilder.get(""String_Node_Str"",VaadinIcon.PLUS.create()).add(LeftSubMenuBuilder.get(""String_Node_Str"",VaadinIcon.PLUS.create()).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.SPLINE_CHART.create(),View2.class)).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.CONNECT.create(),View3.class)).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.COG.create(),View4.class)).build()).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.CONNECT.create(),View5.class)).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.COG.create(),View6.class)).build()).add(LeftSubMenuBuilder.get(""String_Node_Str"",VaadinIcon.PLUS.create()).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.CONNECT.create(),View7.class)).add(new LeftNavigationComponent(""String_Node_Str"",VaadinIcon.COG.create(),View8.class)).build()).add(menu).addToSection(new LeftClickableComponent(""String_Node_Str"",VaadinIcon.COG.create(),clickEvent -> openModeSelector(variant)),FOOTER).build()).build();
  }
 else {
    return AppLayoutBuilder.get(variant).withTitle(""String_Node_Str"").withAppBar(AppBarBuilder.get().add(new AppBarNotificationButton(VaadinIcon.BELL.create(),notificationHolder)).build()).withDesign(AppLayoutDesign.MATERIAL).withAppMenu(TopAppMenuBuilder.get().addToSection(new TopClickableComponent(""String_Node_Str"",VaadinIcon.COG.create(),clickEvent -> openModeSelector(variant)),HEADER).add(new TopNavigationComponent(""String_Node_Str"",VaadinIcon.HOME.create(),View1.class)).add(new TopNavigationComponent(""String_Node_Str"",VaadinIcon.SPLINE_CHART.create(),View2.class)).addToSection(new TopClickableComponent(""String_Node_Str"",VaadinIcon.COG.create(),clickEvent -> openModeSelector(variant)),FOOTER).addToSection(new TopNavigationComponent(""String_Node_Str"",VaadinIcon.CONNECT.create(),View3.class),FOOTER).build()).build();
  }
}","The original code lacked proper badge binding for the menu navigation component, potentially causing inconsistent notification tracking. The fixed code introduces a new `badgeHolder` and binds the badge for the menu navigation component (`View9`), ensuring consistent badge management across different navigation elements. This modification enhances the app's notification tracking and provides a more robust implementation of badge handling in the application layout."
38041,"private void reloadNotifications(){
  if (currentThread != null && !currentThread.isInterrupted()) {
    currentThread.interrupt();
  }
  badge.clearCount();
  notificationHolder.clearNotifications();
  currentThread=new Thread(() -> {
    try {
      Thread.sleep(1000);
      for (int i=0; i < 3; i++) {
        addNotification(MEDIUM);
        badge.increase();
      }
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
);
  currentThread.start();
}","private void reloadNotifications(){
  if (currentThread != null && !currentThread.isInterrupted()) {
    currentThread.interrupt();
  }
  badgeHolder.clearCount();
  notificationHolder.clearNotifications();
  currentThread=new Thread(() -> {
    try {
      Thread.sleep(1000);
      for (int i=0; i < 3; i++) {
        getUI().ifPresent(ui -> ui.access(() -> {
          addNotification(MEDIUM);
          badgeHolder.increase();
          badgeHolder.increase();
        }
));
      }
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
);
  currentThread.start();
}","The original code lacks thread-safe UI updates, potentially causing race conditions and UI inconsistencies when modifying notifications from a background thread. The fixed code introduces `ui.access()` to ensure thread-safe UI modifications and correctly references `badgeHolder` instead of the undefined `badge` object. These changes guarantee synchronized UI updates and prevent potential threading-related errors, improving the method's reliability and preventing potential UI rendering issues."
38042,"public AppLayoutRouterLayout(){
  setSizeFull();
  loadConfiguration();
  UI.getCurrent().getSession().setAttribute(""String_Node_Str"",this);
}","public AppLayoutRouterLayout(){
  setSizeFull();
  getElement().getStyle().set(""String_Node_Str"",""String_Node_Str"");
  loadConfiguration();
  UI.getCurrent().getSession().setAttribute(""String_Node_Str"",this);
}","The original code lacks proper element styling, potentially causing layout or attribute-related issues in the Vaadin application. The fixed code adds a style setting using `getElement().getStyle().set()`, which explicitly defines a style attribute for the component. This modification ensures more robust element configuration and prevents potential rendering or attribute-related problems during UI initialization."
38043,"public PaperDrawerIconItem(String title,String icon,ComponentEventListener<ClickEvent<PaperDrawerIconItem>> listener){
  this.listener=listener;
  setTitle(title);
  setIcon(icon);
  getElement().addEventListener(""String_Node_Str"",domEvent -> {
    if (listener != null) {
      listener.onComponentEvent(new ClickEvent<>(this));
    }
  }
);
}","public PaperDrawerIconItem(String title,String icon,ComponentEventListener<ClickEvent<PaperDrawerIconItem>> listener){
  this.listener=listener;
  setTitle(title);
  setIcon(icon);
  getElement().addEventListener(""String_Node_Str"",domEvent -> {
    if (this.listener != null) {
      this.listener.onComponentEvent(new ClickEvent<>(this));
    }
  }
);
}","The original code incorrectly references a generic `listener` variable, which could potentially be null or not properly scoped. The fixed code uses `this.listener` to explicitly reference the instance-level listener, ensuring proper access and null-safety within the event handler. This modification guarantees that the event listener is correctly bound to the specific instance and prevents potential null pointer exceptions during event handling."
38044,"public PaperDrawerItem(String title,ComponentEventListener<ClickEvent<PaperDrawerIconItem>> listener){
  this.listener=listener;
  setTitle(title);
  getElement().addEventListener(""String_Node_Str"",domEvent -> {
    if (listener != null) {
      listener.onComponentEvent(new ClickEvent<>(this));
    }
  }
);
}","public PaperDrawerItem(String title,ComponentEventListener<ClickEvent<PaperDrawerIconItem>> listener){
  this.listener=listener;
  setTitle(title);
  getElement().addEventListener(""String_Node_Str"",domEvent -> {
    if (this.listener != null) {
      this.listener.onComponentEvent(new ClickEvent<>(this));
    }
  }
);
}","The original code uses a generic `listener` reference without explicitly specifying `this.listener`, which could lead to potential null pointer issues or unexpected behavior. In the fixed code, `this.listener` is used to ensure the correct instance-specific listener is referenced and called. This modification provides more precise event handling and prevents potential runtime errors by explicitly accessing the instance-specific listener."
38045,"public void init(VaadinRequest request){
  setContent(AppLayout.getDefaultBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications)).withNavigationElementInfoProvider(new DefaultNavigationElementInfoProvider()).withDesign(AppLayoutDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(badge,View1.class).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(View2.class).add(View3.class).add(View4.class).build()).add(View5.class).add(View6.class).build());
}","public void init(VaadinRequest request){
  setContent(AppLayout.getDefaultBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications)).withNavigationElementInfoProvider(new DefaultNavigationElementInfoProducer()).withDesign(AppLayoutDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(badge,View1.class).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(View2.class).add(View3.class).add(View4.class).build()).add(View5.class).add(View6.class).build());
}","The original code used an incorrect class `DefaultNavigationElementInfoProvider`, which likely does not exist or is not the intended navigation element producer. In the fixed code, this was replaced with `DefaultNavigationElementInfoProducer`, which is the correct class for providing navigation element information. This correction ensures proper navigation element handling and prevents potential runtime errors in the Vaadin application's layout configuration."
38046,"public void init(VaadinRequest request){
  setContent(AppLayout.getCDIBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withViewProvider(() -> viewProvider).withNavigationElementInfoProvider(new DefaultSpringNavigationElementInfoProvider()).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withDesign(AppLayoutDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(badge,View1.class).add(CDISubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(View2.class).add(View3.class).add(View4.class).build()).add(View5.class).add(View6.class).build());
}","public void init(VaadinRequest request){
  setContent(AppLayout.getCDIBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withViewProvider(() -> viewProvider).withNavigationElementInfoProvider(new DefaultSpringNavigationElementInfoProducer()).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withDesign(AppLayoutDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(badge,View1.class).add(CDISubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(View2.class).add(View3.class).add(View4.class).build()).add(View5.class).add(View6.class).build());
}","The original code used an incorrect class `DefaultSpringNavigationElementInfoProvider`, which likely does not exist or is not the correct implementation for navigation element information. The fixed code replaces this with `DefaultSpringNavigationElementInfoProducer`, which is presumably the correct class for handling navigation element information in a Spring-based Vaadin application. This correction ensures proper navigation element configuration, potentially resolving runtime errors and improving the application's navigation functionality."
38047,"public void init(VaadinRequest request){
  DefaultNotificationHolder notifications=new DefaultNotificationHolder();
  DefaultBadgeHolder badge=new DefaultBadgeHolder();
  AppLayoutComponent layout=AppLayout.getCDIBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withViewProvider(() -> viewProvider).withNavigationElementInfoProvider(new DefaultSpringNavigationElementInfoProvider()).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withDesign(AppLayoutDesign.MATERIAL).withNavigatorConsumer(navigator -> {
  }
).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(""String_Node_Str"",VaadinIcons.HOME,badge,View1.class).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(""String_Node_Str"",VaadinIcons.SPLINE_CHART,View2.class).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(""String_Node_Str"",VaadinIcons.MENU,View5.class).add(""String_Node_Str"",VaadinIcons.LIST,View6.class).build();
  setContent(layout);
}","public void init(VaadinRequest request){
  DefaultNotificationHolder notifications=new DefaultNotificationHolder();
  DefaultBadgeHolder badge=new DefaultBadgeHolder();
  AppLayoutComponent layout=AppLayout.getCDIBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withViewProvider(() -> viewProvider).withNavigationElementInfoProvider(new DefaultSpringNavigationElementInfoProducer()).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withDesign(AppLayoutDesign.MATERIAL).withNavigatorConsumer(navigator -> {
  }
).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(""String_Node_Str"",VaadinIcons.HOME,badge,View1.class).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(""String_Node_Str"",VaadinIcons.SPLINE_CHART,View2.class).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(""String_Node_Str"",VaadinIcons.MENU,View5.class).add(""String_Node_Str"",VaadinIcons.LIST,View6.class).build();
  setContent(layout);
}","The original code used an incorrect class `DefaultSpringNavigationElementInfoProvider`, which is not a standard Vaadin component. The fixed code replaces it with `DefaultSpringNavigationElementInfoProducer`, a more appropriate and likely correct class for navigation element information handling. This correction ensures proper navigation configuration and prevents potential runtime errors in the Vaadin application's layout initialization."
38048,"public void init(VaadinRequest request){
  setContent(AppLayout.getDefaultBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications)).withNavigationElementInfoProvider(new DefaultNavigationElementInfoProducer()).withDesign(AppLayoutDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(badge,View1.class).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(View2.class).add(View3.class).add(View4.class).build()).add(View5.class).add(View6.class).build());
}","public void init(VaadinRequest request){
  setContent(AppLayout.getDefaultBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications)).withNavigationElementInfoProducer(new DefaultNavigationElementInfoProducer()).withDesign(AppLayoutDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(badge,View1.class).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(View2.class).add(View3.class).add(View4.class).build()).add(View5.class).add(View6.class).build());
}","The original code likely contained a syntax error or undefined variable causing compilation or runtime issues. The fixed code removes the problematic element, potentially an undefined variable or incorrectly placed parameter in the method chain. By cleaning up the code structure, the fixed version ensures proper method chaining and reduces the likelihood of errors during application initialization."
38049,"public void init(VaadinRequest request){
  setContent(AppLayout.getCDIBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withViewProvider(() -> viewProvider).withNavigationElementInfoProvider(new DefaultSpringNavigationElementInfoProducer()).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withDesign(AppLayoutDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(badge,View1.class).add(CDISubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(View2.class).add(View3.class).add(View4.class).build()).add(View5.class).add(View6.class).build());
}","public void init(VaadinRequest request){
  setContent(AppLayout.getCDIBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withViewProvider(() -> viewProvider).withNavigationElementInfoProducer(new DefaultSpringNavigationElementInfoProducer()).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withDesign(AppLayoutDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(badge,View1.class).add(CDISubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(View2.class).add(View3.class).add(View4.class).build()).add(View5.class).add(View6.class).build());
}","The buggy code contained an unnecessary parameter in the `withNavigationElementInfoProvider` method, likely a duplicate or erroneous argument. The fixed code removes this redundant parameter, ensuring a clean and correct method call for configuring the navigation element information producer. By eliminating the extraneous parameter, the code becomes more precise, reducing potential runtime errors and improving the overall clarity of the AppLayout configuration."
38050,"public void init(VaadinRequest request){
  DefaultNotificationHolder notifications=new DefaultNotificationHolder();
  DefaultBadgeHolder badge=new DefaultBadgeHolder();
  AppLayoutComponent layout=AppLayout.getCDIBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withViewProvider(() -> viewProvider).withNavigationElementInfoProvider(new DefaultSpringNavigationElementInfoProducer()).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withDesign(AppLayoutDesign.MATERIAL).withNavigatorConsumer(navigator -> {
  }
).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(""String_Node_Str"",VaadinIcons.HOME,badge,View1.class).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(""String_Node_Str"",VaadinIcons.SPLINE_CHART,View2.class).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(""String_Node_Str"",VaadinIcons.MENU,View5.class).add(""String_Node_Str"",VaadinIcons.LIST,View6.class).build();
  setContent(layout);
}","public void init(VaadinRequest request){
  DefaultNotificationHolder notifications=new DefaultNotificationHolder();
  DefaultBadgeHolder badge=new DefaultBadgeHolder();
  AppLayoutComponent layout=AppLayout.getCDIBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withViewProvider(() -> viewProvider).withNavigationElementInfoProducer(new DefaultSpringNavigationElementInfoProducer()).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withDesign(AppLayoutDesign.MATERIAL).withNavigatorConsumer(navigator -> {
  }
).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(""String_Node_Str"",VaadinIcons.HOME,badge,View1.class).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(""String_Node_Str"",VaadinIcons.SPLINE_CHART,View2.class).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(""String_Node_Str"",VaadinIcons.MENU,View5.class).add(""String_Node_Str"",VaadinIcons.LIST,View6.class).build();
  setContent(layout);
}","The original code contained a typo in the method call `withNavigationElementInfoProvider`, which was incorrectly written as `withNavigationElementInfoProducer`. This method is crucial for configuring navigation elements in a Vaadin application. The corrected code uses the proper method name, ensuring correct navigation element configuration and preventing potential runtime errors or unexpected behavior in the application's navigation system."
38051,"/** 
 * Appends a menu element which is bound to a view which then can be navigated to by clicking on the element at the DEFAULT position Note: The caption, icon and navigation path will also be determined via the NavigationElementInfoProvider
 * @param caption
 * @param path
 * @param icon
 * @param badgeHolder
 * @param element
 * @param position
 * @return
 */
public T add(String caption,String path,Resource icon,DefaultBadgeHolder badgeHolder,Class<? extends View> element,AppLayoutConfiguration.Position position){
  addToPosition(new NavigatorNavigationElement(caption,path,icon,badgeHolder,element),position);
  return (T)this;
}","/** 
 * Appends a menu element which is bound to a view which then can be navigated to by clicking on the element at the DEFAULT position Note: The caption, icon and navigation path will also be determined via the NavigationElementInfoProvider
 * @param caption
 * @param icon
 * @param badgeHolder
 * @param element
 * @param position
 * @return
 */
public T add(String caption,Resource icon,DefaultBadgeHolder badgeHolder,Class<? extends View> element,AppLayoutConfiguration.Position position){
  addToPosition(new NavigatorNavigationElement(caption,icon,badgeHolder,element),position);
  return (T)this;
}","The original code incorrectly included a redundant `path` parameter, which was unnecessary for creating a navigation element. The fixed code removes the `path` parameter, simplifying the method signature and relying on the `NavigatorNavigationElement` constructor to handle navigation details more efficiently. This modification reduces method complexity, improves code readability, and ensures a more streamlined approach to creating menu navigation elements."
38052,"/** 
 * Appends a menu element which is bound to a view which then can be navigated to by clicking on the element at the DEFAULT position Note: The caption, icon and navigation path will also be determined via the NavigationElementInfoProvider
 * @param caption
 * @param viewName
 * @param icon
 * @param badgeHolder
 * @param element
 * @param position
 * @return
 */
public T add(String caption,String viewName,Resource icon,DefaultBadgeHolder badgeHolder,View element,AppLayoutConfiguration.Position position){
  addToPosition(new NavigatorNavigationElement(caption,viewName,icon,badgeHolder,element),position);
  return (T)this;
}","/** 
 * Appends a menu element which is bound to a view which then can be navigated to by clicking on the element at the DEFAULT position Note: The caption, icon and navigation path will also be determined via the NavigationElementInfoProvider
 * @param caption
 * @param viewName
 * @param icon
 * @param badgeHolder
 * @param view
 * @param position
 * @return
 */
public T add(String caption,String viewName,Resource icon,DefaultBadgeHolder badgeHolder,View view,AppLayoutConfiguration.Position position){
  addToPosition(new NavigatorNavigationElement(caption,viewName,icon,badgeHolder,view),position);
  return (T)this;
}","The original code used the parameter name ""element"" which could lead to confusion with the method's intent and potential misuse of the View parameter. The fixed code renames the parameter to ""view"", making the method signature more semantically clear and aligned with its actual usage. This change improves code readability and reduces the likelihood of misunderstandings when calling the method, ensuring more precise and intentional implementation."
38053,"private void reloadNotifications(){
  if (currentThread != null && !currentThread.isInterrupted()) {
    currentThread.interrupt();
  }
  badge.clearCount();
  notifications.clearNotifications();
  currentThread=new Thread(() -> {
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    for (int i=0; i < 10; i++) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      addNotification(MEDIUM);
    }
  }
);
  currentThread.start();
}","private void reloadNotifications(){
  if (currentThread != null && !currentThread.isInterrupted()) {
    currentThread.interrupt();
  }
  badge.clearCount();
  notifications.clearNotifications();
  currentThread=new Thread(() -> {
    try {
      Thread.sleep(3000);
      for (int i=0; i < 10; i++) {
        Thread.sleep(1000);
        addNotification(MEDIUM);
      }
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
);
  currentThread.start();
}","The original code had an unnecessary nested try-catch block for Thread.sleep(), which made error handling and code readability inefficient. The fixed code consolidates the sleep operations into a single try-catch block, reducing code complexity and improving the overall thread management by removing redundant exception handling. This refactoring simplifies the thread's execution flow, making the notification reload process more streamlined and easier to maintain."
38054,"public AppLayoutComponent build(){
  if (navigationElementProvider == null) {
    if (variant.isTop())     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
 else     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
  }
  if (customElementProvider == null) {
    if (variant.isTop())     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
 else     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
  }
  if (sectionProvider == null) {
    if (variant.isTop())     sectionProvider=new DefaultLeftSectionElementComponentProvider();
 else     sectionProvider=new DefaultLeftSectionElementComponentProvider();
  }
  if (submenuProvider == null) {
    if (variant.isTop())     submenuProvider=new DefaultTopSubmenuNavigationElementProvider();
 else     submenuProvider=new DefaultLeftSubmenuNavigationElementProvider();
  }
  AppLayoutSessionHelper.setActiveVariant(variant);
  setTitle(title);
  if (navigatorEnabled) {
    navigator=navigatorProducer.apply(instance.getContentHolder());
    navigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (viewProviderSupplier != null) {
      navigator.addProvider(viewProviderSupplier.get());
    }
    if (errorProvider != null) {
      navigator.setErrorProvider(errorProvider.get());
    }
    if (errorViewProvider != null) {
      navigator.setErrorView(errorViewProvider.get());
    }
    if (navigatorConsumer != null) {
      navigatorConsumer.accept(navigator);
    }
    if (!CDI) {
      if (defaultNavigationElement == null) {
        defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
      }
      defaultNavigationElement.addViewToNavigator(navigator);
    }
 else     if (CDI && defaultNavigationElement != null) {
      System.err.println(""String_Node_Str"");
    }
  }
 else {
    componentNavigator=new ComponentNavigator(instance.getContentHolder());
    componentNavigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (viewProviderSupplier != null) {
      componentNavigator.addProvider(viewProviderSupplier.get());
    }
    if (errorProvider != null) {
      componentNavigator.setErrorProvider(errorProvider.get());
    }
    if (errorViewProvider != null) {
      componentNavigator.setErrorView(errorViewProvider.get());
    }
    if (defaultNavigationElement == null) {
      defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
    }
    defaultNavigationElement.addViewToComponentNavigator(componentNavigator);
  }
  addComponents(headerElements,instance::addNavigationHeaderElement);
  addComponents(navigationElements,instance::addNavigationElement);
  addComponents(footerElements,instance::addNavigationFooterElement);
  appBarElements.forEach(instance::addAppBarElement);
  instance.setDesign(design);
  if (appBarIconComponent != null) {
    instance.addAppBarIcon(appBarIconComponent);
  }
  instance.setNavigatorNavigationElements(navigatorElements);
  if (!navigatorEnabled) {
    componentNavigator.navigateTo(defaultNavigationElement.getViewName());
  }
  return instance;
}","public AppLayoutComponent build(){
  if (navigationElementProvider == null) {
    if (variant.isTop())     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
 else     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
  }
  if (customElementProvider == null) {
    if (variant.isTop())     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
 else     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
  }
  if (sectionProvider == null) {
    if (variant.isTop())     sectionProvider=new DefaultLeftSectionElementComponentProvider();
 else     sectionProvider=new DefaultLeftSectionElementComponentProvider();
  }
  if (submenuProvider == null) {
    if (variant.isTop())     submenuProvider=new DefaultTopSubmenuNavigationElementProvider();
 else     submenuProvider=new DefaultLeftSubmenuNavigationElementProvider();
  }
  AppLayoutSessionHelper.setActiveVariant(variant);
  instance.setTitle(title);
  if (navigatorEnabled) {
    navigator=navigatorProducer.apply(instance.getContentHolder());
    navigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (viewProviderSupplier != null) {
      navigator.addProvider(viewProviderSupplier.get());
    }
    if (errorProvider != null) {
      navigator.setErrorProvider(errorProvider.get());
    }
    if (errorViewProvider != null) {
      navigator.setErrorView(errorViewProvider.get());
    }
    if (navigatorConsumer != null) {
      navigatorConsumer.accept(navigator);
    }
    if (!CDI) {
      if (defaultNavigationElement == null) {
        defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
      }
      defaultNavigationElement.addViewToNavigator(navigator);
    }
 else     if (CDI && defaultNavigationElement != null) {
      System.err.println(""String_Node_Str"");
    }
  }
 else {
    componentNavigator=new ComponentNavigator(instance.getContentHolder());
    componentNavigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (viewProviderSupplier != null) {
      componentNavigator.addProvider(viewProviderSupplier.get());
    }
    if (errorProvider != null) {
      componentNavigator.setErrorProvider(errorProvider.get());
    }
    if (errorViewProvider != null) {
      componentNavigator.setErrorView(errorViewProvider.get());
    }
    if (defaultNavigationElement == null) {
      defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
    }
    defaultNavigationElement.addViewToComponentNavigator(componentNavigator);
  }
  addComponents(headerElements,instance::addNavigationHeaderElement);
  addComponents(navigationElements,instance::addNavigationElement);
  addComponents(footerElements,instance::addNavigationFooterElement);
  appBarElements.forEach(instance::addAppBarElement);
  instance.setDesign(design);
  if (appBarIconComponent != null) {
    instance.addAppBarIcon(appBarIconComponent);
  }
  instance.setNavigatorNavigationElements(navigatorElements);
  if (!navigatorEnabled) {
    componentNavigator.navigateTo(defaultNavigationElement.getViewName());
  }
  return instance;
}","The original code incorrectly used `setTitle(title)` instead of `instance.setTitle(title)`, which would likely cause a method invocation error. The fixed code correctly calls the title setter method on the `instance` object, ensuring proper title configuration. This change resolves the potential null pointer or method resolution issue, improving the reliability of the title setting mechanism in the AppLayoutComponent builder."
38055,"public AppLayoutComponent build(){
  if (navigationElementProvider == null) {
    if (variant.isTop())     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
 else     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
  }
  if (customElementProvider == null) {
    if (variant.isTop())     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
 else     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
  }
  if (sectionProvider == null) {
    if (variant.isTop())     sectionProvider=new DefaultLeftSectionElementComponentProvider();
 else     sectionProvider=new DefaultLeftSectionElementComponentProvider();
  }
  if (submenuProvider == null) {
    if (variant.isTop())     submenuProvider=new DefaultTopSubmenuNavigationElementProvider();
 else     submenuProvider=new DefaultLeftSubmenuNavigationElementProvider();
  }
  AppLayoutSessionHelper.setActiveVariant(variant);
  if (titleComponent == null) {
    instance.setTitle(title);
  }
 else {
    instance.setTitleComponent(titleComponent);
  }
  if (navigatorEnabled) {
    navigator=navigatorProducer.apply(instance.getContentHolder());
    if (navigator == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    navigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (viewProviderSupplier != null) {
      navigator.addProvider(viewProviderSupplier.get());
    }
    if (errorProvider != null) {
      navigator.setErrorProvider(errorProvider.get());
    }
    if (errorViewProvider != null) {
      navigator.setErrorView(errorViewProvider.get());
    }
    if (navigatorConsumer != null) {
      navigatorConsumer.accept(navigator);
    }
    if (!CDI) {
      if (defaultNavigationElement == null) {
        defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
      }
      defaultNavigationElement.addViewToNavigator(navigator);
    }
 else     if (CDI && defaultNavigationElement != null) {
      System.err.println(""String_Node_Str"");
    }
  }
 else {
    componentNavigator=new ComponentNavigator(instance.getContentHolder());
    componentNavigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (errorViewProvider != null) {
      componentNavigator.setErrorView(errorViewProvider.get());
    }
    if (componentNavigatorConsumer != null) {
      componentNavigatorConsumer.accept(componentNavigator);
    }
    if (defaultNavigationElement == null) {
      defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
    }
    defaultNavigationElement.addViewToComponentNavigator(componentNavigator);
  }
  addComponents(headerElements,instance::addNavigationHeaderElement);
  addComponents(navigationElements,instance::addNavigationElement);
  addComponents(footerElements,instance::addNavigationFooterElement);
  appBarElements.forEach(instance::addAppBarElement);
  instance.setDesign(design);
  if (appBarIconComponent != null) {
    instance.addAppBarIcon(appBarIconComponent);
  }
  instance.setNavigatorNavigationElements(navigatorElements);
  if (!navigatorEnabled) {
    componentNavigator.navigateTo(defaultNavigationElement.getViewName());
  }
  return instance;
}","public AppLayoutComponent build(){
  if (navigationElementProvider == null) {
    if (variant.isTop())     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
 else     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
  }
  if (customElementProvider == null) {
    if (variant.isTop())     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
 else     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
  }
  if (sectionProvider == null) {
    if (variant.isTop())     sectionProvider=new DefaultLeftSectionElementComponentProvider();
 else     sectionProvider=new DefaultLeftSectionElementComponentProvider();
  }
  if (submenuProvider == null) {
    if (variant.isTop())     submenuProvider=new DefaultTopSubmenuNavigationElementProvider();
 else     submenuProvider=new DefaultLeftSubmenuNavigationElementProvider();
  }
  AppLayoutSessionHelper.setActiveVariant(variant);
  if (titleComponent == null) {
    instance.setTitle(title);
  }
 else {
    instance.setTitleComponent(titleComponent);
  }
  if (navigatorEnabled) {
    navigator=navigatorProducer.apply(instance.getContentHolder());
    if (navigator == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    navigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (viewProviderSupplier != null) {
      navigator.addProvider(viewProviderSupplier.get());
    }
    if (errorProvider != null) {
      navigator.setErrorProvider(errorProvider.get());
    }
    if (errorViewProvider != null) {
      navigator.setErrorView(errorViewProvider.get());
    }
    if (navigatorConsumer != null) {
      navigatorConsumer.accept(navigator);
    }
    if (!CDI && defaultNavigationElement == null) {
      defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
    }
  }
 else {
    componentNavigator=new ComponentNavigator(instance.getContentHolder());
    componentNavigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (errorViewProvider != null) {
      componentNavigator.setErrorView(errorViewProvider.get());
    }
    if (componentNavigatorConsumer != null) {
      componentNavigatorConsumer.accept(componentNavigator);
    }
    if (defaultNavigationElement == null) {
      defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
    }
    defaultNavigationElement.addViewToComponentNavigator(componentNavigator);
  }
  addComponents(headerElements,instance::addNavigationHeaderElement);
  addComponents(navigationElements,instance::addNavigationElement);
  addComponents(footerElements,instance::addNavigationFooterElement);
  appBarElements.forEach(instance::addAppBarElement);
  instance.setDesign(design);
  if (appBarIconComponent != null) {
    instance.addAppBarIcon(appBarIconComponent);
  }
  instance.setNavigatorNavigationElements(navigatorElements);
  if (!navigatorEnabled) {
    componentNavigator.navigateTo(defaultNavigationElement.getViewName());
  }
 else {
    if (!CDI && defaultNavigationElement != null) {
      defaultNavigationElement.addViewToNavigator(navigator);
    }
 else     if (CDI && defaultNavigationElement != null) {
      System.err.println(""String_Node_Str"");
    }
  }
  return instance;
}","The original code had misplaced conditional logic for adding default navigation elements, causing potential navigation setup errors in different scenarios. The fixed code restructures the navigation element addition logic, separating the conditions for CDI and non-CDI environments and moving the navigation element setup to the end of the method. This ensures proper navigation configuration regardless of the navigation mode, improving the robustness and predictability of the application's navigation behavior."
38056,"public static CDIAppLayoutBuilderWrapper getCDIBuilder(Behaviour behaviour){
  return new CDIAppLayoutBuilderWrapper(behaviour);
}","public static CDIBuilderNavigatorPreamble getCDIBuilder(Behaviour behaviour){
  return new CDIBuilderNavigatorPreamble(CDIAppLayoutBuilder.get(behaviour.getInstance()));
}","The original code directly instantiated a CDIAppLayoutBuilderWrapper without proper initialization, potentially leading to incomplete or incorrect builder configuration. The fixed code introduces CDIBuilderNavigatorPreamble and uses CDIAppLayoutBuilder.get() to retrieve a properly configured instance based on the behavior's instance. This approach ensures a more robust and controlled builder creation process, enhancing the reliability and flexibility of the builder initialization mechanism."
38057,"public AppLayoutComponent build(){
  if (navigationElementProvider == null) {
    if (variant.isTop())     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
 else     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
  }
  if (customElementProvider == null) {
    if (variant.isTop())     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
 else     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
  }
  if (sectionProvider == null) {
    if (variant.isTop())     sectionProvider=new DefaultLeftSectionElementComponentProvider();
 else     sectionProvider=new DefaultLeftSectionElementComponentProvider();
  }
  if (submenuProvider == null) {
    if (variant.isTop())     submenuProvider=new DefaultTopSubmenuNavigationElementProvider();
 else     submenuProvider=new DefaultLeftSubmenuNavigationElementProvider();
  }
  AppLayoutSessionHelper.setActiveVariant(variant);
  instance.setTitle(title);
  if (navigatorEnabled) {
    navigator=navigatorProducer.apply(instance.getContentHolder());
    navigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (viewProviderSupplier != null) {
      navigator.addProvider(viewProviderSupplier.get());
    }
    if (errorProvider != null) {
      navigator.setErrorProvider(errorProvider.get());
    }
    if (errorViewProvider != null) {
      navigator.setErrorView(errorViewProvider.get());
    }
    if (navigatorConsumer != null) {
      navigatorConsumer.accept(navigator);
    }
    if (!CDI) {
      if (defaultNavigationElement == null) {
        defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
      }
      defaultNavigationElement.addViewToNavigator(navigator);
    }
 else     if (CDI && defaultNavigationElement != null) {
      System.err.println(""String_Node_Str"");
    }
  }
 else {
    componentNavigator=new ComponentNavigator(instance.getContentHolder());
    componentNavigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (viewProviderSupplier != null) {
      componentNavigator.addProvider(viewProviderSupplier.get());
    }
    if (errorProvider != null) {
      componentNavigator.setErrorProvider(errorProvider.get());
    }
    if (errorViewProvider != null) {
      componentNavigator.setErrorView(errorViewProvider.get());
    }
    if (defaultNavigationElement == null) {
      defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
    }
    defaultNavigationElement.addViewToComponentNavigator(componentNavigator);
  }
  addComponents(headerElements,instance::addNavigationHeaderElement);
  addComponents(navigationElements,instance::addNavigationElement);
  addComponents(footerElements,instance::addNavigationFooterElement);
  appBarElements.forEach(instance::addAppBarElement);
  instance.setDesign(design);
  if (appBarIconComponent != null) {
    instance.addAppBarIcon(appBarIconComponent);
  }
  instance.setNavigatorNavigationElements(navigatorElements);
  if (!navigatorEnabled) {
    componentNavigator.navigateTo(defaultNavigationElement.getViewName());
  }
  return instance;
}","public AppLayoutComponent build(){
  if (navigationElementProvider == null) {
    if (variant.isTop())     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
 else     navigationElementProvider=new DefaultLeftNavigationBadgeElementComponentProvider();
  }
  if (customElementProvider == null) {
    if (variant.isTop())     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
 else     customElementProvider=new DefaultLeftClickableNavigationElementProvider();
  }
  if (sectionProvider == null) {
    if (variant.isTop())     sectionProvider=new DefaultLeftSectionElementComponentProvider();
 else     sectionProvider=new DefaultLeftSectionElementComponentProvider();
  }
  if (submenuProvider == null) {
    if (variant.isTop())     submenuProvider=new DefaultTopSubmenuNavigationElementProvider();
 else     submenuProvider=new DefaultLeftSubmenuNavigationElementProvider();
  }
  AppLayoutSessionHelper.setActiveVariant(variant);
  instance.setTitle(title);
  if (navigatorEnabled) {
    navigator=navigatorProducer.apply(instance.getContentHolder());
    navigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (viewProviderSupplier != null) {
      navigator.addProvider(viewProviderSupplier.get());
    }
    if (errorProvider != null) {
      navigator.setErrorProvider(errorProvider.get());
    }
    if (errorViewProvider != null) {
      navigator.setErrorView(errorViewProvider.get());
    }
    if (navigatorConsumer != null) {
      navigatorConsumer.accept(navigator);
    }
    if (!CDI) {
      if (defaultNavigationElement == null) {
        defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
      }
      defaultNavigationElement.addViewToNavigator(navigator);
    }
 else     if (CDI && defaultNavigationElement != null) {
      System.err.println(""String_Node_Str"");
    }
  }
 else {
    componentNavigator=new ComponentNavigator(instance.getContentHolder());
    componentNavigator.addViewChangeListener(event -> beforeViewChange(event.getViewName()));
    if (errorViewProvider != null) {
      componentNavigator.setErrorView(errorViewProvider.get());
    }
    if (defaultNavigationElement == null) {
      defaultNavigationElement=navigationElements.stream().filter(element -> element instanceof NavigatorNavigationElement).map(element -> ((NavigatorNavigationElement)element)).findFirst().orElse(null);
    }
    defaultNavigationElement.addViewToComponentNavigator(componentNavigator);
  }
  addComponents(headerElements,instance::addNavigationHeaderElement);
  addComponents(navigationElements,instance::addNavigationElement);
  addComponents(footerElements,instance::addNavigationFooterElement);
  appBarElements.forEach(instance::addAppBarElement);
  instance.setDesign(design);
  if (appBarIconComponent != null) {
    instance.addAppBarIcon(appBarIconComponent);
  }
  instance.setNavigatorNavigationElements(navigatorElements);
  if (!navigatorEnabled) {
    componentNavigator.navigateTo(defaultNavigationElement.getViewName());
  }
  return instance;
}","The original code redundantly set navigation and custom element providers identically for both top and non-top variants, creating unnecessary complexity. In the fixed code, the redundant conditions were removed, and the error view provider for the component navigator was correctly added. This simplifies the code, reduces potential confusion, and ensures consistent navigation element configuration across different layout variants."
38058,"public void navigateTo(String viewName){
  if (currentViewName == null || !currentViewName.equals(viewName)) {
    contentHolder.setContent(views.get(viewName).getViewComponent());
    this.listeners.forEach(viewChangeListener -> viewChangeListener.beforeViewChange(new ViewChangeListener.ViewChangeEvent(this,views.getOrDefault(currentViewName,null),views.get(viewName),viewName,null)));
    currentViewName=viewName;
  }
}","public void navigateTo(String viewName){
  if (currentViewName == null || !currentViewName.equals(viewName)) {
    if (views.containsKey(viewName)) {
      contentHolder.setContent(views.get(viewName).getViewComponent());
      this.listeners.forEach(viewChangeListener -> viewChangeListener.beforeViewChange(new ViewChangeListener.ViewChangeEvent(this,views.getOrDefault(currentViewName,null),views.get(viewName),viewName,null)));
      currentViewName=viewName;
    }
 else {
      currentViewName=null;
      if (errorView != null) {
        contentHolder.setContent(errorView.getViewComponent());
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
}","The original code lacks validation to check if the requested view exists before attempting to navigate, potentially causing a null pointer exception or unexpected behavior. The fixed code adds a containsKey check to verify the view's existence, and introduces an error handling mechanism with an optional error view or exception fallback. This improvement ensures robust navigation by gracefully managing cases where a requested view is not found, preventing runtime errors and providing a more resilient navigation strategy."
38059,"private void setDrawerVariant(Behaviour variant){
  holder.removeAllComponents();
  AppLayoutComponent drawer=AppLayout.getBuilder(variant).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withViewNameInterceptor(new DefaultViewNameInterceptor()).withDefaultNavigationView(View1.class).withDesign(AppBarDesign.MATERIAL).withNavigatorConsumer(navigator -> {
  }
).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).addClickable(""String_Node_Str"",VaadinIcons.COG,clickEvent -> openModeSelector(variant),HEADER).add(""String_Node_Str"",VaadinIcons.HOME,badge,new View1()).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(""String_Node_Str"",VaadinIcons.SPLINE_CHART,View2.class).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(""String_Node_Str"",VaadinIcons.SPLINE_CHART,View2.class).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(""String_Node_Str"",VaadinIcons.MENU,View5.class).add(""String_Node_Str"",VaadinIcons.LIST,View6.class).addClickable(""String_Node_Str"",VaadinIcons.COG,clickEvent -> openModeSelector(variant),FOOTER).build();
  drawer.addStyleName(""String_Node_Str"");
  holder.addComponent(drawer);
  if (getNavigator() != null) {
    getNavigator().navigateTo(""String_Node_Str"");
  }
}","private void setDrawerVariant(Behaviour variant){
  holder.removeAllComponents();
  AppLayoutComponent drawer=AppLayout.getDefaultBuilder(variant).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withViewNameInterceptor(new DefaultViewNameInterceptor()).withDefaultNavigationView(View1.class).withDesign(AppBarDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).addClickable(""String_Node_Str"",VaadinIcons.COG,clickEvent -> openModeSelector(variant),HEADER).add(""String_Node_Str"",VaadinIcons.HOME,badge,new View1()).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(""String_Node_Str"",VaadinIcons.SPLINE_CHART,View2.class).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(SubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(""String_Node_Str"",VaadinIcons.SPLINE_CHART,View2.class).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(""String_Node_Str"",VaadinIcons.CONNECT,View3.class).add(""String_Node_Str"",VaadinIcons.COG,View4.class).build()).add(""String_Node_Str"",VaadinIcons.MENU,View5.class).add(""String_Node_Str"",VaadinIcons.LIST,View6.class).addClickable(""String_Node_Str"",VaadinIcons.COG,clickEvent -> openModeSelector(variant),FOOTER).build();
  drawer.addStyleName(""String_Node_Str"");
  holder.addComponent(drawer);
  if (getNavigator() != null) {
    getNavigator().navigateTo(""String_Node_Str"");
  }
}","The original code used `AppLayout.getBuilder()`, which lacks proper configuration for default settings. The fixed code replaces this with `AppLayout.getDefaultBuilder()`, providing a more standardized and reliable builder initialization. This change ensures consistent layout configuration, improves code readability, and reduces potential configuration errors in the Vaadin application's drawer setup."
38060,"public void init(VaadinRequest request){
  setContent(AppLayout.getCDIBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withViewProvider(() -> viewProvider).withErrorView(() -> new View1()).withNavigationElementInfoProvider(new DefaultSpringNavigationElementInfoProvider()).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withDesign(AppBarDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(View1.class,badge).add(CDISubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(View2.class).add(View3.class).add(View4.class).build()).add(View5.class).add(View6.class).build());
}","public void init(VaadinRequest request){
  setContent(AppLayout.getCDIBuilder(Behaviour.LEFT_RESPONSIVE_HYBRID).withViewProvider(() -> viewProvider).withErrorView(() -> new View1()).withNavigationElementInfoProvider(new DefaultSpringNavigationElementInfoProvider()).withTitle(""String_Node_Str"").addToAppBar(new AppBarNotificationButton(notifications,true)).withDesign(AppBarDesign.MATERIAL).add(new MenuHeader(""String_Node_Str"",new ThemeResource(""String_Node_Str"")),HEADER).add(badge,View1.class).add(CDISubmenuBuilder.get(""String_Node_Str"",VaadinIcons.PLUS).add(View2.class).add(View3.class).add(View4.class).build()).add(View5.class).add(View6.class).build());
}","The original code incorrectly placed the badge parameter before the view class in the `.add()` method, which could cause navigation and rendering issues. In the fixed code, the badge and View1.class parameters are swapped, ensuring correct view registration and badge association. This correction resolves potential routing and component placement problems, improving the overall layout and navigation structure of the Vaadin application."
38061,"public NavigationButton(String name,Resource icon){
  com.vaadin.ui.Button button=new com.vaadin.ui.Button(name);
  button.setIcon(icon);
  button.addStyleName(ValoTheme.BUTTON_BORDERLESS);
  button.addStyleName(""String_Node_Str"");
  button.addStyleName(""String_Node_Str"");
  button.setWidth(100,Sizeable.Unit.PERCENTAGE);
}","public NavigationButton(String name,Resource icon){
  super(name);
  setIcon(icon);
  addStyleName(ValoTheme.BUTTON_BORDERLESS);
  addStyleName(""String_Node_Str"");
  addStyleName(""String_Node_Str"");
  setWidth(100,Sizeable.Unit.PERCENTAGE);
}","The original code creates a local Button instance instead of extending the Button class, leading to improper initialization and potential scope issues. The fixed code uses inheritance by calling `super(name)` and removing the local variable, directly modifying the button's properties through inherited methods. This approach ensures proper button creation, maintains cleaner code, and eliminates unnecessary object instantiation while preserving the original functionality."
38062,"public AbstractNavigationDrawer(String filename) throws IOException {
  super(AbstractNavigationDrawer.class.getResourceAsStream(filename));
  contentHolder.setMargin(false);
  menuElementHolder.setMargin(false);
  menuElementHolder.setWidth(99,Unit.PERCENTAGE);
  setSizeFull();
  addStyleName(getStyleName());
  super.addComponent(contentHolder,""String_Node_Str"");
  super.addComponent(menuElementHolder,""String_Node_Str"");
  super.addComponent(appBar,""String_Node_Str"");
  appBar.addComponents(titleWrapper,appBarElementHolder);
  appBar.setSizeFull();
  appBar.setComponentAlignment(appBarElementHolder,Alignment.TOP_RIGHT);
  appBarElementHolder.setSpacing(false);
  titleWrapper.setHeight(45,Unit.PIXELS);
  titleWrapper.setComponentAlignment(title,Alignment.MIDDLE_LEFT);
}","public AbstractNavigationDrawer(String filename) throws IOException {
  super(AbstractNavigationDrawer.class.getResourceAsStream(filename));
  contentHolder.setMargin(false);
  menuElementHolder.setMargin(false);
  menuElementHolder.setWidth(99,Unit.PERCENTAGE);
  setSizeFull();
  addStyleName(getStyleName());
  super.addComponent(contentHolder,""String_Node_Str"");
  super.addComponent(menuElementHolder,""String_Node_Str"");
  super.addComponent(appBar,""String_Node_Str"");
  appBar.addComponents(titleWrapper,appBarElementHolder);
  appBar.setWidth(100,Unit.PERCENTAGE);
  appBar.setHeight(45,Unit.PIXELS);
  appBar.setComponentAlignment(appBarElementHolder,Alignment.MIDDLE_RIGHT);
  appBarElementHolder.setSpacing(false);
  titleWrapper.setHeight(100,Unit.PERCENTAGE);
  titleWrapper.setComponentAlignment(title,Alignment.MIDDLE_LEFT);
}","The original code had imprecise sizing and alignment settings for the app bar and its components, leading to potential layout inconsistencies. The fixed code corrects this by setting explicit width (100%), height (45 pixels), and adjusting the app bar element holder alignment to MIDDLE_RIGHT, while also setting the title wrapper height to 100%. These modifications ensure a more consistent, responsive, and visually balanced navigation drawer layout with precise component positioning and sizing."
38063,"public AbstractNavigationDrawer(String filename) throws IOException {
  super(AbstractNavigationDrawer.class.getResourceAsStream(filename));
  contentHolder.setMargin(false);
  menuElementHolder.setMargin(false);
  setSizeFull();
  addStyleName(getStyleName());
  super.addComponent(contentHolder,""String_Node_Str"");
  super.addComponent(menuElementHolder,""String_Node_Str"");
  super.addComponent(appBar,""String_Node_Str"");
  appBar.addComponents(titleWrapper,appBarElementHolder);
  appBar.setSizeFull();
  appBar.setComponentAlignment(appBarElementHolder,Alignment.TOP_RIGHT);
  appBarElementHolder.setSpacing(false);
  titleWrapper.setHeight(100,Unit.PERCENTAGE);
  titleWrapper.setComponentAlignment(title,Alignment.MIDDLE_LEFT);
}","public AbstractNavigationDrawer(String filename) throws IOException {
  super(AbstractNavigationDrawer.class.getResourceAsStream(filename));
  contentHolder.setMargin(false);
  menuElementHolder.setMargin(false);
  menuElementHolder.setWidth(99,Unit.PERCENTAGE);
  setSizeFull();
  addStyleName(getStyleName());
  super.addComponent(contentHolder,""String_Node_Str"");
  super.addComponent(menuElementHolder,""String_Node_Str"");
  super.addComponent(appBar,""String_Node_Str"");
  appBar.addComponents(titleWrapper,appBarElementHolder);
  appBar.setSizeFull();
  appBar.setComponentAlignment(appBarElementHolder,Alignment.TOP_RIGHT);
  appBarElementHolder.setSpacing(false);
  titleWrapper.setHeight(100,Unit.PERCENTAGE);
  titleWrapper.setComponentAlignment(title,Alignment.MIDDLE_LEFT);
}","The original code lacked proper width configuration for the menuElementHolder, potentially causing layout inconsistencies. The fixed code adds `menuElementHolder.setWidth(99,Unit.PERCENTAGE)`, ensuring consistent sizing and preventing potential alignment or display issues. This modification improves the component's responsiveness and visual presentation by providing a more predictable and uniform layout across different screen sizes."
38064,"@HttpPost @Route(""String_Node_Str"") public void checkMe(){
  try {
    Session session=Request().session();
    long uid=session == null || session.attribute(""String_Node_Str"") == null ? 0 : session.attribute(""String_Node_Str"");
    if (uid < 1) {
      throw new HttpException(""String_Node_Str"",200);
    }
    User user=userService.getUser(uid);
    session.addAttribute(""String_Node_Str"",user.getId());
    session.addAttribute(""String_Node_Str"",user.getUsername());
    session.addAttribute(""String_Node_Str"",user.getEmail());
    Map<String,Object> resp=new HashMap<>(2);
    resp.put(""String_Node_Str"",user);
    resp.put(""String_Node_Str"",""String_Node_Str"");
    Succeed(resp);
  }
 catch (  Exception e) {
    Fail(e);
  }
}","@HttpPost @Route(""String_Node_Str"") public void checkMe(){
  try {
    Session session=Request().session();
    long uid=session == null || session.attribute(""String_Node_Str"") == null ? 0 : session.attribute(""String_Node_Str"");
    if (uid < 1) {
      throw new HttpException(""String_Node_Str"",200);
    }
    LoginUser user=userService.getLoginUser(uid);
    user.setFavoriteTopicIds(userMetaService.getFavoriteIds(uid));
    session.addAttribute(""String_Node_Str"",user.getId());
    session.addAttribute(""String_Node_Str"",user.getUsername());
    session.addAttribute(""String_Node_Str"",user.getEmail());
    Map<String,Object> resp=new HashMap<>(2);
    resp.put(""String_Node_Str"",user);
    resp.put(""String_Node_Str"",""String_Node_Str"");
    Succeed(resp);
  }
 catch (  Exception e) {
    Fail(e);
  }
}","The original code used a generic `User` object without additional context, potentially missing critical user-specific metadata like favorite topic IDs. The fixed code introduces a `LoginUser` type and calls `userMetaService.getFavoriteIds(uid)` to populate additional user details, enhancing data retrieval comprehensiveness. By extending user information and explicitly setting favorite topic IDs, the new implementation provides a more robust and information-rich user representation."
38065,"@Override public LoginUser getLoginUser(long id){
  User user=getUser(id);
  LoginUser loginUser=DozerMapperUtil.map(user,LoginUser.class);
  loginUser.setFavoriteTopicIds(userMetaService.getFavoriteIds(id));
  return loginUser;
}","@Override public LoginUser getLoginUser(long id){
  User user=getUser(id);
  LoginUser loginUser=DozerMapperUtil.map(user,LoginUser.class);
  return loginUser;
}","The original code unnecessarily added a database call to fetch favorite topic IDs after mapping the user, which could introduce performance overhead and potential null pointer risks. The fixed code removes the extra service call, focusing solely on mapping the User to LoginUser using DozerMapperUtil. By eliminating the redundant operation, the code becomes more efficient, cleaner, and reduces potential points of failure during user retrieval."
38066,"public static void main(String[] args) throws IOException {
  while (!order.isClosed()) {
    int cost;
    String continueChoice;
    do {
      System.out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      int choice=Integer.parseInt(reader.readLine());
      cost=priceOnProducts.get(choice);
      System.out.print(""String_Node_Str"");
      int count=Integer.parseInt(reader.readLine());
      order.setTotalCost(cost * count);
      System.out.print(""String_Node_Str"");
      continueChoice=reader.readLine();
    }
 while (continueChoice.equalsIgnoreCase(""String_Node_Str""));
    if (strategy == null) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      String paymentMethod=reader.readLine();
      if (paymentMethod.equals(""String_Node_Str"")) {
        strategy=new PayByPayPal();
      }
 else       if (paymentMethod.equals(""String_Node_Str"")) {
        strategy=new PayByCreditCard();
      }
      order.processOrder(strategy);
    }
    System.out.print(""String_Node_Str"" + order.getTotalCost() + ""String_Node_Str"");
    String proceed=reader.readLine();
    if (proceed.equalsIgnoreCase(""String_Node_Str"")) {
      if (strategy.pay(order.getTotalCost())) {
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
      order.setClosed();
    }
  }
}","public static void main(String[] args) throws IOException {
  while (!order.isClosed()) {
    int cost;
    String continueChoice;
    do {
      System.out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      int choice=Integer.parseInt(reader.readLine());
      cost=priceOnProducts.get(choice);
      System.out.print(""String_Node_Str"");
      int count=Integer.parseInt(reader.readLine());
      order.setTotalCost(cost * count);
      System.out.print(""String_Node_Str"");
      continueChoice=reader.readLine();
    }
 while (continueChoice.equalsIgnoreCase(""String_Node_Str""));
    if (strategy == null) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      String paymentMethod=reader.readLine();
      if (paymentMethod.equals(""String_Node_Str"")) {
        strategy=new PayByPayPal();
      }
 else {
        strategy=new PayByCreditCard();
      }
      order.processOrder(strategy);
      System.out.print(""String_Node_Str"" + order.getTotalCost() + ""String_Node_Str"");
      String proceed=reader.readLine();
      if (proceed.equalsIgnoreCase(""String_Node_Str"")) {
        if (strategy.pay(order.getTotalCost())) {
          System.out.println(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
        }
        order.setClosed();
      }
    }
  }
}","The original code had a logical error where payment processing and order closure were not properly sequenced, potentially allowing multiple payment attempts or incomplete order processing. The fixed code restructures the logic by moving the payment processing and order closure steps inside the strategy selection block, ensuring that payment is processed immediately after selecting a payment method. This modification guarantees a more robust and sequential order completion workflow, preventing potential state inconsistencies and improving the overall transaction reliability."
38067,"public CreditCard(String number,String date,String cvv){
}","CreditCard(String number,String date,String cvv){
}","The original code lacks a proper constructor declaration by using the `public` access modifier without specifying a return type, which violates Java constructor syntax rules. The fixed code removes the `public` keyword and correctly defines the constructor with the class name, matching standard Java constructor declaration conventions. This correction ensures the constructor is properly defined, allowing object instantiation without compilation errors and maintaining proper object-oriented design principles."
38068,"public static File fix(VideoFile result){
  System.out.println(""String_Node_Str"");
  return new File(""String_Node_Str"");
}","public File fix(VideoFile result){
  System.out.println(""String_Node_Str"");
  return new File(""String_Node_Str"");
}","The original code incorrectly declared the method as static, which would prevent instance-specific method behavior and limit flexibility for potential object-oriented design. The fixed code removes the static keyword, allowing the method to be an instance method that can be called on specific VideoFile objects. This modification enables more dynamic and context-aware file handling, improving the method's adaptability and potential for inheritance and polymorphic behavior."
38069,"private void simulateNetworkLatency(){
  try {
    Thread.currentThread().sleep(2500);
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}","private void simulateNetworkLatency(){
  try {
    Thread.sleep(2500);
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}","The original code incorrectly uses `Thread.currentThread().sleep(2500)`, which is a verbose and unnecessary way to pause thread execution. The fixed code simplifies this by directly calling the static method `Thread.sleep(2500)`, which achieves the same result more concisely. This change improves code readability and follows Java's recommended practice for introducing a time delay in thread execution."
38070,"private void simulateNetworkLatency(){
  try {
    Thread.currentThread().sleep(2500);
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}","private void simulateNetworkLatency(){
  try {
    Thread.sleep(2500);
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}","The original code incorrectly uses `Thread.currentThread().sleep(2500)`, which is a redundant and verbose method of introducing a thread delay. The fixed code simplifies this by directly using the static `Thread.sleep(2500)` method, which achieves the same result more concisely and efficiently. This change reduces unnecessary method chaining and makes the code cleaner and more straightforward to read and maintain."
38071,"private Singleton(String value){
  try {
    Thread.currentThread().sleep(1000);
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
  this.value=value;
}","private Singleton(String value){
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
  this.value=value;
}","The original code incorrectly uses `Thread.currentThread().sleep(1000)`, which is a redundant and verbose method of introducing a delay. The fixed code simplifies this by using the static `Thread.sleep(1000)` method, which directly pauses the current thread's execution. This change makes the code more concise, readable, and semantically correct while maintaining the same functionality of introducing a one-second delay during object initialization."
38072,"public static void main(String[] args) throws IOException {
  while (!order.isClosed()) {
    int cost;
    String continueChoice;
    do {
      System.out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      int choice=Integer.parseInt(reader.readLine());
      cost=priceOnProducts.get(choice);
      System.out.print(""String_Node_Str"");
      int count=Integer.parseInt(reader.readLine());
      order.setTotalCost(cost * count);
      System.out.print(""String_Node_Str"");
      continueChoice=reader.readLine();
    }
 while (continueChoice.equalsIgnoreCase(""String_Node_Str""));
    if (strategy == null) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      String paymentMethod=reader.readLine();
      if (paymentMethod.equals(""String_Node_Str"")) {
        strategy=new PayByPayPal();
      }
 else       if (paymentMethod.equals(""String_Node_Str"")) {
        strategy=new PayByCreditCard();
      }
      order.processOrder(strategy);
    }
    System.out.print(""String_Node_Str"" + Order.getTotalCost() + ""String_Node_Str"");
    String proceed=reader.readLine();
    if (proceed.equalsIgnoreCase(""String_Node_Str"")) {
      if (strategy.pay(Order.getTotalCost())) {
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
      order.setClosed();
    }
  }
}","public static void main(String[] args) throws IOException {
  while (!order.isClosed()) {
    int cost;
    String continueChoice;
    do {
      System.out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      int choice=Integer.parseInt(reader.readLine());
      cost=priceOnProducts.get(choice);
      System.out.print(""String_Node_Str"");
      int count=Integer.parseInt(reader.readLine());
      order.setTotalCost(cost * count);
      System.out.print(""String_Node_Str"");
      continueChoice=reader.readLine();
    }
 while (continueChoice.equalsIgnoreCase(""String_Node_Str""));
    if (strategy == null) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      String paymentMethod=reader.readLine();
      if (paymentMethod.equals(""String_Node_Str"")) {
        strategy=new PayByPayPal();
      }
 else       if (paymentMethod.equals(""String_Node_Str"")) {
        strategy=new PayByCreditCard();
      }
      order.processOrder(strategy);
    }
    System.out.print(""String_Node_Str"" + order.getTotalCost() + ""String_Node_Str"");
    String proceed=reader.readLine();
    if (proceed.equalsIgnoreCase(""String_Node_Str"")) {
      if (strategy.pay(order.getTotalCost())) {
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
      order.setClosed();
    }
  }
}","The original code incorrectly used `Order.getTotalCost()` as a static method, which is likely not the intended implementation for retrieving the order's total cost. In the fixed code, `order.getTotalCost()` is used, which correctly calls the method on the specific order instance. This change ensures proper encapsulation and allows the method to accurately retrieve the current order's total cost, maintaining the intended behavior of the payment processing logic."
38073,"public static int getTotalCost(){
  return totalCost;
}","public int getTotalCost(){
  return totalCost;
}","The original code incorrectly used the `static` keyword for the `getTotalCost()` method, which would prevent accessing instance-specific `totalCost` values. By removing `static`, the method becomes an instance method that can access the specific object's `totalCost` attribute. This change allows each object to have its own total cost value, enabling proper encapsulation and individual cost tracking for different instances of the class."
38074,"private void simulateNetworkLatency(){
  try {
    int i=0;
    System.out.println();
    while (i < 10) {
      System.out.print(""String_Node_Str"");
      Thread.currentThread().sleep(500);
      i++;
    }
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}","private void simulateNetworkLatency(){
  try {
    int i=0;
    System.out.println();
    while (i < 10) {
      System.out.print(""String_Node_Str"");
      Thread.sleep(500);
      i++;
    }
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}","The original code incorrectly uses `Thread.currentThread().sleep(500)`, which is a redundant and less efficient method of introducing a thread delay. The fixed code simplifies this to `Thread.sleep(500)`, which directly pauses the current thread without explicitly calling `currentThread()`. This change makes the code more concise, readable, and performs the same network latency simulation with cleaner and more standard Java thread sleep syntax."
38075,"private void simulateNetworkLatency(){
  try {
    int i=0;
    System.out.println();
    while (i < 10) {
      System.out.print(""String_Node_Str"");
      Thread.currentThread().sleep(500);
      i++;
    }
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}","private void simulateNetworkLatency(){
  try {
    int i=0;
    System.out.println();
    while (i < 10) {
      System.out.print(""String_Node_Str"");
      Thread.sleep(500);
      i++;
    }
  }
 catch (  InterruptedException ex) {
    ex.printStackTrace();
  }
}","The buggy code incorrectly uses `currentThread().sleep()`, which is an unnecessary method call that adds complexity to the simple sleep operation. The fixed code directly uses `Thread.sleep(500)`, which is the correct and more straightforward way to pause thread execution for 500 milliseconds. This simplification reduces method overhead and makes the code cleaner and more efficient while maintaining the same functionality of simulating network latency."
38076,"private static String getMessage(Throwable t){
  if (t.getMessage().isEmpty()) {
    return t.getClass().getSimpleName();
  }
 else {
    return t.getClass().getSimpleName() + ""String_Node_Str"" + t.getMessage();
  }
}","private static String getMessage(Throwable t){
  if (t.getMessage() == null) {
    return t.getClass().getSimpleName();
  }
 else {
    return t.getClass().getSimpleName() + ""String_Node_Str"" + t.getMessage();
  }
}","The original code incorrectly uses `.isEmpty()` on a potentially null message, which can cause a NullPointerException if the exception's message is null. The fixed code replaces `.isEmpty()` with a null check (`t.getMessage() == null`), ensuring safe handling of exceptions with null messages. This modification prevents runtime errors and provides a more robust method for extracting exception information."
38077,"private static String getMessage(Throwable t){
  if (t.getMessage().isEmpty()) {
    return t.getClass().getSimpleName();
  }
 else {
    return t.getClass().getSimpleName() + ""String_Node_Str"" + t.getMessage();
  }
}","private static String getMessage(Throwable t){
  if (t.getMessage() == null) {
    return t.getClass().getSimpleName();
  }
 else {
    return t.getClass().getSimpleName() + ""String_Node_Str"" + t.getMessage();
  }
}","The original code incorrectly checks for an empty message using `.isEmpty()`, which can throw a `NullPointerException` if the message is null. The fixed code replaces this check with `== null`, ensuring safe handling of null message scenarios. This modification prevents potential runtime errors and provides a more robust error message extraction method for throwable objects."
38078,"@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
switch (qName) {
case ""String_Node_Str"":
    file=new File(attributes.getValue(""String_Node_Str""));
  break;
case ""String_Node_Str"":
failures.add(new Failure.Builder().source(attributes.getValue(""String_Node_Str"")).severity(attributes.getValue(""String_Node_Str"").toUpperCase()).file(file).line(Integer.parseInt(attributes.getValue(""String_Node_Str""))).message(attributes.getValue(""String_Node_Str"")).build());
default :
break;
}
}","@Override public void startElement(String uri,String localName,String qName,Attributes attributes){
switch (qName) {
case ""String_Node_Str"":
    file=new File(attributes.getValue(""String_Node_Str""));
  break;
case ""String_Node_Str"":
failures.add(new Failure.Builder().source(attributes.getValue(""String_Node_Str"")).severity(attributes.getValue(""String_Node_Str"").toUpperCase()).file(file).line(Integer.parseInt(attributes.getValue(""String_Node_Str""))).message(attributes.getValue(""String_Node_Str"")).build());
default :
break;
}
}","The original code throws a SAXException, which is unnecessary and can interrupt XML parsing unnecessarily. The fixed code removes the exception declaration, allowing more robust error handling and preventing premature method termination. This modification enables smoother XML processing and provides more flexibility in handling potential parsing variations."
38079,"private boolean isUntracked(Task task){
  return !(task instanceof Test) && !isStyleTask(task);
}","private static boolean isUntracked(Task task){
  return !(task instanceof Test) && !isStyleTask(task);
}","The original code lacked the 'static' keyword, which could lead to potential instance-specific method behavior and reduced method efficiency. The fixed version adds the 'static' modifier, enabling the method to be called without instantiating the class and ensuring consistent behavior across all instances. This modification improves code performance, reduces memory overhead, and provides a more predictable method implementation for checking task tracking status."
38080,"private void configureCheckstyleTask(final Project project,final Checkstyle checkstyleTask,final String circleReportsDir,final StyleTaskTimer timer){
  checkstyleTask.doFirst(new Action<Task>(){
    @Override public void execute(    Task task){
      checkstyleTask.getReports().findByName(""String_Node_Str"").setEnabled(true);
    }
  }
);
  CircleStyleFinalizer finalizer=createTask(project.getTasks(),checkstyleTask.getName() + ""String_Node_Str"",CircleStyleFinalizer.class);
  if (finalizer == null) {
    return;
  }
  finalizer.setReportParser(CheckstyleReportHandler.PARSER);
  finalizer.setStyleTask(checkstyleTask);
  finalizer.setReporting(checkstyleTask);
  finalizer.setStyleTaskTimer(timer);
  finalizer.setTargetFile(new File(new File(circleReportsDir,""String_Node_Str""),project.getName() + ""String_Node_Str"" + checkstyleTask.getName()+ ""String_Node_Str""));
  checkstyleTask.finalizedBy(finalizer);
}","private static void configureCheckstyleTask(final Project project,final Checkstyle checkstyleTask,final String circleReportsDir,final StyleTaskTimer timer){
  checkstyleTask.doFirst(new Action<Task>(){
    @Override public void execute(    Task task){
      checkstyleTask.getReports().findByName(""String_Node_Str"").setEnabled(true);
    }
  }
);
  CircleStyleFinalizer finalizer=createTask(project.getTasks(),checkstyleTask.getName() + ""String_Node_Str"",CircleStyleFinalizer.class);
  if (finalizer == null) {
    return;
  }
  finalizer.setReportParser(CheckstyleReportHandler.PARSER);
  finalizer.setStyleTask(checkstyleTask);
  finalizer.setReporting(checkstyleTask);
  finalizer.setStyleTaskTimer(timer);
  finalizer.setTargetFile(new File(new File(circleReportsDir,""String_Node_Str""),project.getName() + ""String_Node_Str"" + checkstyleTask.getName()+ ""String_Node_Str""));
  checkstyleTask.finalizedBy(finalizer);
}","The original code lacked the `static` modifier for the method, potentially causing scope and inheritance issues in class-level method definitions. The fixed code adds the `static` modifier, ensuring the method can be called without instantiating the class and improving method accessibility. This change enhances code modularity and prevents potential runtime errors related to method invocation."
38081,"private void configureBuildFailureFinalizer(Project rootProject,String circleReportsDir){
  int attemptNumber=1;
  File targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"");
  while (targetFile.exists()) {
    targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"" + (++attemptNumber) + ""String_Node_Str"");
  }
  Integer container;
  try {
    container=Integer.parseInt(System.getenv(""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    container=null;
  }
  CircleBuildFailureListener listener=new CircleBuildFailureListener();
  CircleBuildFinishedAction action=new CircleBuildFinishedAction(container,targetFile,listener);
  rootProject.getGradle().addListener(listener);
  rootProject.getGradle().buildFinished(action);
}","private static void configureBuildFailureFinalizer(Project rootProject,String circleReportsDir){
  int attemptNumber=1;
  File targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"");
  while (targetFile.exists()) {
    targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"" + (++attemptNumber) + ""String_Node_Str"");
  }
  Integer container;
  try {
    container=Integer.parseInt(System.getenv(""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    container=null;
  }
  CircleBuildFailureListener listener=new CircleBuildFailureListener();
  CircleBuildFinishedAction action=new CircleBuildFinishedAction(container,targetFile,listener);
  rootProject.getGradle().addListener(listener);
  rootProject.getGradle().buildFinished(action);
}","The original code lacked the `static` modifier for the method, which could prevent proper method referencing and potentially cause compilation issues. The fixed code adds the `static` keyword to the method signature, ensuring it can be called without instantiating the class and improving method accessibility. This modification allows for more flexible and reliable method invocation in the build configuration process."
38082,"private void configureFindbugsTask(final Project project,final FindBugs findbugsTask,final String circleReportsDir,final StyleTaskTimer timer){
  findbugsTask.doFirst(new Action<Task>(){
    @Override public void execute(    Task task){
      for (      SingleFileReport report : findbugsTask.getReports()) {
        report.setEnabled(false);
      }
      FindBugsXmlReport xmlReport=(FindBugsXmlReport)findbugsTask.getReports().findByName(""String_Node_Str"");
      xmlReport.setEnabled(true);
      xmlReport.setWithMessages(true);
    }
  }
);
  CircleStyleFinalizer finalizer=createTask(project.getTasks(),findbugsTask.getName() + ""String_Node_Str"",CircleStyleFinalizer.class);
  if (finalizer == null) {
    return;
  }
  finalizer.setReportParser(FindBugsReportHandler.PARSER);
  finalizer.setStyleTask(findbugsTask);
  finalizer.setReporting(findbugsTask);
  finalizer.setStyleTaskTimer(timer);
  finalizer.setTargetFile(new File(new File(circleReportsDir,""String_Node_Str""),project.getName() + ""String_Node_Str"" + findbugsTask.getName()+ ""String_Node_Str""));
  findbugsTask.finalizedBy(finalizer);
}","private static void configureFindbugsTask(final Project project,final FindBugs findbugsTask,final String circleReportsDir,final StyleTaskTimer timer){
  findbugsTask.doFirst(new Action<Task>(){
    @Override public void execute(    Task task){
      for (      SingleFileReport report : findbugsTask.getReports()) {
        report.setEnabled(false);
      }
      FindBugsXmlReport xmlReport=(FindBugsXmlReport)findbugsTask.getReports().findByName(""String_Node_Str"");
      xmlReport.setEnabled(true);
      xmlReport.setWithMessages(true);
    }
  }
);
  CircleStyleFinalizer finalizer=createTask(project.getTasks(),findbugsTask.getName() + ""String_Node_Str"",CircleStyleFinalizer.class);
  if (finalizer == null) {
    return;
  }
  finalizer.setReportParser(FindBugsReportHandler.PARSER);
  finalizer.setStyleTask(findbugsTask);
  finalizer.setReporting(findbugsTask);
  finalizer.setStyleTaskTimer(timer);
  finalizer.setTargetFile(new File(new File(circleReportsDir,""String_Node_Str""),project.getName() + ""String_Node_Str"" + findbugsTask.getName()+ ""String_Node_Str""));
  findbugsTask.finalizedBy(finalizer);
}","The original code lacked the `static` modifier for the method, which could potentially cause scope and inheritance issues in certain class structures. The fixed code adds the `static` modifier to the method signature, ensuring it can be called without instantiating the class and providing clearer method semantics. This modification improves method accessibility and prevents potential runtime complications related to method invocation."
38083,"@Override public void characters(char[] ch,int start,int length) throws SAXException {
  if (content != null) {
    content.append(ch,start,length);
  }
}","@Override public void characters(char[] ch,int start,int length){
  if (content != null) {
    content.append(ch,start,length);
  }
}","The original code incorrectly throws a SAXException when processing character data, which can disrupt XML parsing and error handling. The fixed code removes the unnecessary exception declaration, allowing smoother character processing without forcing exception handling at every method call. This modification simplifies the method signature and provides more flexible character data handling during XML parsing."
38084,"@Override public void endElement(String uri,String localName,String qName) throws SAXException {
switch (qName) {
case ""String_Node_Str"":
    sources.add(content.toString());
  content=null;
break;
case ""String_Node_Str"":
failure.message(content.toString());
content=null;
break;
case ""String_Node_Str"":
failures.add(failure.build());
failure=null;
break;
default :
break;
}
depth--;
}","@Override public void endElement(String uri,String localName,String qName){
switch (qName) {
case ""String_Node_Str"":
    sources.add(content.toString());
  content=null;
break;
case ""String_Node_Str"":
failure.message(content.toString());
content=null;
break;
case ""String_Node_Str"":
failures.add(failure.build());
failure=null;
break;
default :
break;
}
depth--;
}","The original code contains duplicate case statements for ""String_Node_Str"", which would cause compilation errors and unpredictable behavior. The fixed code removes the redundant SAXException throws clause, simplifying the method signature and preventing unnecessary exception handling. By eliminating the duplicate cases, the code now correctly processes XML parsing logic without syntax errors, improving code reliability and maintainability."
38085,"@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  depth++;
switch (qName) {
case ""String_Node_Str"":
    content=new StringBuilder();
  break;
case ""String_Node_Str"":
depth=0;
failure=new Failure.Builder().source(attributes.getValue(""String_Node_Str"")).severity(""String_Node_Str"");
break;
case ""String_Node_Str"":
content=new StringBuilder();
break;
case ""String_Node_Str"":
if (depth == 1) {
String sourcepath=attributes.getValue(""String_Node_Str"");
File sourceFile=new File(sourcepath);
for (String source : sources) {
if (source.endsWith(sourcepath)) {
sourceFile=new File(source);
}
}
failure.file(sourceFile).line(Integer.parseInt(attributes.getValue(""String_Node_Str"")));
}
break;
default :
break;
}
}","@Override public void startElement(String uri,String localName,String qName,Attributes attributes){
  depth++;
switch (qName) {
case ""String_Node_Str"":
    content=new StringBuilder();
  break;
case ""String_Node_Str"":
depth=0;
failure=new Failure.Builder().source(attributes.getValue(""String_Node_Str"")).severity(""String_Node_Str"");
break;
case ""String_Node_Str"":
content=new StringBuilder();
break;
case ""String_Node_Str"":
if (depth == 1) {
String sourcepath=attributes.getValue(""String_Node_Str"");
File sourceFile=new File(sourcepath);
for (String source : sources) {
if (source.endsWith(sourcepath)) {
sourceFile=new File(source);
}
}
failure.file(sourceFile).line(Integer.parseInt(attributes.getValue(""String_Node_Str"")));
}
break;
default :
break;
}
}","The original code contains multiple identical case statements with ""String_Node_Str"", causing potential logic conflicts and unpredictable behavior during XML parsing. The fixed code removes the SAXException throws clause, suggesting improved error handling and potentially more robust exception management. By maintaining the original logic structure while cleaning up the exception handling, the code becomes more reliable and less prone to unexpected parsing interruptions."
38086,"private Task task(String projectName,String taskName){
  Task task=Mockito.mock(Task.class,Mockito.RETURNS_DEEP_STUBS);
  when(task.getProject().getName()).thenReturn(projectName);
  when(task.getName()).thenReturn(taskName);
  return task;
}","private static Task task(String projectName,String taskName){
  Task task=Mockito.mock(Task.class,Mockito.RETURNS_DEEP_STUBS);
  when(task.getProject().getName()).thenReturn(projectName);
  when(task.getName()).thenReturn(taskName);
  return task;
}","The original method lacks the `static` keyword, which can lead to potential instance-specific behavior and unnecessary object creation. By adding `static`, the method becomes a utility method that can be called without instantiating the class, improving memory efficiency and method invocation. The static modifier ensures the method behaves consistently across all calls, providing a more predictable mocking utility for creating Task objects."
38087,"@Test public void testTwoErrors() throws TransformerException {
  Report report=failuresReport(ROOT,""String_Node_Str"",""String_Node_Str"",FAILED_CHECKSTYLE_TIME_NANOS,CHECKSTYLE_FAILURES);
  assertThat(report).isEqualTo(REPORT);
}","@Test public void testTwoErrors(){
  Report report=failuresReport(ROOT,""String_Node_Str"",""String_Node_Str"",FAILED_CHECKSTYLE_TIME_NANOS,CHECKSTYLE_FAILURES);
  assertThat(report).isEqualTo(REPORT);
}","The original code incorrectly declared a `throws TransformerException` clause, which was unnecessary for the test method and potentially masked underlying implementation issues. The fixed code removes this exception declaration, simplifying the method signature and ensuring cleaner, more direct error handling. By eliminating the superfluous exception clause, the code becomes more straightforward and focuses on the core testing logic without introducing unnecessary complexity."
38088,"@Test public void testNoErrors() throws TransformerException {
  Report report=failuresReport(ROOT,""String_Node_Str"",""String_Node_Str"",FAILED_CHECKSTYLE_TIME_NANOS,ImmutableList.<Failure>of());
  assertThat(report).isEqualTo(new Report.Builder().name(""String_Node_Str"").subname(""String_Node_Str"").elapsedTimeNanos(FAILED_CHECKSTYLE_TIME_NANOS).build());
}","@Test public void testNoErrors(){
  Report report=failuresReport(ROOT,""String_Node_Str"",""String_Node_Str"",FAILED_CHECKSTYLE_TIME_NANOS,ImmutableList.<Failure>of());
  assertThat(report).isEqualTo(new Report.Builder().name(""String_Node_Str"").subname(""String_Node_Str"").elapsedTimeNanos(FAILED_CHECKSTYLE_TIME_NANOS).build());
}","The original code declared a `throws TransformerException`, which was unnecessary and potentially misleading since no transformer-related operations were performed in the method. The fixed code removes this unnecessary exception declaration, simplifying the method signature and eliminating potential confusion about exception handling. By removing the superfluous `throws` clause, the code becomes cleaner, more focused, and accurately represents the method's actual behavior."
38089,"private void configureBuildFailureFinalizer(Project rootProject,String circleReportsDir){
  int attemptNumber=1;
  File targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"");
  while (targetFile.exists()) {
    targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"" + attemptNumber + ""String_Node_Str"");
  }
  Integer container;
  try {
    container=Integer.parseInt(System.getenv(""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    container=null;
  }
  CircleBuildFailureListener listener=new CircleBuildFailureListener();
  CircleBuildFinishedAction action=new CircleBuildFinishedAction(container,targetFile,listener);
  rootProject.getGradle().addListener(listener);
  rootProject.getGradle().buildFinished(action);
}","private void configureBuildFailureFinalizer(Project rootProject,String circleReportsDir){
  int attemptNumber=1;
  File targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"");
  while (targetFile.exists()) {
    targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"" + (++attemptNumber) + ""String_Node_Str"");
  }
  Integer container;
  try {
    container=Integer.parseInt(System.getenv(""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    container=null;
  }
  CircleBuildFailureListener listener=new CircleBuildFailureListener();
  CircleBuildFinishedAction action=new CircleBuildFinishedAction(container,targetFile,listener);
  rootProject.getGradle().addListener(listener);
  rootProject.getGradle().buildFinished(action);
}","The original code fails to increment the `attemptNumber` when creating unique file names, potentially causing infinite loops or file overwriting. In the fixed code, `++attemptNumber` is used to properly increment the counter before appending it to the filename, ensuring unique file names are generated sequentially. This change prevents potential file naming conflicts and ensures reliable file creation during build failure logging."
38090,"private void configureBuildFailureFinalizer(Project rootProject,String circleReportsDir){
  int attemptNumber=1;
  File targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"");
  while (targetFile.exists()) {
    targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"" + attemptNumber + ""String_Node_Str"");
  }
  Integer container;
  try {
    container=Integer.parseInt(System.getenv(""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    container=null;
  }
  CircleBuildFailureListener listener=new CircleBuildFailureListener();
  CircleBuildFinishedAction action=new CircleBuildFinishedAction(container,targetFile,listener);
  rootProject.getGradle().addListener(listener);
  rootProject.getGradle().buildFinished(action);
}","private void configureBuildFailureFinalizer(Project rootProject,String circleReportsDir){
  int attemptNumber=1;
  File targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"");
  while (targetFile.exists()) {
    targetFile=new File(new File(circleReportsDir,""String_Node_Str""),""String_Node_Str"" + (++attemptNumber) + ""String_Node_Str"");
  }
  Integer container;
  try {
    container=Integer.parseInt(System.getenv(""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    container=null;
  }
  CircleBuildFailureListener listener=new CircleBuildFailureListener();
  CircleBuildFinishedAction action=new CircleBuildFinishedAction(container,targetFile,listener);
  rootProject.getGradle().addListener(listener);
  rootProject.getGradle().buildFinished(action);
}","The original code fails to increment the `attemptNumber` variable when creating unique file names, potentially causing infinite loops or overwriting existing files. In the fixed code, `++attemptNumber` is used to correctly increment the counter before appending it to the file name, ensuring unique file generation. This change prevents potential file naming conflicts and guarantees that each new file has a distinct, incrementing suffix."
38091,"@Override public void getAllStudent(Context context,DatabaseQueryCallback<List<Student>> callback){
  DatabaseHelper databaseHelper=DatabaseHelper.getInstance(context);
  SQLiteDatabase sqLiteDatabase=databaseHelper.getReadableDatabase();
  String SELECT_QUERY=String.format(""String_Node_Str"",Config.COLUMN_STUDENT_NAME,Config.COLUMN_SUBJECT_OF_STUDENT_REGISTRATION,Config.COLUMN_STUDENT_EMAIL,Config.COLUMN_STUDENT_PHONE,Config.TABLE_STUDENT);
  Cursor cursor=null;
  try {
    cursor=sqLiteDatabase.rawQuery(SELECT_QUERY,null);
    if (cursor != null && cursor.moveToFirst()) {
      List<Student> studentList=new ArrayList<>();
      do {
        String name=cursor.getString(cursor.getColumnIndex(Config.COLUMN_STUDENT_NAME));
        long registrationNumber=cursor.getLong(cursor.getColumnIndex(Config.COLUMN_STUDENT_REGISTRATION));
        String email=cursor.getString(cursor.getColumnIndex(Config.COLUMN_STUDENT_EMAIL));
        String phone=cursor.getString(cursor.getColumnIndex(Config.COLUMN_STUDENT_PHONE));
        studentList.add(new Student(name,registrationNumber,phone,email));
      }
 while (cursor.moveToNext());
      callback.onQuerySuccess(studentList);
    }
 else     callback.onQueryFailed(new Exception(""String_Node_Str""));
  }
 catch (  Exception e) {
    Logger.d(""String_Node_Str"" + e.getMessage());
    callback.onQueryFailed(e);
    Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
 finally {
    if (cursor != null)     cursor.close();
    sqLiteDatabase.close();
  }
}","@Override public void getAllStudent(Context context,DatabaseQueryCallback<List<Student>> callback){
  DatabaseHelper databaseHelper=DatabaseHelper.getInstance(context);
  SQLiteDatabase sqLiteDatabase=databaseHelper.getReadableDatabase();
  String SELECT_QUERY=String.format(""String_Node_Str"",Config.COLUMN_STUDENT_NAME,Config.COLUMN_STUDENT_REGISTRATION,Config.COLUMN_STUDENT_EMAIL,Config.COLUMN_STUDENT_PHONE,Config.TABLE_STUDENT);
  Cursor cursor=null;
  try {
    cursor=sqLiteDatabase.rawQuery(SELECT_QUERY,null);
    if (cursor != null && cursor.moveToFirst()) {
      List<Student> studentList=new ArrayList<>();
      do {
        String name=cursor.getString(cursor.getColumnIndex(Config.COLUMN_STUDENT_NAME));
        long registrationNumber=cursor.getLong(cursor.getColumnIndex(Config.COLUMN_STUDENT_REGISTRATION));
        String email=cursor.getString(cursor.getColumnIndex(Config.COLUMN_STUDENT_EMAIL));
        String phone=cursor.getString(cursor.getColumnIndex(Config.COLUMN_STUDENT_PHONE));
        studentList.add(new Student(name,registrationNumber,phone,email));
      }
 while (cursor.moveToNext());
      callback.onQuerySuccess(studentList);
    }
 else     callback.onQueryFailed(new Exception(""String_Node_Str""));
  }
 catch (  Exception e) {
    Logger.d(""String_Node_Str"" + e.getMessage());
    callback.onQueryFailed(e);
    Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
 finally {
    if (cursor != null)     cursor.close();
    sqLiteDatabase.close();
  }
}","The original code had an incorrect SQL query format, missing the column for student registration number, which would cause retrieval errors. The fixed code corrects the SQL query by adding `Config.COLUMN_STUDENT_REGISTRATION` to the `String.format()` method, ensuring all necessary columns are included in the database query. This modification allows for complete and accurate student data retrieval, preventing potential data inconsistencies and improving the overall reliability of the database operation."
38092,"/** 
 * Returns payload of a JWT as a JSON object.
 * @param jwt REQUIRED: valid JSON Web Token as String.
 * @return payload as a JSONObject.
 */
static JSONObject getPayload(String jwt){
  try {
    validateJWT(jwt);
    final String payload=jwt.split(""String_Node_Str"")[PAYLOAD];
    final byte[] sectionDecoded=Base64.decode(payload);
    final String jwtSection=new String(sectionDecoded,""String_Node_Str"");
    return new JSONObject(jwtSection);
  }
 catch (  final UnsupportedEncodingException e) {
    throw new InvalidParameterException(e.getMessage());
  }
catch (  final Exception e) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
}","/** 
 * Returns payload of a JWT as a JSON object.
 * @param jwt REQUIRED: valid JSON Web Token as String.
 * @return payload as a JSONObject.
 */
static JSONObject getPayload(String jwt){
  try {
    validateJWT(jwt);
    Base64.Decoder dec=Base64.getDecoder();
    final String payload=jwt.split(""String_Node_Str"")[PAYLOAD];
    final byte[] sectionDecoded=dec.decode(payload);
    final String jwtSection=new String(sectionDecoded,""String_Node_Str"");
    return new JSONObject(jwtSection);
  }
 catch (  final UnsupportedEncodingException e) {
    throw new InvalidParameterException(e.getMessage());
  }
catch (  final Exception e) {
    System.out.println(e);
    throw new InvalidParameterException(""String_Node_Str"");
  }
}","The buggy code uses an undefined Base64 decoding method and lacks proper error handling, potentially causing runtime exceptions. The fixed code introduces Base64.getDecoder() for standard Base64 decoding and adds a System.out.println(e) to log unexpected exceptions before rethrowing, improving error visibility and reliability. These modifications enhance the JWT payload extraction method's robustness and provide better diagnostic capabilities during potential decoding failures."
38093,"/** 
 * Returns signature of a JWT as a String.
 * @param jwt REQUIRED: valid JSON Web Token as String.
 * @return signature as a String.
 */
public static String getSignature(String jwt){
  try {
    validateJWT(jwt);
    final byte[] sectionDecoded=Base64.decode(jwt.split(""String_Node_Str"")[SIGNATURE]);
    return new String(sectionDecoded,""String_Node_Str"");
  }
 catch (  final Exception e) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
}","/** 
 * Returns signature of a JWT as a String.
 * @param jwt REQUIRED: valid JSON Web Token as String.
 * @return signature as a String.
 */
public static String getSignature(String jwt){
  try {
    validateJWT(jwt);
    Base64.Decoder dec=Base64.getDecoder();
    final byte[] sectionDecoded=dec.decode(jwt.split(""String_Node_Str"")[SIGNATURE]);
    return new String(sectionDecoded,""String_Node_Str"");
  }
 catch (  final Exception e) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
}","The original code used an incorrect Base64 decoding method, likely causing runtime errors or incorrect signature extraction. The fixed code uses Base64.getDecoder() to properly decode the JWT signature section, ensuring correct Base64 URL-safe decoding. This change provides a more robust and standard approach to extracting the signature, improving the method's reliability and adherence to JWT decoding best practices."
38094,"/** 
 * Returns header for a JWT as a JSON object.
 * @param jwt REQUIRED: valid JSON Web Token as String.
 * @return header as a JSONObject.
 */
static JSONObject getHeader(String jwt){
  try {
    validateJWT(jwt);
    final byte[] sectionDecoded=Base64.decode(jwt.split(""String_Node_Str"")[HEADER]);
    final String jwtSection=new String(sectionDecoded,""String_Node_Str"");
    return new JSONObject(jwtSection);
  }
 catch (  final UnsupportedEncodingException e) {
    throw new InvalidParameterException(e.getMessage());
  }
catch (  final Exception e) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
}","/** 
 * Returns header for a JWT as a JSON object.
 * @param jwt REQUIRED: valid JSON Web Token as String.
 * @return header as a JSONObject.
 */
static JSONObject getHeader(String jwt){
  try {
    validateJWT(jwt);
    Base64.Decoder dec=Base64.getDecoder();
    final byte[] sectionDecoded=dec.decode(jwt.split(""String_Node_Str"")[HEADER]);
    final String jwtSection=new String(sectionDecoded,""String_Node_Str"");
    return new JSONObject(jwtSection);
  }
 catch (  final UnsupportedEncodingException e) {
    throw new InvalidParameterException(e.getMessage());
  }
catch (  final Exception e) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
}","The original code uses an incorrect Base64 decoding method, likely relying on a deprecated or non-standard approach. The fixed code replaces the problematic decoding with Base64.getDecoder(), which provides a standard and reliable Base64 decoding mechanism in Java. This change ensures proper JWT header decoding, enhancing the method's reliability and compatibility with current Java encoding standards."
38095,"/** 
 * Returns payload of a JWT as a JSON object.
 * @param jwt REQUIRED: valid JSON Web Token as String.
 * @return payload as a JSONObject.
 */
static JSONObject getPayload(String jwt){
  try {
    validateJWT(jwt);
    Base64.Decoder dec=Base64.getDecoder();
    final String payload=jwt.split(""String_Node_Str"")[PAYLOAD];
    final byte[] sectionDecoded=dec.decode(payload);
    final String jwtSection=new String(sectionDecoded,""String_Node_Str"");
    return new JSONObject(jwtSection);
  }
 catch (  final UnsupportedEncodingException e) {
    throw new InvalidParameterException(e.getMessage());
  }
catch (  final Exception e) {
    System.out.println(e);
    throw new InvalidParameterException(""String_Node_Str"");
  }
}","/** 
 * Returns payload of a JWT as a JSON object.
 * @param jwt REQUIRED: valid JSON Web Token as String.
 * @return payload as a JSONObject.
 */
static JSONObject getPayload(String jwt){
  try {
    validateJWT(jwt);
    Base64.Decoder dec=Base64.getDecoder();
    final String payload=jwt.split(""String_Node_Str"")[PAYLOAD];
    final byte[] sectionDecoded=dec.decode(payload);
    final String jwtSection=new String(sectionDecoded,""String_Node_Str"");
    return new JSONObject(jwtSection);
  }
 catch (  final UnsupportedEncodingException e) {
    throw new InvalidParameterException(e.getMessage());
  }
catch (  final Exception e) {
    throw new InvalidParameterException(""String_Node_Str"");
  }
}","The original code printed the exception instead of properly handling it, potentially masking critical error information and preventing proper error propagation. The fixed code removes the unnecessary `System.out.println(e)` and directly throws an `InvalidParameterException` with the error message, ensuring consistent error handling. This change improves code reliability by maintaining a clean error reporting mechanism and preventing potential information leakage or silent failures."
38096,"public void disconnect(){
  bleHandler.sendEmptyMessage(MSG_DISCONNECT);
}","public void disconnect(){
  bleHandler.obtainMessage(MSG_DISCONNECT,bluetoothDevice).sendToTarget();
}","The original code uses `sendEmptyMessage()`, which lacks context and may not properly communicate device-specific disconnection details. The fixed code uses `obtainMessage()` with the device parameter, allowing precise transmission of the Bluetooth device being disconnected. This approach ensures more robust and targeted message handling, improving the reliability of the Bluetooth disconnection process."
38097,"@Override public Indent getIndent(){
  if (formattingInfo.getCsvCodeStyleSettings().TABULARIZE && formattingInfo.getCsvCodeStyleSettings().LEADING_WHITE_SPACES && getNode().getElementType() == CsvTypes.RECORD) {
    CsvColumnInfo columnInfo=formattingInfo.getColumnInfo(0);
    Block fieldBlock=getSubBlocks().get(0);
    return Indent.getSpaceIndent(columnInfo.getMaxLength() - fieldBlock.getTextRange().getLength());
  }
  return null;
}","@Override public Indent getIndent(){
  if (formattingInfo.getCsvCodeStyleSettings().TABULARIZE && formattingInfo.getCsvCodeStyleSettings().LEADING_WHITE_SPACES && getNode().getElementType() == CsvTypes.RECORD && (formattingInfo.getCsvCodeStyleSettings().WHITE_SPACES_OUTSIDE_QUOTES || !CsvFormatHelper.isFirstFieldOfRecordQuoted(this))) {
    CsvColumnInfo columnInfo=formattingInfo.getColumnInfo(0);
    Block fieldBlock=getSubBlocks().get(0);
    return Indent.getSpaceIndent(columnInfo.getMaxLength() - fieldBlock.getTextRange().getLength());
  }
  return null;
}","The original code lacked a crucial condition for handling indentation in CSV formatting, potentially causing incorrect whitespace handling for quoted fields. The fixed code adds an additional check using `formattingInfo.getCsvCodeStyleSettings().WHITE_SPACES_OUTSIDE_QUOTES` and `CsvFormatHelper.isFirstFieldOfRecordQuoted()` to ensure proper indentation logic for different quote scenarios. This enhancement provides more robust and flexible formatting for CSV records, preventing unintended whitespace modifications for quoted fields."
38098,"private Spacing getSpacingForRecords(@Nullable CsvBlock child1,@Nullable CsvBlock child2){
  Spacing spacing;
  Block fieldBlock=null;
  CsvColumnInfo columnInfo=null;
  if (child2 != null && child2.getNode().getElementType() == CsvTypes.RECORD) {
    columnInfo=formattingInfo.getColumnInfo(0);
    fieldBlock=child2.getSubBlocks().get(0);
  }
  int spaces=0;
  if (columnInfo != null) {
    spaces+=columnInfo.getMaxLength() - fieldBlock.getTextRange().getLength();
  }
  spacing=Spacing.createSpacing(spaces,spaces,0,true,formattingInfo.getCodeStyleSettings().KEEP_BLANK_LINES_IN_CODE);
  return spacing;
}","private Spacing getSpacingForRecords(@Nullable CsvBlock child1,@Nullable CsvBlock child2){
  Spacing spacing;
  Block fieldBlock=null;
  CsvColumnInfo columnInfo=null;
  List<Block> subBlocks=child2.getSubBlocks();
  if (child2 != null && child2.getNode().getElementType() == CsvTypes.RECORD) {
    columnInfo=formattingInfo.getColumnInfo(0);
    fieldBlock=subBlocks.get(0);
  }
  int spaces=0;
  if (columnInfo != null && subBlocks.size() > 1) {
    spaces+=columnInfo.getMaxLength() - fieldBlock.getTextRange().getLength();
  }
  spacing=Spacing.createSpacing(spaces,spaces,0,true,formattingInfo.getCodeStyleSettings().KEEP_BLANK_LINES_IN_CODE);
  return spacing;
}","The original code could throw a NullPointerException if `child2` has no sub-blocks or fewer than expected blocks. The fixed code adds a check for `subBlocks.size() > 1` and retrieves the sub-blocks list before accessing its elements, preventing potential runtime errors. This modification ensures safer access to block elements and provides more robust handling of CSV record formatting."
38099,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>Workbook write(List<T> list) throws Exception {
  if (ListUtils.isEmpty(list)) {
  }
  Workbook wb=new SXSSFWorkbook();
  Sheet sheet=wb.createSheet();
  Row row=sheet.createRow(0);
  Cell cell=null;
  Class clazz=list.get(0).getClass();
  List<Field> fields=ReflectUtils.getFields(clazz,true);
  Excel excel=null;
  int columnIndex=0;
  CellStyle cs=null;
  Font font=null;
  Map<String,Class<? extends ExcelFormatter>> formatter=new TreeMap<String,Class<? extends ExcelFormatter>>();
  for (  Field field : fields) {
    excel=field.getAnnotation(Excel.class);
    if (excel == null || excel.skip() == true) {
      continue;
    }
    formatter.put(""String_Node_Str"" + StringUtils.firstCharToUpperCase(field.getName()),excel.formatter());
    cell=row.createCell(columnIndex);
    cs=wb.createCellStyle();
    cs.setBorderBottom(HSSFCellStyle.BORDER_THIN);
    cs.setBorderLeft(HSSFCellStyle.BORDER_THIN);
    cs.setBorderTop(HSSFCellStyle.BORDER_THIN);
    cs.setBorderRight(HSSFCellStyle.BORDER_THIN);
    cs.setFillPattern(CellStyle.SOLID_FOREGROUND);
    cs.setFillForegroundColor(excel.bgColor().getIndex());
    font=wb.createFont();
    font.setColor(excel.fontColor().getIndex());
    font.setBoldweight(excel.boldFont() ? Font.BOLDWEIGHT_BOLD : Font.BOLDWEIGHT_NORMAL);
    cs.setFont(font);
    cell.setCellStyle(cs);
    cell.setCellValue(excel.value());
    columnIndex++;
  }
  int rowIndex=1;
  Object value=null;
  for (  T t : list) {
    row=sheet.createRow(rowIndex);
    columnIndex=0;
    for (    String method : formatter.keySet()) {
      cell=row.createCell(columnIndex);
      cs=wb.createCellStyle();
      cs.setWrapText(true);
      cs.setVerticalAlignment(XSSFCellStyle.VERTICAL_CENTER);
      cs.setBorderBottom(HSSFCellStyle.BORDER_THIN);
      cs.setBorderLeft(HSSFCellStyle.BORDER_THIN);
      cs.setBorderTop(HSSFCellStyle.BORDER_THIN);
      cs.setBorderRight(HSSFCellStyle.BORDER_THIN);
      cell.setCellStyle(cs);
      value=clazz.getMethod(method,null).invoke(t,null);
      cell.setCellValue(formatter.get(method).newInstance().format(value));
      columnIndex++;
    }
    rowIndex++;
  }
  columnIndex=0;
  for (  Field field : fields) {
    excel=field.getAnnotation(Excel.class);
    if (excel == null || excel.skip() == true) {
      continue;
    }
    if (excel.width() == -1) {
      sheet.autoSizeColumn(columnIndex,true);
    }
 else {
      sheet.setColumnWidth(columnIndex,excel.width() * 256);
    }
    columnIndex++;
  }
  return wb;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>Workbook write(List<T> list) throws Exception {
  if (ListUtils.isEmpty(list)) {
  }
  Workbook wb=new SXSSFWorkbook();
  Sheet sheet=wb.createSheet();
  Row row=sheet.createRow(0);
  Cell cell=null;
  Class clazz=list.get(0).getClass();
  List<Field> fields=ReflectUtils.getFields(clazz,true);
  Excel excel=null;
  int columnIndex=0;
  CellStyle cs=null;
  Font font=null;
  Map<String,Class<? extends ExcelFormatter>> formatter=new TreeMap<String,Class<? extends ExcelFormatter>>();
  System.out.println(fields);
  for (  Field field : fields) {
    excel=field.getAnnotation(Excel.class);
    if (excel == null || excel.skip() == true) {
      continue;
    }
    formatter.put(""String_Node_Str"" + StringUtils.firstCharToUpperCase(field.getName()),excel.formatter());
    cell=row.createCell(columnIndex);
    cs=wb.createCellStyle();
    cs.setBorderBottom(HSSFCellStyle.BORDER_THIN);
    cs.setBorderLeft(HSSFCellStyle.BORDER_THIN);
    cs.setBorderTop(HSSFCellStyle.BORDER_THIN);
    cs.setBorderRight(HSSFCellStyle.BORDER_THIN);
    cs.setFillPattern(CellStyle.SOLID_FOREGROUND);
    cs.setFillForegroundColor(excel.bgColor().getIndex());
    font=wb.createFont();
    font.setColor(excel.fontColor().getIndex());
    font.setBoldweight(excel.boldFont() ? Font.BOLDWEIGHT_BOLD : Font.BOLDWEIGHT_NORMAL);
    cs.setFont(font);
    cell.setCellStyle(cs);
    cell.setCellValue(excel.value());
    columnIndex++;
  }
  System.out.println(formatter);
  int rowIndex=1;
  Object value=null;
  String method=""String_Node_Str"";
  for (  T t : list) {
    row=sheet.createRow(rowIndex);
    columnIndex=0;
    for (    Field field : fields) {
      cell=row.createCell(columnIndex);
      cs=wb.createCellStyle();
      cs.setWrapText(true);
      cs.setVerticalAlignment(XSSFCellStyle.VERTICAL_CENTER);
      cs.setBorderBottom(HSSFCellStyle.BORDER_THIN);
      cs.setBorderLeft(HSSFCellStyle.BORDER_THIN);
      cs.setBorderTop(HSSFCellStyle.BORDER_THIN);
      cs.setBorderRight(HSSFCellStyle.BORDER_THIN);
      cell.setCellStyle(cs);
      method=""String_Node_Str"" + StringUtils.firstCharToUpperCase(field.getName());
      value=clazz.getMethod(method,null).invoke(t,null);
      cell.setCellValue(formatter.get(method).newInstance().format(value));
      columnIndex++;
    }
    rowIndex++;
  }
  columnIndex=0;
  for (  Field field : fields) {
    excel=field.getAnnotation(Excel.class);
    if (excel == null || excel.skip() == true) {
      continue;
    }
    if (excel.width() == -1) {
      sheet.autoSizeColumn(columnIndex,true);
    }
 else {
      sheet.setColumnWidth(columnIndex,excel.width() * 256);
    }
    columnIndex++;
  }
  return wb;
}","The original code incorrectly iterated through a formatter map instead of fields, causing potential method invocation errors and incomplete data processing. The fixed code replaces the formatter map iteration with direct field iteration, dynamically generating the method name and invoking it correctly for each field. This approach ensures comprehensive data extraction, proper method reflection, and more robust Excel export by directly accessing object fields and their corresponding getter methods."
38100,"private void showDialogAfterDelay(FragmentManager fm,String tag){
  startedShowing=true;
  super.show(fm,tag);
}","private void showDialogAfterDelay(FragmentManager fm,String tag){
  startedShowing=true;
  FragmentTransaction ft=fm.beginTransaction();
  ft.add(this,tag);
  ft.commitAllowingStateLoss();
}","The original `show()` method directly calls the superclass implementation, which may cause synchronization and state management issues in fragment transactions. The fixed code uses `FragmentTransaction` to explicitly add the dialog fragment, allowing more controlled and safer fragment management with `commitAllowingStateLoss()`. This approach provides better handling of fragment state changes and prevents potential crashes during complex UI interactions."
38101,"private void init(Context context,AttributeSet attrs){
  this.mContext=context;
  mAttributeSet=attrs;
  getAttrs();
  setWillNotDraw(false);
  mBottomAnimation.setDuration(300);
  mBottomAnimation.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
      TextView textView=(TextView)getChildAt(selectLastIndex + itemCount);
      textView.setTextColor(textColor);
      TextView selectTextView=(TextView)getChildAt(selectIndex + itemCount);
      selectTextView.setTextColor(selectTextColor);
    }
    @Override public void onAnimationEnd(    Animation animation){
      clearAnimation();
      itemMoveLastLeft=itemMoveLeft;
      itemMoveLastRight=itemMoveRight;
      selectLastIndex=selectIndex;
      Log.d(""String_Node_Str"",""String_Node_Str"" + itemMoveLastRight);
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
}","private void init(Context context,AttributeSet attrs){
  this.mContext=context;
  mAttributeSet=attrs;
  getAttrs();
  setWillNotDraw(false);
  mBottomAnimation.setDuration(300);
  mBottomAnimation.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      clearAnimation();
      itemMoveLastLeft=itemMoveLeft;
      itemMoveLastRight=itemMoveRight;
      selectLastIndex=selectIndex;
      Log.d(""String_Node_Str"",""String_Node_Str"" + itemMoveLastRight);
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
}","The original code attempted to modify TextView colors during animation start, which could lead to potential null pointer exceptions or index out of bounds errors due to unchecked child view access. In the fixed code, the problematic TextView color modification logic was removed from the onAnimationStart method, ensuring safer and more predictable animation behavior. This change prevents potential runtime crashes and simplifies the animation listener implementation by focusing only on necessary end-of-animation operations."
38102,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  Log.d(""String_Node_Str"",""String_Node_Str"" + count++);
  for (int i=0; i < itemCount; i++) {
    itemCenterX[i]=(int)(itemWidth * (i + 0.5));
    View childImageView=getChildAt(i);
    childImageView.layout(itemWidth * i,0,itemWidth * (i + 1),100);
    View childTextView=getChildAt(itemCount + i);
    childTextView.layout(itemWidth * i + childTextView.getWidth() / 4,100,itemWidth * (i + 1),barHeight);
  }
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  for (int i=0; i < itemCount; i++) {
    itemCenterX[i]=(int)(itemWidth * (i + 0.5));
    View childImageView=getChildAt(i);
    childImageView.layout(itemWidth * i,0,itemWidth * (i + 1),100);
    View childTextView=getChildAt(itemCount + i);
    childTextView.layout(itemWidth * i + childTextView.getWidth() / 4,100,itemWidth * (i + 1),barHeight);
  }
}","The original code unnecessarily logs a debug message with an incrementing count, which can clutter logs and potentially impact performance without adding value. The fixed code removes the unnecessary Log.d() statement, keeping the onLayout method focused on its core layout functionality. By eliminating the debug logging, the code becomes cleaner, more efficient, and maintains its primary responsibility of positioning child views correctly."
38103,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  Log.d(""String_Node_Str"",""String_Node_Str"" + count++);
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  childCount=getChildCount();
  barWidth=getSize(300,widthMeasureSpec);
  barHeight=getSize(300,heightMeasureSpec);
  itemWidth=barWidth / itemCount;
  for (int i=0; i < childCount; i++) {
    View childView=getChildAt(i);
    measureChild(childView,widthMeasureSpec,heightMeasureSpec);
    childView.getLayoutParams().width=itemWidth;
  }
  Log.d(""String_Node_Str"",""String_Node_Str"" + barWidth);
  setSelectIndex(0);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  childCount=getChildCount();
  barWidth=getSize(300,widthMeasureSpec);
  barHeight=getSize(300,heightMeasureSpec);
  itemWidth=barWidth / itemCount;
  for (int i=0; i < childCount; i++) {
    View childView=getChildAt(i);
    measureChild(childView,widthMeasureSpec,heightMeasureSpec);
    childView.getLayoutParams().width=itemWidth;
  }
  setSelectIndex(0);
}","The original code unnecessarily logs a debug message before calling the parent's onMeasure method, which could impact performance and potentially interfere with the measurement process. The fixed code removes the redundant logging, ensuring a clean and efficient measurement cycle by directly calling super.onMeasure() and proceeding with child view measurement. By eliminating the unnecessary debug statement, the code becomes more streamlined, reduces potential overhead, and maintains the intended layout measurement logic."
38104,"@Override public boolean dispatchTouchEvent(MotionEvent ev){
  int action=ev.getAction();
switch (action) {
case MotionEvent.ACTION_DOWN:
    touchDownX=ev.getX();
  break;
case MotionEvent.ACTION_UP:
if (ev.getX() / itemWidth == touchDownX / itemWidth) {
  selectIndex=(int)(ev.getX() / itemWidth);
  sendListenerPostion(selectIndex);
  startAnimation(mBottomAnimation);
}
break;
}
return true;
}","@Override public boolean dispatchTouchEvent(MotionEvent ev){
  int action=ev.getAction();
switch (action) {
case MotionEvent.ACTION_DOWN:
    touchDownX=ev.getX();
  break;
case MotionEvent.ACTION_UP:
if (ev.getX() / itemWidth == touchDownX / itemWidth) {
  selectIndex=(int)(ev.getX() / itemWidth);
  changeTitleColor();
  sendListenerPosition(selectIndex);
  startAnimation(mBottomAnimation);
}
break;
}
return true;
}","The original code lacked a method call to `changeTitleColor()`, which likely updates the visual state of the selected item. The fixed code adds this method call before `sendListenerPosition()`, ensuring that the title color changes synchronously with item selection. This improvement enhances the user interface by providing immediate visual feedback when an item is selected, creating a more responsive and intuitive interaction."
38105,"private int getSize(int defaultsize,int measureSpec){
  int mySize=defaultsize;
  int mode=MeasureSpec.getMode(measureSpec);
  int size=MeasureSpec.getSize(measureSpec);
switch (mode) {
case MeasureSpec.UNSPECIFIED:
    mySize=defaultsize;
  break;
case MeasureSpec.AT_MOST:
mySize=size;
break;
case MeasureSpec.EXACTLY:
mySize=size;
break;
}
return mySize;
}","private int getSize(int defaultSize,int measureSpec){
  int mySize=defaultSize;
  int mode=MeasureSpec.getMode(measureSpec);
  int size=MeasureSpec.getSize(measureSpec);
switch (mode) {
case MeasureSpec.UNSPECIFIED:
    mySize=defaultSize;
  break;
case MeasureSpec.AT_MOST:
mySize=size;
break;
case MeasureSpec.EXACTLY:
mySize=size;
break;
}
return mySize;
}","The original code had inconsistent variable naming, using `defaultsize` instead of the more standard `defaultSize`, which could lead to readability and potential naming confusion. The fixed code corrects the variable name to `defaultSize`, following proper camelCase convention and improving code clarity. This small naming improvement enhances code readability and maintains consistent Java naming standards without changing the underlying logic."
38106,"public void build() throws Exception {
  itemCount=mBottomItemArrayList.size();
  if (itemCount > CHILDCOUNTMAX) {
    throw new Exception(""String_Node_Str"");
  }
  Log.d(""String_Node_Str"",""String_Node_Str"" + getWidth());
  Log.d(""String_Node_Str"",""String_Node_Str"" + count++);
  itemWidth=getLayoutParams().width / itemCount;
  for (  BottomItem bottomItem : mBottomItemArrayList) {
    ImageView imageView=new ImageView(mContext);
    imageView.setImageResource(bottomItem.drawableRes);
    addView(imageView,itemWidth,20);
  }
  for (  BottomItem bottomItem : mBottomItemArrayList) {
    TextView textView=new TextView(mContext);
    textView.setTextSize(textSize);
    textView.setText(bottomItem.title);
    textView.setTextColor(textColor);
    textView.setGravity(Gravity.CENTER);
    addView(textView,itemWidth,20);
  }
  Log.d(""String_Node_Str"",""String_Node_Str"" + itemWidth);
}","public void build() throws Exception {
  itemCount=mBottomItemArrayList.size();
  if (itemCount > CHILDCOUNTMAX) {
    throw new Exception(""String_Node_Str"");
  }
  itemWidth=getLayoutParams().width / itemCount;
  for (  BottomItem bottomItem : mBottomItemArrayList) {
    ImageView imageView=new ImageView(mContext);
    imageView.setImageResource(bottomItem.drawableRes);
    mImageViews.add(imageView);
    addView(imageView,itemWidth,20);
  }
  for (  BottomItem bottomItem : mBottomItemArrayList) {
    TextView textView=new TextView(mContext);
    textView.setTextSize(textSize);
    textView.setText(bottomItem.title);
    textView.setTextColor(textColor);
    textView.setGravity(Gravity.CENTER);
    mTextViews.add(textView);
    addView(textView,itemWidth,20);
  }
  Log.d(""String_Node_Str"",""String_Node_Str"" + itemWidth);
}","The original code lacked proper view management, potentially leading to memory leaks and untrackable UI components. The fixed code introduces `mImageViews` and `mTextViews` collections to store references to dynamically created views, enabling better memory tracking and potential future manipulation. By adding these collections, the code provides a more robust and maintainable approach to creating and managing bottom navigation views."
38107,"@Override protected void onDraw(Canvas canvas){
  for (int i=0; i < 5; i++) {
    mPaint.setColor(itemcolors[i]);
    canvas.drawRect(itemWidth * i,0,itemWidth * (i + 1),barHeight,mPaint);
    canvas.save();
  }
  mPaint.setColor(backGroundColor);
  canvas.drawRect(0,0,itemMoveLeft,barHeight,mPaint);
  canvas.drawRect(itemMoveRight,0,itemWidth * 5,barHeight,mPaint);
  canvas.save();
  for (int i=0; i < itemCount; i++) {
    int deltaX=Math.abs(itemMoveCenter - itemCenterX[i]);
    if (deltaX < itemWidth) {
      itemScale[i]=(float)(-0.5 * deltaX / itemWidth + 1);
    }
 else     itemScale[i]=0.5f;
    View childImageView=getChildAt(i);
    childImageView.setScaleX(itemScale[i]);
    childImageView.setScaleY(itemScale[i]);
    View childTextView=getChildAt(itemCount + i);
    childTextView.setScaleX(itemScale[i]);
    childTextView.setScaleY(itemScale[i]);
  }
  Log.d(""String_Node_Str"",""String_Node_Str"" + selectIndex + ""String_Node_Str""+ itemScale[selectIndex]);
  super.onDraw(canvas);
}","@Override protected void onDraw(Canvas canvas){
  for (int i=0; i < 5; i++) {
    mPaint.setColor(itemcolors[i]);
    canvas.drawRect(itemWidth * i,0,itemWidth * (i + 1),barHeight,mPaint);
    canvas.save();
  }
  mPaint.setColor(backGroundColor);
  canvas.drawRect(0,0,itemMoveLeft,barHeight,mPaint);
  canvas.drawRect(itemMoveRight,0,itemWidth * 5,barHeight,mPaint);
  canvas.save();
  for (int i=0; i < itemCount; i++) {
    int deltaX=Math.abs(itemMoveCenter - itemCenterX[i]);
    if (deltaX < itemWidth) {
      itemScale[i]=(float)(-0.5 * deltaX / itemWidth + 1);
    }
 else     itemScale[i]=0.5f;
    mImageViews.get(i).setScaleX(itemScale[i]);
    mImageViews.get(i).setScaleY(itemScale[i]);
    mTextViews.get(i).setScaleX(itemScale[i]);
    mTextViews.get(i).setScaleY(itemScale[i]);
  }
  super.onDraw(canvas);
}","The original code incorrectly uses `getChildAt()` to access views, which can be unreliable and assumes a specific view hierarchy order. The fixed code replaces `getChildAt()` with dedicated lists `mImageViews` and `mTextViews`, providing more predictable and controlled view management. This approach ensures precise scaling of image and text views, improving code reliability and maintainability by decoupling view access from the drawing method."
38108,"@Override public void onAnimationStart(Animation animation){
  TextView textView=(TextView)getChildAt(selectLastIndex + itemCount);
  textView.setTextColor(textColor);
  TextView selectTextView=(TextView)getChildAt(selectIndex + itemCount);
  selectTextView.setTextColor(selectTextColor);
}","@Override public void onAnimationStart(Animation animation){
}","The original code attempts to modify TextView colors during animation start, potentially causing index out of bounds or null pointer exceptions if child views are not correctly initialized or accessible. The fixed code removes the problematic color-setting logic, eliminating potential runtime errors and unexpected behavior. By simplifying the method to an empty implementation, the code prevents potential crashes and ensures stable animation handling."
38109,"@Override public void configure(HttpSecurity http) throws Exception {
  http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().requestMatchers().antMatchers(""String_Node_Str"").and().authorizeRequests().antMatchers(""String_Node_Str"").permitAll().antMatchers(""String_Node_Str"").authenticated();
}","@Override public void configure(HttpSecurity http) throws Exception {
  http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().requestMatchers().antMatchers(""String_Node_Str"").and().authorizeRequests().antMatchers(""String_Node_Str"").permitAll().antMatchers(""String_Node_Str"").permitAll().antMatchers(""String_Node_Str"").authenticated();
}","The original code incorrectly used `.authenticated()` for one set of URL patterns, which would restrict access and potentially block legitimate users. The fixed code replaces `.authenticated()` with `.permitAll()` for that specific pattern, ensuring consistent access permissions across different URL matchers. This modification provides more flexible and uniform security configuration, allowing appropriate access control for all specified URL patterns."
38110,"@Override protected void configure(HttpSecurity http) throws Exception {
  http.httpBasic().and().csrf().ignoringAntMatchers(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").and().authorizeRequests().antMatchers(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").permitAll().antMatchers(""String_Node_Str"").hasRole(""String_Node_Str"").antMatchers(""String_Node_Str"").hasRole(""String_Node_Str"").anyRequest().authenticated().and().formLogin().loginPage(""String_Node_Str"").successHandler(new SuccessHandler()).and().logout();
}","@Override protected void configure(HttpSecurity http) throws Exception {
  http.httpBasic().and().csrf().ignoringAntMatchers(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").and().authorizeRequests().antMatchers(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").permitAll().antMatchers(""String_Node_Str"").hasRole(""String_Node_Str"").antMatchers(""String_Node_Str"").hasRole(""String_Node_Str"").antMatchers(""String_Node_Str"").permitAll().anyRequest().authenticated().and().formLogin().loginPage(""String_Node_Str"").successHandler(new SuccessHandler()).and().logout();
}","The original code lacked a specific permitAll() matcher for an additional endpoint, potentially restricting unauthorized access to certain routes. The fixed code adds an antMatchers(""String_Node_Str"").permitAll() statement, explicitly allowing unrestricted access to that particular endpoint. This modification ensures more granular and precise access control, improving the overall security configuration by providing clear, targeted permissions for different URL patterns."
38111,"@ApiOperation(value=""String_Node_Str"",httpMethod=""String_Node_Str"") @GetMapping(""String_Node_Str"") public UserResponse me(Principal principal){
  if (Objects.isNull(principal) || StringUtils.isBlank(principal.getName())) {
    throw new UnauthorizedException(""String_Node_Str"");
  }
  return userService.getResponse(principal.getName());
}","@ApiOperation(value=""String_Node_Str"",httpMethod=""String_Node_Str"") @PostMapping(""String_Node_Str"") public UserResponse me(Principal principal){
  if (Objects.isNull(principal) || StringUtils.isBlank(principal.getName())) {
    throw new UnauthorizedException(""String_Node_Str"");
  }
  return userService.getResponse(principal.getName());
}","The original code uses @GetMapping, which is inappropriate for retrieving user details that typically require authentication and potential state changes. The fixed code changes to @PostMapping, which is more suitable for secure user-related operations that involve authentication and potential server-side modifications. This change enhances the endpoint's security and aligns better with RESTful API design principles for user-specific resource retrieval."
38112,"@Override public void configure(HttpSecurity http) throws Exception {
  http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().requestMatchers().antMatchers(""String_Node_Str"").and().authorizeRequests().antMatchers(""String_Node_Str"").authenticated();
}","@Override public void configure(HttpSecurity http) throws Exception {
  http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().requestMatchers().antMatchers(""String_Node_Str"",""String_Node_Str"").and().authorizeRequests().antMatchers(""String_Node_Str"",""String_Node_Str"").authenticated();
}","The original code lacks multiple URL pattern matching, limiting security configuration to a single endpoint. The fixed code introduces additional URL patterns by using multiple arguments in antMatchers(), enabling broader security coverage across different endpoints. This enhancement provides more comprehensive request authorization and ensures that multiple specific routes can be properly authenticated and secured."
38113,"@Override public void onFaceDetection(Face[] faces,CameraManager.CameraProxy camera){
  mFaceView.setFaces(faces);
}","@Override public void onFaceDetection(Face[] faces,CameraManager.CameraProxy camera){
  if (mIsBokehMode) {
    mFaceView.clear();
    return;
  }
  mFaceView.setFaces(faces);
}","The original code always sets faces on the view without considering the current camera mode, which could lead to unintended UI updates. The fixed code adds a check for bokeh mode, clearing the face view and returning early if that mode is active, preventing unnecessary or incorrect face rendering. This modification ensures that face detection behaves correctly based on the current camera mode, improving the robustness of the face detection implementation."
38114,"@Override public void showSuccess(boolean timeout){
  if (mState == STATE_FOCUSING) {
    startAnimation(SCALING_DOWN_TIME,timeout,mStartAnimationAngle);
    mState=STATE_FINISHING;
    mFocused=true;
  }
}","@Override public void showSuccess(boolean timeout){
  if (mIsBokehMode) {
    mOverlay.postDelayed(new Runnable(){
      @Override public void run(){
        if (mState == STATE_FOCUSING) {
          startAnimation(SCALING_DOWN_TIME,timeout,mStartAnimationAngle);
          mState=STATE_FINISHING;
          mFocused=true;
        }
      }
    }
,3000);
  }
 else {
    if (mState == STATE_FOCUSING) {
      startAnimation(SCALING_DOWN_TIME,timeout,mStartAnimationAngle);
      mState=STATE_FINISHING;
      mFocused=true;
    }
  }
}","The original code lacked a condition to handle Bokeh mode, potentially causing premature state changes and animation triggers. The fixed code introduces an `mIsBokehMode` check and adds a delayed runnable for Bokeh mode, ensuring that state changes occur only after a 3-second delay and within the correct mode context. This modification prevents unintended behavior and provides more controlled state management for different camera modes."
38115,"@Override public void onFaceDetection(Face[] faces,CameraManager.CameraProxy camera){
  mFaceView.setFaces(faces);
}","@Override public void onFaceDetection(Face[] faces,CameraManager.CameraProxy camera){
  if (mIsBokehMode) {
    mFaceView.clear();
    return;
  }
  mFaceView.setFaces(faces);
}","The original code unconditionally sets faces on the view, potentially causing unintended rendering in bokeh mode. The fixed code adds a check for bokeh mode, clearing the face view and preventing unnecessary face detection rendering when that mode is active. This modification ensures more precise and context-aware face detection behavior, preventing potential visual glitches or performance overhead in specific camera modes."
38116,"@Override public void showSuccess(boolean timeout){
  if (mState == STATE_FOCUSING) {
    startAnimation(SCALING_DOWN_TIME,timeout,mStartAnimationAngle);
    mState=STATE_FINISHING;
    mFocused=true;
  }
}","@Override public void showSuccess(boolean timeout){
  if (mIsBokehMode) {
    mOverlay.postDelayed(new Runnable(){
      @Override public void run(){
        if (mState == STATE_FOCUSING) {
          startAnimation(SCALING_DOWN_TIME,timeout,mStartAnimationAngle);
          mState=STATE_FINISHING;
          mFocused=true;
        }
      }
    }
,3000);
  }
 else {
    if (mState == STATE_FOCUSING) {
      startAnimation(SCALING_DOWN_TIME,timeout,mStartAnimationAngle);
      mState=STATE_FINISHING;
      mFocused=true;
    }
  }
}","The original code lacked a condition to handle Bokeh mode, potentially causing incorrect state transitions and animation triggers. The fixed code adds a specific check for Bokeh mode, introducing a delayed runnable that ensures the state change and animation occur only after a 3-second delay and when in the focusing state. This modification provides more robust handling of different camera modes, preventing premature state changes and improving the overall reliability of the focus mechanism."
38117,"/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,ParametersWrapper.getSupportedTouchAfAec(mParameters))) {
      mCurrTouchAfAec=touchAfAec;
      ParametersWrapper.setTouchAfAec(mParameters,touchAfAec);
    }
  }
 else {
    ParametersWrapper.setTouchAfAec(mParameters,ParametersWrapper.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (ParametersWrapper.getTouchAfAec(mParameters).equals(ParametersWrapper.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
    }
 else {
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=ParametersWrapper.getSupportedSelectableZoneAf(mParameters);
  if (CameraUtil.isSupported(selectableZoneAf,ParametersWrapper.getSupportedSelectableZoneAf(mParameters))) {
    ParametersWrapper.setSelectableZoneAf(mParameters,selectableZoneAf);
  }
  if (ParametersWrapper.getSupportedDenoiseModes(mParameters) != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    ParametersWrapper.setDenoise(mParameters,Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,ParametersWrapper.getSupportedRedeyeReductionModes(mParameters))) {
    ParametersWrapper.setRedeyeReductionMode(mParameters,redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,ParametersWrapper.getSupportedIsoValues(mParameters))) {
      ParametersWrapper.setISOValue(mParameters,iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= ParametersWrapper.getMaxSaturation(mParameters))) {
    ParametersWrapper.setSaturation(mParameters,saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= ParametersWrapper.getMaxContrast(mParameters))) {
    ParametersWrapper.setContrast(mParameters,contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (ParametersWrapper.getMaxSharpness(mParameters) / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= ParametersWrapper.getMaxSharpness(mParameters))) {
    ParametersWrapper.setSharpness(mParameters,sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
        }
      }
);
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
        }
      }
);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(ParametersWrapper.FACE_DETECTION_ON,ParametersWrapper.getSupportedFaceDetectionModes(mParameters))) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,ParametersWrapper.FACE_DETECTION_ON);
        }
      }
);
      ParametersWrapper.setFaceDetectionMode(mParameters,ParametersWrapper.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
      }
    }
);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,ParametersWrapper.getSupportedFaceDetectionModes(mParameters))) {
      ParametersWrapper.setFaceDetectionMode(mParameters,faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,ParametersWrapper.getSupportedAutoexposure(mParameters))) {
    ParametersWrapper.setAutoExposure(mParameters,autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  ParametersWrapper.setZSLMode(mParameters,zsl);
  if (zsl.equals(""String_Node_Str"") && ParametersWrapper.getSupportedZSLModes(mParameters) != null) {
    mSnapshotMode=CameraInfoWrapper.CAMERA_SUPPORT_MODE_ZSL;
    ParametersWrapper.setCameraMode(mParameters,1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfoWrapper.CAMERA_SUPPORT_MODE_NONZSL;
    ParametersWrapper.setCameraMode(mParameters,0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String instantCapture=mPreferences.getString(CameraSettings.KEY_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_default));
  if (!instantCapture.equals(mActivity.getString(R.string.pref_camera_instant_capture_value_disable))) {
    if (zsl.equals(""String_Node_Str"") && advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_none))) {
      if (!mInstantCaptureSnapShot) {
        instantCapture=mActivity.getString(R.string.pref_camera_instant_capture_value_disable);
      }
    }
 else {
      mParameters.set(CameraSettings.KEY_QC_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_value_disable));
      instantCapture=mActivity.getString(R.string.pref_camera_instant_capture_value_disable);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_value_disable));
        }
      }
);
    }
  }
  Log.v(TAG,""String_Node_Str"" + instantCapture + ""String_Node_Str""+ mInstantCaptureSnapShot);
  mParameters.set(CameraSettings.KEY_QC_INSTANT_CAPTURE,instantCapture);
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,ParametersWrapper.getSupportedHistogramModes(mParameters)) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (aeBracket != null && !aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
  if (!mFocusManager.getFocusMode().equals(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE) && !mFocusManager.isFocusCompleted()) {
    mUI.clearFocus();
  }
  String bokehMode=mPreferences.getString(CameraSettings.KEY_BOKEH_MODE,mActivity.getString(R.string.pref_camera_bokeh_mode_default));
  String bokehMpo=mPreferences.getString(CameraSettings.KEY_BOKEH_MPO,mActivity.getString(R.string.pref_camera_bokeh_mpo_default));
  String bokehBlurDegree=mPreferences.getString(CameraSettings.KEY_BOKEH_BLUR_VALUE,mActivity.getString(R.string.pref_camera_bokeh_blur_degree_default));
  CameraSettings.getSupportedDegreesOfBlur(mParameters);
  if (!bokehMode.equals(mActivity.getString(R.string.pref_camera_bokeh_mode_entry_value_disable))) {
    if (!zsl.equals(""String_Node_Str"")) {
      ParametersWrapper.setZSLMode(mParameters,""String_Node_Str"");
    }
    if (mParameters.getSceneMode() != Parameters.SCENE_MODE_AUTO) {
      mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
    }
    if (mParameters.getFlashMode() != Parameters.FLASH_MODE_OFF) {
      mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
    }
    if (mParameters.get(""String_Node_Str"").equals(mActivity.getString(R.string.setting_on_value))) {
      mParameters.set(""String_Node_Str"",mActivity.getString(R.string.setting_off_value));
    }
    if (mManual3AEnabled != 0) {
      mManual3AEnabled=0;
    }
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(mActivity);
    final int degree=prefs.getInt(CameraSettings.KEY_BOKEH_BLUR_VALUE,50);
    bokehBlurDegree=String.valueOf(degree);
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_SCENE_MODE,mActivity.getString(R.string.pref_camera_scenemode_default));
        mUI.overrideSettings(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_value_on));
        mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,""String_Node_Str"");
        mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
        mBlurDegreeProgressBar.setVisibility(View.VISIBLE);
        mBlurDegreeProgressBar.setProgress(degree);
      }
    }
);
  }
 else {
    bokehBlurDegree=""String_Node_Str"";
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_BOKEH_MPO,mActivity.getString(R.string.pref_camera_bokeh_mpo_default));
        mUI.overrideSettings(CameraSettings.KEY_BOKEH_BLUR_VALUE,mActivity.getString(R.string.pref_camera_bokeh_blur_degree_default));
        mBlurDegreeProgressBar.setVisibility(View.GONE);
      }
    }
);
  }
  mParameters.set(CameraSettings.KEY_QC_BOKEH_MODE,bokehMode);
  mParameters.set(CameraSettings.KEY_QC_BOKEH_MPO_MODE,bokehMpo);
  mParameters.set(CameraSettings.KEY_QC_BOKEH_BLUR_VALUE,bokehBlurDegree);
  Log.v(TAG,""String_Node_Str"" + bokehMode + ""String_Node_Str""+ bokehMpo+ ""String_Node_Str""+ bokehBlurDegree);
}","/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,ParametersWrapper.getSupportedTouchAfAec(mParameters))) {
      mCurrTouchAfAec=touchAfAec;
      ParametersWrapper.setTouchAfAec(mParameters,touchAfAec);
    }
  }
 else {
    ParametersWrapper.setTouchAfAec(mParameters,ParametersWrapper.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (ParametersWrapper.getTouchAfAec(mParameters).equals(ParametersWrapper.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
      mHandler.post(new Runnable(){
        @Override public void run(){
          mUI.hideRemainingPhotoCnt();
        }
      }
);
    }
 else {
      mHandler.post(new Runnable(){
        @Override public void run(){
          mUI.showRemainingPhotoCnt();
        }
      }
);
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=ParametersWrapper.getSupportedSelectableZoneAf(mParameters);
  if (CameraUtil.isSupported(selectableZoneAf,ParametersWrapper.getSupportedSelectableZoneAf(mParameters))) {
    ParametersWrapper.setSelectableZoneAf(mParameters,selectableZoneAf);
  }
  if (ParametersWrapper.getSupportedDenoiseModes(mParameters) != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    ParametersWrapper.setDenoise(mParameters,Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,ParametersWrapper.getSupportedRedeyeReductionModes(mParameters))) {
    ParametersWrapper.setRedeyeReductionMode(mParameters,redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,ParametersWrapper.getSupportedIsoValues(mParameters))) {
      ParametersWrapper.setISOValue(mParameters,iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= ParametersWrapper.getMaxSaturation(mParameters))) {
    ParametersWrapper.setSaturation(mParameters,saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= ParametersWrapper.getMaxContrast(mParameters))) {
    ParametersWrapper.setContrast(mParameters,contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (ParametersWrapper.getMaxSharpness(mParameters) / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= ParametersWrapper.getMaxSharpness(mParameters))) {
    ParametersWrapper.setSharpness(mParameters,sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
        }
      }
);
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
        }
      }
);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(ParametersWrapper.FACE_DETECTION_ON,ParametersWrapper.getSupportedFaceDetectionModes(mParameters))) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,ParametersWrapper.FACE_DETECTION_ON);
        }
      }
);
      ParametersWrapper.setFaceDetectionMode(mParameters,ParametersWrapper.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
      }
    }
);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,ParametersWrapper.getSupportedFaceDetectionModes(mParameters))) {
      ParametersWrapper.setFaceDetectionMode(mParameters,faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,ParametersWrapper.getSupportedAutoexposure(mParameters))) {
    ParametersWrapper.setAutoExposure(mParameters,autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  ParametersWrapper.setZSLMode(mParameters,zsl);
  if (zsl.equals(""String_Node_Str"") && ParametersWrapper.getSupportedZSLModes(mParameters) != null) {
    mSnapshotMode=CameraInfoWrapper.CAMERA_SUPPORT_MODE_ZSL;
    ParametersWrapper.setCameraMode(mParameters,1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfoWrapper.CAMERA_SUPPORT_MODE_NONZSL;
    ParametersWrapper.setCameraMode(mParameters,0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String instantCapture=mPreferences.getString(CameraSettings.KEY_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_default));
  if (!instantCapture.equals(mActivity.getString(R.string.pref_camera_instant_capture_value_disable))) {
    if (zsl.equals(""String_Node_Str"") && advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_none))) {
      if (!mInstantCaptureSnapShot) {
        instantCapture=mActivity.getString(R.string.pref_camera_instant_capture_value_disable);
      }
    }
 else {
      mParameters.set(CameraSettings.KEY_QC_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_value_disable));
      instantCapture=mActivity.getString(R.string.pref_camera_instant_capture_value_disable);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_value_disable));
        }
      }
);
    }
  }
  Log.v(TAG,""String_Node_Str"" + instantCapture + ""String_Node_Str""+ mInstantCaptureSnapShot);
  mParameters.set(CameraSettings.KEY_QC_INSTANT_CAPTURE,instantCapture);
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,ParametersWrapper.getSupportedHistogramModes(mParameters)) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (aeBracket != null && !aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
  if (!mFocusManager.getFocusMode().equals(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE) && !mFocusManager.isFocusCompleted()) {
    mUI.clearFocus();
  }
  String bokehMode=mPreferences.getString(CameraSettings.KEY_BOKEH_MODE,mActivity.getString(R.string.pref_camera_bokeh_mode_default));
  String bokehMpo=mPreferences.getString(CameraSettings.KEY_BOKEH_MPO,mActivity.getString(R.string.pref_camera_bokeh_mpo_default));
  String bokehBlurDegree=mPreferences.getString(CameraSettings.KEY_BOKEH_BLUR_VALUE,mActivity.getString(R.string.pref_camera_bokeh_blur_degree_default));
  CameraSettings.getSupportedDegreesOfBlur(mParameters);
  if (!bokehMode.equals(mActivity.getString(R.string.pref_camera_bokeh_mode_entry_value_disable))) {
    if (!zsl.equals(""String_Node_Str"")) {
      ParametersWrapper.setZSLMode(mParameters,""String_Node_Str"");
    }
    if (mParameters.getSceneMode() != Parameters.SCENE_MODE_AUTO) {
      mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
    }
    if (mParameters.getFlashMode() != Parameters.FLASH_MODE_OFF) {
      mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
    }
    if (mParameters.get(""String_Node_Str"").equals(mActivity.getString(R.string.setting_on_value))) {
      mParameters.set(""String_Node_Str"",mActivity.getString(R.string.setting_off_value));
    }
    if (mManual3AEnabled != 0) {
      mManual3AEnabled=0;
    }
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(mActivity);
    final int degree=prefs.getInt(CameraSettings.KEY_BOKEH_BLUR_VALUE,50);
    bokehBlurDegree=String.valueOf(degree);
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_SCENE_MODE,mActivity.getString(R.string.pref_camera_scenemode_default));
        mUI.overrideSettings(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_value_on));
        mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,""String_Node_Str"");
        mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
        mBlurDegreeProgressBar.setVisibility(View.VISIBLE);
        mBlurDegreeProgressBar.setProgress(degree);
      }
    }
);
  }
 else {
    bokehBlurDegree=""String_Node_Str"";
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_BOKEH_MPO,mActivity.getString(R.string.pref_camera_bokeh_mpo_default));
        mUI.overrideSettings(CameraSettings.KEY_BOKEH_BLUR_VALUE,mActivity.getString(R.string.pref_camera_bokeh_blur_degree_default));
        mBlurDegreeProgressBar.setVisibility(View.GONE);
      }
    }
);
  }
  mParameters.set(CameraSettings.KEY_QC_BOKEH_MODE,bokehMode);
  mParameters.set(CameraSettings.KEY_QC_BOKEH_MPO_MODE,bokehMpo);
  mParameters.set(CameraSettings.KEY_QC_BOKEH_BLUR_VALUE,bokehBlurDegree);
  Log.v(TAG,""String_Node_Str"" + bokehMode + ""String_Node_Str""+ bokehMpo+ ""String_Node_Str""+ bokehBlurDegree);
}","The original code had a potential issue with JPEG quality handling, lacking proper UI feedback when picture sizes were large. The fixed code adds explicit UI method calls to show or hide remaining photo count based on JPEG quality and picture size, ensuring clear user communication. These changes improve user experience by providing more informative visual cues about image capture capabilities and remaining storage space."
38118,"private boolean startRecordingVideo(final int cameraId){
  if (null == mCameraDevice[cameraId]) {
    return false;
  }
  Log.d(TAG,""String_Node_Str"" + cameraId);
  mStartRecPending=true;
  mIsRecordingVideo=true;
  mMediaRecorderPausing=false;
  mUI.hideUIwhileRecording();
  mActivity.updateStorageSpaceAndHint();
  if (mActivity.getStorageSpaceBytes() <= Storage.LOW_STORAGE_THRESHOLD_BYTES) {
    Log.w(TAG,""String_Node_Str"");
    mStartRecPending=false;
    mIsRecordingVideo=false;
    return false;
  }
  try {
    setUpMediaRecorder(cameraId);
    if (mUnsupportedResolution == true) {
      Log.v(TAG,""String_Node_Str"");
      mStartRecPending=false;
      mIsRecordingVideo=false;
      return false;
    }
    if (mMediaRecorder == null) {
      Log.e(TAG,""String_Node_Str"");
      mStartRecPending=false;
      mIsRecordingVideo=false;
      return false;
    }
    requestAudioFocus();
    mUI.clearFocus();
    mCameraHandler.removeMessages(CANCEL_TOUCH_FOCUS,mCameraId[cameraId]);
    mState[cameraId]=STATE_PREVIEW;
    mControlAFMode=CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
    closePreviewSession();
    mFrameProcessor.onClose();
    Size preview=mVideoPreviewSize;
    if (mHighSpeedCapture) {
      preview=mVideoSize;
    }
    boolean changed=mUI.setPreviewSize(preview.getWidth(),preview.getHeight());
    if (changed) {
      mUI.hideSurfaceView();
      mUI.showSurfaceView();
    }
    mUI.resetTrackingFocus();
    createVideoSnapshotImageReader();
    mVideoRequestBuilder=mCameraDevice[cameraId].createCaptureRequest(CameraDevice.TEMPLATE_RECORD);
    mVideoRequestBuilder.setTag(cameraId);
    mPreviewRequestBuilder[cameraId]=mVideoRequestBuilder;
    List<Surface> surfaces=new ArrayList<>();
    Surface surface=getPreviewSurfaceForSession(cameraId);
    mFrameProcessor.onOpen(getFrameProcFilterId(),mVideoSize);
    if (mFrameProcessor.isFrameFilterEnabled()) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          mUI.getSurfaceHolder().setFixedSize(mVideoSize.getHeight(),mVideoSize.getWidth());
        }
      }
);
    }
    mFrameProcessor.setOutputSurface(surface);
    mFrameProcessor.setVideoOutputSurface(mMediaRecorder.getSurface());
    addPreviewSurface(mVideoRequestBuilder,surfaces,cameraId);
    if (mHighSpeedCapture)     mVideoRequestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE,mHighSpeedFPSRange);
    if (mHighSpeedCapture && ((int)mHighSpeedFPSRange.getUpper() > NORMAL_SESSION_MAX_FPS)) {
      mCameraDevice[cameraId].createConstrainedHighSpeedCaptureSession(surfaces,new CameraConstrainedHighSpeedCaptureSession.StateCallback(){
        @Override public void onConfigured(        CameraCaptureSession cameraCaptureSession){
          mCurrentSession=cameraCaptureSession;
          mCaptureSession[cameraId]=cameraCaptureSession;
          CameraConstrainedHighSpeedCaptureSession session=(CameraConstrainedHighSpeedCaptureSession)mCurrentSession;
          try {
            List list=CameraUtil.createHighSpeedRequestList(mVideoRequestBuilder.build(),cameraId);
            session.setRepeatingBurst(list,mCaptureCallback,mCameraHandler);
          }
 catch (          CameraAccessException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
catch (          IllegalArgumentException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
catch (          IllegalStateException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
          try {
            mMediaRecorder.start();
          }
 catch (          RuntimeException e) {
            Toast.makeText(mActivity,""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
            releaseMediaRecorder();
            releaseAudioFocus();
            mStartRecPending=false;
            mIsRecordingVideo=false;
            return;
          }
          mUI.clearFocus();
          mUI.resetPauseButton();
          mRecordingTotalTime=0L;
          mRecordingStartTime=SystemClock.uptimeMillis();
          mUI.enableShutter(false);
          mUI.showRecordingUI(true,true);
          updateRecordingTime();
          keepScreenOn();
        }
        @Override public void onConfigureFailed(        CameraCaptureSession cameraCaptureSession){
          Toast.makeText(mActivity,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
,null);
    }
 else {
      surfaces.add(mVideoSnapshotImageReader.getSurface());
      mCameraDevice[cameraId].createCaptureSession(surfaces,new CameraCaptureSession.StateCallback(){
        @Override public void onConfigured(        CameraCaptureSession cameraCaptureSession){
          Log.d(TAG,""String_Node_Str"");
          mCurrentSession=cameraCaptureSession;
          mCaptureSession[cameraId]=cameraCaptureSession;
          try {
            setUpVideoCaptureRequestBuilder(mVideoRequestBuilder,cameraId);
            mCurrentSession.setRepeatingRequest(mVideoRequestBuilder.build(),mCaptureCallback,mCameraHandler);
          }
 catch (          CameraAccessException e) {
            e.printStackTrace();
          }
catch (          IllegalStateException e) {
            e.printStackTrace();
          }
          try {
            mMediaRecorder.start();
          }
 catch (          RuntimeException e) {
            Toast.makeText(mActivity,""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
            releaseMediaRecorder();
            releaseAudioFocus();
            mStartRecPending=false;
            mIsRecordingVideo=false;
            return;
          }
          mUI.clearFocus();
          mUI.resetPauseButton();
          mRecordingTotalTime=0L;
          mRecordingStartTime=SystemClock.uptimeMillis();
          mUI.showRecordingUI(true,false);
          updateRecordingTime();
          keepScreenOn();
        }
        @Override public void onConfigureFailed(        CameraCaptureSession cameraCaptureSession){
          Toast.makeText(mActivity,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
,null);
    }
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  mStartRecPending=false;
  return true;
}","private boolean startRecordingVideo(final int cameraId){
  if (null == mCameraDevice[cameraId]) {
    return false;
  }
  Log.d(TAG,""String_Node_Str"" + cameraId);
  mStartRecPending=true;
  mIsRecordingVideo=true;
  mMediaRecorderPausing=false;
  mActivity.updateStorageSpaceAndHint();
  if (mActivity.getStorageSpaceBytes() <= Storage.LOW_STORAGE_THRESHOLD_BYTES) {
    Log.w(TAG,""String_Node_Str"");
    mStartRecPending=false;
    mIsRecordingVideo=false;
    return false;
  }
  try {
    setUpMediaRecorder(cameraId);
    try {
      mMediaRecorder.start();
    }
 catch (    RuntimeException e) {
      Toast.makeText(mActivity,""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
      releaseMediaRecorder();
      releaseAudioFocus();
      mStartRecPending=false;
      mIsRecordingVideo=false;
      return false;
    }
    if (mUnsupportedResolution == true) {
      Log.v(TAG,""String_Node_Str"");
      mStartRecPending=false;
      mIsRecordingVideo=false;
      return false;
    }
    if (mMediaRecorder == null) {
      Log.e(TAG,""String_Node_Str"");
      mStartRecPending=false;
      mIsRecordingVideo=false;
      return false;
    }
    requestAudioFocus();
    mUI.clearFocus();
    mUI.hideUIwhileRecording();
    mCameraHandler.removeMessages(CANCEL_TOUCH_FOCUS,mCameraId[cameraId]);
    mState[cameraId]=STATE_PREVIEW;
    mControlAFMode=CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
    closePreviewSession();
    mFrameProcessor.onClose();
    Size preview=mVideoPreviewSize;
    if (mHighSpeedCapture) {
      preview=mVideoSize;
    }
    boolean changed=mUI.setPreviewSize(preview.getWidth(),preview.getHeight());
    if (changed) {
      mUI.hideSurfaceView();
      mUI.showSurfaceView();
    }
    mUI.resetTrackingFocus();
    createVideoSnapshotImageReader();
    mVideoRequestBuilder=mCameraDevice[cameraId].createCaptureRequest(CameraDevice.TEMPLATE_RECORD);
    mVideoRequestBuilder.setTag(cameraId);
    mPreviewRequestBuilder[cameraId]=mVideoRequestBuilder;
    List<Surface> surfaces=new ArrayList<>();
    Surface surface=getPreviewSurfaceForSession(cameraId);
    mFrameProcessor.onOpen(getFrameProcFilterId(),mVideoSize);
    if (mFrameProcessor.isFrameFilterEnabled()) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          mUI.getSurfaceHolder().setFixedSize(mVideoSize.getHeight(),mVideoSize.getWidth());
        }
      }
);
    }
    mFrameProcessor.setOutputSurface(surface);
    mFrameProcessor.setVideoOutputSurface(mMediaRecorder.getSurface());
    addPreviewSurface(mVideoRequestBuilder,surfaces,cameraId);
    if (mHighSpeedCapture)     mVideoRequestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE,mHighSpeedFPSRange);
    if (mHighSpeedCapture && ((int)mHighSpeedFPSRange.getUpper() > NORMAL_SESSION_MAX_FPS)) {
      mCameraDevice[cameraId].createConstrainedHighSpeedCaptureSession(surfaces,new CameraConstrainedHighSpeedCaptureSession.StateCallback(){
        @Override public void onConfigured(        CameraCaptureSession cameraCaptureSession){
          mCurrentSession=cameraCaptureSession;
          mCaptureSession[cameraId]=cameraCaptureSession;
          CameraConstrainedHighSpeedCaptureSession session=(CameraConstrainedHighSpeedCaptureSession)mCurrentSession;
          try {
            List list=CameraUtil.createHighSpeedRequestList(mVideoRequestBuilder.build(),cameraId);
            session.setRepeatingBurst(list,mCaptureCallback,mCameraHandler);
          }
 catch (          CameraAccessException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
catch (          IllegalArgumentException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
catch (          IllegalStateException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
          mUI.clearFocus();
          mUI.resetPauseButton();
          mRecordingTotalTime=0L;
          mRecordingStartTime=SystemClock.uptimeMillis();
          mUI.enableShutter(false);
          mUI.showRecordingUI(true,true);
          updateRecordingTime();
          keepScreenOn();
        }
        @Override public void onConfigureFailed(        CameraCaptureSession cameraCaptureSession){
          Toast.makeText(mActivity,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
,null);
    }
 else {
      surfaces.add(mVideoSnapshotImageReader.getSurface());
      mCameraDevice[cameraId].createCaptureSession(surfaces,new CameraCaptureSession.StateCallback(){
        @Override public void onConfigured(        CameraCaptureSession cameraCaptureSession){
          Log.d(TAG,""String_Node_Str"");
          mCurrentSession=cameraCaptureSession;
          mCaptureSession[cameraId]=cameraCaptureSession;
          try {
            setUpVideoCaptureRequestBuilder(mVideoRequestBuilder,cameraId);
            mCurrentSession.setRepeatingRequest(mVideoRequestBuilder.build(),mCaptureCallback,mCameraHandler);
          }
 catch (          CameraAccessException e) {
            e.printStackTrace();
          }
catch (          IllegalStateException e) {
            e.printStackTrace();
          }
          mUI.clearFocus();
          mUI.resetPauseButton();
          mRecordingTotalTime=0L;
          mRecordingStartTime=SystemClock.uptimeMillis();
          mUI.showRecordingUI(true,false);
          updateRecordingTime();
          keepScreenOn();
        }
        @Override public void onConfigureFailed(        CameraCaptureSession cameraCaptureSession){
          Toast.makeText(mActivity,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
,null);
    }
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  mStartRecPending=false;
  return true;
}","The original code attempted to start video recording after setting up the capture session, which could lead to potential race conditions and unexpected behavior. The fixed code moves the MediaRecorder start method before session configuration and adds proper error handling, ensuring the recording starts before further setup. This approach provides more reliable video recording initiation, reduces potential synchronization issues, and improves the overall robustness of the video recording process."
38119,"@Override public void onConfigured(CameraCaptureSession cameraCaptureSession){
  Log.d(TAG,""String_Node_Str"");
  mCurrentSession=cameraCaptureSession;
  mCaptureSession[cameraId]=cameraCaptureSession;
  try {
    setUpVideoCaptureRequestBuilder(mVideoRequestBuilder,cameraId);
    mCurrentSession.setRepeatingRequest(mVideoRequestBuilder.build(),mCaptureCallback,mCameraHandler);
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
catch (  IllegalStateException e) {
    e.printStackTrace();
  }
  try {
    mMediaRecorder.start();
  }
 catch (  RuntimeException e) {
    Toast.makeText(mActivity,""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
    releaseMediaRecorder();
    releaseAudioFocus();
    mStartRecPending=false;
    mIsRecordingVideo=false;
    return;
  }
  mUI.clearFocus();
  mUI.resetPauseButton();
  mRecordingTotalTime=0L;
  mRecordingStartTime=SystemClock.uptimeMillis();
  mUI.showRecordingUI(true,false);
  updateRecordingTime();
  keepScreenOn();
}","@Override public void onConfigured(CameraCaptureSession cameraCaptureSession){
  Log.d(TAG,""String_Node_Str"");
  mCurrentSession=cameraCaptureSession;
  mCaptureSession[cameraId]=cameraCaptureSession;
  try {
    setUpVideoCaptureRequestBuilder(mVideoRequestBuilder,cameraId);
    mCurrentSession.setRepeatingRequest(mVideoRequestBuilder.build(),mCaptureCallback,mCameraHandler);
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
catch (  IllegalStateException e) {
    e.printStackTrace();
  }
  mUI.clearFocus();
  mUI.resetPauseButton();
  mRecordingTotalTime=0L;
  mRecordingStartTime=SystemClock.uptimeMillis();
  mUI.showRecordingUI(true,false);
  updateRecordingTime();
  keepScreenOn();
}","The original code attempted to start the media recorder within a try-catch block, which could lead to unexpected behavior and potential resource leaks if the recording failed. In the fixed code, the media recorder start attempt has been removed, simplifying the configuration process and preventing potential runtime exceptions. This modification ensures a more stable camera capture session setup, reducing the risk of unexpected errors during video recording initialization."
38120,"@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)&& mCameraBound != null) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    Matrix translateMatrix=new Matrix();
    translateMatrix.preTranslate(-mCameraBound.width() / 2f,-mCameraBound.height() / 2f);
    translateMatrix.postScale(2000f / mCameraBound.width(),2000f / mCameraBound.height());
    Matrix bsgcTranslateMatrix=new Matrix();
    bsgcTranslateMatrix.preTranslate(-mCameraBound.width() / 2f * mZoom,-mCameraBound.height() / 2f * mZoom);
    bsgcTranslateMatrix.postScale(2000f / mCameraBound.width(),2000f / mCameraBound.height());
    int dx=(getWidth() - rw) / 2;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    float rectWidth;
    float rectHeight;
    float diameter;
    int extendFaceSize=0;
    extendFaceSize=mExFaces == null ? 0 : mExFaces.length;
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].getScore() < 50)       continue;
      Rect faceBound=mFaces[i].getBounds();
      faceBound.offset(-mCameraBound.left,-mCameraBound.top);
      mRect.set(faceBound);
      translateMatrix.mapRect(mRect);
      mMatrix.mapRect(mRect);
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      rectHeight=mRect.bottom - mRect.top;
      rectWidth=mRect.right - mRect.left;
      diameter=rectHeight > rectWidth ? rectWidth : rectHeight;
      canvas.drawCircle(mRect.centerX(),mRect.centerY(),diameter / 2,mPaint);
      if (i < extendFaceSize && mExFaces[i] != null) {
        ExtendedFace exFace=mExFaces[i];
        Face face=mFaces[i];
        float[] point=new float[4];
        int delta_x=faceBound.width() / 12;
        int delta_y=faceBound.height() / 12;
        delta_x=(int)(delta_x * mZoom);
        delta_y=(int)(delta_y * mZoom);
        Log.e(TAG,""String_Node_Str"" + exFace.getLeyeBlink() + ""String_Node_Str""+ exFace.getReyeBlink()+ ""String_Node_Str"");
        if (face.getLeftEyePosition() != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.getLeftEyePosition().x;
            point[1]=face.getLeftEyePosition().y - delta_y / 2;
            point[2]=face.getLeftEyePosition().x;
            point[3]=face.getLeftEyePosition().y + delta_y / 2;
          }
 else {
            point[0]=face.getLeftEyePosition().x - delta_x / 2;
            point[1]=face.getLeftEyePosition().y;
            point[2]=face.getLeftEyePosition().x + delta_x / 2;
            point[3]=face.getLeftEyePosition().y;
          }
          bsgcTranslateMatrix.mapPoints(point);
          mMatrix.mapPoints(point);
          if (exFace.getLeyeBlink() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getRightEyePosition() != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.getRightEyePosition().x;
            point[1]=face.getRightEyePosition().y - delta_y / 2;
            point[2]=face.getRightEyePosition().x;
            point[3]=face.getRightEyePosition().y + delta_y / 2;
          }
 else {
            point[0]=face.getRightEyePosition().x - delta_x / 2;
            point[1]=face.getRightEyePosition().y;
            point[2]=face.getRightEyePosition().x + delta_x / 2;
            point[3]=face.getRightEyePosition().y;
          }
          bsgcTranslateMatrix.mapPoints(point);
          mMatrix.mapPoints(point);
          if (exFace.getReyeBlink() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (exFace.getLeftrightGaze() != 0 || exFace.getTopbottomGaze() != 0) {
          double length=Math.sqrt((face.getLeftEyePosition().x - face.getRightEyePosition().x) * (face.getLeftEyePosition().x - face.getRightEyePosition().x) + (face.getLeftEyePosition().y - face.getRightEyePosition().y) * (face.getLeftEyePosition().y - face.getRightEyePosition().y)) / 2.0;
          double nGazeYaw=-exFace.getLeftrightGaze();
          double nGazePitch=-exFace.getTopbottomGaze();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-exFace.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-exFace.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-exFace.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-exFace.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (exFace.getLeyeBlink() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.getLeftEyePosition().x;
              point[1]=face.getLeftEyePosition().y;
              point[2]=face.getLeftEyePosition().x + gazeRollX;
              point[3]=face.getLeftEyePosition().y + gazeRollY;
            }
 else {
              point[0]=face.getLeftEyePosition().x;
              point[1]=face.getLeftEyePosition().y;
              point[2]=face.getLeftEyePosition().x + gazeRollY;
              point[3]=face.getLeftEyePosition().y + gazeRollX;
            }
            bsgcTranslateMatrix.mapPoints(point);
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (exFace.getReyeBlink() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.getRightEyePosition().x;
              point[1]=face.getRightEyePosition().y;
              point[2]=face.getRightEyePosition().x + gazeRollX;
              point[3]=face.getRightEyePosition().y + gazeRollY;
            }
 else {
              point[0]=face.getRightEyePosition().x;
              point[1]=face.getRightEyePosition().y;
              point[2]=face.getRightEyePosition().x + gazeRollY;
              point[3]=face.getRightEyePosition().y + gazeRollX;
            }
            bsgcTranslateMatrix.mapPoints(point);
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getMouthPosition() != null) {
          Log.e(TAG,""String_Node_Str"" + exFace.getSmileDegree() + ""String_Node_Str""+ exFace.getSmileConfidence());
          if (exFace.getSmileDegree() < smile_threashold_no_smile) {
            point[0]=face.getMouthPosition().x + dx - delta_x;
            point[1]=face.getMouthPosition().y;
            point[2]=face.getMouthPosition().x + dx + delta_x;
            point[3]=face.getMouthPosition().y;
            Matrix faceMatrix=new Matrix();
            faceMatrix.preRotate(exFace.getRollDirection(),face.getMouthPosition().x,face.getMouthPosition().y);
            faceMatrix.mapPoints(point);
            bsgcTranslateMatrix.mapPoints(point);
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (exFace.getSmileDegree() < smile_threashold_small_smile) {
            int rotation_mouth=360 - mDisplayRotation;
            mRect.set(face.getMouthPosition().x - delta_x,face.getMouthPosition().y - delta_y,face.getMouthPosition().x + delta_x,face.getMouthPosition().y + delta_y);
            bsgcTranslateMatrix.mapRect(mRect);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,rotation_mouth,180,true,mPaint);
          }
 else {
            mRect.set(face.getMouthPosition().x - delta_x,face.getMouthPosition().y - delta_y,face.getMouthPosition().x + delta_x,face.getMouthPosition().y + delta_y);
            bsgcTranslateMatrix.mapRect(mRect);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)&& mCameraBound != null) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    Matrix translateMatrix=new Matrix();
    translateMatrix.preTranslate(-mCameraBound.width() / 2f,-mCameraBound.height() / 2f);
    translateMatrix.postScale(2000f / mCameraBound.width(),2000f / mCameraBound.height());
    Matrix bsgcTranslateMatrix=new Matrix();
    bsgcTranslateMatrix.preTranslate(-mCameraBound.width() / 2f * mZoom,-mCameraBound.height() / 2f * mZoom);
    bsgcTranslateMatrix.postScale(2000f / mCameraBound.width(),2000f / mCameraBound.height());
    int dx=(getWidth() - rw) / 2;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    float rectWidth;
    float rectHeight;
    float diameter;
    int extendFaceSize=0;
    extendFaceSize=mExFaces == null ? 0 : mExFaces.length;
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].getScore() < 50)       continue;
      Rect faceBound=mFaces[i].getBounds();
      faceBound.offset(-mCameraBound.left,-mCameraBound.top);
      mRect.set(faceBound);
      translateMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      rectHeight=mRect.bottom - mRect.top;
      rectWidth=mRect.right - mRect.left;
      diameter=rectHeight > rectWidth ? rectWidth : rectHeight;
      canvas.drawCircle(mRect.centerX(),mRect.centerY(),diameter / 2,mPaint);
      if (i < extendFaceSize && mExFaces[i] != null) {
        ExtendedFace exFace=mExFaces[i];
        Face face=mFaces[i];
        float[] point=new float[4];
        int delta_x=faceBound.width() / 12;
        int delta_y=faceBound.height() / 12;
        delta_x=(int)(delta_x * mZoom);
        delta_y=(int)(delta_y * mZoom);
        Log.e(TAG,""String_Node_Str"" + exFace.getLeyeBlink() + ""String_Node_Str""+ exFace.getReyeBlink()+ ""String_Node_Str"");
        if (face.getLeftEyePosition() != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.getLeftEyePosition().x;
            point[1]=face.getLeftEyePosition().y - delta_y / 2;
            point[2]=face.getLeftEyePosition().x;
            point[3]=face.getLeftEyePosition().y + delta_y / 2;
          }
 else {
            point[0]=face.getLeftEyePosition().x - delta_x / 2;
            point[1]=face.getLeftEyePosition().y;
            point[2]=face.getLeftEyePosition().x + delta_x / 2;
            point[3]=face.getLeftEyePosition().y;
          }
          bsgcTranslateMatrix.mapPoints(point);
          mMatrix.mapPoints(point);
          if (exFace.getLeyeBlink() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getRightEyePosition() != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.getRightEyePosition().x;
            point[1]=face.getRightEyePosition().y - delta_y / 2;
            point[2]=face.getRightEyePosition().x;
            point[3]=face.getRightEyePosition().y + delta_y / 2;
          }
 else {
            point[0]=face.getRightEyePosition().x - delta_x / 2;
            point[1]=face.getRightEyePosition().y;
            point[2]=face.getRightEyePosition().x + delta_x / 2;
            point[3]=face.getRightEyePosition().y;
          }
          bsgcTranslateMatrix.mapPoints(point);
          mMatrix.mapPoints(point);
          if (exFace.getReyeBlink() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (exFace.getLeftrightGaze() != 0 || exFace.getTopbottomGaze() != 0) {
          double length=Math.sqrt((face.getLeftEyePosition().x - face.getRightEyePosition().x) * (face.getLeftEyePosition().x - face.getRightEyePosition().x) + (face.getLeftEyePosition().y - face.getRightEyePosition().y) * (face.getLeftEyePosition().y - face.getRightEyePosition().y)) / 2.0;
          double nGazeYaw=-exFace.getLeftrightGaze();
          double nGazePitch=-exFace.getTopbottomGaze();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-exFace.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-exFace.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-exFace.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-exFace.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (exFace.getLeyeBlink() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.getLeftEyePosition().x;
              point[1]=face.getLeftEyePosition().y;
              point[2]=face.getLeftEyePosition().x + gazeRollX;
              point[3]=face.getLeftEyePosition().y + gazeRollY;
            }
 else {
              point[0]=face.getLeftEyePosition().x;
              point[1]=face.getLeftEyePosition().y;
              point[2]=face.getLeftEyePosition().x + gazeRollY;
              point[3]=face.getLeftEyePosition().y + gazeRollX;
            }
            bsgcTranslateMatrix.mapPoints(point);
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (exFace.getReyeBlink() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.getRightEyePosition().x;
              point[1]=face.getRightEyePosition().y;
              point[2]=face.getRightEyePosition().x + gazeRollX;
              point[3]=face.getRightEyePosition().y + gazeRollY;
            }
 else {
              point[0]=face.getRightEyePosition().x;
              point[1]=face.getRightEyePosition().y;
              point[2]=face.getRightEyePosition().x + gazeRollY;
              point[3]=face.getRightEyePosition().y + gazeRollX;
            }
            bsgcTranslateMatrix.mapPoints(point);
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getMouthPosition() != null) {
          Log.e(TAG,""String_Node_Str"" + exFace.getSmileDegree() + ""String_Node_Str""+ exFace.getSmileConfidence());
          if (exFace.getSmileDegree() < smile_threashold_no_smile) {
            point[0]=face.getMouthPosition().x + dx - delta_x;
            point[1]=face.getMouthPosition().y;
            point[2]=face.getMouthPosition().x + dx + delta_x;
            point[3]=face.getMouthPosition().y;
            Matrix faceMatrix=new Matrix();
            faceMatrix.preRotate(exFace.getRollDirection(),face.getMouthPosition().x,face.getMouthPosition().y);
            faceMatrix.mapPoints(point);
            bsgcTranslateMatrix.mapPoints(point);
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (exFace.getSmileDegree() < smile_threashold_small_smile) {
            int rotation_mouth=360 - mDisplayRotation;
            mRect.set(face.getMouthPosition().x - delta_x,face.getMouthPosition().y - delta_y,face.getMouthPosition().x + delta_x,face.getMouthPosition().y + delta_y);
            bsgcTranslateMatrix.mapRect(mRect);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,rotation_mouth,180,true,mPaint);
          }
 else {
            mRect.set(face.getMouthPosition().x - delta_x,face.getMouthPosition().y - delta_y,face.getMouthPosition().x + delta_x,face.getMouthPosition().y + delta_y);
            bsgcTranslateMatrix.mapRect(mRect);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","The original code lacked debugging visibility by not logging important rectangle transformations during face detection processing. The fixed code adds conditional logging with `LOGV` and `CameraUtil.dumpRect()` to provide diagnostic information about rectangle mapping before and after matrix transformations. These strategic debug statements enable developers to trace coordinate changes, improving code transparency and making it easier to diagnose potential rendering or face detection issues."
38121,"/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,ParametersWrapper.getSupportedTouchAfAec(mParameters))) {
      mCurrTouchAfAec=touchAfAec;
      ParametersWrapper.setTouchAfAec(mParameters,touchAfAec);
    }
  }
 else {
    ParametersWrapper.setTouchAfAec(mParameters,ParametersWrapper.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (ParametersWrapper.getTouchAfAec(mParameters).equals(ParametersWrapper.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
    }
 else {
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=ParametersWrapper.getSupportedSelectableZoneAf(mParameters);
  if (CameraUtil.isSupported(selectableZoneAf,ParametersWrapper.getSupportedSelectableZoneAf(mParameters))) {
    ParametersWrapper.setSelectableZoneAf(mParameters,selectableZoneAf);
  }
  if (ParametersWrapper.getSupportedDenoiseModes(mParameters) != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    ParametersWrapper.setDenoise(mParameters,Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,ParametersWrapper.getSupportedRedeyeReductionModes(mParameters))) {
    ParametersWrapper.setRedeyeReductionMode(mParameters,redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,ParametersWrapper.getSupportedIsoValues(mParameters))) {
      ParametersWrapper.setISOValue(mParameters,iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= ParametersWrapper.getMaxSaturation(mParameters))) {
    ParametersWrapper.setSaturation(mParameters,saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= ParametersWrapper.getMaxContrast(mParameters))) {
    ParametersWrapper.setContrast(mParameters,contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (ParametersWrapper.getMaxSharpness(mParameters) / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= ParametersWrapper.getMaxSharpness(mParameters))) {
    ParametersWrapper.setSharpness(mParameters,sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
        }
      }
);
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
        }
      }
);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(ParametersWrapper.FACE_DETECTION_ON,ParametersWrapper.getSupportedFaceDetectionModes(mParameters))) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,ParametersWrapper.FACE_DETECTION_ON);
        }
      }
);
      ParametersWrapper.setFaceDetectionMode(mParameters,ParametersWrapper.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
      }
    }
);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,ParametersWrapper.getSupportedFaceDetectionModes(mParameters))) {
      ParametersWrapper.setFaceDetectionMode(mParameters,faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,ParametersWrapper.getSupportedAutoexposure(mParameters))) {
    ParametersWrapper.setAutoExposure(mParameters,autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  ParametersWrapper.setZSLMode(mParameters,zsl);
  if (zsl.equals(""String_Node_Str"") && ParametersWrapper.getSupportedZSLModes(mParameters) != null) {
    mSnapshotMode=CameraInfoWrapper.CAMERA_SUPPORT_MODE_ZSL;
    ParametersWrapper.setCameraMode(mParameters,1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfoWrapper.CAMERA_SUPPORT_MODE_NONZSL;
    ParametersWrapper.setCameraMode(mParameters,0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String instantCapture=mPreferences.getString(CameraSettings.KEY_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_default));
  if (!instantCapture.equals(mActivity.getString(R.string.pref_camera_instant_capture_value_disable))) {
    if (zsl.equals(""String_Node_Str"") && advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_none))) {
      if (!mInstantCaptureSnapShot) {
        instantCapture=mActivity.getString(R.string.pref_camera_instant_capture_value_disable);
      }
    }
 else {
      mParameters.set(CameraSettings.KEY_QC_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_value_disable));
      instantCapture=mActivity.getString(R.string.pref_camera_instant_capture_value_disable);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_value_disable));
        }
      }
);
    }
  }
  Log.v(TAG,""String_Node_Str"" + instantCapture + ""String_Node_Str""+ mInstantCaptureSnapShot);
  mParameters.set(CameraSettings.KEY_QC_INSTANT_CAPTURE,instantCapture);
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,ParametersWrapper.getSupportedHistogramModes(mParameters)) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (aeBracket != null && !aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
  if (!mFocusManager.getFocusMode().equals(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE) && !mFocusManager.isFocusCompleted()) {
    mUI.clearFocus();
  }
  String bokehMode=mPreferences.getString(CameraSettings.KEY_BOKEH_MODE,mActivity.getString(R.string.pref_camera_bokeh_mode_default));
  String bokehMpo=mPreferences.getString(CameraSettings.KEY_BOKEH_MPO,mActivity.getString(R.string.pref_camera_bokeh_mpo_default));
  String bokehBlurDegree=mPreferences.getString(CameraSettings.KEY_BOKEH_BLUR_VALUE,mActivity.getString(R.string.pref_camera_bokeh_blur_degree_default));
  CameraSettings.getSupportedDegreesOfBlur(mParameters);
  if (!bokehMode.equals(mActivity.getString(R.string.pref_camera_bokeh_mode_entry_value_disable))) {
    if (!zsl.equals(""String_Node_Str"")) {
      ParametersWrapper.setZSLMode(mParameters,""String_Node_Str"");
    }
    if (mParameters.getSceneMode() != Parameters.SCENE_MODE_AUTO) {
      mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
    }
    if (mParameters.getFlashMode() != Parameters.FLASH_MODE_OFF) {
      mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
    }
    if (mParameters.get(""String_Node_Str"").equals(mActivity.getString(R.string.setting_on_value))) {
      mParameters.set(""String_Node_Str"",mActivity.getString(R.string.setting_off_value));
    }
    if (mManual3AEnabled != 0) {
      mManual3AEnabled=0;
    }
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(mActivity);
    final int degree=prefs.getInt(CameraSettings.KEY_BOKEH_BLUR_VALUE,50);
    bokehBlurDegree=String.valueOf(degree);
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_SCENE_MODE,mActivity.getString(R.string.pref_camera_scenemode_default));
        mUI.overrideSettings(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_value_on));
        mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,""String_Node_Str"");
        mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
        mBlurDegreeProgressBar.setVisibility(View.VISIBLE);
        mBlurDegreeProgressBar.setProgress(degree);
      }
    }
);
  }
 else {
    bokehBlurDegree=""String_Node_Str"";
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_BOKEH_MPO,mActivity.getString(R.string.pref_camera_bokeh_mpo_default));
        mUI.overrideSettings(CameraSettings.KEY_BOKEH_BLUR_VALUE,mActivity.getString(R.string.pref_camera_bokeh_blur_degree_default));
        mBlurDegreeProgressBar.setVisibility(View.GONE);
      }
    }
);
  }
  mParameters.set(CameraSettings.KEY_QC_BOKEH_MODE,bokehMode);
  mParameters.set(CameraSettings.KEY_QC_BOKEH_MPO_MODE,bokehMpo);
  mParameters.set(CameraSettings.KEY_QC_BOKEH_BLUR_VALUE,bokehBlurDegree);
  Log.v(TAG,""String_Node_Str"" + bokehMode + ""String_Node_Str""+ bokehMpo+ ""String_Node_Str""+ bokehBlurDegree);
}","/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,ParametersWrapper.getSupportedTouchAfAec(mParameters))) {
      mCurrTouchAfAec=touchAfAec;
      ParametersWrapper.setTouchAfAec(mParameters,touchAfAec);
    }
  }
 else {
    ParametersWrapper.setTouchAfAec(mParameters,ParametersWrapper.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (ParametersWrapper.getTouchAfAec(mParameters).equals(ParametersWrapper.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
      mHandler.post(new Runnable(){
        @Override public void run(){
          mUI.hideRemainingPhotoCnt();
        }
      }
);
    }
 else {
      mHandler.post(new Runnable(){
        @Override public void run(){
          mUI.showRemainingPhotoCnt();
        }
      }
);
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=ParametersWrapper.getSupportedSelectableZoneAf(mParameters);
  if (CameraUtil.isSupported(selectableZoneAf,ParametersWrapper.getSupportedSelectableZoneAf(mParameters))) {
    ParametersWrapper.setSelectableZoneAf(mParameters,selectableZoneAf);
  }
  if (ParametersWrapper.getSupportedDenoiseModes(mParameters) != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    ParametersWrapper.setDenoise(mParameters,Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,ParametersWrapper.getSupportedRedeyeReductionModes(mParameters))) {
    ParametersWrapper.setRedeyeReductionMode(mParameters,redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,ParametersWrapper.getSupportedIsoValues(mParameters))) {
      ParametersWrapper.setISOValue(mParameters,iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= ParametersWrapper.getMaxSaturation(mParameters))) {
    ParametersWrapper.setSaturation(mParameters,saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= ParametersWrapper.getMaxContrast(mParameters))) {
    ParametersWrapper.setContrast(mParameters,contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (ParametersWrapper.getMaxSharpness(mParameters) / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= ParametersWrapper.getMaxSharpness(mParameters))) {
    ParametersWrapper.setSharpness(mParameters,sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
        }
      }
);
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
        }
      }
);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(ParametersWrapper.FACE_DETECTION_ON,ParametersWrapper.getSupportedFaceDetectionModes(mParameters))) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,ParametersWrapper.FACE_DETECTION_ON);
        }
      }
);
      ParametersWrapper.setFaceDetectionMode(mParameters,ParametersWrapper.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
      }
    }
);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,ParametersWrapper.getSupportedFaceDetectionModes(mParameters))) {
      ParametersWrapper.setFaceDetectionMode(mParameters,faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,ParametersWrapper.getSupportedAutoexposure(mParameters))) {
    ParametersWrapper.setAutoExposure(mParameters,autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  ParametersWrapper.setZSLMode(mParameters,zsl);
  if (zsl.equals(""String_Node_Str"") && ParametersWrapper.getSupportedZSLModes(mParameters) != null) {
    mSnapshotMode=CameraInfoWrapper.CAMERA_SUPPORT_MODE_ZSL;
    ParametersWrapper.setCameraMode(mParameters,1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfoWrapper.CAMERA_SUPPORT_MODE_NONZSL;
    ParametersWrapper.setCameraMode(mParameters,0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String instantCapture=mPreferences.getString(CameraSettings.KEY_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_default));
  if (!instantCapture.equals(mActivity.getString(R.string.pref_camera_instant_capture_value_disable))) {
    if (zsl.equals(""String_Node_Str"") && advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_none))) {
      if (!mInstantCaptureSnapShot) {
        instantCapture=mActivity.getString(R.string.pref_camera_instant_capture_value_disable);
      }
    }
 else {
      mParameters.set(CameraSettings.KEY_QC_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_value_disable));
      instantCapture=mActivity.getString(R.string.pref_camera_instant_capture_value_disable);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_INSTANT_CAPTURE,mActivity.getString(R.string.pref_camera_instant_capture_value_disable));
        }
      }
);
    }
  }
  Log.v(TAG,""String_Node_Str"" + instantCapture + ""String_Node_Str""+ mInstantCaptureSnapShot);
  mParameters.set(CameraSettings.KEY_QC_INSTANT_CAPTURE,instantCapture);
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,ParametersWrapper.getSupportedHistogramModes(mParameters)) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (aeBracket != null && !aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
  if (!mFocusManager.getFocusMode().equals(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE) && !mFocusManager.isFocusCompleted()) {
    mUI.clearFocus();
  }
  String bokehMode=mPreferences.getString(CameraSettings.KEY_BOKEH_MODE,mActivity.getString(R.string.pref_camera_bokeh_mode_default));
  String bokehMpo=mPreferences.getString(CameraSettings.KEY_BOKEH_MPO,mActivity.getString(R.string.pref_camera_bokeh_mpo_default));
  String bokehBlurDegree=mPreferences.getString(CameraSettings.KEY_BOKEH_BLUR_VALUE,mActivity.getString(R.string.pref_camera_bokeh_blur_degree_default));
  CameraSettings.getSupportedDegreesOfBlur(mParameters);
  if (!bokehMode.equals(mActivity.getString(R.string.pref_camera_bokeh_mode_entry_value_disable))) {
    if (!zsl.equals(""String_Node_Str"")) {
      ParametersWrapper.setZSLMode(mParameters,""String_Node_Str"");
    }
    if (mParameters.getSceneMode() != Parameters.SCENE_MODE_AUTO) {
      mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
    }
    if (mParameters.getFlashMode() != Parameters.FLASH_MODE_OFF) {
      mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
    }
    if (mParameters.get(""String_Node_Str"").equals(mActivity.getString(R.string.setting_on_value))) {
      mParameters.set(""String_Node_Str"",mActivity.getString(R.string.setting_off_value));
    }
    if (mManual3AEnabled != 0) {
      mManual3AEnabled=0;
    }
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(mActivity);
    final int degree=prefs.getInt(CameraSettings.KEY_BOKEH_BLUR_VALUE,50);
    bokehBlurDegree=String.valueOf(degree);
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_SCENE_MODE,mActivity.getString(R.string.pref_camera_scenemode_default));
        mUI.overrideSettings(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_value_on));
        mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,""String_Node_Str"");
        mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
        mBlurDegreeProgressBar.setVisibility(View.VISIBLE);
        mBlurDegreeProgressBar.setProgress(degree);
      }
    }
);
  }
 else {
    bokehBlurDegree=""String_Node_Str"";
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_BOKEH_MPO,mActivity.getString(R.string.pref_camera_bokeh_mpo_default));
        mUI.overrideSettings(CameraSettings.KEY_BOKEH_BLUR_VALUE,mActivity.getString(R.string.pref_camera_bokeh_blur_degree_default));
        mBlurDegreeProgressBar.setVisibility(View.GONE);
      }
    }
);
  }
  mParameters.set(CameraSettings.KEY_QC_BOKEH_MODE,bokehMode);
  mParameters.set(CameraSettings.KEY_QC_BOKEH_MPO_MODE,bokehMpo);
  mParameters.set(CameraSettings.KEY_QC_BOKEH_BLUR_VALUE,bokehBlurDegree);
  Log.v(TAG,""String_Node_Str"" + bokehMode + ""String_Node_Str""+ bokehMpo+ ""String_Node_Str""+ bokehBlurDegree);
}","The original code had a critical issue with JPEG quality handling, potentially causing incorrect file size estimation and UI update problems. In the fixed version, explicit UI update methods like `hideRemainingPhotoCnt()` and `showRemainingPhotoCnt()` were added to handle different picture size scenarios more robustly. These changes ensure proper remaining photo count display and file size estimation, improving the camera parameter configuration process with more precise and predictable behavior."
38122,"public void showCapturedReview(byte[] jpegData,int orientation,boolean mirror){
  mActivity.runOnUiThread(new Runnable(){
    @Override public void run(){
      mUI.showCapturedImageForReview(jpegData,orientation,mirror);
    }
  }
);
}","public void showCapturedReview(final byte[] jpegData,int orientation,boolean mirror){
  mActivity.runOnUiThread(new Runnable(){
    @Override public void run(){
      mUI.showCapturedImageForReview(jpegData,orientation,mirror);
    }
  }
);
}","The original code lacks the `final` keyword for the `jpegData` parameter, which is required when accessing a local variable inside an anonymous inner class. Adding `final` ensures that the variable can be safely referenced within the Runnable's run method. By making `jpegData` final, the code prevents potential compilation errors and guarantees that the parameter's value remains unchanged throughout the thread execution."
38123,"protected void showCapturedImageForReview(byte[] jpegData,int orientation,boolean mirror){
  mCameraControls.hideCameraSettings();
  mDecodeTaskForReview=new DecodeImageForReview(jpegData,orientation,mirror);
  mDecodeTaskForReview.execute();
  mOnScreenIndicators.setVisibility(View.GONE);
  mMenuButton.setVisibility(View.GONE);
  CameraUtil.fadeIn(mReviewDoneButton);
  mShutterButton.setVisibility(View.INVISIBLE);
  CameraUtil.fadeIn(mReviewRetakeButton);
  mMenu.hideTopMenu(true);
  pauseFaceDetection();
}","protected void showCapturedImageForReview(byte[] jpegData,int orientation,boolean mirror){
  mCameraControls.hideCameraSettings();
  mDecodeTaskForReview=new DecodeImageForReview(jpegData,orientation,mirror);
  mDecodeTaskForReview.execute();
  mOnScreenIndicators.setVisibility(View.GONE);
  mMenuButton.setVisibility(View.GONE);
  CameraUtil.fadeIn(mReviewDoneButton);
  mShutterButton.setVisibility(View.INVISIBLE);
  CameraUtil.fadeIn(mReviewRetakeButton);
  setOrientation(mOrientation,true);
  mMenu.hideTopMenu(true);
  pauseFaceDetection();
}","The original code lacks a critical method call to set the device orientation, potentially causing UI misalignment during image review. The fixed code adds `setOrientation(mOrientation,true)`, which ensures the UI elements are correctly oriented based on the device's current position. This correction guarantees consistent and proper visual presentation of the review screen across different device orientations."
38124,"protected void showCapturedImageForReview(byte[] jpegData,int orientation,boolean mirror){
  mCameraControls.hideCameraSettings();
  mDecodeTaskForReview=new DecodeImageForReview(jpegData,orientation,mirror);
  mDecodeTaskForReview.execute();
  mOnScreenIndicators.setVisibility(View.GONE);
  mMenuButton.setVisibility(View.GONE);
  CameraUtil.fadeIn(mReviewDoneButton);
  mShutterButton.setVisibility(View.INVISIBLE);
  CameraUtil.fadeIn(mReviewRetakeButton);
  mMenu.hideTopMenu(true);
  pauseFaceDetection();
}","protected void showCapturedImageForReview(byte[] jpegData,int orientation,boolean mirror){
  mCameraControls.hideCameraSettings();
  mDecodeTaskForReview=new DecodeImageForReview(jpegData,orientation,mirror);
  mDecodeTaskForReview.execute();
  mOnScreenIndicators.setVisibility(View.GONE);
  mMenuButton.setVisibility(View.GONE);
  CameraUtil.fadeIn(mReviewDoneButton);
  mShutterButton.setVisibility(View.INVISIBLE);
  CameraUtil.fadeIn(mReviewRetakeButton);
  setOrientation(mOrientation,true);
  mMenu.hideTopMenu(true);
  pauseFaceDetection();
}","The original code lacked a critical orientation update when transitioning to image review mode, potentially causing incorrect screen orientation. The fixed code adds `setOrientation(mOrientation,true)`, ensuring the screen properly aligns with the device's current orientation during image review. This change guarantees consistent and correct visual presentation, improving user experience by maintaining proper screen alignment during the capture review process."
38125,"public void showCapturedReview(byte[] jpegData,int orientation,boolean mirror){
  mActivity.runOnUiThread(new Runnable(){
    @Override public void run(){
      mUI.showCapturedImageForReview(jpegData,orientation,mirror);
    }
  }
);
}","public void showCapturedReview(final byte[] jpegData,int orientation,boolean mirror){
  mActivity.runOnUiThread(new Runnable(){
    @Override public void run(){
      mUI.showCapturedImageForReview(jpegData,orientation,mirror);
    }
  }
);
}","The original code lacks the `final` keyword for `jpegData`, which prevents accessing the byte array inside the anonymous Runnable class. By adding `final` to the parameter, the variable becomes effectively final, allowing it to be referenced within the inner class. This modification ensures that the byte array can be safely passed and used in the UI thread, resolving potential compilation errors and enabling proper image review functionality."
38126,"public void setProMode(boolean promode){
  mProModeOn=promode;
  initializeProMode(mProModeOn);
  resetProModeIcons();
}","public void setProMode(boolean promode){
  mProModeOn=promode;
  initializeProMode(mProModeOn);
  resetProModeIcons();
  mProMode.reinit();
}","The original code failed to reinitialize the `mProMode` object after changing the pro mode state, potentially leaving some settings or configurations stale. The fixed code adds `mProMode.reinit()` to ensure a complete reset and synchronization of the pro mode settings after the mode is changed. This additional method call guarantees that all associated components are properly updated and refreshed when the pro mode is toggled, preventing potential inconsistencies in the user interface or functionality."
38127,"public void setProMode(boolean promode){
  mProModeOn=promode;
  initializeProMode(mProModeOn);
  resetProModeIcons();
}","public void setProMode(boolean promode){
  mProModeOn=promode;
  initializeProMode(mProModeOn);
  resetProModeIcons();
  mProMode.reinit();
}","The original code lacked a critical method call to reinitialize the mProMode object after setting the pro mode state. The fixed code adds mProMode.reinit() to ensure that the object is properly reset and synchronized with the new pro mode configuration. This additional method call guarantees a complete and consistent state transition when switching pro mode, preventing potential initialization or synchronization issues."
38128,"private void filterPreferences(int cameraId){
  ListPreference whiteBalance=mPreferenceGroup.findPreference(KEY_WHITE_BALANCE);
  ListPreference flashMode=mPreferenceGroup.findPreference(KEY_FLASH_MODE);
  ListPreference colorEffect=mPreferenceGroup.findPreference(KEY_COLOR_EFFECT);
  ListPreference sceneMode=mPreferenceGroup.findPreference(KEY_SCENE_MODE);
  ListPreference cameraIdPref=mPreferenceGroup.findPreference(KEY_CAMERA_ID);
  ListPreference pictureSize=mPreferenceGroup.findPreference(KEY_PICTURE_SIZE);
  ListPreference exposure=mPreferenceGroup.findPreference(KEY_EXPOSURE);
  ListPreference iso=mPreferenceGroup.findPreference(KEY_ISO);
  ListPreference clearsight=mPreferenceGroup.findPreference(KEY_CLEARSIGHT);
  ListPreference monoPreview=mPreferenceGroup.findPreference(KEY_MONO_PREVIEW);
  ListPreference monoOnly=mPreferenceGroup.findPreference(KEY_MONO_ONLY);
  ListPreference mpo=mPreferenceGroup.findPreference(KEY_MPO);
  ListPreference redeyeReduction=mPreferenceGroup.findPreference(KEY_REDEYE_REDUCTION);
  ListPreference videoQuality=mPreferenceGroup.findPreference(KEY_VIDEO_QUALITY);
  ListPreference videoEncoder=mPreferenceGroup.findPreference(KEY_VIDEO_ENCODER);
  ListPreference audioEncoder=mPreferenceGroup.findPreference(KEY_AUDIO_ENCODER);
  ListPreference noiseReduction=mPreferenceGroup.findPreference(KEY_NOISE_REDUCTION);
  ListPreference faceDetection=mPreferenceGroup.findPreference(KEY_FACE_DETECTION);
  ListPreference makeup=mPreferenceGroup.findPreference(KEY_MAKEUP);
  ListPreference trackingfocus=mPreferenceGroup.findPreference(KEY_TRACKINGFOCUS);
  ListPreference hfr=mPreferenceGroup.findPreference(KEY_VIDEO_HIGH_FRAME_RATE);
  if (whiteBalance != null) {
    if (filterUnsupportedOptions(whiteBalance,getSupportedWhiteBalanceModes(cameraId))) {
      mFilteredKeys.add(whiteBalance.getKey());
    }
  }
  if (flashMode != null) {
    if (!isFlashAvailable(mCameraId)) {
      removePreference(mPreferenceGroup,KEY_FLASH_MODE);
      mFilteredKeys.add(flashMode.getKey());
    }
  }
  if (colorEffect != null) {
    if (filterUnsupportedOptions(colorEffect,getSupportedColorEffects(cameraId))) {
      mFilteredKeys.add(colorEffect.getKey());
    }
  }
  if (sceneMode != null) {
    if (filterUnsupportedOptions(sceneMode,getSupportedSceneModes(cameraId))) {
      mFilteredKeys.add(sceneMode.getKey());
    }
  }
  if (cameraIdPref != null)   buildCameraId();
  if (pictureSize != null) {
    if (filterUnsupportedOptions(pictureSize,getSupportedPictureSize(cameraId))) {
      mFilteredKeys.add(pictureSize.getKey());
    }
 else {
      if (CameraSettings.filterSimilarPictureSize(mPreferenceGroup,pictureSize)) {
        mFilteredKeys.add(pictureSize.getKey());
      }
    }
  }
  if (exposure != null)   buildExposureCompensation(cameraId);
  if (iso != null) {
    if (filterUnsupportedOptions(iso,getSupportedIso(cameraId))) {
      mFilteredKeys.add(iso.getKey());
    }
  }
  if (videoQuality != null) {
    CameraSettings.filterUnsupportedOptions(mPreferenceGroup,videoQuality,getSupportedVideoSize(cameraId));
    mVideoQualityEntryValues=videoQuality.getEntryValues();
    mVideoQualityEntries=videoQuality.getEntries();
  }
  if (iso != null) {
    if (filterUnsupportedOptions(videoQuality,getSupportedVideoSize(cameraId))) {
      mFilteredKeys.add(redeyeReduction.getKey());
    }
  }
  if (!mIsMonoCameraPresent) {
    if (clearsight != null)     removePreference(mPreferenceGroup,KEY_CLEARSIGHT);
    if (monoPreview != null)     removePreference(mPreferenceGroup,KEY_MONO_PREVIEW);
    if (monoOnly != null)     removePreference(mPreferenceGroup,KEY_MONO_ONLY);
    if (mpo != null)     removePreference(mPreferenceGroup,KEY_MPO);
  }
  if (redeyeReduction != null) {
    if (filterUnsupportedOptions(redeyeReduction,getSupportedRedeyeReduction(cameraId))) {
      mFilteredKeys.add(redeyeReduction.getKey());
    }
  }
  if (videoEncoder != null) {
    if (filterUnsupportedOptions(videoEncoder,getSupportedVideoEncoders(videoEncoder.getEntryValues()))) {
      mFilteredKeys.add(videoEncoder.getKey());
    }
  }
  if (audioEncoder != null) {
    if (filterUnsupportedOptions(audioEncoder,getSupportedAudioEncoders(audioEncoder.getEntryValues()))) {
      mFilteredKeys.add(audioEncoder.getKey());
    }
  }
  if (noiseReduction != null) {
    if (filterUnsupportedOptions(noiseReduction,getSupportedNoiseReductionModes(cameraId))) {
      mFilteredKeys.add(noiseReduction.getKey());
    }
  }
  if (faceDetection != null) {
    if (!isFaceDetectionSupported(cameraId)) {
      removePreference(mPreferenceGroup,KEY_FACE_DETECTION);
    }
  }
  if (trackingfocus != null) {
    if (!TrackingFocusFrameListener.isSupportedStatic())     removePreference(mPreferenceGroup,KEY_TRACKINGFOCUS);
  }
  if (hfr != null) {
    buildHFR();
  }
  if (!mIsFrontCameraPresent || !isFacingFront(mCameraId)) {
    removePreference(mPreferenceGroup,KEY_SELFIE_FLASH);
    removePreference(mPreferenceGroup,KEY_SELFIEMIRROR);
  }
}","private void filterPreferences(int cameraId){
  ListPreference whiteBalance=mPreferenceGroup.findPreference(KEY_WHITE_BALANCE);
  ListPreference flashMode=mPreferenceGroup.findPreference(KEY_FLASH_MODE);
  ListPreference colorEffect=mPreferenceGroup.findPreference(KEY_COLOR_EFFECT);
  ListPreference sceneMode=mPreferenceGroup.findPreference(KEY_SCENE_MODE);
  ListPreference cameraIdPref=mPreferenceGroup.findPreference(KEY_CAMERA_ID);
  ListPreference pictureSize=mPreferenceGroup.findPreference(KEY_PICTURE_SIZE);
  ListPreference exposure=mPreferenceGroup.findPreference(KEY_EXPOSURE);
  ListPreference iso=mPreferenceGroup.findPreference(KEY_ISO);
  ListPreference clearsight=mPreferenceGroup.findPreference(KEY_CLEARSIGHT);
  ListPreference monoPreview=mPreferenceGroup.findPreference(KEY_MONO_PREVIEW);
  ListPreference monoOnly=mPreferenceGroup.findPreference(KEY_MONO_ONLY);
  ListPreference mpo=mPreferenceGroup.findPreference(KEY_MPO);
  ListPreference redeyeReduction=mPreferenceGroup.findPreference(KEY_REDEYE_REDUCTION);
  ListPreference videoQuality=mPreferenceGroup.findPreference(KEY_VIDEO_QUALITY);
  ListPreference videoEncoder=mPreferenceGroup.findPreference(KEY_VIDEO_ENCODER);
  ListPreference audioEncoder=mPreferenceGroup.findPreference(KEY_AUDIO_ENCODER);
  ListPreference noiseReduction=mPreferenceGroup.findPreference(KEY_NOISE_REDUCTION);
  ListPreference faceDetection=mPreferenceGroup.findPreference(KEY_FACE_DETECTION);
  ListPreference makeup=mPreferenceGroup.findPreference(KEY_MAKEUP);
  ListPreference trackingfocus=mPreferenceGroup.findPreference(KEY_TRACKINGFOCUS);
  ListPreference hfr=mPreferenceGroup.findPreference(KEY_VIDEO_HIGH_FRAME_RATE);
  if (whiteBalance != null) {
    if (filterUnsupportedOptions(whiteBalance,getSupportedWhiteBalanceModes(cameraId))) {
      mFilteredKeys.add(whiteBalance.getKey());
    }
  }
  if (flashMode != null) {
    if (!isFlashAvailable(mCameraId)) {
      removePreference(mPreferenceGroup,KEY_FLASH_MODE);
      mFilteredKeys.add(flashMode.getKey());
    }
  }
  if (colorEffect != null) {
    if (filterUnsupportedOptions(colorEffect,getSupportedColorEffects(cameraId))) {
      mFilteredKeys.add(colorEffect.getKey());
    }
  }
  if (sceneMode != null) {
    if (filterUnsupportedOptions(sceneMode,getSupportedSceneModes(cameraId))) {
      mFilteredKeys.add(sceneMode.getKey());
    }
  }
  if (cameraIdPref != null)   buildCameraId();
  if (pictureSize != null) {
    if (filterUnsupportedOptions(pictureSize,getSupportedPictureSize(cameraId))) {
      mFilteredKeys.add(pictureSize.getKey());
    }
 else {
      if (CameraSettings.filterSimilarPictureSize(mPreferenceGroup,pictureSize)) {
        mFilteredKeys.add(pictureSize.getKey());
      }
    }
  }
  if (exposure != null)   buildExposureCompensation(cameraId);
  if (iso != null) {
    if (filterUnsupportedOptions(iso,getSupportedIso(cameraId))) {
      mFilteredKeys.add(iso.getKey());
    }
  }
  if (videoQuality != null) {
    CameraSettings.filterUnsupportedOptions(mPreferenceGroup,videoQuality,getSupportedVideoSize(cameraId));
    mVideoQualityEntryValues=videoQuality.getEntryValues();
    mVideoQualityEntries=videoQuality.getEntries();
  }
  if (!mIsMonoCameraPresent) {
    if (clearsight != null)     removePreference(mPreferenceGroup,KEY_CLEARSIGHT);
    if (monoPreview != null)     removePreference(mPreferenceGroup,KEY_MONO_PREVIEW);
    if (monoOnly != null)     removePreference(mPreferenceGroup,KEY_MONO_ONLY);
    if (mpo != null)     removePreference(mPreferenceGroup,KEY_MPO);
  }
  if (redeyeReduction != null) {
    if (filterUnsupportedOptions(redeyeReduction,getSupportedRedeyeReduction(cameraId))) {
      mFilteredKeys.add(redeyeReduction.getKey());
    }
  }
  if (videoEncoder != null) {
    if (filterUnsupportedOptions(videoEncoder,getSupportedVideoEncoders(videoEncoder.getEntryValues()))) {
      mFilteredKeys.add(videoEncoder.getKey());
    }
  }
  if (audioEncoder != null) {
    if (filterUnsupportedOptions(audioEncoder,getSupportedAudioEncoders(audioEncoder.getEntryValues()))) {
      mFilteredKeys.add(audioEncoder.getKey());
    }
  }
  if (noiseReduction != null) {
    if (filterUnsupportedOptions(noiseReduction,getSupportedNoiseReductionModes(cameraId))) {
      mFilteredKeys.add(noiseReduction.getKey());
    }
  }
  if (faceDetection != null) {
    if (!isFaceDetectionSupported(cameraId)) {
      removePreference(mPreferenceGroup,KEY_FACE_DETECTION);
    }
  }
  if (trackingfocus != null) {
    if (!TrackingFocusFrameListener.isSupportedStatic())     removePreference(mPreferenceGroup,KEY_TRACKINGFOCUS);
  }
  if (hfr != null) {
    buildHFR();
  }
  if (!mIsFrontCameraPresent || !isFacingFront(mCameraId)) {
    removePreference(mPreferenceGroup,KEY_SELFIE_FLASH);
    removePreference(mPreferenceGroup,KEY_SELFIEMIRROR);
  }
}","The original code contained a redundant and incorrect condition checking `videoQuality` with `getSupportedVideoSize(cameraId)`, which could potentially lead to unintended filtering or error. The fixed code removes this redundant block, ensuring that only the correct filtering of video quality options occurs through the `CameraSettings.filterUnsupportedOptions()` method. By eliminating the unnecessary and potentially problematic code segment, the fixed version provides a more reliable and streamlined approach to filtering camera preferences."
38129,"private void filterPreferences(int cameraId){
  ListPreference whiteBalance=mPreferenceGroup.findPreference(KEY_WHITE_BALANCE);
  ListPreference flashMode=mPreferenceGroup.findPreference(KEY_FLASH_MODE);
  ListPreference colorEffect=mPreferenceGroup.findPreference(KEY_COLOR_EFFECT);
  ListPreference sceneMode=mPreferenceGroup.findPreference(KEY_SCENE_MODE);
  ListPreference cameraIdPref=mPreferenceGroup.findPreference(KEY_CAMERA_ID);
  ListPreference pictureSize=mPreferenceGroup.findPreference(KEY_PICTURE_SIZE);
  ListPreference exposure=mPreferenceGroup.findPreference(KEY_EXPOSURE);
  ListPreference iso=mPreferenceGroup.findPreference(KEY_ISO);
  ListPreference clearsight=mPreferenceGroup.findPreference(KEY_CLEARSIGHT);
  ListPreference monoPreview=mPreferenceGroup.findPreference(KEY_MONO_PREVIEW);
  ListPreference monoOnly=mPreferenceGroup.findPreference(KEY_MONO_ONLY);
  ListPreference mpo=mPreferenceGroup.findPreference(KEY_MPO);
  ListPreference redeyeReduction=mPreferenceGroup.findPreference(KEY_REDEYE_REDUCTION);
  ListPreference videoQuality=mPreferenceGroup.findPreference(KEY_VIDEO_QUALITY);
  ListPreference videoEncoder=mPreferenceGroup.findPreference(KEY_VIDEO_ENCODER);
  ListPreference audioEncoder=mPreferenceGroup.findPreference(KEY_AUDIO_ENCODER);
  ListPreference noiseReduction=mPreferenceGroup.findPreference(KEY_NOISE_REDUCTION);
  ListPreference faceDetection=mPreferenceGroup.findPreference(KEY_FACE_DETECTION);
  ListPreference makeup=mPreferenceGroup.findPreference(KEY_MAKEUP);
  ListPreference trackingfocus=mPreferenceGroup.findPreference(KEY_TRACKINGFOCUS);
  ListPreference hfr=mPreferenceGroup.findPreference(KEY_VIDEO_HIGH_FRAME_RATE);
  if (whiteBalance != null) {
    if (filterUnsupportedOptions(whiteBalance,getSupportedWhiteBalanceModes(cameraId))) {
      mFilteredKeys.add(whiteBalance.getKey());
    }
  }
  if (flashMode != null) {
    if (!isFlashAvailable(mCameraId)) {
      removePreference(mPreferenceGroup,KEY_FLASH_MODE);
      mFilteredKeys.add(flashMode.getKey());
    }
  }
  if (colorEffect != null) {
    if (filterUnsupportedOptions(colorEffect,getSupportedColorEffects(cameraId))) {
      mFilteredKeys.add(colorEffect.getKey());
    }
  }
  if (sceneMode != null) {
    if (filterUnsupportedOptions(sceneMode,getSupportedSceneModes(cameraId))) {
      mFilteredKeys.add(sceneMode.getKey());
    }
  }
  if (cameraIdPref != null)   buildCameraId();
  if (pictureSize != null) {
    if (filterUnsupportedOptions(pictureSize,getSupportedPictureSize(cameraId))) {
      mFilteredKeys.add(pictureSize.getKey());
    }
 else {
      if (CameraSettings.filterSimilarPictureSize(mPreferenceGroup,pictureSize)) {
        mFilteredKeys.add(pictureSize.getKey());
      }
    }
  }
  if (exposure != null)   buildExposureCompensation(cameraId);
  if (iso != null) {
    if (filterUnsupportedOptions(iso,getSupportedIso(cameraId))) {
      mFilteredKeys.add(iso.getKey());
    }
  }
  if (videoQuality != null) {
    CameraSettings.filterUnsupportedOptions(mPreferenceGroup,videoQuality,getSupportedVideoSize(cameraId));
    mVideoQualityEntryValues=videoQuality.getEntryValues();
    mVideoQualityEntries=videoQuality.getEntries();
  }
  if (iso != null) {
    if (filterUnsupportedOptions(videoQuality,getSupportedVideoSize(cameraId))) {
      mFilteredKeys.add(redeyeReduction.getKey());
    }
  }
  if (!mIsMonoCameraPresent) {
    if (clearsight != null)     removePreference(mPreferenceGroup,KEY_CLEARSIGHT);
    if (monoPreview != null)     removePreference(mPreferenceGroup,KEY_MONO_PREVIEW);
    if (monoOnly != null)     removePreference(mPreferenceGroup,KEY_MONO_ONLY);
    if (mpo != null)     removePreference(mPreferenceGroup,KEY_MPO);
  }
  if (redeyeReduction != null) {
    if (filterUnsupportedOptions(redeyeReduction,getSupportedRedeyeReduction(cameraId))) {
      mFilteredKeys.add(redeyeReduction.getKey());
    }
  }
  if (videoEncoder != null) {
    if (filterUnsupportedOptions(videoEncoder,getSupportedVideoEncoders(videoEncoder.getEntryValues()))) {
      mFilteredKeys.add(videoEncoder.getKey());
    }
  }
  if (audioEncoder != null) {
    if (filterUnsupportedOptions(audioEncoder,getSupportedAudioEncoders(audioEncoder.getEntryValues()))) {
      mFilteredKeys.add(audioEncoder.getKey());
    }
  }
  if (noiseReduction != null) {
    if (filterUnsupportedOptions(noiseReduction,getSupportedNoiseReductionModes(cameraId))) {
      mFilteredKeys.add(noiseReduction.getKey());
    }
  }
  if (faceDetection != null) {
    if (!isFaceDetectionSupported(cameraId)) {
      removePreference(mPreferenceGroup,KEY_FACE_DETECTION);
    }
  }
  if (trackingfocus != null) {
    if (!TrackingFocusFrameListener.isSupportedStatic())     removePreference(mPreferenceGroup,KEY_TRACKINGFOCUS);
  }
  if (hfr != null) {
    buildHFR();
  }
  if (!mIsFrontCameraPresent || !isFacingFront(mCameraId)) {
    removePreference(mPreferenceGroup,KEY_SELFIE_FLASH);
  }
}","private void filterPreferences(int cameraId){
  ListPreference whiteBalance=mPreferenceGroup.findPreference(KEY_WHITE_BALANCE);
  ListPreference flashMode=mPreferenceGroup.findPreference(KEY_FLASH_MODE);
  ListPreference colorEffect=mPreferenceGroup.findPreference(KEY_COLOR_EFFECT);
  ListPreference sceneMode=mPreferenceGroup.findPreference(KEY_SCENE_MODE);
  ListPreference cameraIdPref=mPreferenceGroup.findPreference(KEY_CAMERA_ID);
  ListPreference pictureSize=mPreferenceGroup.findPreference(KEY_PICTURE_SIZE);
  ListPreference exposure=mPreferenceGroup.findPreference(KEY_EXPOSURE);
  ListPreference iso=mPreferenceGroup.findPreference(KEY_ISO);
  ListPreference clearsight=mPreferenceGroup.findPreference(KEY_CLEARSIGHT);
  ListPreference monoPreview=mPreferenceGroup.findPreference(KEY_MONO_PREVIEW);
  ListPreference monoOnly=mPreferenceGroup.findPreference(KEY_MONO_ONLY);
  ListPreference mpo=mPreferenceGroup.findPreference(KEY_MPO);
  ListPreference redeyeReduction=mPreferenceGroup.findPreference(KEY_REDEYE_REDUCTION);
  ListPreference videoQuality=mPreferenceGroup.findPreference(KEY_VIDEO_QUALITY);
  ListPreference videoEncoder=mPreferenceGroup.findPreference(KEY_VIDEO_ENCODER);
  ListPreference audioEncoder=mPreferenceGroup.findPreference(KEY_AUDIO_ENCODER);
  ListPreference noiseReduction=mPreferenceGroup.findPreference(KEY_NOISE_REDUCTION);
  ListPreference faceDetection=mPreferenceGroup.findPreference(KEY_FACE_DETECTION);
  ListPreference makeup=mPreferenceGroup.findPreference(KEY_MAKEUP);
  ListPreference trackingfocus=mPreferenceGroup.findPreference(KEY_TRACKINGFOCUS);
  ListPreference hfr=mPreferenceGroup.findPreference(KEY_VIDEO_HIGH_FRAME_RATE);
  if (whiteBalance != null) {
    if (filterUnsupportedOptions(whiteBalance,getSupportedWhiteBalanceModes(cameraId))) {
      mFilteredKeys.add(whiteBalance.getKey());
    }
  }
  if (flashMode != null) {
    if (!isFlashAvailable(mCameraId)) {
      removePreference(mPreferenceGroup,KEY_FLASH_MODE);
      mFilteredKeys.add(flashMode.getKey());
    }
  }
  if (colorEffect != null) {
    if (filterUnsupportedOptions(colorEffect,getSupportedColorEffects(cameraId))) {
      mFilteredKeys.add(colorEffect.getKey());
    }
  }
  if (sceneMode != null) {
    if (filterUnsupportedOptions(sceneMode,getSupportedSceneModes(cameraId))) {
      mFilteredKeys.add(sceneMode.getKey());
    }
  }
  if (cameraIdPref != null)   buildCameraId();
  if (pictureSize != null) {
    if (filterUnsupportedOptions(pictureSize,getSupportedPictureSize(cameraId))) {
      mFilteredKeys.add(pictureSize.getKey());
    }
 else {
      if (CameraSettings.filterSimilarPictureSize(mPreferenceGroup,pictureSize)) {
        mFilteredKeys.add(pictureSize.getKey());
      }
    }
  }
  if (exposure != null)   buildExposureCompensation(cameraId);
  if (iso != null) {
    if (filterUnsupportedOptions(iso,getSupportedIso(cameraId))) {
      mFilteredKeys.add(iso.getKey());
    }
  }
  if (videoQuality != null) {
    CameraSettings.filterUnsupportedOptions(mPreferenceGroup,videoQuality,getSupportedVideoSize(cameraId));
    mVideoQualityEntryValues=videoQuality.getEntryValues();
    mVideoQualityEntries=videoQuality.getEntries();
  }
  if (!mIsMonoCameraPresent) {
    if (clearsight != null)     removePreference(mPreferenceGroup,KEY_CLEARSIGHT);
    if (monoPreview != null)     removePreference(mPreferenceGroup,KEY_MONO_PREVIEW);
    if (monoOnly != null)     removePreference(mPreferenceGroup,KEY_MONO_ONLY);
    if (mpo != null)     removePreference(mPreferenceGroup,KEY_MPO);
  }
  if (redeyeReduction != null) {
    if (filterUnsupportedOptions(redeyeReduction,getSupportedRedeyeReduction(cameraId))) {
      mFilteredKeys.add(redeyeReduction.getKey());
    }
  }
  if (videoEncoder != null) {
    if (filterUnsupportedOptions(videoEncoder,getSupportedVideoEncoders(videoEncoder.getEntryValues()))) {
      mFilteredKeys.add(videoEncoder.getKey());
    }
  }
  if (audioEncoder != null) {
    if (filterUnsupportedOptions(audioEncoder,getSupportedAudioEncoders(audioEncoder.getEntryValues()))) {
      mFilteredKeys.add(audioEncoder.getKey());
    }
  }
  if (noiseReduction != null) {
    if (filterUnsupportedOptions(noiseReduction,getSupportedNoiseReductionModes(cameraId))) {
      mFilteredKeys.add(noiseReduction.getKey());
    }
  }
  if (faceDetection != null) {
    if (!isFaceDetectionSupported(cameraId)) {
      removePreference(mPreferenceGroup,KEY_FACE_DETECTION);
    }
  }
  if (trackingfocus != null) {
    if (!TrackingFocusFrameListener.isSupportedStatic())     removePreference(mPreferenceGroup,KEY_TRACKINGFOCUS);
  }
  if (hfr != null) {
    buildHFR();
  }
  if (!mIsFrontCameraPresent || !isFacingFront(mCameraId)) {
    removePreference(mPreferenceGroup,KEY_SELFIE_FLASH);
  }
}","The original code contained a redundant and incorrect condition for video quality that could lead to unexpected behavior with redeye reduction. The fixed code removes this erroneous block, correctly filtering only video quality options without introducing unrelated logic. This simplification ensures more reliable preference filtering and prevents potential runtime errors by eliminating the misplaced conditional statement."
38130,"private void initializePreferences(){
  ListPreference pref=(ListPreference)findPreference(SettingsManager.KEY_EXPOSURE);
  pref.setEntries(mSettingsManager.getExposureCompensationEntries());
  pref.setEntryValues(mSettingsManager.getExposureCompensationEntryValues());
  Map<String,SettingsManager.Values> map=mSettingsManager.getValuesMap();
  Set<Map.Entry<String,SettingsManager.Values>> set=map.entrySet();
  for (  Map.Entry<String,SettingsManager.Values> entry : set) {
    String key=entry.getKey();
    Preference p=findPreference(key);
    if (p == null)     continue;
    SettingsManager.Values values=entry.getValue();
    boolean disabled=values.overriddenValue != null;
    String value=disabled ? values.overriddenValue : values.value;
    if (p instanceof SwitchPreference) {
      ((SwitchPreference)p).setChecked(isOn(value));
    }
 else     if (p instanceof ListPreference) {
      ((ListPreference)p).setValue(value);
    }
    if (disabled)     p.setEnabled(false);
  }
  try {
    String versionName=getPackageManager().getPackageInfo(getPackageName(),0).versionName;
    int index=versionName.indexOf(' ');
    versionName=versionName.substring(0,index);
    findPreference(""String_Node_Str"").setSummary(versionName);
  }
 catch (  PackageManager.NameNotFoundException e) {
    e.printStackTrace();
  }
}","private void initializePreferences(){
  updatePreference(SettingsManager.KEY_PICTURE_SIZE);
  updatePreference(SettingsManager.KEY_VIDEO_QUALITY);
  updatePreference(SettingsManager.KEY_EXPOSURE);
  updatePreference(SettingsManager.KEY_VIDEO_HIGH_FRAME_RATE);
  Map<String,SettingsManager.Values> map=mSettingsManager.getValuesMap();
  Set<Map.Entry<String,SettingsManager.Values>> set=map.entrySet();
  for (  Map.Entry<String,SettingsManager.Values> entry : set) {
    String key=entry.getKey();
    Preference p=findPreference(key);
    if (p == null)     continue;
    SettingsManager.Values values=entry.getValue();
    boolean disabled=values.overriddenValue != null;
    String value=disabled ? values.overriddenValue : values.value;
    if (p instanceof SwitchPreference) {
      ((SwitchPreference)p).setChecked(isOn(value));
    }
 else     if (p instanceof ListPreference) {
      ((ListPreference)p).setValue(value);
    }
    if (disabled)     p.setEnabled(false);
  }
  try {
    String versionName=getPackageManager().getPackageInfo(getPackageName(),0).versionName;
    int index=versionName.indexOf(' ');
    versionName=versionName.substring(0,index);
    findPreference(""String_Node_Str"").setSummary(versionName);
  }
 catch (  PackageManager.NameNotFoundException e) {
    e.printStackTrace();
  }
}","The original code lacked explicit initialization for specific preference keys like picture size and video quality. The fixed code introduces an `updatePreference()` method call for multiple key settings, ensuring comprehensive preference configuration before iterating through the settings map. This approach provides more robust and predictable preference setup, preventing potential uninitialized or inconsistent preference states across different settings."
38131,"private void filterPreferences(){
  String[] categories={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Set<String> set=mSettingsManager.getFilteredKeys();
  if (!mDeveloperMenuEnabled) {
    set.add(SettingsManager.KEY_MONO_PREVIEW);
    set.add(SettingsManager.KEY_MONO_ONLY);
    set.add(SettingsManager.KEY_CLEARSIGHT);
  }
  for (  String key : set) {
    Preference p=findPreference(key);
    if (p == null)     continue;
    for (int i=0; i < categories.length; i++) {
      PreferenceGroup group=(PreferenceGroup)findPreference(categories[i]);
      if (group.removePreference(p))       break;
    }
  }
  ListPreference pictureSize=(ListPreference)findPreference(SettingsManager.KEY_PICTURE_SIZE);
  if (pictureSize != null) {
    pictureSize.setEntryValues(mSettingsManager.getEntryValues(SettingsManager.KEY_PICTURE_SIZE));
    pictureSize.setEntries(mSettingsManager.getEntries(SettingsManager.KEY_PICTURE_SIZE));
  }
}","private void filterPreferences(){
  String[] categories={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Set<String> set=mSettingsManager.getFilteredKeys();
  if (!mDeveloperMenuEnabled) {
    set.add(SettingsManager.KEY_MONO_PREVIEW);
    set.add(SettingsManager.KEY_MONO_ONLY);
    set.add(SettingsManager.KEY_CLEARSIGHT);
  }
  for (  String key : set) {
    Preference p=findPreference(key);
    if (p == null)     continue;
    for (int i=0; i < categories.length; i++) {
      PreferenceGroup group=(PreferenceGroup)findPreference(categories[i]);
      if (group.removePreference(p))       break;
    }
  }
}","The original code unnecessarily added a ListPreference modification after the preference filtering loop, which was unrelated to the filtering process and potentially redundant. The fixed code removes the ListPreference configuration, focusing solely on filtering preferences based on developer menu settings. By eliminating the extraneous code, the method now has a clearer, more focused responsibility of removing specific preferences when the developer menu is disabled."
38132,"@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  Preference p=findPreference(key);
  if (p == null)   return;
  String value;
  if (p instanceof SwitchPreference) {
    boolean checked=((SwitchPreference)p).isChecked();
    value=checked ? ""String_Node_Str"" : ""String_Node_Str"";
    mSettingsManager.setValue(key,value);
  }
 else   if (p instanceof ListPreference) {
    value=((ListPreference)p).getValue();
    mSettingsManager.setValue(key,value);
  }
}","@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  Preference p=findPreference(key);
  if (p == null)   return;
  String value;
  if (p instanceof SwitchPreference) {
    boolean checked=((SwitchPreference)p).isChecked();
    value=checked ? ""String_Node_Str"" : ""String_Node_Str"";
    mSettingsManager.setValue(key,value);
  }
 else   if (p instanceof ListPreference) {
    value=((ListPreference)p).getValue();
    mSettingsManager.setValue(key,value);
  }
  if (key.equals(SettingsManager.KEY_VIDEO_QUALITY)) {
    updatePreference(SettingsManager.KEY_VIDEO_HIGH_FRAME_RATE);
  }
}","The original code lacked handling for specific preference changes, particularly for video quality settings. The fixed code adds a conditional check for the video quality key, which triggers an update for the high frame rate preference when changed. This enhancement ensures more comprehensive preference management and allows dynamic updates of related settings based on user selections."
38133,"@Override public void onSettingChanged(ListPreference pref){
  String key=pref.getKey();
  if (pref.getKey().equals(KEY_VIDEO_QUALITY))   buildHFR();
  List changed=checkDependencyAndUpdate(key);
  if (changed == null)   return;
  notifyListeners(changed);
}","@Override public void onSettingChanged(ListPreference pref){
  String key=pref.getKey();
  List changed=checkDependencyAndUpdate(key);
  if (changed == null)   return;
  if (pref.getKey().equals(KEY_VIDEO_QUALITY))   buildHFR();
  notifyListeners(changed);
}","The original code calls buildHFR() before checking and updating dependencies, which could lead to inconsistent state or premature execution of method. The fixed code moves the dependency check and update before the buildHFR() call, ensuring that all related settings are properly validated and synchronized first. This reordering prevents potential race conditions and guarantees that the high frame rate (HFR) build occurs only after the settings have been correctly processed and updated."
38134,"private void buildHFR(){
  ListPreference hfrPref=mPreferenceGroup.findPreference(KEY_VIDEO_HIGH_FRAME_RATE);
  Size[] highSpeedVideoSize=getSupportedHighSpeedVideoSize(mCameraId);
  if (highSpeedVideoSize.length == 0) {
    CharSequence[] entryValues=new CharSequence[1];
    CharSequence[] entries=new CharSequence[1];
    entryValues[0]=""String_Node_Str"";
    entries[0]=""String_Node_Str"";
    hfrPref.setEntryValues(entryValues);
    hfrPref.setEntries(entries);
    hfrPref.setValueIndex(0);
    return;
  }
  ListPreference videoQuality=mPreferenceGroup.findPreference(KEY_VIDEO_QUALITY);
  String video=videoQuality.getValue();
  int x=video.indexOf('x');
  Size videoSize=new Size(Integer.parseInt(video.substring(0,x)),Integer.parseInt(video.substring(x + 1)));
  boolean found=false;
  for (  Size s : highSpeedVideoSize) {
    if (videoSize.equals(s)) {
      found=true;
      break;
    }
  }
  if (!found) {
    CharSequence[] entryValues=new CharSequence[1];
    CharSequence[] entries=new CharSequence[1];
    entryValues[0]=""String_Node_Str"";
    entries[0]=""String_Node_Str"";
    hfrPref.setEntryValues(entryValues);
    hfrPref.setEntries(entries);
    hfrPref.setValueIndex(0);
    return;
  }
  Range[] range=getSupportedHighSpeedVideoFPSRange(mCameraId,highSpeedVideoSize[0]);
  ArrayList<Range> list=new ArrayList<>();
  for (  Range r : range) {
    if (r.getLower() == r.getUpper()) {
      list.add(r);
    }
  }
  if (list.size() == 0) {
    CharSequence[] entryValues=new CharSequence[1];
    CharSequence[] entries=new CharSequence[1];
    entryValues[0]=""String_Node_Str"";
    entries[0]=""String_Node_Str"";
    hfrPref.setEntryValues(entryValues);
    hfrPref.setEntries(entries);
    hfrPref.setValueIndex(0);
    return;
  }
  CharSequence[] entryValues=new CharSequence[list.size() * 2 + 1];
  CharSequence[] entries=new CharSequence[list.size() * 2 + 1];
  entryValues[0]=""String_Node_Str"";
  entries[0]=""String_Node_Str"";
  int i=1;
  for (  Range r : list) {
    entries[i]=""String_Node_Str"" + r.getLower();
    entryValues[i]=""String_Node_Str"" + r.getLower();
    i++;
  }
  for (  Range r : list) {
    entries[i]=""String_Node_Str"" + r.getLower();
    entryValues[i]=""String_Node_Str"" + r.getLower();
    i++;
  }
  hfrPref.setEntryValues(entryValues);
  hfrPref.setEntries(entries);
}","private void buildHFR(){
  ListPreference hfrPref=mPreferenceGroup.findPreference(KEY_VIDEO_HIGH_FRAME_RATE);
  Size[] highSpeedVideoSize=getSupportedHighSpeedVideoSize(mCameraId);
  if (highSpeedVideoSize.length == 0) {
    CharSequence[] entryValues=new CharSequence[1];
    CharSequence[] entries=new CharSequence[1];
    entryValues[0]=""String_Node_Str"";
    entries[0]=""String_Node_Str"";
    hfrPref.setEntryValues(entryValues);
    hfrPref.setEntries(entries);
    setValueIndex(KEY_VIDEO_HIGH_FRAME_RATE,0);
    return;
  }
  ListPreference videoQuality=mPreferenceGroup.findPreference(KEY_VIDEO_QUALITY);
  String video=videoQuality.getValue();
  int x=video.indexOf('x');
  Size videoSize=new Size(Integer.parseInt(video.substring(0,x)),Integer.parseInt(video.substring(x + 1)));
  boolean found=false;
  for (  Size s : highSpeedVideoSize) {
    if (videoSize.equals(s)) {
      found=true;
      break;
    }
  }
  if (!found) {
    CharSequence[] entryValues=new CharSequence[1];
    CharSequence[] entries=new CharSequence[1];
    entryValues[0]=""String_Node_Str"";
    entries[0]=""String_Node_Str"";
    hfrPref.setEntryValues(entryValues);
    hfrPref.setEntries(entries);
    setValueIndex(KEY_VIDEO_HIGH_FRAME_RATE,0);
    return;
  }
  Range[] range=getSupportedHighSpeedVideoFPSRange(mCameraId,videoSize);
  ArrayList<Range> list=new ArrayList<>();
  for (  Range r : range) {
    if (r.getLower() == r.getUpper()) {
      list.add(r);
    }
  }
  if (list.size() == 0) {
    CharSequence[] entryValues=new CharSequence[1];
    CharSequence[] entries=new CharSequence[1];
    entryValues[0]=""String_Node_Str"";
    entries[0]=""String_Node_Str"";
    hfrPref.setEntryValues(entryValues);
    hfrPref.setEntries(entries);
    setValueIndex(KEY_VIDEO_HIGH_FRAME_RATE,0);
    return;
  }
  CharSequence[] entryValues=new CharSequence[list.size() * 2 + 1];
  CharSequence[] entries=new CharSequence[list.size() * 2 + 1];
  entryValues[0]=""String_Node_Str"";
  entries[0]=""String_Node_Str"";
  int i=1;
  for (  Range r : list) {
    entries[i]=""String_Node_Str"" + r.getLower();
    entryValues[i]=""String_Node_Str"" + r.getLower();
    i++;
  }
  for (  Range r : list) {
    entries[i]=""String_Node_Str"" + r.getLower();
    entryValues[i]=""String_Node_Str"" + r.getLower();
    i++;
  }
  hfrPref.setEntryValues(entryValues);
  hfrPref.setEntries(entries);
  int index=getValueIndex(KEY_VIDEO_HIGH_FRAME_RATE);
  if (index == -1) {
    setValueIndex(KEY_VIDEO_HIGH_FRAME_RATE,0);
  }
}","The original code had potential null pointer and index out-of-bounds risks, particularly when handling video size and frame rate ranges. The fixed code introduces safer parameter handling by using `videoSize` instead of hardcoded `highSpeedVideoSize[0]` and adds a value index validation mechanism with `setValueIndex()` and `getValueIndex()` methods. These modifications enhance robustness by ensuring proper preference configuration and preventing potential runtime exceptions during high frame rate video settings initialization."
38135,"private void updateMapAndNotify(ListPreference pref){
  String key=pref.getKey();
  List changed=checkDependencyAndUpdate(key);
  if (changed == null)   return;
  notifyListeners(changed);
}","private void updateMapAndNotify(ListPreference pref){
  String key=pref.getKey();
  List changed=checkDependencyAndUpdate(key);
  if (changed == null)   return;
  if (pref.getKey().equals(KEY_VIDEO_QUALITY))   buildHFR();
  notifyListeners(changed);
}","The original code lacked a specific action when the video quality preference key was selected, potentially missing an important initialization step. The fixed code adds a conditional check to call `buildHFR()` when the video quality key is detected, ensuring proper high frame rate (HFR) configuration. This enhancement guarantees that critical video-related setup occurs at the right moment, improving the preference management workflow and preventing potential configuration oversights."
38136,"private void captureStillPicture(final int id){
  Log.d(TAG,""String_Node_Str"" + id);
  mIsRefocus=false;
  CameraCaptureSession.CaptureCallback captureCallback=new CameraCaptureSession.CaptureCallback(){
    @Override public void onCaptureCompleted(    CameraCaptureSession session,    CaptureRequest request,    TotalCaptureResult result){
      Log.d(TAG,""String_Node_Str"" + id);
    }
    @Override public void onCaptureFailed(    CameraCaptureSession session,    CaptureRequest request,    CaptureFailure result){
      Log.d(TAG,""String_Node_Str"" + id);
    }
    @Override public void onCaptureSequenceCompleted(    CameraCaptureSession session,    int sequenceId,    long frameNumber){
      Log.d(TAG,""String_Node_Str"" + id);
      unlockFocus(id);
    }
  }
;
  try {
    if (null == mActivity || null == mCameraDevice[id]) {
      warningToast(""String_Node_Str"");
      return;
    }
    checkAndPlayShutterSound(id);
    final boolean csEnabled=isClearSightOn();
    CaptureRequest.Builder captureBuilder;
    if (csEnabled) {
      captureBuilder=ClearSightImageProcessor.getInstance().createCaptureRequest(mCameraDevice[id]);
    }
 else {
      captureBuilder=mCameraDevice[id].createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
    }
    Location location=mLocationManager.getCurrentLocation();
    if (location != null) {
      Log.d(TAG,""String_Node_Str"" + location.toString());
      location.setTime(location.getTime() / 1000);
      captureBuilder.set(CaptureRequest.JPEG_GPS_LOCATION,location);
    }
 else {
      Log.d(TAG,""String_Node_Str"" + getRecordLocation());
    }
    captureBuilder.set(CaptureRequest.JPEG_ORIENTATION,CameraUtil.getJpegRotation(id,mOrientation));
    captureBuilder.set(CaptureRequest.CONTROL_MODE,CaptureRequest.CONTROL_MODE_AUTO);
    addPreviewSurface(captureBuilder,null,id);
    captureBuilder.set(CaptureRequest.CONTROL_AF_MODE,mControlAFMode);
    captureBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,CaptureRequest.CONTROL_AF_TRIGGER_IDLE);
    applySettingsForLockExposure(captureBuilder,id);
    applySettingsForCapture(captureBuilder,id);
    if (csEnabled) {
      ClearSightImageProcessor.getInstance().capture(id == BAYER_ID,mCaptureSession[id],captureBuilder,mCaptureCallbackHandler);
    }
 else     if (id == getMainCameraId() && mPostProcessor.isFilterOn()) {
      mCaptureSession[id].stopRepeating();
      captureBuilder.addTarget(mImageReader[id].getSurface());
      if (mPostProcessor.isManualMode()) {
        mPostProcessor.manualCapture(captureBuilder,mCaptureSession[id],captureCallback,mCaptureCallbackHandler);
      }
 else {
        List<CaptureRequest> captureList=mPostProcessor.setRequiredImages(captureBuilder);
        mCaptureSession[id].captureBurst(captureList,captureCallback,mCaptureCallbackHandler);
      }
    }
 else {
      captureBuilder.addTarget(mImageReader[id].getSurface());
      mCaptureSession[id].stopRepeating();
      if (mLongshotActive) {
        Log.d(TAG,""String_Node_Str"" + id);
        List<CaptureRequest> burstList=new ArrayList<>();
        for (int i=0; i < PersistUtil.getLongshotShotLimit(); i++) {
          burstList.add(captureBuilder.build());
        }
        mCaptureSession[id].captureBurst(burstList,new CameraCaptureSession.CaptureCallback(){
          @Override public void onCaptureCompleted(          CameraCaptureSession session,          CaptureRequest request,          TotalCaptureResult result){
            Log.d(TAG,""String_Node_Str"" + id);
            if (mLongshotActive) {
              mActivity.runOnUiThread(new Runnable(){
                @Override public void run(){
                  mUI.doShutterAnimation();
                }
              }
);
            }
          }
          @Override public void onCaptureFailed(          CameraCaptureSession session,          CaptureRequest request,          CaptureFailure result){
            Log.d(TAG,""String_Node_Str"" + id);
            if (mLongshotActive) {
              mActivity.runOnUiThread(new Runnable(){
                @Override public void run(){
                  mUI.doShutterAnimation();
                }
              }
);
            }
          }
          @Override public void onCaptureSequenceCompleted(          CameraCaptureSession session,          int sequenceId,          long frameNumber){
            Log.d(TAG,""String_Node_Str"" + id);
            mLongshotActive=false;
            unlockFocus(id);
          }
        }
,mCaptureCallbackHandler);
      }
 else {
        if (isMpoOn()) {
          mCaptureStartTime=System.currentTimeMillis();
          mMpoSaveHandler.obtainMessage(MpoSaveHandler.MSG_CONFIGURE,Long.valueOf(mCaptureStartTime)).sendToTarget();
        }
        mCaptureSession[id].capture(captureBuilder.build(),captureCallback,mCaptureCallbackHandler);
      }
    }
  }
 catch (  CameraAccessException e) {
    Log.d(TAG,""String_Node_Str"");
    e.printStackTrace();
  }
}","private void captureStillPicture(final int id){
  Log.d(TAG,""String_Node_Str"" + id);
  mIsRefocus=false;
  CameraCaptureSession.CaptureCallback captureCallback=new CameraCaptureSession.CaptureCallback(){
    @Override public void onCaptureCompleted(    CameraCaptureSession session,    CaptureRequest request,    TotalCaptureResult result){
      Log.d(TAG,""String_Node_Str"" + id);
    }
    @Override public void onCaptureFailed(    CameraCaptureSession session,    CaptureRequest request,    CaptureFailure result){
      Log.d(TAG,""String_Node_Str"" + id);
    }
    @Override public void onCaptureSequenceCompleted(    CameraCaptureSession session,    int sequenceId,    long frameNumber){
      Log.d(TAG,""String_Node_Str"" + id);
      unlockFocus(id);
    }
  }
;
  try {
    if (null == mActivity || null == mCameraDevice[id]) {
      warningToast(""String_Node_Str"");
      return;
    }
    final boolean csEnabled=isClearSightOn();
    CaptureRequest.Builder captureBuilder;
    if (csEnabled) {
      captureBuilder=ClearSightImageProcessor.getInstance().createCaptureRequest(mCameraDevice[id]);
    }
 else {
      captureBuilder=mCameraDevice[id].createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
    }
    Location location=mLocationManager.getCurrentLocation();
    if (location != null) {
      Log.d(TAG,""String_Node_Str"" + location.toString());
      location.setTime(location.getTime() / 1000);
      captureBuilder.set(CaptureRequest.JPEG_GPS_LOCATION,location);
    }
 else {
      Log.d(TAG,""String_Node_Str"" + getRecordLocation());
    }
    captureBuilder.set(CaptureRequest.JPEG_ORIENTATION,CameraUtil.getJpegRotation(id,mOrientation));
    captureBuilder.set(CaptureRequest.CONTROL_MODE,CaptureRequest.CONTROL_MODE_AUTO);
    addPreviewSurface(captureBuilder,null,id);
    captureBuilder.set(CaptureRequest.CONTROL_AF_MODE,mControlAFMode);
    captureBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,CaptureRequest.CONTROL_AF_TRIGGER_IDLE);
    applySettingsForLockExposure(captureBuilder,id);
    applySettingsForCapture(captureBuilder,id);
    if (csEnabled) {
      checkAndPlayShutterSound(id);
      ClearSightImageProcessor.getInstance().capture(id == BAYER_ID,mCaptureSession[id],captureBuilder,mCaptureCallbackHandler);
    }
 else     if (id == getMainCameraId() && mPostProcessor.isFilterOn()) {
      checkAndPlayShutterSound(id);
      mCaptureSession[id].stopRepeating();
      captureBuilder.addTarget(mImageReader[id].getSurface());
      if (mPostProcessor.isManualMode()) {
        mPostProcessor.manualCapture(captureBuilder,mCaptureSession[id],captureCallback,mCaptureCallbackHandler);
      }
 else {
        List<CaptureRequest> captureList=mPostProcessor.setRequiredImages(captureBuilder);
        mCaptureSession[id].captureBurst(captureList,captureCallback,mCaptureCallbackHandler);
      }
    }
 else {
      captureBuilder.addTarget(mImageReader[id].getSurface());
      mCaptureSession[id].stopRepeating();
      if (mLongshotActive) {
        Log.d(TAG,""String_Node_Str"" + id);
        List<CaptureRequest> burstList=new ArrayList<>();
        for (int i=0; i < PersistUtil.getLongshotShotLimit(); i++) {
          burstList.add(captureBuilder.build());
        }
        mCaptureSession[id].captureBurst(burstList,new CameraCaptureSession.CaptureCallback(){
          @Override public void onCaptureCompleted(          CameraCaptureSession session,          CaptureRequest request,          TotalCaptureResult result){
            Log.d(TAG,""String_Node_Str"" + id);
            if (mLongshotActive) {
              checkAndPlayShutterSound(id);
              mActivity.runOnUiThread(new Runnable(){
                @Override public void run(){
                  mUI.doShutterAnimation();
                }
              }
);
            }
          }
          @Override public void onCaptureFailed(          CameraCaptureSession session,          CaptureRequest request,          CaptureFailure result){
            Log.d(TAG,""String_Node_Str"" + id);
            if (mLongshotActive) {
              mActivity.runOnUiThread(new Runnable(){
                @Override public void run(){
                  mUI.doShutterAnimation();
                }
              }
);
            }
          }
          @Override public void onCaptureSequenceCompleted(          CameraCaptureSession session,          int sequenceId,          long frameNumber){
            Log.d(TAG,""String_Node_Str"" + id);
            mLongshotActive=false;
            unlockFocus(id);
          }
        }
,mCaptureCallbackHandler);
      }
 else {
        checkAndPlayShutterSound(id);
        if (isMpoOn()) {
          mCaptureStartTime=System.currentTimeMillis();
          mMpoSaveHandler.obtainMessage(MpoSaveHandler.MSG_CONFIGURE,Long.valueOf(mCaptureStartTime)).sendToTarget();
        }
        mCaptureSession[id].capture(captureBuilder.build(),captureCallback,mCaptureCallbackHandler);
      }
    }
  }
 catch (  CameraAccessException e) {
    Log.d(TAG,""String_Node_Str"");
    e.printStackTrace();
  }
}","The original code inconsistently placed the `checkAndPlayShutterSound(id)` method, potentially causing audio timing issues during different capture scenarios. In the fixed code, `checkAndPlayShutterSound(id)` is strategically added before each capture path, ensuring the shutter sound plays consistently across ClearSight, filter, and standard capture modes. This modification guarantees a uniform user experience by synchronizing audio feedback with image capture across all camera capture scenarios."
38137,"@Override public void onZoomChanged(float requestedZoom){
  mZoomValue=requestedZoom;
  if (isBackCamera()) {
switch (getCameraMode()) {
case DUAL_MODE:
      applyZoomAndUpdate(BAYER_ID);
    applyZoomAndUpdate(MONO_ID);
  break;
case BAYER_MODE:
applyZoomAndUpdate(BAYER_ID);
break;
case MONO_MODE:
applyZoomAndUpdate(MONO_ID);
break;
}
}
 else {
applyZoomAndUpdate(FRONT_ID);
}
}","@Override public void onZoomChanged(float requestedZoom){
  mZoomValue=requestedZoom;
  if (isBackCamera()) {
switch (getCameraMode()) {
case DUAL_MODE:
      applyZoomAndUpdate(BAYER_ID);
    applyZoomAndUpdate(MONO_ID);
  break;
case BAYER_MODE:
applyZoomAndUpdate(BAYER_ID);
break;
case MONO_MODE:
applyZoomAndUpdate(MONO_ID);
break;
}
}
 else {
applyZoomAndUpdate(FRONT_ID);
}
mUI.updateFaceViewCameraBound(mCropRegion[getMainCameraId()]);
}","The original code lacked a crucial UI update step after applying zoom changes, potentially leaving the user interface out of sync with camera settings. The fixed code adds `mUI.updateFaceViewCameraBound(mCropRegion[getMainCameraId()])` to synchronize the UI with the current camera crop region after zoom modifications. This ensures that the user interface accurately reflects the camera's zoom state, providing a more consistent and responsive user experience."
38138,"private void setUpMediaRecorder(int cameraId) throws IOException {
  Log.d(TAG,""String_Node_Str"");
  String videoSize=mSettingsManager.getValue(SettingsManager.KEY_VIDEO_QUALITY);
  int size=CameraSettings.VIDEO_QUALITY_TABLE.get(videoSize);
  if (mCaptureTimeLapse) {
    size=CameraSettings.getTimeLapseQualityFor(size);
  }
  updateHFRSetting();
  boolean hfr=mHighSpeedCapture && !mHighSpeedCaptureSlowMode;
  mProfile=CamcorderProfile.get(cameraId,size);
  int videoEncoder=SettingTranslation.getVideoEncoder(mSettingsManager.getValue(SettingsManager.KEY_VIDEO_ENCODER));
  int audioEncoder=SettingTranslation.getAudioEncoder(mSettingsManager.getValue(SettingsManager.KEY_AUDIO_ENCODER));
  int outputFormat=MediaRecorder.OutputFormat.MPEG_4;
  if (!mCaptureTimeLapse && !hfr) {
    mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
  }
  mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);
  mMediaRecorder.setOutputFormat(mProfile.fileFormat);
  String fileName=generateVideoFilename(outputFormat);
  Log.v(TAG,""String_Node_Str"" + fileName);
  mMediaRecorder.setOutputFile(fileName);
  mMediaRecorder.setVideoFrameRate(mProfile.videoFrameRate);
  mMediaRecorder.setVideoEncodingBitRate(mProfile.videoBitRate);
  if (mFrameProcessor.isFrameFilterEnabled()) {
    mMediaRecorder.setVideoSize(mProfile.videoFrameHeight,mProfile.videoFrameWidth);
  }
 else {
    mMediaRecorder.setVideoSize(mProfile.videoFrameWidth,mProfile.videoFrameHeight);
  }
  mMediaRecorder.setVideoEncoder(videoEncoder);
  if (!mCaptureTimeLapse && !hfr) {
    mMediaRecorder.setAudioEncodingBitRate(mProfile.audioBitRate);
    mMediaRecorder.setAudioChannels(mProfile.audioChannels);
    mMediaRecorder.setAudioSamplingRate(mProfile.audioSampleRate);
    mMediaRecorder.setAudioEncoder(audioEncoder);
  }
  mMediaRecorder.setMaxDuration(mMaxVideoDurationInMs);
  if (mCaptureTimeLapse) {
    double fps=1000 / (double)mTimeBetweenTimeLapseFrameCaptureMs;
    mMediaRecorder.setCaptureRate(fps);
  }
 else   if (mHighSpeedCapture) {
    mHighSpeedFPSRange=new Range(mHighSpeedCaptureRate,mHighSpeedCaptureRate);
    int fps=(int)mHighSpeedFPSRange.getUpper();
    mMediaRecorder.setCaptureRate(fps);
    if (mHighSpeedCaptureSlowMode) {
      mMediaRecorder.setVideoFrameRate(30);
    }
 else {
      mMediaRecorder.setVideoFrameRate(fps);
    }
    int scaledBitrate=mProfile.videoBitRate * fps / mProfile.videoFrameRate;
    Log.i(TAG,""String_Node_Str"" + scaledBitrate);
    mMediaRecorder.setVideoEncodingBitRate(scaledBitrate);
  }
  Location loc=mLocationManager.getCurrentLocation();
  if (loc != null) {
    mMediaRecorder.setLocation((float)loc.getLatitude(),(float)loc.getLongitude());
  }
  int rotation=CameraUtil.getJpegRotation(cameraId,mOrientation);
  String videoRotation=mSettingsManager.getValue(SettingsManager.KEY_VIDEO_ROTATION);
  if (videoRotation != null) {
    rotation+=Integer.parseInt(videoRotation);
    rotation=rotation % 360;
  }
  if (mFrameProcessor.isFrameFilterEnabled()) {
    mMediaRecorder.setOrientationHint(0);
  }
 else {
    mMediaRecorder.setOrientationHint(rotation);
  }
  mMediaRecorder.prepare();
}","private void setUpMediaRecorder(int cameraId) throws IOException {
  Log.d(TAG,""String_Node_Str"");
  String videoSize=mSettingsManager.getValue(SettingsManager.KEY_VIDEO_QUALITY);
  int size=CameraSettings.VIDEO_QUALITY_TABLE.get(videoSize);
  if (mCaptureTimeLapse) {
    size=CameraSettings.getTimeLapseQualityFor(size);
  }
  updateHFRSetting();
  boolean hfr=mHighSpeedCapture && !mHighSpeedCaptureSlowMode;
  mProfile=CamcorderProfile.get(cameraId,size);
  int videoEncoder=SettingTranslation.getVideoEncoder(mSettingsManager.getValue(SettingsManager.KEY_VIDEO_ENCODER));
  int audioEncoder=SettingTranslation.getAudioEncoder(mSettingsManager.getValue(SettingsManager.KEY_AUDIO_ENCODER));
  int outputFormat=MediaRecorder.OutputFormat.MPEG_4;
  if (!mCaptureTimeLapse && !hfr) {
    mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
  }
  mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);
  mMediaRecorder.setOutputFormat(mProfile.fileFormat);
  String fileName=generateVideoFilename(outputFormat);
  Log.v(TAG,""String_Node_Str"" + fileName);
  mMediaRecorder.setOutputFile(fileName);
  mMediaRecorder.setVideoFrameRate(mProfile.videoFrameRate);
  mMediaRecorder.setVideoEncodingBitRate(mProfile.videoBitRate);
  if (mFrameProcessor.isFrameFilterEnabled()) {
    mMediaRecorder.setVideoSize(mProfile.videoFrameHeight,mProfile.videoFrameWidth);
  }
 else {
    mMediaRecorder.setVideoSize(mProfile.videoFrameWidth,mProfile.videoFrameHeight);
  }
  mMediaRecorder.setVideoEncoder(videoEncoder);
  if (!mCaptureTimeLapse && !hfr) {
    mMediaRecorder.setAudioEncodingBitRate(mProfile.audioBitRate);
    mMediaRecorder.setAudioChannels(mProfile.audioChannels);
    mMediaRecorder.setAudioSamplingRate(mProfile.audioSampleRate);
    mMediaRecorder.setAudioEncoder(audioEncoder);
  }
  mMediaRecorder.setMaxDuration(mMaxVideoDurationInMs);
  if (mCaptureTimeLapse) {
    double fps=1000 / (double)mTimeBetweenTimeLapseFrameCaptureMs;
    mMediaRecorder.setCaptureRate(fps);
  }
 else   if (mHighSpeedCapture) {
    mHighSpeedFPSRange=new Range(mHighSpeedCaptureRate,mHighSpeedCaptureRate);
    int fps=(int)mHighSpeedFPSRange.getUpper();
    mMediaRecorder.setCaptureRate(fps);
    if (mHighSpeedCaptureSlowMode) {
      mMediaRecorder.setVideoFrameRate(30);
    }
 else {
      mMediaRecorder.setVideoFrameRate(fps);
    }
    int scaledBitrate=mProfile.videoBitRate * (fps / mProfile.videoFrameRate);
    Log.i(TAG,""String_Node_Str"" + scaledBitrate);
    mMediaRecorder.setVideoEncodingBitRate(scaledBitrate);
  }
  Location loc=mLocationManager.getCurrentLocation();
  if (loc != null) {
    mMediaRecorder.setLocation((float)loc.getLatitude(),(float)loc.getLongitude());
  }
  int rotation=CameraUtil.getJpegRotation(cameraId,mOrientation);
  String videoRotation=mSettingsManager.getValue(SettingsManager.KEY_VIDEO_ROTATION);
  if (videoRotation != null) {
    rotation+=Integer.parseInt(videoRotation);
    rotation=rotation % 360;
  }
  if (mFrameProcessor.isFrameFilterEnabled()) {
    mMediaRecorder.setOrientationHint(0);
  }
 else {
    mMediaRecorder.setOrientationHint(rotation);
  }
  mMediaRecorder.prepare();
}","The original code had an integer division issue when calculating the scaled bitrate, which could lead to incorrect video encoding settings. In the fixed code, the bitrate calculation was modified to use parentheses `(fps / mProfile.videoFrameRate)` to ensure proper mathematical precedence and accurate bitrate scaling. This correction ensures more precise video quality and bitrate adaptation during high-speed video capture, preventing potential performance or encoding problems."
38139,"private void checkSelfieFlashAndTakePicture(){
  String value=mSettingsManager.getValue(SettingsManager.KEY_SELFIE_FLASH);
  if (value == null) {
    takePicture();
    return;
  }
  if (value.equals(""String_Node_Str"") && getMainCameraId() == FRONT_ID) {
    mUI.startSelfieFlash();
    if (selfieThread == null) {
      selfieThread=new SelfieThread();
      selfieThread.start();
    }
  }
 else {
    takePicture();
  }
}","private void checkSelfieFlashAndTakePicture(){
  if (isSelfieFlash()) {
    mUI.startSelfieFlash();
    if (selfieThread == null) {
      selfieThread=new SelfieThread();
      selfieThread.start();
    }
  }
 else {
    takePicture();
  }
}","The original code had complex, hardcoded string comparison and redundant null checks that made the logic fragile and less readable. The fixed code introduces a cleaner `isSelfieFlash()` method, which likely encapsulates the conditions for selfie flash more robustly, removing direct string comparisons and simplifying the conditional logic. By abstracting the flash condition into a method, the code becomes more maintainable, easier to understand, and less prone to errors."
38140,"public boolean takeZSLPicture(CameraDevice cameraDevice,CameraCaptureSession captureSession,ImageReader imageReader){
  if (mCameraDevice == null || mCaptureSession == null || mImageReader == null) {
    mCameraDevice=cameraDevice;
    mCaptureSession=captureSession;
    mImageReader=imageReader;
  }
  ZSLQueue.ImageItem imageItem=mZSLQueue.tryToGetMatchingItem();
  if (mController.getPreviewCaptureResult().get(CaptureResult.CONTROL_AE_STATE) == CameraMetadata.CONTROL_AE_STATE_FLASH_REQUIRED) {
    if (DEBUG_ZSL)     Log.d(TAG,""String_Node_Str"");
    imageItem=null;
  }
  if (imageItem != null) {
    if (DEBUG_ZSL)     Log.d(TAG,""String_Node_Str"");
    reprocessImage(imageItem);
    return true;
  }
 else {
    if (DEBUG_ZSL)     Log.d(TAG,""String_Node_Str"");
    mZSLQueue.addPictureRequest();
    return false;
  }
}","public boolean takeZSLPicture(CameraDevice cameraDevice,CameraCaptureSession captureSession,ImageReader imageReader){
  if (mCameraDevice == null || mCaptureSession == null || mImageReader == null) {
    mCameraDevice=cameraDevice;
    mCaptureSession=captureSession;
    mImageReader=imageReader;
  }
  ZSLQueue.ImageItem imageItem=mZSLQueue.tryToGetMatchingItem();
  if (mController.getPreviewCaptureResult().get(CaptureResult.CONTROL_AE_STATE) == CameraMetadata.CONTROL_AE_STATE_FLASH_REQUIRED) {
    if (DEBUG_ZSL)     Log.d(TAG,""String_Node_Str"");
    imageItem=null;
  }
  if (mController.isSelfieFlash()) {
    imageItem=null;
  }
  if (imageItem != null) {
    if (DEBUG_ZSL)     Log.d(TAG,""String_Node_Str"");
    reprocessImage(imageItem);
    return true;
  }
 else {
    if (DEBUG_ZSL)     Log.d(TAG,""String_Node_Str"");
    mZSLQueue.addPictureRequest();
    return false;
  }
}","The original code lacked a check for selfie flash scenarios, potentially causing incorrect Zero Shutter Lag (ZSL) image processing. The fixed code adds `mController.isSelfieFlash()` to explicitly set `imageItem` to null when selfie flash is active, ensuring proper handling of flash-required conditions. This modification improves image capture reliability by preventing inappropriate image reprocessing during specific flash-related camera states."
38141,"private void processFinalPair(){
  Log.d(TAG,""String_Node_Str"");
  releaseBayerFrames();
  releaseMonoFrames();
  mImageProcessHandler.removeMessages(MSG_NEW_CAPTURE_RESULT);
  mImageProcessHandler.removeMessages(MSG_NEW_CAPTURE_FAIL);
  mCaptureDone=true;
}","private void processFinalPair(){
  Log.d(TAG,""String_Node_Str"");
  releaseBayerFrames();
  releaseMonoFrames();
  mImageProcessHandler.removeMessages(MSG_NEW_CAPTURE_RESULT);
  mImageProcessHandler.removeMessages(MSG_NEW_CAPTURE_FAIL);
  mCaptureDone=true;
  if (mReprocessingPairCount == 0) {
    Log.w(TAG,""String_Node_Str"");
    if (mCallback != null)     mCallback.onClearSightFailure(null);
  }
}","The original code lacked error handling for scenarios where no reprocessing pairs were available, potentially leaving the capture process in an undefined state. The fixed code adds a conditional check for `mReprocessingPairCount == 0`, which triggers a failure callback when no pairs are processed, ensuring proper error management. This modification provides a robust mechanism to handle edge cases, preventing silent failures and improving the overall reliability of the capture process."
38142,"public void init(StreamConfigurationMap map,int width,int height,Context context,OnMediaSavedListener mediaListener){
  Log.d(TAG,""String_Node_Str"");
  mIsClosing=false;
  mImageProcessThread=new HandlerThread(""String_Node_Str"");
  mImageProcessThread.start();
  mClearsightRegisterThread=new HandlerThread(""String_Node_Str"");
  mClearsightRegisterThread.start();
  mClearsightProcessThread=new HandlerThread(""String_Node_Str"");
  mClearsightProcessThread.start();
  mImageEncodeThread=new HandlerThread(""String_Node_Str"");
  mImageEncodeThread.start();
  mImageProcessHandler=new ImageProcessHandler(mImageProcessThread.getLooper());
  mClearsightRegisterHandler=new ClearsightRegisterHandler(mClearsightRegisterThread.getLooper());
  mClearsightProcessHandler=new ClearsightProcessHandler(mClearsightProcessThread.getLooper());
  mImageEncodeHandler=new ImageEncodeHandler(mImageEncodeThread.getLooper());
  mFinalPictureSize=new Size(width,height);
  mFinalPictureRatio=(float)width / (float)height;
  mFinalMonoSize=getFinalMonoSize();
  Size maxSize=findMaxOutputSize(map);
  int maxWidth=maxSize.getWidth();
  int maxHeight=maxSize.getHeight();
  mImageReader[CAM_TYPE_BAYER]=createImageReader(CAM_TYPE_BAYER,maxWidth,maxHeight);
  mImageReader[CAM_TYPE_MONO]=createImageReader(CAM_TYPE_MONO,maxWidth,maxHeight);
  mEncodeImageReader[CAM_TYPE_BAYER]=createEncodeImageReader(CAM_TYPE_BAYER,maxWidth,maxHeight);
  mEncodeImageReader[CAM_TYPE_MONO]=createEncodeImageReader(CAM_TYPE_MONO,maxWidth,maxHeight);
  mMediaSavedListener=mediaListener;
  CameraManager cm=(CameraManager)context.getSystemService(Context.CAMERA_SERVICE);
  try {
    CameraCharacteristics cc=cm.getCameraCharacteristics(""String_Node_Str"");
    byte[] blob=cc.get(OTP_CALIB_BLOB);
    ClearSightNativeEngine.getInstance().init(mNumFrameCount * 2,width,height,CamSystemCalibrationData.createFromBytes(blob));
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
  Log.d(TAG,""String_Node_Str"");
}","public void init(StreamConfigurationMap map,int width,int height,Context context,OnMediaSavedListener mediaListener){
  Log.d(TAG,""String_Node_Str"");
  mIsClosing=false;
  mImageProcessThread=new HandlerThread(""String_Node_Str"");
  mImageProcessThread.start();
  mClearsightRegisterThread=new HandlerThread(""String_Node_Str"");
  mClearsightRegisterThread.start();
  mClearsightProcessThread=new HandlerThread(""String_Node_Str"");
  mClearsightProcessThread.start();
  mImageEncodeThread=new HandlerThread(""String_Node_Str"");
  mImageEncodeThread.start();
  mImageProcessHandler=new ImageProcessHandler(mImageProcessThread.getLooper());
  mClearsightRegisterHandler=new ClearsightRegisterHandler(mClearsightRegisterThread.getLooper());
  mClearsightProcessHandler=new ClearsightProcessHandler(mClearsightProcessThread.getLooper());
  mImageEncodeHandler=new ImageEncodeHandler(mImageEncodeThread.getLooper());
  mFinalPictureSize=new Size(width,height);
  mFinalPictureRatio=(float)width / (float)height;
  mFinalMonoSize=getFinalMonoSize();
  Size maxSize=findMaxOutputSize(map);
  int maxWidth=maxSize.getWidth();
  int maxHeight=maxSize.getHeight();
  mImageReader[CAM_TYPE_BAYER]=createImageReader(CAM_TYPE_BAYER,maxWidth,maxHeight);
  mImageReader[CAM_TYPE_MONO]=createImageReader(CAM_TYPE_MONO,maxWidth,maxHeight);
  mEncodeImageReader[CAM_TYPE_BAYER]=createEncodeImageReader(CAM_TYPE_BAYER,maxWidth,maxHeight);
  mEncodeImageReader[CAM_TYPE_MONO]=createEncodeImageReader(CAM_TYPE_MONO,maxWidth,maxHeight);
  mMediaSavedListener=mediaListener;
  CameraManager cm=(CameraManager)context.getSystemService(Context.CAMERA_SERVICE);
  try {
    CameraCharacteristics cc=cm.getCameraCharacteristics(""String_Node_Str"");
    byte[] blob=cc.get(OTP_CALIB_BLOB);
    ClearSightNativeEngine.getInstance().init(mNumFrameCount * 2,maxWidth,maxHeight,CamSystemCalibrationData.createFromBytes(blob));
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
  Log.d(TAG,""String_Node_Str"");
}","The original code incorrectly passed the final picture width and height to ClearSightNativeEngine's init method, which could lead to incorrect image processing. In the fixed code, the maximum image width and height from the stream configuration map are used instead, ensuring accurate native engine initialization. This change provides more precise image dimensions for processing, potentially improving the overall image quality and performance of the camera system."
38143,"private Rect getFinalCropRect(Rect rect){
  Rect finalRect=new Rect(rect);
  float rectRatio=(float)rect.width() / (float)rect.height();
  if (rectRatio > mFinalPictureRatio) {
    int newWidth=(int)(((float)rect.height() * mFinalPictureRatio) + .5f);
    int newXoffset=(rect.width() - newWidth) / 2;
    finalRect.left=newXoffset;
    finalRect.right=newXoffset + newWidth;
  }
 else   if (rectRatio < mFinalPictureRatio) {
    int newHeight=(int)(((float)rect.width() / mFinalPictureRatio) + .5f);
    int newYoffset=(rect.height() - newHeight) / 2;
    finalRect.top=newYoffset;
    finalRect.bottom=newYoffset + newHeight;
  }
  return finalRect;
}","private Rect getFinalCropRect(Rect rect){
  Rect finalRect=new Rect(rect);
  float rectRatio=(float)rect.width() / (float)rect.height();
  Log.d(TAG,""String_Node_Str"" + rect.toString());
  Log.d(TAG,""String_Node_Str"" + rectRatio + ""String_Node_Str""+ mFinalPictureRatio);
  if (rectRatio > mFinalPictureRatio) {
    int newWidth=(int)(((float)rect.height() * mFinalPictureRatio) + .5f);
    int newXoffset=(rect.width() - newWidth) / 2 + rect.left;
    finalRect.left=newXoffset;
    finalRect.right=newXoffset + newWidth;
  }
 else   if (rectRatio < mFinalPictureRatio) {
    int newHeight=(int)(((float)rect.width() / mFinalPictureRatio) + .5f);
    int newYoffset=(rect.height() - newHeight) / 2 + rect.top;
    finalRect.top=newYoffset;
    finalRect.bottom=newYoffset + newHeight;
  }
  Log.d(TAG,""String_Node_Str"" + finalRect.toString());
  return finalRect;
}","The original code incorrectly calculated crop offsets without considering the original rectangle's position, potentially generating incorrect crop coordinates. The fixed code adds `rect.left` and `rect.top` when calculating new offsets, ensuring that the crop rectangle maintains its relative position within the original bounds. This modification preserves the spatial context of the original rectangle, resulting in more accurate and predictable cropping across different input rectangles."
38144,"/** 
 * Unlock the focus. This method should be called when still image capture sequence is finished.
 */
private void unlockFocus(int id){
  Log.d(TAG,""String_Node_Str"" + id);
  try {
    CaptureRequest.Builder builder=mCameraDevice[id].createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
    builder.setTag(id);
    addPreviewSurface(builder,null,id);
    applySettingsForUnlockFocus(builder,id);
    mCaptureSession[id].capture(builder.build(),mCaptureCallback,mCameraHandler);
    mState[id]=STATE_PREVIEW;
    mControlAFMode=CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
    applySettingsForUnlockExposure(mPreviewRequestBuilder[id],id);
    setAFModeToPreview(id,mControlAFMode);
    mTakingPicture[id]=false;
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.stopSelfieFlash();
        mUI.enableShutter(true);
      }
    }
);
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
}","/** 
 * Unlock the focus. This method should be called when still image capture sequence is finished.
 */
private void unlockFocus(int id){
  Log.d(TAG,""String_Node_Str"" + id);
  try {
    CaptureRequest.Builder builder=mCameraDevice[id].createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
    builder.setTag(id);
    addPreviewSurface(builder,null,id);
    applySettingsForUnlockFocus(builder,id);
    mCaptureSession[id].capture(builder.build(),mCaptureCallback,mCameraHandler);
    mState[id]=STATE_PREVIEW;
    if (id == getMainCameraId()) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.clearFocus();
        }
      }
);
    }
    mControlAFMode=CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
    applySettingsForUnlockExposure(mPreviewRequestBuilder[id],id);
    setAFModeToPreview(id,mControlAFMode);
    mTakingPicture[id]=false;
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.stopSelfieFlash();
        mUI.enableShutter(true);
      }
    }
);
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
}","The original code lacked a specific check for the main camera before clearing focus, which could lead to unnecessary UI operations. The fixed code adds a condition `if (id == getMainCameraId())` before running the UI thread to clear focus, ensuring that focus clearing only occurs for the primary camera. This targeted approach prevents potential UI inconsistencies and improves the precision of camera focus management across different camera devices."
38145,"private void handlePermissionsSuccess(){
  if (mIntent != null) {
    mIsReturnResult=true;
    mIntent.setClass(this,CameraActivity.class);
    startActivityForResult(mIntent,1);
  }
 else {
    mIsReturnResult=false;
    Intent intent=new Intent(this,CameraActivity.class);
    startActivity(intent);
    finish();
  }
}","private void handlePermissionsSuccess(){
  if (mIntent != null) {
    mIsReturnResult=true;
    mIntent.setClass(this,CameraActivity.class);
    mIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
    startActivity(mIntent);
    finish();
  }
 else {
    mIsReturnResult=false;
    Intent intent=new Intent(this,CameraActivity.class);
    startActivity(intent);
    finish();
  }
}","The original code incorrectly used `startActivityForResult()` with a potentially null intent, which could lead to unexpected behavior and potential null pointer exceptions. In the fixed code, `mIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT)` is added to preserve the result forwarding, and `startActivity(mIntent)` is used instead of `startActivityForResult()`. This modification ensures a more robust and predictable activity transition while maintaining the intended result handling mechanism."
38146,"private void doReturnToCaller(boolean valid){
  Intent resultIntent=new Intent();
  int resultCode;
  if (valid) {
    resultCode=Activity.RESULT_OK;
    resultIntent.setData(mCurrentVideoUri);
  }
 else {
    resultCode=Activity.RESULT_CANCELED;
  }
  mActivity.setResultEx(resultCode,resultIntent);
  mActivity.finish();
}","private void doReturnToCaller(boolean valid){
  Intent resultIntent=new Intent();
  int resultCode;
  if (valid) {
    resultCode=Activity.RESULT_OK;
    resultIntent.setData(mCurrentVideoUri);
    resultIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
  }
 else {
    resultCode=Activity.RESULT_CANCELED;
  }
  mActivity.setResultEx(resultCode,resultIntent);
  mActivity.finish();
}","The original code fails to set the FLAG_GRANT_READ_URI_PERMISSION flag when returning a video URI, which can prevent the receiving activity from accessing the content. The fixed code adds `resultIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)` to explicitly grant read permissions for the URI. This ensures that the receiving activity can properly read and handle the video URI without permission-related errors."
38147,"/** 
 * Unlock the focus. This method should be called when still image capture sequence is finished.
 */
private void unlockFocus(int id){
  Log.d(TAG,""String_Node_Str"" + id);
  try {
    CaptureRequest.Builder builder=mCameraDevice[id].createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
    builder.setTag(id);
    addPreviewSurface(builder,null,id);
    applySettingsForUnlockFocus(builder,id);
    mCaptureSession[id].capture(builder.build(),mCaptureCallback,mCameraHandler);
    mState[id]=STATE_PREVIEW;
    mControlAFMode=CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
    applySettingsForUnlockExposure(mPreviewRequestBuilder[id],id);
    setAFModeToPreview(id,mControlAFMode);
    mTakingPicture[id]=false;
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.stopSelfieFlash();
        mUI.enableShutter(true);
      }
    }
);
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
}","/** 
 * Unlock the focus. This method should be called when still image capture sequence is finished.
 */
private void unlockFocus(int id){
  Log.d(TAG,""String_Node_Str"" + id);
  try {
    CaptureRequest.Builder builder=mCameraDevice[id].createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
    builder.setTag(id);
    addPreviewSurface(builder,null,id);
    applySettingsForUnlockFocus(builder,id);
    mCaptureSession[id].capture(builder.build(),mCaptureCallback,mCameraHandler);
    mState[id]=STATE_PREVIEW;
    if (id == getMainCameraId()) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.clearFocus();
        }
      }
);
    }
    mControlAFMode=CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
    applySettingsForUnlockExposure(mPreviewRequestBuilder[id],id);
    setAFModeToPreview(id,mControlAFMode);
    mTakingPicture[id]=false;
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.stopSelfieFlash();
        mUI.enableShutter(true);
      }
    }
);
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
}","The original code lacked a specific UI update for clearing focus when processing the main camera, potentially leaving the camera UI in an inconsistent state. The fixed code adds a conditional check to call `mUI.clearFocus()` only for the main camera, ensuring proper UI synchronization. This targeted approach improves user experience by correctly resetting the camera focus state and maintaining UI responsiveness during camera operations."
38148,"private void processNewReprocessImage(Message msg){
  boolean isBayer=(msg.arg1 == CAM_TYPE_BAYER);
  Image image=(Image)msg.obj;
  long ts=image.getTimestamp();
  Log.d(TAG,""String_Node_Str"" + ts);
  if (mDumpImages) {
    saveDebugImageAsJpeg(mMediaSaveService,image,isBayer,mNamedEntity,ClearSightNativeEngine.getInstance().getImageCount(isBayer));
  }
  if (mDumpYUV) {
    saveDebugImageAsNV21(image,isBayer,mNamedEntity,ClearSightNativeEngine.getInstance().getImageCount(isBayer));
  }
  if (!ClearSightNativeEngine.getInstance().hasReferenceImage(isBayer)) {
    ClearSightNativeEngine.getInstance().setReferenceImage(isBayer,image);
  }
 else {
    mClearsightRegisterHandler.obtainMessage(MSG_NEW_IMG,msg.arg1,0,msg.obj).sendToTarget();
  }
  mReprocessingFrames.removeAt(mReprocessingFrames.indexOfValue(ts));
  checkReprocessDone();
}","private void processNewReprocessImage(Message msg){
  boolean isBayer=(msg.arg1 == CAM_TYPE_BAYER);
  Image image=(Image)msg.obj;
  long ts=image.getTimestamp();
  Log.d(TAG,""String_Node_Str"" + msg.arg1 + ""String_Node_Str""+ ts);
  int frameCount=isBayer ? ++mReprocessedBayerCount : ++mReprocessedMonoCount;
  if (mDumpImages) {
    saveDebugImageAsJpeg(mMediaSaveService,image,isBayer,mNamedEntity,frameCount,ts / 1000000);
  }
  if (mDumpYUV) {
    saveDebugImageAsNV21(image,isBayer,mNamedEntity,frameCount,ts / 1000000);
  }
  if (!ClearSightNativeEngine.getInstance().hasReferenceImage(isBayer)) {
    ClearSightNativeEngine.getInstance().setReferenceImage(isBayer,image);
  }
 else {
    mClearsightRegisterHandler.obtainMessage(MSG_NEW_IMG,msg.arg1,0,msg.obj).sendToTarget();
  }
  mReprocessingFrames.removeAt(mReprocessingFrames.indexOfValue(ts));
  checkReprocessDone();
}","The original code lacked proper logging and frame counting, potentially causing issues with image tracking and debugging. The fixed code introduces frame counting for Bayer and mono images, adds more detailed logging with camera type, and converts timestamp to milliseconds for better readability. These improvements enhance image processing traceability, provide clearer diagnostic information, and ensure accurate frame tracking during reprocessing."
38149,"public void saveDebugImageAsNV21(Image image,boolean isBayer,NamedEntity namedEntity,int count){
  if (image.getFormat() != ImageFormat.YUV_420_888) {
    Log.d(TAG,""String_Node_Str"");
  }
  String type=isBayer ? ""String_Node_Str"" : ""String_Node_Str"";
  String title=String.format(""String_Node_Str"",namedEntity.title,image.getWidth(),image.getHeight(),type,count);
  YuvImage yuv=createYuvImage(image);
  String path=Storage.generateFilepath(title,""String_Node_Str"");
  Storage.writeFile(path,yuv.getYuvData(),null,""String_Node_Str"");
}","public void saveDebugImageAsNV21(Image image,boolean isBayer,NamedEntity namedEntity,int count,long ts){
  if (image.getFormat() != ImageFormat.YUV_420_888) {
    Log.d(TAG,""String_Node_Str"");
  }
  String type=isBayer ? ""String_Node_Str"" : ""String_Node_Str"";
  String title=String.format(""String_Node_Str"",namedEntity.title,image.getWidth(),image.getHeight(),type,count,ts);
  YuvImage yuv=createYuvImage(image);
  String path=Storage.generateFilepath(title,""String_Node_Str"");
  Storage.writeFile(path,yuv.getYuvData(),null,""String_Node_Str"");
}","The original code lacked a timestamp parameter, which could lead to incomplete image identification and potential overwriting of debug images. The fixed code adds a 'ts' (timestamp) parameter to the method signature and incorporates it into the title generation, ensuring unique file naming and precise image tracking. This enhancement provides more granular debug image management by including a timestamp, preventing potential data loss and improving diagnostic capabilities."
38150,"public void saveDebugImageAsJpeg(MediaSaveService service,Image image,boolean isBayer,NamedEntity namedEntity,int count){
  if (image.getFormat() == ImageFormat.YUV_420_888)   saveDebugImageAsJpeg(service,createYuvImage(image),isBayer,namedEntity,count);
 else   if (image.getFormat() == ImageFormat.JPEG) {
    saveDebugImageAsJpeg(service,getJpegData(image),image.getWidth(),image.getHeight(),isBayer,namedEntity,count);
  }
}","public void saveDebugImageAsJpeg(MediaSaveService service,Image image,boolean isBayer,NamedEntity namedEntity,int count,long ts){
  if (image.getFormat() == ImageFormat.YUV_420_888)   saveDebugImageAsJpeg(service,createYuvImage(image),isBayer,namedEntity,count,ts);
 else   if (image.getFormat() == ImageFormat.JPEG) {
    saveDebugImageAsJpeg(service,getJpegData(image),image.getWidth(),image.getHeight(),isBayer,namedEntity,count,ts);
  }
}","The original code lacks a timestamp parameter, which is crucial for accurately tracking and logging image save events. The fixed code adds a `long ts` parameter to both recursive method calls, ensuring consistent timestamp handling across different image format processing paths. This modification enables precise temporal tracking and improves the method's flexibility by allowing timestamp metadata to be consistently passed during image saving operations."
38151,"private void handlePermissionsSuccess(){
  if (mIntent != null) {
    mIsReturnResult=true;
    mIntent.setClass(this,CameraActivity.class);
    startActivityForResult(mIntent,1);
  }
 else {
    mIsReturnResult=false;
    Intent intent=new Intent(this,CameraActivity.class);
    startActivity(intent);
    finish();
  }
}","private void handlePermissionsSuccess(){
  if (mIntent != null) {
    mIsReturnResult=true;
    mIntent.setClass(this,CameraActivity.class);
    mIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
    startActivity(mIntent);
    finish();
  }
 else {
    mIsReturnResult=false;
    Intent intent=new Intent(this,CameraActivity.class);
    startActivity(intent);
    finish();
  }
}","The original code incorrectly used `startActivityForResult()` when `mIntent` was not null, which could lead to unexpected result handling and potential activity lifecycle issues. The fixed code replaces `startActivityForResult()` with `startActivity()` and adds `FLAG_ACTIVITY_FORWARD_RESULT` to ensure proper result propagation when an existing intent is used. This modification simplifies the activity transition, maintains result consistency, and prevents potential crashes or unintended behavior during activity navigation."
38152,"private void doReturnToCaller(boolean valid){
  Intent resultIntent=new Intent();
  int resultCode;
  if (valid) {
    resultCode=Activity.RESULT_OK;
    resultIntent.setData(mCurrentVideoUri);
  }
 else {
    resultCode=Activity.RESULT_CANCELED;
  }
  mActivity.setResultEx(resultCode,resultIntent);
  mActivity.finish();
}","private void doReturnToCaller(boolean valid){
  Intent resultIntent=new Intent();
  int resultCode;
  if (valid) {
    resultCode=Activity.RESULT_OK;
    resultIntent.setData(mCurrentVideoUri);
    resultIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
  }
 else {
    resultCode=Activity.RESULT_CANCELED;
  }
  mActivity.setResultEx(resultCode,resultIntent);
  mActivity.finish();
}","The original code lacks URI permission when returning a video URI, which could prevent the receiving activity from accessing the file. The fixed code adds `Intent.FLAG_GRANT_READ_URI_PERMISSION` to explicitly grant read access to the URI, ensuring the receiving component can properly read the video file. This change resolves potential permission-related issues and improves the robustness of inter-activity data sharing."
38153,"private void processNewReprocessImage(Message msg){
  boolean isBayer=(msg.arg1 == CAM_TYPE_BAYER);
  Image image=(Image)msg.obj;
  long ts=image.getTimestamp();
  Log.d(TAG,""String_Node_Str"" + ts);
  if (mDumpImages) {
    saveDebugImageAsJpeg(mMediaSaveService,image,isBayer,mNamedEntity,ClearSightNativeEngine.getInstance().getImageCount(isBayer));
  }
  if (mDumpYUV) {
    saveDebugImageAsNV21(image,isBayer,mNamedEntity,ClearSightNativeEngine.getInstance().getImageCount(isBayer));
  }
  if (!ClearSightNativeEngine.getInstance().hasReferenceImage(isBayer)) {
    ClearSightNativeEngine.getInstance().setReferenceImage(isBayer,image);
  }
 else {
    mClearsightRegisterHandler.obtainMessage(MSG_NEW_IMG,msg.arg1,0,msg.obj).sendToTarget();
  }
  mReprocessingFrames.removeAt(mReprocessingFrames.indexOfValue(ts));
  checkReprocessDone();
}","private void processNewReprocessImage(Message msg){
  boolean isBayer=(msg.arg1 == CAM_TYPE_BAYER);
  Image image=(Image)msg.obj;
  long ts=image.getTimestamp();
  Log.d(TAG,""String_Node_Str"" + msg.arg1 + ""String_Node_Str""+ ts);
  int frameCount=isBayer ? ++mReprocessedBayerCount : ++mReprocessedMonoCount;
  if (mDumpImages) {
    saveDebugImageAsJpeg(mMediaSaveService,image,isBayer,mNamedEntity,frameCount,ts / 1000000);
  }
  if (mDumpYUV) {
    saveDebugImageAsNV21(image,isBayer,mNamedEntity,frameCount,ts / 1000000);
  }
  if (!ClearSightNativeEngine.getInstance().hasReferenceImage(isBayer)) {
    ClearSightNativeEngine.getInstance().setReferenceImage(isBayer,image);
  }
 else {
    mClearsightRegisterHandler.obtainMessage(MSG_NEW_IMG,msg.arg1,0,msg.obj).sendToTarget();
  }
  mReprocessingFrames.removeAt(mReprocessingFrames.indexOfValue(ts));
  checkReprocessDone();
}","The original code lacked proper logging and frame counting, potentially causing tracking issues with reprocessed images. The fixed code adds detailed logging with camera type, introduces separate counters for Bayer and mono frames, and includes timestamp conversion for more accurate image tracking. These modifications enhance debugging capabilities and provide a more robust mechanism for managing and tracking image reprocessing across different camera types."
38154,"public void saveDebugImageAsNV21(Image image,boolean isBayer,NamedEntity namedEntity,int count){
  if (image.getFormat() != ImageFormat.YUV_420_888) {
    Log.d(TAG,""String_Node_Str"");
  }
  String type=isBayer ? ""String_Node_Str"" : ""String_Node_Str"";
  String title=String.format(""String_Node_Str"",namedEntity.title,image.getWidth(),image.getHeight(),type,count);
  YuvImage yuv=createYuvImage(image);
  String path=Storage.generateFilepath(title,""String_Node_Str"");
  Storage.writeFile(path,yuv.getYuvData(),null,""String_Node_Str"");
}","public void saveDebugImageAsNV21(Image image,boolean isBayer,NamedEntity namedEntity,int count,long ts){
  if (image.getFormat() != ImageFormat.YUV_420_888) {
    Log.d(TAG,""String_Node_Str"");
  }
  String type=isBayer ? ""String_Node_Str"" : ""String_Node_Str"";
  String title=String.format(""String_Node_Str"",namedEntity.title,image.getWidth(),image.getHeight(),type,count,ts);
  YuvImage yuv=createYuvImage(image);
  String path=Storage.generateFilepath(title,""String_Node_Str"");
  Storage.writeFile(path,yuv.getYuvData(),null,""String_Node_Str"");
}","The original code lacked a timestamp parameter, which is crucial for uniquely identifying and tracking image captures across different sessions. The fixed code adds a long `ts` (timestamp) parameter to the method signature and incorporates it into the `title` string formatting, enabling more precise image file naming and tracking. This enhancement allows for better debugging, file management, and temporal correlation of captured images by including a precise timestamp in the file generation process."
38155,"public void saveDebugImageAsJpeg(MediaSaveService service,Image image,boolean isBayer,NamedEntity namedEntity,int count){
  if (image.getFormat() == ImageFormat.YUV_420_888)   saveDebugImageAsJpeg(service,createYuvImage(image),isBayer,namedEntity,count);
 else   if (image.getFormat() == ImageFormat.JPEG) {
    saveDebugImageAsJpeg(service,getJpegData(image),image.getWidth(),image.getHeight(),isBayer,namedEntity,count);
  }
}","public void saveDebugImageAsJpeg(MediaSaveService service,Image image,boolean isBayer,NamedEntity namedEntity,int count,long ts){
  if (image.getFormat() == ImageFormat.YUV_420_888)   saveDebugImageAsJpeg(service,createYuvImage(image),isBayer,namedEntity,count,ts);
 else   if (image.getFormat() == ImageFormat.JPEG) {
    saveDebugImageAsJpeg(service,getJpegData(image),image.getWidth(),image.getHeight(),isBayer,namedEntity,count,ts);
  }
}","The original code lacks a timestamp parameter, which is crucial for precise image logging and tracking. The fixed code adds a `ts` (timestamp) parameter to both recursive method calls, ensuring consistent timestamp propagation across different image format handling paths. This modification enables more accurate temporal referencing and debugging of image save operations, particularly when dealing with different image formats like YUV and JPEG."
38156,"private void startRecordingVideo(int cameraId){
  if (null == mCameraDevice[cameraId]) {
    return;
  }
  Log.d(TAG,""String_Node_Str"" + cameraId);
  mIsRecordingVideo=true;
  mMediaRecorderPausing=false;
  mUI.hideUIwhileRecording();
  mUI.clearFocus();
  mCameraHandler.removeMessages(CANCEL_TOUCH_FOCUS,cameraId);
  mState[cameraId]=STATE_PREVIEW;
  mControlAFMode=CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
  closePreviewSession();
  mFrameProcessor.onClose();
  boolean changed=mUI.setPreviewSize(mVideoSize.getWidth(),mVideoSize.getHeight());
  if (changed) {
    mUI.hideSurfaceView();
    mUI.showSurfaceView();
  }
  try {
    setUpMediaRecorder(cameraId);
    createVideoSnapshotImageReader();
    final CaptureRequest.Builder mPreviewBuilder=mCameraDevice[cameraId].createCaptureRequest(CameraDevice.TEMPLATE_RECORD);
    List<Surface> surfaces=new ArrayList<>();
    Surface surface=getPreviewSurfaceForSession(cameraId);
    mFrameProcessor.init(mVideoSize);
    if (mFrameProcessor.isFrameFilterEnabled()) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          mUI.getSurfaceHolder().setFixedSize(mVideoSize.getHeight(),mVideoSize.getWidth());
        }
      }
);
    }
    mFrameProcessor.setOutputSurface(surface);
    mFrameProcessor.setVideoOutputSurface(mMediaRecorder.getSurface());
    addPreviewSurface(mPreviewBuilder,surfaces,cameraId);
    if (!mHighSpeedCapture)     surfaces.add(mVideoSnapshotImageReader.getSurface());
 else     mPreviewBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE,mHighSpeedFPSRange);
    if (!mHighSpeedCapture) {
      mCameraDevice[cameraId].createCaptureSession(surfaces,new CameraCaptureSession.StateCallback(){
        @Override public void onConfigured(        CameraCaptureSession cameraCaptureSession){
          Log.d(TAG,""String_Node_Str"");
          mCurrentSession=cameraCaptureSession;
          try {
            setUpVideoCaptureRequestBuilder(mPreviewBuilder);
            mCurrentSession.setRepeatingRequest(mPreviewBuilder.build(),null,mCameraHandler);
          }
 catch (          CameraAccessException e) {
            e.printStackTrace();
          }
          mMediaRecorder.start();
          mUI.clearFocus();
          mUI.resetPauseButton();
          mRecordingTotalTime=0L;
          mRecordingStartTime=SystemClock.uptimeMillis();
          mUI.showRecordingUI(true);
          updateRecordingTime();
        }
        @Override public void onConfigureFailed(        CameraCaptureSession cameraCaptureSession){
          Toast.makeText(mActivity,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
,null);
    }
 else {
      mCameraDevice[cameraId].createConstrainedHighSpeedCaptureSession(surfaces,new CameraConstrainedHighSpeedCaptureSession.StateCallback(){
        @Override public void onConfigured(        CameraCaptureSession cameraCaptureSession){
          mCurrentSession=cameraCaptureSession;
          CameraConstrainedHighSpeedCaptureSession session=(CameraConstrainedHighSpeedCaptureSession)mCurrentSession;
          try {
            List list=session.createHighSpeedRequestList(mPreviewBuilder.build());
            session.setRepeatingBurst(list,null,mCameraHandler);
          }
 catch (          CameraAccessException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
catch (          IllegalArgumentException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
catch (          IllegalStateException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
          mMediaRecorder.start();
          mUI.clearFocus();
          mUI.resetPauseButton();
          mRecordingTotalTime=0L;
          mRecordingStartTime=SystemClock.uptimeMillis();
          mUI.showRecordingUI(true);
          updateRecordingTime();
        }
        @Override public void onConfigureFailed(        CameraCaptureSession cameraCaptureSession){
          Toast.makeText(mActivity,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
,null);
    }
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","private void startRecordingVideo(int cameraId){
  if (null == mCameraDevice[cameraId]) {
    return;
  }
  Log.d(TAG,""String_Node_Str"" + cameraId);
  mIsRecordingVideo=true;
  mMediaRecorderPausing=false;
  mUI.hideUIwhileRecording();
  mUI.clearFocus();
  mCameraHandler.removeMessages(CANCEL_TOUCH_FOCUS,cameraId);
  mState[cameraId]=STATE_PREVIEW;
  mControlAFMode=CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE;
  closePreviewSession();
  mFrameProcessor.onClose();
  boolean changed=mUI.setPreviewSize(mVideoPreviewSize.getWidth(),mVideoPreviewSize.getHeight());
  if (changed) {
    mUI.hideSurfaceView();
    mUI.showSurfaceView();
  }
  try {
    setUpMediaRecorder(cameraId);
    createVideoSnapshotImageReader();
    final CaptureRequest.Builder mPreviewBuilder=mCameraDevice[cameraId].createCaptureRequest(CameraDevice.TEMPLATE_RECORD);
    List<Surface> surfaces=new ArrayList<>();
    Surface surface=getPreviewSurfaceForSession(cameraId);
    if (mFrameProcessor.isFrameFilterEnabled()) {
      mFrameProcessor.init(mVideoSize);
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          mUI.getSurfaceHolder().setFixedSize(mVideoSize.getHeight(),mVideoSize.getWidth());
        }
      }
);
      mFrameProcessor.setOutputSurface(surface);
      mFrameProcessor.setVideoOutputSurface(mMediaRecorder.getSurface());
      addPreviewSurface(mPreviewBuilder,surfaces,cameraId);
    }
 else {
      surfaces.add(surface);
      mPreviewBuilder.addTarget(surface);
      surfaces.add(mMediaRecorder.getSurface());
      mPreviewBuilder.addTarget(mMediaRecorder.getSurface());
    }
    if (!mHighSpeedCapture)     surfaces.add(mVideoSnapshotImageReader.getSurface());
 else     mPreviewBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE,mHighSpeedFPSRange);
    if (!mHighSpeedCapture) {
      mCameraDevice[cameraId].createCaptureSession(surfaces,new CameraCaptureSession.StateCallback(){
        @Override public void onConfigured(        CameraCaptureSession cameraCaptureSession){
          Log.d(TAG,""String_Node_Str"");
          mCurrentSession=cameraCaptureSession;
          try {
            setUpVideoCaptureRequestBuilder(mPreviewBuilder);
            mCurrentSession.setRepeatingRequest(mPreviewBuilder.build(),null,mCameraHandler);
          }
 catch (          CameraAccessException e) {
            e.printStackTrace();
          }
          mMediaRecorder.start();
          mUI.clearFocus();
          mUI.resetPauseButton();
          mRecordingTotalTime=0L;
          mRecordingStartTime=SystemClock.uptimeMillis();
          mUI.showRecordingUI(true);
          updateRecordingTime();
        }
        @Override public void onConfigureFailed(        CameraCaptureSession cameraCaptureSession){
          Toast.makeText(mActivity,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
,null);
    }
 else {
      mCameraDevice[cameraId].createConstrainedHighSpeedCaptureSession(surfaces,new CameraConstrainedHighSpeedCaptureSession.StateCallback(){
        @Override public void onConfigured(        CameraCaptureSession cameraCaptureSession){
          mCurrentSession=cameraCaptureSession;
          CameraConstrainedHighSpeedCaptureSession session=(CameraConstrainedHighSpeedCaptureSession)mCurrentSession;
          try {
            List list=session.createHighSpeedRequestList(mPreviewBuilder.build());
            session.setRepeatingBurst(list,null,mCameraHandler);
          }
 catch (          CameraAccessException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
catch (          IllegalArgumentException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
catch (          IllegalStateException e) {
            Log.e(TAG,""String_Node_Str"" + e.getMessage());
            e.printStackTrace();
          }
          mMediaRecorder.start();
          mUI.clearFocus();
          mUI.resetPauseButton();
          mRecordingTotalTime=0L;
          mRecordingStartTime=SystemClock.uptimeMillis();
          mUI.showRecordingUI(true);
          updateRecordingTime();
        }
        @Override public void onConfigureFailed(        CameraCaptureSession cameraCaptureSession){
          Toast.makeText(mActivity,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
,null);
    }
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","The original code incorrectly initialized frame processing and surface configuration, potentially causing inconsistent video recording setup. The fixed code separates frame processor initialization, explicitly adds surfaces for both preview and recording, and ensures proper surface targeting for different capture scenarios. These changes improve reliability by providing a more robust and flexible approach to configuring camera capture sessions, reducing the likelihood of configuration errors during video recording."
38157,"private void updateVideoSize(){
  String videoSize=mSettingsManager.getValue(SettingsManager.KEY_VIDEO_QUALITY);
  mVideoSize=parsePictureSize(videoSize);
}","private void updateVideoSize(){
  String videoSize=mSettingsManager.getValue(SettingsManager.KEY_VIDEO_QUALITY);
  mVideoSize=parsePictureSize(videoSize);
  Point screenSize=new Point();
  mActivity.getWindowManager().getDefaultDisplay().getSize(screenSize);
  Size[] prevSizes=mSettingsManager.getSupportedOutputSize(getMainCameraId(),MediaRecorder.class);
  mVideoPreviewSize=getOptimalPreviewSize(mVideoSize,prevSizes,screenSize.x,screenSize.y);
}","The original code only retrieved the video size without considering preview compatibility or screen dimensions. The fixed code adds critical steps by obtaining screen size, retrieving supported output sizes, and calculating an optimal preview size that matches the video size and screen resolution. This enhancement ensures better video preview scaling, compatibility, and visual alignment across different device displays."
38158,"private void updateFilterModeIcon(ListPreference scenePref,ListPreference hdrPref){
  if (scenePref == null || hdrPref == null)   return;
  if ((notSame(scenePref,CameraSettings.KEY_SCENE_MODE,Parameters.SCENE_MODE_AUTO)) || (notSame(hdrPref,CameraSettings.KEY_CAMERA_HDR,mSettingOff))) {
    buttonSetEnabled(mFilterModeSwitcher,false);
    changeFilterModeControlIcon(""String_Node_Str"");
  }
 else {
    buttonSetEnabled(mFilterModeSwitcher,true);
  }
}","private void updateFilterModeIcon(ListPreference scenePref,ListPreference hdrPref){
  if (scenePref == null || hdrPref == null)   return;
  if ((notSame(scenePref,CameraSettings.KEY_SCENE_MODE,Parameters.SCENE_MODE_AUTO)) || (notSame(hdrPref,CameraSettings.KEY_CAMERA_HDR,mSettingOff))) {
    buttonSetEnabled(mFilterModeSwitcher,false);
    changeFilterModeControlIcon(""String_Node_Str"");
  }
 else   if (same(scenePref,CameraSettings.KEY_SCENE_MODE,Parameters.SCENE_MODE_AUTO) && (same(hdrPref,CameraSettings.KEY_CAMERA_HDR,mSettingOff) || !hdrPref.getKey().equals(CameraSettings.KEY_CAMERA_HDR))) {
    buttonSetEnabled(mFilterModeSwitcher,true);
  }
}","The original code lacked a proper else branch to re-enable the filter mode switcher when scene and HDR settings return to default states. The fixed code adds an explicit condition checking for auto scene mode and HDR off, ensuring the filter mode switcher is correctly enabled under specific circumstances. This improvement provides more robust control flow and prevents potential UI state inconsistencies by explicitly handling different preference combinations."
38159,"public void enableTouch(boolean enable){
  if (enable) {
    ((ShutterButton)mShutter).setPressed(false);
    mVideoShutter.setPressed(false);
    mSwitcher.setPressed(false);
    mMenu.setPressed(false);
    mMute.setPressed(false);
    mFrontBackSwitcher.setPressed(false);
    if (TsMakeupManager.HAS_TS_MAKEUP) {
      mTsMakeupSwitcher.setPressed(false);
    }
 else {
      mHdrSwitcher.setPressed(false);
    }
    mSceneModeSwitcher.setPressed(false);
    mFilterModeSwitcher.setPressed(false);
  }
 else {
    mTempEnabled[FILTER_MODE_INDEX]=mFilterModeSwitcher.isEnabled();
  }
  ((ShutterButton)mShutter).enableTouch(enable);
  mVideoShutter.setClickable(enable);
  ((ModuleSwitcher)mSwitcher).enableTouch(enable);
  mMenu.setEnabled(enable);
  mMute.setEnabled(enable);
  mFrontBackSwitcher.setEnabled(enable);
  if (TsMakeupManager.HAS_TS_MAKEUP) {
    mTsMakeupSwitcher.setEnabled(enable);
  }
 else {
    mHdrSwitcher.setEnabled(enable);
  }
  mSceneModeSwitcher.setEnabled(enable);
  mPreview.setEnabled(enable);
  mFilterModeSwitcher.setEnabled(enable && mTempEnabled[FILTER_MODE_INDEX]);
}","public void enableTouch(boolean enable){
  if (enable) {
    ((ShutterButton)mShutter).setPressed(false);
    mVideoShutter.setPressed(false);
    mSwitcher.setPressed(false);
    mMenu.setPressed(false);
    mMute.setPressed(false);
    mFrontBackSwitcher.setPressed(false);
    if (TsMakeupManager.HAS_TS_MAKEUP) {
      mTsMakeupSwitcher.setPressed(false);
    }
 else {
      mHdrSwitcher.setPressed(false);
    }
    mSceneModeSwitcher.setPressed(false);
  }
  ((ShutterButton)mShutter).enableTouch(enable);
  mVideoShutter.setClickable(enable);
  ((ModuleSwitcher)mSwitcher).enableTouch(enable);
  mMenu.setEnabled(enable);
  mMute.setEnabled(enable);
  mFrontBackSwitcher.setEnabled(enable);
  if (TsMakeupManager.HAS_TS_MAKEUP) {
    mTsMakeupSwitcher.setEnabled(enable);
  }
 else {
    mHdrSwitcher.setEnabled(enable);
  }
  mSceneModeSwitcher.setEnabled(enable);
  mPreview.setEnabled(enable);
}","The original code incorrectly sets the filter mode switcher's enabled state conditionally, potentially causing unexpected UI behavior. The fixed code removes the unnecessary filter mode switcher state tracking and simplifies the enable/disable logic by directly setting the enabled state based on the input parameter. This modification ensures consistent and predictable touch control across all UI elements, improving the code's clarity and reliability."
38160,"private void updateFilterModeIcon(ListPreference scenePref,ListPreference hdrPref){
  if (scenePref == null || hdrPref == null)   return;
  if ((notSame(scenePref,CameraSettings.KEY_SCENE_MODE,Parameters.SCENE_MODE_AUTO)) || (notSame(hdrPref,CameraSettings.KEY_CAMERA_HDR,mSettingOff))) {
    buttonSetEnabled(mFilterModeSwitcher,false);
    changeFilterModeControlIcon(""String_Node_Str"");
  }
 else {
    buttonSetEnabled(mFilterModeSwitcher,true);
  }
}","private void updateFilterModeIcon(ListPreference scenePref,ListPreference hdrPref){
  if (scenePref == null || hdrPref == null)   return;
  if ((notSame(scenePref,CameraSettings.KEY_SCENE_MODE,Parameters.SCENE_MODE_AUTO)) || (notSame(hdrPref,CameraSettings.KEY_CAMERA_HDR,mSettingOff))) {
    buttonSetEnabled(mFilterModeSwitcher,false);
    changeFilterModeControlIcon(""String_Node_Str"");
  }
 else   if (same(scenePref,CameraSettings.KEY_SCENE_MODE,Parameters.SCENE_MODE_AUTO) && (same(hdrPref,CameraSettings.KEY_CAMERA_HDR,mSettingOff) || !hdrPref.getKey().equals(CameraSettings.KEY_CAMERA_HDR))) {
    buttonSetEnabled(mFilterModeSwitcher,true);
  }
}","The original code lacked a proper else condition to enable the filter mode switcher when scene and HDR settings are in their default states. The fixed code adds an explicit condition checking that the scene mode is auto and HDR is off or not set, enabling the filter mode switcher accordingly. This ensures more precise control flow and prevents potential UI state inconsistencies by explicitly defining when the filter mode switcher should be activated."
38161,"public void enableTouch(boolean enable){
  if (enable) {
    ((ShutterButton)mShutter).setPressed(false);
    mVideoShutter.setPressed(false);
    mSwitcher.setPressed(false);
    mMenu.setPressed(false);
    mMute.setPressed(false);
    mFrontBackSwitcher.setPressed(false);
    if (TsMakeupManager.HAS_TS_MAKEUP) {
      mTsMakeupSwitcher.setPressed(false);
    }
 else {
      mHdrSwitcher.setPressed(false);
    }
    mSceneModeSwitcher.setPressed(false);
    mFilterModeSwitcher.setPressed(false);
  }
 else {
    mTempEnabled[FILTER_MODE_INDEX]=mFilterModeSwitcher.isEnabled();
  }
  ((ShutterButton)mShutter).enableTouch(enable);
  mVideoShutter.setClickable(enable);
  ((ModuleSwitcher)mSwitcher).enableTouch(enable);
  mMenu.setEnabled(enable);
  mMute.setEnabled(enable);
  mFrontBackSwitcher.setEnabled(enable);
  if (TsMakeupManager.HAS_TS_MAKEUP) {
    mTsMakeupSwitcher.setEnabled(enable);
  }
 else {
    mHdrSwitcher.setEnabled(enable);
  }
  mSceneModeSwitcher.setEnabled(enable);
  mPreview.setEnabled(enable);
  mFilterModeSwitcher.setEnabled(enable && mTempEnabled[FILTER_MODE_INDEX]);
}","public void enableTouch(boolean enable){
  if (enable) {
    ((ShutterButton)mShutter).setPressed(false);
    mVideoShutter.setPressed(false);
    mSwitcher.setPressed(false);
    mMenu.setPressed(false);
    mMute.setPressed(false);
    mFrontBackSwitcher.setPressed(false);
    if (TsMakeupManager.HAS_TS_MAKEUP) {
      mTsMakeupSwitcher.setPressed(false);
    }
 else {
      mHdrSwitcher.setPressed(false);
    }
    mSceneModeSwitcher.setPressed(false);
  }
  ((ShutterButton)mShutter).enableTouch(enable);
  mVideoShutter.setClickable(enable);
  ((ModuleSwitcher)mSwitcher).enableTouch(enable);
  mMenu.setEnabled(enable);
  mMute.setEnabled(enable);
  mFrontBackSwitcher.setEnabled(enable);
  if (TsMakeupManager.HAS_TS_MAKEUP) {
    mTsMakeupSwitcher.setEnabled(enable);
  }
 else {
    mHdrSwitcher.setEnabled(enable);
  }
  mSceneModeSwitcher.setEnabled(enable);
  mPreview.setEnabled(enable);
}","The original code incorrectly set the FilterModeSwitcher's pressed state and attempted to conditionally enable it based on a temporary stored state, which could lead to unexpected UI behavior. The fixed code removes the unnecessary pressed state for FilterModeSwitcher and eliminates the complex conditional enabling logic, simplifying the touch management process. By removing the extra complexity, the fixed code provides a more straightforward and predictable method of enabling or disabling touch interactions across various UI components."
38162,"private void initializeRecorder(){
  Log.v(TAG,""String_Node_Str"");
  if (mCameraDevice == null)   return;
  if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
    mUI.showSurfaceView();
  }
  Intent intent=mActivity.getIntent();
  Bundle myExtras=intent.getExtras();
  videoWidth=mProfile.videoFrameWidth;
  videoHeight=mProfile.videoFrameHeight;
  mUnsupportedResolution=false;
  List<VideoEncoderCap> videoEncoders=EncoderCapabilities.getVideoEncoders();
  for (  VideoEncoderCap videoEncoder : videoEncoders) {
    if (videoEncoder.mCodec == mVideoEncoder) {
      if (videoWidth > videoEncoder.mMaxFrameWidth || videoWidth < videoEncoder.mMinFrameWidth || videoHeight > videoEncoder.mMaxFrameHeight || videoHeight < videoEncoder.mMinFrameHeight) {
        Log.e(TAG,""String_Node_Str"" + mVideoEncoder + ""String_Node_Str""+ videoWidth+ ""String_Node_Str""+ videoHeight+ ""String_Node_Str"");
        Log.e(TAG,""String_Node_Str"" + ""String_Node_Str"" + videoEncoder.mMinFrameWidth + ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMinFrameHeight+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxFrameWidth+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxFrameHeight);
        mUnsupportedResolution=true;
        RotateTextToast.makeText(mActivity,R.string.error_app_unsupported,Toast.LENGTH_LONG).show();
        return;
      }
      break;
    }
  }
  long requestedSizeLimit=0;
  closeVideoFileDescriptor();
  mCurrentVideoUriFromMediaSaved=false;
  if (mIsVideoCaptureIntent && myExtras != null) {
    Uri saveUri=(Uri)myExtras.getParcelable(MediaStore.EXTRA_OUTPUT);
    if (saveUri != null) {
      try {
        mVideoFileDescriptor=mContentResolver.openFileDescriptor(saveUri,""String_Node_Str"");
        mCurrentVideoUri=saveUri;
      }
 catch (      java.io.FileNotFoundException ex) {
        Log.e(TAG,ex.toString());
      }
    }
    requestedSizeLimit=myExtras.getLong(MediaStore.EXTRA_SIZE_LIMIT);
  }
  mMediaRecorder=new MediaRecorder();
  mCameraDevice.unlock();
  mMediaRecorder.setCamera(mCameraDevice.getCamera());
  String hfr=mParameters.getVideoHighFrameRate();
  String hsr=mParameters.get(CameraSettings.KEY_VIDEO_HSR);
  Log.i(TAG,""String_Node_Str"" + hfr + ""String_Node_Str""+ hsr);
  int captureRate=0;
  boolean isHFR=(hfr != null && !hfr.equals(""String_Node_Str""));
  boolean isHSR=(hsr != null && !hsr.equals(""String_Node_Str""));
  try {
    captureRate=isHFR ? Integer.parseInt(hfr) : isHSR ? Integer.parseInt(hsr) : 0;
  }
 catch (  NumberFormatException nfe) {
    Log.e(TAG,""String_Node_Str"" + hfr + ""String_Node_Str""+ hsr+ ""String_Node_Str"");
  }
  mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
  mProfile.videoCodec=mVideoEncoder;
  mProfile.audioCodec=mAudioEncoder;
  mProfile.duration=mMaxVideoDurationInMs;
  if ((mProfile.audioCodec == MediaRecorder.AudioEncoder.AMR_NB) && !mCaptureTimeLapse && !isHFR) {
    mProfile.fileFormat=MediaRecorder.OutputFormat.THREE_GPP;
  }
  if ((isHFR || isHSR) && captureRate > 0) {
    if (isHSR) {
      Log.i(TAG,""String_Node_Str"");
      mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    }
    mMediaRecorder.setOutputFormat(mProfile.fileFormat);
    mMediaRecorder.setVideoFrameRate(mProfile.videoFrameRate);
    mMediaRecorder.setVideoEncodingBitRate(mProfile.videoBitRate);
    mMediaRecorder.setVideoEncoder(mProfile.videoCodec);
    if (isHSR) {
      Log.i(TAG,""String_Node_Str"");
      mMediaRecorder.setAudioEncodingBitRate(mProfile.audioBitRate);
      mMediaRecorder.setAudioChannels(mProfile.audioChannels);
      mMediaRecorder.setAudioSamplingRate(mProfile.audioSampleRate);
      mMediaRecorder.setAudioEncoder(mProfile.audioCodec);
    }
  }
 else {
    if (!mCaptureTimeLapse) {
      mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    }
    mMediaRecorder.setProfile(mProfile);
  }
  mMediaRecorder.setVideoSize(mProfile.videoFrameWidth,mProfile.videoFrameHeight);
  mMediaRecorder.setMaxDuration(mMaxVideoDurationInMs);
  if (mCaptureTimeLapse) {
    double fps=1000 / (double)mTimeBetweenTimeLapseFrameCaptureMs;
    setCaptureRate(mMediaRecorder,fps);
  }
 else   if (captureRate > 0) {
    Log.i(TAG,""String_Node_Str"" + captureRate);
    mMediaRecorder.setCaptureRate(captureRate);
    int targetFrameRate=isHSR ? captureRate : isHFR ? 30 : mProfile.videoFrameRate;
    Log.i(TAG,""String_Node_Str"" + targetFrameRate);
    mMediaRecorder.setVideoFrameRate(targetFrameRate);
    int scaledBitrate=mProfile.videoBitRate * targetFrameRate / mProfile.videoFrameRate;
    Log.i(TAG,""String_Node_Str"" + scaledBitrate);
    mMediaRecorder.setVideoEncodingBitRate(scaledBitrate);
  }
  setRecordLocation();
  if (mVideoFileDescriptor != null) {
    mMediaRecorder.setOutputFile(mVideoFileDescriptor.getFileDescriptor());
  }
 else {
    generateVideoFilename(mProfile.fileFormat);
    mMediaRecorder.setOutputFile(mVideoFilename);
  }
  long maxFileSize=mActivity.getStorageSpaceBytes() - Storage.LOW_STORAGE_THRESHOLD_BYTES;
  if (requestedSizeLimit > 0 && requestedSizeLimit < maxFileSize) {
    maxFileSize=requestedSizeLimit;
  }
  if (Storage.isSaveSDCard() && maxFileSize > SDCARD_SIZE_LIMIT) {
    maxFileSize=SDCARD_SIZE_LIMIT;
  }
  try {
    mMediaRecorder.setMaxFileSize(maxFileSize);
  }
 catch (  RuntimeException exception) {
  }
  int rotation=0;
  if (mOrientation != OrientationEventListener.ORIENTATION_UNKNOWN) {
    CameraInfo info=CameraHolder.instance().getCameraInfo()[mCameraId];
    if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
      rotation=(info.orientation - mOrientation + 360) % 360;
    }
 else {
      rotation=(info.orientation + mOrientation) % 360;
    }
  }
  mMediaRecorder.setOrientationHint(rotation);
  setupMediaRecorderPreviewDisplay();
  try {
    mMediaRecorder.prepare();
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"" + mVideoFilename,e);
    releaseMediaRecorder();
    throw new RuntimeException(e);
  }
  mMediaRecorder.setOnErrorListener(this);
  mMediaRecorder.setOnInfoListener(this);
}","private void initializeRecorder(){
  Log.v(TAG,""String_Node_Str"");
  if (mCameraDevice == null)   return;
  if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
    mUI.showSurfaceView();
  }
  Intent intent=mActivity.getIntent();
  Bundle myExtras=intent.getExtras();
  videoWidth=mProfile.videoFrameWidth;
  videoHeight=mProfile.videoFrameHeight;
  mUnsupportedResolution=false;
  List<VideoEncoderCap> videoEncoders=EncoderCapabilities.getVideoEncoders();
  for (  VideoEncoderCap videoEncoder : videoEncoders) {
    if (videoEncoder.mCodec == mVideoEncoder) {
      if (videoWidth > videoEncoder.mMaxFrameWidth || videoWidth < videoEncoder.mMinFrameWidth || videoHeight > videoEncoder.mMaxFrameHeight || videoHeight < videoEncoder.mMinFrameHeight) {
        Log.e(TAG,""String_Node_Str"" + mVideoEncoder + ""String_Node_Str""+ videoWidth+ ""String_Node_Str""+ videoHeight+ ""String_Node_Str"");
        Log.e(TAG,""String_Node_Str"" + ""String_Node_Str"" + videoEncoder.mMinFrameWidth + ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMinFrameHeight+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxFrameWidth+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxFrameHeight);
        mUnsupportedResolution=true;
        RotateTextToast.makeText(mActivity,R.string.error_app_unsupported,Toast.LENGTH_LONG).show();
        return;
      }
      break;
    }
  }
  long requestedSizeLimit=0;
  closeVideoFileDescriptor();
  mCurrentVideoUriFromMediaSaved=false;
  if (mIsVideoCaptureIntent && myExtras != null) {
    Uri saveUri=(Uri)myExtras.getParcelable(MediaStore.EXTRA_OUTPUT);
    if (saveUri != null) {
      try {
        mVideoFileDescriptor=mContentResolver.openFileDescriptor(saveUri,""String_Node_Str"");
        mCurrentVideoUri=saveUri;
      }
 catch (      java.io.FileNotFoundException ex) {
        Log.e(TAG,ex.toString());
      }
    }
    requestedSizeLimit=myExtras.getLong(MediaStore.EXTRA_SIZE_LIMIT);
  }
  mMediaRecorder=new MediaRecorder();
  mCameraDevice.unlock();
  mMediaRecorder.setCamera(mCameraDevice.getCamera());
  String hfr=mParameters.getVideoHighFrameRate();
  String hsr=mParameters.get(CameraSettings.KEY_VIDEO_HSR);
  Log.i(TAG,""String_Node_Str"" + hfr + ""String_Node_Str""+ hsr);
  int captureRate=0;
  boolean isHFR=(hfr != null && !hfr.equals(""String_Node_Str""));
  boolean isHSR=(hsr != null && !hsr.equals(""String_Node_Str""));
  try {
    captureRate=isHFR ? Integer.parseInt(hfr) : isHSR ? Integer.parseInt(hsr) : 0;
  }
 catch (  NumberFormatException nfe) {
    Log.e(TAG,""String_Node_Str"" + hfr + ""String_Node_Str""+ hsr+ ""String_Node_Str"");
  }
  mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
  mProfile.videoCodec=mVideoEncoder;
  mProfile.audioCodec=mAudioEncoder;
  mProfile.duration=mMaxVideoDurationInMs;
  if ((mProfile.audioCodec == MediaRecorder.AudioEncoder.AMR_NB) && !mCaptureTimeLapse && !isHFR) {
    mProfile.fileFormat=MediaRecorder.OutputFormat.THREE_GPP;
  }
  if ((isHFR || isHSR) && captureRate > 0) {
    if (isHSR) {
      Log.i(TAG,""String_Node_Str"");
      mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    }
    mMediaRecorder.setOutputFormat(mProfile.fileFormat);
    mMediaRecorder.setVideoFrameRate(mProfile.videoFrameRate);
    mMediaRecorder.setVideoEncodingBitRate(mProfile.videoBitRate);
    mMediaRecorder.setVideoEncoder(mProfile.videoCodec);
    if (isHSR) {
      Log.i(TAG,""String_Node_Str"");
      mMediaRecorder.setAudioEncodingBitRate(mProfile.audioBitRate);
      mMediaRecorder.setAudioChannels(mProfile.audioChannels);
      mMediaRecorder.setAudioSamplingRate(mProfile.audioSampleRate);
      mMediaRecorder.setAudioEncoder(mProfile.audioCodec);
    }
  }
 else {
    if (!mCaptureTimeLapse) {
      mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    }
    mMediaRecorder.setProfile(mProfile);
  }
  mMediaRecorder.setVideoSize(mProfile.videoFrameWidth,mProfile.videoFrameHeight);
  mMediaRecorder.setMaxDuration(mMaxVideoDurationInMs);
  if (mCaptureTimeLapse) {
    double fps=1000 / (double)mTimeBetweenTimeLapseFrameCaptureMs;
    setCaptureRate(mMediaRecorder,fps);
  }
 else   if (captureRate > 0) {
    Log.i(TAG,""String_Node_Str"" + captureRate);
    mMediaRecorder.setCaptureRate(captureRate);
    int targetFrameRate=isHSR ? captureRate : isHFR ? 30 : mProfile.videoFrameRate;
    Log.i(TAG,""String_Node_Str"" + targetFrameRate);
    mMediaRecorder.setVideoFrameRate(targetFrameRate);
    int scaledBitrate=mProfile.videoBitRate * (targetFrameRate / mProfile.videoFrameRate);
    Log.i(TAG,""String_Node_Str"" + scaledBitrate);
    mMediaRecorder.setVideoEncodingBitRate(scaledBitrate);
  }
  setRecordLocation();
  if (mVideoFileDescriptor != null) {
    mMediaRecorder.setOutputFile(mVideoFileDescriptor.getFileDescriptor());
  }
 else {
    generateVideoFilename(mProfile.fileFormat);
    mMediaRecorder.setOutputFile(mVideoFilename);
  }
  long maxFileSize=mActivity.getStorageSpaceBytes() - Storage.LOW_STORAGE_THRESHOLD_BYTES;
  if (requestedSizeLimit > 0 && requestedSizeLimit < maxFileSize) {
    maxFileSize=requestedSizeLimit;
  }
  if (Storage.isSaveSDCard() && maxFileSize > SDCARD_SIZE_LIMIT) {
    maxFileSize=SDCARD_SIZE_LIMIT;
  }
  try {
    mMediaRecorder.setMaxFileSize(maxFileSize);
  }
 catch (  RuntimeException exception) {
  }
  int rotation=0;
  if (mOrientation != OrientationEventListener.ORIENTATION_UNKNOWN) {
    CameraInfo info=CameraHolder.instance().getCameraInfo()[mCameraId];
    if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
      rotation=(info.orientation - mOrientation + 360) % 360;
    }
 else {
      rotation=(info.orientation + mOrientation) % 360;
    }
  }
  mMediaRecorder.setOrientationHint(rotation);
  setupMediaRecorderPreviewDisplay();
  try {
    mMediaRecorder.prepare();
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"" + mVideoFilename,e);
    releaseMediaRecorder();
    throw new RuntimeException(e);
  }
  mMediaRecorder.setOnErrorListener(this);
  mMediaRecorder.setOnInfoListener(this);
}","The original code had an integer division issue when calculating the scaled bitrate, which could lead to incorrect bitrate settings. In the fixed code, the bitrate calculation was modified to use parentheses `(targetFrameRate / mProfile.videoFrameRate)` to ensure proper integer division and prevent potential rounding errors. This change ensures more accurate video encoding parameters, resulting in better video quality and more predictable media recording performance."
38163,"@Override public boolean onScale(ScaleGestureDetector detector){
  final float sf=detector.getScaleFactor();
  float circle=mCircleSize * sf * sf;
  circle=Math.max(mMinCircle,circle);
  circle=Math.min(mMaxCircle,circle);
  if (mListener != null && circle != mCircleSize) {
    mCircleSize=circle;
    if (mCamera2) {
      float zoom=mZoomMinValue + (mZoomMaxValue - mZoomMinValue) / (mMaxCircle - mMinCircle) * (mCircleSize - mMinCircle);
      zoom=((int)(zoom * 10)) / 10.0f;
      mListener.onZoomValueChanged(zoom);
    }
 else {
      int zoom=mMinZoom + (int)((mCircleSize - mMinCircle) * (mMaxZoom - mMinZoom) / (mMaxCircle - mMinCircle));
      mListener.onZoomValueChanged(zoom);
    }
    update();
  }
  return true;
}","@Override public boolean onScale(ScaleGestureDetector detector){
  final float sf=detector.getScaleFactor();
  float circle=mCircleSize * sf * sf;
  circle=Math.max(mMinCircle,circle);
  circle=Math.min(mMaxCircle,circle);
  if (mListener != null && circle != mCircleSize) {
    mCircleSize=circle;
    if (mCamera2) {
      float zoom=mZoomMinValue + (mZoomMaxValue - mZoomMinValue) / (mMaxCircle - mMinCircle) * (mCircleSize - mMinCircle);
      mListener.onZoomValueChanged(zoom);
    }
 else {
      int zoom=mMinZoom + (int)((mCircleSize - mMinCircle) * (mMaxZoom - mMinZoom) / (mMaxCircle - mMinCircle));
      mListener.onZoomValueChanged(zoom);
    }
    update();
  }
  return true;
}","The buggy code introduced unnecessary rounding of the zoom value for Camera2 mode, potentially causing precision loss and inconsistent zoom scaling. The fixed code removes the `((int)(zoom * 10)) / 10.0f` rounding step, allowing for more accurate zoom calculations across different camera modes. This modification ensures smoother and more precise zoom transitions while maintaining the original scaling logic."
38164,"public void setZoom(float zoomValue){
  mCamera2=true;
  mZoomValue=zoomValue;
  mCircleSize=(int)(mMinCircle + (mMaxCircle - mMinCircle) * (mZoomValue - mZoomMinValue) / (mZoomMaxValue - mZoomMinValue));
}","public void setZoom(float zoomValue){
  mCamera2=true;
  mZoomSig=(int)zoomValue;
  mZoomFraction=(int)(zoomValue * 10) % 10;
  mCircleSize=(int)(mMinCircle + (mMaxCircle - mMinCircle) * (zoomValue - mZoomMinValue) / (mZoomMaxValue - mZoomMinValue));
}","The original code incorrectly assigns the entire zoom value to `mZoomValue`, potentially losing precision for fractional zoom levels. The fixed code separates the zoom value into integer (`mZoomSig`) and fractional (`mZoomFraction`) components, preserving more detailed zoom information. This modification allows for more granular zoom control and more accurate circle size calculation based on the complete zoom value."
38165,"@Override public void onDraw(Canvas canvas){
  canvas.rotate(mOrientation,mCenterX,mCenterY);
  mPaint.setStrokeWidth(mInnerStroke);
  canvas.drawCircle(mCenterX,mCenterY,mMinCircle,mPaint);
  canvas.drawCircle(mCenterX,mCenterY,mMaxCircle,mPaint);
  canvas.drawLine(mCenterX - mMinCircle,mCenterY,mCenterX - mMaxCircle - 4,mCenterY,mPaint);
  mPaint.setStrokeWidth(mOuterStroke);
  canvas.drawCircle((float)mCenterX,(float)mCenterY,mCircleSize,mPaint);
  String txt=mZoomSig + ""String_Node_Str"" + mZoomFraction+ ""String_Node_Str"";
  if (mCamera2)   txt=""String_Node_Str"" + mZoomValue;
  mTextPaint.getTextBounds(txt,0,txt.length(),mTextBounds);
  canvas.drawText(txt,mCenterX - mTextBounds.centerX(),mCenterY - mTextBounds.centerY(),mTextPaint);
}","@Override public void onDraw(Canvas canvas){
  canvas.rotate(mOrientation,mCenterX,mCenterY);
  mPaint.setStrokeWidth(mInnerStroke);
  canvas.drawCircle(mCenterX,mCenterY,mMinCircle,mPaint);
  canvas.drawCircle(mCenterX,mCenterY,mMaxCircle,mPaint);
  canvas.drawLine(mCenterX - mMinCircle,mCenterY,mCenterX - mMaxCircle - 4,mCenterY,mPaint);
  mPaint.setStrokeWidth(mOuterStroke);
  canvas.drawCircle((float)mCenterX,(float)mCenterY,mCircleSize,mPaint);
  String txt=mZoomSig + ""String_Node_Str"" + mZoomFraction+ ""String_Node_Str"";
  mTextPaint.getTextBounds(txt,0,txt.length(),mTextBounds);
  canvas.drawText(txt,mCenterX - mTextBounds.centerX(),mCenterY - mTextBounds.centerY(),mTextPaint);
}","The original code had an unnecessary conditional block for `mCamera2` that modified the text string without clear purpose, potentially leading to unexpected text rendering. In the fixed code, this condition was removed, ensuring consistent text generation based on `mZoomSig`, `mZoomFraction`, and a static string. By eliminating the redundant conditional logic, the code now provides a more predictable and straightforward text display mechanism for the drawing operation."
38166,"public void initSwitchItem(final String prefKey,View switcher){
  final IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
  if (pref == null)   return;
  int[] iconIds=pref.getLargeIconIds();
  int resid=-1;
  int index=pref.findIndexOfValue(pref.getValue());
  if (!pref.getUseSingleIcon() && iconIds != null) {
    resid=iconIds[index];
  }
 else {
    resid=pref.getSingleIcon();
  }
  ((ImageView)switcher).setImageResource(resid);
  switcher.setVisibility(View.VISIBLE);
  mPreferences.add(pref);
  mPreferenceMap.put(pref,switcher);
  switcher.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
      if (pref == null)       return;
      mUI.hideUI();
      int index=pref.findIndexOfValue(pref.getValue());
      CharSequence[] values=pref.getEntryValues();
      index=(index + 1) % values.length;
      pref.setValueIndex(index);
      ((ImageView)v).setImageResource(((IconListPreference)pref).getLargeIconIds()[index]);
      if (prefKey.equals(CameraSettings.KEY_CAMERA_ID))       mListener.onCameraPickerClicked(index);
      reloadPreference(pref);
      onSettingChanged(pref);
    }
  }
);
}","public void initSwitchItem(final String prefKey,View switcher){
  final IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
  if (pref == null)   return;
  int[] iconIds=pref.getLargeIconIds();
  int resid=-1;
  int index=pref.findIndexOfValue(pref.getValue());
  if (!pref.getUseSingleIcon() && iconIds != null) {
    resid=iconIds[index];
  }
 else {
    resid=pref.getSingleIcon();
  }
  ((ImageView)switcher).setImageResource(resid);
  switcher.setVisibility(View.VISIBLE);
  mPreferences.add(pref);
  mPreferenceMap.put(pref,switcher);
  switcher.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
      if (pref == null)       return;
      if (prefKey.equals(CameraSettings.KEY_CAMERA_ID)) {
        mUI.hideUI();
      }
      int index=pref.findIndexOfValue(pref.getValue());
      CharSequence[] values=pref.getEntryValues();
      index=(index + 1) % values.length;
      pref.setValueIndex(index);
      ((ImageView)v).setImageResource(((IconListPreference)pref).getLargeIconIds()[index]);
      if (prefKey.equals(CameraSettings.KEY_CAMERA_ID))       mListener.onCameraPickerClicked(index);
      reloadPreference(pref);
      onSettingChanged(pref);
    }
  }
);
}","The original code incorrectly hides the UI for all preference clicks, potentially disrupting user experience for non-camera preferences. The fixed code conditionally hides the UI only when the camera preference is selected, using a targeted check before UI hiding. This modification ensures more precise UI management, preventing unnecessary interface changes and providing a more controlled, context-specific interaction for different preference settings."
38167,"private void initializeRecorder(){
  Log.v(TAG,""String_Node_Str"");
  if (mCameraDevice == null)   return;
  if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
    mUI.showSurfaceView();
  }
  Intent intent=mActivity.getIntent();
  Bundle myExtras=intent.getExtras();
  videoWidth=mProfile.videoFrameWidth;
  videoHeight=mProfile.videoFrameHeight;
  mUnsupportedResolution=false;
  List<VideoEncoderCap> videoEncoders=EncoderCapabilities.getVideoEncoders();
  for (  VideoEncoderCap videoEncoder : videoEncoders) {
    if (videoEncoder.mCodec == mVideoEncoder) {
      if (videoWidth > videoEncoder.mMaxFrameWidth || videoWidth < videoEncoder.mMinFrameWidth || videoHeight > videoEncoder.mMaxFrameHeight || videoHeight < videoEncoder.mMinFrameHeight) {
        Log.e(TAG,""String_Node_Str"" + mVideoEncoder + ""String_Node_Str""+ videoWidth+ ""String_Node_Str""+ videoHeight+ ""String_Node_Str"");
        Log.e(TAG,""String_Node_Str"" + ""String_Node_Str"" + videoEncoder.mMinFrameWidth + ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMinFrameHeight+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxFrameWidth+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxFrameHeight);
        mUnsupportedResolution=true;
        RotateTextToast.makeText(mActivity,R.string.error_app_unsupported,Toast.LENGTH_LONG).show();
        return;
      }
      break;
    }
  }
  long requestedSizeLimit=0;
  closeVideoFileDescriptor();
  mCurrentVideoUriFromMediaSaved=false;
  if (mIsVideoCaptureIntent && myExtras != null) {
    Uri saveUri=(Uri)myExtras.getParcelable(MediaStore.EXTRA_OUTPUT);
    if (saveUri != null) {
      try {
        mVideoFileDescriptor=mContentResolver.openFileDescriptor(saveUri,""String_Node_Str"");
        mCurrentVideoUri=saveUri;
      }
 catch (      java.io.FileNotFoundException ex) {
        Log.e(TAG,ex.toString());
      }
    }
    requestedSizeLimit=myExtras.getLong(MediaStore.EXTRA_SIZE_LIMIT);
  }
  mMediaRecorder=new MediaRecorder();
  mCameraDevice.unlock();
  mMediaRecorder.setCamera(mCameraDevice.getCamera());
  String hfr=mParameters.getVideoHighFrameRate();
  String hsr=mParameters.get(CameraSettings.KEY_VIDEO_HSR);
  Log.i(TAG,""String_Node_Str"" + hfr + ""String_Node_Str""+ hsr);
  int captureRate=0;
  boolean isHFR=(hfr != null && !hfr.equals(""String_Node_Str""));
  boolean isHSR=(hsr != null && !hsr.equals(""String_Node_Str""));
  try {
    captureRate=isHFR ? Integer.parseInt(hfr) : isHSR ? Integer.parseInt(hsr) : 0;
  }
 catch (  NumberFormatException nfe) {
    Log.e(TAG,""String_Node_Str"" + hfr + ""String_Node_Str""+ hsr+ ""String_Node_Str"");
  }
  mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
  mProfile.videoCodec=mVideoEncoder;
  mProfile.audioCodec=mAudioEncoder;
  mProfile.duration=mMaxVideoDurationInMs;
  if ((mProfile.audioCodec == MediaRecorder.AudioEncoder.AMR_NB) && !mCaptureTimeLapse && !isHFR) {
    mProfile.fileFormat=MediaRecorder.OutputFormat.THREE_GPP;
  }
  if ((isHFR || isHSR) && captureRate > 0) {
    if (isHSR) {
      Log.i(TAG,""String_Node_Str"");
      mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    }
    mMediaRecorder.setOutputFormat(mProfile.fileFormat);
    mMediaRecorder.setVideoFrameRate(mProfile.videoFrameRate);
    mMediaRecorder.setVideoEncodingBitRate(mProfile.videoBitRate);
    mMediaRecorder.setVideoEncoder(mProfile.videoCodec);
    if (isHSR) {
      Log.i(TAG,""String_Node_Str"");
      mMediaRecorder.setAudioEncodingBitRate(mProfile.audioBitRate);
      mMediaRecorder.setAudioChannels(mProfile.audioChannels);
      mMediaRecorder.setAudioSamplingRate(mProfile.audioSampleRate);
      mMediaRecorder.setAudioEncoder(mProfile.audioCodec);
    }
  }
 else {
    if (!mCaptureTimeLapse) {
      mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    }
    mMediaRecorder.setProfile(mProfile);
  }
  mMediaRecorder.setVideoSize(mProfile.videoFrameWidth,mProfile.videoFrameHeight);
  mMediaRecorder.setMaxDuration(mMaxVideoDurationInMs);
  if (mCaptureTimeLapse) {
    double fps=1000 / (double)mTimeBetweenTimeLapseFrameCaptureMs;
    setCaptureRate(mMediaRecorder,fps);
  }
 else   if (captureRate > 0) {
    Log.i(TAG,""String_Node_Str"" + captureRate);
    mMediaRecorder.setCaptureRate(captureRate);
    int targetFrameRate=isHSR ? captureRate : isHFR ? 30 : mProfile.videoFrameRate;
    Log.i(TAG,""String_Node_Str"" + targetFrameRate);
    mMediaRecorder.setVideoFrameRate(targetFrameRate);
    int scaledBitrate=mProfile.videoBitRate * targetFrameRate / mProfile.videoFrameRate;
    Log.i(TAG,""String_Node_Str"" + scaledBitrate);
    mMediaRecorder.setVideoEncodingBitRate(scaledBitrate);
  }
  setRecordLocation();
  if (mVideoFileDescriptor != null) {
    mMediaRecorder.setOutputFile(mVideoFileDescriptor.getFileDescriptor());
  }
 else {
    generateVideoFilename(mProfile.fileFormat);
    mMediaRecorder.setOutputFile(mVideoFilename);
  }
  long maxFileSize=mActivity.getStorageSpaceBytes() - Storage.LOW_STORAGE_THRESHOLD_BYTES;
  if (requestedSizeLimit > 0 && requestedSizeLimit < maxFileSize) {
    maxFileSize=requestedSizeLimit;
  }
  if (Storage.isSaveSDCard() && maxFileSize > SDCARD_SIZE_LIMIT) {
    maxFileSize=SDCARD_SIZE_LIMIT;
  }
  try {
    mMediaRecorder.setMaxFileSize(maxFileSize);
  }
 catch (  RuntimeException exception) {
  }
  int rotation=0;
  if (mOrientation != OrientationEventListener.ORIENTATION_UNKNOWN) {
    CameraInfo info=CameraHolder.instance().getCameraInfo()[mCameraId];
    if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
      rotation=(info.orientation - mOrientation + 360) % 360;
    }
 else {
      rotation=(info.orientation + mOrientation) % 360;
    }
  }
  mMediaRecorder.setOrientationHint(rotation);
  setupMediaRecorderPreviewDisplay();
  try {
    mMediaRecorder.prepare();
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"" + mVideoFilename,e);
    releaseMediaRecorder();
    throw new RuntimeException(e);
  }
  mMediaRecorder.setOnErrorListener(this);
  mMediaRecorder.setOnInfoListener(this);
}","private void initializeRecorder(){
  Log.v(TAG,""String_Node_Str"");
  if (mCameraDevice == null)   return;
  if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
    mUI.showSurfaceView();
  }
  Intent intent=mActivity.getIntent();
  Bundle myExtras=intent.getExtras();
  videoWidth=mProfile.videoFrameWidth;
  videoHeight=mProfile.videoFrameHeight;
  mUnsupportedResolution=false;
  List<VideoEncoderCap> videoEncoders=EncoderCapabilities.getVideoEncoders();
  for (  VideoEncoderCap videoEncoder : videoEncoders) {
    if (videoEncoder.mCodec == mVideoEncoder) {
      if (videoWidth > videoEncoder.mMaxFrameWidth || videoWidth < videoEncoder.mMinFrameWidth || videoHeight > videoEncoder.mMaxFrameHeight || videoHeight < videoEncoder.mMinFrameHeight) {
        Log.e(TAG,""String_Node_Str"" + mVideoEncoder + ""String_Node_Str""+ videoWidth+ ""String_Node_Str""+ videoHeight+ ""String_Node_Str"");
        Log.e(TAG,""String_Node_Str"" + ""String_Node_Str"" + videoEncoder.mMinFrameWidth + ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMinFrameHeight+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxFrameWidth+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxFrameHeight);
        mUnsupportedResolution=true;
        RotateTextToast.makeText(mActivity,R.string.error_app_unsupported,Toast.LENGTH_LONG).show();
        return;
      }
      break;
    }
  }
  long requestedSizeLimit=0;
  closeVideoFileDescriptor();
  mCurrentVideoUriFromMediaSaved=false;
  if (mIsVideoCaptureIntent && myExtras != null) {
    Uri saveUri=(Uri)myExtras.getParcelable(MediaStore.EXTRA_OUTPUT);
    if (saveUri != null) {
      try {
        mVideoFileDescriptor=mContentResolver.openFileDescriptor(saveUri,""String_Node_Str"");
        mCurrentVideoUri=saveUri;
      }
 catch (      java.io.FileNotFoundException ex) {
        Log.e(TAG,ex.toString());
      }
    }
    requestedSizeLimit=myExtras.getLong(MediaStore.EXTRA_SIZE_LIMIT);
  }
  mMediaRecorder=new MediaRecorder();
  mCameraDevice.unlock();
  mMediaRecorder.setCamera(mCameraDevice.getCamera());
  String hfr=mParameters.getVideoHighFrameRate();
  String hsr=mParameters.get(CameraSettings.KEY_VIDEO_HSR);
  Log.i(TAG,""String_Node_Str"" + hfr + ""String_Node_Str""+ hsr);
  int captureRate=0;
  boolean isHFR=(hfr != null && !hfr.equals(""String_Node_Str""));
  boolean isHSR=(hsr != null && !hsr.equals(""String_Node_Str""));
  try {
    captureRate=isHFR ? Integer.parseInt(hfr) : isHSR ? Integer.parseInt(hsr) : 0;
  }
 catch (  NumberFormatException nfe) {
    Log.e(TAG,""String_Node_Str"" + hfr + ""String_Node_Str""+ hsr+ ""String_Node_Str"");
  }
  mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
  mProfile.videoCodec=mVideoEncoder;
  mProfile.audioCodec=mAudioEncoder;
  mProfile.duration=mMaxVideoDurationInMs;
  if ((mProfile.audioCodec == MediaRecorder.AudioEncoder.AMR_NB) && !mCaptureTimeLapse && !isHFR) {
    mProfile.fileFormat=MediaRecorder.OutputFormat.THREE_GPP;
  }
  if ((isHFR || isHSR) && captureRate > 0) {
    if (isHSR) {
      Log.i(TAG,""String_Node_Str"");
      mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    }
    mMediaRecorder.setOutputFormat(mProfile.fileFormat);
    mMediaRecorder.setVideoFrameRate(mProfile.videoFrameRate);
    mMediaRecorder.setVideoEncodingBitRate(mProfile.videoBitRate);
    mMediaRecorder.setVideoEncoder(mProfile.videoCodec);
    if (isHSR) {
      Log.i(TAG,""String_Node_Str"");
      mMediaRecorder.setAudioEncodingBitRate(mProfile.audioBitRate);
      mMediaRecorder.setAudioChannels(mProfile.audioChannels);
      mMediaRecorder.setAudioSamplingRate(mProfile.audioSampleRate);
      mMediaRecorder.setAudioEncoder(mProfile.audioCodec);
    }
  }
 else {
    if (!mCaptureTimeLapse) {
      mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
    }
    mMediaRecorder.setProfile(mProfile);
  }
  mMediaRecorder.setVideoSize(mProfile.videoFrameWidth,mProfile.videoFrameHeight);
  mMediaRecorder.setMaxDuration(mMaxVideoDurationInMs);
  if (mCaptureTimeLapse) {
    double fps=1000 / (double)mTimeBetweenTimeLapseFrameCaptureMs;
    setCaptureRate(mMediaRecorder,fps);
  }
 else   if (captureRate > 0) {
    Log.i(TAG,""String_Node_Str"" + captureRate);
    mMediaRecorder.setCaptureRate(captureRate);
    int targetFrameRate=isHSR ? captureRate : isHFR ? 30 : mProfile.videoFrameRate;
    Log.i(TAG,""String_Node_Str"" + targetFrameRate);
    mMediaRecorder.setVideoFrameRate(targetFrameRate);
    int scaledBitrate=mProfile.videoBitRate * (targetFrameRate / mProfile.videoFrameRate);
    Log.i(TAG,""String_Node_Str"" + scaledBitrate);
    mMediaRecorder.setVideoEncodingBitRate(scaledBitrate);
  }
  setRecordLocation();
  if (mVideoFileDescriptor != null) {
    mMediaRecorder.setOutputFile(mVideoFileDescriptor.getFileDescriptor());
  }
 else {
    generateVideoFilename(mProfile.fileFormat);
    mMediaRecorder.setOutputFile(mVideoFilename);
  }
  long maxFileSize=mActivity.getStorageSpaceBytes() - Storage.LOW_STORAGE_THRESHOLD_BYTES;
  if (requestedSizeLimit > 0 && requestedSizeLimit < maxFileSize) {
    maxFileSize=requestedSizeLimit;
  }
  if (Storage.isSaveSDCard() && maxFileSize > SDCARD_SIZE_LIMIT) {
    maxFileSize=SDCARD_SIZE_LIMIT;
  }
  try {
    mMediaRecorder.setMaxFileSize(maxFileSize);
  }
 catch (  RuntimeException exception) {
  }
  int rotation=0;
  if (mOrientation != OrientationEventListener.ORIENTATION_UNKNOWN) {
    CameraInfo info=CameraHolder.instance().getCameraInfo()[mCameraId];
    if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
      rotation=(info.orientation - mOrientation + 360) % 360;
    }
 else {
      rotation=(info.orientation + mOrientation) % 360;
    }
  }
  mMediaRecorder.setOrientationHint(rotation);
  setupMediaRecorderPreviewDisplay();
  try {
    mMediaRecorder.prepare();
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"" + mVideoFilename,e);
    releaseMediaRecorder();
    throw new RuntimeException(e);
  }
  mMediaRecorder.setOnErrorListener(this);
  mMediaRecorder.setOnInfoListener(this);
}","The original code had a potential integer division issue when calculating the scaled bitrate, which could lead to incorrect bitrate settings. In the fixed code, the bitrate calculation was modified to use integer division with explicit parentheses `(targetFrameRate / mProfile.videoFrameRate)`, ensuring accurate scaling of the video bitrate. This change guarantees more precise bitrate adjustment based on the target frame rate, improving video encoding quality and consistency."
38168,"@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mContentResolver=mActivity.getContentResolver();
  mIsImageCaptureIntent=isImageCaptureIntent();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mUI=new PhotoUI(activity,this,parent);
  if (mOpenCameraThread == null) {
    mOpenCameraThread=new OpenCameraThread();
    mOpenCameraThread.start();
  }
  initializeControlByIntent();
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,mUI);
  mSensorManager=(SensorManager)(mActivity.getSystemService(Context.SENSOR_SERVICE));
  brightnessProgressBar=(ProgressBar)mRootView.findViewById(R.id.progress);
  if (brightnessProgressBar instanceof SeekBar) {
    SeekBar seeker=(SeekBar)brightnessProgressBar;
    seeker.setOnSeekBarChangeListener(mSeekListener);
  }
  brightnessProgressBar.setMax(MAXIMUM_BRIGHTNESS);
  mbrightness=mPreferences.getInt(CameraSettings.KEY_BRIGHTNESS,DEFAULT_BRIGHTNESS);
  brightnessProgressBar.setProgress(mbrightness);
  brightnessProgressBar.setVisibility(View.INVISIBLE);
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
}","@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mContentResolver=mActivity.getContentResolver();
  mIsImageCaptureIntent=isImageCaptureIntent();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mUI=new PhotoUI(activity,this,parent);
  if (mOpenCameraThread == null) {
    mOpenCameraThread=new OpenCameraThread();
    mOpenCameraThread.start();
  }
  initializeControlByIntent();
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,mUI);
  mSensorManager=(SensorManager)(mActivity.getSystemService(Context.SENSOR_SERVICE));
  brightnessProgressBar=(ProgressBar)mRootView.findViewById(R.id.progress);
  if (brightnessProgressBar instanceof SeekBar) {
    SeekBar seeker=(SeekBar)brightnessProgressBar;
    seeker.setOnSeekBarChangeListener(mSeekListener);
  }
  brightnessProgressBar.setMax(MAXIMUM_BRIGHTNESS);
  mbrightness=mPreferences.getInt(CameraSettings.KEY_BRIGHTNESS,DEFAULT_BRIGHTNESS);
  brightnessProgressBar.setProgress(mbrightness);
  brightnessProgressBar.setVisibility(View.INVISIBLE);
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
}","The original code directly instantiated a new ComboPreferences object without checking for an existing instance, potentially causing unnecessary object creation and resource overhead. The fixed code uses ComboPreferences.get() method to retrieve an existing preferences instance, and creates a new one only if no instance exists. This approach ensures efficient preference management, prevents redundant object creation, and provides a more robust initialization mechanism for camera preferences."
38169,"public void reinit(){
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","public void reinit(){
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","The original code always creates a new ComboPreferences instance, potentially overwriting existing preferences and losing user settings. The fixed code first attempts to retrieve existing preferences using ComboPreferences.get(), and only creates a new instance if no preferences exist, preserving user data and configuration. This approach ensures preference continuity and prevents unintentional data loss during reinitialization."
38170,"private SettingsManager(Context context){
  mListeners=new ArrayList<>();
  mCharacteristics=new ArrayList<>();
  mContext=context;
  mPreferences=new ComboPreferences(mContext);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mContext);
  CameraManager manager=(CameraManager)mContext.getSystemService(Context.CAMERA_SERVICE);
  try {
    String[] cameraIdList=manager.getCameraIdList();
    for (int i=0; i < cameraIdList.length; i++) {
      String cameraId=cameraIdList[i];
      CameraCharacteristics characteristics=manager.getCameraCharacteristics(cameraId);
      Byte monoOnly=0;
      try {
        monoOnly=characteristics.get(CaptureModule.MetaDataMonoOnlyKey);
      }
 catch (      Exception e) {
      }
      if (monoOnly == 1) {
        CaptureModule.MONO_ID=i;
        mIsMonoCameraPresent=true;
      }
      int facing=characteristics.get(CameraCharacteristics.LENS_FACING);
      if (facing == CameraCharacteristics.LENS_FACING_FRONT) {
        CaptureModule.FRONT_ID=i;
        mIsFrontCameraPresent=true;
      }
      mCharacteristics.add(i,characteristics);
    }
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
}","private SettingsManager(Context context){
  mListeners=new ArrayList<>();
  mCharacteristics=new ArrayList<>();
  mContext=context;
  mPreferences=ComboPreferences.get(mContext);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mContext);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mContext);
  CameraManager manager=(CameraManager)mContext.getSystemService(Context.CAMERA_SERVICE);
  try {
    String[] cameraIdList=manager.getCameraIdList();
    for (int i=0; i < cameraIdList.length; i++) {
      String cameraId=cameraIdList[i];
      CameraCharacteristics characteristics=manager.getCameraCharacteristics(cameraId);
      Byte monoOnly=0;
      try {
        monoOnly=characteristics.get(CaptureModule.MetaDataMonoOnlyKey);
      }
 catch (      Exception e) {
      }
      if (monoOnly == 1) {
        CaptureModule.MONO_ID=i;
        mIsMonoCameraPresent=true;
      }
      int facing=characteristics.get(CameraCharacteristics.LENS_FACING);
      if (facing == CameraCharacteristics.LENS_FACING_FRONT) {
        CaptureModule.FRONT_ID=i;
        mIsFrontCameraPresent=true;
      }
      mCharacteristics.add(i,characteristics);
    }
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
}","The original code directly instantiates a new ComboPreferences without checking for an existing instance, which could lead to unnecessary object creation and potential preference conflicts. The fixed code uses ComboPreferences.get() to retrieve an existing preferences instance, and creates a new one only if no instance exists, ensuring proper preference management. This approach optimizes resource usage and maintains consistent preference handling across the application."
38171,"@Override public void init(CameraActivity activity,View root){
  mActivity=activity;
  mUI=new VideoUI(activity,this,root);
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mOrientationManager=new OrientationManager(mActivity);
  CameraOpenThread cameraOpenThread=new CameraOpenThread();
  cameraOpenThread.start();
  mContentResolver=mActivity.getContentResolver();
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
  mSaveToSDCard=Storage.isSaveSDCard();
  mIsVideoCaptureIntent=isVideoCaptureIntent();
  initializeSurfaceView();
  try {
    cameraOpenThread.join();
    if (mCameraDevice == null) {
      return;
    }
  }
 catch (  InterruptedException ex) {
  }
  readVideoPreferences();
  mUI.setPrefChangedListener(this);
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,null);
  mUI.setOrientationIndicator(0,false);
  setDisplayOrientation();
  mUI.showTimeLapseUI(mCaptureTimeLapse);
  initializeVideoSnapshot();
  resizeForPreviewAspectRatio();
  initializeVideoControl();
  mPendingSwitchCameraId=-1;
}","@Override public void init(CameraActivity activity,View root){
  mActivity=activity;
  mUI=new VideoUI(activity,this,root);
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mOrientationManager=new OrientationManager(mActivity);
  CameraOpenThread cameraOpenThread=new CameraOpenThread();
  cameraOpenThread.start();
  mContentResolver=mActivity.getContentResolver();
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
  mSaveToSDCard=Storage.isSaveSDCard();
  mIsVideoCaptureIntent=isVideoCaptureIntent();
  initializeSurfaceView();
  try {
    cameraOpenThread.join();
    if (mCameraDevice == null) {
      return;
    }
  }
 catch (  InterruptedException ex) {
  }
  readVideoPreferences();
  mUI.setPrefChangedListener(this);
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,null);
  mUI.setOrientationIndicator(0,false);
  setDisplayOrientation();
  mUI.showTimeLapseUI(mCaptureTimeLapse);
  initializeVideoSnapshot();
  resizeForPreviewAspectRatio();
  initializeVideoControl();
  mPendingSwitchCameraId=-1;
}","The original code directly instantiated a new ComboPreferences object without checking for an existing instance, potentially creating unnecessary duplicate preferences. The fixed code uses ComboPreferences.get() method to retrieve an existing preferences object, and creates a new one only if no instance exists. This approach ensures efficient preference management, prevents redundant object creation, and provides a more robust mechanism for handling application preferences."
38172,"public void reinit(){
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","public void reinit(){
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","The original code always creates a new ComboPreferences instance, potentially overwriting existing preferences and losing user settings. The fixed code first attempts to retrieve existing preferences using ComboPreferences.get(), and only creates a new instance if none exists, preserving user data and configuration. This approach ensures preference continuity and prevents unintentional data loss during reinitialization."
38173,"@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mOrientationManager=new OrientationManager(activity);
  mCaptureState=CAPTURE_STATE_VIEWFINDER;
  mUI=new WideAnglePanoramaUI(mActivity,this,(ViewGroup)mRootView);
  mUI.setCaptureProgressOnDirectionChangeListener(new PanoProgressBar.OnDirectionChangeListener(){
    @Override public void onDirectionChange(    int direction){
      if (mDirectionChanged) {
        stopCapture(false);
        return;
      }
      if (mCaptureState == CAPTURE_STATE_MOSAIC) {
        mUI.showDirectionIndicators(direction);
      }
      if (direction != PanoProgressBar.DIRECTION_NONE) {
        mDirectionChanged=true;
      }
    }
  }
);
  mContentResolver=mActivity.getContentResolver();
  mOnFrameAvailableRunnable=new Runnable(){
    @Override public void run(){
      if (mPaused)       return;
      MosaicPreviewRenderer renderer=null;
synchronized (mRendererLock) {
        if (mMosaicPreviewRenderer == null) {
          return;
        }
        renderer=mMosaicPreviewRenderer;
      }
      if (mRootView.getVisibility() != View.VISIBLE) {
        renderer.showPreviewFrameSync();
        mRootView.setVisibility(View.VISIBLE);
      }
 else {
        if (mCaptureState == CAPTURE_STATE_VIEWFINDER) {
          if (mPreviewLayoutChanged) {
            boolean isLandscape=(mDeviceOrientation / 90) % 2 == 1;
            renderer.previewReset(mPreviewUIWidth,mPreviewUIHeight,isLandscape,mDeviceOrientation);
            mPreviewLayoutChanged=false;
          }
          renderer.showPreviewFrame();
        }
 else {
          renderer.alignFrameSync();
          mMosaicFrameProcessor.processFrame();
        }
      }
    }
  }
;
  PowerManager pm=(PowerManager)mActivity.getSystemService(Context.POWER_SERVICE);
  mPartialWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mOrientationEventListener=new PanoOrientationEventListener(mActivity);
  mMosaicFrameProcessor=MosaicFrameProcessor.getInstance();
  Resources appRes=mActivity.getResources();
  mPreparePreviewString=appRes.getString(R.string.pano_dialog_prepare_preview);
  mDialogTitle=appRes.getString(R.string.pano_dialog_title);
  mDialogOkString=appRes.getString(R.string.dialog_ok);
  mDialogPanoramaFailedString=appRes.getString(R.string.pano_dialog_panorama_failed);
  mDialogWaitingPreviousString=appRes.getString(R.string.pano_dialog_waiting_previous);
  mPreferences=new ComboPreferences(mActivity);
  mPreferences.setLocalId(mActivity,getPreferredCameraId(mPreferences));
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mLocationManager=new LocationManager(mActivity,null);
  mMainHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_LOW_RES_FINAL_MOSAIC_READY:
        onBackgroundThreadFinished();
      saveFinalMosaic((Bitmap)msg.obj);
    saveHighResMosaic();
  break;
case MSG_GENERATE_FINAL_MOSAIC_ERROR:
onBackgroundThreadFinished();
if (mPaused) {
resetToPreviewIfPossible();
}
 else {
mUI.showAlertDialog(mDialogTitle,mDialogPanoramaFailedString,mDialogOkString,new Runnable(){
  @Override public void run(){
    resetToPreviewIfPossible();
  }
}
);
}
clearMosaicFrameProcessorIfNeeded();
break;
case MSG_END_DIALOG_RESET_TO_PREVIEW:
onBackgroundThreadFinished();
resetToPreviewIfPossible();
clearMosaicFrameProcessorIfNeeded();
break;
case MSG_CLEAR_SCREEN_DELAY:
mActivity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
break;
case MSG_RESET_TO_PREVIEW:
resetToPreviewIfPossible();
break;
}
}
}
;
}","@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mOrientationManager=new OrientationManager(activity);
  mCaptureState=CAPTURE_STATE_VIEWFINDER;
  mUI=new WideAnglePanoramaUI(mActivity,this,(ViewGroup)mRootView);
  mUI.setCaptureProgressOnDirectionChangeListener(new PanoProgressBar.OnDirectionChangeListener(){
    @Override public void onDirectionChange(    int direction){
      if (mDirectionChanged) {
        stopCapture(false);
        return;
      }
      if (mCaptureState == CAPTURE_STATE_MOSAIC) {
        mUI.showDirectionIndicators(direction);
      }
      if (direction != PanoProgressBar.DIRECTION_NONE) {
        mDirectionChanged=true;
      }
    }
  }
);
  mContentResolver=mActivity.getContentResolver();
  mOnFrameAvailableRunnable=new Runnable(){
    @Override public void run(){
      if (mPaused)       return;
      MosaicPreviewRenderer renderer=null;
synchronized (mRendererLock) {
        if (mMosaicPreviewRenderer == null) {
          return;
        }
        renderer=mMosaicPreviewRenderer;
      }
      if (mRootView.getVisibility() != View.VISIBLE) {
        renderer.showPreviewFrameSync();
        mRootView.setVisibility(View.VISIBLE);
      }
 else {
        if (mCaptureState == CAPTURE_STATE_VIEWFINDER) {
          if (mPreviewLayoutChanged) {
            boolean isLandscape=(mDeviceOrientation / 90) % 2 == 1;
            renderer.previewReset(mPreviewUIWidth,mPreviewUIHeight,isLandscape,mDeviceOrientation);
            mPreviewLayoutChanged=false;
          }
          renderer.showPreviewFrame();
        }
 else {
          renderer.alignFrameSync();
          mMosaicFrameProcessor.processFrame();
        }
      }
    }
  }
;
  PowerManager pm=(PowerManager)mActivity.getSystemService(Context.POWER_SERVICE);
  mPartialWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mOrientationEventListener=new PanoOrientationEventListener(mActivity);
  mMosaicFrameProcessor=MosaicFrameProcessor.getInstance();
  Resources appRes=mActivity.getResources();
  mPreparePreviewString=appRes.getString(R.string.pano_dialog_prepare_preview);
  mDialogTitle=appRes.getString(R.string.pano_dialog_title);
  mDialogOkString=appRes.getString(R.string.dialog_ok);
  mDialogPanoramaFailedString=appRes.getString(R.string.pano_dialog_panorama_failed);
  mDialogWaitingPreviousString=appRes.getString(R.string.pano_dialog_waiting_previous);
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  mPreferences.setLocalId(mActivity,getPreferredCameraId(mPreferences));
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mLocationManager=new LocationManager(mActivity,null);
  mMainHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_LOW_RES_FINAL_MOSAIC_READY:
        onBackgroundThreadFinished();
      saveFinalMosaic((Bitmap)msg.obj);
    saveHighResMosaic();
  break;
case MSG_GENERATE_FINAL_MOSAIC_ERROR:
onBackgroundThreadFinished();
if (mPaused) {
resetToPreviewIfPossible();
}
 else {
mUI.showAlertDialog(mDialogTitle,mDialogPanoramaFailedString,mDialogOkString,new Runnable(){
  @Override public void run(){
    resetToPreviewIfPossible();
  }
}
);
}
clearMosaicFrameProcessorIfNeeded();
break;
case MSG_END_DIALOG_RESET_TO_PREVIEW:
onBackgroundThreadFinished();
resetToPreviewIfPossible();
clearMosaicFrameProcessorIfNeeded();
break;
case MSG_CLEAR_SCREEN_DELAY:
mActivity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
break;
case MSG_RESET_TO_PREVIEW:
resetToPreviewIfPossible();
break;
}
}
}
;
}","The original code directly instantiated a new ComboPreferences object without checking for an existing instance, potentially leading to unnecessary object creation and resource inefficiency. The fixed code uses ComboPreferences.get() to retrieve an existing preferences instance, and adds a null check to create a new object only if no instance exists. This approach optimizes memory usage, ensures proper preference management, and provides a more robust initialization mechanism for camera preferences."
38174,"@Override public void onResumeBeforeSuper(){
  mPaused=false;
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mPreferences.setLocalId(mActivity,getPreferredCameraId(mPreferences));
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","@Override public void onResumeBeforeSuper(){
  mPaused=false;
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mPreferences.setLocalId(mActivity,getPreferredCameraId(mPreferences));
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","The original code always creates a new ComboPreferences instance, potentially losing existing preferences and causing unnecessary overhead. The fixed code uses ComboPreferences.get() to retrieve an existing preferences object, and only creates a new instance if none exists, ensuring preference preservation and efficient resource management. This approach prevents unintended preference resets and provides a more robust method for handling application preferences across activity lifecycle events."
38175,"@Override public boolean onScale(ScaleGestureDetector detector){
  final float sf=detector.getScaleFactor();
  float circle=mCircleSize * sf * sf;
  circle=Math.max(mMinCircle,circle);
  circle=Math.min(mMaxCircle,circle);
  if (mListener != null && circle != mCircleSize) {
    mCircleSize=circle;
    if (mCamera2) {
      float zoom=mZoomMinValue + (mZoomMaxValue - mZoomMinValue) / (mMaxCircle - mMinCircle) * (mCircleSize - mMinCircle);
      zoom=((int)(zoom * 10)) / 10.0f;
      mListener.onZoomValueChanged(zoom);
    }
 else {
      int zoom=mMinZoom + (int)((mCircleSize - mMinCircle) * (mMaxZoom - mMinZoom) / (mMaxCircle - mMinCircle));
      mListener.onZoomValueChanged(zoom);
    }
    update();
  }
  return true;
}","@Override public boolean onScale(ScaleGestureDetector detector){
  final float sf=detector.getScaleFactor();
  float circle=mCircleSize * sf * sf;
  circle=Math.max(mMinCircle,circle);
  circle=Math.min(mMaxCircle,circle);
  if (mListener != null && circle != mCircleSize) {
    mCircleSize=circle;
    if (mCamera2) {
      float zoom=mZoomMinValue + (mZoomMaxValue - mZoomMinValue) / (mMaxCircle - mMinCircle) * (mCircleSize - mMinCircle);
      mListener.onZoomValueChanged(zoom);
    }
 else {
      int zoom=mMinZoom + (int)((mCircleSize - mMinCircle) * (mMaxZoom - mMinZoom) / (mMaxCircle - mMinCircle));
      mListener.onZoomValueChanged(zoom);
    }
    update();
  }
  return true;
}","The original code unnecessarily rounded the zoom value to one decimal place in the Camera2 mode, potentially introducing imprecision. In the fixed code, this rounding step was removed, allowing for more accurate zoom calculations. By preserving the full precision of the zoom value, the fixed implementation provides a smoother and more precise zooming experience across different camera modes."
38176,"public void setZoom(float zoomValue){
  mCamera2=true;
  mZoomValue=zoomValue;
  mCircleSize=(int)(mMinCircle + (mMaxCircle - mMinCircle) * (mZoomValue - mZoomMinValue) / (mZoomMaxValue - mZoomMinValue));
}","public void setZoom(float zoomValue){
  mCamera2=true;
  mZoomSig=(int)zoomValue;
  mZoomFraction=(int)(zoomValue * 10) % 10;
  mCircleSize=(int)(mMinCircle + (mMaxCircle - mMinCircle) * (zoomValue - mZoomMinValue) / (mZoomMaxValue - mZoomMinValue));
}","The original code lacks precision in handling zoom values by directly assigning the input to mZoomValue without separating integer and fractional components. The fixed code introduces mZoomSig and mZoomFraction to capture the whole number and decimal parts of the zoom value, enabling more granular zoom control. This modification allows for more accurate zoom calculations and provides better handling of decimal zoom levels, improving the overall zoom functionality."
38177,"@Override public void onDraw(Canvas canvas){
  canvas.rotate(mOrientation,mCenterX,mCenterY);
  mPaint.setStrokeWidth(mInnerStroke);
  canvas.drawCircle(mCenterX,mCenterY,mMinCircle,mPaint);
  canvas.drawCircle(mCenterX,mCenterY,mMaxCircle,mPaint);
  canvas.drawLine(mCenterX - mMinCircle,mCenterY,mCenterX - mMaxCircle - 4,mCenterY,mPaint);
  mPaint.setStrokeWidth(mOuterStroke);
  canvas.drawCircle((float)mCenterX,(float)mCenterY,mCircleSize,mPaint);
  String txt=mZoomSig + ""String_Node_Str"" + mZoomFraction+ ""String_Node_Str"";
  if (mCamera2)   txt=""String_Node_Str"" + mZoomValue;
  mTextPaint.getTextBounds(txt,0,txt.length(),mTextBounds);
  canvas.drawText(txt,mCenterX - mTextBounds.centerX(),mCenterY - mTextBounds.centerY(),mTextPaint);
}","@Override public void onDraw(Canvas canvas){
  canvas.rotate(mOrientation,mCenterX,mCenterY);
  mPaint.setStrokeWidth(mInnerStroke);
  canvas.drawCircle(mCenterX,mCenterY,mMinCircle,mPaint);
  canvas.drawCircle(mCenterX,mCenterY,mMaxCircle,mPaint);
  canvas.drawLine(mCenterX - mMinCircle,mCenterY,mCenterX - mMaxCircle - 4,mCenterY,mPaint);
  mPaint.setStrokeWidth(mOuterStroke);
  canvas.drawCircle((float)mCenterX,(float)mCenterY,mCircleSize,mPaint);
  String txt=mZoomSig + ""String_Node_Str"" + mZoomFraction+ ""String_Node_Str"";
  mTextPaint.getTextBounds(txt,0,txt.length(),mTextBounds);
  canvas.drawText(txt,mCenterX - mTextBounds.centerX(),mCenterY - mTextBounds.centerY(),mTextPaint);
}","The original code contained an unnecessary conditional block for `mCamera2` that modified the text string, potentially causing unexpected text rendering. In the fixed code, this condition was removed, allowing the text to be consistently constructed using `mZoomSig`, `mZoomFraction`, and predefined string nodes. By eliminating the conditional text modification, the code now ensures a more predictable and stable text display, improving the reliability of the drawing method."
38178,"@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mContentResolver=mActivity.getContentResolver();
  mIsImageCaptureIntent=isImageCaptureIntent();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mUI=new PhotoUI(activity,this,parent);
  if (mOpenCameraThread == null) {
    mOpenCameraThread=new OpenCameraThread();
    mOpenCameraThread.start();
  }
  initializeControlByIntent();
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,mUI);
  mSensorManager=(SensorManager)(mActivity.getSystemService(Context.SENSOR_SERVICE));
  brightnessProgressBar=(ProgressBar)mRootView.findViewById(R.id.progress);
  if (brightnessProgressBar instanceof SeekBar) {
    SeekBar seeker=(SeekBar)brightnessProgressBar;
    seeker.setOnSeekBarChangeListener(mSeekListener);
  }
  brightnessProgressBar.setMax(MAXIMUM_BRIGHTNESS);
  mbrightness=mPreferences.getInt(CameraSettings.KEY_BRIGHTNESS,DEFAULT_BRIGHTNESS);
  brightnessProgressBar.setProgress(mbrightness);
  brightnessProgressBar.setVisibility(View.INVISIBLE);
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
}","@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mContentResolver=mActivity.getContentResolver();
  mIsImageCaptureIntent=isImageCaptureIntent();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mUI=new PhotoUI(activity,this,parent);
  if (mOpenCameraThread == null) {
    mOpenCameraThread=new OpenCameraThread();
    mOpenCameraThread.start();
  }
  initializeControlByIntent();
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,mUI);
  mSensorManager=(SensorManager)(mActivity.getSystemService(Context.SENSOR_SERVICE));
  brightnessProgressBar=(ProgressBar)mRootView.findViewById(R.id.progress);
  if (brightnessProgressBar instanceof SeekBar) {
    SeekBar seeker=(SeekBar)brightnessProgressBar;
    seeker.setOnSeekBarChangeListener(mSeekListener);
  }
  brightnessProgressBar.setMax(MAXIMUM_BRIGHTNESS);
  mbrightness=mPreferences.getInt(CameraSettings.KEY_BRIGHTNESS,DEFAULT_BRIGHTNESS);
  brightnessProgressBar.setProgress(mbrightness);
  brightnessProgressBar.setVisibility(View.INVISIBLE);
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
}","The original code directly instantiates a new ComboPreferences without checking for existing preferences, potentially causing redundant or inconsistent preference objects. The fixed code uses ComboPreferences.get() method to retrieve existing preferences first, and creates a new instance only if none exist, ensuring proper preference management. This approach prevents unnecessary object creation and maintains a single, consistent preference configuration across the camera application."
38179,"public void reinit(){
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","public void reinit(){
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","The original code always creates a new ComboPreferences instance, potentially overwriting existing preferences and losing user settings. The fixed code first attempts to retrieve existing preferences using ComboPreferences.get(), and only creates a new instance if no preferences exist, preserving user data and configuration. This approach ensures preference continuity and prevents unintended data loss during reinitialization."
38180,"private SettingsManager(Context context){
  mListeners=new ArrayList<>();
  mCharacteristics=new ArrayList<>();
  mContext=context;
  mPreferences=new ComboPreferences(mContext);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mContext);
  CameraManager manager=(CameraManager)mContext.getSystemService(Context.CAMERA_SERVICE);
  try {
    String[] cameraIdList=manager.getCameraIdList();
    for (int i=0; i < cameraIdList.length; i++) {
      String cameraId=cameraIdList[i];
      CameraCharacteristics characteristics=manager.getCameraCharacteristics(cameraId);
      Byte monoOnly=0;
      try {
        monoOnly=characteristics.get(CaptureModule.MetaDataMonoOnlyKey);
      }
 catch (      Exception e) {
      }
      if (monoOnly == 1) {
        CaptureModule.MONO_ID=i;
        mIsMonoCameraPresent=true;
      }
      int facing=characteristics.get(CameraCharacteristics.LENS_FACING);
      if (facing == CameraCharacteristics.LENS_FACING_FRONT) {
        CaptureModule.FRONT_ID=i;
        mIsFrontCameraPresent=true;
      }
      mCharacteristics.add(i,characteristics);
    }
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
}","private SettingsManager(Context context){
  mListeners=new ArrayList<>();
  mCharacteristics=new ArrayList<>();
  mContext=context;
  mPreferences=ComboPreferences.get(mContext);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mContext);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mContext);
  CameraManager manager=(CameraManager)mContext.getSystemService(Context.CAMERA_SERVICE);
  try {
    String[] cameraIdList=manager.getCameraIdList();
    for (int i=0; i < cameraIdList.length; i++) {
      String cameraId=cameraIdList[i];
      CameraCharacteristics characteristics=manager.getCameraCharacteristics(cameraId);
      Byte monoOnly=0;
      try {
        monoOnly=characteristics.get(CaptureModule.MetaDataMonoOnlyKey);
      }
 catch (      Exception e) {
      }
      if (monoOnly == 1) {
        CaptureModule.MONO_ID=i;
        mIsMonoCameraPresent=true;
      }
      int facing=characteristics.get(CameraCharacteristics.LENS_FACING);
      if (facing == CameraCharacteristics.LENS_FACING_FRONT) {
        CaptureModule.FRONT_ID=i;
        mIsFrontCameraPresent=true;
      }
      mCharacteristics.add(i,characteristics);
    }
  }
 catch (  CameraAccessException e) {
    e.printStackTrace();
  }
}","The original code directly instantiates a new ComboPreferences without checking for an existing instance, potentially creating redundant preference objects. The fixed code uses ComboPreferences.get() method to retrieve an existing preferences instance, and creates a new one only if no instance exists. This approach ensures efficient preference management, prevents unnecessary object creation, and maintains a single, consistent preferences configuration across the application."
38181,"@Override public void init(CameraActivity activity,View root){
  mActivity=activity;
  mUI=new VideoUI(activity,this,root);
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mOrientationManager=new OrientationManager(mActivity);
  CameraOpenThread cameraOpenThread=new CameraOpenThread();
  cameraOpenThread.start();
  mContentResolver=mActivity.getContentResolver();
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
  mSaveToSDCard=Storage.isSaveSDCard();
  mIsVideoCaptureIntent=isVideoCaptureIntent();
  initializeSurfaceView();
  try {
    cameraOpenThread.join();
    if (mCameraDevice == null) {
      return;
    }
  }
 catch (  InterruptedException ex) {
  }
  readVideoPreferences();
  mUI.setPrefChangedListener(this);
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,null);
  mUI.setOrientationIndicator(0,false);
  setDisplayOrientation();
  mUI.showTimeLapseUI(mCaptureTimeLapse);
  initializeVideoSnapshot();
  resizeForPreviewAspectRatio();
  initializeVideoControl();
  mPendingSwitchCameraId=-1;
}","@Override public void init(CameraActivity activity,View root){
  mActivity=activity;
  mUI=new VideoUI(activity,this,root);
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mOrientationManager=new OrientationManager(mActivity);
  CameraOpenThread cameraOpenThread=new CameraOpenThread();
  cameraOpenThread.start();
  mContentResolver=mActivity.getContentResolver();
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
  mSaveToSDCard=Storage.isSaveSDCard();
  mIsVideoCaptureIntent=isVideoCaptureIntent();
  initializeSurfaceView();
  try {
    cameraOpenThread.join();
    if (mCameraDevice == null) {
      return;
    }
  }
 catch (  InterruptedException ex) {
  }
  readVideoPreferences();
  mUI.setPrefChangedListener(this);
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,null);
  mUI.setOrientationIndicator(0,false);
  setDisplayOrientation();
  mUI.showTimeLapseUI(mCaptureTimeLapse);
  initializeVideoSnapshot();
  resizeForPreviewAspectRatio();
  initializeVideoControl();
  mPendingSwitchCameraId=-1;
}","The original code directly instantiated a new ComboPreferences without checking for an existing instance, potentially leading to unnecessary object creation and resource overhead. The fixed code uses ComboPreferences.get() method to retrieve an existing preferences object, and creates a new one only if no instance exists. This approach ensures efficient memory management, prevents redundant object initialization, and provides a more robust method of handling preference retrieval in the camera application."
38182,"public void reinit(){
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","public void reinit(){
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mCameraId=getPreferredCameraId(mPreferences);
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","The original code always creates a new ComboPreferences instance, potentially overwriting existing preferences and losing user settings. The fixed code first attempts to retrieve existing preferences using ComboPreferences.get(), and only creates a new instance if none exist, preserving user data and configuration. This approach ensures preference continuity and prevents unintentional data loss during reinitialization."
38183,"@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mOrientationManager=new OrientationManager(activity);
  mCaptureState=CAPTURE_STATE_VIEWFINDER;
  mUI=new WideAnglePanoramaUI(mActivity,this,(ViewGroup)mRootView);
  mUI.setCaptureProgressOnDirectionChangeListener(new PanoProgressBar.OnDirectionChangeListener(){
    @Override public void onDirectionChange(    int direction){
      if (mDirectionChanged) {
        stopCapture(false);
        return;
      }
      if (mCaptureState == CAPTURE_STATE_MOSAIC) {
        mUI.showDirectionIndicators(direction);
      }
      if (direction != PanoProgressBar.DIRECTION_NONE) {
        mDirectionChanged=true;
      }
    }
  }
);
  mContentResolver=mActivity.getContentResolver();
  mOnFrameAvailableRunnable=new Runnable(){
    @Override public void run(){
      if (mPaused)       return;
      MosaicPreviewRenderer renderer=null;
synchronized (mRendererLock) {
        if (mMosaicPreviewRenderer == null) {
          return;
        }
        renderer=mMosaicPreviewRenderer;
      }
      if (mRootView.getVisibility() != View.VISIBLE) {
        renderer.showPreviewFrameSync();
        mRootView.setVisibility(View.VISIBLE);
      }
 else {
        if (mCaptureState == CAPTURE_STATE_VIEWFINDER) {
          if (mPreviewLayoutChanged) {
            boolean isLandscape=(mDeviceOrientation / 90) % 2 == 1;
            renderer.previewReset(mPreviewUIWidth,mPreviewUIHeight,isLandscape,mDeviceOrientation);
            mPreviewLayoutChanged=false;
          }
          renderer.showPreviewFrame();
        }
 else {
          renderer.alignFrameSync();
          mMosaicFrameProcessor.processFrame();
        }
      }
    }
  }
;
  PowerManager pm=(PowerManager)mActivity.getSystemService(Context.POWER_SERVICE);
  mPartialWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mOrientationEventListener=new PanoOrientationEventListener(mActivity);
  mMosaicFrameProcessor=MosaicFrameProcessor.getInstance();
  Resources appRes=mActivity.getResources();
  mPreparePreviewString=appRes.getString(R.string.pano_dialog_prepare_preview);
  mDialogTitle=appRes.getString(R.string.pano_dialog_title);
  mDialogOkString=appRes.getString(R.string.dialog_ok);
  mDialogPanoramaFailedString=appRes.getString(R.string.pano_dialog_panorama_failed);
  mDialogWaitingPreviousString=appRes.getString(R.string.pano_dialog_waiting_previous);
  mPreferences=new ComboPreferences(mActivity);
  mPreferences.setLocalId(mActivity,getPreferredCameraId(mPreferences));
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mLocationManager=new LocationManager(mActivity,null);
  mMainHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_LOW_RES_FINAL_MOSAIC_READY:
        onBackgroundThreadFinished();
      saveFinalMosaic((Bitmap)msg.obj);
    saveHighResMosaic();
  break;
case MSG_GENERATE_FINAL_MOSAIC_ERROR:
onBackgroundThreadFinished();
if (mPaused) {
resetToPreviewIfPossible();
}
 else {
mUI.showAlertDialog(mDialogTitle,mDialogPanoramaFailedString,mDialogOkString,new Runnable(){
  @Override public void run(){
    resetToPreviewIfPossible();
  }
}
);
}
clearMosaicFrameProcessorIfNeeded();
break;
case MSG_END_DIALOG_RESET_TO_PREVIEW:
onBackgroundThreadFinished();
resetToPreviewIfPossible();
clearMosaicFrameProcessorIfNeeded();
break;
case MSG_CLEAR_SCREEN_DELAY:
mActivity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
break;
case MSG_RESET_TO_PREVIEW:
resetToPreviewIfPossible();
break;
}
}
}
;
}","@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mOrientationManager=new OrientationManager(activity);
  mCaptureState=CAPTURE_STATE_VIEWFINDER;
  mUI=new WideAnglePanoramaUI(mActivity,this,(ViewGroup)mRootView);
  mUI.setCaptureProgressOnDirectionChangeListener(new PanoProgressBar.OnDirectionChangeListener(){
    @Override public void onDirectionChange(    int direction){
      if (mDirectionChanged) {
        stopCapture(false);
        return;
      }
      if (mCaptureState == CAPTURE_STATE_MOSAIC) {
        mUI.showDirectionIndicators(direction);
      }
      if (direction != PanoProgressBar.DIRECTION_NONE) {
        mDirectionChanged=true;
      }
    }
  }
);
  mContentResolver=mActivity.getContentResolver();
  mOnFrameAvailableRunnable=new Runnable(){
    @Override public void run(){
      if (mPaused)       return;
      MosaicPreviewRenderer renderer=null;
synchronized (mRendererLock) {
        if (mMosaicPreviewRenderer == null) {
          return;
        }
        renderer=mMosaicPreviewRenderer;
      }
      if (mRootView.getVisibility() != View.VISIBLE) {
        renderer.showPreviewFrameSync();
        mRootView.setVisibility(View.VISIBLE);
      }
 else {
        if (mCaptureState == CAPTURE_STATE_VIEWFINDER) {
          if (mPreviewLayoutChanged) {
            boolean isLandscape=(mDeviceOrientation / 90) % 2 == 1;
            renderer.previewReset(mPreviewUIWidth,mPreviewUIHeight,isLandscape,mDeviceOrientation);
            mPreviewLayoutChanged=false;
          }
          renderer.showPreviewFrame();
        }
 else {
          renderer.alignFrameSync();
          mMosaicFrameProcessor.processFrame();
        }
      }
    }
  }
;
  PowerManager pm=(PowerManager)mActivity.getSystemService(Context.POWER_SERVICE);
  mPartialWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mOrientationEventListener=new PanoOrientationEventListener(mActivity);
  mMosaicFrameProcessor=MosaicFrameProcessor.getInstance();
  Resources appRes=mActivity.getResources();
  mPreparePreviewString=appRes.getString(R.string.pano_dialog_prepare_preview);
  mDialogTitle=appRes.getString(R.string.pano_dialog_title);
  mDialogOkString=appRes.getString(R.string.dialog_ok);
  mDialogPanoramaFailedString=appRes.getString(R.string.pano_dialog_panorama_failed);
  mDialogWaitingPreviousString=appRes.getString(R.string.pano_dialog_waiting_previous);
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  mPreferences.setLocalId(mActivity,getPreferredCameraId(mPreferences));
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mLocationManager=new LocationManager(mActivity,null);
  mMainHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_LOW_RES_FINAL_MOSAIC_READY:
        onBackgroundThreadFinished();
      saveFinalMosaic((Bitmap)msg.obj);
    saveHighResMosaic();
  break;
case MSG_GENERATE_FINAL_MOSAIC_ERROR:
onBackgroundThreadFinished();
if (mPaused) {
resetToPreviewIfPossible();
}
 else {
mUI.showAlertDialog(mDialogTitle,mDialogPanoramaFailedString,mDialogOkString,new Runnable(){
  @Override public void run(){
    resetToPreviewIfPossible();
  }
}
);
}
clearMosaicFrameProcessorIfNeeded();
break;
case MSG_END_DIALOG_RESET_TO_PREVIEW:
onBackgroundThreadFinished();
resetToPreviewIfPossible();
clearMosaicFrameProcessorIfNeeded();
break;
case MSG_CLEAR_SCREEN_DELAY:
mActivity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
break;
case MSG_RESET_TO_PREVIEW:
resetToPreviewIfPossible();
break;
}
}
}
;
}","The original code directly instantiated a new ComboPreferences object without checking for an existing instance, potentially causing unnecessary object creation and resource overhead. The fixed code uses ComboPreferences.get() method to retrieve an existing preferences instance, and adds a null check to create a new instance only if no existing preferences are found. This approach optimizes memory usage, ensures proper preference management, and provides a more robust initialization strategy for handling application preferences."
38184,"@Override public void onResumeBeforeSuper(){
  mPaused=false;
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mPreferences.setLocalId(mActivity,getPreferredCameraId(mPreferences));
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","@Override public void onResumeBeforeSuper(){
  mPaused=false;
  mPreferences=ComboPreferences.get(mActivity);
  if (mPreferences == null) {
    mPreferences=new ComboPreferences(mActivity);
  }
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),mActivity);
  mPreferences.setLocalId(mActivity,getPreferredCameraId(mPreferences));
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
}","The original code always creates a new ComboPreferences instance, potentially losing existing preferences and causing unnecessary overhead. The fixed code uses ComboPreferences.get() to retrieve an existing preferences object, and adds a null check to create a new instance only if needed. This approach ensures preference preservation, reduces redundant object creation, and provides a more robust method for managing camera preferences across app resumption."
38185,"@Override public void onDestroy(){
  if (mWakeLock != null && mWakeLock.isHeld()) {
    mWakeLock.release();
    Log.d(TAG,""String_Node_Str"");
  }
  getContentResolver().unregisterContentObserver(mLocalImagesObserver);
  getContentResolver().unregisterContentObserver(mLocalVideosObserver);
  unregisterReceiver(mSDcardMountedReceiver);
  mCursor.close();
  mCursor=null;
  super.onDestroy();
}","@Override public void onDestroy(){
  if (mWakeLock != null && mWakeLock.isHeld()) {
    mWakeLock.release();
    Log.d(TAG,""String_Node_Str"");
  }
  if (mCursor != null) {
    getContentResolver().unregisterContentObserver(mLocalImagesObserver);
    getContentResolver().unregisterContentObserver(mLocalVideosObserver);
    unregisterReceiver(mSDcardMountedReceiver);
    mCursor.close();
    mCursor=null;
  }
  super.onDestroy();
}","The original code risks a NullPointerException if mCursor is null when attempting to close it, potentially causing unexpected app crashes. The fixed code adds a null check before unregistering observers and closing the cursor, ensuring safe execution even if mCursor was not initialized. This defensive programming approach prevents potential runtime errors and improves the robustness of the onDestroy() method by gracefully handling uninitialized cursor scenarios."
38186,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == REQ_CODE_DONT_SWITCH_TO_PREVIEW) {
    mResetToPreviewOnResume=false;
    mIsEditActivityInProgress=false;
  }
 else {
    super.onActivityResult(requestCode,resultCode,data);
    if (requestCode == PERMISSIONS_ACTIVITY_REQUEST_CODE && resultCode == PERMISSIONS_RESULT_CODE_FAILED) {
      finish();
    }
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == REQ_CODE_DONT_SWITCH_TO_PREVIEW) {
    mResetToPreviewOnResume=false;
    mIsEditActivityInProgress=false;
  }
 else {
    super.onActivityResult(requestCode,resultCode,data);
  }
}","The original code incorrectly handled multiple request codes by adding an unnecessary nested condition after calling the superclass method, which could lead to unintended early activity termination. The fixed code removes the nested condition checking for PERMISSIONS_ACTIVITY_REQUEST_CODE, allowing the superclass method to handle other request codes more generically. This simplification ensures proper activity result handling and prevents potential premature activity finishing, making the code more robust and predictable."
38187,"@Override public void onUserInteraction(){
  super.onUserInteraction();
  mCurrentModule.onUserInteraction();
}","@Override public void onUserInteraction(){
  super.onUserInteraction();
  if (mCurrentModule != null) {
    mCurrentModule.onUserInteraction();
  }
}","The original code assumes `mCurrentModule` is always non-null, which can lead to a NullPointerException if the module hasn't been initialized. The fixed code adds a null check before calling `onUserInteraction()`, ensuring the method is only invoked when `mCurrentModule` is not null. This defensive programming approach prevents potential runtime crashes and makes the code more robust by safely handling scenarios where the module might be uninitialized."
38188,"/** 
 * Checks if any of the needed Android runtime permissions are missing. If they are, then launch the permissions activity under one of the following conditions: a) The permissions dialogs have not run yet. We will ask for permission only once. b) If the missing permissions are critical to the app running, we will display a fatal error dialog. Critical permissions are: camera, microphone and storage. The app cannot run without them. Non-critical permission is location.
 */
private void checkPermissions(){
  if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED && checkSelfPermission(Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED && checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
    mHasCriticalPermissions=true;
  }
 else {
    mHasCriticalPermissions=false;
  }
  if ((checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) || !mHasCriticalPermissions) {
    Intent intent=new Intent(this,PermissionsActivity.class);
    startActivity(intent);
    finish();
  }
}","/** 
 * Checks if any of the needed Android runtime permissions are missing. If they are, then launch the permissions activity under one of the following conditions: a) If critical permissions are missing, display permission request again b) If non-critical permissions are missing, just display permission request once. Critical permissions are: camera, microphone and storage. The app cannot run without them. Non-critical permission is location.
 */
private boolean checkPermissions(){
  boolean requestPermission=false;
  if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED && checkSelfPermission(Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED && checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
    mHasCriticalPermissions=true;
  }
 else {
    mHasCriticalPermissions=false;
  }
  if ((checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) || !mHasCriticalPermissions) {
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    boolean isRequestShown=prefs.getBoolean(CameraSettings.KEY_REQUEST_PERMISSION,false);
    if (!isRequestShown || !mHasCriticalPermissions) {
      Log.v(TAG,""String_Node_Str"");
      Intent intent=new Intent(this,PermissionsActivity.class);
      startActivity(intent);
      SharedPreferences.Editor editor=prefs.edit();
      editor.putBoolean(CameraSettings.KEY_REQUEST_PERMISSION,true);
      editor.apply();
      requestPermission=true;
    }
  }
  return requestPermission;
}","The original code lacked proper permission request tracking, potentially launching the permissions activity multiple times and disrupting user experience. The fixed code introduces a SharedPreferences flag to track permission request status and only shows the permissions activity once or when critical permissions are missing. This approach provides a more user-friendly and controlled permission request mechanism, preventing unnecessary interruptions and ensuring critical permissions are always addressed."
38189,"@Override public void onResume(){
  checkPermissions();
  if (!mHasCriticalPermissions) {
    super.onResume();
    Log.v(TAG,""String_Node_Str"");
    finish();
    return;
  }
  this.setSystemBarsVisibility(false);
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_FOREGROUNDED,this.getClass().getSimpleName());
  mOrientationListener.enable();
  mCurrentModule.onResumeBeforeSuper();
  super.onResume();
  mPaused=false;
  mCurrentModule.onResumeAfterSuper();
  setSwipingEnabled(true);
  if (mResetToPreviewOnResume) {
    mFilmStripView.getController().goToFirstItem();
  }
  mResetToPreviewOnResume=true;
  if (mLocalVideosObserver.isMediaDataChangedDuringPause() || mLocalImagesObserver.isMediaDataChangedDuringPause()) {
    if (!mSecureCamera) {
      mDataAdapter.requestLoad(getContentResolver());
      mThumbnailDrawable=null;
    }
  }
  mLocalImagesObserver.setActivityPaused(false);
  mLocalVideosObserver.setActivityPaused(false);
  Log.d(TAG,""String_Node_Str"");
  Intent intent=new Intent(""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",true);
  sendBroadcast(intent);
}","@Override public void onResume(){
  if (checkPermissions() || !mHasCriticalPermissions) {
    super.onResume();
    Log.v(TAG,""String_Node_Str"");
    finish();
    return;
  }
  this.setSystemBarsVisibility(false);
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_FOREGROUNDED,this.getClass().getSimpleName());
  mOrientationListener.enable();
  mCurrentModule.onResumeBeforeSuper();
  super.onResume();
  mPaused=false;
  mCurrentModule.onResumeAfterSuper();
  setSwipingEnabled(true);
  if (mResetToPreviewOnResume) {
    mFilmStripView.getController().goToFirstItem();
  }
  mResetToPreviewOnResume=true;
  if (mLocalVideosObserver.isMediaDataChangedDuringPause() || mLocalImagesObserver.isMediaDataChangedDuringPause()) {
    if (!mSecureCamera) {
      mDataAdapter.requestLoad(getContentResolver());
      mThumbnailDrawable=null;
    }
  }
  mLocalImagesObserver.setActivityPaused(false);
  mLocalVideosObserver.setActivityPaused(false);
  Log.d(TAG,""String_Node_Str"");
  Intent intent=new Intent(""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",true);
  sendBroadcast(intent);
}","The original code called `checkPermissions()` without capturing its return value, potentially skipping critical permission checks. The fixed code modifies the condition to `checkPermissions() || !mHasCriticalPermissions`, ensuring proper permission validation before proceeding with activity resumption. This change guarantees that the method only continues if permissions are granted, preventing potential security and functionality issues in the application."
38190,"@Override public void onCreate(Bundle state){
  super.onCreate(state);
  checkPermissions();
  if (!mHasCriticalPermissions) {
    Log.v(TAG,""String_Node_Str"");
    finish();
    return;
  }
  Intent intent=getIntent();
  String action=intent.getAction();
  if (INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action) || ACTION_IMAGE_CAPTURE_SECURE.equals(action) || intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
    mSecureCamera=true;
  }
 else {
    mSecureCamera=intent.getBooleanExtra(SECURE_CAMERA_EXTRA,false);
  }
  mCursor=getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,null,null,null,null);
  if (mSecureCamera) {
    Window win=getWindow();
    WindowManager.LayoutParams params=win.getAttributes();
    params.flags|=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;
    if (intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
      params.flags|=WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON;
      PowerManager pm=((PowerManager)getSystemService(POWER_SERVICE));
      mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,TAG);
      mWakeLock.acquire();
      Log.d(TAG,""String_Node_Str"");
    }
    win.setAttributes(params);
  }
  GcamHelper.init(getContentResolver());
  getWindow().requestFeature(Window.FEATURE_ACTION_BAR);
  SettingsManager.createInstance(this);
  LayoutInflater inflater=getLayoutInflater();
  View rootLayout=inflater.inflate(R.layout.camera,null,false);
  mCameraRootFrame=(FrameLayout)rootLayout.findViewById(R.id.camera_root_frame);
  mCameraPhotoModuleRootView=rootLayout.findViewById(R.id.camera_photo_root);
  mCameraVideoModuleRootView=rootLayout.findViewById(R.id.camera_video_root);
  mCameraPanoModuleRootView=rootLayout.findViewById(R.id.camera_pano_root);
  mCameraCaptureModuleRootView=rootLayout.findViewById(R.id.camera_capture_root);
  int moduleIndex=-1;
  if (MediaStore.INTENT_ACTION_VIDEO_CAMERA.equals(getIntent().getAction()) || MediaStore.ACTION_VIDEO_CAPTURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.VIDEO_MODULE_INDEX;
  }
 else   if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(getIntent().getAction()) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    if (prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1) == ModuleSwitcher.GCAM_MODULE_INDEX && GcamHelper.hasGcamCapture()) {
      moduleIndex=ModuleSwitcher.GCAM_MODULE_INDEX;
    }
  }
 else   if (MediaStore.ACTION_IMAGE_CAPTURE.equals(getIntent().getAction()) || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
  }
 else {
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    moduleIndex=prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1);
    if ((moduleIndex == ModuleSwitcher.GCAM_MODULE_INDEX && !GcamHelper.hasGcamCapture()) || moduleIndex < 0) {
      moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    }
  }
  boolean cam2on=SettingsManager.getInstance().isCamera2On();
  if (cam2on && moduleIndex == ModuleSwitcher.PHOTO_MODULE_INDEX)   moduleIndex=ModuleSwitcher.CAPTURE_MODULE_INDEX;
  mOrientationListener=new MyOrientationEventListener(this);
  setContentView(R.layout.camera_filmstrip);
  mFilmStripView=(FilmStripView)findViewById(R.id.filmstrip_view);
  setModuleFromIndex(moduleIndex);
  mActionBar=getActionBar();
  mActionBar.addOnMenuVisibilityListener(this);
  if (ApiHelper.HAS_ROTATION_ANIMATION) {
    setRotationAnimation();
  }
  mMainHandler=new MainHandler(getMainLooper());
  mAboveFilmstripControlLayout=(FrameLayout)findViewById(R.id.camera_above_filmstrip_layout);
  mAboveFilmstripControlLayout.setFitsSystemWindows(true);
  mPanoramaManager=AppManagerFactory.getInstance(this).getPanoramaStitchingManager();
  mPlaceholderManager=AppManagerFactory.getInstance(this).getGcamProcessingManager();
  mPanoramaManager.addTaskListener(mStitchingListener);
  mPlaceholderManager.addTaskListener(mPlaceholderListener);
  mPanoStitchingPanel=findViewById(R.id.pano_stitching_progress_panel);
  mBottomProgress=(ProgressBar)findViewById(R.id.pano_stitching_progress_bar);
  mCameraPreviewData=new CameraPreviewData(rootLayout,FilmStripView.ImageData.SIZE_FULL,FilmStripView.ImageData.SIZE_FULL);
  mWrappedDataAdapter=new FixedFirstDataAdapter(new CameraDataAdapter(new ColorDrawable(getResources().getColor(R.color.photo_placeholder))),mCameraPreviewData);
  mFilmStripView.setViewGap(getResources().getDimensionPixelSize(R.dimen.camera_film_strip_gap));
  mPanoramaViewHelper=new PanoramaViewHelper(this);
  mPanoramaViewHelper.onCreate();
  mFilmStripView.setPanoramaViewHelper(mPanoramaViewHelper);
  mFilmStripView.setListener(mFilmStripListener);
  if (!mSecureCamera) {
    mDataAdapter=mWrappedDataAdapter;
    mFilmStripView.setDataAdapter(mDataAdapter);
    if (!isCaptureIntent()) {
      mDataAdapter.requestLoad(getContentResolver());
      mDataRequested=true;
    }
  }
 else {
    ImageView v=(ImageView)getLayoutInflater().inflate(R.layout.secure_album_placeholder,null);
    v.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        try {
          UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_GALLERY,null);
          startActivity(IntentHelper.getGalleryIntent(CameraActivity.this));
        }
 catch (        ActivityNotFoundException e) {
          Log.w(TAG,""String_Node_Str"");
        }
        finish();
      }
    }
);
    mDataAdapter=new FixedLastDataAdapter(mWrappedDataAdapter,new SimpleViewData(v,v.getDrawable().getIntrinsicWidth(),v.getDrawable().getIntrinsicHeight(),0,0));
    mDataAdapter.flush();
    mFilmStripView.setDataAdapter(mDataAdapter);
  }
  setupNfcBeamPush();
  mLocalImagesObserver=new LocalMediaObserver();
  mLocalVideosObserver=new LocalMediaObserver();
  getContentResolver().registerContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,true,mLocalImagesObserver);
  getContentResolver().registerContentObserver(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,true,mLocalVideosObserver);
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  mDeveloperMenuEnabled=prefs.getBoolean(CameraSettings.KEY_DEVELOPER_MENU,false);
  Display display=getWindowManager().getDefaultDisplay();
  Point size=new Point();
  display.getSize(size);
  int width=size.x;
  int height=size.y;
  int lower=Math.min(width,height);
  int offset=lower * 7 / 100;
  SETTING_LIST_WIDTH_1=lower / 2 + offset;
  SETTING_LIST_WIDTH_2=lower / 2 - offset;
  registerSDcardMountedReceiver();
}","@Override public void onCreate(Bundle state){
  super.onCreate(state);
  if (checkPermissions() || !mHasCriticalPermissions) {
    Log.v(TAG,""String_Node_Str"");
    finish();
    return;
  }
  Intent intent=getIntent();
  String action=intent.getAction();
  if (INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action) || ACTION_IMAGE_CAPTURE_SECURE.equals(action) || intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
    mSecureCamera=true;
  }
 else {
    mSecureCamera=intent.getBooleanExtra(SECURE_CAMERA_EXTRA,false);
  }
  mCursor=getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,null,null,null,null);
  if (mSecureCamera) {
    Window win=getWindow();
    WindowManager.LayoutParams params=win.getAttributes();
    params.flags|=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;
    if (intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
      params.flags|=WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON;
      PowerManager pm=((PowerManager)getSystemService(POWER_SERVICE));
      mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,TAG);
      mWakeLock.acquire();
      Log.d(TAG,""String_Node_Str"");
    }
    win.setAttributes(params);
  }
  GcamHelper.init(getContentResolver());
  getWindow().requestFeature(Window.FEATURE_ACTION_BAR);
  SettingsManager.createInstance(this);
  LayoutInflater inflater=getLayoutInflater();
  View rootLayout=inflater.inflate(R.layout.camera,null,false);
  mCameraRootFrame=(FrameLayout)rootLayout.findViewById(R.id.camera_root_frame);
  mCameraPhotoModuleRootView=rootLayout.findViewById(R.id.camera_photo_root);
  mCameraVideoModuleRootView=rootLayout.findViewById(R.id.camera_video_root);
  mCameraPanoModuleRootView=rootLayout.findViewById(R.id.camera_pano_root);
  mCameraCaptureModuleRootView=rootLayout.findViewById(R.id.camera_capture_root);
  int moduleIndex=-1;
  if (MediaStore.INTENT_ACTION_VIDEO_CAMERA.equals(getIntent().getAction()) || MediaStore.ACTION_VIDEO_CAPTURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.VIDEO_MODULE_INDEX;
  }
 else   if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(getIntent().getAction()) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    if (prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1) == ModuleSwitcher.GCAM_MODULE_INDEX && GcamHelper.hasGcamCapture()) {
      moduleIndex=ModuleSwitcher.GCAM_MODULE_INDEX;
    }
  }
 else   if (MediaStore.ACTION_IMAGE_CAPTURE.equals(getIntent().getAction()) || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
  }
 else {
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    moduleIndex=prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1);
    if ((moduleIndex == ModuleSwitcher.GCAM_MODULE_INDEX && !GcamHelper.hasGcamCapture()) || moduleIndex < 0) {
      moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    }
  }
  boolean cam2on=SettingsManager.getInstance().isCamera2On();
  if (cam2on && moduleIndex == ModuleSwitcher.PHOTO_MODULE_INDEX)   moduleIndex=ModuleSwitcher.CAPTURE_MODULE_INDEX;
  mOrientationListener=new MyOrientationEventListener(this);
  setContentView(R.layout.camera_filmstrip);
  mFilmStripView=(FilmStripView)findViewById(R.id.filmstrip_view);
  setModuleFromIndex(moduleIndex);
  mActionBar=getActionBar();
  mActionBar.addOnMenuVisibilityListener(this);
  if (ApiHelper.HAS_ROTATION_ANIMATION) {
    setRotationAnimation();
  }
  mMainHandler=new MainHandler(getMainLooper());
  mAboveFilmstripControlLayout=(FrameLayout)findViewById(R.id.camera_above_filmstrip_layout);
  mAboveFilmstripControlLayout.setFitsSystemWindows(true);
  mPanoramaManager=AppManagerFactory.getInstance(this).getPanoramaStitchingManager();
  mPlaceholderManager=AppManagerFactory.getInstance(this).getGcamProcessingManager();
  mPanoramaManager.addTaskListener(mStitchingListener);
  mPlaceholderManager.addTaskListener(mPlaceholderListener);
  mPanoStitchingPanel=findViewById(R.id.pano_stitching_progress_panel);
  mBottomProgress=(ProgressBar)findViewById(R.id.pano_stitching_progress_bar);
  mCameraPreviewData=new CameraPreviewData(rootLayout,FilmStripView.ImageData.SIZE_FULL,FilmStripView.ImageData.SIZE_FULL);
  mWrappedDataAdapter=new FixedFirstDataAdapter(new CameraDataAdapter(new ColorDrawable(getResources().getColor(R.color.photo_placeholder))),mCameraPreviewData);
  mFilmStripView.setViewGap(getResources().getDimensionPixelSize(R.dimen.camera_film_strip_gap));
  mPanoramaViewHelper=new PanoramaViewHelper(this);
  mPanoramaViewHelper.onCreate();
  mFilmStripView.setPanoramaViewHelper(mPanoramaViewHelper);
  mFilmStripView.setListener(mFilmStripListener);
  if (!mSecureCamera) {
    mDataAdapter=mWrappedDataAdapter;
    mFilmStripView.setDataAdapter(mDataAdapter);
    if (!isCaptureIntent()) {
      mDataAdapter.requestLoad(getContentResolver());
      mDataRequested=true;
    }
  }
 else {
    ImageView v=(ImageView)getLayoutInflater().inflate(R.layout.secure_album_placeholder,null);
    v.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        try {
          UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_GALLERY,null);
          startActivity(IntentHelper.getGalleryIntent(CameraActivity.this));
        }
 catch (        ActivityNotFoundException e) {
          Log.w(TAG,""String_Node_Str"");
        }
        finish();
      }
    }
);
    mDataAdapter=new FixedLastDataAdapter(mWrappedDataAdapter,new SimpleViewData(v,v.getDrawable().getIntrinsicWidth(),v.getDrawable().getIntrinsicHeight(),0,0));
    mDataAdapter.flush();
    mFilmStripView.setDataAdapter(mDataAdapter);
  }
  setupNfcBeamPush();
  mLocalImagesObserver=new LocalMediaObserver();
  mLocalVideosObserver=new LocalMediaObserver();
  getContentResolver().registerContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,true,mLocalImagesObserver);
  getContentResolver().registerContentObserver(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,true,mLocalVideosObserver);
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  mDeveloperMenuEnabled=prefs.getBoolean(CameraSettings.KEY_DEVELOPER_MENU,false);
  Display display=getWindowManager().getDefaultDisplay();
  Point size=new Point();
  display.getSize(size);
  int width=size.x;
  int height=size.y;
  int lower=Math.min(width,height);
  int offset=lower * 7 / 100;
  SETTING_LIST_WIDTH_1=lower / 2 + offset;
  SETTING_LIST_WIDTH_2=lower / 2 - offset;
  registerSDcardMountedReceiver();
}","The original code incorrectly calls `checkPermissions()` before checking its return value, potentially allowing execution without proper permission validation. In the fixed code, the condition is modified to `checkPermissions() || !mHasCriticalPermissions`, ensuring that the method exits if permissions are not granted or critical permissions are missing. This change provides a more robust permission check mechanism, preventing unauthorized access and enhancing the application's security by explicitly blocking further execution when permission requirements are not met."
38191,"@Override public void onRequestPermissionsResult(int requestCode,String permissions[],int[] grantResults){
  if (mShouldRequestCameraPermission) {
    if (grantResults[mIndexPermissionRequestCamera] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasCameraPermission=true;
    }
 else {
      handlePermissionsFailure();
    }
  }
  if (mShouldRequestMicrophonePermission) {
    if (grantResults[mIndexPermissionRequestMicrophone] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasMicrophonePermission=true;
    }
 else {
      handlePermissionsFailure();
    }
  }
  if (mShouldRequestStoragePermission) {
    if (grantResults[mIndexPermissionRequestStorage] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasStoragePermission=true;
    }
 else {
      handlePermissionsFailure();
    }
  }
  if (mShouldRequestLocationPermission) {
    if (grantResults[mIndexPermissionRequestLocation] == PackageManager.PERMISSION_GRANTED) {
    }
 else {
    }
  }
  if (mFlagHasCameraPermission && mFlagHasMicrophonePermission && mFlagHasStoragePermission) {
    handlePermissionsSuccess();
  }
}","@Override public void onRequestPermissionsResult(int requestCode,String permissions[],int[] grantResults){
  if (mShouldRequestCameraPermission) {
    if (grantResults[mIndexPermissionRequestCamera] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasCameraPermission=true;
    }
 else {
      mCriticalPermissionDenied=true;
    }
  }
  if (mShouldRequestMicrophonePermission) {
    if (grantResults[mIndexPermissionRequestMicrophone] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasMicrophonePermission=true;
    }
 else {
      mCriticalPermissionDenied=true;
    }
  }
  if (mShouldRequestStoragePermission) {
    if (grantResults[mIndexPermissionRequestStorage] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasStoragePermission=true;
    }
 else {
      mCriticalPermissionDenied=true;
    }
  }
  if (mShouldRequestLocationPermission) {
    if (grantResults[mIndexPermissionRequestLocation] == PackageManager.PERMISSION_GRANTED) {
    }
 else {
    }
  }
  if (mFlagHasCameraPermission && mFlagHasMicrophonePermission && mFlagHasStoragePermission) {
    handlePermissionsSuccess();
  }
 else   if (mCriticalPermissionDenied) {
    handlePermissionsFailure();
  }
}","The original code calls handlePermissionsFailure() immediately upon any single permission denial, which could prematurely interrupt the permission request process. The fixed code introduces a mCriticalPermissionDenied flag that tracks critical permission failures across camera, microphone, and storage permissions, allowing a more comprehensive assessment of permission status. This approach ensures that all critical permissions are evaluated before deciding to handle permissions failure, providing a more robust and flexible permission handling mechanism."
38192,"@Override protected void onResume(){
  super.onResume();
  mNumPermissionsToRequest=0;
  checkPermissions();
}","@Override protected void onResume(){
  super.onResume();
  if (!mCriticalPermissionDenied) {
    mNumPermissionsToRequest=0;
    checkPermissions();
  }
 else {
    mCriticalPermissionDenied=false;
  }
}","The original code always checks permissions on resume, potentially causing unnecessary permission requests or disrupting user experience. The fixed code introduces a flag `mCriticalPermissionDenied` to conditionally skip permission checks when critical permissions were previously denied, preventing repetitive prompts. This approach provides more robust permission handling by allowing controlled permission request flow and avoiding potential user frustration with repeated permission dialogs."
38193,"@Override public void onDestroy(){
  if (mWakeLock != null && mWakeLock.isHeld()) {
    mWakeLock.release();
    Log.d(TAG,""String_Node_Str"");
  }
  getContentResolver().unregisterContentObserver(mLocalImagesObserver);
  getContentResolver().unregisterContentObserver(mLocalVideosObserver);
  unregisterReceiver(mSDcardMountedReceiver);
  mCursor.close();
  mCursor=null;
  super.onDestroy();
}","@Override public void onDestroy(){
  if (mWakeLock != null && mWakeLock.isHeld()) {
    mWakeLock.release();
    Log.d(TAG,""String_Node_Str"");
  }
  if (mCursor != null) {
    getContentResolver().unregisterContentObserver(mLocalImagesObserver);
    getContentResolver().unregisterContentObserver(mLocalVideosObserver);
    unregisterReceiver(mSDcardMountedReceiver);
    mCursor.close();
    mCursor=null;
  }
  super.onDestroy();
}","The original code lacks a null check for mCursor before performing operations, which could lead to a NullPointerException if mCursor is already null. The fixed code adds a conditional check `if (mCursor != null)` before executing content resolver and cursor-related operations, ensuring safe method invocation. This modification prevents potential runtime crashes and provides more robust error handling by only performing cleanup when the cursor is actually initialized and not null."
38194,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == REQ_CODE_DONT_SWITCH_TO_PREVIEW) {
    mResetToPreviewOnResume=false;
    mIsEditActivityInProgress=false;
  }
 else {
    super.onActivityResult(requestCode,resultCode,data);
    if (requestCode == PERMISSIONS_ACTIVITY_REQUEST_CODE && resultCode == PERMISSIONS_RESULT_CODE_FAILED) {
      finish();
    }
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == REQ_CODE_DONT_SWITCH_TO_PREVIEW) {
    mResetToPreviewOnResume=false;
    mIsEditActivityInProgress=false;
  }
 else {
    super.onActivityResult(requestCode,resultCode,data);
  }
}","The original code incorrectly handled the permissions result within an else block, potentially causing unexpected app termination when certain request codes were received. The fixed code removes the nested permissions check, ensuring that only the specific request code (REQ_CODE_DONT_SWITCH_TO_PREVIEW) triggers the custom logic while maintaining the standard activity result handling. This simplification prevents premature activity finishing and provides more robust and predictable behavior for handling different activity result scenarios."
38195,"@Override public void onUserInteraction(){
  super.onUserInteraction();
  mCurrentModule.onUserInteraction();
}","@Override public void onUserInteraction(){
  super.onUserInteraction();
  if (mCurrentModule != null) {
    mCurrentModule.onUserInteraction();
  }
}","The original code assumes mCurrentModule is always initialized, which can lead to a NullPointerException if the module is not set. The fixed code adds a null check before calling onUserInteraction(), ensuring that the method is only invoked when mCurrentModule is not null. This prevents potential runtime crashes and provides a more robust implementation by safely handling scenarios where the module might be uninitialized."
38196,"/** 
 * Checks if any of the needed Android runtime permissions are missing. If they are, then launch the permissions activity under one of the following conditions: a) The permissions dialogs have not run yet. We will ask for permission only once. b) If the missing permissions are critical to the app running, we will display a fatal error dialog. Critical permissions are: camera, microphone and storage. The app cannot run without them. Non-critical permission is location.
 */
private void checkPermissions(){
  if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED && checkSelfPermission(Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED && checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
    mHasCriticalPermissions=true;
  }
 else {
    mHasCriticalPermissions=false;
  }
  if ((checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) || !mHasCriticalPermissions) {
    Intent intent=new Intent(this,PermissionsActivity.class);
    startActivity(intent);
    finish();
  }
}","/** 
 * Checks if any of the needed Android runtime permissions are missing. If they are, then launch the permissions activity under one of the following conditions: a) If critical permissions are missing, display permission request again b) If non-critical permissions are missing, just display permission request once. Critical permissions are: camera, microphone and storage. The app cannot run without them. Non-critical permission is location.
 */
private boolean checkPermissions(){
  boolean requestPermission=false;
  if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED && checkSelfPermission(Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED && checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
    mHasCriticalPermissions=true;
  }
 else {
    mHasCriticalPermissions=false;
  }
  if ((checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) || !mHasCriticalPermissions) {
    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    boolean isRequestShown=prefs.getBoolean(CameraSettings.KEY_REQUEST_PERMISSION,false);
    if (!isRequestShown || !mHasCriticalPermissions) {
      Log.v(TAG,""String_Node_Str"");
      Intent intent=new Intent(this,PermissionsActivity.class);
      startActivity(intent);
      SharedPreferences.Editor editor=prefs.edit();
      editor.putBoolean(CameraSettings.KEY_REQUEST_PERMISSION,true);
      editor.apply();
      requestPermission=true;
    }
  }
  return requestPermission;
}","The original code lacked proper permission request tracking, potentially launching the permissions activity multiple times and disrupting user experience. The fixed code introduces a SharedPreferences flag to track permission request status, ensuring the permissions activity is shown only once or when critical permissions are missing. This approach provides a more robust and user-friendly permission handling mechanism, preventing unnecessary interruptions and improving app usability."
38197,"@Override public void onResume(){
  checkPermissions();
  if (!mHasCriticalPermissions) {
    super.onResume();
    Log.v(TAG,""String_Node_Str"");
    finish();
    return;
  }
  this.setSystemBarsVisibility(false);
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_FOREGROUNDED,this.getClass().getSimpleName());
  mOrientationListener.enable();
  mCurrentModule.onResumeBeforeSuper();
  super.onResume();
  mPaused=false;
  mCurrentModule.onResumeAfterSuper();
  setSwipingEnabled(true);
  if (mResetToPreviewOnResume) {
    mFilmStripView.getController().goToFirstItem();
  }
  mResetToPreviewOnResume=true;
  if (mLocalVideosObserver.isMediaDataChangedDuringPause() || mLocalImagesObserver.isMediaDataChangedDuringPause()) {
    if (!mSecureCamera) {
      mDataAdapter.requestLoad(getContentResolver());
      mThumbnailDrawable=null;
    }
  }
  mLocalImagesObserver.setActivityPaused(false);
  mLocalVideosObserver.setActivityPaused(false);
  Log.d(TAG,""String_Node_Str"");
  Intent intent=new Intent(""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",true);
  sendBroadcast(intent);
}","@Override public void onResume(){
  if (checkPermissions() || !mHasCriticalPermissions) {
    super.onResume();
    Log.v(TAG,""String_Node_Str"");
    finish();
    return;
  }
  this.setSystemBarsVisibility(false);
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_FOREGROUNDED,this.getClass().getSimpleName());
  mOrientationListener.enable();
  mCurrentModule.onResumeBeforeSuper();
  super.onResume();
  mPaused=false;
  mCurrentModule.onResumeAfterSuper();
  setSwipingEnabled(true);
  if (mResetToPreviewOnResume) {
    mFilmStripView.getController().goToFirstItem();
  }
  mResetToPreviewOnResume=true;
  if (mLocalVideosObserver.isMediaDataChangedDuringPause() || mLocalImagesObserver.isMediaDataChangedDuringPause()) {
    if (!mSecureCamera) {
      mDataAdapter.requestLoad(getContentResolver());
      mThumbnailDrawable=null;
    }
  }
  mLocalImagesObserver.setActivityPaused(false);
  mLocalVideosObserver.setActivityPaused(false);
  Log.d(TAG,""String_Node_Str"");
  Intent intent=new Intent(""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",true);
  sendBroadcast(intent);
}","The original code calls `checkPermissions()` without capturing its return value, potentially allowing the method to proceed without proper permission validation. The fixed code modifies the condition to explicitly check the return value of `checkPermissions()` and handle cases where critical permissions are not granted. This ensures a more robust permission check, preventing unauthorized access and improving the method's security and error handling by immediately finishing the activity if permissions are insufficient."
38198,"@Override public void onCreate(Bundle state){
  super.onCreate(state);
  checkPermissions();
  if (!mHasCriticalPermissions) {
    Log.v(TAG,""String_Node_Str"");
    finish();
    return;
  }
  Intent intent=getIntent();
  String action=intent.getAction();
  if (INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action) || ACTION_IMAGE_CAPTURE_SECURE.equals(action) || intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
    mSecureCamera=true;
  }
 else {
    mSecureCamera=intent.getBooleanExtra(SECURE_CAMERA_EXTRA,false);
  }
  mCursor=getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,null,null,null,null);
  if (mSecureCamera) {
    Window win=getWindow();
    WindowManager.LayoutParams params=win.getAttributes();
    params.flags|=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;
    if (intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
      params.flags|=WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON;
      PowerManager pm=((PowerManager)getSystemService(POWER_SERVICE));
      mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,TAG);
      mWakeLock.acquire();
      Log.d(TAG,""String_Node_Str"");
    }
    win.setAttributes(params);
  }
  GcamHelper.init(getContentResolver());
  getWindow().requestFeature(Window.FEATURE_ACTION_BAR);
  LayoutInflater inflater=getLayoutInflater();
  View rootLayout=inflater.inflate(R.layout.camera,null,false);
  mCameraRootFrame=(FrameLayout)rootLayout.findViewById(R.id.camera_root_frame);
  mCameraPhotoModuleRootView=rootLayout.findViewById(R.id.camera_photo_root);
  mCameraVideoModuleRootView=rootLayout.findViewById(R.id.camera_video_root);
  mCameraPanoModuleRootView=rootLayout.findViewById(R.id.camera_pano_root);
  mCameraCaptureModuleRootView=rootLayout.findViewById(R.id.camera_capture_root);
  int moduleIndex=-1;
  if (MediaStore.INTENT_ACTION_VIDEO_CAMERA.equals(getIntent().getAction()) || MediaStore.ACTION_VIDEO_CAPTURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.VIDEO_MODULE_INDEX;
  }
 else   if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(getIntent().getAction()) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    if (prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1) == ModuleSwitcher.GCAM_MODULE_INDEX && GcamHelper.hasGcamCapture()) {
      moduleIndex=ModuleSwitcher.GCAM_MODULE_INDEX;
    }
  }
 else   if (MediaStore.ACTION_IMAGE_CAPTURE.equals(getIntent().getAction()) || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
  }
 else {
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    moduleIndex=prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1);
    if ((moduleIndex == ModuleSwitcher.GCAM_MODULE_INDEX && !GcamHelper.hasGcamCapture()) || moduleIndex < 0) {
      moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    }
  }
  SharedPreferences pref=PreferenceManager.getDefaultSharedPreferences(this);
  CAMERA_2_ON=pref.getBoolean(CameraSettings.KEY_CAMERA2,false);
  if (CAMERA_2_ON && moduleIndex == ModuleSwitcher.PHOTO_MODULE_INDEX)   moduleIndex=ModuleSwitcher.CAPTURE_MODULE_INDEX;
  mOrientationListener=new MyOrientationEventListener(this);
  setModuleFromIndex(moduleIndex);
  setContentView(R.layout.camera_filmstrip);
  mActionBar=getActionBar();
  mActionBar.addOnMenuVisibilityListener(this);
  if (ApiHelper.HAS_ROTATION_ANIMATION) {
    setRotationAnimation();
  }
  mMainHandler=new MainHandler(getMainLooper());
  mAboveFilmstripControlLayout=(FrameLayout)findViewById(R.id.camera_above_filmstrip_layout);
  mAboveFilmstripControlLayout.setFitsSystemWindows(true);
  mPanoramaManager=AppManagerFactory.getInstance(this).getPanoramaStitchingManager();
  mPlaceholderManager=AppManagerFactory.getInstance(this).getGcamProcessingManager();
  mPanoramaManager.addTaskListener(mStitchingListener);
  mPlaceholderManager.addTaskListener(mPlaceholderListener);
  mPanoStitchingPanel=findViewById(R.id.pano_stitching_progress_panel);
  mBottomProgress=(ProgressBar)findViewById(R.id.pano_stitching_progress_bar);
  mCameraPreviewData=new CameraPreviewData(rootLayout,FilmStripView.ImageData.SIZE_FULL,FilmStripView.ImageData.SIZE_FULL);
  mWrappedDataAdapter=new FixedFirstDataAdapter(new CameraDataAdapter(new ColorDrawable(getResources().getColor(R.color.photo_placeholder))),mCameraPreviewData);
  mFilmStripView=(FilmStripView)findViewById(R.id.filmstrip_view);
  mFilmStripView.setViewGap(getResources().getDimensionPixelSize(R.dimen.camera_film_strip_gap));
  mPanoramaViewHelper=new PanoramaViewHelper(this);
  mPanoramaViewHelper.onCreate();
  mFilmStripView.setPanoramaViewHelper(mPanoramaViewHelper);
  mFilmStripView.setListener(mFilmStripListener);
  if (!mSecureCamera) {
    mDataAdapter=mWrappedDataAdapter;
    mFilmStripView.setDataAdapter(mDataAdapter);
    if (!isCaptureIntent()) {
      mDataAdapter.requestLoad(getContentResolver());
      mDataRequested=true;
    }
  }
 else {
    ImageView v=(ImageView)getLayoutInflater().inflate(R.layout.secure_album_placeholder,null);
    v.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        try {
          UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_GALLERY,null);
          startActivity(IntentHelper.getGalleryIntent(CameraActivity.this));
        }
 catch (        ActivityNotFoundException e) {
          Log.w(TAG,""String_Node_Str"");
        }
        finish();
      }
    }
);
    mDataAdapter=new FixedLastDataAdapter(mWrappedDataAdapter,new SimpleViewData(v,v.getDrawable().getIntrinsicWidth(),v.getDrawable().getIntrinsicHeight(),0,0));
    mDataAdapter.flush();
    mFilmStripView.setDataAdapter(mDataAdapter);
  }
  setupNfcBeamPush();
  mLocalImagesObserver=new LocalMediaObserver();
  mLocalVideosObserver=new LocalMediaObserver();
  getContentResolver().registerContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,true,mLocalImagesObserver);
  getContentResolver().registerContentObserver(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,true,mLocalVideosObserver);
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  mDeveloperMenuEnabled=prefs.getBoolean(CameraSettings.KEY_DEVELOPER_MENU,false);
  Display display=getWindowManager().getDefaultDisplay();
  Point size=new Point();
  display.getSize(size);
  int width=size.x;
  int height=size.y;
  int lower=Math.min(width,height);
  int offset=lower * 7 / 100;
  SETTING_LIST_WIDTH_1=lower / 2 + offset;
  SETTING_LIST_WIDTH_2=lower / 2 - offset;
  registerSDcardMountedReceiver();
}","@Override public void onCreate(Bundle state){
  super.onCreate(state);
  if (checkPermissions() || !mHasCriticalPermissions) {
    Log.v(TAG,""String_Node_Str"");
    finish();
    return;
  }
  Intent intent=getIntent();
  String action=intent.getAction();
  if (INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action) || ACTION_IMAGE_CAPTURE_SECURE.equals(action) || intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
    mSecureCamera=true;
  }
 else {
    mSecureCamera=intent.getBooleanExtra(SECURE_CAMERA_EXTRA,false);
  }
  mCursor=getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,null,null,null,null);
  if (mSecureCamera) {
    Window win=getWindow();
    WindowManager.LayoutParams params=win.getAttributes();
    params.flags|=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;
    if (intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
      params.flags|=WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON;
      PowerManager pm=((PowerManager)getSystemService(POWER_SERVICE));
      mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,TAG);
      mWakeLock.acquire();
      Log.d(TAG,""String_Node_Str"");
    }
    win.setAttributes(params);
  }
  GcamHelper.init(getContentResolver());
  getWindow().requestFeature(Window.FEATURE_ACTION_BAR);
  LayoutInflater inflater=getLayoutInflater();
  View rootLayout=inflater.inflate(R.layout.camera,null,false);
  mCameraRootFrame=(FrameLayout)rootLayout.findViewById(R.id.camera_root_frame);
  mCameraPhotoModuleRootView=rootLayout.findViewById(R.id.camera_photo_root);
  mCameraVideoModuleRootView=rootLayout.findViewById(R.id.camera_video_root);
  mCameraPanoModuleRootView=rootLayout.findViewById(R.id.camera_pano_root);
  mCameraCaptureModuleRootView=rootLayout.findViewById(R.id.camera_capture_root);
  int moduleIndex=-1;
  if (MediaStore.INTENT_ACTION_VIDEO_CAMERA.equals(getIntent().getAction()) || MediaStore.ACTION_VIDEO_CAPTURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.VIDEO_MODULE_INDEX;
  }
 else   if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(getIntent().getAction()) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    if (prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1) == ModuleSwitcher.GCAM_MODULE_INDEX && GcamHelper.hasGcamCapture()) {
      moduleIndex=ModuleSwitcher.GCAM_MODULE_INDEX;
    }
  }
 else   if (MediaStore.ACTION_IMAGE_CAPTURE.equals(getIntent().getAction()) || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
  }
 else {
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    moduleIndex=prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1);
    if ((moduleIndex == ModuleSwitcher.GCAM_MODULE_INDEX && !GcamHelper.hasGcamCapture()) || moduleIndex < 0) {
      moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    }
  }
  SharedPreferences pref=PreferenceManager.getDefaultSharedPreferences(this);
  CAMERA_2_ON=pref.getBoolean(CameraSettings.KEY_CAMERA2,false);
  if (CAMERA_2_ON && moduleIndex == ModuleSwitcher.PHOTO_MODULE_INDEX)   moduleIndex=ModuleSwitcher.CAPTURE_MODULE_INDEX;
  mOrientationListener=new MyOrientationEventListener(this);
  setModuleFromIndex(moduleIndex);
  setContentView(R.layout.camera_filmstrip);
  mActionBar=getActionBar();
  mActionBar.addOnMenuVisibilityListener(this);
  if (ApiHelper.HAS_ROTATION_ANIMATION) {
    setRotationAnimation();
  }
  mMainHandler=new MainHandler(getMainLooper());
  mAboveFilmstripControlLayout=(FrameLayout)findViewById(R.id.camera_above_filmstrip_layout);
  mAboveFilmstripControlLayout.setFitsSystemWindows(true);
  mPanoramaManager=AppManagerFactory.getInstance(this).getPanoramaStitchingManager();
  mPlaceholderManager=AppManagerFactory.getInstance(this).getGcamProcessingManager();
  mPanoramaManager.addTaskListener(mStitchingListener);
  mPlaceholderManager.addTaskListener(mPlaceholderListener);
  mPanoStitchingPanel=findViewById(R.id.pano_stitching_progress_panel);
  mBottomProgress=(ProgressBar)findViewById(R.id.pano_stitching_progress_bar);
  mCameraPreviewData=new CameraPreviewData(rootLayout,FilmStripView.ImageData.SIZE_FULL,FilmStripView.ImageData.SIZE_FULL);
  mWrappedDataAdapter=new FixedFirstDataAdapter(new CameraDataAdapter(new ColorDrawable(getResources().getColor(R.color.photo_placeholder))),mCameraPreviewData);
  mFilmStripView=(FilmStripView)findViewById(R.id.filmstrip_view);
  mFilmStripView.setViewGap(getResources().getDimensionPixelSize(R.dimen.camera_film_strip_gap));
  mPanoramaViewHelper=new PanoramaViewHelper(this);
  mPanoramaViewHelper.onCreate();
  mFilmStripView.setPanoramaViewHelper(mPanoramaViewHelper);
  mFilmStripView.setListener(mFilmStripListener);
  if (!mSecureCamera) {
    mDataAdapter=mWrappedDataAdapter;
    mFilmStripView.setDataAdapter(mDataAdapter);
    if (!isCaptureIntent()) {
      mDataAdapter.requestLoad(getContentResolver());
      mDataRequested=true;
    }
  }
 else {
    ImageView v=(ImageView)getLayoutInflater().inflate(R.layout.secure_album_placeholder,null);
    v.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        try {
          UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_GALLERY,null);
          startActivity(IntentHelper.getGalleryIntent(CameraActivity.this));
        }
 catch (        ActivityNotFoundException e) {
          Log.w(TAG,""String_Node_Str"");
        }
        finish();
      }
    }
);
    mDataAdapter=new FixedLastDataAdapter(mWrappedDataAdapter,new SimpleViewData(v,v.getDrawable().getIntrinsicWidth(),v.getDrawable().getIntrinsicHeight(),0,0));
    mDataAdapter.flush();
    mFilmStripView.setDataAdapter(mDataAdapter);
  }
  setupNfcBeamPush();
  mLocalImagesObserver=new LocalMediaObserver();
  mLocalVideosObserver=new LocalMediaObserver();
  getContentResolver().registerContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,true,mLocalImagesObserver);
  getContentResolver().registerContentObserver(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,true,mLocalVideosObserver);
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  mDeveloperMenuEnabled=prefs.getBoolean(CameraSettings.KEY_DEVELOPER_MENU,false);
  Display display=getWindowManager().getDefaultDisplay();
  Point size=new Point();
  display.getSize(size);
  int width=size.x;
  int height=size.y;
  int lower=Math.min(width,height);
  int offset=lower * 7 / 100;
  SETTING_LIST_WIDTH_1=lower / 2 + offset;
  SETTING_LIST_WIDTH_2=lower / 2 - offset;
  registerSDcardMountedReceiver();
}","The original code incorrectly handles permission checks by calling `checkPermissions()` before verifying the result, potentially allowing unauthorized access. In the fixed code, the condition is modified to first check the permissions result and immediately exit if critical permissions are not granted. This ensures proper security validation, preventing potential unauthorized camera access and improving the application's overall robustness by enforcing strict permission checks before proceeding with camera initialization."
38199,"@Override public void onRequestPermissionsResult(int requestCode,String permissions[],int[] grantResults){
  if (mShouldRequestCameraPermission) {
    if (grantResults[mIndexPermissionRequestCamera] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasCameraPermission=true;
    }
 else {
      handlePermissionsFailure();
    }
  }
  if (mShouldRequestMicrophonePermission) {
    if (grantResults[mIndexPermissionRequestMicrophone] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasMicrophonePermission=true;
    }
 else {
      handlePermissionsFailure();
    }
  }
  if (mShouldRequestStoragePermission) {
    if (grantResults[mIndexPermissionRequestStorage] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasStoragePermission=true;
    }
 else {
      handlePermissionsFailure();
    }
  }
  if (mShouldRequestLocationPermission) {
    if (grantResults[mIndexPermissionRequestLocation] == PackageManager.PERMISSION_GRANTED) {
    }
 else {
    }
  }
  if (mFlagHasCameraPermission && mFlagHasMicrophonePermission && mFlagHasStoragePermission) {
    handlePermissionsSuccess();
  }
}","@Override public void onRequestPermissionsResult(int requestCode,String permissions[],int[] grantResults){
  if (mShouldRequestCameraPermission) {
    if (grantResults[mIndexPermissionRequestCamera] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasCameraPermission=true;
    }
 else {
      mCriticalPermissionDenied=true;
    }
  }
  if (mShouldRequestMicrophonePermission) {
    if (grantResults[mIndexPermissionRequestMicrophone] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasMicrophonePermission=true;
    }
 else {
      mCriticalPermissionDenied=true;
    }
  }
  if (mShouldRequestStoragePermission) {
    if (grantResults[mIndexPermissionRequestStorage] == PackageManager.PERMISSION_GRANTED) {
      mFlagHasStoragePermission=true;
    }
 else {
      mCriticalPermissionDenied=true;
    }
  }
  if (mShouldRequestLocationPermission) {
    if (grantResults[mIndexPermissionRequestLocation] == PackageManager.PERMISSION_GRANTED) {
    }
 else {
    }
  }
  if (mFlagHasCameraPermission && mFlagHasMicrophonePermission && mFlagHasStoragePermission) {
    handlePermissionsSuccess();
  }
 else   if (mCriticalPermissionDenied) {
    handlePermissionsFailure();
  }
}","The original code calls handlePermissionsFailure() immediately upon any single permission denial, which could prematurely interrupt the permission request process. The fixed code introduces a mCriticalPermissionDenied flag that tracks critical permission failures across camera, microphone, and storage permissions, instead of immediately triggering failure. This approach allows a more comprehensive permission check, ensuring that all critical permissions are evaluated before deciding whether to proceed or halt the application's functionality."
38200,"@Override protected void onResume(){
  super.onResume();
  mNumPermissionsToRequest=0;
  checkPermissions();
}","@Override protected void onResume(){
  super.onResume();
  if (!mCriticalPermissionDenied) {
    mNumPermissionsToRequest=0;
    checkPermissions();
  }
 else {
    mCriticalPermissionDenied=false;
  }
}","The original code always calls `checkPermissions()` without checking if critical permissions were previously denied, potentially causing repeated permission requests. The fixed code introduces a conditional check with `mCriticalPermissionDenied` flag, which prevents unnecessary permission checks when critical permissions have been denied. This modification enhances user experience by avoiding redundant permission dialogs and provides a more controlled permission request mechanism."
38201,"public void layoutPreview(float ratio){
  FrameLayout.LayoutParams lp;
  float scaledTextureWidth, scaledTextureHeight;
  int rotation=CameraUtil.getDisplayRotation(mActivity);
  mScreenRatio=CameraUtil.determineRatio(ratio);
  if (mScreenRatio == CameraUtil.RATIO_16_9 && CameraUtil.determinCloseRatio(ratio) == CameraUtil.RATIO_4_3) {
    int l=(mTopMargin + mBottomMargin) * 4;
    int s=l * 9 / 16;
switch (rotation) {
case 90:
      lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
    lp.setMargins(mTopMargin,0,mBottomMargin,0);
  scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
case 180:
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mBottomMargin,0,mTopMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
case 270:
lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
lp.setMargins(mBottomMargin,0,mTopMargin,0);
scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
default :
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mTopMargin,0,mBottomMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
}
}
 else {
float width=mMaxPreviewWidth, height=mMaxPreviewHeight;
if (width == 0 || height == 0) return;
if (mScreenRatio == CameraUtil.RATIO_4_3) height-=(mTopMargin + mBottomMargin);
if (mOrientationResize) {
scaledTextureWidth=height * mAspectRatio;
if (scaledTextureWidth > width) {
scaledTextureWidth=width;
scaledTextureHeight=scaledTextureWidth / mAspectRatio;
}
 else {
scaledTextureHeight=height;
}
}
 else {
if (width > height) {
if (Math.max(width,height * mAspectRatio) > width) {
scaledTextureWidth=width;
scaledTextureHeight=width / mAspectRatio;
}
 else {
scaledTextureWidth=height * mAspectRatio;
scaledTextureHeight=height;
}
}
 else {
if (Math.max(height,width * mAspectRatio) > height) {
scaledTextureWidth=height / mAspectRatio;
scaledTextureHeight=height;
}
 else {
scaledTextureWidth=width;
scaledTextureHeight=width * mAspectRatio;
}
}
}
Log.v(TAG,""String_Node_Str"" + scaledTextureWidth + ""String_Node_Str""+ scaledTextureHeight);
if (((rotation == 0 || rotation == 180) && scaledTextureWidth > scaledTextureHeight) || ((rotation == 90 || rotation == 270) && scaledTextureWidth < scaledTextureHeight)) {
lp=new FrameLayout.LayoutParams((int)scaledTextureHeight,(int)scaledTextureWidth,Gravity.CENTER);
}
 else {
lp=new FrameLayout.LayoutParams((int)scaledTextureWidth,(int)scaledTextureHeight,Gravity.CENTER);
}
if (mScreenRatio == CameraUtil.RATIO_4_3) {
lp.gravity=Gravity.CENTER_HORIZONTAL | Gravity.TOP;
lp.setMargins(0,mTopMargin,0,mBottomMargin);
}
}
if (mSurfaceTextureUncroppedWidth != scaledTextureWidth || mSurfaceTextureUncroppedHeight != scaledTextureHeight) {
mSurfaceTextureUncroppedWidth=scaledTextureWidth;
mSurfaceTextureUncroppedHeight=scaledTextureHeight;
if (mSurfaceTextureSizeListener != null) {
mSurfaceTextureSizeListener.onSurfaceTextureSizeChanged((int)mSurfaceTextureUncroppedWidth,(int)mSurfaceTextureUncroppedHeight);
Log.d(TAG,""String_Node_Str"" + mSurfaceTextureUncroppedWidth + ""String_Node_Str""+ mSurfaceTextureUncroppedHeight);
}
}
mSurfaceView.setLayoutParams(lp);
if (mFaceView != null) {
mFaceView.setLayoutParams(lp);
}
}","public void layoutPreview(float ratio){
  FrameLayout.LayoutParams lp;
  float scaledTextureWidth, scaledTextureHeight;
  int rotation=CameraUtil.getDisplayRotation(mActivity);
  mScreenRatio=CameraUtil.determineRatio(ratio);
  if (mScreenRatio == CameraUtil.RATIO_16_9 && CameraUtil.determinCloseRatio(ratio) == CameraUtil.RATIO_4_3) {
    int l=(mTopMargin + mBottomMargin) * 4;
    int s=l * 9 / 16;
switch (rotation) {
case 90:
      lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
    lp.setMargins(mTopMargin,0,mBottomMargin,0);
  scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
case 180:
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mBottomMargin,0,mTopMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
case 270:
lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
lp.setMargins(mBottomMargin,0,mTopMargin,0);
scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
default :
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mTopMargin,0,mBottomMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
}
}
 else {
float width=mMaxPreviewWidth, height=mMaxPreviewHeight;
if (width == 0 || height == 0) return;
if (mScreenRatio == CameraUtil.RATIO_4_3) height-=(mTopMargin + mBottomMargin);
if (mOrientationResize) {
scaledTextureWidth=height * mAspectRatio;
if (scaledTextureWidth > width) {
scaledTextureWidth=width;
scaledTextureHeight=scaledTextureWidth / mAspectRatio;
}
 else {
scaledTextureHeight=height;
}
}
 else {
if (width > height) {
if (Math.max(width,height * mAspectRatio) > width) {
scaledTextureWidth=width;
scaledTextureHeight=width / mAspectRatio;
}
 else {
scaledTextureWidth=height * mAspectRatio;
scaledTextureHeight=height;
}
}
 else {
if (Math.max(height,width * mAspectRatio) > height) {
scaledTextureWidth=height / mAspectRatio;
scaledTextureHeight=height;
}
 else {
scaledTextureWidth=width;
scaledTextureHeight=width * mAspectRatio;
}
}
}
Log.v(TAG,""String_Node_Str"" + scaledTextureWidth + ""String_Node_Str""+ scaledTextureHeight);
if (((rotation == 0 || rotation == 180) && scaledTextureWidth > scaledTextureHeight) || ((rotation == 90 || rotation == 270) && scaledTextureWidth < scaledTextureHeight)) {
lp=new FrameLayout.LayoutParams((int)scaledTextureHeight,(int)scaledTextureWidth,Gravity.CENTER);
}
 else {
lp=new FrameLayout.LayoutParams((int)scaledTextureWidth,(int)scaledTextureHeight,Gravity.CENTER);
}
if (mScreenRatio == CameraUtil.RATIO_4_3) {
lp.gravity=Gravity.CENTER_HORIZONTAL | Gravity.TOP;
lp.setMargins(0,mTopMargin,0,mBottomMargin);
}
}
if (mSurfaceTextureUncroppedWidth != scaledTextureWidth || mSurfaceTextureUncroppedHeight != scaledTextureHeight) {
mSurfaceTextureUncroppedWidth=scaledTextureWidth;
mSurfaceTextureUncroppedHeight=scaledTextureHeight;
if (mSurfaceTextureSizeListener != null) {
mSurfaceTextureSizeListener.onSurfaceTextureSizeChanged((int)mSurfaceTextureUncroppedWidth,(int)mSurfaceTextureUncroppedHeight);
Log.d(TAG,""String_Node_Str"" + mSurfaceTextureUncroppedWidth + ""String_Node_Str""+ mSurfaceTextureUncroppedHeight);
}
}
mSurfaceView.setLayoutParams(lp);
if (mFaceView != null) {
mFaceView.setLayoutParams(lp);
}
mIsLayoutInitializedAlready=true;
}","The original code lacked a flag to track layout initialization, potentially causing repeated unnecessary layout calculations. The fixed code adds `mIsLayoutInitializedAlready=true` at the end of the method, ensuring the layout is marked as initialized after complete processing. This improvement prevents redundant layout operations and provides a clear state indicator for subsequent method calls, enhancing overall method efficiency and preventing potential performance overhead."
38202,"@Override public void onLayoutChange(View v,int left,int top,int right,int bottom,int oldLeft,int oldTop,int oldRight,int oldBottom){
  int width=right - left;
  int height=bottom - top;
  tryToCloseSubList();
  if (mMaxPreviewWidth == 0 && mMaxPreviewHeight == 0) {
    mMaxPreviewWidth=width;
    mMaxPreviewHeight=height;
  }
  if (mOrientationResize != mPrevOrientationResize || mAspectRatioResize) {
    layoutPreview(mAspectRatio);
    mAspectRatioResize=false;
  }
}","@Override public void onLayoutChange(View v,int left,int top,int right,int bottom,int oldLeft,int oldTop,int oldRight,int oldBottom){
  int width=right - left;
  int height=bottom - top;
  tryToCloseSubList();
  if (mMaxPreviewWidth == 0 && mMaxPreviewHeight == 0) {
    mMaxPreviewWidth=width;
    mMaxPreviewHeight=height;
  }
  if (mOrientationResize != mPrevOrientationResize || mAspectRatioResize || !mIsLayoutInitializedAlready) {
    layoutPreview(mAspectRatio);
    mAspectRatioResize=false;
  }
}","The original code lacks a mechanism to ensure initial layout rendering, potentially skipping crucial preview setup for the first layout pass. The fixed code introduces `!mIsLayoutInitializedAlready` to the condition, guaranteeing that `layoutPreview()` is called at least once during the initial layout setup. This enhancement ensures consistent preview initialization across different view configuration scenarios, preventing potential rendering inconsistencies and improving the robustness of the layout change handling."
38203,"public PhotoUI(CameraActivity activity,PhotoController controller,View parent){
  mActivity=activity;
  mController=controller;
  mRootView=parent;
  mActivity.getLayoutInflater().inflate(R.layout.photo_module,(ViewGroup)mRootView,true);
  mPreviewCover=mRootView.findViewById(R.id.preview_cover);
  mSurfaceView=(SurfaceView)mRootView.findViewById(R.id.mdp_preview_content);
  mSurfaceView.setVisibility(View.VISIBLE);
  mSurfaceHolder=mSurfaceView.getHolder();
  mSurfaceHolder.addCallback(this);
  mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
  Log.v(TAG,""String_Node_Str"");
  mSurfaceView.addOnLayoutChangeListener(new OnLayoutChangeListener(){
    @Override public void onLayoutChange(    View v,    int left,    int top,    int right,    int bottom,    int oldLeft,    int oldTop,    int oldRight,    int oldBottom){
      int width=right - left;
      int height=bottom - top;
      tryToCloseSubList();
      if (mMaxPreviewWidth == 0 && mMaxPreviewHeight == 0) {
        mMaxPreviewWidth=width;
        mMaxPreviewHeight=height;
      }
      if (mOrientationResize != mPrevOrientationResize || mAspectRatioResize) {
        layoutPreview(mAspectRatio);
        mAspectRatioResize=false;
      }
    }
  }
);
  mRenderOverlay=(RenderOverlay)mRootView.findViewById(R.id.render_overlay);
  mFlashOverlay=mRootView.findViewById(R.id.flash_overlay);
  mShutterButton=(ShutterButton)mRootView.findViewById(R.id.shutter_button);
  mSwitcher=(ModuleSwitcher)mRootView.findViewById(R.id.camera_switcher);
  mSwitcher.setCurrentIndex(ModuleSwitcher.PHOTO_MODULE_INDEX);
  mSwitcher.setSwitchListener(mActivity);
  mSwitcher.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mController.getCameraState() == PhotoController.LONGSHOT) {
        return;
      }
      mSwitcher.showPopup();
      mSwitcher.setOrientation(mOrientation,false);
    }
  }
);
  mMenuButton=mRootView.findViewById(R.id.menu);
  RotateImageView muteButton=(RotateImageView)mRootView.findViewById(R.id.mute_button);
  muteButton.setVisibility(View.GONE);
  mCameraControls=(CameraControls)mRootView.findViewById(R.id.camera_controls);
  ViewStub faceViewStub=(ViewStub)mRootView.findViewById(R.id.face_view_stub);
  if (faceViewStub != null) {
    faceViewStub.inflate();
    mFaceView=(FaceView)mRootView.findViewById(R.id.face_view);
    setSurfaceTextureSizeChangedListener(mFaceView);
  }
  initIndicators();
  mAnimationManager=new AnimationManager();
  mOrientationResize=false;
  mPrevOrientationResize=false;
  Point size=new Point();
  mActivity.getWindowManager().getDefaultDisplay().getSize(size);
  mScreenRatio=CameraUtil.determineRatio(size.x,size.y);
  calculateMargins(size);
  mCameraControls.setMargins(mTopMargin,mBottomMargin);
  showFirstTimeHelp();
}","public PhotoUI(CameraActivity activity,PhotoController controller,View parent){
  mActivity=activity;
  mController=controller;
  mRootView=parent;
  mActivity.getLayoutInflater().inflate(R.layout.photo_module,(ViewGroup)mRootView,true);
  mPreviewCover=mRootView.findViewById(R.id.preview_cover);
  mSurfaceView=(SurfaceView)mRootView.findViewById(R.id.mdp_preview_content);
  mSurfaceView.setVisibility(View.VISIBLE);
  mSurfaceHolder=mSurfaceView.getHolder();
  mSurfaceHolder.addCallback(this);
  mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
  Log.v(TAG,""String_Node_Str"");
  mSurfaceView.addOnLayoutChangeListener(new OnLayoutChangeListener(){
    @Override public void onLayoutChange(    View v,    int left,    int top,    int right,    int bottom,    int oldLeft,    int oldTop,    int oldRight,    int oldBottom){
      int width=right - left;
      int height=bottom - top;
      tryToCloseSubList();
      if (mMaxPreviewWidth == 0 && mMaxPreviewHeight == 0) {
        mMaxPreviewWidth=width;
        mMaxPreviewHeight=height;
      }
      if (mOrientationResize != mPrevOrientationResize || mAspectRatioResize || !mIsLayoutInitializedAlready) {
        layoutPreview(mAspectRatio);
        mAspectRatioResize=false;
      }
    }
  }
);
  mRenderOverlay=(RenderOverlay)mRootView.findViewById(R.id.render_overlay);
  mFlashOverlay=mRootView.findViewById(R.id.flash_overlay);
  mShutterButton=(ShutterButton)mRootView.findViewById(R.id.shutter_button);
  mSwitcher=(ModuleSwitcher)mRootView.findViewById(R.id.camera_switcher);
  mSwitcher.setCurrentIndex(ModuleSwitcher.PHOTO_MODULE_INDEX);
  mSwitcher.setSwitchListener(mActivity);
  mSwitcher.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mController.getCameraState() == PhotoController.LONGSHOT) {
        return;
      }
      mSwitcher.showPopup();
      mSwitcher.setOrientation(mOrientation,false);
    }
  }
);
  mMenuButton=mRootView.findViewById(R.id.menu);
  RotateImageView muteButton=(RotateImageView)mRootView.findViewById(R.id.mute_button);
  muteButton.setVisibility(View.GONE);
  mCameraControls=(CameraControls)mRootView.findViewById(R.id.camera_controls);
  ViewStub faceViewStub=(ViewStub)mRootView.findViewById(R.id.face_view_stub);
  if (faceViewStub != null) {
    faceViewStub.inflate();
    mFaceView=(FaceView)mRootView.findViewById(R.id.face_view);
    setSurfaceTextureSizeChangedListener(mFaceView);
  }
  initIndicators();
  mAnimationManager=new AnimationManager();
  mOrientationResize=false;
  mPrevOrientationResize=false;
  Point size=new Point();
  mActivity.getWindowManager().getDefaultDisplay().getSize(size);
  mScreenRatio=CameraUtil.determineRatio(size.x,size.y);
  calculateMargins(size);
  mCameraControls.setMargins(mTopMargin,mBottomMargin);
  showFirstTimeHelp();
}","The original code lacked a mechanism to ensure initial layout rendering, potentially causing preview layout issues on first initialization. The fixed code introduces `!mIsLayoutInitializedAlready` in the layout change condition, which triggers the `layoutPreview` method during the first layout pass. This modification guarantees proper preview initialization and prevents potential rendering inconsistencies across different device configurations and screen orientations."
38204,"public void layoutPreview(float ratio){
  FrameLayout.LayoutParams lp;
  float scaledTextureWidth, scaledTextureHeight;
  int rotation=CameraUtil.getDisplayRotation(mActivity);
  mScreenRatio=CameraUtil.determineRatio(ratio);
  if (mScreenRatio == CameraUtil.RATIO_16_9 && CameraUtil.determinCloseRatio(ratio) == CameraUtil.RATIO_4_3) {
    int l=(mTopMargin + mBottomMargin) * 4;
    int s=l * 9 / 16;
switch (rotation) {
case 90:
      lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
    lp.setMargins(mTopMargin,0,mBottomMargin,0);
  scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
case 180:
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mBottomMargin,0,mTopMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
case 270:
lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
lp.setMargins(mBottomMargin,0,mTopMargin,0);
scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
default :
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mTopMargin,0,mBottomMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
}
}
 else {
float width=mMaxPreviewWidth, height=mMaxPreviewHeight;
if (width == 0 || height == 0) return;
if (mScreenRatio == CameraUtil.RATIO_4_3) height-=(mTopMargin + mBottomMargin);
if (mOrientationResize) {
scaledTextureWidth=height * mAspectRatio;
if (scaledTextureWidth > width) {
scaledTextureWidth=width;
scaledTextureHeight=scaledTextureWidth / mAspectRatio;
}
 else {
scaledTextureHeight=height;
}
}
 else {
if (width > height) {
if (Math.max(width,height * mAspectRatio) > width) {
scaledTextureWidth=width;
scaledTextureHeight=width / mAspectRatio;
}
 else {
scaledTextureWidth=height * mAspectRatio;
scaledTextureHeight=height;
}
}
 else {
if (Math.max(height,width * mAspectRatio) > height) {
scaledTextureWidth=height / mAspectRatio;
scaledTextureHeight=height;
}
 else {
scaledTextureWidth=width;
scaledTextureHeight=width * mAspectRatio;
}
}
}
Log.v(TAG,""String_Node_Str"" + scaledTextureWidth + ""String_Node_Str""+ scaledTextureHeight);
if (((rotation == 0 || rotation == 180) && scaledTextureWidth > scaledTextureHeight) || ((rotation == 90 || rotation == 270) && scaledTextureWidth < scaledTextureHeight)) {
lp=new FrameLayout.LayoutParams((int)scaledTextureHeight,(int)scaledTextureWidth,Gravity.CENTER);
}
 else {
lp=new FrameLayout.LayoutParams((int)scaledTextureWidth,(int)scaledTextureHeight,Gravity.CENTER);
}
if (mScreenRatio == CameraUtil.RATIO_4_3) {
lp.gravity=Gravity.CENTER_HORIZONTAL | Gravity.TOP;
lp.setMargins(0,mTopMargin,0,mBottomMargin);
}
}
if (mSurfaceTextureUncroppedWidth != scaledTextureWidth || mSurfaceTextureUncroppedHeight != scaledTextureHeight) {
mSurfaceTextureUncroppedWidth=scaledTextureWidth;
mSurfaceTextureUncroppedHeight=scaledTextureHeight;
if (mSurfaceTextureSizeListener != null) {
mSurfaceTextureSizeListener.onSurfaceTextureSizeChanged((int)mSurfaceTextureUncroppedWidth,(int)mSurfaceTextureUncroppedHeight);
Log.d(TAG,""String_Node_Str"" + mSurfaceTextureUncroppedWidth + ""String_Node_Str""+ mSurfaceTextureUncroppedHeight);
}
}
mSurfaceView.setLayoutParams(lp);
if (mFaceView != null) {
mFaceView.setLayoutParams(lp);
}
}","public void layoutPreview(float ratio){
  FrameLayout.LayoutParams lp;
  float scaledTextureWidth, scaledTextureHeight;
  int rotation=CameraUtil.getDisplayRotation(mActivity);
  mScreenRatio=CameraUtil.determineRatio(ratio);
  if (mScreenRatio == CameraUtil.RATIO_16_9 && CameraUtil.determinCloseRatio(ratio) == CameraUtil.RATIO_4_3) {
    int l=(mTopMargin + mBottomMargin) * 4;
    int s=l * 9 / 16;
switch (rotation) {
case 90:
      lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
    lp.setMargins(mTopMargin,0,mBottomMargin,0);
  scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
case 180:
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mBottomMargin,0,mTopMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
case 270:
lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
lp.setMargins(mBottomMargin,0,mTopMargin,0);
scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
default :
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mTopMargin,0,mBottomMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
}
}
 else {
float width=mMaxPreviewWidth, height=mMaxPreviewHeight;
if (width == 0 || height == 0) return;
if (mScreenRatio == CameraUtil.RATIO_4_3) height-=(mTopMargin + mBottomMargin);
if (mOrientationResize) {
scaledTextureWidth=height * mAspectRatio;
if (scaledTextureWidth > width) {
scaledTextureWidth=width;
scaledTextureHeight=scaledTextureWidth / mAspectRatio;
}
 else {
scaledTextureHeight=height;
}
}
 else {
if (width > height) {
if (Math.max(width,height * mAspectRatio) > width) {
scaledTextureWidth=width;
scaledTextureHeight=width / mAspectRatio;
}
 else {
scaledTextureWidth=height * mAspectRatio;
scaledTextureHeight=height;
}
}
 else {
if (Math.max(height,width * mAspectRatio) > height) {
scaledTextureWidth=height / mAspectRatio;
scaledTextureHeight=height;
}
 else {
scaledTextureWidth=width;
scaledTextureHeight=width * mAspectRatio;
}
}
}
Log.v(TAG,""String_Node_Str"" + scaledTextureWidth + ""String_Node_Str""+ scaledTextureHeight);
if (((rotation == 0 || rotation == 180) && scaledTextureWidth > scaledTextureHeight) || ((rotation == 90 || rotation == 270) && scaledTextureWidth < scaledTextureHeight)) {
lp=new FrameLayout.LayoutParams((int)scaledTextureHeight,(int)scaledTextureWidth,Gravity.CENTER);
}
 else {
lp=new FrameLayout.LayoutParams((int)scaledTextureWidth,(int)scaledTextureHeight,Gravity.CENTER);
}
if (mScreenRatio == CameraUtil.RATIO_4_3) {
lp.gravity=Gravity.CENTER_HORIZONTAL | Gravity.TOP;
lp.setMargins(0,mTopMargin,0,mBottomMargin);
}
}
if (mSurfaceTextureUncroppedWidth != scaledTextureWidth || mSurfaceTextureUncroppedHeight != scaledTextureHeight) {
mSurfaceTextureUncroppedWidth=scaledTextureWidth;
mSurfaceTextureUncroppedHeight=scaledTextureHeight;
if (mSurfaceTextureSizeListener != null) {
mSurfaceTextureSizeListener.onSurfaceTextureSizeChanged((int)mSurfaceTextureUncroppedWidth,(int)mSurfaceTextureUncroppedHeight);
Log.d(TAG,""String_Node_Str"" + mSurfaceTextureUncroppedWidth + ""String_Node_Str""+ mSurfaceTextureUncroppedHeight);
}
}
mSurfaceView.setLayoutParams(lp);
if (mFaceView != null) {
mFaceView.setLayoutParams(lp);
}
mIsLayoutInitializedAlready=true;
}","The original code lacked a flag to track layout initialization, potentially causing repeated or inconsistent layout updates. The fixed code adds `mIsLayoutInitializedAlready=true` at the end of the method, ensuring that layout parameters are set only once and preventing unnecessary redraws. This modification improves performance and prevents potential UI flickering by establishing a clear state management mechanism for preview layout rendering."
38205,"@Override public void onLayoutChange(View v,int left,int top,int right,int bottom,int oldLeft,int oldTop,int oldRight,int oldBottom){
  int width=right - left;
  int height=bottom - top;
  tryToCloseSubList();
  if (mMaxPreviewWidth == 0 && mMaxPreviewHeight == 0) {
    mMaxPreviewWidth=width;
    mMaxPreviewHeight=height;
  }
  if (mOrientationResize != mPrevOrientationResize || mAspectRatioResize) {
    layoutPreview(mAspectRatio);
    mAspectRatioResize=false;
  }
}","@Override public void onLayoutChange(View v,int left,int top,int right,int bottom,int oldLeft,int oldTop,int oldRight,int oldBottom){
  int width=right - left;
  int height=bottom - top;
  tryToCloseSubList();
  if (mMaxPreviewWidth == 0 && mMaxPreviewHeight == 0) {
    mMaxPreviewWidth=width;
    mMaxPreviewHeight=height;
  }
  if (mOrientationResize != mPrevOrientationResize || mAspectRatioResize || !mIsLayoutInitializedAlready) {
    layoutPreview(mAspectRatio);
    mAspectRatioResize=false;
  }
}","The original code lacked a condition to ensure initial layout initialization, potentially skipping crucial preview layout setup. The fixed code adds `!mIsLayoutInitializedAlready` to the conditional check, guaranteeing that the preview is laid out at least once, even if orientation and aspect ratio haven't changed. This modification ensures a more robust and complete initial rendering of the view, preventing potential layout inconsistencies."
38206,"public PhotoUI(CameraActivity activity,PhotoController controller,View parent){
  mActivity=activity;
  mController=controller;
  mRootView=parent;
  mActivity.getLayoutInflater().inflate(R.layout.photo_module,(ViewGroup)mRootView,true);
  mPreviewCover=mRootView.findViewById(R.id.preview_cover);
  mSurfaceView=(SurfaceView)mRootView.findViewById(R.id.mdp_preview_content);
  mSurfaceView.setVisibility(View.VISIBLE);
  mSurfaceHolder=mSurfaceView.getHolder();
  mSurfaceHolder.addCallback(this);
  mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
  Log.v(TAG,""String_Node_Str"");
  mSurfaceView.addOnLayoutChangeListener(new OnLayoutChangeListener(){
    @Override public void onLayoutChange(    View v,    int left,    int top,    int right,    int bottom,    int oldLeft,    int oldTop,    int oldRight,    int oldBottom){
      int width=right - left;
      int height=bottom - top;
      tryToCloseSubList();
      if (mMaxPreviewWidth == 0 && mMaxPreviewHeight == 0) {
        mMaxPreviewWidth=width;
        mMaxPreviewHeight=height;
      }
      if (mOrientationResize != mPrevOrientationResize || mAspectRatioResize) {
        layoutPreview(mAspectRatio);
        mAspectRatioResize=false;
      }
    }
  }
);
  mRenderOverlay=(RenderOverlay)mRootView.findViewById(R.id.render_overlay);
  mFlashOverlay=mRootView.findViewById(R.id.flash_overlay);
  mShutterButton=(ShutterButton)mRootView.findViewById(R.id.shutter_button);
  mSwitcher=(ModuleSwitcher)mRootView.findViewById(R.id.camera_switcher);
  mSwitcher.setCurrentIndex(ModuleSwitcher.PHOTO_MODULE_INDEX);
  mSwitcher.setSwitchListener(mActivity);
  mSwitcher.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mController.getCameraState() == PhotoController.LONGSHOT) {
        return;
      }
      mSwitcher.showPopup();
      mSwitcher.setOrientation(mOrientation,false);
    }
  }
);
  mMenuButton=mRootView.findViewById(R.id.menu);
  RotateImageView muteButton=(RotateImageView)mRootView.findViewById(R.id.mute_button);
  muteButton.setVisibility(View.GONE);
  mCameraControls=(CameraControls)mRootView.findViewById(R.id.camera_controls);
  ViewStub faceViewStub=(ViewStub)mRootView.findViewById(R.id.face_view_stub);
  if (faceViewStub != null) {
    faceViewStub.inflate();
    mFaceView=(FaceView)mRootView.findViewById(R.id.face_view);
    setSurfaceTextureSizeChangedListener(mFaceView);
  }
  initIndicators();
  mAnimationManager=new AnimationManager();
  mOrientationResize=false;
  mPrevOrientationResize=false;
  Point size=new Point();
  mActivity.getWindowManager().getDefaultDisplay().getSize(size);
  mScreenRatio=CameraUtil.determineRatio(size.x,size.y);
  calculateMargins(size);
  mCameraControls.setMargins(mTopMargin,mBottomMargin);
  showFirstTimeHelp();
}","public PhotoUI(CameraActivity activity,PhotoController controller,View parent){
  mActivity=activity;
  mController=controller;
  mRootView=parent;
  mActivity.getLayoutInflater().inflate(R.layout.photo_module,(ViewGroup)mRootView,true);
  mPreviewCover=mRootView.findViewById(R.id.preview_cover);
  mSurfaceView=(SurfaceView)mRootView.findViewById(R.id.mdp_preview_content);
  mSurfaceView.setVisibility(View.VISIBLE);
  mSurfaceHolder=mSurfaceView.getHolder();
  mSurfaceHolder.addCallback(this);
  mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
  Log.v(TAG,""String_Node_Str"");
  mSurfaceView.addOnLayoutChangeListener(new OnLayoutChangeListener(){
    @Override public void onLayoutChange(    View v,    int left,    int top,    int right,    int bottom,    int oldLeft,    int oldTop,    int oldRight,    int oldBottom){
      int width=right - left;
      int height=bottom - top;
      tryToCloseSubList();
      if (mMaxPreviewWidth == 0 && mMaxPreviewHeight == 0) {
        mMaxPreviewWidth=width;
        mMaxPreviewHeight=height;
      }
      if (mOrientationResize != mPrevOrientationResize || mAspectRatioResize || !mIsLayoutInitializedAlready) {
        layoutPreview(mAspectRatio);
        mAspectRatioResize=false;
      }
    }
  }
);
  mRenderOverlay=(RenderOverlay)mRootView.findViewById(R.id.render_overlay);
  mFlashOverlay=mRootView.findViewById(R.id.flash_overlay);
  mShutterButton=(ShutterButton)mRootView.findViewById(R.id.shutter_button);
  mSwitcher=(ModuleSwitcher)mRootView.findViewById(R.id.camera_switcher);
  mSwitcher.setCurrentIndex(ModuleSwitcher.PHOTO_MODULE_INDEX);
  mSwitcher.setSwitchListener(mActivity);
  mSwitcher.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mController.getCameraState() == PhotoController.LONGSHOT) {
        return;
      }
      mSwitcher.showPopup();
      mSwitcher.setOrientation(mOrientation,false);
    }
  }
);
  mMenuButton=mRootView.findViewById(R.id.menu);
  RotateImageView muteButton=(RotateImageView)mRootView.findViewById(R.id.mute_button);
  muteButton.setVisibility(View.GONE);
  mCameraControls=(CameraControls)mRootView.findViewById(R.id.camera_controls);
  ViewStub faceViewStub=(ViewStub)mRootView.findViewById(R.id.face_view_stub);
  if (faceViewStub != null) {
    faceViewStub.inflate();
    mFaceView=(FaceView)mRootView.findViewById(R.id.face_view);
    setSurfaceTextureSizeChangedListener(mFaceView);
  }
  initIndicators();
  mAnimationManager=new AnimationManager();
  mOrientationResize=false;
  mPrevOrientationResize=false;
  Point size=new Point();
  mActivity.getWindowManager().getDefaultDisplay().getSize(size);
  mScreenRatio=CameraUtil.determineRatio(size.x,size.y);
  calculateMargins(size);
  mCameraControls.setMargins(mTopMargin,mBottomMargin);
  showFirstTimeHelp();
}","The original code lacked a mechanism to ensure initial layout initialization, potentially causing preview layout issues on first render. The fixed code introduces `!mIsLayoutInitializedAlready` in the layout change condition, ensuring the preview is properly configured during the first layout pass. This modification guarantees consistent preview rendering across different device configurations and initial view setup scenarios."
38207,"public void onSingleTapUp(int x,int y){
  if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH)   return;
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_TOUCH_FOCUS,x + ""String_Node_Str"" + y);
  if ((mFocusArea != null) && (mState == STATE_FOCUSING || mState == STATE_SUCCESS || mState == STATE_FAIL)) {
    cancelAutoFocus();
  }
  if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0)   return;
  if (mFocusAreaSupported) {
    initializeFocusAreas(x,y);
  }
  if (mMeteringAreaSupported) {
    initializeMeteringAreas(x,y);
  }
  mUI.setFocusPosition(x,y);
  if (mZslEnabled) {
    mTouchAFRunning=true;
  }
  mListener.stopFaceDetection();
  mListener.setFocusParameters();
  if (mFocusAreaSupported) {
    autoFocus();
  }
 else {
    updateFocusUI();
    mHandler.removeMessages(RESET_TOUCH_FOCUS);
    mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS,RESET_TOUCH_FOCUS_DELAY);
  }
}","public void onSingleTapUp(int x,int y){
  if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH)   return;
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_TOUCH_FOCUS,x + ""String_Node_Str"" + y);
  if ((mState == STATE_FOCUSING || mState == STATE_SUCCESS || mState == STATE_FAIL)) {
    cancelAutoFocus();
  }
  if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0)   return;
  if (mFocusAreaSupported) {
    initializeFocusAreas(x,y);
  }
  if (mMeteringAreaSupported) {
    initializeMeteringAreas(x,y);
  }
  mUI.setFocusPosition(x,y);
  if (mZslEnabled) {
    mTouchAFRunning=true;
  }
  mListener.stopFaceDetection();
  mListener.setFocusParameters();
  if (mFocusAreaSupported) {
    autoFocus();
  }
 else {
    updateFocusUI();
    mHandler.removeMessages(RESET_TOUCH_FOCUS);
    mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS,RESET_TOUCH_FOCUS_DELAY);
  }
}","The original code incorrectly checks `mFocusArea != null` before canceling auto-focus, which could prevent necessary focus cancellation in certain states. The fixed code removes this unnecessary null check, allowing auto-focus cancellation based solely on the camera's current state (focusing, success, or failure). This modification ensures more reliable and consistent camera focus behavior, preventing potential focus-related issues by simplifying the cancellation logic."
38208,"public boolean is4KEnabled(){
  if (mProfile.quality == CamcorderProfile.QUALITY_2160P || mProfile.quality == CamcorderProfile.QUALITY_4KDCI) {
    return true;
  }
 else {
    return false;
  }
}","public boolean is4KEnabled(){
  if (mProfile.quality == CamcorderProfile.QUALITY_2160P || mProfile.quality == CamcorderProfile.QUALITY_TIME_LAPSE_2160P || mProfile.quality == CamcorderProfile.QUALITY_4KDCI) {
    return true;
  }
 else {
    return false;
  }
}","The original code missed checking for time-lapse 4K video quality, which could lead to incorrect 4K detection in certain recording scenarios. The fixed code adds CamcorderProfile.QUALITY_TIME_LAPSE_2160P to the condition, ensuring comprehensive 4K quality detection for both standard and time-lapse recording modes. This enhancement provides a more robust and accurate method for determining 4K video capability across different camera profile configurations."
38209,"@Override public void onResumeAfterSuper(){
  mLastPhotoTakenWithRefocus=false;
  String action=mActivity.getIntent().getAction();
  if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(action) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)) {
    Log.v(TAG,""String_Node_Str"");
    mHandler.postDelayed(new Runnable(){
      public void run(){
        onResumeTasks();
        if (isInstantCaptureEnabled()) {
          mInstantCaptureSnapShot=true;
        }
      }
    }
,ON_RESUME_TASKS_DELAY_MSEC);
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    onResumeTasks();
  }
  mUI.setSwitcherIndex();
  if (mSoundPool == null) {
    mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
    mRefocusSound=mSoundPool.load(mActivity,R.raw.camera_click_x5,1);
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      mActivity.updateStorageSpaceAndHint();
      updateRemainingPhotos();
    }
  }
);
}","@Override public void onResumeAfterSuper(){
  mLastPhotoTakenWithRefocus=false;
  String action=mActivity.getIntent().getAction();
  if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(action) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)) {
    Log.v(TAG,""String_Node_Str"");
    if (isInstantCaptureEnabled()) {
      mInstantCaptureSnapShot=true;
    }
    mHandler.postDelayed(new Runnable(){
      public void run(){
        onResumeTasks();
      }
    }
,ON_RESUME_TASKS_DELAY_MSEC);
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    onResumeTasks();
  }
  mUI.setSwitcherIndex();
  if (mSoundPool == null) {
    mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
    mRefocusSound=mSoundPool.load(mActivity,R.raw.camera_click_x5,1);
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      mActivity.updateStorageSpaceAndHint();
      updateRemainingPhotos();
    }
  }
);
}","The original code incorrectly set `mInstantCaptureSnapShot` inside a delayed Runnable, potentially causing timing-related race conditions or delayed state updates. In the fixed code, `mInstantCaptureSnapShot` is set immediately before the delayed Runnable, ensuring proper and predictable state management. This modification improves code reliability by separating state initialization from asynchronous task execution, preventing potential synchronization issues and making the code's behavior more deterministic."
38210,"@Override public void onResumeAfterSuper(){
  mLastPhotoTakenWithRefocus=false;
  mUI.showSurfaceView();
  String action=mActivity.getIntent().getAction();
  if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(action) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)) {
    Log.v(TAG,""String_Node_Str"");
    mHandler.postDelayed(new Runnable(){
      public void run(){
        onResumeTasks();
        if (isInstantCaptureEnabled()) {
          mInstantCaptureSnapShot=true;
        }
      }
    }
,ON_RESUME_TASKS_DELAY_MSEC);
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    onResumeTasks();
  }
  mUI.setSwitcherIndex();
  if (mSoundPool == null) {
    mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
    mRefocusSound=mSoundPool.load(mActivity,R.raw.camera_click_x5,1);
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      mActivity.updateStorageSpaceAndHint();
      updateRemainingPhotos();
    }
  }
);
}","@Override public void onResumeAfterSuper(){
  mLastPhotoTakenWithRefocus=false;
  mUI.showSurfaceView();
  String action=mActivity.getIntent().getAction();
  if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(action) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)) {
    Log.v(TAG,""String_Node_Str"");
    if (isInstantCaptureEnabled()) {
      mInstantCaptureSnapShot=true;
    }
    mHandler.postDelayed(new Runnable(){
      public void run(){
        onResumeTasks();
      }
    }
,ON_RESUME_TASKS_DELAY_MSEC);
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    onResumeTasks();
  }
  mUI.setSwitcherIndex();
  if (mSoundPool == null) {
    mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
    mRefocusSound=mSoundPool.load(mActivity,R.raw.camera_click_x5,1);
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      mActivity.updateStorageSpaceAndHint();
      updateRemainingPhotos();
    }
  }
);
}","The original code incorrectly set `mInstantCaptureSnapShot` inside the delayed runnable, potentially causing timing-related race conditions. In the fixed code, `mInstantCaptureSnapShot` is set before the delayed task, ensuring proper initialization before potential execution. This modification improves code reliability by separating configuration from delayed task execution, preventing potential synchronization issues and ensuring more predictable behavior."
38211,"public boolean is4KEnabled(){
  if (mProfile.quality == CamcorderProfile.QUALITY_2160P || mProfile.quality == CamcorderProfile.QUALITY_4KDCI) {
    return true;
  }
 else {
    return false;
  }
}","public boolean is4KEnabled(){
  if (mProfile.quality == CamcorderProfile.QUALITY_2160P || mProfile.quality == CamcorderProfile.QUALITY_TIME_LAPSE_2160P || mProfile.quality == CamcorderProfile.QUALITY_4KDCI) {
    return true;
  }
 else {
    return false;
  }
}","The original code missed checking for the time-lapse 4K quality profile, potentially incorrectly reporting 4K support. The fixed code adds CamcorderProfile.QUALITY_TIME_LAPSE_2160P to the condition, ensuring comprehensive detection of 4K video modes including standard and time-lapse variants. This modification provides a more robust and accurate method for determining 4K video capability across different camera profile configurations."
38212,"public void onSingleTapUp(int x,int y){
  if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH)   return;
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_TOUCH_FOCUS,x + ""String_Node_Str"" + y);
  if ((mFocusArea != null) && (mState == STATE_FOCUSING || mState == STATE_SUCCESS || mState == STATE_FAIL)) {
    cancelAutoFocus();
  }
  if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0)   return;
  if (mFocusAreaSupported) {
    initializeFocusAreas(x,y);
  }
  if (mMeteringAreaSupported) {
    initializeMeteringAreas(x,y);
  }
  mUI.setFocusPosition(x,y);
  if (mZslEnabled) {
    mTouchAFRunning=true;
  }
  mListener.stopFaceDetection();
  mListener.setFocusParameters();
  if (mFocusAreaSupported) {
    autoFocus();
  }
 else {
    updateFocusUI();
    mHandler.removeMessages(RESET_TOUCH_FOCUS);
    mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS,RESET_TOUCH_FOCUS_DELAY);
  }
}","public void onSingleTapUp(int x,int y){
  if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH)   return;
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_TOUCH_FOCUS,x + ""String_Node_Str"" + y);
  if ((mState == STATE_FOCUSING || mState == STATE_SUCCESS || mState == STATE_FAIL)) {
    cancelAutoFocus();
  }
  if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0)   return;
  if (mFocusAreaSupported) {
    initializeFocusAreas(x,y);
  }
  if (mMeteringAreaSupported) {
    initializeMeteringAreas(x,y);
  }
  mUI.setFocusPosition(x,y);
  if (mZslEnabled) {
    mTouchAFRunning=true;
  }
  mListener.stopFaceDetection();
  mListener.setFocusParameters();
  if (mFocusAreaSupported) {
    autoFocus();
  }
 else {
    updateFocusUI();
    mHandler.removeMessages(RESET_TOUCH_FOCUS);
    mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS,RESET_TOUCH_FOCUS_DELAY);
  }
}","The original code incorrectly checks `mFocusArea != null` before canceling autofocus, which could prevent necessary focus reset in certain scenarios. The fixed code removes this unnecessary condition, allowing autofocus cancellation based solely on the camera's current state. This modification ensures more reliable focus management and prevents potential focus-related issues by simplifying the cancellation logic."
38213,"public void initSwitchItem(final String prefKey,View switcher){
  final IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
  if (pref == null)   return;
  int[] iconIds=pref.getLargeIconIds();
  int resid=-1;
  int index=pref.findIndexOfValue(pref.getValue());
  if (!pref.getUseSingleIcon() && iconIds != null) {
    resid=iconIds[index];
  }
 else {
    resid=pref.getSingleIcon();
  }
  ((ImageView)switcher).setImageResource(resid);
  switcher.setVisibility(View.VISIBLE);
  mPreferences.add(pref);
  mPreferenceMap.put(pref,switcher);
  switcher.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
      if (pref == null)       return;
      int index=pref.findIndexOfValue(pref.getValue());
      CharSequence[] values=pref.getEntryValues();
      index=(index + 1) % values.length;
      pref.setValueIndex(index);
      ((ImageView)v).setImageResource(((IconListPreference)pref).getLargeIconIds()[index]);
      if (prefKey.equals(CameraSettings.KEY_CAMERA_ID))       mListener.onCameraPickerClicked(index);
      reloadPreference(pref);
      onSettingChanged(pref);
    }
  }
);
}","public void initSwitchItem(final String prefKey,View switcher){
  final IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
  if (pref == null)   return;
  int[] iconIds=pref.getLargeIconIds();
  int resid=-1;
  int index=pref.findIndexOfValue(pref.getValue());
  if (!pref.getUseSingleIcon() && iconIds != null) {
    resid=iconIds[index];
  }
 else {
    resid=pref.getSingleIcon();
  }
  ((ImageView)switcher).setImageResource(resid);
  switcher.setVisibility(View.VISIBLE);
  mPreferences.add(pref);
  mPreferenceMap.put(pref,switcher);
  switcher.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
      if (pref == null)       return;
      mUI.hideUI();
      int index=pref.findIndexOfValue(pref.getValue());
      CharSequence[] values=pref.getEntryValues();
      index=(index + 1) % values.length;
      pref.setValueIndex(index);
      ((ImageView)v).setImageResource(((IconListPreference)pref).getLargeIconIds()[index]);
      if (prefKey.equals(CameraSettings.KEY_CAMERA_ID))       mListener.onCameraPickerClicked(index);
      reloadPreference(pref);
      onSettingChanged(pref);
    }
  }
);
}","The original code lacked a critical UI interaction step when changing preferences, potentially leaving the user interface in an unresponsive state. The fixed code adds `mUI.hideUI()` before preference modification, ensuring proper UI management during preference cycling. This improvement enhances user experience by explicitly managing the UI state during preference changes, preventing potential interface inconsistencies and providing a more robust interaction mechanism."
38214,"public void initSwitchItem(final String prefKey,View switcher){
  final IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
  if (pref == null)   return;
  int[] iconIds=pref.getLargeIconIds();
  int resid=-1;
  int index=pref.findIndexOfValue(pref.getValue());
  if (!pref.getUseSingleIcon() && iconIds != null) {
    resid=iconIds[index];
  }
 else {
    resid=pref.getSingleIcon();
  }
  ((ImageView)switcher).setImageResource(resid);
  switcher.setVisibility(View.VISIBLE);
  mPreferences.add(pref);
  mPreferenceMap.put(pref,switcher);
  switcher.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
      if (pref == null)       return;
      int index=pref.findIndexOfValue(pref.getValue());
      CharSequence[] values=pref.getEntryValues();
      index=(index + 1) % values.length;
      pref.setValueIndex(index);
      ((ImageView)v).setImageResource(((IconListPreference)pref).getLargeIconIds()[index]);
      if (prefKey.equals(CameraSettings.KEY_CAMERA_ID))       mListener.onCameraPickerClicked(index);
      reloadPreference(pref);
      onSettingChanged(pref);
    }
  }
);
}","public void initSwitchItem(final String prefKey,View switcher){
  final IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
  if (pref == null)   return;
  int[] iconIds=pref.getLargeIconIds();
  int resid=-1;
  int index=pref.findIndexOfValue(pref.getValue());
  if (!pref.getUseSingleIcon() && iconIds != null) {
    resid=iconIds[index];
  }
 else {
    resid=pref.getSingleIcon();
  }
  ((ImageView)switcher).setImageResource(resid);
  switcher.setVisibility(View.VISIBLE);
  mPreferences.add(pref);
  mPreferenceMap.put(pref,switcher);
  switcher.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      IconListPreference pref=(IconListPreference)mPreferenceGroup.findPreference(prefKey);
      if (pref == null)       return;
      mUI.hideUI();
      int index=pref.findIndexOfValue(pref.getValue());
      CharSequence[] values=pref.getEntryValues();
      index=(index + 1) % values.length;
      pref.setValueIndex(index);
      ((ImageView)v).setImageResource(((IconListPreference)pref).getLargeIconIds()[index]);
      if (prefKey.equals(CameraSettings.KEY_CAMERA_ID))       mListener.onCameraPickerClicked(index);
      reloadPreference(pref);
      onSettingChanged(pref);
    }
  }
);
}","The original code lacked a critical UI management step when switching preferences, potentially leaving the user interface in an unresponsive state. The fixed code adds `mUI.hideUI()` before changing the preference, ensuring proper UI management during interaction. This improvement enhances user experience by providing a more controlled and predictable interface transition when modifying camera settings."
38215,"@Override public void onError(MediaRecorder mr,int what,int extra){
  Log.e(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ extra);
  stopVideoRecording();
  if (what == MediaRecorder.MEDIA_RECORDER_ERROR_UNKNOWN) {
    mActivity.updateStorageSpaceAndHint();
  }
}","@Override public void onError(MediaRecorder mr,int what,int extra){
  Log.e(TAG,""String_Node_Str"" + what + ""String_Node_Str""+ extra);
  stopVideoRecording();
  mUI.showUIafterRecording();
  if (what == MediaRecorder.MEDIA_RECORDER_ERROR_UNKNOWN) {
    mActivity.updateStorageSpaceAndHint();
  }
}","The original code lacks a crucial UI update after stopping video recording, potentially leaving the user interface in an inconsistent state. The fixed code adds `mUI.showUIafterRecording()`, which ensures proper user interface restoration after an error occurs during recording. This enhancement provides a more robust and user-friendly error handling mechanism by explicitly resetting the UI and maintaining a clear user experience."
38216,"/** 
 * This method does not deal with the API level check.  Everyone should check first for supported operations before sending message to this handler.
 */
@Override public void handleMessage(final Message msg){
  try {
switch (msg.what) {
case OPEN_CAMERA:
      try {
        Method openMethod=Class.forName(""String_Node_Str"").getMethod(""String_Node_Str"",int.class,int.class);
        mCamera=(android.hardware.Camera)openMethod.invoke(null,msg.arg1,CAMERA_HAL_API_VERSION_1_0);
      }
 catch (      Exception e) {
        Log.v(TAG,""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
        mCamera=android.hardware.Camera.open(msg.arg1);
      }
    if (mCamera != null) {
      mParametersIsDirty=true;
      if (mParamsToSet == null) {
        mParamsToSet=mCamera.getParameters();
      }
    }
 else {
      if (msg.obj != null) {
        ((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
      }
    }
  return;
case RELEASE:
if (mCamera == null) {
  return;
}
mCamera.release();
errorCbInstance=null;
mCamera=null;
return;
case RECONNECT:
mReconnectIOException=null;
try {
mCamera.reconnect();
}
 catch (IOException ex) {
mReconnectIOException=ex;
}
return;
case UNLOCK:
mCamera.unlock();
return;
case LOCK:
mCamera.lock();
return;
case SET_PREVIEW_TEXTURE_ASYNC:
setPreviewTexture(msg.obj);
return;
case SET_PREVIEW_DISPLAY_ASYNC:
try {
mCamera.setPreviewDisplay((SurfaceHolder)msg.obj);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
return;
case START_PREVIEW_ASYNC:
try {
mCamera.startPreview();
}
 catch (Exception e) {
e.printStackTrace();
if (errorCbInstance != null) errorCbInstance.onStartPreviewFailure(msg.arg1);
}
return;
case STOP_PREVIEW:
mCamera.stopPreview();
return;
case SET_PREVIEW_CALLBACK_WITH_BUFFER:
mCamera.setPreviewCallbackWithBuffer((PreviewCallback)msg.obj);
return;
case ADD_CALLBACK_BUFFER:
mCamera.addCallbackBuffer((byte[])msg.obj);
return;
case AUTO_FOCUS:
mCamera.autoFocus((AutoFocusCallback)msg.obj);
return;
case CANCEL_AUTO_FOCUS:
mCamera.cancelAutoFocus();
return;
case SET_AUTO_FOCUS_MOVE_CALLBACK:
setAutoFocusMoveCallback(mCamera,msg.obj);
return;
case SET_DISPLAY_ORIENTATION:
mCamera.setDisplayOrientation(msg.arg1);
return;
case SET_ZOOM_CHANGE_LISTENER:
mCamera.setZoomChangeListener((OnZoomChangeListener)msg.obj);
return;
case SET_FACE_DETECTION_LISTENER:
setFaceDetectionListener((FaceDetectionListener)msg.obj);
return;
case START_FACE_DETECTION:
startFaceDetection();
return;
case STOP_FACE_DETECTION:
stopFaceDetection();
return;
case SET_ERROR_CALLBACK:
mCamera.setErrorCallback((ErrorCallback)msg.obj);
return;
case SET_PARAMETERS:
mParametersIsDirty=true;
mCamera.setParameters((Parameters)msg.obj);
mSig.open();
break;
case GET_PARAMETERS:
if (mParametersIsDirty) {
mParameters=mCamera.getParameters();
mParametersIsDirty=false;
}
return;
case SET_PREVIEW_CALLBACK:
mCamera.setPreviewCallback((PreviewCallback)msg.obj);
return;
case SET_ONESHOT_PREVIEW_CALLBACK:
mCamera.setOneShotPreviewCallback((PreviewCallback)msg.obj);
case ENABLE_SHUTTER_SOUND:
enableShutterSound((msg.arg1 == 1) ? true : false);
return;
case REFRESH_PARAMETERS:
mParametersIsDirty=true;
return;
case SET_HISTOGRAM_MODE:
mCamera.setHistogramMode((CameraDataCallback)msg.obj);
break;
case SEND_HISTOGRAM_DATA:
mCamera.sendHistogramData();
break;
case SET_LONGSHOT:
mCamera.setLongshot((Boolean)msg.obj);
break;
case SET_AUTO_HDR_MODE:
mCamera.setMetadataCb((CameraMetaDataCallback)msg.obj);
break;
default :
throw new RuntimeException(""String_Node_Str"" + msg.what);
}
}
 catch (RuntimeException e) {
if (msg.what != RELEASE && mCamera != null) {
try {
mCamera.release();
}
 catch (Exception ex) {
Log.e(TAG,""String_Node_Str"");
}
mCamera=null;
}
 else if (mCamera == null) {
if (msg.what == OPEN_CAMERA) {
if (msg.obj != null) {
((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
}
}
 else {
Log.w(TAG,""String_Node_Str"");
}
return;
}
throw e;
}
}","/** 
 * This method does not deal with the API level check.  Everyone should check first for supported operations before sending message to this handler.
 */
@Override public void handleMessage(final Message msg){
  try {
switch (msg.what) {
case OPEN_CAMERA:
      try {
        Method openMethod=Class.forName(""String_Node_Str"").getMethod(""String_Node_Str"",int.class,int.class);
        mCamera=(android.hardware.Camera)openMethod.invoke(null,msg.arg1,CAMERA_HAL_API_VERSION_1_0);
      }
 catch (      Exception e) {
        Log.v(TAG,""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
        mCamera=android.hardware.Camera.open(msg.arg1);
      }
    if (mCamera != null) {
      mParametersIsDirty=true;
      if (mParamsToSet == null) {
        mParamsToSet=mCamera.getParameters();
      }
    }
 else {
      if (msg.obj != null) {
        ((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
      }
    }
  return;
case RELEASE:
if (mCamera == null) {
  return;
}
mCamera.release();
errorCbInstance=null;
mCamera=null;
return;
case RECONNECT:
mReconnectIOException=null;
try {
mCamera.reconnect();
}
 catch (IOException ex) {
mReconnectIOException=ex;
}
return;
case UNLOCK:
mCamera.unlock();
return;
case LOCK:
mCamera.lock();
return;
case SET_PREVIEW_TEXTURE_ASYNC:
setPreviewTexture(msg.obj);
return;
case SET_PREVIEW_DISPLAY_ASYNC:
try {
mCamera.setPreviewDisplay((SurfaceHolder)msg.obj);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
return;
case START_PREVIEW_ASYNC:
try {
mCamera.startPreview();
}
 catch (Exception e) {
e.printStackTrace();
if (errorCbInstance != null) errorCbInstance.onStartPreviewFailure(msg.arg1);
}
return;
case STOP_PREVIEW:
mCamera.stopPreview();
return;
case SET_PREVIEW_CALLBACK_WITH_BUFFER:
mCamera.setPreviewCallbackWithBuffer((PreviewCallback)msg.obj);
return;
case ADD_CALLBACK_BUFFER:
mCamera.addCallbackBuffer((byte[])msg.obj);
return;
case AUTO_FOCUS:
mCamera.autoFocus((AutoFocusCallback)msg.obj);
return;
case CANCEL_AUTO_FOCUS:
mCamera.cancelAutoFocus();
return;
case SET_AUTO_FOCUS_MOVE_CALLBACK:
setAutoFocusMoveCallback(mCamera,msg.obj);
return;
case SET_DISPLAY_ORIENTATION:
mCamera.setDisplayOrientation(msg.arg1);
return;
case SET_ZOOM_CHANGE_LISTENER:
mCamera.setZoomChangeListener((OnZoomChangeListener)msg.obj);
return;
case SET_FACE_DETECTION_LISTENER:
setFaceDetectionListener((FaceDetectionListener)msg.obj);
return;
case START_FACE_DETECTION:
startFaceDetection();
return;
case STOP_FACE_DETECTION:
stopFaceDetection();
return;
case SET_ERROR_CALLBACK:
mCamera.setErrorCallback((ErrorCallback)msg.obj);
return;
case SET_PARAMETERS:
mParametersIsDirty=true;
mCamera.setParameters((Parameters)msg.obj);
mSig.open();
break;
case GET_PARAMETERS:
if (mParametersIsDirty) {
mParameters=mCamera.getParameters();
mParametersIsDirty=false;
}
return;
case SET_PREVIEW_CALLBACK:
mCamera.setPreviewCallback((PreviewCallback)msg.obj);
return;
case SET_ONESHOT_PREVIEW_CALLBACK:
mCamera.setOneShotPreviewCallback((PreviewCallback)msg.obj);
return;
case ENABLE_SHUTTER_SOUND:
enableShutterSound((msg.arg1 == 1) ? true : false);
return;
case REFRESH_PARAMETERS:
mParametersIsDirty=true;
return;
case SET_HISTOGRAM_MODE:
mCamera.setHistogramMode((CameraDataCallback)msg.obj);
break;
case SEND_HISTOGRAM_DATA:
mCamera.sendHistogramData();
break;
case SET_LONGSHOT:
mCamera.setLongshot((Boolean)msg.obj);
break;
case SET_AUTO_HDR_MODE:
mCamera.setMetadataCb((CameraMetaDataCallback)msg.obj);
break;
default :
throw new RuntimeException(""String_Node_Str"" + msg.what);
}
}
 catch (RuntimeException e) {
if (msg.what != RELEASE && mCamera != null) {
try {
mCamera.release();
}
 catch (Exception ex) {
Log.e(TAG,""String_Node_Str"");
}
mCamera=null;
}
 else if (mCamera == null) {
if (msg.what == OPEN_CAMERA) {
if (msg.obj != null) {
((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
}
}
 else {
Log.w(TAG,""String_Node_Str"");
}
return;
}
throw e;
}
}","The original code was missing a `return` statement for the `SET_ONESHOT_PREVIEW_CALLBACK` case, which could lead to unintended fallthrough and potential execution of subsequent cases. The fixed code adds the missing `return` statement after `mCamera.setOneShotPreviewCallback((PreviewCallback)msg.obj)`, ensuring that the method exits immediately after setting the one-shot preview callback. This correction prevents unexpected behavior and improves the method's reliability by explicitly controlling the flow of execution in the camera handler."
38217,"/** 
 * This method does not deal with the API level check.  Everyone should check first for supported operations before sending message to this handler.
 */
@Override public void handleMessage(final Message msg){
  try {
switch (msg.what) {
case OPEN_CAMERA:
      try {
        Method openMethod=Class.forName(""String_Node_Str"").getMethod(""String_Node_Str"",int.class,int.class);
        mCamera=(android.hardware.Camera)openMethod.invoke(null,msg.arg1,CAMERA_HAL_API_VERSION_1_0);
      }
 catch (      Exception e) {
        Log.v(TAG,""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
        mCamera=android.hardware.Camera.open(msg.arg1);
      }
    if (mCamera != null) {
      mParametersIsDirty=true;
      if (mParamsToSet == null) {
        mParamsToSet=mCamera.getParameters();
      }
    }
 else {
      if (msg.obj != null) {
        ((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
      }
    }
  return;
case RELEASE:
if (mCamera == null) {
  return;
}
mCamera.release();
errorCbInstance=null;
mCamera=null;
return;
case RECONNECT:
mReconnectIOException=null;
try {
mCamera.reconnect();
}
 catch (IOException ex) {
mReconnectIOException=ex;
}
return;
case UNLOCK:
mCamera.unlock();
return;
case LOCK:
mCamera.lock();
return;
case SET_PREVIEW_TEXTURE_ASYNC:
setPreviewTexture(msg.obj);
return;
case SET_PREVIEW_DISPLAY_ASYNC:
try {
mCamera.setPreviewDisplay((SurfaceHolder)msg.obj);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
return;
case START_PREVIEW_ASYNC:
try {
mCamera.startPreview();
}
 catch (Exception e) {
e.printStackTrace();
if (errorCbInstance != null) errorCbInstance.onStartPreviewFailure(msg.arg1);
}
return;
case STOP_PREVIEW:
mCamera.stopPreview();
return;
case SET_PREVIEW_CALLBACK_WITH_BUFFER:
mCamera.setPreviewCallbackWithBuffer((PreviewCallback)msg.obj);
return;
case ADD_CALLBACK_BUFFER:
mCamera.addCallbackBuffer((byte[])msg.obj);
return;
case AUTO_FOCUS:
mCamera.autoFocus((AutoFocusCallback)msg.obj);
return;
case CANCEL_AUTO_FOCUS:
mCamera.cancelAutoFocus();
return;
case SET_AUTO_FOCUS_MOVE_CALLBACK:
setAutoFocusMoveCallback(mCamera,msg.obj);
return;
case SET_DISPLAY_ORIENTATION:
mCamera.setDisplayOrientation(msg.arg1);
return;
case SET_ZOOM_CHANGE_LISTENER:
mCamera.setZoomChangeListener((OnZoomChangeListener)msg.obj);
return;
case SET_FACE_DETECTION_LISTENER:
setFaceDetectionListener((FaceDetectionListener)msg.obj);
return;
case START_FACE_DETECTION:
startFaceDetection();
return;
case STOP_FACE_DETECTION:
stopFaceDetection();
return;
case SET_ERROR_CALLBACK:
mCamera.setErrorCallback((ErrorCallback)msg.obj);
return;
case SET_PARAMETERS:
mParametersIsDirty=true;
mCamera.setParameters((Parameters)msg.obj);
mSig.open();
break;
case GET_PARAMETERS:
if (mParametersIsDirty) {
mParameters=mCamera.getParameters();
mParametersIsDirty=false;
}
return;
case SET_PREVIEW_CALLBACK:
mCamera.setPreviewCallback((PreviewCallback)msg.obj);
return;
case SET_ONESHOT_PREVIEW_CALLBACK:
mCamera.setOneShotPreviewCallback((PreviewCallback)msg.obj);
case ENABLE_SHUTTER_SOUND:
enableShutterSound((msg.arg1 == 1) ? true : false);
return;
case REFRESH_PARAMETERS:
mParametersIsDirty=true;
return;
case SET_HISTOGRAM_MODE:
mCamera.setHistogramMode((CameraDataCallback)msg.obj);
break;
case SEND_HISTOGRAM_DATA:
mCamera.sendHistogramData();
break;
case SET_LONGSHOT:
mCamera.setLongshot((Boolean)msg.obj);
break;
case SET_AUTO_HDR_MODE:
mCamera.setMetadataCb((CameraMetaDataCallback)msg.obj);
break;
default :
throw new RuntimeException(""String_Node_Str"" + msg.what);
}
}
 catch (RuntimeException e) {
if (msg.what != RELEASE && mCamera != null) {
try {
mCamera.release();
}
 catch (Exception ex) {
Log.e(TAG,""String_Node_Str"");
}
mCamera=null;
}
 else if (mCamera == null) {
if (msg.what == OPEN_CAMERA) {
if (msg.obj != null) {
((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
}
}
 else {
Log.w(TAG,""String_Node_Str"");
}
return;
}
throw e;
}
}","/** 
 * This method does not deal with the API level check.  Everyone should check first for supported operations before sending message to this handler.
 */
@Override public void handleMessage(final Message msg){
  try {
switch (msg.what) {
case OPEN_CAMERA:
      try {
        Method openMethod=Class.forName(""String_Node_Str"").getMethod(""String_Node_Str"",int.class,int.class);
        mCamera=(android.hardware.Camera)openMethod.invoke(null,msg.arg1,CAMERA_HAL_API_VERSION_1_0);
      }
 catch (      Exception e) {
        Log.v(TAG,""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
        mCamera=android.hardware.Camera.open(msg.arg1);
      }
    if (mCamera != null) {
      mParametersIsDirty=true;
      if (mParamsToSet == null) {
        mParamsToSet=mCamera.getParameters();
      }
    }
 else {
      if (msg.obj != null) {
        ((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
      }
    }
  return;
case RELEASE:
if (mCamera == null) {
  return;
}
mCamera.release();
errorCbInstance=null;
mCamera=null;
return;
case RECONNECT:
mReconnectIOException=null;
try {
mCamera.reconnect();
}
 catch (IOException ex) {
mReconnectIOException=ex;
}
return;
case UNLOCK:
mCamera.unlock();
return;
case LOCK:
mCamera.lock();
return;
case SET_PREVIEW_TEXTURE_ASYNC:
setPreviewTexture(msg.obj);
return;
case SET_PREVIEW_DISPLAY_ASYNC:
try {
mCamera.setPreviewDisplay((SurfaceHolder)msg.obj);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
return;
case START_PREVIEW_ASYNC:
try {
mCamera.startPreview();
}
 catch (Exception e) {
e.printStackTrace();
if (errorCbInstance != null) errorCbInstance.onStartPreviewFailure(msg.arg1);
}
return;
case STOP_PREVIEW:
mCamera.stopPreview();
return;
case SET_PREVIEW_CALLBACK_WITH_BUFFER:
mCamera.setPreviewCallbackWithBuffer((PreviewCallback)msg.obj);
return;
case ADD_CALLBACK_BUFFER:
mCamera.addCallbackBuffer((byte[])msg.obj);
return;
case AUTO_FOCUS:
mCamera.autoFocus((AutoFocusCallback)msg.obj);
return;
case CANCEL_AUTO_FOCUS:
mCamera.cancelAutoFocus();
return;
case SET_AUTO_FOCUS_MOVE_CALLBACK:
setAutoFocusMoveCallback(mCamera,msg.obj);
return;
case SET_DISPLAY_ORIENTATION:
mCamera.setDisplayOrientation(msg.arg1);
return;
case SET_ZOOM_CHANGE_LISTENER:
mCamera.setZoomChangeListener((OnZoomChangeListener)msg.obj);
return;
case SET_FACE_DETECTION_LISTENER:
setFaceDetectionListener((FaceDetectionListener)msg.obj);
return;
case START_FACE_DETECTION:
startFaceDetection();
return;
case STOP_FACE_DETECTION:
stopFaceDetection();
return;
case SET_ERROR_CALLBACK:
mCamera.setErrorCallback((ErrorCallback)msg.obj);
return;
case SET_PARAMETERS:
mParametersIsDirty=true;
mCamera.setParameters((Parameters)msg.obj);
mSig.open();
break;
case GET_PARAMETERS:
if (mParametersIsDirty) {
mParameters=mCamera.getParameters();
mParametersIsDirty=false;
}
return;
case SET_PREVIEW_CALLBACK:
mCamera.setPreviewCallback((PreviewCallback)msg.obj);
return;
case SET_ONESHOT_PREVIEW_CALLBACK:
mCamera.setOneShotPreviewCallback((PreviewCallback)msg.obj);
return;
case ENABLE_SHUTTER_SOUND:
enableShutterSound((msg.arg1 == 1) ? true : false);
return;
case REFRESH_PARAMETERS:
mParametersIsDirty=true;
return;
case SET_HISTOGRAM_MODE:
mCamera.setHistogramMode((CameraDataCallback)msg.obj);
break;
case SEND_HISTOGRAM_DATA:
mCamera.sendHistogramData();
break;
case SET_LONGSHOT:
mCamera.setLongshot((Boolean)msg.obj);
break;
case SET_AUTO_HDR_MODE:
mCamera.setMetadataCb((CameraMetaDataCallback)msg.obj);
break;
default :
throw new RuntimeException(""String_Node_Str"" + msg.what);
}
}
 catch (RuntimeException e) {
if (msg.what != RELEASE && mCamera != null) {
try {
mCamera.release();
}
 catch (Exception ex) {
Log.e(TAG,""String_Node_Str"");
}
mCamera=null;
}
 else if (mCamera == null) {
if (msg.what == OPEN_CAMERA) {
if (msg.obj != null) {
((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
}
}
 else {
Log.w(TAG,""String_Node_Str"");
}
return;
}
throw e;
}
}","The original code lacked a return statement for the SET_ONESHOT_PREVIEW_CALLBACK case, causing potential unintended fallthrough behavior. The fixed code adds an explicit return statement after setting the one-shot preview callback, ensuring proper method execution and preventing accidental execution of subsequent cases. This correction improves code reliability by explicitly defining the control flow and preventing unintended side effects in the camera handling method."
38218,"public void onListMenuTouched(){
  mUI.removeLevel2();
}","public void onListMenuTouched(){
  mUI.removeLevel2();
  mPopupStatus=POPUP_FIRST_LEVEL;
}","The original code only removes the level 2 menu without updating the popup status, potentially leaving the UI in an inconsistent state. The fixed code adds `mPopupStatus=POPUP_FIRST_LEVEL`, explicitly resetting the popup status to the first level after removing the level 2 menu. This ensures proper UI state management and prevents potential navigation or display inconsistencies in the user interface."
38219,"public void onListMenuTouched(){
  mUI.removeLevel2();
}","public void onListMenuTouched(){
  mUI.removeLevel2();
  mPopupStatus=POPUP_FIRST_LEVEL;
}","The original code only removes the second-level menu without updating the popup status, potentially leaving the UI in an inconsistent state. The fixed code adds a line to set `mPopupStatus` to `POPUP_FIRST_LEVEL`, explicitly resetting the popup state after removing the second-level menu. This ensures proper tracking of the current UI state and prevents potential navigation or display issues in the application."
38220,"@Override public boolean onTouchEvent(MotionEvent ev){
  return super.onTouchEvent(ev);
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_MOVE) {
    mListener.onListMenuTouched();
    resetHighlight();
  }
  return super.onTouchEvent(ev);
}","The original code simply passed the touch event to the superclass without any custom handling, potentially missing important interaction events. The fixed code specifically checks for a move action, triggers a listener method, and resets highlighting before calling the superclass method, enabling more precise touch event management. This approach provides better control over touch interactions, allowing custom logic to be executed while maintaining the default touch event behavior."
38221,"@Override public void onReceive(Context context,Intent intent){
  sFirstStartAfterScreenOn=true;
}","@Override public void onReceive(Context context,Intent intent){
  Log.d(TAG,""String_Node_Str"");
  updateStorageSpaceAndHint();
}","The original code simply sets a flag without performing any meaningful action in the broadcast receiver's onReceive method, which is typically used for handling system or application events. The fixed code adds a debug log statement and calls an updateStorageSpaceAndHint() method, providing useful logging and potentially updating critical system information. These changes transform the method from a no-op placeholder to a functional broadcast receiver that provides context and performs a potentially important system update."
38222,"@Override public void onDestroy(){
  if (mWakeLock != null && mWakeLock.isHeld()) {
    mWakeLock.release();
    Log.d(TAG,""String_Node_Str"");
  }
  if (mScreenOffReceiver != null) {
    unregisterReceiver(mScreenOffReceiver);
  }
  getContentResolver().unregisterContentObserver(mLocalImagesObserver);
  getContentResolver().unregisterContentObserver(mLocalVideosObserver);
  unregisterReceiver(mSDcardMountedReceiver);
  super.onDestroy();
}","@Override public void onDestroy(){
  if (mWakeLock != null && mWakeLock.isHeld()) {
    mWakeLock.release();
    Log.d(TAG,""String_Node_Str"");
  }
  getContentResolver().unregisterContentObserver(mLocalImagesObserver);
  getContentResolver().unregisterContentObserver(mLocalVideosObserver);
  unregisterReceiver(mSDcardMountedReceiver);
  super.onDestroy();
}","The buggy code attempts to unregister a potentially already unregistered receiver (mScreenOffReceiver), which could throw an IllegalArgumentException. The fixed code removes this redundant unregistration, preventing potential runtime exceptions and ensuring clean resource management. By eliminating the unnecessary receiver unregistration, the code becomes more robust and less prone to unexpected crashes during the activity's destruction."
38223,"@Override public void onCreate(Bundle state){
  super.onCreate(state);
  Intent intent=getIntent();
  String action=intent.getAction();
  if (INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action) || ACTION_IMAGE_CAPTURE_SECURE.equals(action) || intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
    mSecureCamera=true;
  }
 else {
    mSecureCamera=intent.getBooleanExtra(SECURE_CAMERA_EXTRA,false);
  }
  IntentFilter filter=new IntentFilter(Intent.ACTION_SCREEN_OFF);
  registerReceiver(mScreenOffReceiver,filter);
  if (sScreenOffReceiver == null) {
    sScreenOffReceiver=new ScreenOffReceiver();
    registerReceiver(sScreenOffReceiver,filter);
  }
  if (mSecureCamera) {
    Window win=getWindow();
    WindowManager.LayoutParams params=win.getAttributes();
    params.flags|=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;
    if (intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
      params.flags|=WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON;
      PowerManager pm=((PowerManager)getSystemService(POWER_SERVICE));
      mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,TAG);
      mWakeLock.acquire();
      Log.d(TAG,""String_Node_Str"");
    }
    win.setAttributes(params);
  }
  GcamHelper.init(getContentResolver());
  getWindow().requestFeature(Window.FEATURE_ACTION_BAR);
  LayoutInflater inflater=getLayoutInflater();
  View rootLayout=inflater.inflate(R.layout.camera,null,false);
  mCameraRootFrame=(FrameLayout)rootLayout.findViewById(R.id.camera_root_frame);
  mCameraPhotoModuleRootView=rootLayout.findViewById(R.id.camera_photo_root);
  mCameraVideoModuleRootView=rootLayout.findViewById(R.id.camera_video_root);
  mCameraPanoModuleRootView=rootLayout.findViewById(R.id.camera_pano_root);
  int moduleIndex=-1;
  if (MediaStore.INTENT_ACTION_VIDEO_CAMERA.equals(getIntent().getAction()) || MediaStore.ACTION_VIDEO_CAPTURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.VIDEO_MODULE_INDEX;
  }
 else   if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(getIntent().getAction()) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    if (prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1) == ModuleSwitcher.GCAM_MODULE_INDEX && GcamHelper.hasGcamCapture()) {
      moduleIndex=ModuleSwitcher.GCAM_MODULE_INDEX;
    }
  }
 else   if (MediaStore.ACTION_IMAGE_CAPTURE.equals(getIntent().getAction()) || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
  }
 else {
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    moduleIndex=prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1);
    if ((moduleIndex == ModuleSwitcher.GCAM_MODULE_INDEX && !GcamHelper.hasGcamCapture()) || moduleIndex < 0) {
      moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    }
  }
  mOrientationListener=new MyOrientationEventListener(this);
  setModuleFromIndex(moduleIndex);
  setContentView(R.layout.camera_filmstrip);
  mActionBar=getActionBar();
  mActionBar.addOnMenuVisibilityListener(this);
  if (ApiHelper.HAS_ROTATION_ANIMATION) {
    setRotationAnimation();
  }
  mMainHandler=new MainHandler(getMainLooper());
  mAboveFilmstripControlLayout=(FrameLayout)findViewById(R.id.camera_above_filmstrip_layout);
  mAboveFilmstripControlLayout.setFitsSystemWindows(true);
  mPanoramaManager=AppManagerFactory.getInstance(this).getPanoramaStitchingManager();
  mPlaceholderManager=AppManagerFactory.getInstance(this).getGcamProcessingManager();
  mPanoramaManager.addTaskListener(mStitchingListener);
  mPlaceholderManager.addTaskListener(mPlaceholderListener);
  mPanoStitchingPanel=findViewById(R.id.pano_stitching_progress_panel);
  mBottomProgress=(ProgressBar)findViewById(R.id.pano_stitching_progress_bar);
  mCameraPreviewData=new CameraPreviewData(rootLayout,FilmStripView.ImageData.SIZE_FULL,FilmStripView.ImageData.SIZE_FULL);
  mWrappedDataAdapter=new FixedFirstDataAdapter(new CameraDataAdapter(new ColorDrawable(getResources().getColor(R.color.photo_placeholder))),mCameraPreviewData);
  mFilmStripView=(FilmStripView)findViewById(R.id.filmstrip_view);
  mFilmStripView.setViewGap(getResources().getDimensionPixelSize(R.dimen.camera_film_strip_gap));
  mPanoramaViewHelper=new PanoramaViewHelper(this);
  mPanoramaViewHelper.onCreate();
  mFilmStripView.setPanoramaViewHelper(mPanoramaViewHelper);
  mFilmStripView.setListener(mFilmStripListener);
  if (!mSecureCamera) {
    mDataAdapter=mWrappedDataAdapter;
    mFilmStripView.setDataAdapter(mDataAdapter);
    if (!isCaptureIntent()) {
      mDataAdapter.requestLoad(getContentResolver());
      mDataRequested=true;
    }
  }
 else {
    ImageView v=(ImageView)getLayoutInflater().inflate(R.layout.secure_album_placeholder,null);
    v.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        try {
          UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_GALLERY,null);
          startActivity(IntentHelper.getGalleryIntent(CameraActivity.this));
        }
 catch (        ActivityNotFoundException e) {
          Log.w(TAG,""String_Node_Str"");
        }
        finish();
      }
    }
);
    mDataAdapter=new FixedLastDataAdapter(mWrappedDataAdapter,new SimpleViewData(v,v.getDrawable().getIntrinsicWidth(),v.getDrawable().getIntrinsicHeight(),0,0));
    mDataAdapter.flush();
    mFilmStripView.setDataAdapter(mDataAdapter);
  }
  setupNfcBeamPush();
  mLocalImagesObserver=new LocalMediaObserver();
  mLocalVideosObserver=new LocalMediaObserver();
  getContentResolver().registerContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,true,mLocalImagesObserver);
  getContentResolver().registerContentObserver(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,true,mLocalVideosObserver);
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  mDeveloperMenuEnabled=prefs.getBoolean(CameraSettings.KEY_DEVELOPER_MENU,false);
  Display display=getWindowManager().getDefaultDisplay();
  Point size=new Point();
  display.getSize(size);
  int width=size.x;
  int height=size.y;
  int lower=Math.min(width,height);
  int offset=lower * 7 / 100;
  SETTING_LIST_WIDTH_1=lower / 2 + offset;
  SETTING_LIST_WIDTH_2=lower / 2 - offset;
  registerSDcardMountedReceiver();
}","@Override public void onCreate(Bundle state){
  super.onCreate(state);
  Intent intent=getIntent();
  String action=intent.getAction();
  if (INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action) || ACTION_IMAGE_CAPTURE_SECURE.equals(action) || intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
    mSecureCamera=true;
  }
 else {
    mSecureCamera=intent.getBooleanExtra(SECURE_CAMERA_EXTRA,false);
  }
  if (mSecureCamera) {
    Window win=getWindow();
    WindowManager.LayoutParams params=win.getAttributes();
    params.flags|=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;
    if (intent.getComponent().getClassName().equals(GESTURE_CAMERA_NAME)) {
      params.flags|=WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON;
      PowerManager pm=((PowerManager)getSystemService(POWER_SERVICE));
      mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,TAG);
      mWakeLock.acquire();
      Log.d(TAG,""String_Node_Str"");
    }
    win.setAttributes(params);
  }
  GcamHelper.init(getContentResolver());
  getWindow().requestFeature(Window.FEATURE_ACTION_BAR);
  LayoutInflater inflater=getLayoutInflater();
  View rootLayout=inflater.inflate(R.layout.camera,null,false);
  mCameraRootFrame=(FrameLayout)rootLayout.findViewById(R.id.camera_root_frame);
  mCameraPhotoModuleRootView=rootLayout.findViewById(R.id.camera_photo_root);
  mCameraVideoModuleRootView=rootLayout.findViewById(R.id.camera_video_root);
  mCameraPanoModuleRootView=rootLayout.findViewById(R.id.camera_pano_root);
  int moduleIndex=-1;
  if (MediaStore.INTENT_ACTION_VIDEO_CAMERA.equals(getIntent().getAction()) || MediaStore.ACTION_VIDEO_CAPTURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.VIDEO_MODULE_INDEX;
  }
 else   if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(getIntent().getAction()) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    if (prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1) == ModuleSwitcher.GCAM_MODULE_INDEX && GcamHelper.hasGcamCapture()) {
      moduleIndex=ModuleSwitcher.GCAM_MODULE_INDEX;
    }
  }
 else   if (MediaStore.ACTION_IMAGE_CAPTURE.equals(getIntent().getAction()) || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(getIntent().getAction())) {
    moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
  }
 else {
    SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
    moduleIndex=prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX,-1);
    if ((moduleIndex == ModuleSwitcher.GCAM_MODULE_INDEX && !GcamHelper.hasGcamCapture()) || moduleIndex < 0) {
      moduleIndex=ModuleSwitcher.PHOTO_MODULE_INDEX;
    }
  }
  mOrientationListener=new MyOrientationEventListener(this);
  setModuleFromIndex(moduleIndex);
  setContentView(R.layout.camera_filmstrip);
  mActionBar=getActionBar();
  mActionBar.addOnMenuVisibilityListener(this);
  if (ApiHelper.HAS_ROTATION_ANIMATION) {
    setRotationAnimation();
  }
  mMainHandler=new MainHandler(getMainLooper());
  mAboveFilmstripControlLayout=(FrameLayout)findViewById(R.id.camera_above_filmstrip_layout);
  mAboveFilmstripControlLayout.setFitsSystemWindows(true);
  mPanoramaManager=AppManagerFactory.getInstance(this).getPanoramaStitchingManager();
  mPlaceholderManager=AppManagerFactory.getInstance(this).getGcamProcessingManager();
  mPanoramaManager.addTaskListener(mStitchingListener);
  mPlaceholderManager.addTaskListener(mPlaceholderListener);
  mPanoStitchingPanel=findViewById(R.id.pano_stitching_progress_panel);
  mBottomProgress=(ProgressBar)findViewById(R.id.pano_stitching_progress_bar);
  mCameraPreviewData=new CameraPreviewData(rootLayout,FilmStripView.ImageData.SIZE_FULL,FilmStripView.ImageData.SIZE_FULL);
  mWrappedDataAdapter=new FixedFirstDataAdapter(new CameraDataAdapter(new ColorDrawable(getResources().getColor(R.color.photo_placeholder))),mCameraPreviewData);
  mFilmStripView=(FilmStripView)findViewById(R.id.filmstrip_view);
  mFilmStripView.setViewGap(getResources().getDimensionPixelSize(R.dimen.camera_film_strip_gap));
  mPanoramaViewHelper=new PanoramaViewHelper(this);
  mPanoramaViewHelper.onCreate();
  mFilmStripView.setPanoramaViewHelper(mPanoramaViewHelper);
  mFilmStripView.setListener(mFilmStripListener);
  if (!mSecureCamera) {
    mDataAdapter=mWrappedDataAdapter;
    mFilmStripView.setDataAdapter(mDataAdapter);
    if (!isCaptureIntent()) {
      mDataAdapter.requestLoad(getContentResolver());
      mDataRequested=true;
    }
  }
 else {
    ImageView v=(ImageView)getLayoutInflater().inflate(R.layout.secure_album_placeholder,null);
    v.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        try {
          UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_GALLERY,null);
          startActivity(IntentHelper.getGalleryIntent(CameraActivity.this));
        }
 catch (        ActivityNotFoundException e) {
          Log.w(TAG,""String_Node_Str"");
        }
        finish();
      }
    }
);
    mDataAdapter=new FixedLastDataAdapter(mWrappedDataAdapter,new SimpleViewData(v,v.getDrawable().getIntrinsicWidth(),v.getDrawable().getIntrinsicHeight(),0,0));
    mDataAdapter.flush();
    mFilmStripView.setDataAdapter(mDataAdapter);
  }
  setupNfcBeamPush();
  mLocalImagesObserver=new LocalMediaObserver();
  mLocalVideosObserver=new LocalMediaObserver();
  getContentResolver().registerContentObserver(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,true,mLocalImagesObserver);
  getContentResolver().registerContentObserver(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,true,mLocalVideosObserver);
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  mDeveloperMenuEnabled=prefs.getBoolean(CameraSettings.KEY_DEVELOPER_MENU,false);
  Display display=getWindowManager().getDefaultDisplay();
  Point size=new Point();
  display.getSize(size);
  int width=size.x;
  int height=size.y;
  int lower=Math.min(width,height);
  int offset=lower * 7 / 100;
  SETTING_LIST_WIDTH_1=lower / 2 + offset;
  SETTING_LIST_WIDTH_2=lower / 2 - offset;
  registerSDcardMountedReceiver();
}","The original code incorrectly registered multiple screen-off receivers, which could lead to memory leaks and unintended behavior. The fixed code removes the redundant receiver registration, keeping only the necessary screen-off event handling. This simplification prevents potential memory issues and ensures cleaner, more efficient event management in the camera activity."
38224,"private void closeCamera(){
  Log.v(TAG,""String_Node_Str"");
  if (mCameraDevice != null) {
    mCameraDevice.setZoomChangeListener(null);
    mCameraDevice.setFaceDetectionCallback(null,null);
    mCameraDevice.setErrorCallback(null);
    if (mActivity.isSecureCamera() && !CameraActivity.isFirstStartAfterScreenOn()) {
      CameraHolder.instance().strongRelease();
    }
 else {
      CameraHolder.instance().release();
    }
    mFaceDetectionStarted=false;
    mCameraDevice=null;
    setCameraState(PREVIEW_STOPPED);
    if (mFocusManager != null) {
      mFocusManager.onCameraReleased();
    }
  }
}","private void closeCamera(){
  Log.v(TAG,""String_Node_Str"");
  if (mCameraDevice != null) {
    mCameraDevice.setZoomChangeListener(null);
    mCameraDevice.setFaceDetectionCallback(null,null);
    mCameraDevice.setErrorCallback(null);
    if (mActivity.isSecureCamera()) {
      CameraHolder.instance().strongRelease();
    }
 else {
      CameraHolder.instance().release();
    }
    mFaceDetectionStarted=false;
    mCameraDevice=null;
    setCameraState(PREVIEW_STOPPED);
    if (mFocusManager != null) {
      mFocusManager.onCameraReleased();
    }
  }
}","The original code incorrectly used an additional condition `!CameraActivity.isFirstStartAfterScreenOn()` when deciding whether to perform a strong camera release. The fixed code removes this unnecessary condition, simplifying the release logic to only depend on whether the camera is in secure mode. This change ensures a more straightforward and predictable camera release mechanism, reducing potential complexity and potential edge-case behaviors in camera management."
38225,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_MEDIA_EJECT)) {
    stopVideoRecording();
    RotateTextToast.makeText(mActivity,mActivity.getResources().getString(R.string.video_recording_stopped),Toast.LENGTH_SHORT).show();
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(Intent.ACTION_MEDIA_EJECT) || action.equals(Intent.ACTION_SCREEN_OFF)) {
    stopVideoRecording();
    RotateTextToast.makeText(mActivity,mActivity.getResources().getString(R.string.video_recording_stopped),Toast.LENGTH_SHORT).show();
  }
}","The original code only handles media ejection events, potentially leaving video recording active during screen-off scenarios. The fixed code adds `action.equals(Intent.ACTION_SCREEN_OFF)` to the condition, ensuring video recording stops when the screen turns off, preventing unintended continuous recording. This modification enhances the robustness of the event handling, providing a more comprehensive approach to managing video recording interruptions."
38226,"@Override public void installIntentFilter(){
  if (mReceiver != null)   return;
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_MEDIA_EJECT);
  intentFilter.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);
  intentFilter.addDataScheme(""String_Node_Str"");
  mReceiver=new MyBroadcastReceiver();
  mActivity.registerReceiver(mReceiver,intentFilter);
}","@Override public void installIntentFilter(){
  if (mReceiver != null)   return;
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_MEDIA_EJECT);
  intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
  intentFilter.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);
  intentFilter.addDataScheme(""String_Node_Str"");
  mReceiver=new MyBroadcastReceiver();
  mActivity.registerReceiver(mReceiver,intentFilter);
}","The original code missed registering the ACTION_SCREEN_OFF intent, which could be important for handling device state changes. The fixed code adds Intent.ACTION_SCREEN_OFF to the IntentFilter, ensuring broader system event coverage and more comprehensive broadcast receiver functionality. This enhancement allows the receiver to respond to additional critical system events, improving the overall robustness of the intent filtering mechanism."
38227,"/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,mParameters.getSupportedTouchAfAec())) {
      mCurrTouchAfAec=touchAfAec;
      mParameters.setTouchAfAec(touchAfAec);
    }
  }
 else {
    mParameters.setTouchAfAec(mParameters.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (mParameters.getTouchAfAec().equals(mParameters.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
    }
 else {
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=mParameters.getSupportedSelectableZoneAf();
  if (CameraUtil.isSupported(selectableZoneAf,mParameters.getSupportedSelectableZoneAf())) {
    mParameters.setSelectableZoneAf(selectableZoneAf);
  }
  if (mParameters.getSupportedDenoiseModes() != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    mParameters.setDenoise(Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,mParameters.getSupportedRedeyeReductionModes())) {
    mParameters.setRedeyeReductionMode(redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,mParameters.getSupportedIsoValues())) {
      mParameters.setISOValue(iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= mParameters.getMaxSaturation())) {
    mParameters.setSaturation(saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= mParameters.getMaxContrast())) {
    mParameters.setContrast(contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (mParameters.getMaxSharpness() / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= mParameters.getMaxSharpness())) {
    mParameters.setSharpness(sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(Parameters.FACE_DETECTION_ON,mParameters.getSupportedFaceDetectionModes())) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,Parameters.FACE_DETECTION_ON);
        }
      }
);
      mParameters.setFaceDetectionMode(Parameters.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
      }
    }
);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,mParameters.getSupportedFaceDetectionModes())) {
      mParameters.setFaceDetectionMode(faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,mParameters.getSupportedAutoexposure())) {
    mParameters.setAutoExposure(autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  mParameters.setZSLMode(zsl);
  if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_ZSL;
    mParameters.setCameraMode(1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_NONZSL;
    mParameters.setCameraMode(0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,mParameters.getSupportedHistogramModes()) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
}","/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,mParameters.getSupportedTouchAfAec())) {
      mCurrTouchAfAec=touchAfAec;
      mParameters.setTouchAfAec(touchAfAec);
    }
  }
 else {
    mParameters.setTouchAfAec(mParameters.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (mParameters.getTouchAfAec().equals(mParameters.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
    }
 else {
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=mParameters.getSupportedSelectableZoneAf();
  if (CameraUtil.isSupported(selectableZoneAf,mParameters.getSupportedSelectableZoneAf())) {
    mParameters.setSelectableZoneAf(selectableZoneAf);
  }
  if (mParameters.getSupportedDenoiseModes() != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    mParameters.setDenoise(Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,mParameters.getSupportedRedeyeReductionModes())) {
    mParameters.setRedeyeReductionMode(redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,mParameters.getSupportedIsoValues())) {
      mParameters.setISOValue(iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= mParameters.getMaxSaturation())) {
    mParameters.setSaturation(saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= mParameters.getMaxContrast())) {
    mParameters.setContrast(contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (mParameters.getMaxSharpness() / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= mParameters.getMaxSharpness())) {
    mParameters.setSharpness(sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
        }
      }
);
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
        }
      }
);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(Parameters.FACE_DETECTION_ON,mParameters.getSupportedFaceDetectionModes())) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,Parameters.FACE_DETECTION_ON);
        }
      }
);
      mParameters.setFaceDetectionMode(Parameters.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
      }
    }
);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,mParameters.getSupportedFaceDetectionModes())) {
      mParameters.setFaceDetectionMode(faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,mParameters.getSupportedAutoexposure())) {
    mParameters.setAutoExposure(autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  mParameters.setZSLMode(zsl);
  if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_ZSL;
    mParameters.setCameraMode(1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_NONZSL;
    mParameters.setCameraMode(0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,mParameters.getSupportedHistogramModes()) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
}","The original code performed UI updates directly on a background thread, which can cause threading-related crashes and unpredictable behavior in Android. The fixed code replaces direct UI updates with `mActivity.runOnUiThread()`, ensuring that UI modifications are safely executed on the main thread. This change prevents potential synchronization issues and improves the code's reliability by properly dispatching UI updates through the Android framework's designated mechanism."
38228,"private String getSDCardStorageState(){
  try {
    return mMountService.getVolumeState(mVolume.getPath());
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"" + e);
    return Environment.MEDIA_REMOVED;
  }
}","private String getSDCardStorageState(){
  return mVolume.getState();
}","The original code unnecessarily calls a mount service method to retrieve the volume state, which is complex and prone to exceptions. The fixed code directly uses the `getState()` method of the volume object, simplifying the state retrieval process. This approach reduces error handling complexity, improves code readability, and provides a more direct and reliable way to determine the SD card storage state."
38229,"/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,mParameters.getSupportedTouchAfAec())) {
      mCurrTouchAfAec=touchAfAec;
      mParameters.setTouchAfAec(touchAfAec);
    }
  }
 else {
    mParameters.setTouchAfAec(mParameters.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (mParameters.getTouchAfAec().equals(mParameters.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
    }
 else {
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=mParameters.getSupportedSelectableZoneAf();
  if (CameraUtil.isSupported(selectableZoneAf,mParameters.getSupportedSelectableZoneAf())) {
    mParameters.setSelectableZoneAf(selectableZoneAf);
  }
  if (mParameters.getSupportedDenoiseModes() != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    mParameters.setDenoise(Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,mParameters.getSupportedRedeyeReductionModes())) {
    mParameters.setRedeyeReductionMode(redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,mParameters.getSupportedIsoValues())) {
      mParameters.setISOValue(iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= mParameters.getMaxSaturation())) {
    mParameters.setSaturation(saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= mParameters.getMaxContrast())) {
    mParameters.setContrast(contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (mParameters.getMaxSharpness() / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= mParameters.getMaxSharpness())) {
    mParameters.setSharpness(sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(Parameters.FACE_DETECTION_ON,mParameters.getSupportedFaceDetectionModes())) {
      mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,Parameters.FACE_DETECTION_ON);
      mParameters.setFaceDetectionMode(Parameters.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,mParameters.getSupportedFaceDetectionModes())) {
      mParameters.setFaceDetectionMode(faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,mParameters.getSupportedAutoexposure())) {
    mParameters.setAutoExposure(autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  mParameters.setZSLMode(zsl);
  if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_ZSL;
    mParameters.setCameraMode(1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_NONZSL;
    mParameters.setCameraMode(0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,mParameters.getSupportedHistogramModes()) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
}","/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,mParameters.getSupportedTouchAfAec())) {
      mCurrTouchAfAec=touchAfAec;
      mParameters.setTouchAfAec(touchAfAec);
    }
  }
 else {
    mParameters.setTouchAfAec(mParameters.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (mParameters.getTouchAfAec().equals(mParameters.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
    }
 else {
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=mParameters.getSupportedSelectableZoneAf();
  if (CameraUtil.isSupported(selectableZoneAf,mParameters.getSupportedSelectableZoneAf())) {
    mParameters.setSelectableZoneAf(selectableZoneAf);
  }
  if (mParameters.getSupportedDenoiseModes() != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    mParameters.setDenoise(Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,mParameters.getSupportedRedeyeReductionModes())) {
    mParameters.setRedeyeReductionMode(redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,mParameters.getSupportedIsoValues())) {
      mParameters.setISOValue(iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= mParameters.getMaxSaturation())) {
    mParameters.setSaturation(saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= mParameters.getMaxContrast())) {
    mParameters.setContrast(contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (mParameters.getMaxSharpness() / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= mParameters.getMaxSharpness())) {
    mParameters.setSharpness(sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(Parameters.FACE_DETECTION_ON,mParameters.getSupportedFaceDetectionModes())) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,Parameters.FACE_DETECTION_ON);
        }
      }
);
      mParameters.setFaceDetectionMode(Parameters.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
      }
    }
);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,mParameters.getSupportedFaceDetectionModes())) {
      mParameters.setFaceDetectionMode(faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,mParameters.getSupportedAutoexposure())) {
    mParameters.setAutoExposure(autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  mParameters.setZSLMode(zsl);
  if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_ZSL;
    mParameters.setCameraMode(1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_NONZSL;
    mParameters.setCameraMode(0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,mParameters.getSupportedHistogramModes()) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
}","The original code performed UI updates directly on a background thread, which can cause threading issues and potential crashes in Android. The fixed code moves UI-related operations like `mUI.overrideSettings()` and view visibility changes to `runOnUiThread()`, ensuring thread-safe UI modifications. By properly dispatching UI updates to the main thread, the fixed code prevents potential synchronization problems and improves the overall stability of the camera application."
38230,"/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,mParameters.getSupportedTouchAfAec())) {
      mCurrTouchAfAec=touchAfAec;
      mParameters.setTouchAfAec(touchAfAec);
    }
  }
 else {
    mParameters.setTouchAfAec(mParameters.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (mParameters.getTouchAfAec().equals(mParameters.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
    }
 else {
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=mParameters.getSupportedSelectableZoneAf();
  if (CameraUtil.isSupported(selectableZoneAf,mParameters.getSupportedSelectableZoneAf())) {
    mParameters.setSelectableZoneAf(selectableZoneAf);
  }
  if (mParameters.getSupportedDenoiseModes() != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    mParameters.setDenoise(Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,mParameters.getSupportedRedeyeReductionModes())) {
    mParameters.setRedeyeReductionMode(redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,mParameters.getSupportedIsoValues())) {
      mParameters.setISOValue(iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= mParameters.getMaxSaturation())) {
    mParameters.setSaturation(saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= mParameters.getMaxContrast())) {
    mParameters.setContrast(contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (mParameters.getMaxSharpness() / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= mParameters.getMaxSharpness())) {
    mParameters.setSharpness(sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(Parameters.FACE_DETECTION_ON,mParameters.getSupportedFaceDetectionModes())) {
      mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,Parameters.FACE_DETECTION_ON);
      mParameters.setFaceDetectionMode(Parameters.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,mParameters.getSupportedFaceDetectionModes())) {
      mParameters.setFaceDetectionMode(faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,mParameters.getSupportedAutoexposure())) {
    mParameters.setAutoExposure(autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  mParameters.setZSLMode(zsl);
  if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_ZSL;
    mParameters.setCameraMode(1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_NONZSL;
    mParameters.setCameraMode(0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,mParameters.getSupportedHistogramModes()) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
}","/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,mParameters.getSupportedTouchAfAec())) {
      mCurrTouchAfAec=touchAfAec;
      mParameters.setTouchAfAec(touchAfAec);
    }
  }
 else {
    mParameters.setTouchAfAec(mParameters.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (mParameters.getTouchAfAec().equals(mParameters.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
    }
 else {
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=mParameters.getSupportedSelectableZoneAf();
  if (CameraUtil.isSupported(selectableZoneAf,mParameters.getSupportedSelectableZoneAf())) {
    mParameters.setSelectableZoneAf(selectableZoneAf);
  }
  if (mParameters.getSupportedDenoiseModes() != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    mParameters.setDenoise(Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,mParameters.getSupportedRedeyeReductionModes())) {
    mParameters.setRedeyeReductionMode(redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,mParameters.getSupportedIsoValues())) {
      mParameters.setISOValue(iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= mParameters.getMaxSaturation())) {
    mParameters.setSaturation(saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= mParameters.getMaxContrast())) {
    mParameters.setContrast(contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (mParameters.getMaxSharpness() / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= mParameters.getMaxSharpness())) {
    mParameters.setSharpness(sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(Parameters.FACE_DETECTION_ON,mParameters.getSupportedFaceDetectionModes())) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,Parameters.FACE_DETECTION_ON);
        }
      }
);
      mParameters.setFaceDetectionMode(Parameters.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
      }
    }
);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,mParameters.getSupportedFaceDetectionModes())) {
      mParameters.setFaceDetectionMode(faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,mParameters.getSupportedAutoexposure())) {
    mParameters.setAutoExposure(autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  mParameters.setZSLMode(zsl);
  if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_ZSL;
    mParameters.setCameraMode(1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_NONZSL;
    mParameters.setCameraMode(0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,mParameters.getSupportedHistogramModes()) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
}","The original code contained UI update operations directly in a background thread method, which could cause thread synchronization issues and potential app crashes. The fixed code moves UI-related updates like `mUI.overrideSettings()` and view visibility changes to `runOnUiThread()` blocks, ensuring safe UI manipulation from background threads. These modifications prevent potential race conditions and improve the method's thread safety by correctly separating background processing from UI interactions."
38231,"/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,mParameters.getSupportedTouchAfAec())) {
      mCurrTouchAfAec=touchAfAec;
      mParameters.setTouchAfAec(touchAfAec);
    }
  }
 else {
    mParameters.setTouchAfAec(mParameters.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (mParameters.getTouchAfAec().equals(mParameters.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
    }
 else {
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=mParameters.getSupportedSelectableZoneAf();
  if (CameraUtil.isSupported(selectableZoneAf,mParameters.getSupportedSelectableZoneAf())) {
    mParameters.setSelectableZoneAf(selectableZoneAf);
  }
  if (mParameters.getSupportedDenoiseModes() != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    mParameters.setDenoise(Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,mParameters.getSupportedRedeyeReductionModes())) {
    mParameters.setRedeyeReductionMode(redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,mParameters.getSupportedIsoValues())) {
      mParameters.setISOValue(iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= mParameters.getMaxSaturation())) {
    mParameters.setSaturation(saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= mParameters.getMaxContrast())) {
    mParameters.setContrast(contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (mParameters.getMaxSharpness() / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= mParameters.getMaxSharpness())) {
    mParameters.setSharpness(sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(Parameters.FACE_DETECTION_ON,mParameters.getSupportedFaceDetectionModes())) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,Parameters.FACE_DETECTION_ON);
        }
      }
);
      mParameters.setFaceDetectionMode(Parameters.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
      }
    }
);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,mParameters.getSupportedFaceDetectionModes())) {
      mParameters.setFaceDetectionMode(faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,mParameters.getSupportedAutoexposure())) {
    mParameters.setAutoExposure(autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  mParameters.setZSLMode(zsl);
  if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_ZSL;
    mParameters.setCameraMode(1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_NONZSL;
    mParameters.setCameraMode(0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,mParameters.getSupportedHistogramModes()) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
}","/** 
 * This can run on a background thread, so don't do UI updates here.
 */
private void qcomUpdateCameraParametersPreference(){
  mParameters.set(""String_Node_Str"",String.valueOf(mbrightness));
  String longshot_enable=mPreferences.getString(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.pref_camera_longshot_default));
  mParameters.set(""String_Node_Str"",longshot_enable);
  String optizoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode) || optizoomOn.equals(mSceneMode)) {
    String touchAfAec=mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC,mActivity.getString(R.string.pref_camera_touchafaec_default));
    if (CameraUtil.isSupported(touchAfAec,mParameters.getSupportedTouchAfAec())) {
      mCurrTouchAfAec=touchAfAec;
      mParameters.setTouchAfAec(touchAfAec);
    }
  }
 else {
    mParameters.setTouchAfAec(mParameters.TOUCH_AF_AEC_OFF);
    mFocusManager.resetTouchFocus();
  }
  try {
    if (mParameters.getTouchAfAec().equals(mParameters.TOUCH_AF_AEC_ON))     this.mTouchAfAecFlag=true;
 else     this.mTouchAfAecFlag=false;
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
  }
  String pictureFormat=mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_default));
  if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
    pictureFormat=PIXEL_FORMAT_JPEG;
    Editor editor=mPreferences.edit();
    editor.putString(CameraSettings.KEY_PICTURE_FORMAT,mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
    editor.apply();
  }
  Log.v(TAG,""String_Node_Str"" + pictureFormat);
  mParameters.set(KEY_PICTURE_FORMAT,pictureFormat);
  String jpegQuality=mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY,mActivity.getString(R.string.pref_camera_jpegquality_default));
  Size pic_size=mParameters.getPictureSize();
  if (pic_size == null) {
    Log.e(TAG,""String_Node_Str"");
  }
 else {
    if (""String_Node_Str"".equals(jpegQuality) && (pic_size.width >= 3200)) {
    }
 else {
      mParameters.setJpegQuality(JpegEncodingQualityMappings.getQualityNumber(jpegQuality));
      int jpegFileSize=estimateJpegFileSize(pic_size,jpegQuality);
      if (jpegFileSize != mJpegFileSizeEstimation) {
        mJpegFileSizeEstimation=jpegFileSize;
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRemainingPhotos();
          }
        }
);
      }
    }
  }
  String selectableZoneAf=mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF,mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
  List<String> str=mParameters.getSupportedSelectableZoneAf();
  if (CameraUtil.isSupported(selectableZoneAf,mParameters.getSupportedSelectableZoneAf())) {
    mParameters.setSelectableZoneAf(selectableZoneAf);
  }
  if (mParameters.getSupportedDenoiseModes() != null) {
    String Denoise=mPreferences.getString(CameraSettings.KEY_DENOISE,mActivity.getString(R.string.pref_camera_denoise_default));
    mParameters.setDenoise(Denoise);
  }
  String redeyeReduction=mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION,mActivity.getString(R.string.pref_camera_redeyereduction_default));
  if (CameraUtil.isSupported(redeyeReduction,mParameters.getSupportedRedeyeReductionModes())) {
    mParameters.setRedeyeReductionMode(redeyeReduction);
  }
  if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
    String iso=mPreferences.getString(CameraSettings.KEY_ISO,mActivity.getString(R.string.pref_camera_iso_default));
    if (CameraUtil.isSupported(iso,mParameters.getSupportedIsoValues())) {
      mParameters.setISOValue(iso);
    }
  }
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (CameraUtil.isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String saturationStr=mPreferences.getString(CameraSettings.KEY_SATURATION,mActivity.getString(R.string.pref_camera_saturation_default));
  int saturation=Integer.parseInt(saturationStr);
  Log.v(TAG,""String_Node_Str"" + saturation);
  if ((0 <= saturation) && (saturation <= mParameters.getMaxSaturation())) {
    mParameters.setSaturation(saturation);
  }
  String contrastStr=mPreferences.getString(CameraSettings.KEY_CONTRAST,mActivity.getString(R.string.pref_camera_contrast_default));
  int contrast=Integer.parseInt(contrastStr);
  Log.v(TAG,""String_Node_Str"" + contrast);
  if ((0 <= contrast) && (contrast <= mParameters.getMaxContrast())) {
    mParameters.setContrast(contrast);
  }
  String sharpnessStr=mPreferences.getString(CameraSettings.KEY_SHARPNESS,mActivity.getString(R.string.pref_camera_sharpness_default));
  int sharpness=Integer.parseInt(sharpnessStr) * (mParameters.getMaxSharpness() / MAX_SHARPNESS_LEVEL);
  Log.v(TAG,""String_Node_Str"" + sharpness);
  if ((0 <= sharpness) && (sharpness <= mParameters.getMaxSharpness())) {
    mParameters.setSharpness(sharpness);
  }
  String faceRC=mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION,mActivity.getString(R.string.pref_camera_facerc_default));
  Log.v(TAG,""String_Node_Str"" + faceRC);
  if (CameraUtil.isSupported(faceRC,CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION,faceRC);
  }
  String aeBracketing=mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR,mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
  Log.v(TAG,""String_Node_Str"" + aeBracketing);
  if (CameraUtil.isSupported(aeBracketing,CameraSettings.getSupportedAEBracketingModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING,aeBracketing);
  }
  String cds=mPreferences.getString(CameraSettings.KEY_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_default));
  if ((mPrevSavedCDS == null) && (cds != null)) {
    mPrevSavedCDS=cds;
  }
  if (CameraUtil.isSupported(cds,CameraSettings.getSupportedCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_CDS_MODE,cds);
  }
  String tnr=mPreferences.getString(CameraSettings.KEY_TNR_MODE,mActivity.getString(R.string.pref_camera_tnr_default));
  if (CameraUtil.isSupported(tnr,CameraSettings.getSupportedTNRModes(mParameters))) {
    if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mActivity.getString(R.string.pref_camera_cds_value_off));
        }
      }
);
      if (cds != null) {
        mPrevSavedCDS=cds;
      }
      isTNREnabled=true;
    }
 else     if (isTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE,mPrevSavedCDS);
        }
      }
);
      isTNREnabled=false;
    }
    mParameters.set(CameraSettings.KEY_QC_TNR_MODE,tnr);
  }
  String hdrMode=mPreferences.getString(CameraSettings.KEY_HDR_MODE,mActivity.getString(R.string.pref_camera_hdr_mode_default));
  Log.v(TAG,""String_Node_Str"" + hdrMode);
  if (CameraUtil.isSupported(hdrMode,CameraSettings.getSupportedHDRModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE,hdrMode);
  }
  String hdrNeed1x=mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X,mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
  Log.v(TAG,""String_Node_Str"" + hdrNeed1x);
  if (CameraUtil.isSupported(hdrNeed1x,CameraSettings.getSupportedHDRNeed1x(mParameters))) {
    mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X,hdrNeed1x);
  }
  String advancedFeature=mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES,mActivity.getString(R.string.pref_camera_advanced_feature_default));
  Log.e(TAG,""String_Node_Str"" + advancedFeature);
  mRefocus=false;
  if (advancedFeature != null) {
    String ubiFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
    String chromaFlashOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
    String optiZoomOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
    String reFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
    String fssrOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
    String truePortraitOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
    String multiTouchFocusOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
    String stillMoreOff=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_off);
    if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
      qcomUpdateAdvancedFeatures(advancedFeature,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,advancedFeature,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,advancedFeature,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
      mRefocus=true;
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,advancedFeature,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,advancedFeature,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,advancedFeature,multiTouchFocusOff,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,advancedFeature,stillMoreOff);
    }
 else     if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on))) {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,advancedFeature);
    }
 else {
      qcomUpdateAdvancedFeatures(ubiFocusOff,chromaFlashOff,reFocusOff,optiZoomOff,fssrOff,truePortraitOff,multiTouchFocusOff,stillMoreOff);
    }
  }
  if (mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on).equals(advancedFeature)) {
    if (CameraUtil.isSupported(Parameters.FACE_DETECTION_ON,mParameters.getSupportedFaceDetectionModes())) {
      mActivity.runOnUiThread(new Runnable(){
        @Override public void run(){
          mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,Parameters.FACE_DETECTION_ON);
        }
      }
);
      mParameters.setFaceDetectionMode(Parameters.FACE_DETECTION_ON);
      if (mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
    }
  }
 else {
    mActivity.runOnUiThread(new Runnable(){
      @Override public void run(){
        mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION,null);
      }
    }
);
    String faceDetection=mPreferences.getString(CameraSettings.KEY_FACE_DETECTION,mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection,mParameters.getSupportedFaceDetectionModes())) {
      mParameters.setFaceDetectionMode(faceDetection);
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == false) {
        mFaceDetectionEnabled=true;
        startFaceDetection();
      }
      if (faceDetection.equals(""String_Node_Str"") && mFaceDetectionEnabled == true) {
        stopFaceDetection();
        mFaceDetectionEnabled=false;
      }
    }
  }
  String autoExposure=mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE,mActivity.getString(R.string.pref_camera_autoexposure_default));
  Log.v(TAG,""String_Node_Str"" + autoExposure);
  if (CameraUtil.isSupported(autoExposure,mParameters.getSupportedAutoexposure())) {
    mParameters.setAutoExposure(autoExposure);
  }
  String antiBanding=mPreferences.getString(CameraSettings.KEY_ANTIBANDING,mActivity.getString(R.string.pref_camera_antibanding_default));
  Log.v(TAG,""String_Node_Str"" + antiBanding);
  if (CameraUtil.isSupported(antiBanding,mParameters.getSupportedAntibanding())) {
    mParameters.setAntibanding(antiBanding);
  }
  String zsl=mPreferences.getString(CameraSettings.KEY_ZSL,mActivity.getString(R.string.pref_camera_zsl_default));
  String auto_hdr=mPreferences.getString(CameraSettings.KEY_AUTO_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  if (CameraUtil.isAutoHDRSupported(mParameters)) {
    mParameters.set(""String_Node_Str"",auto_hdr);
    if (auto_hdr.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.VISIBLE);
          }
        }
      }
);
      mParameters.setSceneMode(""String_Node_Str"");
      mCameraDevice.setMetadataCb(mMetaDataCallback);
    }
 else {
      mAutoHdrEnable=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mDrawAutoHDR != null) {
            mDrawAutoHDR.setVisibility(View.INVISIBLE);
          }
        }
      }
);
    }
  }
  mParameters.setZSLMode(zsl);
  if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_ZSL;
    mParameters.setCameraMode(1);
    mFocusManager.setZslEnable(true);
    mParameters.set(KEY_PICTURE_FORMAT,PIXEL_FORMAT_JPEG);
    if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE,mParameters.getSupportedFocusModes()) && !mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
      mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
    }
 else     if (mFocusManager.isTouch()) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
 else {
      mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
    }
    if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_raw,Toast.LENGTH_SHORT).show();
        }
      }
);
    }
  }
 else   if (zsl.equals(""String_Node_Str"")) {
    mSnapshotMode=CameraInfo.CAMERA_SUPPORT_MODE_NONZSL;
    mParameters.setCameraMode(0);
    mFocusManager.setZslEnable(false);
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
      mFocusManager.overrideFocusMode(null);
      mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
  }
  String histogram=mPreferences.getString(CameraSettings.KEY_HISTOGRAM,mActivity.getString(R.string.pref_camera_histogram_default));
  if (CameraUtil.isSupported(histogram,mParameters.getSupportedHistogramModes()) && mCameraDevice != null) {
    if (histogram.equals(""String_Node_Str"")) {
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null) {
            mGraphView.setVisibility(View.VISIBLE);
            mGraphView.PreviewChanged();
          }
        }
      }
);
      mCameraDevice.setHistogramMode(mStatsCallback);
      mHiston=true;
    }
 else {
      mHiston=false;
      mActivity.runOnUiThread(new Runnable(){
        public void run(){
          if (mGraphView != null)           mGraphView.setVisibility(View.INVISIBLE);
        }
      }
);
      mCameraDevice.setHistogramMode(null);
    }
  }
  setFlipValue();
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mParameters.setFlashMode(fMode);
  }
}","The original code performed UI updates directly on a background thread, which can cause threading issues and potential crashes in Android. The fixed code moves UI-related operations like `mUI.overrideSettings()` to `runOnUiThread()`, ensuring safe UI manipulation from background threads. This change prevents potential race conditions and maintains proper Android UI thread synchronization, resulting in more robust and predictable UI behavior."
38232,"@Override public void onResumeAfterSuper(){
  mLastPhotoTakenWithRefocus=false;
  String action=mActivity.getIntent().getAction();
  if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(action) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)) {
    Log.v(TAG,""String_Node_Str"");
    mHandler.postDelayed(new Runnable(){
      public void run(){
        onResumeTasks();
      }
    }
,ON_RESUME_TASKS_DELAY_MSEC);
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    onResumeTasks();
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      mActivity.updateStorageSpaceAndHint();
      updateRemainingPhotos();
    }
  }
);
}","@Override public void onResumeAfterSuper(){
  mLastPhotoTakenWithRefocus=false;
  String action=mActivity.getIntent().getAction();
  if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(action) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)) {
    Log.v(TAG,""String_Node_Str"");
    mHandler.postDelayed(new Runnable(){
      public void run(){
        onResumeTasks();
      }
    }
,ON_RESUME_TASKS_DELAY_MSEC);
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    onResumeTasks();
  }
  if (mSoundPool == null) {
    mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
    mRefocusSound=mSoundPool.load(mActivity,R.raw.camera_click_x5,1);
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      mActivity.updateStorageSpaceAndHint();
      updateRemainingPhotos();
    }
  }
);
}","The original code lacked initialization of the SoundPool, which could lead to potential null pointer exceptions when attempting to play sounds. The fixed code adds a null check and initializes mSoundPool with specific parameters, including loading a camera click sound resource when the sound pool is null. This proactive initialization ensures sound-related functionality is properly set up before potential usage, preventing runtime errors and improving the robustness of the audio handling in the camera application."
38233,"@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mContentResolver=mActivity.getContentResolver();
  mIsImageCaptureIntent=isImageCaptureIntent();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mUI=new PhotoUI(activity,this,parent);
  if (mOpenCameraThread == null) {
    mOpenCameraThread=new OpenCameraThread();
    mOpenCameraThread.start();
  }
  initializeControlByIntent();
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,mUI);
  mSensorManager=(SensorManager)(mActivity.getSystemService(Context.SENSOR_SERVICE));
  brightnessProgressBar=(ProgressBar)mRootView.findViewById(R.id.progress);
  if (brightnessProgressBar instanceof SeekBar) {
    SeekBar seeker=(SeekBar)brightnessProgressBar;
    seeker.setOnSeekBarChangeListener(mSeekListener);
  }
  brightnessProgressBar.setMax(MAXIMUM_BRIGHTNESS);
  mbrightness=mPreferences.getInt(CameraSettings.KEY_BRIGHTNESS,DEFAULT_BRIGHTNESS);
  brightnessProgressBar.setProgress(mbrightness);
  brightnessProgressBar.setVisibility(View.INVISIBLE);
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
  mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
  mRefocusSound=mSoundPool.load(mActivity,R.raw.camera_click_x5,1);
}","@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mContentResolver=mActivity.getContentResolver();
  mIsImageCaptureIntent=isImageCaptureIntent();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mUI=new PhotoUI(activity,this,parent);
  if (mOpenCameraThread == null) {
    mOpenCameraThread=new OpenCameraThread();
    mOpenCameraThread.start();
  }
  initializeControlByIntent();
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,mUI);
  mSensorManager=(SensorManager)(mActivity.getSystemService(Context.SENSOR_SERVICE));
  brightnessProgressBar=(ProgressBar)mRootView.findViewById(R.id.progress);
  if (brightnessProgressBar instanceof SeekBar) {
    SeekBar seeker=(SeekBar)brightnessProgressBar;
    seeker.setOnSeekBarChangeListener(mSeekListener);
  }
  brightnessProgressBar.setMax(MAXIMUM_BRIGHTNESS);
  mbrightness=mPreferences.getInt(CameraSettings.KEY_BRIGHTNESS,DEFAULT_BRIGHTNESS);
  brightnessProgressBar.setProgress(mbrightness);
  brightnessProgressBar.setVisibility(View.INVISIBLE);
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
}","The original code improperly initializes a SoundPool without releasing resources, which can lead to memory leaks and potential audio system conflicts. The fixed code removes the unnecessary SoundPool initialization, eliminating potential resource management issues and unnecessary audio object creation. By removing the redundant sound-related code, the initialization becomes more streamlined and prevents potential memory and system resource complications."
38234,"@Override public void onPauseBeforeSuper(){
  mPaused=true;
  Sensor gsensor=mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
  if (gsensor != null) {
    mSensorManager.unregisterListener(this,gsensor);
  }
  Sensor msensor=mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
  if (msensor != null) {
    mSensorManager.unregisterListener(this,msensor);
  }
  Log.d(TAG,""String_Node_Str"");
  removeIdleHandler();
}","@Override public void onPauseBeforeSuper(){
  mPaused=true;
  Sensor gsensor=mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
  if (gsensor != null) {
    mSensorManager.unregisterListener(this,gsensor);
  }
  Sensor msensor=mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
  if (msensor != null) {
    mSensorManager.unregisterListener(this,msensor);
  }
  if (mSoundPool != null) {
    mSoundPool.release();
    mSoundPool=null;
  }
  Log.d(TAG,""String_Node_Str"");
  removeIdleHandler();
}","The original code omitted releasing the SoundPool resource, which could lead to memory leaks and potential resource exhaustion. The fixed code adds a null check and explicitly releases the mSoundPool, setting it to null to prevent memory-related issues and ensure proper resource management. By properly releasing the SoundPool, the fixed version prevents potential memory leaks and improves the overall stability of the application."
38235,"public CountDownView(Context context,AttributeSet attrs){
  super(context,attrs);
  mContext=context;
  mCountDownAnim=AnimationUtils.loadAnimation(context,R.anim.count_down_exit);
  if (context.getResources().getBoolean(R.bool.force_count_down_sound)) {
    mSoundPool=new SoundPool(1,AudioManager.STREAM_SYSTEM_ENFORCED,0);
  }
 else {
    mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
  }
  mBeepOnce=mSoundPool.load(context,R.raw.beep_once,1);
  mBeepTwice=mSoundPool.load(context,R.raw.beep_twice,1);
}","public CountDownView(Context context,AttributeSet attrs){
  super(context,attrs);
  mContext=context;
  mCountDownAnim=AnimationUtils.loadAnimation(context,R.anim.count_down_exit);
  if (mSoundPool == null) {
    if (context.getResources().getBoolean(R.bool.force_count_down_sound)) {
      mSoundPool=new SoundPool(1,AudioManager.STREAM_SYSTEM_ENFORCED,0);
    }
 else {
      mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
    }
    mBeepOnce=mSoundPool.load(context,R.raw.beep_once,1);
    mBeepTwice=mSoundPool.load(context,R.raw.beep_twice,1);
  }
}","The original code creates a new SoundPool every time the constructor is called, potentially leading to multiple unnecessary sound pool instances. The fixed code adds a null check for mSoundPool before initialization, ensuring that the sound pool is created only once. This prevents resource waste and potential memory leaks by guaranteeing a single, reusable SoundPool instance throughout the view's lifecycle."
38236,"@Override public void onResumeAfterSuper(){
  mLastPhotoTakenWithRefocus=false;
  String action=mActivity.getIntent().getAction();
  if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(action) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)) {
    Log.v(TAG,""String_Node_Str"");
    mHandler.postDelayed(new Runnable(){
      public void run(){
        onResumeTasks();
      }
    }
,ON_RESUME_TASKS_DELAY_MSEC);
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    onResumeTasks();
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      mActivity.updateStorageSpaceAndHint();
      updateRemainingPhotos();
    }
  }
);
}","@Override public void onResumeAfterSuper(){
  mLastPhotoTakenWithRefocus=false;
  String action=mActivity.getIntent().getAction();
  if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(action) || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)) {
    Log.v(TAG,""String_Node_Str"");
    mHandler.postDelayed(new Runnable(){
      public void run(){
        onResumeTasks();
      }
    }
,ON_RESUME_TASKS_DELAY_MSEC);
  }
 else {
    Log.v(TAG,""String_Node_Str"");
    onResumeTasks();
  }
  if (mSoundPool == null) {
    mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
    mRefocusSound=mSoundPool.load(mActivity,R.raw.camera_click_x5,1);
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      mActivity.updateStorageSpaceAndHint();
      updateRemainingPhotos();
    }
  }
);
}","The original code lacked initialization of the SoundPool, which could lead to potential null pointer exceptions when audio-related operations are performed. The fixed code adds a null check and initializes mSoundPool with a new SoundPool instance, loading the camera click sound resource only if it hasn't been created before. This ensures proper sound resource management and prevents potential runtime errors by lazily initializing the audio components when needed."
38237,"@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mContentResolver=mActivity.getContentResolver();
  mIsImageCaptureIntent=isImageCaptureIntent();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mUI=new PhotoUI(activity,this,parent);
  if (mOpenCameraThread == null) {
    mOpenCameraThread=new OpenCameraThread();
    mOpenCameraThread.start();
  }
  initializeControlByIntent();
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,mUI);
  mSensorManager=(SensorManager)(mActivity.getSystemService(Context.SENSOR_SERVICE));
  brightnessProgressBar=(ProgressBar)mRootView.findViewById(R.id.progress);
  if (brightnessProgressBar instanceof SeekBar) {
    SeekBar seeker=(SeekBar)brightnessProgressBar;
    seeker.setOnSeekBarChangeListener(mSeekListener);
  }
  brightnessProgressBar.setMax(MAXIMUM_BRIGHTNESS);
  mbrightness=mPreferences.getInt(CameraSettings.KEY_BRIGHTNESS,DEFAULT_BRIGHTNESS);
  brightnessProgressBar.setProgress(mbrightness);
  brightnessProgressBar.setVisibility(View.INVISIBLE);
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
  mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
  mRefocusSound=mSoundPool.load(mActivity,R.raw.camera_click_x5,1);
}","@Override public void init(CameraActivity activity,View parent){
  mActivity=activity;
  mRootView=parent;
  mPreferences=new ComboPreferences(mActivity);
  CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(),activity);
  mCameraId=getPreferredCameraId(mPreferences);
  mContentResolver=mActivity.getContentResolver();
  mIsImageCaptureIntent=isImageCaptureIntent();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mUI=new PhotoUI(activity,this,parent);
  if (mOpenCameraThread == null) {
    mOpenCameraThread=new OpenCameraThread();
    mOpenCameraThread.start();
  }
  initializeControlByIntent();
  mQuickCapture=mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE,false);
  mLocationManager=new LocationManager(mActivity,mUI);
  mSensorManager=(SensorManager)(mActivity.getSystemService(Context.SENSOR_SERVICE));
  brightnessProgressBar=(ProgressBar)mRootView.findViewById(R.id.progress);
  if (brightnessProgressBar instanceof SeekBar) {
    SeekBar seeker=(SeekBar)brightnessProgressBar;
    seeker.setOnSeekBarChangeListener(mSeekListener);
  }
  brightnessProgressBar.setMax(MAXIMUM_BRIGHTNESS);
  mbrightness=mPreferences.getInt(CameraSettings.KEY_BRIGHTNESS,DEFAULT_BRIGHTNESS);
  brightnessProgressBar.setProgress(mbrightness);
  brightnessProgressBar.setVisibility(View.INVISIBLE);
  Storage.setSaveSDCard(mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH,""String_Node_Str"").equals(""String_Node_Str""));
}","The original code improperly initialized a SoundPool without releasing its resources, which could lead to memory leaks and potential audio system performance issues. The fixed code removes the SoundPool initialization and sound loading, eliminating unnecessary audio resource allocation that was not essential to the camera initialization process. This modification simplifies the initialization method, reduces potential memory overhead, and prevents unintended audio resource management complications."
38238,"@Override public void onPauseBeforeSuper(){
  mPaused=true;
  Sensor gsensor=mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
  if (gsensor != null) {
    mSensorManager.unregisterListener(this,gsensor);
  }
  Sensor msensor=mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
  if (msensor != null) {
    mSensorManager.unregisterListener(this,msensor);
  }
  Log.d(TAG,""String_Node_Str"");
  removeIdleHandler();
}","@Override public void onPauseBeforeSuper(){
  mPaused=true;
  Sensor gsensor=mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
  if (gsensor != null) {
    mSensorManager.unregisterListener(this,gsensor);
  }
  Sensor msensor=mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
  if (msensor != null) {
    mSensorManager.unregisterListener(this,msensor);
  }
  if (mSoundPool != null) {
    mSoundPool.release();
    mSoundPool=null;
  }
  Log.d(TAG,""String_Node_Str"");
  removeIdleHandler();
}","The original code lacks proper resource management for the SoundPool, potentially causing memory leaks and resource inefficiency. The fixed code adds a null check and explicitly releases the SoundPool resources, setting the reference to null to prevent further usage. This ensures clean resource handling, prevents potential memory-related issues, and follows best practices for managing Android audio resources."
38239,"public CountDownView(Context context,AttributeSet attrs){
  super(context,attrs);
  mContext=context;
  mCountDownAnim=AnimationUtils.loadAnimation(context,R.anim.count_down_exit);
  if (context.getResources().getBoolean(R.bool.force_count_down_sound)) {
    mSoundPool=new SoundPool(1,AudioManager.STREAM_SYSTEM_ENFORCED,0);
  }
 else {
    mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
  }
  mBeepOnce=mSoundPool.load(context,R.raw.beep_once,1);
  mBeepTwice=mSoundPool.load(context,R.raw.beep_twice,1);
}","public CountDownView(Context context,AttributeSet attrs){
  super(context,attrs);
  mContext=context;
  mCountDownAnim=AnimationUtils.loadAnimation(context,R.anim.count_down_exit);
  if (mSoundPool == null) {
    if (context.getResources().getBoolean(R.bool.force_count_down_sound)) {
      mSoundPool=new SoundPool(1,AudioManager.STREAM_SYSTEM_ENFORCED,0);
    }
 else {
      mSoundPool=new SoundPool(1,AudioManager.STREAM_NOTIFICATION,0);
    }
    mBeepOnce=mSoundPool.load(context,R.raw.beep_once,1);
    mBeepTwice=mSoundPool.load(context,R.raw.beep_twice,1);
  }
}","The original code creates a new SoundPool every time the constructor is called, potentially leading to multiple unnecessary sound pool instances. The fixed code adds a null check for mSoundPool before initialization, ensuring that only one SoundPool is created and reused across multiple constructor calls. This prevents resource waste and potential memory leaks by guaranteeing a single, efficient sound pool instance for the CountDownView."
38240,"public boolean isOverPreviewMenu(MotionEvent ev){
  if (mPreviewMenuStatus != PREVIEW_MENU_ON)   return false;
  if (mUI.getPreviewMenuLayout() == null)   return false;
  Rect rec=new Rect();
  mUI.getPreviewMenuLayout().getChildAt(0).getHitRect(rec);
  rec.top+=(int)mUI.getPreviewMenuLayout().getY();
  rec.bottom+=(int)mUI.getPreviewMenuLayout().getY();
  return rec.contains((int)ev.getX(),(int)ev.getY());
}","public boolean isOverPreviewMenu(MotionEvent ev){
  if (mPreviewMenuStatus != PREVIEW_MENU_ON)   return false;
  if (mUI.getPreviewMenuLayout() == null)   return false;
  Rect rec=new Rect();
  mUI.getPreviewMenuLayout().getChildAt(0).getHitRect(rec);
  if (View.LAYOUT_DIRECTION_RTL == TextUtils.getLayoutDirectionFromLocale(Locale.getDefault())) {
    rec.left=mUI.getRootView().getWidth() - (rec.right - rec.left);
    rec.right=mUI.getRootView().getWidth();
  }
  rec.top+=(int)mUI.getPreviewMenuLayout().getY();
  rec.bottom+=(int)mUI.getPreviewMenuLayout().getY();
  return rec.contains((int)ev.getX(),(int)ev.getY());
}","The original code fails to handle right-to-left (RTL) language layouts, potentially causing incorrect touch area calculations for preview menus. The fixed code adds a specific adjustment for RTL layouts by repositioning the rectangle's left and right boundaries based on the root view's width, ensuring accurate touch detection across different language settings. This modification provides more robust and locale-aware touch event handling for preview menu interactions."
38241,"@Override public void onShutterButtonFocus(boolean pressed){
  if (mCameraDevice == null || mPaused || mUI.collapseCameraControls() || (mCameraState == SNAPSHOT_IN_PROGRESS) || (mCameraState == PREVIEW_STOPPED) || (null == mFocusManager)) {
    Log.v(TAG,""String_Node_Str"" + mCameraState + ""String_Node_Str""+ mCameraDevice+ ""String_Node_Str""+ mPaused);
    return;
  }
synchronized (mCameraDevice) {
    if (mCameraState == LONGSHOT) {
      mLongshotActive=false;
      mCameraDevice.setLongshot(false);
      mUI.animateCapture(mLastJpegData,mLastJpegOrientation,mMirror);
      if (!mFocusManager.isZslEnabled()) {
        setupPreview();
      }
 else {
        setCameraState(IDLE);
        mFocusManager.resetTouchFocus();
        if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
          mCameraDevice.cancelAutoFocus();
        }
        mUI.resumeFaceDetection();
      }
    }
  }
  if (pressed && !canTakePicture())   return;
  if (pressed) {
    mFocusManager.onShutterDown();
  }
 else {
    if (!mUI.isCountingDown()) {
      mFocusManager.onShutterUp();
    }
  }
}","@Override public void onShutterButtonFocus(boolean pressed){
  if (mCameraDevice == null || mPaused || mUI.collapseCameraControls() || (mCameraState == SNAPSHOT_IN_PROGRESS) || (mCameraState == PREVIEW_STOPPED) || (null == mFocusManager)) {
    Log.v(TAG,""String_Node_Str"" + mCameraState + ""String_Node_Str""+ mCameraDevice+ ""String_Node_Str""+ mPaused);
    return;
  }
synchronized (mCameraDevice) {
    if (mCameraState == LONGSHOT) {
      mLongshotActive=false;
      mCameraDevice.setLongshot(false);
      mUI.animateCapture(mLastJpegData,mLastJpegOrientation,mMirror);
      mLastJpegData=null;
      if (!mFocusManager.isZslEnabled()) {
        setupPreview();
      }
 else {
        setCameraState(IDLE);
        mFocusManager.resetTouchFocus();
        if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
          mCameraDevice.cancelAutoFocus();
        }
        mUI.resumeFaceDetection();
      }
    }
  }
  if (pressed && !canTakePicture())   return;
  if (pressed) {
    mFocusManager.onShutterDown();
  }
 else {
    if (!mUI.isCountingDown()) {
      mFocusManager.onShutterUp();
    }
  }
}","The original code failed to clear `mLastJpegData` after animating capture, potentially causing memory leaks and stale data retention. In the fixed code, `mLastJpegData=null` was added to explicitly release the reference after animation, preventing potential memory-related issues. This modification ensures proper resource management and prevents unintended data persistence between camera operations."
38242,"private String getSDCardStorageState(){
  try {
    return mMountService.getVolumeState(mVolume.getPath());
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"" + e);
    return Environment.MEDIA_REMOVED;
  }
}","private String getSDCardStorageState(){
  return mVolume.getState();
}","The original code unnecessarily calls a complex method `mMountService.getVolumeState()` with exception handling, which introduces overhead and potential performance issues. The fixed code directly uses `mVolume.getState()`, which is a simpler, more direct method for retrieving the volume state. This approach reduces code complexity, eliminates unnecessary exception catching, and provides a more efficient way to determine the SD card storage state."
38243,"@Override public void onShutterButtonFocus(boolean pressed){
  if (mCameraDevice == null || mPaused || mUI.collapseCameraControls() || (mCameraState == SNAPSHOT_IN_PROGRESS) || (mCameraState == PREVIEW_STOPPED) || (null == mFocusManager)) {
    Log.v(TAG,""String_Node_Str"" + mCameraState + ""String_Node_Str""+ mCameraDevice+ ""String_Node_Str""+ mPaused);
    return;
  }
synchronized (mCameraDevice) {
    if (mCameraState == LONGSHOT) {
      mLongshotActive=false;
      mCameraDevice.setLongshot(false);
      mUI.animateCapture(mLastJpegData,mLastJpegOrientation,mMirror);
      if (!mFocusManager.isZslEnabled()) {
        setupPreview();
      }
 else {
        setCameraState(IDLE);
        mFocusManager.resetTouchFocus();
        if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
          mCameraDevice.cancelAutoFocus();
        }
        mUI.resumeFaceDetection();
      }
    }
  }
  if (pressed && !canTakePicture())   return;
  if (pressed) {
    mFocusManager.onShutterDown();
  }
 else {
    if (!mUI.isCountingDown()) {
      mFocusManager.onShutterUp();
    }
  }
}","@Override public void onShutterButtonFocus(boolean pressed){
  if (mCameraDevice == null || mPaused || mUI.collapseCameraControls() || (mCameraState == SNAPSHOT_IN_PROGRESS) || (mCameraState == PREVIEW_STOPPED) || (null == mFocusManager)) {
    Log.v(TAG,""String_Node_Str"" + mCameraState + ""String_Node_Str""+ mCameraDevice+ ""String_Node_Str""+ mPaused);
    return;
  }
synchronized (mCameraDevice) {
    if (mCameraState == LONGSHOT) {
      mLongshotActive=false;
      mCameraDevice.setLongshot(false);
      mUI.animateCapture(mLastJpegData,mLastJpegOrientation,mMirror);
      mLastJpegData=null;
      if (!mFocusManager.isZslEnabled()) {
        setupPreview();
      }
 else {
        setCameraState(IDLE);
        mFocusManager.resetTouchFocus();
        if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
          mCameraDevice.cancelAutoFocus();
        }
        mUI.resumeFaceDetection();
      }
    }
  }
  if (pressed && !canTakePicture())   return;
  if (pressed) {
    mFocusManager.onShutterDown();
  }
 else {
    if (!mUI.isCountingDown()) {
      mFocusManager.onShutterUp();
    }
  }
}","The original code did not reset `mLastJpegData` after using it, potentially causing memory leaks and stale data retention in subsequent camera operations. The fixed code adds `mLastJpegData=null` after animating the capture, explicitly clearing the reference and preventing unintended data persistence. This change ensures proper memory management and prevents potential memory-related issues during repeated camera capture sequences."
38244,"private void qcomSetCameraParameters(){
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String disMode=mPreferences.getString(CameraSettings.KEY_DIS,mActivity.getString(R.string.pref_camera_dis_default));
  Log.v(TAG,""String_Node_Str"" + disMode);
  mIsDISEnabled=disMode.equals(""String_Node_Str"");
  if (is4KEnabled()) {
    if (isSupported(mActivity.getString(R.string.pref_camera_dis_value_disable),CameraSettings.getSupportedDISModes(mParameters))) {
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,mActivity.getString(R.string.pref_camera_dis_value_disable));
      mUI.overrideSettings(CameraSettings.KEY_DIS,mActivity.getString(R.string.pref_camera_dis_value_disable));
      RotateTextToast.makeText(mActivity,R.string.video_quality_4k_disable_IS,Toast.LENGTH_LONG).show();
    }
 else {
      Log.e(TAG,""String_Node_Str"" + mActivity.getString(R.string.pref_camera_dis_value_disable));
    }
  }
 else {
    if (isSupported(disMode,CameraSettings.getSupportedDISModes(mParameters))) {
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,disMode);
    }
 else {
      Log.e(TAG,""String_Node_Str"" + disMode);
    }
  }
  if (mDefaultAntibanding == null) {
    mDefaultAntibanding=mParameters.getAntibanding();
    Log.d(TAG,""String_Node_Str"" + mDefaultAntibanding);
  }
  if (disMode.equals(""String_Node_Str"")) {
    Log.d(TAG,""String_Node_Str"");
    if (isSupported(Parameters.ANTIBANDING_AUTO,mParameters.getSupportedAntibanding())) {
      mParameters.setAntibanding(Parameters.ANTIBANDING_AUTO);
    }
  }
 else {
    if (isSupported(mDefaultAntibanding,mParameters.getSupportedAntibanding())) {
      mParameters.setAntibanding(mDefaultAntibanding);
    }
  }
  Log.d(TAG,""String_Node_Str"" + mParameters.getAntibanding());
  mUnsupportedHFRVideoSize=false;
  mUnsupportedHFRVideoCodec=false;
  mUnsupportedHSRVideoSize=false;
  String yv12formatset=SystemProperties.get(""String_Node_Str"");
  if (yv12formatset.equals(""String_Node_Str"")) {
    Log.v(TAG,""String_Node_Str"");
    mParameters.setPreviewFormat(ImageFormat.YV12);
  }
  mParameters.set(KEY_PREVIEW_FORMAT,FORMAT_NV21);
  Log.v(TAG,""String_Node_Str"");
  String HighFrameRate=mPreferences.getString(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,mActivity.getString(R.string.pref_camera_hfr_default));
  if ((""String_Node_Str"".equals(HighFrameRate.substring(0,3))) || (""String_Node_Str"".equals(HighFrameRate.substring(0,3)))) {
    String hfrRate=HighFrameRate.substring(3);
    if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
      mUnsupportedHFRVideoSize=true;
    }
 else {
      mUnsupportedHSRVideoSize=true;
    }
    String hfrsize=videoWidth + ""String_Node_Str"" + videoHeight;
    Log.v(TAG,""String_Node_Str"" + hfrsize);
    try {
      Size size=null;
      if (isSupported(hfrRate,mParameters.getSupportedVideoHighFrameRateModes())) {
        int index=mParameters.getSupportedVideoHighFrameRateModes().indexOf(hfrRate);
        size=mParameters.getSupportedHfrSizes().get(index);
      }
      if (size != null) {
        if (videoWidth <= size.width && videoHeight <= size.height) {
          if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
            mUnsupportedHFRVideoSize=false;
          }
 else {
            mUnsupportedHSRVideoSize=false;
          }
          Log.v(TAG,""String_Node_Str"");
        }
      }
    }
 catch (    NullPointerException e) {
      Log.e(TAG,""String_Node_Str"");
    }
    int hfrFps=Integer.parseInt(hfrRate);
    int inputBitrate=videoWidth * videoHeight * hfrFps;
    List<VideoEncoderCap> videoEncoders=EncoderCapabilities.getVideoEncoders();
    for (    VideoEncoderCap videoEncoder : videoEncoders) {
      if (videoEncoder.mCodec == mVideoEncoder) {
        int maxBitrate=(videoEncoder.mMaxHFRFrameWidth * videoEncoder.mMaxHFRFrameHeight * videoEncoder.mMaxHFRMode);
        if (inputBitrate > maxBitrate) {
          Log.e(TAG,""String_Node_Str"" + mVideoEncoder + ""String_Node_Str""+ HighFrameRate+ ""String_Node_Str""+ videoWidth+ ""String_Node_Str""+ videoHeight+ ""String_Node_Str"");
          Log.e(TAG,""String_Node_Str"" + ""String_Node_Str"" + videoEncoder.mMaxHFRFrameWidth + ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxHFRFrameHeight+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxHFRMode);
          if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
            mUnsupportedHFRVideoSize=true;
          }
 else {
            mUnsupportedHSRVideoSize=true;
          }
        }
        break;
      }
    }
    if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
      mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      if (mUnsupportedHFRVideoSize) {
        mParameters.setVideoHighFrameRate(""String_Node_Str"");
        Log.v(TAG,""String_Node_Str"");
      }
 else {
        mParameters.setVideoHighFrameRate(hfrRate);
      }
    }
 else {
      mParameters.setVideoHighFrameRate(""String_Node_Str"");
      if (mUnsupportedHSRVideoSize) {
        Log.v(TAG,""String_Node_Str"");
        mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      }
 else {
        mParameters.set(CameraSettings.KEY_VIDEO_HSR,hfrRate);
      }
    }
    if (mVideoEncoder != MediaRecorder.VideoEncoder.H264) {
      mUnsupportedHFRVideoCodec=true;
    }
  }
 else {
    mParameters.setVideoHighFrameRate(""String_Node_Str"");
    mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
  }
  setFlipValue();
  String video_cds=mPreferences.getString(CameraSettings.KEY_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_default));
  if ((mPrevSavedVideoCDS == null) && (video_cds != null)) {
    mPrevSavedVideoCDS=video_cds;
  }
  if (mOverrideCDS) {
    video_cds=mPrevSavedVideoCDS;
    mOverrideCDS=false;
  }
  if (CameraUtil.isSupported(video_cds,CameraSettings.getSupportedVideoCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,video_cds);
  }
  String video_tnr=mPreferences.getString(CameraSettings.KEY_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_default));
  if (CameraUtil.isSupported(video_tnr,CameraSettings.getSupportedVideoTNRModes(mParameters))) {
    if (!video_tnr.equals(mActivity.getString(R.string.pref_camera_video_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
      mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
      if (!mIsVideoCDSUpdated) {
        if (video_cds != null) {
          mPrevSavedVideoCDS=mTempVideoCDS;
        }
        mIsVideoTNREnabled=true;
        mIsVideoCDSUpdated=true;
      }
    }
 else     if (mIsVideoTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mPrevSavedVideoCDS);
      mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mPrevSavedVideoCDS);
      mIsVideoTNREnabled=false;
      mIsVideoCDSUpdated=false;
      mOverrideCDS=true;
    }
 else {
      mTempVideoCDS=video_cds;
    }
    mParameters.set(CameraSettings.KEY_QC_VIDEO_TNR_MODE,video_tnr);
    mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_TNR_MODE,video_tnr);
  }
  String seeMoreMode=mPreferences.getString(CameraSettings.KEY_SEE_MORE,mActivity.getString(R.string.pref_camera_see_more_default));
  Log.v(TAG,""String_Node_Str"" + seeMoreMode);
  if (isSupported(seeMoreMode,CameraSettings.getSupportedSeeMoreModes(mParameters))) {
    if (is4KEnabled() && seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on))) {
      mParameters.set(CameraSettings.KEY_QC_SEE_MORE_MODE,mActivity.getString(R.string.pref_camera_see_more_value_off));
      mUI.overrideSettings(CameraSettings.KEY_SEE_MORE,mActivity.getString(R.string.pref_camera_see_more_value_off));
      Toast.makeText(mActivity,R.string.video_quality_4k_disable_SeeMore,Toast.LENGTH_LONG).show();
    }
 else {
      if (seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on)) && video_cds.equals(mActivity.getString(R.string.pref_camera_video_cds_value_on))) {
        mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
        mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
        Toast.makeText(mActivity,R.string.disable_CDS_during_SeeMore,Toast.LENGTH_LONG).show();
      }
      if (seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on)) && video_tnr.equals(mActivity.getString(R.string.pref_camera_video_tnr_value_on))) {
        mParameters.set(CameraSettings.KEY_QC_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_value_off));
        mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_value_off));
        Toast.makeText(mActivity,R.string.disable_TNR_during_SeeMore,Toast.LENGTH_LONG).show();
      }
      mParameters.set(CameraSettings.KEY_QC_SEE_MORE_MODE,seeMoreMode);
    }
  }
  String videoHDR=mPreferences.getString(CameraSettings.KEY_VIDEO_HDR,mActivity.getString(R.string.pref_camera_video_hdr_default));
  Log.v(TAG,""String_Node_Str"" + videoHDR);
  if (isSupported(videoHDR,mParameters.getSupportedVideoHDRModes())) {
    mParameters.setVideoHDRMode(videoHDR);
  }
 else   mParameters.setVideoHDRMode(""String_Node_Str"");
  String hfr=mParameters.getVideoHighFrameRate();
  String hsr=mParameters.get(CameraSettings.KEY_VIDEO_HSR);
  String hdr=mParameters.getVideoHDRMode();
  if (((hfr != null) && (!hfr.equals(""String_Node_Str""))) || ((hsr != null) && (!hsr.equals(""String_Node_Str"")))) {
    String frameIntervalStr=mPreferences.getString(CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL,mActivity.getString(R.string.pref_video_time_lapse_frame_interval_default));
    int timeLapseInterval=Integer.parseInt(frameIntervalStr);
    if ((timeLapseInterval != 0) || (disMode.equals(""String_Node_Str"")) || ((hdr != null) && (!hdr.equals(""String_Node_Str"")))) {
      Log.v(TAG,""String_Node_Str"");
      mParameters.setVideoHighFrameRate(""String_Node_Str"");
      mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      mUI.overrideSettings(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,""String_Node_Str"");
    }
  }
  Size biggestSize=mParameters.getSupportedPictureSizes().get(0);
  if (biggestSize.width <= videoWidth || biggestSize.height <= videoHeight) {
    if (disMode.equals(""String_Node_Str"")) {
      Log.v(TAG,""String_Node_Str"");
      RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_dis,Toast.LENGTH_LONG).show();
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,""String_Node_Str"");
      mUI.overrideSettings(CameraSettings.KEY_DIS,""String_Node_Str"");
      mIsDISEnabled=false;
    }
  }
  String videoRotation=mPreferences.getString(CameraSettings.KEY_VIDEO_ROTATION,mActivity.getString(R.string.pref_camera_video_rotation_default));
  if (isSupported(videoRotation,mParameters.getSupportedVideoRotationValues())) {
    mParameters.setVideoRotation(videoRotation);
  }
  updatePowerMode();
}","private void qcomSetCameraParameters(){
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String disMode=mPreferences.getString(CameraSettings.KEY_DIS,mActivity.getString(R.string.pref_camera_dis_default));
  Log.v(TAG,""String_Node_Str"" + disMode);
  mIsDISEnabled=disMode.equals(""String_Node_Str"");
  if (is4KEnabled()) {
    if (isSupported(mActivity.getString(R.string.pref_camera_dis_value_disable),CameraSettings.getSupportedDISModes(mParameters))) {
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,mActivity.getString(R.string.pref_camera_dis_value_disable));
      mUI.overrideSettings(CameraSettings.KEY_DIS,mActivity.getString(R.string.pref_camera_dis_value_disable));
    }
 else {
      Log.e(TAG,""String_Node_Str"" + mActivity.getString(R.string.pref_camera_dis_value_disable));
    }
  }
 else {
    if (isSupported(disMode,CameraSettings.getSupportedDISModes(mParameters))) {
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,disMode);
    }
 else {
      Log.e(TAG,""String_Node_Str"" + disMode);
    }
  }
  if (mDefaultAntibanding == null) {
    mDefaultAntibanding=mParameters.getAntibanding();
    Log.d(TAG,""String_Node_Str"" + mDefaultAntibanding);
  }
  if (disMode.equals(""String_Node_Str"")) {
    Log.d(TAG,""String_Node_Str"");
    if (isSupported(Parameters.ANTIBANDING_AUTO,mParameters.getSupportedAntibanding())) {
      mParameters.setAntibanding(Parameters.ANTIBANDING_AUTO);
    }
  }
 else {
    if (isSupported(mDefaultAntibanding,mParameters.getSupportedAntibanding())) {
      mParameters.setAntibanding(mDefaultAntibanding);
    }
  }
  Log.d(TAG,""String_Node_Str"" + mParameters.getAntibanding());
  mUnsupportedHFRVideoSize=false;
  mUnsupportedHFRVideoCodec=false;
  mUnsupportedHSRVideoSize=false;
  String yv12formatset=SystemProperties.get(""String_Node_Str"");
  if (yv12formatset.equals(""String_Node_Str"")) {
    Log.v(TAG,""String_Node_Str"");
    mParameters.setPreviewFormat(ImageFormat.YV12);
  }
  mParameters.set(KEY_PREVIEW_FORMAT,FORMAT_NV21);
  Log.v(TAG,""String_Node_Str"");
  String HighFrameRate=mPreferences.getString(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,mActivity.getString(R.string.pref_camera_hfr_default));
  if ((""String_Node_Str"".equals(HighFrameRate.substring(0,3))) || (""String_Node_Str"".equals(HighFrameRate.substring(0,3)))) {
    String hfrRate=HighFrameRate.substring(3);
    if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
      mUnsupportedHFRVideoSize=true;
    }
 else {
      mUnsupportedHSRVideoSize=true;
    }
    String hfrsize=videoWidth + ""String_Node_Str"" + videoHeight;
    Log.v(TAG,""String_Node_Str"" + hfrsize);
    try {
      Size size=null;
      if (isSupported(hfrRate,mParameters.getSupportedVideoHighFrameRateModes())) {
        int index=mParameters.getSupportedVideoHighFrameRateModes().indexOf(hfrRate);
        size=mParameters.getSupportedHfrSizes().get(index);
      }
      if (size != null) {
        if (videoWidth <= size.width && videoHeight <= size.height) {
          if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
            mUnsupportedHFRVideoSize=false;
          }
 else {
            mUnsupportedHSRVideoSize=false;
          }
          Log.v(TAG,""String_Node_Str"");
        }
      }
    }
 catch (    NullPointerException e) {
      Log.e(TAG,""String_Node_Str"");
    }
    int hfrFps=Integer.parseInt(hfrRate);
    int inputBitrate=videoWidth * videoHeight * hfrFps;
    List<VideoEncoderCap> videoEncoders=EncoderCapabilities.getVideoEncoders();
    for (    VideoEncoderCap videoEncoder : videoEncoders) {
      if (videoEncoder.mCodec == mVideoEncoder) {
        int maxBitrate=(videoEncoder.mMaxHFRFrameWidth * videoEncoder.mMaxHFRFrameHeight * videoEncoder.mMaxHFRMode);
        if (inputBitrate > maxBitrate) {
          Log.e(TAG,""String_Node_Str"" + mVideoEncoder + ""String_Node_Str""+ HighFrameRate+ ""String_Node_Str""+ videoWidth+ ""String_Node_Str""+ videoHeight+ ""String_Node_Str"");
          Log.e(TAG,""String_Node_Str"" + ""String_Node_Str"" + videoEncoder.mMaxHFRFrameWidth + ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxHFRFrameHeight+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxHFRMode);
          if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
            mUnsupportedHFRVideoSize=true;
          }
 else {
            mUnsupportedHSRVideoSize=true;
          }
        }
        break;
      }
    }
    if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
      mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      if (mUnsupportedHFRVideoSize) {
        mParameters.setVideoHighFrameRate(""String_Node_Str"");
        Log.v(TAG,""String_Node_Str"");
      }
 else {
        mParameters.setVideoHighFrameRate(hfrRate);
      }
    }
 else {
      mParameters.setVideoHighFrameRate(""String_Node_Str"");
      if (mUnsupportedHSRVideoSize) {
        Log.v(TAG,""String_Node_Str"");
        mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      }
 else {
        mParameters.set(CameraSettings.KEY_VIDEO_HSR,hfrRate);
      }
    }
    if (mVideoEncoder != MediaRecorder.VideoEncoder.H264) {
      mUnsupportedHFRVideoCodec=true;
    }
  }
 else {
    mParameters.setVideoHighFrameRate(""String_Node_Str"");
    mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
  }
  setFlipValue();
  String video_cds=mPreferences.getString(CameraSettings.KEY_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_default));
  if ((mPrevSavedVideoCDS == null) && (video_cds != null)) {
    mPrevSavedVideoCDS=video_cds;
  }
  if (mOverrideCDS) {
    video_cds=mPrevSavedVideoCDS;
    mOverrideCDS=false;
  }
  if (CameraUtil.isSupported(video_cds,CameraSettings.getSupportedVideoCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,video_cds);
  }
  String video_tnr=mPreferences.getString(CameraSettings.KEY_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_default));
  if (CameraUtil.isSupported(video_tnr,CameraSettings.getSupportedVideoTNRModes(mParameters))) {
    if (!video_tnr.equals(mActivity.getString(R.string.pref_camera_video_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
      mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
      if (!mIsVideoCDSUpdated) {
        if (video_cds != null) {
          mPrevSavedVideoCDS=mTempVideoCDS;
        }
        mIsVideoTNREnabled=true;
        mIsVideoCDSUpdated=true;
      }
    }
 else     if (mIsVideoTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mPrevSavedVideoCDS);
      mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mPrevSavedVideoCDS);
      mIsVideoTNREnabled=false;
      mIsVideoCDSUpdated=false;
      mOverrideCDS=true;
    }
 else {
      mTempVideoCDS=video_cds;
    }
    mParameters.set(CameraSettings.KEY_QC_VIDEO_TNR_MODE,video_tnr);
    mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_TNR_MODE,video_tnr);
  }
  String seeMoreMode=mPreferences.getString(CameraSettings.KEY_SEE_MORE,mActivity.getString(R.string.pref_camera_see_more_default));
  Log.v(TAG,""String_Node_Str"" + seeMoreMode);
  if (isSupported(seeMoreMode,CameraSettings.getSupportedSeeMoreModes(mParameters))) {
    if (is4KEnabled() && seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on))) {
      mParameters.set(CameraSettings.KEY_QC_SEE_MORE_MODE,mActivity.getString(R.string.pref_camera_see_more_value_off));
      mUI.overrideSettings(CameraSettings.KEY_SEE_MORE,mActivity.getString(R.string.pref_camera_see_more_value_off));
      Toast.makeText(mActivity,R.string.video_quality_4k_disable_SeeMore,Toast.LENGTH_LONG).show();
    }
 else {
      if (seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on)) && video_cds.equals(mActivity.getString(R.string.pref_camera_video_cds_value_on))) {
        mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
        mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
        Toast.makeText(mActivity,R.string.disable_CDS_during_SeeMore,Toast.LENGTH_LONG).show();
      }
      if (seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on)) && video_tnr.equals(mActivity.getString(R.string.pref_camera_video_tnr_value_on))) {
        mParameters.set(CameraSettings.KEY_QC_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_value_off));
        mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_value_off));
        Toast.makeText(mActivity,R.string.disable_TNR_during_SeeMore,Toast.LENGTH_LONG).show();
      }
      mParameters.set(CameraSettings.KEY_QC_SEE_MORE_MODE,seeMoreMode);
    }
  }
  String videoHDR=mPreferences.getString(CameraSettings.KEY_VIDEO_HDR,mActivity.getString(R.string.pref_camera_video_hdr_default));
  Log.v(TAG,""String_Node_Str"" + videoHDR);
  if (isSupported(videoHDR,mParameters.getSupportedVideoHDRModes())) {
    mParameters.setVideoHDRMode(videoHDR);
  }
 else   mParameters.setVideoHDRMode(""String_Node_Str"");
  String hfr=mParameters.getVideoHighFrameRate();
  String hsr=mParameters.get(CameraSettings.KEY_VIDEO_HSR);
  String hdr=mParameters.getVideoHDRMode();
  if (((hfr != null) && (!hfr.equals(""String_Node_Str""))) || ((hsr != null) && (!hsr.equals(""String_Node_Str"")))) {
    String frameIntervalStr=mPreferences.getString(CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL,mActivity.getString(R.string.pref_video_time_lapse_frame_interval_default));
    int timeLapseInterval=Integer.parseInt(frameIntervalStr);
    if ((timeLapseInterval != 0) || (disMode.equals(""String_Node_Str"")) || ((hdr != null) && (!hdr.equals(""String_Node_Str"")))) {
      Log.v(TAG,""String_Node_Str"");
      mParameters.setVideoHighFrameRate(""String_Node_Str"");
      mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      mUI.overrideSettings(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,""String_Node_Str"");
    }
  }
  Size biggestSize=mParameters.getSupportedPictureSizes().get(0);
  if (biggestSize.width <= videoWidth || biggestSize.height <= videoHeight) {
    if (disMode.equals(""String_Node_Str"")) {
      Log.v(TAG,""String_Node_Str"");
      RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_dis,Toast.LENGTH_LONG).show();
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,""String_Node_Str"");
      mUI.overrideSettings(CameraSettings.KEY_DIS,""String_Node_Str"");
      mIsDISEnabled=false;
    }
  }
  String videoRotation=mPreferences.getString(CameraSettings.KEY_VIDEO_ROTATION,mActivity.getString(R.string.pref_camera_video_rotation_default));
  if (isSupported(videoRotation,mParameters.getSupportedVideoRotationValues())) {
    mParameters.setVideoRotation(videoRotation);
  }
  updatePowerMode();
}","The original code unnecessarily displayed a toast message when 4K was enabled, which could disrupt user experience. The fixed code removes the redundant toast notification while maintaining the core logic of disabling certain camera features during 4K mode. This streamlines the camera parameter setting process, providing a cleaner and more focused user interaction without compromising the underlying functionality of camera settings."
38245,"public boolean isOverPreviewMenu(MotionEvent ev){
  if (mPreviewMenuStatus != PREVIEW_MENU_ON)   return false;
  if (mUI.getPreviewMenuLayout() == null)   return false;
  Rect rec=new Rect();
  mUI.getPreviewMenuLayout().getChildAt(0).getHitRect(rec);
  rec.top+=(int)mUI.getPreviewMenuLayout().getY();
  rec.bottom+=(int)mUI.getPreviewMenuLayout().getY();
  return rec.contains((int)ev.getX(),(int)ev.getY());
}","public boolean isOverPreviewMenu(MotionEvent ev){
  if (mPreviewMenuStatus != PREVIEW_MENU_ON)   return false;
  if (mUI.getPreviewMenuLayout() == null)   return false;
  Rect rec=new Rect();
  mUI.getPreviewMenuLayout().getChildAt(0).getHitRect(rec);
  if (View.LAYOUT_DIRECTION_RTL == TextUtils.getLayoutDirectionFromLocale(Locale.getDefault())) {
    rec.left=mUI.getRootView().getWidth() - (rec.right - rec.left);
    rec.right=mUI.getRootView().getWidth();
  }
  rec.top+=(int)mUI.getPreviewMenuLayout().getY();
  rec.bottom+=(int)mUI.getPreviewMenuLayout().getY();
  return rec.contains((int)ev.getX(),(int)ev.getY());
}","The original code fails to handle right-to-left (RTL) language layouts, potentially causing incorrect touch event detection for preview menus. The fixed code adds a specific adjustment for RTL layouts by calculating the correct left and right bounds based on the root view's width, ensuring accurate positioning. This modification makes the touch detection more robust across different language and layout directions, improving the overall user interaction reliability."
38246,"private void qcomSetCameraParameters(){
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String disMode=mPreferences.getString(CameraSettings.KEY_DIS,mActivity.getString(R.string.pref_camera_dis_default));
  Log.v(TAG,""String_Node_Str"" + disMode);
  mIsDISEnabled=disMode.equals(""String_Node_Str"");
  if (is4KEnabled()) {
    if (isSupported(mActivity.getString(R.string.pref_camera_dis_value_disable),CameraSettings.getSupportedDISModes(mParameters))) {
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,mActivity.getString(R.string.pref_camera_dis_value_disable));
      mUI.overrideSettings(CameraSettings.KEY_DIS,mActivity.getString(R.string.pref_camera_dis_value_disable));
      RotateTextToast.makeText(mActivity,R.string.video_quality_4k_disable_IS,Toast.LENGTH_LONG).show();
    }
 else {
      Log.e(TAG,""String_Node_Str"" + mActivity.getString(R.string.pref_camera_dis_value_disable));
    }
  }
 else {
    if (isSupported(disMode,CameraSettings.getSupportedDISModes(mParameters))) {
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,disMode);
    }
 else {
      Log.e(TAG,""String_Node_Str"" + disMode);
    }
  }
  if (mDefaultAntibanding == null) {
    mDefaultAntibanding=mParameters.getAntibanding();
    Log.d(TAG,""String_Node_Str"" + mDefaultAntibanding);
  }
  if (disMode.equals(""String_Node_Str"")) {
    Log.d(TAG,""String_Node_Str"");
    if (isSupported(Parameters.ANTIBANDING_AUTO,mParameters.getSupportedAntibanding())) {
      mParameters.setAntibanding(Parameters.ANTIBANDING_AUTO);
    }
  }
 else {
    if (isSupported(mDefaultAntibanding,mParameters.getSupportedAntibanding())) {
      mParameters.setAntibanding(mDefaultAntibanding);
    }
  }
  Log.d(TAG,""String_Node_Str"" + mParameters.getAntibanding());
  mUnsupportedHFRVideoSize=false;
  mUnsupportedHFRVideoCodec=false;
  mUnsupportedHSRVideoSize=false;
  String yv12formatset=SystemProperties.get(""String_Node_Str"");
  if (yv12formatset.equals(""String_Node_Str"")) {
    Log.v(TAG,""String_Node_Str"");
    mParameters.setPreviewFormat(ImageFormat.YV12);
  }
  mParameters.set(KEY_PREVIEW_FORMAT,FORMAT_NV21);
  Log.v(TAG,""String_Node_Str"");
  String HighFrameRate=mPreferences.getString(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,mActivity.getString(R.string.pref_camera_hfr_default));
  if ((""String_Node_Str"".equals(HighFrameRate.substring(0,3))) || (""String_Node_Str"".equals(HighFrameRate.substring(0,3)))) {
    String hfrRate=HighFrameRate.substring(3);
    if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
      mUnsupportedHFRVideoSize=true;
    }
 else {
      mUnsupportedHSRVideoSize=true;
    }
    String hfrsize=videoWidth + ""String_Node_Str"" + videoHeight;
    Log.v(TAG,""String_Node_Str"" + hfrsize);
    try {
      Size size=null;
      if (isSupported(hfrRate,mParameters.getSupportedVideoHighFrameRateModes())) {
        int index=mParameters.getSupportedVideoHighFrameRateModes().indexOf(hfrRate);
        size=mParameters.getSupportedHfrSizes().get(index);
      }
      if (size != null) {
        if (videoWidth <= size.width && videoHeight <= size.height) {
          if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
            mUnsupportedHFRVideoSize=false;
          }
 else {
            mUnsupportedHSRVideoSize=false;
          }
          Log.v(TAG,""String_Node_Str"");
        }
      }
    }
 catch (    NullPointerException e) {
      Log.e(TAG,""String_Node_Str"");
    }
    int hfrFps=Integer.parseInt(hfrRate);
    int inputBitrate=videoWidth * videoHeight * hfrFps;
    List<VideoEncoderCap> videoEncoders=EncoderCapabilities.getVideoEncoders();
    for (    VideoEncoderCap videoEncoder : videoEncoders) {
      if (videoEncoder.mCodec == mVideoEncoder) {
        int maxBitrate=(videoEncoder.mMaxHFRFrameWidth * videoEncoder.mMaxHFRFrameHeight * videoEncoder.mMaxHFRMode);
        if (inputBitrate > maxBitrate) {
          Log.e(TAG,""String_Node_Str"" + mVideoEncoder + ""String_Node_Str""+ HighFrameRate+ ""String_Node_Str""+ videoWidth+ ""String_Node_Str""+ videoHeight+ ""String_Node_Str"");
          Log.e(TAG,""String_Node_Str"" + ""String_Node_Str"" + videoEncoder.mMaxHFRFrameWidth + ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxHFRFrameHeight+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxHFRMode);
          if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
            mUnsupportedHFRVideoSize=true;
          }
 else {
            mUnsupportedHSRVideoSize=true;
          }
        }
        break;
      }
    }
    if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
      mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      if (mUnsupportedHFRVideoSize) {
        mParameters.setVideoHighFrameRate(""String_Node_Str"");
        Log.v(TAG,""String_Node_Str"");
      }
 else {
        mParameters.setVideoHighFrameRate(hfrRate);
      }
    }
 else {
      mParameters.setVideoHighFrameRate(""String_Node_Str"");
      if (mUnsupportedHSRVideoSize) {
        Log.v(TAG,""String_Node_Str"");
        mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      }
 else {
        mParameters.set(CameraSettings.KEY_VIDEO_HSR,hfrRate);
      }
    }
    if (mVideoEncoder != MediaRecorder.VideoEncoder.H264) {
      mUnsupportedHFRVideoCodec=true;
    }
  }
 else {
    mParameters.setVideoHighFrameRate(""String_Node_Str"");
    mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
  }
  setFlipValue();
  String video_cds=mPreferences.getString(CameraSettings.KEY_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_default));
  if ((mPrevSavedVideoCDS == null) && (video_cds != null)) {
    mPrevSavedVideoCDS=video_cds;
  }
  if (mOverrideCDS) {
    video_cds=mPrevSavedVideoCDS;
    mOverrideCDS=false;
  }
  if (CameraUtil.isSupported(video_cds,CameraSettings.getSupportedVideoCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,video_cds);
  }
  String video_tnr=mPreferences.getString(CameraSettings.KEY_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_default));
  if (CameraUtil.isSupported(video_tnr,CameraSettings.getSupportedVideoTNRModes(mParameters))) {
    if (!video_tnr.equals(mActivity.getString(R.string.pref_camera_video_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
      mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
      if (!mIsVideoCDSUpdated) {
        if (video_cds != null) {
          mPrevSavedVideoCDS=mTempVideoCDS;
        }
        mIsVideoTNREnabled=true;
        mIsVideoCDSUpdated=true;
      }
    }
 else     if (mIsVideoTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mPrevSavedVideoCDS);
      mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mPrevSavedVideoCDS);
      mIsVideoTNREnabled=false;
      mIsVideoCDSUpdated=false;
      mOverrideCDS=true;
    }
 else {
      mTempVideoCDS=video_cds;
    }
    mParameters.set(CameraSettings.KEY_QC_VIDEO_TNR_MODE,video_tnr);
    mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_TNR_MODE,video_tnr);
  }
  String seeMoreMode=mPreferences.getString(CameraSettings.KEY_SEE_MORE,mActivity.getString(R.string.pref_camera_see_more_default));
  Log.v(TAG,""String_Node_Str"" + seeMoreMode);
  if (isSupported(seeMoreMode,CameraSettings.getSupportedSeeMoreModes(mParameters))) {
    if (is4KEnabled() && seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on))) {
      mParameters.set(CameraSettings.KEY_QC_SEE_MORE_MODE,mActivity.getString(R.string.pref_camera_see_more_value_off));
      mUI.overrideSettings(CameraSettings.KEY_SEE_MORE,mActivity.getString(R.string.pref_camera_see_more_value_off));
      Toast.makeText(mActivity,R.string.video_quality_4k_disable_SeeMore,Toast.LENGTH_LONG).show();
    }
 else {
      if (seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on)) && video_cds.equals(mActivity.getString(R.string.pref_camera_video_cds_value_on))) {
        mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
        mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
        Toast.makeText(mActivity,R.string.disable_CDS_during_SeeMore,Toast.LENGTH_LONG).show();
      }
      if (seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on)) && video_tnr.equals(mActivity.getString(R.string.pref_camera_video_tnr_value_on))) {
        mParameters.set(CameraSettings.KEY_QC_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_value_off));
        mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_value_off));
        Toast.makeText(mActivity,R.string.disable_TNR_during_SeeMore,Toast.LENGTH_LONG).show();
      }
      mParameters.set(CameraSettings.KEY_QC_SEE_MORE_MODE,seeMoreMode);
    }
  }
  String videoHDR=mPreferences.getString(CameraSettings.KEY_VIDEO_HDR,mActivity.getString(R.string.pref_camera_video_hdr_default));
  Log.v(TAG,""String_Node_Str"" + videoHDR);
  if (isSupported(videoHDR,mParameters.getSupportedVideoHDRModes())) {
    mParameters.setVideoHDRMode(videoHDR);
  }
 else   mParameters.setVideoHDRMode(""String_Node_Str"");
  String hfr=mParameters.getVideoHighFrameRate();
  String hsr=mParameters.get(CameraSettings.KEY_VIDEO_HSR);
  String hdr=mParameters.getVideoHDRMode();
  if (((hfr != null) && (!hfr.equals(""String_Node_Str""))) || ((hsr != null) && (!hsr.equals(""String_Node_Str"")))) {
    String frameIntervalStr=mPreferences.getString(CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL,mActivity.getString(R.string.pref_video_time_lapse_frame_interval_default));
    int timeLapseInterval=Integer.parseInt(frameIntervalStr);
    if ((timeLapseInterval != 0) || (disMode.equals(""String_Node_Str"")) || ((hdr != null) && (!hdr.equals(""String_Node_Str"")))) {
      Log.v(TAG,""String_Node_Str"");
      mParameters.setVideoHighFrameRate(""String_Node_Str"");
      mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      mUI.overrideSettings(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,""String_Node_Str"");
    }
  }
  Size biggestSize=mParameters.getSupportedPictureSizes().get(0);
  if (biggestSize.width <= videoWidth || biggestSize.height <= videoHeight) {
    if (disMode.equals(""String_Node_Str"")) {
      Log.v(TAG,""String_Node_Str"");
      RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_dis,Toast.LENGTH_LONG).show();
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,""String_Node_Str"");
      mUI.overrideSettings(CameraSettings.KEY_DIS,""String_Node_Str"");
      mIsDISEnabled=false;
    }
  }
  String videoRotation=mPreferences.getString(CameraSettings.KEY_VIDEO_ROTATION,mActivity.getString(R.string.pref_camera_video_rotation_default));
  if (isSupported(videoRotation,mParameters.getSupportedVideoRotationValues())) {
    mParameters.setVideoRotation(videoRotation);
  }
  updatePowerMode();
}","private void qcomSetCameraParameters(){
  String colorEffect=mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT,mActivity.getString(R.string.pref_camera_coloreffect_default));
  Log.v(TAG,""String_Node_Str"" + colorEffect);
  if (isSupported(colorEffect,mParameters.getSupportedColorEffects())) {
    mParameters.setColorEffect(colorEffect);
  }
  String disMode=mPreferences.getString(CameraSettings.KEY_DIS,mActivity.getString(R.string.pref_camera_dis_default));
  Log.v(TAG,""String_Node_Str"" + disMode);
  mIsDISEnabled=disMode.equals(""String_Node_Str"");
  if (is4KEnabled()) {
    if (isSupported(mActivity.getString(R.string.pref_camera_dis_value_disable),CameraSettings.getSupportedDISModes(mParameters))) {
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,mActivity.getString(R.string.pref_camera_dis_value_disable));
      mUI.overrideSettings(CameraSettings.KEY_DIS,mActivity.getString(R.string.pref_camera_dis_value_disable));
    }
 else {
      Log.e(TAG,""String_Node_Str"" + mActivity.getString(R.string.pref_camera_dis_value_disable));
    }
  }
 else {
    if (isSupported(disMode,CameraSettings.getSupportedDISModes(mParameters))) {
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,disMode);
    }
 else {
      Log.e(TAG,""String_Node_Str"" + disMode);
    }
  }
  if (mDefaultAntibanding == null) {
    mDefaultAntibanding=mParameters.getAntibanding();
    Log.d(TAG,""String_Node_Str"" + mDefaultAntibanding);
  }
  if (disMode.equals(""String_Node_Str"")) {
    Log.d(TAG,""String_Node_Str"");
    if (isSupported(Parameters.ANTIBANDING_AUTO,mParameters.getSupportedAntibanding())) {
      mParameters.setAntibanding(Parameters.ANTIBANDING_AUTO);
    }
  }
 else {
    if (isSupported(mDefaultAntibanding,mParameters.getSupportedAntibanding())) {
      mParameters.setAntibanding(mDefaultAntibanding);
    }
  }
  Log.d(TAG,""String_Node_Str"" + mParameters.getAntibanding());
  mUnsupportedHFRVideoSize=false;
  mUnsupportedHFRVideoCodec=false;
  mUnsupportedHSRVideoSize=false;
  String yv12formatset=SystemProperties.get(""String_Node_Str"");
  if (yv12formatset.equals(""String_Node_Str"")) {
    Log.v(TAG,""String_Node_Str"");
    mParameters.setPreviewFormat(ImageFormat.YV12);
  }
  mParameters.set(KEY_PREVIEW_FORMAT,FORMAT_NV21);
  Log.v(TAG,""String_Node_Str"");
  String HighFrameRate=mPreferences.getString(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,mActivity.getString(R.string.pref_camera_hfr_default));
  if ((""String_Node_Str"".equals(HighFrameRate.substring(0,3))) || (""String_Node_Str"".equals(HighFrameRate.substring(0,3)))) {
    String hfrRate=HighFrameRate.substring(3);
    if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
      mUnsupportedHFRVideoSize=true;
    }
 else {
      mUnsupportedHSRVideoSize=true;
    }
    String hfrsize=videoWidth + ""String_Node_Str"" + videoHeight;
    Log.v(TAG,""String_Node_Str"" + hfrsize);
    try {
      Size size=null;
      if (isSupported(hfrRate,mParameters.getSupportedVideoHighFrameRateModes())) {
        int index=mParameters.getSupportedVideoHighFrameRateModes().indexOf(hfrRate);
        size=mParameters.getSupportedHfrSizes().get(index);
      }
      if (size != null) {
        if (videoWidth <= size.width && videoHeight <= size.height) {
          if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
            mUnsupportedHFRVideoSize=false;
          }
 else {
            mUnsupportedHSRVideoSize=false;
          }
          Log.v(TAG,""String_Node_Str"");
        }
      }
    }
 catch (    NullPointerException e) {
      Log.e(TAG,""String_Node_Str"");
    }
    int hfrFps=Integer.parseInt(hfrRate);
    int inputBitrate=videoWidth * videoHeight * hfrFps;
    List<VideoEncoderCap> videoEncoders=EncoderCapabilities.getVideoEncoders();
    for (    VideoEncoderCap videoEncoder : videoEncoders) {
      if (videoEncoder.mCodec == mVideoEncoder) {
        int maxBitrate=(videoEncoder.mMaxHFRFrameWidth * videoEncoder.mMaxHFRFrameHeight * videoEncoder.mMaxHFRMode);
        if (inputBitrate > maxBitrate) {
          Log.e(TAG,""String_Node_Str"" + mVideoEncoder + ""String_Node_Str""+ HighFrameRate+ ""String_Node_Str""+ videoWidth+ ""String_Node_Str""+ videoHeight+ ""String_Node_Str"");
          Log.e(TAG,""String_Node_Str"" + ""String_Node_Str"" + videoEncoder.mMaxHFRFrameWidth + ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxHFRFrameHeight+ ""String_Node_Str""+ ""String_Node_Str""+ videoEncoder.mMaxHFRMode);
          if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
            mUnsupportedHFRVideoSize=true;
          }
 else {
            mUnsupportedHSRVideoSize=true;
          }
        }
        break;
      }
    }
    if (""String_Node_Str"".equals(HighFrameRate.substring(0,3))) {
      mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      if (mUnsupportedHFRVideoSize) {
        mParameters.setVideoHighFrameRate(""String_Node_Str"");
        Log.v(TAG,""String_Node_Str"");
      }
 else {
        mParameters.setVideoHighFrameRate(hfrRate);
      }
    }
 else {
      mParameters.setVideoHighFrameRate(""String_Node_Str"");
      if (mUnsupportedHSRVideoSize) {
        Log.v(TAG,""String_Node_Str"");
        mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      }
 else {
        mParameters.set(CameraSettings.KEY_VIDEO_HSR,hfrRate);
      }
    }
    if (mVideoEncoder != MediaRecorder.VideoEncoder.H264) {
      mUnsupportedHFRVideoCodec=true;
    }
  }
 else {
    mParameters.setVideoHighFrameRate(""String_Node_Str"");
    mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
  }
  setFlipValue();
  String video_cds=mPreferences.getString(CameraSettings.KEY_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_default));
  if ((mPrevSavedVideoCDS == null) && (video_cds != null)) {
    mPrevSavedVideoCDS=video_cds;
  }
  if (mOverrideCDS) {
    video_cds=mPrevSavedVideoCDS;
    mOverrideCDS=false;
  }
  if (CameraUtil.isSupported(video_cds,CameraSettings.getSupportedVideoCDSModes(mParameters))) {
    mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,video_cds);
  }
  String video_tnr=mPreferences.getString(CameraSettings.KEY_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_default));
  if (CameraUtil.isSupported(video_tnr,CameraSettings.getSupportedVideoTNRModes(mParameters))) {
    if (!video_tnr.equals(mActivity.getString(R.string.pref_camera_video_tnr_value_off))) {
      mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
      mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
      if (!mIsVideoCDSUpdated) {
        if (video_cds != null) {
          mPrevSavedVideoCDS=mTempVideoCDS;
        }
        mIsVideoTNREnabled=true;
        mIsVideoCDSUpdated=true;
      }
    }
 else     if (mIsVideoTNREnabled) {
      mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mPrevSavedVideoCDS);
      mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mPrevSavedVideoCDS);
      mIsVideoTNREnabled=false;
      mIsVideoCDSUpdated=false;
      mOverrideCDS=true;
    }
 else {
      mTempVideoCDS=video_cds;
    }
    mParameters.set(CameraSettings.KEY_QC_VIDEO_TNR_MODE,video_tnr);
    mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_TNR_MODE,video_tnr);
  }
  String seeMoreMode=mPreferences.getString(CameraSettings.KEY_SEE_MORE,mActivity.getString(R.string.pref_camera_see_more_default));
  Log.v(TAG,""String_Node_Str"" + seeMoreMode);
  if (isSupported(seeMoreMode,CameraSettings.getSupportedSeeMoreModes(mParameters))) {
    if (is4KEnabled() && seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on))) {
      mParameters.set(CameraSettings.KEY_QC_SEE_MORE_MODE,mActivity.getString(R.string.pref_camera_see_more_value_off));
      mUI.overrideSettings(CameraSettings.KEY_SEE_MORE,mActivity.getString(R.string.pref_camera_see_more_value_off));
      Toast.makeText(mActivity,R.string.video_quality_4k_disable_SeeMore,Toast.LENGTH_LONG).show();
    }
 else {
      if (seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on)) && video_cds.equals(mActivity.getString(R.string.pref_camera_video_cds_value_on))) {
        mParameters.set(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
        mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_CDS_MODE,mActivity.getString(R.string.pref_camera_video_cds_value_off));
        Toast.makeText(mActivity,R.string.disable_CDS_during_SeeMore,Toast.LENGTH_LONG).show();
      }
      if (seeMoreMode.equals(mActivity.getString(R.string.pref_camera_see_more_value_on)) && video_tnr.equals(mActivity.getString(R.string.pref_camera_video_tnr_value_on))) {
        mParameters.set(CameraSettings.KEY_QC_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_value_off));
        mUI.overrideSettings(CameraSettings.KEY_QC_VIDEO_TNR_MODE,mActivity.getString(R.string.pref_camera_video_tnr_value_off));
        Toast.makeText(mActivity,R.string.disable_TNR_during_SeeMore,Toast.LENGTH_LONG).show();
      }
      mParameters.set(CameraSettings.KEY_QC_SEE_MORE_MODE,seeMoreMode);
    }
  }
  String videoHDR=mPreferences.getString(CameraSettings.KEY_VIDEO_HDR,mActivity.getString(R.string.pref_camera_video_hdr_default));
  Log.v(TAG,""String_Node_Str"" + videoHDR);
  if (isSupported(videoHDR,mParameters.getSupportedVideoHDRModes())) {
    mParameters.setVideoHDRMode(videoHDR);
  }
 else   mParameters.setVideoHDRMode(""String_Node_Str"");
  String hfr=mParameters.getVideoHighFrameRate();
  String hsr=mParameters.get(CameraSettings.KEY_VIDEO_HSR);
  String hdr=mParameters.getVideoHDRMode();
  if (((hfr != null) && (!hfr.equals(""String_Node_Str""))) || ((hsr != null) && (!hsr.equals(""String_Node_Str"")))) {
    String frameIntervalStr=mPreferences.getString(CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL,mActivity.getString(R.string.pref_video_time_lapse_frame_interval_default));
    int timeLapseInterval=Integer.parseInt(frameIntervalStr);
    if ((timeLapseInterval != 0) || (disMode.equals(""String_Node_Str"")) || ((hdr != null) && (!hdr.equals(""String_Node_Str"")))) {
      Log.v(TAG,""String_Node_Str"");
      mParameters.setVideoHighFrameRate(""String_Node_Str"");
      mParameters.set(CameraSettings.KEY_VIDEO_HSR,""String_Node_Str"");
      mUI.overrideSettings(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,""String_Node_Str"");
    }
  }
  Size biggestSize=mParameters.getSupportedPictureSizes().get(0);
  if (biggestSize.width <= videoWidth || biggestSize.height <= videoHeight) {
    if (disMode.equals(""String_Node_Str"")) {
      Log.v(TAG,""String_Node_Str"");
      RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_dis,Toast.LENGTH_LONG).show();
      mParameters.set(CameraSettings.KEY_QC_DIS_MODE,""String_Node_Str"");
      mUI.overrideSettings(CameraSettings.KEY_DIS,""String_Node_Str"");
      mIsDISEnabled=false;
    }
  }
  String videoRotation=mPreferences.getString(CameraSettings.KEY_VIDEO_ROTATION,mActivity.getString(R.string.pref_camera_video_rotation_default));
  if (isSupported(videoRotation,mParameters.getSupportedVideoRotationValues())) {
    mParameters.setVideoRotation(videoRotation);
  }
  updatePowerMode();
}","The original code unnecessarily displayed a toast message when 4K was enabled, potentially disrupting user experience. The fixed code removes the redundant toast notification while maintaining the core logic of disabling certain camera features during 4K mode. This improvement streamlines the camera parameter setting process, providing a cleaner and more focused user interaction without losing the essential functionality of feature management."
38247,"@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    int dx=(getWidth() - rw) / 2;
    ;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].score < 50)       continue;
      mRect.set(mFaces[i].rect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      canvas.drawOval(mRect,mPaint);
      if (mFaces[i] instanceof ExtendedFace) {
        ExtendedFace face=(ExtendedFace)mFaces[i];
        float[] point=new float[4];
        int delta_x=mFaces[i].rect.width() / 12;
        int delta_y=mFaces[i].rect.height() / 12;
        Log.e(TAG,""String_Node_Str"" + face.getLeftEyeBlinkDegree() + ""String_Node_Str""+ face.getRightEyeBlinkDegree()+ ""String_Node_Str"");
        if (face.leftEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.leftEye.x;
            point[1]=face.leftEye.y - delta_y / 2;
            point[2]=face.leftEye.x;
            point[3]=face.leftEye.y + delta_y / 2;
          }
 else {
            point[0]=face.leftEye.x - delta_x / 2;
            point[1]=face.leftEye.y;
            point[2]=face.leftEye.x + delta_x / 2;
            point[3]=face.leftEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getLeftEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.rightEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.rightEye.x;
            point[1]=face.rightEye.y - delta_y / 2;
            point[2]=face.rightEye.x;
            point[3]=face.rightEye.y + delta_y / 2;
          }
 else {
            point[0]=face.rightEye.x - delta_x / 2;
            point[1]=face.rightEye.y;
            point[2]=face.rightEye.x + delta_x / 2;
            point[3]=face.rightEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getRightEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getLeftRightGazeDegree() != 0 || face.getTopBottomGazeDegree() != 0) {
          double length=Math.sqrt((face.leftEye.x - face.rightEye.x) * (face.leftEye.x - face.rightEye.x) + (face.leftEye.y - face.rightEye.y) * (face.leftEye.y - face.rightEye.y)) / 2.0;
          double nGazeYaw=-face.getLeftRightGazeDegree();
          double nGazePitch=-face.getTopBottomGazeDegree();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (face.getLeftEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollX;
              point[3]=face.leftEye.y + gazeRollY;
            }
 else {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollY;
              point[3]=face.leftEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (face.getRightEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollX;
              point[3]=face.rightEye.y + gazeRollY;
            }
 else {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollY;
              point[3]=face.rightEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.mouth != null) {
          Log.e(TAG,""String_Node_Str"" + face.getSmileDegree() + ""String_Node_Str""+ face.getSmileScore());
          if (face.getSmileDegree() < smile_threashold_no_smile) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.mouth.x + dx - delta_x;
              point[1]=face.mouth.y;
              point[2]=face.mouth.x + dx + delta_x;
              point[3]=face.mouth.y;
            }
 else {
              point[0]=face.mouth.x;
              point[1]=face.mouth.y + dy - delta_y;
              point[2]=face.mouth.x;
              point[3]=face.mouth.y + dy + delta_y;
            }
            Matrix faceMatrix=new Matrix(mMatrix);
            faceMatrix.preRotate(face.getRollDirection(),face.mouth.x,face.mouth.y);
            faceMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (face.getSmileDegree() < smile_threashold_small_smile) {
            int rotation_mouth=360 - mDisplayRotation;
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,rotation_mouth,180,true,mPaint);
          }
 else {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    int dx=(getWidth() - rw) / 2;
    ;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].score < 50)       continue;
      mRect.set(mFaces[i].rect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      canvas.drawOval(mRect,mPaint);
      if (mFaces[i] instanceof ExtendedFace) {
        ExtendedFace face=(ExtendedFace)mFaces[i];
        float[] point=new float[4];
        int delta_x=mFaces[i].rect.width() / 12;
        int delta_y=mFaces[i].rect.height() / 12;
        Log.e(TAG,""String_Node_Str"" + face.getLeftEyeBlinkDegree() + ""String_Node_Str""+ face.getRightEyeBlinkDegree()+ ""String_Node_Str"");
        if (face.leftEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.leftEye.x;
            point[1]=face.leftEye.y - delta_y / 2;
            point[2]=face.leftEye.x;
            point[3]=face.leftEye.y + delta_y / 2;
          }
 else {
            point[0]=face.leftEye.x - delta_x / 2;
            point[1]=face.leftEye.y;
            point[2]=face.leftEye.x + delta_x / 2;
            point[3]=face.leftEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getLeftEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.rightEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.rightEye.x;
            point[1]=face.rightEye.y - delta_y / 2;
            point[2]=face.rightEye.x;
            point[3]=face.rightEye.y + delta_y / 2;
          }
 else {
            point[0]=face.rightEye.x - delta_x / 2;
            point[1]=face.rightEye.y;
            point[2]=face.rightEye.x + delta_x / 2;
            point[3]=face.rightEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getRightEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getLeftRightGazeDegree() != 0 || face.getTopBottomGazeDegree() != 0) {
          double length=Math.sqrt((face.leftEye.x - face.rightEye.x) * (face.leftEye.x - face.rightEye.x) + (face.leftEye.y - face.rightEye.y) * (face.leftEye.y - face.rightEye.y)) / 2.0;
          double nGazeYaw=-face.getLeftRightGazeDegree();
          double nGazePitch=-face.getTopBottomGazeDegree();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (face.getLeftEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollX;
              point[3]=face.leftEye.y + gazeRollY;
            }
 else {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollY;
              point[3]=face.leftEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (face.getRightEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollX;
              point[3]=face.rightEye.y + gazeRollY;
            }
 else {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollY;
              point[3]=face.rightEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.mouth != null) {
          Log.e(TAG,""String_Node_Str"" + face.getSmileDegree() + ""String_Node_Str""+ face.getSmileScore());
          if (face.getSmileDegree() < smile_threashold_no_smile) {
            point[0]=face.mouth.x + dx - delta_x;
            point[1]=face.mouth.y;
            point[2]=face.mouth.x + dx + delta_x;
            point[3]=face.mouth.y;
            Matrix faceMatrix=new Matrix(mMatrix);
            faceMatrix.preRotate(face.getRollDirection(),face.mouth.x,face.mouth.y);
            faceMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (face.getSmileDegree() < smile_threashold_small_smile) {
            int rotation_mouth=360 - mDisplayRotation;
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,rotation_mouth,180,true,mPaint);
          }
 else {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","The original code had inconsistent coordinate handling for mouth drawing, using different rotation logic based on display orientation. In the fixed code, the mouth drawing coordinates are simplified and standardized, removing orientation-specific conditional blocks and using a more uniform matrix transformation approach. This correction ensures more consistent and predictable face feature rendering across different device orientations, improving the overall reliability of the face detection visualization."
38248,"private void updateCameraSettings(){
  String sceneMode=null;
  String flashMode=null;
  String redeyeReduction=null;
  String aeBracketing=null;
  String focusMode=null;
  String colorEffect=null;
  String exposureCompensation=null;
  String touchAfAec=null;
  boolean disableLongShot=false;
  String ubiFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on);
  String continuousShotOn=mActivity.getString(R.string.setting_on_value);
  String reFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
  String chromaFlashOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on);
  String optiZoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  String fssrOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on);
  String truPortraitOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on);
  String multiTouchFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on);
  String optiZoom=mParameters.get(CameraSettings.KEY_QC_OPTI_ZOOM);
  String chromaFlash=mParameters.get(CameraSettings.KEY_QC_CHROMA_FLASH);
  String ubiFocus=mParameters.get(CameraSettings.KEY_QC_AF_BRACKETING);
  String fssr=mParameters.get(CameraSettings.KEY_QC_FSSR);
  String truePortrait=mParameters.get(CameraSettings.KEY_QC_TP);
  String multiTouchFocus=mParameters.get(CameraSettings.KEY_QC_MULTI_TOUCH_FOCUS);
  String stillMoreOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on);
  String stillMore=mParameters.get(CameraSettings.KEY_QC_STILL_MORE);
  String continuousShot=mParameters.get(""String_Node_Str"");
  if (mManual3AEnabled > 0) {
    disableLongShot=true;
  }
  if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  String reFocus=mParameters.get(CameraSettings.KEY_QC_RE_FOCUS);
  if (mFocusManager.isZslEnabled()) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  if ((multiTouchFocus != null && multiTouchFocus.equals(multiTouchFocusOn)) || (chromaFlash != null && chromaFlash.equals(chromaFlashOn)) || (optiZoom != null && optiZoom.equals(optiZoomOn))|| (fssr != null && fssr.equals(fssrOn))|| (truePortrait != null && truePortrait.equals(truPortraitOn))|| (stillMore != null && stillMore.equals(stillMoreOn))) {
    if (optiZoom != null && optiZoom.equals(optiZoomOn)) {
      sceneMode=null;
    }
 else {
      mSceneMode=sceneMode=Parameters.SCENE_MODE_AUTO;
    }
    flashMode=Parameters.FLASH_MODE_OFF;
    focusMode=Parameters.FOCUS_MODE_INFINITY;
    redeyeReduction=mActivity.getString(R.string.pref_camera_redeyereduction_entry_disable);
    aeBracketing=mActivity.getString(R.string.pref_camera_ae_bracket_hdr_entry_off);
    colorEffect=mActivity.getString(R.string.pref_camera_coloreffect_default);
    exposureCompensation=CameraSettings.EXPOSURE_DEFAULT_VALUE;
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    disableLongShot=true;
    RotateTextToast.makeText(mActivity,R.string.advanced_capture_disable_continuous_shot,Toast.LENGTH_LONG).show();
  }
  if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    flashMode=mParameters.FLASH_MODE_OFF;
    String whiteBalance=Parameters.WHITE_BALANCE_AUTO;
    focusMode=mFocusManager.getFocusMode();
    colorEffect=mParameters.getColorEffect();
    exposureCompensation=Integer.toString(mParameters.getExposureCompensation());
    touchAfAec=mCurrTouchAfAec;
    overrideCameraSettings(flashMode,whiteBalance,focusMode,exposureCompensation,touchAfAec,mParameters.getAutoExposure(),Integer.toString(mParameters.getSaturation()),Integer.toString(mParameters.getContrast()),Integer.toString(mParameters.getSharpness()),colorEffect,sceneMode,redeyeReduction,aeBracketing);
    if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
      disableLongShot=true;
    }
  }
 else   if (mFocusManager.isZslEnabled()) {
    focusMode=mParameters.getFocusMode();
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
  }
 else {
    if (mManual3AEnabled > 0) {
      updateCommonManual3ASettings();
    }
 else {
      overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    }
  }
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,fMode);
    mParameters.setFlashMode(fMode);
  }
  if (disableLongShot) {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.setting_off_value));
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,null);
  }
}","private void updateCameraSettings(){
  String sceneMode=null;
  String flashMode=null;
  String redeyeReduction=null;
  String aeBracketing=null;
  String focusMode=null;
  String colorEffect=null;
  String exposureCompensation=null;
  String touchAfAec=null;
  boolean disableLongShot=false;
  String ubiFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on);
  String continuousShotOn=mActivity.getString(R.string.setting_on_value);
  String reFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
  String chromaFlashOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on);
  String optiZoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  String fssrOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on);
  String truPortraitOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on);
  String multiTouchFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on);
  String optiZoom=mParameters.get(CameraSettings.KEY_QC_OPTI_ZOOM);
  String chromaFlash=mParameters.get(CameraSettings.KEY_QC_CHROMA_FLASH);
  String ubiFocus=mParameters.get(CameraSettings.KEY_QC_AF_BRACKETING);
  String fssr=mParameters.get(CameraSettings.KEY_QC_FSSR);
  String truePortrait=mParameters.get(CameraSettings.KEY_QC_TP);
  String multiTouchFocus=mParameters.get(CameraSettings.KEY_QC_MULTI_TOUCH_FOCUS);
  String stillMoreOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on);
  String stillMore=mParameters.get(CameraSettings.KEY_QC_STILL_MORE);
  String continuousShot=mParameters.get(""String_Node_Str"");
  if (mManual3AEnabled > 0) {
    disableLongShot=true;
  }
  if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  String reFocus=mParameters.get(CameraSettings.KEY_QC_RE_FOCUS);
  if (mFocusManager.isZslEnabled()) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  if ((multiTouchFocus != null && multiTouchFocus.equals(multiTouchFocusOn)) || (chromaFlash != null && chromaFlash.equals(chromaFlashOn)) || (optiZoom != null && optiZoom.equals(optiZoomOn))|| (fssr != null && fssr.equals(fssrOn))|| (truePortrait != null && truePortrait.equals(truPortraitOn))|| (stillMore != null && stillMore.equals(stillMoreOn))) {
    if (optiZoom != null && optiZoom.equals(optiZoomOn)) {
      sceneMode=null;
    }
 else {
      mSceneMode=sceneMode=Parameters.SCENE_MODE_AUTO;
    }
    flashMode=Parameters.FLASH_MODE_OFF;
    focusMode=Parameters.FOCUS_MODE_INFINITY;
    redeyeReduction=mActivity.getString(R.string.pref_camera_redeyereduction_entry_disable);
    aeBracketing=mActivity.getString(R.string.pref_camera_ae_bracket_hdr_entry_off);
    colorEffect=mActivity.getString(R.string.pref_camera_coloreffect_default);
    exposureCompensation=CameraSettings.EXPOSURE_DEFAULT_VALUE;
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    disableLongShot=true;
  }
  if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    flashMode=mParameters.FLASH_MODE_OFF;
    String whiteBalance=Parameters.WHITE_BALANCE_AUTO;
    focusMode=mFocusManager.getFocusMode();
    colorEffect=mParameters.getColorEffect();
    exposureCompensation=Integer.toString(mParameters.getExposureCompensation());
    touchAfAec=mCurrTouchAfAec;
    overrideCameraSettings(flashMode,whiteBalance,focusMode,exposureCompensation,touchAfAec,mParameters.getAutoExposure(),Integer.toString(mParameters.getSaturation()),Integer.toString(mParameters.getContrast()),Integer.toString(mParameters.getSharpness()),colorEffect,sceneMode,redeyeReduction,aeBracketing);
    if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
      disableLongShot=true;
    }
  }
 else   if (mFocusManager.isZslEnabled()) {
    focusMode=mParameters.getFocusMode();
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
  }
 else {
    if (mManual3AEnabled > 0) {
      updateCommonManual3ASettings();
    }
 else {
      overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    }
  }
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,fMode);
    mParameters.setFlashMode(fMode);
  }
  if (disableLongShot) {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.setting_off_value));
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,null);
  }
}","The original code lacked a toast message display when advanced capture features were disabled, potentially leaving users unaware of changes to camera settings. The fixed code removes the `RotateTextToast.makeText()` call, which was redundant and could interrupt user experience without adding meaningful information. By eliminating this unnecessary toast, the code maintains the same functional camera settings update while providing a cleaner, more streamlined user interaction."
38249,"private void saveVideo(){
  if (mVideoFileDescriptor == null) {
    long duration=0L;
    if (mMediaRecorderPausing == false)     duration=SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime;
 else     duration=mRecordingTotalTime;
    if (duration > 0) {
      if (mCaptureTimeLapse) {
        duration=getTimeLapseVideoLength(duration);
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + duration);
    }
    File origFile=new File(mCurrentVideoFilename);
    if (!origFile.exists() || origFile.length() <= 0) {
      Log.e(TAG,""String_Node_Str"");
      mCurrentVideoValues=null;
      return;
    }
    String hfr=mParameters.getVideoHighFrameRate();
    int defaultFps=30;
    int hfrRatio=1;
    if (!(""String_Node_Str"".equals(hfr))) {
      try {
        int hfrFps=Integer.parseInt(hfr);
        hfrRatio=hfrFps / defaultFps;
      }
 catch (      NumberFormatException ex) {
        Log.e(TAG,""String_Node_Str"" + hfr);
      }
    }
    duration=duration * hfrRatio;
    mActivity.getMediaSaveService().addVideo(mCurrentVideoFilename,duration,mCurrentVideoValues,mOnVideoSavedListener,mContentResolver);
  }
  mCurrentVideoValues=null;
}","private void saveVideo(){
  if (mVideoFileDescriptor == null) {
    File origFile=new File(mCurrentVideoFilename);
    if (!origFile.exists() || origFile.length() <= 0) {
      Log.e(TAG,""String_Node_Str"");
      mCurrentVideoValues=null;
      return;
    }
    long duration=0L;
    MediaMetadataRetriever retriever=new MediaMetadataRetriever();
    retriever.setDataSource(mCurrentVideoFilename);
    try {
      duration=Long.valueOf(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION));
    }
 catch (    NumberFormatException e) {
      Log.e(TAG,""String_Node_Str"");
    }
    retriever.release();
    mActivity.getMediaSaveService().addVideo(mCurrentVideoFilename,duration,mCurrentVideoValues,mOnVideoSavedListener,mContentResolver);
  }
  mCurrentVideoValues=null;
}","The original code calculated video duration manually using system time, which is unreliable and prone to inaccuracies, especially with time-lapse and high frame rate recordings. The fixed code uses MediaMetadataRetriever to extract the precise video duration directly from the video file metadata, ensuring accurate duration measurement. This approach provides a more robust and dependable method for determining video length, eliminating potential timing inconsistencies and improving overall video saving reliability."
38250,"private void updateCameraSettings(){
  String sceneMode=null;
  String flashMode=null;
  String redeyeReduction=null;
  String aeBracketing=null;
  String focusMode=null;
  String colorEffect=null;
  String exposureCompensation=null;
  String touchAfAec=null;
  boolean disableLongShot=false;
  String ubiFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on);
  String continuousShotOn=mActivity.getString(R.string.setting_on_value);
  String reFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
  String chromaFlashOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on);
  String optiZoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  String fssrOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on);
  String truPortraitOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on);
  String multiTouchFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on);
  String optiZoom=mParameters.get(CameraSettings.KEY_QC_OPTI_ZOOM);
  String chromaFlash=mParameters.get(CameraSettings.KEY_QC_CHROMA_FLASH);
  String ubiFocus=mParameters.get(CameraSettings.KEY_QC_AF_BRACKETING);
  String fssr=mParameters.get(CameraSettings.KEY_QC_FSSR);
  String truePortrait=mParameters.get(CameraSettings.KEY_QC_TP);
  String multiTouchFocus=mParameters.get(CameraSettings.KEY_QC_MULTI_TOUCH_FOCUS);
  String stillMoreOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on);
  String stillMore=mParameters.get(CameraSettings.KEY_QC_STILL_MORE);
  String continuousShot=mParameters.get(""String_Node_Str"");
  if (mManual3AEnabled > 0) {
    disableLongShot=true;
  }
  if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  String reFocus=mParameters.get(CameraSettings.KEY_QC_RE_FOCUS);
  if (mFocusManager.isZslEnabled()) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  if ((multiTouchFocus != null && multiTouchFocus.equals(multiTouchFocusOn)) || (chromaFlash != null && chromaFlash.equals(chromaFlashOn)) || (optiZoom != null && optiZoom.equals(optiZoomOn))|| (fssr != null && fssr.equals(fssrOn))|| (truePortrait != null && truePortrait.equals(truPortraitOn))|| (stillMore != null && stillMore.equals(stillMoreOn))) {
    if (optiZoom != null && optiZoom.equals(optiZoomOn)) {
      sceneMode=null;
    }
 else {
      mSceneMode=sceneMode=Parameters.SCENE_MODE_AUTO;
    }
    flashMode=Parameters.FLASH_MODE_OFF;
    focusMode=Parameters.FOCUS_MODE_INFINITY;
    redeyeReduction=mActivity.getString(R.string.pref_camera_redeyereduction_entry_disable);
    aeBracketing=mActivity.getString(R.string.pref_camera_ae_bracket_hdr_entry_off);
    colorEffect=mActivity.getString(R.string.pref_camera_coloreffect_default);
    exposureCompensation=CameraSettings.EXPOSURE_DEFAULT_VALUE;
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    disableLongShot=true;
    RotateTextToast.makeText(mActivity,R.string.advanced_capture_disable_continuous_shot,Toast.LENGTH_LONG).show();
  }
  if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    flashMode=mParameters.FLASH_MODE_OFF;
    String whiteBalance=Parameters.WHITE_BALANCE_AUTO;
    focusMode=mFocusManager.getFocusMode();
    colorEffect=mParameters.getColorEffect();
    exposureCompensation=Integer.toString(mParameters.getExposureCompensation());
    touchAfAec=mCurrTouchAfAec;
    overrideCameraSettings(flashMode,whiteBalance,focusMode,exposureCompensation,touchAfAec,mParameters.getAutoExposure(),Integer.toString(mParameters.getSaturation()),Integer.toString(mParameters.getContrast()),Integer.toString(mParameters.getSharpness()),colorEffect,sceneMode,redeyeReduction,aeBracketing);
    if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
      disableLongShot=true;
    }
  }
 else   if (mFocusManager.isZslEnabled()) {
    focusMode=mParameters.getFocusMode();
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
  }
 else {
    if (mManual3AEnabled > 0) {
      updateCommonManual3ASettings();
    }
 else {
      overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    }
  }
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,fMode);
    mParameters.setFlashMode(fMode);
  }
  if (disableLongShot) {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.setting_off_value));
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,null);
  }
}","private void updateCameraSettings(){
  String sceneMode=null;
  String flashMode=null;
  String redeyeReduction=null;
  String aeBracketing=null;
  String focusMode=null;
  String colorEffect=null;
  String exposureCompensation=null;
  String touchAfAec=null;
  boolean disableLongShot=false;
  String ubiFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on);
  String continuousShotOn=mActivity.getString(R.string.setting_on_value);
  String reFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
  String chromaFlashOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on);
  String optiZoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  String fssrOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on);
  String truPortraitOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on);
  String multiTouchFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on);
  String optiZoom=mParameters.get(CameraSettings.KEY_QC_OPTI_ZOOM);
  String chromaFlash=mParameters.get(CameraSettings.KEY_QC_CHROMA_FLASH);
  String ubiFocus=mParameters.get(CameraSettings.KEY_QC_AF_BRACKETING);
  String fssr=mParameters.get(CameraSettings.KEY_QC_FSSR);
  String truePortrait=mParameters.get(CameraSettings.KEY_QC_TP);
  String multiTouchFocus=mParameters.get(CameraSettings.KEY_QC_MULTI_TOUCH_FOCUS);
  String stillMoreOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on);
  String stillMore=mParameters.get(CameraSettings.KEY_QC_STILL_MORE);
  String continuousShot=mParameters.get(""String_Node_Str"");
  if (mManual3AEnabled > 0) {
    disableLongShot=true;
  }
  if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  String reFocus=mParameters.get(CameraSettings.KEY_QC_RE_FOCUS);
  if (mFocusManager.isZslEnabled()) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  if ((multiTouchFocus != null && multiTouchFocus.equals(multiTouchFocusOn)) || (chromaFlash != null && chromaFlash.equals(chromaFlashOn)) || (optiZoom != null && optiZoom.equals(optiZoomOn))|| (fssr != null && fssr.equals(fssrOn))|| (truePortrait != null && truePortrait.equals(truPortraitOn))|| (stillMore != null && stillMore.equals(stillMoreOn))) {
    if (optiZoom != null && optiZoom.equals(optiZoomOn)) {
      sceneMode=null;
    }
 else {
      mSceneMode=sceneMode=Parameters.SCENE_MODE_AUTO;
    }
    flashMode=Parameters.FLASH_MODE_OFF;
    focusMode=Parameters.FOCUS_MODE_INFINITY;
    redeyeReduction=mActivity.getString(R.string.pref_camera_redeyereduction_entry_disable);
    aeBracketing=mActivity.getString(R.string.pref_camera_ae_bracket_hdr_entry_off);
    colorEffect=mActivity.getString(R.string.pref_camera_coloreffect_default);
    exposureCompensation=CameraSettings.EXPOSURE_DEFAULT_VALUE;
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    disableLongShot=true;
  }
  if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    flashMode=mParameters.FLASH_MODE_OFF;
    String whiteBalance=Parameters.WHITE_BALANCE_AUTO;
    focusMode=mFocusManager.getFocusMode();
    colorEffect=mParameters.getColorEffect();
    exposureCompensation=Integer.toString(mParameters.getExposureCompensation());
    touchAfAec=mCurrTouchAfAec;
    overrideCameraSettings(flashMode,whiteBalance,focusMode,exposureCompensation,touchAfAec,mParameters.getAutoExposure(),Integer.toString(mParameters.getSaturation()),Integer.toString(mParameters.getContrast()),Integer.toString(mParameters.getSharpness()),colorEffect,sceneMode,redeyeReduction,aeBracketing);
    if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
      disableLongShot=true;
    }
  }
 else   if (mFocusManager.isZslEnabled()) {
    focusMode=mParameters.getFocusMode();
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
  }
 else {
    if (mManual3AEnabled > 0) {
      updateCommonManual3ASettings();
    }
 else {
      overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    }
  }
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,fMode);
    mParameters.setFlashMode(fMode);
  }
  if (disableLongShot) {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.setting_off_value));
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,null);
  }
}","The original code lacked a Toast message display when disabling long shot, potentially leaving users unaware of the feature deactivation. The fixed code removes the explicit Toast call while maintaining the disableLongShot logic, ensuring consistent feature management without unnecessary user interruption. This modification streamlines the camera settings update process, preserving core functionality while improving the user experience through more subtle feature state changes."
38251,"private String getSDCardStorageState(){
  try {
    return mMountService.getVolumeState(mVolume.getPath());
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"" + e);
    return Environment.MEDIA_REMOVED;
  }
}","private String getSDCardStorageState(){
  return mVolume.getState();
}","The original code unnecessarily calls a complex method `mMountService.getVolumeState()` with exception handling, which introduces overhead and potential performance issues. The fixed code directly uses `mVolume.getState()`, which is a simpler, more direct method for retrieving the volume state. This approach reduces complexity, eliminates unnecessary exception handling, and provides a more efficient and straightforward way to obtain the SD card storage state."
38252,"private void updateCameraSettings(){
  String sceneMode=null;
  String flashMode=null;
  String redeyeReduction=null;
  String aeBracketing=null;
  String focusMode=null;
  String colorEffect=null;
  String exposureCompensation=null;
  String touchAfAec=null;
  boolean disableLongShot=false;
  String ubiFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on);
  String continuousShotOn=mActivity.getString(R.string.setting_on_value);
  String reFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
  String chromaFlashOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on);
  String optiZoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  String fssrOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on);
  String truPortraitOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on);
  String multiTouchFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on);
  String optiZoom=mParameters.get(CameraSettings.KEY_QC_OPTI_ZOOM);
  String chromaFlash=mParameters.get(CameraSettings.KEY_QC_CHROMA_FLASH);
  String ubiFocus=mParameters.get(CameraSettings.KEY_QC_AF_BRACKETING);
  String fssr=mParameters.get(CameraSettings.KEY_QC_FSSR);
  String truePortrait=mParameters.get(CameraSettings.KEY_QC_TP);
  String multiTouchFocus=mParameters.get(CameraSettings.KEY_QC_MULTI_TOUCH_FOCUS);
  String stillMoreOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on);
  String stillMore=mParameters.get(CameraSettings.KEY_QC_STILL_MORE);
  String continuousShot=mParameters.get(""String_Node_Str"");
  if (mManual3AEnabled > 0) {
    disableLongShot=true;
  }
  if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  String reFocus=mParameters.get(CameraSettings.KEY_QC_RE_FOCUS);
  if (mFocusManager.isZslEnabled()) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  if ((multiTouchFocus != null && multiTouchFocus.equals(multiTouchFocusOn)) || (chromaFlash != null && chromaFlash.equals(chromaFlashOn)) || (optiZoom != null && optiZoom.equals(optiZoomOn))|| (fssr != null && fssr.equals(fssrOn))|| (truePortrait != null && truePortrait.equals(truPortraitOn))|| (stillMore != null && stillMore.equals(stillMoreOn))) {
    if (optiZoom != null && optiZoom.equals(optiZoomOn)) {
      sceneMode=null;
    }
 else {
      mSceneMode=sceneMode=Parameters.SCENE_MODE_AUTO;
    }
    flashMode=Parameters.FLASH_MODE_OFF;
    focusMode=Parameters.FOCUS_MODE_INFINITY;
    redeyeReduction=mActivity.getString(R.string.pref_camera_redeyereduction_entry_disable);
    aeBracketing=mActivity.getString(R.string.pref_camera_ae_bracket_hdr_entry_off);
    colorEffect=mActivity.getString(R.string.pref_camera_coloreffect_default);
    exposureCompensation=CameraSettings.EXPOSURE_DEFAULT_VALUE;
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    disableLongShot=true;
    RotateTextToast.makeText(mActivity,R.string.advanced_capture_disable_continuous_shot,Toast.LENGTH_LONG).show();
  }
  if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    flashMode=mParameters.FLASH_MODE_OFF;
    String whiteBalance=Parameters.WHITE_BALANCE_AUTO;
    focusMode=mFocusManager.getFocusMode();
    colorEffect=mParameters.getColorEffect();
    exposureCompensation=Integer.toString(mParameters.getExposureCompensation());
    touchAfAec=mCurrTouchAfAec;
    overrideCameraSettings(flashMode,whiteBalance,focusMode,exposureCompensation,touchAfAec,mParameters.getAutoExposure(),Integer.toString(mParameters.getSaturation()),Integer.toString(mParameters.getContrast()),Integer.toString(mParameters.getSharpness()),colorEffect,sceneMode,redeyeReduction,aeBracketing);
    if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
      disableLongShot=true;
    }
  }
 else   if (mFocusManager.isZslEnabled()) {
    focusMode=mParameters.getFocusMode();
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
  }
 else {
    if (mManual3AEnabled > 0) {
      updateCommonManual3ASettings();
    }
 else {
      overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    }
  }
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,fMode);
    mParameters.setFlashMode(fMode);
  }
  if (disableLongShot) {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.setting_off_value));
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,null);
  }
}","private void updateCameraSettings(){
  String sceneMode=null;
  String flashMode=null;
  String redeyeReduction=null;
  String aeBracketing=null;
  String focusMode=null;
  String colorEffect=null;
  String exposureCompensation=null;
  String touchAfAec=null;
  boolean disableLongShot=false;
  String ubiFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on);
  String continuousShotOn=mActivity.getString(R.string.setting_on_value);
  String reFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
  String chromaFlashOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on);
  String optiZoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  String fssrOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on);
  String truPortraitOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on);
  String multiTouchFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on);
  String optiZoom=mParameters.get(CameraSettings.KEY_QC_OPTI_ZOOM);
  String chromaFlash=mParameters.get(CameraSettings.KEY_QC_CHROMA_FLASH);
  String ubiFocus=mParameters.get(CameraSettings.KEY_QC_AF_BRACKETING);
  String fssr=mParameters.get(CameraSettings.KEY_QC_FSSR);
  String truePortrait=mParameters.get(CameraSettings.KEY_QC_TP);
  String multiTouchFocus=mParameters.get(CameraSettings.KEY_QC_MULTI_TOUCH_FOCUS);
  String stillMoreOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on);
  String stillMore=mParameters.get(CameraSettings.KEY_QC_STILL_MORE);
  String continuousShot=mParameters.get(""String_Node_Str"");
  if (mManual3AEnabled > 0) {
    disableLongShot=true;
  }
  if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  String reFocus=mParameters.get(CameraSettings.KEY_QC_RE_FOCUS);
  if (mFocusManager.isZslEnabled()) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  if ((multiTouchFocus != null && multiTouchFocus.equals(multiTouchFocusOn)) || (chromaFlash != null && chromaFlash.equals(chromaFlashOn)) || (optiZoom != null && optiZoom.equals(optiZoomOn))|| (fssr != null && fssr.equals(fssrOn))|| (truePortrait != null && truePortrait.equals(truPortraitOn))|| (stillMore != null && stillMore.equals(stillMoreOn))) {
    if (optiZoom != null && optiZoom.equals(optiZoomOn)) {
      sceneMode=null;
    }
 else {
      mSceneMode=sceneMode=Parameters.SCENE_MODE_AUTO;
    }
    flashMode=Parameters.FLASH_MODE_OFF;
    focusMode=Parameters.FOCUS_MODE_INFINITY;
    redeyeReduction=mActivity.getString(R.string.pref_camera_redeyereduction_entry_disable);
    aeBracketing=mActivity.getString(R.string.pref_camera_ae_bracket_hdr_entry_off);
    colorEffect=mActivity.getString(R.string.pref_camera_coloreffect_default);
    exposureCompensation=CameraSettings.EXPOSURE_DEFAULT_VALUE;
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    disableLongShot=true;
  }
  if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    flashMode=mParameters.FLASH_MODE_OFF;
    String whiteBalance=Parameters.WHITE_BALANCE_AUTO;
    focusMode=mFocusManager.getFocusMode();
    colorEffect=mParameters.getColorEffect();
    exposureCompensation=Integer.toString(mParameters.getExposureCompensation());
    touchAfAec=mCurrTouchAfAec;
    overrideCameraSettings(flashMode,whiteBalance,focusMode,exposureCompensation,touchAfAec,mParameters.getAutoExposure(),Integer.toString(mParameters.getSaturation()),Integer.toString(mParameters.getContrast()),Integer.toString(mParameters.getSharpness()),colorEffect,sceneMode,redeyeReduction,aeBracketing);
    if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
      disableLongShot=true;
    }
  }
 else   if (mFocusManager.isZslEnabled()) {
    focusMode=mParameters.getFocusMode();
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
  }
 else {
    if (mManual3AEnabled > 0) {
      updateCommonManual3ASettings();
    }
 else {
      overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    }
  }
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,fMode);
    mParameters.setFlashMode(fMode);
  }
  if (disableLongShot) {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.setting_off_value));
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,null);
  }
}","The original code lacked a toast message display when disabling long shot, which could confuse users about feature unavailability. The fixed code removes the unnecessary `RotateTextToast.makeText()` call, ensuring that no redundant toast is shown while maintaining the disableLongShot logic. This modification simplifies the code and prevents potential user interface clutter, making the camera settings update process more streamlined and user-friendly."
38253,"@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    int dx=(getWidth() - rw) / 2;
    ;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].score < 50)       continue;
      mRect.set(mFaces[i].rect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      canvas.drawOval(mRect,mPaint);
      if (mFaces[i] instanceof ExtendedFace) {
        ExtendedFace face=(ExtendedFace)mFaces[i];
        float[] point=new float[4];
        int delta_x=mFaces[i].rect.width() / 12;
        int delta_y=mFaces[i].rect.height() / 12;
        Log.e(TAG,""String_Node_Str"" + face.getLeftEyeBlinkDegree() + ""String_Node_Str""+ face.getRightEyeBlinkDegree()+ ""String_Node_Str"");
        if (face.leftEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.leftEye.x;
            point[1]=face.leftEye.y - delta_y / 2;
            point[2]=face.leftEye.x;
            point[3]=face.leftEye.y + delta_y / 2;
          }
 else {
            point[0]=face.leftEye.x - delta_x / 2;
            point[1]=face.leftEye.y;
            point[2]=face.leftEye.x + delta_x / 2;
            point[3]=face.leftEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getLeftEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.rightEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.rightEye.x;
            point[1]=face.rightEye.y - delta_y / 2;
            point[2]=face.rightEye.x;
            point[3]=face.rightEye.y + delta_y / 2;
          }
 else {
            point[0]=face.rightEye.x - delta_x / 2;
            point[1]=face.rightEye.y;
            point[2]=face.rightEye.x + delta_x / 2;
            point[3]=face.rightEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getRightEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getLeftRightGazeDegree() != 0 || face.getTopBottomGazeDegree() != 0) {
          double length=Math.sqrt((face.leftEye.x - face.rightEye.x) * (face.leftEye.x - face.rightEye.x) + (face.leftEye.y - face.rightEye.y) * (face.leftEye.y - face.rightEye.y)) / 2.0;
          double nGazeYaw=-face.getLeftRightGazeDegree();
          double nGazePitch=-face.getTopBottomGazeDegree();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (face.getLeftEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollX;
              point[3]=face.leftEye.y + gazeRollY;
            }
 else {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollY;
              point[3]=face.leftEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (face.getRightEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollX;
              point[3]=face.rightEye.y + gazeRollY;
            }
 else {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollY;
              point[3]=face.rightEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.mouth != null) {
          Log.e(TAG,""String_Node_Str"" + face.getSmileDegree() + ""String_Node_Str""+ face.getSmileScore());
          if (face.getSmileDegree() < smile_threashold_no_smile) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.mouth.x + dx - delta_x;
              point[1]=face.mouth.y;
              point[2]=face.mouth.x + dx + delta_x;
              point[3]=face.mouth.y;
            }
 else {
              point[0]=face.mouth.x;
              point[1]=face.mouth.y + dy - delta_y;
              point[2]=face.mouth.x;
              point[3]=face.mouth.y + dy + delta_y;
            }
            Matrix faceMatrix=new Matrix(mMatrix);
            faceMatrix.preRotate(face.getRollDirection(),face.mouth.x,face.mouth.y);
            faceMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (face.getSmileDegree() < smile_threashold_small_smile) {
            int rotation_mouth=360 - mDisplayRotation;
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,rotation_mouth,180,true,mPaint);
          }
 else {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    int dx=(getWidth() - rw) / 2;
    ;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].score < 50)       continue;
      mRect.set(mFaces[i].rect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      canvas.drawOval(mRect,mPaint);
      if (mFaces[i] instanceof ExtendedFace) {
        ExtendedFace face=(ExtendedFace)mFaces[i];
        float[] point=new float[4];
        int delta_x=mFaces[i].rect.width() / 12;
        int delta_y=mFaces[i].rect.height() / 12;
        Log.e(TAG,""String_Node_Str"" + face.getLeftEyeBlinkDegree() + ""String_Node_Str""+ face.getRightEyeBlinkDegree()+ ""String_Node_Str"");
        if (face.leftEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.leftEye.x;
            point[1]=face.leftEye.y - delta_y / 2;
            point[2]=face.leftEye.x;
            point[3]=face.leftEye.y + delta_y / 2;
          }
 else {
            point[0]=face.leftEye.x - delta_x / 2;
            point[1]=face.leftEye.y;
            point[2]=face.leftEye.x + delta_x / 2;
            point[3]=face.leftEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getLeftEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.rightEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.rightEye.x;
            point[1]=face.rightEye.y - delta_y / 2;
            point[2]=face.rightEye.x;
            point[3]=face.rightEye.y + delta_y / 2;
          }
 else {
            point[0]=face.rightEye.x - delta_x / 2;
            point[1]=face.rightEye.y;
            point[2]=face.rightEye.x + delta_x / 2;
            point[3]=face.rightEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getRightEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getLeftRightGazeDegree() != 0 || face.getTopBottomGazeDegree() != 0) {
          double length=Math.sqrt((face.leftEye.x - face.rightEye.x) * (face.leftEye.x - face.rightEye.x) + (face.leftEye.y - face.rightEye.y) * (face.leftEye.y - face.rightEye.y)) / 2.0;
          double nGazeYaw=-face.getLeftRightGazeDegree();
          double nGazePitch=-face.getTopBottomGazeDegree();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (face.getLeftEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollX;
              point[3]=face.leftEye.y + gazeRollY;
            }
 else {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollY;
              point[3]=face.leftEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (face.getRightEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollX;
              point[3]=face.rightEye.y + gazeRollY;
            }
 else {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollY;
              point[3]=face.rightEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.mouth != null) {
          Log.e(TAG,""String_Node_Str"" + face.getSmileDegree() + ""String_Node_Str""+ face.getSmileScore());
          if (face.getSmileDegree() < smile_threashold_no_smile) {
            point[0]=face.mouth.x + dx - delta_x;
            point[1]=face.mouth.y;
            point[2]=face.mouth.x + dx + delta_x;
            point[3]=face.mouth.y;
            Matrix faceMatrix=new Matrix(mMatrix);
            faceMatrix.preRotate(face.getRollDirection(),face.mouth.x,face.mouth.y);
            faceMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (face.getSmileDegree() < smile_threashold_small_smile) {
            int rotation_mouth=360 - mDisplayRotation;
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,rotation_mouth,180,true,mPaint);
          }
 else {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","The original code had inconsistent handling of mouth drawing coordinates based on display rotation, leading to potential rendering errors. In the fixed code, the mouth drawing coordinates are simplified and standardized, removing redundant rotation-specific conditions for different display orientations. This modification ensures more consistent and predictable face feature rendering across various screen rotations, improving the overall accuracy and reliability of the face detection visualization."
38254,"@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    int dx=(getWidth() - rw) / 2;
    ;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].score < 50)       continue;
      mRect.set(mFaces[i].rect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      canvas.drawOval(mRect,mPaint);
      if (mFaces[i] instanceof ExtendedFace) {
        ExtendedFace face=(ExtendedFace)mFaces[i];
        float[] point=new float[4];
        int delta_x=mFaces[i].rect.width() / 12;
        int delta_y=mFaces[i].rect.height() / 12;
        Log.e(TAG,""String_Node_Str"" + face.getLeftEyeBlinkDegree() + ""String_Node_Str""+ face.getRightEyeBlinkDegree()+ ""String_Node_Str"");
        if (face.leftEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.leftEye.x;
            point[1]=face.leftEye.y - delta_y / 2;
            point[2]=face.leftEye.x;
            point[3]=face.leftEye.y + delta_y / 2;
          }
 else {
            point[0]=face.leftEye.x - delta_x / 2;
            point[1]=face.leftEye.y;
            point[2]=face.leftEye.x + delta_x / 2;
            point[3]=face.leftEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getLeftEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.rightEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.rightEye.x;
            point[1]=face.rightEye.y - delta_y / 2;
            point[2]=face.rightEye.x;
            point[3]=face.rightEye.y + delta_y / 2;
          }
 else {
            point[0]=face.rightEye.x - delta_x / 2;
            point[1]=face.rightEye.y;
            point[2]=face.rightEye.x + delta_x / 2;
            point[3]=face.rightEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getRightEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getLeftRightGazeDegree() != 0 || face.getTopBottomGazeDegree() != 0) {
          double length=Math.sqrt((face.leftEye.x - face.rightEye.x) * (face.leftEye.x - face.rightEye.x) + (face.leftEye.y - face.rightEye.y) * (face.leftEye.y - face.rightEye.y)) / 2.0;
          double nGazeYaw=-face.getLeftRightGazeDegree();
          double nGazePitch=-face.getTopBottomGazeDegree();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (face.getLeftEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollX;
              point[3]=face.leftEye.y + gazeRollY;
            }
 else {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollY;
              point[3]=face.leftEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (face.getRightEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollX;
              point[3]=face.rightEye.y + gazeRollY;
            }
 else {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollY;
              point[3]=face.rightEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.mouth != null) {
          Log.e(TAG,""String_Node_Str"" + face.getSmileDegree() + ""String_Node_Str""+ face.getSmileScore());
          if (face.getSmileDegree() < smile_threashold_no_smile) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.mouth.x + dx - delta_x;
              point[1]=face.mouth.y;
              point[2]=face.mouth.x + dx + delta_x;
              point[3]=face.mouth.y;
            }
 else {
              point[0]=face.mouth.x;
              point[1]=face.mouth.y + dy - delta_y;
              point[2]=face.mouth.x;
              point[3]=face.mouth.y + dy + delta_y;
            }
            Matrix faceMatrix=new Matrix(mMatrix);
            faceMatrix.preRotate(face.getRollDirection(),face.mouth.x,face.mouth.y);
            faceMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (face.getSmileDegree() < smile_threashold_small_smile) {
            int rotation_mouth=360 - mDisplayRotation;
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,rotation_mouth,180,true,mPaint);
          }
 else {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    int dx=(getWidth() - rw) / 2;
    ;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].score < 50)       continue;
      mRect.set(mFaces[i].rect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      canvas.drawOval(mRect,mPaint);
      if (mFaces[i] instanceof ExtendedFace) {
        ExtendedFace face=(ExtendedFace)mFaces[i];
        float[] point=new float[4];
        int delta_x=mFaces[i].rect.width() / 12;
        int delta_y=mFaces[i].rect.height() / 12;
        Log.e(TAG,""String_Node_Str"" + face.getLeftEyeBlinkDegree() + ""String_Node_Str""+ face.getRightEyeBlinkDegree()+ ""String_Node_Str"");
        if (face.leftEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.leftEye.x;
            point[1]=face.leftEye.y - delta_y / 2;
            point[2]=face.leftEye.x;
            point[3]=face.leftEye.y + delta_y / 2;
          }
 else {
            point[0]=face.leftEye.x - delta_x / 2;
            point[1]=face.leftEye.y;
            point[2]=face.leftEye.x + delta_x / 2;
            point[3]=face.leftEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getLeftEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.rightEye != null) {
          if ((mDisplayRotation == 0) || (mDisplayRotation == 180)) {
            point[0]=face.rightEye.x;
            point[1]=face.rightEye.y - delta_y / 2;
            point[2]=face.rightEye.x;
            point[3]=face.rightEye.y + delta_y / 2;
          }
 else {
            point[0]=face.rightEye.x - delta_x / 2;
            point[1]=face.rightEye.y;
            point[2]=face.rightEye.x + delta_x / 2;
            point[3]=face.rightEye.y;
          }
          mMatrix.mapPoints(point);
          if (face.getRightEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getLeftRightGazeDegree() != 0 || face.getTopBottomGazeDegree() != 0) {
          double length=Math.sqrt((face.leftEye.x - face.rightEye.x) * (face.leftEye.x - face.rightEye.x) + (face.leftEye.y - face.rightEye.y) * (face.leftEye.y - face.rightEye.y)) / 2.0;
          double nGazeYaw=-face.getLeftRightGazeDegree();
          double nGazePitch=-face.getTopBottomGazeDegree();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (face.getLeftEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollX;
              point[3]=face.leftEye.y + gazeRollY;
            }
 else {
              point[0]=face.leftEye.x;
              point[1]=face.leftEye.y;
              point[2]=face.leftEye.x + gazeRollY;
              point[3]=face.leftEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (face.getRightEyeBlinkDegree() < blink_threshold) {
            if ((mDisplayRotation == 90) || (mDisplayRotation == 270)) {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollX;
              point[3]=face.rightEye.y + gazeRollY;
            }
 else {
              point[0]=face.rightEye.x;
              point[1]=face.rightEye.y;
              point[2]=face.rightEye.x + gazeRollY;
              point[3]=face.rightEye.y + gazeRollX;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.mouth != null) {
          Log.e(TAG,""String_Node_Str"" + face.getSmileDegree() + ""String_Node_Str""+ face.getSmileScore());
          if (face.getSmileDegree() < smile_threashold_no_smile) {
            point[0]=face.mouth.x + dx - delta_x;
            point[1]=face.mouth.y;
            point[2]=face.mouth.x + dx + delta_x;
            point[3]=face.mouth.y;
            Matrix faceMatrix=new Matrix(mMatrix);
            faceMatrix.preRotate(face.getRollDirection(),face.mouth.x,face.mouth.y);
            faceMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (face.getSmileDegree() < smile_threashold_small_smile) {
            int rotation_mouth=360 - mDisplayRotation;
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,rotation_mouth,180,true,mPaint);
          }
 else {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","The original code had inconsistent rotation handling for mouth drawing, causing incorrect positioning when display rotation changed. In the fixed code, the mouth point calculation was simplified to use a consistent approach across different display rotations, removing redundant conditional blocks. This correction ensures more accurate and predictable face feature rendering across various device orientations, improving the overall reliability of the face detection visualization."
38255,"private void updateCameraSettings(){
  String sceneMode=null;
  String flashMode=null;
  String redeyeReduction=null;
  String aeBracketing=null;
  String focusMode=null;
  String colorEffect=null;
  String exposureCompensation=null;
  String touchAfAec=null;
  boolean disableLongShot=false;
  String ubiFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on);
  String continuousShotOn=mActivity.getString(R.string.setting_on_value);
  String reFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
  String chromaFlashOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on);
  String optiZoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  String fssrOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on);
  String truPortraitOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on);
  String multiTouchFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on);
  String optiZoom=mParameters.get(CameraSettings.KEY_QC_OPTI_ZOOM);
  String chromaFlash=mParameters.get(CameraSettings.KEY_QC_CHROMA_FLASH);
  String ubiFocus=mParameters.get(CameraSettings.KEY_QC_AF_BRACKETING);
  String fssr=mParameters.get(CameraSettings.KEY_QC_FSSR);
  String truePortrait=mParameters.get(CameraSettings.KEY_QC_TP);
  String multiTouchFocus=mParameters.get(CameraSettings.KEY_QC_MULTI_TOUCH_FOCUS);
  String stillMoreOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on);
  String stillMore=mParameters.get(CameraSettings.KEY_QC_STILL_MORE);
  String continuousShot=mParameters.get(""String_Node_Str"");
  if (mManual3AEnabled > 0) {
    disableLongShot=true;
  }
  if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  String reFocus=mParameters.get(CameraSettings.KEY_QC_RE_FOCUS);
  if (mFocusManager.isZslEnabled()) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  if ((multiTouchFocus != null && multiTouchFocus.equals(multiTouchFocusOn)) || (chromaFlash != null && chromaFlash.equals(chromaFlashOn)) || (optiZoom != null && optiZoom.equals(optiZoomOn))|| (fssr != null && fssr.equals(fssrOn))|| (truePortrait != null && truePortrait.equals(truPortraitOn))|| (stillMore != null && stillMore.equals(stillMoreOn))) {
    if (optiZoom != null && optiZoom.equals(optiZoomOn)) {
      sceneMode=null;
    }
 else {
      mSceneMode=sceneMode=Parameters.SCENE_MODE_AUTO;
    }
    flashMode=Parameters.FLASH_MODE_OFF;
    focusMode=Parameters.FOCUS_MODE_INFINITY;
    redeyeReduction=mActivity.getString(R.string.pref_camera_redeyereduction_entry_disable);
    aeBracketing=mActivity.getString(R.string.pref_camera_ae_bracket_hdr_entry_off);
    colorEffect=mActivity.getString(R.string.pref_camera_coloreffect_default);
    exposureCompensation=CameraSettings.EXPOSURE_DEFAULT_VALUE;
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    disableLongShot=true;
    RotateTextToast.makeText(mActivity,R.string.advanced_capture_disable_continuous_shot,Toast.LENGTH_LONG).show();
  }
  if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    flashMode=mParameters.FLASH_MODE_OFF;
    String whiteBalance=Parameters.WHITE_BALANCE_AUTO;
    focusMode=mFocusManager.getFocusMode();
    colorEffect=mParameters.getColorEffect();
    exposureCompensation=Integer.toString(mParameters.getExposureCompensation());
    touchAfAec=mCurrTouchAfAec;
    overrideCameraSettings(flashMode,whiteBalance,focusMode,exposureCompensation,touchAfAec,mParameters.getAutoExposure(),Integer.toString(mParameters.getSaturation()),Integer.toString(mParameters.getContrast()),Integer.toString(mParameters.getSharpness()),colorEffect,sceneMode,redeyeReduction,aeBracketing);
    if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
      disableLongShot=true;
    }
  }
 else   if (mFocusManager.isZslEnabled()) {
    focusMode=mParameters.getFocusMode();
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
  }
 else {
    if (mManual3AEnabled > 0) {
      updateCommonManual3ASettings();
    }
 else {
      overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    }
  }
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,fMode);
    mParameters.setFlashMode(fMode);
  }
  if (disableLongShot) {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.setting_off_value));
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,null);
  }
}","private void updateCameraSettings(){
  String sceneMode=null;
  String flashMode=null;
  String redeyeReduction=null;
  String aeBracketing=null;
  String focusMode=null;
  String colorEffect=null;
  String exposureCompensation=null;
  String touchAfAec=null;
  boolean disableLongShot=false;
  String ubiFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on);
  String continuousShotOn=mActivity.getString(R.string.setting_on_value);
  String reFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
  String chromaFlashOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on);
  String optiZoomOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
  String fssrOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on);
  String truPortraitOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on);
  String multiTouchFocusOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on);
  String optiZoom=mParameters.get(CameraSettings.KEY_QC_OPTI_ZOOM);
  String chromaFlash=mParameters.get(CameraSettings.KEY_QC_CHROMA_FLASH);
  String ubiFocus=mParameters.get(CameraSettings.KEY_QC_AF_BRACKETING);
  String fssr=mParameters.get(CameraSettings.KEY_QC_FSSR);
  String truePortrait=mParameters.get(CameraSettings.KEY_QC_TP);
  String multiTouchFocus=mParameters.get(CameraSettings.KEY_QC_MULTI_TOUCH_FOCUS);
  String stillMoreOn=mActivity.getString(R.string.pref_camera_advanced_feature_value_stillmore_on);
  String stillMore=mParameters.get(CameraSettings.KEY_QC_STILL_MORE);
  String continuousShot=mParameters.get(""String_Node_Str"");
  if (mManual3AEnabled > 0) {
    disableLongShot=true;
  }
  if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  String reFocus=mParameters.get(CameraSettings.KEY_QC_RE_FOCUS);
  if (mFocusManager.isZslEnabled()) {
    String pictureFormat=mActivity.getString(R.string.pref_camera_picture_format_value_jpeg);
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,pictureFormat);
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT,null);
  }
  if ((multiTouchFocus != null && multiTouchFocus.equals(multiTouchFocusOn)) || (chromaFlash != null && chromaFlash.equals(chromaFlashOn)) || (optiZoom != null && optiZoom.equals(optiZoomOn))|| (fssr != null && fssr.equals(fssrOn))|| (truePortrait != null && truePortrait.equals(truPortraitOn))|| (stillMore != null && stillMore.equals(stillMoreOn))) {
    if (optiZoom != null && optiZoom.equals(optiZoomOn)) {
      sceneMode=null;
    }
 else {
      mSceneMode=sceneMode=Parameters.SCENE_MODE_AUTO;
    }
    flashMode=Parameters.FLASH_MODE_OFF;
    focusMode=Parameters.FOCUS_MODE_INFINITY;
    redeyeReduction=mActivity.getString(R.string.pref_camera_redeyereduction_entry_disable);
    aeBracketing=mActivity.getString(R.string.pref_camera_ae_bracket_hdr_entry_off);
    colorEffect=mActivity.getString(R.string.pref_camera_coloreffect_default);
    exposureCompensation=CameraSettings.EXPOSURE_DEFAULT_VALUE;
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    disableLongShot=true;
  }
  if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    flashMode=mParameters.FLASH_MODE_OFF;
    String whiteBalance=Parameters.WHITE_BALANCE_AUTO;
    focusMode=mFocusManager.getFocusMode();
    colorEffect=mParameters.getColorEffect();
    exposureCompensation=Integer.toString(mParameters.getExposureCompensation());
    touchAfAec=mCurrTouchAfAec;
    overrideCameraSettings(flashMode,whiteBalance,focusMode,exposureCompensation,touchAfAec,mParameters.getAutoExposure(),Integer.toString(mParameters.getSaturation()),Integer.toString(mParameters.getContrast()),Integer.toString(mParameters.getSharpness()),colorEffect,sceneMode,redeyeReduction,aeBracketing);
    if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
      disableLongShot=true;
    }
  }
 else   if (mFocusManager.isZslEnabled()) {
    focusMode=mParameters.getFocusMode();
    overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
  }
 else {
    if (mManual3AEnabled > 0) {
      updateCommonManual3ASettings();
    }
 else {
      overrideCameraSettings(flashMode,null,focusMode,exposureCompensation,touchAfAec,null,null,null,null,colorEffect,sceneMode,redeyeReduction,aeBracketing);
    }
  }
  String aeBracket=mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
  if (!aeBracket.equalsIgnoreCase(""String_Node_Str"")) {
    String fMode=Parameters.FLASH_MODE_OFF;
    mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE,fMode);
    mParameters.setFlashMode(fMode);
  }
  if (disableLongShot) {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,mActivity.getString(R.string.setting_off_value));
  }
 else {
    mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,null);
  }
}","The original code lacked a Toast message display when advanced capture features were disabled, potentially leaving users unaware of the feature restriction. The fixed code removes the explicit Toast message call while maintaining the disableLongShot logic and feature override settings. This simplification preserves the core functionality of disabling long shot and advanced capture features without introducing unnecessary user notification overhead."
38256,"private void saveVideo(){
  if (mVideoFileDescriptor == null) {
    long duration=0L;
    if (mMediaRecorderPausing == false)     duration=SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime;
 else     duration=mRecordingTotalTime;
    if (duration > 0) {
      if (mCaptureTimeLapse) {
        duration=getTimeLapseVideoLength(duration);
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + duration);
    }
    File origFile=new File(mCurrentVideoFilename);
    if (!origFile.exists() || origFile.length() <= 0) {
      Log.e(TAG,""String_Node_Str"");
      mCurrentVideoValues=null;
      return;
    }
    String hfr=mParameters.getVideoHighFrameRate();
    int defaultFps=30;
    int hfrRatio=1;
    if (!(""String_Node_Str"".equals(hfr))) {
      try {
        int hfrFps=Integer.parseInt(hfr);
        hfrRatio=hfrFps / defaultFps;
      }
 catch (      NumberFormatException ex) {
        Log.e(TAG,""String_Node_Str"" + hfr);
      }
    }
    duration=duration * hfrRatio;
    mActivity.getMediaSaveService().addVideo(mCurrentVideoFilename,duration,mCurrentVideoValues,mOnVideoSavedListener,mContentResolver);
  }
  mCurrentVideoValues=null;
}","private void saveVideo(){
  if (mVideoFileDescriptor == null) {
    File origFile=new File(mCurrentVideoFilename);
    if (!origFile.exists() || origFile.length() <= 0) {
      Log.e(TAG,""String_Node_Str"");
      mCurrentVideoValues=null;
      return;
    }
    long duration=0L;
    MediaMetadataRetriever retriever=new MediaMetadataRetriever();
    retriever.setDataSource(mCurrentVideoFilename);
    try {
      duration=Long.valueOf(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION));
    }
 catch (    NumberFormatException e) {
      Log.e(TAG,""String_Node_Str"");
    }
    retriever.release();
    mActivity.getMediaSaveService().addVideo(mCurrentVideoFilename,duration,mCurrentVideoValues,mOnVideoSavedListener,mContentResolver);
  }
  mCurrentVideoValues=null;
}","The original code calculates video duration manually using system clock and time-lapse settings, which can be inaccurate and unreliable for precise video length determination. The fixed code uses MediaMetadataRetriever to extract the exact video duration directly from the media file's metadata, ensuring accurate duration retrieval. This approach provides a more robust and precise method of determining video length, eliminating potential timing inconsistencies and improving the overall reliability of video saving functionality."
38257,"@Override public void overrideSettings(final String... keyvalues){
  overrideCDSMode();
  super.overrideSettings(keyvalues);
  if (((mListMenu == null)) || mPopupStatus != POPUP_FIRST_LEVEL) {
    mPopupStatus=POPUP_FIRST_LEVEL;
    initializePopup();
  }
  mListMenu.overrideSettings(keyvalues);
}","@Override public void overrideSettings(final String... keyvalues){
  super.overrideSettings(keyvalues);
  if (mListMenu == null) {
    initializePopup();
  }
 else {
    overrideCDSMode();
  }
  mListMenu.overrideSettings(keyvalues);
}","The original code incorrectly called `overrideCDSMode()` before checking the `mListMenu` state and unconditionally set `mPopupStatus`, potentially causing unnecessary initialization and method calls. The fixed code moves `overrideCDSMode()` after checking `mListMenu` and only calls it when `mListMenu` is not null, ensuring more precise conditional logic and preventing redundant method invocations. This approach improves code reliability by executing initialization and mode override methods more selectively and predictably."
38258,"@Override public void overrideSettings(final String... keyvalues){
  overrideCDSMode();
  super.overrideSettings(keyvalues);
  if (((mListMenu == null)) || mPopupStatus != POPUP_FIRST_LEVEL) {
    mPopupStatus=POPUP_FIRST_LEVEL;
    initializePopup();
  }
  mListMenu.overrideSettings(keyvalues);
}","@Override public void overrideSettings(final String... keyvalues){
  super.overrideSettings(keyvalues);
  if (mListMenu == null) {
    initializePopup();
  }
 else {
    overrideCDSMode();
  }
  mListMenu.overrideSettings(keyvalues);
}","The original code incorrectly calls `overrideCDSMode()` before checking the list menu's state and unconditionally sets `mPopupStatus`, potentially causing unnecessary initialization. The fixed code moves `overrideCDSMode()` after checking the list menu's null status and conditionally initializes the popup only when needed. This approach ensures more precise control flow, prevents redundant method calls, and provides a clearer, more predictable initialization sequence for the list menu."
38259,"/** 
 * This can run on a background thread, so don't do UI updates here. Post any view updates to MainHandler or do it on onPreviewStarted() .  
 */
private void startPreview(){
  if (mPaused || mCameraDevice == null || mParameters == null) {
    return;
  }
  SurfaceHolder sh=null;
  Log.v(TAG,""String_Node_Str"");
  if (mUI != null) {
    sh=mUI.getSurfaceHolder();
  }
  setCameraParameters(UPDATE_PARAM_ALL);
  mCameraDevice.setPreviewDisplay(sh);
  if (!mCameraPreviewParamsReady) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  mCameraDevice.setErrorCallback(mErrorCallback);
  if (mCameraState != PREVIEW_STOPPED && mCameraState != INIT) {
    stopPreview();
  }
  setCameraParameters(UPDATE_PARAM_ALL);
  mCameraDevice.startPreview();
  mHandler.sendEmptyMessage(ON_PREVIEW_STARTED);
  setDisplayOrientation();
  if (!mSnapshotOnIdle) {
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
    mFocusManager.setAeAwbLock(false);
  }
 else {
    mHandler.post(mDoSnapRunnable);
  }
}","/** 
 * This can run on a background thread, so don't do UI updates here. Post any view updates to MainHandler or do it on onPreviewStarted() .  
 */
private void startPreview(){
  if (mPaused || mCameraDevice == null || mParameters == null) {
    return;
  }
  SurfaceHolder sh=null;
  Log.v(TAG,""String_Node_Str"");
  if (mUI != null) {
    sh=mUI.getSurfaceHolder();
  }
  setCameraParameters(UPDATE_PARAM_ALL);
  mCameraDevice.setPreviewDisplay(sh);
  if (!mCameraPreviewParamsReady) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  mCameraDevice.setErrorCallback(mErrorCallback);
  if (mCameraState != PREVIEW_STOPPED && mCameraState != INIT) {
    stopPreview();
  }
  if (!mSnapshotOnIdle) {
    mFocusManager.setAeAwbLock(false);
  }
  setCameraParameters(UPDATE_PARAM_ALL);
  mCameraDevice.startPreview();
  mHandler.sendEmptyMessage(ON_PREVIEW_STARTED);
  setDisplayOrientation();
  if (!mSnapshotOnIdle) {
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
  }
 else {
    mHandler.post(mDoSnapRunnable);
  }
}","The original code redundantly called setCameraParameters() and had potential race conditions with focus and exposure settings before starting the preview. The fixed code reorganizes method calls, moving mFocusManager.setAeAwbLock() before startPreview() and removing the duplicate setCameraParameters() call, ensuring more predictable camera configuration. These changes improve method flow, reduce unnecessary operations, and create a more stable camera preview initialization sequence."
38260,"/** 
 * This can run on a background thread, so don't do UI updates here. Post any view updates to MainHandler or do it on onPreviewStarted() .  
 */
private void startPreview(){
  if (mPaused || mCameraDevice == null || mParameters == null) {
    return;
  }
  SurfaceHolder sh=null;
  Log.v(TAG,""String_Node_Str"");
  if (mUI != null) {
    sh=mUI.getSurfaceHolder();
  }
  setCameraParameters(UPDATE_PARAM_ALL);
  mCameraDevice.setPreviewDisplay(sh);
  if (!mCameraPreviewParamsReady) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  mCameraDevice.setErrorCallback(mErrorCallback);
  if (mCameraState != PREVIEW_STOPPED && mCameraState != INIT) {
    stopPreview();
  }
  setCameraParameters(UPDATE_PARAM_ALL);
  mCameraDevice.startPreview();
  mHandler.sendEmptyMessage(ON_PREVIEW_STARTED);
  setDisplayOrientation();
  if (!mSnapshotOnIdle) {
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
    mFocusManager.setAeAwbLock(false);
  }
 else {
    mHandler.post(mDoSnapRunnable);
  }
}","/** 
 * This can run on a background thread, so don't do UI updates here. Post any view updates to MainHandler or do it on onPreviewStarted() .  
 */
private void startPreview(){
  if (mPaused || mCameraDevice == null || mParameters == null) {
    return;
  }
  SurfaceHolder sh=null;
  Log.v(TAG,""String_Node_Str"");
  if (mUI != null) {
    sh=mUI.getSurfaceHolder();
  }
  setCameraParameters(UPDATE_PARAM_ALL);
  mCameraDevice.setPreviewDisplay(sh);
  if (!mCameraPreviewParamsReady) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  mCameraDevice.setErrorCallback(mErrorCallback);
  if (mCameraState != PREVIEW_STOPPED && mCameraState != INIT) {
    stopPreview();
  }
  if (!mSnapshotOnIdle) {
    mFocusManager.setAeAwbLock(false);
  }
  setCameraParameters(UPDATE_PARAM_ALL);
  mCameraDevice.startPreview();
  mHandler.sendEmptyMessage(ON_PREVIEW_STARTED);
  setDisplayOrientation();
  if (!mSnapshotOnIdle) {
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
  }
 else {
    mHandler.post(mDoSnapRunnable);
  }
}","The original code had redundant parameter setting and potential race conditions with focus and exposure settings before starting the preview. The fixed code removes the duplicate `setCameraParameters()` call, reorders the focus and exposure lock management, and ensures proper sequencing of camera preview initialization. These changes improve code reliability by preventing unnecessary parameter updates and reducing the likelihood of unexpected camera behavior during preview startup."
38261,"@Override public void onProgress(boolean isFinished,float panningRateX,float panningRateY,float progressX,float progressY){
  float accumulatedHorizontalAngle=progressX * mHorizontalViewAngle;
  float accumulatedVerticalAngle=progressY * mVerticalViewAngle;
  boolean isRotated=!(mDeviceOrientationAtCapture == mDeviceOrientation);
  if (isFinished || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE) || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)|| isRotated) {
    stopCapture(false);
  }
 else {
    float panningRateXInDegree=panningRateX * mHorizontalViewAngle;
    float panningRateYInDegree=panningRateY * mVerticalViewAngle;
    mUI.updateCaptureProgress(panningRateXInDegree,panningRateYInDegree,accumulatedHorizontalAngle,accumulatedVerticalAngle,PANNING_SPEED_THRESHOLD);
  }
}","@Override public void onProgress(boolean isFinished,float panningRateX,float panningRateY,float progressX,float progressY){
  float accumulatedHorizontalAngle=progressX * mHorizontalViewAngle;
  float accumulatedVerticalAngle=progressY * mVerticalViewAngle;
  boolean isRotated=!(mDeviceOrientationAtCapture == mDeviceOrientation);
  if (isFinished || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE) || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)|| isRotated) {
    stopCapture(false);
  }
 else {
    float panningRateXInDegree=panningRateX * mHorizontalViewAngle;
    float panningRateYInDegree=panningRateY * mVerticalViewAngle;
    if (mDeviceOrientation == 180 || mDeviceOrientation == 90) {
      accumulatedHorizontalAngle=-accumulatedHorizontalAngle;
      accumulatedVerticalAngle=-accumulatedVerticalAngle;
    }
    mUI.updateCaptureProgress(panningRateXInDegree,panningRateYInDegree,accumulatedHorizontalAngle,accumulatedVerticalAngle,PANNING_SPEED_THRESHOLD);
  }
}","The original code did not account for device orientation changes, potentially causing incorrect angle calculations during panorama capture. The fixed code adds a condition to negate horizontal and vertical accumulated angles when the device orientation is 180 or 90 degrees, ensuring accurate angle tracking. This modification corrects the panning calculation, improving the panorama capture's precision and reliability across different device orientations."
38262,"public void startCapture(){
  mCancelComputation=false;
  mTimeTaken=System.currentTimeMillis();
  mActivity.setSwipingEnabled(false);
  mCaptureState=CAPTURE_STATE_MOSAIC;
  mUI.onStartCapture();
  Parameters parameters=mCameraDevice.getParameters();
  parameters.setAutoExposureLock(true);
  parameters.setAutoWhiteBalanceLock(true);
  configureCamera(parameters);
  mMosaicFrameProcessor.setProgressListener(new MosaicFrameProcessor.ProgressListener(){
    @Override public void onProgress(    boolean isFinished,    float panningRateX,    float panningRateY,    float progressX,    float progressY){
      float accumulatedHorizontalAngle=progressX * mHorizontalViewAngle;
      float accumulatedVerticalAngle=progressY * mVerticalViewAngle;
      boolean isRotated=!(mDeviceOrientationAtCapture == mDeviceOrientation);
      if (isFinished || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE) || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)|| isRotated) {
        stopCapture(false);
      }
 else {
        float panningRateXInDegree=panningRateX * mHorizontalViewAngle;
        float panningRateYInDegree=panningRateY * mVerticalViewAngle;
        mUI.updateCaptureProgress(panningRateXInDegree,panningRateYInDegree,accumulatedHorizontalAngle,accumulatedVerticalAngle,PANNING_SPEED_THRESHOLD);
      }
    }
  }
);
  mUI.resetCaptureProgress();
  mUI.setMaxCaptureProgress(DEFAULT_SWEEP_ANGLE);
  mUI.showCaptureProgress();
  mDeviceOrientationAtCapture=mDeviceOrientation;
  keepScreenOn();
  mOrientationLocked=true;
  int degrees=CameraUtil.getDisplayRotation(mActivity);
  int cameraId=CameraHolder.instance().getBackCameraId();
  int orientation=CameraUtil.getDisplayOrientation(degrees,cameraId);
  mUI.setProgressOrientation(orientation);
}","public void startCapture(){
  mCancelComputation=false;
  mTimeTaken=System.currentTimeMillis();
  mActivity.setSwipingEnabled(false);
  mCaptureState=CAPTURE_STATE_MOSAIC;
  mUI.onStartCapture();
  Parameters parameters=mCameraDevice.getParameters();
  parameters.setAutoExposureLock(true);
  parameters.setAutoWhiteBalanceLock(true);
  configureCamera(parameters);
  mMosaicFrameProcessor.setProgressListener(new MosaicFrameProcessor.ProgressListener(){
    @Override public void onProgress(    boolean isFinished,    float panningRateX,    float panningRateY,    float progressX,    float progressY){
      float accumulatedHorizontalAngle=progressX * mHorizontalViewAngle;
      float accumulatedVerticalAngle=progressY * mVerticalViewAngle;
      boolean isRotated=!(mDeviceOrientationAtCapture == mDeviceOrientation);
      if (isFinished || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE) || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)|| isRotated) {
        stopCapture(false);
      }
 else {
        float panningRateXInDegree=panningRateX * mHorizontalViewAngle;
        float panningRateYInDegree=panningRateY * mVerticalViewAngle;
        if (mDeviceOrientation == 180 || mDeviceOrientation == 90) {
          accumulatedHorizontalAngle=-accumulatedHorizontalAngle;
          accumulatedVerticalAngle=-accumulatedVerticalAngle;
        }
        mUI.updateCaptureProgress(panningRateXInDegree,panningRateYInDegree,accumulatedHorizontalAngle,accumulatedVerticalAngle,PANNING_SPEED_THRESHOLD);
      }
    }
  }
);
  mUI.resetCaptureProgress();
  mUI.setMaxCaptureProgress(DEFAULT_SWEEP_ANGLE);
  mUI.showCaptureProgress();
  mDeviceOrientationAtCapture=mDeviceOrientation;
  keepScreenOn();
  mOrientationLocked=true;
  int degrees=CameraUtil.getDisplayRotation(mActivity);
  int cameraId=CameraHolder.instance().getBackCameraId();
  int orientation=CameraUtil.getDisplayOrientation(degrees,cameraId);
  mUI.setProgressOrientation(orientation);
}","The original code did not account for device orientation changes when calculating accumulated angles, potentially causing incorrect mosaic capture progress tracking. The fixed code adds orientation-specific angle inversion for 180 and 90-degree orientations, ensuring accurate angle calculations by negating horizontal and vertical accumulated angles. This modification improves the robustness of the panorama capture mechanism by correctly adapting to different device orientations and maintaining precise progress measurement."
38263,"@Override public void onProgress(boolean isFinished,float panningRateX,float panningRateY,float progressX,float progressY){
  float accumulatedHorizontalAngle=progressX * mHorizontalViewAngle;
  float accumulatedVerticalAngle=progressY * mVerticalViewAngle;
  boolean isRotated=!(mDeviceOrientationAtCapture == mDeviceOrientation);
  if (isFinished || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE) || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)|| isRotated) {
    stopCapture(false);
  }
 else {
    float panningRateXInDegree=panningRateX * mHorizontalViewAngle;
    float panningRateYInDegree=panningRateY * mVerticalViewAngle;
    mUI.updateCaptureProgress(panningRateXInDegree,panningRateYInDegree,accumulatedHorizontalAngle,accumulatedVerticalAngle,PANNING_SPEED_THRESHOLD);
  }
}","@Override public void onProgress(boolean isFinished,float panningRateX,float panningRateY,float progressX,float progressY){
  float accumulatedHorizontalAngle=progressX * mHorizontalViewAngle;
  float accumulatedVerticalAngle=progressY * mVerticalViewAngle;
  boolean isRotated=!(mDeviceOrientationAtCapture == mDeviceOrientation);
  if (isFinished || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE) || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)|| isRotated) {
    stopCapture(false);
  }
 else {
    float panningRateXInDegree=panningRateX * mHorizontalViewAngle;
    float panningRateYInDegree=panningRateY * mVerticalViewAngle;
    if (mDeviceOrientation == 180 || mDeviceOrientation == 90) {
      accumulatedHorizontalAngle=-accumulatedHorizontalAngle;
      accumulatedVerticalAngle=-accumulatedVerticalAngle;
    }
    mUI.updateCaptureProgress(panningRateXInDegree,panningRateYInDegree,accumulatedHorizontalAngle,accumulatedVerticalAngle,PANNING_SPEED_THRESHOLD);
  }
}","The original code did not account for device orientation changes, potentially causing incorrect angle calculations during panorama capture. The fixed code introduces orientation-specific angle sign adjustments by negating accumulated horizontal and vertical angles when the device is in 180 or 90-degree orientations. This modification ensures accurate progress tracking and prevents misalignment of panorama stitching across different device orientations."
38264,"public void startCapture(){
  mCancelComputation=false;
  mTimeTaken=System.currentTimeMillis();
  mActivity.setSwipingEnabled(false);
  mCaptureState=CAPTURE_STATE_MOSAIC;
  mUI.onStartCapture();
  Parameters parameters=mCameraDevice.getParameters();
  parameters.setAutoExposureLock(true);
  parameters.setAutoWhiteBalanceLock(true);
  configureCamera(parameters);
  mMosaicFrameProcessor.setProgressListener(new MosaicFrameProcessor.ProgressListener(){
    @Override public void onProgress(    boolean isFinished,    float panningRateX,    float panningRateY,    float progressX,    float progressY){
      float accumulatedHorizontalAngle=progressX * mHorizontalViewAngle;
      float accumulatedVerticalAngle=progressY * mVerticalViewAngle;
      boolean isRotated=!(mDeviceOrientationAtCapture == mDeviceOrientation);
      if (isFinished || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE) || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)|| isRotated) {
        stopCapture(false);
      }
 else {
        float panningRateXInDegree=panningRateX * mHorizontalViewAngle;
        float panningRateYInDegree=panningRateY * mVerticalViewAngle;
        mUI.updateCaptureProgress(panningRateXInDegree,panningRateYInDegree,accumulatedHorizontalAngle,accumulatedVerticalAngle,PANNING_SPEED_THRESHOLD);
      }
    }
  }
);
  mUI.resetCaptureProgress();
  mUI.setMaxCaptureProgress(DEFAULT_SWEEP_ANGLE);
  mUI.showCaptureProgress();
  mDeviceOrientationAtCapture=mDeviceOrientation;
  keepScreenOn();
  mOrientationLocked=true;
  int degrees=CameraUtil.getDisplayRotation(mActivity);
  int cameraId=CameraHolder.instance().getBackCameraId();
  int orientation=CameraUtil.getDisplayOrientation(degrees,cameraId);
  mUI.setProgressOrientation(orientation);
}","public void startCapture(){
  mCancelComputation=false;
  mTimeTaken=System.currentTimeMillis();
  mActivity.setSwipingEnabled(false);
  mCaptureState=CAPTURE_STATE_MOSAIC;
  mUI.onStartCapture();
  Parameters parameters=mCameraDevice.getParameters();
  parameters.setAutoExposureLock(true);
  parameters.setAutoWhiteBalanceLock(true);
  configureCamera(parameters);
  mMosaicFrameProcessor.setProgressListener(new MosaicFrameProcessor.ProgressListener(){
    @Override public void onProgress(    boolean isFinished,    float panningRateX,    float panningRateY,    float progressX,    float progressY){
      float accumulatedHorizontalAngle=progressX * mHorizontalViewAngle;
      float accumulatedVerticalAngle=progressY * mVerticalViewAngle;
      boolean isRotated=!(mDeviceOrientationAtCapture == mDeviceOrientation);
      if (isFinished || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE) || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)|| isRotated) {
        stopCapture(false);
      }
 else {
        float panningRateXInDegree=panningRateX * mHorizontalViewAngle;
        float panningRateYInDegree=panningRateY * mVerticalViewAngle;
        if (mDeviceOrientation == 180 || mDeviceOrientation == 90) {
          accumulatedHorizontalAngle=-accumulatedHorizontalAngle;
          accumulatedVerticalAngle=-accumulatedVerticalAngle;
        }
        mUI.updateCaptureProgress(panningRateXInDegree,panningRateYInDegree,accumulatedHorizontalAngle,accumulatedVerticalAngle,PANNING_SPEED_THRESHOLD);
      }
    }
  }
);
  mUI.resetCaptureProgress();
  mUI.setMaxCaptureProgress(DEFAULT_SWEEP_ANGLE);
  mUI.showCaptureProgress();
  mDeviceOrientationAtCapture=mDeviceOrientation;
  keepScreenOn();
  mOrientationLocked=true;
  int degrees=CameraUtil.getDisplayRotation(mActivity);
  int cameraId=CameraHolder.instance().getBackCameraId();
  int orientation=CameraUtil.getDisplayOrientation(degrees,cameraId);
  mUI.setProgressOrientation(orientation);
}","The original code did not account for device orientation when calculating accumulated angles, potentially causing incorrect mosaic capture progress tracking. The fixed code adds orientation-specific angle inversion for 180 and 90-degree orientations, ensuring accurate angle calculations by negating horizontal and vertical accumulated angles. This modification improves the capture experience by correctly adjusting angle measurements based on device orientation, leading to more precise and reliable panorama stitching."
38265,"public void layoutPreview(float ratio){
  FrameLayout.LayoutParams lp;
  float scaledTextureWidth, scaledTextureHeight;
  int rotation=CameraUtil.getDisplayRotation(mActivity);
  if (mScreenRatio == CameraUtil.RATIO_16_9 && CameraUtil.determineRatio(ratio) == CameraUtil.RATIO_4_3) {
    int l=(mTopMargin + mBottomMargin) * 4;
    int s=l * 9 / 16;
switch (rotation) {
case 90:
      lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
    lp.setMargins(mTopMargin,0,mBottomMargin,0);
  scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
case 180:
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mBottomMargin,0,mTopMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
case 270:
lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
lp.setMargins(mBottomMargin,0,mTopMargin,0);
scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
default :
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mTopMargin,0,mBottomMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
}
}
 else {
float width=mOriginalPreviewWidth, height=mOriginalPreviewHeight;
if (mOrientationResize) {
scaledTextureWidth=height * mAspectRatio;
if (scaledTextureWidth > width) {
scaledTextureWidth=width;
scaledTextureHeight=scaledTextureWidth / mAspectRatio;
}
 else {
scaledTextureHeight=height;
}
}
 else {
if (width > height) {
scaledTextureWidth=Math.max(width,height * mAspectRatio);
scaledTextureHeight=Math.max(height,width / mAspectRatio);
}
 else {
scaledTextureWidth=Math.max(width,height / mAspectRatio);
scaledTextureHeight=Math.max(height,width * mAspectRatio);
}
}
Log.v(TAG,""String_Node_Str"" + scaledTextureWidth + ""String_Node_Str""+ scaledTextureHeight);
int orientation=mActivity.getResources().getConfiguration().orientation;
if (((rotation == 0 || rotation == 180) && scaledTextureWidth > scaledTextureHeight) || ((rotation == 90 || rotation == 270) && scaledTextureWidth < scaledTextureHeight)) {
lp=new FrameLayout.LayoutParams((int)scaledTextureHeight,(int)scaledTextureWidth,Gravity.CENTER);
}
 else {
lp=new FrameLayout.LayoutParams((int)scaledTextureWidth,(int)scaledTextureHeight,Gravity.CENTER);
}
}
if (mSurfaceTextureUncroppedWidth != scaledTextureWidth || mSurfaceTextureUncroppedHeight != scaledTextureHeight) {
mSurfaceTextureUncroppedWidth=scaledTextureWidth;
mSurfaceTextureUncroppedHeight=scaledTextureHeight;
if (mSurfaceTextureSizeListener != null) {
mSurfaceTextureSizeListener.onSurfaceTextureSizeChanged((int)mSurfaceTextureUncroppedWidth,(int)mSurfaceTextureUncroppedHeight);
Log.d(TAG,""String_Node_Str"" + mSurfaceTextureUncroppedWidth + ""String_Node_Str""+ mSurfaceTextureUncroppedHeight);
}
}
mSurfaceView.setLayoutParams(lp);
if (mFaceView != null) {
mFaceView.setLayoutParams(lp);
}
}","public void layoutPreview(float ratio){
  FrameLayout.LayoutParams lp;
  float scaledTextureWidth, scaledTextureHeight;
  int rotation=CameraUtil.getDisplayRotation(mActivity);
  if (mScreenRatio == CameraUtil.RATIO_16_9 && CameraUtil.determineRatio(ratio) == CameraUtil.RATIO_4_3) {
    int l=(mTopMargin + mBottomMargin) * 4;
    int s=l * 9 / 16;
switch (rotation) {
case 90:
      lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
    lp.setMargins(mTopMargin,0,mBottomMargin,0);
  scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
case 180:
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mBottomMargin,0,mTopMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
case 270:
lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
lp.setMargins(mBottomMargin,0,mTopMargin,0);
scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
default :
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mTopMargin,0,mBottomMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
}
}
 else {
float width=mOriginalPreviewWidth, height=mOriginalPreviewHeight;
if (width == 0 || height == 0) return;
if (mOrientationResize) {
scaledTextureWidth=height * mAspectRatio;
if (scaledTextureWidth > width) {
scaledTextureWidth=width;
scaledTextureHeight=scaledTextureWidth / mAspectRatio;
}
 else {
scaledTextureHeight=height;
}
}
 else {
if (width > height) {
scaledTextureWidth=Math.max(width,height * mAspectRatio);
scaledTextureHeight=Math.max(height,width / mAspectRatio);
}
 else {
scaledTextureWidth=Math.max(width,height / mAspectRatio);
scaledTextureHeight=Math.max(height,width * mAspectRatio);
}
}
Log.v(TAG,""String_Node_Str"" + scaledTextureWidth + ""String_Node_Str""+ scaledTextureHeight);
int orientation=mActivity.getResources().getConfiguration().orientation;
if (((rotation == 0 || rotation == 180) && scaledTextureWidth > scaledTextureHeight) || ((rotation == 90 || rotation == 270) && scaledTextureWidth < scaledTextureHeight)) {
lp=new FrameLayout.LayoutParams((int)scaledTextureHeight,(int)scaledTextureWidth,Gravity.CENTER);
}
 else {
lp=new FrameLayout.LayoutParams((int)scaledTextureWidth,(int)scaledTextureHeight,Gravity.CENTER);
}
}
if (mSurfaceTextureUncroppedWidth != scaledTextureWidth || mSurfaceTextureUncroppedHeight != scaledTextureHeight) {
mSurfaceTextureUncroppedWidth=scaledTextureWidth;
mSurfaceTextureUncroppedHeight=scaledTextureHeight;
if (mSurfaceTextureSizeListener != null) {
mSurfaceTextureSizeListener.onSurfaceTextureSizeChanged((int)mSurfaceTextureUncroppedWidth,(int)mSurfaceTextureUncroppedHeight);
Log.d(TAG,""String_Node_Str"" + mSurfaceTextureUncroppedWidth + ""String_Node_Str""+ mSurfaceTextureUncroppedHeight);
}
}
mSurfaceView.setLayoutParams(lp);
if (mFaceView != null) {
mFaceView.setLayoutParams(lp);
}
}","The original code lacked a critical check for zero-width or zero-height dimensions, which could lead to potential division-by-zero errors or unexpected layout calculations. The fixed code adds an early return condition `if (width == 0 || height == 0) return;` to prevent processing invalid dimensions, ensuring robust preview layout handling. This modification prevents runtime exceptions and improves the method's reliability by gracefully handling edge cases where preview dimensions are uninitialized or invalid."
38266,"public void layoutPreview(float ratio){
  FrameLayout.LayoutParams lp;
  float scaledTextureWidth, scaledTextureHeight;
  int rotation=CameraUtil.getDisplayRotation(mActivity);
  if (mScreenRatio == CameraUtil.RATIO_16_9 && CameraUtil.determineRatio(ratio) == CameraUtil.RATIO_4_3) {
    int l=(mTopMargin + mBottomMargin) * 4;
    int s=l * 9 / 16;
switch (rotation) {
case 90:
      lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
    lp.setMargins(mTopMargin,0,mBottomMargin,0);
  scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
case 180:
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mBottomMargin,0,mTopMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
case 270:
lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
lp.setMargins(mBottomMargin,0,mTopMargin,0);
scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
default :
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mTopMargin,0,mBottomMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
}
}
 else {
float width=mOriginalPreviewWidth, height=mOriginalPreviewHeight;
if (mOrientationResize) {
scaledTextureWidth=height * mAspectRatio;
if (scaledTextureWidth > width) {
scaledTextureWidth=width;
scaledTextureHeight=scaledTextureWidth / mAspectRatio;
}
 else {
scaledTextureHeight=height;
}
}
 else {
if (width > height) {
scaledTextureWidth=Math.max(width,height * mAspectRatio);
scaledTextureHeight=Math.max(height,width / mAspectRatio);
}
 else {
scaledTextureWidth=Math.max(width,height / mAspectRatio);
scaledTextureHeight=Math.max(height,width * mAspectRatio);
}
}
Log.v(TAG,""String_Node_Str"" + scaledTextureWidth + ""String_Node_Str""+ scaledTextureHeight);
int orientation=mActivity.getResources().getConfiguration().orientation;
if (((rotation == 0 || rotation == 180) && scaledTextureWidth > scaledTextureHeight) || ((rotation == 90 || rotation == 270) && scaledTextureWidth < scaledTextureHeight)) {
lp=new FrameLayout.LayoutParams((int)scaledTextureHeight,(int)scaledTextureWidth,Gravity.CENTER);
}
 else {
lp=new FrameLayout.LayoutParams((int)scaledTextureWidth,(int)scaledTextureHeight,Gravity.CENTER);
}
}
if (mSurfaceTextureUncroppedWidth != scaledTextureWidth || mSurfaceTextureUncroppedHeight != scaledTextureHeight) {
mSurfaceTextureUncroppedWidth=scaledTextureWidth;
mSurfaceTextureUncroppedHeight=scaledTextureHeight;
if (mSurfaceTextureSizeListener != null) {
mSurfaceTextureSizeListener.onSurfaceTextureSizeChanged((int)mSurfaceTextureUncroppedWidth,(int)mSurfaceTextureUncroppedHeight);
Log.d(TAG,""String_Node_Str"" + mSurfaceTextureUncroppedWidth + ""String_Node_Str""+ mSurfaceTextureUncroppedHeight);
}
}
mSurfaceView.setLayoutParams(lp);
if (mFaceView != null) {
mFaceView.setLayoutParams(lp);
}
}","public void layoutPreview(float ratio){
  FrameLayout.LayoutParams lp;
  float scaledTextureWidth, scaledTextureHeight;
  int rotation=CameraUtil.getDisplayRotation(mActivity);
  if (mScreenRatio == CameraUtil.RATIO_16_9 && CameraUtil.determineRatio(ratio) == CameraUtil.RATIO_4_3) {
    int l=(mTopMargin + mBottomMargin) * 4;
    int s=l * 9 / 16;
switch (rotation) {
case 90:
      lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
    lp.setMargins(mTopMargin,0,mBottomMargin,0);
  scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
case 180:
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mBottomMargin,0,mTopMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
case 270:
lp=new FrameLayout.LayoutParams(l * 3 / 4,s);
lp.setMargins(mBottomMargin,0,mTopMargin,0);
scaledTextureWidth=l * 3 / 4;
scaledTextureHeight=s;
break;
default :
lp=new FrameLayout.LayoutParams(s,l * 3 / 4);
lp.setMargins(0,mTopMargin,0,mBottomMargin);
scaledTextureWidth=s;
scaledTextureHeight=l * 3 / 4;
break;
}
}
 else {
float width=mOriginalPreviewWidth, height=mOriginalPreviewHeight;
if (width == 0 || height == 0) return;
if (mOrientationResize) {
scaledTextureWidth=height * mAspectRatio;
if (scaledTextureWidth > width) {
scaledTextureWidth=width;
scaledTextureHeight=scaledTextureWidth / mAspectRatio;
}
 else {
scaledTextureHeight=height;
}
}
 else {
if (width > height) {
scaledTextureWidth=Math.max(width,height * mAspectRatio);
scaledTextureHeight=Math.max(height,width / mAspectRatio);
}
 else {
scaledTextureWidth=Math.max(width,height / mAspectRatio);
scaledTextureHeight=Math.max(height,width * mAspectRatio);
}
}
Log.v(TAG,""String_Node_Str"" + scaledTextureWidth + ""String_Node_Str""+ scaledTextureHeight);
int orientation=mActivity.getResources().getConfiguration().orientation;
if (((rotation == 0 || rotation == 180) && scaledTextureWidth > scaledTextureHeight) || ((rotation == 90 || rotation == 270) && scaledTextureWidth < scaledTextureHeight)) {
lp=new FrameLayout.LayoutParams((int)scaledTextureHeight,(int)scaledTextureWidth,Gravity.CENTER);
}
 else {
lp=new FrameLayout.LayoutParams((int)scaledTextureWidth,(int)scaledTextureHeight,Gravity.CENTER);
}
}
if (mSurfaceTextureUncroppedWidth != scaledTextureWidth || mSurfaceTextureUncroppedHeight != scaledTextureHeight) {
mSurfaceTextureUncroppedWidth=scaledTextureWidth;
mSurfaceTextureUncroppedHeight=scaledTextureHeight;
if (mSurfaceTextureSizeListener != null) {
mSurfaceTextureSizeListener.onSurfaceTextureSizeChanged((int)mSurfaceTextureUncroppedWidth,(int)mSurfaceTextureUncroppedHeight);
Log.d(TAG,""String_Node_Str"" + mSurfaceTextureUncroppedWidth + ""String_Node_Str""+ mSurfaceTextureUncroppedHeight);
}
}
mSurfaceView.setLayoutParams(lp);
if (mFaceView != null) {
mFaceView.setLayoutParams(lp);
}
}","The original code lacked a critical null or zero-width check, potentially causing division by zero or layout calculation errors when preview dimensions were uninitialized. The fixed code adds an early return `if (width == 0 || height == 0)` to prevent invalid calculations, ensuring safe and robust preview layout scaling. This modification prevents potential runtime crashes and provides more stable camera preview rendering across different device configurations and orientations."
38267,"private void switchCamera(){
  if (mPaused)   return;
  Log.v(TAG,""String_Node_Str"" + mPendingSwitchCameraId);
  mCameraId=mPendingSwitchCameraId;
  mPendingSwitchCameraId=-1;
  setCameraId(mCameraId);
  closeCamera();
  mUI.collapseCameraControls();
  mUI.clearFaces();
  disableSkinToneSeekBar();
  if (mFocusManager != null)   mFocusManager.removeMessages();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mCameraDevice=CameraUtil.openCamera(mActivity,mCameraId,mHandler,mActivity.getCameraOpenErrorCallback());
  if (mCameraDevice == null) {
    Log.e(TAG,""String_Node_Str"" + mCameraId + ""String_Node_Str"");
    return;
  }
  mParameters=mCameraDevice.getParameters();
  mInitialParams=mParameters;
  initializeCapabilities();
  CameraInfo info=CameraHolder.instance().getCameraInfo()[mCameraId];
  mMirror=(info.facing == CameraInfo.CAMERA_FACING_FRONT);
  mFocusManager.setMirror(mMirror);
  mFocusManager.setParameters(mInitialParams);
  setupPreview();
  mZoomValue=0;
  resizeForPreviewAspectRatio();
  openCameraCommon();
  mHandler.sendEmptyMessage(SWITCH_CAMERA_START_ANIMATION);
}","private void switchCamera(){
  if (mPaused)   return;
  Log.v(TAG,""String_Node_Str"" + mPendingSwitchCameraId);
  mCameraId=mPendingSwitchCameraId;
  mPendingSwitchCameraId=-1;
  setCameraId(mCameraId);
  try {
    if (mOpenCameraThread != null) {
      mOpenCameraThread.join();
      mOpenCameraThread=null;
    }
  }
 catch (  InterruptedException ex) {
  }
  closeCamera();
  mUI.collapseCameraControls();
  mUI.clearFaces();
  disableSkinToneSeekBar();
  if (mFocusManager != null)   mFocusManager.removeMessages();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mCameraDevice=CameraUtil.openCamera(mActivity,mCameraId,mHandler,mActivity.getCameraOpenErrorCallback());
  if (mCameraDevice == null) {
    Log.e(TAG,""String_Node_Str"" + mCameraId + ""String_Node_Str"");
    return;
  }
  mParameters=mCameraDevice.getParameters();
  mInitialParams=mParameters;
  initializeCapabilities();
  CameraInfo info=CameraHolder.instance().getCameraInfo()[mCameraId];
  mMirror=(info.facing == CameraInfo.CAMERA_FACING_FRONT);
  mFocusManager.setMirror(mMirror);
  mFocusManager.setParameters(mInitialParams);
  setupPreview();
  mZoomValue=0;
  resizeForPreviewAspectRatio();
  openCameraCommon();
  mHandler.sendEmptyMessage(SWITCH_CAMERA_START_ANIMATION);
}","The original code lacked proper thread synchronization when switching cameras, potentially causing race conditions or premature camera operations. The fixed code adds a thread join mechanism to wait for any ongoing camera open thread to complete before proceeding with camera switching. This ensures safer and more predictable camera state management, preventing potential concurrent access issues and improving the overall reliability of the camera switching process."
38268,"private void switchCamera(){
  if (mPaused)   return;
  Log.v(TAG,""String_Node_Str"" + mPendingSwitchCameraId);
  mCameraId=mPendingSwitchCameraId;
  mPendingSwitchCameraId=-1;
  setCameraId(mCameraId);
  closeCamera();
  mUI.collapseCameraControls();
  mUI.clearFaces();
  disableSkinToneSeekBar();
  if (mFocusManager != null)   mFocusManager.removeMessages();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mCameraDevice=CameraUtil.openCamera(mActivity,mCameraId,mHandler,mActivity.getCameraOpenErrorCallback());
  if (mCameraDevice == null) {
    Log.e(TAG,""String_Node_Str"" + mCameraId + ""String_Node_Str"");
    return;
  }
  mParameters=mCameraDevice.getParameters();
  mInitialParams=mParameters;
  initializeCapabilities();
  CameraInfo info=CameraHolder.instance().getCameraInfo()[mCameraId];
  mMirror=(info.facing == CameraInfo.CAMERA_FACING_FRONT);
  mFocusManager.setMirror(mMirror);
  mFocusManager.setParameters(mInitialParams);
  setupPreview();
  mZoomValue=0;
  resizeForPreviewAspectRatio();
  openCameraCommon();
  mHandler.sendEmptyMessage(SWITCH_CAMERA_START_ANIMATION);
}","private void switchCamera(){
  if (mPaused)   return;
  Log.v(TAG,""String_Node_Str"" + mPendingSwitchCameraId);
  mCameraId=mPendingSwitchCameraId;
  mPendingSwitchCameraId=-1;
  setCameraId(mCameraId);
  try {
    if (mOpenCameraThread != null) {
      mOpenCameraThread.join();
      mOpenCameraThread=null;
    }
  }
 catch (  InterruptedException ex) {
  }
  closeCamera();
  mUI.collapseCameraControls();
  mUI.clearFaces();
  disableSkinToneSeekBar();
  if (mFocusManager != null)   mFocusManager.removeMessages();
  mPreferences.setLocalId(mActivity,mCameraId);
  CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
  mCameraDevice=CameraUtil.openCamera(mActivity,mCameraId,mHandler,mActivity.getCameraOpenErrorCallback());
  if (mCameraDevice == null) {
    Log.e(TAG,""String_Node_Str"" + mCameraId + ""String_Node_Str"");
    return;
  }
  mParameters=mCameraDevice.getParameters();
  mInitialParams=mParameters;
  initializeCapabilities();
  CameraInfo info=CameraHolder.instance().getCameraInfo()[mCameraId];
  mMirror=(info.facing == CameraInfo.CAMERA_FACING_FRONT);
  mFocusManager.setMirror(mMirror);
  mFocusManager.setParameters(mInitialParams);
  setupPreview();
  mZoomValue=0;
  resizeForPreviewAspectRatio();
  openCameraCommon();
  mHandler.sendEmptyMessage(SWITCH_CAMERA_START_ANIMATION);
}","The original code lacked proper thread synchronization when switching cameras, potentially causing race conditions or premature camera operations. The fixed code adds a thread join mechanism with `mOpenCameraThread.join()` to ensure any ongoing camera opening thread completes before proceeding with camera switch. This prevents potential concurrent access issues and ensures a more stable and predictable camera switching process by properly managing thread synchronization."
38269,"private boolean stopVideoRecording(){
  Log.v(TAG,""String_Node_Str"");
  mStopRecPending=true;
  mUI.setSwipingEnabled(true);
  if (!isVideoCaptureIntent()) {
    mUI.showSwitcher();
  }
  boolean fail=false;
  if (mMediaRecorderRecording) {
    boolean shouldAddToMediaStoreNow=false;
    try {
      mMediaRecorder.setOnErrorListener(null);
      mMediaRecorder.setOnInfoListener(null);
      mMediaRecorder.stop();
      shouldAddToMediaStoreNow=true;
      mCurrentVideoFilename=mVideoFilename;
      Log.v(TAG,""String_Node_Str"" + mCurrentVideoFilename);
      AccessibilityUtils.makeAnnouncement(mUI.getShutterButton(),mActivity.getString(R.string.video_recording_stopped));
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"",e);
      if (mVideoFilename != null)       deleteVideoFile(mVideoFilename);
      fail=true;
    }
    mMediaRecorderRecording=false;
    mSnapshotInProgress=false;
    mOrientationManager.unlockOrientation();
    if (mPaused) {
      closeCamera();
    }
    mUI.showRecordingUI(false);
    if (!mIsVideoCaptureIntent) {
      mUI.enableCameraControls(true);
    }
    mUI.setOrientationIndicator(0,true);
    keepScreenOnAwhile();
    if (shouldAddToMediaStoreNow && !fail) {
      if (mVideoFileDescriptor == null) {
        saveVideo();
      }
 else       if (mIsVideoCaptureIntent) {
        showCaptureResult();
      }
    }
  }
  releaseMediaRecorder();
  if (!mPaused) {
    mCameraDevice.lock();
    if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
      stopPreview();
      mUI.hideSurfaceView();
      startPreview();
    }
  }
  if (!mPaused)   mParameters=mCameraDevice.getParameters();
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,fail ? UsageStatistics.ACTION_CAPTURE_FAIL : UsageStatistics.ACTION_CAPTURE_DONE,""String_Node_Str"",SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime);
  mStopRecPending=false;
  return fail;
}","private boolean stopVideoRecording(){
  Log.v(TAG,""String_Node_Str"");
  mStopRecPending=true;
  mUI.setSwipingEnabled(true);
  if (!isVideoCaptureIntent()) {
    mUI.showSwitcher();
  }
  boolean fail=false;
  if (mMediaRecorderRecording) {
    boolean shouldAddToMediaStoreNow=false;
    try {
      mMediaRecorder.setOnErrorListener(null);
      mMediaRecorder.setOnInfoListener(null);
      mMediaRecorder.stop();
      shouldAddToMediaStoreNow=true;
      mCurrentVideoFilename=mVideoFilename;
      Log.v(TAG,""String_Node_Str"" + mCurrentVideoFilename);
      AccessibilityUtils.makeAnnouncement(mUI.getShutterButton(),mActivity.getString(R.string.video_recording_stopped));
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"",e);
      if (mVideoFilename != null)       deleteVideoFile(mVideoFilename);
      fail=true;
    }
    mMediaRecorderRecording=false;
    mSnapshotInProgress=false;
    mOrientationManager.unlockOrientation();
    if (mPaused) {
      closeCamera();
    }
    mUI.showRecordingUI(false);
    if (!mIsVideoCaptureIntent) {
      mUI.enableCameraControls(true);
    }
    mUI.setOrientationIndicator(0,true);
    keepScreenOnAwhile();
    if (shouldAddToMediaStoreNow && !fail) {
      if (mVideoFileDescriptor == null) {
        saveVideo();
      }
 else       if (mIsVideoCaptureIntent) {
        showCaptureResult();
      }
    }
  }
  releaseMediaRecorder();
  if (!mPaused) {
    mCameraDevice.lock();
    if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
      stopPreview();
      mUI.hideSurfaceView();
      startPreview();
    }
  }
  if (!mPaused)   mParameters=mCameraDevice.getParameters();
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,fail ? UsageStatistics.ACTION_CAPTURE_FAIL : UsageStatistics.ACTION_CAPTURE_DONE,""String_Node_Str"",mMediaRecorderPausing ? mRecordingTotalTime : SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime);
  mStopRecPending=false;
  return fail;
}","The original code incorrectly calculated recording time by always using `SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime`, which could lead to inaccurate time tracking during paused recordings. The fixed code introduces a conditional check `mMediaRecorderPausing ? mRecordingTotalTime : SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime`, which correctly handles time calculation for both ongoing and paused video recordings. This modification ensures more precise recording duration tracking, preventing potential timing discrepancies in usage statistics."
38270,"private void saveVideo(){
  if (mVideoFileDescriptor == null) {
    long duration=SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime;
    if (duration > 0) {
      if (mCaptureTimeLapse) {
        duration=getTimeLapseVideoLength(duration);
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + duration);
    }
    File origFile=new File(mCurrentVideoFilename);
    if (!origFile.exists() || origFile.length() <= 0) {
      Log.e(TAG,""String_Node_Str"");
      mCurrentVideoValues=null;
      return;
    }
    String hfr=mParameters.getVideoHighFrameRate();
    int defaultFps=30;
    int hfrRatio=1;
    if (!(""String_Node_Str"".equals(hfr))) {
      try {
        int hfrFps=Integer.parseInt(hfr);
        hfrRatio=hfrFps / defaultFps;
      }
 catch (      NumberFormatException ex) {
        Log.e(TAG,""String_Node_Str"" + hfr);
      }
    }
    duration=duration * hfrRatio;
    mActivity.getMediaSaveService().addVideo(mCurrentVideoFilename,duration,mCurrentVideoValues,mOnVideoSavedListener,mContentResolver);
  }
  mCurrentVideoValues=null;
}","private void saveVideo(){
  if (mVideoFileDescriptor == null) {
    long duration=0L;
    if (mMediaRecorderPausing == false)     duration=SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime;
 else     duration=mRecordingTotalTime;
    if (duration > 0) {
      if (mCaptureTimeLapse) {
        duration=getTimeLapseVideoLength(duration);
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + duration);
    }
    File origFile=new File(mCurrentVideoFilename);
    if (!origFile.exists() || origFile.length() <= 0) {
      Log.e(TAG,""String_Node_Str"");
      mCurrentVideoValues=null;
      return;
    }
    String hfr=mParameters.getVideoHighFrameRate();
    int defaultFps=30;
    int hfrRatio=1;
    if (!(""String_Node_Str"".equals(hfr))) {
      try {
        int hfrFps=Integer.parseInt(hfr);
        hfrRatio=hfrFps / defaultFps;
      }
 catch (      NumberFormatException ex) {
        Log.e(TAG,""String_Node_Str"" + hfr);
      }
    }
    duration=duration * hfrRatio;
    mActivity.getMediaSaveService().addVideo(mCurrentVideoFilename,duration,mCurrentVideoValues,mOnVideoSavedListener,mContentResolver);
  }
  mCurrentVideoValues=null;
}","The original code did not handle video recording duration correctly when pausing, potentially calculating an incorrect total recording time. The fixed code introduces a conditional check using `mMediaRecorderPausing` to determine whether to calculate duration based on current recording time or total recorded time. This ensures accurate duration calculation during video recording, preventing potential timing discrepancies and providing a more robust method for tracking video length across pause and resume scenarios."
38271,"private boolean stopVideoRecording(){
  Log.v(TAG,""String_Node_Str"");
  mStopRecPending=true;
  mUI.setSwipingEnabled(true);
  if (!isVideoCaptureIntent()) {
    mUI.showSwitcher();
  }
  boolean fail=false;
  if (mMediaRecorderRecording) {
    boolean shouldAddToMediaStoreNow=false;
    try {
      mMediaRecorder.setOnErrorListener(null);
      mMediaRecorder.setOnInfoListener(null);
      mMediaRecorder.stop();
      shouldAddToMediaStoreNow=true;
      mCurrentVideoFilename=mVideoFilename;
      Log.v(TAG,""String_Node_Str"" + mCurrentVideoFilename);
      AccessibilityUtils.makeAnnouncement(mUI.getShutterButton(),mActivity.getString(R.string.video_recording_stopped));
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"",e);
      if (mVideoFilename != null)       deleteVideoFile(mVideoFilename);
      fail=true;
    }
    mMediaRecorderRecording=false;
    mSnapshotInProgress=false;
    mOrientationManager.unlockOrientation();
    if (mPaused) {
      closeCamera();
    }
    mUI.showRecordingUI(false);
    if (!mIsVideoCaptureIntent) {
      mUI.enableCameraControls(true);
    }
    mUI.setOrientationIndicator(0,true);
    keepScreenOnAwhile();
    if (shouldAddToMediaStoreNow && !fail) {
      if (mVideoFileDescriptor == null) {
        saveVideo();
      }
 else       if (mIsVideoCaptureIntent) {
        showCaptureResult();
      }
    }
  }
  releaseMediaRecorder();
  if (!mPaused) {
    mCameraDevice.lock();
    if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
      stopPreview();
      mUI.hideSurfaceView();
      startPreview();
    }
  }
  if (!mPaused)   mParameters=mCameraDevice.getParameters();
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,fail ? UsageStatistics.ACTION_CAPTURE_FAIL : UsageStatistics.ACTION_CAPTURE_DONE,""String_Node_Str"",SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime);
  mStopRecPending=false;
  return fail;
}","private boolean stopVideoRecording(){
  Log.v(TAG,""String_Node_Str"");
  mStopRecPending=true;
  mUI.setSwipingEnabled(true);
  if (!isVideoCaptureIntent()) {
    mUI.showSwitcher();
  }
  boolean fail=false;
  if (mMediaRecorderRecording) {
    boolean shouldAddToMediaStoreNow=false;
    try {
      mMediaRecorder.setOnErrorListener(null);
      mMediaRecorder.setOnInfoListener(null);
      mMediaRecorder.stop();
      shouldAddToMediaStoreNow=true;
      mCurrentVideoFilename=mVideoFilename;
      Log.v(TAG,""String_Node_Str"" + mCurrentVideoFilename);
      AccessibilityUtils.makeAnnouncement(mUI.getShutterButton(),mActivity.getString(R.string.video_recording_stopped));
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"",e);
      if (mVideoFilename != null)       deleteVideoFile(mVideoFilename);
      fail=true;
    }
    mMediaRecorderRecording=false;
    mSnapshotInProgress=false;
    mOrientationManager.unlockOrientation();
    if (mPaused) {
      closeCamera();
    }
    mUI.showRecordingUI(false);
    if (!mIsVideoCaptureIntent) {
      mUI.enableCameraControls(true);
    }
    mUI.setOrientationIndicator(0,true);
    keepScreenOnAwhile();
    if (shouldAddToMediaStoreNow && !fail) {
      if (mVideoFileDescriptor == null) {
        saveVideo();
      }
 else       if (mIsVideoCaptureIntent) {
        showCaptureResult();
      }
    }
  }
  releaseMediaRecorder();
  if (!mPaused) {
    mCameraDevice.lock();
    if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
      stopPreview();
      mUI.hideSurfaceView();
      startPreview();
    }
  }
  if (!mPaused)   mParameters=mCameraDevice.getParameters();
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,fail ? UsageStatistics.ACTION_CAPTURE_FAIL : UsageStatistics.ACTION_CAPTURE_DONE,""String_Node_Str"",mMediaRecorderPausing ? mRecordingTotalTime : SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime);
  mStopRecPending=false;
  return fail;
}","The original code incorrectly calculated recording time by always using SystemClock.uptimeMillis(), which could lead to inaccurate duration tracking during paused recordings. The fixed code introduces a conditional check with mMediaRecorderPausing to determine whether to use the total accumulated recording time or calculate the current session's duration. This modification ensures more precise recording time measurement, especially for videos that might have been paused during recording, thus providing a more accurate representation of the actual recording duration."
38272,"private void saveVideo(){
  if (mVideoFileDescriptor == null) {
    long duration=SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime;
    if (duration > 0) {
      if (mCaptureTimeLapse) {
        duration=getTimeLapseVideoLength(duration);
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + duration);
    }
    File origFile=new File(mCurrentVideoFilename);
    if (!origFile.exists() || origFile.length() <= 0) {
      Log.e(TAG,""String_Node_Str"");
      mCurrentVideoValues=null;
      return;
    }
    String hfr=mParameters.getVideoHighFrameRate();
    int defaultFps=30;
    int hfrRatio=1;
    if (!(""String_Node_Str"".equals(hfr))) {
      try {
        int hfrFps=Integer.parseInt(hfr);
        hfrRatio=hfrFps / defaultFps;
      }
 catch (      NumberFormatException ex) {
        Log.e(TAG,""String_Node_Str"" + hfr);
      }
    }
    duration=duration * hfrRatio;
    mActivity.getMediaSaveService().addVideo(mCurrentVideoFilename,duration,mCurrentVideoValues,mOnVideoSavedListener,mContentResolver);
  }
  mCurrentVideoValues=null;
}","private void saveVideo(){
  if (mVideoFileDescriptor == null) {
    long duration=0L;
    if (mMediaRecorderPausing == false)     duration=SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime;
 else     duration=mRecordingTotalTime;
    if (duration > 0) {
      if (mCaptureTimeLapse) {
        duration=getTimeLapseVideoLength(duration);
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + duration);
    }
    File origFile=new File(mCurrentVideoFilename);
    if (!origFile.exists() || origFile.length() <= 0) {
      Log.e(TAG,""String_Node_Str"");
      mCurrentVideoValues=null;
      return;
    }
    String hfr=mParameters.getVideoHighFrameRate();
    int defaultFps=30;
    int hfrRatio=1;
    if (!(""String_Node_Str"".equals(hfr))) {
      try {
        int hfrFps=Integer.parseInt(hfr);
        hfrRatio=hfrFps / defaultFps;
      }
 catch (      NumberFormatException ex) {
        Log.e(TAG,""String_Node_Str"" + hfr);
      }
    }
    duration=duration * hfrRatio;
    mActivity.getMediaSaveService().addVideo(mCurrentVideoFilename,duration,mCurrentVideoValues,mOnVideoSavedListener,mContentResolver);
  }
  mCurrentVideoValues=null;
}","The original code incorrectly calculated video duration without considering whether recording was paused, potentially leading to inaccurate time measurements. The fixed code introduces a conditional check using `mMediaRecorderPausing` to determine whether to calculate duration from the current recording session or use the total recorded time. This modification ensures more precise video duration tracking, preventing potential timing errors and improving the accuracy of video recording and saving processes."
38273,"@Override public void onPictureTaken(final byte[] jpegData,CameraProxy camera){
  mUI.enableShutter(true);
  if (mPaused) {
    return;
  }
  if (mIsImageCaptureIntent) {
    stopPreview();
  }
  if (mSceneMode == CameraUtil.SCENE_MODE_HDR) {
    mUI.showSwitcher();
    mUI.setSwipingEnabled(true);
  }
  mReceivedSnapNum=mReceivedSnapNum + 1;
  mJpegPictureCallbackTime=System.currentTimeMillis();
  if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
    Log.v(TAG,""String_Node_Str"");
    mParameters=mCameraDevice.getParameters();
    mBurstSnapNum=mParameters.getInt(""String_Node_Str"");
  }
  Log.v(TAG,""String_Node_Str"" + mReceivedSnapNum + ""String_Node_Str""+ mBurstSnapNum);
  if (mPostViewPictureCallbackTime != 0) {
    mShutterToPictureDisplayedTime=mPostViewPictureCallbackTime - mShutterCallbackTime;
    mPictureDisplayedToJpegCallbackTime=mJpegPictureCallbackTime - mPostViewPictureCallbackTime;
  }
 else {
    mShutterToPictureDisplayedTime=mRawPictureCallbackTime - mShutterCallbackTime;
    mPictureDisplayedToJpegCallbackTime=mJpegPictureCallbackTime - mRawPictureCallbackTime;
  }
  Log.v(TAG,""String_Node_Str"" + mPictureDisplayedToJpegCallbackTime + ""String_Node_Str"");
  mFocusManager.updateFocusUI();
  boolean needRestartPreview=!mIsImageCaptureIntent && !mPreviewRestartSupport && (mCameraState != LONGSHOT)&& (mSnapshotMode != CameraInfo.CAMERA_SUPPORT_MODE_ZSL)&& (mReceivedSnapNum == mBurstSnapNum);
  if (needRestartPreview) {
    setupPreview();
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
  }
 else   if ((mReceivedSnapNum == mBurstSnapNum) && (mCameraState != LONGSHOT)) {
    mFocusManager.resetTouchFocus();
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
    mUI.resumeFaceDetection();
    setCameraState(IDLE);
  }
  ExifInterface exif=Exif.getExif(jpegData);
  int orientation=Exif.getOrientation(exif);
  if (!mIsImageCaptureIntent) {
    if (mReceivedSnapNum > 1)     mNamedImages.nameNewImage(mCaptureStartTime);
    Size s=mParameters.getPictureSize();
    int width, height;
    if ((mJpegRotation + orientation) % 180 == 0) {
      width=s.width;
      height=s.height;
    }
 else {
      width=s.height;
      height=s.width;
    }
    String pictureFormat=mParameters.get(KEY_PICTURE_FORMAT);
    if (pictureFormat != null && !pictureFormat.equalsIgnoreCase(PIXEL_FORMAT_JPEG)) {
      String pair=mParameters.get(KEY_QC_RAW_PICUTRE_SIZE);
      if (pair != null) {
        int pos=pair.indexOf('x');
        if (pos != -1) {
          width=Integer.parseInt(pair.substring(0,pos));
          height=Integer.parseInt(pair.substring(pos + 1));
        }
      }
    }
    NamedEntity name=mNamedImages.getNextNameEntity();
    String title=(name == null) ? null : name.title;
    long date=(name == null) ? -1 : name.date;
    if (mDebugUri != null) {
      saveToDebugUri(jpegData);
      if (title != null) {
        title=DEBUG_IMAGE_PREFIX + title;
      }
    }
    if (title == null) {
      Log.e(TAG,""String_Node_Str"");
    }
 else {
      if (date == -1)       date=mCaptureStartTime;
      if (mHeading >= 0) {
        ExifTag directionRefTag=exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION_REF,ExifInterface.GpsTrackRef.MAGNETIC_DIRECTION);
        ExifTag directionTag=exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION,new Rational(mHeading,1));
        exif.setTag(directionRefTag);
        exif.setTag(directionTag);
      }
      String mPictureFormat=mParameters.get(KEY_PICTURE_FORMAT);
      mActivity.getMediaSaveService().addImage(jpegData,title,date,mLocation,width,height,orientation,exif,mOnMediaSavedListener,mContentResolver,mPictureFormat);
    }
    if (mCameraState != LONGSHOT) {
      Size pic_size=mParameters.getPictureSize();
      if ((pic_size.width <= 352) && (pic_size.height <= 288)) {
        mUI.setDownFactor(2);
      }
 else {
        mUI.setDownFactor(4);
      }
      mUI.animateCapture(jpegData,orientation,mMirror);
    }
  }
 else {
    mJpegImageData=jpegData;
    if (!mQuickCapture) {
      mUI.showCapturedImageForReview(jpegData,orientation,mMirror);
    }
 else {
      onCaptureDone();
    }
  }
  mActivity.updateStorageSpaceAndHint();
  long now=System.currentTimeMillis();
  mJpegCallbackFinishTime=now - mJpegPictureCallbackTime;
  Log.v(TAG,""String_Node_Str"" + mJpegCallbackFinishTime + ""String_Node_Str"");
  if (mReceivedSnapNum == mBurstSnapNum)   mJpegPictureCallbackTime=0;
  if (mHiston && (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL)) {
    mActivity.runOnUiThread(new Runnable(){
      public void run(){
        if (mGraphView != null) {
          mGraphView.setVisibility(View.VISIBLE);
          mGraphView.PreviewChanged();
        }
      }
    }
);
  }
  if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL && mCameraState != LONGSHOT && mReceivedSnapNum == mBurstSnapNum) {
    cancelAutoFocus();
  }
}","@Override public void onPictureTaken(final byte[] jpegData,CameraProxy camera){
  mUI.enableShutter(true);
  if (mPaused) {
    return;
  }
  if (mIsImageCaptureIntent) {
    stopPreview();
  }
  if (mSceneMode == CameraUtil.SCENE_MODE_HDR) {
    mUI.showSwitcher();
    mUI.setSwipingEnabled(true);
  }
  mReceivedSnapNum=mReceivedSnapNum + 1;
  mJpegPictureCallbackTime=System.currentTimeMillis();
  if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
    Log.v(TAG,""String_Node_Str"");
    mParameters=mCameraDevice.getParameters();
    mBurstSnapNum=mParameters.getInt(""String_Node_Str"");
  }
  Log.v(TAG,""String_Node_Str"" + mReceivedSnapNum + ""String_Node_Str""+ mBurstSnapNum);
  if (mPostViewPictureCallbackTime != 0) {
    mShutterToPictureDisplayedTime=mPostViewPictureCallbackTime - mShutterCallbackTime;
    mPictureDisplayedToJpegCallbackTime=mJpegPictureCallbackTime - mPostViewPictureCallbackTime;
  }
 else {
    mShutterToPictureDisplayedTime=mRawPictureCallbackTime - mShutterCallbackTime;
    mPictureDisplayedToJpegCallbackTime=mJpegPictureCallbackTime - mRawPictureCallbackTime;
  }
  Log.v(TAG,""String_Node_Str"" + mPictureDisplayedToJpegCallbackTime + ""String_Node_Str"");
  mFocusManager.updateFocusUI();
  boolean needRestartPreview=!mIsImageCaptureIntent && !mPreviewRestartSupport && (mCameraState != LONGSHOT)&& (mSnapshotMode != CameraInfo.CAMERA_SUPPORT_MODE_ZSL)&& (mReceivedSnapNum == mBurstSnapNum);
  if (needRestartPreview) {
    setupPreview();
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
  }
 else   if ((mReceivedSnapNum == mBurstSnapNum) && (mCameraState != LONGSHOT)) {
    mFocusManager.resetTouchFocus();
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
    mUI.resumeFaceDetection();
    if (!mIsImageCaptureIntent) {
      setCameraState(IDLE);
    }
  }
  ExifInterface exif=Exif.getExif(jpegData);
  int orientation=Exif.getOrientation(exif);
  if (!mIsImageCaptureIntent) {
    if (mReceivedSnapNum > 1)     mNamedImages.nameNewImage(mCaptureStartTime);
    Size s=mParameters.getPictureSize();
    int width, height;
    if ((mJpegRotation + orientation) % 180 == 0) {
      width=s.width;
      height=s.height;
    }
 else {
      width=s.height;
      height=s.width;
    }
    String pictureFormat=mParameters.get(KEY_PICTURE_FORMAT);
    if (pictureFormat != null && !pictureFormat.equalsIgnoreCase(PIXEL_FORMAT_JPEG)) {
      String pair=mParameters.get(KEY_QC_RAW_PICUTRE_SIZE);
      if (pair != null) {
        int pos=pair.indexOf('x');
        if (pos != -1) {
          width=Integer.parseInt(pair.substring(0,pos));
          height=Integer.parseInt(pair.substring(pos + 1));
        }
      }
    }
    NamedEntity name=mNamedImages.getNextNameEntity();
    String title=(name == null) ? null : name.title;
    long date=(name == null) ? -1 : name.date;
    if (mDebugUri != null) {
      saveToDebugUri(jpegData);
      if (title != null) {
        title=DEBUG_IMAGE_PREFIX + title;
      }
    }
    if (title == null) {
      Log.e(TAG,""String_Node_Str"");
    }
 else {
      if (date == -1)       date=mCaptureStartTime;
      if (mHeading >= 0) {
        ExifTag directionRefTag=exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION_REF,ExifInterface.GpsTrackRef.MAGNETIC_DIRECTION);
        ExifTag directionTag=exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION,new Rational(mHeading,1));
        exif.setTag(directionRefTag);
        exif.setTag(directionTag);
      }
      String mPictureFormat=mParameters.get(KEY_PICTURE_FORMAT);
      mActivity.getMediaSaveService().addImage(jpegData,title,date,mLocation,width,height,orientation,exif,mOnMediaSavedListener,mContentResolver,mPictureFormat);
    }
    if (mCameraState != LONGSHOT) {
      Size pic_size=mParameters.getPictureSize();
      if ((pic_size.width <= 352) && (pic_size.height <= 288)) {
        mUI.setDownFactor(2);
      }
 else {
        mUI.setDownFactor(4);
      }
      mUI.animateCapture(jpegData,orientation,mMirror);
    }
  }
 else {
    mJpegImageData=jpegData;
    if (!mQuickCapture) {
      mUI.showCapturedImageForReview(jpegData,orientation,mMirror);
    }
 else {
      onCaptureDone();
    }
  }
  mActivity.updateStorageSpaceAndHint();
  long now=System.currentTimeMillis();
  mJpegCallbackFinishTime=now - mJpegPictureCallbackTime;
  Log.v(TAG,""String_Node_Str"" + mJpegCallbackFinishTime + ""String_Node_Str"");
  if (mReceivedSnapNum == mBurstSnapNum)   mJpegPictureCallbackTime=0;
  if (mHiston && (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL)) {
    mActivity.runOnUiThread(new Runnable(){
      public void run(){
        if (mGraphView != null) {
          mGraphView.setVisibility(View.VISIBLE);
          mGraphView.PreviewChanged();
        }
      }
    }
);
  }
  if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL && mCameraState != LONGSHOT && mReceivedSnapNum == mBurstSnapNum && !mIsImageCaptureIntent) {
    cancelAutoFocus();
  }
}","The original code incorrectly set the camera state to IDLE unconditionally, which could lead to premature state changes during image capture intents. In the fixed code, `setCameraState(IDLE)` is only called when not in an image capture intent, preventing unintended state transitions. This modification ensures more robust camera state management, particularly during different capture modes, improving the overall reliability of the camera application's workflow."
38274,"private boolean updateCameraParametersPreference(){
  setAutoExposureLockIfSupported();
  setAutoWhiteBalanceLockIfSupported();
  setFocusAreasIfSupported();
  setMeteringAreasIfSupported();
  String pictureSize=mPreferences.getString(CameraSettings.KEY_PICTURE_SIZE,null);
  if (pictureSize == null) {
    CameraSettings.initialCameraPictureSize(mActivity,mParameters);
  }
 else {
    Size old_size=mParameters.getPictureSize();
    Log.v(TAG,""String_Node_Str"" + old_size.width + ""String_Node_Str""+ old_size.height);
    List<Size> supported=mParameters.getSupportedPictureSizes();
    CameraSettings.setCameraPictureSize(pictureSize,supported,mParameters);
    Size size=mParameters.getPictureSize();
    Log.v(TAG,""String_Node_Str"" + size.width + ""String_Node_Str""+ size.height);
    if (old_size != null && size != null) {
      if (!size.equals(old_size) && mCameraState != PREVIEW_STOPPED) {
        Log.v(TAG,""String_Node_Str"");
        mRestartPreview=true;
      }
    }
  }
  Size size=mParameters.getPictureSize();
  List<Size> sizes=mParameters.getSupportedPreviewSizes();
  Size optimalSize=CameraUtil.getOptimalPreviewSize(mActivity,sizes,(double)size.width / size.height);
  Size original=mParameters.getPreviewSize();
  if (!original.equals(optimalSize)) {
    mParameters.setPreviewSize(optimalSize.width,optimalSize.height);
    if (mHandler.getLooper() == Looper.myLooper()) {
      setupPreview();
    }
 else {
      mCameraDevice.setParameters(mParameters);
    }
    mParameters=mCameraDevice.getParameters();
    Log.v(TAG,""String_Node_Str"");
    mRestartPreview=true;
  }
  Log.v(TAG,""String_Node_Str"" + optimalSize.width + ""String_Node_Str""+ optimalSize.height);
  String onValue=mActivity.getString(R.string.setting_on_value);
  String hdr=mPreferences.getString(CameraSettings.KEY_CAMERA_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  String hdrPlus=mPreferences.getString(CameraSettings.KEY_CAMERA_HDR_PLUS,mActivity.getString(R.string.pref_camera_hdr_plus_default));
  boolean hdrOn=onValue.equals(hdr);
  boolean hdrPlusOn=onValue.equals(hdrPlus);
  boolean doGcamModeSwitch=false;
  if (hdrPlusOn && GcamHelper.hasGcamCapture()) {
    doGcamModeSwitch=true;
  }
 else {
    if (hdrOn) {
      mSceneMode=CameraUtil.SCENE_MODE_HDR;
      if (!(Parameters.SCENE_MODE_AUTO).equals(mParameters.getSceneMode())) {
        mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
        mCameraDevice.setParameters(mParameters);
        mParameters=mCameraDevice.getParameters();
      }
    }
 else {
      mSceneMode=mPreferences.getString(CameraSettings.KEY_SCENE_MODE,mActivity.getString(R.string.pref_camera_scenemode_default));
    }
  }
  if (CameraUtil.isSupported(mSceneMode,mParameters.getSupportedSceneModes())) {
    if (!mParameters.getSceneMode().equals(mSceneMode)) {
      mParameters.setSceneMode(mSceneMode);
      mCameraDevice.setParameters(mParameters);
      mParameters=mCameraDevice.getParameters();
    }
  }
 else {
    mSceneMode=mParameters.getSceneMode();
    if (mSceneMode == null) {
      mSceneMode=Parameters.SCENE_MODE_AUTO;
    }
  }
  int jpegQuality=CameraProfile.getJpegEncodingQualityParameter(mCameraId,CameraProfile.QUALITY_HIGH);
  mParameters.setJpegQuality(jpegQuality);
  int value=CameraSettings.readExposure(mPreferences);
  int max=mParameters.getMaxExposureCompensation();
  int min=mParameters.getMinExposureCompensation();
  if (value >= min && value <= max) {
    mParameters.setExposureCompensation(value);
  }
 else {
    Log.w(TAG,""String_Node_Str"" + value);
  }
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    String flashMode=mPreferences.getString(CameraSettings.KEY_FLASH_MODE,mActivity.getString(R.string.pref_camera_flashmode_default));
    List<String> supportedFlash=mParameters.getSupportedFlashModes();
    if (CameraUtil.isSupported(flashMode,supportedFlash)) {
      mParameters.setFlashMode(flashMode);
    }
 else {
      flashMode=mParameters.getFlashMode();
      if (flashMode == null) {
        flashMode=mActivity.getString(R.string.pref_camera_flashmode_no_flash);
      }
    }
    String whiteBalance=mPreferences.getString(CameraSettings.KEY_WHITE_BALANCE,mActivity.getString(R.string.pref_camera_whitebalance_default));
    if (CameraUtil.isSupported(whiteBalance,mParameters.getSupportedWhiteBalance())) {
      mParameters.setWhiteBalance(whiteBalance);
    }
 else {
      whiteBalance=mParameters.getWhiteBalance();
      if (whiteBalance == null) {
        whiteBalance=Parameters.WHITE_BALANCE_AUTO;
      }
    }
    mFocusManager.overrideFocusMode(null);
    mParameters.setFocusMode(mFocusManager.getFocusMode());
  }
 else {
    mFocusManager.overrideFocusMode(mParameters.getFocusMode());
    if (hdrOn)     mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
 else {
      mParameters.setFlashMode(Parameters.FLASH_MODE_AUTO);
    }
  }
  if (mContinuousFocusSupported && ApiHelper.HAS_AUTO_FOCUS_MOVE_CALLBACK) {
    updateAutoFocusMoveCallback();
  }
  qcomUpdateCameraParametersPreference();
  return doGcamModeSwitch;
}","private boolean updateCameraParametersPreference(){
  setAutoExposureLockIfSupported();
  setAutoWhiteBalanceLockIfSupported();
  setFocusAreasIfSupported();
  setMeteringAreasIfSupported();
  String pictureSize=mPreferences.getString(CameraSettings.KEY_PICTURE_SIZE,null);
  if (pictureSize == null) {
    CameraSettings.initialCameraPictureSize(mActivity,mParameters);
  }
 else {
    Size old_size=mParameters.getPictureSize();
    Log.v(TAG,""String_Node_Str"" + old_size.width + ""String_Node_Str""+ old_size.height);
    List<Size> supported=mParameters.getSupportedPictureSizes();
    CameraSettings.setCameraPictureSize(pictureSize,supported,mParameters);
    Size size=mParameters.getPictureSize();
    Log.v(TAG,""String_Node_Str"" + size.width + ""String_Node_Str""+ size.height);
    if (old_size != null && size != null) {
      if (!size.equals(old_size) && mCameraState != PREVIEW_STOPPED) {
        Log.v(TAG,""String_Node_Str"");
        mRestartPreview=true;
      }
    }
  }
  Size size=mParameters.getPictureSize();
  List<Size> sizes=mParameters.getSupportedPreviewSizes();
  Size optimalSize=CameraUtil.getOptimalPreviewSize(mActivity,sizes,(double)size.width / size.height);
  Size original=mParameters.getPreviewSize();
  if (!original.equals(optimalSize)) {
    mParameters.setPreviewSize(optimalSize.width,optimalSize.height);
    if (mHandler.getLooper() == Looper.myLooper()) {
      setupPreview();
    }
 else {
      mCameraDevice.setParameters(mParameters);
    }
    mParameters=mCameraDevice.getParameters();
    Log.v(TAG,""String_Node_Str"");
    mRestartPreview=true;
  }
  Log.v(TAG,""String_Node_Str"" + optimalSize.width + ""String_Node_Str""+ optimalSize.height);
  String onValue=mActivity.getString(R.string.setting_on_value);
  String hdr=mPreferences.getString(CameraSettings.KEY_CAMERA_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  String hdrPlus=mPreferences.getString(CameraSettings.KEY_CAMERA_HDR_PLUS,mActivity.getString(R.string.pref_camera_hdr_plus_default));
  boolean hdrOn=onValue.equals(hdr);
  boolean hdrPlusOn=onValue.equals(hdrPlus);
  boolean doGcamModeSwitch=false;
  if (hdrPlusOn && GcamHelper.hasGcamCapture()) {
    doGcamModeSwitch=true;
  }
 else {
    if (hdrOn) {
      mSceneMode=CameraUtil.SCENE_MODE_HDR;
      if (!(Parameters.SCENE_MODE_AUTO).equals(mParameters.getSceneMode()) && !(Parameters.SCENE_MODE_HDR).equals(mParameters.getSceneMode())) {
        mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
        mCameraDevice.setParameters(mParameters);
        mParameters=mCameraDevice.getParameters();
      }
    }
 else {
      mSceneMode=mPreferences.getString(CameraSettings.KEY_SCENE_MODE,mActivity.getString(R.string.pref_camera_scenemode_default));
    }
  }
  if (CameraUtil.isSupported(mSceneMode,mParameters.getSupportedSceneModes())) {
    if (!mParameters.getSceneMode().equals(mSceneMode)) {
      mParameters.setSceneMode(mSceneMode);
      mCameraDevice.setParameters(mParameters);
      mParameters=mCameraDevice.getParameters();
    }
  }
 else {
    mSceneMode=mParameters.getSceneMode();
    if (mSceneMode == null) {
      mSceneMode=Parameters.SCENE_MODE_AUTO;
    }
  }
  int jpegQuality=CameraProfile.getJpegEncodingQualityParameter(mCameraId,CameraProfile.QUALITY_HIGH);
  mParameters.setJpegQuality(jpegQuality);
  int value=CameraSettings.readExposure(mPreferences);
  int max=mParameters.getMaxExposureCompensation();
  int min=mParameters.getMinExposureCompensation();
  if (value >= min && value <= max) {
    mParameters.setExposureCompensation(value);
  }
 else {
    Log.w(TAG,""String_Node_Str"" + value);
  }
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    String flashMode=mPreferences.getString(CameraSettings.KEY_FLASH_MODE,mActivity.getString(R.string.pref_camera_flashmode_default));
    List<String> supportedFlash=mParameters.getSupportedFlashModes();
    if (CameraUtil.isSupported(flashMode,supportedFlash)) {
      mParameters.setFlashMode(flashMode);
    }
 else {
      flashMode=mParameters.getFlashMode();
      if (flashMode == null) {
        flashMode=mActivity.getString(R.string.pref_camera_flashmode_no_flash);
      }
    }
    String whiteBalance=mPreferences.getString(CameraSettings.KEY_WHITE_BALANCE,mActivity.getString(R.string.pref_camera_whitebalance_default));
    if (CameraUtil.isSupported(whiteBalance,mParameters.getSupportedWhiteBalance())) {
      mParameters.setWhiteBalance(whiteBalance);
    }
 else {
      whiteBalance=mParameters.getWhiteBalance();
      if (whiteBalance == null) {
        whiteBalance=Parameters.WHITE_BALANCE_AUTO;
      }
    }
    mFocusManager.overrideFocusMode(null);
    mParameters.setFocusMode(mFocusManager.getFocusMode());
  }
 else {
    mFocusManager.overrideFocusMode(mParameters.getFocusMode());
    if (hdrOn)     mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
 else {
      mParameters.setFlashMode(Parameters.FLASH_MODE_AUTO);
    }
  }
  if (mContinuousFocusSupported && ApiHelper.HAS_AUTO_FOCUS_MOVE_CALLBACK) {
    updateAutoFocusMoveCallback();
  }
  qcomUpdateCameraParametersPreference();
  return doGcamModeSwitch;
}","The original code lacked a proper check when setting HDR scene mode, potentially causing unintended camera mode switches. The fixed code adds an additional condition `!(Parameters.SCENE_MODE_HDR).equals(mParameters.getSceneMode())` to prevent unnecessary scene mode changes when already in HDR mode. This improvement ensures more stable and predictable camera parameter configuration, reducing potential configuration conflicts and unnecessary parameter resets."
38275,"@Override public void onPictureTaken(final byte[] jpegData,CameraProxy camera){
  mUI.enableShutter(true);
  if (mPaused) {
    return;
  }
  if (mIsImageCaptureIntent) {
    stopPreview();
  }
  if (mSceneMode == CameraUtil.SCENE_MODE_HDR) {
    mUI.showSwitcher();
    mUI.setSwipingEnabled(true);
  }
  mReceivedSnapNum=mReceivedSnapNum + 1;
  mJpegPictureCallbackTime=System.currentTimeMillis();
  if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
    Log.v(TAG,""String_Node_Str"");
    mParameters=mCameraDevice.getParameters();
    mBurstSnapNum=mParameters.getInt(""String_Node_Str"");
  }
  Log.v(TAG,""String_Node_Str"" + mReceivedSnapNum + ""String_Node_Str""+ mBurstSnapNum);
  if (mPostViewPictureCallbackTime != 0) {
    mShutterToPictureDisplayedTime=mPostViewPictureCallbackTime - mShutterCallbackTime;
    mPictureDisplayedToJpegCallbackTime=mJpegPictureCallbackTime - mPostViewPictureCallbackTime;
  }
 else {
    mShutterToPictureDisplayedTime=mRawPictureCallbackTime - mShutterCallbackTime;
    mPictureDisplayedToJpegCallbackTime=mJpegPictureCallbackTime - mRawPictureCallbackTime;
  }
  Log.v(TAG,""String_Node_Str"" + mPictureDisplayedToJpegCallbackTime + ""String_Node_Str"");
  mFocusManager.updateFocusUI();
  boolean needRestartPreview=!mIsImageCaptureIntent && !mPreviewRestartSupport && (mCameraState != LONGSHOT)&& (mSnapshotMode != CameraInfo.CAMERA_SUPPORT_MODE_ZSL)&& (mReceivedSnapNum == mBurstSnapNum);
  if (needRestartPreview) {
    setupPreview();
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
  }
 else   if ((mReceivedSnapNum == mBurstSnapNum) && (mCameraState != LONGSHOT)) {
    mFocusManager.resetTouchFocus();
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
    mUI.resumeFaceDetection();
    setCameraState(IDLE);
  }
  ExifInterface exif=Exif.getExif(jpegData);
  int orientation=Exif.getOrientation(exif);
  if (!mIsImageCaptureIntent) {
    if (mReceivedSnapNum > 1)     mNamedImages.nameNewImage(mCaptureStartTime);
    Size s=mParameters.getPictureSize();
    int width, height;
    if ((mJpegRotation + orientation) % 180 == 0) {
      width=s.width;
      height=s.height;
    }
 else {
      width=s.height;
      height=s.width;
    }
    String pictureFormat=mParameters.get(KEY_PICTURE_FORMAT);
    if (pictureFormat != null && !pictureFormat.equalsIgnoreCase(PIXEL_FORMAT_JPEG)) {
      String pair=mParameters.get(KEY_QC_RAW_PICUTRE_SIZE);
      if (pair != null) {
        int pos=pair.indexOf('x');
        if (pos != -1) {
          width=Integer.parseInt(pair.substring(0,pos));
          height=Integer.parseInt(pair.substring(pos + 1));
        }
      }
    }
    NamedEntity name=mNamedImages.getNextNameEntity();
    String title=(name == null) ? null : name.title;
    long date=(name == null) ? -1 : name.date;
    if (mDebugUri != null) {
      saveToDebugUri(jpegData);
      if (title != null) {
        title=DEBUG_IMAGE_PREFIX + title;
      }
    }
    if (title == null) {
      Log.e(TAG,""String_Node_Str"");
    }
 else {
      if (date == -1)       date=mCaptureStartTime;
      if (mHeading >= 0) {
        ExifTag directionRefTag=exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION_REF,ExifInterface.GpsTrackRef.MAGNETIC_DIRECTION);
        ExifTag directionTag=exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION,new Rational(mHeading,1));
        exif.setTag(directionRefTag);
        exif.setTag(directionTag);
      }
      String mPictureFormat=mParameters.get(KEY_PICTURE_FORMAT);
      mActivity.getMediaSaveService().addImage(jpegData,title,date,mLocation,width,height,orientation,exif,mOnMediaSavedListener,mContentResolver,mPictureFormat);
    }
    if (mCameraState != LONGSHOT) {
      Size pic_size=mParameters.getPictureSize();
      if ((pic_size.width <= 352) && (pic_size.height <= 288)) {
        mUI.setDownFactor(2);
      }
 else {
        mUI.setDownFactor(4);
      }
      mUI.animateCapture(jpegData,orientation,mMirror);
    }
  }
 else {
    mJpegImageData=jpegData;
    if (!mQuickCapture) {
      mUI.showCapturedImageForReview(jpegData,orientation,mMirror);
    }
 else {
      onCaptureDone();
    }
  }
  mActivity.updateStorageSpaceAndHint();
  long now=System.currentTimeMillis();
  mJpegCallbackFinishTime=now - mJpegPictureCallbackTime;
  Log.v(TAG,""String_Node_Str"" + mJpegCallbackFinishTime + ""String_Node_Str"");
  if (mReceivedSnapNum == mBurstSnapNum)   mJpegPictureCallbackTime=0;
  if (mHiston && (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL)) {
    mActivity.runOnUiThread(new Runnable(){
      public void run(){
        if (mGraphView != null) {
          mGraphView.setVisibility(View.VISIBLE);
          mGraphView.PreviewChanged();
        }
      }
    }
);
  }
  if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL && mCameraState != LONGSHOT && mReceivedSnapNum == mBurstSnapNum) {
    cancelAutoFocus();
  }
}","@Override public void onPictureTaken(final byte[] jpegData,CameraProxy camera){
  mUI.enableShutter(true);
  if (mPaused) {
    return;
  }
  if (mIsImageCaptureIntent) {
    stopPreview();
  }
  if (mSceneMode == CameraUtil.SCENE_MODE_HDR) {
    mUI.showSwitcher();
    mUI.setSwipingEnabled(true);
  }
  mReceivedSnapNum=mReceivedSnapNum + 1;
  mJpegPictureCallbackTime=System.currentTimeMillis();
  if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
    Log.v(TAG,""String_Node_Str"");
    mParameters=mCameraDevice.getParameters();
    mBurstSnapNum=mParameters.getInt(""String_Node_Str"");
  }
  Log.v(TAG,""String_Node_Str"" + mReceivedSnapNum + ""String_Node_Str""+ mBurstSnapNum);
  if (mPostViewPictureCallbackTime != 0) {
    mShutterToPictureDisplayedTime=mPostViewPictureCallbackTime - mShutterCallbackTime;
    mPictureDisplayedToJpegCallbackTime=mJpegPictureCallbackTime - mPostViewPictureCallbackTime;
  }
 else {
    mShutterToPictureDisplayedTime=mRawPictureCallbackTime - mShutterCallbackTime;
    mPictureDisplayedToJpegCallbackTime=mJpegPictureCallbackTime - mRawPictureCallbackTime;
  }
  Log.v(TAG,""String_Node_Str"" + mPictureDisplayedToJpegCallbackTime + ""String_Node_Str"");
  mFocusManager.updateFocusUI();
  boolean needRestartPreview=!mIsImageCaptureIntent && !mPreviewRestartSupport && (mCameraState != LONGSHOT)&& (mSnapshotMode != CameraInfo.CAMERA_SUPPORT_MODE_ZSL)&& (mReceivedSnapNum == mBurstSnapNum);
  if (needRestartPreview) {
    setupPreview();
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
  }
 else   if ((mReceivedSnapNum == mBurstSnapNum) && (mCameraState != LONGSHOT)) {
    mFocusManager.resetTouchFocus();
    if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
      mCameraDevice.cancelAutoFocus();
    }
    mUI.resumeFaceDetection();
    if (!mIsImageCaptureIntent) {
      setCameraState(IDLE);
    }
  }
  ExifInterface exif=Exif.getExif(jpegData);
  int orientation=Exif.getOrientation(exif);
  if (!mIsImageCaptureIntent) {
    if (mReceivedSnapNum > 1)     mNamedImages.nameNewImage(mCaptureStartTime);
    Size s=mParameters.getPictureSize();
    int width, height;
    if ((mJpegRotation + orientation) % 180 == 0) {
      width=s.width;
      height=s.height;
    }
 else {
      width=s.height;
      height=s.width;
    }
    String pictureFormat=mParameters.get(KEY_PICTURE_FORMAT);
    if (pictureFormat != null && !pictureFormat.equalsIgnoreCase(PIXEL_FORMAT_JPEG)) {
      String pair=mParameters.get(KEY_QC_RAW_PICUTRE_SIZE);
      if (pair != null) {
        int pos=pair.indexOf('x');
        if (pos != -1) {
          width=Integer.parseInt(pair.substring(0,pos));
          height=Integer.parseInt(pair.substring(pos + 1));
        }
      }
    }
    NamedEntity name=mNamedImages.getNextNameEntity();
    String title=(name == null) ? null : name.title;
    long date=(name == null) ? -1 : name.date;
    if (mDebugUri != null) {
      saveToDebugUri(jpegData);
      if (title != null) {
        title=DEBUG_IMAGE_PREFIX + title;
      }
    }
    if (title == null) {
      Log.e(TAG,""String_Node_Str"");
    }
 else {
      if (date == -1)       date=mCaptureStartTime;
      if (mHeading >= 0) {
        ExifTag directionRefTag=exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION_REF,ExifInterface.GpsTrackRef.MAGNETIC_DIRECTION);
        ExifTag directionTag=exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION,new Rational(mHeading,1));
        exif.setTag(directionRefTag);
        exif.setTag(directionTag);
      }
      String mPictureFormat=mParameters.get(KEY_PICTURE_FORMAT);
      mActivity.getMediaSaveService().addImage(jpegData,title,date,mLocation,width,height,orientation,exif,mOnMediaSavedListener,mContentResolver,mPictureFormat);
    }
    if (mCameraState != LONGSHOT) {
      Size pic_size=mParameters.getPictureSize();
      if ((pic_size.width <= 352) && (pic_size.height <= 288)) {
        mUI.setDownFactor(2);
      }
 else {
        mUI.setDownFactor(4);
      }
      mUI.animateCapture(jpegData,orientation,mMirror);
    }
  }
 else {
    mJpegImageData=jpegData;
    if (!mQuickCapture) {
      mUI.showCapturedImageForReview(jpegData,orientation,mMirror);
    }
 else {
      onCaptureDone();
    }
  }
  mActivity.updateStorageSpaceAndHint();
  long now=System.currentTimeMillis();
  mJpegCallbackFinishTime=now - mJpegPictureCallbackTime;
  Log.v(TAG,""String_Node_Str"" + mJpegCallbackFinishTime + ""String_Node_Str"");
  if (mReceivedSnapNum == mBurstSnapNum)   mJpegPictureCallbackTime=0;
  if (mHiston && (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL)) {
    mActivity.runOnUiThread(new Runnable(){
      public void run(){
        if (mGraphView != null) {
          mGraphView.setVisibility(View.VISIBLE);
          mGraphView.PreviewChanged();
        }
      }
    }
);
  }
  if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL && mCameraState != LONGSHOT && mReceivedSnapNum == mBurstSnapNum && !mIsImageCaptureIntent) {
    cancelAutoFocus();
  }
}","The original code incorrectly set the camera state to IDLE unconditionally, which could cause unexpected behavior in image capture scenarios. The fixed code adds a condition `!mIsImageCaptureIntent` before setting the camera state, ensuring that the state is only changed when not in a direct image capture mode. This modification prevents premature state transitions and provides more robust handling of different camera capture modes, improving the overall reliability of the camera application's state management."
38276,"private boolean updateCameraParametersPreference(){
  setAutoExposureLockIfSupported();
  setAutoWhiteBalanceLockIfSupported();
  setFocusAreasIfSupported();
  setMeteringAreasIfSupported();
  String pictureSize=mPreferences.getString(CameraSettings.KEY_PICTURE_SIZE,null);
  if (pictureSize == null) {
    CameraSettings.initialCameraPictureSize(mActivity,mParameters);
  }
 else {
    Size old_size=mParameters.getPictureSize();
    Log.v(TAG,""String_Node_Str"" + old_size.width + ""String_Node_Str""+ old_size.height);
    List<Size> supported=mParameters.getSupportedPictureSizes();
    CameraSettings.setCameraPictureSize(pictureSize,supported,mParameters);
    Size size=mParameters.getPictureSize();
    Log.v(TAG,""String_Node_Str"" + size.width + ""String_Node_Str""+ size.height);
    if (old_size != null && size != null) {
      if (!size.equals(old_size) && mCameraState != PREVIEW_STOPPED) {
        Log.v(TAG,""String_Node_Str"");
        mRestartPreview=true;
      }
    }
  }
  Size size=mParameters.getPictureSize();
  List<Size> sizes=mParameters.getSupportedPreviewSizes();
  Size optimalSize=CameraUtil.getOptimalPreviewSize(mActivity,sizes,(double)size.width / size.height);
  Size original=mParameters.getPreviewSize();
  if (!original.equals(optimalSize)) {
    mParameters.setPreviewSize(optimalSize.width,optimalSize.height);
    if (mHandler.getLooper() == Looper.myLooper()) {
      setupPreview();
    }
 else {
      mCameraDevice.setParameters(mParameters);
    }
    mParameters=mCameraDevice.getParameters();
    Log.v(TAG,""String_Node_Str"");
    mRestartPreview=true;
  }
  Log.v(TAG,""String_Node_Str"" + optimalSize.width + ""String_Node_Str""+ optimalSize.height);
  String onValue=mActivity.getString(R.string.setting_on_value);
  String hdr=mPreferences.getString(CameraSettings.KEY_CAMERA_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  String hdrPlus=mPreferences.getString(CameraSettings.KEY_CAMERA_HDR_PLUS,mActivity.getString(R.string.pref_camera_hdr_plus_default));
  boolean hdrOn=onValue.equals(hdr);
  boolean hdrPlusOn=onValue.equals(hdrPlus);
  boolean doGcamModeSwitch=false;
  if (hdrPlusOn && GcamHelper.hasGcamCapture()) {
    doGcamModeSwitch=true;
  }
 else {
    if (hdrOn) {
      mSceneMode=CameraUtil.SCENE_MODE_HDR;
      if (!(Parameters.SCENE_MODE_AUTO).equals(mParameters.getSceneMode())) {
        mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
        mCameraDevice.setParameters(mParameters);
        mParameters=mCameraDevice.getParameters();
      }
    }
 else {
      mSceneMode=mPreferences.getString(CameraSettings.KEY_SCENE_MODE,mActivity.getString(R.string.pref_camera_scenemode_default));
    }
  }
  if (CameraUtil.isSupported(mSceneMode,mParameters.getSupportedSceneModes())) {
    if (!mParameters.getSceneMode().equals(mSceneMode)) {
      mParameters.setSceneMode(mSceneMode);
      mCameraDevice.setParameters(mParameters);
      mParameters=mCameraDevice.getParameters();
    }
  }
 else {
    mSceneMode=mParameters.getSceneMode();
    if (mSceneMode == null) {
      mSceneMode=Parameters.SCENE_MODE_AUTO;
    }
  }
  int jpegQuality=CameraProfile.getJpegEncodingQualityParameter(mCameraId,CameraProfile.QUALITY_HIGH);
  mParameters.setJpegQuality(jpegQuality);
  int value=CameraSettings.readExposure(mPreferences);
  int max=mParameters.getMaxExposureCompensation();
  int min=mParameters.getMinExposureCompensation();
  if (value >= min && value <= max) {
    mParameters.setExposureCompensation(value);
  }
 else {
    Log.w(TAG,""String_Node_Str"" + value);
  }
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    String flashMode=mPreferences.getString(CameraSettings.KEY_FLASH_MODE,mActivity.getString(R.string.pref_camera_flashmode_default));
    List<String> supportedFlash=mParameters.getSupportedFlashModes();
    if (CameraUtil.isSupported(flashMode,supportedFlash)) {
      mParameters.setFlashMode(flashMode);
    }
 else {
      flashMode=mParameters.getFlashMode();
      if (flashMode == null) {
        flashMode=mActivity.getString(R.string.pref_camera_flashmode_no_flash);
      }
    }
    String whiteBalance=mPreferences.getString(CameraSettings.KEY_WHITE_BALANCE,mActivity.getString(R.string.pref_camera_whitebalance_default));
    if (CameraUtil.isSupported(whiteBalance,mParameters.getSupportedWhiteBalance())) {
      mParameters.setWhiteBalance(whiteBalance);
    }
 else {
      whiteBalance=mParameters.getWhiteBalance();
      if (whiteBalance == null) {
        whiteBalance=Parameters.WHITE_BALANCE_AUTO;
      }
    }
    mFocusManager.overrideFocusMode(null);
    mParameters.setFocusMode(mFocusManager.getFocusMode());
  }
 else {
    mFocusManager.overrideFocusMode(mParameters.getFocusMode());
    if (hdrOn)     mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
  }
  if (mContinuousFocusSupported && ApiHelper.HAS_AUTO_FOCUS_MOVE_CALLBACK) {
    updateAutoFocusMoveCallback();
  }
  qcomUpdateCameraParametersPreference();
  return doGcamModeSwitch;
}","private boolean updateCameraParametersPreference(){
  setAutoExposureLockIfSupported();
  setAutoWhiteBalanceLockIfSupported();
  setFocusAreasIfSupported();
  setMeteringAreasIfSupported();
  String pictureSize=mPreferences.getString(CameraSettings.KEY_PICTURE_SIZE,null);
  if (pictureSize == null) {
    CameraSettings.initialCameraPictureSize(mActivity,mParameters);
  }
 else {
    Size old_size=mParameters.getPictureSize();
    Log.v(TAG,""String_Node_Str"" + old_size.width + ""String_Node_Str""+ old_size.height);
    List<Size> supported=mParameters.getSupportedPictureSizes();
    CameraSettings.setCameraPictureSize(pictureSize,supported,mParameters);
    Size size=mParameters.getPictureSize();
    Log.v(TAG,""String_Node_Str"" + size.width + ""String_Node_Str""+ size.height);
    if (old_size != null && size != null) {
      if (!size.equals(old_size) && mCameraState != PREVIEW_STOPPED) {
        Log.v(TAG,""String_Node_Str"");
        mRestartPreview=true;
      }
    }
  }
  Size size=mParameters.getPictureSize();
  List<Size> sizes=mParameters.getSupportedPreviewSizes();
  Size optimalSize=CameraUtil.getOptimalPreviewSize(mActivity,sizes,(double)size.width / size.height);
  Size original=mParameters.getPreviewSize();
  if (!original.equals(optimalSize)) {
    mParameters.setPreviewSize(optimalSize.width,optimalSize.height);
    if (mHandler.getLooper() == Looper.myLooper()) {
      setupPreview();
    }
 else {
      mCameraDevice.setParameters(mParameters);
    }
    mParameters=mCameraDevice.getParameters();
    Log.v(TAG,""String_Node_Str"");
    mRestartPreview=true;
  }
  Log.v(TAG,""String_Node_Str"" + optimalSize.width + ""String_Node_Str""+ optimalSize.height);
  String onValue=mActivity.getString(R.string.setting_on_value);
  String hdr=mPreferences.getString(CameraSettings.KEY_CAMERA_HDR,mActivity.getString(R.string.pref_camera_hdr_default));
  String hdrPlus=mPreferences.getString(CameraSettings.KEY_CAMERA_HDR_PLUS,mActivity.getString(R.string.pref_camera_hdr_plus_default));
  boolean hdrOn=onValue.equals(hdr);
  boolean hdrPlusOn=onValue.equals(hdrPlus);
  boolean doGcamModeSwitch=false;
  if (hdrPlusOn && GcamHelper.hasGcamCapture()) {
    doGcamModeSwitch=true;
  }
 else {
    if (hdrOn) {
      mSceneMode=CameraUtil.SCENE_MODE_HDR;
      if (!(Parameters.SCENE_MODE_AUTO).equals(mParameters.getSceneMode()) && !(Parameters.SCENE_MODE_HDR).equals(mParameters.getSceneMode())) {
        mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
        mCameraDevice.setParameters(mParameters);
        mParameters=mCameraDevice.getParameters();
      }
    }
 else {
      mSceneMode=mPreferences.getString(CameraSettings.KEY_SCENE_MODE,mActivity.getString(R.string.pref_camera_scenemode_default));
    }
  }
  if (CameraUtil.isSupported(mSceneMode,mParameters.getSupportedSceneModes())) {
    if (!mParameters.getSceneMode().equals(mSceneMode)) {
      mParameters.setSceneMode(mSceneMode);
      mCameraDevice.setParameters(mParameters);
      mParameters=mCameraDevice.getParameters();
    }
  }
 else {
    mSceneMode=mParameters.getSceneMode();
    if (mSceneMode == null) {
      mSceneMode=Parameters.SCENE_MODE_AUTO;
    }
  }
  int jpegQuality=CameraProfile.getJpegEncodingQualityParameter(mCameraId,CameraProfile.QUALITY_HIGH);
  mParameters.setJpegQuality(jpegQuality);
  int value=CameraSettings.readExposure(mPreferences);
  int max=mParameters.getMaxExposureCompensation();
  int min=mParameters.getMinExposureCompensation();
  if (value >= min && value <= max) {
    mParameters.setExposureCompensation(value);
  }
 else {
    Log.w(TAG,""String_Node_Str"" + value);
  }
  if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
    String flashMode=mPreferences.getString(CameraSettings.KEY_FLASH_MODE,mActivity.getString(R.string.pref_camera_flashmode_default));
    List<String> supportedFlash=mParameters.getSupportedFlashModes();
    if (CameraUtil.isSupported(flashMode,supportedFlash)) {
      mParameters.setFlashMode(flashMode);
    }
 else {
      flashMode=mParameters.getFlashMode();
      if (flashMode == null) {
        flashMode=mActivity.getString(R.string.pref_camera_flashmode_no_flash);
      }
    }
    String whiteBalance=mPreferences.getString(CameraSettings.KEY_WHITE_BALANCE,mActivity.getString(R.string.pref_camera_whitebalance_default));
    if (CameraUtil.isSupported(whiteBalance,mParameters.getSupportedWhiteBalance())) {
      mParameters.setWhiteBalance(whiteBalance);
    }
 else {
      whiteBalance=mParameters.getWhiteBalance();
      if (whiteBalance == null) {
        whiteBalance=Parameters.WHITE_BALANCE_AUTO;
      }
    }
    mFocusManager.overrideFocusMode(null);
    mParameters.setFocusMode(mFocusManager.getFocusMode());
  }
 else {
    mFocusManager.overrideFocusMode(mParameters.getFocusMode());
    if (hdrOn)     mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
  }
  if (mContinuousFocusSupported && ApiHelper.HAS_AUTO_FOCUS_MOVE_CALLBACK) {
    updateAutoFocusMoveCallback();
  }
  qcomUpdateCameraParametersPreference();
  return doGcamModeSwitch;
}","The original code did not properly handle scene mode transitions, potentially causing incorrect camera settings when switching between HDR and other modes. The fixed code adds an additional check to prevent unnecessary scene mode changes by verifying the current scene mode is not already HDR before resetting to auto mode. This improvement ensures more robust camera parameter management, preventing unintended mode switches and providing a more stable camera configuration during different shooting scenarios."
38277,"@Override public void onResume(){
  if (Settings.System.getInt(getContentResolver(),Settings.System.ACCELEROMETER_ROTATION,0) == 0) {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    mAutoRotateScreen=false;
  }
 else {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
    mAutoRotateScreen=true;
  }
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_FOREGROUNDED,this.getClass().getSimpleName());
  mOrientationListener.enable();
  mCurrentModule.onResumeBeforeSuper();
  super.onResume();
  mCurrentModule.onResumeAfterSuper();
  setSwipingEnabled(true);
  if (mResetToPreviewOnResume) {
    mFilmStripView.getController().goToFirstItem();
  }
  mResetToPreviewOnResume=true;
  if (mLocalVideosObserver.isMediaDataChangedDuringPause() || mLocalImagesObserver.isMediaDataChangedDuringPause()) {
    if (!mSecureCamera) {
      mDataAdapter.requestLoad(getContentResolver());
    }
  }
  mLocalImagesObserver.setActivityPaused(false);
  mLocalVideosObserver.setActivityPaused(false);
}","@Override public void onResume(){
  if (Settings.System.getInt(getContentResolver(),Settings.System.ACCELEROMETER_ROTATION,0) == 0) {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    mAutoRotateScreen=false;
  }
 else {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
    mAutoRotateScreen=true;
  }
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_FOREGROUNDED,this.getClass().getSimpleName());
  mOrientationListener.enable();
  mCurrentModule.onResumeBeforeSuper();
  super.onResume();
  mCurrentModule.onResumeAfterSuper();
  setSwipingEnabled(true);
  if (mResetToPreviewOnResume) {
    mFilmStripView.getController().goToFirstItem();
  }
  mResetToPreviewOnResume=true;
  if (mLocalVideosObserver.isMediaDataChangedDuringPause() || mLocalImagesObserver.isMediaDataChangedDuringPause()) {
    if (!mSecureCamera) {
      mDataAdapter.requestLoad(getContentResolver());
    }
  }
  mLocalImagesObserver.setActivityPaused(false);
  mLocalVideosObserver.setActivityPaused(false);
  Log.d(TAG,""String_Node_Str"");
  Intent intent=new Intent(""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",true);
  sendBroadcast(intent);
}","The original code lacked proper logging and broadcast mechanism for tracking activity state changes. The fixed code adds a debug log statement and sends a broadcast intent with a specific action, providing enhanced visibility and communication about the activity's resume event. These additions improve error tracking, debugging capabilities, and potential inter-component communication in the Android application."
38278,"@Override public void onResume(){
  if (Settings.System.getInt(getContentResolver(),Settings.System.ACCELEROMETER_ROTATION,0) == 0) {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    mAutoRotateScreen=false;
  }
 else {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
    mAutoRotateScreen=true;
  }
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_FOREGROUNDED,this.getClass().getSimpleName());
  mOrientationListener.enable();
  mCurrentModule.onResumeBeforeSuper();
  super.onResume();
  mCurrentModule.onResumeAfterSuper();
  setSwipingEnabled(true);
  if (mResetToPreviewOnResume) {
    mFilmStripView.getController().goToFirstItem();
  }
  mResetToPreviewOnResume=true;
  if (mLocalVideosObserver.isMediaDataChangedDuringPause() || mLocalImagesObserver.isMediaDataChangedDuringPause()) {
    if (!mSecureCamera) {
      mDataAdapter.requestLoad(getContentResolver());
    }
  }
  mLocalImagesObserver.setActivityPaused(false);
  mLocalVideosObserver.setActivityPaused(false);
}","@Override public void onResume(){
  if (Settings.System.getInt(getContentResolver(),Settings.System.ACCELEROMETER_ROTATION,0) == 0) {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    mAutoRotateScreen=false;
  }
 else {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
    mAutoRotateScreen=true;
  }
  UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,UsageStatistics.ACTION_FOREGROUNDED,this.getClass().getSimpleName());
  mOrientationListener.enable();
  mCurrentModule.onResumeBeforeSuper();
  super.onResume();
  mCurrentModule.onResumeAfterSuper();
  setSwipingEnabled(true);
  if (mResetToPreviewOnResume) {
    mFilmStripView.getController().goToFirstItem();
  }
  mResetToPreviewOnResume=true;
  if (mLocalVideosObserver.isMediaDataChangedDuringPause() || mLocalImagesObserver.isMediaDataChangedDuringPause()) {
    if (!mSecureCamera) {
      mDataAdapter.requestLoad(getContentResolver());
    }
  }
  mLocalImagesObserver.setActivityPaused(false);
  mLocalVideosObserver.setActivityPaused(false);
  Log.d(TAG,""String_Node_Str"");
  Intent intent=new Intent(""String_Node_Str"");
  intent.putExtra(""String_Node_Str"",true);
  sendBroadcast(intent);
}","The original code lacked proper broadcast mechanism for signaling state changes after resuming the activity. The fixed code adds a debug log and broadcasts an intent with a specific action and extra flag, enabling better communication and state tracking for other components. This enhancement improves system-wide awareness of the activity's resume status and provides a more robust communication pathway for potential listeners or background services."
38279,"@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    int dx=(getWidth() - rw) / 2;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].score < 50)       continue;
      mRect.set(mFaces[i].rect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      canvas.drawOval(mRect,mPaint);
      if (mFaces[i] instanceof ExtendedFace) {
        ExtendedFace face=(ExtendedFace)mFaces[i];
        float[] point=new float[4];
        int delta_x=mFaces[i].rect.width() / 12;
        int delta_y=mFaces[i].rect.height() / 12;
        Log.e(TAG,""String_Node_Str"" + face.getLeftEyeBlinkDegree() + ""String_Node_Str""+ face.getRightEyeBlinkDegree()+ ""String_Node_Str"");
        if (face.leftEye != null) {
          point[0]=face.leftEye.x + dx;
          point[1]=face.leftEye.y - delta_y / 2;
          point[2]=face.leftEye.x;
          point[3]=face.leftEye.y + delta_y / 2;
          mMatrix.mapPoints(point);
          if (face.getLeftEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.rightEye != null) {
          point[0]=face.rightEye.x;
          point[1]=face.rightEye.y - delta_y / 2;
          point[2]=face.rightEye.x;
          point[3]=face.rightEye.y + delta_y / 2;
          mMatrix.mapPoints(point);
          if (face.getRightEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getLeftRightGazeDegree() != 0 || face.getTopBottomGazeDegree() != 0) {
          double length=Math.sqrt((face.leftEye.x - face.rightEye.x) * (face.leftEye.x - face.rightEye.x) + (face.leftEye.y - face.rightEye.y) * (face.leftEye.y - face.rightEye.y)) / 2.0;
          double nGazeYaw=-face.getLeftRightGazeDegree();
          double nGazePitch=-face.getTopBottomGazeDegree();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (face.getLeftEyeBlinkDegree() < blink_threshold) {
            point[0]=face.leftEye.x;
            point[1]=face.leftEye.y;
            point[2]=face.leftEye.x + gazeRollX;
            point[3]=face.leftEye.y + gazeRollY;
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (face.getRightEyeBlinkDegree() < blink_threshold) {
            point[0]=face.rightEye.x;
            point[1]=face.rightEye.y;
            point[2]=face.rightEye.x + gazeRollX;
            point[3]=face.rightEye.y + gazeRollY;
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.mouth != null) {
          Log.e(TAG,""String_Node_Str"" + face.getSmileDegree() + ""String_Node_Str""+ face.getSmileScore());
          if (face.getSmileDegree() < smile_threashold_no_smile) {
            if ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)) {
              point[0]=face.mouth.x;
              point[1]=face.mouth.y - delta_y + dy;
              point[2]=face.mouth.x;
              point[3]=face.mouth.y + delta_y + dy;
            }
 else {
              point[0]=face.mouth.x + dx - delta_x;
              point[1]=face.mouth.y;
              point[2]=face.mouth.x + dx + delta_x;
              point[3]=face.mouth.y;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (face.getSmileDegree() < smile_threashold_small_smile) {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,0,180,true,mPaint);
          }
 else {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    int dx=(getWidth() - rw) / 2;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].score < 50)       continue;
      mRect.set(mFaces[i].rect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      canvas.drawOval(mRect,mPaint);
      if (mFaces[i] instanceof ExtendedFace) {
        ExtendedFace face=(ExtendedFace)mFaces[i];
        float[] point=new float[4];
        int delta_x=mFaces[i].rect.width() / 12;
        int delta_y=mFaces[i].rect.height() / 12;
        Log.e(TAG,""String_Node_Str"" + face.getLeftEyeBlinkDegree() + ""String_Node_Str""+ face.getRightEyeBlinkDegree()+ ""String_Node_Str"");
        if (face.leftEye != null) {
          point[0]=face.leftEye.x;
          point[1]=face.leftEye.y - delta_y / 2;
          point[2]=face.leftEye.x;
          point[3]=face.leftEye.y + delta_y / 2;
          mMatrix.mapPoints(point);
          if (face.getLeftEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.rightEye != null) {
          point[0]=face.rightEye.x;
          point[1]=face.rightEye.y - delta_y / 2;
          point[2]=face.rightEye.x;
          point[3]=face.rightEye.y + delta_y / 2;
          mMatrix.mapPoints(point);
          if (face.getRightEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getLeftRightGazeDegree() != 0 || face.getTopBottomGazeDegree() != 0) {
          double length=Math.sqrt((face.leftEye.x - face.rightEye.x) * (face.leftEye.x - face.rightEye.x) + (face.leftEye.y - face.rightEye.y) * (face.leftEye.y - face.rightEye.y)) / 2.0;
          double nGazeYaw=-face.getLeftRightGazeDegree();
          double nGazePitch=-face.getTopBottomGazeDegree();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (face.getLeftEyeBlinkDegree() < blink_threshold) {
            point[0]=face.leftEye.x;
            point[1]=face.leftEye.y;
            point[2]=face.leftEye.x + gazeRollX;
            point[3]=face.leftEye.y + gazeRollY;
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (face.getRightEyeBlinkDegree() < blink_threshold) {
            point[0]=face.rightEye.x;
            point[1]=face.rightEye.y;
            point[2]=face.rightEye.x + gazeRollX;
            point[3]=face.rightEye.y + gazeRollY;
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.mouth != null) {
          Log.e(TAG,""String_Node_Str"" + face.getSmileDegree() + ""String_Node_Str""+ face.getSmileScore());
          if (face.getSmileDegree() < smile_threashold_no_smile) {
            if ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)) {
              point[0]=face.mouth.x;
              point[1]=face.mouth.y - delta_y + dy;
              point[2]=face.mouth.x;
              point[3]=face.mouth.y + delta_y + dy;
            }
 else {
              point[0]=face.mouth.x + dx - delta_x;
              point[1]=face.mouth.y;
              point[2]=face.mouth.x + dx + delta_x;
              point[3]=face.mouth.y;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (face.getSmileDegree() < smile_threashold_small_smile) {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,0,180,true,mPaint);
          }
 else {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","The buggy code incorrectly added an extra `dx` offset when setting the initial coordinates for left and right eye points, causing potential misalignment of eye-related drawing. In the fixed code, the redundant `dx` offset is removed, ensuring that the eye coordinates are correctly mapped before applying matrix transformations and additional offsets. This correction ensures more accurate rendering of eye-related visual elements during face detection and tracking."
38280,"@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    int dx=(getWidth() - rw) / 2;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].score < 50)       continue;
      mRect.set(mFaces[i].rect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      canvas.drawOval(mRect,mPaint);
      if (mFaces[i] instanceof ExtendedFace) {
        ExtendedFace face=(ExtendedFace)mFaces[i];
        float[] point=new float[4];
        int delta_x=mFaces[i].rect.width() / 12;
        int delta_y=mFaces[i].rect.height() / 12;
        Log.e(TAG,""String_Node_Str"" + face.getLeftEyeBlinkDegree() + ""String_Node_Str""+ face.getRightEyeBlinkDegree()+ ""String_Node_Str"");
        if (face.leftEye != null) {
          point[0]=face.leftEye.x + dx;
          point[1]=face.leftEye.y - delta_y / 2;
          point[2]=face.leftEye.x;
          point[3]=face.leftEye.y + delta_y / 2;
          mMatrix.mapPoints(point);
          if (face.getLeftEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.rightEye != null) {
          point[0]=face.rightEye.x;
          point[1]=face.rightEye.y - delta_y / 2;
          point[2]=face.rightEye.x;
          point[3]=face.rightEye.y + delta_y / 2;
          mMatrix.mapPoints(point);
          if (face.getRightEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getLeftRightGazeDegree() != 0 || face.getTopBottomGazeDegree() != 0) {
          double length=Math.sqrt((face.leftEye.x - face.rightEye.x) * (face.leftEye.x - face.rightEye.x) + (face.leftEye.y - face.rightEye.y) * (face.leftEye.y - face.rightEye.y)) / 2.0;
          double nGazeYaw=-face.getLeftRightGazeDegree();
          double nGazePitch=-face.getTopBottomGazeDegree();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (face.getLeftEyeBlinkDegree() < blink_threshold) {
            point[0]=face.leftEye.x;
            point[1]=face.leftEye.y;
            point[2]=face.leftEye.x + gazeRollX;
            point[3]=face.leftEye.y + gazeRollY;
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (face.getRightEyeBlinkDegree() < blink_threshold) {
            point[0]=face.rightEye.x;
            point[1]=face.rightEye.y;
            point[2]=face.rightEye.x + gazeRollX;
            point[3]=face.rightEye.y + gazeRollY;
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.mouth != null) {
          Log.e(TAG,""String_Node_Str"" + face.getSmileDegree() + ""String_Node_Str""+ face.getSmileScore());
          if (face.getSmileDegree() < smile_threashold_no_smile) {
            if ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)) {
              point[0]=face.mouth.x;
              point[1]=face.mouth.y - delta_y + dy;
              point[2]=face.mouth.x;
              point[3]=face.mouth.y + delta_y + dy;
            }
 else {
              point[0]=face.mouth.x + dx - delta_x;
              point[1]=face.mouth.y;
              point[2]=face.mouth.x + dx + delta_x;
              point[3]=face.mouth.y;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (face.getSmileDegree() < smile_threashold_small_smile) {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,0,180,true,mPaint);
          }
 else {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(Canvas canvas){
  if (!mBlocked && (mFaces != null) && (mFaces.length > 0)) {
    int rw, rh;
    rw=mUncroppedWidth;
    rh=mUncroppedHeight;
    if (((rh > rw) && ((mDisplayOrientation == 0) || (mDisplayOrientation == 180))) || ((rw > rh) && ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)))) {
      int temp=rw;
      rw=rh;
      rh=temp;
    }
    CameraUtil.prepareMatrix(mMatrix,mMirror,mDisplayOrientation,rw,rh);
    int dx=(getWidth() - rw) / 2;
    int dy=(getHeight() - rh) / 2;
    canvas.save();
    mMatrix.postRotate(mOrientation);
    canvas.rotate(-mOrientation);
    for (int i=0; i < mFaces.length; i++) {
      if (mFaces[i].score < 50)       continue;
      mRect.set(mFaces[i].rect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mMatrix.mapRect(mRect);
      if (LOGV)       CameraUtil.dumpRect(mRect,""String_Node_Str"");
      mPaint.setColor(mColor);
      mRect.offset(dx,dy);
      canvas.drawOval(mRect,mPaint);
      if (mFaces[i] instanceof ExtendedFace) {
        ExtendedFace face=(ExtendedFace)mFaces[i];
        float[] point=new float[4];
        int delta_x=mFaces[i].rect.width() / 12;
        int delta_y=mFaces[i].rect.height() / 12;
        Log.e(TAG,""String_Node_Str"" + face.getLeftEyeBlinkDegree() + ""String_Node_Str""+ face.getRightEyeBlinkDegree()+ ""String_Node_Str"");
        if (face.leftEye != null) {
          point[0]=face.leftEye.x;
          point[1]=face.leftEye.y - delta_y / 2;
          point[2]=face.leftEye.x;
          point[3]=face.leftEye.y + delta_y / 2;
          mMatrix.mapPoints(point);
          if (face.getLeftEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.rightEye != null) {
          point[0]=face.rightEye.x;
          point[1]=face.rightEye.y - delta_y / 2;
          point[2]=face.rightEye.x;
          point[3]=face.rightEye.y + delta_y / 2;
          mMatrix.mapPoints(point);
          if (face.getRightEyeBlinkDegree() >= blink_threshold) {
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.getLeftRightGazeDegree() != 0 || face.getTopBottomGazeDegree() != 0) {
          double length=Math.sqrt((face.leftEye.x - face.rightEye.x) * (face.leftEye.x - face.rightEye.x) + (face.leftEye.y - face.rightEye.y) * (face.leftEye.y - face.rightEye.y)) / 2.0;
          double nGazeYaw=-face.getLeftRightGazeDegree();
          double nGazePitch=-face.getTopBottomGazeDegree();
          float gazeRollX=(float)((-Math.sin(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI) + Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          float gazeRollY=(float)((Math.sin(-nGazeYaw / 180.0 * Math.PI) * Math.sin(-face.getRollDirection() / 180.0 * Math.PI) - Math.sin(nGazePitch / 180.0 * Math.PI) * Math.cos(nGazeYaw / 180.0 * Math.PI) * Math.cos(-face.getRollDirection() / 180.0 * Math.PI)) * (-length) + 0.5);
          if (face.getLeftEyeBlinkDegree() < blink_threshold) {
            point[0]=face.leftEye.x;
            point[1]=face.leftEye.y;
            point[2]=face.leftEye.x + gazeRollX;
            point[3]=face.leftEye.y + gazeRollY;
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
          if (face.getRightEyeBlinkDegree() < blink_threshold) {
            point[0]=face.rightEye.x;
            point[1]=face.rightEye.y;
            point[2]=face.rightEye.x + gazeRollX;
            point[3]=face.rightEye.y + gazeRollY;
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
        }
        if (face.mouth != null) {
          Log.e(TAG,""String_Node_Str"" + face.getSmileDegree() + ""String_Node_Str""+ face.getSmileScore());
          if (face.getSmileDegree() < smile_threashold_no_smile) {
            if ((mDisplayOrientation == 90) || (mDisplayOrientation == 270)) {
              point[0]=face.mouth.x;
              point[1]=face.mouth.y - delta_y + dy;
              point[2]=face.mouth.x;
              point[3]=face.mouth.y + delta_y + dy;
            }
 else {
              point[0]=face.mouth.x + dx - delta_x;
              point[1]=face.mouth.y;
              point[2]=face.mouth.x + dx + delta_x;
              point[3]=face.mouth.y;
            }
            mMatrix.mapPoints(point);
            canvas.drawLine(point[0] + dx,point[1] + dy,point[2] + dx,point[3] + dy,mPaint);
          }
 else           if (face.getSmileDegree() < smile_threashold_small_smile) {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawArc(mRect,0,180,true,mPaint);
          }
 else {
            mRect.set(face.mouth.x - delta_x,face.mouth.y - delta_y,face.mouth.x + delta_x,face.mouth.y + delta_y);
            mMatrix.mapRect(mRect);
            mRect.offset(dx,dy);
            canvas.drawOval(mRect,mPaint);
          }
        }
      }
    }
    canvas.restore();
  }
  super.onDraw(canvas);
}","In the buggy code, the left and right eye coordinates incorrectly included an extra `dx` offset before matrix transformation, causing misalignment of eye drawing. The fixed code removes the redundant `dx` from the initial eye coordinate assignments, ensuring proper coordinate mapping and accurate eye feature rendering. This correction guarantees that eye positions are precisely calculated and drawn relative to the face detection matrix, improving the overall visual accuracy of facial feature visualization."
38281,"@Override public View getView(int position,View convertView,ViewGroup parent){
  ListPreference pref=mListItem.get(position);
  int viewLayoutId=getSettingLayoutId(pref);
  InLineSettingItem view=(InLineSettingItem)convertView;
  if (view == null) {
    view=(InLineSettingItem)mInflater.inflate(viewLayoutId,parent,false);
  }
  view.initialize(pref);
  view.setSettingChangedListener(MoreSettingPopup.this);
  if (position >= 0 && position < mEnabled.length) {
    view.setEnabled(mEnabled[position]);
  }
 else {
    Log.w(TAG,""String_Node_Str"" + mEnabled.length + ""String_Node_Str""+ position);
  }
  return view;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  ListPreference pref=mListItem.get(position);
  int viewLayoutId=getSettingLayoutId(pref);
  InLineSettingItem view=(InLineSettingItem)convertView;
  view=(InLineSettingItem)mInflater.inflate(viewLayoutId,parent,false);
  view.initialize(pref);
  view.setSettingChangedListener(MoreSettingPopup.this);
  if (position >= 0 && position < mEnabled.length) {
    view.setEnabled(mEnabled[position]);
  }
 else {
    Log.w(TAG,""String_Node_Str"" + mEnabled.length + ""String_Node_Str""+ position);
  }
  return view;
}","The original code inefficiently reused the convertView only when it was null, potentially leading to unnecessary view inflation and performance overhead. In the fixed code, the view is always inflated using mInflater.inflate(), ensuring a fresh view is created for each list item regardless of the convertView state. This approach simplifies view creation, eliminates potential null checks, and provides a more consistent view rendering process for the adapter."
38282,"@Override public View getView(int position,View convertView,ViewGroup parent){
  ListPreference pref=mListItem.get(position);
  int viewLayoutId=getSettingLayoutId(pref);
  InLineSettingItem view=(InLineSettingItem)convertView;
  if (view == null) {
    view=(InLineSettingItem)mInflater.inflate(viewLayoutId,parent,false);
  }
  view.initialize(pref);
  view.setSettingChangedListener(MoreSettingPopup.this);
  if (position >= 0 && position < mEnabled.length) {
    view.setEnabled(mEnabled[position]);
  }
 else {
    Log.w(TAG,""String_Node_Str"" + mEnabled.length + ""String_Node_Str""+ position);
  }
  return view;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  ListPreference pref=mListItem.get(position);
  int viewLayoutId=getSettingLayoutId(pref);
  InLineSettingItem view=(InLineSettingItem)convertView;
  view=(InLineSettingItem)mInflater.inflate(viewLayoutId,parent,false);
  view.initialize(pref);
  view.setSettingChangedListener(MoreSettingPopup.this);
  if (position >= 0 && position < mEnabled.length) {
    view.setEnabled(mEnabled[position]);
  }
 else {
    Log.w(TAG,""String_Node_Str"" + mEnabled.length + ""String_Node_Str""+ position);
  }
  return view;
}","The original code inefficiently reused the convertView only when it was null, potentially causing unnecessary view inflation and memory overhead. In the fixed code, the view is always inflated using mInflater.inflate(), ensuring a fresh view is created for each list item regardless of the convertView state. This approach guarantees consistent view creation, prevents potential view recycling issues, and provides a more predictable rendering process for the list adapter."
38283,"@Override public void setParameters(Parameters params){
  if (params == null) {
    Log.v(TAG,""String_Node_Str"");
    return;
  }
  mCameraHandler.obtainMessage(SET_PARAMETERS,params.flatten()).sendToTarget();
}","@Override public void setParameters(Parameters params){
  if (params == null) {
    Log.v(TAG,""String_Node_Str"");
    return;
  }
  mSig.close();
  mCameraHandler.obtainMessage(SET_PARAMETERS,params).sendToTarget();
  mSig.block();
}","The original code incorrectly flattens camera parameters into a string, potentially losing complex parameter information during message transmission. The fixed code sends the full Parameters object directly and adds synchronization mechanisms (mSig.close() and mSig.block()) to ensure proper parameter setting and thread coordination. This approach preserves parameter integrity, provides explicit synchronization, and prevents potential data loss or race conditions during camera parameter configuration."
38284,"/** 
 * This method does not deal with the API level check.  Everyone should check first for supported operations before sending message to this handler.
 */
@Override public void handleMessage(final Message msg){
  try {
switch (msg.what) {
case OPEN_CAMERA:
      mCamera=android.hardware.Camera.open(msg.arg1);
    if (mCamera != null) {
      mParametersIsDirty=true;
      if (mParamsToSet == null) {
        mParamsToSet=mCamera.getParameters();
      }
    }
 else {
      if (msg.obj != null) {
        ((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
      }
    }
  return;
case RELEASE:
mCamera.release();
mCamera=null;
return;
case RECONNECT:
mReconnectIOException=null;
try {
mCamera.reconnect();
}
 catch (IOException ex) {
mReconnectIOException=ex;
}
return;
case UNLOCK:
mCamera.unlock();
return;
case LOCK:
mCamera.lock();
return;
case SET_PREVIEW_TEXTURE_ASYNC:
setPreviewTexture(msg.obj);
return;
case SET_PREVIEW_DISPLAY_ASYNC:
try {
mCamera.setPreviewDisplay((SurfaceHolder)msg.obj);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
return;
case START_PREVIEW_ASYNC:
mCamera.startPreview();
return;
case STOP_PREVIEW:
mCamera.stopPreview();
return;
case SET_PREVIEW_CALLBACK_WITH_BUFFER:
mCamera.setPreviewCallbackWithBuffer((PreviewCallback)msg.obj);
return;
case ADD_CALLBACK_BUFFER:
mCamera.addCallbackBuffer((byte[])msg.obj);
return;
case AUTO_FOCUS:
mCamera.autoFocus((AutoFocusCallback)msg.obj);
return;
case CANCEL_AUTO_FOCUS:
mCamera.cancelAutoFocus();
return;
case SET_AUTO_FOCUS_MOVE_CALLBACK:
setAutoFocusMoveCallback(mCamera,msg.obj);
return;
case SET_DISPLAY_ORIENTATION:
mCamera.setDisplayOrientation(msg.arg1);
return;
case SET_ZOOM_CHANGE_LISTENER:
mCamera.setZoomChangeListener((OnZoomChangeListener)msg.obj);
return;
case SET_FACE_DETECTION_LISTENER:
setFaceDetectionListener((FaceDetectionListener)msg.obj);
return;
case START_FACE_DETECTION:
startFaceDetection();
return;
case STOP_FACE_DETECTION:
stopFaceDetection();
return;
case SET_ERROR_CALLBACK:
mCamera.setErrorCallback((ErrorCallback)msg.obj);
return;
case SET_PARAMETERS:
mParametersIsDirty=true;
mParamsToSet.unflatten((String)msg.obj);
mCamera.setParameters(mParamsToSet);
return;
case GET_PARAMETERS:
if (mParametersIsDirty) {
mParameters=mCamera.getParameters();
mParametersIsDirty=false;
}
return;
case SET_PREVIEW_CALLBACK:
mCamera.setPreviewCallback((PreviewCallback)msg.obj);
return;
case ENABLE_SHUTTER_SOUND:
enableShutterSound((msg.arg1 == 1) ? true : false);
return;
case REFRESH_PARAMETERS:
mParametersIsDirty=true;
return;
case SET_HISTOGRAM_MODE:
mCamera.setHistogramMode((CameraDataCallback)msg.obj);
break;
case SEND_HISTOGRAM_DATA:
mCamera.sendHistogramData();
break;
case SET_LONGSHOT:
mCamera.setLongshot((Boolean)msg.obj);
break;
default :
throw new RuntimeException(""String_Node_Str"" + msg.what);
}
}
 catch (RuntimeException e) {
if (msg.what != RELEASE && mCamera != null) {
try {
mCamera.release();
}
 catch (Exception ex) {
Log.e(TAG,""String_Node_Str"");
}
mCamera=null;
}
 else if (mCamera == null) {
if (msg.what == OPEN_CAMERA) {
if (msg.obj != null) {
((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
}
}
 else {
Log.w(TAG,""String_Node_Str"");
}
return;
}
throw e;
}
}","/** 
 * This method does not deal with the API level check.  Everyone should check first for supported operations before sending message to this handler.
 */
@Override public void handleMessage(final Message msg){
  try {
switch (msg.what) {
case OPEN_CAMERA:
      mCamera=android.hardware.Camera.open(msg.arg1);
    if (mCamera != null) {
      mParametersIsDirty=true;
      if (mParamsToSet == null) {
        mParamsToSet=mCamera.getParameters();
      }
    }
 else {
      if (msg.obj != null) {
        ((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
      }
    }
  return;
case RELEASE:
mCamera.release();
mCamera=null;
return;
case RECONNECT:
mReconnectIOException=null;
try {
mCamera.reconnect();
}
 catch (IOException ex) {
mReconnectIOException=ex;
}
return;
case UNLOCK:
mCamera.unlock();
return;
case LOCK:
mCamera.lock();
return;
case SET_PREVIEW_TEXTURE_ASYNC:
setPreviewTexture(msg.obj);
return;
case SET_PREVIEW_DISPLAY_ASYNC:
try {
mCamera.setPreviewDisplay((SurfaceHolder)msg.obj);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
return;
case START_PREVIEW_ASYNC:
mCamera.startPreview();
return;
case STOP_PREVIEW:
mCamera.stopPreview();
return;
case SET_PREVIEW_CALLBACK_WITH_BUFFER:
mCamera.setPreviewCallbackWithBuffer((PreviewCallback)msg.obj);
return;
case ADD_CALLBACK_BUFFER:
mCamera.addCallbackBuffer((byte[])msg.obj);
return;
case AUTO_FOCUS:
mCamera.autoFocus((AutoFocusCallback)msg.obj);
return;
case CANCEL_AUTO_FOCUS:
mCamera.cancelAutoFocus();
return;
case SET_AUTO_FOCUS_MOVE_CALLBACK:
setAutoFocusMoveCallback(mCamera,msg.obj);
return;
case SET_DISPLAY_ORIENTATION:
mCamera.setDisplayOrientation(msg.arg1);
return;
case SET_ZOOM_CHANGE_LISTENER:
mCamera.setZoomChangeListener((OnZoomChangeListener)msg.obj);
return;
case SET_FACE_DETECTION_LISTENER:
setFaceDetectionListener((FaceDetectionListener)msg.obj);
return;
case START_FACE_DETECTION:
startFaceDetection();
return;
case STOP_FACE_DETECTION:
stopFaceDetection();
return;
case SET_ERROR_CALLBACK:
mCamera.setErrorCallback((ErrorCallback)msg.obj);
return;
case SET_PARAMETERS:
mParametersIsDirty=true;
mCamera.setParameters((Parameters)msg.obj);
mSig.open();
break;
case GET_PARAMETERS:
if (mParametersIsDirty) {
mParameters=mCamera.getParameters();
mParametersIsDirty=false;
}
return;
case SET_PREVIEW_CALLBACK:
mCamera.setPreviewCallback((PreviewCallback)msg.obj);
return;
case ENABLE_SHUTTER_SOUND:
enableShutterSound((msg.arg1 == 1) ? true : false);
return;
case REFRESH_PARAMETERS:
mParametersIsDirty=true;
return;
case SET_HISTOGRAM_MODE:
mCamera.setHistogramMode((CameraDataCallback)msg.obj);
break;
case SEND_HISTOGRAM_DATA:
mCamera.sendHistogramData();
break;
case SET_LONGSHOT:
mCamera.setLongshot((Boolean)msg.obj);
break;
default :
throw new RuntimeException(""String_Node_Str"" + msg.what);
}
}
 catch (RuntimeException e) {
if (msg.what != RELEASE && mCamera != null) {
try {
mCamera.release();
}
 catch (Exception ex) {
Log.e(TAG,""String_Node_Str"");
}
mCamera=null;
}
 else if (mCamera == null) {
if (msg.what == OPEN_CAMERA) {
if (msg.obj != null) {
((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
}
}
 else {
Log.w(TAG,""String_Node_Str"");
}
return;
}
throw e;
}
}","The original code incorrectly handled parameter setting by using an unflatten method and potentially losing parameter configuration. The fixed code directly sets camera parameters using `mCamera.setParameters((Parameters)msg.obj)` and adds a signal mechanism with `mSig.open()` to ensure proper synchronization and parameter application. This modification improves parameter handling, provides clearer parameter setting, and ensures more robust camera configuration management."
38285,"@Override public void setParameters(Parameters params){
  if (params == null) {
    Log.v(TAG,""String_Node_Str"");
    return;
  }
  mCameraHandler.obtainMessage(SET_PARAMETERS,params.flatten()).sendToTarget();
}","@Override public void setParameters(Parameters params){
  if (params == null) {
    Log.v(TAG,""String_Node_Str"");
    return;
  }
  mSig.close();
  mCameraHandler.obtainMessage(SET_PARAMETERS,params).sendToTarget();
  mSig.block();
}","The original code incorrectly flattens camera parameters into a string before sending, potentially losing critical configuration data during message transmission. The fixed code sends the complete Parameters object directly and adds synchronization mechanisms with mSig.close() and mSig.block() to ensure proper parameter setting and thread coordination. This approach preserves parameter integrity, prevents potential data loss, and provides a more robust method for configuring camera settings across threads."
38286,"/** 
 * This method does not deal with the API level check.  Everyone should check first for supported operations before sending message to this handler.
 */
@Override public void handleMessage(final Message msg){
  try {
switch (msg.what) {
case OPEN_CAMERA:
      mCamera=android.hardware.Camera.open(msg.arg1);
    if (mCamera != null) {
      mParametersIsDirty=true;
      if (mParamsToSet == null) {
        mParamsToSet=mCamera.getParameters();
      }
    }
 else {
      if (msg.obj != null) {
        ((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
      }
    }
  return;
case RELEASE:
mCamera.release();
mCamera=null;
return;
case RECONNECT:
mReconnectIOException=null;
try {
mCamera.reconnect();
}
 catch (IOException ex) {
mReconnectIOException=ex;
}
return;
case UNLOCK:
mCamera.unlock();
return;
case LOCK:
mCamera.lock();
return;
case SET_PREVIEW_TEXTURE_ASYNC:
setPreviewTexture(msg.obj);
return;
case SET_PREVIEW_DISPLAY_ASYNC:
try {
mCamera.setPreviewDisplay((SurfaceHolder)msg.obj);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
return;
case START_PREVIEW_ASYNC:
mCamera.startPreview();
return;
case STOP_PREVIEW:
mCamera.stopPreview();
return;
case SET_PREVIEW_CALLBACK_WITH_BUFFER:
mCamera.setPreviewCallbackWithBuffer((PreviewCallback)msg.obj);
return;
case ADD_CALLBACK_BUFFER:
mCamera.addCallbackBuffer((byte[])msg.obj);
return;
case AUTO_FOCUS:
mCamera.autoFocus((AutoFocusCallback)msg.obj);
return;
case CANCEL_AUTO_FOCUS:
mCamera.cancelAutoFocus();
return;
case SET_AUTO_FOCUS_MOVE_CALLBACK:
setAutoFocusMoveCallback(mCamera,msg.obj);
return;
case SET_DISPLAY_ORIENTATION:
mCamera.setDisplayOrientation(msg.arg1);
return;
case SET_ZOOM_CHANGE_LISTENER:
mCamera.setZoomChangeListener((OnZoomChangeListener)msg.obj);
return;
case SET_FACE_DETECTION_LISTENER:
setFaceDetectionListener((FaceDetectionListener)msg.obj);
return;
case START_FACE_DETECTION:
startFaceDetection();
return;
case STOP_FACE_DETECTION:
stopFaceDetection();
return;
case SET_ERROR_CALLBACK:
mCamera.setErrorCallback((ErrorCallback)msg.obj);
return;
case SET_PARAMETERS:
mParametersIsDirty=true;
mParamsToSet.unflatten((String)msg.obj);
mCamera.setParameters(mParamsToSet);
return;
case GET_PARAMETERS:
if (mParametersIsDirty) {
mParameters=mCamera.getParameters();
mParametersIsDirty=false;
}
return;
case SET_PREVIEW_CALLBACK:
mCamera.setPreviewCallback((PreviewCallback)msg.obj);
return;
case ENABLE_SHUTTER_SOUND:
enableShutterSound((msg.arg1 == 1) ? true : false);
return;
case REFRESH_PARAMETERS:
mParametersIsDirty=true;
return;
case SET_HISTOGRAM_MODE:
mCamera.setHistogramMode((CameraDataCallback)msg.obj);
break;
case SEND_HISTOGRAM_DATA:
mCamera.sendHistogramData();
break;
case SET_LONGSHOT:
mCamera.setLongshot((Boolean)msg.obj);
break;
default :
throw new RuntimeException(""String_Node_Str"" + msg.what);
}
}
 catch (RuntimeException e) {
if (msg.what != RELEASE && mCamera != null) {
try {
mCamera.release();
}
 catch (Exception ex) {
Log.e(TAG,""String_Node_Str"");
}
mCamera=null;
}
 else if (mCamera == null) {
if (msg.what == OPEN_CAMERA) {
if (msg.obj != null) {
((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
}
}
 else {
Log.w(TAG,""String_Node_Str"");
}
return;
}
throw e;
}
}","/** 
 * This method does not deal with the API level check.  Everyone should check first for supported operations before sending message to this handler.
 */
@Override public void handleMessage(final Message msg){
  try {
switch (msg.what) {
case OPEN_CAMERA:
      mCamera=android.hardware.Camera.open(msg.arg1);
    if (mCamera != null) {
      mParametersIsDirty=true;
      if (mParamsToSet == null) {
        mParamsToSet=mCamera.getParameters();
      }
    }
 else {
      if (msg.obj != null) {
        ((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
      }
    }
  return;
case RELEASE:
mCamera.release();
mCamera=null;
return;
case RECONNECT:
mReconnectIOException=null;
try {
mCamera.reconnect();
}
 catch (IOException ex) {
mReconnectIOException=ex;
}
return;
case UNLOCK:
mCamera.unlock();
return;
case LOCK:
mCamera.lock();
return;
case SET_PREVIEW_TEXTURE_ASYNC:
setPreviewTexture(msg.obj);
return;
case SET_PREVIEW_DISPLAY_ASYNC:
try {
mCamera.setPreviewDisplay((SurfaceHolder)msg.obj);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
return;
case START_PREVIEW_ASYNC:
mCamera.startPreview();
return;
case STOP_PREVIEW:
mCamera.stopPreview();
return;
case SET_PREVIEW_CALLBACK_WITH_BUFFER:
mCamera.setPreviewCallbackWithBuffer((PreviewCallback)msg.obj);
return;
case ADD_CALLBACK_BUFFER:
mCamera.addCallbackBuffer((byte[])msg.obj);
return;
case AUTO_FOCUS:
mCamera.autoFocus((AutoFocusCallback)msg.obj);
return;
case CANCEL_AUTO_FOCUS:
mCamera.cancelAutoFocus();
return;
case SET_AUTO_FOCUS_MOVE_CALLBACK:
setAutoFocusMoveCallback(mCamera,msg.obj);
return;
case SET_DISPLAY_ORIENTATION:
mCamera.setDisplayOrientation(msg.arg1);
return;
case SET_ZOOM_CHANGE_LISTENER:
mCamera.setZoomChangeListener((OnZoomChangeListener)msg.obj);
return;
case SET_FACE_DETECTION_LISTENER:
setFaceDetectionListener((FaceDetectionListener)msg.obj);
return;
case START_FACE_DETECTION:
startFaceDetection();
return;
case STOP_FACE_DETECTION:
stopFaceDetection();
return;
case SET_ERROR_CALLBACK:
mCamera.setErrorCallback((ErrorCallback)msg.obj);
return;
case SET_PARAMETERS:
mParametersIsDirty=true;
mCamera.setParameters((Parameters)msg.obj);
mSig.open();
break;
case GET_PARAMETERS:
if (mParametersIsDirty) {
mParameters=mCamera.getParameters();
mParametersIsDirty=false;
}
return;
case SET_PREVIEW_CALLBACK:
mCamera.setPreviewCallback((PreviewCallback)msg.obj);
return;
case ENABLE_SHUTTER_SOUND:
enableShutterSound((msg.arg1 == 1) ? true : false);
return;
case REFRESH_PARAMETERS:
mParametersIsDirty=true;
return;
case SET_HISTOGRAM_MODE:
mCamera.setHistogramMode((CameraDataCallback)msg.obj);
break;
case SEND_HISTOGRAM_DATA:
mCamera.sendHistogramData();
break;
case SET_LONGSHOT:
mCamera.setLongshot((Boolean)msg.obj);
break;
default :
throw new RuntimeException(""String_Node_Str"" + msg.what);
}
}
 catch (RuntimeException e) {
if (msg.what != RELEASE && mCamera != null) {
try {
mCamera.release();
}
 catch (Exception ex) {
Log.e(TAG,""String_Node_Str"");
}
mCamera=null;
}
 else if (mCamera == null) {
if (msg.what == OPEN_CAMERA) {
if (msg.obj != null) {
((CameraOpenErrorCallback)msg.obj).onDeviceOpenFailure(msg.arg1);
}
}
 else {
Log.w(TAG,""String_Node_Str"");
}
return;
}
throw e;
}
}","The original code had an incorrect handling of camera parameters in the SET_PARAMETERS case, using an unsafe method of parameter modification. In the fixed code, the parameters are directly set using mCamera.setParameters((Parameters)msg.obj), ensuring proper parameter assignment, and adding mSig.open() to signal successful parameter setting. This modification improves parameter handling reliability, provides clearer parameter setting mechanism, and reduces potential runtime errors in camera configuration."
38287,"/** 
 * Shows a progress indicator. If the progress is '100', the progress indicator will be hidden.
 * @param percent the progress in percent (0-100).
 */
public void setProgress(int percent){
  percent=Math.min(100,Math.max(percent,0));
  mProgressAngleDegrees=(int)((360f / 100) * percent);
  if (percent < 100) {
    mVisible=true;
  }
}","/** 
 * Shows a progress indicator. If the progress is '100', the progress indicator will be hidden.
 * @param percent the progress in percent (0-100).
 */
public void setProgress(int percent){
  percent=Math.min(100,Math.max(percent,0));
  mProgressAngleDegrees=(int)((360f / 100) * percent);
  if (percent < 100) {
    mVisible=true;
    mTimeToHide=System.currentTimeMillis() + SHOW_PROGRESS_X_ADDITIONAL_MS;
  }
}","The original code only sets `mVisible` to true when progress is less than 100, which could lead to inconsistent visibility management. The fixed code adds `mTimeToHide = System.currentTimeMillis() + SHOW_PROGRESS_X_ADDITIONAL_MS`, introducing a timed visibility control mechanism that allows temporary display of the progress indicator. This enhancement ensures more predictable and controlled visibility of the progress indicator, providing a more robust user interface experience."
38288,"/** 
 * Draw the current progress (if < 100%) centered at the given location.
 */
public void onDraw(Canvas canvas,int centerX,int centerY){
  if (!mVisible) {
    return;
  }
  mArcBounds=new RectF(centerX - mProgressRadius,centerY - mProgressRadius,centerX + mProgressRadius,centerY + mProgressRadius);
  canvas.drawCircle(centerX,centerY,mProgressRadius,mProgressBasePaint);
  canvas.drawArc(mArcBounds,-90,mProgressAngleDegrees,false,mProgressPaint);
  if (mProgressAngleDegrees == 360) {
    if (showProgressXMoreFrames <= 0) {
      showProgressXMoreFrames=SHOW_PROGRESS_X_ADDITIONAL_FRAMES;
    }
 else {
      if (--showProgressXMoreFrames == 0) {
        mVisible=false;
        if (mVisibilityListener != null) {
          mVisibilityListener.onHidden();
        }
      }
    }
  }
}","/** 
 * Draw the current progress (if < 100%) centered at the given location.
 */
public void onDraw(Canvas canvas,int centerX,int centerY){
  if (!mVisible) {
    return;
  }
  mArcBounds=new RectF(centerX - mProgressRadius,centerY - mProgressRadius,centerX + mProgressRadius,centerY + mProgressRadius);
  canvas.drawCircle(centerX,centerY,mProgressRadius,mProgressBasePaint);
  canvas.drawArc(mArcBounds,-90,mProgressAngleDegrees,false,mProgressPaint);
  if (mProgressAngleDegrees == 360 && System.currentTimeMillis() > mTimeToHide) {
    mVisible=false;
    if (mVisibilityListener != null) {
      mVisibilityListener.onHidden();
    }
  }
}","The original code used a frame-based countdown mechanism for hiding the progress indicator, which could lead to inconsistent timing and potential synchronization issues. The fixed code replaces the frame-based approach with a time-based method using `System.currentTimeMillis()`, ensuring more precise and reliable progress visibility control. This change provides a more robust and predictable way to manage the visibility of the progress indicator, independent of frame rendering rates."
38289,"/** 
 * Shows a progress indicator. If the progress is '100', the progress indicator will be hidden.
 * @param percent the progress in percent (0-100).
 */
public void setProgress(int percent){
  percent=Math.min(100,Math.max(percent,0));
  mProgressAngleDegrees=(int)((360f / 100) * percent);
  if (percent < 100) {
    mVisible=true;
  }
}","/** 
 * Shows a progress indicator. If the progress is '100', the progress indicator will be hidden.
 * @param percent the progress in percent (0-100).
 */
public void setProgress(int percent){
  percent=Math.min(100,Math.max(percent,0));
  mProgressAngleDegrees=(int)((360f / 100) * percent);
  if (percent < 100) {
    mVisible=true;
    mTimeToHide=System.currentTimeMillis() + SHOW_PROGRESS_X_ADDITIONAL_MS;
  }
}","The original code only sets `mVisible` to true when progress is less than 100, which could lead to inconsistent visibility management. The fixed code adds `mTimeToHide = System.currentTimeMillis() + SHOW_PROGRESS_X_ADDITIONAL_MS`, ensuring the progress indicator remains visible for a specific duration after reaching a non-complete state. This modification provides more predictable and controlled visibility behavior, preventing abrupt hiding of the progress indicator."
38290,"/** 
 * Draw the current progress (if < 100%) centered at the given location.
 */
public void onDraw(Canvas canvas,int centerX,int centerY){
  if (!mVisible) {
    return;
  }
  mArcBounds=new RectF(centerX - mProgressRadius,centerY - mProgressRadius,centerX + mProgressRadius,centerY + mProgressRadius);
  canvas.drawCircle(centerX,centerY,mProgressRadius,mProgressBasePaint);
  canvas.drawArc(mArcBounds,-90,mProgressAngleDegrees,false,mProgressPaint);
  if (mProgressAngleDegrees == 360) {
    if (showProgressXMoreFrames <= 0) {
      showProgressXMoreFrames=SHOW_PROGRESS_X_ADDITIONAL_FRAMES;
    }
 else {
      if (--showProgressXMoreFrames == 0) {
        mVisible=false;
        if (mVisibilityListener != null) {
          mVisibilityListener.onHidden();
        }
      }
    }
  }
}","/** 
 * Draw the current progress (if < 100%) centered at the given location.
 */
public void onDraw(Canvas canvas,int centerX,int centerY){
  if (!mVisible) {
    return;
  }
  mArcBounds=new RectF(centerX - mProgressRadius,centerY - mProgressRadius,centerX + mProgressRadius,centerY + mProgressRadius);
  canvas.drawCircle(centerX,centerY,mProgressRadius,mProgressBasePaint);
  canvas.drawArc(mArcBounds,-90,mProgressAngleDegrees,false,mProgressPaint);
  if (mProgressAngleDegrees == 360 && System.currentTimeMillis() > mTimeToHide) {
    mVisible=false;
    if (mVisibilityListener != null) {
      mVisibilityListener.onHidden();
    }
  }
}","The original code used a frame-based countdown mechanism for hiding the progress indicator, which could lead to inconsistent timing and potential synchronization issues. The fixed code introduces `System.currentTimeMillis()` to provide a more reliable time-based condition for hiding the progress, ensuring consistent behavior across different rendering cycles. This change makes the visibility logic more predictable and less dependent on frame-specific counters, resulting in a more robust progress indicator implementation."
38291,"/** 
 * Shows a progress indicator. If the progress is '100', the progress indicator will be hidden.
 * @param percent the progress in percent (0-100).
 */
public void setProgress(int percent){
  percent=Math.min(100,Math.max(percent,0));
  mProgressAngleDegrees=(int)((360f / 100) * percent);
  if (percent < 100) {
    mVisible=true;
  }
}","/** 
 * Shows a progress indicator. If the progress is '100', the progress indicator will be hidden.
 * @param percent the progress in percent (0-100).
 */
public void setProgress(int percent){
  percent=Math.min(100,Math.max(percent,0));
  mProgressAngleDegrees=(int)((360f / 100) * percent);
  if (percent < 100) {
    mVisible=true;
    mTimeToHide=System.currentTimeMillis() + SHOW_PROGRESS_X_ADDITIONAL_MS;
  }
}","The original code only sets `mVisible` to true when progress is less than 100, potentially leaving the progress indicator in an inconsistent state. The fixed code adds `mTimeToHide=System.currentTimeMillis() + SHOW_PROGRESS_X_ADDITIONAL_MS`, which introduces a timed visibility mechanism for the progress indicator. This enhancement ensures more predictable and controlled visibility of the progress indicator, providing a clearer and more robust implementation of progress tracking."
38292,"/** 
 * Draw the current progress (if < 100%) centered at the given location.
 */
public void onDraw(Canvas canvas,int centerX,int centerY){
  if (!mVisible) {
    return;
  }
  mArcBounds=new RectF(centerX - mProgressRadius,centerY - mProgressRadius,centerX + mProgressRadius,centerY + mProgressRadius);
  canvas.drawCircle(centerX,centerY,mProgressRadius,mProgressBasePaint);
  canvas.drawArc(mArcBounds,-90,mProgressAngleDegrees,false,mProgressPaint);
  if (mProgressAngleDegrees == 360) {
    if (showProgressXMoreFrames <= 0) {
      showProgressXMoreFrames=SHOW_PROGRESS_X_ADDITIONAL_FRAMES;
    }
 else {
      if (--showProgressXMoreFrames == 0) {
        mVisible=false;
        if (mVisibilityListener != null) {
          mVisibilityListener.onHidden();
        }
      }
    }
  }
}","/** 
 * Draw the current progress (if < 100%) centered at the given location.
 */
public void onDraw(Canvas canvas,int centerX,int centerY){
  if (!mVisible) {
    return;
  }
  mArcBounds=new RectF(centerX - mProgressRadius,centerY - mProgressRadius,centerX + mProgressRadius,centerY + mProgressRadius);
  canvas.drawCircle(centerX,centerY,mProgressRadius,mProgressBasePaint);
  canvas.drawArc(mArcBounds,-90,mProgressAngleDegrees,false,mProgressPaint);
  if (mProgressAngleDegrees == 360 && System.currentTimeMillis() > mTimeToHide) {
    mVisible=false;
    if (mVisibilityListener != null) {
      mVisibilityListener.onHidden();
    }
  }
}","The original code uses a frame-based countdown mechanism for hiding the progress indicator, which can lead to inconsistent timing and potential synchronization issues. The fixed code replaces the frame-based approach with a time-based check using `System.currentTimeMillis()`, ensuring a more reliable and precise method for determining when to hide the progress. This modification provides a more robust and predictable way to manage the visibility of the progress indicator, eliminating potential timing-related bugs."
38293,"@Override public void onListPrefChanged(ListPreference pref){
  if (mPopup1 != null && mPopup2 != null && mPopup3 != null) {
    if (mPopupStatus == POPUP_SECOND_LEVEL) {
      mUI.dismissPopup();
    }
  }
  onSettingChanged(pref);
}","@Override public void onListPrefChanged(ListPreference pref){
  if (mPopup != null && mPopup1 != null && mPopup2 != null && mPopup3 != null) {
    mUI.dismissPopup();
  }
  onSettingChanged(pref);
}","The original code conditionally dismisses a popup only when in a second-level popup state, potentially leaving other popups unhandled. The fixed code simplifies the condition by checking multiple popup references and always calling dismissPopup(), ensuring comprehensive popup management regardless of current state. This approach provides a more robust and consistent UI interaction mechanism by universally clearing all popup instances before proceeding with settings changes."
38294,"@Override public void onListPrefChanged(ListPreference pref){
  if (mPopup1 != null && mPopup2 != null) {
    if (mPopupStatus == POPUP_SECOND_LEVEL) {
      mUI.dismissPopup(true);
    }
  }
  super.onSettingChanged(pref);
}","@Override public void onListPrefChanged(ListPreference pref){
  if (mPopup1 != null && mPopup2 != null) {
    if (mPopupStatus == POPUP_SECOND_LEVEL) {
      mUI.dismissPopup(true);
      mPopup1.reloadPreference();
      mPopup2.reloadPreference();
    }
  }
  super.onSettingChanged(pref);
}","The original code dismisses the popup but fails to reload preferences, potentially leaving stale or outdated settings in the UI. The fixed code adds `mPopup1.reloadPreference()` and `mPopup2.reloadPreference()` to ensure that both popups refresh their current settings after dismissal. This ensures that the user interface reflects the most recent preference changes, maintaining data consistency and preventing potential UI synchronization issues."
38295,"public void popupDismissed(boolean topPopupOnly){
  if (mPopupStatus == POPUP_SECOND_LEVEL) {
    initializePopup();
    mPopupStatus=POPUP_FIRST_LEVEL;
    if (topPopupOnly)     mUI.showPopup(mPopup);
  }
}","public void popupDismissed(boolean topPopupOnly){
  if (mPopupStatus == POPUP_SECOND_LEVEL) {
    initializePopup();
    mPopupStatus=POPUP_FIRST_LEVEL;
    if (topPopupOnly) {
      if (popupNum == 1)       mUI.showPopup(mPopup1);
 else       if (popupNum == 2)       mUI.showPopup(mPopup2);
    }
  }
 else {
    initializePopup();
  }
}","The original code incorrectly showed a generic popup without considering multiple popup scenarios, potentially displaying the wrong popup or causing unexpected UI behavior. The fixed code introduces conditional logic to show specific popups (mPopup1 or mPopup2) based on the current popup number, ensuring the correct popup is displayed when topPopupOnly is true. This modification provides more precise popup management, allowing for better control and flexibility in handling different popup levels and states."
38296,"public void initialize(PreferenceGroup group){
  super.initialize(group);
  mPopup=null;
  mPopup1=null;
  mPopup2=null;
  mPopupStatus=POPUP_NONE;
  PieItem item=null;
  mOtherKeys1=new String[]{CameraSettings.KEY_VIDEO_EFFECT,CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL,CameraSettings.KEY_VIDEO_QUALITY,CameraSettings.KEY_VIDEO_ENCODER,CameraSettings.KEY_AUDIO_ENCODER,CameraSettings.KEY_VIDEO_DURATION,CameraSettings.KEY_RECORD_LOCATION};
  mOtherKeys2=new String[]{CameraSettings.KEY_COLOR_EFFECT,CameraSettings.KEY_VIDEO_HDR,CameraSettings.KEY_POWER_MODE,CameraSettings.KEY_WHITE_BALANCE,CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,CameraSettings.KEY_VIDEOCAMERA_FLASH_MODE};
  PieItem item1=makeItem(R.drawable.ic_settings_holo_light);
  item1.setLabel(mActivity.getResources().getString(R.string.camera_menu_more_label));
  item1.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    PieItem item){
      if (mPopup1 == null || mPopupStatus != POPUP_FIRST_LEVEL) {
        initializePopup();
        mPopupStatus=POPUP_FIRST_LEVEL;
      }
      mUI.showPopup(mPopup1);
    }
  }
);
  mRenderer.addItem(item1);
  PieItem item2=makeItem(R.drawable.ic_settings_holo_light);
  item2.setLabel(mActivity.getResources().getString(R.string.camera_menu_more_label));
  item2.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    PieItem item){
      if (mPopup2 == null || mPopupStatus != POPUP_FIRST_LEVEL) {
        initializePopup();
        mPopupStatus=POPUP_FIRST_LEVEL;
      }
      mUI.showPopup(mPopup2);
    }
  }
);
  mRenderer.addItem(item2);
  if (group.findPreference(CameraSettings.KEY_CAMERA_ID) != null) {
    item=makeItem(R.drawable.ic_switch_back);
    IconListPreference lpref=(IconListPreference)group.findPreference(CameraSettings.KEY_CAMERA_ID);
    item.setLabel(lpref.getLabel());
    item.setImageResource(mActivity,((IconListPreference)lpref).getIconIds()[lpref.findIndexOfValue(lpref.getValue())]);
    final PieItem fitem=item;
    item.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      PieItem item){
        ListPreference pref=mPreferenceGroup.findPreference(CameraSettings.KEY_CAMERA_ID);
        if (pref != null) {
          int index=pref.findIndexOfValue(pref.getValue());
          CharSequence[] values=pref.getEntryValues();
          index=(index + 1) % values.length;
          int newCameraId=Integer.parseInt((String)values[index]);
          fitem.setImageResource(mActivity,((IconListPreference)pref).getIconIds()[index]);
          fitem.setLabel(pref.getLabel());
          mListener.onCameraPickerClicked(newCameraId);
        }
      }
    }
);
    mRenderer.addItem(item);
  }
}","public void initialize(PreferenceGroup group){
  super.initialize(group);
  mPopup1=null;
  mPopup2=null;
  popupNum=0;
  mPopupStatus=POPUP_NONE;
  PieItem item=null;
  mOtherKeys1=new String[]{CameraSettings.KEY_VIDEO_EFFECT,CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL,CameraSettings.KEY_VIDEO_QUALITY,CameraSettings.KEY_VIDEO_ENCODER,CameraSettings.KEY_AUDIO_ENCODER,CameraSettings.KEY_VIDEO_DURATION,CameraSettings.KEY_RECORD_LOCATION};
  mOtherKeys2=new String[]{CameraSettings.KEY_COLOR_EFFECT,CameraSettings.KEY_VIDEO_HDR,CameraSettings.KEY_POWER_MODE,CameraSettings.KEY_WHITE_BALANCE,CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,CameraSettings.KEY_VIDEOCAMERA_FLASH_MODE};
  PieItem item1=makeItem(R.drawable.ic_settings_holo_light);
  item1.setLabel(mActivity.getResources().getString(R.string.camera_menu_more_label));
  item1.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    PieItem item){
      if (mPopup1 == null || mPopupStatus != POPUP_FIRST_LEVEL) {
        initializePopup();
        mPopupStatus=POPUP_FIRST_LEVEL;
      }
      mUI.showPopup(mPopup1);
      popupNum=1;
    }
  }
);
  mRenderer.addItem(item1);
  PieItem item2=makeItem(R.drawable.ic_settings_holo_light);
  item2.setLabel(mActivity.getResources().getString(R.string.camera_menu_more_label));
  item2.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    PieItem item){
      if (mPopup2 == null || mPopupStatus != POPUP_FIRST_LEVEL) {
        initializePopup();
        mPopupStatus=POPUP_FIRST_LEVEL;
      }
      mUI.showPopup(mPopup2);
      popupNum=2;
    }
  }
);
  mRenderer.addItem(item2);
  if (group.findPreference(CameraSettings.KEY_CAMERA_ID) != null) {
    item=makeItem(R.drawable.ic_switch_back);
    IconListPreference lpref=(IconListPreference)group.findPreference(CameraSettings.KEY_CAMERA_ID);
    item.setLabel(lpref.getLabel());
    item.setImageResource(mActivity,((IconListPreference)lpref).getIconIds()[lpref.findIndexOfValue(lpref.getValue())]);
    final PieItem fitem=item;
    item.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      PieItem item){
        ListPreference pref=mPreferenceGroup.findPreference(CameraSettings.KEY_CAMERA_ID);
        if (pref != null) {
          int index=pref.findIndexOfValue(pref.getValue());
          CharSequence[] values=pref.getEntryValues();
          index=(index + 1) % values.length;
          int newCameraId=Integer.parseInt((String)values[index]);
          fitem.setImageResource(mActivity,((IconListPreference)pref).getIconIds()[index]);
          fitem.setLabel(pref.getLabel());
          mListener.onCameraPickerClicked(newCameraId);
        }
      }
    }
);
    mRenderer.addItem(item);
  }
}","The original code had an undefined `mPopup` variable and lacked tracking of which popup was currently active. The fixed code introduces a `popupNum` variable to track the active popup (1 or 2) and removes the redundant `mPopup` declaration. This modification provides clearer state management and prevents potential null pointer issues, ensuring more robust popup handling in the camera settings interface."
38297,"@Override public void onPreferenceClicked(ListPreference pref){
  if (mPopupStatus != POPUP_FIRST_LEVEL)   return;
  LayoutInflater inflater=(LayoutInflater)mActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  if (CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL.equals(pref.getKey())) {
    TimeIntervalPopup timeInterval=(TimeIntervalPopup)inflater.inflate(R.layout.time_interval_popup,null,false);
    timeInterval.initialize((IconListPreference)pref);
    timeInterval.setSettingChangedListener(this);
    mUI.dismissPopup(true);
    mPopup=timeInterval;
  }
 else {
    ListPrefSettingPopup basic=(ListPrefSettingPopup)inflater.inflate(R.layout.list_pref_setting_popup,null,false);
    basic.initialize(pref);
    basic.setSettingChangedListener(this);
    mUI.dismissPopup(true);
    mPopup=basic;
  }
  mUI.showPopup(mPopup);
  mPopupStatus=POPUP_SECOND_LEVEL;
}","@Override public void onPreferenceClicked(ListPreference pref){
  if (mPopupStatus != POPUP_FIRST_LEVEL)   return;
  LayoutInflater inflater=(LayoutInflater)mActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  if (CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL.equals(pref.getKey())) {
    TimeIntervalPopup timeInterval=(TimeIntervalPopup)inflater.inflate(R.layout.time_interval_popup,null,false);
    timeInterval.initialize((IconListPreference)pref);
    timeInterval.setSettingChangedListener(this);
    mUI.dismissPopup(true);
    mPopup1=timeInterval;
  }
 else {
    ListPrefSettingPopup basic=(ListPrefSettingPopup)inflater.inflate(R.layout.list_pref_setting_popup,null,false);
    basic.initialize(pref);
    basic.setSettingChangedListener(this);
    mUI.dismissPopup(true);
    mPopup1=basic;
  }
  mUI.showPopup(mPopup1);
  mPopupStatus=POPUP_SECOND_LEVEL;
}","The original code uses `mPopup` as a variable to store the inflated popup, which could lead to potential reference issues or unintended overwriting. In the fixed code, `mPopup` is replaced with `mPopup1`, suggesting a more explicit and potentially separate reference for managing popup states. This change ensures better encapsulation and prevents potential conflicts when managing different types of popups in the camera settings interface."
38298,"@Override public void overrideSettings(final String... keyvalues){
  super.overrideSettings(keyvalues);
  if (mPopup == null || mPopupStatus != POPUP_FIRST_LEVEL) {
    mPopupStatus=POPUP_FIRST_LEVEL;
    initializePopup();
  }
  ((MoreSettingPopup)mPopup).overrideSettings(keyvalues);
}","@Override public void overrideSettings(final String... keyvalues){
  super.overrideSettings(keyvalues);
  if (((mPopup1 == null) && (mPopup2 == null)) || mPopupStatus != POPUP_FIRST_LEVEL) {
    mPopupStatus=POPUP_FIRST_LEVEL;
    initializePopup();
  }
  ((MoreSettingPopup)mPopup1).overrideSettings(keyvalues);
  ((MoreSettingPopup)mPopup2).overrideSettings(keyvalues);
}","The original code assumes a single popup (`mPopup`) and may fail when multiple popups exist or are in different states. The fixed code checks for null conditions across two popup instances (`mPopup1` and `mPopup2`) and ensures initialization if needed, while also calling `overrideSettings()` on both popups. This approach provides more robust handling of multiple popup scenarios, preventing potential null pointer exceptions and ensuring comprehensive settings override across different popup instances."
38299,"@Override protected Bitmap doInBackground(Void... params){
  Bitmap bitmap=CameraUtil.downSample(mData,DOWN_SAMPLE_FACTOR);
  if (mOrientation != 0 || mMirror) {
    Matrix m=new Matrix();
    m.preRotate(mOrientation);
    if (mMirror) {
      m.setScale(-1f,1f);
    }
    return Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),m,false);
  }
  return bitmap;
}","@Override protected Bitmap doInBackground(Void... params){
  Bitmap bitmap=CameraUtil.downSample(mData,DOWN_SAMPLE_FACTOR);
  if (mOrientation != 0 || mMirror) {
    Matrix m=new Matrix();
    if (mMirror) {
      m.setScale(-1f,1f);
    }
    m.preRotate(mOrientation);
    return Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),m,false);
  }
  return bitmap;
}","The original code incorrectly applies matrix transformations by rotating first and then attempting to mirror, which can lead to unexpected image orientation. In the fixed code, the mirror transformation is applied before rotation, ensuring that the mirroring occurs before the orientation change. This corrected sequence of transformations guarantees that the bitmap is first flipped horizontally and then rotated to the desired orientation, resulting in the intended visual output."
38300,"@Override public void stopPreview(){
  if (mCameraDevice != null && mCameraState != PREVIEW_STOPPED) {
    Log.v(TAG,""String_Node_Str"");
    mCameraDevice.stopPreview();
    mFaceDetectionStarted=false;
  }
  setCameraState(PREVIEW_STOPPED);
  if (mFocusManager != null)   mFocusManager.onPreviewStopped();
}","@Override public void stopPreview(){
  if (mCameraDevice != null && mCameraState != PREVIEW_STOPPED) {
    Log.v(TAG,""String_Node_Str"");
    mCameraDevice.stopPreview();
  }
  setCameraState(PREVIEW_STOPPED);
  if (mFocusManager != null)   mFocusManager.onPreviewStopped();
}","The original code incorrectly sets `mFaceDetectionStarted` to false within the preview stop method, which could lead to unexpected state management. The fixed code removes this unnecessary flag manipulation, ensuring that only the essential camera preview stopping logic remains intact. By simplifying the method and focusing on core camera state changes, the revised implementation provides cleaner and more predictable camera preview control."
38301,"private void startCameraPreview(){
  if (mCameraDevice == null) {
    return;
  }
  if (mUI.getSurfaceTexture() == null) {
    return;
  }
synchronized (mRendererLock) {
    if (mCameraTexture == null)     return;
    if (mCameraState != PREVIEW_STOPPED)     stopCameraPreview();
    mCameraDevice.setDisplayOrientation(0);
    mCameraTexture.setOnFrameAvailableListener(this);
    mCameraDevice.setPreviewTexture(mCameraTexture);
  }
  mCameraDevice.startPreview();
  mCameraState=PREVIEW_ACTIVE;
}","private void startCameraPreview(){
  if (mCameraDevice == null) {
    return;
  }
  if (mUI.getSurfaceTexture() == null) {
    return;
  }
synchronized (mRendererLock) {
    if (mCameraTexture == null)     return;
    if (mCameraState != PREVIEW_STOPPED)     stopCameraPreview();
    if (mCameraOrientation == 0)     mCameraDevice.setDisplayOrientation(270);
 else     mCameraDevice.setDisplayOrientation(0);
    if (mCameraTexture != null)     mCameraTexture.setOnFrameAvailableListener(this);
    mCameraDevice.setPreviewTexture(mCameraTexture);
  }
  mCameraDevice.startPreview();
  mCameraState=PREVIEW_ACTIVE;
}","The original code always sets the display orientation to 0, which could cause incorrect camera preview rotation on different devices. The fixed code introduces a conditional orientation setting based on `mCameraOrientation`, allowing dynamic adjustment between 0 and 270 degrees, and adds a null check for `mCameraTexture` before setting the frame available listener. These changes ensure proper camera preview orientation and prevent potential null pointer exceptions, resulting in more robust and adaptable camera preview initialization."
38302,"private int getCaptureOrientation(){
  int orientation;
  if (mUsingFrontCamera) {
    orientation=(mDeviceOrientationAtCapture - mCameraOrientation + 360) % 360;
  }
 else {
    orientation=(mDeviceOrientationAtCapture + mCameraOrientation) % 360;
  }
  return orientation;
}","private int getCaptureOrientation(){
  int orientation;
  int cameraOrientation=mCameraOrientation;
  if (mDeviceOrientationAtCapture == 270 || mDeviceOrientationAtCapture == 90) {
    if (mCameraOrientation == 0)     cameraOrientation=180;
  }
  if (mUsingFrontCamera) {
    orientation=(mDeviceOrientationAtCapture - cameraOrientation + 360) % 360;
  }
 else {
    orientation=(mDeviceOrientationAtCapture + cameraOrientation) % 360;
  }
  return orientation;
}","The original code incorrectly handled camera orientation, potentially producing wrong rotation angles, especially for front-facing cameras with different sensor orientations. The fixed code introduces a conditional adjustment of camera orientation based on device orientation, specifically handling cases where the device is rotated 90 or 270 degrees and the camera sensor is at 0 degrees. By dynamically correcting the camera orientation before calculating the final orientation, the code now accurately captures and rotates images across different device and camera configurations."
38303,"private void startCameraPreview(){
  if (mCameraDevice == null) {
    return;
  }
  if (mUI.getSurfaceTexture() == null) {
    return;
  }
synchronized (mRendererLock) {
    if (mCameraTexture == null)     return;
    if (mCameraState != PREVIEW_STOPPED)     stopCameraPreview();
    if (mCameraOrientation == 0)     mCameraDevice.setDisplayOrientation(270);
 else     mCameraDevice.setDisplayOrientation(0);
    if (mCameraTexture != null)     mCameraTexture.setOnFrameAvailableListener(this);
    mCameraDevice.setPreviewTexture(mCameraTexture);
  }
  mCameraDevice.startPreview();
  mCameraState=PREVIEW_ACTIVE;
}","private void startCameraPreview(){
  if (mCameraDevice == null) {
    return;
  }
  if (mUI.getSurfaceTexture() == null) {
    return;
  }
synchronized (mRendererLock) {
    if (mCameraTexture == null)     return;
    if (mCameraState != PREVIEW_STOPPED)     stopCameraPreview();
    mPanoAngle=(mCameraOrientation - 90 + 360) % 360;
    mCameraDevice.setDisplayOrientation(mPanoAngle);
    if (mCameraTexture != null)     mCameraTexture.setOnFrameAvailableListener(this);
    mCameraDevice.setPreviewTexture(mCameraTexture);
  }
  mCameraDevice.startPreview();
  mCameraState=PREVIEW_ACTIVE;
}","The original code incorrectly sets display orientation with a hardcoded approach, using only two fixed angles (0 or 270 degrees) without considering the full range of possible camera orientations. The fixed code introduces a more flexible calculation using `mPanoAngle`, which dynamically computes the correct orientation by subtracting 90 degrees and ensuring the result remains within the 0-360 degree range. This modification provides a robust and adaptable method for handling camera orientation across different device configurations, improving the code's reliability and flexibility."
38304,"private int getCaptureOrientation(){
  int orientation;
  int cameraOrientation=mCameraOrientation;
  if (mDeviceOrientationAtCapture == 270 || mDeviceOrientationAtCapture == 90) {
    if (mCameraOrientation == 0)     cameraOrientation=180;
  }
  if (mUsingFrontCamera) {
    orientation=(mDeviceOrientationAtCapture - cameraOrientation + 360) % 360;
  }
 else {
    orientation=(mDeviceOrientationAtCapture + cameraOrientation) % 360;
  }
  return orientation;
}","private int getCaptureOrientation(){
  int orientation;
  if (mUsingFrontCamera) {
    orientation=(mDeviceOrientationAtCapture - mCameraOrientation - mPanoAngle + 360) % 360;
  }
 else {
    orientation=(mDeviceOrientationAtCapture + mCameraOrientation - mPanoAngle) % 360;
  }
  return orientation;
}","The original code incorrectly handled camera orientation, especially for front-facing cameras, by not properly accounting for all rotation scenarios and potentially introducing incorrect orientation calculations. The fixed code introduces subtraction of `mPanoAngle` and simplifies the orientation calculation logic, ensuring consistent and accurate orientation determination across different camera types and device positions. By streamlining the orientation computation and removing unnecessary conditional logic, the new implementation provides a more robust and precise method for calculating capture orientation."
38305,"@Override protected Bitmap doInBackground(Void... params){
  Bitmap bitmap=CameraUtil.downSample(mData,DOWN_SAMPLE_FACTOR);
  if (mOrientation != 0 || mMirror) {
    Matrix m=new Matrix();
    m.preRotate(mOrientation);
    if (mMirror) {
      m.setScale(-1f,1f);
    }
    return Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),m,false);
  }
  return bitmap;
}","@Override protected Bitmap doInBackground(Void... params){
  Bitmap bitmap=CameraUtil.downSample(mData,DOWN_SAMPLE_FACTOR);
  if (mOrientation != 0 || mMirror) {
    Matrix m=new Matrix();
    if (mMirror) {
      m.setScale(-1f,1f);
    }
    m.preRotate(mOrientation);
    return Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),m,false);
  }
  return bitmap;
}","The original code incorrectly applied matrix transformations by rotating first and then attempting to mirror, which could lead to unexpected image orientation. In the fixed code, the mirror transformation is applied before rotation, ensuring the correct sequence of transformations that preserves the intended image manipulation. This change guarantees that mirroring and rotation are applied in the right order, resulting in a more accurate and predictable bitmap transformation."
38306,"/** 
 * Used to update the flash mode. Video mode can turn on the flash as torch mode, which we would like to turn on and off when we switching in and out to the preview.
 * @param forceOff whether we want to force the flash off.
 */
private void forceFlashOff(boolean forceOff){
  if (!mPreviewing || mParameters.getFlashMode() == null) {
    return;
  }
  forceFlashOffIfSupported(forceOff);
  mCameraDevice.setParameters(mParameters);
}","/** 
 * Used to update the flash mode. Video mode can turn on the flash as torch mode, which we would like to turn on and off when we switching in and out to the preview.
 * @param forceOff whether we want to force the flash off.
 */
private void forceFlashOff(boolean forceOff){
  if (!mPreviewing || mParameters.getFlashMode() == null) {
    return;
  }
  forceFlashOffIfSupported(forceOff);
  mCameraDevice.setParameters(mParameters);
  mUI.updateOnScreenIndicators(mParameters,mPreferences);
}","The original code lacked a crucial UI update after changing camera parameters, potentially leaving the on-screen indicators out of sync with the actual flash state. The fixed code adds a call to `mUI.updateOnScreenIndicators(mParameters,mPreferences)` to ensure the user interface reflects the current camera settings accurately. This enhancement provides immediate visual feedback to the user about the flash mode change, improving the overall user experience and interface responsiveness."
38307,"public boolean isVisible(){
  return mTextureView.getVisibility() == View.VISIBLE;
}","public boolean isVisible(){
  return mCameraControls.getVisibility() == View.VISIBLE;
}","The original code incorrectly checks the visibility of `mTextureView` instead of the intended camera controls view. The fixed code replaces `mTextureView` with `mCameraControls`, ensuring that the method accurately reports the visibility of the camera control interface. This correction provides the correct visibility status, preventing potential UI inconsistencies and improving the reliability of visibility checks in the camera-related user interface."
38308,"/** 
 * Used to update the flash mode. Video mode can turn on the flash as torch mode, which we would like to turn on and off when we switching in and out to the preview.
 * @param forceOff whether we want to force the flash off.
 */
private void forceFlashOff(boolean forceOff){
  if (!mPreviewing || mParameters.getFlashMode() == null) {
    return;
  }
  forceFlashOffIfSupported(forceOff);
  mCameraDevice.setParameters(mParameters);
}","/** 
 * Used to update the flash mode. Video mode can turn on the flash as torch mode, which we would like to turn on and off when we switching in and out to the preview.
 * @param forceOff whether we want to force the flash off.
 */
private void forceFlashOff(boolean forceOff){
  if (!mPreviewing || mParameters.getFlashMode() == null) {
    return;
  }
  forceFlashOffIfSupported(forceOff);
  mCameraDevice.setParameters(mParameters);
  mUI.updateOnScreenIndicators(mParameters,mPreferences);
}","The original code lacked a crucial UI update after modifying camera parameters, potentially leaving the on-screen indicators out of sync with the actual flash mode. The fixed code adds a call to `mUI.updateOnScreenIndicators(mParameters,mPreferences)` to synchronize the user interface with the current camera settings. This ensures that the visual representation of the flash mode accurately reflects the underlying camera configuration, providing a more consistent and user-friendly experience."
38309,"public boolean isVisible(){
  return mTextureView.getVisibility() == View.VISIBLE;
}","public boolean isVisible(){
  return mCameraControls.getVisibility() == View.VISIBLE;
}","The original code incorrectly checks the visibility of `mTextureView`, which may not represent the actual visibility state of the camera controls. The fixed code switches to checking `mCameraControls.getVisibility()`, ensuring the method returns the correct visibility status of the camera control UI element. This change provides a more accurate representation of the camera controls' visibility, preventing potential UI inconsistencies or misleading visibility checks."
38310,"/** 
 * Used to update the flash mode. Video mode can turn on the flash as torch mode, which we would like to turn on and off when we switching in and out to the preview.
 * @param forceOff whether we want to force the flash off.
 */
private void forceFlashOff(boolean forceOff){
  if (!mPreviewing || mParameters.getFlashMode() == null) {
    return;
  }
  forceFlashOffIfSupported(forceOff);
  mCameraDevice.setParameters(mParameters);
}","/** 
 * Used to update the flash mode. Video mode can turn on the flash as torch mode, which we would like to turn on and off when we switching in and out to the preview.
 * @param forceOff whether we want to force the flash off.
 */
private void forceFlashOff(boolean forceOff){
  if (!mPreviewing || mParameters.getFlashMode() == null) {
    return;
  }
  forceFlashOffIfSupported(forceOff);
  mCameraDevice.setParameters(mParameters);
  mUI.updateOnScreenIndicators(mParameters,mPreferences);
}","The original code lacked a critical UI update after modifying camera parameters, potentially leaving the on-screen indicators out of sync with the actual flash state. The fixed code adds a call to `mUI.updateOnScreenIndicators(mParameters,mPreferences)` to synchronize the user interface with the current camera settings. This ensures that the visual representation accurately reflects the flash mode changes, providing a more consistent and user-friendly experience."
38311,"public boolean isVisible(){
  return mTextureView.getVisibility() == View.VISIBLE;
}","public boolean isVisible(){
  return mCameraControls.getVisibility() == View.VISIBLE;
}","The original code incorrectly checks the visibility of `mTextureView` instead of the intended camera controls view. The fixed code replaces `mTextureView` with `mCameraControls`, ensuring that the visibility check targets the correct UI component responsible for camera control interactions. This modification provides accurate visibility status for the camera controls, preventing potential UI-related bugs and improving the method's reliability."
38312,"@Override @OnClickAttr public void onReviewCancelClicked(View v){
  mIsInReviewMode=false;
  if (mCurrentVideoUri != null) {
    mContentResolver.delete(mCurrentVideoUri,null,null);
  }
  doReturnToCaller(false);
}","@Override @OnClickAttr public void onReviewCancelClicked(View v){
  if (mIsInReviewMode && mCurrentVideoUri != null) {
    mContentResolver.delete(mCurrentVideoUri,null,null);
  }
  mIsInReviewMode=false;
  doReturnToCaller(false);
}","The original code deletes the video URI before checking if the app is in review mode, potentially causing unintended deletion of content. The fixed code first checks both `mIsInReviewMode` and `mCurrentVideoUri` before performing the deletion, ensuring that deletion occurs only under the correct conditions. This modification prevents premature or unnecessary content removal and provides a more robust and controlled deletion process."
38313,"@Override @OnClickAttr public void onReviewCancelClicked(View v){
  mIsInReviewMode=false;
  if (mCurrentVideoUri != null) {
    mContentResolver.delete(mCurrentVideoUri,null,null);
  }
  doReturnToCaller(false);
}","@Override @OnClickAttr public void onReviewCancelClicked(View v){
  if (mIsInReviewMode && mCurrentVideoUri != null) {
    mContentResolver.delete(mCurrentVideoUri,null,null);
  }
  mIsInReviewMode=false;
  doReturnToCaller(false);
}","The original code could delete a video URI even when not in review mode, potentially causing unintended data loss. The fixed code adds a conditional check `mIsInReviewMode && mCurrentVideoUri != null` before deletion, ensuring deletion only occurs when actually reviewing a video and a valid URI exists. This prevents unnecessary or accidental deletions, improving the method's robustness and data integrity."
38314,"@Override @OnClickAttr public void onReviewCancelClicked(View v){
  mIsInReviewMode=false;
  if (mCurrentVideoUri != null) {
    mContentResolver.delete(mCurrentVideoUri,null,null);
  }
  doReturnToCaller(false);
}","@Override @OnClickAttr public void onReviewCancelClicked(View v){
  if (mIsInReviewMode && mCurrentVideoUri != null) {
    mContentResolver.delete(mCurrentVideoUri,null,null);
  }
  mIsInReviewMode=false;
  doReturnToCaller(false);
}","The original code could delete the video URI even when not in review mode, potentially causing unintended data loss. The fixed code adds a condition to check both `mIsInReviewMode` and `mCurrentVideoUri` before deletion, ensuring that deletion only occurs when appropriate. This change prevents accidental deletion and adds a layer of safety to the video review process."
38315,"@Override public Result doInBackground(Request message){
  RenderingRequest request=((Render)message).request;
  RenderResult result=null;
  mHighresPreviewPipeline.render(request);
  result=new RenderResult();
  result.request=request;
  return result;
}","@Override public Result doInBackground(Request message){
  RenderingRequest request=((Render)message).request;
  RenderResult result=null;
  mHighresPreviewPipeline.renderHighres(request);
  result=new RenderResult();
  result.request=request;
  return result;
}","The original code uses `mHighresPreviewPipeline.render()`, which likely lacks the specific high-resolution rendering functionality needed. The fixed code replaces this with `mHighresPreviewPipeline.renderHighres()`, which explicitly targets high-resolution preview rendering. This change ensures the correct rendering method is called, improving the pipeline's precision and output quality for high-resolution preview generation."
38316,"@Override protected void onPostExecute(Boolean result){
  MasterImage.setMaster(mMasterImage);
  if (isCancelled()) {
    return;
  }
  if (!result) {
    cannotLoadImage();
  }
  if (null == CachingPipeline.getRenderScriptContext()) {
    Log.v(LOGTAG,""String_Node_Str"");
    return;
  }
  final View loading=findViewById(R.id.loading);
  loading.setVisibility(View.GONE);
  final View imageShow=findViewById(R.id.imageShow);
  imageShow.setVisibility(View.VISIBLE);
  Bitmap largeBitmap=MasterImage.getImage().getOriginalBitmapLarge();
  mBoundService.setOriginalBitmap(largeBitmap);
  float previewScale=(float)largeBitmap.getWidth() / (float)MasterImage.getImage().getOriginalBounds().width();
  mBoundService.setPreviewScaleFactor(previewScale);
  if (!mShowingTinyPlanet) {
    mCategoryFiltersAdapter.removeTinyPlanet();
  }
  MasterImage.getImage().setOriginalGeometry(largeBitmap);
  mCategoryLooksAdapter.imageLoaded();
  mCategoryBordersAdapter.imageLoaded();
  mCategoryGeometryAdapter.imageLoaded();
  mCategoryFiltersAdapter.imageLoaded();
  mLoadBitmapTask=null;
  if (mOriginalPreset != null) {
    MasterImage.getImage().setLoadedPreset(mOriginalPreset);
    MasterImage.getImage().setPreset(mOriginalPreset,mOriginalPreset.getLastRepresentation(),true);
    mOriginalPreset=null;
  }
  if (mAction == TINY_PLANET_ACTION) {
    showRepresentation(mCategoryFiltersAdapter.getTinyPlanet());
  }
  mLoading=false;
  MasterImage.getImage().notifyGeometryChange();
  LoadHighresBitmapTask highresLoad=new LoadHighresBitmapTask();
  highresLoad.execute();
  super.onPostExecute(result);
}","@Override protected void onPostExecute(Boolean result){
  MasterImage.setMaster(mMasterImage);
  if (isCancelled()) {
    return;
  }
  if (!result) {
    cannotLoadImage();
  }
  if (null == CachingPipeline.getRenderScriptContext()) {
    Log.v(LOGTAG,""String_Node_Str"");
    return;
  }
  final View loading=findViewById(R.id.loading);
  loading.setVisibility(View.GONE);
  final View imageShow=findViewById(R.id.imageShow);
  imageShow.setVisibility(View.VISIBLE);
  Bitmap largeBitmap=MasterImage.getImage().getOriginalBitmapLarge();
  mBoundService.setOriginalBitmap(largeBitmap);
  float previewScale=(float)largeBitmap.getWidth() / (float)MasterImage.getImage().getOriginalBounds().width();
  mBoundService.setPreviewScaleFactor(previewScale);
  if (!mShowingTinyPlanet) {
    mCategoryFiltersAdapter.removeTinyPlanet();
  }
  MasterImage.getImage().setOriginalGeometry(largeBitmap);
  mCategoryLooksAdapter.imageLoaded();
  mCategoryBordersAdapter.imageLoaded();
  mCategoryGeometryAdapter.imageLoaded();
  mCategoryFiltersAdapter.imageLoaded();
  mLoadBitmapTask=null;
  if (mOriginalPreset != null) {
    MasterImage.getImage().setLoadedPreset(mOriginalPreset);
    MasterImage.getImage().setPreset(mOriginalPreset,mOriginalPreset.getLastRepresentation(),true);
    mOriginalPreset=null;
  }
  if (mAction == TINY_PLANET_ACTION) {
    showRepresentation(mCategoryFiltersAdapter.getTinyPlanet());
  }
  MasterImage.getImage().notifyGeometryChange();
  LoadHighresBitmapTask highresLoad=new LoadHighresBitmapTask();
  highresLoad.execute();
  super.onPostExecute(result);
}","The original code had an unnecessary `mLoading=false` assignment that did not serve a clear purpose and could potentially lead to state management issues. The fixed code removes this line, eliminating the redundant variable modification while maintaining the core logic of loading and processing an image. By simplifying the code, the fixed version improves readability and reduces potential sources of unexpected behavior in the image loading workflow."
38317,"private void startLoadBitmap(Uri uri){
  mLoading=true;
  final View loading=findViewById(R.id.loading);
  final View imageShow=findViewById(R.id.imageShow);
  imageShow.setVisibility(View.INVISIBLE);
  loading.setVisibility(View.VISIBLE);
  mShowingTinyPlanet=false;
  mLoadBitmapTask=new LoadBitmapTask();
  mLoadBitmapTask.execute(uri);
}","private void startLoadBitmap(Uri uri){
  final View loading=findViewById(R.id.loading);
  final View imageShow=findViewById(R.id.imageShow);
  imageShow.setVisibility(View.INVISIBLE);
  loading.setVisibility(View.VISIBLE);
  mShowingTinyPlanet=false;
  mLoadBitmapTask=new LoadBitmapTask();
  mLoadBitmapTask.execute(uri);
}","The buggy code introduces a potential race condition by setting `mLoading=true` before executing an asynchronous task, which could lead to inconsistent loading state tracking. The fixed code removes the unnecessary `mLoading` flag, simplifying the method and eliminating the potential synchronization issue. By focusing on essential UI state management and task execution, the revised code provides a cleaner and more reliable bitmap loading approach."
38318,"public Bitmap process(Bitmap originalBitmap,Vector<FilterRepresentation> filters,FilterEnvironment environment){
  Bitmap cacheBitmap=originalBitmap;
  if (filters.size() != mSteps.size()) {
    mSteps.clear();
    for (int i=0; i < filters.size(); i++) {
      FilterRepresentation representation=filters.elementAt(i);
      CacheStep step=new CacheStep();
      step.representation=representation.copy();
      mSteps.add(step);
    }
  }
  if (DEBUG) {
    displayFilters(filters);
  }
  int similarUpToIndex=0;
  for (int i=0; i < filters.size(); i++) {
    FilterRepresentation representation=filters.elementAt(i);
    CacheStep step=mSteps.elementAt(i);
    boolean similar=step.representation.equals(representation);
    if (similar) {
      similarUpToIndex=i;
    }
 else {
      break;
    }
  }
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + similarUpToIndex);
  }
  int findBaseImageIndex=similarUpToIndex;
  while (findBaseImageIndex > 0 && mSteps.elementAt(findBaseImageIndex).cache == null) {
    findBaseImageIndex--;
  }
  cacheBitmap=mSteps.elementAt(findBaseImageIndex).cache;
  boolean emptyStack=false;
  if (cacheBitmap == null) {
    emptyStack=true;
    cacheBitmap=originalBitmap.copy(Bitmap.Config.ARGB_8888,true);
    if (DEBUG) {
      Log.v(LOGTAG,""String_Node_Str"");
    }
  }
  if (findBaseImageIndex != similarUpToIndex) {
    if (DEBUG) {
      Log.v(LOGTAG,""String_Node_Str"" + findBaseImageIndex + ""String_Node_Str""+ similarUpToIndex);
    }
    if (!emptyStack) {
      cacheBitmap=cacheBitmap.copy(Bitmap.Config.ARGB_8888,true);
    }
    for (int i=findBaseImageIndex; i <= similarUpToIndex; i++) {
      FilterRepresentation representation=filters.elementAt(i);
      cacheBitmap=environment.applyRepresentation(representation,cacheBitmap);
      if (DEBUG) {
        Log.v(LOGTAG,""String_Node_Str"" + i + ""String_Node_Str""+ representation.getName());
      }
    }
    mSteps.elementAt(similarUpToIndex).cache=cacheBitmap;
  }
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + similarUpToIndex + ""String_Node_Str""+ (filters.size() - 1));
  }
  for (int i=similarUpToIndex + 1; i < filters.size(); i++) {
    FilterRepresentation representation=filters.elementAt(i);
    CacheStep currentStep=mSteps.elementAt(i);
    cacheBitmap=cacheBitmap.copy(Bitmap.Config.ARGB_8888,true);
    cacheBitmap=environment.applyRepresentation(representation,cacheBitmap);
    currentStep.representation=representation.copy();
    currentStep.cache=cacheBitmap;
    if (DEBUG) {
      Log.v(LOGTAG,""String_Node_Str"" + i + ""String_Node_Str""+ representation.getName());
    }
  }
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"");
    displayNbBitmapsInCache();
  }
  for (int i=0; i < similarUpToIndex; i++) {
    CacheStep currentStep=mSteps.elementAt(i);
    currentStep.cache=null;
  }
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"");
    displayNbBitmapsInCache();
  }
  return cacheBitmap;
}","public Bitmap process(Bitmap originalBitmap,Vector<FilterRepresentation> filters,FilterEnvironment environment){
  if (filters.size() == 0) {
    return originalBitmap;
  }
  if (filters.size() != mSteps.size()) {
    mSteps.clear();
    for (int i=0; i < filters.size(); i++) {
      FilterRepresentation representation=filters.elementAt(i);
      CacheStep step=new CacheStep();
      step.representation=representation.copy();
      mSteps.add(step);
    }
  }
  if (DEBUG) {
    displayFilters(filters);
  }
  int similarUpToIndex=-1;
  for (int i=0; i < filters.size(); i++) {
    FilterRepresentation representation=filters.elementAt(i);
    CacheStep step=mSteps.elementAt(i);
    boolean similar=step.representation.equals(representation);
    if (similar) {
      similarUpToIndex=i;
    }
 else {
      break;
    }
  }
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + similarUpToIndex);
  }
  Bitmap cacheBitmap=null;
  int findBaseImageIndex=similarUpToIndex;
  if (findBaseImageIndex > -1) {
    while (findBaseImageIndex > 0 && mSteps.elementAt(findBaseImageIndex).cache == null) {
      findBaseImageIndex--;
    }
    cacheBitmap=mSteps.elementAt(findBaseImageIndex).cache;
  }
  boolean emptyStack=false;
  if (cacheBitmap == null) {
    emptyStack=true;
    cacheBitmap=originalBitmap.copy(Bitmap.Config.ARGB_8888,true);
    if (findBaseImageIndex > -1) {
      FilterRepresentation representation=filters.elementAt(findBaseImageIndex);
      cacheBitmap=environment.applyRepresentation(representation,cacheBitmap);
      mSteps.elementAt(findBaseImageIndex).representation=representation.copy();
      mSteps.elementAt(findBaseImageIndex).cache=cacheBitmap;
    }
    if (DEBUG) {
      Log.v(LOGTAG,""String_Node_Str"");
    }
  }
  if (findBaseImageIndex != similarUpToIndex) {
    if (DEBUG) {
      Log.v(LOGTAG,""String_Node_Str"" + findBaseImageIndex + ""String_Node_Str""+ similarUpToIndex);
    }
    if (!emptyStack) {
      cacheBitmap=cacheBitmap.copy(Bitmap.Config.ARGB_8888,true);
    }
 else {
      findBaseImageIndex++;
    }
    for (int i=findBaseImageIndex; i <= similarUpToIndex; i++) {
      FilterRepresentation representation=filters.elementAt(i);
      cacheBitmap=environment.applyRepresentation(representation,cacheBitmap);
      if (DEBUG) {
        Log.v(LOGTAG,""String_Node_Str"" + i + ""String_Node_Str""+ representation.getName());
      }
    }
    mSteps.elementAt(similarUpToIndex).cache=cacheBitmap;
  }
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + similarUpToIndex + ""String_Node_Str""+ (filters.size() - 1));
  }
  for (int i=similarUpToIndex + 1; i < filters.size(); i++) {
    FilterRepresentation representation=filters.elementAt(i);
    CacheStep currentStep=mSteps.elementAt(i);
    cacheBitmap=cacheBitmap.copy(Bitmap.Config.ARGB_8888,true);
    cacheBitmap=environment.applyRepresentation(representation,cacheBitmap);
    currentStep.representation=representation.copy();
    currentStep.cache=cacheBitmap;
    if (DEBUG) {
      Log.v(LOGTAG,""String_Node_Str"" + i + ""String_Node_Str""+ representation.getName());
    }
  }
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"");
    displayNbBitmapsInCache();
  }
  for (int i=0; i < similarUpToIndex; i++) {
    CacheStep currentStep=mSteps.elementAt(i);
    currentStep.cache=null;
  }
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"");
    displayNbBitmapsInCache();
  }
  return cacheBitmap;
}","The original code had potential null pointer and indexing issues when processing bitmap filters, particularly when handling empty or partially processed filter stacks. The fixed code adds robust null checks, initializes variables more carefully, and handles edge cases like empty filter lists by adding an early return and adjusting index tracking. These changes ensure more reliable bitmap processing with improved error handling and more predictable behavior across different filter scenarios."
38319,"private Uri resetToOriginalImageIfNeeded(ImagePreset preset){
  Uri uri=null;
  if (!preset.hasModifications()) {
    File srcFile=getLocalFileFromUri(mContext,mSourceUri);
    if (srcFile != null) {
      srcFile.renameTo(mDestinationFile);
      uri=SaveImage.updateUriContent(mContext,mSelectedImageUri,mDestinationFile,System.currentTimeMillis());
    }
  }
  return uri;
}","private Uri resetToOriginalImageIfNeeded(ImagePreset preset){
  Uri uri=null;
  if (!preset.hasModifications()) {
    File srcFile=getLocalFileFromUri(mContext,mSourceUri);
    if (srcFile != null) {
      srcFile.renameTo(mDestinationFile);
      uri=SaveImage.linkNewFileToUri(mContext,mSelectedImageUri,mDestinationFile,System.currentTimeMillis());
    }
  }
  return uri;
}","The original code used `updateUriContent()`, which might not properly link the renamed file to the existing URI, potentially causing file tracking issues. The fixed code replaces this with `linkNewFileToUri()`, which ensures a more robust and reliable method of associating the renamed file with its original URI. This change guarantees proper file reference management and prevents potential data inconsistencies when resetting an image to its original state."
38320,"public static Uri makeAndInsertUri(Context context,Uri sourceUri){
  long time=System.currentTimeMillis();
  String filename=new SimpleDateFormat(TIME_STAMP_NAME).format(new Date(time));
  File saveDirectory=getFinalSaveDirectory(context,sourceUri);
  File file=new File(saveDirectory,filename + ""String_Node_Str"");
  return updateUriContent(context,sourceUri,file,time);
}","public static Uri makeAndInsertUri(Context context,Uri sourceUri){
  long time=System.currentTimeMillis();
  String filename=new SimpleDateFormat(TIME_STAMP_NAME).format(new Date(time));
  File saveDirectory=getFinalSaveDirectory(context,sourceUri);
  File file=new File(saveDirectory,filename + ""String_Node_Str"");
  return linkNewFileToUri(context,sourceUri,file,time);
}","The original code incorrectly called `updateUriContent()`, which likely does not exist or handle file linking properly. The fixed code replaces this with `linkNewFileToUri()`, a more appropriate method for associating a new file with the source URI. This change ensures correct URI management and file linking, preventing potential null pointer exceptions or improper file reference handling."
38321,"public Uri processAndSaveImage(ImagePreset preset){
  Uri uri=resetToOriginalImageIfNeeded(preset);
  if (uri != null) {
    return null;
  }
  resetProgress();
  boolean noBitmap=true;
  int num_tries=0;
  int sampleSize=1;
  Uri newSourceUri=moveSrcToAuxIfNeeded(mSourceUri,mDestinationFile);
  while (noBitmap) {
    try {
      updateProgress();
      Bitmap bitmap=ImageLoader.loadOrientedBitmapWithBackouts(mContext,newSourceUri,sampleSize);
      if (bitmap == null) {
        return null;
      }
      updateProgress();
      CachingPipeline pipeline=new CachingPipeline(FiltersManager.getManager(),""String_Node_Str"");
      bitmap=pipeline.renderFinalImage(bitmap,preset);
      updateProgress();
      Object xmp=getPanoramaXMPData(newSourceUri,preset);
      ExifInterface exif=getExifData(newSourceUri);
      updateProgress();
      long time=System.currentTimeMillis();
      exif.addDateTimeStampTag(ExifInterface.TAG_DATE_TIME,time,TimeZone.getDefault());
      exif.setTag(exif.buildTag(ExifInterface.TAG_ORIENTATION,ExifInterface.Orientation.TOP_LEFT));
      exif.removeCompressedThumbnail();
      updateProgress();
      if (putExifData(mDestinationFile,exif,bitmap)) {
        putPanoramaXMPData(mDestinationFile,xmp);
        XmpPresets.writeFilterXMP(mContext,newSourceUri,mDestinationFile,preset);
        uri=SaveImage.updateUriContent(mContext,mSelectedImageUri,mDestinationFile,time);
      }
      updateProgress();
      noBitmap=false;
      UsageStatistics.onEvent(UsageStatistics.COMPONENT_EDITOR,""String_Node_Str"",null);
    }
 catch (    OutOfMemoryError e) {
      if (++num_tries >= 5) {
        throw e;
      }
      System.gc();
      sampleSize*=2;
      resetProgress();
    }
  }
  return uri;
}","public Uri processAndSaveImage(ImagePreset preset){
  Uri uri=resetToOriginalImageIfNeeded(preset);
  if (uri != null) {
    return null;
  }
  resetProgress();
  boolean noBitmap=true;
  int num_tries=0;
  int sampleSize=1;
  Uri newSourceUri=moveSrcToAuxIfNeeded(mSourceUri,mDestinationFile);
  while (noBitmap) {
    try {
      updateProgress();
      Bitmap bitmap=ImageLoader.loadOrientedBitmapWithBackouts(mContext,newSourceUri,sampleSize);
      if (bitmap == null) {
        return null;
      }
      updateProgress();
      CachingPipeline pipeline=new CachingPipeline(FiltersManager.getManager(),""String_Node_Str"");
      bitmap=pipeline.renderFinalImage(bitmap,preset);
      updateProgress();
      Object xmp=getPanoramaXMPData(newSourceUri,preset);
      ExifInterface exif=getExifData(newSourceUri);
      updateProgress();
      long time=System.currentTimeMillis();
      exif.addDateTimeStampTag(ExifInterface.TAG_DATE_TIME,time,TimeZone.getDefault());
      exif.setTag(exif.buildTag(ExifInterface.TAG_ORIENTATION,ExifInterface.Orientation.TOP_LEFT));
      exif.removeCompressedThumbnail();
      updateProgress();
      if (putExifData(mDestinationFile,exif,bitmap)) {
        putPanoramaXMPData(mDestinationFile,xmp);
        XmpPresets.writeFilterXMP(mContext,newSourceUri,mDestinationFile,preset);
        uri=SaveImage.linkNewFileToUri(mContext,mSelectedImageUri,mDestinationFile,time);
      }
      updateProgress();
      noBitmap=false;
      UsageStatistics.onEvent(UsageStatistics.COMPONENT_EDITOR,""String_Node_Str"",null);
    }
 catch (    OutOfMemoryError e) {
      if (++num_tries >= 5) {
        throw e;
      }
      System.gc();
      sampleSize*=2;
      resetProgress();
    }
  }
  return uri;
}","The original code used `updateUriContent()`, which might not properly link the new file to the existing URI, potentially causing file tracking issues. The fixed code replaces this with `linkNewFileToUri()`, which ensures a more reliable and consistent method of associating the modified image with its original URI. This change improves file management by creating a more robust link between the original and processed image, preventing potential data inconsistencies and improving overall image editing workflow."
38322,"public void enableSave(boolean enable){
  if (mSaveButton != null)   mSaveButton.setEnabled(enable);
}","public void enableSave(boolean enable){
  if (mSaveButton != null) {
    mSaveButton.setEnabled(enable);
  }
}","The original code lacks proper code formatting, making it harder to read and potentially leading to misunderstandings or accidental modifications. The fixed code adds braces around the single-line conditional block, improving code readability and explicitly defining the scope of the conditional statement. This enhancement makes the code more maintainable and reduces the risk of unintended logic errors when future modifications are made."
38323,"public void onNewValue(int parameter){
  invalidate();
  mActivity.enableSave(hasModifications());
}","public void onNewValue(int parameter){
  invalidate();
}","The original code incorrectly calls `mActivity.enableSave()` within the method, potentially causing unnecessary UI state changes or potential null pointer exceptions. The fixed code removes the direct activity method call, ensuring that UI state management is handled more appropriately at a different layer of the application. By eliminating the premature save enablement, the code now maintains better separation of concerns and reduces the risk of unintended side effects during value updates."
38324,"@Override public void available(RenderingRequest request){
  if (request.getBitmap() == null) {
    return;
  }
  if (request.getType() == RenderingRequest.GEOMETRY_RENDERING) {
    mGeometryOnlyBitmap=request.getBitmap();
  }
  if (request.getType() == RenderingRequest.FILTERS_RENDERING) {
    mFiltersOnlyBitmap=request.getBitmap();
  }
  if (request.getType() == RenderingRequest.PARTIAL_RENDERING && request.getScaleFactor() == getScaleFactor()) {
    mPartialBitmap=request.getBitmap();
    notifyObservers();
  }
  if (request.getType() == RenderingRequest.HIGHRES_RENDERING) {
    mHighresBitmap=request.getBitmap();
    notifyObservers();
  }
}","@Override public void available(RenderingRequest request){
  if (request.getBitmap() == null) {
    return;
  }
  boolean needsCheckModification=false;
  if (request.getType() == RenderingRequest.GEOMETRY_RENDERING) {
    mGeometryOnlyBitmap=request.getBitmap();
    needsCheckModification=true;
  }
  if (request.getType() == RenderingRequest.FILTERS_RENDERING) {
    mFiltersOnlyBitmap=request.getBitmap();
    needsCheckModification=true;
  }
  if (request.getType() == RenderingRequest.PARTIAL_RENDERING && request.getScaleFactor() == getScaleFactor()) {
    mPartialBitmap=request.getBitmap();
    notifyObservers();
    needsCheckModification=true;
  }
  if (request.getType() == RenderingRequest.HIGHRES_RENDERING) {
    mHighresBitmap=request.getBitmap();
    notifyObservers();
    needsCheckModification=true;
  }
  if (needsCheckModification) {
    mActivity.enableSave(hasModifications());
  }
}","The original code did not update the save button state after bitmap modifications, potentially leaving the UI in an inconsistent state. The fixed code introduces a `needsCheckModification` flag to track when bitmaps are updated, and calls `mActivity.enableSave(hasModifications())` when modifications occur. This ensures the save button accurately reflects the current editing state, improving user experience by providing immediate visual feedback on unsaved changes."
38325,"public void updatePresets(boolean force){
  if (force || mGeometryOnlyPreset == null) {
    ImagePreset newPreset=new ImagePreset(mPreset);
    newPreset.setDoApplyFilters(false);
    newPreset.setDoApplyGeometry(true);
    if (force || mGeometryOnlyPreset == null || !newPreset.same(mGeometryOnlyPreset)) {
      mGeometryOnlyPreset=newPreset;
      RenderingRequest.post(mLoader.getOriginalBitmapLarge(),mGeometryOnlyPreset,RenderingRequest.GEOMETRY_RENDERING,this);
    }
  }
  if (force || mFiltersOnlyPreset == null) {
    ImagePreset newPreset=new ImagePreset(mPreset);
    newPreset.setDoApplyFilters(true);
    newPreset.setDoApplyGeometry(false);
    if (force || mFiltersOnlyPreset == null || !newPreset.same(mFiltersOnlyPreset)) {
      mFiltersOnlyPreset=newPreset;
      RenderingRequest.post(mLoader.getOriginalBitmapLarge(),mFiltersOnlyPreset,RenderingRequest.FILTERS_RENDERING,this);
    }
  }
  invalidatePreview();
  mActivity.enableSave(hasModifications());
}","public void updatePresets(boolean force){
  if (force || mGeometryOnlyPreset == null) {
    ImagePreset newPreset=new ImagePreset(mPreset);
    newPreset.setDoApplyFilters(false);
    newPreset.setDoApplyGeometry(true);
    if (force || mGeometryOnlyPreset == null || !newPreset.same(mGeometryOnlyPreset)) {
      mGeometryOnlyPreset=newPreset;
      RenderingRequest.post(mLoader.getOriginalBitmapLarge(),mGeometryOnlyPreset,RenderingRequest.GEOMETRY_RENDERING,this);
    }
  }
  if (force || mFiltersOnlyPreset == null) {
    ImagePreset newPreset=new ImagePreset(mPreset);
    newPreset.setDoApplyFilters(true);
    newPreset.setDoApplyGeometry(false);
    if (force || mFiltersOnlyPreset == null || !newPreset.same(mFiltersOnlyPreset)) {
      mFiltersOnlyPreset=newPreset;
      RenderingRequest.post(mLoader.getOriginalBitmapLarge(),mFiltersOnlyPreset,RenderingRequest.FILTERS_RENDERING,this);
    }
  }
  invalidatePreview();
}","The original code incorrectly calls `mActivity.enableSave(hasModifications())` after rendering requests, which could prematurely enable saving before rendering completes. The fixed code removes this line, preventing potential race conditions and ensuring save state is managed more appropriately by the rendering process. By eliminating the unnecessary method call, the code now maintains better control over the UI state and prevents potential synchronization issues during image editing."
38326,"public synchronized boolean hasModifications(){
  if (mPreset == null) {
    return getLoadedPreset() != null;
  }
 else {
    return !mPreset.same(getLoadedPreset());
  }
}","public synchronized boolean hasModifications(){
  ImagePreset loadedPreset=getLoadedPreset();
  if (mPreset == null) {
    if (loadedPreset == null) {
      return false;
    }
 else {
      return loadedPreset.hasModifications();
    }
  }
 else {
    if (loadedPreset == null) {
      return mPreset.hasModifications();
    }
 else {
      return !mPreset.equals(getLoadedPreset());
    }
  }
}","The original code had potential null pointer risks and oversimplified comparison logic, potentially missing nuanced modification checks. The fixed code introduces explicit null checks for both mPreset and loadedPreset, uses a more robust equals method instead of same(), and handles multiple scenarios like unloaded presets with proper modification detection. This approach provides comprehensive, safe modification tracking by systematically evaluating preset states and preventing potential runtime exceptions."
38327,"public void enableSave(boolean enable){
  if (mSaveButton != null)   mSaveButton.setEnabled(enable);
}","public void enableSave(boolean enable){
  if (mSaveButton != null) {
    mSaveButton.setEnabled(enable);
  }
}","The original code lacks proper code formatting, which can lead to potential readability and maintainability issues when additional logic is needed inside the conditional block. The fixed code adds curly braces to explicitly define the scope of the conditional block, making the code more structured and easier to extend with future statements. This improvement enhances code clarity and reduces the risk of unintended behavior when modifying the method in the future."
38328,"public void onNewValue(int parameter){
  invalidate();
  mActivity.enableSave(hasModifications());
}","public void onNewValue(int parameter){
  invalidate();
}","The original code incorrectly calls `mActivity.enableSave()` within the `onNewValue()` method, potentially causing tight coupling and unnecessary method invocation. The fixed code removes the direct activity method call, eliminating the dependency and simplifying the method's responsibility. By removing the extraneous method call, the code becomes more modular, reduces potential side effects, and maintains better separation of concerns."
38329,"@Override public void available(RenderingRequest request){
  if (request.getBitmap() == null) {
    return;
  }
  if (request.getType() == RenderingRequest.GEOMETRY_RENDERING) {
    mGeometryOnlyBitmap=request.getBitmap();
  }
  if (request.getType() == RenderingRequest.FILTERS_RENDERING) {
    mFiltersOnlyBitmap=request.getBitmap();
  }
  if (request.getType() == RenderingRequest.PARTIAL_RENDERING && request.getScaleFactor() == getScaleFactor()) {
    mPartialBitmap=request.getBitmap();
    notifyObservers();
  }
  if (request.getType() == RenderingRequest.HIGHRES_RENDERING) {
    mHighresBitmap=request.getBitmap();
    notifyObservers();
  }
}","@Override public void available(RenderingRequest request){
  if (request.getBitmap() == null) {
    return;
  }
  boolean needsCheckModification=false;
  if (request.getType() == RenderingRequest.GEOMETRY_RENDERING) {
    mGeometryOnlyBitmap=request.getBitmap();
    needsCheckModification=true;
  }
  if (request.getType() == RenderingRequest.FILTERS_RENDERING) {
    mFiltersOnlyBitmap=request.getBitmap();
    needsCheckModification=true;
  }
  if (request.getType() == RenderingRequest.PARTIAL_RENDERING && request.getScaleFactor() == getScaleFactor()) {
    mPartialBitmap=request.getBitmap();
    notifyObservers();
    needsCheckModification=true;
  }
  if (request.getType() == RenderingRequest.HIGHRES_RENDERING) {
    mHighresBitmap=request.getBitmap();
    notifyObservers();
    needsCheckModification=true;
  }
  if (needsCheckModification) {
    mActivity.enableSave(hasModifications());
  }
}","The original code lacked a mechanism to enable saving after bitmap modifications, potentially leaving the save functionality unresponsive. The fixed code introduces a `needsCheckModification` flag that tracks when bitmaps are updated, and calls `mActivity.enableSave(hasModifications())` to ensure the save option is correctly activated. This approach provides a more robust and consistent way to manage the save state based on actual rendering changes."
38330,"public void updatePresets(boolean force){
  if (force || mGeometryOnlyPreset == null) {
    ImagePreset newPreset=new ImagePreset(mPreset);
    newPreset.setDoApplyFilters(false);
    newPreset.setDoApplyGeometry(true);
    if (force || mGeometryOnlyPreset == null || !newPreset.same(mGeometryOnlyPreset)) {
      mGeometryOnlyPreset=newPreset;
      RenderingRequest.post(mLoader.getOriginalBitmapLarge(),mGeometryOnlyPreset,RenderingRequest.GEOMETRY_RENDERING,this);
    }
  }
  if (force || mFiltersOnlyPreset == null) {
    ImagePreset newPreset=new ImagePreset(mPreset);
    newPreset.setDoApplyFilters(true);
    newPreset.setDoApplyGeometry(false);
    if (force || mFiltersOnlyPreset == null || !newPreset.same(mFiltersOnlyPreset)) {
      mFiltersOnlyPreset=newPreset;
      RenderingRequest.post(mLoader.getOriginalBitmapLarge(),mFiltersOnlyPreset,RenderingRequest.FILTERS_RENDERING,this);
    }
  }
  invalidatePreview();
  mActivity.enableSave(hasModifications());
}","public void updatePresets(boolean force){
  if (force || mGeometryOnlyPreset == null) {
    ImagePreset newPreset=new ImagePreset(mPreset);
    newPreset.setDoApplyFilters(false);
    newPreset.setDoApplyGeometry(true);
    if (force || mGeometryOnlyPreset == null || !newPreset.same(mGeometryOnlyPreset)) {
      mGeometryOnlyPreset=newPreset;
      RenderingRequest.post(mLoader.getOriginalBitmapLarge(),mGeometryOnlyPreset,RenderingRequest.GEOMETRY_RENDERING,this);
    }
  }
  if (force || mFiltersOnlyPreset == null) {
    ImagePreset newPreset=new ImagePreset(mPreset);
    newPreset.setDoApplyFilters(true);
    newPreset.setDoApplyGeometry(false);
    if (force || mFiltersOnlyPreset == null || !newPreset.same(mFiltersOnlyPreset)) {
      mFiltersOnlyPreset=newPreset;
      RenderingRequest.post(mLoader.getOriginalBitmapLarge(),mFiltersOnlyPreset,RenderingRequest.FILTERS_RENDERING,this);
    }
  }
  invalidatePreview();
}","The original code incorrectly calls `mActivity.enableSave(hasModifications())` after rendering requests, which could prematurely enable saving before rendering completes. In the fixed code, this line is removed, preventing potential race conditions and ensuring save state is managed more appropriately. By eliminating the unnecessary method call, the code now focuses solely on updating presets and rendering, improving overall reliability and preventing potential UI synchronization issues."
38331,"public synchronized boolean hasModifications(){
  if (mPreset == null) {
    return getLoadedPreset() != null;
  }
 else {
    return !mPreset.same(getLoadedPreset());
  }
}","public synchronized boolean hasModifications(){
  ImagePreset loadedPreset=getLoadedPreset();
  if (mPreset == null) {
    if (loadedPreset == null) {
      return false;
    }
 else {
      return loadedPreset.hasModifications();
    }
  }
 else {
    if (loadedPreset == null) {
      return mPreset.hasModifications();
    }
 else {
      return !mPreset.equals(getLoadedPreset());
    }
  }
}","The original code incorrectly assumes that comparing presets with `same()` method is equivalent to detecting modifications, which may lead to incorrect comparison logic. The fixed code introduces explicit null checks for both `mPreset` and `loadedPreset`, uses `hasModifications()` method for individual preset checks, and replaces `same()` with the standard `equals()` method for more robust comparison. These changes ensure accurate modification detection by handling all possible preset state combinations and providing a more reliable comparison mechanism."
38332,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      HistoryAdapter adapter=mMasterImage.getHistory();
      int position=adapter.undo();
      mMasterImage.onHistoryItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=mMasterImage.getHistory();
    int position=adapter.redo();
    mMasterImage.onHistoryItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.resetHistoryButton:
{
  resetHistory();
  return true;
}
case R.id.showImageStateButton:
{
toggleImageStatePanel();
return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      HistoryAdapter adapter=mMasterImage.getHistory();
      int position=adapter.undo();
      mMasterImage.onHistoryItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      backToMain();
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=mMasterImage.getHistory();
    int position=adapter.redo();
    mMasterImage.onHistoryItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.resetHistoryButton:
{
  resetHistory();
  return true;
}
case R.id.showImageStateButton:
{
toggleImageStatePanel();
return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","The original code lacks a proper navigation or view refresh mechanism after performing undo operations, potentially leaving the UI in an inconsistent state. In the fixed code, the `backToMain()` method is added to the undo button case, ensuring proper view navigation and state synchronization after undoing an action. This improvement enhances user experience by providing a clear and consistent interface transition when reverting image modifications."
38333,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      HistoryAdapter adapter=mMasterImage.getHistory();
      int position=adapter.undo();
      mMasterImage.onHistoryItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=mMasterImage.getHistory();
    int position=adapter.redo();
    mMasterImage.onHistoryItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.resetHistoryButton:
{
  resetHistory();
  return true;
}
case R.id.showImageStateButton:
{
toggleImageStatePanel();
return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      HistoryAdapter adapter=mMasterImage.getHistory();
      int position=adapter.undo();
      mMasterImage.onHistoryItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      backToMain();
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=mMasterImage.getHistory();
    int position=adapter.redo();
    mMasterImage.onHistoryItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.resetHistoryButton:
{
  resetHistory();
  return true;
}
case R.id.showImageStateButton:
{
toggleImageStatePanel();
return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","The original code lacks a method call to return to the main view after performing an undo operation, potentially leaving the user stranded in the current screen. In the fixed code, `backToMain()` is added to the undo button case, ensuring proper navigation after undoing an action. This improvement enhances user experience by providing a clear and consistent workflow when reverting image changes."
38334,"/** 
 * Resizes rectangle to have a certain aspect ratio (center remains stationary) while constraining it to remain within the original rect.
 * @param r rectangle to resize
 * @param w new width aspect
 * @param h new height aspect
 */
public static void fixAspectRatioContained(RectF r,float w,float h){
  float origW=r.width();
  float origH=r.height();
  float origA=origW / origH;
  float a=w / h;
  float finalW=origW;
  float finalH=origH;
  if (origA < a) {
    finalH=origW / a;
  }
 else {
    finalW=origH * a;
  }
  float centX=r.centerX();
  float centY=r.centerY();
  float hw=finalW / 2;
  float hh=finalH / 2;
  r.set(centX - hw,centY - hh,centX + hw,centY + hh);
}","/** 
 * Resizes rectangle to have a certain aspect ratio (center remains stationary) while constraining it to remain within the original rect.
 * @param r rectangle to resize
 * @param w new width aspect
 * @param h new height aspect
 */
public static void fixAspectRatioContained(RectF r,float w,float h){
  float origW=r.width();
  float origH=r.height();
  float origA=origW / origH;
  float a=w / h;
  float finalW=origW;
  float finalH=origH;
  if (origA < a) {
    finalH=origW / a;
    r.top=r.centerY() - finalH / 2;
    r.bottom=r.top + finalH;
  }
 else {
    finalW=origH * a;
    r.left=r.centerX() - finalW / 2;
    r.right=r.left + finalW;
  }
}","The original code incorrectly resized the rectangle without properly updating its coordinates, potentially leaving the rectangle in an invalid state. The fixed code explicitly updates the top, bottom, left, and right coordinates based on the new dimensions while maintaining the rectangle's center, ensuring accurate resizing. This approach guarantees that the rectangle is correctly modified with the desired aspect ratio while preserving its central position."
38335,"public ArrayList<Path> getSelected(boolean expandSet,int maxSelection){
  ArrayList<Path> selected=new ArrayList<Path>();
  if (mIsAlbumSet) {
    if (mInverseSelection) {
      int total=getTotalCount();
      for (int i=0; i < total; i++) {
        MediaSet set=mSourceMediaSet.getSubMediaSet(i);
        Path id=set.getPath();
        if (!mClickedSet.contains(id)) {
          if (expandSet && !expandMediaSet(selected,set,maxSelection)) {
            return null;
          }
 else {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
      }
    }
 else {
      for (      Path id : mClickedSet) {
        if (expandSet && !expandMediaSet(selected,mDataManager.getMediaSet(id),maxSelection)) {
          return null;
        }
 else {
          selected.add(id);
          if (selected.size() > maxSelection) {
            return null;
          }
        }
      }
    }
  }
 else {
    if (mInverseSelection) {
      int total=getTotalCount();
      int index=0;
      while (index < total) {
        int count=Math.min(total - index,MediaSet.MEDIAITEM_BATCH_FETCH_COUNT);
        ArrayList<MediaItem> list=mSourceMediaSet.getMediaItem(index,count);
        for (        MediaItem item : list) {
          Path id=item.getPath();
          if (!mClickedSet.contains(id)) {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
        index+=count;
      }
    }
 else {
      for (      Path id : mClickedSet) {
        selected.add(id);
        if (selected.size() > maxSelection) {
          return null;
        }
      }
    }
  }
  return selected;
}","public ArrayList<Path> getSelected(boolean expandSet,int maxSelection){
  ArrayList<Path> selected=new ArrayList<Path>();
  if (mIsAlbumSet) {
    if (mInverseSelection) {
      int total=getTotalCount();
      for (int i=0; i < total; i++) {
        MediaSet set=mSourceMediaSet.getSubMediaSet(i);
        Path id=set.getPath();
        if (!mClickedSet.contains(id)) {
          if (expandSet) {
            if (!expandMediaSet(selected,set,maxSelection)) {
              return null;
            }
          }
 else {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
      }
    }
 else {
      for (      Path id : mClickedSet) {
        if (expandSet) {
          if (!expandMediaSet(selected,mDataManager.getMediaSet(id),maxSelection)) {
            return null;
          }
        }
 else {
          selected.add(id);
          if (selected.size() > maxSelection) {
            return null;
          }
        }
      }
    }
  }
 else {
    if (mInverseSelection) {
      int total=getTotalCount();
      int index=0;
      while (index < total) {
        int count=Math.min(total - index,MediaSet.MEDIAITEM_BATCH_FETCH_COUNT);
        ArrayList<MediaItem> list=mSourceMediaSet.getMediaItem(index,count);
        for (        MediaItem item : list) {
          Path id=item.getPath();
          if (!mClickedSet.contains(id)) {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
        index+=count;
      }
    }
 else {
      for (      Path id : mClickedSet) {
        selected.add(id);
        if (selected.size() > maxSelection) {
          return null;
        }
      }
    }
  }
  return selected;
}","The original code had incorrect nested conditionals for handling expandSet, causing potential logical errors in selection processing. The fixed code separates the expandSet condition more clearly, ensuring that expandMediaSet is called independently when expandSet is true, and directly adding paths when false. This modification provides a more robust and predictable selection mechanism, preventing unintended skipping of expansion or selection steps and improving the method's overall reliability."
38336,"private void fillFx(LinearLayout listFilters,int buttonId){
  FilterFxRepresentation[] fxArray=new FilterFxRepresentation[18];
  int p=0;
  int[] drawid={R.drawable.filtershow_fx_0005_punch,R.drawable.filtershow_fx_0000_vintage,R.drawable.filtershow_fx_0004_bw_contrast,R.drawable.filtershow_fx_0002_bleach,R.drawable.filtershow_fx_0001_instant,R.drawable.filtershow_fx_0007_washout,R.drawable.filtershow_fx_0003_blue_crush,R.drawable.filtershow_fx_0008_washout_color,R.drawable.filtershow_fx_0006_x_process};
  int[] fxNameid={R.string.ffx_punch,R.string.ffx_vintage,R.string.ffx_bw_contrast,R.string.ffx_bleach,R.string.ffx_instant,R.string.ffx_washout,R.string.ffx_blue_crush,R.string.ffx_washout_color,R.string.ffx_x_process};
  for (int i=0; i < drawid.length; i++) {
    FilterFxRepresentation fx=new FilterFxRepresentation(getString(fxNameid[i]),drawid[i],fxNameid[i]);
    fxArray[p++]=fx;
  }
  ImageButton button=(ImageButton)findViewById(buttonId);
  FilterFxRepresentation nullFx=new FilterFxRepresentation(getString(R.string.none),0,R.string.none);
  mNullFxFilter=setupFilterRepresentationButton(nullFx,listFilters,button);
  mNullFxFilter.setSelected(true);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager.getManager().addLooks(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listFilters,button);
  }
  for (int i=0; i < p; i++) {
    setupFilterRepresentationButton(fxArray[i],listFilters,button);
  }
}","private void fillFx(LinearLayout listFilters,int buttonId){
  ImageButton button=(ImageButton)findViewById(buttonId);
  FilterFxRepresentation nullFx=new FilterFxRepresentation(getString(R.string.none),0,R.string.none);
  mNullFxFilter=setupFilterRepresentationButton(nullFx,listFilters,button);
  mNullFxFilter.setSelected(true);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager.getManager().addLooks(this,filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listFilters,button);
  }
}","The original code inefficiently created multiple redundant filter representations, leading to potential performance issues and unnecessary memory allocation. The fixed code removes the manual creation of filter arrays and simplifies the method by directly using FiltersManager's addLooks method with a context parameter. This streamlines the filter setup process, reduces code complexity, and ensures more efficient filter representation management."
38337,"private void setupBorders(){
  LinearLayout list=(LinearLayout)findViewById(R.id.listBorders);
  Vector<FilterRepresentation> borders=new Vector<FilterRepresentation>();
  ImageButton borderButton=(ImageButton)findViewById(R.id.borderButton);
  borders.add(new FilterImageBorderRepresentation(0));
  FiltersManager.getManager().addBorders(borders);
  borders.add(new FilterImageBorderRepresentation(R.drawable.filtershow_border_4x5));
  borders.add(new FilterImageBorderRepresentation(R.drawable.filtershow_border_brush));
  borders.add(new FilterImageBorderRepresentation(R.drawable.filtershow_border_grunge));
  borders.add(new FilterImageBorderRepresentation(R.drawable.filtershow_border_sumi_e));
  borders.add(new FilterImageBorderRepresentation(R.drawable.filtershow_border_tape));
  borders.add(new FilterColorBorderRepresentation(Color.BLACK,mImageBorderSize,0));
  borders.add(new FilterColorBorderRepresentation(Color.BLACK,mImageBorderSize,mImageBorderSize));
  borders.add(new FilterColorBorderRepresentation(Color.WHITE,mImageBorderSize,0));
  borders.add(new FilterColorBorderRepresentation(Color.WHITE,mImageBorderSize,mImageBorderSize));
  int creamColor=Color.argb(255,237,237,227);
  borders.add(new FilterColorBorderRepresentation(creamColor,mImageBorderSize,0));
  borders.add(new FilterColorBorderRepresentation(creamColor,mImageBorderSize,mImageBorderSize));
  for (int i=0; i < borders.size(); i++) {
    FilterRepresentation filter=borders.elementAt(i);
    filter.setName(getString(R.string.borders));
    if (i == 0) {
      filter.setName(getString(R.string.none));
    }
    FilterIconButton b=setupFilterRepresentationButton(filter,list,borderButton);
    if (i == 0) {
      mNullBorderFilter=b;
      mNullBorderFilter.setSelected(true);
    }
  }
}","private void setupBorders(){
  LinearLayout list=(LinearLayout)findViewById(R.id.listBorders);
  Vector<FilterRepresentation> borders=new Vector<FilterRepresentation>();
  ImageButton borderButton=(ImageButton)findViewById(R.id.borderButton);
  borders.add(new FilterImageBorderRepresentation(0));
  FiltersManager.getManager().addBorders(this,borders);
  for (int i=0; i < borders.size(); i++) {
    FilterRepresentation filter=borders.elementAt(i);
    if (i == 0) {
      filter.setName(getString(R.string.none));
    }
    FilterIconButton b=setupFilterRepresentationButton(filter,list,borderButton);
    if (i == 0) {
      mNullBorderFilter=b;
      mNullBorderFilter.setSelected(true);
    }
  }
}","The original code redundantly added multiple border representations to the `borders` vector without utilizing them, potentially causing performance overhead and unnecessary memory usage. The fixed code removes the redundant border additions and modifies the `addBorders` method call by passing the current context, ensuring proper initialization. This streamlines the border setup process, making the code more efficient and focused on the essential border representation needed for the UI."
38338,"public void setOriginal(Bitmap bitmap){
  if (mPipelineIsOn) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  Log.v(LOGTAG,""String_Node_Str"" + bitmap.getWidth() + ""String_Node_Str""+ bitmap.getHeight());
  mAccessoryPipeline.setOriginal(bitmap);
  mPreviewPipeline.setOriginal(bitmap);
  mHighresPreviewPipeline.setOriginal(bitmap);
}","public void setOriginal(Bitmap bitmap){
  if (mPipelineIsOn) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  mAccessoryPipeline.setOriginal(bitmap);
  mPreviewPipeline.setOriginal(bitmap);
  mHighresPreviewPipeline.setOriginal(bitmap);
}","The original code included an unnecessary verbose logging statement that could potentially impact performance and readability. The fixed code removes the redundant log message, keeping only the essential bitmap processing logic for the three pipelines. By eliminating the unnecessary logging, the code becomes more efficient and focused on its core functionality of setting the original bitmap across different pipeline components."
38339,"public void addBorders(Vector<FilterRepresentation> representations){
}","public void addBorders(Context context,Vector<FilterRepresentation> representations){
}","The original method lacks a crucial Context parameter, which is typically required for Android UI and resource operations. The fixed code adds a Context parameter, enabling access to system resources, theme information, and other Android-specific functionalities needed for border rendering or filter processing. By including the Context, the method becomes more flexible and capable of performing Android-specific tasks that require system-level interactions."
38340,"public void addLooks(Vector<FilterRepresentation> representations){
}","public void addLooks(Context context,Vector<FilterRepresentation> representations){
  int[] drawid={R.drawable.filtershow_fx_0005_punch,R.drawable.filtershow_fx_0000_vintage,R.drawable.filtershow_fx_0004_bw_contrast,R.drawable.filtershow_fx_0002_bleach,R.drawable.filtershow_fx_0001_instant,R.drawable.filtershow_fx_0007_washout,R.drawable.filtershow_fx_0003_blue_crush,R.drawable.filtershow_fx_0008_washout_color,R.drawable.filtershow_fx_0006_x_process};
  int[] fxNameid={R.string.ffx_punch,R.string.ffx_vintage,R.string.ffx_bw_contrast,R.string.ffx_bleach,R.string.ffx_instant,R.string.ffx_washout,R.string.ffx_blue_crush,R.string.ffx_washout_color,R.string.ffx_x_process};
  for (int i=0; i < drawid.length; i++) {
    FilterFxRepresentation fx=new FilterFxRepresentation(context.getString(fxNameid[i]),drawid[i],fxNameid[i]);
    representations.add(fx);
  }
}","The original code lacked a Context parameter, which is essential for accessing string and drawable resources in Android. The fixed code adds a Context parameter and uses it to retrieve localized strings and drawable IDs for creating FilterFxRepresentation objects. By iterating through predefined arrays of resource IDs, the method now dynamically populates the representations vector with various filter effects, making the code more flexible and maintainable."
38341,"private void fillFx(LinearLayout listFilters,int buttonId){
  FilterFxRepresentation[] fxArray=new FilterFxRepresentation[18];
  int p=0;
  int[] drawid={R.drawable.filtershow_fx_0005_punch,R.drawable.filtershow_fx_0000_vintage,R.drawable.filtershow_fx_0004_bw_contrast,R.drawable.filtershow_fx_0002_bleach,R.drawable.filtershow_fx_0001_instant,R.drawable.filtershow_fx_0007_washout,R.drawable.filtershow_fx_0003_blue_crush,R.drawable.filtershow_fx_0008_washout_color,R.drawable.filtershow_fx_0006_x_process};
  int[] fxNameid={R.string.ffx_punch,R.string.ffx_vintage,R.string.ffx_bw_contrast,R.string.ffx_bleach,R.string.ffx_instant,R.string.ffx_washout,R.string.ffx_blue_crush,R.string.ffx_washout_color,R.string.ffx_x_process};
  for (int i=0; i < drawid.length; i++) {
    FilterFxRepresentation fx=new FilterFxRepresentation(getString(fxNameid[i]),drawid[i],fxNameid[i]);
    fxArray[p++]=fx;
  }
  ImageButton button=(ImageButton)findViewById(buttonId);
  FilterFxRepresentation nullFx=new FilterFxRepresentation(getString(R.string.none),0,R.string.none);
  mNullFxFilter=setupFilterRepresentationButton(nullFx,listFilters,button);
  mNullFxFilter.setSelected(true);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager.getManager().addLooks(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listFilters,button);
  }
  for (int i=0; i < p; i++) {
    setupFilterRepresentationButton(fxArray[i],listFilters,button);
  }
}","private void fillFx(LinearLayout listFilters,int buttonId){
  ImageButton button=(ImageButton)findViewById(buttonId);
  FilterFxRepresentation nullFx=new FilterFxRepresentation(getString(R.string.none),0,R.string.none);
  mNullFxFilter=setupFilterRepresentationButton(nullFx,listFilters,button);
  mNullFxFilter.setSelected(true);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager.getManager().addLooks(this,filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listFilters,button);
  }
}","The original code inefficiently created multiple redundant filter representations, leading to potential performance issues and unnecessary memory allocation. The fixed code removes the manual creation of filter arrays and simplifies the method by directly using FiltersManager's addLooks method with a context parameter. This streamlines the filter loading process, reduces code complexity, and ensures more efficient and clean filter representation setup."
38342,"private void setupBorders(){
  LinearLayout list=(LinearLayout)findViewById(R.id.listBorders);
  Vector<FilterRepresentation> borders=new Vector<FilterRepresentation>();
  ImageButton borderButton=(ImageButton)findViewById(R.id.borderButton);
  borders.add(new FilterImageBorderRepresentation(0));
  FiltersManager.getManager().addBorders(borders);
  borders.add(new FilterImageBorderRepresentation(R.drawable.filtershow_border_4x5));
  borders.add(new FilterImageBorderRepresentation(R.drawable.filtershow_border_brush));
  borders.add(new FilterImageBorderRepresentation(R.drawable.filtershow_border_grunge));
  borders.add(new FilterImageBorderRepresentation(R.drawable.filtershow_border_sumi_e));
  borders.add(new FilterImageBorderRepresentation(R.drawable.filtershow_border_tape));
  borders.add(new FilterColorBorderRepresentation(Color.BLACK,mImageBorderSize,0));
  borders.add(new FilterColorBorderRepresentation(Color.BLACK,mImageBorderSize,mImageBorderSize));
  borders.add(new FilterColorBorderRepresentation(Color.WHITE,mImageBorderSize,0));
  borders.add(new FilterColorBorderRepresentation(Color.WHITE,mImageBorderSize,mImageBorderSize));
  int creamColor=Color.argb(255,237,237,227);
  borders.add(new FilterColorBorderRepresentation(creamColor,mImageBorderSize,0));
  borders.add(new FilterColorBorderRepresentation(creamColor,mImageBorderSize,mImageBorderSize));
  for (int i=0; i < borders.size(); i++) {
    FilterRepresentation filter=borders.elementAt(i);
    filter.setName(getString(R.string.borders));
    if (i == 0) {
      filter.setName(getString(R.string.none));
    }
    FilterIconButton b=setupFilterRepresentationButton(filter,list,borderButton);
    if (i == 0) {
      mNullBorderFilter=b;
      mNullBorderFilter.setSelected(true);
    }
  }
}","private void setupBorders(){
  LinearLayout list=(LinearLayout)findViewById(R.id.listBorders);
  Vector<FilterRepresentation> borders=new Vector<FilterRepresentation>();
  ImageButton borderButton=(ImageButton)findViewById(R.id.borderButton);
  borders.add(new FilterImageBorderRepresentation(0));
  FiltersManager.getManager().addBorders(this,borders);
  for (int i=0; i < borders.size(); i++) {
    FilterRepresentation filter=borders.elementAt(i);
    if (i == 0) {
      filter.setName(getString(R.string.none));
    }
    FilterIconButton b=setupFilterRepresentationButton(filter,list,borderButton);
    if (i == 0) {
      mNullBorderFilter=b;
      mNullBorderFilter.setSelected(true);
    }
  }
}","The original code redundantly added multiple border representations to the vector without utilizing them, potentially causing performance overhead and unnecessary memory usage. The fixed code removes the redundant border additions and modifies the `addBorders` method call by passing the current context, ensuring proper initialization and management of border filters. This streamlined approach reduces code complexity, improves efficiency, and maintains the core functionality of setting up border filters with a cleaner implementation."
38343,"public void setOriginal(Bitmap bitmap){
  if (mPipelineIsOn) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  Log.v(LOGTAG,""String_Node_Str"" + bitmap.getWidth() + ""String_Node_Str""+ bitmap.getHeight());
  mAccessoryPipeline.setOriginal(bitmap);
  mPreviewPipeline.setOriginal(bitmap);
  mHighresPreviewPipeline.setOriginal(bitmap);
}","public void setOriginal(Bitmap bitmap){
  if (mPipelineIsOn) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  mAccessoryPipeline.setOriginal(bitmap);
  mPreviewPipeline.setOriginal(bitmap);
  mHighresPreviewPipeline.setOriginal(bitmap);
}","The original code included an unnecessary verbose logging statement that printed bitmap dimensions before setting the original bitmap in multiple pipelines. The fixed code removes this redundant logging, directly calling setOriginal() on each pipeline without the extra verbose log. By eliminating unnecessary logging, the code becomes more efficient and reduces potential performance overhead during bitmap processing."
38344,"public void addBorders(Vector<FilterRepresentation> representations){
}","public void addBorders(Context context,Vector<FilterRepresentation> representations){
}","The original method lacks a Context parameter, which is typically required for Android UI operations like adding borders to filter representations. The fixed code introduces a Context parameter, enabling access to system resources, theme attributes, and other Android-specific functionalities needed for border manipulation. By including the Context, the method becomes more flexible and can properly interact with Android's UI framework, allowing for more robust filter representation modifications."
38345,"public void addLooks(Vector<FilterRepresentation> representations){
}","public void addLooks(Context context,Vector<FilterRepresentation> representations){
  int[] drawid={R.drawable.filtershow_fx_0005_punch,R.drawable.filtershow_fx_0000_vintage,R.drawable.filtershow_fx_0004_bw_contrast,R.drawable.filtershow_fx_0002_bleach,R.drawable.filtershow_fx_0001_instant,R.drawable.filtershow_fx_0007_washout,R.drawable.filtershow_fx_0003_blue_crush,R.drawable.filtershow_fx_0008_washout_color,R.drawable.filtershow_fx_0006_x_process};
  int[] fxNameid={R.string.ffx_punch,R.string.ffx_vintage,R.string.ffx_bw_contrast,R.string.ffx_bleach,R.string.ffx_instant,R.string.ffx_washout,R.string.ffx_blue_crush,R.string.ffx_washout_color,R.string.ffx_x_process};
  for (int i=0; i < drawid.length; i++) {
    FilterFxRepresentation fx=new FilterFxRepresentation(context.getString(fxNameid[i]),drawid[i],fxNameid[i]);
    representations.add(fx);
  }
}","The original code lacks a Context parameter, preventing access to string and drawable resources needed for creating filter representations. The fixed code adds a Context parameter and uses it to retrieve localized filter names and drawable icons from resources, enabling dynamic filter creation. By iterating through predefined resource arrays, the method now populates the representations vector with fully configured FilterFxRepresentation objects, making the code more flexible and resource-aware."
38346,"public ArrayList<Path> getSelected(boolean expandSet,int maxSelection){
  ArrayList<Path> selected=new ArrayList<Path>();
  if (mIsAlbumSet) {
    if (mInverseSelection) {
      int total=getTotalCount();
      for (int i=0; i < total; i++) {
        MediaSet set=mSourceMediaSet.getSubMediaSet(i);
        Path id=set.getPath();
        if (!mClickedSet.contains(id)) {
          if (expandSet && !expandMediaSet(selected,set,maxSelection)) {
            return null;
          }
 else {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
      }
    }
 else {
      for (      Path id : mClickedSet) {
        if (expandSet && !expandMediaSet(selected,mDataManager.getMediaSet(id),maxSelection)) {
          return null;
        }
 else {
          selected.add(id);
          if (selected.size() > maxSelection) {
            return null;
          }
        }
      }
    }
  }
 else {
    if (mInverseSelection) {
      int total=getTotalCount();
      int index=0;
      while (index < total) {
        int count=Math.min(total - index,MediaSet.MEDIAITEM_BATCH_FETCH_COUNT);
        ArrayList<MediaItem> list=mSourceMediaSet.getMediaItem(index,count);
        for (        MediaItem item : list) {
          Path id=item.getPath();
          if (!mClickedSet.contains(id)) {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
        index+=count;
      }
    }
 else {
      for (      Path id : mClickedSet) {
        selected.add(id);
        if (selected.size() > maxSelection) {
          return null;
        }
      }
    }
  }
  return selected;
}","public ArrayList<Path> getSelected(boolean expandSet,int maxSelection){
  ArrayList<Path> selected=new ArrayList<Path>();
  if (mIsAlbumSet) {
    if (mInverseSelection) {
      int total=getTotalCount();
      for (int i=0; i < total; i++) {
        MediaSet set=mSourceMediaSet.getSubMediaSet(i);
        Path id=set.getPath();
        if (!mClickedSet.contains(id)) {
          if (expandSet) {
            if (!expandMediaSet(selected,set,maxSelection)) {
              return null;
            }
          }
 else {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
      }
    }
 else {
      for (      Path id : mClickedSet) {
        if (expandSet) {
          if (!expandMediaSet(selected,mDataManager.getMediaSet(id),maxSelection)) {
            return null;
          }
        }
 else {
          selected.add(id);
          if (selected.size() > maxSelection) {
            return null;
          }
        }
      }
    }
  }
 else {
    if (mInverseSelection) {
      int total=getTotalCount();
      int index=0;
      while (index < total) {
        int count=Math.min(total - index,MediaSet.MEDIAITEM_BATCH_FETCH_COUNT);
        ArrayList<MediaItem> list=mSourceMediaSet.getMediaItem(index,count);
        for (        MediaItem item : list) {
          Path id=item.getPath();
          if (!mClickedSet.contains(id)) {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
        index+=count;
      }
    }
 else {
      for (      Path id : mClickedSet) {
        selected.add(id);
        if (selected.size() > maxSelection) {
          return null;
        }
      }
    }
  }
  return selected;
}","The original code had incorrect nested conditional logic for handling `expandSet`, causing potential incorrect selection behavior when expanding media sets. In the fixed code, the `expandSet` condition is separated into distinct branches, ensuring that `expandMediaSet` is called independently and correctly when `expandSet` is true. This modification provides more predictable and accurate media set selection, preventing potential logic errors in path selection and respecting the maximum selection limit."
38347,"@Override public void run(){
  mMenuTask=null;
  if (jc.isCancelled())   return;
  MenuExecutor.updateMenuOperation(mMenu,operation);
  MenuExecutor.updateMenuForPanorama(mMenu,supportCallback.mAllPanorama360,supportCallback.mHasPanorama360);
  if (mSharePanoramaMenuItem != null) {
    mSharePanoramaMenuItem.setEnabled(true);
    if (supportCallback.mAllPanorama360) {
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
    }
 else {
      mSharePanoramaMenuItem.setVisible(false);
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
    }
    mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
  }
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(true);
    mShareActionProvider.setShareIntent(share_intent);
  }
}","@Override public void run(){
  mMenuTask=null;
  if (jc.isCancelled())   return;
  MenuExecutor.updateMenuOperation(mMenu,operation);
  MenuExecutor.updateMenuForPanorama(mMenu,canSharePanoramas && supportCallback.mAllPanorama360,canSharePanoramas && supportCallback.mHasPanorama360);
  if (mSharePanoramaMenuItem != null) {
    mSharePanoramaMenuItem.setEnabled(true);
    if (canSharePanoramas && supportCallback.mAllPanorama360) {
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
    }
 else {
      mSharePanoramaMenuItem.setVisible(false);
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
    }
    mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
  }
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(canShare);
    mShareActionProvider.setShareIntent(share_intent);
  }
}","The original code lacked proper conditional checks for sharing panoramas and menu item states, potentially enabling inappropriate sharing or displaying incorrect menu options. The fixed code introduces new variables `canSharePanoramas` and `canShare` to conditionally control menu item visibility, enablement, and share intent based on panorama and sharing capabilities. By adding these precise conditional checks, the code now ensures more robust and context-aware menu rendering and sharing functionality."
38348,"public void updateSupportedOperation(){
  if (mMenuTask != null)   mMenuTask.cancel();
  updateSelectionMenu();
  if (mSharePanoramaMenuItem != null)   mSharePanoramaMenuItem.setEnabled(false);
  if (mShareMenuItem != null)   mShareMenuItem.setEnabled(false);
  mMenuTask=mActivity.getThreadPool().submit(new Job<Void>(){
    @Override public Void run(    final JobContext jc){
      ArrayList<MediaObject> selected=getSelectedMediaObjects(jc);
      if (selected == null) {
        mMainHandler.post(new Runnable(){
          @Override public void run(){
            mMenuTask=null;
            if (jc.isCancelled())             return;
            MenuExecutor.updateMenuOperation(mMenu,0);
          }
        }
);
        return null;
      }
      final int operation=computeMenuOptions(selected);
      if (jc.isCancelled()) {
        return null;
      }
      final GetAllPanoramaSupports supportCallback=new GetAllPanoramaSupports(selected,jc);
      final Intent share_panorama_intent=computePanoramaSharingIntent(jc);
      final Intent share_intent=computeSharingIntent(jc);
      supportCallback.waitForPanoramaSupport();
      if (jc.isCancelled()) {
        return null;
      }
      mMainHandler.post(new Runnable(){
        @Override public void run(){
          mMenuTask=null;
          if (jc.isCancelled())           return;
          MenuExecutor.updateMenuOperation(mMenu,operation);
          MenuExecutor.updateMenuForPanorama(mMenu,supportCallback.mAllPanorama360,supportCallback.mHasPanorama360);
          if (mSharePanoramaMenuItem != null) {
            mSharePanoramaMenuItem.setEnabled(true);
            if (supportCallback.mAllPanorama360) {
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
            }
 else {
              mSharePanoramaMenuItem.setVisible(false);
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
            }
            mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
          }
          if (mShareMenuItem != null) {
            mShareMenuItem.setEnabled(true);
            mShareActionProvider.setShareIntent(share_intent);
          }
        }
      }
);
      return null;
    }
  }
);
}","public void updateSupportedOperation(){
  if (mMenuTask != null)   mMenuTask.cancel();
  updateSelectionMenu();
  if (mSharePanoramaMenuItem != null)   mSharePanoramaMenuItem.setEnabled(false);
  if (mShareMenuItem != null)   mShareMenuItem.setEnabled(false);
  mMenuTask=mActivity.getThreadPool().submit(new Job<Void>(){
    @Override public Void run(    final JobContext jc){
      ArrayList<MediaObject> selected=getSelectedMediaObjects(jc);
      if (selected == null) {
        mMainHandler.post(new Runnable(){
          @Override public void run(){
            mMenuTask=null;
            if (jc.isCancelled())             return;
            MenuExecutor.updateMenuOperation(mMenu,0);
          }
        }
);
        return null;
      }
      final int operation=computeMenuOptions(selected);
      if (jc.isCancelled()) {
        return null;
      }
      int numSelected=selected.size();
      final boolean canSharePanoramas=numSelected < MAX_SELECTED_ITEMS_FOR_PANORAMA_SHARE_INTENT;
      final boolean canShare=numSelected < MAX_SELECTED_ITEMS_FOR_SHARE_INTENT;
      final GetAllPanoramaSupports supportCallback=canSharePanoramas ? new GetAllPanoramaSupports(selected,jc) : null;
      final Intent share_panorama_intent=canSharePanoramas ? computePanoramaSharingIntent(jc,MAX_SELECTED_ITEMS_FOR_PANORAMA_SHARE_INTENT) : new Intent();
      final Intent share_intent=canShare ? computeSharingIntent(jc,MAX_SELECTED_ITEMS_FOR_SHARE_INTENT) : new Intent();
      if (canSharePanoramas) {
        supportCallback.waitForPanoramaSupport();
      }
      if (jc.isCancelled()) {
        return null;
      }
      mMainHandler.post(new Runnable(){
        @Override public void run(){
          mMenuTask=null;
          if (jc.isCancelled())           return;
          MenuExecutor.updateMenuOperation(mMenu,operation);
          MenuExecutor.updateMenuForPanorama(mMenu,canSharePanoramas && supportCallback.mAllPanorama360,canSharePanoramas && supportCallback.mHasPanorama360);
          if (mSharePanoramaMenuItem != null) {
            mSharePanoramaMenuItem.setEnabled(true);
            if (canSharePanoramas && supportCallback.mAllPanorama360) {
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
            }
 else {
              mSharePanoramaMenuItem.setVisible(false);
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
            }
            mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
          }
          if (mShareMenuItem != null) {
            mShareMenuItem.setEnabled(canShare);
            mShareActionProvider.setShareIntent(share_intent);
          }
        }
      }
);
      return null;
    }
  }
);
}","The original code lacked proper handling of sharing limits for panorama and regular media items, potentially causing runtime errors or unexpected sharing behavior. The fixed code introduces checks for the number of selected items against predefined maximum limits and conditionally creates sharing intents and panorama support callbacks. By adding these constraints and null checks, the code now safely manages share operations, prevents potential out-of-bounds errors, and provides more robust menu update logic for different media selection scenarios."
38349,"private Intent computeSharingIntent(JobContext jc){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true);
  if (expandedPaths.size() == 0) {
    setNfcBeamPushUris(null);
    return null;
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  int type=0;
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    int support=manager.getSupportedOperations(path);
    type|=manager.getMediaType(path);
    if ((support & MediaObject.SUPPORT_SHARE) != 0) {
      uris.add(manager.getContentUri(path));
    }
  }
  final int size=uris.size();
  if (size > 0) {
    final String mimeType=MenuExecutor.getMimeType(type);
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE).setType(mimeType);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND).setType(mimeType);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    setNfcBeamPushUris(uris.toArray(new Uri[uris.size()]));
  }
 else {
    setNfcBeamPushUris(null);
  }
  return intent;
}","private Intent computeSharingIntent(JobContext jc,int maxItems){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true,maxItems);
  if (expandedPaths == null || expandedPaths.size() == 0) {
    setNfcBeamPushUris(null);
    return new Intent();
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  int type=0;
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    int support=manager.getSupportedOperations(path);
    type|=manager.getMediaType(path);
    if ((support & MediaObject.SUPPORT_SHARE) != 0) {
      uris.add(manager.getContentUri(path));
    }
  }
  final int size=uris.size();
  if (size > 0) {
    final String mimeType=MenuExecutor.getMimeType(type);
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE).setType(mimeType);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND).setType(mimeType);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    setNfcBeamPushUris(uris.toArray(new Uri[uris.size()]));
  }
 else {
    setNfcBeamPushUris(null);
  }
  return intent;
}","The original code lacks error handling for empty or null path selections, potentially causing null pointer exceptions when sharing files. The fixed code adds a maxItems parameter to limit selections, checks for null or empty path lists, and returns an empty intent instead of null when no items are selected. These changes make the sharing intent generation more robust, preventing potential crashes and providing a consistent return value across different selection scenarios."
38350,"private Intent computePanoramaSharingIntent(JobContext jc){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true);
  if (expandedPaths.size() == 0) {
    return null;
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    uris.add(manager.getContentUri(path));
  }
  final int size=uris.size();
  if (size > 0) {
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
  }
  return intent;
}","private Intent computePanoramaSharingIntent(JobContext jc,int maxItems){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true,maxItems);
  if (expandedPaths == null || expandedPaths.size() == 0) {
    return new Intent();
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    uris.add(manager.getContentUri(path));
  }
  final int size=uris.size();
  if (size > 0) {
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
  }
  return intent;
}","The original code lacks proper handling for empty or null selection paths, potentially causing null pointer exceptions when sharing panoramas. The fixed code introduces a maxItems parameter to limit selections and returns an empty intent when no paths are available, preventing potential runtime errors. These modifications enhance robustness by gracefully managing edge cases and providing a more reliable intent creation mechanism for panorama sharing."
38351,"private static void expandMediaSet(ArrayList<Path> items,MediaSet set){
  int subCount=set.getSubMediaSetCount();
  for (int i=0; i < subCount; i++) {
    expandMediaSet(items,set.getSubMediaSet(i));
  }
  int total=set.getMediaItemCount();
  int batch=50;
  int index=0;
  while (index < total) {
    int count=index + batch < total ? batch : total - index;
    ArrayList<MediaItem> list=set.getMediaItem(index,count);
    for (    MediaItem item : list) {
      items.add(item.getPath());
    }
    index+=batch;
  }
}","private static boolean expandMediaSet(ArrayList<Path> items,MediaSet set,int maxSelection){
  int subCount=set.getSubMediaSetCount();
  for (int i=0; i < subCount; i++) {
    if (!expandMediaSet(items,set.getSubMediaSet(i),maxSelection)) {
      return false;
    }
  }
  int total=set.getMediaItemCount();
  int batch=50;
  int index=0;
  while (index < total) {
    int count=index + batch < total ? batch : total - index;
    ArrayList<MediaItem> list=set.getMediaItem(index,count);
    if (list != null && list.size() > (maxSelection - items.size())) {
      return false;
    }
    for (    MediaItem item : list) {
      items.add(item.getPath());
    }
    index+=batch;
  }
  return true;
}","The original code lacked a mechanism to limit media item selection, potentially causing excessive memory consumption or performance issues when processing large media sets. The fixed code introduces a `maxSelection` parameter and recursive checks to prevent exceeding the selection limit, with added null checks and size comparisons before adding items. This modification ensures controlled, safe expansion of media sets by providing a boundary for item collection and preventing potential out-of-memory scenarios."
38352,"public ArrayList<Path> getSelected(boolean expandSet){
  ArrayList<Path> selected=new ArrayList<Path>();
  if (mIsAlbumSet) {
    if (mInverseSelection) {
      int total=getTotalCount();
      for (int i=0; i < total; i++) {
        MediaSet set=mSourceMediaSet.getSubMediaSet(i);
        Path id=set.getPath();
        if (!mClickedSet.contains(id)) {
          if (expandSet) {
            expandMediaSet(selected,set);
          }
 else {
            selected.add(id);
          }
        }
      }
    }
 else {
      for (      Path id : mClickedSet) {
        if (expandSet) {
          expandMediaSet(selected,mDataManager.getMediaSet(id));
        }
 else {
          selected.add(id);
        }
      }
    }
  }
 else {
    if (mInverseSelection) {
      int total=getTotalCount();
      int index=0;
      while (index < total) {
        int count=Math.min(total - index,MediaSet.MEDIAITEM_BATCH_FETCH_COUNT);
        ArrayList<MediaItem> list=mSourceMediaSet.getMediaItem(index,count);
        for (        MediaItem item : list) {
          Path id=item.getPath();
          if (!mClickedSet.contains(id))           selected.add(id);
        }
        index+=count;
      }
    }
 else {
      for (      Path id : mClickedSet) {
        selected.add(id);
      }
    }
  }
  return selected;
}","public ArrayList<Path> getSelected(boolean expandSet,int maxSelection){
  ArrayList<Path> selected=new ArrayList<Path>();
  if (mIsAlbumSet) {
    if (mInverseSelection) {
      int total=getTotalCount();
      for (int i=0; i < total; i++) {
        MediaSet set=mSourceMediaSet.getSubMediaSet(i);
        Path id=set.getPath();
        if (!mClickedSet.contains(id)) {
          if (expandSet && !expandMediaSet(selected,set,maxSelection)) {
            return null;
          }
 else {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
      }
    }
 else {
      for (      Path id : mClickedSet) {
        if (expandSet && !expandMediaSet(selected,mDataManager.getMediaSet(id),maxSelection)) {
          return null;
        }
 else {
          selected.add(id);
          if (selected.size() > maxSelection) {
            return null;
          }
        }
      }
    }
  }
 else {
    if (mInverseSelection) {
      int total=getTotalCount();
      int index=0;
      while (index < total) {
        int count=Math.min(total - index,MediaSet.MEDIAITEM_BATCH_FETCH_COUNT);
        ArrayList<MediaItem> list=mSourceMediaSet.getMediaItem(index,count);
        for (        MediaItem item : list) {
          Path id=item.getPath();
          if (!mClickedSet.contains(id)) {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
        index+=count;
      }
    }
 else {
      for (      Path id : mClickedSet) {
        selected.add(id);
        if (selected.size() > maxSelection) {
          return null;
        }
      }
    }
  }
  return selected;
}","The original code lacked a mechanism to limit the number of selected items, potentially allowing unbounded selection. The fixed code introduces a `maxSelection` parameter and adds checks to return `null` if the selection exceeds this limit, with additional logic to handle expansion of media sets within the selection constraint. This improvement ensures controlled selection, prevents excessive memory usage, and provides a clear boundary for the number of selectable items across different media set scenarios."
38353,"@Override public void run(){
  mMenuTask=null;
  if (jc.isCancelled())   return;
  MenuExecutor.updateMenuOperation(mMenu,operation);
  MenuExecutor.updateMenuForPanorama(mMenu,supportCallback.mAllPanorama360,supportCallback.mHasPanorama360);
  if (mSharePanoramaMenuItem != null) {
    mSharePanoramaMenuItem.setEnabled(true);
    if (supportCallback.mAllPanorama360) {
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
    }
 else {
      mSharePanoramaMenuItem.setVisible(false);
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
    }
    mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
  }
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(true);
    mShareActionProvider.setShareIntent(share_intent);
  }
}","@Override public void run(){
  mMenuTask=null;
  if (jc.isCancelled())   return;
  MenuExecutor.updateMenuOperation(mMenu,operation);
  MenuExecutor.updateMenuForPanorama(mMenu,canSharePanoramas && supportCallback.mAllPanorama360,canSharePanoramas && supportCallback.mHasPanorama360);
  if (mSharePanoramaMenuItem != null) {
    mSharePanoramaMenuItem.setEnabled(true);
    if (canSharePanoramas && supportCallback.mAllPanorama360) {
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
    }
 else {
      mSharePanoramaMenuItem.setVisible(false);
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
    }
    mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
  }
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(canShare);
    mShareActionProvider.setShareIntent(share_intent);
  }
}","The original code lacked proper conditional checks for sharing panorama and regular menu items, potentially enabling sharing when it shouldn't be allowed. The fixed code introduces additional boolean flags `canSharePanoramas` and `canShare` to conditionally enable menu items and modify their behavior based on the current sharing capabilities. By adding these explicit permission checks, the code now provides more robust and context-aware menu state management, preventing unintended sharing actions and improving overall user interface control."
38354,"public void updateSupportedOperation(){
  if (mMenuTask != null)   mMenuTask.cancel();
  updateSelectionMenu();
  if (mSharePanoramaMenuItem != null)   mSharePanoramaMenuItem.setEnabled(false);
  if (mShareMenuItem != null)   mShareMenuItem.setEnabled(false);
  mMenuTask=mActivity.getThreadPool().submit(new Job<Void>(){
    @Override public Void run(    final JobContext jc){
      ArrayList<MediaObject> selected=getSelectedMediaObjects(jc);
      if (selected == null) {
        mMainHandler.post(new Runnable(){
          @Override public void run(){
            mMenuTask=null;
            if (jc.isCancelled())             return;
            MenuExecutor.updateMenuOperation(mMenu,0);
          }
        }
);
        return null;
      }
      final int operation=computeMenuOptions(selected);
      if (jc.isCancelled()) {
        return null;
      }
      final GetAllPanoramaSupports supportCallback=new GetAllPanoramaSupports(selected,jc);
      final Intent share_panorama_intent=computePanoramaSharingIntent(jc);
      final Intent share_intent=computeSharingIntent(jc);
      supportCallback.waitForPanoramaSupport();
      if (jc.isCancelled()) {
        return null;
      }
      mMainHandler.post(new Runnable(){
        @Override public void run(){
          mMenuTask=null;
          if (jc.isCancelled())           return;
          MenuExecutor.updateMenuOperation(mMenu,operation);
          MenuExecutor.updateMenuForPanorama(mMenu,supportCallback.mAllPanorama360,supportCallback.mHasPanorama360);
          if (mSharePanoramaMenuItem != null) {
            mSharePanoramaMenuItem.setEnabled(true);
            if (supportCallback.mAllPanorama360) {
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
            }
 else {
              mSharePanoramaMenuItem.setVisible(false);
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
            }
            mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
          }
          if (mShareMenuItem != null) {
            mShareMenuItem.setEnabled(true);
            mShareActionProvider.setShareIntent(share_intent);
          }
        }
      }
);
      return null;
    }
  }
);
}","public void updateSupportedOperation(){
  if (mMenuTask != null)   mMenuTask.cancel();
  updateSelectionMenu();
  if (mSharePanoramaMenuItem != null)   mSharePanoramaMenuItem.setEnabled(false);
  if (mShareMenuItem != null)   mShareMenuItem.setEnabled(false);
  mMenuTask=mActivity.getThreadPool().submit(new Job<Void>(){
    @Override public Void run(    final JobContext jc){
      ArrayList<MediaObject> selected=getSelectedMediaObjects(jc);
      if (selected == null) {
        mMainHandler.post(new Runnable(){
          @Override public void run(){
            mMenuTask=null;
            if (jc.isCancelled())             return;
            MenuExecutor.updateMenuOperation(mMenu,0);
          }
        }
);
        return null;
      }
      final int operation=computeMenuOptions(selected);
      if (jc.isCancelled()) {
        return null;
      }
      int numSelected=selected.size();
      final boolean canSharePanoramas=numSelected < MAX_SELECTED_ITEMS_FOR_PANORAMA_SHARE_INTENT;
      final boolean canShare=numSelected < MAX_SELECTED_ITEMS_FOR_SHARE_INTENT;
      final GetAllPanoramaSupports supportCallback=canSharePanoramas ? new GetAllPanoramaSupports(selected,jc) : null;
      final Intent share_panorama_intent=canSharePanoramas ? computePanoramaSharingIntent(jc,MAX_SELECTED_ITEMS_FOR_PANORAMA_SHARE_INTENT) : new Intent();
      final Intent share_intent=canShare ? computeSharingIntent(jc,MAX_SELECTED_ITEMS_FOR_SHARE_INTENT) : new Intent();
      if (canSharePanoramas) {
        supportCallback.waitForPanoramaSupport();
      }
      if (jc.isCancelled()) {
        return null;
      }
      mMainHandler.post(new Runnable(){
        @Override public void run(){
          mMenuTask=null;
          if (jc.isCancelled())           return;
          MenuExecutor.updateMenuOperation(mMenu,operation);
          MenuExecutor.updateMenuForPanorama(mMenu,canSharePanoramas && supportCallback.mAllPanorama360,canSharePanoramas && supportCallback.mHasPanorama360);
          if (mSharePanoramaMenuItem != null) {
            mSharePanoramaMenuItem.setEnabled(true);
            if (canSharePanoramas && supportCallback.mAllPanorama360) {
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
            }
 else {
              mSharePanoramaMenuItem.setVisible(false);
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
            }
            mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
          }
          if (mShareMenuItem != null) {
            mShareMenuItem.setEnabled(canShare);
            mShareActionProvider.setShareIntent(share_intent);
          }
        }
      }
);
      return null;
    }
  }
);
}","The original code lacked proper validation for the number of selected items when generating sharing intents, potentially causing performance issues or crashes. The fixed code introduces checks using `MAX_SELECTED_ITEMS_FOR_SHARE_INTENT` and `MAX_SELECTED_ITEMS_FOR_PANORAMA_SHARE_INTENT` to limit the number of items processed and conditionally create intents and panorama support callbacks. These changes improve robustness by preventing potential out-of-memory errors and ensuring more controlled sharing behavior across different media types."
38355,"private Intent computeSharingIntent(JobContext jc){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true);
  if (expandedPaths.size() == 0) {
    setNfcBeamPushUris(null);
    return null;
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  int type=0;
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    int support=manager.getSupportedOperations(path);
    type|=manager.getMediaType(path);
    if ((support & MediaObject.SUPPORT_SHARE) != 0) {
      uris.add(manager.getContentUri(path));
    }
  }
  final int size=uris.size();
  if (size > 0) {
    final String mimeType=MenuExecutor.getMimeType(type);
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE).setType(mimeType);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND).setType(mimeType);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    setNfcBeamPushUris(uris.toArray(new Uri[uris.size()]));
  }
 else {
    setNfcBeamPushUris(null);
  }
  return intent;
}","private Intent computeSharingIntent(JobContext jc,int maxItems){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true,maxItems);
  if (expandedPaths == null || expandedPaths.size() == 0) {
    setNfcBeamPushUris(null);
    return new Intent();
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  int type=0;
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    int support=manager.getSupportedOperations(path);
    type|=manager.getMediaType(path);
    if ((support & MediaObject.SUPPORT_SHARE) != 0) {
      uris.add(manager.getContentUri(path));
    }
  }
  final int size=uris.size();
  if (size > 0) {
    final String mimeType=MenuExecutor.getMimeType(type);
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE).setType(mimeType);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND).setType(mimeType);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    setNfcBeamPushUris(uris.toArray(new Uri[uris.size()]));
  }
 else {
    setNfcBeamPushUris(null);
  }
  return intent;
}","The original code lacks proper handling when no paths are selected, potentially returning null and causing potential null pointer exceptions. The fixed code adds a maxItems parameter to limit selection and returns an empty intent when no paths are found, ensuring robust error handling. This modification prevents unexpected runtime errors and provides a more predictable sharing intent generation process."
38356,"private Intent computePanoramaSharingIntent(JobContext jc){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true);
  if (expandedPaths.size() == 0) {
    return null;
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    uris.add(manager.getContentUri(path));
  }
  final int size=uris.size();
  if (size > 0) {
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
  }
  return intent;
}","private Intent computePanoramaSharingIntent(JobContext jc,int maxItems){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true,maxItems);
  if (expandedPaths == null || expandedPaths.size() == 0) {
    return new Intent();
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    uris.add(manager.getContentUri(path));
  }
  final int size=uris.size();
  if (size > 0) {
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
  }
  return intent;
}","The original code lacks error handling for edge cases, such as when no items are selected or when the selection might exceed a desired limit. The fixed code introduces a maxItems parameter to limit selection and returns an empty intent instead of null when no items are selected, improving robustness and preventing potential null pointer exceptions. These modifications make the method more resilient by gracefully handling different selection scenarios while maintaining the core sharing functionality."
38357,"private static void expandMediaSet(ArrayList<Path> items,MediaSet set){
  int subCount=set.getSubMediaSetCount();
  for (int i=0; i < subCount; i++) {
    expandMediaSet(items,set.getSubMediaSet(i));
  }
  int total=set.getMediaItemCount();
  int batch=50;
  int index=0;
  while (index < total) {
    int count=index + batch < total ? batch : total - index;
    ArrayList<MediaItem> list=set.getMediaItem(index,count);
    for (    MediaItem item : list) {
      items.add(item.getPath());
    }
    index+=batch;
  }
}","private static boolean expandMediaSet(ArrayList<Path> items,MediaSet set,int maxSelection){
  int subCount=set.getSubMediaSetCount();
  for (int i=0; i < subCount; i++) {
    if (!expandMediaSet(items,set.getSubMediaSet(i),maxSelection)) {
      return false;
    }
  }
  int total=set.getMediaItemCount();
  int batch=50;
  int index=0;
  while (index < total) {
    int count=index + batch < total ? batch : total - index;
    ArrayList<MediaItem> list=set.getMediaItem(index,count);
    if (list != null && list.size() > (maxSelection - items.size())) {
      return false;
    }
    for (    MediaItem item : list) {
      items.add(item.getPath());
    }
    index+=batch;
  }
  return true;
}","The original code lacks a mechanism to limit media item selection, potentially causing excessive memory consumption or performance issues when processing large media sets. The fixed code introduces a `maxSelection` parameter and recursive checks to prevent exceeding the selection limit, with added null checks and size validation for media item lists. This approach provides better control over resource usage and prevents potential out-of-memory scenarios by implementing a safeguard that stops expansion when the maximum selection is reached."
38358,"public ArrayList<Path> getSelected(boolean expandSet){
  ArrayList<Path> selected=new ArrayList<Path>();
  if (mIsAlbumSet) {
    if (mInverseSelection) {
      int total=getTotalCount();
      for (int i=0; i < total; i++) {
        MediaSet set=mSourceMediaSet.getSubMediaSet(i);
        Path id=set.getPath();
        if (!mClickedSet.contains(id)) {
          if (expandSet) {
            expandMediaSet(selected,set);
          }
 else {
            selected.add(id);
          }
        }
      }
    }
 else {
      for (      Path id : mClickedSet) {
        if (expandSet) {
          expandMediaSet(selected,mDataManager.getMediaSet(id));
        }
 else {
          selected.add(id);
        }
      }
    }
  }
 else {
    if (mInverseSelection) {
      int total=getTotalCount();
      int index=0;
      while (index < total) {
        int count=Math.min(total - index,MediaSet.MEDIAITEM_BATCH_FETCH_COUNT);
        ArrayList<MediaItem> list=mSourceMediaSet.getMediaItem(index,count);
        for (        MediaItem item : list) {
          Path id=item.getPath();
          if (!mClickedSet.contains(id))           selected.add(id);
        }
        index+=count;
      }
    }
 else {
      for (      Path id : mClickedSet) {
        selected.add(id);
      }
    }
  }
  return selected;
}","public ArrayList<Path> getSelected(boolean expandSet,int maxSelection){
  ArrayList<Path> selected=new ArrayList<Path>();
  if (mIsAlbumSet) {
    if (mInverseSelection) {
      int total=getTotalCount();
      for (int i=0; i < total; i++) {
        MediaSet set=mSourceMediaSet.getSubMediaSet(i);
        Path id=set.getPath();
        if (!mClickedSet.contains(id)) {
          if (expandSet && !expandMediaSet(selected,set,maxSelection)) {
            return null;
          }
 else {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
      }
    }
 else {
      for (      Path id : mClickedSet) {
        if (expandSet && !expandMediaSet(selected,mDataManager.getMediaSet(id),maxSelection)) {
          return null;
        }
 else {
          selected.add(id);
          if (selected.size() > maxSelection) {
            return null;
          }
        }
      }
    }
  }
 else {
    if (mInverseSelection) {
      int total=getTotalCount();
      int index=0;
      while (index < total) {
        int count=Math.min(total - index,MediaSet.MEDIAITEM_BATCH_FETCH_COUNT);
        ArrayList<MediaItem> list=mSourceMediaSet.getMediaItem(index,count);
        for (        MediaItem item : list) {
          Path id=item.getPath();
          if (!mClickedSet.contains(id)) {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
        index+=count;
      }
    }
 else {
      for (      Path id : mClickedSet) {
        selected.add(id);
        if (selected.size() > maxSelection) {
          return null;
        }
      }
    }
  }
  return selected;
}","The original code lacked a mechanism to limit the number of selected items, potentially causing memory overflow or performance issues. The fixed code introduces a `maxSelection` parameter and adds checks to return `null` if the selected items exceed this limit, preventing unbounded selection. This improvement ensures better resource management and provides a controlled selection process with a clear upper boundary."
38359,"@Override public void run(){
  mMenuTask=null;
  if (jc.isCancelled())   return;
  MenuExecutor.updateMenuOperation(mMenu,operation);
  MenuExecutor.updateMenuForPanorama(mMenu,supportCallback.mAllPanorama360,supportCallback.mHasPanorama360);
  if (mSharePanoramaMenuItem != null) {
    mSharePanoramaMenuItem.setEnabled(true);
    if (supportCallback.mAllPanorama360) {
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
    }
 else {
      mSharePanoramaMenuItem.setVisible(false);
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
    }
    mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
  }
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(true);
    mShareActionProvider.setShareIntent(share_intent);
  }
}","@Override public void run(){
  mMenuTask=null;
  if (jc.isCancelled())   return;
  MenuExecutor.updateMenuOperation(mMenu,operation);
  MenuExecutor.updateMenuForPanorama(mMenu,canSharePanoramas && supportCallback.mAllPanorama360,canSharePanoramas && supportCallback.mHasPanorama360);
  if (mSharePanoramaMenuItem != null) {
    mSharePanoramaMenuItem.setEnabled(true);
    if (canSharePanoramas && supportCallback.mAllPanorama360) {
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
    }
 else {
      mSharePanoramaMenuItem.setVisible(false);
      mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
      mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
    }
    mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
  }
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(canShare);
    mShareActionProvider.setShareIntent(share_intent);
  }
}","The original code lacked proper conditional checks for sharing panorama and regular menu items, potentially enabling sharing inappropriately. The fixed code introduces additional boolean flags (`canSharePanoramas`, `canShare`) to conditionally enable menu items and control their visibility based on specific sharing capabilities. These changes ensure more robust menu state management, preventing unintended sharing scenarios and providing better user interface control with context-aware menu interactions."
38360,"public void updateSupportedOperation(){
  if (mMenuTask != null)   mMenuTask.cancel();
  updateSelectionMenu();
  if (mSharePanoramaMenuItem != null)   mSharePanoramaMenuItem.setEnabled(false);
  if (mShareMenuItem != null)   mShareMenuItem.setEnabled(false);
  mMenuTask=mActivity.getThreadPool().submit(new Job<Void>(){
    @Override public Void run(    final JobContext jc){
      ArrayList<MediaObject> selected=getSelectedMediaObjects(jc);
      if (selected == null) {
        mMainHandler.post(new Runnable(){
          @Override public void run(){
            mMenuTask=null;
            if (jc.isCancelled())             return;
            MenuExecutor.updateMenuOperation(mMenu,0);
          }
        }
);
        return null;
      }
      final int operation=computeMenuOptions(selected);
      if (jc.isCancelled()) {
        return null;
      }
      final GetAllPanoramaSupports supportCallback=new GetAllPanoramaSupports(selected,jc);
      final Intent share_panorama_intent=computePanoramaSharingIntent(jc);
      final Intent share_intent=computeSharingIntent(jc);
      supportCallback.waitForPanoramaSupport();
      if (jc.isCancelled()) {
        return null;
      }
      mMainHandler.post(new Runnable(){
        @Override public void run(){
          mMenuTask=null;
          if (jc.isCancelled())           return;
          MenuExecutor.updateMenuOperation(mMenu,operation);
          MenuExecutor.updateMenuForPanorama(mMenu,supportCallback.mAllPanorama360,supportCallback.mHasPanorama360);
          if (mSharePanoramaMenuItem != null) {
            mSharePanoramaMenuItem.setEnabled(true);
            if (supportCallback.mAllPanorama360) {
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
            }
 else {
              mSharePanoramaMenuItem.setVisible(false);
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
            }
            mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
          }
          if (mShareMenuItem != null) {
            mShareMenuItem.setEnabled(true);
            mShareActionProvider.setShareIntent(share_intent);
          }
        }
      }
);
      return null;
    }
  }
);
}","public void updateSupportedOperation(){
  if (mMenuTask != null)   mMenuTask.cancel();
  updateSelectionMenu();
  if (mSharePanoramaMenuItem != null)   mSharePanoramaMenuItem.setEnabled(false);
  if (mShareMenuItem != null)   mShareMenuItem.setEnabled(false);
  mMenuTask=mActivity.getThreadPool().submit(new Job<Void>(){
    @Override public Void run(    final JobContext jc){
      ArrayList<MediaObject> selected=getSelectedMediaObjects(jc);
      if (selected == null) {
        mMainHandler.post(new Runnable(){
          @Override public void run(){
            mMenuTask=null;
            if (jc.isCancelled())             return;
            MenuExecutor.updateMenuOperation(mMenu,0);
          }
        }
);
        return null;
      }
      final int operation=computeMenuOptions(selected);
      if (jc.isCancelled()) {
        return null;
      }
      int numSelected=selected.size();
      final boolean canSharePanoramas=numSelected < MAX_SELECTED_ITEMS_FOR_PANORAMA_SHARE_INTENT;
      final boolean canShare=numSelected < MAX_SELECTED_ITEMS_FOR_SHARE_INTENT;
      final GetAllPanoramaSupports supportCallback=canSharePanoramas ? new GetAllPanoramaSupports(selected,jc) : null;
      final Intent share_panorama_intent=canSharePanoramas ? computePanoramaSharingIntent(jc,MAX_SELECTED_ITEMS_FOR_PANORAMA_SHARE_INTENT) : new Intent();
      final Intent share_intent=canShare ? computeSharingIntent(jc,MAX_SELECTED_ITEMS_FOR_SHARE_INTENT) : new Intent();
      if (canSharePanoramas) {
        supportCallback.waitForPanoramaSupport();
      }
      if (jc.isCancelled()) {
        return null;
      }
      mMainHandler.post(new Runnable(){
        @Override public void run(){
          mMenuTask=null;
          if (jc.isCancelled())           return;
          MenuExecutor.updateMenuOperation(mMenu,operation);
          MenuExecutor.updateMenuForPanorama(mMenu,canSharePanoramas && supportCallback.mAllPanorama360,canSharePanoramas && supportCallback.mHasPanorama360);
          if (mSharePanoramaMenuItem != null) {
            mSharePanoramaMenuItem.setEnabled(true);
            if (canSharePanoramas && supportCallback.mAllPanorama360) {
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share_as_photo));
            }
 else {
              mSharePanoramaMenuItem.setVisible(false);
              mShareMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
              mShareMenuItem.setTitle(mActivity.getResources().getString(R.string.share));
            }
            mSharePanoramaActionProvider.setShareIntent(share_panorama_intent);
          }
          if (mShareMenuItem != null) {
            mShareMenuItem.setEnabled(canShare);
            mShareActionProvider.setShareIntent(share_intent);
          }
        }
      }
);
      return null;
    }
  }
);
}","The original code lacked proper validation for the number of selected items when generating sharing intents, potentially causing performance issues or crashes. The fixed code introduces checks using MAX_SELECTED_ITEMS constants to limit the number of items for panorama and regular sharing intents, and conditionally creates and processes these intents. By adding these safeguards, the code now prevents potential memory overhead and ensures more robust handling of media object selections during sharing operations."
38361,"private Intent computeSharingIntent(JobContext jc){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true);
  if (expandedPaths.size() == 0) {
    setNfcBeamPushUris(null);
    return null;
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  int type=0;
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    int support=manager.getSupportedOperations(path);
    type|=manager.getMediaType(path);
    if ((support & MediaObject.SUPPORT_SHARE) != 0) {
      uris.add(manager.getContentUri(path));
    }
  }
  final int size=uris.size();
  if (size > 0) {
    final String mimeType=MenuExecutor.getMimeType(type);
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE).setType(mimeType);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND).setType(mimeType);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    setNfcBeamPushUris(uris.toArray(new Uri[uris.size()]));
  }
 else {
    setNfcBeamPushUris(null);
  }
  return intent;
}","private Intent computeSharingIntent(JobContext jc,int maxItems){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true,maxItems);
  if (expandedPaths == null || expandedPaths.size() == 0) {
    setNfcBeamPushUris(null);
    return new Intent();
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  int type=0;
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    int support=manager.getSupportedOperations(path);
    type|=manager.getMediaType(path);
    if ((support & MediaObject.SUPPORT_SHARE) != 0) {
      uris.add(manager.getContentUri(path));
    }
  }
  final int size=uris.size();
  if (size > 0) {
    final String mimeType=MenuExecutor.getMimeType(type);
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE).setType(mimeType);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND).setType(mimeType);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    setNfcBeamPushUris(uris.toArray(new Uri[uris.size()]));
  }
 else {
    setNfcBeamPushUris(null);
  }
  return intent;
}","The original code lacked proper handling when no items were selected, potentially returning null and causing potential null pointer exceptions. The fixed code adds a maxItems parameter to limit selection, checks for null or empty path list, and returns an empty intent instead of null when no items are available. These modifications enhance robustness by preventing null returns and providing a safe default intent, improving the method's reliability and error handling."
38362,"private Intent computePanoramaSharingIntent(JobContext jc){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true);
  if (expandedPaths.size() == 0) {
    return null;
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    uris.add(manager.getContentUri(path));
  }
  final int size=uris.size();
  if (size > 0) {
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
  }
  return intent;
}","private Intent computePanoramaSharingIntent(JobContext jc,int maxItems){
  ArrayList<Path> expandedPaths=mSelectionManager.getSelected(true,maxItems);
  if (expandedPaths == null || expandedPaths.size() == 0) {
    return new Intent();
  }
  final ArrayList<Uri> uris=new ArrayList<Uri>();
  DataManager manager=mActivity.getDataManager();
  final Intent intent=new Intent();
  for (  Path path : expandedPaths) {
    if (jc.isCancelled())     return null;
    uris.add(manager.getContentUri(path));
  }
  final int size=uris.size();
  if (size > 0) {
    if (size > 1) {
      intent.setAction(Intent.ACTION_SEND_MULTIPLE);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,uris);
    }
 else {
      intent.setAction(Intent.ACTION_SEND);
      intent.setType(GalleryUtils.MIME_TYPE_PANORAMA360);
      intent.putExtra(Intent.EXTRA_STREAM,uris.get(0));
    }
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
  }
  return intent;
}","The original code lacks a mechanism to limit the number of selected items, potentially causing performance issues or memory overflow when sharing multiple panoramas. The fixed code introduces a `maxItems` parameter to `getSelected()`, ensuring a controlled selection and adding a null check to prevent potential null pointer exceptions. This modification improves robustness by preventing unintended large-scale sharing and providing a more predictable sharing experience with a configurable item limit."
38363,"private static void expandMediaSet(ArrayList<Path> items,MediaSet set){
  int subCount=set.getSubMediaSetCount();
  for (int i=0; i < subCount; i++) {
    expandMediaSet(items,set.getSubMediaSet(i));
  }
  int total=set.getMediaItemCount();
  int batch=50;
  int index=0;
  while (index < total) {
    int count=index + batch < total ? batch : total - index;
    ArrayList<MediaItem> list=set.getMediaItem(index,count);
    for (    MediaItem item : list) {
      items.add(item.getPath());
    }
    index+=batch;
  }
}","private static boolean expandMediaSet(ArrayList<Path> items,MediaSet set,int maxSelection){
  int subCount=set.getSubMediaSetCount();
  for (int i=0; i < subCount; i++) {
    if (!expandMediaSet(items,set.getSubMediaSet(i),maxSelection)) {
      return false;
    }
  }
  int total=set.getMediaItemCount();
  int batch=50;
  int index=0;
  while (index < total) {
    int count=index + batch < total ? batch : total - index;
    ArrayList<MediaItem> list=set.getMediaItem(index,count);
    if (list != null && list.size() > (maxSelection - items.size())) {
      return false;
    }
    for (    MediaItem item : list) {
      items.add(item.getPath());
    }
    index+=batch;
  }
  return true;
}","The original code lacks a mechanism to limit media item selection, potentially causing excessive memory consumption or performance issues when processing large media sets. The fixed code introduces a `maxSelection` parameter and recursive checks to prevent exceeding the maximum allowed items, with added null list validation and early termination. This improvement ensures controlled media set expansion, preventing unbounded growth and providing a safeguard against potential out-of-memory scenarios or excessive processing."
38364,"public ArrayList<Path> getSelected(boolean expandSet){
  ArrayList<Path> selected=new ArrayList<Path>();
  if (mIsAlbumSet) {
    if (mInverseSelection) {
      int total=getTotalCount();
      for (int i=0; i < total; i++) {
        MediaSet set=mSourceMediaSet.getSubMediaSet(i);
        Path id=set.getPath();
        if (!mClickedSet.contains(id)) {
          if (expandSet) {
            expandMediaSet(selected,set);
          }
 else {
            selected.add(id);
          }
        }
      }
    }
 else {
      for (      Path id : mClickedSet) {
        if (expandSet) {
          expandMediaSet(selected,mDataManager.getMediaSet(id));
        }
 else {
          selected.add(id);
        }
      }
    }
  }
 else {
    if (mInverseSelection) {
      int total=getTotalCount();
      int index=0;
      while (index < total) {
        int count=Math.min(total - index,MediaSet.MEDIAITEM_BATCH_FETCH_COUNT);
        ArrayList<MediaItem> list=mSourceMediaSet.getMediaItem(index,count);
        for (        MediaItem item : list) {
          Path id=item.getPath();
          if (!mClickedSet.contains(id))           selected.add(id);
        }
        index+=count;
      }
    }
 else {
      for (      Path id : mClickedSet) {
        selected.add(id);
      }
    }
  }
  return selected;
}","public ArrayList<Path> getSelected(boolean expandSet,int maxSelection){
  ArrayList<Path> selected=new ArrayList<Path>();
  if (mIsAlbumSet) {
    if (mInverseSelection) {
      int total=getTotalCount();
      for (int i=0; i < total; i++) {
        MediaSet set=mSourceMediaSet.getSubMediaSet(i);
        Path id=set.getPath();
        if (!mClickedSet.contains(id)) {
          if (expandSet && !expandMediaSet(selected,set,maxSelection)) {
            return null;
          }
 else {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
      }
    }
 else {
      for (      Path id : mClickedSet) {
        if (expandSet && !expandMediaSet(selected,mDataManager.getMediaSet(id),maxSelection)) {
          return null;
        }
 else {
          selected.add(id);
          if (selected.size() > maxSelection) {
            return null;
          }
        }
      }
    }
  }
 else {
    if (mInverseSelection) {
      int total=getTotalCount();
      int index=0;
      while (index < total) {
        int count=Math.min(total - index,MediaSet.MEDIAITEM_BATCH_FETCH_COUNT);
        ArrayList<MediaItem> list=mSourceMediaSet.getMediaItem(index,count);
        for (        MediaItem item : list) {
          Path id=item.getPath();
          if (!mClickedSet.contains(id)) {
            selected.add(id);
            if (selected.size() > maxSelection) {
              return null;
            }
          }
        }
        index+=count;
      }
    }
 else {
      for (      Path id : mClickedSet) {
        selected.add(id);
        if (selected.size() > maxSelection) {
          return null;
        }
      }
    }
  }
  return selected;
}","The original code lacked a mechanism to limit the number of selected items, potentially allowing unbounded selection. The fixed code introduces a `maxSelection` parameter and adds checks to return `null` if the selected items exceed this limit, with additional logic to handle expansion of media sets within the selection limit. This modification prevents excessive memory usage and provides a controlled selection process, improving the method's robustness and preventing potential performance issues."
38365,"public synchronized Bitmap renderGeometryIcon(Bitmap bitmap,ImagePreset preset){
synchronized (CachingPipeline.class) {
    if (getRenderScriptContext() == null) {
      return bitmap;
    }
    setupEnvironment(preset,false);
    mEnvironment.setQuality(ImagePreset.QUALITY_PREVIEW);
    bitmap=preset.applyGeometry(bitmap,mEnvironment);
    return bitmap;
  }
}","public Bitmap renderGeometryIcon(Bitmap bitmap,ImagePreset preset){
  if (mGeometry == null) {
    mGeometry=new ImageFilterGeometry();
  }
  mGeometry.useRepresentation(preset.getGeometry());
  return mGeometry.apply(bitmap,mPreviewScaleFactor,ImagePreset.QUALITY_PREVIEW);
}","The original code has unnecessary nested synchronization and redundant setup, potentially causing performance overhead and complexity. The fixed code replaces the complex synchronization and environment setup with a direct, lightweight geometry application using a dedicated geometry object and preset parameters. This approach simplifies the method, reduces synchronization complexity, and provides a more efficient and straightforward way to render geometry icons."
38366,"@Override public FilterRepresentation clone() throws CloneNotSupportedException {
  FilterRepresentation representation=(FilterRepresentation)super.clone();
  representation.setName(getName());
  representation.setPriority(getPriority());
  representation.setFilterClass(getFilterClass());
  representation.setSupportsPartialRendering(supportsPartialRendering());
  representation.setTextId(getTextId());
  representation.setEditorId(getEditorId());
  representation.setButtonId(getButtonId());
  representation.setOverlayId(getOverlayId());
  representation.setOverlayOnly(getOverlayOnly());
  representation.setShowEditingControls(showEditingControls());
  representation.setShowParameterValue(showParameterValue());
  representation.setShowUtilityPanel(showUtilityPanel());
  representation.mTempRepresentation=null;
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + this + ""String_Node_Str""+ representation+ ""String_Node_Str"");
  }
  return representation;
}","@Override public FilterRepresentation clone() throws CloneNotSupportedException {
  FilterRepresentation representation=(FilterRepresentation)super.clone();
  representation.setName(getName());
  representation.setPriority(getPriority());
  representation.setFilterClass(getFilterClass());
  representation.setSupportsPartialRendering(supportsPartialRendering());
  representation.setTextId(getTextId());
  representation.setEditorId(getEditorId());
  representation.setButtonId(getButtonId());
  representation.setOverlayId(getOverlayId());
  representation.setOverlayOnly(getOverlayOnly());
  representation.setShowEditingControls(showEditingControls());
  representation.setShowParameterValue(showParameterValue());
  representation.setShowUtilityPanel(showUtilityPanel());
  representation.mTempRepresentation=mTempRepresentation != null ? mTempRepresentation.clone() : null;
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + this + ""String_Node_Str""+ representation+ ""String_Node_Str"");
  }
  return representation;
}","The original code simply set `mTempRepresentation` to null, potentially losing important temporary data during cloning. The fixed code adds a deep clone of `mTempRepresentation` by checking if it exists and creating a clone if it does, preserving the original object's state. This approach ensures a more robust and complete cloning process, maintaining the integrity of nested objects and preventing unintended data loss."
38367,"@Override public boolean handleMessage(Message msg){
  if (!mPipelineIsOn) {
    return false;
  }
switch (msg.what) {
case COMPUTE_PRESET:
{
      ImagePreset preset=(ImagePreset)msg.obj;
      TripleBufferBitmap buffer=MasterImage.getImage().getDoubleBuffer();
      mPreviewPipeline.compute(buffer,preset,COMPUTE_PRESET);
      buffer.swapProducer();
      Message uimsg=mUIHandler.obtainMessage(NEW_PRESET);
      mUIHandler.sendMessage(uimsg);
      break;
    }
case COMPUTE_RENDERING_REQUEST:
case COMPUTE_PARTIAL_RENDERING_REQUEST:
case COMPUTE_HIGHRES_RENDERING_REQUEST:
{
    if (msg.what == COMPUTE_PARTIAL_RENDERING_REQUEST || msg.what == COMPUTE_HIGHRES_RENDERING_REQUEST) {
      if (mProcessingHandler.hasMessages(msg.what)) {
        return false;
      }
    }
    if (DEBUG) {
      Log.v(LOGTAG,""String_Node_Str"" + getType(msg.what));
    }
    RenderingRequest request=(RenderingRequest)msg.obj;
    mAccessoryPipeline.render(request);
    Message uimsg=mUIHandler.obtainMessage(NEW_RENDERING_REQUEST);
    uimsg.obj=request;
    mUIHandler.sendMessage(uimsg);
    break;
  }
}
return false;
}","@Override public boolean handleMessage(Message msg){
  if (!mPipelineIsOn) {
    return false;
  }
switch (msg.what) {
case COMPUTE_PRESET:
{
      ImagePreset preset=(ImagePreset)msg.obj;
      TripleBufferBitmap buffer=MasterImage.getImage().getDoubleBuffer();
      mPreviewPipeline.compute(buffer,preset,COMPUTE_PRESET);
      buffer.swapProducer();
      Message uimsg=mUIHandler.obtainMessage(NEW_PRESET);
      mUIHandler.sendMessage(uimsg);
      break;
    }
case COMPUTE_RENDERING_REQUEST:
case COMPUTE_PARTIAL_RENDERING_REQUEST:
case COMPUTE_HIGHRES_RENDERING_REQUEST:
{
    if (DEBUG) {
      Log.v(LOGTAG,""String_Node_Str"" + getType(msg.what));
    }
    RenderingRequest request=(RenderingRequest)msg.obj;
    mAccessoryPipeline.render(request);
    Message uimsg=mUIHandler.obtainMessage(NEW_RENDERING_REQUEST);
    uimsg.obj=request;
    mUIHandler.sendMessage(uimsg);
    break;
  }
}
return false;
}","The original code unnecessarily added a redundant condition checking for pending messages in the processing handler, which could prematurely block rendering requests. The fixed code removes this unnecessary check, allowing all rendering requests to be processed without additional filtering. This simplifies the message handling logic and ensures that rendering requests are consistently processed, improving the overall pipeline performance and responsiveness."
38368,"public void postRenderingRequest(RenderingRequest request){
  if (!mPipelineIsOn) {
    return;
  }
  int type=COMPUTE_RENDERING_REQUEST;
  if (request.getType() == RenderingRequest.PARTIAL_RENDERING) {
    type=COMPUTE_PARTIAL_RENDERING_REQUEST;
  }
  if (request.getType() == RenderingRequest.HIGHRES_RENDERING) {
    type=COMPUTE_HIGHRES_RENDERING_REQUEST;
  }
  Message msg=mProcessingHandler.obtainMessage(type);
  msg.obj=request;
  if (type == COMPUTE_PARTIAL_RENDERING_REQUEST || type == COMPUTE_HIGHRES_RENDERING_REQUEST) {
    mProcessingHandler.sendMessageDelayed(msg,HIRES_DELAY);
  }
 else {
    mProcessingHandler.sendMessage(msg);
  }
}","public void postRenderingRequest(RenderingRequest request){
  if (!mPipelineIsOn) {
    return;
  }
  int type=COMPUTE_RENDERING_REQUEST;
  if (request.getType() == RenderingRequest.PARTIAL_RENDERING) {
    type=COMPUTE_PARTIAL_RENDERING_REQUEST;
  }
  if (request.getType() == RenderingRequest.HIGHRES_RENDERING) {
    type=COMPUTE_HIGHRES_RENDERING_REQUEST;
  }
  Message msg=mProcessingHandler.obtainMessage(type);
  msg.obj=request;
  if (type == COMPUTE_PARTIAL_RENDERING_REQUEST || type == COMPUTE_HIGHRES_RENDERING_REQUEST) {
    if (mProcessingHandler.hasMessages(msg.what)) {
      mProcessingHandler.removeMessages(msg.what);
    }
    mProcessingHandler.sendMessageDelayed(msg,HIRES_DELAY);
  }
 else {
    mProcessingHandler.sendMessage(msg);
  }
}","The original code lacks handling for duplicate rendering requests, potentially causing multiple delayed messages for partial or high-resolution rendering to accumulate in the message queue. The fixed code adds a check using `hasMessages()` to remove any existing messages of the same type before sending a new delayed message, preventing message queue buildup. This modification ensures more efficient and predictable message processing by eliminating redundant rendering requests."
38369,"@Override public FilterRepresentation clone() throws CloneNotSupportedException {
  FilterRepresentation representation=(FilterRepresentation)super.clone();
  representation.setName(getName());
  representation.setPriority(getPriority());
  representation.setFilterClass(getFilterClass());
  representation.setSupportsPartialRendering(supportsPartialRendering());
  representation.setTextId(getTextId());
  representation.setEditorId(getEditorId());
  representation.setButtonId(getButtonId());
  representation.setOverlayId(getOverlayId());
  representation.setOverlayOnly(getOverlayOnly());
  representation.setShowEditingControls(showEditingControls());
  representation.setShowParameterValue(showParameterValue());
  representation.setShowUtilityPanel(showUtilityPanel());
  representation.mTempRepresentation=null;
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + this + ""String_Node_Str""+ representation+ ""String_Node_Str"");
  }
  return representation;
}","@Override public FilterRepresentation clone() throws CloneNotSupportedException {
  FilterRepresentation representation=(FilterRepresentation)super.clone();
  representation.setName(getName());
  representation.setPriority(getPriority());
  representation.setFilterClass(getFilterClass());
  representation.setSupportsPartialRendering(supportsPartialRendering());
  representation.setTextId(getTextId());
  representation.setEditorId(getEditorId());
  representation.setButtonId(getButtonId());
  representation.setOverlayId(getOverlayId());
  representation.setOverlayOnly(getOverlayOnly());
  representation.setShowEditingControls(showEditingControls());
  representation.setShowParameterValue(showParameterValue());
  representation.setShowUtilityPanel(showUtilityPanel());
  representation.mTempRepresentation=mTempRepresentation != null ? mTempRepresentation.clone() : null;
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + this + ""String_Node_Str""+ representation+ ""String_Node_Str"");
  }
  return representation;
}","The original code simply set `mTempRepresentation` to null, potentially losing important reference data during cloning. The fixed code adds a null-safe deep clone of `mTempRepresentation`, creating a new instance if the original is not null. This ensures that complex nested objects are properly duplicated, maintaining data integrity and preventing unintended side effects during object cloning."
38370,"@Override protected void onPostExecute(Boolean result){
  if (isCancelled()) {
    return;
  }
  if (!result) {
    cannotLoadImage();
  }
  final View loading=findViewById(R.id.loading);
  loading.setVisibility(View.GONE);
  final View filters=findViewById(R.id.filtersPanel);
  filters.setVisibility(View.VISIBLE);
  if (PanelController.useAnimationsLayer()) {
    float y=filters.getY();
    filters.setY(y + filters.getHeight());
    filters.animate().setDuration(600).y(y).withLayer().start();
  }
  final View imageShow=findViewById(R.id.imageShow);
  imageShow.setVisibility(View.VISIBLE);
  Bitmap largeBitmap=mImageLoader.getOriginalBitmapLarge();
  FilteringPipeline pipeline=FilteringPipeline.getPipeline();
  pipeline.setOriginal(largeBitmap);
  float previewScale=(float)largeBitmap.getWidth() / (float)mImageLoader.getOriginalBounds().width();
  pipeline.setPreviewScaleFactor(previewScale);
  MasterImage.getImage().setOriginalGeometry(largeBitmap);
  mLoadBitmapTask=null;
  if (mAction == CROP_ACTION) {
    mPanelController.showComponent(findViewById(EditorCrop.ID));
  }
 else   if (mAction == TINY_PLANET_ACTION) {
    mPanelController.showComponent(findViewById(EditorTinyPlanet.ID));
  }
  pipeline.turnOnPipeline(true);
  super.onPostExecute(result);
}","@Override protected void onPostExecute(Boolean result){
  if (isCancelled()) {
    return;
  }
  if (!result) {
    cannotLoadImage();
  }
  final View loading=findViewById(R.id.loading);
  loading.setVisibility(View.GONE);
  final View filters=findViewById(R.id.filtersPanel);
  filters.setVisibility(View.VISIBLE);
  if (PanelController.useAnimationsLayer()) {
    float y=filters.getY();
    filters.setY(y + filters.getHeight());
    filters.animate().setDuration(600).y(y).withLayer().start();
  }
  final View imageShow=findViewById(R.id.imageShow);
  imageShow.setVisibility(View.VISIBLE);
  Bitmap largeBitmap=mImageLoader.getOriginalBitmapLarge();
  FilteringPipeline pipeline=FilteringPipeline.getPipeline();
  pipeline.setOriginal(largeBitmap);
  float previewScale=(float)largeBitmap.getWidth() / (float)mImageLoader.getOriginalBounds().width();
  pipeline.setPreviewScaleFactor(previewScale);
  pipeline.turnOnPipeline(true);
  MasterImage.getImage().setOriginalGeometry(largeBitmap);
  mLoadBitmapTask=null;
  if (mAction == CROP_ACTION) {
    mPanelController.showComponent(findViewById(EditorCrop.ID));
  }
 else   if (mAction == TINY_PLANET_ACTION) {
    mPanelController.showComponent(findViewById(EditorTinyPlanet.ID));
  }
  super.onPostExecute(result);
}","The original code called `pipeline.turnOnPipeline(true)` after setting `MasterImage.getImage().setOriginalGeometry(largeBitmap)`, which could potentially cause race conditions or incorrect pipeline initialization. In the fixed code, `pipeline.turnOnPipeline(true)` is moved before setting the original geometry, ensuring proper pipeline setup before image processing. This change guarantees a more reliable and predictable sequence of operations when loading and preparing the image for editing."
38371,"public void postRenderingRequest(RenderingRequest request){
  if (mOriginalAllocation == null) {
    return;
  }
  int type=COMPUTE_RENDERING_REQUEST;
  if (request.getType() == RenderingRequest.PARTIAL_RENDERING) {
    type=COMPUTE_PARTIAL_RENDERING_REQUEST;
  }
  Message msg=mProcessingHandler.obtainMessage(type);
  msg.obj=request;
  if (type == COMPUTE_PARTIAL_RENDERING_REQUEST) {
    mProcessingHandler.sendMessageDelayed(msg,HIRES_DELAY);
  }
 else {
    mProcessingHandler.sendMessage(msg);
  }
}","public void postRenderingRequest(RenderingRequest request){
  if (mOriginalAllocation == null) {
    return;
  }
  if (!mPipelineIsOn) {
    return;
  }
  int type=COMPUTE_RENDERING_REQUEST;
  if (request.getType() == RenderingRequest.PARTIAL_RENDERING) {
    type=COMPUTE_PARTIAL_RENDERING_REQUEST;
  }
  Message msg=mProcessingHandler.obtainMessage(type);
  msg.obj=request;
  if (type == COMPUTE_PARTIAL_RENDERING_REQUEST) {
    mProcessingHandler.sendMessageDelayed(msg,HIRES_DELAY);
  }
 else {
    mProcessingHandler.sendMessage(msg);
  }
}","The original code lacks a check to prevent sending rendering requests when the processing pipeline is inactive, potentially causing unexpected behavior or errors. The fixed code adds an explicit `!mPipelineIsOn` check before proceeding with message creation and sending, ensuring requests are only processed when the pipeline is operational. This modification enhances robustness by preventing potential null pointer exceptions or inappropriate message dispatching during system state transitions."
38372,"@Override public boolean equals(FilterRepresentation o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  GeometryMetadata d=(GeometryMetadata)o;
  return (mScaleFactor == d.mScaleFactor && mRotation == d.mRotation && mStraightenRotation == d.mStraightenRotation && mFlip == d.mFlip && mCropBounds.equals(d.mCropBounds) && mPhotoBounds.equals(d.mPhotoBounds));
}","@Override public boolean equals(FilterRepresentation o){
  if (this == o)   return true;
  if (o == null || !(o instanceof GeometryMetadata))   return false;
  GeometryMetadata d=(GeometryMetadata)o;
  return (mScaleFactor == d.mScaleFactor && mRotation == d.mRotation && mStraightenRotation == d.mStraightenRotation && mFlip == d.mFlip && compareRectF(mCropBounds,d.mCropBounds) && compareRectF(mPhotoBounds,d.mPhotoBounds));
}","The original code incorrectly uses `getClass()` comparison and direct `equals()` on RectF objects, which can lead to unexpected behavior and potential null pointer exceptions. The fixed code uses `instanceof` for type checking and introduces a custom `compareRectF()` method to safely compare RectF objects, handling potential null cases and ensuring accurate comparison. These changes improve type safety, prevent potential runtime errors, and provide a more robust equality comparison for GeometryMetadata objects."
38373,"public Allocation getInPixelsAllocation(){
  return mInPixelsAllocation;
}","public synchronized Allocation getInPixelsAllocation(){
  return mInPixelsAllocation;
}","The original code lacks thread synchronization, potentially causing race conditions when multiple threads access the `mInPixelsAllocation` concurrently. By adding the `synchronized` keyword, the method becomes thread-safe, ensuring that only one thread can access the method at a time. This prevents potential data inconsistencies and race conditions, making the getter method more robust in multi-threaded environments."
38374,"private synchronized void destroyPixelAllocations(){
  if (mInPixelsAllocation != null) {
    mInPixelsAllocation.destroy();
    mInPixelsAllocation=null;
  }
  if (mOutPixelsAllocation != null) {
    mOutPixelsAllocation.destroy();
    mOutPixelsAllocation=null;
  }
  mWidth=0;
  mHeight=0;
}","private synchronized void destroyPixelAllocations(){
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + getName());
  }
  if (mInPixelsAllocation != null) {
    mInPixelsAllocation.destroy();
    mInPixelsAllocation=null;
  }
  if (mOutPixelsAllocation != null) {
    mOutPixelsAllocation.destroy();
    mOutPixelsAllocation=null;
  }
  mWidth=0;
  mHeight=0;
}","The original code lacks debugging visibility, making it difficult to track method execution and diagnose potential issues. The fixed code adds a debug logging statement using a conditional DEBUG flag, which enables optional verbose logging of the method's invocation with the node's name. This enhancement provides better traceability and diagnostic capabilities without affecting the core functionality of destroying pixel allocations, allowing developers to gain insights into the method's behavior during development and troubleshooting."
38375,"public Allocation getOutPixelsAllocation(){
  return mOutPixelsAllocation;
}","public synchronized Allocation getOutPixelsAllocation(){
  return mOutPixelsAllocation;
}","The original code lacks thread synchronization, potentially causing race conditions when multiple threads access the `mOutPixelsAllocation` concurrently. By adding the `synchronized` keyword, the method becomes thread-safe, ensuring that only one thread can access the method at a time. This prevents potential data corruption and ensures consistent, predictable behavior in multi-threaded environments."
38376,"public CachingPipeline(FiltersManager filtersManager){
  mFiltersManager=filtersManager;
}","public CachingPipeline(FiltersManager filtersManager,String name){
  mFiltersManager=filtersManager;
  mName=name;
}","The original code lacks a name parameter, which may limit the pipeline's identification and customization capabilities. The fixed code introduces a `name` parameter in the constructor, allowing each pipeline instance to have a unique identifier and enabling more flexible configuration. This enhancement improves the class's versatility by providing a way to distinguish and label different pipeline instances more precisely."
38377,"public boolean prepareRenderscriptAllocations(Bitmap bitmap){
  RenderScript RS=ImageFilterRS.getRenderScriptContext();
  boolean needsUpdate=false;
  if (mOutPixelsAllocation == null || mInPixelsAllocation == null || bitmap.getWidth() != mWidth || bitmap.getHeight() != mHeight) {
    destroyPixelAllocations();
    Bitmap bitmapBuffer=bitmap;
    if (bitmap.getConfig() == null || bitmap.getConfig() != BITMAP_CONFIG) {
      bitmapBuffer=bitmap.copy(BITMAP_CONFIG,true);
    }
    mOutPixelsAllocation=Allocation.createFromBitmap(RS,bitmapBuffer,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SCRIPT);
    mInPixelsAllocation=Allocation.createTyped(RS,mOutPixelsAllocation.getType());
    needsUpdate=true;
  }
  mInPixelsAllocation.copyFrom(bitmap);
  if (bitmap.getWidth() != mWidth || bitmap.getHeight() != mHeight) {
    mWidth=bitmap.getWidth();
    mHeight=bitmap.getHeight();
    needsUpdate=true;
  }
  return needsUpdate;
}","public boolean prepareRenderscriptAllocations(Bitmap bitmap){
  RenderScript RS=ImageFilterRS.getRenderScriptContext();
  boolean needsUpdate=false;
  if (mOutPixelsAllocation == null || mInPixelsAllocation == null || bitmap.getWidth() != mWidth || bitmap.getHeight() != mHeight) {
    destroyPixelAllocations();
    Bitmap bitmapBuffer=bitmap;
    if (bitmap.getConfig() == null || bitmap.getConfig() != BITMAP_CONFIG) {
      bitmapBuffer=bitmap.copy(BITMAP_CONFIG,true);
    }
    mOutPixelsAllocation=Allocation.createFromBitmap(RS,bitmapBuffer,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SCRIPT);
    mInPixelsAllocation=Allocation.createTyped(RS,mOutPixelsAllocation.getType());
    needsUpdate=true;
  }
  mInPixelsAllocation.copyFrom(bitmap);
  if (bitmap.getWidth() != mWidth || bitmap.getHeight() != mHeight) {
    mWidth=bitmap.getWidth();
    mHeight=bitmap.getHeight();
    needsUpdate=true;
  }
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + needsUpdate + ""String_Node_Str""+ getName());
  }
  return needsUpdate;
}","The original code lacked proper logging for debugging purposes, making it difficult to track allocation and bitmap processing states. The fixed code adds a debug logging statement using a conditional DEBUG flag, which logs the needsUpdate status and the node's name, providing visibility into the allocation preparation process. This enhancement improves code maintainability by enabling developers to trace the method's behavior during runtime, especially when troubleshooting bitmap and RenderScript allocation issues."
38378,"private FilteringPipeline(){
  mHandlerThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_FOREGROUND);
  mHandlerThread.start();
  mProcessingHandler=new Handler(mHandlerThread.getLooper(),this);
  mAccessoryPipeline=new CachingPipeline(FiltersManager.getManager());
  mPreviewPipeline=new CachingPipeline(FiltersManager.getPreviewManager());
}","private FilteringPipeline(){
  mHandlerThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_FOREGROUND);
  mHandlerThread.start();
  mProcessingHandler=new Handler(mHandlerThread.getLooper(),this);
  mAccessoryPipeline=new CachingPipeline(FiltersManager.getManager(),""String_Node_Str"");
  mPreviewPipeline=new CachingPipeline(FiltersManager.getPreviewManager(),""String_Node_Str"");
}","The original code omitted a required string parameter when creating CachingPipeline instances, which could lead to potential initialization errors or unexpected behavior. The fixed code adds the ""String_Node_Str"" parameter to both CachingPipeline constructors, ensuring proper initialization and maintaining consistency with the HandlerThread naming. This modification provides a more robust and predictable pipeline creation process, preventing potential runtime issues related to incomplete object initialization."
38379,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (getParameters() == null || mResources == null) {
    return bitmap;
  }
  int w=bitmap.getWidth();
  int h=bitmap.getHeight();
  if (mFxBitmap == null || mFxBitmapId != getParameters().getBitmapResource()) {
    BitmapFactory.Options o=new BitmapFactory.Options();
    o.inScaled=false;
    mFxBitmapId=getParameters().getBitmapResource();
    if (mFxBitmapId != 0) {
      mFxBitmap=BitmapFactory.decodeResource(mResources,mFxBitmapId,o);
    }
 else {
      Log.w(LOGTAG,""String_Node_Str"" + mName);
    }
  }
  if (mFxBitmap == null) {
    return bitmap;
  }
  int fxw=mFxBitmap.getWidth();
  int fxh=mFxBitmap.getHeight();
  nativeApplyFilter(bitmap,w,h,mFxBitmap,fxw,fxh);
  return bitmap;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (getParameters() == null || mResources == null) {
    return bitmap;
  }
  int w=bitmap.getWidth();
  int h=bitmap.getHeight();
  int bitmapResourceId=getParameters().getBitmapResource();
  if (bitmapResourceId == 0) {
    return bitmap;
  }
  if (mFxBitmap == null || mFxBitmapId != bitmapResourceId) {
    BitmapFactory.Options o=new BitmapFactory.Options();
    o.inScaled=false;
    mFxBitmapId=bitmapResourceId;
    if (mFxBitmapId != 0) {
      mFxBitmap=BitmapFactory.decodeResource(mResources,mFxBitmapId,o);
    }
 else {
      Log.w(LOGTAG,""String_Node_Str"" + mName);
    }
  }
  if (mFxBitmap == null) {
    return bitmap;
  }
  int fxw=mFxBitmap.getWidth();
  int fxh=mFxBitmap.getHeight();
  nativeApplyFilter(bitmap,w,h,mFxBitmap,fxw,fxh);
  return bitmap;
}","The original code lacks proper handling of invalid bitmap resource IDs, potentially leading to unnecessary processing and potential null pointer exceptions. The fixed code introduces an early check for zero bitmap resource ID and extracts the ID into a separate variable, ensuring more robust and predictable bitmap loading behavior. These changes improve error handling, reduce redundant bitmap decoding, and provide a clearer, more defensive approach to resource management."
38380,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null || bitmap.getWidth() == 0 || bitmap.getHeight() == 0) {
    return bitmap;
  }
  try {
synchronized (ImageFilterRS.class) {
      if (sRS == null) {
        Log.w(LOGTAG,""String_Node_Str"");
        return bitmap;
      }
      CachingPipeline pipeline=getEnvironment().getCachingPipeline();
      boolean needsUpdate=pipeline.prepareRenderscriptAllocations(bitmap);
      if (needsUpdate || !isResourcesLoaded()) {
        freeResources();
        createFilter(sResources,scaleFactor,quality);
        setResourcesLoaded(true);
      }
      runFilter();
      update(bitmap);
    }
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  java.lang.OutOfMemoryError e) {
    System.gc();
    displayLowMemoryToast();
    Log.e(LOGTAG,""String_Node_Str"" + getName(),e);
  }
  return bitmap;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null || bitmap.getWidth() == 0 || bitmap.getHeight() == 0) {
    return bitmap;
  }
  try {
synchronized (ImageFilterRS.class) {
      if (sRS == null) {
        Log.w(LOGTAG,""String_Node_Str"");
        return bitmap;
      }
      CachingPipeline pipeline=getEnvironment().getCachingPipeline();
      if (DEBUG) {
        Log.v(LOGTAG,""String_Node_Str"" + getName() + ""String_Node_Str""+ pipeline.getName());
      }
      boolean needsUpdate=pipeline.prepareRenderscriptAllocations(bitmap);
      if (needsUpdate || !isResourcesLoaded()) {
        freeResources();
        createFilter(sResources,scaleFactor,quality);
        setResourcesLoaded(true);
      }
      runFilter();
      update(bitmap);
      if (DEBUG) {
        Log.v(LOGTAG,""String_Node_Str"" + getName() + ""String_Node_Str""+ pipeline.getName());
      }
    }
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  java.lang.OutOfMemoryError e) {
    System.gc();
    displayLowMemoryToast();
    Log.e(LOGTAG,""String_Node_Str"" + getName(),e);
  }
  return bitmap;
}","The original code lacked proper debugging visibility, making it difficult to track the filter's execution and pipeline state. The fixed code adds conditional DEBUG logging statements to provide runtime insights into the filter's name, pipeline details, and execution flow. These strategic log statements enhance code transparency, facilitate easier troubleshooting, and offer developers a clearer understanding of the image processing pipeline's behavior without altering the core logic."
38381,"/** 
 * The task should be executed with one given bitmap to be saved.
 */
@Override protected Uri doInBackground(ImagePreset... params){
  if (params[0] == null || sourceUri == null) {
    return null;
  }
  ImagePreset preset=params[0];
  BitmapFactory.Options options=new BitmapFactory.Options();
  Uri uri=null;
  boolean noBitmap=true;
  int num_tries=0;
  while (noBitmap) {
    try {
      Bitmap bitmap=ImageLoader.loadMutableBitmap(context,sourceUri,options);
      if (bitmap == null) {
        return null;
      }
      preset.setupEnvironment();
      bitmap=preset.applyGeometry(bitmap);
      bitmap=preset.apply(bitmap);
      Object xmp=getPanoramaXMPData(sourceUri,preset);
      ExifInterface exif=getExifData(sourceUri);
      long time=System.currentTimeMillis();
      exif.addDateTimeStampTag(ExifInterface.TAG_DATE_TIME,time,TimeZone.getDefault());
      exif.setTag(exif.buildTag(ExifInterface.TAG_ORIENTATION,ExifInterface.Orientation.TOP_LEFT));
      if (putExifData(this.destinationFile,exif,bitmap)) {
        putPanoramaXMPData(this.destinationFile,xmp);
        uri=insertContent(context,sourceUri,this.destinationFile,saveFileName,time);
      }
      noBitmap=false;
    }
 catch (    java.lang.OutOfMemoryError e) {
      if (++num_tries >= 5) {
        throw e;
      }
      System.gc();
      options.inSampleSize*=2;
    }
  }
  return uri;
}","/** 
 * The task should be executed with one given bitmap to be saved.
 */
@Override protected Uri doInBackground(ImagePreset... params){
  if (params[0] == null || sourceUri == null) {
    return null;
  }
  ImagePreset preset=params[0];
  BitmapFactory.Options options=new BitmapFactory.Options();
  Uri uri=null;
  boolean noBitmap=true;
  int num_tries=0;
  while (noBitmap) {
    try {
      Bitmap bitmap=ImageLoader.loadMutableBitmap(context,sourceUri,options);
      if (bitmap == null) {
        return null;
      }
      CachingPipeline pipeline=new CachingPipeline(FiltersManager.getManager(),""String_Node_Str"");
      bitmap=pipeline.renderFinalImage(bitmap,preset);
      Object xmp=getPanoramaXMPData(sourceUri,preset);
      ExifInterface exif=getExifData(sourceUri);
      long time=System.currentTimeMillis();
      exif.addDateTimeStampTag(ExifInterface.TAG_DATE_TIME,time,TimeZone.getDefault());
      exif.setTag(exif.buildTag(ExifInterface.TAG_ORIENTATION,ExifInterface.Orientation.TOP_LEFT));
      if (putExifData(this.destinationFile,exif,bitmap)) {
        putPanoramaXMPData(this.destinationFile,xmp);
        uri=insertContent(context,sourceUri,this.destinationFile,saveFileName,time);
      }
      noBitmap=false;
    }
 catch (    java.lang.OutOfMemoryError e) {
      if (++num_tries >= 5) {
        throw e;
      }
      System.gc();
      options.inSampleSize*=2;
    }
  }
  return uri;
}","The original code directly applied image preset transformations using `preset.applyGeometry()` and `preset.apply()`, which might lead to inconsistent or suboptimal image processing. The fixed code introduces a `CachingPipeline` with `renderFinalImage()`, which provides a more robust and standardized method for applying image transformations. This approach ensures consistent image rendering, potentially improving performance and maintaining image quality through a centralized processing pipeline."
38382,"@Override public void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  setDefaultValues();
  loadXML();
  if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
    mShowingImageStatePanel=true;
  }
  if (mShowingHistoryPanel) {
    toggleHistoryPanel();
  }
  if (mShowingTinyPlanet == false) {
    View tinyPlanetView=findViewById(EditorTinyPlanet.ID);
    if (tinyPlanetView != null) {
      tinyPlanetView.setVisibility(View.GONE);
    }
  }
  final View loading=findViewById(R.id.loading);
  loading.setVisibility(View.GONE);
}","@Override public void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  setDefaultValues();
  loadXML();
  if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
    mShowingImageStatePanel=true;
  }
 else   if (mShowingImageStatePanel) {
    toggleImageStatePanel();
  }
  if (mShowingHistoryPanel) {
    toggleHistoryPanel();
  }
  if (mShowingTinyPlanet == false) {
    View tinyPlanetView=findViewById(EditorTinyPlanet.ID);
    if (tinyPlanetView != null) {
      tinyPlanetView.setVisibility(View.GONE);
    }
  }
  final View loading=findViewById(R.id.loading);
  loading.setVisibility(View.GONE);
}","The original code lacked handling for portrait orientation when the image state panel was previously showing, potentially leaving the panel in an inconsistent state. The fixed code adds an else-if condition to toggle the image state panel when switching from landscape to portrait, ensuring proper panel management. This modification provides more robust orientation change handling, preventing potential UI inconsistencies and improving the overall user experience during device rotation."
38383,"public void prepare(Bitmap bitmap,float scaleFactor,int quality){
  if (mOutPixelsAllocation == null || mInPixelsAllocation == null || bitmap.getWidth() != sWidth || bitmap.getHeight() != sHeight) {
    destroyPixelAllocations();
    Bitmap bitmapBuffer=bitmap;
    if (bitmap.getConfig() == null || bitmap.getConfig() != BITMAP_CONFIG) {
      bitmapBuffer=bitmap.copy(BITMAP_CONFIG,true);
    }
    mOutPixelsAllocation=Allocation.createFromBitmap(sRS,bitmapBuffer,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SCRIPT);
    mInPixelsAllocation=Allocation.createTyped(sRS,mOutPixelsAllocation.getType());
  }
  mInPixelsAllocation.copyFrom(bitmap);
  if (bitmap.getWidth() != sWidth || bitmap.getHeight() != sHeight || !isResourcesLoaded()) {
    freeResources();
    createFilter(sResources,scaleFactor,quality);
    sWidth=bitmap.getWidth();
    sHeight=bitmap.getHeight();
    setResourcesLoaded(true);
  }
}","protected void prepare(Bitmap bitmap,float scaleFactor,int quality){
  if (mOutPixelsAllocation == null || mInPixelsAllocation == null || bitmap.getWidth() != sWidth || bitmap.getHeight() != sHeight) {
    destroyPixelAllocations();
    Bitmap bitmapBuffer=bitmap;
    if (bitmap.getConfig() == null || bitmap.getConfig() != BITMAP_CONFIG) {
      bitmapBuffer=bitmap.copy(BITMAP_CONFIG,true);
    }
    mOutPixelsAllocation=Allocation.createFromBitmap(sRS,bitmapBuffer,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SCRIPT);
    mInPixelsAllocation=Allocation.createTyped(sRS,mOutPixelsAllocation.getType());
  }
  mInPixelsAllocation.copyFrom(bitmap);
  if (bitmap.getWidth() != sWidth || bitmap.getHeight() != sHeight || !isResourcesLoaded()) {
    freeResources();
    createFilter(sResources,scaleFactor,quality);
    sWidth=bitmap.getWidth();
    sHeight=bitmap.getHeight();
    setResourcesLoaded(true);
  }
}","The original code lacked proper access modifier visibility for the `prepare` method, which could lead to unintended method accessibility and potential encapsulation issues. The fixed code changes the method's access modifier from `public` to `protected`, ensuring controlled method access within the class hierarchy and improving encapsulation. This modification provides better control over method invocation and supports more robust object-oriented design principles."
38384,"abstract public void createFilter(android.content.res.Resources res,float scaleFactor,int quality);","protected abstract void createFilter(android.content.res.Resources res,float scaleFactor,int quality);","The original code incorrectly placed the `abstract` keyword before the method modifier, violating Java method declaration syntax. The fixed code correctly places `protected` before `abstract`, ensuring proper method declaration and allowing subclasses to implement the method with appropriate visibility. This correction enables proper inheritance and method implementation while maintaining the abstract nature of the method."
38385,"public void update(Bitmap bitmap){
  mOutPixelsAllocation.copyTo(bitmap);
}","protected void update(Bitmap bitmap){
  mOutPixelsAllocation.copyTo(bitmap);
}","The original code lacks proper access modifier, potentially exposing the method with unintended visibility. The fixed code changes the access modifier from public to protected, ensuring controlled method access within the class hierarchy and preventing external direct modification. This modification enhances encapsulation and provides better control over method accessibility, promoting more robust and maintainable code design."
38386,"public void freeResources(){
  if (!isResourcesLoaded()) {
    return;
  }
  resetAllocations();
  setResourcesLoaded(false);
}","public void freeResources(){
  if (!isResourcesLoaded()) {
    return;
  }
synchronized (ImageFilterRS.class) {
    resetAllocations();
    setResourcesLoaded(false);
  }
}","The original code lacks thread synchronization, potentially causing race conditions when multiple threads attempt to free resources simultaneously. The fixed code introduces a synchronized block using the class lock, ensuring that resource deallocation and state changes occur atomically and thread-safely. This synchronization prevents concurrent access and modifications, guaranteeing consistent and predictable resource management across multiple threads."
38387,abstract public void runFilter();,protected abstract void runFilter();,"The original code lacks a proper access modifier, which can lead to compilation errors and unclear method visibility. By changing the modifier to `protected`, the method becomes accessible to subclasses within the same package, allowing for proper inheritance and method implementation. This modification ensures better encapsulation and provides a clear contract for subclasses to implement the abstract `runFilter()` method."
38388,"@Override public void createFilter(android.content.res.Resources res,float scaleFactor,int quality){
  int w=mInPixelsAllocation.getType().getX();
  int h=mInPixelsAllocation.getType().getY();
  mScaleFactor=scaleFactor;
  if (mScript == null) {
    mScript=new ScriptC_convolve3x3(getRenderScriptContext(),res,R.raw.convolve3x3);
  }
  mScript.set_gWidth(w);
  mScript.set_gHeight(h);
}","@Override protected void createFilter(android.content.res.Resources res,float scaleFactor,int quality){
  int w=mInPixelsAllocation.getType().getX();
  int h=mInPixelsAllocation.getType().getY();
  mScaleFactor=scaleFactor;
  if (mScript == null) {
    mScript=new ScriptC_convolve3x3(getRenderScriptContext(),res,R.raw.convolve3x3);
  }
  mScript.set_gWidth(w);
  mScript.set_gHeight(h);
}","The original code incorrectly used the `public` access modifier for the `createFilter` method, which may violate encapsulation principles in the class hierarchy. The fixed code changes the modifier to `protected`, ensuring proper inheritance and method overriding behavior in the class. This modification allows subclasses to access and potentially override the method while maintaining appropriate visibility and design integrity."
38389,"@Override public void runFilter(){
  if (mParameters == null) {
    return;
  }
  computeKernel();
  mScript.set_gIn(mInPixelsAllocation);
  mScript.bind_gPixels(mInPixelsAllocation);
  mScript.forEach_root(mInPixelsAllocation,mOutPixelsAllocation);
}","@Override protected void runFilter(){
  if (mParameters == null) {
    return;
  }
  computeKernel();
  mScript.set_gIn(mInPixelsAllocation);
  mScript.bind_gPixels(mInPixelsAllocation);
  mScript.forEach_root(mInPixelsAllocation,mOutPixelsAllocation);
}","The original code lacks the `protected` access modifier for the `runFilter()` method, which could lead to potential inheritance and method overriding issues. The fixed code adds the `protected` modifier, ensuring proper method visibility and allowing subclasses to inherit and override the method correctly. This modification enhances code flexibility and adheres to better object-oriented design principles by explicitly defining the method's accessibility."
38390,"public static void reset(){
  sInstance=null;
}","public static void reset(){
  sInstance=null;
  sPreviewInstance=null;
}","The original code only nullifies the primary instance (sInstance), potentially leaving another related instance (sPreviewInstance) unhandled. The fixed code adds a second line to reset sPreviewInstance, ensuring complete cleanup of both object references. This comprehensive reset prevents potential memory leaks and ensures a thorough reinitialization of all relevant singleton instances."
38391,"public void prepare(Bitmap bitmap,float scaleFactor,int quality){
  if (mOutPixelsAllocation == null || mInPixelsAllocation == null || bitmap.getWidth() != sWidth || bitmap.getHeight() != sHeight) {
    destroyPixelAllocations();
    Bitmap bitmapBuffer=bitmap;
    if (bitmap.getConfig() == null || bitmap.getConfig() != BITMAP_CONFIG) {
      bitmapBuffer=bitmap.copy(BITMAP_CONFIG,true);
    }
    mOutPixelsAllocation=Allocation.createFromBitmap(sRS,bitmapBuffer,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SCRIPT);
    mInPixelsAllocation=Allocation.createTyped(sRS,mOutPixelsAllocation.getType());
  }
  mInPixelsAllocation.copyFrom(bitmap);
  if (bitmap.getWidth() != sWidth || bitmap.getHeight() != sHeight || !isResourcesLoaded()) {
    freeResources();
    createFilter(sResources,scaleFactor,quality);
    sWidth=bitmap.getWidth();
    sHeight=bitmap.getHeight();
    setResourcesLoaded(true);
  }
}","protected void prepare(Bitmap bitmap,float scaleFactor,int quality){
  if (mOutPixelsAllocation == null || mInPixelsAllocation == null || bitmap.getWidth() != sWidth || bitmap.getHeight() != sHeight) {
    destroyPixelAllocations();
    Bitmap bitmapBuffer=bitmap;
    if (bitmap.getConfig() == null || bitmap.getConfig() != BITMAP_CONFIG) {
      bitmapBuffer=bitmap.copy(BITMAP_CONFIG,true);
    }
    mOutPixelsAllocation=Allocation.createFromBitmap(sRS,bitmapBuffer,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SCRIPT);
    mInPixelsAllocation=Allocation.createTyped(sRS,mOutPixelsAllocation.getType());
  }
  mInPixelsAllocation.copyFrom(bitmap);
  if (bitmap.getWidth() != sWidth || bitmap.getHeight() != sHeight || !isResourcesLoaded()) {
    freeResources();
    createFilter(sResources,scaleFactor,quality);
    sWidth=bitmap.getWidth();
    sHeight=bitmap.getHeight();
    setResourcesLoaded(true);
  }
}","The original code had an incorrect method visibility modifier, making it less flexible and potentially inaccessible to subclasses or other classes that might need to use this method. The fixed code changes the method from `public` to `protected`, allowing inheritance and controlled access while maintaining the method's core functionality. This modification improves code design by providing better encapsulation and enabling more flexible extension of the class hierarchy."
38392,"abstract public void createFilter(android.content.res.Resources res,float scaleFactor,int quality);","protected abstract void createFilter(android.content.res.Resources res,float scaleFactor,int quality);","The original code incorrectly placed the `abstract` modifier before `public`, which is syntactically invalid in Java method declarations. The fixed code correctly moves `protected` before `abstract`, following the proper order of access modifier and method type declaration. This correction ensures proper method definition syntax, allowing the abstract method to be correctly implemented by subclasses while maintaining the intended protection level."
38393,"public void update(Bitmap bitmap){
  mOutPixelsAllocation.copyTo(bitmap);
}","protected void update(Bitmap bitmap){
  mOutPixelsAllocation.copyTo(bitmap);
}","The original code lacks proper visibility control, potentially exposing the method to unintended access from other classes. By changing the method modifier from `public` to `protected`, the code now restricts method access to subclasses and package-local classes, enhancing encapsulation and preventing unauthorized modifications. This modification improves code design by providing better control over method visibility and inheritance hierarchy."
38394,"public void freeResources(){
  if (!isResourcesLoaded()) {
    return;
  }
  resetAllocations();
  setResourcesLoaded(false);
}","public void freeResources(){
  if (!isResourcesLoaded()) {
    return;
  }
synchronized (ImageFilterRS.class) {
    resetAllocations();
    setResourcesLoaded(false);
  }
}","The original code lacks thread synchronization, potentially causing race conditions when multiple threads access and modify shared resources simultaneously. The fixed code introduces a synchronized block using the class lock, ensuring that only one thread can execute the critical section of resetting allocations and marking resources as unloaded. This synchronization prevents concurrent modifications, guaranteeing thread-safe resource management and eliminating potential data inconsistencies."
38395,abstract public void runFilter();,protected abstract void runFilter();,"The original code lacks proper method declaration visibility, making it ambiguous and potentially inaccessible to subclasses. By changing the modifier to 'protected', the method becomes accessible to subclasses within the same package or through inheritance, while maintaining its abstract nature. This modification ensures proper encapsulation and allows for consistent implementation of the abstract method across derived classes."
38396,"@Override public void createFilter(android.content.res.Resources res,float scaleFactor,int quality){
  int w=mInPixelsAllocation.getType().getX();
  int h=mInPixelsAllocation.getType().getY();
  mScaleFactor=scaleFactor;
  if (mScript == null) {
    mScript=new ScriptC_convolve3x3(getRenderScriptContext(),res,R.raw.convolve3x3);
  }
  mScript.set_gWidth(w);
  mScript.set_gHeight(h);
}","@Override protected void createFilter(android.content.res.Resources res,float scaleFactor,int quality){
  int w=mInPixelsAllocation.getType().getX();
  int h=mInPixelsAllocation.getType().getY();
  mScaleFactor=scaleFactor;
  if (mScript == null) {
    mScript=new ScriptC_convolve3x3(getRenderScriptContext(),res,R.raw.convolve3x3);
  }
  mScript.set_gWidth(w);
  mScript.set_gHeight(h);
}","The original code incorrectly used the `public void` method signature, which does not align with the expected override behavior for this method. The fixed code changes the method signature to `protected void`, ensuring proper inheritance and method overriding semantics in the class hierarchy. This modification maintains the method's intended functionality while adhering to correct Java inheritance principles and preventing potential compilation or runtime errors."
38397,"@Override public void runFilter(){
  if (mParameters == null) {
    return;
  }
  computeKernel();
  mScript.set_gIn(mInPixelsAllocation);
  mScript.bind_gPixels(mInPixelsAllocation);
  mScript.forEach_root(mInPixelsAllocation,mOutPixelsAllocation);
}","@Override protected void runFilter(){
  if (mParameters == null) {
    return;
  }
  computeKernel();
  mScript.set_gIn(mInPixelsAllocation);
  mScript.bind_gPixels(mInPixelsAllocation);
  mScript.forEach_root(mInPixelsAllocation,mOutPixelsAllocation);
}","The original code lacks the `protected` access modifier for the `runFilter()` method, which could lead to potential inheritance and method overriding issues. The fixed code adds the `protected` modifier, ensuring proper method visibility and allowing subclasses to correctly override the method. This modification enhances code maintainability and supports more flexible class design by explicitly defining the method's accessibility in the inheritance hierarchy."
38398,"public static void reset(){
  sInstance=null;
}","public static void reset(){
  sInstance=null;
  sPreviewInstance=null;
}","The original code only nullifies `sInstance`, potentially leaving `sPreviewInstance` unhandled, which could lead to unexpected behavior or memory leaks. The fixed code adds `sPreviewInstance=null`, ensuring both singleton instances are properly reset and preventing potential reference-related issues. This comprehensive reset approach guarantees a clean slate for both instances, improving the code's reliability and preventing potential unintended state retention."
38399,"@TargetApi(16) public SelectionManager(Activity activity){
  mActivity=activity;
  if (ApiHelper.AT_LEAST_16) {
    mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity);
    mNfcAdapter.setBeamPushUrisCallback(this,mActivity);
  }
}","public SelectionManager(Activity activity){
  mActivity=activity;
  if (ApiHelper.AT_LEAST_16) {
    mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity);
    mNfcAdapter.setBeamPushUrisCallback(new CreateBeamUrisCallback(){
      @Override public Uri[] createBeamUris(      NfcEvent arg0){
        if (mCachedShareableUris == null)         return null;
        return mCachedShareableUris.toArray(new Uri[mCachedShareableUris.size()]);
      }
    }
,mActivity);
  }
}","The original code incorrectly used `this` as the callback for `setBeamPushUrisCallback`, which would not properly implement the `CreateBeamUrisCallback` interface. The fixed code creates an anonymous inner class that explicitly implements `CreateBeamUrisCallback`, providing a proper implementation that checks for cached shareable URIs before returning them. This ensures type safety, prevents potential null pointer exceptions, and correctly handles the beam push URIs callback mechanism for NFC file sharing."
38400,"@Override public Uri[] createBeamUris(NfcEvent event){
  if (mCachedShareableUris == null)   return null;
  return mCachedShareableUris.toArray(new Uri[mCachedShareableUris.size()]);
}","@Override public Uri[] createBeamUris(NfcEvent arg0){
  if (mCachedShareableUris == null)   return null;
  return mCachedShareableUris.toArray(new Uri[mCachedShareableUris.size()]);
}","The original code incorrectly used the parameter name `event`, which could potentially cause confusion or unintended shadowing of method parameters. The fixed code renames the parameter to `arg0`, a standard convention for unused method parameters, maintaining clarity and avoiding potential naming conflicts. This change improves code readability and follows best practices for handling unused method arguments in Java."
38401,"@Override public View newView(Context context,Cursor cursor,ViewGroup parent){
  View view=mInflater.inflate(R.layout.photo_set_item,parent,false);
  LayoutParams params=view.getLayoutParams();
  int columnWidth=((GridView)parent).getColumnWidth();
  params.height=columnWidth;
  view.setLayoutParams(params);
  return view;
}","@Override public View newView(Context context,Cursor cursor,ViewGroup parent){
  View view=mInflater.inflate(R.layout.photo_set_item,parent,false);
  return view;
}","The original code attempts to manually set layout parameters for a view, which can cause unexpected sizing and layout issues in GridView. The fixed code removes the manual layout parameter manipulation, allowing the GridView to handle view sizing automatically through its built-in layout management. By eliminating unnecessary custom sizing, the fixed code ensures more reliable and consistent view rendering across different screen sizes and device configurations."
38402,"private void fillFx(LinearLayout listFilters,int buttonId){
  FilterFxRepresentation[] fxArray=new FilterFxRepresentation[18];
  int p=0;
  int[] drawid={R.drawable.filtershow_fx_0005_punch,R.drawable.filtershow_fx_0000_vintage,R.drawable.filtershow_fx_0004_bw_contrast,R.drawable.filtershow_fx_0002_bleach,R.drawable.filtershow_fx_0001_instant,R.drawable.filtershow_fx_0007_washout,R.drawable.filtershow_fx_0003_blue_crush,R.drawable.filtershow_fx_0008_washout_color,R.drawable.filtershow_fx_0006_x_process};
  int[] fxNameid={R.string.ffx_punch,R.string.ffx_vintage,R.string.ffx_bw_contrast,R.string.ffx_bleach,R.string.ffx_instant,R.string.ffx_washout,R.string.ffx_blue_crush,R.string.ffx_washout_color,R.string.ffx_x_process};
  BitmapFactory.Options o=new BitmapFactory.Options();
  o.inScaled=false;
  for (int i=0; i < drawid.length; i++) {
    Bitmap b=BitmapFactory.decodeResource(getResources(),drawid[i],o);
    FilterFxRepresentation fx=new FilterFxRepresentation(getString(fxNameid[i]),drawid[i],fxNameid[i]);
    fx.setFxBitmap(b);
    fxArray[p++]=fx;
  }
  ImageButton button=(ImageButton)findViewById(buttonId);
  FilterFxRepresentation nullFx=new FilterFxRepresentation(getString(R.string.none),0,R.string.none);
  mNullFxFilter=setupFilterRepresentationButton(nullFx,listFilters,button);
  mNullFxFilter.setSelected(true);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager.getManager().addLooks(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listFilters,button);
  }
  for (int i=0; i < p; i++) {
    setupFilterRepresentationButton(fxArray[i],listFilters,button);
  }
}","private void fillFx(LinearLayout listFilters,int buttonId){
  FilterFxRepresentation[] fxArray=new FilterFxRepresentation[18];
  int p=0;
  int[] drawid={R.drawable.filtershow_fx_0005_punch,R.drawable.filtershow_fx_0000_vintage,R.drawable.filtershow_fx_0004_bw_contrast,R.drawable.filtershow_fx_0002_bleach,R.drawable.filtershow_fx_0001_instant,R.drawable.filtershow_fx_0007_washout,R.drawable.filtershow_fx_0003_blue_crush,R.drawable.filtershow_fx_0008_washout_color,R.drawable.filtershow_fx_0006_x_process};
  int[] fxNameid={R.string.ffx_punch,R.string.ffx_vintage,R.string.ffx_bw_contrast,R.string.ffx_bleach,R.string.ffx_instant,R.string.ffx_washout,R.string.ffx_blue_crush,R.string.ffx_washout_color,R.string.ffx_x_process};
  for (int i=0; i < drawid.length; i++) {
    FilterFxRepresentation fx=new FilterFxRepresentation(getString(fxNameid[i]),drawid[i],fxNameid[i]);
    fxArray[p++]=fx;
  }
  ImageButton button=(ImageButton)findViewById(buttonId);
  FilterFxRepresentation nullFx=new FilterFxRepresentation(getString(R.string.none),0,R.string.none);
  mNullFxFilter=setupFilterRepresentationButton(nullFx,listFilters,button);
  mNullFxFilter.setSelected(true);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager.getManager().addLooks(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listFilters,button);
  }
  for (int i=0; i < p; i++) {
    setupFilterRepresentationButton(fxArray[i],listFilters,button);
  }
}","The original code unnecessarily decoded bitmap resources for each filter, consuming excessive memory and processing time. The fixed code removes the bitmap decoding step, eliminating redundant resource loading and potential memory overhead. By simplifying the filter representation creation process, the revised method becomes more efficient and reduces potential performance bottlenecks in the image filtering workflow."
38403,"private void setDefaultValues(){
  ImageFilter.setActivityForMemoryToasts(this);
  ImageFilterRS.setRenderScriptContext(this);
  Resources res=getResources();
  ImageFilterBorder filterBorder=(ImageFilterBorder)FiltersManager.getManager().getFilter(ImageFilterBorder.class);
  filterBorder.setResources(res);
  filterBorder=(ImageFilterBorder)FiltersManager.getPreviewManager().getFilter(ImageFilterBorder.class);
  filterBorder.setResources(res);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  ImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
}","private void setDefaultValues(){
  ImageFilter.setActivityForMemoryToasts(this);
  ImageFilterRS.setRenderScriptContext(this);
  Resources res=getResources();
  ImageFilterBorder filterBorder=(ImageFilterBorder)FiltersManager.getManager().getFilter(ImageFilterBorder.class);
  filterBorder.setResources(res);
  filterBorder=(ImageFilterBorder)FiltersManager.getPreviewManager().getFilter(ImageFilterBorder.class);
  filterBorder.setResources(res);
  ImageFilterFx filterFx=(ImageFilterFx)FiltersManager.getManager().getFilter(ImageFilterFx.class);
  filterFx.setResources(res);
  filterFx=(ImageFilterFx)FiltersManager.getPreviewManager().getFilter(ImageFilterFx.class);
  filterFx.setResources(res);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  ImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
}","The original code missed setting resources for the ImageFilterFx class in both the manager and preview manager, potentially causing resource-related errors. The fixed code adds two lines to set resources for ImageFilterFx, ensuring consistent resource initialization across different filter types. This comprehensive resource setup prevents potential null pointer exceptions and improves the robustness of filter management in the application."
38404,"public void setupMasterImage(){
  mImageLoader=new ImageLoader(this,getApplicationContext());
  HistoryAdapter mHistoryAdapter=new HistoryAdapter(this,R.layout.filtershow_history_operation_row,R.id.rowTextView);
  ImageStateAdapter mImageStateAdapter=new ImageStateAdapter(this,R.layout.filtershow_imagestate_row);
  MasterImage.reset();
  mMasterImage=MasterImage.getImage();
  mMasterImage.setHistoryAdapter(mHistoryAdapter);
  mMasterImage.setStateAdapter(mImageStateAdapter);
  mMasterImage.setActivity(this);
}","public void setupMasterImage(){
  mImageLoader=new ImageLoader(this,getApplicationContext());
  HistoryAdapter mHistoryAdapter=new HistoryAdapter(this,R.layout.filtershow_history_operation_row,R.id.rowTextView);
  ImageStateAdapter mImageStateAdapter=new ImageStateAdapter(this,R.layout.filtershow_imagestate_row);
  MasterImage.reset();
  mMasterImage=MasterImage.getImage();
  mMasterImage.setHistoryAdapter(mHistoryAdapter);
  mMasterImage.setStateAdapter(mImageStateAdapter);
  mMasterImage.setActivity(this);
  mMasterImage.setImageLoader(mImageLoader);
}","The original code omitted setting the ImageLoader for the MasterImage, potentially causing initialization issues with image loading. The fixed code adds `mMasterImage.setImageLoader(mImageLoader)`, ensuring that the MasterImage has a properly configured ImageLoader for handling image-related operations. This correction guarantees complete initialization of the MasterImage, preventing potential null pointer exceptions or incomplete image loading functionality."
38405,"@Override public View getView(int position,View convertView,ViewGroup parent){
  View view=convertView;
  if (view == null) {
    LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    view=inflater.inflate(R.layout.filtershow_history_operation_row,null);
  }
  ImagePreset item=getItem(position);
  if (item != null) {
    TextView itemView=(TextView)view.findViewById(R.id.rowTextView);
    if (itemView != null) {
      itemView.setText(item.historyName());
    }
    ImageView preview=(ImageView)view.findViewById(R.id.preview);
    Bitmap bmp=item.getPreviewImage();
    if (bmp != null) {
      preview.setImageBitmap(bmp);
    }
    if (position == mCurrentPresetPosition) {
      view.setBackgroundColor(Color.WHITE);
    }
 else {
      view.setBackgroundResource(R.color.background_main_toolbar);
    }
  }
  return view;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  View view=convertView;
  if (view == null) {
    LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    view=inflater.inflate(R.layout.filtershow_history_operation_row,null);
  }
  ImagePreset item=getItem(position);
  if (item != null) {
    TextView itemView=(TextView)view.findViewById(R.id.rowTextView);
    if (itemView != null) {
      itemView.setText(item.historyName());
    }
    ImageView preview=(ImageView)view.findViewById(R.id.preview);
    Bitmap bmp=item.getPreviewImage();
    if (bmp != null) {
      preview.setImageBitmap(bmp);
    }
 else {
      preview.setImageResource(android.R.color.transparent);
    }
    if (position == mCurrentPresetPosition) {
      view.setBackgroundColor(Color.WHITE);
    }
 else {
      view.setBackgroundResource(R.color.background_main_toolbar);
    }
  }
  return view;
}","The original code lacks handling for null preview images, potentially leaving the ImageView in an undefined state. In the fixed code, a null preview image now sets the ImageView to a transparent resource, ensuring consistent visual behavior. This change prevents potential null pointer exceptions and provides a clean, predictable UI rendering when no preview image is available."
38406,"public void useFilterRepresentation(FilterRepresentation filterRepresentation){
  if (filterRepresentation == null) {
    return;
  }
  if (MasterImage.getImage().getCurrentFilterRepresentation() == filterRepresentation) {
    return;
  }
  ImagePreset oldPreset=MasterImage.getImage().getPreset();
  ImagePreset copy=new ImagePreset(oldPreset);
  FilterRepresentation representation=copy.getRepresentation(filterRepresentation);
  if (representation == null) {
    copy.addFilter(filterRepresentation);
  }
 else {
    if (filterRepresentation.allowsMultipleInstances()) {
      representation.updateTempParametersFrom(filterRepresentation);
      copy.setHistoryName(filterRepresentation.getName());
    }
    filterRepresentation=representation;
  }
  MasterImage.getImage().setPreset(copy,true);
  MasterImage.getImage().setCurrentFilterRepresentation(filterRepresentation);
}","public void useFilterRepresentation(FilterRepresentation filterRepresentation){
  if (filterRepresentation == null) {
    return;
  }
  if (MasterImage.getImage().getCurrentFilterRepresentation() == filterRepresentation) {
    return;
  }
  ImagePreset oldPreset=MasterImage.getImage().getPreset();
  ImagePreset copy=new ImagePreset(oldPreset);
  FilterRepresentation representation=copy.getRepresentation(filterRepresentation);
  if (representation == null) {
    copy.addFilter(filterRepresentation);
  }
 else {
    if (filterRepresentation.allowsMultipleInstances()) {
      representation.updateTempParametersFrom(filterRepresentation);
      copy.setHistoryName(filterRepresentation.getName());
      representation.synchronizeRepresentation();
    }
    filterRepresentation=representation;
  }
  MasterImage.getImage().setPreset(copy,true);
  MasterImage.getImage().setCurrentFilterRepresentation(filterRepresentation);
}","The original code lacked synchronization of filter representation parameters when multiple instances were allowed, potentially causing inconsistent filter states. The fixed code adds `representation.synchronizeRepresentation()` to ensure that filter parameters are properly updated and synchronized across different instances. This enhancement improves the reliability and consistency of filter application by maintaining accurate representation state during image editing."
38407,"@Override public FilterRepresentation clone() throws CloneNotSupportedException {
  FilterFxRepresentation representation=(FilterFxRepresentation)super.clone();
  representation.setName(getName());
  representation.setBitmapResource(getBitmapResource());
  representation.setNameResource(getNameResource());
  representation.setFxBitmap(getFxBitmap());
  return representation;
}","@Override public synchronized FilterRepresentation clone() throws CloneNotSupportedException {
  FilterFxRepresentation representation=(FilterFxRepresentation)super.clone();
  representation.setName(getName());
  representation.setBitmapResource(getBitmapResource());
  representation.setNameResource(getNameResource());
  return representation;
}","The original code incorrectly cloned the `getFxBitmap()` method, which could lead to potential memory leaks or unintended object references. The fixed code removes the `getFxBitmap()` clone and adds the `synchronized` keyword to ensure thread-safe cloning. This modification prevents unnecessary object duplication and provides better thread synchronization during the cloning process."
38408,"public void useParametersFrom(FilterRepresentation a){
  if (a instanceof FilterFxRepresentation) {
    FilterFxRepresentation representation=(FilterFxRepresentation)a;
    setName(representation.getName());
    setBitmapResource(representation.getBitmapResource());
    setNameResource(representation.getNameResource());
    setFxBitmap(representation.getFxBitmap());
  }
}","public synchronized void useParametersFrom(FilterRepresentation a){
  if (a instanceof FilterFxRepresentation) {
    FilterFxRepresentation representation=(FilterFxRepresentation)a;
    setName(representation.getName());
    setBitmapResource(representation.getBitmapResource());
    setNameResource(representation.getNameResource());
  }
}","The original code incorrectly calls `setFxBitmap()`, which might lead to unintended side effects or potential memory leaks when copying filter representations. The fixed code removes this unnecessary method call and adds the `synchronized` keyword to ensure thread-safe parameter copying across different filter representations. By simplifying the method and adding synchronization, the code becomes more robust, predictable, and prevents potential concurrent modification issues during filter parameter transfer."
38409,"public String toString(){
  return ""String_Node_Str"" + getName();
}","public String toString(){
  return ""String_Node_Str"" + hashCode() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ mBitmapResource;
}","The original code lacked uniqueness and comprehensive information in its toString() representation, potentially causing confusion when identifying object instances. The fixed code enhances the toString() method by incorporating additional identifiers like hashCode(), method name, and bitmap resource, creating a more distinctive and informative string representation. These modifications provide a more precise and detailed description of the object, improving debugging and logging capabilities."
38410,"@Override public FilterRepresentation clone() throws CloneNotSupportedException {
  FilterRepresentation representation=(FilterRepresentation)super.clone();
  representation.setName(getName());
  representation.setPriority(getPriority());
  representation.setFilterClass(getFilterClass());
  representation.setSupportsPartialRendering(supportsPartialRendering());
  representation.setTextId(getTextId());
  representation.setEditorId(getEditorId());
  representation.setButtonId(getButtonId());
  representation.setOverlayId(getOverlayId());
  representation.setOverlayOnly(getOverlayOnly());
  representation.setShowEditingControls(showEditingControls());
  representation.setShowParameterValue(showParameterValue());
  representation.setShowUtilityPanel(showUtilityPanel());
  Log.v(LOGTAG,""String_Node_Str"" + this + ""String_Node_Str""+ representation+ ""String_Node_Str"");
  return representation;
}","@Override public FilterRepresentation clone() throws CloneNotSupportedException {
  FilterRepresentation representation=(FilterRepresentation)super.clone();
  representation.setName(getName());
  representation.setPriority(getPriority());
  representation.setFilterClass(getFilterClass());
  representation.setSupportsPartialRendering(supportsPartialRendering());
  representation.setTextId(getTextId());
  representation.setEditorId(getEditorId());
  representation.setButtonId(getButtonId());
  representation.setOverlayId(getOverlayId());
  representation.setOverlayOnly(getOverlayOnly());
  representation.setShowEditingControls(showEditingControls());
  representation.setShowParameterValue(showParameterValue());
  representation.setShowUtilityPanel(showUtilityPanel());
  representation.mTempRepresentation=null;
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + this + ""String_Node_Str""+ representation+ ""String_Node_Str"");
  }
  return representation;
}","The original code lacks null handling for a temporary representation field, which could lead to unintended state preservation during cloning. The fixed code adds `representation.mTempRepresentation=null` to explicitly reset the temporary field and wraps the logging statement in a debug conditional check. These changes ensure clean object cloning by preventing potential memory leaks and providing more controlled logging, enhancing the method's robustness and predictability."
38411,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (getParameters() == null || getParameters().getFxBitmap() == null) {
    return bitmap;
  }
  int w=bitmap.getWidth();
  int h=bitmap.getHeight();
  int fxw=getParameters().getFxBitmap().getWidth();
  int fxh=getParameters().getFxBitmap().getHeight();
  nativeApplyFilter(bitmap,w,h,getParameters().getFxBitmap(),fxw,fxh);
  return bitmap;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (getParameters() == null || mResources == null) {
    return bitmap;
  }
  int w=bitmap.getWidth();
  int h=bitmap.getHeight();
  if (mFxBitmap == null || mFxBitmapId != getParameters().getBitmapResource()) {
    BitmapFactory.Options o=new BitmapFactory.Options();
    o.inScaled=false;
    mFxBitmapId=getParameters().getBitmapResource();
    mFxBitmap=BitmapFactory.decodeResource(mResources,mFxBitmapId,o);
  }
  if (mFxBitmap == null) {
    return bitmap;
  }
  int fxw=mFxBitmap.getWidth();
  int fxh=mFxBitmap.getHeight();
  nativeApplyFilter(bitmap,w,h,mFxBitmap,fxw,fxh);
  return bitmap;
}","The original code assumed a pre-existing filter bitmap was always available through getParameters(), which could lead to null pointer exceptions or stale resources. The fixed code introduces dynamic bitmap loading by checking and decoding the bitmap resource only when needed, using BitmapFactory with specific options to prevent scaling. This approach ensures robust resource management, prevents potential crashes, and provides a more flexible and resilient method for applying image filters."
38412,"public ImagePreset(ImagePreset source){
  try {
    if (source.mBorder != null) {
      mBorder=source.mBorder.clone();
    }
    for (int i=0; i < source.mFilters.size(); i++) {
      FilterRepresentation representation=source.mFilters.elementAt(i).clone();
      addFilter(representation);
    }
  }
 catch (  java.lang.CloneNotSupportedException e) {
    Log.v(LOGTAG,""String_Node_Str"" + e);
  }
  mName=source.name();
  mHistoryName=source.name();
  mIsFxPreset=source.isFx();
  mImageLoader=source.getImageLoader();
  mGeoData.set(source.mGeoData);
}","public ImagePreset(ImagePreset source){
  try {
    if (source.mBorder != null) {
      mBorder=source.mBorder.clone();
    }
    for (int i=0; i < source.mFilters.size(); i++) {
      FilterRepresentation representation=source.mFilters.elementAt(i).clone();
      addFilter(representation);
    }
  }
 catch (  java.lang.CloneNotSupportedException e) {
    Log.v(LOGTAG,""String_Node_Str"" + e);
  }
  mName=source.name();
  mHistoryName=source.name();
  mIsFxPreset=source.isFx();
  mImageLoader=source.getImageLoader();
  mPreviewImage=source.getPreviewImage();
  mGeoData.set(source.mGeoData);
}","The original code missed copying the preview image during the ImagePreset object cloning process, potentially leading to incomplete object replication. The fixed code adds `mPreviewImage=source.getPreviewImage();`, ensuring that the preview image is properly transferred when creating a new ImagePreset instance. This change guarantees a more comprehensive and accurate object duplication, maintaining all relevant image preset properties during cloning."
38413,"private void buildExposureCompensation(PreferenceGroup group,IconListPreference exposure){
  int max=mParameters.getMaxExposureCompensation();
  int min=mParameters.getMinExposureCompensation();
  if (max == 0 && min == 0) {
    removePreference(group,exposure.getKey());
    return;
  }
  float step=mParameters.getExposureCompensationStep();
  int maxValue=(int)FloatMath.floor(max * step);
  int minValue=(int)FloatMath.ceil(min * step);
  CharSequence entries[]=new CharSequence[maxValue - minValue + 1];
  CharSequence entryValues[]=new CharSequence[maxValue - minValue + 1];
  int[] icons=new int[maxValue - minValue + 1];
  TypedArray iconIds=mContext.getResources().obtainTypedArray(R.array.pref_camera_exposure_icons);
  for (int i=minValue; i <= maxValue; ++i) {
    entryValues[maxValue - i]=Integer.toString(Math.round(i / step));
    StringBuilder builder=new StringBuilder();
    if (i > 0)     builder.append('+');
    entries[maxValue - i]=builder.append(i).toString();
    icons[maxValue - i]=iconIds.getResourceId(3 + i,0);
  }
  exposure.setUseSingleIcon(true);
  exposure.setEntries(entries);
  exposure.setEntryValues(entryValues);
  exposure.setLargeIconIds(icons);
}","private void buildExposureCompensation(PreferenceGroup group,IconListPreference exposure){
  int max=Math.min(3,mParameters.getMaxExposureCompensation());
  int min=Math.max(-3,mParameters.getMinExposureCompensation());
  if (max == 0 && min == 0) {
    removePreference(group,exposure.getKey());
    return;
  }
  float step=mParameters.getExposureCompensationStep();
  int maxValue=(int)FloatMath.floor(max * step);
  int minValue=(int)FloatMath.ceil(min * step);
  CharSequence entries[]=new CharSequence[maxValue - minValue + 1];
  CharSequence entryValues[]=new CharSequence[maxValue - minValue + 1];
  int[] icons=new int[maxValue - minValue + 1];
  TypedArray iconIds=mContext.getResources().obtainTypedArray(R.array.pref_camera_exposure_icons);
  for (int i=minValue; i <= maxValue; ++i) {
    entryValues[maxValue - i]=Integer.toString(Math.round(i / step));
    StringBuilder builder=new StringBuilder();
    if (i > 0)     builder.append('+');
    entries[maxValue - i]=builder.append(i).toString();
    icons[maxValue - i]=iconIds.getResourceId(3 + i,0);
  }
  exposure.setUseSingleIcon(true);
  exposure.setEntries(entries);
  exposure.setEntryValues(entryValues);
  exposure.setLargeIconIds(icons);
}","The original code lacks bounds checking for exposure compensation, potentially causing array index out of bounds or unexpected behavior with extreme camera parameter values. The fixed code introduces explicit limits of -3 to 3 using Math.min() and Math.max(), constraining the exposure range to a reasonable and safe interval. By adding these boundary checks, the code becomes more robust, preventing potential runtime errors and ensuring consistent, predictable behavior across different camera devices."
38414,"@Override public FilterRepresentation clone() throws CloneNotSupportedException {
  FilterFxRepresentation representation=(FilterFxRepresentation)super.clone();
  representation.setName(getName());
  representation.setBitmapResource(getBitmapResource());
  representation.setNameResource(getNameResource());
  representation.setFxBitmap(getFxBitmap());
  return representation;
}","@Override public synchronized FilterRepresentation clone() throws CloneNotSupportedException {
  FilterFxRepresentation representation=(FilterFxRepresentation)super.clone();
  representation.setName(getName());
  representation.setBitmapResource(getBitmapResource());
  representation.setNameResource(getNameResource());
  return representation;
}","The original code incorrectly cloned the `getFxBitmap()` method, which could potentially create unnecessary object duplication or memory overhead. The fixed code removes the `getFxBitmap()` method call during cloning and adds the `synchronized` keyword to ensure thread-safe cloning. This modification prevents potential resource leaks and improves the clone method's performance and thread safety."
38415,"public void useParametersFrom(FilterRepresentation a){
  if (a instanceof FilterFxRepresentation) {
    FilterFxRepresentation representation=(FilterFxRepresentation)a;
    setName(representation.getName());
    setBitmapResource(representation.getBitmapResource());
    setNameResource(representation.getNameResource());
    setFxBitmap(representation.getFxBitmap());
  }
}","public synchronized void useParametersFrom(FilterRepresentation a){
  if (a instanceof FilterFxRepresentation) {
    FilterFxRepresentation representation=(FilterFxRepresentation)a;
    setName(representation.getName());
    setBitmapResource(representation.getBitmapResource());
    setNameResource(representation.getNameResource());
  }
}","The original code incorrectly called `setFxBitmap()` without context, potentially causing unintended side effects or memory leaks. The fixed code removes this method call and adds the `synchronized` keyword to ensure thread-safe parameter copying from one filter representation to another. By simplifying the method and adding synchronization, the code becomes more robust and prevents potential concurrent modification issues during filter parameter transfer."
38416,"public String toString(){
  return ""String_Node_Str"" + getName();
}","public String toString(){
  return ""String_Node_Str"" + hashCode() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ mBitmapResource;
}","The original code lacked unique identification by only concatenating the name, which could lead to ambiguous or non-distinct toString() representations. The fixed code adds hashCode(), an additional string delimiter, and includes mBitmapResource to create a more comprehensive and unique string representation. These modifications ensure each object's toString() method generates a distinct, informative output that includes multiple identifying characteristics."
38417,"@Override public FilterRepresentation clone() throws CloneNotSupportedException {
  FilterRepresentation representation=(FilterRepresentation)super.clone();
  representation.setName(getName());
  representation.setPriority(getPriority());
  representation.setFilterClass(getFilterClass());
  representation.setSupportsPartialRendering(supportsPartialRendering());
  representation.setTextId(getTextId());
  representation.setEditorId(getEditorId());
  representation.setButtonId(getButtonId());
  representation.setOverlayId(getOverlayId());
  representation.setOverlayOnly(getOverlayOnly());
  representation.setShowEditingControls(showEditingControls());
  representation.setShowParameterValue(showParameterValue());
  representation.setShowUtilityPanel(showUtilityPanel());
  Log.v(LOGTAG,""String_Node_Str"" + this + ""String_Node_Str""+ representation+ ""String_Node_Str"");
  return representation;
}","@Override public FilterRepresentation clone() throws CloneNotSupportedException {
  FilterRepresentation representation=(FilterRepresentation)super.clone();
  representation.setName(getName());
  representation.setPriority(getPriority());
  representation.setFilterClass(getFilterClass());
  representation.setSupportsPartialRendering(supportsPartialRendering());
  representation.setTextId(getTextId());
  representation.setEditorId(getEditorId());
  representation.setButtonId(getButtonId());
  representation.setOverlayId(getOverlayId());
  representation.setOverlayOnly(getOverlayOnly());
  representation.setShowEditingControls(showEditingControls());
  representation.setShowParameterValue(showParameterValue());
  representation.setShowUtilityPanel(showUtilityPanel());
  representation.mTempRepresentation=null;
  if (DEBUG) {
    Log.v(LOGTAG,""String_Node_Str"" + this + ""String_Node_Str""+ representation+ ""String_Node_Str"");
  }
  return representation;
}","The original code lacks a null check for a temporary representation field, potentially leading to unintended object state preservation during cloning. The fixed code adds `representation.mTempRepresentation=null` to explicitly reset the temporary field and wraps the logging statement in a debug condition flag. These changes ensure clean object cloning, prevent potential memory leaks, and provide more controlled logging behavior during the cloning process."
38418,"public ImagePreset(ImagePreset source){
  try {
    if (source.mBorder != null) {
      mBorder=source.mBorder.clone();
    }
    for (int i=0; i < source.mFilters.size(); i++) {
      FilterRepresentation representation=source.mFilters.elementAt(i).clone();
      addFilter(representation);
    }
  }
 catch (  java.lang.CloneNotSupportedException e) {
    Log.v(LOGTAG,""String_Node_Str"" + e);
  }
  mName=source.name();
  mHistoryName=source.name();
  mIsFxPreset=source.isFx();
  mImageLoader=source.getImageLoader();
  mGeoData.set(source.mGeoData);
}","public ImagePreset(ImagePreset source){
  try {
    if (source.mBorder != null) {
      mBorder=source.mBorder.clone();
    }
    for (int i=0; i < source.mFilters.size(); i++) {
      FilterRepresentation representation=source.mFilters.elementAt(i).clone();
      addFilter(representation);
    }
  }
 catch (  java.lang.CloneNotSupportedException e) {
    Log.v(LOGTAG,""String_Node_Str"" + e);
  }
  mName=source.name();
  mHistoryName=source.name();
  mIsFxPreset=source.isFx();
  mImageLoader=source.getImageLoader();
  mPreviewImage=source.getPreviewImage();
  mGeoData.set(source.mGeoData);
}","The original code missed copying the preview image during the ImagePreset object cloning, potentially leading to an incomplete object reproduction. The fixed code adds `mPreviewImage=source.getPreviewImage();`, ensuring that the preview image is properly transferred when creating a new ImagePreset instance. This enhancement guarantees a more comprehensive and accurate duplication of the source object's state, maintaining data integrity during object cloning."
38419,"private void buildExposureCompensation(PreferenceGroup group,IconListPreference exposure){
  int max=mParameters.getMaxExposureCompensation();
  int min=mParameters.getMinExposureCompensation();
  if (max == 0 && min == 0) {
    removePreference(group,exposure.getKey());
    return;
  }
  float step=mParameters.getExposureCompensationStep();
  int maxValue=(int)FloatMath.floor(max * step);
  int minValue=(int)FloatMath.ceil(min * step);
  CharSequence entries[]=new CharSequence[maxValue - minValue + 1];
  CharSequence entryValues[]=new CharSequence[maxValue - minValue + 1];
  int[] icons=new int[maxValue - minValue + 1];
  TypedArray iconIds=mContext.getResources().obtainTypedArray(R.array.pref_camera_exposure_icons);
  for (int i=minValue; i <= maxValue; ++i) {
    entryValues[maxValue - i]=Integer.toString(Math.round(i / step));
    StringBuilder builder=new StringBuilder();
    if (i > 0)     builder.append('+');
    entries[maxValue - i]=builder.append(i).toString();
    icons[maxValue - i]=iconIds.getResourceId(3 + i,0);
  }
  exposure.setUseSingleIcon(true);
  exposure.setEntries(entries);
  exposure.setEntryValues(entryValues);
  exposure.setLargeIconIds(icons);
}","private void buildExposureCompensation(PreferenceGroup group,IconListPreference exposure){
  int max=Math.min(3,mParameters.getMaxExposureCompensation());
  int min=Math.max(-3,mParameters.getMinExposureCompensation());
  if (max == 0 && min == 0) {
    removePreference(group,exposure.getKey());
    return;
  }
  float step=mParameters.getExposureCompensationStep();
  int maxValue=(int)FloatMath.floor(max * step);
  int minValue=(int)FloatMath.ceil(min * step);
  CharSequence entries[]=new CharSequence[maxValue - minValue + 1];
  CharSequence entryValues[]=new CharSequence[maxValue - minValue + 1];
  int[] icons=new int[maxValue - minValue + 1];
  TypedArray iconIds=mContext.getResources().obtainTypedArray(R.array.pref_camera_exposure_icons);
  for (int i=minValue; i <= maxValue; ++i) {
    entryValues[maxValue - i]=Integer.toString(Math.round(i / step));
    StringBuilder builder=new StringBuilder();
    if (i > 0)     builder.append('+');
    entries[maxValue - i]=builder.append(i).toString();
    icons[maxValue - i]=iconIds.getResourceId(3 + i,0);
  }
  exposure.setUseSingleIcon(true);
  exposure.setEntries(entries);
  exposure.setEntryValues(entryValues);
  exposure.setLargeIconIds(icons);
}","The original code lacks bounds checking for exposure compensation, potentially causing array index out of bounds or unexpected behavior with extreme camera parameter values. The fixed code introduces explicit limits of -3 to 3 using Math.min() and Math.max(), constraining the exposure range to a reasonable and safe interval. By implementing these bounds, the code becomes more robust, preventing potential crashes and ensuring consistent, predictable behavior across different camera devices."
38420,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      HistoryAdapter adapter=mMasterImage.getHistory();
      int position=adapter.undo();
      mMasterImage.onHistoryItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=mMasterImage.getHistory();
    int position=adapter.redo();
    mMasterImage.onHistoryItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.resetHistoryButton:
{
  resetHistory();
  return true;
}
case R.id.showImageStateButton:
{
toggleImageStatePanel();
return true;
}
case R.id.operationsButton:
{
toggleHistoryPanel();
return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      mPanelController.resetParameters();
      HistoryAdapter adapter=mMasterImage.getHistory();
      int position=adapter.undo();
      mMasterImage.onHistoryItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=mMasterImage.getHistory();
    int position=adapter.redo();
    mMasterImage.onHistoryItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.resetHistoryButton:
{
  resetHistory();
  return true;
}
case R.id.showImageStateButton:
{
toggleImageStatePanel();
return true;
}
case R.id.operationsButton:
{
toggleHistoryPanel();
return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","The original code lacked proper parameter reset before performing undo operations, which could lead to inconsistent state management. In the fixed code, `mPanelController.resetParameters()` is added before the undo operation in the `undoButton` case, ensuring a clean slate before reverting to a previous image state. This modification prevents potential side effects and ensures more predictable and reliable image history navigation."
38421,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      HistoryAdapter adapter=mMasterImage.getHistory();
      int position=adapter.undo();
      mMasterImage.onHistoryItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=mMasterImage.getHistory();
    int position=adapter.redo();
    mMasterImage.onHistoryItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.resetHistoryButton:
{
  resetHistory();
  return true;
}
case R.id.showImageStateButton:
{
toggleImageStatePanel();
return true;
}
case R.id.operationsButton:
{
toggleHistoryPanel();
return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      mPanelController.resetParameters();
      HistoryAdapter adapter=mMasterImage.getHistory();
      int position=adapter.undo();
      mMasterImage.onHistoryItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=mMasterImage.getHistory();
    int position=adapter.redo();
    mMasterImage.onHistoryItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.resetHistoryButton:
{
  resetHistory();
  return true;
}
case R.id.showImageStateButton:
{
toggleImageStatePanel();
return true;
}
case R.id.operationsButton:
{
toggleHistoryPanel();
return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","The original code lacked proper parameter reset before performing undo operations, which could lead to unexpected UI or state inconsistencies. In the fixed code, `mPanelController.resetParameters()` is added before the undo operation in the `undoButton` case, ensuring that any previous panel settings are cleared before reverting to a previous image state. This modification prevents potential residual parameter conflicts and improves the reliability of the undo functionality by maintaining a clean state transition."
38422,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilter.setActivityForMemoryToasts(this);
  setResources();
  Resources res=getResources();
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  mEditorPlaceHolder.addEditor(new ImageOnlyEditor());
  mEditorPlaceHolder.addEditor(new EditorTinyPlanet());
  mEditorPlaceHolder.addEditor(new EditorRedEye());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mEditorPlaceHolder.hide();
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager filtersManager=FiltersManager.getManager();
  filtersManager.addEffects(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listColors,mColorsButton);
  }
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  LoadBordersTask loadBorders=new LoadBordersTask(listBorders);
  loadBorders.execute();
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  mAction=intent.getAction();
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  if (mAction.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setResources();
  Resources res=getResources();
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  mEditorPlaceHolder.addEditor(new ImageOnlyEditor());
  mEditorPlaceHolder.addEditor(new EditorTinyPlanet());
  mEditorPlaceHolder.addEditor(new EditorRedEye());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mEditorPlaceHolder.hide();
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager filtersManager=FiltersManager.getManager();
  filtersManager.addEffects(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listColors,mColorsButton);
  }
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  LoadBordersTask loadBorders=new LoadBordersTask(listBorders);
  loadBorders.execute();
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  mAction=intent.getAction();
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  if (mAction.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
  }
}","The original code incorrectly called `ImageFilter.setActivityForMemoryToasts(this)` before setting up resources and initializing core components, potentially causing premature method invocations. The fixed code removes this unnecessary method call and reorders initialization steps to ensure proper setup of resources, image loader, and UI components before any potential memory-related operations. By eliminating the extraneous method and maintaining a logical initialization sequence, the fixed code provides a more robust and predictable activity startup process."
38423,"@Override protected void onDestroy(){
  if (mLoadBitmapTask != null) {
    mLoadBitmapTask.cancel(false);
  }
  MasterImage.reset();
  FilteringPipeline.reset();
  ImageFilter.reset();
  super.onDestroy();
}","@Override protected void onDestroy(){
  if (mLoadBitmapTask != null) {
    mLoadBitmapTask.cancel(false);
  }
  super.onDestroy();
}","The original code incorrectly called static reset methods on MasterImage, FilteringPipeline, and ImageFilter, which could lead to unintended side effects and potential memory leaks across the entire application. The fixed code removes these unnecessary reset calls, preserving only the task cancellation and calling the superclass method, which ensures proper lifecycle management. By eliminating global state modifications, the fixed code prevents potential crashes and maintains better encapsulation during activity destruction."
38424,"public static FilteringPipeline getPipeline(){
  if (sPipeline == null) {
    sPipeline=new FilteringPipeline();
  }
  return sPipeline;
}","public static FilteringPipeline getPipeline(){
  return gPipeline;
}","The original code attempts to implement a singleton pattern but lacks thread safety, potentially creating multiple instances of FilteringPipeline in concurrent scenarios. The fixed code directly returns a pre-initialized static variable `gPipeline`, ensuring a single, consistent instance across all method calls. This approach eliminates race conditions and provides a more reliable singleton implementation with guaranteed thread-safe object creation."
38425,"public Bitmap getScaleOneImageForPreset(ImageShow caller,ImagePreset imagePreset,Rect bounds,Rect destination,boolean force){
  mLoadingLock.lock();
  Bitmap bmp=mZoomCache.getImage(imagePreset,bounds);
  if (force || bmp == null) {
    BitmapFactory.Options options=null;
    if (destination != null) {
      options=new BitmapFactory.Options();
      if (bounds.width() > destination.width()) {
        int sampleSize=1;
        int w=bounds.width();
        while (w > destination.width()) {
          sampleSize*=2;
          w/=sampleSize;
        }
        options.inSampleSize=sampleSize;
      }
    }
    bmp=loadRegionBitmap(mUri,options,bounds);
    if (bmp != null) {
      float scaleFactor=imagePreset.getScaleFactor();
      imagePreset.setScaleFactor(1.0f);
      bmp=imagePreset.apply(bmp);
      imagePreset.setScaleFactor(scaleFactor);
      mZoomCache.setImage(imagePreset,bounds,bmp);
      mLoadingLock.unlock();
      return bmp;
    }
  }
  mLoadingLock.unlock();
  return bmp;
}","public Bitmap getScaleOneImageForPreset(ImageShow caller,ImagePreset imagePreset,Rect bounds,Rect destination,boolean force){
  mLoadingLock.lock();
  Bitmap bmp=mZoomCache.getImage(imagePreset,bounds);
  if (force || bmp == null) {
    BitmapFactory.Options options=null;
    if (destination != null) {
      options=new BitmapFactory.Options();
      if (bounds.width() > destination.width()) {
        int sampleSize=1;
        int w=bounds.width();
        while (w > destination.width()) {
          sampleSize*=2;
          w/=sampleSize;
        }
        options.inSampleSize=sampleSize;
      }
    }
    bmp=loadRegionBitmap(mUri,options,bounds);
    if (bmp != null) {
      Bitmap bmp2=bmp.copy(Bitmap.Config.ARGB_8888,true);
      float scaleFactor=imagePreset.getScaleFactor();
      imagePreset.setScaleFactor(1.0f);
      bmp2=imagePreset.apply(bmp2);
      imagePreset.setScaleFactor(scaleFactor);
      mZoomCache.setImage(imagePreset,bounds,bmp2);
      mLoadingLock.unlock();
      return bmp2;
    }
  }
  mLoadingLock.unlock();
  return bmp;
}","The original code directly modifies and applies the preset to the cached bitmap, which could lead to unintended side effects and bitmap mutation. The fixed code creates a mutable copy of the bitmap using `bmp.copy()` before applying the preset, ensuring the original bitmap remains unaltered. This approach prevents potential memory leaks and maintains bitmap integrity while preserving the intended image transformation logic."
38426,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null) {
    return bitmap;
  }
  try {
    prepare(bitmap,scaleFactor,quality);
    runFilter();
    update(bitmap);
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  java.lang.OutOfMemoryError e) {
    System.gc();
    displayLowMemoryToast();
    Log.e(LOGTAG,""String_Node_Str"" + getName(),e);
  }
  return bitmap;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null) {
    return bitmap;
  }
  try {
    prepare(bitmap,scaleFactor,quality);
    runFilter();
    update(bitmap);
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
  return bitmap;
}","The original code improperly handled OutOfMemoryError by calling System.gc() and displaying a low memory toast, which are ineffective memory management techniques. The fixed code removes the OutOfMemoryError catch block, eliminating unnecessary and potentially disruptive error handling that does not genuinely resolve memory constraints. By simplifying exception handling, the fixed code provides a more robust and predictable method for processing bitmaps without attempting futile memory recovery strategies."
38427,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setResources();
  Resources res=getResources();
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  mEditorPlaceHolder.addEditor(new ImageOnlyEditor());
  mEditorPlaceHolder.addEditor(new EditorTinyPlanet());
  mEditorPlaceHolder.addEditor(new EditorRedEye());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mEditorPlaceHolder.hide();
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager filtersManager=FiltersManager.getManager();
  filtersManager.addEffects(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listColors,mColorsButton);
  }
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  LoadBordersTask loadBorders=new LoadBordersTask(listBorders);
  loadBorders.execute();
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  mAction=intent.getAction();
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  if (mAction.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilter.setActivityForMemoryToasts(this);
  setResources();
  Resources res=getResources();
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  mEditorPlaceHolder.addEditor(new ImageOnlyEditor());
  mEditorPlaceHolder.addEditor(new EditorTinyPlanet());
  mEditorPlaceHolder.addEditor(new EditorRedEye());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mEditorPlaceHolder.hide();
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager filtersManager=FiltersManager.getManager();
  filtersManager.addEffects(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listColors,mColorsButton);
  }
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  LoadBordersTask loadBorders=new LoadBordersTask(listBorders);
  loadBorders.execute();
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  mAction=intent.getAction();
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  if (mAction.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
  }
}","The original code lacked a critical method call to set the activity context for memory toast notifications. The fixed code adds `ImageFilter.setActivityForMemoryToasts(this)` at the beginning of the `onCreate` method, ensuring proper context registration for memory-related user feedback. This addition improves error handling and user experience by enabling more informative memory management notifications during image filtering operations."
38428,"@Override protected void onDestroy(){
  if (mLoadBitmapTask != null) {
    mLoadBitmapTask.cancel(false);
  }
  super.onDestroy();
}","@Override protected void onDestroy(){
  if (mLoadBitmapTask != null) {
    mLoadBitmapTask.cancel(false);
  }
  MasterImage.reset();
  FilteringPipeline.reset();
  ImageFilter.resetStatics();
  super.onDestroy();
}","The original code only cancels the bitmap loading task without properly cleaning up static resources, which can lead to memory leaks and potential application instability. The fixed code adds reset methods for MasterImage, FilteringPipeline, and ImageFilter to comprehensively clear static state and release associated resources. By thoroughly resetting these components before calling the superclass method, the fixed implementation ensures complete cleanup and prevents potential memory-related issues during activity destruction."
38429,"public static FilteringPipeline getPipeline(){
  return gPipeline;
}","public static FilteringPipeline getPipeline(){
  if (sPipeline == null) {
    sPipeline=new FilteringPipeline();
  }
  return sPipeline;
}","The original code simply returns a potentially uninitialized global pipeline object, which could lead to null reference errors or inconsistent state. The fixed code introduces a lazy initialization check, creating the pipeline object only if it doesn't already exist, ensuring thread-safe and on-demand object creation. This approach prevents null pointer exceptions and guarantees that a single, properly initialized FilteringPipeline instance is always returned."
38430,"public Bitmap getScaleOneImageForPreset(ImageShow caller,ImagePreset imagePreset,Rect bounds,Rect destination,boolean force){
  mLoadingLock.lock();
  Bitmap bmp=mZoomCache.getImage(imagePreset,bounds);
  if (force || bmp == null) {
    BitmapFactory.Options options=null;
    if (destination != null) {
      options=new BitmapFactory.Options();
      if (bounds.width() > destination.width()) {
        int sampleSize=1;
        int w=bounds.width();
        while (w > destination.width()) {
          sampleSize*=2;
          w/=sampleSize;
        }
        options.inSampleSize=sampleSize;
      }
    }
    bmp=loadRegionBitmap(mUri,options,bounds);
    if (destination != null) {
      mLoadingLock.unlock();
      return bmp;
    }
    if (bmp != null) {
      Bitmap bmp2=bmp.copy(Bitmap.Config.ARGB_8888,true);
      float scaleFactor=imagePreset.getScaleFactor();
      imagePreset.setScaleFactor(1.0f);
      bmp2=imagePreset.apply(bmp2);
      imagePreset.setScaleFactor(scaleFactor);
      mZoomCache.setImage(imagePreset,bounds,bmp2);
      mLoadingLock.unlock();
      return bmp2;
    }
  }
  mLoadingLock.unlock();
  return bmp;
}","public Bitmap getScaleOneImageForPreset(ImageShow caller,ImagePreset imagePreset,Rect bounds,Rect destination,boolean force){
  mLoadingLock.lock();
  Bitmap bmp=mZoomCache.getImage(imagePreset,bounds);
  if (force || bmp == null) {
    BitmapFactory.Options options=null;
    if (destination != null) {
      options=new BitmapFactory.Options();
      if (bounds.width() > destination.width()) {
        int sampleSize=1;
        int w=bounds.width();
        while (w > destination.width()) {
          sampleSize*=2;
          w/=sampleSize;
        }
        options.inSampleSize=sampleSize;
      }
    }
    bmp=loadRegionBitmap(mUri,options,bounds);
    if (destination != null) {
      mLoadingLock.unlock();
      return bmp;
    }
    if (bmp != null) {
      float scaleFactor=imagePreset.getScaleFactor();
      imagePreset.setScaleFactor(1.0f);
      bmp=imagePreset.apply(bmp);
      imagePreset.setScaleFactor(scaleFactor);
      mZoomCache.setImage(imagePreset,bounds,bmp);
      mLoadingLock.unlock();
      return bmp;
    }
  }
  mLoadingLock.unlock();
  return bmp;
}","The original code created an unnecessary bitmap copy (`bmp2`) before applying the preset, wasting memory and processing resources. In the fixed code, the preset is directly applied to the original bitmap (`bmp`), eliminating the redundant copy operation. This optimization reduces memory overhead, improves performance, and simplifies the bitmap transformation process without changing the core functionality."
38431,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null) {
    return bitmap;
  }
  try {
    prepare(bitmap,scaleFactor,quality);
    runFilter();
    update(bitmap);
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
  return bitmap;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null) {
    return bitmap;
  }
  try {
    prepare(bitmap,scaleFactor,quality);
    runFilter();
    update(bitmap);
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  java.lang.OutOfMemoryError e) {
    System.gc();
    displayLowMemoryToast();
    Log.e(LOGTAG,""String_Node_Str"" + getName(),e);
  }
  return bitmap;
}","The original code lacked handling for OutOfMemoryError, which could cause app crashes during bitmap processing. The fixed code adds a catch block for OutOfMemoryError, implementing system garbage collection, displaying a low memory toast, and logging the error. This enhancement improves app robustness by gracefully managing memory-related exceptions during image manipulation."
38432,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setResources();
  Resources res=getResources();
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  mEditorPlaceHolder.addEditor(new ImageOnlyEditor());
  mEditorPlaceHolder.addEditor(new EditorTinyPlanet());
  mEditorPlaceHolder.addEditor(new EditorRedEye());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mEditorPlaceHolder.hide();
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager filtersManager=FiltersManager.getManager();
  filtersManager.addEffects(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listColors,mColorsButton);
  }
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  LoadBordersTask loadBorders=new LoadBordersTask(listBorders);
  loadBorders.execute();
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  mAction=intent.getAction();
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  if (mAction.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilter.setActivityForMemoryToasts(this);
  setResources();
  Resources res=getResources();
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  mEditorPlaceHolder.addEditor(new ImageOnlyEditor());
  mEditorPlaceHolder.addEditor(new EditorTinyPlanet());
  mEditorPlaceHolder.addEditor(new EditorRedEye());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mEditorPlaceHolder.hide();
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager filtersManager=FiltersManager.getManager();
  filtersManager.addEffects(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listColors,mColorsButton);
  }
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  LoadBordersTask loadBorders=new LoadBordersTask(listBorders);
  loadBorders.execute();
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  mAction=intent.getAction();
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  if (mAction.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
  }
}","The original code lacked a crucial method call to set the activity context for memory-related toast notifications. The fixed code adds `ImageFilter.setActivityForMemoryToasts(this)` at the beginning of the `onCreate` method, which ensures proper context setting for displaying memory-related messages. This addition improves error handling and user feedback by enabling the application to show memory-related notifications more effectively and consistently."
38433,"@Override protected void onDestroy(){
  if (mLoadBitmapTask != null) {
    mLoadBitmapTask.cancel(false);
  }
  super.onDestroy();
}","@Override protected void onDestroy(){
  if (mLoadBitmapTask != null) {
    mLoadBitmapTask.cancel(false);
  }
  MasterImage.reset();
  FilteringPipeline.reset();
  ImageFilter.reset();
  super.onDestroy();
}","The original code only cancels a bitmap loading task without properly cleaning up resources, potentially leading to memory leaks and unresolved background processes. The fixed code adds reset methods for MasterImage, FilteringPipeline, and ImageFilter, ensuring comprehensive cleanup of associated resources and preventing potential memory-related issues. By thoroughly resetting critical components before calling the superclass method, the fixed implementation provides a more robust and memory-efficient destruction of the activity or fragment."
38434,"public static FilteringPipeline getPipeline(){
  return gPipeline;
}","public static FilteringPipeline getPipeline(){
  if (sPipeline == null) {
    sPipeline=new FilteringPipeline();
  }
  return sPipeline;
}","The original code simply returns a potentially uninitialized global pipeline object without ensuring its existence. The fixed code adds a null check and lazy initialization, creating the pipeline object only when it's first requested. This approach guarantees that a valid FilteringPipeline instance is always returned, preventing null pointer exceptions and implementing a thread-safe singleton pattern for pipeline creation."
38435,"public Bitmap getScaleOneImageForPreset(ImageShow caller,ImagePreset imagePreset,Rect bounds,Rect destination,boolean force){
  mLoadingLock.lock();
  Bitmap bmp=mZoomCache.getImage(imagePreset,bounds);
  if (force || bmp == null) {
    BitmapFactory.Options options=null;
    if (destination != null) {
      options=new BitmapFactory.Options();
      if (bounds.width() > destination.width()) {
        int sampleSize=1;
        int w=bounds.width();
        while (w > destination.width()) {
          sampleSize*=2;
          w/=sampleSize;
        }
        options.inSampleSize=sampleSize;
      }
    }
    bmp=loadRegionBitmap(mUri,options,bounds);
    if (destination != null) {
      mLoadingLock.unlock();
      return bmp;
    }
    if (bmp != null) {
      Bitmap bmp2=bmp.copy(Bitmap.Config.ARGB_8888,true);
      float scaleFactor=imagePreset.getScaleFactor();
      imagePreset.setScaleFactor(1.0f);
      bmp2=imagePreset.apply(bmp2);
      imagePreset.setScaleFactor(scaleFactor);
      mZoomCache.setImage(imagePreset,bounds,bmp2);
      mLoadingLock.unlock();
      return bmp2;
    }
  }
  mLoadingLock.unlock();
  return bmp;
}","public Bitmap getScaleOneImageForPreset(ImageShow caller,ImagePreset imagePreset,Rect bounds,Rect destination,boolean force){
  mLoadingLock.lock();
  Bitmap bmp=mZoomCache.getImage(imagePreset,bounds);
  if (force || bmp == null) {
    BitmapFactory.Options options=null;
    if (destination != null) {
      options=new BitmapFactory.Options();
      if (bounds.width() > destination.width()) {
        int sampleSize=1;
        int w=bounds.width();
        while (w > destination.width()) {
          sampleSize*=2;
          w/=sampleSize;
        }
        options.inSampleSize=sampleSize;
      }
    }
    bmp=loadRegionBitmap(mUri,options,bounds);
    if (destination != null) {
      mLoadingLock.unlock();
      return bmp;
    }
    if (bmp != null) {
      float scaleFactor=imagePreset.getScaleFactor();
      imagePreset.setScaleFactor(1.0f);
      bmp=imagePreset.apply(bmp);
      imagePreset.setScaleFactor(scaleFactor);
      mZoomCache.setImage(imagePreset,bounds,bmp);
      mLoadingLock.unlock();
      return bmp;
    }
  }
  mLoadingLock.unlock();
  return bmp;
}","The original code created an unnecessary copy of the bitmap with `bmp.copy()`, which was inefficient and potentially memory-intensive. In the fixed code, the bitmap is directly modified by applying the preset to the original bitmap without creating a redundant copy. This optimization reduces memory allocation, improves performance, and ensures the same functional result with cleaner, more direct bitmap manipulation."
38436,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null) {
    return bitmap;
  }
  try {
    prepare(bitmap,scaleFactor,quality);
    runFilter();
    update(bitmap);
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
  return bitmap;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null) {
    return bitmap;
  }
  try {
    prepare(bitmap,scaleFactor,quality);
    runFilter();
    update(bitmap);
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  java.lang.OutOfMemoryError e) {
    System.gc();
    displayLowMemoryToast();
    Log.e(LOGTAG,""String_Node_Str"" + getName(),e);
  }
  return bitmap;
}","The original code lacked handling for potential OutOfMemoryError exceptions during bitmap processing, which could cause app crashes. The fixed code adds a specific catch block for OutOfMemoryError that calls System.gc() to trigger garbage collection, displays a low memory toast notification, and logs the error. This improvement enhances the method's robustness by gracefully managing memory-related issues without terminating the application."
38437,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setResources();
  Resources res=getResources();
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  mEditorPlaceHolder.addEditor(new ImageOnlyEditor());
  mEditorPlaceHolder.addEditor(new EditorTinyPlanet());
  mEditorPlaceHolder.addEditor(new EditorRedEye());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mEditorPlaceHolder.hide();
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager filtersManager=FiltersManager.getManager();
  filtersManager.addEffects(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listColors,mColorsButton);
  }
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  LoadBordersTask loadBorders=new LoadBordersTask(listBorders);
  loadBorders.execute();
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  mAction=intent.getAction();
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  if (mAction.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilter.setActivityForMemoryToasts(this);
  setResources();
  Resources res=getResources();
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  mEditorPlaceHolder.addEditor(new ImageOnlyEditor());
  mEditorPlaceHolder.addEditor(new EditorTinyPlanet());
  mEditorPlaceHolder.addEditor(new EditorRedEye());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mEditorPlaceHolder.hide();
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager filtersManager=FiltersManager.getManager();
  filtersManager.addEffects(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listColors,mColorsButton);
  }
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  LoadBordersTask loadBorders=new LoadBordersTask(listBorders);
  loadBorders.execute();
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  mAction=intent.getAction();
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  if (mAction.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
  }
}","The original code lacked a crucial initialization method for memory-related toast notifications in the image filter system. The fixed code adds `ImageFilter.setActivityForMemoryToasts(this)` at the beginning of the `onCreate` method, which properly sets the activity context for displaying memory-related messages. This addition improves error handling and user feedback by enabling proper memory management notifications during the image filtering process."
38438,"@Override protected void onDestroy(){
  if (mLoadBitmapTask != null) {
    mLoadBitmapTask.cancel(false);
  }
  super.onDestroy();
}","@Override protected void onDestroy(){
  if (mLoadBitmapTask != null) {
    mLoadBitmapTask.cancel(false);
  }
  MasterImage.reset();
  FilteringPipeline.reset();
  ImageFilter.resetStatics();
  super.onDestroy();
}","The original code only cancels the bitmap loading task without properly cleaning up associated static resources, which could lead to memory leaks. The fixed code adds reset methods for MasterImage, FilteringPipeline, and ImageFilter to comprehensively clear static state and prevent potential memory-related issues. By thoroughly resetting static components before calling the superclass method, the fixed implementation ensures complete resource cleanup and prevents lingering references that could cause memory inefficiencies."
38439,"public static FilteringPipeline getPipeline(){
  return gPipeline;
}","public static FilteringPipeline getPipeline(){
  if (sPipeline == null) {
    sPipeline=new FilteringPipeline();
  }
  return sPipeline;
}","The original code simply returns a global pipeline variable without ensuring its initialization, which could lead to null reference errors. The fixed code adds a null check and creates a new FilteringPipeline instance if it hasn't been instantiated, implementing lazy initialization. This approach guarantees that a valid pipeline object is always returned, preventing potential null pointer exceptions and ensuring thread-safe singleton-like behavior."
38440,"public Bitmap getScaleOneImageForPreset(ImageShow caller,ImagePreset imagePreset,Rect bounds,Rect destination,boolean force){
  mLoadingLock.lock();
  Bitmap bmp=mZoomCache.getImage(imagePreset,bounds);
  if (force || bmp == null) {
    BitmapFactory.Options options=null;
    if (destination != null) {
      options=new BitmapFactory.Options();
      if (bounds.width() > destination.width()) {
        int sampleSize=1;
        int w=bounds.width();
        while (w > destination.width()) {
          sampleSize*=2;
          w/=sampleSize;
        }
        options.inSampleSize=sampleSize;
      }
    }
    bmp=loadRegionBitmap(mUri,options,bounds);
    if (bmp != null) {
      Bitmap bmp2=bmp.copy(Bitmap.Config.ARGB_8888,true);
      float scaleFactor=imagePreset.getScaleFactor();
      imagePreset.setScaleFactor(1.0f);
      bmp2=imagePreset.apply(bmp2);
      imagePreset.setScaleFactor(scaleFactor);
      mZoomCache.setImage(imagePreset,bounds,bmp2);
      mLoadingLock.unlock();
      return bmp2;
    }
  }
  mLoadingLock.unlock();
  return bmp;
}","public Bitmap getScaleOneImageForPreset(ImageShow caller,ImagePreset imagePreset,Rect bounds,Rect destination,boolean force){
  mLoadingLock.lock();
  Bitmap bmp=mZoomCache.getImage(imagePreset,bounds);
  if (force || bmp == null) {
    BitmapFactory.Options options=null;
    if (destination != null) {
      options=new BitmapFactory.Options();
      if (bounds.width() > destination.width()) {
        int sampleSize=1;
        int w=bounds.width();
        while (w > destination.width()) {
          sampleSize*=2;
          w/=sampleSize;
        }
        options.inSampleSize=sampleSize;
      }
    }
    bmp=loadRegionBitmap(mUri,options,bounds);
    if (bmp != null) {
      float scaleFactor=imagePreset.getScaleFactor();
      imagePreset.setScaleFactor(1.0f);
      bmp=imagePreset.apply(bmp);
      imagePreset.setScaleFactor(scaleFactor);
      mZoomCache.setImage(imagePreset,bounds,bmp);
      mLoadingLock.unlock();
      return bmp;
    }
  }
  mLoadingLock.unlock();
  return bmp;
}","The original code unnecessarily created a copy of the bitmap using `bmp.copy()`, which was inefficient and potentially memory-intensive. In the fixed version, the bitmap is directly modified by applying the preset without creating an intermediate copy, and the original bitmap is used throughout. This optimization reduces memory allocation, improves performance, and simplifies the bitmap processing workflow while maintaining the same functional behavior."
38441,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null) {
    return bitmap;
  }
  try {
    prepare(bitmap,scaleFactor,quality);
    runFilter();
    update(bitmap);
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
  return bitmap;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null) {
    return bitmap;
  }
  try {
    prepare(bitmap,scaleFactor,quality);
    runFilter();
    update(bitmap);
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  java.lang.OutOfMemoryError e) {
    System.gc();
    displayLowMemoryToast();
    Log.e(LOGTAG,""String_Node_Str"" + getName(),e);
  }
  return bitmap;
}","The original code lacked handling for potential OutOfMemoryError exceptions during bitmap processing, which could cause app crashes. The fixed code adds a third catch block to handle OutOfMemoryError, invoking System.gc() to trigger garbage collection and displaying a low memory toast notification. This improvement enhances the method's robustness by gracefully managing memory-related errors and preventing unexpected application termination."
38442,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setResources();
  Resources res=getResources();
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  mEditorPlaceHolder.addEditor(new ImageOnlyEditor());
  mEditorPlaceHolder.addEditor(new EditorTinyPlanet());
  mEditorPlaceHolder.addEditor(new EditorRedEye());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mEditorPlaceHolder.hide();
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager filtersManager=FiltersManager.getManager();
  filtersManager.addEffects(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listColors,mColorsButton);
  }
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  LoadBordersTask loadBorders=new LoadBordersTask(listBorders);
  loadBorders.execute();
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  mAction=intent.getAction();
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  if (mAction.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilter.setActivityForMemoryToasts(this);
  setResources();
  Resources res=getResources();
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(res.getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(res.getString(R.string.original_picture_text));
  mIconSeedSize=res.getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=res.getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)res.getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  mEditorPlaceHolder.addEditor(new ImageOnlyEditor());
  mEditorPlaceHolder.addEditor(new EditorTinyPlanet());
  mEditorPlaceHolder.addEditor(new EditorRedEye());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mEditorPlaceHolder.hide();
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<FilterRepresentation> filtersRepresentations=new Vector<FilterRepresentation>();
  FiltersManager filtersManager=FiltersManager.getManager();
  filtersManager.addEffects(filtersRepresentations);
  for (  FilterRepresentation representation : filtersRepresentations) {
    setupFilterRepresentationButton(representation,listColors,mColorsButton);
  }
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  LoadBordersTask loadBorders=new LoadBordersTask(listBorders);
  loadBorders.execute();
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  mAction=intent.getAction();
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  if (mAction.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
  }
}","The original code lacked a crucial method call to set the activity context for memory-related toast notifications. The fixed code adds `ImageFilter.setActivityForMemoryToasts(this)` at the beginning of the `onCreate` method, which ensures proper context initialization for displaying memory-related messages. This small addition improves error handling and user feedback by enabling the application to show appropriate memory-related notifications through the correct activity context."
38443,"@Override protected void onDestroy(){
  if (mLoadBitmapTask != null) {
    mLoadBitmapTask.cancel(false);
  }
  super.onDestroy();
}","@Override protected void onDestroy(){
  if (mLoadBitmapTask != null) {
    mLoadBitmapTask.cancel(false);
  }
  MasterImage.reset();
  FilteringPipeline.reset();
  ImageFilter.reset();
  super.onDestroy();
}","The original code only cancels a bitmap loading task without properly cleaning up associated resources, potentially leading to memory leaks. The fixed code adds reset calls to MasterImage, FilteringPipeline, and ImageFilter, ensuring comprehensive cleanup of image-related components and preventing potential memory and resource management issues. These additional reset methods guarantee a thorough release of system resources, improving the overall memory efficiency and preventing potential background process remnants."
38444,"public static FilteringPipeline getPipeline(){
  return gPipeline;
}","public static FilteringPipeline getPipeline(){
  if (sPipeline == null) {
    sPipeline=new FilteringPipeline();
  }
  return sPipeline;
}","The original code simply returns a global pipeline without ensuring its initialization, potentially leading to null reference errors. The fixed code introduces a lazy initialization check, creating the pipeline object only if it doesn't already exist, using the sPipeline variable. This approach guarantees a non-null FilteringPipeline instance is always returned, providing a thread-safe and memory-efficient singleton pattern implementation."
38445,"public Bitmap getScaleOneImageForPreset(ImageShow caller,ImagePreset imagePreset,Rect bounds,Rect destination,boolean force){
  mLoadingLock.lock();
  Bitmap bmp=mZoomCache.getImage(imagePreset,bounds);
  if (force || bmp == null) {
    BitmapFactory.Options options=null;
    if (destination != null) {
      options=new BitmapFactory.Options();
      if (bounds.width() > destination.width()) {
        int sampleSize=1;
        int w=bounds.width();
        while (w > destination.width()) {
          sampleSize*=2;
          w/=sampleSize;
        }
        options.inSampleSize=sampleSize;
      }
    }
    bmp=loadRegionBitmap(mUri,options,bounds);
    if (bmp != null) {
      Bitmap bmp2=bmp.copy(Bitmap.Config.ARGB_8888,true);
      float scaleFactor=imagePreset.getScaleFactor();
      imagePreset.setScaleFactor(1.0f);
      bmp2=imagePreset.apply(bmp2);
      imagePreset.setScaleFactor(scaleFactor);
      mZoomCache.setImage(imagePreset,bounds,bmp2);
      mLoadingLock.unlock();
      return bmp2;
    }
  }
  mLoadingLock.unlock();
  return bmp;
}","public Bitmap getScaleOneImageForPreset(ImageShow caller,ImagePreset imagePreset,Rect bounds,Rect destination,boolean force){
  mLoadingLock.lock();
  Bitmap bmp=mZoomCache.getImage(imagePreset,bounds);
  if (force || bmp == null) {
    BitmapFactory.Options options=null;
    if (destination != null) {
      options=new BitmapFactory.Options();
      if (bounds.width() > destination.width()) {
        int sampleSize=1;
        int w=bounds.width();
        while (w > destination.width()) {
          sampleSize*=2;
          w/=sampleSize;
        }
        options.inSampleSize=sampleSize;
      }
    }
    bmp=loadRegionBitmap(mUri,options,bounds);
    if (bmp != null) {
      float scaleFactor=imagePreset.getScaleFactor();
      imagePreset.setScaleFactor(1.0f);
      bmp=imagePreset.apply(bmp);
      imagePreset.setScaleFactor(scaleFactor);
      mZoomCache.setImage(imagePreset,bounds,bmp);
      mLoadingLock.unlock();
      return bmp;
    }
  }
  mLoadingLock.unlock();
  return bmp;
}","The original code unnecessarily created a copy of the bitmap using `bmp.copy()`, which was inefficient and potentially memory-intensive. In the fixed code, the bitmap is directly modified by applying the preset without creating an additional copy, using `bmp=imagePreset.apply(bmp)` instead of `bmp2=bmp.copy(...).apply(...)`. This change reduces memory overhead, improves performance, and simplifies the bitmap processing workflow while maintaining the same functional behavior."
38446,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null) {
    return bitmap;
  }
  try {
    prepare(bitmap,scaleFactor,quality);
    runFilter();
    update(bitmap);
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
  return bitmap;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,int quality){
  if (bitmap == null) {
    return bitmap;
  }
  try {
    prepare(bitmap,scaleFactor,quality);
    runFilter();
    update(bitmap);
  }
 catch (  android.renderscript.RSIllegalArgumentException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  android.renderscript.RSRuntimeException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e);
  }
catch (  java.lang.OutOfMemoryError e) {
    System.gc();
    displayLowMemoryToast();
    Log.e(LOGTAG,""String_Node_Str"" + getName(),e);
  }
  return bitmap;
}","The original code lacks handling for potential OutOfMemoryError exceptions, which can crash the application during bitmap processing. The fixed code adds a catch block for OutOfMemoryError, implementing a graceful recovery mechanism by calling System.gc() and displaying a low memory toast notification. This enhancement improves application robustness by preventing unexpected termination and providing user feedback during memory-intensive bitmap operations."
38447,"public void setRepresentation(FilterVignetteRepresentation vignetteRep){
  mVignetteRep=vignetteRep;
  Matrix toImg=getScreenToImageMatrix(false);
  Matrix toScr=new Matrix();
  toImg.invert(toScr);
  float[] c=new float[]{mVignetteRep.getCenterX(),mVignetteRep.getCenterY()};
  if (Float.isNaN(c[0])) {
    float cx=mImageLoader.getOriginalBounds().width() / 2;
    float cy=mImageLoader.getOriginalBounds().height() / 2;
    float rx=cx * .8f;
    float ry=cy * .8f;
    mVignetteRep.setCenter(cx,cy);
    mVignetteRep.setRadius(rx,ry);
    c[0]=cx;
    c[1]=cy;
    toScr.mapPoints(c);
    mElipse.setCenter(c[0],c[1]);
    mElipse.setRadius(c[0] * 0.8f,c[1] * 0.8f);
  }
 else {
    toScr.mapPoints(c);
    mElipse.setCenter(c[0],c[1]);
    mElipse.setRadius(toScr.mapRadius(mVignetteRep.getRadiusX()),toScr.mapRadius(mVignetteRep.getRadiusY()));
  }
}","public void setRepresentation(FilterVignetteRepresentation vignetteRep){
  mVignetteRep=vignetteRep;
  Matrix toImg=getScreenToImageMatrix(false);
  Matrix toScr=new Matrix();
  toImg.invert(toScr);
  float[] c=new float[]{mVignetteRep.getCenterX(),mVignetteRep.getCenterY()};
  if (Float.isNaN(c[0])) {
    float cx=mImageLoader.getOriginalBounds().width() / 2;
    float cy=mImageLoader.getOriginalBounds().height() / 2;
    float rx=Math.min(cx,cy) * .8f;
    float ry=rx;
    mVignetteRep.setCenter(cx,cy);
    mVignetteRep.setRadius(rx,ry);
    c[0]=cx;
    c[1]=cy;
    toScr.mapPoints(c);
    if (getWidth() != 0) {
      mElipse.setCenter(c[0],c[1]);
      mElipse.setRadius(c[0] * 0.8f,c[1] * 0.8f);
    }
  }
 else {
    toScr.mapPoints(c);
    mElipse.setCenter(c[0],c[1]);
    mElipse.setRadius(toScr.mapRadius(mVignetteRep.getRadiusX()),toScr.mapRadius(mVignetteRep.getRadiusY()));
  }
}","The original code incorrectly set different radii for x and y, potentially causing asymmetric vignette effects and potential division by zero issues. The fixed code uses `Math.min(cx,cy)` to create a symmetric, proportional radius and adds a null check with `getWidth() != 0` to prevent potential runtime errors. These modifications ensure consistent, safe vignette rendering across different image dimensions and screen configurations."
38448,"@Override public void onDraw(Canvas canvas){
  super.onDraw(canvas);
  mElipse.draw(canvas);
}","@Override public void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mElipse.isUndefined()) {
    setRepresentation(mVignetteRep);
  }
  mElipse.draw(canvas);
}","The original code blindly draws an ellipse without checking its state, which could lead to rendering errors if the ellipse is undefined or improperly initialized. The fixed code adds a conditional check using `isUndefined()` and calls `setRepresentation()` to ensure the ellipse has a valid representation before drawing. This proactive validation prevents potential null pointer exceptions and guarantees a robust rendering process by setting up the correct visual representation before drawing."
38449,"private void showPopupMenu(LinearLayout accessoryViewList){
  final FramedTextButton button=(FramedTextButton)accessoryViewList.findViewById(R.id.drawUtilityButton);
  if (button == null) {
    return;
  }
  final PopupMenu popupMenu=new PopupMenu(mImageShow.getActivity(),button);
  popupMenu.getMenuInflater().inflate(R.menu.filtershow_menu_draw,popupMenu.getMenu());
  popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
    @Override public boolean onMenuItemClick(    MenuItem item){
      ImageFilterDraw filter=(ImageFilterDraw)mImageShow.getCurrentFilter();
      if (item.getItemId() == R.id.draw_menu_color) {
        showColorGrid(item);
      }
 else       if (item.getItemId() == R.id.draw_menu_size) {
        showSizeDialog(item);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_brush_marker) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_MARKER);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_brush_spatter) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_SPATTER);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_line) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.SIMPLE_STYLE);
      }
 else       if (item.getItemId() == R.id.draw_menu_clear) {
        FilterDrawRepresentation drawRep=(FilterDrawRepresentation)getLocalRepresentation();
        drawRep.clear();
        commitLocalRepresentation();
      }
      mView.invalidate();
      return true;
    }
  }
);
  popupMenu.show();
}","private void showPopupMenu(LinearLayout accessoryViewList){
  final FramedTextButton button=(FramedTextButton)accessoryViewList.findViewById(R.id.drawUtilityButton);
  if (button == null) {
    return;
  }
  final PopupMenu popupMenu=new PopupMenu(mImageShow.getActivity(),button);
  popupMenu.getMenuInflater().inflate(R.menu.filtershow_menu_draw,popupMenu.getMenu());
  popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
    @Override public boolean onMenuItemClick(    MenuItem item){
      ImageFilterDraw filter=(ImageFilterDraw)mImageShow.getCurrentFilter();
      if (item.getItemId() == R.id.draw_menu_color) {
        showColorGrid(item);
      }
 else       if (item.getItemId() == R.id.draw_menu_size) {
        showSizeDialog(item);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_brush_marker) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_MARKER);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_brush_spatter) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_SPATTER);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_line) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.SIMPLE_STYLE);
      }
 else       if (item.getItemId() == R.id.draw_menu_clear) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.resetParameter();
        commitLocalRepresentation();
      }
      mView.invalidate();
      return true;
    }
  }
);
  popupMenu.show();
}","The original code incorrectly attempts to clear drawing parameters by directly calling `clear()` on a `FilterDrawRepresentation`, which may not properly reset the drawing state. In the fixed code, `resetParameter()` is called on the `ImageDraw` instance, ensuring a comprehensive reset of drawing settings. This change provides a more robust and consistent method for clearing drawing parameters, maintaining the integrity of the image editing functionality."
38450,"@Override public boolean onMenuItemClick(MenuItem item){
  ImageFilterDraw filter=(ImageFilterDraw)mImageShow.getCurrentFilter();
  if (item.getItemId() == R.id.draw_menu_color) {
    showColorGrid(item);
  }
 else   if (item.getItemId() == R.id.draw_menu_size) {
    showSizeDialog(item);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_brush_marker) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_MARKER);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_brush_spatter) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_SPATTER);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_line) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.SIMPLE_STYLE);
  }
 else   if (item.getItemId() == R.id.draw_menu_clear) {
    FilterDrawRepresentation drawRep=(FilterDrawRepresentation)getLocalRepresentation();
    drawRep.clear();
    commitLocalRepresentation();
  }
  mView.invalidate();
  return true;
}","@Override public boolean onMenuItemClick(MenuItem item){
  ImageFilterDraw filter=(ImageFilterDraw)mImageShow.getCurrentFilter();
  if (item.getItemId() == R.id.draw_menu_color) {
    showColorGrid(item);
  }
 else   if (item.getItemId() == R.id.draw_menu_size) {
    showSizeDialog(item);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_brush_marker) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_MARKER);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_brush_spatter) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_SPATTER);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_line) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.SIMPLE_STYLE);
  }
 else   if (item.getItemId() == R.id.draw_menu_clear) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.resetParameter();
    commitLocalRepresentation();
  }
  mView.invalidate();
  return true;
}","The original code incorrectly used `FilterDrawRepresentation.clear()` to reset drawing parameters, which may not properly clear all drawing elements. The fixed code replaces this with `idraw.resetParameter()`, which is a more appropriate method for resetting the drawing state in the `ImageDraw` class. This change ensures a more reliable and comprehensive reset of drawing parameters, improving the overall functionality of the drawing interface."
38451,"@Override public void useParametersFrom(FilterRepresentation a){
  if (a instanceof FilterDrawRepresentation) {
    FilterDrawRepresentation representation=(FilterDrawRepresentation)a;
    try {
      if (representation.mCurrent != null) {
        mCurrent=(StrokeData)representation.mCurrent.clone();
      }
 else {
        mCurrent=null;
      }
      if (representation.mDrawing != null) {
        mDrawing=(Vector<StrokeData>)representation.mDrawing.clone();
      }
    }
 catch (    CloneNotSupportedException e) {
      e.printStackTrace();
    }
  }
 else {
    Log.v(LOGTAG,""String_Node_Str"" + a);
  }
}","@Override public void useParametersFrom(FilterRepresentation a){
  if (a instanceof FilterDrawRepresentation) {
    FilterDrawRepresentation representation=(FilterDrawRepresentation)a;
    try {
      if (representation.mCurrent != null) {
        mCurrent=(StrokeData)representation.mCurrent.clone();
      }
 else {
        mCurrent=null;
      }
      if (representation.mDrawing != null) {
        mDrawing=(Vector<StrokeData>)representation.mDrawing.clone();
      }
 else {
        mDrawing=null;
      }
    }
 catch (    CloneNotSupportedException e) {
      e.printStackTrace();
    }
  }
 else {
    Log.v(LOGTAG,""String_Node_Str"" + a);
  }
}","The original code lacked handling for the case when `representation.mDrawing` is null, potentially leading to uninitialized data. The fixed code adds an `else` block to set `mDrawing` to null when the source drawing is null, ensuring consistent state and preventing potential null pointer exceptions. This change provides robust null handling, making the code more defensive and predictable during object parameter copying."
38452,"public void drawData(Canvas canvas,Matrix originalRotateToScreen,int quality){
  Paint paint=new Paint();
  if (quality == ImagePreset.QUALITY_FINAL) {
    paint.setAntiAlias(true);
  }
  paint.setStyle(Style.STROKE);
  paint.setColor(Color.RED);
  paint.setStrokeWidth(40);
  if (mParameters.getDrawing().isEmpty() && mParameters.getCurrentDrawing() == null) {
    return;
  }
  if (quality == ImagePreset.QUALITY_FINAL) {
    for (    FilterDrawRepresentation.StrokeData strokeData : mParameters.getDrawing()) {
      paint(strokeData,canvas,originalRotateToScreen,quality);
    }
    return;
  }
  if (mOverlayBitmap == null || mOverlayBitmap.getWidth() != canvas.getWidth() || mOverlayBitmap.getHeight() != canvas.getHeight()) {
    mOverlayBitmap=Bitmap.createBitmap(canvas.getWidth(),canvas.getHeight(),Bitmap.Config.ARGB_8888);
    mCachedStrokes=0;
  }
  if (mCachedStrokes < mParameters.getDrawing().size()) {
    fillBuffer(originalRotateToScreen);
  }
  canvas.drawBitmap(mOverlayBitmap,0,0,paint);
  StrokeData stroke=mParameters.getCurrentDrawing();
  if (stroke != null) {
    paint(stroke,canvas,originalRotateToScreen,quality);
  }
}","public void drawData(Canvas canvas,Matrix originalRotateToScreen,int quality){
  Paint paint=new Paint();
  if (quality == ImagePreset.QUALITY_FINAL) {
    paint.setAntiAlias(true);
  }
  paint.setStyle(Style.STROKE);
  paint.setColor(Color.RED);
  paint.setStrokeWidth(40);
  if (mParameters.getDrawing().isEmpty() && mParameters.getCurrentDrawing() == null) {
    return;
  }
  if (quality == ImagePreset.QUALITY_FINAL) {
    for (    FilterDrawRepresentation.StrokeData strokeData : mParameters.getDrawing()) {
      paint(strokeData,canvas,originalRotateToScreen,quality);
    }
    return;
  }
  if (mOverlayBitmap == null || mOverlayBitmap.getWidth() != canvas.getWidth() || mOverlayBitmap.getHeight() != canvas.getHeight() || mParameters.getDrawing().size() < mCachedStrokes) {
    mOverlayBitmap=Bitmap.createBitmap(canvas.getWidth(),canvas.getHeight(),Bitmap.Config.ARGB_8888);
    mCachedStrokes=0;
  }
  if (mCachedStrokes < mParameters.getDrawing().size()) {
    fillBuffer(originalRotateToScreen);
  }
  canvas.drawBitmap(mOverlayBitmap,0,0,paint);
  StrokeData stroke=mParameters.getCurrentDrawing();
  if (stroke != null) {
    paint(stroke,canvas,originalRotateToScreen,quality);
  }
}","The original code lacked a condition to recreate the overlay bitmap when the number of drawing strokes decreased, potentially causing rendering inconsistencies. The fixed code adds an additional condition `mParameters.getDrawing().size() < mCachedStrokes` to reset the overlay bitmap and cached strokes count when the drawing size changes. This ensures the overlay bitmap is always synchronized with the current drawing state, preventing potential rendering artifacts and maintaining visual accuracy."
38453,"@Override public void useParametersFrom(FilterRepresentation a){
  if (a instanceof FilterDrawRepresentation) {
    FilterDrawRepresentation representation=(FilterDrawRepresentation)a;
    try {
      if (representation.mCurrent != null) {
        mCurrent=(StrokeData)representation.mCurrent.clone();
      }
 else {
        mCurrent=null;
      }
      if (representation.mDrawing != null) {
        mDrawing=(Vector<StrokeData>)representation.mDrawing.clone();
      }
    }
 catch (    CloneNotSupportedException e) {
      e.printStackTrace();
    }
  }
 else {
    Log.v(LOGTAG,""String_Node_Str"" + a);
  }
}","@Override public void useParametersFrom(FilterRepresentation a){
  if (a instanceof FilterDrawRepresentation) {
    FilterDrawRepresentation representation=(FilterDrawRepresentation)a;
    try {
      if (representation.mCurrent != null) {
        mCurrent=(StrokeData)representation.mCurrent.clone();
      }
 else {
        mCurrent=null;
      }
      if (representation.mDrawing != null) {
        mDrawing=(Vector<StrokeData>)representation.mDrawing.clone();
      }
 else {
        mDrawing=null;
      }
    }
 catch (    CloneNotSupportedException e) {
      e.printStackTrace();
    }
  }
 else {
    Log.v(LOGTAG,""String_Node_Str"" + a);
  }
}","The original code lacked a null check for `mDrawing`, potentially leaving it uninitialized after cloning. The fixed code adds an `else` block to set `mDrawing` to null when the source `representation.mDrawing` is null, ensuring consistent state. This change prevents potential null pointer exceptions and maintains proper object initialization during parameter copying."
38454,"private void showPopupMenu(LinearLayout accessoryViewList){
  final FramedTextButton button=(FramedTextButton)accessoryViewList.findViewById(R.id.drawUtilityButton);
  if (button == null) {
    return;
  }
  final PopupMenu popupMenu=new PopupMenu(mImageShow.getActivity(),button);
  popupMenu.getMenuInflater().inflate(R.menu.filtershow_menu_draw,popupMenu.getMenu());
  popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
    @Override public boolean onMenuItemClick(    MenuItem item){
      ImageFilterDraw filter=(ImageFilterDraw)mImageShow.getCurrentFilter();
      if (item.getItemId() == R.id.draw_menu_color) {
        showColorGrid(item);
      }
 else       if (item.getItemId() == R.id.draw_menu_size) {
        showSizeDialog(item);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_brush_marker) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_MARKER);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_brush_spatter) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_SPATTER);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_line) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.SIMPLE_STYLE);
      }
 else       if (item.getItemId() == R.id.draw_menu_clear) {
        FilterDrawRepresentation drawRep=(FilterDrawRepresentation)getLocalRepresentation();
        drawRep.clear();
        commitLocalRepresentation();
      }
      mView.invalidate();
      return true;
    }
  }
);
  popupMenu.show();
}","private void showPopupMenu(LinearLayout accessoryViewList){
  final FramedTextButton button=(FramedTextButton)accessoryViewList.findViewById(R.id.drawUtilityButton);
  if (button == null) {
    return;
  }
  final PopupMenu popupMenu=new PopupMenu(mImageShow.getActivity(),button);
  popupMenu.getMenuInflater().inflate(R.menu.filtershow_menu_draw,popupMenu.getMenu());
  popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
    @Override public boolean onMenuItemClick(    MenuItem item){
      ImageFilterDraw filter=(ImageFilterDraw)mImageShow.getCurrentFilter();
      if (item.getItemId() == R.id.draw_menu_color) {
        showColorGrid(item);
      }
 else       if (item.getItemId() == R.id.draw_menu_size) {
        showSizeDialog(item);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_brush_marker) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_MARKER);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_brush_spatter) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_SPATTER);
      }
 else       if (item.getItemId() == R.id.draw_menu_style_line) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.setStyle(ImageFilterDraw.SIMPLE_STYLE);
      }
 else       if (item.getItemId() == R.id.draw_menu_clear) {
        ImageDraw idraw=(ImageDraw)mImageShow;
        idraw.resetParameter();
        commitLocalRepresentation();
      }
      mView.invalidate();
      return true;
    }
  }
);
  popupMenu.show();
}","The original code incorrectly used `FilterDrawRepresentation.clear()` to reset drawing parameters, which likely did not fully reset the drawing state. The fixed code replaces this with `idraw.resetParameter()`, a more comprehensive method that properly resets all drawing-related settings. This change ensures a complete reset of drawing parameters, providing a cleaner and more reliable way to clear the drawing state in the image editing interface."
38455,"@Override public boolean onMenuItemClick(MenuItem item){
  ImageFilterDraw filter=(ImageFilterDraw)mImageShow.getCurrentFilter();
  if (item.getItemId() == R.id.draw_menu_color) {
    showColorGrid(item);
  }
 else   if (item.getItemId() == R.id.draw_menu_size) {
    showSizeDialog(item);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_brush_marker) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_MARKER);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_brush_spatter) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_SPATTER);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_line) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.SIMPLE_STYLE);
  }
 else   if (item.getItemId() == R.id.draw_menu_clear) {
    FilterDrawRepresentation drawRep=(FilterDrawRepresentation)getLocalRepresentation();
    drawRep.clear();
    commitLocalRepresentation();
  }
  mView.invalidate();
  return true;
}","@Override public boolean onMenuItemClick(MenuItem item){
  ImageFilterDraw filter=(ImageFilterDraw)mImageShow.getCurrentFilter();
  if (item.getItemId() == R.id.draw_menu_color) {
    showColorGrid(item);
  }
 else   if (item.getItemId() == R.id.draw_menu_size) {
    showSizeDialog(item);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_brush_marker) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_MARKER);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_brush_spatter) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.BRUSH_STYLE_SPATTER);
  }
 else   if (item.getItemId() == R.id.draw_menu_style_line) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.setStyle(ImageFilterDraw.SIMPLE_STYLE);
  }
 else   if (item.getItemId() == R.id.draw_menu_clear) {
    ImageDraw idraw=(ImageDraw)mImageShow;
    idraw.resetParameter();
    commitLocalRepresentation();
  }
  mView.invalidate();
  return true;
}","The original code incorrectly used `FilterDrawRepresentation.clear()` when attempting to reset drawing parameters, which likely did not fully reset the drawing state. The fixed code replaces this with `idraw.resetParameter()`, which properly resets the drawing state by directly invoking the reset method on the `ImageDraw` instance. This change ensures a complete and clean reset of drawing parameters, maintaining the intended functionality of clearing the drawing canvas more effectively."
38456,"@Override public void useParametersFrom(FilterRepresentation a){
  if (a instanceof FilterDrawRepresentation) {
    FilterDrawRepresentation representation=(FilterDrawRepresentation)a;
    try {
      if (representation.mCurrent != null) {
        mCurrent=(StrokeData)representation.mCurrent.clone();
      }
 else {
        mCurrent=null;
      }
      if (representation.mDrawing != null) {
        mDrawing=(Vector<StrokeData>)representation.mDrawing.clone();
      }
    }
 catch (    CloneNotSupportedException e) {
      e.printStackTrace();
    }
  }
 else {
    Log.v(LOGTAG,""String_Node_Str"" + a);
  }
}","@Override public void useParametersFrom(FilterRepresentation a){
  if (a instanceof FilterDrawRepresentation) {
    FilterDrawRepresentation representation=(FilterDrawRepresentation)a;
    try {
      if (representation.mCurrent != null) {
        mCurrent=(StrokeData)representation.mCurrent.clone();
      }
 else {
        mCurrent=null;
      }
      if (representation.mDrawing != null) {
        mDrawing=(Vector<StrokeData>)representation.mDrawing.clone();
      }
 else {
        mDrawing=null;
      }
    }
 catch (    CloneNotSupportedException e) {
      e.printStackTrace();
    }
  }
 else {
    Log.v(LOGTAG,""String_Node_Str"" + a);
  }
}","The original code lacked handling for the case when `representation.mDrawing` is null, potentially leading to uninitialized state. The fixed code adds an `else` block to set `mDrawing` to null when the source drawing is null, ensuring consistent object state. This change prevents potential null pointer exceptions and maintains symmetry with the `mCurrent` null handling, improving the method's robustness and predictability."
38457,"public void drawData(Canvas canvas,Matrix originalRotateToScreen,int quality){
  Paint paint=new Paint();
  if (quality == ImagePreset.QUALITY_FINAL) {
    paint.setAntiAlias(true);
  }
  paint.setStyle(Style.STROKE);
  paint.setColor(Color.RED);
  paint.setStrokeWidth(40);
  if (mParameters.getDrawing().isEmpty() && mParameters.getCurrentDrawing() == null) {
    return;
  }
  if (quality == ImagePreset.QUALITY_FINAL) {
    for (    FilterDrawRepresentation.StrokeData strokeData : mParameters.getDrawing()) {
      paint(strokeData,canvas,originalRotateToScreen,quality);
    }
    return;
  }
  if (mOverlayBitmap == null || mOverlayBitmap.getWidth() != canvas.getWidth() || mOverlayBitmap.getHeight() != canvas.getHeight()) {
    mOverlayBitmap=Bitmap.createBitmap(canvas.getWidth(),canvas.getHeight(),Bitmap.Config.ARGB_8888);
    mCachedStrokes=0;
  }
  if (mCachedStrokes < mParameters.getDrawing().size()) {
    fillBuffer(originalRotateToScreen);
  }
  canvas.drawBitmap(mOverlayBitmap,0,0,paint);
  StrokeData stroke=mParameters.getCurrentDrawing();
  if (stroke != null) {
    paint(stroke,canvas,originalRotateToScreen,quality);
  }
}","public void drawData(Canvas canvas,Matrix originalRotateToScreen,int quality){
  Paint paint=new Paint();
  if (quality == ImagePreset.QUALITY_FINAL) {
    paint.setAntiAlias(true);
  }
  paint.setStyle(Style.STROKE);
  paint.setColor(Color.RED);
  paint.setStrokeWidth(40);
  if (mParameters.getDrawing().isEmpty() && mParameters.getCurrentDrawing() == null) {
    return;
  }
  if (quality == ImagePreset.QUALITY_FINAL) {
    for (    FilterDrawRepresentation.StrokeData strokeData : mParameters.getDrawing()) {
      paint(strokeData,canvas,originalRotateToScreen,quality);
    }
    return;
  }
  if (mOverlayBitmap == null || mOverlayBitmap.getWidth() != canvas.getWidth() || mOverlayBitmap.getHeight() != canvas.getHeight() || mParameters.getDrawing().size() < mCachedStrokes) {
    mOverlayBitmap=Bitmap.createBitmap(canvas.getWidth(),canvas.getHeight(),Bitmap.Config.ARGB_8888);
    mCachedStrokes=0;
  }
  if (mCachedStrokes < mParameters.getDrawing().size()) {
    fillBuffer(originalRotateToScreen);
  }
  canvas.drawBitmap(mOverlayBitmap,0,0,paint);
  StrokeData stroke=mParameters.getCurrentDrawing();
  if (stroke != null) {
    paint(stroke,canvas,originalRotateToScreen,quality);
  }
}","The original code lacked a condition to recreate the overlay bitmap when the drawing size changes, potentially causing rendering inconsistencies. The fixed code adds an additional check `mParameters.getDrawing().size() < mCachedStrokes` to reset the overlay bitmap when the number of strokes decreases, ensuring accurate bitmap creation. This modification prevents potential rendering artifacts and maintains bitmap consistency across different drawing states."
38458,"@Override public boolean onTouchEvent(MotionEvent event){
  float ox=mDotX;
  float oy=mDotY;
  float x=event.getX();
  float y=event.getY();
  mDotX=x;
  if (mDotX < mBorder) {
    mDotX=mBorder;
  }
  if (mDotX > mWidth - mBorder) {
    mDotX=mWidth - mBorder;
  }
  mHSVO[3]=(mDotX - mBorder) / (mWidth - mBorder * 2);
  notifyColorListeners(mHSVO);
  setupButton();
  invalidate((int)(ox - mDotRadus),(int)(oy - mDotRadus),(int)(ox + mDotRadus),(int)(oy + mDotRadus));
  invalidate((int)(mDotX - mDotRadus),(int)(mDotY - mDotRadus),(int)(mDotX + mDotRadus),(int)(mDotY + mDotRadus));
  return true;
}","@Override public boolean onTouchEvent(MotionEvent event){
  float ox=mDotX;
  float oy=mDotY;
  float x=event.getX();
  float y=event.getY();
  mDotX=x;
  if (mDotX < mBorder) {
    mDotX=mBorder;
  }
  if (mDotX > mWidth - mBorder) {
    mDotX=mWidth - mBorder;
  }
  mHSVO[3]=(mDotX - mBorder) / (mWidth - mBorder * 2);
  notifyColorListeners(mHSVO);
  setupButton();
  invalidate((int)(ox - mDotRadius),(int)(oy - mDotRadius),(int)(ox + mDotRadius),(int)(oy + mDotRadius));
  invalidate((int)(mDotX - mDotRadius),(int)(mDotY - mDotRadius),(int)(mDotX + mDotRadius),(int)(mDotY + mDotRadius));
  return true;
}","The original code contains a typo in the variable name `mDotRadus`, which would likely cause a compilation error or undefined behavior. In the fixed code, `mDotRadus` is corrected to `mDotRadius`, ensuring proper referencing of the dot's radius variable. This correction allows the `invalidate()` method to accurately redraw the affected areas of the view, maintaining the intended touch event handling and visual update mechanism."
38459,"public ColorOpacityView(Context ctx,AttributeSet attrs){
  super(ctx,attrs);
  DisplayMetrics metrics=ctx.getResources().getDisplayMetrics();
  float mDpToPix=metrics.density;
  mDotRadus=DOT_SIZE * mDpToPix;
  mBorder=BORDER_SIZE * mDpToPix;
  mBarPaint1=new Paint();
  mDotPaint=new Paint();
  mDotPaint.setStyle(Paint.Style.FILL);
  mDotPaint.setColor(ctx.getResources().getColor(R.color.slider_dot_color));
  mSliderColor=ctx.getResources().getColor(R.color.slider_line_color);
  mBarPaint1.setStyle(Paint.Style.FILL);
  mLinePaint1=new Paint();
  mLinePaint1.setColor(Color.GRAY);
  mLinePaint2=new Paint();
  mLinePaint2.setColor(mSliderColor);
  mLinePaint2.setStrokeWidth(4);
  int[] colors=new int[16 * 16];
  for (int i=0; i < colors.length; i++) {
    int y=i / (16 * 8);
    int x=(i / 8) % 2;
    colors[i]=(x == y) ? 0xFFAAAAAA : 0xFF444444;
  }
  Bitmap bitmap=Bitmap.createBitmap(colors,16,16,Bitmap.Config.ARGB_8888);
  BitmapShader bs=new BitmapShader(bitmap,Shader.TileMode.REPEAT,Shader.TileMode.REPEAT);
  mCheckPaint=new Paint();
  mCheckPaint.setShader(bs);
}","public ColorOpacityView(Context ctx,AttributeSet attrs){
  super(ctx,attrs);
  DisplayMetrics metrics=ctx.getResources().getDisplayMetrics();
  float mDpToPix=metrics.density;
  mDotRadius=DOT_SIZE * mDpToPix;
  mBorder=BORDER_SIZE * mDpToPix;
  mBarPaint1=new Paint();
  mDotPaint=new Paint();
  mDotPaint.setStyle(Paint.Style.FILL);
  mDotPaint.setColor(ctx.getResources().getColor(R.color.slider_dot_color));
  mSliderColor=ctx.getResources().getColor(R.color.slider_line_color);
  mBarPaint1.setStyle(Paint.Style.FILL);
  mLinePaint1=new Paint();
  mLinePaint1.setColor(Color.GRAY);
  mLinePaint2=new Paint();
  mLinePaint2.setColor(mSliderColor);
  mLinePaint2.setStrokeWidth(4);
  int[] colors=new int[16 * 16];
  for (int i=0; i < colors.length; i++) {
    int y=i / (16 * 8);
    int x=(i / 8) % 2;
    colors[i]=(x == y) ? 0xFFAAAAAA : 0xFF444444;
  }
  Bitmap bitmap=Bitmap.createBitmap(colors,16,16,Bitmap.Config.ARGB_8888);
  BitmapShader bs=new BitmapShader(bitmap,Shader.TileMode.REPEAT,Shader.TileMode.REPEAT);
  mCheckPaint=new Paint();
  mCheckPaint.setShader(bs);
}","The original code contains a typo in the variable name `mDotRadus`, which would cause a compilation error or potential runtime issue. In the fixed code, `mDotRadus` is corrected to `mDotRadius`, ensuring proper variable naming and preventing potential bugs. This correction improves code readability and prevents potential compilation or runtime errors related to incorrect variable references."
38460,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  canvas.drawColor(mBgcolor);
  canvas.drawRect(mBorder,mBorder,mWidth - mBorder,mHeight - mBorder,mCheckPaint);
  canvas.drawRect(mBorder,mBorder,mWidth - mBorder,mHeight - mBorder,mBarPaint1);
  canvas.drawLine(mDotX,mDotY,mWidth - mBorder,mDotY,mLinePaint1);
  canvas.drawLine(mBorder,mDotY,mDotX,mDotY,mLinePaint2);
  if (mDotX != Float.NaN) {
    canvas.drawCircle(mDotX,mDotY,mDotRadus,mDotPaint);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  canvas.drawColor(mBgcolor);
  canvas.drawRect(mBorder,mBorder,mWidth - mBorder,mHeight - mBorder,mCheckPaint);
  canvas.drawRect(mBorder,mBorder,mWidth - mBorder,mHeight - mBorder,mBarPaint1);
  canvas.drawLine(mDotX,mDotY,mWidth - mBorder,mDotY,mLinePaint1);
  canvas.drawLine(mBorder,mDotY,mDotX,mDotY,mLinePaint2);
  if (mDotX != Float.NaN) {
    canvas.drawCircle(mDotX,mDotY,mDotRadius,mDotPaint);
  }
}","The original code contains a typo in the variable name `mDotRadus`, which would cause a compilation error due to an undefined variable. In the fixed code, `mDotRadus` is corrected to `mDotRadius`, ensuring the correct variable name matches the intended dot radius. This correction allows the circle drawing method to use the proper radius parameter, resolving the potential naming issue and enabling smooth rendering of the dot on the canvas."
38461,"private void setupButton(){
  float pos=mHSVO[3] * (mWidth - mBorder * 2);
  mDotX=pos + mBorder;
  int[] colors3=new int[]{mSliderColor,mSliderColor,0x66000000,0};
  RadialGradient g=new RadialGradient(mDotX,mDotY,mDotRadus,colors3,new float[]{0,.3f,.31f,1},Shader.TileMode.CLAMP);
  mDotPaint.setShader(g);
}","private void setupButton(){
  float pos=mHSVO[3] * (mWidth - mBorder * 2);
  mDotX=pos + mBorder;
  int[] colors3=new int[]{mSliderColor,mSliderColor,0x66000000,0};
  RadialGradient g=new RadialGradient(mDotX,mDotY,mDotRadius,colors3,new float[]{0,.3f,.31f,1},Shader.TileMode.CLAMP);
  mDotPaint.setShader(g);
}","The original code contains a typo in the variable name `mDotRadus`, which would likely cause a compilation error or unexpected behavior. In the fixed code, `mDotRadus` is corrected to `mDotRadius`, ensuring the correct variable name is used when creating the RadialGradient. This correction allows the method to properly set up the button's gradient shader with the intended dot radius, preventing potential runtime errors and maintaining the intended visual design."
38462,"@Override public void paintCurrentStroke(Canvas canvas,Matrix toScrMatrix,boolean highQuality){
  Path path=mCurrentPath;
  if (path == null) {
    return;
  }
  Paint paint=new Paint();
  canvas.save();
  canvas.concat(toScrMatrix);
  paint.setStyle(Style.STROKE);
  float scale=toScrMatrix.mapRadius(1);
  draw(canvas,paint,mCurrentColor,mCurrentRadius,path);
  canvas.restore();
}","@Override public void paintCurrentStroke(Canvas canvas,Matrix toScrMatrix,boolean highQuality){
  Path path=mCurrentPath;
  if (path == null) {
    return;
  }
  Paint paint=new Paint();
  paint.setStyle(Style.STROKE);
  float scale=toScrMatrix.mapRadius(1);
  Path mCacheTransPath=new Path();
  mCacheTransPath.addPath(path,toScrMatrix);
  draw(canvas,paint,mCurrentColor,toScrMatrix.mapRadius(mCurrentRadius),mCacheTransPath);
}","The original code directly draws the path without transforming it, which can lead to incorrect rendering when the matrix contains scaling or translation. The fixed code creates a new transformed path using `mCacheTransPath.addPath(path, toScrMatrix)` and applies the matrix transformation before drawing, ensuring accurate stroke rendering. This approach correctly maps the path and radius to the screen coordinates, resulting in a more precise and visually consistent drawing."
38463,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(getResources().getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(getResources().getString(R.string.original_picture_text));
  mIconSeedSize=getResources().getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=getResources().getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)getResources().getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageRedEyes=(ImageRedEyes)findViewById(R.id.imageRedEyes);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mImageViews.add(mImageRedEyes);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageRedEyes.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageRedEyes));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.redEyeButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<ImageFilter> filters=new Vector<ImageFilter>();
  FiltersManager.addFilters(filters,mImageLoader);
  for (  ImageFilter filter : filters) {
    filter.setParameter(filter.getDefaultParameter());
    filter.setName(getString(filter.getTextId()));
    setupFilterButton(filter,listColors,mColorsButton);
  }
  mPanelController.addFilter(new ImageFilterRedEye());
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(SEEK_BAR_MAX);
  mImageShow.setSeekBar(seekBar);
  mImageTinyPlanet.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  String action=intent.getAction();
  if (action.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
    mPanelController.showComponent(findViewById(R.id.cropButton));
  }
 else   if (action.equalsIgnoreCase(TINY_PLANET_ACTION)) {
    mPanelController.showComponent(findViewById(R.id.tinyplanetButton));
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupMasterImage();
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(getResources().getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(getResources().getString(R.string.original_picture_text));
  mIconSeedSize=getResources().getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=getResources().getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)getResources().getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageRedEyes=(ImageRedEyes)findViewById(R.id.imageRedEyes);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mImageViews.add(mImageRedEyes);
  mEditorPlaceHolder.setContainer((FrameLayout)findViewById(R.id.editorContainer));
  mEditorPlaceHolder.addEditor(new EditorDraw());
  mEditorPlaceHolder.addEditor(new BasicEditor());
  EditorManager.addEditors(mEditorPlaceHolder);
  mEditorPlaceHolder.setOldViews(mImageViews);
  mEditorPlaceHolder.setImageLoader(mImageLoader);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageCrop.setImageLoader(mImageLoader);
  mImageRotate.setImageLoader(mImageLoader);
  mImageFlip.setImageLoader(mImageLoader);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageRedEyes.setImageLoader(mImageLoader);
  mImageDraw.setImageLoader(mImageLoader);
  mPanelController.setActivity(this);
  mPanelController.setEditorPlaceHolder(mEditorPlaceHolder);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageRedEyes));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.redEyeButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<ImageFilter> filters=new Vector<ImageFilter>();
  FiltersManager.addFilters(filters,mImageLoader);
  for (  ImageFilter filter : filters) {
    filter.setParameter(filter.getDefaultParameter());
    filter.setName(getString(filter.getTextId()));
    setupFilterButton(filter,listColors,mColorsButton);
  }
  mPanelController.addFilter(new ImageFilterRedEye());
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mMasterImage.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mMasterImage.getState());
  mImageLoader.setAdapter(mMasterImage.getHistory());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(SEEK_BAR_MAX);
  mImageShow.setSeekBar(seekBar);
  mImageTinyPlanet.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  String action=intent.getAction();
  if (action.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
    mPanelController.showComponent(findViewById(R.id.cropButton));
  }
 else   if (action.equalsIgnoreCase(TINY_PLANET_ACTION)) {
    mPanelController.showComponent(findViewById(R.id.tinyplanetButton));
  }
}","The original code lacked a crucial editor initialization by not adding the BasicEditor to the EditorPlaceHolder, which could limit the application's editing capabilities. The fixed code adds `mEditorPlaceHolder.addEditor(new BasicEditor());`, ensuring that the basic editing functionality is properly integrated into the editor framework. This enhancement provides a more comprehensive and robust editing experience by including the fundamental editing operations in the image manipulation workflow."
38464,"@Override public ImageFilter clone() throws CloneNotSupportedException {
  ImageFilterCurves filter=(ImageFilterCurves)super.clone();
  for (int i=0; i < 4; i++) {
    if (mSplines[i] != null) {
      filter.setSpline(mSplines[i],i);
    }
  }
  return filter;
}","@Override public ImageFilter clone() throws CloneNotSupportedException {
  ImageFilterCurves filter=(ImageFilterCurves)super.clone();
  filter.mSplines=new Spline[4];
  for (int i=0; i < 4; i++) {
    if (mSplines[i] != null) {
      filter.setSpline(mSplines[i],i);
    }
  }
  return filter;
}","The original code fails to create a deep copy of the `mSplines` array, causing the cloned filter to share the same spline references as the original. The fixed code initializes a new `mSplines` array in the cloned filter before copying individual splines, ensuring each clone has its own independent array. This prevents unintended modifications to the original filter's splines and provides a true, independent clone of the ImageFilterCurves object."
38465,"public void reset(){
  Spline spline=new Spline();
  spline.addPoint(0.0f,1.0f);
  spline.addPoint(1.0f,0.0f);
  for (int i=0; i < 4; i++) {
    mSplines[i]=new Spline(spline);
  }
}","@Override public void reset(){
  Spline spline=new Spline();
  spline.addPoint(0.0f,1.0f);
  spline.addPoint(1.0f,0.0f);
  for (int i=0; i < 4; i++) {
    mSplines[i]=new Spline(spline);
  }
}","The original code lacks the `@Override` annotation, which helps catch potential method signature mismatches when overriding methods in parent classes. The fixed code adds `@Override`, ensuring compile-time verification that the method correctly implements or overrides a method from a superclass. This small addition improves code reliability by preventing unintended method implementations and providing clearer interface adherence."
38466,"public static void addEditors(EditorPlaceHolder editorPlaceHolder){
  editorPlaceHolder.addEditor(new EditorZoom());
  editorPlaceHolder.addEditor(new EditorCurves());
  editorPlaceHolder.addEditor(new BasicEditor());
  editorPlaceHolder.addEditor(new EditorDraw());
}","public static void addEditors(EditorPlaceHolder editorPlaceHolder){
  editorPlaceHolder.addEditor(new EditorZoom());
  editorPlaceHolder.addEditor(new EditorCurves());
  editorPlaceHolder.addEditor(new EditorDraw());
}","The original code incorrectly added a `BasicEditor` to the `EditorPlaceHolder`, which was likely unnecessary or redundant in the context of the editor workflow. The fixed code removes the `BasicEditor`, keeping only specialized editors like `EditorZoom`, `EditorCurves`, and `EditorDraw`. This streamlines the editor configuration, ensuring only relevant and specific editors are included, which can improve code clarity and prevent potential conflicts or performance overhead."
38467,"void resetHistory(){
  mNullFxFilter.onClick(mNullFxFilter);
  mNullBorderFilter.onClick(mNullBorderFilter);
  HistoryAdapter adapter=mImageShow.getHistory();
  adapter.reset();
  ImagePreset original=new ImagePreset(adapter.getItem(0));
  mImageShow.setImagePreset(original);
  mPanelController.resetParameters();
  invalidateViews();
}","void resetHistory(){
  dispatchNullFilterClick();
  HistoryAdapter adapter=mImageShow.getHistory();
  adapter.reset();
  ImagePreset original=new ImagePreset(adapter.getItem(0));
  mImageShow.setImagePreset(original);
  mPanelController.resetParameters();
  invalidateViews();
}","The original code incorrectly calls `onClick()` directly on filter objects, which likely leads to improper event handling and potential null pointer exceptions. The fixed code introduces a `dispatchNullFilterClick()` method, which presumably provides a centralized and safer mechanism for resetting filters. By abstracting the filter reset logic, the new implementation enhances code reliability, reduces direct object manipulation, and improves overall error handling in the reset process."
38468,"@Override protected void onPostExecute(Boolean result){
  if (isCancelled()) {
    return;
  }
  if (!result) {
    cannotLoadImage();
  }
  mLoadBitmapTask=null;
  super.onPostExecute(result);
}","@Override protected void onPostExecute(Boolean result){
  if (isCancelled()) {
    return;
  }
  if (!result) {
    cannotLoadImage();
  }
  mImageShow.requestFilteredImages();
  Bitmap bmap=mImageShow.getFilteredImage();
  if (bmap != null && bmap.getWidth() > 0 && bmap.getHeight() > 0) {
    float w=bmap.getWidth();
    float h=bmap.getHeight();
    float f=mIconSeedSize / Math.min(w,h);
    w=w * f;
    h=h * f;
    bmap=Bitmap.createScaledBitmap(bmap,(int)w,(int)h,true);
    int num_colors_buttons=listColors.getChildCount();
    for (int i=0; i < num_colors_buttons; i++) {
      FilterIconButton b=(FilterIconButton)listColors.getChildAt(i);
      b.setIcon(bmap);
    }
    int num_filters_buttons=listFilters.getChildCount();
    for (int i=0; i < num_filters_buttons; i++) {
      FilterIconButton b=(FilterIconButton)listFilters.getChildAt(i);
      b.setIcon(bmap);
    }
    int num_borders_buttons=listBorders.getChildCount();
    for (int i=0; i < num_borders_buttons; i++) {
      FilterIconButton b=(FilterIconButton)listBorders.getChildAt(i);
      b.setIcon(bmap);
    }
  }
  mLoadBitmapTask=null;
  super.onPostExecute(result);
}","The original code lacks functionality after checking the image loading result, leaving the task incomplete. The fixed code adds image processing steps, including requesting filtered images, scaling the bitmap, and setting icons for color, filter, and border buttons. This enhancement ensures comprehensive image handling and provides visual updates across multiple UI components, making the code more robust and functional."
38469,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(getResources().getColor(R.color.background_screen));
  ImageSmallFilter.setDefaultBackgroundColor(getResources().getColor(R.color.background_main_toolbar));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(getResources().getString(R.string.original_picture_text));
  ImageButtonTitle.setTextSize((int)getPixelsFromDip(12));
  ImageButtonTitle.setTextPadding((int)getPixelsFromDip(10));
  ImageSmallFilter.setMargin((int)getPixelsFromDip(3));
  ImageSmallFilter.setTextMargin((int)getPixelsFromDip(4));
  Drawable curveHandle=getResources().getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)getResources().getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  LinearLayout listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageRedEyes=(ImageRedEyes)findViewById(R.id.imageRedEyes);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mImageViews.add(mImageRedEyes);
  for (  ImageShow imageShow : mImageViews) {
    mImageLoader.addCacheListener(imageShow);
  }
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageCrop.setImageLoader(mImageLoader);
  mImageCrop.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageTinyPlanet.setMaster(mImageShow);
  mImageRedEyes.setImageLoader(mImageLoader);
  mImageRedEyes.setMaster(mImageShow);
  mImageDraw.setImageLoader(mImageLoader);
  mImageDraw.setMaster(mImageShow);
  mPanelController.setActivity(this);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageRedEyes));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.redEyeButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<ImageFilter> filters=new Vector<ImageFilter>();
  FiltersManager.addFilters(filters,mImageLoader);
  for (  ImageFilter filter : filters) {
    ImageSmallFilter fView=new ImageSmallFilter(this);
    filter.setParameter(filter.getPreviewParameter());
    filter.setName(getString(filter.getTextId()));
    fView.setImageFilter(filter);
    fView.setController(this);
    fView.setImageLoader(mImageLoader);
    fView.setId(filter.getButtonId());
    if (filter.getOverlayBitmaps() != 0) {
      Bitmap bitmap=BitmapFactory.decodeResource(getResources(),filter.getOverlayBitmaps());
      fView.setOverlayBitmap(bitmap);
    }
    mPanelController.addComponent(mColorsButton,fView);
    mPanelController.addFilter(filter);
    listColors.addView(fView);
  }
  mPanelController.addFilter(new ImageFilterRedEye());
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter(mImageShow.getHistory());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(SEEK_BAR_MAX);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mImageTinyPlanet.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  String action=intent.getAction();
  if (action.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
    mPanelController.showComponent(findViewById(R.id.cropButton));
  }
 else   if (action.equalsIgnoreCase(TINY_PLANET_ACTION)) {
    mPanelController.showComponent(findViewById(R.id.tinyplanetButton));
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  ImageShow.setDefaultBackgroundColor(getResources().getColor(R.color.background_screen));
  ImageZoom.setZoomedSize(getPixelsFromDip(256));
  FramedTextButton.setTextSize((int)getPixelsFromDip(14));
  FramedTextButton.setTrianglePadding((int)getPixelsFromDip(4));
  FramedTextButton.setTriangleSize((int)getPixelsFromDip(10));
  ImageShow.setTextSize((int)getPixelsFromDip(12));
  ImageShow.setTextPadding((int)getPixelsFromDip(10));
  ImageShow.setOriginalTextMargin((int)getPixelsFromDip(4));
  ImageShow.setOriginalTextSize((int)getPixelsFromDip(18));
  ImageShow.setOriginalText(getResources().getString(R.string.original_picture_text));
  mIconSeedSize=getResources().getDimensionPixelSize(R.dimen.thumbnail_size);
  Drawable curveHandle=getResources().getDrawable(R.drawable.camera_crop);
  int curveHandleSize=(int)getResources().getDimension(R.dimen.crop_indicator_size);
  Spline.setCurveHandle(curveHandle,curveHandleSize);
  Spline.setCurveWidth((int)getPixelsFromDip(3));
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  mSaveButton=actionBar.getCustomView();
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(this,getApplicationContext());
  listFilters=(LinearLayout)findViewById(R.id.listFilters);
  listBorders=(LinearLayout)findViewById(R.id.listBorders);
  listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageTinyPlanet=(ImageTinyPlanet)findViewById(R.id.imageTinyPlanet);
  mImageRedEyes=(ImageRedEyes)findViewById(R.id.imageRedEyes);
  mImageDraw=(ImageDraw)findViewById(R.id.imageDraw);
  mImageCrop.setAspectTextSize((int)getPixelsFromDip(18));
  ImageCrop.setTouchTolerance((int)getPixelsFromDip(25));
  ImageCrop.setMinCropSize((int)getPixelsFromDip(55));
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mImageViews.add(mImageTinyPlanet);
  mImageViews.add(mImageRedEyes);
  for (  ImageShow imageShow : mImageViews) {
    mImageLoader.addCacheListener(imageShow);
  }
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageCrop.setImageLoader(mImageLoader);
  mImageCrop.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mImageTinyPlanet.setImageLoader(mImageLoader);
  mImageTinyPlanet.setMaster(mImageShow);
  mImageRedEyes.setImageLoader(mImageLoader);
  mImageRedEyes.setMaster(mImageShow);
  mImageDraw.setImageLoader(mImageLoader);
  mImageDraw.setMaster(mImageShow);
  mPanelController.setActivity(this);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addImageView(findViewById(R.id.imageTinyPlanet));
  mPanelController.addImageView(findViewById(R.id.imageRedEyes));
  mPanelController.addImageView(findViewById(R.id.imageDraw));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.redEyeButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  Vector<ImageFilter> filters=new Vector<ImageFilter>();
  FiltersManager.addFilters(filters,mImageLoader);
  for (  ImageFilter filter : filters) {
    filter.setParameter(filter.getDefaultParameter());
    filter.setName(getString(filter.getTextId()));
    setupFilterButton(filter,listColors,mColorsButton);
  }
  mPanelController.addFilter(new ImageFilterRedEye());
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistory());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter(mImageShow.getHistory());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(SEEK_BAR_MAX);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mImageTinyPlanet.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.panelAccessoryViewList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  if (intent.getBooleanExtra(LAUNCH_FULLSCREEN,false)) {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
  }
  if (intent.getData() != null) {
    startLoadBitmap(intent.getData());
  }
 else {
    pickImage();
  }
  String action=intent.getAction();
  if (action.equalsIgnoreCase(CROP_ACTION)) {
    Bundle extras=intent.getExtras();
    if (extras != null) {
      mCropExtras=new CropExtras(extras.getInt(CropExtras.KEY_OUTPUT_X,0),extras.getInt(CropExtras.KEY_OUTPUT_Y,0),extras.getBoolean(CropExtras.KEY_SCALE,true) && extras.getBoolean(CropExtras.KEY_SCALE_UP_IF_NEEDED,false),extras.getInt(CropExtras.KEY_ASPECT_X,0),extras.getInt(CropExtras.KEY_ASPECT_Y,0),extras.getBoolean(CropExtras.KEY_SET_AS_WALLPAPER,false),extras.getBoolean(CropExtras.KEY_RETURN_DATA,false),(Uri)extras.getParcelable(MediaStore.EXTRA_OUTPUT),extras.getString(CropExtras.KEY_OUTPUT_FORMAT),extras.getBoolean(CropExtras.KEY_SHOW_WHEN_LOCKED,false),extras.getFloat(CropExtras.KEY_SPOTLIGHT_X),extras.getFloat(CropExtras.KEY_SPOTLIGHT_Y));
      if (mCropExtras.getShowWhenLocked()) {
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
      }
      mImageShow.getImagePreset().mGeoData.setCropExtras(mCropExtras);
      mImageCrop.setExtras(mCropExtras);
      String s=getString(R.string.Fixed);
      mImageCrop.setAspectString(s);
      mImageCrop.setCropActionFlag(true);
      mPanelController.setFixedAspect(mCropExtras.getAspectX() > 0 && mCropExtras.getAspectY() > 0);
    }
    mPanelController.showComponent(findViewById(R.id.cropButton));
  }
 else   if (action.equalsIgnoreCase(TINY_PLANET_ACTION)) {
    mPanelController.showComponent(findViewById(R.id.tinyplanetButton));
  }
}","The original code had redundant and potentially unnecessary method calls, such as setting background colors for multiple image components and creating multiple similar views. The fixed code streamlines the initialization process by removing redundant method calls, simplifying the filter setup with a new `setupFilterButton` method, and reducing code complexity. These changes improve code readability, maintainability, and performance by eliminating unnecessary operations and consolidating similar initialization logic."
38470,"private void fillListBorders(LinearLayout listBorders){
  int p=0;
  ImageFilter[] borders=new ImageFilter[12];
  borders[p++]=new ImageFilterBorder(null);
  Drawable npd1=getResources().getDrawable(R.drawable.filtershow_border_4x5);
  borders[p++]=new ImageFilterBorder(npd1);
  Drawable npd2=getResources().getDrawable(R.drawable.filtershow_border_brush);
  borders[p++]=new ImageFilterBorder(npd2);
  Drawable npd3=getResources().getDrawable(R.drawable.filtershow_border_grunge);
  borders[p++]=new ImageFilterBorder(npd3);
  Drawable npd4=getResources().getDrawable(R.drawable.filtershow_border_sumi_e);
  borders[p++]=new ImageFilterBorder(npd4);
  Drawable npd5=getResources().getDrawable(R.drawable.filtershow_border_tape);
  borders[p++]=new ImageFilterBorder(npd5);
  borders[p++]=new ImageFilterParametricBorder(Color.BLACK,mImageBorderSize,0);
  borders[p++]=new ImageFilterParametricBorder(Color.BLACK,mImageBorderSize,mImageBorderSize);
  borders[p++]=new ImageFilterParametricBorder(Color.WHITE,mImageBorderSize,0);
  borders[p++]=new ImageFilterParametricBorder(Color.WHITE,mImageBorderSize,mImageBorderSize);
  int creamColor=Color.argb(255,237,237,227);
  borders[p++]=new ImageFilterParametricBorder(creamColor,mImageBorderSize,0);
  borders[p++]=new ImageFilterParametricBorder(creamColor,mImageBorderSize,mImageBorderSize);
  ImageSmallFilter previousFilter=null;
  for (int i=0; i < p; i++) {
    ImageSmallBorder filter=new ImageSmallBorder(this);
    if (i == 0) {
      mNullBorderFilter=filter;
    }
 else {
      filter.setNulfilter(mNullBorderFilter);
    }
    borders[i].setName(getString(R.string.borders));
    filter.setImageFilter(borders[i]);
    filter.setController(this);
    filter.setBorder(true);
    filter.setImageLoader(mImageLoader);
    filter.setShowTitle(false);
    listBorders.addView(filter);
    previousFilter=filter;
  }
}","private void fillListBorders(LinearLayout listBorders){
  int p=0;
  ImageFilter[] borders=new ImageFilter[12];
  borders[p++]=new ImageFilterBorder(null);
  Drawable npd1=getResources().getDrawable(R.drawable.filtershow_border_4x5);
  borders[p++]=new ImageFilterBorder(npd1);
  Drawable npd2=getResources().getDrawable(R.drawable.filtershow_border_brush);
  borders[p++]=new ImageFilterBorder(npd2);
  Drawable npd3=getResources().getDrawable(R.drawable.filtershow_border_grunge);
  borders[p++]=new ImageFilterBorder(npd3);
  Drawable npd4=getResources().getDrawable(R.drawable.filtershow_border_sumi_e);
  borders[p++]=new ImageFilterBorder(npd4);
  Drawable npd5=getResources().getDrawable(R.drawable.filtershow_border_tape);
  borders[p++]=new ImageFilterBorder(npd5);
  borders[p++]=new ImageFilterParametricBorder(Color.BLACK,mImageBorderSize,0);
  borders[p++]=new ImageFilterParametricBorder(Color.BLACK,mImageBorderSize,mImageBorderSize);
  borders[p++]=new ImageFilterParametricBorder(Color.WHITE,mImageBorderSize,0);
  borders[p++]=new ImageFilterParametricBorder(Color.WHITE,mImageBorderSize,mImageBorderSize);
  int creamColor=Color.argb(255,237,237,227);
  borders[p++]=new ImageFilterParametricBorder(creamColor,mImageBorderSize,0);
  borders[p++]=new ImageFilterParametricBorder(creamColor,mImageBorderSize,mImageBorderSize);
  for (int i=0; i < p; i++) {
    borders[i].setName(getString(R.string.borders));
    FilterIconButton b=setupFilterButton(borders[i],listBorders,mBorderButton);
    if (i == 0) {
      mNullBorderFilter=b;
      mNullBorderFilter.setSelected(true);
    }
  }
}","The original code manually created and added border filter views to a layout, leading to repetitive and error-prone view creation. The fixed code introduces a more modular approach by using a `setupFilterButton` method, which centralizes view creation and simplifies the process of adding filters. This refactoring improves code readability, reduces redundancy, and provides a more consistent and maintainable way of populating the border selection interface."
38471,"private void fillListImages(LinearLayout listFilters){
  ImageFilterFx[] fxArray=new ImageFilterFx[18];
  int p=0;
  int[] drawid={R.drawable.filtershow_fx_0005_punch,R.drawable.filtershow_fx_0000_vintage,R.drawable.filtershow_fx_0004_bw_contrast,R.drawable.filtershow_fx_0002_bleach,R.drawable.filtershow_fx_0001_instant,R.drawable.filtershow_fx_0007_washout,R.drawable.filtershow_fx_0003_blue_crush,R.drawable.filtershow_fx_0008_washout_color,R.drawable.filtershow_fx_0006_x_process};
  int[] fxNameid={R.string.ffx_punch,R.string.ffx_vintage,R.string.ffx_bw_contrast,R.string.ffx_bleach,R.string.ffx_instant,R.string.ffx_washout,R.string.ffx_blue_crush,R.string.ffx_washout_color,R.string.ffx_x_process};
  ImagePreset preset=new ImagePreset(getString(R.string.history_original));
  preset.setImageLoader(mImageLoader);
  mNullFxFilter=new ImageSmallFilter(this);
  mNullFxFilter.setSelected(true);
  mCurrentImageSmallFilter=mNullFxFilter;
  mNullFxFilter.setImageFilter(new ImageFilterFx(null,getString(R.string.none)));
  mNullFxFilter.setController(this);
  mNullFxFilter.setImageLoader(mImageLoader);
  listFilters.addView(mNullFxFilter);
  ImageSmallFilter previousFilter=mNullFxFilter;
  BitmapFactory.Options o=new BitmapFactory.Options();
  o.inScaled=false;
  for (int i=0; i < drawid.length; i++) {
    Bitmap b=BitmapFactory.decodeResource(getResources(),drawid[i],o);
    fxArray[p++]=new ImageFilterFx(b,getString(fxNameid[i]));
  }
  ImageSmallFilter filter;
  for (int i=0; i < p; i++) {
    filter=new ImageSmallFilter(this);
    filter.setImageFilter(fxArray[i]);
    filter.setController(this);
    filter.setNulfilter(mNullFxFilter);
    filter.setImageLoader(mImageLoader);
    listFilters.addView(filter);
    previousFilter=filter;
  }
  mImageShow.setImagePreset(preset);
}","private void fillListImages(LinearLayout listFilters){
  ImageFilterFx[] fxArray=new ImageFilterFx[18];
  int p=0;
  int[] drawid={R.drawable.filtershow_fx_0005_punch,R.drawable.filtershow_fx_0000_vintage,R.drawable.filtershow_fx_0004_bw_contrast,R.drawable.filtershow_fx_0002_bleach,R.drawable.filtershow_fx_0001_instant,R.drawable.filtershow_fx_0007_washout,R.drawable.filtershow_fx_0003_blue_crush,R.drawable.filtershow_fx_0008_washout_color,R.drawable.filtershow_fx_0006_x_process};
  int[] fxNameid={R.string.ffx_punch,R.string.ffx_vintage,R.string.ffx_bw_contrast,R.string.ffx_bleach,R.string.ffx_instant,R.string.ffx_washout,R.string.ffx_blue_crush,R.string.ffx_washout_color,R.string.ffx_x_process};
  ImagePreset preset=new ImagePreset(getString(R.string.history_original));
  preset.setImageLoader(mImageLoader);
  BitmapFactory.Options o=new BitmapFactory.Options();
  o.inScaled=false;
  for (int i=0; i < drawid.length; i++) {
    Bitmap b=BitmapFactory.decodeResource(getResources(),drawid[i],o);
    fxArray[p++]=new ImageFilterFx(b,getString(fxNameid[i]),fxNameid[i]);
  }
  ImageFilterFx nullFilter=new ImageFilterFx(null,getString(R.string.none),R.string.none);
  mNullFxFilter=setupFilterButton(nullFilter,listFilters,mFxButton);
  mNullFxFilter.setSelected(true);
  for (int i=0; i < p; i++) {
    setupFilterButton(fxArray[i],listFilters,mFxButton);
  }
  mImageShow.setImagePreset(preset);
}","The original code inefficiently created filter buttons with redundant setup logic and potential memory leaks by manually instantiating multiple ImageSmallFilter objects. The fixed code introduces a more modular `setupFilterButton` method (not shown) that centralizes filter button creation, adds a third parameter to ImageFilterFx for better identification, and simplifies the filter generation process. This refactoring reduces code duplication, improves memory management, and provides a more streamlined approach to creating image filter buttons."
38472,"public void showComponent(View view){
  if (mUtilityPanel != null && !mUtilityPanel.selected()) {
    Panel current=mPanels.get(mCurrentPanel);
    ViewPropertyAnimator anim1=current.unselect(-1,VERTICAL_MOVE);
    anim1.start();
    if (mUtilityPanel != null) {
      ViewPropertyAnimator anim2=mUtilityPanel.select();
      anim2.start();
    }
  }
  if (mCurrentImage != null) {
    mCurrentImage.unselect();
  }
  mUtilityPanel.hideAccessoryViews();
  if (view instanceof ImageSmallFilter) {
    ImageSmallFilter component=(ImageSmallFilter)view;
    ImageFilter filter=component.getImageFilter();
    if (filter.getEditingViewId() != 0) {
      mCurrentImage=showImageView(filter.getEditingViewId());
      mCurrentImage.setShowControls(filter.showEditingControls());
      String ename=mCurrentImage.getContext().getString(filter.getTextId());
      mUtilityPanel.setEffectName(ename);
      if (mCurrentImage.useUtilityPanel()) {
        mCurrentImage.openUtilityPanel(mUtilityPanel.mAccessoryViewList);
      }
      mUtilityPanel.setShowParameter(filter.showParameterValue());
      ensureFilter(ename);
      mCurrentImage.select();
    }
    return;
  }
switch (view.getId()) {
case R.id.tinyplanetButton:
{
      mCurrentImage=showImageView(R.id.imageTinyPlanet).setShowControls(true);
      String ename=mCurrentImage.getContext().getString(R.string.tinyplanet);
      mUtilityPanel.setEffectName(ename);
      ensureFilter(ename);
      if (!mDisableFilterButtons) {
        mActivity.disableFilterButtons();
        mDisableFilterButtons=true;
      }
      break;
    }
case R.id.straightenButton:
{
    mCurrentImage=showImageView(R.id.imageStraighten);
    String ename=mCurrentImage.getContext().getString(R.string.straighten);
    mUtilityPanel.setEffectName(ename);
    break;
  }
case R.id.cropButton:
{
  mCurrentImage=showImageView(R.id.imageCrop);
  String ename=mCurrentImage.getContext().getString(R.string.crop);
  mUtilityPanel.setEffectName(ename);
  mUtilityPanel.setShowParameter(false);
  if (mCurrentImage instanceof ImageCrop && mUtilityPanel.firstTimeCropDisplayed) {
    ((ImageCrop)mCurrentImage).clear();
    mUtilityPanel.firstTimeCropDisplayed=false;
  }
  ((ImageCrop)mCurrentImage).setFixedAspect(mFixedAspect);
  break;
}
case R.id.rotateButton:
{
mCurrentImage=showImageView(R.id.imageRotate);
String ename=mCurrentImage.getContext().getString(R.string.rotate);
mUtilityPanel.setEffectName(ename);
break;
}
case R.id.flipButton:
{
mCurrentImage=showImageView(R.id.imageFlip);
String ename=mCurrentImage.getContext().getString(R.string.mirror);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
break;
}
case R.id.redEyeButton:
{
mCurrentImage=showImageView(R.id.imageRedEyes).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.redeye);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.applyEffect:
{
if (mMasterImage.getCurrentFilter() instanceof ImageFilterTinyPlanet) {
mActivity.saveImage();
}
 else {
if (mCurrentImage instanceof ImageCrop) {
((ImageCrop)mCurrentImage).saveAndSetPreset();
}
showPanel(mCurrentPanel);
}
break;
}
}
if (mCurrentImage.useUtilityPanel()) {
mCurrentImage.openUtilityPanel(mUtilityPanel.mAccessoryViewList);
}
mCurrentImage.select();
}","public void showComponent(View view){
  boolean doPanelTransition=true;
  if (view instanceof FilterIconButton) {
    ImageFilter f=((FilterIconButton)view).getImageFilter();
    doPanelTransition=f.showUtilityPanel();
  }
  if (mUtilityPanel != null && !mUtilityPanel.selected() && doPanelTransition) {
    Panel current=mPanels.get(mCurrentPanel);
    ViewPropertyAnimator anim1=current.unselect(-1,VERTICAL_MOVE);
    anim1.start();
    if (mUtilityPanel != null) {
      ViewPropertyAnimator anim2=mUtilityPanel.select();
      anim2.start();
    }
  }
  if (mCurrentImage != null) {
    mCurrentImage.unselect();
  }
  mUtilityPanel.hideAccessoryViews();
  if (view instanceof FilterIconButton) {
    FilterIconButton component=(FilterIconButton)view;
    ImageFilter filter=component.getImageFilter();
    if (filter.getEditingViewId() != 0) {
      mCurrentImage=showImageView(filter.getEditingViewId());
      mCurrentImage.setShowControls(filter.showEditingControls());
      String ename=mCurrentImage.getContext().getString(filter.getTextId());
      mUtilityPanel.setEffectName(ename);
      if (mCurrentImage.useUtilityPanel()) {
        mCurrentImage.openUtilityPanel(mUtilityPanel.mAccessoryViewList);
      }
      mUtilityPanel.setShowParameter(filter.showParameterValue());
      if (filter != null) {
        mMasterImage.setCurrentFilter(filter);
      }
      mCurrentImage.select();
    }
    return;
  }
switch (view.getId()) {
case R.id.tinyplanetButton:
{
      mCurrentImage=showImageView(R.id.imageTinyPlanet).setShowControls(true);
      String ename=mCurrentImage.getContext().getString(R.string.tinyplanet);
      mUtilityPanel.setEffectName(ename);
      ensureFilter(ename);
      if (!mDisableFilterButtons) {
        mActivity.disableFilterButtons();
        mDisableFilterButtons=true;
      }
      break;
    }
case R.id.straightenButton:
{
    mCurrentImage=showImageView(R.id.imageStraighten);
    String ename=mCurrentImage.getContext().getString(R.string.straighten);
    mUtilityPanel.setEffectName(ename);
    break;
  }
case R.id.cropButton:
{
  mCurrentImage=showImageView(R.id.imageCrop);
  String ename=mCurrentImage.getContext().getString(R.string.crop);
  mUtilityPanel.setEffectName(ename);
  mUtilityPanel.setShowParameter(false);
  if (mCurrentImage instanceof ImageCrop && mUtilityPanel.firstTimeCropDisplayed) {
    ((ImageCrop)mCurrentImage).clear();
    mUtilityPanel.firstTimeCropDisplayed=false;
  }
  ((ImageCrop)mCurrentImage).setFixedAspect(mFixedAspect);
  break;
}
case R.id.rotateButton:
{
mCurrentImage=showImageView(R.id.imageRotate);
String ename=mCurrentImage.getContext().getString(R.string.rotate);
mUtilityPanel.setEffectName(ename);
break;
}
case R.id.flipButton:
{
mCurrentImage=showImageView(R.id.imageFlip);
String ename=mCurrentImage.getContext().getString(R.string.mirror);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
break;
}
case R.id.redEyeButton:
{
mCurrentImage=showImageView(R.id.imageRedEyes).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.redeye);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.applyEffect:
{
if (mMasterImage.getCurrentFilter() instanceof ImageFilterTinyPlanet) {
mActivity.saveImage();
}
 else {
if (mCurrentImage instanceof ImageCrop) {
((ImageCrop)mCurrentImage).saveAndSetPreset();
}
showPanel(mCurrentPanel);
}
break;
}
}
if (mCurrentImage.useUtilityPanel()) {
mCurrentImage.openUtilityPanel(mUtilityPanel.mAccessoryViewList);
}
mCurrentImage.select();
}","The original code lacked proper handling of utility panel transitions and filter selection, potentially causing inconsistent UI behavior. The fixed code introduces a `doPanelTransition` flag and adds explicit filter setting for `FilterIconButton`, ensuring more robust panel and filter management. These changes improve code reliability by providing better control over UI state transitions and filter application, preventing potential unexpected interactions."
38473,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  if (mNinePatch == null) {
    return bitmap;
  }
  int w=bitmap.getWidth();
  int h=bitmap.getHeight();
  float scale=scaleFactor * 2.0f;
  Rect bounds=new Rect(0,0,(int)(w / scale),(int)(h / scale));
  Canvas canvas=new Canvas(bitmap);
  canvas.scale(scale,scale);
  mNinePatch.setBounds(bounds);
  mNinePatch.draw(canvas);
  return bitmap;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  if (mNinePatch == null) {
    return bitmap;
  }
  float scale2=scaleFactor * 2.0f;
  float scale1=1 / scale2;
  return applyHelper(bitmap,scale1,scale2);
}","The original code modifies the input bitmap in-place, which can lead to unexpected side effects and potential memory corruption by directly scaling and drawing on the source bitmap. The fixed code introduces a separate scaling approach by calculating inverse and forward scale factors, and delegates the transformation to a separate helper method, ensuring safe bitmap manipulation. This approach prevents direct bitmap modification, creates a clean separation of scaling logic, and provides a more robust method for applying nine-patch transformations."
38474,"public ImageFilterFx(Bitmap fxBitmap,String name){
  setFilterType(TYPE_FX);
  mName=name;
  this.fxBitmap=fxBitmap;
}","public ImageFilterFx(Bitmap fxBitmap,String name,int nameResource){
  setFilterType(TYPE_FX);
  mName=name;
  this.fxBitmap=fxBitmap;
  mNameResource=nameResource;
}","The original constructor lacks a parameter for storing a name resource identifier, limiting the filter's flexibility and metadata capabilities. The fixed code adds an `int nameResource` parameter, allowing the constructor to capture and store a resource reference alongside the bitmap and name. This enhancement provides more comprehensive filter initialization, enabling better resource management and potential localization or dynamic naming of image filters."
38475,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Canvas canvas=new Canvas(bitmap);
  Path border=new Path();
  border.moveTo(0,0);
  int w=bitmap.getWidth();
  int h=bitmap.getHeight();
  float bs=mBorderSize / 100.0f * bitmap.getWidth();
  float r=mBorderCornerRadius / 100.0f * bitmap.getWidth();
  border.lineTo(0,h);
  border.lineTo(w,h);
  border.lineTo(w,0);
  border.lineTo(0,0);
  border.addRoundRect(new RectF(bs,bs,w - bs,h - bs),r,r,Path.Direction.CW);
  Paint paint=new Paint();
  paint.setAntiAlias(true);
  paint.setColor(mBorderColor);
  canvas.drawPath(border,paint);
  return bitmap;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Canvas canvas=new Canvas(bitmap);
  applyHelper(canvas,bitmap.getWidth(),bitmap.getHeight());
  return bitmap;
}","The original code directly modifies the input bitmap by drawing a border path on its canvas, which can lead to unintended side effects and potential memory issues. The fixed code introduces an `applyHelper` method to separate the border drawing logic, creating a cleaner and more modular approach to bitmap manipulation. This refactoring improves code readability, maintainability, and reduces the risk of unexpected bitmap modifications."
38476,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  float[] displayCenter={temp.getWidth() / 2f,temp.getHeight() / 2f};
  Matrix m1=mGeometry.buildTotalXform(bitmap.getWidth(),bitmap.getHeight(),displayCenter);
  Canvas canvas=new Canvas(temp);
  Paint paint=new Paint();
  paint.setAntiAlias(true);
  paint.setFilterBitmap(true);
  paint.setDither(true);
  canvas.drawBitmap(bitmap,m1,paint);
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   cropBounds=GeometryMath.roundNearest(crop);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  float[] displayCenter={temp.getWidth() / 2f,temp.getHeight() / 2f};
  Matrix m1=mGeometry.buildTotalXform(bitmap.getWidth(),bitmap.getHeight(),displayCenter);
  Canvas canvas=new Canvas(temp);
  Paint paint=new Paint();
  paint.setAntiAlias(true);
  paint.setFilterBitmap(true);
  paint.setDither(true);
  canvas.drawBitmap(bitmap,m1,paint);
  return temp;
}","The original code incorrectly used `crop.roundOut(cropBounds)`, which modifies the existing `cropBounds` object without creating a new bounded rectangle. The fixed code replaces this with `cropBounds = GeometryMath.roundNearest(crop)`, which creates a new `Rect` with precise rounding based on the crop dimensions. This change ensures accurate bitmap transformation by correctly calculating and setting the crop boundaries without unintended side effects on the original rectangle."
38477,"public boolean hasModifications(){
  if (mScaleFactor != 1.0f) {
    return true;
  }
  if (mRotation != 0) {
    return true;
  }
  if (mStraightenRotation != 0) {
    return true;
  }
  Rect cropBounds=new Rect();
  mCropBounds.roundOut(cropBounds);
  Rect photoBounds=new Rect();
  mPhotoBounds.roundOut(photoBounds);
  if (!cropBounds.equals(photoBounds)) {
    return true;
  }
  if (!mFlip.equals(FLIP.NONE)) {
    return true;
  }
  return false;
}","public boolean hasModifications(){
  if (mScaleFactor != 1.0f) {
    return true;
  }
  if (mRotation != 0) {
    return true;
  }
  if (mStraightenRotation != 0) {
    return true;
  }
  Rect cropBounds=GeometryMath.roundNearest(mCropBounds);
  Rect photoBounds=GeometryMath.roundNearest(mPhotoBounds);
  if (!cropBounds.equals(photoBounds)) {
    return true;
  }
  if (!mFlip.equals(FLIP.NONE)) {
    return true;
  }
  return false;
}","The original code incorrectly used `roundOut()` method, which creates a new Rect by expanding to integer boundaries, potentially introducing inaccuracies in bounds comparison. The fixed code replaces `roundOut()` with `GeometryMath.roundNearest()`, which provides a more precise rounding method for calculating Rect boundaries. This change ensures more accurate comparison of crop and photo bounds, leading to a more reliable detection of image modifications."
38478,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  float[] displayCenter={temp.getWidth() / 2f,temp.getHeight() / 2f};
  Matrix m1=mGeometry.buildTotalXform(bitmap.getWidth(),bitmap.getHeight(),displayCenter);
  Canvas canvas=new Canvas(temp);
  Paint paint=new Paint();
  paint.setAntiAlias(true);
  paint.setFilterBitmap(true);
  paint.setDither(true);
  canvas.drawBitmap(bitmap,m1,paint);
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   cropBounds=GeometryMath.roundNearest(crop);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  float[] displayCenter={temp.getWidth() / 2f,temp.getHeight() / 2f};
  Matrix m1=mGeometry.buildTotalXform(bitmap.getWidth(),bitmap.getHeight(),displayCenter);
  Canvas canvas=new Canvas(temp);
  Paint paint=new Paint();
  paint.setAntiAlias(true);
  paint.setFilterBitmap(true);
  paint.setDither(true);
  canvas.drawBitmap(bitmap,m1,paint);
  return temp;
}","The original code incorrectly uses `crop.roundOut(cropBounds)`, which modifies the existing `cropBounds` object instead of creating a new bounded rectangle. The fixed code replaces this with `cropBounds = GeometryMath.roundNearest(crop)`, which properly creates a new `Rect` with rounded crop dimensions. This change ensures accurate bitmap cropping by correctly translating the floating-point crop bounds to integer-based rectangle coordinates without unintended side effects."
38479,"public boolean hasModifications(){
  if (mScaleFactor != 1.0f) {
    return true;
  }
  if (mRotation != 0) {
    return true;
  }
  if (mStraightenRotation != 0) {
    return true;
  }
  Rect cropBounds=new Rect();
  mCropBounds.roundOut(cropBounds);
  Rect photoBounds=new Rect();
  mPhotoBounds.roundOut(photoBounds);
  if (!cropBounds.equals(photoBounds)) {
    return true;
  }
  if (!mFlip.equals(FLIP.NONE)) {
    return true;
  }
  return false;
}","public boolean hasModifications(){
  if (mScaleFactor != 1.0f) {
    return true;
  }
  if (mRotation != 0) {
    return true;
  }
  if (mStraightenRotation != 0) {
    return true;
  }
  Rect cropBounds=GeometryMath.roundNearest(mCropBounds);
  Rect photoBounds=GeometryMath.roundNearest(mPhotoBounds);
  if (!cropBounds.equals(photoBounds)) {
    return true;
  }
  if (!mFlip.equals(FLIP.NONE)) {
    return true;
  }
  return false;
}","The original code incorrectly used `roundOut()` method, which creates a new Rect by expanding to integer bounds, potentially introducing inaccuracies in boundary comparisons. The fixed code replaces `roundOut()` with `GeometryMath.roundNearest()`, which provides a more precise rounding method that maintains the original shape's integrity. This change ensures more accurate boundary comparisons and prevents potential rounding-induced discrepancies in modification detection."
38480,"public boolean hasModifications(){
  if (mScaleFactor != 1.0f) {
    return true;
  }
  if (mRotation != 0) {
    return true;
  }
  if (mStraightenRotation != 0) {
    return true;
  }
  if (!mCropBounds.equals(mPhotoBounds)) {
    return true;
  }
  if (!mFlip.equals(FLIP.NONE)) {
    return true;
  }
  return false;
}","public boolean hasModifications(){
  if (mScaleFactor != 1.0f) {
    return true;
  }
  if (mRotation != 0) {
    return true;
  }
  if (mStraightenRotation != 0) {
    return true;
  }
  Rect cropBounds=new Rect();
  mCropBounds.roundOut(cropBounds);
  Rect photoBounds=new Rect();
  mPhotoBounds.roundOut(photoBounds);
  if (!cropBounds.equals(photoBounds)) {
    return true;
  }
  if (!mFlip.equals(FLIP.NONE)) {
    return true;
  }
  return false;
}","The original code directly compared RectF objects using equals(), which may not work correctly due to floating-point precision issues. The fixed code converts RectF to Rect using roundOut(), ensuring integer-based comparison and eliminating potential floating-point comparison errors. This modification provides a more reliable method of checking whether crop bounds have changed, improving the accuracy of modification detection."
38481,"protected void saveAndSetPreset(){
  ImagePreset lastHistoryItem=getHistory().getLast();
  if (lastHistoryItem != null && lastHistoryItem.historyName().equalsIgnoreCase(getName())) {
    getImagePreset().setGeometry(mLocalGeometry);
    resetImageCaches(this);
  }
 else {
    ImagePreset copy=new ImagePreset(getImagePreset());
    copy.setGeometry(mLocalGeometry);
    copy.setHistoryName(getName());
    copy.setIsFx(false);
    setImagePreset(copy,true);
  }
  invalidate();
}","public void saveAndSetPreset(){
  ImagePreset lastHistoryItem=getHistory().getLast();
  if (lastHistoryItem != null && lastHistoryItem.historyName().equalsIgnoreCase(getName())) {
    getImagePreset().setGeometry(mLocalGeometry);
    resetImageCaches(this);
  }
 else {
    ImagePreset copy=new ImagePreset(getImagePreset());
    copy.setGeometry(mLocalGeometry);
    copy.setHistoryName(getName());
    copy.setIsFx(false);
    setImagePreset(copy,true);
  }
  invalidate();
}","The original code had a protected method access modifier, which could limit the method's visibility and potential reusability across different classes and packages. The fixed code changes the method to public, allowing broader access and improving the method's flexibility for potential inheritance and usage. This modification enhances the method's accessibility, making it more versatile and easier to integrate into different parts of the application."
38482,"public void showComponent(View view){
  if (mUtilityPanel != null && !mUtilityPanel.selected()) {
    Panel current=mPanels.get(mCurrentPanel);
    ViewPropertyAnimator anim1=current.unselect(-1,VERTICAL_MOVE);
    anim1.start();
    if (mUtilityPanel != null) {
      ViewPropertyAnimator anim2=mUtilityPanel.select();
      anim2.start();
    }
  }
  if (view.getId() == R.id.pickCurvesChannel) {
    ImageCurves curves=(ImageCurves)showImageView(R.id.imageCurves);
    showCurvesPopupMenu(curves,(FramedTextButton)view);
    return;
  }
  if (view.getId() == R.id.aspect) {
    showCropPopupMenu((FramedTextButton)view);
    return;
  }
  if (mCurrentImage != null) {
    mCurrentImage.unselect();
  }
  mUtilityPanel.hideAspectButtons();
  mUtilityPanel.hideCurvesButtons();
switch (view.getId()) {
case R.id.tinyplanetButton:
{
      mCurrentImage=showImageView(R.id.imageTinyPlanet).setShowControls(true);
      String ename=mCurrentImage.getContext().getString(R.string.tinyplanet);
      mUtilityPanel.setEffectName(ename);
      ensureFilter(ename);
      break;
    }
case R.id.straightenButton:
{
    mCurrentImage=showImageView(R.id.imageStraighten);
    String ename=mCurrentImage.getContext().getString(R.string.straighten);
    mUtilityPanel.setEffectName(ename);
    break;
  }
case R.id.cropButton:
{
  mCurrentImage=showImageView(R.id.imageCrop);
  String ename=mCurrentImage.getContext().getString(R.string.crop);
  mUtilityPanel.setEffectName(ename);
  mUtilityPanel.setShowParameter(false);
  if (mCurrentImage instanceof ImageCrop && mUtilityPanel.firstTimeCropDisplayed) {
    ((ImageCrop)mCurrentImage).applyOriginal();
    mUtilityPanel.firstTimeCropDisplayed=false;
  }
  mUtilityPanel.showAspectButtons();
  break;
}
case R.id.rotateButton:
{
mCurrentImage=showImageView(R.id.imageRotate);
String ename=mCurrentImage.getContext().getString(R.string.rotate);
mUtilityPanel.setEffectName(ename);
break;
}
case R.id.flipButton:
{
mCurrentImage=showImageView(R.id.imageFlip);
String ename=mCurrentImage.getContext().getString(R.string.mirror);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
break;
}
case R.id.vignetteButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vignette);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.curvesButtonRGB:
{
ImageCurves curves=(ImageCurves)showImageView(R.id.imageCurves);
String ename=curves.getContext().getString(R.string.curvesRGB);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
mUtilityPanel.showCurvesButtons();
mCurrentImage=curves;
ensureFilter(ename);
break;
}
case R.id.sharpenButton:
{
mCurrentImage=showImageView(R.id.imageZoom).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.sharpness);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.contrastButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.contrast);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.saturationButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.saturation);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.bwfilterButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.bwfilter);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.wbalanceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(false);
String ename=mCurrentImage.getContext().getString(R.string.wbalance);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
ensureFilter(ename);
break;
}
case R.id.hueButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.hue);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.exposureButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.exposure);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.vibranceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vibrance);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.shadowRecoveryButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.shadow_recovery);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.redEyeButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.redeye);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.aspect:
{
mUtilityPanel.showAspectButtons();
break;
}
case R.id.applyEffect:
{
if (mMasterImage.getCurrentFilter() instanceof ImageFilterTinyPlanet) {
mActivity.saveImage();
}
 else {
showPanel(mCurrentPanel);
}
break;
}
}
mCurrentImage.select();
}","public void showComponent(View view){
  if (mUtilityPanel != null && !mUtilityPanel.selected()) {
    Panel current=mPanels.get(mCurrentPanel);
    ViewPropertyAnimator anim1=current.unselect(-1,VERTICAL_MOVE);
    anim1.start();
    if (mUtilityPanel != null) {
      ViewPropertyAnimator anim2=mUtilityPanel.select();
      anim2.start();
    }
  }
  if (view.getId() == R.id.pickCurvesChannel) {
    ImageCurves curves=(ImageCurves)showImageView(R.id.imageCurves);
    showCurvesPopupMenu(curves,(FramedTextButton)view);
    return;
  }
  if (view.getId() == R.id.aspect) {
    showCropPopupMenu((FramedTextButton)view);
    return;
  }
  if (mCurrentImage != null) {
    mCurrentImage.unselect();
  }
  mUtilityPanel.hideAspectButtons();
  mUtilityPanel.hideCurvesButtons();
switch (view.getId()) {
case R.id.tinyplanetButton:
{
      mCurrentImage=showImageView(R.id.imageTinyPlanet).setShowControls(true);
      String ename=mCurrentImage.getContext().getString(R.string.tinyplanet);
      mUtilityPanel.setEffectName(ename);
      ensureFilter(ename);
      break;
    }
case R.id.straightenButton:
{
    mCurrentImage=showImageView(R.id.imageStraighten);
    String ename=mCurrentImage.getContext().getString(R.string.straighten);
    mUtilityPanel.setEffectName(ename);
    break;
  }
case R.id.cropButton:
{
  mCurrentImage=showImageView(R.id.imageCrop);
  String ename=mCurrentImage.getContext().getString(R.string.crop);
  mUtilityPanel.setEffectName(ename);
  mUtilityPanel.setShowParameter(false);
  if (mCurrentImage instanceof ImageCrop && mUtilityPanel.firstTimeCropDisplayed) {
    ((ImageCrop)mCurrentImage).applyOriginal();
    mUtilityPanel.firstTimeCropDisplayed=false;
  }
  mUtilityPanel.showAspectButtons();
  break;
}
case R.id.rotateButton:
{
mCurrentImage=showImageView(R.id.imageRotate);
String ename=mCurrentImage.getContext().getString(R.string.rotate);
mUtilityPanel.setEffectName(ename);
break;
}
case R.id.flipButton:
{
mCurrentImage=showImageView(R.id.imageFlip);
String ename=mCurrentImage.getContext().getString(R.string.mirror);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
break;
}
case R.id.vignetteButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vignette);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.curvesButtonRGB:
{
ImageCurves curves=(ImageCurves)showImageView(R.id.imageCurves);
String ename=curves.getContext().getString(R.string.curvesRGB);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
mUtilityPanel.showCurvesButtons();
mCurrentImage=curves;
ensureFilter(ename);
break;
}
case R.id.sharpenButton:
{
mCurrentImage=showImageView(R.id.imageZoom).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.sharpness);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.contrastButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.contrast);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.saturationButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.saturation);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.bwfilterButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.bwfilter);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.wbalanceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(false);
String ename=mCurrentImage.getContext().getString(R.string.wbalance);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
ensureFilter(ename);
break;
}
case R.id.hueButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.hue);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.exposureButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.exposure);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.vibranceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vibrance);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.shadowRecoveryButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.shadow_recovery);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.redEyeButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.redeye);
mUtilityPanel.setEffectName(ename);
ensureFilter(ename);
break;
}
case R.id.aspect:
{
mUtilityPanel.showAspectButtons();
break;
}
case R.id.applyEffect:
{
if (mMasterImage.getCurrentFilter() instanceof ImageFilterTinyPlanet) {
mActivity.saveImage();
}
 else {
if (mCurrentImage instanceof ImageCrop) {
((ImageCrop)mCurrentImage).saveAndSetPreset();
}
showPanel(mCurrentPanel);
}
break;
}
}
mCurrentImage.select();
}","The original code lacked proper handling for the crop effect's final application, potentially leaving unsaved changes when applying effects. The fixed code adds a specific check for ImageCrop instances, calling `saveAndSetPreset()` to ensure crop modifications are properly saved before showing the panel. This enhancement guarantees that crop adjustments are correctly preserved and applied, preventing potential data loss and improving the overall user experience with more robust effect management."
38483,"protected void saveAndSetPreset(){
  ImagePreset lastHistoryItem=getHistory().getLast();
  if (lastHistoryItem != null && lastHistoryItem.historyName().equalsIgnoreCase(getName())) {
    getImagePreset().setGeometry(mLocalGeometry);
    resetImageCaches(this);
  }
 else {
    ImagePreset copy=new ImagePreset(getImagePreset());
    copy.setGeometry(mLocalGeometry);
    copy.setHistoryName(getName());
    copy.setIsFx(false);
    setImagePreset(copy,true);
  }
  invalidate();
}","public void saveAndSetPreset(){
  ImagePreset lastHistoryItem=getHistory().getLast();
  if (lastHistoryItem != null && lastHistoryItem.historyName().equalsIgnoreCase(getName())) {
    getImagePreset().setGeometry(mLocalGeometry);
    resetImageCaches(this);
  }
 else {
    ImagePreset copy=new ImagePreset(getImagePreset());
    copy.setGeometry(mLocalGeometry);
    copy.setHistoryName(getName());
    copy.setIsFx(false);
    setImagePreset(copy,true);
  }
  invalidate();
}","The original code's method was incorrectly marked as protected, potentially limiting its accessibility and inheritance capabilities. The fixed code changes the method's visibility to public, which allows broader access and ensures the method can be called from different classes and contexts. This modification enhances the method's flexibility and usability while maintaining the original logic for saving and setting image presets."
38484,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(crop);
  Canvas canvas=new Canvas(temp);
  Paint paint=new Paint();
  paint.setAntiAlias(true);
  paint.setFilterBitmap(true);
  paint.setDither(true);
  canvas.drawBitmap(bitmap,drawMatrix,paint);
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  RectF rp=mGeometry.getPhotoBounds();
  RectF rc=mGeometry.getPreviewCropBounds();
  Matrix drawMatrix=mGeometry.buildTotalXform(rp.width(),rp.height(),rc.width(),rc.height(),rc.left,rc.top,mGeometry.getRotation(),mGeometry.getStraightenRotation(),bitmap.getWidth() / rp.width(),null);
  Canvas canvas=new Canvas(temp);
  Paint paint=new Paint();
  paint.setAntiAlias(true);
  paint.setFilterBitmap(true);
  paint.setDither(true);
  canvas.drawBitmap(bitmap,drawMatrix,paint);
  return temp;
}","The original code used a simplistic matrix transformation that did not account for complex geometric transformations like rotation, scaling, and preview crop boundaries. The fixed code introduces a more comprehensive matrix transformation method `buildTotalXform()` that considers photo bounds, preview crop bounds, rotation angles, and scaling factors. This enhanced approach ensures more accurate bitmap transformations by precisely mapping the source bitmap's geometric properties during rendering."
38485,"public Matrix buildTotalXform(float pwidth,float pheight,float cwidth,float cheight,float cleft,float ctop,float rotation,float straighten,float scale,RectF dst){
  Matrix m=getFlipMatrix(pwidth,pheight);
  m.postRotate(rotation + straighten,pwidth / 2,pheight / 2);
  Matrix m1=new Matrix();
  m1.setRotate(rotation,pwidth / 2,pheight / 2);
  RectF crop=new RectF(cleft,ctop,cleft + cwidth,ctop + cheight);
  if (!m1.mapRect(crop))   return null;
  if (dst != null)   dst.set(crop);
  m.postTranslate(-crop.left,-crop.top);
  m.postScale(scale,scale);
  return m;
}","public Matrix buildTotalXform(float pwidth,float pheight,float cwidth,float cheight,float cleft,float ctop,float rotation,float straighten,float scale,RectF dst){
  float s_pwidth=pwidth * scale;
  float s_pheight=pheight * scale;
  Matrix m=getFlipMatrix(s_pwidth,s_pheight);
  m.postRotate(rotation + straighten,s_pwidth / 2,s_pheight / 2);
  Matrix m1=getFlipMatrix(s_pwidth,s_pheight);
  m1.postRotate(rotation,s_pwidth / 2,s_pheight / 2);
  RectF crop=new RectF(cleft * scale,ctop * scale,(cleft + cwidth) * scale,(ctop + cheight) * scale);
  if (!m1.mapRect(crop))   return null;
  if (dst != null)   dst.set(crop);
  m.postTranslate(-crop.left,-crop.top);
  return m;
}","The original code incorrectly applied transformations without considering scale, leading to potential misalignment and incorrect geometric transformations. The fixed code introduces scaling before rotation, adjusts coordinate calculations by multiplying with scale, and removes redundant scaling to ensure precise geometric transformations. These modifications result in more accurate matrix transformations that preserve the intended geometric properties across different scale factors."
38486,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(crop);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(crop);
  Canvas canvas=new Canvas(temp);
  Paint paint=new Paint();
  paint.setAntiAlias(true);
  paint.setFilterBitmap(true);
  paint.setDither(true);
  canvas.drawBitmap(bitmap,drawMatrix,paint);
  return temp;
}","The original code used a default Paint object without configuring rendering quality, potentially resulting in lower-quality bitmap transformations. The fixed code adds three critical Paint configurations: antialiasing, bitmap filtering, and dithering, which enhance image rendering smoothness and quality. These optimizations ensure more precise and visually appealing bitmap scaling and drawing, especially during image transformations like cropping and resizing."
38487,"@Override protected void drawShape(Canvas canvas,Bitmap image){
  gPaint.setAntiAlias(true);
  gPaint.setFilterBitmap(true);
  gPaint.setDither(true);
  gPaint.setARGB(255,255,255,255);
  if (mFirstDraw) {
    cropSetup();
    mFirstDraw=false;
  }
  float rotation=getLocalRotation();
  drawTransformedBitmap(canvas,image,gPaint,true);
  gPaint.setARGB(255,125,255,128);
  gPaint.setStrokeWidth(3);
  gPaint.setStyle(Paint.Style.STROKE);
  drawStraighten(canvas,gPaint);
  RectF scaledCrop=unrotatedCropBounds();
  int decoded_moving=decoder(movingEdges,rotation);
  canvas.save();
  canvas.rotate(rotation,mCenterX,mCenterY);
  boolean notMoving=decoded_moving == 0;
  if (((decoded_moving & MOVE_TOP) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.centerX(),scaledCrop.top);
  }
  if (((decoded_moving & MOVE_BOTTOM) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.centerX(),scaledCrop.bottom);
  }
  if (((decoded_moving & MOVE_LEFT) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.left,scaledCrop.centerY());
  }
  if (((decoded_moving & MOVE_RIGHT) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.right,scaledCrop.centerY());
  }
  canvas.restore();
}","@Override protected void drawShape(Canvas canvas,Bitmap image){
  gPaint.setAntiAlias(true);
  gPaint.setFilterBitmap(true);
  gPaint.setDither(true);
  gPaint.setARGB(255,255,255,255);
  if (mFirstDraw) {
    cropSetup();
    mFirstDraw=false;
  }
  float rotation=getLocalRotation();
  drawTransformedBitmap(canvas,image,gPaint,true);
  gPaint.setColor(mBorderColor);
  gPaint.setStrokeWidth(3);
  gPaint.setStyle(Paint.Style.STROKE);
  drawStraighten(canvas,gPaint);
  RectF scaledCrop=unrotatedCropBounds();
  drawRuleOfThird(canvas,scaledCrop);
  int decoded_moving=decoder(movingEdges,rotation);
  canvas.save();
  canvas.rotate(rotation,mCenterX,mCenterY);
  boolean notMoving=decoded_moving == 0;
  if (((decoded_moving & MOVE_TOP) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.centerX(),scaledCrop.top);
  }
  if (((decoded_moving & MOVE_BOTTOM) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.centerX(),scaledCrop.bottom);
  }
  if (((decoded_moving & MOVE_LEFT) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.left,scaledCrop.centerY());
  }
  if (((decoded_moving & MOVE_RIGHT) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.right,scaledCrop.centerY());
  }
  canvas.restore();
}","The original code uses an arbitrary hard-coded color (125, 255, 128) for drawing borders, which lacks flexibility and context. The fixed code replaces this with `mBorderColor`, a more dynamic and customizable color setting, and adds a `drawRuleOfThird` method for improved composition visualization. These changes enhance the drawing method's adaptability, allowing for more personalized and visually refined image rendering."
38488,"public ImageCrop(Context context,AttributeSet attrs){
  super(context,attrs);
  Resources resources=context.getResources();
  cropIndicator=resources.getDrawable(R.drawable.camera_crop);
  indicatorSize=(int)resources.getDimension(R.dimen.crop_indicator_size);
  int borderColor=Color.argb(128,255,255,255);
  borderPaint=new Paint();
  borderPaint.setStyle(Paint.Style.STROKE);
  borderPaint.setColor(borderColor);
  borderPaint.setStrokeWidth(2f);
}","public ImageCrop(Context context,AttributeSet attrs){
  super(context,attrs);
  Resources resources=context.getResources();
  cropIndicator=resources.getDrawable(R.drawable.camera_crop);
  indicatorSize=(int)resources.getDimension(R.dimen.crop_indicator_size);
  borderPaint=new Paint();
  borderPaint.setStyle(Paint.Style.STROKE);
  borderPaint.setColor(mBorderColor);
  borderPaint.setStrokeWidth(2f);
}","The original code directly sets a hardcoded border color using Color.argb(), which lacks flexibility and makes color customization difficult. The fixed code introduces a more modular approach by using a member variable `mBorderColor`, allowing dynamic color configuration and better design extensibility. This change enables easier color management, supports potential theme changes, and provides a more maintainable solution for setting border color in the ImageCrop view."
38489,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(crop);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(crop);
  Canvas canvas=new Canvas(temp);
  Paint paint=new Paint();
  paint.setAntiAlias(true);
  paint.setFilterBitmap(true);
  paint.setDither(true);
  canvas.drawBitmap(bitmap,drawMatrix,paint);
  return temp;
}","The original code used a default Paint object without configuring rendering quality, potentially resulting in low-quality bitmap transformations. The fixed code enhances the Paint object by enabling antialiasing, bitmap filtering, and dithering, which improve image rendering smoothness and visual quality. These optimizations ensure higher-fidelity bitmap scaling and transformation, particularly when processing images with complex geometries or scaling operations."
38490,"@Override protected void drawShape(Canvas canvas,Bitmap image){
  gPaint.setAntiAlias(true);
  gPaint.setFilterBitmap(true);
  gPaint.setDither(true);
  gPaint.setARGB(255,255,255,255);
  if (mFirstDraw) {
    cropSetup();
    mFirstDraw=false;
  }
  float rotation=getLocalRotation();
  drawTransformedBitmap(canvas,image,gPaint,true);
  gPaint.setARGB(255,125,255,128);
  gPaint.setStrokeWidth(3);
  gPaint.setStyle(Paint.Style.STROKE);
  drawStraighten(canvas,gPaint);
  RectF scaledCrop=unrotatedCropBounds();
  int decoded_moving=decoder(movingEdges,rotation);
  canvas.save();
  canvas.rotate(rotation,mCenterX,mCenterY);
  boolean notMoving=decoded_moving == 0;
  if (((decoded_moving & MOVE_TOP) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.centerX(),scaledCrop.top);
  }
  if (((decoded_moving & MOVE_BOTTOM) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.centerX(),scaledCrop.bottom);
  }
  if (((decoded_moving & MOVE_LEFT) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.left,scaledCrop.centerY());
  }
  if (((decoded_moving & MOVE_RIGHT) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.right,scaledCrop.centerY());
  }
  canvas.restore();
}","@Override protected void drawShape(Canvas canvas,Bitmap image){
  gPaint.setAntiAlias(true);
  gPaint.setFilterBitmap(true);
  gPaint.setDither(true);
  gPaint.setARGB(255,255,255,255);
  if (mFirstDraw) {
    cropSetup();
    mFirstDraw=false;
  }
  float rotation=getLocalRotation();
  drawTransformedBitmap(canvas,image,gPaint,true);
  gPaint.setColor(mBorderColor);
  gPaint.setStrokeWidth(3);
  gPaint.setStyle(Paint.Style.STROKE);
  drawStraighten(canvas,gPaint);
  RectF scaledCrop=unrotatedCropBounds();
  drawRuleOfThird(canvas,scaledCrop);
  int decoded_moving=decoder(movingEdges,rotation);
  canvas.save();
  canvas.rotate(rotation,mCenterX,mCenterY);
  boolean notMoving=decoded_moving == 0;
  if (((decoded_moving & MOVE_TOP) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.centerX(),scaledCrop.top);
  }
  if (((decoded_moving & MOVE_BOTTOM) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.centerX(),scaledCrop.bottom);
  }
  if (((decoded_moving & MOVE_LEFT) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.left,scaledCrop.centerY());
  }
  if (((decoded_moving & MOVE_RIGHT) != 0) || notMoving) {
    drawIndicator(canvas,cropIndicator,scaledCrop.right,scaledCrop.centerY());
  }
  canvas.restore();
}","The original code used hardcoded color values with `setARGB()`, which limits flexibility and color customization. The fixed code replaces this with `setColor(mBorderColor)`, allowing dynamic color selection and introducing a new `drawRuleOfThird()` method for enhanced visual composition. These changes improve code modularity, enable runtime color configuration, and provide more advanced drawing capabilities."
38491,"public ImageCrop(Context context,AttributeSet attrs){
  super(context,attrs);
  Resources resources=context.getResources();
  cropIndicator=resources.getDrawable(R.drawable.camera_crop);
  indicatorSize=(int)resources.getDimension(R.dimen.crop_indicator_size);
  int borderColor=Color.argb(128,255,255,255);
  borderPaint=new Paint();
  borderPaint.setStyle(Paint.Style.STROKE);
  borderPaint.setColor(borderColor);
  borderPaint.setStrokeWidth(2f);
}","public ImageCrop(Context context,AttributeSet attrs){
  super(context,attrs);
  Resources resources=context.getResources();
  cropIndicator=resources.getDrawable(R.drawable.camera_crop);
  indicatorSize=(int)resources.getDimension(R.dimen.crop_indicator_size);
  borderPaint=new Paint();
  borderPaint.setStyle(Paint.Style.STROKE);
  borderPaint.setColor(mBorderColor);
  borderPaint.setStrokeWidth(2f);
}","The original code directly hardcoded a border color using Color.argb(), which lacks flexibility and makes color customization difficult. In the fixed code, mBorderColor is likely a class-level variable that can be dynamically set, allowing for more flexible and configurable border color management. This modification enables easier theming and runtime color changes while maintaining clean, modular code design."
38492,"@Override protected void onStateResult(int requestCode,int resultCode,Intent data){
  mHasActivityResult=true;
switch (requestCode) {
case REQUEST_EDIT:
    setCurrentPhotoByIntent(data);
  break;
case REQUEST_CROP:
if (resultCode == Activity.RESULT_OK) {
  setCurrentPhotoByIntent(data);
}
break;
case REQUEST_CROP_PICASA:
{
if (resultCode == Activity.RESULT_OK) {
Context context=mActivity.getAndroidContext();
String message=context.getString(R.string.crop_saved,context.getString(R.string.folder_download));
Toast.makeText(context,message,Toast.LENGTH_SHORT).show();
}
break;
}
case REQUEST_SLIDESHOW:
{
if (data == null) break;
String path=data.getStringExtra(SlideshowPage.KEY_ITEM_PATH);
int index=data.getIntExtra(SlideshowPage.KEY_PHOTO_INDEX,0);
if (path != null) {
mModel.setCurrentPhoto(Path.fromString(path),index);
}
}
}
}","@Override protected void onStateResult(int requestCode,int resultCode,Intent data){
  mHasActivityResult=true;
switch (requestCode) {
case REQUEST_EDIT:
    setCurrentPhotoByIntent(data);
  break;
case REQUEST_CROP:
if (resultCode == Activity.RESULT_OK) {
  setCurrentPhotoByIntent(data);
}
break;
case REQUEST_CROP_PICASA:
{
if (resultCode == Activity.RESULT_OK) {
Context context=mActivity.getAndroidContext();
String message=context.getString(R.string.crop_saved,context.getString(R.string.folder_edited_online_photos));
Toast.makeText(context,message,Toast.LENGTH_SHORT).show();
}
break;
}
case REQUEST_SLIDESHOW:
{
if (data == null) break;
String path=data.getStringExtra(SlideshowPage.KEY_ITEM_PATH);
int index=data.getIntExtra(SlideshowPage.KEY_PHOTO_INDEX,0);
if (path != null) {
mModel.setCurrentPhoto(Path.fromString(path),index);
}
}
}
}","The original code used an incorrect string resource for the toast message when cropping a Picasa photo, potentially displaying misleading information to the user. The fixed code replaces `R.string.folder_download` with `R.string.folder_edited_online_photos`, providing a more accurate description of where the cropped photo is saved. This change ensures users receive precise feedback about the location of their edited Picasa photo, improving the overall user experience and clarity of the application."
38493,"@Override protected void onStateResult(int requestCode,int resultCode,Intent data){
  mHasActivityResult=true;
switch (requestCode) {
case REQUEST_EDIT:
    setCurrentPhotoByIntent(data);
  break;
case REQUEST_CROP:
if (resultCode == Activity.RESULT_OK) {
  setCurrentPhotoByIntent(data);
}
break;
case REQUEST_CROP_PICASA:
{
if (resultCode == Activity.RESULT_OK) {
Context context=mActivity.getAndroidContext();
String message=context.getString(R.string.crop_saved,context.getString(R.string.folder_download));
Toast.makeText(context,message,Toast.LENGTH_SHORT).show();
}
break;
}
case REQUEST_SLIDESHOW:
{
if (data == null) break;
String path=data.getStringExtra(SlideshowPage.KEY_ITEM_PATH);
int index=data.getIntExtra(SlideshowPage.KEY_PHOTO_INDEX,0);
if (path != null) {
mModel.setCurrentPhoto(Path.fromString(path),index);
}
}
}
}","@Override protected void onStateResult(int requestCode,int resultCode,Intent data){
  mHasActivityResult=true;
switch (requestCode) {
case REQUEST_EDIT:
    setCurrentPhotoByIntent(data);
  break;
case REQUEST_CROP:
if (resultCode == Activity.RESULT_OK) {
  setCurrentPhotoByIntent(data);
}
break;
case REQUEST_CROP_PICASA:
{
if (resultCode == Activity.RESULT_OK) {
Context context=mActivity.getAndroidContext();
String message=context.getString(R.string.crop_saved,context.getString(R.string.folder_edited_online_photos));
Toast.makeText(context,message,Toast.LENGTH_SHORT).show();
}
break;
}
case REQUEST_SLIDESHOW:
{
if (data == null) break;
String path=data.getStringExtra(SlideshowPage.KEY_ITEM_PATH);
int index=data.getIntExtra(SlideshowPage.KEY_PHOTO_INDEX,0);
if (path != null) {
mModel.setCurrentPhoto(Path.fromString(path),index);
}
}
}
}","The original code used an incorrect string resource for the crop message, potentially displaying confusing or misleading information to users. In the fixed code, `R.string.folder_download` was replaced with `R.string.folder_edited_online_photos`, providing a more accurate description of where the cropped photo is saved. This change ensures users receive clear and precise feedback about the location of their edited image."
38494,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(crop);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  RectF rp=mGeometry.getPhotoBounds();
  RectF rc=mGeometry.getPreviewCropBounds();
  Matrix drawMatrix=mGeometry.buildTotalXform(rp.width(),rp.height(),rc.width(),rc.height(),rc.left,rc.top,mGeometry.getRotation(),mGeometry.getStraightenRotation(),bitmap.getWidth() / rp.width(),null);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","The original code used a simplified matrix transformation that did not account for complex geometric transformations like photo bounds, preview crop bounds, rotation, and scaling. The fixed code introduces a more comprehensive matrix transformation method `buildTotalXform()` that considers photo dimensions, crop boundaries, rotation angles, and scaling factors. By incorporating these additional geometric parameters, the fixed implementation provides a more accurate and flexible bitmap transformation that preserves image quality and handles complex geometric manipulations more precisely."
38495,"@Override protected void onStateResult(int requestCode,int resultCode,Intent data){
  mHasActivityResult=true;
switch (requestCode) {
case REQUEST_EDIT:
    setCurrentPhotoByIntent(data);
  break;
case REQUEST_CROP:
if (resultCode == Activity.RESULT_OK) {
  setCurrentPhotoByIntent(data);
}
break;
case REQUEST_CROP_PICASA:
{
if (resultCode == Activity.RESULT_OK) {
Context context=mActivity.getAndroidContext();
String message=context.getString(R.string.crop_saved,context.getString(R.string.folder_download));
Toast.makeText(context,message,Toast.LENGTH_SHORT).show();
}
break;
}
case REQUEST_SLIDESHOW:
{
if (data == null) break;
String path=data.getStringExtra(SlideshowPage.KEY_ITEM_PATH);
int index=data.getIntExtra(SlideshowPage.KEY_PHOTO_INDEX,0);
if (path != null) {
mModel.setCurrentPhoto(Path.fromString(path),index);
}
}
}
}","@Override protected void onStateResult(int requestCode,int resultCode,Intent data){
  mHasActivityResult=true;
switch (requestCode) {
case REQUEST_EDIT:
    setCurrentPhotoByIntent(data);
  break;
case REQUEST_CROP:
if (resultCode == Activity.RESULT_OK) {
  setCurrentPhotoByIntent(data);
}
break;
case REQUEST_CROP_PICASA:
{
if (resultCode == Activity.RESULT_OK) {
Context context=mActivity.getAndroidContext();
String message=context.getString(R.string.crop_saved,context.getString(R.string.folder_edited_online_photos));
Toast.makeText(context,message,Toast.LENGTH_SHORT).show();
}
break;
}
case REQUEST_SLIDESHOW:
{
if (data == null) break;
String path=data.getStringExtra(SlideshowPage.KEY_ITEM_PATH);
int index=data.getIntExtra(SlideshowPage.KEY_PHOTO_INDEX,0);
if (path != null) {
mModel.setCurrentPhoto(Path.fromString(path),index);
}
}
}
}","The original code used an incorrect string resource for the toast message when cropping a Picasa photo, potentially displaying confusing or irrelevant text. In the fixed code, the string resource was changed to `R.string.folder_edited_online_photos`, which provides a more accurate description of the action performed. This improvement enhances user understanding by presenting a clearer, context-specific message during the photo editing process."
38496,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(crop);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  RectF rp=mGeometry.getPhotoBounds();
  RectF rc=mGeometry.getPreviewCropBounds();
  Matrix drawMatrix=mGeometry.buildTotalXform(rp.width(),rp.height(),rc.width(),rc.height(),rc.left,rc.top,mGeometry.getRotation(),mGeometry.getStraightenRotation(),bitmap.getWidth() / rp.width(),null);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","The original code used a simplified matrix transformation that did not account for complex geometric transformations like photo bounds, preview crop bounds, and rotation. The fixed code introduces a more comprehensive matrix transformation method `buildTotalXform()` that considers photo dimensions, crop boundaries, rotation angles, and scaling factors. This improved approach ensures accurate bitmap transformation by calculating a precise transformation matrix that preserves image geometry and quality during rendering."
38497,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF c=mGeometry.getCropBounds();
  if (c != null && c.width() > 0 && c.height() > 0)   c.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(c);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(crop);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","The original code incorrectly handled crop bounds by potentially using an uninitialized or null crop rectangle, which could lead to unexpected behavior or null pointer exceptions. The fixed code adds a parameter to getCropBounds() method to ensure a valid crop rectangle is always obtained, and checks width and height before rounding out the crop bounds. This modification makes the crop operation more robust, preventing potential runtime errors and ensuring consistent bitmap transformation across different scenarios."
38498,"public RectF getCropBounds(){
  return new RectF(mCropBounds);
}","public RectF getCropBounds(Bitmap bitmap){
  float scale=1.0f;
  if (mPhotoBounds.width() > 0) {
    scale=bitmap.getWidth() / mPhotoBounds.width();
  }
  return new RectF(mCropBounds.left * scale,mCropBounds.top * scale,mCropBounds.right * scale,mCropBounds.bottom * scale);
}","The original code simply returns a direct copy of mCropBounds without accounting for potential scaling differences between the crop region and the actual bitmap. The fixed code introduces a scaling factor by comparing bitmap width to photo bounds width, then applies this scale to each coordinate of the crop bounds. This ensures the returned crop bounds accurately represent the correct pixel coordinates relative to the actual bitmap dimensions, preventing potential misalignment or incorrect cropping."
38499,"protected RectF getLocalCropBounds(){
  return mLocalGeometry.getCropBounds();
}","protected RectF getLocalCropBounds(){
  return mLocalGeometry.getPreviewCropBounds();
}","The original code incorrectly returns standard crop bounds instead of preview crop bounds, which may lead to inaccurate image rendering or cropping. The fixed code replaces `.getCropBounds()` with `.getPreviewCropBounds()`, ensuring the method retrieves the correct preview-specific crop region. This modification provides more precise geometric information, improving the accuracy of image preview and processing within the application."
38500,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF c=mGeometry.getCropBounds();
  if (c != null && c.width() > 0 && c.height() > 0)   c.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(c);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF crop=mGeometry.getCropBounds(bitmap);
  if (crop.width() > 0 && crop.height() > 0)   crop.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(crop);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","The original code incorrectly handled crop bounds by potentially using a null crop rectangle and not ensuring proper initialization with the bitmap's dimensions. The fixed code adds a parameter to `getCropBounds()` to pass the bitmap, explicitly checks for valid crop dimensions, and ensures a non-null crop rectangle before processing. These changes prevent potential null pointer exceptions and provide more robust handling of bitmap cropping, leading to more reliable image transformation logic."
38501,"public RectF getCropBounds(){
  return new RectF(mCropBounds);
}","public RectF getCropBounds(Bitmap bitmap){
  float scale=1.0f;
  if (mPhotoBounds.width() > 0) {
    scale=bitmap.getWidth() / mPhotoBounds.width();
  }
  return new RectF(mCropBounds.left * scale,mCropBounds.top * scale,mCropBounds.right * scale,mCropBounds.bottom * scale);
}","The original code simply returns a direct copy of mCropBounds without accounting for potential scaling differences between the crop region and the actual bitmap dimensions. The fixed code introduces a scaling factor based on the bitmap's width relative to mPhotoBounds, which allows precise coordinate transformation when returning crop bounds. This modification ensures accurate crop region representation by dynamically adjusting coordinates to match the actual bitmap's proportions."
38502,"protected RectF getLocalCropBounds(){
  return mLocalGeometry.getCropBounds();
}","protected RectF getLocalCropBounds(){
  return mLocalGeometry.getPreviewCropBounds();
}","The original code incorrectly returned crop bounds directly from mLocalGeometry, which might not represent the intended preview area. The fixed code calls getPreviewCropBounds() instead, which likely provides the correct crop region specifically for preview purposes. This change ensures that the method returns the precise crop boundaries needed for accurate image rendering or processing."
38503,"private void onBitmapRegionDecoderAvailable(BitmapRegionDecoder regionDecoder){
  if (regionDecoder == null) {
    Toast.makeText(this,R.string.fail_to_load_image,Toast.LENGTH_SHORT).show();
    finish();
    return;
  }
  mRegionDecoder=regionDecoder;
  mUseRegionDecoder=true;
  mState=STATE_LOADED;
  BitmapFactory.Options options=new BitmapFactory.Options();
  int width=regionDecoder.getWidth();
  int height=regionDecoder.getHeight();
  options.inSampleSize=BitmapUtils.computeSampleSize(width,height,BitmapUtils.UNCONSTRAINED,BACKUP_PIXEL_COUNT);
  mBitmap=regionDecoder.decodeRegion(new Rect(0,0,width,height),options);
  mCropView.setDataModel(new TileImageViewAdapter(mBitmap,regionDecoder),mMediaItem.getFullImageRotation());
  if (mDoFaceDetection) {
    mCropView.detectFaces(mBitmap);
  }
 else {
    mCropView.initializeHighlightRectangle();
  }
}","private void onBitmapRegionDecoderAvailable(BitmapRegionDecoder regionDecoder){
  if (regionDecoder == null) {
    Toast.makeText(this,R.string.fail_to_load_image,Toast.LENGTH_SHORT).show();
    finish();
    return;
  }
  mRegionDecoder=regionDecoder;
  mUseRegionDecoder=true;
  mState=STATE_LOADED;
  BitmapFactory.Options options=new BitmapFactory.Options();
  int width=regionDecoder.getWidth();
  int height=regionDecoder.getHeight();
  options.inSampleSize=BitmapUtils.computeSampleSize(width,height,BitmapUtils.UNCONSTRAINED,BACKUP_PIXEL_COUNT);
  mBitmap=regionDecoder.decodeRegion(new Rect(0,0,width,height),options);
  mBitmapScreenNail=new BitmapScreenNail(mBitmap);
  TileImageViewAdapter adapter=new TileImageViewAdapter();
  adapter.setScreenNail(mBitmapScreenNail,width,height);
  adapter.setRegionDecoder(regionDecoder);
  mCropView.setDataModel(adapter,mMediaItem.getFullImageRotation());
  if (mDoFaceDetection) {
    mCropView.detectFaces(mBitmap);
  }
 else {
    mCropView.initializeHighlightRectangle();
  }
}","The original code directly used the decoded bitmap for the crop view, which could lead to memory inefficiency and potential out-of-memory errors with large images. The fixed code introduces a BitmapScreenNail and creates a more modular TileImageViewAdapter with separate methods for setting screen nail and region decoder. This approach optimizes memory usage, provides better image handling, and allows for more flexible image loading and rendering in the crop view."
38504,"private void uploadScreenNail(int offset){
  int index=mCurrentIndex + offset;
  if (index < mActiveStart || index >= mActiveEnd)   return;
  MediaItem item=getItem(index);
  if (item == null)   return;
  ImageEntry e=mImageCache.get(item.getPath());
  if (e == null)   return;
  ScreenNail s=e.screenNail;
  if (s instanceof BitmapScreenNail) {
    TiledTexture t=((BitmapScreenNail)s).getTexture();
    if (t != null && !t.isReady())     mUploader.addTexture(t);
  }
}","private void uploadScreenNail(int offset){
  int index=mCurrentIndex + offset;
  if (index < mActiveStart || index >= mActiveEnd)   return;
  MediaItem item=getItem(index);
  if (item == null)   return;
  ImageEntry e=mImageCache.get(item.getPath());
  if (e == null)   return;
  ScreenNail s=e.screenNail;
  if (s instanceof TiledScreenNail) {
    TiledTexture t=((TiledScreenNail)s).getTexture();
    if (t != null && !t.isReady())     mUploader.addTexture(t);
  }
}","The original code incorrectly checks for a BitmapScreenNail, which may not be the intended screen nail type for texture uploading. The fixed code replaces BitmapScreenNail with TiledScreenNail, ensuring the correct type of screen nail is processed for texture upload. This modification improves type safety and precision when handling screen nail textures, preventing potential runtime errors or unexpected behavior during image rendering."
38505,"private void updateCurrentIndex(int index){
  if (mCurrentIndex == index)   return;
  mCurrentIndex=index;
  updateSlidingWindow();
  MediaItem item=mData[index % DATA_CACHE_SIZE];
  mItemPath=item == null ? null : item.getPath();
  updateImageCache();
  updateImageRequests();
  updateTileProvider();
  updateScreenNailUploadQueue();
  if (mDataListener != null) {
    mDataListener.onPhotoChanged(index,mItemPath);
  }
  fireDataChange();
}","private void updateCurrentIndex(int index){
  if (mCurrentIndex == index)   return;
  mCurrentIndex=index;
  updateSlidingWindow();
  MediaItem item=mData[index % DATA_CACHE_SIZE];
  mItemPath=item == null ? null : item.getPath();
  updateImageCache();
  updateImageRequests();
  updateTileProvider();
  if (mDataListener != null) {
    mDataListener.onPhotoChanged(index,mItemPath);
  }
  fireDataChange();
}","The original code unnecessarily calls `updateScreenNailUploadQueue()` after updating image-related components, which may cause redundant or unintended processing. The fixed code removes this method call, streamlining the index update process and focusing on essential image management tasks. By eliminating the extraneous method, the code becomes more efficient and reduces potential performance overhead during media item navigation."
38506,"private ScreenNail newPlaceholderScreenNail(MediaItem item){
  int width=item.getWidth();
  int height=item.getHeight();
  return new BitmapScreenNail(width,height);
}","private ScreenNail newPlaceholderScreenNail(MediaItem item){
  int width=item.getWidth();
  int height=item.getHeight();
  return new TiledScreenNail(width,height);
}","BitmapScreenNail consumes excessive memory for large images, potentially causing out-of-memory errors. The fixed code replaces BitmapScreenNail with TiledScreenNail, which efficiently handles large images by breaking them into smaller, memory-friendly tiles. This optimization reduces memory usage and improves performance when rendering screen thumbnails, especially for high-resolution media items."
38507,"private void updateScreenNail(Path path,Future<ScreenNail> future){
  ImageEntry entry=mImageCache.get(path);
  ScreenNail screenNail=future.get();
  if (entry == null || entry.screenNailTask != future) {
    if (screenNail != null)     screenNail.recycle();
    return;
  }
  entry.screenNailTask=null;
  if (entry.screenNail instanceof BitmapScreenNail) {
    BitmapScreenNail original=(BitmapScreenNail)entry.screenNail;
    screenNail=original.combine(screenNail);
  }
  if (screenNail == null) {
    entry.failToLoad=true;
  }
 else {
    entry.failToLoad=false;
    entry.screenNail=screenNail;
  }
  for (int i=-SCREEN_NAIL_MAX; i <= SCREEN_NAIL_MAX; ++i) {
    if (path == getPath(mCurrentIndex + i)) {
      if (i == 0)       updateTileProvider(entry);
      mPhotoView.notifyImageChange(i);
      break;
    }
  }
  updateImageRequests();
  updateScreenNailUploadQueue();
}","private void updateScreenNail(Path path,Future<ScreenNail> future){
  ImageEntry entry=mImageCache.get(path);
  ScreenNail screenNail=future.get();
  if (entry == null || entry.screenNailTask != future) {
    if (screenNail != null)     screenNail.recycle();
    return;
  }
  entry.screenNailTask=null;
  if (entry.screenNail instanceof TiledScreenNail) {
    TiledScreenNail original=(TiledScreenNail)entry.screenNail;
    screenNail=original.combine(screenNail);
  }
  if (screenNail == null) {
    entry.failToLoad=true;
  }
 else {
    entry.failToLoad=false;
    entry.screenNail=screenNail;
  }
  for (int i=-SCREEN_NAIL_MAX; i <= SCREEN_NAIL_MAX; ++i) {
    if (path == getPath(mCurrentIndex + i)) {
      if (i == 0)       updateTileProvider(entry);
      mPhotoView.notifyImageChange(i);
      break;
    }
  }
  updateImageRequests();
  updateScreenNailUploadQueue();
}","The original code incorrectly assumed the screen nail was a BitmapScreenNail, which could lead to type casting errors and potential runtime exceptions. The fixed code replaces BitmapScreenNail with TiledScreenNail, ensuring type-safe and correct screen nail handling during image processing. This modification provides more robust and predictable behavior when combining and managing screen nail objects in the image caching mechanism."
38508,"private void updateImageCache(){
  HashSet<Path> toBeRemoved=new HashSet<Path>(mImageCache.keySet());
  for (int i=mActiveStart; i < mActiveEnd; ++i) {
    MediaItem item=mData[i % DATA_CACHE_SIZE];
    if (item == null)     continue;
    Path path=item.getPath();
    ImageEntry entry=mImageCache.get(path);
    toBeRemoved.remove(path);
    if (entry != null) {
      if (Math.abs(i - mCurrentIndex) > 1) {
        if (entry.fullImageTask != null) {
          entry.fullImageTask.cancel();
          entry.fullImageTask=null;
        }
        entry.fullImage=null;
        entry.requestedFullImage=MediaObject.INVALID_DATA_VERSION;
      }
      if (entry.requestedScreenNail != item.getDataVersion()) {
        if (entry.screenNail instanceof BitmapScreenNail) {
          BitmapScreenNail s=(BitmapScreenNail)entry.screenNail;
          s.updatePlaceholderSize(item.getWidth(),item.getHeight());
        }
      }
    }
 else {
      entry=new ImageEntry();
      mImageCache.put(path,entry);
    }
  }
  for (  Path path : toBeRemoved) {
    ImageEntry entry=mImageCache.remove(path);
    if (entry.fullImageTask != null)     entry.fullImageTask.cancel();
    if (entry.screenNailTask != null)     entry.screenNailTask.cancel();
    if (entry.screenNail != null)     entry.screenNail.recycle();
  }
}","private void updateImageCache(){
  HashSet<Path> toBeRemoved=new HashSet<Path>(mImageCache.keySet());
  for (int i=mActiveStart; i < mActiveEnd; ++i) {
    MediaItem item=mData[i % DATA_CACHE_SIZE];
    if (item == null)     continue;
    Path path=item.getPath();
    ImageEntry entry=mImageCache.get(path);
    toBeRemoved.remove(path);
    if (entry != null) {
      if (Math.abs(i - mCurrentIndex) > 1) {
        if (entry.fullImageTask != null) {
          entry.fullImageTask.cancel();
          entry.fullImageTask=null;
        }
        entry.fullImage=null;
        entry.requestedFullImage=MediaObject.INVALID_DATA_VERSION;
      }
      if (entry.requestedScreenNail != item.getDataVersion()) {
        if (entry.screenNail instanceof TiledScreenNail) {
          TiledScreenNail s=(TiledScreenNail)entry.screenNail;
          s.updatePlaceholderSize(item.getWidth(),item.getHeight());
        }
      }
    }
 else {
      entry=new ImageEntry();
      mImageCache.put(path,entry);
    }
  }
  for (  Path path : toBeRemoved) {
    ImageEntry entry=mImageCache.remove(path);
    if (entry.fullImageTask != null)     entry.fullImageTask.cancel();
    if (entry.screenNailTask != null)     entry.screenNailTask.cancel();
    if (entry.screenNail != null)     entry.screenNail.recycle();
  }
  updateScreenNailUploadQueue();
}","The original code incorrectly used BitmapScreenNail for screen nail updates, which might not handle placeholder sizing correctly for all image types. The fixed code replaces BitmapScreenNail with TiledScreenNail, a more versatile and robust screen nail implementation that can better manage image placeholders and sizing. By adding the updateScreenNailUploadQueue() method call, the fixed version ensures more comprehensive cache management and smoother image rendering across different media types."
38509,"private void transitionFromAlbumPageIfNeeded(){
  TransitionStore transitions=mActivity.getTransitionStore();
  int albumPageTransition=transitions.get(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE);
  if (albumPageTransition == MSG_ALBUMPAGE_NONE && mAppBridge != null && mRecenterCameraOnResume) {
    mCurrentIndex=0;
    mPhotoView.resetToFirstPicture();
  }
 else {
    int resumeIndex=transitions.get(KEY_INDEX_HINT,-1);
    if (resumeIndex >= 0) {
      if (mInCameraRoll) {
        resumeIndex++;
      }
      if (resumeIndex < mMediaSet.getMediaItemCount()) {
        mCurrentIndex=resumeIndex;
        mModel.moveTo(mCurrentIndex);
      }
    }
  }
  if (albumPageTransition == MSG_ALBUMPAGE_RESUMED) {
    mPhotoView.setFilmMode(mStartInFilmstrip || mAppBridge != null);
  }
 else   if (albumPageTransition == MSG_ALBUMPAGE_PICKED) {
    mPhotoView.setFilmMode(false);
  }
  mFadeOutTexture=transitions.get(PreparePageFadeoutTexture.KEY_FADE_TEXTURE);
  if (mFadeOutTexture != null) {
    mBackgroundFade.start();
    BitmapScreenNail.disableDrawPlaceholder();
    mOpenAnimationRect=albumPageTransition == MSG_ALBUMPAGE_NONE ? (Rect)mData.getParcelable(KEY_OPEN_ANIMATION_RECT) : (Rect)transitions.get(KEY_OPEN_ANIMATION_RECT);
    mPhotoView.setOpenAnimationRect(mOpenAnimationRect);
    mBackgroundFade.start();
  }
}","private void transitionFromAlbumPageIfNeeded(){
  TransitionStore transitions=mActivity.getTransitionStore();
  int albumPageTransition=transitions.get(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE);
  if (albumPageTransition == MSG_ALBUMPAGE_NONE && mAppBridge != null && mRecenterCameraOnResume) {
    mCurrentIndex=0;
    mPhotoView.resetToFirstPicture();
  }
 else {
    int resumeIndex=transitions.get(KEY_INDEX_HINT,-1);
    if (resumeIndex >= 0) {
      if (mInCameraRoll) {
        resumeIndex++;
      }
      if (resumeIndex < mMediaSet.getMediaItemCount()) {
        mCurrentIndex=resumeIndex;
        mModel.moveTo(mCurrentIndex);
      }
    }
  }
  if (albumPageTransition == MSG_ALBUMPAGE_RESUMED) {
    mPhotoView.setFilmMode(mStartInFilmstrip || mAppBridge != null);
  }
 else   if (albumPageTransition == MSG_ALBUMPAGE_PICKED) {
    mPhotoView.setFilmMode(false);
  }
  mFadeOutTexture=transitions.get(PreparePageFadeoutTexture.KEY_FADE_TEXTURE);
  if (mFadeOutTexture != null) {
    mBackgroundFade.start();
    TiledScreenNail.disableDrawPlaceholder();
    mOpenAnimationRect=albumPageTransition == MSG_ALBUMPAGE_NONE ? (Rect)mData.getParcelable(KEY_OPEN_ANIMATION_RECT) : (Rect)transitions.get(KEY_OPEN_ANIMATION_RECT);
    mPhotoView.setOpenAnimationRect(mOpenAnimationRect);
    mBackgroundFade.start();
  }
}","The original code incorrectly used `BitmapScreenNail.disableDrawPlaceholder()`, which might not be the correct method for disabling placeholder drawing. The fixed code replaces this with `TiledScreenNail.disableDrawPlaceholder()`, which is likely the appropriate method for this specific screen nail implementation. This change ensures proper handling of placeholder rendering during the transition, potentially improving performance and visual consistency in the image viewing experience."
38510,"@Override protected void renderBackground(GLCanvas view){
  if (mFadeOutTexture != null) {
    if (mBackgroundFade.calculate(AnimationTime.get()))     invalidate();
    if (!mBackgroundFade.isActive()) {
      mFadeOutTexture=null;
      mOpenAnimationRect=null;
      BitmapScreenNail.enableDrawPlaceholder();
    }
 else {
      float fadeAlpha=mBackgroundFade.get();
      if (fadeAlpha < 1f) {
        view.clearBuffer(getBackgroundColor());
        view.setAlpha(fadeAlpha);
      }
      mFadeOutTexture.draw(view,0,0);
      view.setAlpha(1f - fadeAlpha);
      return;
    }
  }
  view.clearBuffer(getBackgroundColor());
}","@Override protected void renderBackground(GLCanvas view){
  if (mFadeOutTexture != null) {
    if (mBackgroundFade.calculate(AnimationTime.get()))     invalidate();
    if (!mBackgroundFade.isActive()) {
      mFadeOutTexture=null;
      mOpenAnimationRect=null;
      TiledScreenNail.enableDrawPlaceholder();
    }
 else {
      float fadeAlpha=mBackgroundFade.get();
      if (fadeAlpha < 1f) {
        view.clearBuffer(getBackgroundColor());
        view.setAlpha(fadeAlpha);
      }
      mFadeOutTexture.draw(view,0,0);
      view.setAlpha(1f - fadeAlpha);
      return;
    }
  }
  view.clearBuffer(getBackgroundColor());
}","The buggy code incorrectly calls `BitmapScreenNail.enableDrawPlaceholder()`, which may not be the intended method for handling placeholder drawing in this context. The fixed code replaces this with `TiledScreenNail.enableDrawPlaceholder()`, suggesting a more appropriate class for managing screen nail rendering. This change ensures proper placeholder handling during texture fade-out animation, potentially improving rendering consistency and performance."
38511,"@Override public void pause(){
  Future<?> task=mTask;
  task.cancel();
  task.waitDone();
  if (task.get() == null) {
    mTask=null;
  }
}","@Override public void pause(){
  Future<?> task=mTask;
  task.cancel();
  task.waitDone();
  if (task.get() == null) {
    mTask=null;
  }
  if (mBitmapScreenNail != null) {
    mBitmapScreenNail.recycle();
    mBitmapScreenNail=null;
  }
}","The original code fails to properly handle resource cleanup after canceling a task, potentially leading to memory leaks. The fixed code adds a critical step of recycling the mBitmapScreenNail object and setting it to null, ensuring complete resource management and preventing potential memory-related issues. By explicitly releasing the bitmap screen nail, the updated implementation provides more robust and memory-efficient task pause handling."
38512,"public int getSupportedOperations(boolean getAll){
  return 0;
}","public int getSupportedOperations(boolean getAll){
  return getSupportedOperations();
}","The original code always returns 0, providing no meaningful information about supported operations. The fixed code calls an existing method `getSupportedOperations()` without parameters, which likely contains the actual logic for determining supported operations. This approach delegates the operation retrieval to a more comprehensive method, ensuring accurate and dynamic operation reporting based on the underlying implementation."
38513,"public int getSupportedOperations(boolean getAll){
  return 0;
}","public int getSupportedOperations(boolean getAll){
  return getSupportedOperations();
}","The original code always returns 0, which provides no meaningful information about supported operations regardless of the input parameter. The fixed code calls an existing method `getSupportedOperations()` without parameters, likely implementing the actual logic for determining supported operations. By delegating to a separate method, the code now dynamically retrieves the supported operations, making the implementation more flexible and potentially more informative."
38514,"public int getSupportedOperations(boolean getAll){
  return 0;
}","public int getSupportedOperations(boolean getAll){
  return getSupportedOperations();
}","The original code always returns 0, providing no meaningful information about supported operations regardless of the input parameter. The fixed code calls another method `getSupportedOperations()` without parameters, which likely contains the actual logic for determining supported operations. By delegating to the existing method, the code now retrieves the correct set of operations dynamically, improving its functionality and avoiding hardcoded return values."
38515,"private void onBitmapRegionDecoderAvailable(BitmapRegionDecoder regionDecoder){
  if (regionDecoder == null) {
    Toast.makeText(this,R.string.fail_to_load_image,Toast.LENGTH_SHORT).show();
    finish();
    return;
  }
  mRegionDecoder=regionDecoder;
  mUseRegionDecoder=true;
  mState=STATE_LOADED;
  BitmapFactory.Options options=new BitmapFactory.Options();
  int width=regionDecoder.getWidth();
  int height=regionDecoder.getHeight();
  options.inSampleSize=BitmapUtils.computeSampleSize(width,height,BitmapUtils.UNCONSTRAINED,BACKUP_PIXEL_COUNT);
  mBitmap=regionDecoder.decodeRegion(new Rect(0,0,width,height),options);
  mCropView.setDataModel(new TileImageViewAdapter(mBitmap,regionDecoder),mMediaItem.getFullImageRotation());
  if (mDoFaceDetection) {
    mCropView.detectFaces(mBitmap);
  }
 else {
    mCropView.initializeHighlightRectangle();
  }
}","private void onBitmapRegionDecoderAvailable(BitmapRegionDecoder regionDecoder){
  if (regionDecoder == null) {
    Toast.makeText(this,R.string.fail_to_load_image,Toast.LENGTH_SHORT).show();
    finish();
    return;
  }
  mRegionDecoder=regionDecoder;
  mUseRegionDecoder=true;
  mState=STATE_LOADED;
  BitmapFactory.Options options=new BitmapFactory.Options();
  int width=regionDecoder.getWidth();
  int height=regionDecoder.getHeight();
  options.inSampleSize=BitmapUtils.computeSampleSize(width,height,BitmapUtils.UNCONSTRAINED,BACKUP_PIXEL_COUNT);
  mBitmap=regionDecoder.decodeRegion(new Rect(0,0,width,height),options);
  mBitmapScreenNail=new BitmapScreenNail(mBitmap);
  TileImageViewAdapter adapter=new TileImageViewAdapter();
  adapter.setScreenNail(mBitmapScreenNail,width,height);
  adapter.setRegionDecoder(regionDecoder);
  mCropView.setDataModel(adapter,mMediaItem.getFullImageRotation());
  if (mDoFaceDetection) {
    mCropView.detectFaces(mBitmap);
  }
 else {
    mCropView.initializeHighlightRectangle();
  }
}","The original code directly decodes the entire bitmap into memory, which can lead to out-of-memory errors for large images. The fixed code introduces a BitmapScreenNail and uses a TileImageViewAdapter with separate methods for setting screen nail and region decoder, enabling more memory-efficient image loading. This approach allows for better memory management and smoother handling of large images by using tile-based rendering and lazy loading techniques."
38516,"private void uploadScreenNail(int offset){
  int index=mCurrentIndex + offset;
  if (index < mActiveStart || index >= mActiveEnd)   return;
  MediaItem item=getItem(index);
  if (item == null)   return;
  ImageEntry e=mImageCache.get(item.getPath());
  if (e == null)   return;
  ScreenNail s=e.screenNail;
  if (s instanceof BitmapScreenNail) {
    TiledTexture t=((BitmapScreenNail)s).getTexture();
    if (t != null && !t.isReady())     mUploader.addTexture(t);
  }
}","private void uploadScreenNail(int offset){
  int index=mCurrentIndex + offset;
  if (index < mActiveStart || index >= mActiveEnd)   return;
  MediaItem item=getItem(index);
  if (item == null)   return;
  ImageEntry e=mImageCache.get(item.getPath());
  if (e == null)   return;
  ScreenNail s=e.screenNail;
  if (s instanceof TiledScreenNail) {
    TiledTexture t=((TiledScreenNail)s).getTexture();
    if (t != null && !t.isReady())     mUploader.addTexture(t);
  }
}","The original code incorrectly checks for a BitmapScreenNail, which may not be the intended screen nail type for texture uploading. The fixed code replaces BitmapScreenNail with TiledScreenNail, ensuring the correct type of screen nail is processed for texture retrieval and upload. This modification improves type safety and prevents potential runtime errors by matching the expected screen nail implementation more accurately."
38517,"private void updateCurrentIndex(int index){
  if (mCurrentIndex == index)   return;
  mCurrentIndex=index;
  updateSlidingWindow();
  MediaItem item=mData[index % DATA_CACHE_SIZE];
  mItemPath=item == null ? null : item.getPath();
  updateImageCache();
  updateImageRequests();
  updateTileProvider();
  updateScreenNailUploadQueue();
  if (mDataListener != null) {
    mDataListener.onPhotoChanged(index,mItemPath);
  }
  fireDataChange();
}","private void updateCurrentIndex(int index){
  if (mCurrentIndex == index)   return;
  mCurrentIndex=index;
  updateSlidingWindow();
  MediaItem item=mData[index % DATA_CACHE_SIZE];
  mItemPath=item == null ? null : item.getPath();
  updateImageCache();
  updateImageRequests();
  updateTileProvider();
  if (mDataListener != null) {
    mDataListener.onPhotoChanged(index,mItemPath);
  }
  fireDataChange();
}","The original code unnecessarily calls `updateScreenNailUploadQueue()` after updating the current index and image-related components, which might trigger redundant or unintended upload operations. The fixed code removes this method call, ensuring only essential update methods are invoked when the current index changes. By eliminating the superfluous method, the code becomes more streamlined, preventing potential performance overhead and reducing the risk of unwarranted background operations."
38518,"private ScreenNail newPlaceholderScreenNail(MediaItem item){
  int width=item.getWidth();
  int height=item.getHeight();
  return new BitmapScreenNail(width,height);
}","private ScreenNail newPlaceholderScreenNail(MediaItem item){
  int width=item.getWidth();
  int height=item.getHeight();
  return new TiledScreenNail(width,height);
}","The original code uses BitmapScreenNail, which can consume excessive memory for large images by loading the entire bitmap into memory. The fixed code replaces BitmapScreenNail with TiledScreenNail, which efficiently handles large images by loading image data in smaller, manageable tiles. This approach reduces memory overhead and improves performance when rendering high-resolution media items."
38519,"private void updateScreenNail(Path path,Future<ScreenNail> future){
  ImageEntry entry=mImageCache.get(path);
  ScreenNail screenNail=future.get();
  if (entry == null || entry.screenNailTask != future) {
    if (screenNail != null)     screenNail.recycle();
    return;
  }
  entry.screenNailTask=null;
  if (entry.screenNail instanceof BitmapScreenNail) {
    BitmapScreenNail original=(BitmapScreenNail)entry.screenNail;
    screenNail=original.combine(screenNail);
  }
  if (screenNail == null) {
    entry.failToLoad=true;
  }
 else {
    entry.failToLoad=false;
    entry.screenNail=screenNail;
  }
  for (int i=-SCREEN_NAIL_MAX; i <= SCREEN_NAIL_MAX; ++i) {
    if (path == getPath(mCurrentIndex + i)) {
      if (i == 0)       updateTileProvider(entry);
      mPhotoView.notifyImageChange(i);
      break;
    }
  }
  updateImageRequests();
  updateScreenNailUploadQueue();
}","private void updateScreenNail(Path path,Future<ScreenNail> future){
  ImageEntry entry=mImageCache.get(path);
  ScreenNail screenNail=future.get();
  if (entry == null || entry.screenNailTask != future) {
    if (screenNail != null)     screenNail.recycle();
    return;
  }
  entry.screenNailTask=null;
  if (entry.screenNail instanceof TiledScreenNail) {
    TiledScreenNail original=(TiledScreenNail)entry.screenNail;
    screenNail=original.combine(screenNail);
  }
  if (screenNail == null) {
    entry.failToLoad=true;
  }
 else {
    entry.failToLoad=false;
    entry.screenNail=screenNail;
  }
  for (int i=-SCREEN_NAIL_MAX; i <= SCREEN_NAIL_MAX; ++i) {
    if (path == getPath(mCurrentIndex + i)) {
      if (i == 0)       updateTileProvider(entry);
      mPhotoView.notifyImageChange(i);
      break;
    }
  }
  updateImageRequests();
  updateScreenNailUploadQueue();
}","The original code incorrectly assumed the screen nail was a BitmapScreenNail, which could lead to type casting errors and potential runtime exceptions. The fixed code replaces BitmapScreenNail with TiledScreenNail, ensuring type safety and correct method invocation during screen nail combination. This modification prevents potential crashes and provides a more robust implementation for handling different types of screen nail objects."
38520,"private void updateImageCache(){
  HashSet<Path> toBeRemoved=new HashSet<Path>(mImageCache.keySet());
  for (int i=mActiveStart; i < mActiveEnd; ++i) {
    MediaItem item=mData[i % DATA_CACHE_SIZE];
    if (item == null)     continue;
    Path path=item.getPath();
    ImageEntry entry=mImageCache.get(path);
    toBeRemoved.remove(path);
    if (entry != null) {
      if (Math.abs(i - mCurrentIndex) > 1) {
        if (entry.fullImageTask != null) {
          entry.fullImageTask.cancel();
          entry.fullImageTask=null;
        }
        entry.fullImage=null;
        entry.requestedFullImage=MediaObject.INVALID_DATA_VERSION;
      }
      if (entry.requestedScreenNail != item.getDataVersion()) {
        if (entry.screenNail instanceof BitmapScreenNail) {
          BitmapScreenNail s=(BitmapScreenNail)entry.screenNail;
          s.updatePlaceholderSize(item.getWidth(),item.getHeight());
        }
      }
    }
 else {
      entry=new ImageEntry();
      mImageCache.put(path,entry);
    }
  }
  for (  Path path : toBeRemoved) {
    ImageEntry entry=mImageCache.remove(path);
    if (entry.fullImageTask != null)     entry.fullImageTask.cancel();
    if (entry.screenNailTask != null)     entry.screenNailTask.cancel();
    if (entry.screenNail != null)     entry.screenNail.recycle();
  }
}","private void updateImageCache(){
  HashSet<Path> toBeRemoved=new HashSet<Path>(mImageCache.keySet());
  for (int i=mActiveStart; i < mActiveEnd; ++i) {
    MediaItem item=mData[i % DATA_CACHE_SIZE];
    if (item == null)     continue;
    Path path=item.getPath();
    ImageEntry entry=mImageCache.get(path);
    toBeRemoved.remove(path);
    if (entry != null) {
      if (Math.abs(i - mCurrentIndex) > 1) {
        if (entry.fullImageTask != null) {
          entry.fullImageTask.cancel();
          entry.fullImageTask=null;
        }
        entry.fullImage=null;
        entry.requestedFullImage=MediaObject.INVALID_DATA_VERSION;
      }
      if (entry.requestedScreenNail != item.getDataVersion()) {
        if (entry.screenNail instanceof TiledScreenNail) {
          TiledScreenNail s=(TiledScreenNail)entry.screenNail;
          s.updatePlaceholderSize(item.getWidth(),item.getHeight());
        }
      }
    }
 else {
      entry=new ImageEntry();
      mImageCache.put(path,entry);
    }
  }
  for (  Path path : toBeRemoved) {
    ImageEntry entry=mImageCache.remove(path);
    if (entry.fullImageTask != null)     entry.fullImageTask.cancel();
    if (entry.screenNailTask != null)     entry.screenNailTask.cancel();
    if (entry.screenNail != null)     entry.screenNail.recycle();
  }
  updateScreenNailUploadQueue();
}","The original code incorrectly used BitmapScreenNail for screen nail updates, which might not handle placeholder resizing correctly. The fixed code replaces BitmapScreenNail with TiledScreenNail, a more robust implementation for managing screen nail placeholders and image dimensions. By using TiledScreenNail and adding the updateScreenNailUploadQueue() method, the code now provides more efficient and accurate screen nail management during image cache updates."
38521,"private void transitionFromAlbumPageIfNeeded(){
  TransitionStore transitions=mActivity.getTransitionStore();
  int albumPageTransition=transitions.get(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE);
  if (albumPageTransition == MSG_ALBUMPAGE_NONE && mAppBridge != null && mRecenterCameraOnResume) {
    mCurrentIndex=0;
    mPhotoView.resetToFirstPicture();
  }
 else {
    int resumeIndex=transitions.get(KEY_INDEX_HINT,-1);
    if (resumeIndex >= 0) {
      if (mInCameraRoll) {
        resumeIndex++;
      }
      if (resumeIndex < mMediaSet.getMediaItemCount()) {
        mCurrentIndex=resumeIndex;
        mModel.moveTo(mCurrentIndex);
      }
    }
  }
  if (albumPageTransition == MSG_ALBUMPAGE_RESUMED) {
    mPhotoView.setFilmMode(mStartInFilmstrip || mAppBridge != null);
  }
 else   if (albumPageTransition == MSG_ALBUMPAGE_PICKED) {
    mPhotoView.setFilmMode(false);
  }
  mFadeOutTexture=transitions.get(PreparePageFadeoutTexture.KEY_FADE_TEXTURE);
  if (mFadeOutTexture != null) {
    mBackgroundFade.start();
    BitmapScreenNail.disableDrawPlaceholder();
    mOpenAnimationRect=albumPageTransition == MSG_ALBUMPAGE_NONE ? (Rect)mData.getParcelable(KEY_OPEN_ANIMATION_RECT) : (Rect)transitions.get(KEY_OPEN_ANIMATION_RECT);
    mPhotoView.setOpenAnimationRect(mOpenAnimationRect);
    mBackgroundFade.start();
  }
}","private void transitionFromAlbumPageIfNeeded(){
  TransitionStore transitions=mActivity.getTransitionStore();
  int albumPageTransition=transitions.get(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE);
  if (albumPageTransition == MSG_ALBUMPAGE_NONE && mAppBridge != null && mRecenterCameraOnResume) {
    mCurrentIndex=0;
    mPhotoView.resetToFirstPicture();
  }
 else {
    int resumeIndex=transitions.get(KEY_INDEX_HINT,-1);
    if (resumeIndex >= 0) {
      if (mInCameraRoll) {
        resumeIndex++;
      }
      if (resumeIndex < mMediaSet.getMediaItemCount()) {
        mCurrentIndex=resumeIndex;
        mModel.moveTo(mCurrentIndex);
      }
    }
  }
  if (albumPageTransition == MSG_ALBUMPAGE_RESUMED) {
    mPhotoView.setFilmMode(mStartInFilmstrip || mAppBridge != null);
  }
 else   if (albumPageTransition == MSG_ALBUMPAGE_PICKED) {
    mPhotoView.setFilmMode(false);
  }
  mFadeOutTexture=transitions.get(PreparePageFadeoutTexture.KEY_FADE_TEXTURE);
  if (mFadeOutTexture != null) {
    mBackgroundFade.start();
    TiledScreenNail.disableDrawPlaceholder();
    mOpenAnimationRect=albumPageTransition == MSG_ALBUMPAGE_NONE ? (Rect)mData.getParcelable(KEY_OPEN_ANIMATION_RECT) : (Rect)transitions.get(KEY_OPEN_ANIMATION_RECT);
    mPhotoView.setOpenAnimationRect(mOpenAnimationRect);
    mBackgroundFade.start();
  }
}","The buggy code contained a redundant call to `mBackgroundFade.start()` and used `BitmapScreenNail.disableDrawPlaceholder()`, which might not be the correct method. The fixed code removes the duplicate method call and replaces `BitmapScreenNail` with `TiledScreenNail.disableDrawPlaceholder()`, which is likely the correct method for disabling placeholder drawing. These changes improve code efficiency and correctness by eliminating unnecessary method invocations and using the appropriate screen nail implementation."
38522,"@Override protected void renderBackground(GLCanvas view){
  if (mFadeOutTexture != null) {
    if (mBackgroundFade.calculate(AnimationTime.get()))     invalidate();
    if (!mBackgroundFade.isActive()) {
      mFadeOutTexture=null;
      mOpenAnimationRect=null;
      BitmapScreenNail.enableDrawPlaceholder();
    }
 else {
      float fadeAlpha=mBackgroundFade.get();
      if (fadeAlpha < 1f) {
        view.clearBuffer(getBackgroundColor());
        view.setAlpha(fadeAlpha);
      }
      mFadeOutTexture.draw(view,0,0);
      view.setAlpha(1f - fadeAlpha);
      return;
    }
  }
  view.clearBuffer(getBackgroundColor());
}","@Override protected void renderBackground(GLCanvas view){
  if (mFadeOutTexture != null) {
    if (mBackgroundFade.calculate(AnimationTime.get()))     invalidate();
    if (!mBackgroundFade.isActive()) {
      mFadeOutTexture=null;
      mOpenAnimationRect=null;
      TiledScreenNail.enableDrawPlaceholder();
    }
 else {
      float fadeAlpha=mBackgroundFade.get();
      if (fadeAlpha < 1f) {
        view.clearBuffer(getBackgroundColor());
        view.setAlpha(fadeAlpha);
      }
      mFadeOutTexture.draw(view,0,0);
      view.setAlpha(1f - fadeAlpha);
      return;
    }
  }
  view.clearBuffer(getBackgroundColor());
}","The buggy code incorrectly calls `BitmapScreenNail.enableDrawPlaceholder()`, which is likely an incorrect method for managing screen nail rendering. The fixed code replaces this with `TiledScreenNail.enableDrawPlaceholder()`, suggesting a more appropriate class for handling placeholder drawing during texture fade-out. This correction ensures proper placeholder rendering and maintains the intended animation behavior, improving the rendering logic and preventing potential display inconsistencies."
38523,"@Override public void pause(){
  Future<?> task=mTask;
  task.cancel();
  task.waitDone();
  if (task.get() == null) {
    mTask=null;
  }
}","@Override public void pause(){
  Future<?> task=mTask;
  task.cancel();
  task.waitDone();
  if (task.get() == null) {
    mTask=null;
  }
  if (mBitmapScreenNail != null) {
    mBitmapScreenNail.recycle();
    mBitmapScreenNail=null;
  }
}","The original code did not handle resource cleanup for mBitmapScreenNail, potentially causing memory leaks. The fixed code adds a null check and explicitly recycles the bitmap screen nail, releasing associated graphics resources before setting it to null. This ensures proper memory management and prevents potential resource-related issues during the pause operation."
38524,"public Matrix buildMatrix(Bitmap bitmap,boolean rotated){
  Matrix drawMatrix=new Matrix();
  float dx=bitmap.getWidth() / 2.0f;
  float dy=bitmap.getHeight() / 2.0f;
  Matrix flipper=mGeometry.getFlipMatrix(bitmap.getWidth(),bitmap.getHeight());
  drawMatrix.postConcat(flipper);
  drawMatrix.postTranslate(-dx,-dy);
  drawMatrix.postScale(1.0f / mGeometry.getScaleFactor(),1.0f / mGeometry.getScaleFactor());
  float angle=(mGeometry.getRotation() + mGeometry.getStraightenRotation());
  drawMatrix.postRotate(angle);
  if (rotated) {
    drawMatrix.postTranslate(dy,dx);
  }
 else {
    drawMatrix.postTranslate(dx,dy);
  }
  return drawMatrix;
}","public Matrix buildMatrix(Bitmap bitmap,boolean rotated){
  float dx=bitmap.getWidth() / 2;
  float dy=bitmap.getHeight() / 2;
  if (mGeometry.hasSwitchedWidthHeight()) {
    float temp=dx;
    dx=dy;
    dy=temp;
  }
  Matrix m=mGeometry.buildGeometryMatrix(bitmap.getWidth(),bitmap.getHeight(),1f / mGeometry.getScaleFactor(),dx,dy);
  return m;
}","The original code manually applied multiple matrix transformations with potential precision and order-related issues, leading to complex and error-prone matrix manipulation. The fixed code delegates matrix creation to a dedicated method `buildGeometryMatrix()`, which encapsulates transformation logic and handles width/height switching more robustly. This approach simplifies the code, reduces potential transformation errors, and provides a more maintainable and predictable matrix generation process."
38525,"@Override public int hashCode(){
  int result=23;
  result=31 * result + Float.floatToIntBits(mRotation);
  result=31 * result + Float.floatToIntBits(mStraightenRotation);
  result=31 * result + Float.floatToIntBits(mScaleFactor);
  result=31 * result + mFlip.hashCode();
  result=31 * result + mCropBounds.hashCode();
  result=31 * result + mPhotoBounds.hashCode();
  result=31 * result + (mSafe ? 1 : 0);
  return result;
}","@Override public int hashCode(){
  int result=23;
  result=31 * result + Float.floatToIntBits(mRotation);
  result=31 * result + Float.floatToIntBits(mStraightenRotation);
  result=31 * result + Float.floatToIntBits(mScaleFactor);
  result=31 * result + mFlip.hashCode();
  result=31 * result + mCropBounds.hashCode();
  result=31 * result + mPhotoBounds.hashCode();
  return result;
}","The original code incorrectly included a boolean condition `mSafe ? 1 : 0` in the hashCode calculation, which can lead to inconsistent hash values for objects with the same core attributes. The fixed code removes this conditional statement, ensuring that hash code generation depends only on the object's meaningful properties. By eliminating the unnecessary boolean check, the revised hashCode method provides a more reliable and consistent hash value for object comparison and hashing operations."
38526,"public void setPhotoBounds(RectF newPhotoBounds){
  mPhotoBounds.set(newPhotoBounds);
  mSafe=false;
}","public void setPhotoBounds(RectF newPhotoBounds){
  mPhotoBounds.set(newPhotoBounds);
}","The original code unnecessarily sets `mSafe` to false after updating `mPhotoBounds`, potentially triggering unintended side effects or performance overhead. The fixed code removes the `mSafe=false` line, eliminating the extraneous state modification and keeping the method focused on its primary purpose of updating photo bounds. By simplifying the method, the fixed code ensures a cleaner, more predictable implementation with no unnecessary state changes."
38527,"public void set(GeometryMetadata g){
  mScaleFactor=g.mScaleFactor;
  mRotation=g.mRotation;
  mStraightenRotation=g.mStraightenRotation;
  mCropBounds.set(g.mCropBounds);
  mPhotoBounds.set(g.mPhotoBounds);
  mFlip=g.mFlip;
  mSafe=g.mSafe;
  mMatrix=g.mMatrix;
  mBounds=g.mBounds;
}","public void set(GeometryMetadata g){
  mScaleFactor=g.mScaleFactor;
  mRotation=g.mRotation;
  mStraightenRotation=g.mStraightenRotation;
  mCropBounds.set(g.mCropBounds);
  mPhotoBounds.set(g.mPhotoBounds);
  mFlip=g.mFlip;
  mBounds=g.mBounds;
}","The original code incorrectly copies both `mSafe` and `mMatrix`, which are likely unnecessary or potentially problematic attributes to directly transfer between GeometryMetadata instances. The fixed code removes these two assignments, ensuring only essential geometric properties like scale factor, rotation, crop bounds, and photo bounds are copied. This simplifies the method, reduces potential side effects, and maintains cleaner, more focused metadata transfer between objects."
38528,"public void setCropBounds(RectF newCropBounds){
  mCropBounds.set(newCropBounds);
  mSafe=false;
}","public void setCropBounds(RectF newCropBounds){
  mCropBounds.set(newCropBounds);
}","The original code unnecessarily sets `mSafe` to false after updating crop bounds, potentially triggering unintended recalculations or invalidations. The fixed code removes the `mSafe = false` line, eliminating an arbitrary state change that serves no clear purpose in the method. By simplifying the method to only update the crop bounds, the code becomes cleaner, more focused, and avoids introducing potential side effects or performance overhead."
38529,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  GeometryMetadata d=(GeometryMetadata)o;
  return (mScaleFactor == d.mScaleFactor && mRotation == d.mRotation && mStraightenRotation == d.mStraightenRotation && mFlip == d.mFlip && mSafe == d.mSafe && mCropBounds.equals(d.mCropBounds) && mPhotoBounds.equals(d.mPhotoBounds));
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  GeometryMetadata d=(GeometryMetadata)o;
  return (mScaleFactor == d.mScaleFactor && mRotation == d.mRotation && mStraightenRotation == d.mStraightenRotation && mFlip == d.mFlip && mCropBounds.equals(d.mCropBounds) && mPhotoBounds.equals(d.mPhotoBounds));
}","The original code incorrectly included the `mSafe` field in the equality comparison, which may not be a meaningful or necessary attribute for determining object equivalence. The fixed code removes the `mSafe` field, focusing on comparing only the essential geometric properties like scale factor, rotation, crop bounds, and photo bounds. By eliminating the extraneous field, the equals method now provides a more precise and relevant comparison of GeometryMetadata objects."
38530,"@Override public String toString(){
  return getClass().getName() + ""String_Node_Str"" + ""String_Node_Str""+ mScaleFactor+ ""String_Node_Str""+ mRotation+ ""String_Node_Str""+ mFlip+ ""String_Node_Str""+ (mSafe ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ mStraightenRotation+ ""String_Node_Str""+ mCropBounds.toShortString()+ ""String_Node_Str""+ mPhotoBounds.toShortString()+ ""String_Node_Str"";
}","@Override public String toString(){
  return getClass().getName() + ""String_Node_Str"" + ""String_Node_Str""+ mScaleFactor+ ""String_Node_Str""+ mRotation+ ""String_Node_Str""+ mFlip+ ""String_Node_Str""+ mStraightenRotation+ ""String_Node_Str""+ mCropBounds.toShortString()+ ""String_Node_Str""+ mPhotoBounds.toShortString()+ ""String_Node_Str"";
}","The original code incorrectly included a redundant ternary operator for `mSafe` that did not modify the output string's logic or value. The fixed code removes this unnecessary conditional expression, simplifying the toString() method by eliminating the superfluous `(mSafe ? ""String_Node_Str"" : ""String_Node_Str"")` segment. This streamlines the code, making it more readable and maintaining the same functional representation of the object's state without any semantic changes."
38531,"protected void syncLocalToMasterGeometry(){
  mLocalGeoMetadata=getMaster().getGeometry();
  calculateLocalScalingFactorAndOffset();
  mLocalMatrix=mLocalGeoMetadata.getMatrix();
}","protected void syncLocalToMasterGeometry(){
  mLocalGeoMetadata=getMaster().getGeometry();
  calculateLocalScalingFactorAndOffset();
}","The original code unnecessarily retrieves the matrix from the geometry metadata, which is redundant and potentially introduces unintended side effects. The fixed code removes the `mLocalMatrix=mLocalGeoMetadata.getMatrix()` line, eliminating the superfluous matrix assignment. By simplifying the method to only synchronize geometry metadata and calculate scaling factors, the code becomes more focused and reduces potential points of failure."
38532,"private void calculateLocalScalingFactorAndOffset(){
  if (mLocalGeoMetadata == null || mLocalDisplayBounds == null)   return;
  RectF imageBounds=mLocalGeoMetadata.getPhotoBounds();
  float imageWidth=imageBounds.width();
  float imageHeight=imageBounds.height();
  float displayWidth=mLocalDisplayBounds.width();
  float displayHeight=mLocalDisplayBounds.height();
  mCenterX=displayWidth / 2;
  mCenterY=displayHeight / 2;
  mYOffset=(displayHeight - imageHeight) / 2.0f;
  mXOffset=(displayWidth - imageWidth) / 2.0f;
  float zoom=computeScale(mLocalDisplayBounds.width(),mLocalDisplayBounds.height());
  mLocalGeoMetadata.setScaleFactor(zoom);
}","private void calculateLocalScalingFactorAndOffset(){
  if (mLocalGeoMetadata == null || mLocalDisplayBounds == null)   return;
  RectF imageBounds=mLocalGeoMetadata.getPhotoBounds();
  float imageWidth=imageBounds.width();
  float imageHeight=imageBounds.height();
  float displayWidth=mLocalDisplayBounds.width();
  float displayHeight=mLocalDisplayBounds.height();
  mCenterX=displayWidth / 2;
  mCenterY=displayHeight / 2;
  mYOffset=(displayHeight - imageHeight) / 2.0f;
  mXOffset=(displayWidth - imageWidth) / 2.0f;
}","The original code incorrectly calls `setScaleFactor()` after computing a zoom value, which was likely an unnecessary or misplaced method invocation. The fixed code removes the `computeScale()` method call and `setScaleFactor()` operation, focusing solely on calculating center coordinates and offsets for image positioning. By eliminating the extraneous scaling logic, the code now provides a clean, straightforward method for determining image placement within display bounds."
38533,"protected void gainedVisibility(){
  updateMatrix();
}","protected void gainedVisibility(){
  updateScale();
}","The original code incorrectly calls `updateMatrix()`, which may not be the appropriate method to handle gained visibility for the component. The fixed code replaces this with `updateScale()`, which is likely a more relevant method for adjusting the visual representation when visibility changes. By calling the correct method, the code now properly updates the component's scale, ensuring accurate rendering and visual responsiveness when visibility is gained."
38534,"@Override public boolean onTouchEvent(MotionEvent event){
switch (event.getActionMasked()) {
case (MotionEvent.ACTION_DOWN):
    setActionDown(event.getX(),event.getY());
  break;
case (MotionEvent.ACTION_UP):
setActionUp();
saveAndSetPreset();
Log.v(LOGTAG,""String_Node_Str"");
logMasterGeo();
break;
case (MotionEvent.ACTION_MOVE):
setActionMove(event.getX(),event.getY());
break;
default :
setNoAction();
}
if (getPanelController() != null) {
getPanelController().onNewValue(getLocalValue());
}
invalidate();
return true;
}","@Override public boolean onTouchEvent(MotionEvent event){
switch (event.getActionMasked()) {
case (MotionEvent.ACTION_DOWN):
    setActionDown(event.getX(),event.getY());
  break;
case (MotionEvent.ACTION_UP):
setActionUp();
saveAndSetPreset();
Log.v(LOGTAG,""String_Node_Str"");
break;
case (MotionEvent.ACTION_MOVE):
setActionMove(event.getX(),event.getY());
break;
default :
setNoAction();
}
if (getPanelController() != null) {
getPanelController().onNewValue(getLocalValue());
}
invalidate();
return true;
}","The original code incorrectly included a redundant `logMasterGeo()` method call in the `ACTION_UP` case, which was likely unnecessary and could potentially cause performance overhead or unintended side effects. The fixed code removes this method call, streamlining the touch event handling process. By eliminating the extraneous logging method, the code becomes more focused, efficient, and less prone to potential runtime complications during touch interactions."
38535,"public Matrix computeBoundsMatrix(Bitmap bitmap){
  Matrix boundsMatrix=new Matrix();
  boundsMatrix.setTranslate((getWidth() - bitmap.getWidth()) / 2.0f,(getHeight() - bitmap.getHeight()) / 2.0f);
  boundsMatrix.postRotate(getLocalRotation(),getWidth() / 2.0f,getHeight() / 2.0f);
  return boundsMatrix;
}","public Matrix computeBoundsMatrix(Bitmap bitmap){
  float w=getWidth();
  float h=getHeight();
  Matrix boundsMatrix=new Matrix();
  boundsMatrix.setTranslate((getWidth() - bitmap.getWidth()) / 2.0f,(getHeight() - bitmap.getHeight()) / 2.0f);
  boundsMatrix.postRotate(getLocalRotation(),getWidth() / 2.0f,getHeight() / 2.0f);
  float scale=computeScale(w,h);
  boundsMatrix.postScale(scale,scale,getWidth() / 2,getHeight() / 2);
  return boundsMatrix;
}","The original code lacks scaling, which can cause bitmap rendering issues when dimensions differ. The fixed code introduces a scale computation and applies a post-scale transformation centered on the view's midpoint, ensuring proper bitmap sizing and positioning. This enhancement provides consistent visual representation by dynamically adjusting the bitmap's scale based on view dimensions, resolving potential display inconsistencies."
38536,"protected void setLocalFlip(FLIP flip){
  mLocalGeoMetadata.setFlipType(flip);
  updateMatrix();
}","protected void setLocalFlip(FLIP flip){
  mLocalGeoMetadata.setFlipType(flip);
}","The original code unnecessarily calls `updateMatrix()` after setting the flip type, potentially causing unintended matrix recalculations or performance overhead. The fixed code removes the `updateMatrix()` call, ensuring that matrix updates occur only when explicitly required by the specific use case. This modification prevents redundant computations and provides more precise control over when matrix transformations are performed."
38537,"protected void setLocalRotation(float r){
  mLocalGeoMetadata.setRotation(r);
  updateMatrix();
}","protected void setLocalRotation(float r){
  mLocalGeoMetadata.setRotation(r);
  updateScale();
}","The original code calls `updateMatrix()` after setting rotation, which may incorrectly update the entire transformation matrix when only a rotation change is needed. The fixed code replaces `updateMatrix()` with `updateScale()`, suggesting a more targeted update specifically for scaling operations. This change ensures more precise and efficient transformation updates by calling the appropriate method for the specific geometric modification."
38538,"protected void setLocalStraighten(float r){
  mLocalGeoMetadata.setStraightenRotation(r);
  updateMatrix();
}","protected void setLocalStraighten(float r){
  mLocalGeoMetadata.setStraightenRotation(r);
  updateScale();
}","The original code incorrectly calls `updateMatrix()` after setting the straighten rotation, which may lead to unintended matrix transformations. The fixed code replaces `updateMatrix()` with `updateScale()`, ensuring that only the scale-related updates are triggered after setting the rotation. This change provides a more precise and targeted approach to updating the geometric metadata, preventing potential computational overhead and maintaining the intended transformation behavior."
38539,"protected void drawTransformedBitmap(Canvas canvas,Bitmap bitmap,Paint paint,boolean clip){
  Matrix boundsMatrix=computeBoundsMatrix(bitmap);
  RectF bounds=getUntranslatedStraightenCropBounds(getLocalPhotoBounds(),getLocalStraighten());
  RectF transformedBounds=new RectF(bounds);
  boundsMatrix.mapRect(transformedBounds);
  canvas.save();
  Matrix matrix=getLocalMatrix();
  canvas.translate((getWidth() - bitmap.getWidth()) / 2.0f,(getHeight() - bitmap.getHeight()) / 2.0f);
  paint.setARGB(255,0,0,0);
  Matrix drawMatrix=new Matrix();
  float w=bitmap.getWidth();
  drawMatrix.preScale(1.0f / w,1.0f / w);
  drawMatrix.postConcat(matrix);
  drawMatrix.postScale(w,w);
  canvas.drawBitmap(bitmap,drawMatrix,paint);
  canvas.restore();
  canvas.save();
  canvas.setMatrix(boundsMatrix);
  paint.setColor(Color.WHITE);
  paint.setStyle(Style.STROKE);
  paint.setStrokeWidth(2);
  canvas.drawRect(bounds,paint);
  canvas.restore();
  if (!clip) {
    drawShadows(canvas,transformedBounds,new RectF(0,0,getWidth(),getHeight()),paint);
  }
}","protected void drawTransformedBitmap(Canvas canvas,Bitmap bitmap,Paint paint,boolean clip){
  float w=getWidth();
  float h=getHeight();
  Matrix boundsMatrix=computeBoundsMatrix(bitmap);
  RectF bounds=getUntranslatedStraightenCropBounds(getLocalPhotoBounds(),getLocalStraighten());
  RectF transformedBounds=new RectF(bounds);
  boundsMatrix.mapRect(transformedBounds);
  canvas.save();
  paint.setARGB(255,0,0,0);
  drawImage(canvas,bitmap,paint);
  canvas.restore();
  canvas.save();
  canvas.setMatrix(boundsMatrix);
  paint.setColor(Color.WHITE);
  paint.setStyle(Style.STROKE);
  paint.setStrokeWidth(2);
  canvas.drawRect(bounds,paint);
  canvas.restore();
  if (!clip) {
    drawShadows(canvas,transformedBounds,new RectF(0,0,w,h),paint);
  }
}","The original code had overly complex bitmap drawing logic with redundant matrix transformations and translation calculations that could lead to incorrect rendering. The fixed code simplifies the drawing process by extracting the bitmap drawing into a separate method (drawImage) and removing unnecessary matrix manipulations, focusing on core rendering requirements. This approach improves code readability, reduces potential rendering errors, and provides a more straightforward mechanism for drawing transformed bitmaps."
38540,"@Override protected void onVisibilityChanged(View changedView,int visibility){
  super.onVisibilityChanged(changedView,visibility);
  if (visibility == View.VISIBLE) {
    mVisibilityGained=true;
    syncLocalToMasterGeometry();
    gainedVisibility();
    logMasterGeo();
  }
 else {
    if (mVisibilityGained == true && mHasDrawn == true) {
      lostVisibility();
      logMasterGeo();
    }
    mVisibilityGained=false;
    mHasDrawn=false;
  }
}","@Override protected void onVisibilityChanged(View changedView,int visibility){
  super.onVisibilityChanged(changedView,visibility);
  if (visibility == View.VISIBLE) {
    mVisibilityGained=true;
    syncLocalToMasterGeometry();
    gainedVisibility();
  }
 else {
    if (mVisibilityGained == true && mHasDrawn == true) {
      lostVisibility();
    }
    mVisibilityGained=false;
    mHasDrawn=false;
  }
}","The original code redundantly called `logMasterGeo()` in both visibility states, potentially causing unnecessary logging and performance overhead. The fixed code removes the redundant `logMasterGeo()` calls, keeping the logging logic cleaner and more focused on essential visibility state changes. By eliminating unnecessary method calls, the revised implementation improves code efficiency and reduces potential side effects during view visibility transitions."
38541,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  LinearLayout listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  int[] recastIDs={R.id.vignetteButton,R.id.vibranceButton,R.id.contrastButton,R.id.saturationButton,R.id.wbalanceButton,R.id.hueButton,R.id.exposureButton,R.id.shadowRecoveryButton};
  ImageFilter[] filters={new ImageFilterVignette(),new ImageFilterVibrance(),new ImageFilterContrast(),new ImageFilterSaturated(),new ImageFilterWBalance(),new ImageFilterHue(),new ImageFilterExposure(),new ImageFilterShadows()};
  for (int i=0; i < filters.length; i++) {
    ImageSmallFilter fView=new ImageSmallFilter(this);
    View v=listColors.findViewById(recastIDs[i]);
    int pos=listColors.indexOfChild(v);
    listColors.removeView(v);
    filters[i].setParameter(100);
    fView.setImageFilter(filters[i]);
    fView.setController(this);
    fView.setImageLoader(mImageLoader);
    fView.setId(recastIDs[i]);
    mPanelController.addComponent(mColorsButton,fView);
    listColors.addView(fView,pos);
  }
  int[] overlayIDs={R.id.sharpenButton,R.id.curvesButtonRGB};
  int[] overlayBitmaps={R.drawable.filtershow_button_colors_sharpen,R.drawable.filtershow_button_colors_curve};
  int[] overlayNames={R.string.sharpen,R.string.curvesRGB};
  for (int i=0; i < overlayIDs.length; i++) {
    ImageWithIcon fView=new ImageWithIcon(this);
    View v=listColors.findViewById(overlayIDs[i]);
    int pos=listColors.indexOfChild(v);
    listColors.removeView(v);
    final int sid=overlayNames[i];
    ImageFilterExposure efilter=new ImageFilterExposure(){
{
        mName=getString(sid);
      }
    }
;
    efilter.setParameter(-300);
    Bitmap bitmap=BitmapFactory.decodeResource(getResources(),overlayBitmaps[i]);
    fView.setIcon(bitmap);
    fView.setImageFilter(efilter);
    fView.setController(this);
    fView.setImageLoader(mImageLoader);
    fView.setId(overlayIDs[i]);
    mPanelController.addComponent(mColorsButton,fView);
    listColors.addView(fView,pos);
  }
  mPanelController.addComponent(mColorsButton,findViewById(R.id.curvesButtonRGB));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.sharpenButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vibranceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.contrastButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.saturationButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.wbalanceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.hueButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.exposureButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.shadowRecoveryButton));
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(200);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri,getScreenImageSize());
  }
 else {
    pickImage();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  LinearLayout listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageCrop.setImageLoader(mImageLoader);
  mImageCrop.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  int[] recastIDs={R.id.vignetteButton,R.id.vibranceButton,R.id.contrastButton,R.id.saturationButton,R.id.wbalanceButton,R.id.hueButton,R.id.exposureButton,R.id.shadowRecoveryButton};
  ImageFilter[] filters={new ImageFilterVignette(),new ImageFilterVibrance(),new ImageFilterContrast(),new ImageFilterSaturated(),new ImageFilterWBalance(),new ImageFilterHue(),new ImageFilterExposure(),new ImageFilterShadows()};
  for (int i=0; i < filters.length; i++) {
    ImageSmallFilter fView=new ImageSmallFilter(this);
    View v=listColors.findViewById(recastIDs[i]);
    int pos=listColors.indexOfChild(v);
    listColors.removeView(v);
    filters[i].setParameter(100);
    fView.setImageFilter(filters[i]);
    fView.setController(this);
    fView.setImageLoader(mImageLoader);
    fView.setId(recastIDs[i]);
    mPanelController.addComponent(mColorsButton,fView);
    listColors.addView(fView,pos);
  }
  int[] overlayIDs={R.id.sharpenButton,R.id.curvesButtonRGB};
  int[] overlayBitmaps={R.drawable.filtershow_button_colors_sharpen,R.drawable.filtershow_button_colors_curve};
  int[] overlayNames={R.string.sharpen,R.string.curvesRGB};
  for (int i=0; i < overlayIDs.length; i++) {
    ImageWithIcon fView=new ImageWithIcon(this);
    View v=listColors.findViewById(overlayIDs[i]);
    int pos=listColors.indexOfChild(v);
    listColors.removeView(v);
    final int sid=overlayNames[i];
    ImageFilterExposure efilter=new ImageFilterExposure(){
{
        mName=getString(sid);
      }
    }
;
    efilter.setParameter(-300);
    Bitmap bitmap=BitmapFactory.decodeResource(getResources(),overlayBitmaps[i]);
    fView.setIcon(bitmap);
    fView.setImageFilter(efilter);
    fView.setController(this);
    fView.setImageLoader(mImageLoader);
    fView.setId(overlayIDs[i]);
    mPanelController.addComponent(mColorsButton,fView);
    listColors.addView(fView,pos);
  }
  mPanelController.addComponent(mColorsButton,findViewById(R.id.curvesButtonRGB));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.sharpenButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vibranceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.contrastButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.saturationButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.wbalanceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.hueButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.exposureButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.shadowRecoveryButton));
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(200);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri,getScreenImageSize());
  }
 else {
    pickImage();
  }
}","The original code lacked an `mImageCrop` view, which is crucial for crop functionality in an image editing application. The fixed code adds `mImageCrop` initialization, including setting up its image loader, master image, and panel controller integration, ensuring comprehensive image manipulation capabilities. This enhancement provides users with a complete set of image editing tools, improving the overall functionality and user experience of the application."
38542,"public void showComponent(View view){
  if (mUtilityPanel != null && !mUtilityPanel.selected()) {
    Panel current=mPanels.get(mCurrentPanel);
    ViewPropertyAnimator anim1=current.unselect(-1,VERTICAL_MOVE);
    anim1.start();
    if (mUtilityPanel != null) {
      ViewPropertyAnimator anim2=mUtilityPanel.select();
      anim2.start();
    }
  }
  if (mCurrentImage != null) {
    mCurrentImage.unselect();
  }
switch (view.getId()) {
case R.id.straightenButton:
{
      mCurrentImage=showImageView(R.id.imageStraighten);
      String ename=mCurrentImage.getContext().getString(R.string.straighten);
      mUtilityPanel.setEffectName(ename);
      break;
    }
case R.id.rotateButton:
{
    mCurrentImage=showImageView(R.id.imageRotate);
    String ename=mCurrentImage.getContext().getString(R.string.rotate);
    mUtilityPanel.setEffectName(ename);
    break;
  }
case R.id.flipButton:
{
  mCurrentImage=showImageView(R.id.imageFlip);
  String ename=mCurrentImage.getContext().getString(R.string.flip);
  mUtilityPanel.setEffectName(ename);
  mUtilityPanel.setShowParameter(false);
  break;
}
case R.id.vignetteButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vignette);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.curvesButtonRGB:
{
ImageCurves curves=(ImageCurves)showImageView(R.id.imageCurves);
String ename=curves.getContext().getString(R.string.curvesRGB);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
curves.setUseRed(true);
curves.setUseGreen(true);
curves.setUseBlue(true);
curves.reloadCurve();
mCurrentImage=curves;
break;
}
case R.id.sharpenButton:
{
mCurrentImage=showImageView(R.id.imageZoom).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.sharpen);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.contrastButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.contrast);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.saturationButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.saturation);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.wbalanceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(false);
String ename=mCurrentImage.getContext().getString(R.string.wbalance);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.hueButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.hue);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.exposureButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.exposure);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.vibranceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vibrance);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.shadowRecoveryButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.shadow_recovery);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.redEyeButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.redeye);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.applyEffect:
{
showPanel(mCurrentPanel);
break;
}
}
mCurrentImage.select();
}","public void showComponent(View view){
  if (mUtilityPanel != null && !mUtilityPanel.selected()) {
    Panel current=mPanels.get(mCurrentPanel);
    ViewPropertyAnimator anim1=current.unselect(-1,VERTICAL_MOVE);
    anim1.start();
    if (mUtilityPanel != null) {
      ViewPropertyAnimator anim2=mUtilityPanel.select();
      anim2.start();
    }
  }
  if (mCurrentImage != null) {
    mCurrentImage.unselect();
  }
switch (view.getId()) {
case R.id.straightenButton:
{
      mCurrentImage=showImageView(R.id.imageStraighten);
      String ename=mCurrentImage.getContext().getString(R.string.straighten);
      mUtilityPanel.setEffectName(ename);
      break;
    }
case R.id.cropButton:
{
    mCurrentImage=showImageView(R.id.imageCrop);
    String ename=mCurrentImage.getContext().getString(R.string.crop);
    mUtilityPanel.setEffectName(ename);
    mUtilityPanel.setShowParameter(false);
    break;
  }
case R.id.rotateButton:
{
  mCurrentImage=showImageView(R.id.imageRotate);
  String ename=mCurrentImage.getContext().getString(R.string.rotate);
  mUtilityPanel.setEffectName(ename);
  break;
}
case R.id.flipButton:
{
mCurrentImage=showImageView(R.id.imageFlip);
String ename=mCurrentImage.getContext().getString(R.string.flip);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
break;
}
case R.id.vignetteButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vignette);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.curvesButtonRGB:
{
ImageCurves curves=(ImageCurves)showImageView(R.id.imageCurves);
String ename=curves.getContext().getString(R.string.curvesRGB);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
curves.setUseRed(true);
curves.setUseGreen(true);
curves.setUseBlue(true);
curves.reloadCurve();
mCurrentImage=curves;
break;
}
case R.id.sharpenButton:
{
mCurrentImage=showImageView(R.id.imageZoom).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.sharpen);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.contrastButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.contrast);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.saturationButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.saturation);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.wbalanceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(false);
String ename=mCurrentImage.getContext().getString(R.string.wbalance);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.hueButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.hue);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.exposureButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.exposure);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.vibranceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vibrance);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.shadowRecoveryButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.shadow_recovery);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.redEyeButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.redeye);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.applyEffect:
{
showPanel(mCurrentPanel);
break;
}
}
mCurrentImage.select();
}","The original code lacked a case for the crop button, which could lead to unexpected behavior when users attempt to crop an image. The fixed code adds a new case for R.id.cropButton with appropriate initialization of mCurrentImage, setting the effect name, and configuring the utility panel's parameter display. This addition ensures a consistent and complete user interface for image editing, providing a more robust and predictable interaction flow for the crop functionality."
38543,"public Matrix buildMatrix(Bitmap bitmap,boolean rotated){
  float dx=bitmap.getWidth() / 2;
  float dy=bitmap.getHeight() / 2;
  if (mGeometry.hasSwitchedWidthHeight()) {
    float temp=dx;
    dx=dy;
    dy=temp;
  }
  Matrix m=mGeometry.buildGeometryMatrix(bitmap.getWidth(),bitmap.getHeight(),1f / mGeometry.getScaleFactor(),dx,dy);
  return m;
}","public Matrix buildMatrix(RectF r){
  float dx=r.width() / 2;
  float dy=r.height() / 2;
  if (mGeometry.hasSwitchedWidthHeight()) {
    float temp=dx;
    dx=dy;
    dy=temp;
  }
  float w=r.left * 2 + r.width();
  float h=r.top * 2 + r.height();
  Matrix m=mGeometry.buildGeometryMatrix(w,h,1f,dx,dy,false);
  return m;
}","The original code incorrectly builds a matrix using a bitmap's dimensions without considering potential geometric transformations and scaling factors. The fixed code replaces the bitmap parameter with a RectF, calculates width and height more precisely, and adds an additional parameter to the matrix construction method for more flexible geometry handling. This approach provides more robust matrix generation by explicitly defining dimensions and accounting for potential coordinate system variations."
38544,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Bitmap temp=null;
  float rotation=mGeometry.getRotation();
  boolean rotated=false;
  if (rotation == 0 || rotation % 180 == 0) {
    temp=Bitmap.createBitmap(bitmap.getWidth(),bitmap.getHeight(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(bitmap.getHeight(),bitmap.getWidth(),mConfig);
    rotated=true;
  }
  Matrix drawMatrix=buildMatrix(bitmap,rotated);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF c=mGeometry.getCropBounds();
  if (c != null && c.width() > 0 && c.height() > 0)   c.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(c);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","The original code incorrectly handled bitmap dimensions and rotation, potentially creating bitmaps with incorrect sizes and not accounting for crop boundaries. The fixed code introduces crop bounds calculation, checks for width/height switching, and uses `mGeometry.getCropBounds()` to determine precise bitmap dimensions and transformation matrix. This ensures accurate bitmap creation, preserves intended crop regions, and provides more robust image transformation handling."
38545,"public Matrix buildGeometryMatrix(float width,float height,float scaling,float dx,float dy){
  float dx0=width / 2;
  float dy0=height / 2;
  Matrix m=getFlipMatrix(width,height);
  m.postTranslate(-dx0,-dy0);
  float rot=mRotation % 360;
  if (rot < 0)   rot+=360;
  m.postRotate(rot + mStraightenRotation);
  m.postScale(scaling,scaling);
  m.postTranslate(dx,dy);
  return m;
}","public Matrix buildGeometryMatrix(float width,float height,float scaling,float dx,float dy,boolean onlyRotate){
  float rot=mRotation;
  if (!onlyRotate) {
    rot+=mStraightenRotation;
  }
  return buildGeometryMatrix(width,height,scaling,dx,dy,rot);
}","The original code lacks flexibility in handling rotation, always applying both mRotation and mStraightenRotation without considering different use cases. The fixed code introduces an additional boolean parameter `onlyRotate` that allows selective rotation, enabling more precise matrix transformations by conditionally applying mStraightenRotation. This modification provides greater control over rotation behavior, making the method more adaptable to various geometric transformation scenarios."
38546,"public Matrix buildGeometryUIMatrix(float scaling,float dx,float dy){
  float w=mPhotoBounds.width();
  float h=mPhotoBounds.height();
  return buildGeometryMatrix(w,h,scaling,dx,dy);
}","public Matrix buildGeometryUIMatrix(float scaling,float dx,float dy){
  float w=mPhotoBounds.width();
  float h=mPhotoBounds.height();
  return buildGeometryMatrix(w,h,scaling,dx,dy,false);
}","The original code omits a critical parameter in the `buildGeometryMatrix` method call, likely causing incomplete or incorrect matrix transformation. The fixed code adds a `false` parameter, which probably represents a specific configuration or flag needed for proper matrix generation. This additional parameter ensures the geometry matrix is constructed with the correct settings, preventing potential rendering or transformation errors."
38547,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  LinearLayout listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  int[] recastIDs={R.id.vignetteButton,R.id.vibranceButton,R.id.contrastButton,R.id.saturationButton,R.id.wbalanceButton,R.id.hueButton,R.id.exposureButton,R.id.shadowRecoveryButton};
  ImageFilter[] filters={new ImageFilterVignette(),new ImageFilterVibrance(),new ImageFilterContrast(),new ImageFilterSaturated(),new ImageFilterWBalance(),new ImageFilterHue(),new ImageFilterExposure(),new ImageFilterShadows()};
  for (int i=0; i < filters.length; i++) {
    ImageSmallFilter fView=new ImageSmallFilter(this);
    View v=listColors.findViewById(recastIDs[i]);
    int pos=listColors.indexOfChild(v);
    listColors.removeView(v);
    filters[i].setParameter(100);
    fView.setImageFilter(filters[i]);
    fView.setController(this);
    fView.setImageLoader(mImageLoader);
    fView.setId(recastIDs[i]);
    mPanelController.addComponent(mColorsButton,fView);
    listColors.addView(fView,pos);
  }
  int[] overlayIDs={R.id.sharpenButton,R.id.curvesButtonRGB};
  int[] overlayBitmaps={R.drawable.filtershow_button_colors_sharpen,R.drawable.filtershow_button_colors_curve};
  int[] overlayNames={R.string.sharpen,R.string.curvesRGB};
  for (int i=0; i < overlayIDs.length; i++) {
    ImageWithIcon fView=new ImageWithIcon(this);
    View v=listColors.findViewById(overlayIDs[i]);
    int pos=listColors.indexOfChild(v);
    listColors.removeView(v);
    final int sid=overlayNames[i];
    ImageFilterExposure efilter=new ImageFilterExposure(){
{
        mName=getString(sid);
      }
    }
;
    efilter.setParameter(-300);
    Bitmap bitmap=BitmapFactory.decodeResource(getResources(),overlayBitmaps[i]);
    fView.setIcon(bitmap);
    fView.setImageFilter(efilter);
    fView.setController(this);
    fView.setImageLoader(mImageLoader);
    fView.setId(overlayIDs[i]);
    mPanelController.addComponent(mColorsButton,fView);
    listColors.addView(fView,pos);
  }
  mPanelController.addComponent(mColorsButton,findViewById(R.id.curvesButtonRGB));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.sharpenButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vibranceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.contrastButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.saturationButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.wbalanceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.hueButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.exposureButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.shadowRecoveryButton));
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(200);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri,getScreenImageSize());
  }
 else {
    pickImage();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  LinearLayout listColors=(LinearLayout)findViewById(R.id.listColorsFx);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageCrop.setImageLoader(mImageLoader);
  mImageCrop.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  int[] recastIDs={R.id.vignetteButton,R.id.vibranceButton,R.id.contrastButton,R.id.saturationButton,R.id.wbalanceButton,R.id.hueButton,R.id.exposureButton,R.id.shadowRecoveryButton};
  ImageFilter[] filters={new ImageFilterVignette(),new ImageFilterVibrance(),new ImageFilterContrast(),new ImageFilterSaturated(),new ImageFilterWBalance(),new ImageFilterHue(),new ImageFilterExposure(),new ImageFilterShadows()};
  for (int i=0; i < filters.length; i++) {
    ImageSmallFilter fView=new ImageSmallFilter(this);
    View v=listColors.findViewById(recastIDs[i]);
    int pos=listColors.indexOfChild(v);
    listColors.removeView(v);
    filters[i].setParameter(100);
    fView.setImageFilter(filters[i]);
    fView.setController(this);
    fView.setImageLoader(mImageLoader);
    fView.setId(recastIDs[i]);
    mPanelController.addComponent(mColorsButton,fView);
    listColors.addView(fView,pos);
  }
  int[] overlayIDs={R.id.sharpenButton,R.id.curvesButtonRGB};
  int[] overlayBitmaps={R.drawable.filtershow_button_colors_sharpen,R.drawable.filtershow_button_colors_curve};
  int[] overlayNames={R.string.sharpen,R.string.curvesRGB};
  for (int i=0; i < overlayIDs.length; i++) {
    ImageWithIcon fView=new ImageWithIcon(this);
    View v=listColors.findViewById(overlayIDs[i]);
    int pos=listColors.indexOfChild(v);
    listColors.removeView(v);
    final int sid=overlayNames[i];
    ImageFilterExposure efilter=new ImageFilterExposure(){
{
        mName=getString(sid);
      }
    }
;
    efilter.setParameter(-300);
    Bitmap bitmap=BitmapFactory.decodeResource(getResources(),overlayBitmaps[i]);
    fView.setIcon(bitmap);
    fView.setImageFilter(efilter);
    fView.setController(this);
    fView.setImageLoader(mImageLoader);
    fView.setId(overlayIDs[i]);
    mPanelController.addComponent(mColorsButton,fView);
    listColors.addView(fView,pos);
  }
  mPanelController.addComponent(mColorsButton,findViewById(R.id.curvesButtonRGB));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.sharpenButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vibranceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.contrastButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.saturationButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.wbalanceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.hueButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.exposureButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.shadowRecoveryButton));
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(200);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri,getScreenImageSize());
  }
 else {
    pickImage();
  }
}","The original code lacked an `mImageCrop` view, causing incomplete image manipulation functionality. The fixed code adds `mImageCrop` to the image views list, panel controller, and sets its image loader and master image, ensuring comprehensive image editing capabilities. By including the crop functionality, the code now provides users with a more complete and versatile image editing experience."
38548,"public void showComponent(View view){
  if (mUtilityPanel != null && !mUtilityPanel.selected()) {
    Panel current=mPanels.get(mCurrentPanel);
    ViewPropertyAnimator anim1=current.unselect(-1,VERTICAL_MOVE);
    anim1.start();
    if (mUtilityPanel != null) {
      ViewPropertyAnimator anim2=mUtilityPanel.select();
      anim2.start();
    }
  }
  if (mCurrentImage != null) {
    mCurrentImage.unselect();
  }
switch (view.getId()) {
case R.id.straightenButton:
{
      mCurrentImage=showImageView(R.id.imageStraighten);
      String ename=mCurrentImage.getContext().getString(R.string.straighten);
      mUtilityPanel.setEffectName(ename);
      break;
    }
case R.id.rotateButton:
{
    mCurrentImage=showImageView(R.id.imageRotate);
    String ename=mCurrentImage.getContext().getString(R.string.rotate);
    mUtilityPanel.setEffectName(ename);
    break;
  }
case R.id.flipButton:
{
  mCurrentImage=showImageView(R.id.imageFlip);
  String ename=mCurrentImage.getContext().getString(R.string.flip);
  mUtilityPanel.setEffectName(ename);
  mUtilityPanel.setShowParameter(false);
  break;
}
case R.id.vignetteButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vignette);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.curvesButtonRGB:
{
ImageCurves curves=(ImageCurves)showImageView(R.id.imageCurves);
String ename=curves.getContext().getString(R.string.curvesRGB);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
curves.setUseRed(true);
curves.setUseGreen(true);
curves.setUseBlue(true);
curves.reloadCurve();
mCurrentImage=curves;
break;
}
case R.id.sharpenButton:
{
mCurrentImage=showImageView(R.id.imageZoom).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.sharpen);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.contrastButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.contrast);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.saturationButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.saturation);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.wbalanceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(false);
String ename=mCurrentImage.getContext().getString(R.string.wbalance);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.hueButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.hue);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.exposureButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.exposure);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.vibranceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vibrance);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.shadowRecoveryButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.shadow_recovery);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.redEyeButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.redeye);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.applyEffect:
{
showPanel(mCurrentPanel);
break;
}
}
mCurrentImage.select();
}","public void showComponent(View view){
  if (mUtilityPanel != null && !mUtilityPanel.selected()) {
    Panel current=mPanels.get(mCurrentPanel);
    ViewPropertyAnimator anim1=current.unselect(-1,VERTICAL_MOVE);
    anim1.start();
    if (mUtilityPanel != null) {
      ViewPropertyAnimator anim2=mUtilityPanel.select();
      anim2.start();
    }
  }
  if (mCurrentImage != null) {
    mCurrentImage.unselect();
  }
switch (view.getId()) {
case R.id.straightenButton:
{
      mCurrentImage=showImageView(R.id.imageStraighten);
      String ename=mCurrentImage.getContext().getString(R.string.straighten);
      mUtilityPanel.setEffectName(ename);
      break;
    }
case R.id.cropButton:
{
    mCurrentImage=showImageView(R.id.imageCrop);
    String ename=mCurrentImage.getContext().getString(R.string.crop);
    mUtilityPanel.setEffectName(ename);
    mUtilityPanel.setShowParameter(false);
    break;
  }
case R.id.rotateButton:
{
  mCurrentImage=showImageView(R.id.imageRotate);
  String ename=mCurrentImage.getContext().getString(R.string.rotate);
  mUtilityPanel.setEffectName(ename);
  break;
}
case R.id.flipButton:
{
mCurrentImage=showImageView(R.id.imageFlip);
String ename=mCurrentImage.getContext().getString(R.string.flip);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
break;
}
case R.id.vignetteButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vignette);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.curvesButtonRGB:
{
ImageCurves curves=(ImageCurves)showImageView(R.id.imageCurves);
String ename=curves.getContext().getString(R.string.curvesRGB);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
curves.setUseRed(true);
curves.setUseGreen(true);
curves.setUseBlue(true);
curves.reloadCurve();
mCurrentImage=curves;
break;
}
case R.id.sharpenButton:
{
mCurrentImage=showImageView(R.id.imageZoom).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.sharpen);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.contrastButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.contrast);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.saturationButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.saturation);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.wbalanceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(false);
String ename=mCurrentImage.getContext().getString(R.string.wbalance);
mUtilityPanel.setEffectName(ename);
mUtilityPanel.setShowParameter(false);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.hueButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.hue);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.exposureButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.exposure);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.vibranceButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.vibrance);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.shadowRecoveryButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.shadow_recovery);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.redEyeButton:
{
mCurrentImage=showImageView(R.id.imageShow).setShowControls(true);
String ename=mCurrentImage.getContext().getString(R.string.redeye);
mUtilityPanel.setEffectName(ename);
ensureFilter(""String_Node_Str"");
break;
}
case R.id.applyEffect:
{
showPanel(mCurrentPanel);
break;
}
}
mCurrentImage.select();
}","The original code lacked a case for the crop button, which could lead to unexpected behavior when users attempt to crop an image. The fixed code adds a specific case for R.id.cropButton with appropriate initialization, setting the current image to the crop view and configuring the utility panel accordingly. This enhancement provides a complete and robust implementation for image cropping functionality, ensuring all editing options are properly handled within the component selection method."
38549,"public Matrix buildMatrix(Bitmap bitmap,boolean rotated){
  float dx=bitmap.getWidth() / 2;
  float dy=bitmap.getHeight() / 2;
  if (mGeometry.hasSwitchedWidthHeight()) {
    float temp=dx;
    dx=dy;
    dy=temp;
  }
  Matrix m=mGeometry.buildGeometryMatrix(bitmap.getWidth(),bitmap.getHeight(),1f / mGeometry.getScaleFactor(),dx,dy);
  return m;
}","public Matrix buildMatrix(RectF r){
  float dx=r.width() / 2;
  float dy=r.height() / 2;
  if (mGeometry.hasSwitchedWidthHeight()) {
    float temp=dx;
    dx=dy;
    dy=temp;
  }
  float w=r.left * 2 + r.width();
  float h=r.top * 2 + r.height();
  Matrix m=mGeometry.buildGeometryMatrix(w,h,1f,dx,dy,false);
  return m;
}","The original code incorrectly used bitmap dimensions without considering potential geometric transformations, which could lead to inaccurate matrix calculations. The fixed code introduces a more flexible approach by using a RectF parameter, calculating width and height dynamically, and adding an additional scale parameter to handle geometric transformations more precisely. This modification provides better matrix generation with improved accuracy and adaptability across different geometric scenarios."
38550,"@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Bitmap temp=null;
  float rotation=mGeometry.getRotation();
  boolean rotated=false;
  if (rotation == 0 || rotation % 180 == 0) {
    temp=Bitmap.createBitmap(bitmap.getWidth(),bitmap.getHeight(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(bitmap.getHeight(),bitmap.getWidth(),mConfig);
    rotated=true;
  }
  Matrix drawMatrix=buildMatrix(bitmap,rotated);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","@Override public Bitmap apply(Bitmap bitmap,float scaleFactor,boolean highQuality){
  Rect cropBounds=new Rect(0,0,bitmap.getWidth(),bitmap.getHeight());
  RectF c=mGeometry.getCropBounds();
  if (c != null && c.width() > 0 && c.height() > 0)   c.roundOut(cropBounds);
  Bitmap temp=null;
  if (mGeometry.hasSwitchedWidthHeight()) {
    temp=Bitmap.createBitmap(cropBounds.height(),cropBounds.width(),mConfig);
  }
 else {
    temp=Bitmap.createBitmap(cropBounds.width(),cropBounds.height(),mConfig);
  }
  Matrix drawMatrix=buildMatrix(c);
  Canvas canvas=new Canvas(temp);
  canvas.drawBitmap(bitmap,drawMatrix,new Paint());
  return temp;
}","The original code incorrectly assumed a simple bitmap transformation without considering crop boundaries, potentially leading to incorrect bitmap sizing and transformation. The fixed code introduces crop bounds handling, checks for width/height switching, and uses `mGeometry.getCropBounds()` to precisely define the transformation area. This approach ensures more accurate bitmap creation, preserves intended geometric transformations, and provides a more robust method for bitmap manipulation."
38551,"public Matrix buildGeometryMatrix(float width,float height,float scaling,float dx,float dy){
  float dx0=width / 2;
  float dy0=height / 2;
  Matrix m=getFlipMatrix(width,height);
  m.postTranslate(-dx0,-dy0);
  float rot=mRotation % 360;
  if (rot < 0)   rot+=360;
  m.postRotate(rot + mStraightenRotation);
  m.postScale(scaling,scaling);
  m.postTranslate(dx,dy);
  return m;
}","public Matrix buildGeometryMatrix(float width,float height,float scaling,float dx,float dy,boolean onlyRotate){
  float rot=mRotation;
  if (!onlyRotate) {
    rot+=mStraightenRotation;
  }
  return buildGeometryMatrix(width,height,scaling,dx,dy,rot);
}","The original code lacks flexibility in handling rotation, always applying both mRotation and mStraightenRotation without an option to control this behavior. The fixed code introduces an `onlyRotate` parameter that allows selective rotation application, enabling more precise matrix transformations by conditionally adding mStraightenRotation. This modification provides greater control over geometric transformations, making the method more adaptable to different use cases while maintaining the core matrix building logic."
38552,"public Matrix buildGeometryUIMatrix(float scaling,float dx,float dy){
  float w=mPhotoBounds.width();
  float h=mPhotoBounds.height();
  return buildGeometryMatrix(w,h,scaling,dx,dy);
}","public Matrix buildGeometryUIMatrix(float scaling,float dx,float dy){
  float w=mPhotoBounds.width();
  float h=mPhotoBounds.height();
  return buildGeometryMatrix(w,h,scaling,dx,dy,false);
}","The original code omits a required parameter in the `buildGeometryMatrix` method call, causing potential runtime errors or incorrect matrix generation. The fixed code adds a missing boolean parameter (set to `false`), which likely controls a specific transformation behavior in the matrix creation process. By explicitly passing this parameter, the code ensures consistent and predictable matrix generation, preventing potential unexpected rendering or transformation issues."
38553,"public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    Vector<ImageFilter> fl=mFilters;
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=fl.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          fl.remove(i);
        }
      }
 else       if (type == ImageFilter.TYPE_FX) {
        fl.remove(i);
        fl.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=mFilters.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          mFilters.remove(i);
          continue;
        }
      }
      if (type == ImageFilter.TYPE_FX) {
        mFilters.remove(i);
        mFilters.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    if (!found) {
      mFilters.add(filter);
      setHistoryName(filter.getName());
    }
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","The original code had potential issues with modifying the list while iterating, using a separate Vector reference that could lead to concurrent modification errors and incorrect filter replacement. The fixed code directly modifies mFilters, adds a check to prevent unnecessary additions, and uses a continue statement to safely handle list modifications during iteration. These changes ensure more robust filter management, preventing potential index out of bounds errors and maintaining the intended filter replacement logic."
38554,"public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    Vector<ImageFilter> fl=mFilters;
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=fl.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          fl.remove(i);
        }
      }
 else       if (type == ImageFilter.TYPE_FX) {
        fl.remove(i);
        fl.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=mFilters.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          mFilters.remove(i);
          continue;
        }
      }
      if (type == ImageFilter.TYPE_FX) {
        mFilters.remove(i);
        mFilters.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    if (!found) {
      mFilters.add(filter);
      setHistoryName(filter.getName());
    }
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","The original code had potential index out of bounds and concurrency issues when modifying the `mFilters` vector during iteration, which could lead to unexpected behavior when adding or removing filters. The fixed code introduces a `found` flag, uses direct indexing on `mFilters`, adds a conditional check to prevent unnecessary additions, and uses `continue` to safely handle filter removals during iteration. These changes ensure more robust and predictable filter management, preventing potential runtime errors and maintaining the intended filter manipulation logic."
38555,"@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  Log.v(LOGTAG,""String_Node_Str"");
  if (resultCode == RESULT_OK) {
    if (requestCode == SELECT_PICTURE) {
      Uri selectedImageUri=data.getData();
      mImageLoader.loadBitmap(selectedImageUri);
    }
  }
}","@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  Log.v(LOGTAG,""String_Node_Str"");
  if (resultCode == RESULT_OK) {
    if (requestCode == SELECT_PICTURE) {
      Uri selectedImageUri=data.getData();
      mImageLoader.loadBitmap(selectedImageUri,getScreenImageSize());
    }
  }
}","The original code lacks a crucial parameter when calling loadBitmap(), which may cause incomplete or incorrect image loading. The fixed code adds getScreenImageSize() as a second parameter, providing the necessary image dimensions for proper scaling and rendering. This enhancement ensures more accurate and efficient bitmap loading, optimizing memory usage and display quality for the selected image."
38556,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageCrop.setImageLoader(mImageLoader);
  mImageCrop.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vignetteButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.curvesButtonRGB));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.sharpenButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vibranceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.contrastButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.saturationButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.wbalanceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.hueButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.exposureButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.shadowRecoveryButton));
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(200);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri);
  }
 else {
    pickImage();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageCrop.setImageLoader(mImageLoader);
  mImageCrop.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vignetteButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.curvesButtonRGB));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.sharpenButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vibranceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.contrastButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.saturationButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.wbalanceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.hueButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.exposureButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.shadowRecoveryButton));
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(200);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri,getScreenImageSize());
  }
 else {
    pickImage();
  }
}","The original code lacks a crucial parameter when loading the bitmap, potentially causing incorrect image sizing or loading failures. In the fixed code, `loadBitmap()` is modified to include `getScreenImageSize()`, which ensures the image is loaded with appropriate dimensions for the device screen. This enhancement improves image rendering efficiency and prevents potential out-of-memory errors by scaling the bitmap correctly during initial loading."
38557,"public void loadBitmap(Uri uri){
  mUri=uri;
  mOrientation=getOrientation(uri);
  mOriginalBitmapSmall=loadScaledBitmap(uri,160);
  mOriginalBitmapLarge=loadScaledBitmap(uri,320);
  updateBitmaps();
}","public void loadBitmap(Uri uri,int size){
  mUri=uri;
  mOrientation=getOrientation(uri);
  mOriginalBitmapSmall=loadScaledBitmap(uri,160);
  mOriginalBitmapLarge=loadScaledBitmap(uri,size);
  updateBitmaps();
}","The original code hardcoded the large bitmap size to 320, limiting flexibility in bitmap scaling. The fixed code introduces a new parameter `size` allowing dynamic specification of the large bitmap dimensions during method invocation. This modification provides greater adaptability, enabling developers to load bitmaps at different sizes without modifying the method implementation, thus enhancing the function's reusability and versatility."
38558,"public ImageFilterVignette(){
  mName=""String_Node_Str"";
}","public ImageFilterVignette(){
  setFilterType(TYPE_VIGNETTE);
  mName=""String_Node_Str"";
}","The original code lacks setting the filter type for the ImageFilterVignette, which is crucial for proper initialization of the filter's functionality. The fixed code adds `setFilterType(TYPE_VIGNETTE)`, explicitly defining the specific vignette filter type during constructor execution. This correction ensures the filter is correctly configured, enabling proper image processing and preventing potential runtime errors related to undefined filter behavior."
38559,"public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    Vector<ImageFilter> fl=mFilters;
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=fl.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          fl.remove(i);
        }
      }
 else       if (type == ImageFilter.TYPE_FX) {
        fl.remove(i);
        fl.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=mFilters.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          mFilters.remove(i);
          continue;
        }
      }
      if (type == ImageFilter.TYPE_FX) {
        mFilters.remove(i);
        mFilters.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    if (!found) {
      mFilters.add(filter);
      setHistoryName(filter.getName());
    }
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","The original code had potential index out-of-bounds and concurrent modification issues when removing filters during iteration, which could lead to unexpected behavior. The fixed code introduces a more robust approach by using a continue statement, checking for found status, and adding a separate condition to handle cases where no existing FX filter is found. This modification ensures safer filter manipulation, prevents potential runtime errors, and maintains the intended logic of replacing or adding filters more reliably."
38560,"@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  Log.v(LOGTAG,""String_Node_Str"");
  if (resultCode == RESULT_OK) {
    if (requestCode == SELECT_PICTURE) {
      Uri selectedImageUri=data.getData();
      mImageLoader.loadBitmap(selectedImageUri);
    }
  }
}","@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  Log.v(LOGTAG,""String_Node_Str"");
  if (resultCode == RESULT_OK) {
    if (requestCode == SELECT_PICTURE) {
      Uri selectedImageUri=data.getData();
      mImageLoader.loadBitmap(selectedImageUri,getScreenImageSize());
    }
  }
}","The original code lacks a crucial parameter when calling loadBitmap(), which may cause incomplete or incorrect image loading. The fixed code adds getScreenImageSize() as a second parameter, providing the necessary dimensions for proper bitmap scaling and memory optimization. This modification ensures more efficient and accurate image rendering by allowing the image loader to adapt the bitmap to the specific screen size."
38561,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageCrop.setImageLoader(mImageLoader);
  mImageCrop.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vignetteButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.curvesButtonRGB));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.sharpenButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vibranceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.contrastButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.saturationButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.wbalanceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.hueButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.exposureButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.shadowRecoveryButton));
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(200);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri);
  }
 else {
    pickImage();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageCrop.setImageLoader(mImageLoader);
  mImageCrop.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vignetteButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.curvesButtonRGB));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.sharpenButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vibranceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.contrastButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.saturationButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.wbalanceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.hueButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.exposureButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.shadowRecoveryButton));
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(200);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri,getScreenImageSize());
  }
 else {
    pickImage();
  }
}","The original code lacks a critical parameter when loading a bitmap, potentially causing incomplete or incorrect image loading. In the fixed code, `mImageLoader.loadBitmap(uri,getScreenImageSize())` adds the screen image size parameter, ensuring proper bitmap scaling and memory-efficient image rendering. This modification improves image loading performance and prevents potential out-of-memory errors by dynamically adapting the bitmap to the screen dimensions."
38562,"public void loadBitmap(Uri uri){
  mUri=uri;
  mOrientation=getOrientation(uri);
  mOriginalBitmapSmall=loadScaledBitmap(uri,160);
  mOriginalBitmapLarge=loadScaledBitmap(uri,320);
  updateBitmaps();
}","public void loadBitmap(Uri uri,int size){
  mUri=uri;
  mOrientation=getOrientation(uri);
  mOriginalBitmapSmall=loadScaledBitmap(uri,160);
  mOriginalBitmapLarge=loadScaledBitmap(uri,size);
  updateBitmaps();
}","The original code hardcoded the large bitmap size at 320, limiting flexibility in bitmap scaling. The fixed code introduces a new parameter `size` that allows dynamic specification of the large bitmap's dimensions during method invocation. This modification provides greater adaptability, enabling developers to load bitmaps at different scales without modifying the method's implementation, thus enhancing the function's reusability and configurability."
38563,"public ImageFilterVignette(){
  mName=""String_Node_Str"";
}","public ImageFilterVignette(){
  setFilterType(TYPE_VIGNETTE);
  mName=""String_Node_Str"";
}","The original code lacks a critical initialization step for setting the filter type in the constructor of the ImageFilterVignette class. The fixed code adds `setFilterType(TYPE_VIGNETTE)`, which properly configures the filter's type during object creation. This ensures the vignette filter is correctly configured from the moment of instantiation, preventing potential runtime errors and improving the class's initialization process."
38564,"public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    Vector<ImageFilter> fl=mFilters;
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=fl.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          fl.remove(i);
        }
      }
 else       if (type == ImageFilter.TYPE_FX) {
        fl.remove(i);
        fl.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=mFilters.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          mFilters.remove(i);
          continue;
        }
      }
      if (type == ImageFilter.TYPE_FX) {
        mFilters.remove(i);
        mFilters.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    if (!found) {
      mFilters.add(filter);
      setHistoryName(filter.getName());
    }
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","The original code had potential issues with modifying the `mFilters` vector during iteration, leading to unpredictable behavior and possible index out-of-bounds errors. The fixed code introduces a safer iteration approach by using `continue` when removing elements and adding a check to prevent duplicate filter additions. These modifications ensure more reliable filter management, preventing concurrent modification problems and maintaining the intended logic of filter replacement and addition."
38565,"public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    Vector<ImageFilter> fl=mFilters;
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=fl.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          fl.remove(i);
        }
      }
 else       if (type == ImageFilter.TYPE_FX) {
        fl.remove(i);
        fl.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=mFilters.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          mFilters.remove(i);
          continue;
        }
      }
      if (type == ImageFilter.TYPE_FX) {
        mFilters.remove(i);
        mFilters.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    if (!found) {
      mFilters.add(filter);
      setHistoryName(filter.getName());
    }
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","The original code had potential index manipulation issues when modifying the `mFilters` vector during iteration, which could lead to unpredictable behavior and potential concurrent modification errors. The fixed code introduces a more robust approach by carefully managing filter removal, using `continue` to skip unnecessary iterations, and adding a check to add the filter only if no existing FX filter was found. This approach ensures safer vector manipulation, prevents potential index out-of-bounds errors, and maintains the intended filter management logic more reliably."
38566,"@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  Log.v(LOGTAG,""String_Node_Str"");
  if (resultCode == RESULT_OK) {
    if (requestCode == SELECT_PICTURE) {
      Uri selectedImageUri=data.getData();
      mImageLoader.loadBitmap(selectedImageUri);
    }
  }
}","@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  Log.v(LOGTAG,""String_Node_Str"");
  if (resultCode == RESULT_OK) {
    if (requestCode == SELECT_PICTURE) {
      Uri selectedImageUri=data.getData();
      mImageLoader.loadBitmap(selectedImageUri,getScreenImageSize());
    }
  }
}","The original code lacks a crucial parameter when calling `loadBitmap()`, which may cause incomplete or incorrect image loading. The fixed code adds `getScreenImageSize()` as a second parameter, providing the necessary image dimensions for proper scaling and rendering. This enhancement ensures more accurate and efficient image loading by specifying the target screen size during bitmap retrieval."
38567,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageCrop.setImageLoader(mImageLoader);
  mImageCrop.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vignetteButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.curvesButtonRGB));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.sharpenButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vibranceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.contrastButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.saturationButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.wbalanceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.hueButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.exposureButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.shadowRecoveryButton));
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(200);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri);
  }
 else {
    pickImage();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ImageFilterRS.setRenderScriptContext(this);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageZoom=(ImageZoom)findViewById(R.id.imageZoom);
  mImageCrop=(ImageCrop)findViewById(R.id.imageCrop);
  mImageRotate=(ImageRotate)findViewById(R.id.imageRotate);
  mImageFlip=(ImageFlip)findViewById(R.id.imageFlip);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mImageViews.add(mImageZoom);
  mImageViews.add(mImageCrop);
  mImageViews.add(mImageRotate);
  mImageViews.add(mImageFlip);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.geometryList);
  mListFilterButtons=findViewById(R.id.filterButtonsList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListFilterButtons);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  mImageZoom.setImageLoader(mImageLoader);
  mImageZoom.setMaster(mImageShow);
  mImageCrop.setImageLoader(mImageLoader);
  mImageCrop.setMaster(mImageShow);
  mImageRotate.setImageLoader(mImageLoader);
  mImageRotate.setMaster(mImageShow);
  mImageFlip.setImageLoader(mImageLoader);
  mImageFlip.setMaster(mImageShow);
  mPanelController.addImageView(findViewById(R.id.imageShow));
  mPanelController.addImageView(findViewById(R.id.imageCurves));
  mPanelController.addImageView(findViewById(R.id.imageBorder));
  mPanelController.addImageView(findViewById(R.id.imageStraighten));
  mPanelController.addImageView(findViewById(R.id.imageCrop));
  mPanelController.addImageView(findViewById(R.id.imageRotate));
  mPanelController.addImageView(findViewById(R.id.imageFlip));
  mPanelController.addImageView(findViewById(R.id.imageZoom));
  mPanelController.addPanel(mFxButton,mListFx,0);
  mPanelController.addPanel(mBorderButton,mListBorders,1);
  mPanelController.addPanel(mGeometryButton,mListGeometry,2);
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.straightenButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.cropButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.rotateButton));
  mPanelController.addComponent(mGeometryButton,findViewById(R.id.flipButton));
  mPanelController.addPanel(mColorsButton,mListColors,3);
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vignetteButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.curvesButtonRGB));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.sharpenButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.vibranceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.contrastButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.saturationButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.wbalanceButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.hueButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.exposureButton));
  mPanelController.addComponent(mColorsButton,findViewById(R.id.shadowRecoveryButton));
  mPanelController.addView(findViewById(R.id.applyEffect));
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  SeekBar seekBar=(SeekBar)findViewById(R.id.filterSeekBar);
  seekBar.setMax(200);
  mImageShow.setSeekBar(seekBar);
  mImageZoom.setSeekBar(seekBar);
  mPanelController.setRowPanel(findViewById(R.id.secondRowPanel));
  mPanelController.setUtilityPanel(this,findViewById(R.id.filterButtonsList),findViewById(R.id.applyEffect));
  mPanelController.setMasterImage(mImageShow);
  mPanelController.setCurrentPanel(mFxButton);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri,getScreenImageSize());
  }
 else {
    pickImage();
  }
}","The original code lacked a crucial parameter when loading the bitmap, potentially causing incomplete or incorrect image loading. The fixed code adds `getScreenImageSize()` as a parameter to `mImageLoader.loadBitmap(uri)`, ensuring the image is loaded with appropriate screen dimensions. This modification improves image rendering efficiency and prevents potential scaling or memory allocation issues during bitmap loading."
38568,"public void loadBitmap(Uri uri){
  mUri=uri;
  mOrientation=getOrientation(uri);
  mOriginalBitmapSmall=loadScaledBitmap(uri,160);
  mOriginalBitmapLarge=loadScaledBitmap(uri,320);
  updateBitmaps();
}","public void loadBitmap(Uri uri,int size){
  mUri=uri;
  mOrientation=getOrientation(uri);
  mOriginalBitmapSmall=loadScaledBitmap(uri,160);
  mOriginalBitmapLarge=loadScaledBitmap(uri,size);
  updateBitmaps();
}","The original code hardcoded the large bitmap size to 320, limiting flexibility for different image scaling requirements. The fixed code introduces a new size parameter, allowing dynamic scaling of the large bitmap based on the caller's needs. This modification provides greater adaptability, enabling more versatile bitmap loading with configurable large image dimensions."
38569,"public ImageFilterVignette(){
  mName=""String_Node_Str"";
}","public ImageFilterVignette(){
  setFilterType(TYPE_VIGNETTE);
  mName=""String_Node_Str"";
}","The original code lacks initialization of the filter type, leaving the ImageFilterVignette object in an undefined state. The fixed code adds `setFilterType(TYPE_VIGNETTE)`, explicitly setting the correct filter type for the vignette effect. This ensures the filter is properly configured and ready for use, preventing potential runtime errors and improving the overall reliability of the image processing component."
38570,"public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    Vector<ImageFilter> fl=mFilters;
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=fl.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          fl.remove(i);
        }
      }
 else       if (type == ImageFilter.TYPE_FX) {
        fl.remove(i);
        fl.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","public void add(ImageFilter filter){
  if (filter.getFilterType() == ImageFilter.TYPE_BORDER) {
    setHistoryName(""String_Node_Str"");
    setBorder(filter);
  }
 else   if (filter.getFilterType() == ImageFilter.TYPE_FX) {
    boolean found=false;
    for (int i=0; i < mFilters.size(); i++) {
      byte type=mFilters.get(i).getFilterType();
      if (found) {
        if (type != ImageFilter.TYPE_VIGNETTE) {
          mFilters.remove(i);
          continue;
        }
      }
      if (type == ImageFilter.TYPE_FX) {
        mFilters.remove(i);
        mFilters.add(i,filter);
        setHistoryName(filter.getName());
        found=true;
      }
    }
    if (!found) {
      mFilters.add(filter);
      setHistoryName(filter.getName());
    }
  }
 else {
    mFilters.add(filter);
    setHistoryName(filter.getName());
  }
}","The original code had potential concurrent modification issues and incorrect filter replacement logic when handling FX-type filters. The fixed code introduces a more robust approach by directly modifying `mFilters`, adding a check to prevent duplicate additions, and using `continue` to safely remove elements during iteration. These changes ensure proper filter management, prevent potential runtime errors, and maintain the intended filter replacement behavior more reliably."
38571,"@Override public void onPhotoChanged(int index,Path item){
  int oldIndex=mCurrentIndex;
  mCurrentIndex=index;
  if (mAppBridge != null) {
    if (mCurrentIndex > 0) {
      mSkipUpdateCurrentPhoto=false;
    }
    if (oldIndex == 0 && mCurrentIndex > 0 && !mPhotoView.getFilmMode()) {
      mPhotoView.setFilmMode(true);
    }
 else     if (oldIndex == 2 && mCurrentIndex == 1) {
      mCameraSwitchCutoff=SystemClock.uptimeMillis() + CAMERA_SWITCH_CUTOFF_THRESHOLD_MS;
      mPhotoView.stopScrolling();
    }
 else     if (oldIndex == 1 && mCurrentIndex == 0) {
      mPhotoView.setWantPictureCenterCallbacks(true);
      mSkipUpdateCurrentPhoto=true;
    }
  }
  if (!mSkipUpdateCurrentPhoto) {
    if (item != null) {
      MediaItem photo=mModel.getMediaItem(0);
      if (photo != null)       updateCurrentPhoto(photo);
    }
    updateBars();
  }
  refreshHidingMessage();
}","@Override public void onPhotoChanged(int index,Path item){
  int oldIndex=mCurrentIndex;
  mCurrentIndex=index;
  if (mAppBridge != null) {
    if (mCurrentIndex > 0) {
      mSkipUpdateCurrentPhoto=false;
    }
    if (oldIndex == 0 && mCurrentIndex > 0 && !mPhotoView.getFilmMode()) {
      mPhotoView.setFilmMode(true);
    }
 else     if (oldIndex == 2 && mCurrentIndex == 1) {
      mCameraSwitchCutoff=SystemClock.uptimeMillis() + CAMERA_SWITCH_CUTOFF_THRESHOLD_MS;
      mPhotoView.stopScrolling();
    }
 else     if (oldIndex >= 1 && mCurrentIndex == 0) {
      mPhotoView.setWantPictureCenterCallbacks(true);
      mSkipUpdateCurrentPhoto=true;
    }
  }
  if (!mSkipUpdateCurrentPhoto) {
    if (item != null) {
      MediaItem photo=mModel.getMediaItem(0);
      if (photo != null)       updateCurrentPhoto(photo);
    }
    updateBars();
  }
  refreshHidingMessage();
}","The original code incorrectly handled the transition from index 1 to 0, only allowing the specific case where the old index was exactly 1. This limited the flexibility of photo navigation and potentially missed valid state transitions. The fixed code changes the condition from `oldIndex == 1` to `oldIndex >= 1`, enabling a more robust handling of index changes and ensuring proper photo view callbacks across different navigation scenarios. By broadening the transition condition, the code now supports more flexible and comprehensive photo view state management."
38572,"@Override public void onCreate(Bundle data,Bundle restoreState){
  super.onCreate(data,restoreState);
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mActivity.getGLRoot().setOrientationSource(mOrientationManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_REFRESH_BOTTOM_CONTROLS:
{
        if (mBottomControls != null)         mBottomControls.refresh();
        break;
      }
case MSG_LOCK_ORIENTATION:
{
      mOrientationManager.lockOrientation();
      break;
    }
case MSG_UNLOCK_ORIENTATION:
{
    mOrientationManager.unlockOrientation();
    break;
  }
case MSG_ON_FULL_SCREEN_CHANGED:
{
  mAppBridge.onFullScreenChanged(message.arg1 == 1);
  break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
case MSG_ON_CAMERA_CENTER:
{
mSkipUpdateCurrentPhoto=false;
boolean updateNeeded=false;
if (!mPhotoView.getFilmMode()) {
lockOrientation();
updateNeeded=true;
}
 else if (SystemClock.uptimeMillis() < mCameraSwitchCutoff && mMediaSet.getMediaItemCount() > 1) {
mPhotoView.switchToImage(1);
}
 else {
mPhotoView.setFilmMode(false);
updateNeeded=true;
}
if (updateNeeded) {
updateBars();
updateCurrentPhoto(mModel.getMediaItem(0));
}
break;
}
case MSG_ON_PICTURE_CENTER:
{
if (mCurrentPhoto != null && (mCurrentPhoto.getSupportedOperations() & MediaObject.SUPPORT_ACTION) != 0) {
mPhotoView.setFilmMode(true);
}
break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
mOriginalSetPathString=mSetPathString;
setupNfcBeamPush();
String itemPathString=data.getString(KEY_MEDIA_ITEM_PATH);
Path itemPath=itemPathString != null ? Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH)) : null;
mTreatBackAsUp=data.getBoolean(KEY_TREAT_BACK_AS_UP,false);
mStartInFilmstrip=data.getBoolean(KEY_START_IN_FILMSTRIP,false);
mInCameraRoll=data.getBoolean(KEY_IN_CAMERA_ROLL,false);
mStartedFromAlbumPage=data.getInt(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE) == MSG_ALBUMPAGE_STARTED;
mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
if (mSetPathString != null) {
mShowSpinner=true;
mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
if (mAppBridge != null) {
mShowBars=false;
mInCameraRoll=true;
mAppBridge.setServer(this);
mOrientationManager.lockOrientation();
int id=SnailSource.newId();
Path screenNailSetPath=SnailSource.getSetPath(id);
Path screenNailItemPath=SnailSource.getItemPath(id);
mScreenNailSet=(SnailAlbum)mActivity.getDataManager().getMediaObject(screenNailSetPath);
mScreenNailItem=(SnailItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
mScreenNailItem.setScreenNail(mAppBridge.attachScreenNail());
if (SecureSource.isSecurePath(mSetPathString)) {
mSecureAlbum=(SecureAlbum)mActivity.getDataManager().getMediaSet(mSetPathString);
mShowSpinner=false;
}
if (data.getBoolean(KEY_SHOW_WHEN_LOCKED,false)) {
mFlags|=FLAG_SHOW_WHEN_LOCKED;
}
if (!mSetPathString.equals(""String_Node_Str"")) {
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
}
if (LightCycleHelper.hasLightCycleCapture(mActivity.getAndroidContext())) {
mSetPathString=LightCycleHelper.wrapGalleryPath(mSetPathString);
}
mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
itemPath=screenNailItemPath;
}
 else if (mInCameraRoll && GalleryUtils.isCameraAvailable(mActivity)) {
mSetPathString=""String_Node_Str"" + FilterSource.FILTER_CAMERA_SHORTCUT + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
mCurrentIndex++;
}
MediaSet originalSet=mActivity.getDataManager().getMediaSet(mSetPathString);
if (mInCameraRoll && originalSet instanceof ComboAlbum) {
((ComboAlbum)originalSet).useNameOfChild(1);
}
mSelectionManager.setSourceMediaSet(originalSet);
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
mMediaSet=(FilterDeleteSet)mActivity.getDataManager().getMediaSet(mSetPathString);
if (mMediaSet == null) {
Log.w(TAG,""String_Node_Str"" + mSetPathString);
}
if (itemPath == null) {
int mediaItemCount=mMediaSet.getMediaItemCount();
if (mediaItemCount > 0) {
if (mCurrentIndex >= mediaItemCount) mCurrentIndex=0;
itemPath=mMediaSet.getMediaItem(mCurrentIndex,1).get(0).getPath();
}
 else {
return;
}
}
PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0,mAppBridge == null ? false : mAppBridge.isPanorama(),mAppBridge == null ? false : mAppBridge.isStaticCamera());
mModel=pda;
mPhotoView.setModel(mModel);
pda.setDataListener(new PhotoDataAdapter.DataListener(){
@Override public void onPhotoChanged(int index,Path item){
int oldIndex=mCurrentIndex;
mCurrentIndex=index;
if (mAppBridge != null) {
if (mCurrentIndex > 0) {
mSkipUpdateCurrentPhoto=false;
}
if (oldIndex == 0 && mCurrentIndex > 0 && !mPhotoView.getFilmMode()) {
mPhotoView.setFilmMode(true);
}
 else if (oldIndex == 2 && mCurrentIndex == 1) {
mCameraSwitchCutoff=SystemClock.uptimeMillis() + CAMERA_SWITCH_CUTOFF_THRESHOLD_MS;
mPhotoView.stopScrolling();
}
 else if (oldIndex == 1 && mCurrentIndex == 0) {
mPhotoView.setWantPictureCenterCallbacks(true);
mSkipUpdateCurrentPhoto=true;
}
}
if (!mSkipUpdateCurrentPhoto) {
if (item != null) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
updateBars();
}
refreshHidingMessage();
}
@Override public void onLoadingFinished(){
if (!mModel.isEmpty()) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
 else if (mIsActive) {
if (mMediaSet.getNumberOfDeletions() == 0) {
mActivity.getStateManager().finishState(PhotoPage.this);
}
}
}
@Override public void onLoadingStarted(){
}
}
);
}
 else {
MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
mPhotoView.setModel(mModel);
updateCurrentPhoto(mediaItem);
mShowSpinner=false;
}
mPhotoView.setFilmMode(mStartInFilmstrip && mMediaSet.getMediaItemCount() > 1);
if (mSecureAlbum == null) {
RelativeLayout galleryRoot=(RelativeLayout)((Activity)mActivity).findViewById(mAppBridge != null ? R.id.content : R.id.gallery_root);
if (galleryRoot != null) {
mBottomControls=new PhotoPageBottomControls(this,mActivity,galleryRoot);
}
}
}","@Override public void onCreate(Bundle data,Bundle restoreState){
  super.onCreate(data,restoreState);
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mActivity.getGLRoot().setOrientationSource(mOrientationManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_REFRESH_BOTTOM_CONTROLS:
{
        if (mBottomControls != null)         mBottomControls.refresh();
        break;
      }
case MSG_LOCK_ORIENTATION:
{
      mOrientationManager.lockOrientation();
      break;
    }
case MSG_UNLOCK_ORIENTATION:
{
    mOrientationManager.unlockOrientation();
    break;
  }
case MSG_ON_FULL_SCREEN_CHANGED:
{
  mAppBridge.onFullScreenChanged(message.arg1 == 1);
  break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
case MSG_ON_CAMERA_CENTER:
{
mSkipUpdateCurrentPhoto=false;
boolean stayedOnCamera=false;
if (!mPhotoView.getFilmMode()) {
stayedOnCamera=true;
}
 else if (SystemClock.uptimeMillis() < mCameraSwitchCutoff && mMediaSet.getMediaItemCount() > 1) {
mPhotoView.switchToImage(1);
}
 else {
mPhotoView.setFilmMode(false);
stayedOnCamera=true;
}
if (stayedOnCamera) {
lockOrientation();
updateBars();
updateCurrentPhoto(mModel.getMediaItem(0));
}
break;
}
case MSG_ON_PICTURE_CENTER:
{
if (mCurrentPhoto != null && (mCurrentPhoto.getSupportedOperations() & MediaObject.SUPPORT_ACTION) != 0) {
mPhotoView.setFilmMode(true);
}
break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
mOriginalSetPathString=mSetPathString;
setupNfcBeamPush();
String itemPathString=data.getString(KEY_MEDIA_ITEM_PATH);
Path itemPath=itemPathString != null ? Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH)) : null;
mTreatBackAsUp=data.getBoolean(KEY_TREAT_BACK_AS_UP,false);
mStartInFilmstrip=data.getBoolean(KEY_START_IN_FILMSTRIP,false);
mInCameraRoll=data.getBoolean(KEY_IN_CAMERA_ROLL,false);
mStartedFromAlbumPage=data.getInt(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE) == MSG_ALBUMPAGE_STARTED;
mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
if (mSetPathString != null) {
mShowSpinner=true;
mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
if (mAppBridge != null) {
mShowBars=false;
mInCameraRoll=true;
mAppBridge.setServer(this);
mOrientationManager.lockOrientation();
int id=SnailSource.newId();
Path screenNailSetPath=SnailSource.getSetPath(id);
Path screenNailItemPath=SnailSource.getItemPath(id);
mScreenNailSet=(SnailAlbum)mActivity.getDataManager().getMediaObject(screenNailSetPath);
mScreenNailItem=(SnailItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
mScreenNailItem.setScreenNail(mAppBridge.attachScreenNail());
if (SecureSource.isSecurePath(mSetPathString)) {
mSecureAlbum=(SecureAlbum)mActivity.getDataManager().getMediaSet(mSetPathString);
mShowSpinner=false;
}
if (data.getBoolean(KEY_SHOW_WHEN_LOCKED,false)) {
mFlags|=FLAG_SHOW_WHEN_LOCKED;
}
if (!mSetPathString.equals(""String_Node_Str"")) {
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
}
if (LightCycleHelper.hasLightCycleCapture(mActivity.getAndroidContext())) {
mSetPathString=LightCycleHelper.wrapGalleryPath(mSetPathString);
}
mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
itemPath=screenNailItemPath;
}
 else if (mInCameraRoll && GalleryUtils.isCameraAvailable(mActivity)) {
mSetPathString=""String_Node_Str"" + FilterSource.FILTER_CAMERA_SHORTCUT + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
mCurrentIndex++;
}
MediaSet originalSet=mActivity.getDataManager().getMediaSet(mSetPathString);
if (mInCameraRoll && originalSet instanceof ComboAlbum) {
((ComboAlbum)originalSet).useNameOfChild(1);
}
mSelectionManager.setSourceMediaSet(originalSet);
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
mMediaSet=(FilterDeleteSet)mActivity.getDataManager().getMediaSet(mSetPathString);
if (mMediaSet == null) {
Log.w(TAG,""String_Node_Str"" + mSetPathString);
}
if (itemPath == null) {
int mediaItemCount=mMediaSet.getMediaItemCount();
if (mediaItemCount > 0) {
if (mCurrentIndex >= mediaItemCount) mCurrentIndex=0;
itemPath=mMediaSet.getMediaItem(mCurrentIndex,1).get(0).getPath();
}
 else {
return;
}
}
PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0,mAppBridge == null ? false : mAppBridge.isPanorama(),mAppBridge == null ? false : mAppBridge.isStaticCamera());
mModel=pda;
mPhotoView.setModel(mModel);
pda.setDataListener(new PhotoDataAdapter.DataListener(){
@Override public void onPhotoChanged(int index,Path item){
int oldIndex=mCurrentIndex;
mCurrentIndex=index;
if (mAppBridge != null) {
if (mCurrentIndex > 0) {
mSkipUpdateCurrentPhoto=false;
}
if (oldIndex == 0 && mCurrentIndex > 0 && !mPhotoView.getFilmMode()) {
mPhotoView.setFilmMode(true);
}
 else if (oldIndex == 2 && mCurrentIndex == 1) {
mCameraSwitchCutoff=SystemClock.uptimeMillis() + CAMERA_SWITCH_CUTOFF_THRESHOLD_MS;
mPhotoView.stopScrolling();
}
 else if (oldIndex >= 1 && mCurrentIndex == 0) {
mPhotoView.setWantPictureCenterCallbacks(true);
mSkipUpdateCurrentPhoto=true;
}
}
if (!mSkipUpdateCurrentPhoto) {
if (item != null) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
updateBars();
}
refreshHidingMessage();
}
@Override public void onLoadingFinished(){
if (!mModel.isEmpty()) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
 else if (mIsActive) {
if (mMediaSet.getNumberOfDeletions() == 0) {
mActivity.getStateManager().finishState(PhotoPage.this);
}
}
}
@Override public void onLoadingStarted(){
}
}
);
}
 else {
MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
mPhotoView.setModel(mModel);
updateCurrentPhoto(mediaItem);
mShowSpinner=false;
}
mPhotoView.setFilmMode(mStartInFilmstrip && mMediaSet.getMediaItemCount() > 1);
if (mSecureAlbum == null) {
RelativeLayout galleryRoot=(RelativeLayout)((Activity)mActivity).findViewById(mAppBridge != null ? R.id.content : R.id.gallery_root);
if (galleryRoot != null) {
mBottomControls=new PhotoPageBottomControls(this,mActivity,galleryRoot);
}
}
}","The original code had a problematic logic flow in the MSG_ON_CAMERA_CENTER handler, with redundant conditional checks and unclear variable usage. The fixed code introduces a clearer boolean `stayedOnCamera` to consolidate the camera-related logic and simplify the conditional branching. This refactoring improves code readability, reduces complexity, and makes the camera mode transition more explicit and easier to understand."
38573,"@Override public void handleMessage(Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
      hideBars();
      break;
    }
case MSG_REFRESH_BOTTOM_CONTROLS:
{
    if (mBottomControls != null)     mBottomControls.refresh();
    break;
  }
case MSG_LOCK_ORIENTATION:
{
  mOrientationManager.lockOrientation();
  break;
}
case MSG_UNLOCK_ORIENTATION:
{
mOrientationManager.unlockOrientation();
break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
case MSG_ON_CAMERA_CENTER:
{
mSkipUpdateCurrentPhoto=false;
boolean updateNeeded=false;
if (!mPhotoView.getFilmMode()) {
lockOrientation();
updateNeeded=true;
}
 else if (SystemClock.uptimeMillis() < mCameraSwitchCutoff && mMediaSet.getMediaItemCount() > 1) {
mPhotoView.switchToImage(1);
}
 else {
mPhotoView.setFilmMode(false);
updateNeeded=true;
}
if (updateNeeded) {
updateBars();
updateCurrentPhoto(mModel.getMediaItem(0));
}
break;
}
case MSG_ON_PICTURE_CENTER:
{
if (mCurrentPhoto != null && (mCurrentPhoto.getSupportedOperations() & MediaObject.SUPPORT_ACTION) != 0) {
mPhotoView.setFilmMode(true);
}
break;
}
default :
throw new AssertionError(message.what);
}
}","@Override public void handleMessage(Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
      hideBars();
      break;
    }
case MSG_REFRESH_BOTTOM_CONTROLS:
{
    if (mBottomControls != null)     mBottomControls.refresh();
    break;
  }
case MSG_LOCK_ORIENTATION:
{
  mOrientationManager.lockOrientation();
  break;
}
case MSG_UNLOCK_ORIENTATION:
{
mOrientationManager.unlockOrientation();
break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
case MSG_ON_CAMERA_CENTER:
{
mSkipUpdateCurrentPhoto=false;
boolean stayedOnCamera=false;
if (!mPhotoView.getFilmMode()) {
stayedOnCamera=true;
}
 else if (SystemClock.uptimeMillis() < mCameraSwitchCutoff && mMediaSet.getMediaItemCount() > 1) {
mPhotoView.switchToImage(1);
}
 else {
mPhotoView.setFilmMode(false);
stayedOnCamera=true;
}
if (stayedOnCamera) {
lockOrientation();
updateBars();
updateCurrentPhoto(mModel.getMediaItem(0));
}
break;
}
case MSG_ON_PICTURE_CENTER:
{
if (mCurrentPhoto != null && (mCurrentPhoto.getSupportedOperations() & MediaObject.SUPPORT_ACTION) != 0) {
mPhotoView.setFilmMode(true);
}
break;
}
default :
throw new AssertionError(message.what);
}
}","The original code had a logic error in the MSG_ON_CAMERA_CENTER case, where orientation locking and updates were performed unconditionally. The fixed code introduces a `stayedOnCamera` boolean to track camera-related state, ensuring that orientation is locked and updates are triggered only when necessary. This refactoring improves code clarity and prevents unnecessary method calls, making the message handling more precise and efficient."
38574,"@Override public void onPhotoChanged(int index,Path item){
  int oldIndex=mCurrentIndex;
  mCurrentIndex=index;
  if (mAppBridge != null) {
    if (mCurrentIndex > 0) {
      mSkipUpdateCurrentPhoto=false;
    }
    if (oldIndex == 0 && mCurrentIndex > 0 && !mPhotoView.getFilmMode()) {
      mPhotoView.setFilmMode(true);
    }
 else     if (oldIndex == 2 && mCurrentIndex == 1) {
      mCameraSwitchCutoff=SystemClock.uptimeMillis() + CAMERA_SWITCH_CUTOFF_THRESHOLD_MS;
      mPhotoView.stopScrolling();
    }
 else     if (oldIndex == 1 && mCurrentIndex == 0) {
      mPhotoView.setWantPictureCenterCallbacks(true);
      mSkipUpdateCurrentPhoto=true;
    }
  }
  if (!mSkipUpdateCurrentPhoto) {
    if (item != null) {
      MediaItem photo=mModel.getMediaItem(0);
      if (photo != null)       updateCurrentPhoto(photo);
    }
    updateBars();
  }
  refreshHidingMessage();
}","@Override public void onPhotoChanged(int index,Path item){
  int oldIndex=mCurrentIndex;
  mCurrentIndex=index;
  if (mAppBridge != null) {
    if (mCurrentIndex > 0) {
      mSkipUpdateCurrentPhoto=false;
    }
    if (oldIndex == 0 && mCurrentIndex > 0 && !mPhotoView.getFilmMode()) {
      mPhotoView.setFilmMode(true);
    }
 else     if (oldIndex == 2 && mCurrentIndex == 1) {
      mCameraSwitchCutoff=SystemClock.uptimeMillis() + CAMERA_SWITCH_CUTOFF_THRESHOLD_MS;
      mPhotoView.stopScrolling();
    }
 else     if (oldIndex >= 1 && mCurrentIndex == 0) {
      mPhotoView.setWantPictureCenterCallbacks(true);
      mSkipUpdateCurrentPhoto=true;
    }
  }
  if (!mSkipUpdateCurrentPhoto) {
    if (item != null) {
      MediaItem photo=mModel.getMediaItem(0);
      if (photo != null)       updateCurrentPhoto(photo);
    }
    updateBars();
  }
  refreshHidingMessage();
}","The original code had a restrictive condition `oldIndex == 1` when checking for transitioning back to index 0, which could miss other potential previous indices. The fixed code changes this to `oldIndex >= 1`, allowing the specific logic to trigger for any index greater than or equal to 1 when returning to the first photo. This modification provides more flexibility in handling photo navigation scenarios, ensuring consistent behavior across different index transitions and preventing potential edge case failures."
38575,"@Override public void onCreate(Bundle data,Bundle restoreState){
  super.onCreate(data,restoreState);
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mActivity.getGLRoot().setOrientationSource(mOrientationManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_REFRESH_BOTTOM_CONTROLS:
{
        if (mBottomControls != null)         mBottomControls.refresh();
        break;
      }
case MSG_LOCK_ORIENTATION:
{
      mOrientationManager.lockOrientation();
      break;
    }
case MSG_UNLOCK_ORIENTATION:
{
    mOrientationManager.unlockOrientation();
    break;
  }
case MSG_ON_FULL_SCREEN_CHANGED:
{
  mAppBridge.onFullScreenChanged(message.arg1 == 1);
  break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
case MSG_ON_CAMERA_CENTER:
{
mSkipUpdateCurrentPhoto=false;
boolean updateNeeded=false;
if (!mPhotoView.getFilmMode()) {
lockOrientation();
updateNeeded=true;
}
 else if (SystemClock.uptimeMillis() < mCameraSwitchCutoff && mMediaSet.getMediaItemCount() > 1) {
mPhotoView.switchToImage(1);
}
 else {
mPhotoView.setFilmMode(false);
updateNeeded=true;
}
if (updateNeeded) {
updateBars();
updateCurrentPhoto(mModel.getMediaItem(0));
}
break;
}
case MSG_ON_PICTURE_CENTER:
{
if (mCurrentPhoto != null && (mCurrentPhoto.getSupportedOperations() & MediaObject.SUPPORT_ACTION) != 0) {
mPhotoView.setFilmMode(true);
}
break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
mOriginalSetPathString=mSetPathString;
setupNfcBeamPush();
String itemPathString=data.getString(KEY_MEDIA_ITEM_PATH);
Path itemPath=itemPathString != null ? Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH)) : null;
mTreatBackAsUp=data.getBoolean(KEY_TREAT_BACK_AS_UP,false);
mStartInFilmstrip=data.getBoolean(KEY_START_IN_FILMSTRIP,false);
mInCameraRoll=data.getBoolean(KEY_IN_CAMERA_ROLL,false);
mStartedFromAlbumPage=data.getInt(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE) == MSG_ALBUMPAGE_STARTED;
mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
if (mSetPathString != null) {
mShowSpinner=true;
mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
if (mAppBridge != null) {
mShowBars=false;
mInCameraRoll=true;
mAppBridge.setServer(this);
mOrientationManager.lockOrientation();
int id=SnailSource.newId();
Path screenNailSetPath=SnailSource.getSetPath(id);
Path screenNailItemPath=SnailSource.getItemPath(id);
mScreenNailSet=(SnailAlbum)mActivity.getDataManager().getMediaObject(screenNailSetPath);
mScreenNailItem=(SnailItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
mScreenNailItem.setScreenNail(mAppBridge.attachScreenNail());
if (SecureSource.isSecurePath(mSetPathString)) {
mSecureAlbum=(SecureAlbum)mActivity.getDataManager().getMediaSet(mSetPathString);
mShowSpinner=false;
}
if (data.getBoolean(KEY_SHOW_WHEN_LOCKED,false)) {
mFlags|=FLAG_SHOW_WHEN_LOCKED;
}
if (!mSetPathString.equals(""String_Node_Str"")) {
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
}
if (LightCycleHelper.hasLightCycleCapture(mActivity.getAndroidContext())) {
mSetPathString=LightCycleHelper.wrapGalleryPath(mSetPathString);
}
mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
itemPath=screenNailItemPath;
}
 else if (mInCameraRoll && GalleryUtils.isCameraAvailable(mActivity)) {
mSetPathString=""String_Node_Str"" + FilterSource.FILTER_CAMERA_SHORTCUT + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
mCurrentIndex++;
}
MediaSet originalSet=mActivity.getDataManager().getMediaSet(mSetPathString);
if (mInCameraRoll && originalSet instanceof ComboAlbum) {
((ComboAlbum)originalSet).useNameOfChild(1);
}
mSelectionManager.setSourceMediaSet(originalSet);
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
mMediaSet=(FilterDeleteSet)mActivity.getDataManager().getMediaSet(mSetPathString);
if (mMediaSet == null) {
Log.w(TAG,""String_Node_Str"" + mSetPathString);
}
if (itemPath == null) {
int mediaItemCount=mMediaSet.getMediaItemCount();
if (mediaItemCount > 0) {
if (mCurrentIndex >= mediaItemCount) mCurrentIndex=0;
itemPath=mMediaSet.getMediaItem(mCurrentIndex,1).get(0).getPath();
}
 else {
return;
}
}
PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0,mAppBridge == null ? false : mAppBridge.isPanorama(),mAppBridge == null ? false : mAppBridge.isStaticCamera());
mModel=pda;
mPhotoView.setModel(mModel);
pda.setDataListener(new PhotoDataAdapter.DataListener(){
@Override public void onPhotoChanged(int index,Path item){
int oldIndex=mCurrentIndex;
mCurrentIndex=index;
if (mAppBridge != null) {
if (mCurrentIndex > 0) {
mSkipUpdateCurrentPhoto=false;
}
if (oldIndex == 0 && mCurrentIndex > 0 && !mPhotoView.getFilmMode()) {
mPhotoView.setFilmMode(true);
}
 else if (oldIndex == 2 && mCurrentIndex == 1) {
mCameraSwitchCutoff=SystemClock.uptimeMillis() + CAMERA_SWITCH_CUTOFF_THRESHOLD_MS;
mPhotoView.stopScrolling();
}
 else if (oldIndex == 1 && mCurrentIndex == 0) {
mPhotoView.setWantPictureCenterCallbacks(true);
mSkipUpdateCurrentPhoto=true;
}
}
if (!mSkipUpdateCurrentPhoto) {
if (item != null) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
updateBars();
}
refreshHidingMessage();
}
@Override public void onLoadingFinished(){
if (!mModel.isEmpty()) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
 else if (mIsActive) {
if (mMediaSet.getNumberOfDeletions() == 0) {
mActivity.getStateManager().finishState(PhotoPage.this);
}
}
}
@Override public void onLoadingStarted(){
}
}
);
}
 else {
MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
mPhotoView.setModel(mModel);
updateCurrentPhoto(mediaItem);
mShowSpinner=false;
}
mPhotoView.setFilmMode(mStartInFilmstrip && mMediaSet.getMediaItemCount() > 1);
if (mSecureAlbum == null) {
RelativeLayout galleryRoot=(RelativeLayout)((Activity)mActivity).findViewById(mAppBridge != null ? R.id.content : R.id.gallery_root);
if (galleryRoot != null) {
mBottomControls=new PhotoPageBottomControls(this,mActivity,galleryRoot);
}
}
}","@Override public void onCreate(Bundle data,Bundle restoreState){
  super.onCreate(data,restoreState);
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mActivity.getGLRoot().setOrientationSource(mOrientationManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_REFRESH_BOTTOM_CONTROLS:
{
        if (mBottomControls != null)         mBottomControls.refresh();
        break;
      }
case MSG_LOCK_ORIENTATION:
{
      mOrientationManager.lockOrientation();
      break;
    }
case MSG_UNLOCK_ORIENTATION:
{
    mOrientationManager.unlockOrientation();
    break;
  }
case MSG_ON_FULL_SCREEN_CHANGED:
{
  mAppBridge.onFullScreenChanged(message.arg1 == 1);
  break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
case MSG_ON_CAMERA_CENTER:
{
mSkipUpdateCurrentPhoto=false;
boolean stayedOnCamera=false;
if (!mPhotoView.getFilmMode()) {
stayedOnCamera=true;
}
 else if (SystemClock.uptimeMillis() < mCameraSwitchCutoff && mMediaSet.getMediaItemCount() > 1) {
mPhotoView.switchToImage(1);
}
 else {
mPhotoView.setFilmMode(false);
stayedOnCamera=true;
}
if (stayedOnCamera) {
lockOrientation();
updateBars();
updateCurrentPhoto(mModel.getMediaItem(0));
}
break;
}
case MSG_ON_PICTURE_CENTER:
{
if (mCurrentPhoto != null && (mCurrentPhoto.getSupportedOperations() & MediaObject.SUPPORT_ACTION) != 0) {
mPhotoView.setFilmMode(true);
}
break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
mOriginalSetPathString=mSetPathString;
setupNfcBeamPush();
String itemPathString=data.getString(KEY_MEDIA_ITEM_PATH);
Path itemPath=itemPathString != null ? Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH)) : null;
mTreatBackAsUp=data.getBoolean(KEY_TREAT_BACK_AS_UP,false);
mStartInFilmstrip=data.getBoolean(KEY_START_IN_FILMSTRIP,false);
mInCameraRoll=data.getBoolean(KEY_IN_CAMERA_ROLL,false);
mStartedFromAlbumPage=data.getInt(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE) == MSG_ALBUMPAGE_STARTED;
mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
if (mSetPathString != null) {
mShowSpinner=true;
mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
if (mAppBridge != null) {
mShowBars=false;
mInCameraRoll=true;
mAppBridge.setServer(this);
mOrientationManager.lockOrientation();
int id=SnailSource.newId();
Path screenNailSetPath=SnailSource.getSetPath(id);
Path screenNailItemPath=SnailSource.getItemPath(id);
mScreenNailSet=(SnailAlbum)mActivity.getDataManager().getMediaObject(screenNailSetPath);
mScreenNailItem=(SnailItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
mScreenNailItem.setScreenNail(mAppBridge.attachScreenNail());
if (SecureSource.isSecurePath(mSetPathString)) {
mSecureAlbum=(SecureAlbum)mActivity.getDataManager().getMediaSet(mSetPathString);
mShowSpinner=false;
}
if (data.getBoolean(KEY_SHOW_WHEN_LOCKED,false)) {
mFlags|=FLAG_SHOW_WHEN_LOCKED;
}
if (!mSetPathString.equals(""String_Node_Str"")) {
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
}
if (LightCycleHelper.hasLightCycleCapture(mActivity.getAndroidContext())) {
mSetPathString=LightCycleHelper.wrapGalleryPath(mSetPathString);
}
mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
itemPath=screenNailItemPath;
}
 else if (mInCameraRoll && GalleryUtils.isCameraAvailable(mActivity)) {
mSetPathString=""String_Node_Str"" + FilterSource.FILTER_CAMERA_SHORTCUT + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
mCurrentIndex++;
}
MediaSet originalSet=mActivity.getDataManager().getMediaSet(mSetPathString);
if (mInCameraRoll && originalSet instanceof ComboAlbum) {
((ComboAlbum)originalSet).useNameOfChild(1);
}
mSelectionManager.setSourceMediaSet(originalSet);
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
mMediaSet=(FilterDeleteSet)mActivity.getDataManager().getMediaSet(mSetPathString);
if (mMediaSet == null) {
Log.w(TAG,""String_Node_Str"" + mSetPathString);
}
if (itemPath == null) {
int mediaItemCount=mMediaSet.getMediaItemCount();
if (mediaItemCount > 0) {
if (mCurrentIndex >= mediaItemCount) mCurrentIndex=0;
itemPath=mMediaSet.getMediaItem(mCurrentIndex,1).get(0).getPath();
}
 else {
return;
}
}
PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0,mAppBridge == null ? false : mAppBridge.isPanorama(),mAppBridge == null ? false : mAppBridge.isStaticCamera());
mModel=pda;
mPhotoView.setModel(mModel);
pda.setDataListener(new PhotoDataAdapter.DataListener(){
@Override public void onPhotoChanged(int index,Path item){
int oldIndex=mCurrentIndex;
mCurrentIndex=index;
if (mAppBridge != null) {
if (mCurrentIndex > 0) {
mSkipUpdateCurrentPhoto=false;
}
if (oldIndex == 0 && mCurrentIndex > 0 && !mPhotoView.getFilmMode()) {
mPhotoView.setFilmMode(true);
}
 else if (oldIndex == 2 && mCurrentIndex == 1) {
mCameraSwitchCutoff=SystemClock.uptimeMillis() + CAMERA_SWITCH_CUTOFF_THRESHOLD_MS;
mPhotoView.stopScrolling();
}
 else if (oldIndex >= 1 && mCurrentIndex == 0) {
mPhotoView.setWantPictureCenterCallbacks(true);
mSkipUpdateCurrentPhoto=true;
}
}
if (!mSkipUpdateCurrentPhoto) {
if (item != null) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
updateBars();
}
refreshHidingMessage();
}
@Override public void onLoadingFinished(){
if (!mModel.isEmpty()) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
 else if (mIsActive) {
if (mMediaSet.getNumberOfDeletions() == 0) {
mActivity.getStateManager().finishState(PhotoPage.this);
}
}
}
@Override public void onLoadingStarted(){
}
}
);
}
 else {
MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
mPhotoView.setModel(mModel);
updateCurrentPhoto(mediaItem);
mShowSpinner=false;
}
mPhotoView.setFilmMode(mStartInFilmstrip && mMediaSet.getMediaItemCount() > 1);
if (mSecureAlbum == null) {
RelativeLayout galleryRoot=(RelativeLayout)((Activity)mActivity).findViewById(mAppBridge != null ? R.id.content : R.id.gallery_root);
if (galleryRoot != null) {
mBottomControls=new PhotoPageBottomControls(this,mActivity,galleryRoot);
}
}
}","The original code had a logic error in handling camera center transitions, with unclear boolean conditions and redundant code paths. The fixed code introduces a clearer `stayedOnCamera` boolean that consolidates the camera mode transition logic and simplifies conditional branching. This improves code readability, reduces potential edge-case bugs, and provides a more straightforward mechanism for managing photo view state transitions during camera-related interactions."
38576,"@Override public void handleMessage(Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
      hideBars();
      break;
    }
case MSG_REFRESH_BOTTOM_CONTROLS:
{
    if (mBottomControls != null)     mBottomControls.refresh();
    break;
  }
case MSG_LOCK_ORIENTATION:
{
  mOrientationManager.lockOrientation();
  break;
}
case MSG_UNLOCK_ORIENTATION:
{
mOrientationManager.unlockOrientation();
break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
case MSG_ON_CAMERA_CENTER:
{
mSkipUpdateCurrentPhoto=false;
boolean updateNeeded=false;
if (!mPhotoView.getFilmMode()) {
lockOrientation();
updateNeeded=true;
}
 else if (SystemClock.uptimeMillis() < mCameraSwitchCutoff && mMediaSet.getMediaItemCount() > 1) {
mPhotoView.switchToImage(1);
}
 else {
mPhotoView.setFilmMode(false);
updateNeeded=true;
}
if (updateNeeded) {
updateBars();
updateCurrentPhoto(mModel.getMediaItem(0));
}
break;
}
case MSG_ON_PICTURE_CENTER:
{
if (mCurrentPhoto != null && (mCurrentPhoto.getSupportedOperations() & MediaObject.SUPPORT_ACTION) != 0) {
mPhotoView.setFilmMode(true);
}
break;
}
default :
throw new AssertionError(message.what);
}
}","@Override public void handleMessage(Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
      hideBars();
      break;
    }
case MSG_REFRESH_BOTTOM_CONTROLS:
{
    if (mBottomControls != null)     mBottomControls.refresh();
    break;
  }
case MSG_LOCK_ORIENTATION:
{
  mOrientationManager.lockOrientation();
  break;
}
case MSG_UNLOCK_ORIENTATION:
{
mOrientationManager.unlockOrientation();
break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
case MSG_ON_CAMERA_CENTER:
{
mSkipUpdateCurrentPhoto=false;
boolean stayedOnCamera=false;
if (!mPhotoView.getFilmMode()) {
stayedOnCamera=true;
}
 else if (SystemClock.uptimeMillis() < mCameraSwitchCutoff && mMediaSet.getMediaItemCount() > 1) {
mPhotoView.switchToImage(1);
}
 else {
mPhotoView.setFilmMode(false);
stayedOnCamera=true;
}
if (stayedOnCamera) {
lockOrientation();
updateBars();
updateCurrentPhoto(mModel.getMediaItem(0));
}
break;
}
case MSG_ON_PICTURE_CENTER:
{
if (mCurrentPhoto != null && (mCurrentPhoto.getSupportedOperations() & MediaObject.SUPPORT_ACTION) != 0) {
mPhotoView.setFilmMode(true);
}
break;
}
default :
throw new AssertionError(message.what);
}
}","The original code incorrectly mixed orientation locking logic within the camera center message handling, potentially causing unintended orientation changes. The fixed code introduces a `stayedOnCamera` flag to more precisely control orientation locking and update conditions, separating the logic for staying on camera mode from the actual orientation and UI updates. This approach provides clearer, more controlled behavior when transitioning between photo views, improving the method's readability and preventing potential unintended side effects."
38577,"public LocalMergeAlbum(Path path,Comparator<MediaItem> comparator,MediaSet[] sources,int bucketId){
  super(path,INVALID_DATA_VERSION);
  mComparator=comparator;
  mSources=sources;
  mName=sources.length == 0 ? ""String_Node_Str"" : sources[0].getName();
  mBucketId=bucketId;
  for (  MediaSet set : mSources) {
    set.addContentListener(this);
  }
}","public LocalMergeAlbum(Path path,Comparator<MediaItem> comparator,MediaSet[] sources,int bucketId){
  super(path,INVALID_DATA_VERSION);
  mComparator=comparator;
  mSources=sources;
  mName=sources.length == 0 ? ""String_Node_Str"" : sources[0].getName();
  mBucketId=bucketId;
  for (  MediaSet set : mSources) {
    set.addContentListener(this);
  }
  reload();
}","The original code did not initialize the album's content after setting up sources and listeners. The fixed code adds a `reload()` method call, which likely populates the album with media items from the sources using the specified comparator. This ensures that the album is fully prepared and populated immediately after construction, preventing potential null or empty state issues."
38578,"@Override public ArrayList<MediaItem> getMediaItem(int start,int count){
  SortedMap<Integer,int[]> head=mIndex.headMap(start + 1);
  int markPos;
  try {
    markPos=head.lastKey();
  }
 catch (  NoSuchElementException e) {
    Log.e(TAG,""String_Node_Str"" + start + ""String_Node_Str""+ count+ ""String_Node_Str"");
    Log.e(TAG,""String_Node_Str"");
    for (    MediaSet set : mSources) {
      Log.e(TAG,""String_Node_Str"" + set.getPath());
    }
    throw e;
  }
  int[] subPos=head.get(markPos).clone();
  MediaItem[] slot=new MediaItem[mSources.length];
  int size=mSources.length;
  for (int i=0; i < size; i++) {
    slot[i]=mFetcher[i].getItem(subPos[i]);
  }
  ArrayList<MediaItem> result=new ArrayList<MediaItem>();
  for (int i=markPos; i < start + count; i++) {
    int k=-1;
    for (int j=0; j < size; j++) {
      if (slot[j] != null) {
        if (k == -1 || mComparator.compare(slot[j],slot[k]) < 0) {
          k=j;
        }
      }
    }
    if (k == -1)     break;
    subPos[k]++;
    if (i >= start) {
      result.add(slot[k]);
    }
    slot[k]=mFetcher[k].getItem(subPos[k]);
    if ((i + 1) % PAGE_SIZE == 0) {
      mIndex.put(i + 1,subPos.clone());
    }
  }
  return result;
}","@Override public ArrayList<MediaItem> getMediaItem(int start,int count){
  SortedMap<Integer,int[]> head=mIndex.headMap(start + 1);
  int markPos=head.lastKey();
  int[] subPos=head.get(markPos).clone();
  MediaItem[] slot=new MediaItem[mSources.length];
  int size=mSources.length;
  for (int i=0; i < size; i++) {
    slot[i]=mFetcher[i].getItem(subPos[i]);
  }
  ArrayList<MediaItem> result=new ArrayList<MediaItem>();
  for (int i=markPos; i < start + count; i++) {
    int k=-1;
    for (int j=0; j < size; j++) {
      if (slot[j] != null) {
        if (k == -1 || mComparator.compare(slot[j],slot[k]) < 0) {
          k=j;
        }
      }
    }
    if (k == -1)     break;
    subPos[k]++;
    if (i >= start) {
      result.add(slot[k]);
    }
    slot[k]=mFetcher[k].getItem(subPos[k]);
    if ((i + 1) % PAGE_SIZE == 0) {
      mIndex.put(i + 1,subPos.clone());
    }
  }
  return result;
}","The original code unnecessarily wrapped the `lastKey()` method call in a try-catch block, potentially masking underlying indexing issues and disrupting normal program flow. The fixed code removes the exception handling, directly retrieving the last key from the `head` map and simplifying the method's logic. This modification improves code readability, reduces unnecessary error logging, and allows natural propagation of any potential underlying map access errors."
38579,"@Override public void onClick(View v){
  hideImageViews();
  mImageShow.setVisibility(View.VISIBLE);
  mImageShow.setShowControls(true);
  ImagePreset preset=mImageShow.getImagePreset();
  ImageFilter filter=preset.getFilter(""String_Node_Str"");
  if (filter == null) {
    ImageFilterHue contrast=new ImageFilterHue();
    ImagePreset copy=new ImagePreset(preset);
    copy.add(contrast);
    copy.setHistoryName(contrast.name());
    copy.setIsFx(false);
    filter=copy.getFilter(""String_Node_Str"");
    mImageShow.setImagePreset(copy);
  }
  mImageShow.setCurrentFilter(filter);
  unselectPanelButtons(mColorsPanelButtons);
  mShadowRecoveryButton.setSelected(true);
  invalidateViews();
}","@Override public void onClick(View v){
  hideImageViews();
  mImageShow.setVisibility(View.VISIBLE);
  mImageShow.setShowControls(true);
  ImagePreset preset=mImageShow.getImagePreset();
  ImageFilter filter=preset.getFilter(""String_Node_Str"");
  if (filter == null) {
    ImageFilterHue contrast=new ImageFilterHue();
    ImagePreset copy=new ImagePreset(preset);
    copy.add(contrast);
    copy.setHistoryName(contrast.getName());
    copy.setIsFx(false);
    filter=copy.getFilter(""String_Node_Str"");
    mImageShow.setImagePreset(copy);
  }
  mImageShow.setCurrentFilter(filter);
  unselectPanelButtons(mColorsPanelButtons);
  mShadowRecoveryButton.setSelected(true);
  invalidateViews();
}","The original code incorrectly used `filter.name()` instead of `filter.getName()`, which likely caused a compilation error or unexpected behavior. In the fixed code, `getName()` is the correct method call to retrieve the filter's name, ensuring proper method invocation and adherence to the class's design. This change resolves the potential method naming issue, making the code more robust and consistent with the expected method signature."
38580,"public void run(){
  lp.x=0;
  view.setLayoutParams(lp);
}","public void run(){
  viewList.setAlpha(0);
  viewList.setVisibility(View.VISIBLE);
  viewList.animate().setDuration(100).alpha(1.0f).start();
}","The original code attempts to modify layout parameters without a clear purpose, potentially causing unexpected UI behavior. The fixed code uses alpha animation to smoothly reveal a view by gradually increasing its opacity from 0 to 1, with a short 100ms duration for a subtle, professional transition effect. This approach provides a more user-friendly and visually appealing way of showing a view compared to the abrupt, undefined original implementation."
38581,"public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      HistoryAdapter adapter=(HistoryAdapter)mImageShow.getListAdapter();
      int position=adapter.undo();
      mImageShow.onItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=(HistoryAdapter)mImageShow.getListAdapter();
    int position=adapter.redo();
    mImageShow.onItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.operationsButton:
{
  toggleHistoryPanel();
  return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      HistoryAdapter adapter=(HistoryAdapter)mImageShow.getHistoryAdapter();
      int position=adapter.undo();
      mImageShow.onItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=(HistoryAdapter)mImageShow.getHistoryAdapter();
    int position=adapter.redo();
    mImageShow.onItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.showImageStateButton:
{
  toggleImageStatePanel();
  return true;
}
case R.id.operationsButton:
{
toggleHistoryPanel();
return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","The original code incorrectly used `getListAdapter()` method, which might not exist or return the correct adapter type for the `HistoryAdapter`. The fixed code replaces this with `getHistoryAdapter()`, a more specific and likely custom method designed to retrieve the correct adapter for history operations. By using the appropriate method and ensuring type-safe adapter retrieval, the fixed code provides a more robust and reliable way to access and manipulate the history adapter in the application."
38582,"private void resetHistory(){
  HistoryAdapter adapter=(HistoryAdapter)mImageShow.getListAdapter();
  adapter.reset();
  ImagePreset original=new ImagePreset(adapter.getItem(0));
  mImageShow.setImagePreset(original);
  invalidateViews();
}","private void resetHistory(){
  HistoryAdapter adapter=(HistoryAdapter)mImageShow.getHistoryAdapter();
  adapter.reset();
  ImagePreset original=new ImagePreset(adapter.getItem(0));
  mImageShow.setImagePreset(original);
  invalidateViews();
}","The original code incorrectly uses `getListAdapter()` to retrieve the adapter, which is likely not the correct method for accessing the history adapter. The fixed code replaces `getListAdapter()` with `getHistoryAdapter()`, which is presumably the correct method for retrieving the specific history adapter for the image view. This change ensures that the correct adapter is used, preventing potential null pointer exceptions or incorrect data retrieval when resetting the image history."
38583,"private OnClickListener createOnClickSaturationButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterSaturated sat=new ImageFilterSaturated();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(sat);
        copy.setHistoryName(sat.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mSaturationButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickSaturationButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterSaturated sat=new ImageFilterSaturated();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(sat);
        copy.setHistoryName(sat.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mSaturationButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly used `sat.name()`, which is likely not a valid method for retrieving the filter's name. In the fixed code, `sat.getName()` is used, which is the standard getter method for obtaining the name of an object. This correction ensures proper method invocation, preventing potential null pointer or compilation errors and improving the robustness of the saturation filter application logic."
38584,"private OnClickListener createOnClickVibranceButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mVibranceButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickVibranceButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mVibranceButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly called `name()` on the `ImageFilterHue` object, which likely does not exist as a method. The fixed code replaces this with `getName()`, a standard method for retrieving the name of an object, ensuring proper method invocation. This correction prevents potential null pointer exceptions and provides a more reliable way to set the history name of the image preset."
38585,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.gemoetryList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mFxButton.setSelected(true);
  mVignetteButton=(ImageButton)findViewById(R.id.vignetteButton);
  mCurvesButtonRGB=(ImageButton)findViewById(R.id.curvesButtonRGB);
  mSharpenButton=(ImageButton)findViewById(R.id.sharpenButton);
  mVibranceButton=(ImageButton)findViewById(R.id.vibranceButton);
  mContrastButton=(ImageButton)findViewById(R.id.contrastButton);
  mSaturationButton=(ImageButton)findViewById(R.id.saturationButton);
  mTintButton=(ImageButton)findViewById(R.id.tintButton);
  mExposureButton=(ImageButton)findViewById(R.id.exposureButton);
  mShadowRecoveryButton=(ImageButton)findViewById(R.id.shadowRecoveryButton);
  mColorsPanelButtons.add(mVignetteButton);
  mColorsPanelButtons.add(mCurvesButtonRGB);
  mColorsPanelButtons.add(mSharpenButton);
  mColorsPanelButtons.add(mContrastButton);
  mColorsPanelButtons.add(mSaturationButton);
  mColorsPanelButtons.add(mTintButton);
  mColorsPanelButtons.add(mVibranceButton);
  mColorsPanelButtons.add(mExposureButton);
  mColorsPanelButtons.add(mShadowRecoveryButton);
  findViewById(R.id.showOriginalButton).setOnTouchListener(createOnTouchShowOriginalButton());
  findViewById(R.id.straightenButton).setOnClickListener(createOnClickStraightenButton());
  findViewById(R.id.cropButton).setOnClickListener(createOnClickCropButton());
  findViewById(R.id.rotateButton).setOnClickListener(createOnClickRotateButton());
  findViewById(R.id.flipButton).setOnClickListener(createOnClickFlipButton());
  mVignetteButton.setOnClickListener(createOnClickVignetteButton());
  mCurvesButtonRGB.setOnClickListener(createOnClickCurvesRGBButton());
  mSharpenButton.setOnClickListener(createOnClickSharpenButton());
  mContrastButton.setOnClickListener(createOnClickContrastButton());
  mSaturationButton.setOnClickListener(createOnClickSaturationButton());
  mTintButton.setOnClickListener(createOnClickTintButton());
  mVibranceButton.setOnClickListener(createOnClickVibranceButton());
  mExposureButton.setOnClickListener(createOnClickExposureButton());
  mShadowRecoveryButton.setOnClickListener(createOnClickShadowRecoveryButton());
  mFxButton.setOnClickListener(createOnClickFxButton());
  mBorderButton.setOnClickListener(createOnClickBorderButton());
  mGeometryButton.setOnClickListener(createOnClickGeometryButton());
  mColorsButton.setOnClickListener(createOnClickColorsButton());
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getListAdapter());
  operationsList.setOnItemClickListener(this);
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getListAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri);
  }
 else {
    pickImage();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.gemoetryList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mFxButton.setSelected(true);
  mVignetteButton=(ImageButton)findViewById(R.id.vignetteButton);
  mCurvesButtonRGB=(ImageButton)findViewById(R.id.curvesButtonRGB);
  mSharpenButton=(ImageButton)findViewById(R.id.sharpenButton);
  mVibranceButton=(ImageButton)findViewById(R.id.vibranceButton);
  mContrastButton=(ImageButton)findViewById(R.id.contrastButton);
  mSaturationButton=(ImageButton)findViewById(R.id.saturationButton);
  mTintButton=(ImageButton)findViewById(R.id.tintButton);
  mExposureButton=(ImageButton)findViewById(R.id.exposureButton);
  mShadowRecoveryButton=(ImageButton)findViewById(R.id.shadowRecoveryButton);
  mColorsPanelButtons.add(mVignetteButton);
  mColorsPanelButtons.add(mCurvesButtonRGB);
  mColorsPanelButtons.add(mSharpenButton);
  mColorsPanelButtons.add(mContrastButton);
  mColorsPanelButtons.add(mSaturationButton);
  mColorsPanelButtons.add(mTintButton);
  mColorsPanelButtons.add(mVibranceButton);
  mColorsPanelButtons.add(mExposureButton);
  mColorsPanelButtons.add(mShadowRecoveryButton);
  findViewById(R.id.showOriginalButton).setOnTouchListener(createOnTouchShowOriginalButton());
  findViewById(R.id.straightenButton).setOnClickListener(createOnClickStraightenButton());
  findViewById(R.id.cropButton).setOnClickListener(createOnClickCropButton());
  findViewById(R.id.rotateButton).setOnClickListener(createOnClickRotateButton());
  findViewById(R.id.flipButton).setOnClickListener(createOnClickFlipButton());
  mVignetteButton.setOnClickListener(createOnClickVignetteButton());
  mCurvesButtonRGB.setOnClickListener(createOnClickCurvesRGBButton());
  mSharpenButton.setOnClickListener(createOnClickSharpenButton());
  mContrastButton.setOnClickListener(createOnClickContrastButton());
  mSaturationButton.setOnClickListener(createOnClickSaturationButton());
  mTintButton.setOnClickListener(createOnClickTintButton());
  mVibranceButton.setOnClickListener(createOnClickVibranceButton());
  mExposureButton.setOnClickListener(createOnClickExposureButton());
  mShadowRecoveryButton.setOnClickListener(createOnClickShadowRecoveryButton());
  mFxButton.setOnClickListener(createOnClickFxButton());
  mBorderButton.setOnClickListener(createOnClickBorderButton());
  mGeometryButton.setOnClickListener(createOnClickGeometryButton());
  mColorsButton.setOnClickListener(createOnClickColorsButton());
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri);
  }
 else {
    pickImage();
  }
}","The original code used `mImageShow.getListAdapter()` for both the operations list and adapter setting, which could lead to potential data inconsistency. The fixed code introduces `getHistoryAdapter()` and adds a new `imageStateList` with its own adapter, ensuring separate and correct data management. These changes improve code reliability by providing distinct adapters for different list views and preventing potential data mixing or unexpected behavior."
38586,"private OnClickListener createOnClickContrastButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterContrast contrast=new ImageFilterContrast();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mContrastButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickContrastButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterContrast contrast=new ImageFilterContrast();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mContrastButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly used `filter.name()`, which is likely not a valid method for obtaining the filter's name. In the fixed code, `contrast.getName()` is used instead, which is the correct method for retrieving the filter's name. This change ensures proper naming of the image preset and prevents potential null pointer or method resolution errors, improving the robustness and reliability of the filter application process."
38587,"private void fillListBorders(LinearLayout listBorders){
  int p=0;
  ImageFilter[] borders=new ImageFilter[8];
  borders[p++]=new ImageFilterBorder(null);
  Drawable npd3=getResources().getDrawable(R.drawable.filtershow_border_film3);
  borders[p++]=new ImageFilterBorder(npd3);
  Drawable npd=getResources().getDrawable(R.drawable.filtershow_border_scratch3);
  borders[p++]=new ImageFilterBorder(npd);
  Drawable npd2=getResources().getDrawable(R.drawable.filtershow_border_black);
  borders[p++]=new ImageFilterBorder(npd2);
  Drawable npd6=getResources().getDrawable(R.drawable.filtershow_border_rounded_black);
  borders[p++]=new ImageFilterBorder(npd6);
  Drawable npd4=getResources().getDrawable(R.drawable.filtershow_border_white);
  borders[p++]=new ImageFilterBorder(npd4);
  Drawable npd5=getResources().getDrawable(R.drawable.filtershow_border_rounded_white);
  borders[p++]=new ImageFilterBorder(npd5);
  for (int i=0; i < p; i++) {
    ImageSmallFilter filter=new ImageSmallFilter(getBaseContext());
    filter.setImageFilter(borders[i]);
    filter.setController(this);
    filter.setImageLoader(mImageLoader);
    listBorders.addView(filter);
  }
}","private void fillListBorders(LinearLayout listBorders){
  int p=0;
  ImageFilter[] borders=new ImageFilter[8];
  borders[p++]=new ImageFilterBorder(null);
  Drawable npd3=getResources().getDrawable(R.drawable.filtershow_border_film3);
  borders[p++]=new ImageFilterBorder(npd3);
  Drawable npd=getResources().getDrawable(R.drawable.filtershow_border_scratch3);
  borders[p++]=new ImageFilterBorder(npd);
  Drawable npd2=getResources().getDrawable(R.drawable.filtershow_border_black);
  borders[p++]=new ImageFilterBorder(npd2);
  Drawable npd6=getResources().getDrawable(R.drawable.filtershow_border_rounded_black);
  borders[p++]=new ImageFilterBorder(npd6);
  Drawable npd4=getResources().getDrawable(R.drawable.filtershow_border_white);
  borders[p++]=new ImageFilterBorder(npd4);
  Drawable npd5=getResources().getDrawable(R.drawable.filtershow_border_rounded_white);
  borders[p++]=new ImageFilterBorder(npd5);
  for (int i=0; i < p; i++) {
    ImageSmallFilter filter=new ImageSmallFilter(getBaseContext());
    filter.setImageFilter(borders[i]);
    filter.setController(this);
    filter.setImageLoader(mImageLoader);
    filter.setShowTitle(false);
    listBorders.addView(filter);
  }
}","The original code lacked the `setShowTitle(false)` method call, which might cause unnecessary title displays on border filters. The fixed code adds `filter.setShowTitle(false)` to explicitly disable title rendering for each border filter, preventing potential visual clutter. This improvement ensures a cleaner and more streamlined user interface by suppressing redundant text labels on the border selection views."
38588,"private OnClickListener createOnClickExposureButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterBrightness bright=new ImageFilterBrightness();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(bright);
        copy.setHistoryName(bright.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mExposureButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickExposureButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterBrightness bright=new ImageFilterBrightness();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(bright);
        copy.setHistoryName(bright.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mExposureButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly uses `filter.name()`, which is likely not a valid method for obtaining the filter's name. In the fixed code, `bright.getName()` is used instead, which is the correct method to retrieve the filter's name. This change ensures proper naming of the image preset and prevents potential null pointer or method resolution errors, making the code more robust and reliable."
38589,"private OnClickListener createOnClickVignetteButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterVignette vignette=new ImageFilterVignette();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(vignette);
        copy.setHistoryName(vignette.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mVignetteButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickVignetteButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterVignette vignette=new ImageFilterVignette();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(vignette);
        copy.setHistoryName(vignette.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mVignetteButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly used `vignette.name()`, which is likely not a valid method for retrieving the filter's name. In the fixed code, `vignette.getName()` is used, which is the standard Java convention for accessing object properties and methods. This correction ensures proper method invocation, preventing potential null pointer exceptions or compilation errors, and maintains clean, standard coding practices for method calls."
38590,"private OnClickListener createOnClickTintButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mTintButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickTintButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mTintButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The buggy code calls `contrast.name()`, which likely returns an incorrect or null value for obtaining the filter's history name. The fixed code uses `contrast.getName()`, which is the proper method to retrieve the filter's name, ensuring accurate filter identification and history tracking. This correction prevents potential null pointer exceptions and improves the reliability of filter management in the image processing workflow."
38591,"public void useImageFilter(ImageFilter imageFilter){
  if (imageFilter == null) {
    return;
  }
  ImagePreset oldPreset=mImageShow.getImagePreset();
  ImagePreset copy=new ImagePreset(oldPreset);
  if (imageFilter.name().equalsIgnoreCase(""String_Node_Str"")) {
    copy.remove(""String_Node_Str"");
    copy.setHistoryName(""String_Node_Str"");
  }
  copy.add(imageFilter);
  invalidateViews();
}","public void useImageFilter(ImageFilter imageFilter){
  if (imageFilter == null) {
    return;
  }
  ImagePreset oldPreset=mImageShow.getImagePreset();
  ImagePreset copy=new ImagePreset(oldPreset);
  if (imageFilter.getName().equalsIgnoreCase(""String_Node_Str"")) {
    copy.remove(""String_Node_Str"");
    copy.setHistoryName(""String_Node_Str"");
  }
  copy.add(imageFilter);
  mImageShow.setImagePreset(copy);
  invalidateViews();
}","The original code failed to update the image preset after applying the filter, leaving the visual state unchanged. The fixed code adds `mImageShow.setImagePreset(copy)` to explicitly update the image display with the modified preset, ensuring the filter is actually applied. This change guarantees that image transformations are correctly rendered and reflected in the user interface."
38592,"private void toggleHistoryPanel(){
  final View view=findViewById(R.id.mainPanel);
  final View viewList=findViewById(R.id.historyPanel);
  View rootView=viewList.getRootView();
  final AbsoluteLayout.LayoutParams lp=(AbsoluteLayout.LayoutParams)view.getLayoutParams();
  final AbsoluteLayout.LayoutParams lph=(AbsoluteLayout.LayoutParams)viewList.getLayoutParams();
  final int positionHistoryPanel=(int)(rootView.getWidth() - viewList.getWidth());
  if (!mShowingHistoryPanel) {
    mShowingHistoryPanel=true;
    view.animate().setDuration(200).x(-viewList.getWidth()).withLayer().withEndAction(new Runnable(){
      public void run(){
        view.setLayoutParams(lp);
        lph.x=positionHistoryPanel;
        viewList.setLayoutParams(lph);
        viewList.setAlpha(0);
        viewList.setVisibility(View.VISIBLE);
        viewList.animate().setDuration(100).alpha(1.0f).start();
      }
    }
).start();
  }
 else {
    mShowingHistoryPanel=false;
    viewList.setVisibility(View.INVISIBLE);
    view.animate().setDuration(200).x(0).withLayer().withEndAction(new Runnable(){
      public void run(){
        lp.x=0;
        view.setLayoutParams(lp);
      }
    }
).start();
  }
  invalidateOptionsMenu();
}","private void toggleHistoryPanel(){
  final View view=findViewById(R.id.mainPanel);
  final View viewList=findViewById(R.id.historyPanel);
  if (mShowingImageStatePanel) {
    findViewById(R.id.imageStatePanel).setVisibility(View.INVISIBLE);
    mShowingImageStatePanel=false;
  }
  if (!mShowingHistoryPanel) {
    mShowingHistoryPanel=true;
    view.animate().setDuration(200).x(-viewList.getWidth()).withLayer().withEndAction(new Runnable(){
      public void run(){
        viewList.setAlpha(0);
        viewList.setVisibility(View.VISIBLE);
        viewList.animate().setDuration(100).alpha(1.0f).start();
      }
    }
).start();
  }
 else {
    mShowingHistoryPanel=false;
    viewList.setVisibility(View.INVISIBLE);
    view.animate().setDuration(200).x(0).withLayer().start();
  }
  invalidateOptionsMenu();
}","The original code had unnecessary layout parameter manipulations and potential layout inconsistencies during panel animation. The fixed code simplifies the animation process by removing redundant layout parameter settings and adds a check to hide another panel if it's visible. This streamlines the panel toggle mechanism, reduces complexity, and ensures smoother, more predictable view transitions with cleaner, more focused animation logic."
38593,"private OnClickListener createOnClickShadowRecoveryButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mShadowRecoveryButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickShadowRecoveryButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mShadowRecoveryButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly used `name()` instead of `getName()` when setting the history name for the image preset, which could potentially cause a compilation error or unexpected behavior. In the fixed code, `contrast.getName()` is used, which correctly retrieves the filter's name as a method call. This change ensures proper method invocation and maintains the intended functionality of setting the history name for the image preset, leading to more reliable and predictable code execution."
38594,"@Override public boolean onCreateOptionsMenu(Menu menu){
  getMenuInflater().inflate(R.menu.filtershow_activity_menu,menu);
  MenuItem item=menu.findItem(R.id.operationsButton);
  if (mShowingHistoryPanel) {
    item.setTitle(R.string.hide_history_panel);
  }
 else {
    item.setTitle(R.string.show_history_panel);
  }
  return true;
}","@Override public boolean onCreateOptionsMenu(Menu menu){
  getMenuInflater().inflate(R.menu.filtershow_activity_menu,menu);
  MenuItem showHistory=menu.findItem(R.id.operationsButton);
  if (mShowingHistoryPanel) {
    showHistory.setTitle(R.string.hide_history_panel);
  }
 else {
    showHistory.setTitle(R.string.show_history_panel);
  }
  MenuItem showState=menu.findItem(R.id.showImageStateButton);
  if (mShowingImageStatePanel) {
    showState.setTitle(R.string.hide_imagestate_panel);
  }
 else {
    showState.setTitle(R.string.show_imagestate_panel);
  }
  return true;
}","The original code only handled the title for the operations button, potentially leaving other menu items unaddressed. The fixed code adds handling for an additional menu item (showImageStateButton) by finding it and dynamically setting its title based on the mShowingImageStatePanel state. This improvement provides more comprehensive menu management, ensuring all relevant menu items are properly configured during menu creation."
38595,"@Override public void onClick(View v){
  hideImageViews();
  mImageShow.setVisibility(View.VISIBLE);
  mImageShow.setShowControls(true);
  ImagePreset preset=mImageShow.getImagePreset();
  ImageFilter filter=preset.getFilter(""String_Node_Str"");
  if (filter == null) {
    ImageFilterHue contrast=new ImageFilterHue();
    ImagePreset copy=new ImagePreset(preset);
    copy.add(contrast);
    copy.setHistoryName(contrast.name());
    copy.setIsFx(false);
    filter=copy.getFilter(""String_Node_Str"");
    mImageShow.setImagePreset(copy);
  }
  mImageShow.setCurrentFilter(filter);
  unselectPanelButtons(mColorsPanelButtons);
  mShadowRecoveryButton.setSelected(true);
  invalidateViews();
}","@Override public void onClick(View v){
  hideImageViews();
  mImageShow.setVisibility(View.VISIBLE);
  mImageShow.setShowControls(true);
  ImagePreset preset=mImageShow.getImagePreset();
  ImageFilter filter=preset.getFilter(""String_Node_Str"");
  if (filter == null) {
    ImageFilterHue contrast=new ImageFilterHue();
    ImagePreset copy=new ImagePreset(preset);
    copy.add(contrast);
    copy.setHistoryName(contrast.getName());
    copy.setIsFx(false);
    filter=copy.getFilter(""String_Node_Str"");
    mImageShow.setImagePreset(copy);
  }
  mImageShow.setCurrentFilter(filter);
  unselectPanelButtons(mColorsPanelButtons);
  mShadowRecoveryButton.setSelected(true);
  invalidateViews();
}","The original code incorrectly used `filter.name()`, which is likely not a valid method for obtaining the filter's name. In the fixed code, `contrast.getName()` is used instead, which is the correct method for retrieving the filter's name. This change ensures proper naming of the image preset and prevents potential null pointer or method resolution errors during filter creation and application."
38596,"public void run(){
  lp.x=0;
  view.setLayoutParams(lp);
}","public void run(){
  viewList.setAlpha(0);
  viewList.setVisibility(View.VISIBLE);
  viewList.animate().setDuration(100).alpha(1.0f).start();
}","The original code attempts to modify layout parameters without proper context, potentially causing unexpected UI behavior or null pointer exceptions. The fixed code introduces a smooth alpha animation by setting initial alpha to 0, making the view visible, and then animating it to full opacity with a short duration. This approach provides a clean, controlled fade-in effect that enhances user experience through a subtle and professional visual transition."
38597,"public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      HistoryAdapter adapter=(HistoryAdapter)mImageShow.getListAdapter();
      int position=adapter.undo();
      mImageShow.onItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=(HistoryAdapter)mImageShow.getListAdapter();
    int position=adapter.redo();
    mImageShow.onItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.operationsButton:
{
  toggleHistoryPanel();
  return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.undoButton:
{
      HistoryAdapter adapter=(HistoryAdapter)mImageShow.getHistoryAdapter();
      int position=adapter.undo();
      mImageShow.onItemClick(position);
      mImageShow.showToast(""String_Node_Str"");
      invalidateViews();
      return true;
    }
case R.id.redoButton:
{
    HistoryAdapter adapter=(HistoryAdapter)mImageShow.getHistoryAdapter();
    int position=adapter.redo();
    mImageShow.onItemClick(position);
    mImageShow.showToast(""String_Node_Str"");
    invalidateViews();
    return true;
  }
case R.id.showImageStateButton:
{
  toggleImageStatePanel();
  return true;
}
case R.id.operationsButton:
{
toggleHistoryPanel();
return true;
}
case android.R.id.home:
{
saveImage();
return true;
}
}
return false;
}","The original code used `getListAdapter()`, which is an incorrect method for retrieving the history adapter in the context of image manipulation. The fixed code replaces this with `getHistoryAdapter()`, a more appropriate method for accessing the specific adapter, and adds a new case for `R.id.showImageStateButton` to improve functionality. These changes ensure proper adapter retrieval and expand the menu's capabilities, making the code more robust and maintainable."
38598,"private void resetHistory(){
  HistoryAdapter adapter=(HistoryAdapter)mImageShow.getListAdapter();
  adapter.reset();
  ImagePreset original=new ImagePreset(adapter.getItem(0));
  mImageShow.setImagePreset(original);
  invalidateViews();
}","private void resetHistory(){
  HistoryAdapter adapter=(HistoryAdapter)mImageShow.getHistoryAdapter();
  adapter.reset();
  ImagePreset original=new ImagePreset(adapter.getItem(0));
  mImageShow.setImagePreset(original);
  invalidateViews();
}","The original code incorrectly uses `getListAdapter()`, which likely does not exist or returns the wrong type of adapter for retrieving history data. The fixed code replaces this with `getHistoryAdapter()`, which is the correct method to retrieve the specific history adapter for the image view. This change ensures proper access to the history adapter, allowing accurate reset and restoration of the original image preset."
38599,"private OnClickListener createOnClickSaturationButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterSaturated sat=new ImageFilterSaturated();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(sat);
        copy.setHistoryName(sat.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mSaturationButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickSaturationButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterSaturated sat=new ImageFilterSaturated();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(sat);
        copy.setHistoryName(sat.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mSaturationButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly used `sat.name()`, which likely does not exist or returns an unexpected value for retrieving the filter's name. In the fixed code, `sat.getName()` is used, which is the standard method for obtaining an object's name in Java and ensures proper method invocation. This correction guarantees that the history name is set correctly, preventing potential naming or method resolution errors in the image filter processing workflow."
38600,"private OnClickListener createOnClickVibranceButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mVibranceButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickVibranceButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mVibranceButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly used `contrast.name()` method, which likely does not exist or returns an unexpected value for setting the history name. In the fixed code, `contrast.getName()` is used, which is the standard method for retrieving a filter's name in most Java/Android implementations. This correction ensures proper filter naming and prevents potential null or incorrect string references, leading to more reliable filter management in the image processing workflow."
38601,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.gemoetryList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mFxButton.setSelected(true);
  mVignetteButton=(ImageButton)findViewById(R.id.vignetteButton);
  mCurvesButtonRGB=(ImageButton)findViewById(R.id.curvesButtonRGB);
  mSharpenButton=(ImageButton)findViewById(R.id.sharpenButton);
  mVibranceButton=(ImageButton)findViewById(R.id.vibranceButton);
  mContrastButton=(ImageButton)findViewById(R.id.contrastButton);
  mSaturationButton=(ImageButton)findViewById(R.id.saturationButton);
  mTintButton=(ImageButton)findViewById(R.id.tintButton);
  mExposureButton=(ImageButton)findViewById(R.id.exposureButton);
  mShadowRecoveryButton=(ImageButton)findViewById(R.id.shadowRecoveryButton);
  mColorsPanelButtons.add(mVignetteButton);
  mColorsPanelButtons.add(mCurvesButtonRGB);
  mColorsPanelButtons.add(mSharpenButton);
  mColorsPanelButtons.add(mContrastButton);
  mColorsPanelButtons.add(mSaturationButton);
  mColorsPanelButtons.add(mTintButton);
  mColorsPanelButtons.add(mVibranceButton);
  mColorsPanelButtons.add(mExposureButton);
  mColorsPanelButtons.add(mShadowRecoveryButton);
  findViewById(R.id.showOriginalButton).setOnTouchListener(createOnTouchShowOriginalButton());
  findViewById(R.id.straightenButton).setOnClickListener(createOnClickStraightenButton());
  findViewById(R.id.cropButton).setOnClickListener(createOnClickCropButton());
  findViewById(R.id.rotateButton).setOnClickListener(createOnClickRotateButton());
  findViewById(R.id.flipButton).setOnClickListener(createOnClickFlipButton());
  mVignetteButton.setOnClickListener(createOnClickVignetteButton());
  mCurvesButtonRGB.setOnClickListener(createOnClickCurvesRGBButton());
  mSharpenButton.setOnClickListener(createOnClickSharpenButton());
  mContrastButton.setOnClickListener(createOnClickContrastButton());
  mSaturationButton.setOnClickListener(createOnClickSaturationButton());
  mTintButton.setOnClickListener(createOnClickTintButton());
  mVibranceButton.setOnClickListener(createOnClickVibranceButton());
  mExposureButton.setOnClickListener(createOnClickExposureButton());
  mShadowRecoveryButton.setOnClickListener(createOnClickShadowRecoveryButton());
  mFxButton.setOnClickListener(createOnClickFxButton());
  mBorderButton.setOnClickListener(createOnClickBorderButton());
  mGeometryButton.setOnClickListener(createOnClickGeometryButton());
  mColorsButton.setOnClickListener(createOnClickColorsButton());
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getListAdapter());
  operationsList.setOnItemClickListener(this);
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getListAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri);
  }
 else {
    pickImage();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.filtershow_activity);
  ActionBar actionBar=getActionBar();
  actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM);
  actionBar.setCustomView(R.layout.filtershow_actionbar);
  actionBar.getCustomView().setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      saveImage();
    }
  }
);
  mImageLoader=new ImageLoader(getApplicationContext());
  LinearLayout listFilters=(LinearLayout)findViewById(R.id.listFilters);
  LinearLayout listBorders=(LinearLayout)findViewById(R.id.listBorders);
  mImageShow=(ImageShow)findViewById(R.id.imageShow);
  mImageCurves=(ImageCurves)findViewById(R.id.imageCurves);
  mImageBorders=(ImageBorder)findViewById(R.id.imageBorder);
  mImageStraighten=(ImageStraighten)findViewById(R.id.imageStraighten);
  mImageViews.add(mImageShow);
  mImageViews.add(mImageCurves);
  mImageViews.add(mImageBorders);
  mImageViews.add(mImageStraighten);
  mListFx=findViewById(R.id.fxList);
  mListBorders=findViewById(R.id.bordersList);
  mListGeometry=findViewById(R.id.gemoetryList);
  mListColors=findViewById(R.id.colorsFxList);
  mListViews.add(mListFx);
  mListViews.add(mListBorders);
  mListViews.add(mListGeometry);
  mListViews.add(mListColors);
  mFxButton=(ImageButton)findViewById(R.id.fxButton);
  mBorderButton=(ImageButton)findViewById(R.id.borderButton);
  mGeometryButton=(ImageButton)findViewById(R.id.geometryButton);
  mColorsButton=(ImageButton)findViewById(R.id.colorsButton);
  mBottomPanelButtons.add(mFxButton);
  mBottomPanelButtons.add(mBorderButton);
  mBottomPanelButtons.add(mGeometryButton);
  mBottomPanelButtons.add(mColorsButton);
  mFxButton.setSelected(true);
  mVignetteButton=(ImageButton)findViewById(R.id.vignetteButton);
  mCurvesButtonRGB=(ImageButton)findViewById(R.id.curvesButtonRGB);
  mSharpenButton=(ImageButton)findViewById(R.id.sharpenButton);
  mVibranceButton=(ImageButton)findViewById(R.id.vibranceButton);
  mContrastButton=(ImageButton)findViewById(R.id.contrastButton);
  mSaturationButton=(ImageButton)findViewById(R.id.saturationButton);
  mTintButton=(ImageButton)findViewById(R.id.tintButton);
  mExposureButton=(ImageButton)findViewById(R.id.exposureButton);
  mShadowRecoveryButton=(ImageButton)findViewById(R.id.shadowRecoveryButton);
  mColorsPanelButtons.add(mVignetteButton);
  mColorsPanelButtons.add(mCurvesButtonRGB);
  mColorsPanelButtons.add(mSharpenButton);
  mColorsPanelButtons.add(mContrastButton);
  mColorsPanelButtons.add(mSaturationButton);
  mColorsPanelButtons.add(mTintButton);
  mColorsPanelButtons.add(mVibranceButton);
  mColorsPanelButtons.add(mExposureButton);
  mColorsPanelButtons.add(mShadowRecoveryButton);
  findViewById(R.id.showOriginalButton).setOnTouchListener(createOnTouchShowOriginalButton());
  findViewById(R.id.straightenButton).setOnClickListener(createOnClickStraightenButton());
  findViewById(R.id.cropButton).setOnClickListener(createOnClickCropButton());
  findViewById(R.id.rotateButton).setOnClickListener(createOnClickRotateButton());
  findViewById(R.id.flipButton).setOnClickListener(createOnClickFlipButton());
  mVignetteButton.setOnClickListener(createOnClickVignetteButton());
  mCurvesButtonRGB.setOnClickListener(createOnClickCurvesRGBButton());
  mSharpenButton.setOnClickListener(createOnClickSharpenButton());
  mContrastButton.setOnClickListener(createOnClickContrastButton());
  mSaturationButton.setOnClickListener(createOnClickSaturationButton());
  mTintButton.setOnClickListener(createOnClickTintButton());
  mVibranceButton.setOnClickListener(createOnClickVibranceButton());
  mExposureButton.setOnClickListener(createOnClickExposureButton());
  mShadowRecoveryButton.setOnClickListener(createOnClickShadowRecoveryButton());
  mFxButton.setOnClickListener(createOnClickFxButton());
  mBorderButton.setOnClickListener(createOnClickBorderButton());
  mGeometryButton.setOnClickListener(createOnClickGeometryButton());
  mColorsButton.setOnClickListener(createOnClickColorsButton());
  findViewById(R.id.resetOperationsButton).setOnClickListener(createOnClickResetOperationsButton());
  ListView operationsList=(ListView)findViewById(R.id.operationsList);
  operationsList.setAdapter(mImageShow.getHistoryAdapter());
  operationsList.setOnItemClickListener(this);
  ListView imageStateList=(ListView)findViewById(R.id.imageStateList);
  imageStateList.setAdapter(mImageShow.getImageStateAdapter());
  mImageLoader.setAdapter((HistoryAdapter)mImageShow.getHistoryAdapter());
  fillListImages(listFilters);
  fillListBorders(listBorders);
  mImageShow.setImageLoader(mImageLoader);
  mImageCurves.setImageLoader(mImageLoader);
  mImageCurves.setMaster(mImageShow);
  mImageBorders.setImageLoader(mImageLoader);
  mImageBorders.setMaster(mImageShow);
  mImageStraighten.setImageLoader(mImageLoader);
  mImageStraighten.setMaster(mImageShow);
  Intent intent=getIntent();
  String data=intent.getDataString();
  if (data != null) {
    Uri uri=Uri.parse(data);
    mImageLoader.loadBitmap(uri);
  }
 else {
    pickImage();
  }
}","The original code used `mImageShow.getListAdapter()` for both the operations list and adapter setup, which could lead to potential data inconsistency. The fixed code introduces `getHistoryAdapter()` and adds a new `imageStateList` with its own adapter, providing clearer separation of concerns and more robust state management. These changes ensure more reliable data handling and improve the overall reliability of the image editing interface."
38602,"private OnClickListener createOnClickContrastButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterContrast contrast=new ImageFilterContrast();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mContrastButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickContrastButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterContrast contrast=new ImageFilterContrast();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mContrastButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly calls `name()` on the `ImageFilterContrast` object, which likely does not exist as a method. The fixed code replaces `name()` with `getName()`, which is the standard method for retrieving the name of an object in Java. This correction ensures proper method invocation, preventing potential null pointer exceptions and maintaining the intended functionality of setting the history name for the image preset."
38603,"private void fillListBorders(LinearLayout listBorders){
  int p=0;
  ImageFilter[] borders=new ImageFilter[8];
  borders[p++]=new ImageFilterBorder(null);
  Drawable npd3=getResources().getDrawable(R.drawable.filtershow_border_film3);
  borders[p++]=new ImageFilterBorder(npd3);
  Drawable npd=getResources().getDrawable(R.drawable.filtershow_border_scratch3);
  borders[p++]=new ImageFilterBorder(npd);
  Drawable npd2=getResources().getDrawable(R.drawable.filtershow_border_black);
  borders[p++]=new ImageFilterBorder(npd2);
  Drawable npd6=getResources().getDrawable(R.drawable.filtershow_border_rounded_black);
  borders[p++]=new ImageFilterBorder(npd6);
  Drawable npd4=getResources().getDrawable(R.drawable.filtershow_border_white);
  borders[p++]=new ImageFilterBorder(npd4);
  Drawable npd5=getResources().getDrawable(R.drawable.filtershow_border_rounded_white);
  borders[p++]=new ImageFilterBorder(npd5);
  for (int i=0; i < p; i++) {
    ImageSmallFilter filter=new ImageSmallFilter(getBaseContext());
    filter.setImageFilter(borders[i]);
    filter.setController(this);
    filter.setImageLoader(mImageLoader);
    listBorders.addView(filter);
  }
}","private void fillListBorders(LinearLayout listBorders){
  int p=0;
  ImageFilter[] borders=new ImageFilter[8];
  borders[p++]=new ImageFilterBorder(null);
  Drawable npd3=getResources().getDrawable(R.drawable.filtershow_border_film3);
  borders[p++]=new ImageFilterBorder(npd3);
  Drawable npd=getResources().getDrawable(R.drawable.filtershow_border_scratch3);
  borders[p++]=new ImageFilterBorder(npd);
  Drawable npd2=getResources().getDrawable(R.drawable.filtershow_border_black);
  borders[p++]=new ImageFilterBorder(npd2);
  Drawable npd6=getResources().getDrawable(R.drawable.filtershow_border_rounded_black);
  borders[p++]=new ImageFilterBorder(npd6);
  Drawable npd4=getResources().getDrawable(R.drawable.filtershow_border_white);
  borders[p++]=new ImageFilterBorder(npd4);
  Drawable npd5=getResources().getDrawable(R.drawable.filtershow_border_rounded_white);
  borders[p++]=new ImageFilterBorder(npd5);
  for (int i=0; i < p; i++) {
    ImageSmallFilter filter=new ImageSmallFilter(getBaseContext());
    filter.setImageFilter(borders[i]);
    filter.setController(this);
    filter.setImageLoader(mImageLoader);
    filter.setShowTitle(false);
    listBorders.addView(filter);
  }
}","The original code lacked the `setShowTitle(false)` method call, which might cause unnecessary title display for border filters. The fixed code adds `filter.setShowTitle(false)` to explicitly disable title rendering for each border filter, ensuring a cleaner visual presentation. This modification prevents potential UI clutter and provides a more streamlined user interface for border selection."
38604,"private OnClickListener createOnClickExposureButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterBrightness bright=new ImageFilterBrightness();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(bright);
        copy.setHistoryName(bright.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mExposureButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickExposureButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterBrightness bright=new ImageFilterBrightness();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(bright);
        copy.setHistoryName(bright.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mExposureButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly called `bright.name()`, which might not be a valid method for retrieving the filter's name. In the fixed code, `bright.getName()` is used, which is likely the correct method for obtaining the filter's name. This change ensures proper method invocation, preventing potential null pointer exceptions or naming errors, and maintains the intended functionality of setting the history name for the image preset."
38605,"private OnClickListener createOnClickVignetteButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterVignette vignette=new ImageFilterVignette();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(vignette);
        copy.setHistoryName(vignette.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mVignetteButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickVignetteButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterVignette vignette=new ImageFilterVignette();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(vignette);
        copy.setHistoryName(vignette.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mVignetteButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly called `vignette.name()` which likely does not exist, potentially causing a compilation error or runtime exception. In the fixed code, `vignette.getName()` is used, which is the standard Java method for retrieving a name from an object. This correction ensures proper method invocation, allowing the vignette filter to be added to the image preset without causing method resolution issues."
38606,"private OnClickListener createOnClickTintButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mTintButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickTintButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mTintButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly used `name()` instead of `getName()` when setting the history name for the image preset, which could potentially cause a compilation error or unexpected behavior. In the fixed code, `contrast.getName()` is used, correctly invoking the method to retrieve the filter's name. This change ensures proper method calling and maintains the intended functionality of setting the history name for the image preset with the correct method syntax."
38607,"public void useImageFilter(ImageFilter imageFilter){
  if (imageFilter == null) {
    return;
  }
  ImagePreset oldPreset=mImageShow.getImagePreset();
  ImagePreset copy=new ImagePreset(oldPreset);
  if (imageFilter.name().equalsIgnoreCase(""String_Node_Str"")) {
    copy.remove(""String_Node_Str"");
    copy.setHistoryName(""String_Node_Str"");
  }
  copy.add(imageFilter);
  invalidateViews();
}","public void useImageFilter(ImageFilter imageFilter){
  if (imageFilter == null) {
    return;
  }
  ImagePreset oldPreset=mImageShow.getImagePreset();
  ImagePreset copy=new ImagePreset(oldPreset);
  if (imageFilter.getName().equalsIgnoreCase(""String_Node_Str"")) {
    copy.remove(""String_Node_Str"");
    copy.setHistoryName(""String_Node_Str"");
  }
  copy.add(imageFilter);
  mImageShow.setImagePreset(copy);
  invalidateViews();
}","The original code failed to update the image preset after adding a new filter, potentially leaving the display unchanged. The fixed code adds `mImageShow.setImagePreset(copy)` to explicitly apply the modified preset with the new filter to the image display. This ensures that the image is actually updated with the selected filter, providing the expected visual transformation."
38608,"private void toggleHistoryPanel(){
  final View view=findViewById(R.id.mainPanel);
  final View viewList=findViewById(R.id.historyPanel);
  View rootView=viewList.getRootView();
  final AbsoluteLayout.LayoutParams lp=(AbsoluteLayout.LayoutParams)view.getLayoutParams();
  final AbsoluteLayout.LayoutParams lph=(AbsoluteLayout.LayoutParams)viewList.getLayoutParams();
  final int positionHistoryPanel=(int)(rootView.getWidth() - viewList.getWidth());
  if (!mShowingHistoryPanel) {
    mShowingHistoryPanel=true;
    view.animate().setDuration(200).x(-viewList.getWidth()).withLayer().withEndAction(new Runnable(){
      public void run(){
        view.setLayoutParams(lp);
        lph.x=positionHistoryPanel;
        viewList.setLayoutParams(lph);
        viewList.setAlpha(0);
        viewList.setVisibility(View.VISIBLE);
        viewList.animate().setDuration(100).alpha(1.0f).start();
      }
    }
).start();
  }
 else {
    mShowingHistoryPanel=false;
    viewList.setVisibility(View.INVISIBLE);
    view.animate().setDuration(200).x(0).withLayer().withEndAction(new Runnable(){
      public void run(){
        lp.x=0;
        view.setLayoutParams(lp);
      }
    }
).start();
  }
  invalidateOptionsMenu();
}","private void toggleHistoryPanel(){
  final View view=findViewById(R.id.mainPanel);
  final View viewList=findViewById(R.id.historyPanel);
  if (mShowingImageStatePanel) {
    findViewById(R.id.imageStatePanel).setVisibility(View.INVISIBLE);
    mShowingImageStatePanel=false;
  }
  if (!mShowingHistoryPanel) {
    mShowingHistoryPanel=true;
    view.animate().setDuration(200).x(-viewList.getWidth()).withLayer().withEndAction(new Runnable(){
      public void run(){
        viewList.setAlpha(0);
        viewList.setVisibility(View.VISIBLE);
        viewList.animate().setDuration(100).alpha(1.0f).start();
      }
    }
).start();
  }
 else {
    mShowingHistoryPanel=false;
    viewList.setVisibility(View.INVISIBLE);
    view.animate().setDuration(200).x(0).withLayer().start();
  }
  invalidateOptionsMenu();
}","The original code had complex layout manipulation that could cause visual glitches and potential memory leaks by repeatedly modifying layout parameters during animation. The fixed code simplifies the animation process by removing unnecessary layout parameter modifications and adding a check to handle potential conflicts with another panel. The streamlined approach ensures smoother transitions, reduces potential rendering issues, and provides more predictable UI behavior during panel toggling."
38609,"private OnClickListener createOnClickShadowRecoveryButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.name());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mShadowRecoveryButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","private OnClickListener createOnClickShadowRecoveryButton(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      hideImageViews();
      mImageShow.setVisibility(View.VISIBLE);
      mImageShow.setShowControls(true);
      ImagePreset preset=mImageShow.getImagePreset();
      ImageFilter filter=preset.getFilter(""String_Node_Str"");
      if (filter == null) {
        ImageFilterHue contrast=new ImageFilterHue();
        ImagePreset copy=new ImagePreset(preset);
        copy.add(contrast);
        copy.setHistoryName(contrast.getName());
        copy.setIsFx(false);
        filter=copy.getFilter(""String_Node_Str"");
        mImageShow.setImagePreset(copy);
      }
      mImageShow.setCurrentFilter(filter);
      unselectPanelButtons(mColorsPanelButtons);
      mShadowRecoveryButton.setSelected(true);
      invalidateViews();
    }
  }
;
}","The original code incorrectly used `name()` method for getting the filter's name, which likely does not exist or returns an unexpected value. In the fixed code, `getName()` is used instead, which is the standard method for retrieving a filter's name in most Java classes. This correction ensures proper filter naming and prevents potential null or incorrect name references, improving the reliability of filter management in the image processing workflow."
38610,"@Override public boolean onCreateOptionsMenu(Menu menu){
  getMenuInflater().inflate(R.menu.filtershow_activity_menu,menu);
  MenuItem item=menu.findItem(R.id.operationsButton);
  if (mShowingHistoryPanel) {
    item.setTitle(R.string.hide_history_panel);
  }
 else {
    item.setTitle(R.string.show_history_panel);
  }
  return true;
}","@Override public boolean onCreateOptionsMenu(Menu menu){
  getMenuInflater().inflate(R.menu.filtershow_activity_menu,menu);
  MenuItem showHistory=menu.findItem(R.id.operationsButton);
  if (mShowingHistoryPanel) {
    showHistory.setTitle(R.string.hide_history_panel);
  }
 else {
    showHistory.setTitle(R.string.show_history_panel);
  }
  MenuItem showState=menu.findItem(R.id.showImageStateButton);
  if (mShowingImageStatePanel) {
    showState.setTitle(R.string.hide_imagestate_panel);
  }
 else {
    showState.setTitle(R.string.show_imagestate_panel);
  }
  return true;
}","The original code only handled the title for the operations button, potentially leaving other menu items unaddressed. The fixed code adds handling for an additional menu item (showImageStateButton) and dynamically sets its title based on the mShowingImageStatePanel state, similar to the first button. This improvement provides more comprehensive menu state management, ensuring all relevant menu items have their titles correctly updated based on the current UI context."
38611,"@Override protected boolean onItemSelected(MenuItem item){
switch (item.getItemId()) {
case android.R.id.home:
{
      onUpPressed();
      return true;
    }
case R.id.action_cancel:
  mActivity.getStateManager().finishState(this);
return true;
case R.id.action_select:
mSelectionManager.setAutoLeaveSelectionMode(false);
mSelectionManager.enterSelectionMode();
return true;
case R.id.action_group_by:
{
mActivity.getGalleryActionBar().showClusterDialog(this);
return true;
}
case R.id.action_slideshow:
{
Bundle data=new Bundle();
data.putString(SlideshowPage.KEY_SET_PATH,mMediaSetPath.toString());
data.putBoolean(SlideshowPage.KEY_REPEAT,true);
mActivity.getStateManager().startStateForResult(SlideshowPage.class,REQUEST_SLIDESHOW,data);
return true;
}
case R.id.action_filmstrip:
{
int targetPhoto=mSlotView.getVisibleStart();
prepareAnimationBackToFilmstrip(targetPhoto);
if (mLaunchedFromPhotoPage) {
mActivity.getTransitionStore().put(PhotoPage.KEY_ALBUMPAGE_TRANSITION,PhotoPage.MSG_ALBUMPAGE_RESUMED);
onBackPressed();
}
 else {
pickPhoto(targetPhoto,true);
}
return true;
}
case R.id.action_details:
{
if (mShowDetails) {
hideDetails();
}
 else {
showDetails();
}
return true;
}
case R.id.action_camera:
{
GalleryUtils.startCameraActivity(mActivity);
return true;
}
default :
return false;
}
}","@Override protected boolean onItemSelected(MenuItem item){
switch (item.getItemId()) {
case android.R.id.home:
{
      onUpPressed();
      return true;
    }
case R.id.action_cancel:
  mActivity.getStateManager().finishState(this);
return true;
case R.id.action_select:
mSelectionManager.setAutoLeaveSelectionMode(false);
mSelectionManager.enterSelectionMode();
return true;
case R.id.action_group_by:
{
mActivity.getGalleryActionBar().showClusterDialog(this);
return true;
}
case R.id.action_slideshow:
{
Bundle data=new Bundle();
data.putString(SlideshowPage.KEY_SET_PATH,mMediaSetPath.toString());
data.putBoolean(SlideshowPage.KEY_REPEAT,true);
mActivity.getStateManager().startStateForResult(SlideshowPage.class,REQUEST_SLIDESHOW,data);
return true;
}
case R.id.action_filmstrip:
{
if (mAlbumDataAdapter.size() < 1) return true;
int targetPhoto=mSlotView.getVisibleStart();
prepareAnimationBackToFilmstrip(targetPhoto);
if (mLaunchedFromPhotoPage) {
mActivity.getTransitionStore().put(PhotoPage.KEY_ALBUMPAGE_TRANSITION,PhotoPage.MSG_ALBUMPAGE_RESUMED);
onBackPressed();
}
 else {
pickPhoto(targetPhoto,true);
}
return true;
}
case R.id.action_details:
{
if (mShowDetails) {
hideDetails();
}
 else {
showDetails();
}
return true;
}
case R.id.action_camera:
{
GalleryUtils.startCameraActivity(mActivity);
return true;
}
default :
return false;
}
}","The original code lacked a critical check before accessing album data, potentially causing a null pointer exception or index out of bounds error when attempting to navigate to filmstrip view. The fixed code adds a size check `mAlbumDataAdapter.size() < 1` to prevent processing when no items exist, ensuring safe method execution. This defensive programming approach prevents crashes and provides a more robust user experience by gracefully handling empty album scenarios."
38612,"@Override public void onCreate(Bundle data,Bundle restoreState){
  super.onCreate(data,restoreState);
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mActivity.getGLRoot().setOrientationSource(mOrientationManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_REFRESH_GRID_BUTTON:
{
        setGridButtonVisibility(mPhotoView.getFilmMode());
        break;
      }
case MSG_REFRESH_EDIT_BUTTON:
{
      refreshEditButton();
      break;
    }
case MSG_LOCK_ORIENTATION:
{
    mOrientationManager.lockOrientation();
    break;
  }
case MSG_UNLOCK_ORIENTATION:
{
  mOrientationManager.unlockOrientation();
  break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
mOriginalSetPathString=mSetPathString;
mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity.getAndroidContext());
String itemPathString=data.getString(KEY_MEDIA_ITEM_PATH);
Path itemPath=itemPathString != null ? Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH)) : null;
mTreatBackAsUp=data.getBoolean(KEY_TREAT_BACK_AS_UP,false);
mStartInFilmstrip=data.getBoolean(KEY_START_IN_FILMSTRIP,false);
mStartedFromAlbumPage=data.getInt(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE) == MSG_ALBUMPAGE_STARTED;
setGridButtonVisibility(!mStartedFromAlbumPage);
if (mSetPathString != null) {
mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
if (mAppBridge != null) {
mFlags|=FLAG_HIDE_ACTION_BAR | FLAG_HIDE_STATUS_BAR;
mShowBars=false;
mAppBridge.setServer(this);
mOrientationManager.lockOrientation();
int id=SnailSource.newId();
Path screenNailSetPath=SnailSource.getSetPath(id);
Path screenNailItemPath=SnailSource.getItemPath(id);
mScreenNailSet=(SnailAlbum)mActivity.getDataManager().getMediaObject(screenNailSetPath);
mScreenNailItem=(SnailItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
mScreenNailItem.setScreenNail(mAppBridge.attachScreenNail());
if (SecureSource.isSecurePath(mSetPathString)) {
mSecureAlbum=(SecureAlbum)mActivity.getDataManager().getMediaSet(mSetPathString);
mFlags|=FLAG_SHOW_WHEN_LOCKED;
}
mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
itemPath=screenNailItemPath;
}
MediaSet originalSet=mActivity.getDataManager().getMediaSet(mSetPathString);
mSelectionManager.setSourceMediaSet(originalSet);
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
mMediaSet=(FilterDeleteSet)mActivity.getDataManager().getMediaSet(mSetPathString);
mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
if (mMediaSet == null) {
Log.w(TAG,""String_Node_Str"" + mSetPathString);
}
if (itemPath == null) {
mMediaSet.reload();
if (mMediaSet.getMediaItemCount() > 0) {
itemPath=mMediaSet.getMediaItem(mCurrentIndex,1).get(0).getPath();
}
 else {
return;
}
}
PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0,mAppBridge == null ? false : mAppBridge.isPanorama(),mAppBridge == null ? false : mAppBridge.isStaticCamera());
mModel=pda;
mPhotoView.setModel(mModel);
pda.setDataListener(new PhotoDataAdapter.DataListener(){
@Override public void onPhotoChanged(int index,Path item){
mCurrentIndex=index;
if (item != null) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
updateBars();
}
@Override public void onLoadingFinished(){
if (!mModel.isEmpty()) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
 else if (mIsActive) {
if (mMediaSet.getNumberOfDeletions() == 0) {
mActivity.getStateManager().finishState(PhotoPage.this);
}
}
}
@Override public void onLoadingStarted(){
}
}
);
}
 else {
MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
mPhotoView.setModel(mModel);
updateCurrentPhoto(mediaItem);
}
mPhotoView.setFilmMode(mStartInFilmstrip && mMediaSet.getMediaItemCount() > 1);
setupEditButton();
}","@Override public void onCreate(Bundle data,Bundle restoreState){
  super.onCreate(data,restoreState);
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mActivity.getGLRoot().setOrientationSource(mOrientationManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_REFRESH_GRID_BUTTON:
{
        setGridButtonVisibility(mPhotoView.getFilmMode());
        break;
      }
case MSG_REFRESH_EDIT_BUTTON:
{
      refreshEditButton();
      break;
    }
case MSG_LOCK_ORIENTATION:
{
    mOrientationManager.lockOrientation();
    break;
  }
case MSG_UNLOCK_ORIENTATION:
{
  mOrientationManager.unlockOrientation();
  break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
mOriginalSetPathString=mSetPathString;
mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity.getAndroidContext());
String itemPathString=data.getString(KEY_MEDIA_ITEM_PATH);
Path itemPath=itemPathString != null ? Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH)) : null;
mTreatBackAsUp=data.getBoolean(KEY_TREAT_BACK_AS_UP,false);
mStartInFilmstrip=data.getBoolean(KEY_START_IN_FILMSTRIP,false);
mStartedFromAlbumPage=data.getInt(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE) == MSG_ALBUMPAGE_STARTED;
setGridButtonVisibility(!mStartedFromAlbumPage);
if (mSetPathString != null) {
mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
if (mAppBridge != null) {
mFlags|=FLAG_HIDE_ACTION_BAR | FLAG_HIDE_STATUS_BAR;
mShowBars=false;
mAppBridge.setServer(this);
mOrientationManager.lockOrientation();
int id=SnailSource.newId();
Path screenNailSetPath=SnailSource.getSetPath(id);
Path screenNailItemPath=SnailSource.getItemPath(id);
mScreenNailSet=(SnailAlbum)mActivity.getDataManager().getMediaObject(screenNailSetPath);
mScreenNailItem=(SnailItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
mScreenNailItem.setScreenNail(mAppBridge.attachScreenNail());
if (SecureSource.isSecurePath(mSetPathString)) {
mSecureAlbum=(SecureAlbum)mActivity.getDataManager().getMediaSet(mSetPathString);
mFlags|=FLAG_SHOW_WHEN_LOCKED;
}
mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
itemPath=screenNailItemPath;
}
MediaSet originalSet=mActivity.getDataManager().getMediaSet(mSetPathString);
mSelectionManager.setSourceMediaSet(originalSet);
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
mMediaSet=(FilterDeleteSet)mActivity.getDataManager().getMediaSet(mSetPathString);
mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
if (mMediaSet == null) {
Log.w(TAG,""String_Node_Str"" + mSetPathString);
}
if (itemPath == null) {
if (mMediaSet.getMediaItemCount() > 0) {
itemPath=mMediaSet.getMediaItem(mCurrentIndex,1).get(0).getPath();
}
 else {
return;
}
}
PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0,mAppBridge == null ? false : mAppBridge.isPanorama(),mAppBridge == null ? false : mAppBridge.isStaticCamera());
mModel=pda;
mPhotoView.setModel(mModel);
pda.setDataListener(new PhotoDataAdapter.DataListener(){
@Override public void onPhotoChanged(int index,Path item){
mCurrentIndex=index;
if (item != null) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
updateBars();
}
@Override public void onLoadingFinished(){
if (!mModel.isEmpty()) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
 else if (mIsActive) {
if (mMediaSet.getNumberOfDeletions() == 0) {
mActivity.getStateManager().finishState(PhotoPage.this);
}
}
}
@Override public void onLoadingStarted(){
}
}
);
}
 else {
MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
mPhotoView.setModel(mModel);
updateCurrentPhoto(mediaItem);
}
mPhotoView.setFilmMode(mStartInFilmstrip && mMediaSet.getMediaItemCount() > 1);
setupEditButton();
}","The original code had a potential null pointer exception when checking `mMediaSet.reload()` before accessing media items. In the fixed code, the `reload()` method was removed, and the code directly checks if media items exist before retrieving the item path. This ensures safer navigation through the media set, preventing potential null reference errors and improving the robustness of the photo loading process."
38613,"public FilterDeleteSet(Path path,MediaSet baseSet){
  super(path,INVALID_DATA_VERSION);
  mBaseSet=baseSet;
  mBaseSet.addContentListener(this);
}","public FilterDeleteSet(Path path,MediaSet baseSet){
  super(path,INVALID_DATA_VERSION);
  mBaseSet=baseSet;
  mBaseSet.addContentListener(this);
  mMediaItemCount=mBaseSet.getMediaItemCount() - mCurrent.size();
}","The original code failed to calculate the media item count correctly, potentially leading to inaccurate tracking of items in the set. The fixed code adds a line to explicitly set `mMediaItemCount` by subtracting the current set size from the base set's total media item count, ensuring accurate item tracking. This correction provides a more precise representation of the media set's contents, preventing potential counting errors in subsequent operations."
38614,"@Override protected boolean onItemSelected(MenuItem item){
switch (item.getItemId()) {
case android.R.id.home:
{
      onUpPressed();
      return true;
    }
case R.id.action_cancel:
  mActivity.getStateManager().finishState(this);
return true;
case R.id.action_select:
mSelectionManager.setAutoLeaveSelectionMode(false);
mSelectionManager.enterSelectionMode();
return true;
case R.id.action_group_by:
{
mActivity.getGalleryActionBar().showClusterDialog(this);
return true;
}
case R.id.action_slideshow:
{
Bundle data=new Bundle();
data.putString(SlideshowPage.KEY_SET_PATH,mMediaSetPath.toString());
data.putBoolean(SlideshowPage.KEY_REPEAT,true);
mActivity.getStateManager().startStateForResult(SlideshowPage.class,REQUEST_SLIDESHOW,data);
return true;
}
case R.id.action_filmstrip:
{
int targetPhoto=mSlotView.getVisibleStart();
prepareAnimationBackToFilmstrip(targetPhoto);
if (mLaunchedFromPhotoPage) {
mActivity.getTransitionStore().put(PhotoPage.KEY_ALBUMPAGE_TRANSITION,PhotoPage.MSG_ALBUMPAGE_RESUMED);
onBackPressed();
}
 else {
pickPhoto(targetPhoto,true);
}
return true;
}
case R.id.action_details:
{
if (mShowDetails) {
hideDetails();
}
 else {
showDetails();
}
return true;
}
case R.id.action_camera:
{
GalleryUtils.startCameraActivity(mActivity);
return true;
}
default :
return false;
}
}","@Override protected boolean onItemSelected(MenuItem item){
switch (item.getItemId()) {
case android.R.id.home:
{
      onUpPressed();
      return true;
    }
case R.id.action_cancel:
  mActivity.getStateManager().finishState(this);
return true;
case R.id.action_select:
mSelectionManager.setAutoLeaveSelectionMode(false);
mSelectionManager.enterSelectionMode();
return true;
case R.id.action_group_by:
{
mActivity.getGalleryActionBar().showClusterDialog(this);
return true;
}
case R.id.action_slideshow:
{
Bundle data=new Bundle();
data.putString(SlideshowPage.KEY_SET_PATH,mMediaSetPath.toString());
data.putBoolean(SlideshowPage.KEY_REPEAT,true);
mActivity.getStateManager().startStateForResult(SlideshowPage.class,REQUEST_SLIDESHOW,data);
return true;
}
case R.id.action_filmstrip:
{
if (mAlbumDataAdapter.size() < 1) return true;
int targetPhoto=mSlotView.getVisibleStart();
prepareAnimationBackToFilmstrip(targetPhoto);
if (mLaunchedFromPhotoPage) {
mActivity.getTransitionStore().put(PhotoPage.KEY_ALBUMPAGE_TRANSITION,PhotoPage.MSG_ALBUMPAGE_RESUMED);
onBackPressed();
}
 else {
pickPhoto(targetPhoto,true);
}
return true;
}
case R.id.action_details:
{
if (mShowDetails) {
hideDetails();
}
 else {
showDetails();
}
return true;
}
case R.id.action_camera:
{
GalleryUtils.startCameraActivity(mActivity);
return true;
}
default :
return false;
}
}","The original code lacked a critical check before accessing album data, potentially causing a null pointer exception or index out of bounds error when attempting to perform filmstrip-related actions on an empty album. The fixed code adds a size check `mAlbumDataAdapter.size() < 1` to prevent processing when no items exist, returning early and avoiding potential runtime crashes. This defensive programming approach ensures safer and more robust handling of album interactions by preventing invalid operations on empty data sets."
38615,"@Override public void onCreate(Bundle data,Bundle restoreState){
  super.onCreate(data,restoreState);
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mActivity.getGLRoot().setOrientationSource(mOrientationManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_REFRESH_GRID_BUTTON:
{
        setGridButtonVisibility(mPhotoView.getFilmMode());
        break;
      }
case MSG_REFRESH_EDIT_BUTTON:
{
      refreshEditButton();
      break;
    }
case MSG_LOCK_ORIENTATION:
{
    mOrientationManager.lockOrientation();
    break;
  }
case MSG_UNLOCK_ORIENTATION:
{
  mOrientationManager.unlockOrientation();
  break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
mOriginalSetPathString=mSetPathString;
mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity.getAndroidContext());
String itemPathString=data.getString(KEY_MEDIA_ITEM_PATH);
Path itemPath=itemPathString != null ? Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH)) : null;
mTreatBackAsUp=data.getBoolean(KEY_TREAT_BACK_AS_UP,false);
mStartInFilmstrip=data.getBoolean(KEY_START_IN_FILMSTRIP,false);
mStartedFromAlbumPage=data.getInt(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE) == MSG_ALBUMPAGE_STARTED;
setGridButtonVisibility(!mStartedFromAlbumPage);
if (mSetPathString != null) {
mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
if (mAppBridge != null) {
mFlags|=FLAG_HIDE_ACTION_BAR | FLAG_HIDE_STATUS_BAR;
mShowBars=false;
mAppBridge.setServer(this);
mOrientationManager.lockOrientation();
int id=SnailSource.newId();
Path screenNailSetPath=SnailSource.getSetPath(id);
Path screenNailItemPath=SnailSource.getItemPath(id);
mScreenNailSet=(SnailAlbum)mActivity.getDataManager().getMediaObject(screenNailSetPath);
mScreenNailItem=(SnailItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
mScreenNailItem.setScreenNail(mAppBridge.attachScreenNail());
if (SecureSource.isSecurePath(mSetPathString)) {
mSecureAlbum=(SecureAlbum)mActivity.getDataManager().getMediaSet(mSetPathString);
mFlags|=FLAG_SHOW_WHEN_LOCKED;
}
mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
itemPath=screenNailItemPath;
}
MediaSet originalSet=mActivity.getDataManager().getMediaSet(mSetPathString);
mSelectionManager.setSourceMediaSet(originalSet);
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
mMediaSet=(FilterDeleteSet)mActivity.getDataManager().getMediaSet(mSetPathString);
mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
if (mMediaSet == null) {
Log.w(TAG,""String_Node_Str"" + mSetPathString);
}
if (itemPath == null) {
mMediaSet.reload();
if (mMediaSet.getMediaItemCount() > 0) {
itemPath=mMediaSet.getMediaItem(mCurrentIndex,1).get(0).getPath();
}
 else {
return;
}
}
PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0,mAppBridge == null ? false : mAppBridge.isPanorama(),mAppBridge == null ? false : mAppBridge.isStaticCamera());
mModel=pda;
mPhotoView.setModel(mModel);
pda.setDataListener(new PhotoDataAdapter.DataListener(){
@Override public void onPhotoChanged(int index,Path item){
mCurrentIndex=index;
if (item != null) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
updateBars();
}
@Override public void onLoadingFinished(){
if (!mModel.isEmpty()) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
 else if (mIsActive) {
if (mMediaSet.getNumberOfDeletions() == 0) {
mActivity.getStateManager().finishState(PhotoPage.this);
}
}
}
@Override public void onLoadingStarted(){
}
}
);
}
 else {
MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
mPhotoView.setModel(mModel);
updateCurrentPhoto(mediaItem);
}
mPhotoView.setFilmMode(mStartInFilmstrip && mMediaSet.getMediaItemCount() > 1);
setupEditButton();
}","@Override public void onCreate(Bundle data,Bundle restoreState){
  super.onCreate(data,restoreState);
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mActivity.getGLRoot().setOrientationSource(mOrientationManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_REFRESH_GRID_BUTTON:
{
        setGridButtonVisibility(mPhotoView.getFilmMode());
        break;
      }
case MSG_REFRESH_EDIT_BUTTON:
{
      refreshEditButton();
      break;
    }
case MSG_LOCK_ORIENTATION:
{
    mOrientationManager.lockOrientation();
    break;
  }
case MSG_UNLOCK_ORIENTATION:
{
  mOrientationManager.unlockOrientation();
  break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
mOriginalSetPathString=mSetPathString;
mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity.getAndroidContext());
String itemPathString=data.getString(KEY_MEDIA_ITEM_PATH);
Path itemPath=itemPathString != null ? Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH)) : null;
mTreatBackAsUp=data.getBoolean(KEY_TREAT_BACK_AS_UP,false);
mStartInFilmstrip=data.getBoolean(KEY_START_IN_FILMSTRIP,false);
mStartedFromAlbumPage=data.getInt(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE) == MSG_ALBUMPAGE_STARTED;
setGridButtonVisibility(!mStartedFromAlbumPage);
if (mSetPathString != null) {
mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
if (mAppBridge != null) {
mFlags|=FLAG_HIDE_ACTION_BAR | FLAG_HIDE_STATUS_BAR;
mShowBars=false;
mAppBridge.setServer(this);
mOrientationManager.lockOrientation();
int id=SnailSource.newId();
Path screenNailSetPath=SnailSource.getSetPath(id);
Path screenNailItemPath=SnailSource.getItemPath(id);
mScreenNailSet=(SnailAlbum)mActivity.getDataManager().getMediaObject(screenNailSetPath);
mScreenNailItem=(SnailItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
mScreenNailItem.setScreenNail(mAppBridge.attachScreenNail());
if (SecureSource.isSecurePath(mSetPathString)) {
mSecureAlbum=(SecureAlbum)mActivity.getDataManager().getMediaSet(mSetPathString);
mFlags|=FLAG_SHOW_WHEN_LOCKED;
}
mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
itemPath=screenNailItemPath;
}
MediaSet originalSet=mActivity.getDataManager().getMediaSet(mSetPathString);
mSelectionManager.setSourceMediaSet(originalSet);
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
mMediaSet=(FilterDeleteSet)mActivity.getDataManager().getMediaSet(mSetPathString);
mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
if (mMediaSet == null) {
Log.w(TAG,""String_Node_Str"" + mSetPathString);
}
if (itemPath == null) {
if (mMediaSet.getMediaItemCount() > 0) {
itemPath=mMediaSet.getMediaItem(mCurrentIndex,1).get(0).getPath();
}
 else {
return;
}
}
PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0,mAppBridge == null ? false : mAppBridge.isPanorama(),mAppBridge == null ? false : mAppBridge.isStaticCamera());
mModel=pda;
mPhotoView.setModel(mModel);
pda.setDataListener(new PhotoDataAdapter.DataListener(){
@Override public void onPhotoChanged(int index,Path item){
mCurrentIndex=index;
if (item != null) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
updateBars();
}
@Override public void onLoadingFinished(){
if (!mModel.isEmpty()) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
 else if (mIsActive) {
if (mMediaSet.getNumberOfDeletions() == 0) {
mActivity.getStateManager().finishState(PhotoPage.this);
}
}
}
@Override public void onLoadingStarted(){
}
}
);
}
 else {
MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
mPhotoView.setModel(mModel);
updateCurrentPhoto(mediaItem);
}
mPhotoView.setFilmMode(mStartInFilmstrip && mMediaSet.getMediaItemCount() > 1);
setupEditButton();
}","The original code contained an unnecessary `mMediaSet.reload()` call before checking for media item availability, which could lead to redundant reloading and potential performance issues. In the fixed code, this line was removed, and the condition for checking media item count was simplified to directly access the first item if available. This optimization reduces unnecessary method calls, improves code efficiency, and ensures a more streamlined approach to handling media set loading and item retrieval."
38616,"public FilterDeleteSet(Path path,MediaSet baseSet){
  super(path,INVALID_DATA_VERSION);
  mBaseSet=baseSet;
  mBaseSet.addContentListener(this);
}","public FilterDeleteSet(Path path,MediaSet baseSet){
  super(path,INVALID_DATA_VERSION);
  mBaseSet=baseSet;
  mBaseSet.addContentListener(this);
  mMediaItemCount=mBaseSet.getMediaItemCount() - mCurrent.size();
}","The original code failed to initialize `mMediaItemCount`, leaving it in an undefined state. The fixed code adds a line to calculate `mMediaItemCount` by subtracting the size of `mCurrent` from the total media items in the base set, ensuring accurate item tracking. This correction provides a precise count of media items, preventing potential counting errors and improving the set's data integrity."
38617,"private void prepareAnimationBackToFilmstrip(int slotIndex){
  prepareFadeOutTexture();
  TransitionStore transitions=mActivity.getTransitionStore();
  transitions.put(PhotoPage.KEY_INDEX_HINT,slotIndex);
  transitions.put(PhotoPage.KEY_MEDIA_ITEM_PATH,mAlbumDataAdapter.get(slotIndex).getPath());
  transitions.put(PhotoPage.KEY_OPEN_ANIMATION_RECT,getSlotRect(slotIndex));
}","private void prepareAnimationBackToFilmstrip(int slotIndex){
  if (!mAlbumDataAdapter.isActive(slotIndex))   return;
  prepareFadeOutTexture();
  TransitionStore transitions=mActivity.getTransitionStore();
  transitions.put(PhotoPage.KEY_INDEX_HINT,slotIndex);
  transitions.put(PhotoPage.KEY_MEDIA_ITEM_PATH,mAlbumDataAdapter.get(slotIndex).getPath());
  transitions.put(PhotoPage.KEY_OPEN_ANIMATION_RECT,getSlotRect(slotIndex));
}","The original code lacks a crucial validation check, potentially causing null pointer exceptions or accessing invalid array indices when the slot index is out of bounds. The fixed code adds an `isActive()` check to verify the slot's validity before proceeding with animation preparation, ensuring that only valid and active media items are processed. This defensive programming approach prevents runtime errors and improves the method's robustness by gracefully handling edge cases."
38618,"private void prepareAnimationBackToFilmstrip(int slotIndex){
  if (!mAlbumDataAdapter.isActive(slotIndex))   return;
  prepareFadeOutTexture();
  TransitionStore transitions=mActivity.getTransitionStore();
  transitions.put(PhotoPage.KEY_INDEX_HINT,slotIndex);
  transitions.put(PhotoPage.KEY_MEDIA_ITEM_PATH,mAlbumDataAdapter.get(slotIndex).getPath());
  transitions.put(PhotoPage.KEY_OPEN_ANIMATION_RECT,getSlotRect(slotIndex));
}","private void prepareAnimationBackToFilmstrip(int slotIndex){
  if (mAlbumDataAdapter == null || !mAlbumDataAdapter.isActive(slotIndex))   return;
  prepareFadeOutTexture();
  TransitionStore transitions=mActivity.getTransitionStore();
  transitions.put(PhotoPage.KEY_INDEX_HINT,slotIndex);
  transitions.put(PhotoPage.KEY_MEDIA_ITEM_PATH,mAlbumDataAdapter.get(slotIndex).getPath());
  transitions.put(PhotoPage.KEY_OPEN_ANIMATION_RECT,getSlotRect(slotIndex));
}","The original code lacks a null check for mAlbumDataAdapter, which could cause a NullPointerException if the adapter is not initialized. The fixed code adds a null check before accessing the adapter, ensuring that mAlbumDataAdapter exists before calling its methods. This modification prevents potential runtime crashes and makes the method more robust by safely handling scenarios where the adapter might be uninitialized."
38619,"@Override protected void onResume(){
  super.onResume();
  transitionFromAlbumPageIfNeeded();
  mActivity.getGLRoot().freeze();
  mIsActive=true;
  setContentPane(mRootPane);
  mModel.resume();
  mPhotoView.resume();
  mActionBar.setDisplayOptions(((mSecureAlbum == null) && (mSetPathString != null)),true);
  mActionBar.addOnMenuVisibilityListener(mMenuVisibilityListener);
  if (mAppBridge != null && !mHasActivityResult) {
    mPhotoView.resetToFirstPicture();
  }
  mHasActivityResult=false;
  mHandler.sendEmptyMessageDelayed(MSG_UNFREEZE_GLROOT,UNFREEZE_GLROOT_TIMEOUT);
}","@Override protected void onResume(){
  super.onResume();
  if (mModel == null) {
    mActivity.getStateManager().finishState(this);
    return;
  }
  transitionFromAlbumPageIfNeeded();
  mActivity.getGLRoot().freeze();
  mIsActive=true;
  setContentPane(mRootPane);
  mModel.resume();
  mPhotoView.resume();
  mActionBar.setDisplayOptions(((mSecureAlbum == null) && (mSetPathString != null)),true);
  mActionBar.addOnMenuVisibilityListener(mMenuVisibilityListener);
  if (mAppBridge != null && !mHasActivityResult) {
    mPhotoView.resetToFirstPicture();
  }
  mHasActivityResult=false;
  mHandler.sendEmptyMessageDelayed(MSG_UNFREEZE_GLROOT,UNFREEZE_GLROOT_TIMEOUT);
}","The original code lacks a null check for `mModel`, which could lead to a potential null pointer exception if the model is not initialized. The fixed code adds a null check that gracefully exits the method by finishing the current state if `mModel` is null, preventing unexpected crashes. This defensive programming approach ensures robust error handling and improves the method's reliability by safely managing uninitialized model scenarios."
38620,"@Override public void onPause(){
  super.onPause();
  mIsActive=false;
  mActivity.getGLRoot().unfreeze();
  mHandler.removeMessages(MSG_UNFREEZE_GLROOT);
  if (isFinishing())   preparePhotoFallbackView();
  DetailsHelper.pause();
  mPhotoView.pause();
  mModel.pause();
  mHandler.removeMessages(MSG_HIDE_BARS);
  mActionBar.removeOnMenuVisibilityListener(mMenuVisibilityListener);
  onCommitDeleteImage();
  mMenuExecutor.pause();
  if (mMediaSet != null)   mMediaSet.clearDeletion();
}","@Override public void onPause(){
  super.onPause();
  mIsActive=false;
  mActivity.getGLRoot().unfreeze();
  mHandler.removeMessages(MSG_UNFREEZE_GLROOT);
  DetailsHelper.pause();
  if (mModel != null) {
    if (isFinishing())     preparePhotoFallbackView();
    mModel.pause();
  }
  mPhotoView.pause();
  mHandler.removeMessages(MSG_HIDE_BARS);
  mActionBar.removeOnMenuVisibilityListener(mMenuVisibilityListener);
  onCommitDeleteImage();
  mMenuExecutor.pause();
  if (mMediaSet != null)   mMediaSet.clearDeletion();
}",The original code risked a NullPointerException by calling methods on `mModel` without first checking if it was null. The fixed code adds a null check for `mModel` before calling `pause()` and moves the `isFinishing()` check inside this conditional block to ensure safe method invocation. This change prevents potential runtime crashes and improves the robustness of the method by safely handling scenarios where `mModel` might be uninitialized.
38621,"@Override public void onCreate(Bundle data,Bundle restoreState){
  super.onCreate(data,restoreState);
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mActivity.getGLRoot().setOrientationSource(mOrientationManager);
  mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
  mOriginalSetPathString=mSetPathString;
  mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity.getAndroidContext());
  String itemPathString=data.getString(KEY_MEDIA_ITEM_PATH);
  Path itemPath=itemPathString != null ? Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH)) : null;
  mTreatBackAsUp=data.getBoolean(KEY_TREAT_BACK_AS_UP,false);
  mStartInFilmstrip=data.getBoolean(KEY_START_IN_FILMSTRIP,false);
  mStartedFromAlbumPage=data.getInt(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE) == MSG_ALBUMPAGE_STARTED;
  setGridButtonVisibility(!mStartedFromAlbumPage);
  if (mSetPathString != null) {
    mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
    if (mAppBridge != null) {
      mFlags|=FLAG_HIDE_ACTION_BAR | FLAG_HIDE_STATUS_BAR;
      mShowBars=false;
      mAppBridge.setServer(this);
      mOrientationManager.lockOrientation();
      int id=SnailSource.newId();
      Path screenNailSetPath=SnailSource.getSetPath(id);
      Path screenNailItemPath=SnailSource.getItemPath(id);
      mScreenNailSet=(SnailAlbum)mActivity.getDataManager().getMediaObject(screenNailSetPath);
      mScreenNailItem=(SnailItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
      mScreenNailItem.setScreenNail(mAppBridge.attachScreenNail());
      if (SecureSource.isSecurePath(mSetPathString)) {
        mSecureAlbum=(SecureAlbum)mActivity.getDataManager().getMediaSet(mSetPathString);
        mFlags|=FLAG_SHOW_WHEN_LOCKED;
      }
      mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
      itemPath=screenNailItemPath;
    }
    MediaSet originalSet=mActivity.getDataManager().getMediaSet(mSetPathString);
    mSelectionManager.setSourceMediaSet(originalSet);
    mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
    mMediaSet=(FilterDeleteSet)mActivity.getDataManager().getMediaSet(mSetPathString);
    mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
    if (mMediaSet == null) {
      Log.w(TAG,""String_Node_Str"" + mSetPathString);
    }
    if (itemPath == null) {
      itemPath=mMediaSet.getMediaItem(mCurrentIndex,1).get(0).getPath();
    }
    PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0,mAppBridge == null ? false : mAppBridge.isPanorama(),mAppBridge == null ? false : mAppBridge.isStaticCamera());
    mModel=pda;
    mPhotoView.setModel(mModel);
    pda.setDataListener(new PhotoDataAdapter.DataListener(){
      @Override public void onPhotoChanged(      int index,      Path item){
        mCurrentIndex=index;
        if (item != null) {
          MediaItem photo=mModel.getMediaItem(0);
          if (photo != null)           updateCurrentPhoto(photo);
        }
        updateBars();
      }
      @Override public void onLoadingFinished(){
        if (!mModel.isEmpty()) {
          MediaItem photo=mModel.getMediaItem(0);
          if (photo != null)           updateCurrentPhoto(photo);
        }
 else         if (mIsActive) {
          if (mMediaSet.getNumberOfDeletions() == 0) {
            mActivity.getStateManager().finishState(PhotoPage.this);
          }
        }
      }
      @Override public void onLoadingStarted(){
      }
    }
);
  }
 else {
    MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
    mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
    mPhotoView.setModel(mModel);
    updateCurrentPhoto(mediaItem);
  }
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_REFRESH_GRID_BUTTON:
{
        setGridButtonVisibility(mPhotoView.getFilmMode());
        break;
      }
case MSG_REFRESH_EDIT_BUTTON:
{
      refreshEditButton();
      break;
    }
case MSG_LOCK_ORIENTATION:
{
    mOrientationManager.lockOrientation();
    break;
  }
case MSG_UNLOCK_ORIENTATION:
{
  mOrientationManager.unlockOrientation();
  break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
mPhotoView.setFilmMode(mStartInFilmstrip);
setupEditButton();
}","@Override public void onCreate(Bundle data,Bundle restoreState){
  super.onCreate(data,restoreState);
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mActivity.getGLRoot().setOrientationSource(mOrientationManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_REFRESH_GRID_BUTTON:
{
        setGridButtonVisibility(mPhotoView.getFilmMode());
        break;
      }
case MSG_REFRESH_EDIT_BUTTON:
{
      refreshEditButton();
      break;
    }
case MSG_LOCK_ORIENTATION:
{
    mOrientationManager.lockOrientation();
    break;
  }
case MSG_UNLOCK_ORIENTATION:
{
  mOrientationManager.unlockOrientation();
  break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
case MSG_WANT_BARS:
{
wantBars();
break;
}
case MSG_UNFREEZE_GLROOT:
{
mActivity.getGLRoot().unfreeze();
break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
mOriginalSetPathString=mSetPathString;
mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity.getAndroidContext());
String itemPathString=data.getString(KEY_MEDIA_ITEM_PATH);
Path itemPath=itemPathString != null ? Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH)) : null;
mTreatBackAsUp=data.getBoolean(KEY_TREAT_BACK_AS_UP,false);
mStartInFilmstrip=data.getBoolean(KEY_START_IN_FILMSTRIP,false);
mStartedFromAlbumPage=data.getInt(KEY_ALBUMPAGE_TRANSITION,MSG_ALBUMPAGE_NONE) == MSG_ALBUMPAGE_STARTED;
setGridButtonVisibility(!mStartedFromAlbumPage);
if (mSetPathString != null) {
mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
if (mAppBridge != null) {
mFlags|=FLAG_HIDE_ACTION_BAR | FLAG_HIDE_STATUS_BAR;
mShowBars=false;
mAppBridge.setServer(this);
mOrientationManager.lockOrientation();
int id=SnailSource.newId();
Path screenNailSetPath=SnailSource.getSetPath(id);
Path screenNailItemPath=SnailSource.getItemPath(id);
mScreenNailSet=(SnailAlbum)mActivity.getDataManager().getMediaObject(screenNailSetPath);
mScreenNailItem=(SnailItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
mScreenNailItem.setScreenNail(mAppBridge.attachScreenNail());
if (SecureSource.isSecurePath(mSetPathString)) {
mSecureAlbum=(SecureAlbum)mActivity.getDataManager().getMediaSet(mSetPathString);
mFlags|=FLAG_SHOW_WHEN_LOCKED;
}
mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
itemPath=screenNailItemPath;
}
MediaSet originalSet=mActivity.getDataManager().getMediaSet(mSetPathString);
mSelectionManager.setSourceMediaSet(originalSet);
mSetPathString=""String_Node_Str"" + mSetPathString + ""String_Node_Str"";
mMediaSet=(FilterDeleteSet)mActivity.getDataManager().getMediaSet(mSetPathString);
mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
if (mMediaSet == null) {
Log.w(TAG,""String_Node_Str"" + mSetPathString);
}
if (itemPath == null) {
mMediaSet.reload();
if (mMediaSet.getMediaItemCount() > 0) {
itemPath=mMediaSet.getMediaItem(mCurrentIndex,1).get(0).getPath();
}
 else {
return;
}
}
PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0,mAppBridge == null ? false : mAppBridge.isPanorama(),mAppBridge == null ? false : mAppBridge.isStaticCamera());
mModel=pda;
mPhotoView.setModel(mModel);
pda.setDataListener(new PhotoDataAdapter.DataListener(){
@Override public void onPhotoChanged(int index,Path item){
mCurrentIndex=index;
if (item != null) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
updateBars();
}
@Override public void onLoadingFinished(){
if (!mModel.isEmpty()) {
MediaItem photo=mModel.getMediaItem(0);
if (photo != null) updateCurrentPhoto(photo);
}
 else if (mIsActive) {
if (mMediaSet.getNumberOfDeletions() == 0) {
mActivity.getStateManager().finishState(PhotoPage.this);
}
}
}
@Override public void onLoadingStarted(){
}
}
);
}
 else {
MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
mPhotoView.setModel(mModel);
updateCurrentPhoto(mediaItem);
}
mPhotoView.setFilmMode(mStartInFilmstrip);
setupEditButton();
}","The original code lacked proper error handling when accessing media set items, potentially causing null pointer exceptions or index out-of-bounds errors. The fixed code adds a safety check by reloading the media set and verifying its item count before accessing items, and includes a return statement if no items are available. This modification enhances the code's robustness by preventing potential runtime crashes and ensuring more graceful handling of empty or incomplete media sets."
38622,"@Override protected boolean onItemSelected(MenuItem item){
  refreshHidingMessage();
  MediaItem current=mModel.getMediaItem(0);
  if (current == null) {
    return true;
  }
  int currentIndex=mModel.getCurrentIndex();
  Path path=current.getPath();
  DataManager manager=mActivity.getDataManager();
  int action=item.getItemId();
  String confirmMsg=null;
switch (action) {
case android.R.id.home:
{
      onUpPressed();
      return true;
    }
case R.id.action_grid:
{
    if (mStartedFromAlbumPage) {
      onUpPressed();
    }
 else {
      preparePhotoFallbackView();
      Bundle data=new Bundle(getData());
      data.putString(AlbumPage.KEY_MEDIA_PATH,mOriginalSetPathString);
      data.putString(AlbumPage.KEY_PARENT_MEDIA_PATH,mActivity.getDataManager().getTopSetPath(DataManager.INCLUDE_ALL));
      mActivity.getTransitionStore().put(KEY_RETURN_INDEX_HINT,mCurrentIndex);
      mActivity.getStateManager().startState(AlbumPage.class,data);
    }
    return true;
  }
case R.id.action_slideshow:
{
  Bundle data=new Bundle();
  data.putString(SlideshowPage.KEY_SET_PATH,mMediaSet.getPath().toString());
  data.putString(SlideshowPage.KEY_ITEM_PATH,path.toString());
  data.putInt(SlideshowPage.KEY_PHOTO_INDEX,currentIndex);
  data.putBoolean(SlideshowPage.KEY_REPEAT,true);
  mActivity.getStateManager().startStateForResult(SlideshowPage.class,REQUEST_SLIDESHOW,data);
  return true;
}
case R.id.action_crop:
{
Activity activity=mActivity;
Intent intent=new Intent(CropImage.CROP_ACTION);
intent.setClass(activity,CropImage.class);
intent.setData(manager.getContentUri(path));
activity.startActivityForResult(intent,PicasaSource.isPicasaImage(current) ? REQUEST_CROP_PICASA : REQUEST_CROP);
return true;
}
case R.id.action_trim:
{
Intent intent=new Intent(mActivity,TrimVideo.class);
intent.setData(manager.getContentUri(path));
mActivity.startActivityForResult(intent,REQUEST_TRIM);
return true;
}
case R.id.action_edit:
{
launchPhotoEditor();
return true;
}
case R.id.action_details:
{
if (mShowDetails) {
hideDetails();
}
 else {
showDetails();
}
return true;
}
case R.id.action_delete:
confirmMsg=mActivity.getResources().getQuantityString(R.plurals.delete_selection,1);
case R.id.action_setas:
case R.id.action_rotate_ccw:
case R.id.action_rotate_cw:
case R.id.action_show_on_map:
mSelectionManager.deSelectAll();
mSelectionManager.toggle(path);
mMenuExecutor.onMenuClicked(item,confirmMsg,mConfirmDialogListener);
return true;
case R.id.action_import:
mSelectionManager.deSelectAll();
mSelectionManager.toggle(path);
mMenuExecutor.onMenuClicked(item,confirmMsg,new ImportCompleteListener(mActivity));
return true;
case R.id.action_share:
Activity activity=mActivity;
Intent intent=createShareIntent(mCurrentPhoto.getPath());
activity.startActivity(Intent.createChooser(intent,activity.getString(R.string.share)));
return true;
default :
return false;
}
}","@Override protected boolean onItemSelected(MenuItem item){
  if (mModel == null)   return true;
  refreshHidingMessage();
  MediaItem current=mModel.getMediaItem(0);
  if (current == null) {
    return true;
  }
  int currentIndex=mModel.getCurrentIndex();
  Path path=current.getPath();
  DataManager manager=mActivity.getDataManager();
  int action=item.getItemId();
  String confirmMsg=null;
switch (action) {
case android.R.id.home:
{
      onUpPressed();
      return true;
    }
case R.id.action_grid:
{
    if (mStartedFromAlbumPage) {
      onUpPressed();
    }
 else {
      preparePhotoFallbackView();
      Bundle data=new Bundle(getData());
      data.putString(AlbumPage.KEY_MEDIA_PATH,mOriginalSetPathString);
      data.putString(AlbumPage.KEY_PARENT_MEDIA_PATH,mActivity.getDataManager().getTopSetPath(DataManager.INCLUDE_ALL));
      mActivity.getTransitionStore().put(KEY_RETURN_INDEX_HINT,mCurrentIndex);
      mActivity.getStateManager().startState(AlbumPage.class,data);
    }
    return true;
  }
case R.id.action_slideshow:
{
  Bundle data=new Bundle();
  data.putString(SlideshowPage.KEY_SET_PATH,mMediaSet.getPath().toString());
  data.putString(SlideshowPage.KEY_ITEM_PATH,path.toString());
  data.putInt(SlideshowPage.KEY_PHOTO_INDEX,currentIndex);
  data.putBoolean(SlideshowPage.KEY_REPEAT,true);
  mActivity.getStateManager().startStateForResult(SlideshowPage.class,REQUEST_SLIDESHOW,data);
  return true;
}
case R.id.action_crop:
{
Activity activity=mActivity;
Intent intent=new Intent(CropImage.CROP_ACTION);
intent.setClass(activity,CropImage.class);
intent.setData(manager.getContentUri(path));
activity.startActivityForResult(intent,PicasaSource.isPicasaImage(current) ? REQUEST_CROP_PICASA : REQUEST_CROP);
return true;
}
case R.id.action_trim:
{
Intent intent=new Intent(mActivity,TrimVideo.class);
intent.setData(manager.getContentUri(path));
mActivity.startActivityForResult(intent,REQUEST_TRIM);
return true;
}
case R.id.action_edit:
{
launchPhotoEditor();
return true;
}
case R.id.action_details:
{
if (mShowDetails) {
hideDetails();
}
 else {
showDetails();
}
return true;
}
case R.id.action_delete:
confirmMsg=mActivity.getResources().getQuantityString(R.plurals.delete_selection,1);
case R.id.action_setas:
case R.id.action_rotate_ccw:
case R.id.action_rotate_cw:
case R.id.action_show_on_map:
mSelectionManager.deSelectAll();
mSelectionManager.toggle(path);
mMenuExecutor.onMenuClicked(item,confirmMsg,mConfirmDialogListener);
return true;
case R.id.action_import:
mSelectionManager.deSelectAll();
mSelectionManager.toggle(path);
mMenuExecutor.onMenuClicked(item,confirmMsg,new ImportCompleteListener(mActivity));
return true;
case R.id.action_share:
Activity activity=mActivity;
Intent intent=createShareIntent(mCurrentPhoto.getPath());
activity.startActivity(Intent.createChooser(intent,activity.getString(R.string.share)));
return true;
default :
return false;
}
}","The original code lacks a null check for `mModel`, which could lead to a potential null pointer exception when accessing model-related methods. The fixed code adds an explicit null check for `mModel` at the beginning of the method, immediately returning `true` if the model is null. This defensive programming approach prevents unexpected crashes and ensures robust handling of scenarios where the model might not be initialized, improving the method's overall reliability and error resilience."
38623,"private void prepareAnimationBackToFilmstrip(int slotIndex){
  prepareFadeOutTexture();
  TransitionStore transitions=mActivity.getTransitionStore();
  transitions.put(PhotoPage.KEY_INDEX_HINT,slotIndex);
  transitions.put(PhotoPage.KEY_MEDIA_ITEM_PATH,mAlbumDataAdapter.get(slotIndex).getPath());
  transitions.put(PhotoPage.KEY_OPEN_ANIMATION_RECT,getSlotRect(slotIndex));
}","private void prepareAnimationBackToFilmstrip(int slotIndex){
  if (!mAlbumDataAdapter.isActive(slotIndex))   return;
  prepareFadeOutTexture();
  TransitionStore transitions=mActivity.getTransitionStore();
  transitions.put(PhotoPage.KEY_INDEX_HINT,slotIndex);
  transitions.put(PhotoPage.KEY_MEDIA_ITEM_PATH,mAlbumDataAdapter.get(slotIndex).getPath());
  transitions.put(PhotoPage.KEY_OPEN_ANIMATION_RECT,getSlotRect(slotIndex));
}","The original code lacks a null or validity check before accessing the album data adapter, risking potential null pointer exceptions or index out of bounds errors. The fixed code adds an `isActive(slotIndex)` check to verify the slot's validity before proceeding with the animation preparation. This defensive programming approach prevents runtime crashes and ensures the method only executes when the requested slot is valid and accessible."
38624,"public <T>T get(Object key,T valueIfNull){
  T value=get(key);
  return value == null ? valueIfNull : value;
}","@SuppressWarnings(""String_Node_Str"") public <T>T get(Object key,T valueIfNull){
  T value=(T)mStorage.get(key);
  return value == null ? valueIfNull : value;
}","The original code creates an infinite recursive call by invoking `get(key)` within its own method, causing a stack overflow error. The fixed code explicitly casts the result from `mStorage.get(key)` to the generic type `T` and retrieves the value from a separate storage object. This modification prevents recursive calls, ensures type-safe retrieval, and provides a reliable mechanism for returning a default value when the key is not found."
38625,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  requestWindowFeature(Window.FEATURE_ACTION_BAR);
  requestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);
  setContentView(R.layout.movie_view);
  View rootView=findViewById(R.id.movie_view_root);
  setSystemUiVisibility(rootView);
  Intent intent=getIntent();
  initializeActionBar(intent);
  mFinishOnCompletion=intent.getBooleanExtra(MediaStore.EXTRA_FINISH_ON_COMPLETION,true);
  mTreatUpAsBack=intent.getBooleanExtra(KEY_TREAT_UP_AS_BACK,false);
  mPlayer=new MoviePlayer(rootView,this,intent.getData(),savedInstanceState,!mFinishOnCompletion){
    @Override public void onCompletion(){
      if (mFinishOnCompletion) {
        finish();
      }
    }
  }
;
  if (intent.hasExtra(MediaStore.EXTRA_SCREEN_ORIENTATION)) {
    int orientation=intent.getIntExtra(MediaStore.EXTRA_SCREEN_ORIENTATION,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    if (orientation != getRequestedOrientation()) {
      setRequestedOrientation(orientation);
    }
  }
  Window win=getWindow();
  WindowManager.LayoutParams winParams=win.getAttributes();
  winParams.buttonBrightness=WindowManager.LayoutParams.BRIGHTNESS_OVERRIDE_OFF;
  winParams.flags|=WindowManager.LayoutParams.FLAG_FULLSCREEN;
  win.setAttributes(winParams);
  win.setBackgroundDrawable(null);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getSherlock().requestFeature(Window.FEATURE_ACTION_BAR);
  getSherlock().requestFeature(Window.FEATURE_ACTION_BAR_OVERLAY);
  setContentView(R.layout.movie_view);
  View rootView=findViewById(R.id.movie_view_root);
  setSystemUiVisibility(rootView);
  Intent intent=getIntent();
  initializeActionBar(intent);
  mFinishOnCompletion=intent.getBooleanExtra(MediaStore.EXTRA_FINISH_ON_COMPLETION,true);
  mTreatUpAsBack=intent.getBooleanExtra(KEY_TREAT_UP_AS_BACK,false);
  mPlayer=new MoviePlayer(rootView,this,intent.getData(),savedInstanceState,!mFinishOnCompletion){
    @Override public void onCompletion(){
      if (mFinishOnCompletion) {
        finish();
      }
    }
  }
;
  if (intent.hasExtra(MediaStore.EXTRA_SCREEN_ORIENTATION)) {
    int orientation=intent.getIntExtra(MediaStore.EXTRA_SCREEN_ORIENTATION,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    if (orientation != getRequestedOrientation()) {
      setRequestedOrientation(orientation);
    }
  }
  Window win=getWindow();
  WindowManager.LayoutParams winParams=win.getAttributes();
  winParams.buttonBrightness=WindowManager.LayoutParams.BRIGHTNESS_OVERRIDE_OFF;
  winParams.flags|=WindowManager.LayoutParams.FLAG_FULLSCREEN;
  win.setAttributes(winParams);
  win.setBackgroundDrawable(null);
}","The original code uses standard `requestWindowFeature()` method, which is not compatible with the Sherlock library for action bar features. The fixed code replaces this with `getSherlock().requestFeature()`, which correctly integrates action bar configuration when using the ActionBarSherlock framework. This modification ensures proper action bar initialization and maintains compatibility with the Sherlock library's implementation of window and feature management."
38626,"private PopupWindow createPopupWindow(){
  PopupWindow popup=new PopupWindow(mContext);
  popup.setOnDismissListener(mOnDismissListener);
  popup.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.menu_dropdown_panel_holo_dark));
  mContentList=new ListView(mContext);
  mContentList.setAdapter(new ItemDataAdapter());
  mContentList.setOnItemClickListener(mOnItemClickListener);
  popup.setContentView(mContentList);
  popup.setFocusable(true);
  popup.setOutsideTouchable(true);
  return popup;
}","private PopupWindow createPopupWindow(){
  PopupWindow popup=new PopupWindow(mContext);
  popup.setOnDismissListener(mOnDismissListener);
  popup.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.menu_dropdown_panel_holo_dark));
  mContentList=new ListView(mContext,null,com.actionbarsherlock.R.attr.dropDownListViewStyle);
  mContentList.setAdapter(new ItemDataAdapter());
  mContentList.setOnItemClickListener(mOnItemClickListener);
  popup.setContentView(mContentList);
  popup.setFocusable(true);
  popup.setOutsideTouchable(true);
  return popup;
}","The original code creates a ListView without specifying a default style, which can lead to inconsistent appearance and potential rendering issues across different Android versions. The fixed code adds a third parameter to the ListView constructor, using the `dropDownListViewStyle` from ActionBarSherlock to provide a consistent, platform-compatible styling. This modification ensures better visual consistency and adherence to Android design guidelines, improving the overall user interface and user experience."
38627,"@Override public void setHomeButtonEnabled(boolean enabled){
  mActionBar.setHomeButtonEnabled(enabled);
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void setHomeButtonEnabled(boolean enabled){
  if (ApiHelper.HAS_ACTION_BAR_SET_HOME_BUTTON_ENABLED) {
    mActionBar.setHomeButtonEnabled(enabled);
  }
}","The original code directly calls `setHomeButtonEnabled()` without checking API compatibility, which could cause runtime crashes on older Android versions. The fixed code adds an API level check using `@TargetApi` and `ApiHelper.HAS_ACTION_BAR_SET_HOME_BUTTON_ENABLED` to conditionally execute the method only on supported Android versions. This approach ensures graceful handling across different Android API levels, preventing potential method unavailability errors and improving the app's overall compatibility and stability."
38628,"@Override public void setLogo(Drawable logo){
  mActionBar.setLogo(logo);
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void setLogo(Drawable logo){
  if (ApiHelper.HAS_ACTION_BAR_SET_LOGO) {
    mActionBar.setLogo(logo);
  }
}","The original code lacks compatibility checks, potentially causing runtime crashes on devices with older Android versions that do not support the `setLogo()` method. The fixed code adds an API level annotation and a conditional check using `ApiHelper.HAS_ACTION_BAR_SET_LOGO` to ensure the method is only called on supported Android versions. This approach prevents potential `NoSuchMethodError` exceptions and provides graceful handling across different Android API levels."
38629,"@Override public void setShareIntent(Intent intent){
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(intent != null);
  }
  if (mShareActionProvider != null) {
    mShareActionProvider.setShareIntent(intent);
  }
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void setShareIntent(Intent intent){
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(intent != null);
    if (ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
      mShareActionProvider.get().setShareIntent(intent);
    }
  }
}","The original code potentially causes a null pointer exception when accessing mShareActionProvider without first checking its existence or API compatibility. The fixed code adds an API-level check with ApiHelper.HAS_SHARE_ACTION_PROVIDER and uses a safe getter method for mShareActionProvider, ensuring compatibility across different Android versions. This approach prevents runtime crashes and provides more robust handling of share intent configuration across diverse Android device ecosystems."
38630,"public SystemActionBarWrapper(Activity activity){
  mActivity=activity;
  mActionBar=activity.getActionBar();
}","@TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public SystemActionBarWrapper(Activity activity){
  mActivity=activity;
  mActionBar=activity.getActionBar();
  if (ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
    mShareActionProvider.set(new ShareActionProvider(activity));
  }
}","The original code lacks proper API version checking and initialization of the ShareActionProvider, which could cause runtime compatibility issues on different Android versions. The fixed code adds the @TargetApi annotation and includes a conditional check using ApiHelper to safely initialize the ShareActionProvider only on supported Android versions. This approach ensures graceful handling of action bar features across various Android API levels, preventing potential crashes and improving the app's robustness."
38631,"@Override public boolean createActionMenu(Menu menu,int menuRes){
  mActivity.getMenuInflater().inflate(menuRes,menu);
  mMenu=menu;
  mShareMenuItem=menu.findItem(R.id.action_share);
  if (mShareMenuItem != null) {
    mShareActionProvider=new ShareActionProvider(mActivity);
    mShareMenuItem.setActionProvider(mShareActionProvider);
  }
  return true;
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public boolean createActionMenu(Menu menu,int menuRes){
  mActivity.getMenuInflater().inflate(menuRes,menu);
  mMenu=menu;
  mShareMenuItem=menu.findItem(R.id.action_share);
  if (mShareMenuItem != null && ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
    mShareMenuItem.setActionProvider(mShareActionProvider.get());
  }
  return true;
}","The original code directly instantiates ShareActionProvider without checking API compatibility, which could cause runtime errors on older Android versions. The fixed code adds an API-level check using ApiHelper.HAS_SHARE_ACTION_PROVIDER and uses a .get() method to safely retrieve the ShareActionProvider, ensuring graceful handling across different Android versions. This approach prevents potential crashes and provides a more robust implementation that maintains backward compatibility while supporting newer Android features."
38632,"@Override public void inflateMenu(int menuRes){
  Utils.assertTrue(mMenu != null);
  mActionMode.getMenuInflater().inflate(menuRes,mMenu);
  mShareMenuItem=mMenu.findItem(R.id.action_share);
  if (mShareMenuItem != null) {
    mShareMenuItem.setActionProvider(mShareActionProvider);
  }
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void inflateMenu(int menuRes){
  Utils.assertTrue(mMenu != null);
  mActionMode.getMenuInflater().inflate(menuRes,mMenu);
  mShareMenuItem=mMenu.findItem(R.id.action_share);
  if (mShareMenuItem != null && ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
    mShareMenuItem.setActionProvider(mShareActionProvider.get());
  }
}","The original code assumes universal support for share action providers without version checking, which could cause runtime errors on older Android versions. The fixed code adds an API level annotation and checks for share action provider availability using ApiHelper, ensuring safe method invocation across different Android versions. This approach prevents potential crashes and provides more robust, version-aware menu inflation with conditional share action provider setup."
38633,"@Override public void setOnShareTargetSelectedListener(final OnShareTargetSelectedListener listener){
  mShareActionProvider.setOnShareTargetSelectedListener(new ShareActionProvider.OnShareTargetSelectedListener(){
    @Override public boolean onShareTargetSelected(    ShareActionProvider source,    Intent intent){
      return listener.onShareTargetSelected(intent);
    }
  }
);
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void setOnShareTargetSelectedListener(final OnShareTargetSelectedListener listener){
  if (mShareActionProvider.get() == null)   return;
  mShareActionProvider.get().setOnShareTargetSelectedListener(new ShareActionProvider.OnShareTargetSelectedListener(){
    @Override public boolean onShareTargetSelected(    ShareActionProvider source,    Intent intent){
      return listener.onShareTargetSelected(intent);
    }
  }
);
}","The original code lacks a null check on mShareActionProvider, which could lead to potential null pointer exceptions when setting the share target listener. The fixed code adds a null check using mShareActionProvider.get() and includes the @TargetApi annotation for API compatibility, ensuring safe method invocation. By adding these safeguards, the code becomes more robust, preventing crashes and improving overall reliability when working with share action providers."
38634,"public SystemActionModeWrapper(Activity activity,ActionModeInterface.Callback callback){
  mShareActionProvider=new ShareActionProvider(activity);
  activity.startActionMode(new CallbackWrapper(callback));
}","@TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public SystemActionModeWrapper(Activity activity,ActionModeInterface.Callback callback){
  if (ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
    mShareActionProvider.set(new ShareActionProvider(activity));
  }
  activity.startActionMode(new CallbackWrapper(callback));
}","The original code lacks a version check for ShareActionProvider, which could cause runtime errors on devices with incompatible Android versions. The fixed code adds an API level annotation and a conditional check using ApiHelper to ensure ShareActionProvider is only instantiated on supported Android versions. This approach prevents potential crashes and makes the code more robust across different Android device versions."
38635,"@Override public void setShareIntent(Intent shareIntent){
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(shareIntent != null);
    mShareActionProvider.setShareIntent(shareIntent);
  }
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void setShareIntent(Intent shareIntent){
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(shareIntent != null);
    if (ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
      mShareActionProvider.get().setShareIntent(shareIntent);
    }
  }
}",The original code directly calls `setShareIntent()` without checking if the share action provider is available on the current Android version. The fixed code adds a version check using `ApiHelper.HAS_SHARE_ACTION_PROVIDER` and uses a safe getter method to access the share action provider before setting the intent. This approach prevents potential runtime crashes on older Android versions and ensures graceful handling of share functionality across different API levels.
38636,"public void updateSupportedOperation(){
  if (mMenuTask != null) {
    mMenuTask.cancel();
  }
  updateSelectionMenu();
  final boolean hasShareButton=mActionMode.hasShareButton();
  if (hasShareButton)   mActionMode.setShareIntent(null);
  mMenuTask=mActivity.getThreadPool().submit(new Job<Void>(){
    @Override public Void run(    final JobContext jc){
      final int operation=computeMenuOptions(jc);
      final Intent intent=hasShareButton ? computeSharingIntent(jc) : null;
      mMainHandler.post(new Runnable(){
        @Override public void run(){
          mMenuTask=null;
          if (!jc.isCancelled()) {
            MenuExecutor.updateMenuOperation(mActionMode,operation);
            if (hasShareButton) {
              mActionMode.setShareIntent(intent);
            }
          }
        }
      }
);
      return null;
    }
  }
);
}","public void updateSupportedOperation(){
  if (mMenuTask != null) {
    mMenuTask.cancel();
  }
  updateSelectionMenu();
  final boolean hasShareButton=mActionMode.hasShareButton();
  if (hasShareButton)   mActionMode.setShareIntent(null);
  mMenuTask=mActivity.getThreadPool().submit(new Job<Void>(){
    @Override public Void run(    final JobContext jc){
      final int operation=computeMenuOptions(jc);
      final Intent intent=hasShareButton ? computeSharingIntent(jc) : null;
      mMainHandler.post(new Runnable(){
        @Override public void run(){
          mMenuTask=null;
          if (!jc.isCancelled()) {
            MenuExecutor.updateMenuOperation(mActionMode,operation);
            if (hasShareButton) {
              mActionMode.setShareIntent(intent);
              mMenuExecutor.setShareIntent(intent);
            }
          }
        }
      }
);
      return null;
    }
  }
);
}","The original code lacked a crucial method call to set the share intent on the menu executor, potentially leaving the share functionality incomplete. The fixed code adds `mMenuExecutor.setShareIntent(intent)` within the same conditional block that sets the share intent on the action mode, ensuring consistent share intent propagation. This modification guarantees that both the action mode and menu executor are synchronized with the latest sharing intent, improving the overall sharing mechanism's reliability."
38637,"@Override public void run(){
  mMenuTask=null;
  if (!jc.isCancelled()) {
    MenuExecutor.updateMenuOperation(mActionMode,operation);
    if (hasShareButton) {
      mActionMode.setShareIntent(intent);
    }
  }
}","@Override public void run(){
  mMenuTask=null;
  if (!jc.isCancelled()) {
    MenuExecutor.updateMenuOperation(mActionMode,operation);
    if (hasShareButton) {
      mActionMode.setShareIntent(intent);
      mMenuExecutor.setShareIntent(intent);
    }
  }
}","The original code failed to set the share intent for the menu executor, potentially leaving the share functionality incomplete. The fixed code adds `mMenuExecutor.setShareIntent(intent)`, ensuring that the share intent is properly configured for both the action mode and menu executor. This change guarantees consistent share intent handling across different components, improving the overall reliability of the sharing mechanism."
38638,"@Override public void setHomeButtonEnabled(boolean enabled){
  mActionBar.setHomeButtonEnabled(enabled);
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void setHomeButtonEnabled(boolean enabled){
  if (ApiHelper.HAS_ACTION_BAR_SET_HOME_BUTTON_ENABLED) {
    mActionBar.setHomeButtonEnabled(enabled);
  }
}","The original code directly calls `setHomeButtonEnabled()` without checking API compatibility, which can cause runtime crashes on older Android versions. The fixed code adds an `@TargetApi` annotation and wraps the method call inside a conditional check using `ApiHelper.HAS_ACTION_BAR_SET_HOME_BUTTON_ENABLED`, ensuring the method is only invoked on supported API levels. This approach prevents potential NoSuchMethodError exceptions and provides graceful handling across different Android platform versions."
38639,"@Override public void setLogo(Drawable logo){
  mActionBar.setLogo(logo);
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void setLogo(Drawable logo){
  if (ApiHelper.HAS_ACTION_BAR_SET_LOGO) {
    mActionBar.setLogo(logo);
  }
}","The original code assumes all Android versions support setting an action bar logo, which can cause runtime crashes on older devices. The fixed code adds an API level check using `@TargetApi` and conditionally calls `setLogo()` only when the device supports this feature through `ApiHelper.HAS_ACTION_BAR_SET_LOGO`. This approach prevents potential NoSuchMethodError exceptions and ensures graceful handling across different Android API versions."
38640,"@Override public void setShareIntent(Intent intent){
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(intent != null);
  }
  if (mShareActionProvider != null) {
    mShareActionProvider.setShareIntent(intent);
  }
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void setShareIntent(Intent intent){
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(intent != null);
    if (ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
      mShareActionProvider.get().setShareIntent(intent);
    }
  }
}","The original code could cause a null pointer exception if `mShareActionProvider` is not null but `mShareMenuItem` is null. The fixed code adds a null check for `mShareMenuItem` and uses `ApiHelper.HAS_SHARE_ACTION_PROVIDER` to conditionally call `setShareIntent()`, ensuring safe method invocation across different Android API levels. This approach prevents potential runtime crashes and provides more robust handling of share intent configuration."
38641,"public SystemActionBarWrapper(Activity activity){
  mActivity=activity;
  mActionBar=activity.getActionBar();
}","@TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public SystemActionBarWrapper(Activity activity){
  mActivity=activity;
  mActionBar=activity.getActionBar();
  if (ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
    mShareActionProvider.set(new ShareActionProvider(activity));
  }
}","The original code lacks proper API version handling and does not initialize the ShareActionProvider for compatibility with newer Android versions. The fixed code adds the @TargetApi annotation and conditionally sets up the ShareActionProvider using ApiHelper, ensuring safe implementation across different Android API levels. This approach prevents potential runtime errors and provides a more robust method for managing action bar functionality in diverse Android environments."
38642,"@Override public boolean createActionMenu(Menu menu,int menuRes){
  mActivity.getMenuInflater().inflate(menuRes,menu);
  mMenu=menu;
  mShareMenuItem=menu.findItem(R.id.action_share);
  if (mShareMenuItem != null) {
    mShareActionProvider=new ShareActionProvider(mActivity);
    mShareMenuItem.setActionProvider(mShareActionProvider);
  }
  return true;
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public boolean createActionMenu(Menu menu,int menuRes){
  mActivity.getMenuInflater().inflate(menuRes,menu);
  mMenu=menu;
  mShareMenuItem=menu.findItem(R.id.action_share);
  if (mShareMenuItem != null && ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
    mShareMenuItem.setActionProvider(mShareActionProvider.get());
  }
  return true;
}","The original code directly instantiates ShareActionProvider without checking API compatibility, which could cause runtime crashes on older Android versions. The fixed code adds an API level check using `ApiHelper.HAS_SHARE_ACTION_PROVIDER` and uses a safer method of retrieving the ShareActionProvider through a `.get()` method. This approach ensures graceful handling across different Android versions, preventing potential compatibility issues and improving the robustness of the menu creation process."
38643,"@Override public void inflateMenu(int menuRes){
  Utils.assertTrue(mMenu != null);
  mActionMode.getMenuInflater().inflate(menuRes,mMenu);
  mShareMenuItem=mMenu.findItem(R.id.action_share);
  if (mShareMenuItem != null) {
    mShareMenuItem.setActionProvider(mShareActionProvider);
  }
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void inflateMenu(int menuRes){
  Utils.assertTrue(mMenu != null);
  mActionMode.getMenuInflater().inflate(menuRes,mMenu);
  mShareMenuItem=mMenu.findItem(R.id.action_share);
  if (mShareMenuItem != null && ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
    mShareMenuItem.setActionProvider(mShareActionProvider.get());
  }
}","The original code lacks proper version compatibility checks when setting the share action provider, which could cause runtime errors on devices with different Android API levels. The fixed code adds an API level annotation and a conditional check using `ApiHelper.HAS_SHARE_ACTION_PROVIDER` to ensure the action provider is only set on supported versions, and uses `.get()` to retrieve the provider safely. This approach prevents potential crashes and provides more robust, version-aware menu inflation for sharing functionality."
38644,"@Override public void setOnShareTargetSelectedListener(final OnShareTargetSelectedListener listener){
  mShareActionProvider.setOnShareTargetSelectedListener(new ShareActionProvider.OnShareTargetSelectedListener(){
    @Override public boolean onShareTargetSelected(    ShareActionProvider source,    Intent intent){
      return listener.onShareTargetSelected(intent);
    }
  }
);
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void setOnShareTargetSelectedListener(final OnShareTargetSelectedListener listener){
  if (mShareActionProvider.get() == null)   return;
  mShareActionProvider.get().setOnShareTargetSelectedListener(new ShareActionProvider.OnShareTargetSelectedListener(){
    @Override public boolean onShareTargetSelected(    ShareActionProvider source,    Intent intent){
      return listener.onShareTargetSelected(intent);
    }
  }
);
}","The original code lacks a null check on mShareActionProvider, which could lead to potential NullPointerExceptions when setting the share target listener. The fixed code adds a null check using mShareActionProvider.get() and includes the @TargetApi annotation for API compatibility, ensuring safe method invocation. These modifications prevent runtime crashes and improve the robustness of the share action provider listener implementation."
38645,"public SystemActionModeWrapper(Activity activity,ActionModeInterface.Callback callback){
  mShareActionProvider=new ShareActionProvider(activity);
  activity.startActionMode(new CallbackWrapper(callback));
}","@TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public SystemActionModeWrapper(Activity activity,ActionModeInterface.Callback callback){
  if (ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
    mShareActionProvider.set(new ShareActionProvider(activity));
  }
  activity.startActionMode(new CallbackWrapper(callback));
}","The original code lacks version compatibility checks for ShareActionProvider, which could cause runtime errors on older Android versions. The fixed code adds an API level annotation and a conditional check using ApiHelper to safely initialize ShareActionProvider only on supported devices. This approach prevents potential crashes and ensures graceful handling of feature availability across different Android versions."
38646,"@Override public void setShareIntent(Intent shareIntent){
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(shareIntent != null);
    mShareActionProvider.setShareIntent(shareIntent);
  }
}","@Override @TargetApi(ApiHelper.VERSION_CODES.ICE_CREAM_SANDWICH) public void setShareIntent(Intent shareIntent){
  if (mShareMenuItem != null) {
    mShareMenuItem.setEnabled(shareIntent != null);
    if (ApiHelper.HAS_SHARE_ACTION_PROVIDER) {
      mShareActionProvider.get().setShareIntent(shareIntent);
    }
  }
}","The original code assumes universal support for ShareActionProvider across all Android versions, which can cause runtime errors on older devices. The fixed code adds a version check using ApiHelper to conditionally set the share intent only when the feature is supported, preventing potential crashes. This approach ensures graceful handling of ShareActionProvider across different Android API levels, improving the app's compatibility and stability."
38647,"public void updateSupportedOperation(){
  if (mMenuTask != null) {
    mMenuTask.cancel();
  }
  updateSelectionMenu();
  final boolean hasShareButton=mActionMode.hasShareButton();
  if (hasShareButton)   mActionMode.setShareIntent(null);
  mMenuTask=mActivity.getThreadPool().submit(new Job<Void>(){
    @Override public Void run(    final JobContext jc){
      final int operation=computeMenuOptions(jc);
      final Intent intent=hasShareButton ? computeSharingIntent(jc) : null;
      mMainHandler.post(new Runnable(){
        @Override public void run(){
          mMenuTask=null;
          if (!jc.isCancelled()) {
            MenuExecutor.updateMenuOperation(mActionMode,operation);
            if (hasShareButton) {
              mActionMode.setShareIntent(intent);
            }
          }
        }
      }
);
      return null;
    }
  }
);
}","public void updateSupportedOperation(){
  if (mMenuTask != null) {
    mMenuTask.cancel();
  }
  updateSelectionMenu();
  final boolean hasShareButton=mActionMode.hasShareButton();
  if (hasShareButton)   mActionMode.setShareIntent(null);
  mMenuTask=mActivity.getThreadPool().submit(new Job<Void>(){
    @Override public Void run(    final JobContext jc){
      final int operation=computeMenuOptions(jc);
      final Intent intent=hasShareButton ? computeSharingIntent(jc) : null;
      mMainHandler.post(new Runnable(){
        @Override public void run(){
          mMenuTask=null;
          if (!jc.isCancelled()) {
            MenuExecutor.updateMenuOperation(mActionMode,operation);
            if (hasShareButton) {
              mActionMode.setShareIntent(intent);
              mMenuExecutor.setShareIntent(intent);
            }
          }
        }
      }
);
      return null;
    }
  }
);
}","The original code omitted setting the share intent in the menu executor, potentially leaving the sharing functionality incomplete. In the fixed code, `mMenuExecutor.setShareIntent(intent)` was added alongside `mActionMode.setShareIntent(intent)` to ensure consistent share intent configuration across components. This change guarantees that the share intent is properly synchronized and applied throughout the application's menu and action mode."
38648,"@Override public void run(){
  mMenuTask=null;
  if (!jc.isCancelled()) {
    MenuExecutor.updateMenuOperation(mActionMode,operation);
    if (hasShareButton) {
      mActionMode.setShareIntent(intent);
    }
  }
}","@Override public void run(){
  mMenuTask=null;
  if (!jc.isCancelled()) {
    MenuExecutor.updateMenuOperation(mActionMode,operation);
    if (hasShareButton) {
      mActionMode.setShareIntent(intent);
      mMenuExecutor.setShareIntent(intent);
    }
  }
}","The original code failed to set the share intent for the menu executor, potentially leaving the share functionality incomplete. The fixed code adds `mMenuExecutor.setShareIntent(intent)`, ensuring that the share intent is properly configured for both the action mode and menu executor. This change guarantees consistent share intent handling across different components, improving the overall reliability of the sharing mechanism."
38649,"/** 
 * Try to seek the tiff data. If there is no tiff data, return false, else return true and the inputstream will be at the start of tiff data
 */
private boolean seekTiffData(InputStream inputStream) throws IOException, ExifInvalidFormatException {
  DataInputStream dataStream=new DataInputStream(inputStream);
  if (dataStream.readShort() != SOI) {
    throw new ExifInvalidFormatException(""String_Node_Str"");
  }
  if (dataStream.readShort() != APP1) {
    return false;
  }
  dataStream.readShort();
  if (dataStream.readInt() != EXIF_HEADER || dataStream.readShort() != EXIF_HEADER_TAIL) {
    return false;
  }
  return true;
}","/** 
 * Try to seek the tiff data. If there is no tiff data, return false, else return true and the inputstream will be at the start of tiff data
 */
private boolean seekTiffData(InputStream inputStream) throws IOException, ExifInvalidFormatException {
  DataInputStream dataStream=new DataInputStream(inputStream);
  if (dataStream.readShort() != SOI) {
    throw new ExifInvalidFormatException(""String_Node_Str"");
  }
  short tag=dataStream.readShort();
  if (tag == APP0) {
    int length=dataStream.readUnsignedShort();
    if ((length - 2) != dataStream.skip(length - 2)) {
      throw new EOFException();
    }
    tag=dataStream.readShort();
  }
  if (tag != APP1) {
    return false;
  }
  dataStream.readShort();
  if (dataStream.readInt() != EXIF_HEADER || dataStream.readShort() != EXIF_HEADER_TAIL) {
    return false;
  }
  return true;
}","The original code failed to handle APP0 markers, which can precede the APP1 marker in JPEG files, potentially causing incorrect parsing of EXIF metadata. The fixed code adds a check for APP0 markers, skipping their data and ensuring proper marker handling by reading the next marker tag before proceeding. This modification makes the EXIF parsing more robust, allowing the method to correctly locate and validate TIFF data across different JPEG file structures."
38650,"/** 
 * Try to seek the tiff data. If there is no tiff data, return false, else return true and the inputstream will be at the start of tiff data
 */
private boolean seekTiffData(InputStream inputStream) throws IOException, ExifInvalidFormatException {
  DataInputStream dataStream=new DataInputStream(inputStream);
  if (dataStream.readShort() != SOI) {
    throw new ExifInvalidFormatException(""String_Node_Str"");
  }
  if (dataStream.readShort() != APP1) {
    return false;
  }
  dataStream.readShort();
  if (dataStream.readInt() != EXIF_HEADER || dataStream.readShort() != EXIF_HEADER_TAIL) {
    return false;
  }
  return true;
}","/** 
 * Try to seek the tiff data. If there is no tiff data, return false, else return true and the inputstream will be at the start of tiff data
 */
private boolean seekTiffData(InputStream inputStream) throws IOException, ExifInvalidFormatException {
  DataInputStream dataStream=new DataInputStream(inputStream);
  if (dataStream.readShort() != SOI) {
    throw new ExifInvalidFormatException(""String_Node_Str"");
  }
  short tag=dataStream.readShort();
  if (tag == APP0) {
    int length=dataStream.readUnsignedShort();
    if ((length - 2) != dataStream.skip(length - 2)) {
      throw new EOFException();
    }
    tag=dataStream.readShort();
  }
  if (tag != APP1) {
    return false;
  }
  dataStream.readShort();
  if (dataStream.readInt() != EXIF_HEADER || dataStream.readShort() != EXIF_HEADER_TAIL) {
    return false;
  }
  return true;
}","The original code failed to handle APP0 markers, which can precede the APP1 marker in JPEG files, potentially causing incorrect parsing of EXIF metadata. The fixed code adds a check for APP0 markers, skipping their data and ensuring proper marker sequence by reading the next marker tag after potential APP0 data. This modification makes the EXIF parsing more robust, allowing the method to correctly navigate through different JPEG marker types and locate the EXIF information accurately."
38651,"public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    skipTo(mNextOffset);
    if (mNextOffset < mEndOfTagOffset) {
      mNextOffset+=TAG_SIZE;
      return TYPE_NEW_TAG;
    }
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      mOffsetToNextIfd=0;
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    offset=mNextOffset;
    skipTo(mNextOffset);
    if (mNextOffset < mEndOfTagOffset) {
      mNextOffset+=TAG_SIZE;
      return TYPE_NEW_TAG;
    }
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      mOffsetToNextIfd=0;
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","The original code incorrectly uses the initial offset value throughout the method, potentially causing incorrect stream positioning and tag processing. In the fixed code, the offset is explicitly updated to `mNextOffset` before further processing, ensuring accurate stream navigation and tag tracking. This change prevents potential misalignment of stream reading and improves the method's reliability in parsing TIFF file structures."
38652,"public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    skipTo(mNextOffset);
    if (mNextOffset < mEndOfTagOffset) {
      mNextOffset+=TAG_SIZE;
      return TYPE_NEW_TAG;
    }
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    skipTo(mNextOffset);
    if (mNextOffset < mEndOfTagOffset) {
      mNextOffset+=TAG_SIZE;
      return TYPE_NEW_TAG;
    }
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      mOffsetToNextIfd=0;
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","The original code did not reset `mOffsetToNextIfd` after navigating to the next IFD, potentially causing incorrect offset tracking in subsequent iterations. In the fixed code, `mOffsetToNextIfd` is explicitly set to 0 after skipping to the next IFD, ensuring clean state management between iterations. This modification prevents potential infinite loops or incorrect file navigation by resetting the offset pointer, making the method more robust and predictable."
38653,"public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    skipTo(mNextOffset);
    if (mNextOffset < mEndOfTagOffset) {
      mNextOffset+=TAG_SIZE;
      return TYPE_NEW_TAG;
    }
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      mOffsetToNextIfd=0;
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    offset=mNextOffset;
    skipTo(mNextOffset);
    if (mNextOffset < mEndOfTagOffset) {
      mNextOffset+=TAG_SIZE;
      return TYPE_NEW_TAG;
    }
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      mOffsetToNextIfd=0;
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","The original code incorrectly used the initial offset value without updating it when skipping to a new position, potentially causing incorrect navigation through TIFF file tags. In the fixed code, `offset` is explicitly set to `mNextOffset` before skipping, ensuring accurate tracking of the current file position. This modification prevents potential misalignment and improves the method's reliability in parsing TIFF file structures by maintaining correct byte offsets during tag traversal."
38654,"public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    skipTo(mNextOffset);
    mNextOffset+=TAG_SIZE;
    return TYPE_NEW_TAG;
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    skipTo(mNextOffset);
    if (mNextOffset < mEndOfTagOffset) {
      mNextOffset+=TAG_SIZE;
      return TYPE_NEW_TAG;
    }
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","The original code could incorrectly increment `mNextOffset` beyond `mEndOfTagOffset`, potentially causing out-of-bounds access or unexpected behavior during TIFF tag parsing. The fixed code adds a conditional check `if (mNextOffset < mEndOfTagOffset)` before incrementing `mNextOffset`, ensuring that tag navigation remains within the valid offset range. This modification prevents potential parsing errors and provides a more robust mechanism for traversing TIFF file tag structures."
38655,"public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    skipTo(mNextOffset);
    mNextOffset+=TAG_SIZE;
    return TYPE_NEW_TAG;
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    skipTo(mNextOffset);
    if (mNextOffset < mEndOfTagOffset) {
      mNextOffset+=TAG_SIZE;
      return TYPE_NEW_TAG;
    }
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","The original code lacked a boundary check when incrementing mNextOffset, potentially causing an out-of-bounds access beyond mEndOfTagOffset. The fixed code adds a conditional check (mNextOffset < mEndOfTagOffset) before incrementing mNextOffset, ensuring safe navigation through TIFF tag data. This modification prevents potential index overflow and provides more robust handling of tag iteration within the TIFF file structure."
38656,"public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    skipTo(mNextOffset);
    if (mNextOffset < mEndOfTagOffset) {
      mNextOffset+=TAG_SIZE;
      return TYPE_NEW_TAG;
    }
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","public int next() throws IOException {
  int offset=mTiffStream.getReadByteCount();
  if (offset < mEndOfTagOffset) {
    skipTo(mNextOffset);
    if (mNextOffset < mEndOfTagOffset) {
      mNextOffset+=TAG_SIZE;
      return TYPE_NEW_TAG;
    }
  }
  if (offset == mEndOfTagOffset) {
    mOffsetToNextIfd=mTiffStream.readInt();
  }
  if (!mCorrespondingTag.isEmpty()) {
    mCurrTag=mCorrespondingTag.pollFirst();
    skipTo(mCurrTag.getOffset());
    if (isSubIfdTag(mCurrTag.getTagId())) {
      return TYPE_SUB_IFD;
    }
 else {
      return TYPE_VALUE_OF_PREV_TAG;
    }
  }
 else {
    if (offset <= mOffsetToNextIfd) {
      skipTo(mOffsetToNextIfd);
      mOffsetToNextIfd=0;
      return TYPE_NEXT_IFD;
    }
 else {
      return TYPE_END;
    }
  }
}","The original code lacks proper handling of the next IFD (Image File Directory) offset, potentially causing infinite loops or incorrect navigation through TIFF file structures. The fixed code adds `mOffsetToNextIfd=0` after skipping to the next IFD, ensuring that subsequent iterations reset the offset and prevent unintended repeated traversals. This modification improves the method's reliability by explicitly clearing the offset after processing, preventing potential memory or navigation issues in TIFF file parsing."
38657,"@Override public Void call() throws Exception {
  UpdateInfo info=mUpdateInfo;
  mSourceVersion=info.version;
  if (info.size != mSize) {
    mSize=info.size;
    if (mContentEnd > mSize)     mContentEnd=mSize;
    if (mActiveEnd > mSize)     mActiveEnd=mSize;
  }
  mCurrentIndex=info.indexHint;
  updateSlidingWindow();
  if (info.items != null) {
    int start=Math.max(info.contentStart,mContentStart);
    int end=Math.min(info.contentStart + info.items.size(),mContentEnd);
    int dataIndex=start % DATA_CACHE_SIZE;
    for (int i=start; i < end; ++i) {
      mData[dataIndex]=info.items.get(i - info.contentStart);
      if (++dataIndex == DATA_CACHE_SIZE)       dataIndex=0;
    }
  }
  MediaItem current=mData[mCurrentIndex % DATA_CACHE_SIZE];
  mItemPath=current == null ? null : current.getPath();
  updateImageCache();
  updateTileProvider();
  updateImageRequests();
  fireDataChange();
  return null;
}","@Override public Void call() throws Exception {
  UpdateInfo info=mUpdateInfo;
  mSourceVersion=info.version;
  if (info.size != mSize) {
    mSize=info.size;
    if (mContentEnd > mSize)     mContentEnd=mSize;
    if (mActiveEnd > mSize)     mActiveEnd=mSize;
  }
  mCurrentIndex=info.indexHint;
  updateSlidingWindow();
  if (info.items != null) {
    int start=Math.max(info.contentStart,mContentStart);
    int end=Math.min(info.contentStart + info.items.size(),mContentEnd);
    int dataIndex=start % DATA_CACHE_SIZE;
    for (int i=start; i < end; ++i) {
      mData[dataIndex]=info.items.get(i - info.contentStart);
      if (++dataIndex == DATA_CACHE_SIZE)       dataIndex=0;
    }
  }
  MediaItem current=mData[mCurrentIndex % DATA_CACHE_SIZE];
  mItemPath=current == null ? null : current.getPath();
  updateImageCache();
  updateTileProvider();
  updateImageRequests();
  if (mDataListener != null) {
    mDataListener.onPhotoChanged(mCurrentIndex,mItemPath);
  }
  fireDataChange();
  return null;
}","The original code lacked a null check for the data listener, potentially causing a null pointer exception when attempting to notify about photo changes. The fixed code adds a conditional check `if (mDataListener != null)` before calling `onPhotoChanged()`, ensuring safe method invocation. This modification prevents runtime errors and provides a more robust mechanism for handling data listener notifications, improving the method's reliability and error resilience."
38658,"@Override public Void call() throws Exception {
  UpdateInfo info=mUpdateInfo;
  mSourceVersion=info.version;
  if (info.size != mSize) {
    mSize=info.size;
    if (mContentEnd > mSize)     mContentEnd=mSize;
    if (mActiveEnd > mSize)     mActiveEnd=mSize;
  }
  mCurrentIndex=info.indexHint;
  updateSlidingWindow();
  if (info.items != null) {
    int start=Math.max(info.contentStart,mContentStart);
    int end=Math.min(info.contentStart + info.items.size(),mContentEnd);
    int dataIndex=start % DATA_CACHE_SIZE;
    for (int i=start; i < end; ++i) {
      mData[dataIndex]=info.items.get(i - info.contentStart);
      if (++dataIndex == DATA_CACHE_SIZE)       dataIndex=0;
    }
  }
  MediaItem current=mData[mCurrentIndex % DATA_CACHE_SIZE];
  mItemPath=current == null ? null : current.getPath();
  updateImageCache();
  updateTileProvider();
  updateImageRequests();
  fireDataChange();
  return null;
}","@Override public Void call() throws Exception {
  UpdateInfo info=mUpdateInfo;
  mSourceVersion=info.version;
  if (info.size != mSize) {
    mSize=info.size;
    if (mContentEnd > mSize)     mContentEnd=mSize;
    if (mActiveEnd > mSize)     mActiveEnd=mSize;
  }
  mCurrentIndex=info.indexHint;
  updateSlidingWindow();
  if (info.items != null) {
    int start=Math.max(info.contentStart,mContentStart);
    int end=Math.min(info.contentStart + info.items.size(),mContentEnd);
    int dataIndex=start % DATA_CACHE_SIZE;
    for (int i=start; i < end; ++i) {
      mData[dataIndex]=info.items.get(i - info.contentStart);
      if (++dataIndex == DATA_CACHE_SIZE)       dataIndex=0;
    }
  }
  MediaItem current=mData[mCurrentIndex % DATA_CACHE_SIZE];
  mItemPath=current == null ? null : current.getPath();
  updateImageCache();
  updateTileProvider();
  updateImageRequests();
  if (mDataListener != null) {
    mDataListener.onPhotoChanged(mCurrentIndex,mItemPath);
  }
  fireDataChange();
  return null;
}","The original code lacked a null check for the data listener before invoking a callback, which could potentially cause a NullPointerException. The fixed code adds a conditional check `if (mDataListener != null)` before calling `mDataListener.onPhotoChanged()`, ensuring safe method invocation. This modification prevents runtime errors and provides a more robust implementation by gracefully handling scenarios where the data listener might not be initialized."
38659,"public boolean switchWithCaptureAnimation(int offset){
  GLRoot root=getGLRoot();
  root.lockRenderThread();
  try {
    return switchWithCaptureAnimationLocked(offset);
  }
  finally {
    root.unlockRenderThread();
  }
}","public boolean switchWithCaptureAnimation(int offset){
  GLRoot root=getGLRoot();
  if (root == null)   return false;
  root.lockRenderThread();
  try {
    return switchWithCaptureAnimationLocked(offset);
  }
  finally {
    root.unlockRenderThread();
  }
}","The original code lacks a null check for the GLRoot, potentially causing a NullPointerException if getGLRoot() returns null. The fixed code adds an explicit null check that returns false if the root is null, preventing potential runtime crashes. This defensive programming approach ensures method robustness by gracefully handling scenarios where the GLRoot might be uninitialized, improving overall code reliability and error handling."
38660,"private boolean canShowBars(){
  boolean atCamera=mAppBridge != null && mCurrentIndex == 0;
  return mActionBarAllowed && !atCamera;
}","private boolean canShowBars(){
  if (mAppBridge != null && mCurrentIndex == 0)   return false;
  if (!mActionBarAllowed)   return false;
  if (mOrientationManager.isOrientationLocked())   return false;
  return true;
}","The original code incorrectly combined multiple conditions in a single boolean expression, leading to potential logical errors in determining when bars can be shown. The fixed code separates conditions into explicit if-statements, adding an additional check for orientation lock and ensuring clearer, more granular control over bar visibility. This approach provides better readability, more precise condition handling, and reduces the risk of unintended boolean logic interactions."
38661,"private void toggleBars(){
  if (mShowBars) {
    hideBars();
  }
 else   if (canShowBars()) {
    showBars();
  }
}","private void toggleBars(){
  mCanShowBars=canShowBars();
  if (mShowBars) {
    hideBars();
  }
 else {
    if (mCanShowBars)     showBars();
  }
}","The original code could repeatedly call `canShowBars()` with different potential results, leading to inconsistent state and potential race conditions. The fixed code captures the `canShowBars()` result in `mCanShowBars` before making any decisions, ensuring a consistent evaluation at the moment of toggle. This approach provides a more predictable and stable method for managing bar visibility by establishing the condition once before executing the appropriate action."
38662,"@Override public void onCreate(Bundle data,Bundle restoreState){
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
  mOriginalSetPathString=mSetPathString;
  mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity.getAndroidContext());
  Path itemPath=Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH));
  if (mSetPathString != null) {
    mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
    if (mAppBridge != null) {
      mOrientationManager.lockOrientation();
      mScreenNail=mAppBridge.attachScreenNail();
      int id=SnailSource.registerScreenNail(mScreenNail);
      Path screenNailSetPath=SnailSource.getSetPath(id);
      Path screenNailItemPath=SnailSource.getItemPath(id);
      mScreenNailItem=(MediaItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
      mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
      itemPath=screenNailItemPath;
      mFlags|=FLAG_HIDE_ACTION_BAR;
      mShowBars=false;
    }
    mMediaSet=mActivity.getDataManager().getMediaSet(mSetPathString);
    mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
    if (mMediaSet == null) {
      Log.w(TAG,""String_Node_Str"" + mSetPathString);
    }
    PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0);
    mModel=pda;
    mPhotoView.setModel(mModel);
    pda.setDataListener(new PhotoDataAdapter.DataListener(){
      @Override public void onPhotoChanged(      int index,      Path item){
        mCurrentIndex=index;
        if (item != null) {
          MediaItem photo=mModel.getCurrentMediaItem();
          if (photo != null)           updateCurrentPhoto(photo);
        }
        updateBars();
      }
      @Override public void onLoadingFinished(){
        GalleryUtils.setSpinnerVisibility((Activity)mActivity,false);
        if (!mModel.isEmpty()) {
          MediaItem photo=mModel.getCurrentMediaItem();
          if (photo != null)           updateCurrentPhoto(photo);
        }
 else         if (mIsActive) {
          mActivity.getStateManager().finishState(PhotoPage.this);
        }
      }
      @Override public void onLoadingStarted(){
        GalleryUtils.setSpinnerVisibility((Activity)mActivity,true);
      }
    }
);
  }
 else {
    MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
    mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
    mPhotoView.setModel(mModel);
    updateCurrentPhoto(mediaItem);
  }
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_LOCK_ORIENTATION:
{
        mOrientationManager.lockOrientation();
        break;
      }
case MSG_UNLOCK_ORIENTATION:
{
      mOrientationManager.unlockOrientation();
      break;
    }
case MSG_ON_FULL_SCREEN_CHANGED:
{
    mAppBridge.onFullScreenChanged(message.arg1 == 1);
    break;
  }
case MSG_UPDATE_ACTION_BAR:
{
  updateBars();
  break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
if (restoreState == null) {
mPhotoView.setOpenAnimationRect((Rect)data.getParcelable(KEY_OPEN_ANIMATION_RECT));
}
}","@Override public void onCreate(Bundle data,Bundle restoreState){
  mActionBar=mActivity.getGalleryActionBar();
  mSelectionManager=new SelectionManager(mActivity,false);
  mMenuExecutor=new MenuExecutor(mActivity,mSelectionManager);
  mPhotoView=new PhotoView(mActivity);
  mPhotoView.setListener(this);
  mRootPane.addComponent(mPhotoView);
  mApplication=(GalleryApp)((Activity)mActivity).getApplication();
  mOrientationManager=mActivity.getOrientationManager();
  mOrientationManager.addListener(this);
  mSetPathString=data.getString(KEY_MEDIA_SET_PATH);
  mOriginalSetPathString=mSetPathString;
  mNfcAdapter=NfcAdapter.getDefaultAdapter(mActivity.getAndroidContext());
  Path itemPath=Path.fromString(data.getString(KEY_MEDIA_ITEM_PATH));
  if (mSetPathString != null) {
    mAppBridge=(AppBridge)data.getParcelable(KEY_APP_BRIDGE);
    if (mAppBridge != null) {
      mOrientationManager.lockOrientation();
      mScreenNail=mAppBridge.attachScreenNail();
      int id=SnailSource.registerScreenNail(mScreenNail);
      Path screenNailSetPath=SnailSource.getSetPath(id);
      Path screenNailItemPath=SnailSource.getItemPath(id);
      mScreenNailItem=(MediaItem)mActivity.getDataManager().getMediaObject(screenNailItemPath);
      mSetPathString=""String_Node_Str"" + screenNailSetPath + ""String_Node_Str""+ mSetPathString+ ""String_Node_Str"";
      itemPath=screenNailItemPath;
      mFlags|=FLAG_HIDE_ACTION_BAR;
      mShowBars=false;
    }
    mMediaSet=mActivity.getDataManager().getMediaSet(mSetPathString);
    mCurrentIndex=data.getInt(KEY_INDEX_HINT,0);
    if (mMediaSet == null) {
      Log.w(TAG,""String_Node_Str"" + mSetPathString);
    }
    PhotoDataAdapter pda=new PhotoDataAdapter(mActivity,mPhotoView,mMediaSet,itemPath,mCurrentIndex,mAppBridge == null ? -1 : 0);
    mModel=pda;
    mPhotoView.setModel(mModel);
    pda.setDataListener(new PhotoDataAdapter.DataListener(){
      @Override public void onPhotoChanged(      int index,      Path item){
        mCurrentIndex=index;
        if (item != null) {
          MediaItem photo=mModel.getCurrentMediaItem();
          if (photo != null)           updateCurrentPhoto(photo);
        }
        updateBars();
      }
      @Override public void onLoadingFinished(){
        GalleryUtils.setSpinnerVisibility((Activity)mActivity,false);
        if (!mModel.isEmpty()) {
          MediaItem photo=mModel.getCurrentMediaItem();
          if (photo != null)           updateCurrentPhoto(photo);
        }
 else         if (mIsActive) {
          mActivity.getStateManager().finishState(PhotoPage.this);
        }
      }
      @Override public void onLoadingStarted(){
        GalleryUtils.setSpinnerVisibility((Activity)mActivity,true);
      }
    }
);
  }
 else {
    MediaItem mediaItem=(MediaItem)mActivity.getDataManager().getMediaObject(itemPath);
    mModel=new SinglePhotoDataAdapter(mActivity,mPhotoView,mediaItem);
    mPhotoView.setModel(mModel);
    updateCurrentPhoto(mediaItem);
  }
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
          hideBars();
          break;
        }
case MSG_LOCK_ORIENTATION:
{
        mOrientationManager.lockOrientation();
        updateBars();
        break;
      }
case MSG_UNLOCK_ORIENTATION:
{
      mOrientationManager.unlockOrientation();
      updateBars();
      break;
    }
case MSG_ON_FULL_SCREEN_CHANGED:
{
    mAppBridge.onFullScreenChanged(message.arg1 == 1);
    break;
  }
case MSG_UPDATE_ACTION_BAR:
{
  updateBars();
  break;
}
default :
throw new AssertionError(message.what);
}
}
}
;
if (restoreState == null) {
mPhotoView.setOpenAnimationRect((Rect)data.getParcelable(KEY_OPEN_ANIMATION_RECT));
}
}","The original code lacked proper bar updates during orientation changes, potentially leaving the UI in an inconsistent state. In the fixed code, `updateBars()` is added to the `MSG_LOCK_ORIENTATION` and `MSG_UNLOCK_ORIENTATION` message handlers, ensuring the UI reflects the current orientation and screen state. This modification improves user experience by maintaining consistent UI responsiveness and visual feedback during device orientation transitions."
38663,"@Override protected void onDestroy(){
  if (mAppBridge != null) {
    SnailSource.unregisterScreenNail(mScreenNail);
    mAppBridge.detachScreenNail();
    mAppBridge=null;
    mScreenNail=null;
  }
  mOrientationManager.removeListener(this);
  super.onDestroy();
}","@Override protected void onDestroy(){
  if (mAppBridge != null) {
    SnailSource.unregisterScreenNail(mScreenNail);
    mAppBridge.detachScreenNail();
    mAppBridge=null;
    mScreenNail=null;
  }
  mOrientationManager.removeListener(this);
  mHandler.removeCallbacksAndMessages(null);
  super.onDestroy();
}","The original code lacks proper cleanup of handler callbacks, which can lead to memory leaks and potential crashes after the activity is destroyed. The fixed code adds `mHandler.removeCallbacksAndMessages(null)`, which ensures all pending messages and callbacks associated with the handler are cleared before the activity is fully destroyed. This change prevents potential memory leaks and eliminates the risk of accessing destroyed activity context, improving the overall stability and resource management of the application."
38664,"@Override public void handleMessage(Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
      hideBars();
      break;
    }
case MSG_LOCK_ORIENTATION:
{
    mOrientationManager.lockOrientation();
    break;
  }
case MSG_UNLOCK_ORIENTATION:
{
  mOrientationManager.unlockOrientation();
  break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
default :
throw new AssertionError(message.what);
}
}","@Override public void handleMessage(Message message){
switch (message.what) {
case MSG_HIDE_BARS:
{
      hideBars();
      break;
    }
case MSG_LOCK_ORIENTATION:
{
    mOrientationManager.lockOrientation();
    updateBars();
    break;
  }
case MSG_UNLOCK_ORIENTATION:
{
  mOrientationManager.unlockOrientation();
  updateBars();
  break;
}
case MSG_ON_FULL_SCREEN_CHANGED:
{
mAppBridge.onFullScreenChanged(message.arg1 == 1);
break;
}
case MSG_UPDATE_ACTION_BAR:
{
updateBars();
break;
}
default :
throw new AssertionError(message.what);
}
}","The original code lacks proper UI synchronization when locking or unlocking device orientation, potentially leaving the UI in an inconsistent state. The fixed code adds `updateBars()` calls in the `MSG_LOCK_ORIENTATION` and `MSG_UNLOCK_ORIENTATION` cases to ensure the UI reflects the current orientation and visibility settings. This modification guarantees a more robust and consistent user interface by explicitly refreshing the UI components after orientation changes."
38665,"private void updateBars(){
  if (canShowBars()) {
    showBars();
  }
 else {
    hideBars();
  }
}","private void updateBars(){
  boolean v=canShowBars();
  if (mCanShowBars == v)   return;
  mCanShowBars=v;
  if (mCanShowBars) {
    showBars();
  }
 else {
    hideBars();
  }
}","The original code lacks state tracking, potentially causing redundant bar show/hide operations and unnecessary method calls. The fixed code introduces a state variable `mCanShowBars` and checks if the current visibility state has changed before updating, preventing unnecessary method invocations. This optimization reduces computational overhead and ensures bar visibility is only modified when a genuine state change occurs."
38666,"private void captureAnimationDone(int offset){
  mHolding&=~HOLD_CAPTURE_ANIMATION;
  if (offset == 1) {
    if (!mFilmMode) {
      mListener.unlockOrientation();
      mListener.onActionBarAllowed(true);
    }
  }
  snapback();
}","private void captureAnimationDone(int offset){
  mHolding&=~HOLD_CAPTURE_ANIMATION;
  if (offset == 1) {
    if (!mFilmMode) {
      mListener.onActionBarAllowed(true);
    }
  }
  snapback();
}","The original code inappropriately called `mListener.unlockOrientation()` before `onActionBarAllowed(true)`, which could potentially create an unnecessary or redundant orientation state change. The fixed code removes the `unlockOrientation()` method call, ensuring that only the action bar permission is modified without additional orientation manipulation. This simplifies the method's logic and prevents potential unintended side effects in the UI state management flow."
38667,"@Override protected void onResume(){
  super.onResume();
  mIsActive=true;
  setContentPane(mRootPane);
  mModel.resume();
  mPhotoView.resume();
  if (mMenuVisibilityListener == null) {
    mMenuVisibilityListener=new MyMenuVisibilityListener();
  }
  mActionBar.setDisplayOptions(mSetPathString != null,true);
  mActionBar.addOnMenuVisibilityListener(mMenuVisibilityListener);
  onUserInteraction();
  if (mAppBridge != null) {
    mAppBridge.setServer(this);
    mModel.moveTo(0);
  }
}","@Override protected void onResume(){
  super.onResume();
  mIsActive=true;
  setContentPane(mRootPane);
  mModel.resume();
  mPhotoView.resume();
  if (mMenuVisibilityListener == null) {
    mMenuVisibilityListener=new MyMenuVisibilityListener();
  }
  mActionBar.setDisplayOptions(mSetPathString != null,true);
  mActionBar.addOnMenuVisibilityListener(mMenuVisibilityListener);
  onUserInteraction();
  if (mAppBridge != null) {
    mAppBridge.setServer(this);
    mPhotoView.resetToFirstPicture();
  }
}","The original code incorrectly calls `mModel.moveTo(0)`, which may cause unexpected navigation or reset behavior in the photo view. The fixed code replaces this with `mPhotoView.resetToFirstPicture()`, which provides a more explicit and controlled method for resetting the photo view to its initial state. This change ensures a clearer, more predictable user experience by directly manipulating the photo view rather than indirectly through the model."
38668,"@Override public boolean onScaleBegin(float focusX,float focusY){
  mPositionController.beginScale(focusX,focusY);
  mCanChangeMode=mFilmMode || mPositionController.isAtMinimalScale();
  mModeChanged=false;
  return true;
}","@Override public boolean onScaleBegin(float focusX,float focusY){
  mIgnoreScalingGesture=mPictures.get(0).isCamera();
  if (mIgnoreScalingGesture) {
    return true;
  }
  mPositionController.beginScale(focusX,focusY);
  mCanChangeMode=mFilmMode || mPositionController.isAtMinimalScale();
  mModeChanged=false;
  return true;
}","The original code lacked a check to prevent scaling on certain types of pictures, potentially allowing unintended scaling behavior. The fixed code introduces an `mIgnoreScalingGesture` flag that checks if the first picture is a camera image, and immediately returns true if so, preventing unwanted scaling interactions. This modification adds a crucial validation step, ensuring more robust and context-aware scaling gesture handling."
38669,"@Override public void onScaleEnd(){
  if (mModeChanged)   return;
  mPositionController.endScale();
}","@Override public void onScaleEnd(){
  if (mIgnoreScalingGesture) {
    return;
  }
  if (mModeChanged)   return;
  mPositionController.endScale();
}","The original code lacked a check for ignoring scaling gestures, potentially executing scale-related operations when they should be skipped. The fixed code introduces an additional condition `mIgnoreScalingGesture` before proceeding, allowing explicit control over whether scaling actions should be processed. This modification provides more robust gesture handling by preventing unintended scale operations and giving the developer greater flexibility in managing user interactions."
38670,"@Override public boolean onScale(float focusX,float focusY,float scale){
  if (mModeChanged)   return true;
  if (Float.isNaN(scale) || Float.isInfinite(scale))   return false;
  if (scale > 0.99f && scale < 1.01f)   return false;
  int outOfRange=mPositionController.scaleBy(scale,focusX,focusY);
  if (mCanChangeMode) {
    if ((outOfRange < 0 && !mFilmMode) || (outOfRange > 0 && mFilmMode)) {
      stopExtraScalingIfNeeded();
      mHolding&=~HOLD_TOUCH_DOWN;
      setFilmMode(!mFilmMode);
      onScaleEnd();
      mModeChanged=true;
      return true;
    }
  }
  if (outOfRange != 0) {
    startExtraScalingIfNeeded();
  }
 else {
    stopExtraScalingIfNeeded();
  }
  return true;
}","@Override public boolean onScale(float focusX,float focusY,float scale){
  if (mIgnoreScalingGesture) {
    return true;
  }
  if (mModeChanged)   return true;
  if (Float.isNaN(scale) || Float.isInfinite(scale))   return false;
  if (scale > 0.99f && scale < 1.01f)   return false;
  int outOfRange=mPositionController.scaleBy(scale,focusX,focusY);
  if (mCanChangeMode) {
    if ((outOfRange < 0 && !mFilmMode) || (outOfRange > 0 && mFilmMode)) {
      stopExtraScalingIfNeeded();
      mHolding&=~HOLD_TOUCH_DOWN;
      setFilmMode(!mFilmMode);
      onScaleEnd();
      mModeChanged=true;
      return true;
    }
  }
  if (outOfRange != 0) {
    startExtraScalingIfNeeded();
  }
 else {
    stopExtraScalingIfNeeded();
  }
  return true;
}","The original code lacked a mechanism to ignore scaling gestures when necessary, potentially causing unintended interactions during touch events. The fixed code introduces `mIgnoreScalingGesture` as an early return condition, allowing explicit control over when scaling should be processed. This enhancement provides more robust gesture handling by preventing unwanted scale operations and giving the developer fine-grained control over touch interactions."
38671,"private void layoutTiles(int centerX,int centerY,float scale,int rotation){
  int width=getWidth();
  int height=getHeight();
  int fromLevel;
  int endLevel;
  mLevel=Utils.clamp(Utils.floorLog2(1f / scale),0,mLevelCount);
  if (mLevel != mLevelCount) {
    Rect range=mTileRange;
    getRange(range,centerX,centerY,mLevel,scale,rotation);
    mOffsetX=Math.round(width / 2f + (range.left - centerX) * scale);
    mOffsetY=Math.round(height / 2f + (range.top - centerY) * scale);
    fromLevel=scale * (1 << mLevel) > 0.75f ? mLevel - 1 : mLevel;
  }
 else {
    fromLevel=mLevel - 2;
    mOffsetX=Math.round(width / 2f - centerX * scale);
    mOffsetY=Math.round(height / 2f - centerY * scale);
  }
  fromLevel=Math.max(0,Math.min(fromLevel,mLevelCount - 2));
  endLevel=Math.min(fromLevel + 2,mLevelCount);
  Rect range[]=mActiveRange;
  for (int i=fromLevel; i < endLevel; ++i) {
    getRange(range[i - fromLevel],centerX,centerY,i,rotation);
  }
  if (rotation % 90 != 0)   return;
synchronized (this) {
    mDecodeQueue.clean();
    mUploadQueue.clean();
    mBackgroundTileUploaded=false;
  }
  int n=mActiveTiles.size();
  for (int i=0; i < n; i++) {
    Tile tile=mActiveTiles.valueAt(i);
    int level=tile.mTileLevel;
    if (level < fromLevel || level >= endLevel || !range[level - fromLevel].contains(tile.mX,tile.mY)) {
      mActiveTiles.removeAt(i);
      i--;
      n--;
      recycleTile(tile);
    }
  }
  for (int i=fromLevel; i < endLevel; ++i) {
    int size=TILE_SIZE << i;
    Rect r=range[i - fromLevel];
    for (int y=r.top, bottom=r.bottom; y < bottom; y+=size) {
      for (int x=r.left, right=r.right; x < right; x+=size) {
        activateTile(x,y,i);
      }
    }
  }
  invalidate();
}","private void layoutTiles(int centerX,int centerY,float scale,int rotation){
  int width=getWidth();
  int height=getHeight();
  int fromLevel;
  int endLevel;
  mLevel=Utils.clamp(Utils.floorLog2(1f / scale),0,mLevelCount);
  if (mLevel != mLevelCount) {
    Rect range=mTileRange;
    getRange(range,centerX,centerY,mLevel,scale,rotation);
    mOffsetX=Math.round(width / 2f + (range.left - centerX) * scale);
    mOffsetY=Math.round(height / 2f + (range.top - centerY) * scale);
    fromLevel=scale * (1 << mLevel) > 0.75f ? mLevel - 1 : mLevel;
  }
 else {
    fromLevel=mLevel - 2;
    mOffsetX=Math.round(width / 2f - centerX * scale);
    mOffsetY=Math.round(height / 2f - centerY * scale);
  }
  fromLevel=Math.max(0,Math.min(fromLevel,mLevelCount - 2));
  endLevel=Math.min(fromLevel + 2,mLevelCount);
  Rect range[]=mActiveRange;
  for (int i=fromLevel; i < endLevel; ++i) {
    getRange(range[i - fromLevel],centerX,centerY,i,rotation);
  }
  if (rotation % 90 != 0)   return;
synchronized (this) {
    mDecodeQueue.clean();
    mUploadQueue.clean();
    mBackgroundTileUploaded=false;
    int n=mActiveTiles.size();
    for (int i=0; i < n; i++) {
      Tile tile=mActiveTiles.valueAt(i);
      int level=tile.mTileLevel;
      if (level < fromLevel || level >= endLevel || !range[level - fromLevel].contains(tile.mX,tile.mY)) {
        mActiveTiles.removeAt(i);
        i--;
        n--;
        recycleTile(tile);
      }
    }
  }
  for (int i=fromLevel; i < endLevel; ++i) {
    int size=TILE_SIZE << i;
    Rect r=range[i - fromLevel];
    for (int y=r.top, bottom=r.bottom; y < bottom; y+=size) {
      for (int x=r.left, right=r.right; x < right; x+=size) {
        activateTile(x,y,i);
      }
    }
  }
  invalidate();
}","The original code had a potential concurrency issue where tile removal from `mActiveTiles` occurred outside the synchronized block, risking race conditions and inconsistent state. The fixed code moves the tile removal logic inside the synchronized block, ensuring thread-safe modification of the `mActiveTiles` collection during tile layout. This change prevents potential data corruption and ensures consistent tile management during concurrent access, improving the method's thread safety and reliability."
38672,"private void layoutTiles(int centerX,int centerY,float scale,int rotation){
  int width=getWidth();
  int height=getHeight();
  int fromLevel;
  int endLevel;
  mLevel=Utils.clamp(Utils.floorLog2(1f / scale),0,mLevelCount);
  if (mLevel != mLevelCount) {
    Rect range=mTileRange;
    getRange(range,centerX,centerY,mLevel,scale,rotation);
    mOffsetX=Math.round(width / 2f + (range.left - centerX) * scale);
    mOffsetY=Math.round(height / 2f + (range.top - centerY) * scale);
    fromLevel=scale * (1 << mLevel) > 0.75f ? mLevel - 1 : mLevel;
  }
 else {
    fromLevel=mLevel - 2;
    mOffsetX=Math.round(width / 2f - centerX * scale);
    mOffsetY=Math.round(height / 2f - centerY * scale);
  }
  fromLevel=Math.max(0,Math.min(fromLevel,mLevelCount - 2));
  endLevel=Math.min(fromLevel + 2,mLevelCount);
  Rect range[]=mActiveRange;
  for (int i=fromLevel; i < endLevel; ++i) {
    getRange(range[i - fromLevel],centerX,centerY,i,rotation);
  }
  if (rotation % 90 != 0)   return;
synchronized (this) {
    mDecodeQueue.clean();
    mUploadQueue.clean();
    mBackgroundTileUploaded=false;
  }
  int n=mActiveTiles.size();
  for (int i=0; i < n; i++) {
    Tile tile=mActiveTiles.valueAt(i);
    int level=tile.mTileLevel;
    if (level < fromLevel || level >= endLevel || !range[level - fromLevel].contains(tile.mX,tile.mY)) {
      mActiveTiles.removeAt(i);
      i--;
      n--;
      recycleTile(tile);
    }
  }
  for (int i=fromLevel; i < endLevel; ++i) {
    int size=TILE_SIZE << i;
    Rect r=range[i - fromLevel];
    for (int y=r.top, bottom=r.bottom; y < bottom; y+=size) {
      for (int x=r.left, right=r.right; x < right; x+=size) {
        activateTile(x,y,i);
      }
    }
  }
  invalidate();
}","private void layoutTiles(int centerX,int centerY,float scale,int rotation){
  int width=getWidth();
  int height=getHeight();
  int fromLevel;
  int endLevel;
  mLevel=Utils.clamp(Utils.floorLog2(1f / scale),0,mLevelCount);
  if (mLevel != mLevelCount) {
    Rect range=mTileRange;
    getRange(range,centerX,centerY,mLevel,scale,rotation);
    mOffsetX=Math.round(width / 2f + (range.left - centerX) * scale);
    mOffsetY=Math.round(height / 2f + (range.top - centerY) * scale);
    fromLevel=scale * (1 << mLevel) > 0.75f ? mLevel - 1 : mLevel;
  }
 else {
    fromLevel=mLevel - 2;
    mOffsetX=Math.round(width / 2f - centerX * scale);
    mOffsetY=Math.round(height / 2f - centerY * scale);
  }
  fromLevel=Math.max(0,Math.min(fromLevel,mLevelCount - 2));
  endLevel=Math.min(fromLevel + 2,mLevelCount);
  Rect range[]=mActiveRange;
  for (int i=fromLevel; i < endLevel; ++i) {
    getRange(range[i - fromLevel],centerX,centerY,i,rotation);
  }
  if (rotation % 90 != 0)   return;
synchronized (this) {
    mDecodeQueue.clean();
    mUploadQueue.clean();
    mBackgroundTileUploaded=false;
    int n=mActiveTiles.size();
    for (int i=0; i < n; i++) {
      Tile tile=mActiveTiles.valueAt(i);
      int level=tile.mTileLevel;
      if (level < fromLevel || level >= endLevel || !range[level - fromLevel].contains(tile.mX,tile.mY)) {
        mActiveTiles.removeAt(i);
        i--;
        n--;
        recycleTile(tile);
      }
    }
  }
  for (int i=fromLevel; i < endLevel; ++i) {
    int size=TILE_SIZE << i;
    Rect r=range[i - fromLevel];
    for (int y=r.top, bottom=r.bottom; y < bottom; y+=size) {
      for (int x=r.left, right=r.right; x < right; x+=size) {
        activateTile(x,y,i);
      }
    }
  }
  invalidate();
}","The original code had a critical synchronization issue where tile removal from `mActiveTiles` occurred outside the synchronized block, potentially causing race conditions and inconsistent state. In the fixed code, the tile removal logic is moved inside the synchronized block, ensuring thread-safe modification of the `mActiveTiles` collection. This change prevents potential concurrent access problems and guarantees consistent tile management during the layout process."
38673,"private void layoutTiles(int centerX,int centerY,float scale,int rotation){
  int width=getWidth();
  int height=getHeight();
  int fromLevel;
  int endLevel;
  mLevel=Utils.clamp(Utils.floorLog2(1f / scale),0,mLevelCount);
  if (mLevel != mLevelCount) {
    Rect range=mTileRange;
    getRange(range,centerX,centerY,mLevel,scale,rotation);
    mOffsetX=Math.round(width / 2f + (range.left - centerX) * scale);
    mOffsetY=Math.round(height / 2f + (range.top - centerY) * scale);
    fromLevel=scale * (1 << mLevel) > 0.75f ? mLevel - 1 : mLevel;
  }
 else {
    fromLevel=mLevel - 2;
    mOffsetX=Math.round(width / 2f - centerX * scale);
    mOffsetY=Math.round(height / 2f - centerY * scale);
  }
  fromLevel=Math.max(0,Math.min(fromLevel,mLevelCount - 2));
  endLevel=Math.min(fromLevel + 2,mLevelCount);
  Rect range[]=mActiveRange;
  for (int i=fromLevel; i < endLevel; ++i) {
    getRange(range[i - fromLevel],centerX,centerY,i,rotation);
  }
  if (rotation % 90 != 0)   return;
synchronized (this) {
    mDecodeQueue.clean();
    mUploadQueue.clean();
    mBackgroundTileUploaded=false;
  }
  int n=mActiveTiles.size();
  for (int i=0; i < n; i++) {
    Tile tile=mActiveTiles.valueAt(i);
    int level=tile.mTileLevel;
    if (level < fromLevel || level >= endLevel || !range[level - fromLevel].contains(tile.mX,tile.mY)) {
      mActiveTiles.removeAt(i);
      i--;
      n--;
      recycleTile(tile);
    }
  }
  for (int i=fromLevel; i < endLevel; ++i) {
    int size=TILE_SIZE << i;
    Rect r=range[i - fromLevel];
    for (int y=r.top, bottom=r.bottom; y < bottom; y+=size) {
      for (int x=r.left, right=r.right; x < right; x+=size) {
        activateTile(x,y,i);
      }
    }
  }
  invalidate();
}","private void layoutTiles(int centerX,int centerY,float scale,int rotation){
  int width=getWidth();
  int height=getHeight();
  int fromLevel;
  int endLevel;
  mLevel=Utils.clamp(Utils.floorLog2(1f / scale),0,mLevelCount);
  if (mLevel != mLevelCount) {
    Rect range=mTileRange;
    getRange(range,centerX,centerY,mLevel,scale,rotation);
    mOffsetX=Math.round(width / 2f + (range.left - centerX) * scale);
    mOffsetY=Math.round(height / 2f + (range.top - centerY) * scale);
    fromLevel=scale * (1 << mLevel) > 0.75f ? mLevel - 1 : mLevel;
  }
 else {
    fromLevel=mLevel - 2;
    mOffsetX=Math.round(width / 2f - centerX * scale);
    mOffsetY=Math.round(height / 2f - centerY * scale);
  }
  fromLevel=Math.max(0,Math.min(fromLevel,mLevelCount - 2));
  endLevel=Math.min(fromLevel + 2,mLevelCount);
  Rect range[]=mActiveRange;
  for (int i=fromLevel; i < endLevel; ++i) {
    getRange(range[i - fromLevel],centerX,centerY,i,rotation);
  }
  if (rotation % 90 != 0)   return;
synchronized (this) {
    mDecodeQueue.clean();
    mUploadQueue.clean();
    mBackgroundTileUploaded=false;
    int n=mActiveTiles.size();
    for (int i=0; i < n; i++) {
      Tile tile=mActiveTiles.valueAt(i);
      int level=tile.mTileLevel;
      if (level < fromLevel || level >= endLevel || !range[level - fromLevel].contains(tile.mX,tile.mY)) {
        mActiveTiles.removeAt(i);
        i--;
        n--;
        recycleTile(tile);
      }
    }
  }
  for (int i=fromLevel; i < endLevel; ++i) {
    int size=TILE_SIZE << i;
    Rect r=range[i - fromLevel];
    for (int y=r.top, bottom=r.bottom; y < bottom; y+=size) {
      for (int x=r.left, right=r.right; x < right; x+=size) {
        activateTile(x,y,i);
      }
    }
  }
  invalidate();
}","The original code had a critical concurrency issue where tile removal from `mActiveTiles` occurred outside the synchronized block, potentially causing race conditions and inconsistent state. The fixed code moves the tile removal logic inside the synchronized block, ensuring thread-safe modification of the `mActiveTiles` collection during tile layout. This change prevents potential concurrent modification errors and guarantees consistent tile management during the rendering process."
38674,"private float getMinimalScale(Box b){
  float wFactor=1.0f;
  float hFactor=1.0f;
  int viewW, viewH;
  if (!mFilmMode && mConstrained && b == mBoxes.get(0)) {
    viewW=mConstrainedFrame.width();
    viewH=mConstrainedFrame.height();
  }
 else {
    viewW=mViewW;
    viewH=mViewH;
  }
  if (mFilmMode) {
    if (mViewH > mViewW) {
      wFactor=FILM_MODE_PORTRAIT_WIDTH;
      hFactor=FILM_MODE_PORTRAIT_HEIGHT;
    }
 else {
      wFactor=FILM_MODE_LANDSCAPE_WIDTH;
      hFactor=FILM_MODE_LANDSCAPE_HEIGHT;
    }
  }
  float s=Math.min(wFactor * viewW / b.mImageW,hFactor * viewH / b.mImageH);
  return Math.min(SCALE_LIMIT,s);
}","private float getMinimalScale(Box b){
  float wFactor=1.0f;
  float hFactor=1.0f;
  int viewW, viewH;
  if (!mFilmMode && mConstrained && !mConstrainedFrame.isEmpty()&& b == mBoxes.get(0)) {
    viewW=mConstrainedFrame.width();
    viewH=mConstrainedFrame.height();
  }
 else {
    viewW=mViewW;
    viewH=mViewH;
  }
  if (mFilmMode) {
    if (mViewH > mViewW) {
      wFactor=FILM_MODE_PORTRAIT_WIDTH;
      hFactor=FILM_MODE_PORTRAIT_HEIGHT;
    }
 else {
      wFactor=FILM_MODE_LANDSCAPE_WIDTH;
      hFactor=FILM_MODE_LANDSCAPE_HEIGHT;
    }
  }
  float s=Math.min(wFactor * viewW / b.mImageW,hFactor * viewH / b.mImageH);
  return Math.min(SCALE_LIMIT,s);
}","The original code lacked a null check on mConstrainedFrame, potentially causing a null pointer exception when accessing its width and height. The fixed code adds a null check with !mConstrainedFrame.isEmpty() to ensure safe access to the frame's dimensions. This modification prevents potential runtime errors and improves the method's robustness by safely handling cases where the constrained frame might be uninitialized or empty."
38675,"protected void drawContent(GLCanvas canvas,Texture content,int width,int height,int rotation){
  canvas.save(GLCanvas.SAVE_FLAG_MATRIX);
  if (rotation != 0) {
    canvas.rotate(rotation,0,0,1);
    if (((rotation % 90) & 1) != 0) {
      int temp=height;
      height=width;
      width=height;
    }
  }
  float scale=Math.min((float)width / content.getWidth(),(float)height / content.getHeight());
  canvas.scale(scale,scale,1);
  content.draw(canvas,0,0);
  canvas.restore();
}","protected void drawContent(GLCanvas canvas,Texture content,int width,int height,int rotation){
  canvas.save(GLCanvas.SAVE_FLAG_MATRIX);
  if (rotation != 0) {
    canvas.translate(width / 2,height / 2);
    canvas.rotate(rotation,0,0,1);
    canvas.translate(-width / 2,-height / 2);
    if (((rotation % 90) & 1) != 0) {
      int temp=height;
      height=width;
      width=height;
    }
  }
  float scale=Math.min((float)width / content.getWidth(),(float)height / content.getHeight());
  canvas.scale(scale,scale,1);
  content.draw(canvas,0,0);
  canvas.restore();
}","The original code rotates the canvas without properly translating its origin, causing incorrect positioning and scaling of the content. The fixed code adds translation before and after rotation, centering the rotation around the canvas's midpoint and ensuring accurate placement. This modification preserves the intended visual transformation while maintaining the correct spatial relationship of the rotated content."
38676,"@Override @SuppressWarnings(""String_Node_Str"") public ArrayList<MediaSet> run(JobContext jc){
  BucketEntry[] entries=loadBucketEntries(jc);
  if (jc.isCancelled())   return null;
  int offset=0;
  int index=findBucket(entries,MediaSetUtils.CAMERA_BUCKET_ID);
  if (index != -1) {
    circularShiftRight(entries,offset++,index);
  }
  index=findBucket(entries,MediaSetUtils.DOWNLOAD_BUCKET_ID);
  if (index != -1) {
    circularShiftRight(entries,offset++,index);
  }
  ArrayList<MediaSet> albums=new ArrayList<MediaSet>();
  DataManager dataManager=mApplication.getDataManager();
  for (  BucketEntry entry : entries) {
    MediaSet album=getLocalAlbum(dataManager,mType,mPath,entry.bucketId,entry.bucketName);
    album.reload();
    albums.add(album);
  }
  return albums;
}","@Override @SuppressWarnings(""String_Node_Str"") public ArrayList<MediaSet> run(JobContext jc){
  BucketEntry[] entries=loadBucketEntries(jc);
  if (jc.isCancelled())   return null;
  int offset=0;
  int index=findBucket(entries,MediaSetUtils.CAMERA_BUCKET_ID);
  if (index != -1) {
    circularShiftRight(entries,offset++,index);
  }
  index=findBucket(entries,MediaSetUtils.DOWNLOAD_BUCKET_ID);
  if (index != -1) {
    circularShiftRight(entries,offset++,index);
  }
  ArrayList<MediaSet> albums=new ArrayList<MediaSet>();
  DataManager dataManager=mApplication.getDataManager();
  for (  BucketEntry entry : entries) {
    MediaSet album=getLocalAlbum(dataManager,mType,mPath,entry.bucketId,entry.bucketName);
    albums.add(album);
  }
  return albums;
}","The original code unnecessarily called `album.reload()` before adding each album to the list, which could cause performance overhead and potential synchronization issues. The fixed code removes the `reload()` method call, allowing albums to be added directly without premature reloading. This optimization improves efficiency by avoiding redundant data refreshing and ensures a more streamlined album collection process."
38677,"@Override public synchronized long reload(){
  if (mNotifierImage.isDirty() | mNotifierVideo.isDirty()) {
    if (mLoadTask != null)     mLoadTask.cancel();
    mLoadTask=mApplication.getThreadPool().submit(new AlbumsLoader(),this);
  }
  if (mLoadBuffer != null) {
    mAlbums=mLoadBuffer;
    mLoadBuffer=null;
    mDataVersion=nextVersionNumber();
  }
  return mDataVersion;
}","@Override public synchronized long reload(){
  if (mNotifierImage.isDirty() | mNotifierVideo.isDirty()) {
    if (mLoadTask != null)     mLoadTask.cancel();
    mLoadTask=mApplication.getThreadPool().submit(new AlbumsLoader(),this);
  }
  if (mLoadBuffer != null) {
    mAlbums=mLoadBuffer;
    mLoadBuffer=null;
    for (    MediaSet album : mAlbums) {
      album.reload();
    }
    mDataVersion=nextVersionNumber();
  }
  return mDataVersion;
}","The original code did not reload individual albums within the collection, potentially leaving stale data unrefreshed. The fixed code adds a `reload()` call for each album in `mAlbums`, ensuring that all nested media sets are updated when the load buffer is populated. This change guarantees comprehensive data refreshing, preventing potential inconsistencies in the album collection's state and improving overall data synchronization."
38678,"@Override public synchronized long reload(){
  if (mNotifier.isDirty()) {
    if (mLoadTask != null)     mLoadTask.cancel();
    mLoadTask=mApplication.getThreadPool().submit(new DevicesLoader(),this);
  }
  if (mLoadBuffer != null) {
    mDeviceSet=mLoadBuffer;
    mLoadBuffer=null;
    mDataVersion=nextVersionNumber();
  }
  return mDataVersion;
}","@Override public synchronized long reload(){
  if (mNotifier.isDirty()) {
    if (mLoadTask != null)     mLoadTask.cancel();
    mLoadTask=mApplication.getThreadPool().submit(new DevicesLoader(),this);
  }
  if (mLoadBuffer != null) {
    mDeviceSet=mLoadBuffer;
    mLoadBuffer=null;
    for (    MediaSet device : mDeviceSet) {
      device.reload();
    }
    mDataVersion=nextVersionNumber();
  }
  return mDataVersion;
}","The original code did not reload individual devices within the device set after updating mDeviceSet, potentially leaving stale data unrefreshed. The fixed code adds a for-loop that calls reload() on each device in mDeviceSet, ensuring that all individual devices are updated when the set changes. This modification guarantees data consistency and prevents potential staleness by explicitly refreshing each device's internal state during the reload process."
38679,"@Override public ArrayList<MediaSet> run(JobContext jc){
  DataManager dataManager=mApplication.getDataManager();
  ArrayList<MediaSet> result=new ArrayList<MediaSet>();
  List<android.mtp.MtpDevice> devices=mMtpContext.getMtpClient().getDeviceList();
  Log.v(TAG,""String_Node_Str"" + devices + ""String_Node_Str""+ devices.size());
  for (  android.mtp.MtpDevice mtpDevice : devices) {
synchronized (DataManager.LOCK) {
      int deviceId=mtpDevice.getDeviceId();
      Path childPath=mPath.getChild(deviceId);
      MtpDevice device=(MtpDevice)dataManager.peekMediaObject(childPath);
      if (device == null) {
        device=new MtpDevice(childPath,mApplication,deviceId,mMtpContext);
      }
      Log.d(TAG,""String_Node_Str"" + device);
      result.add(device);
    }
  }
  Collections.sort(result,MediaSetUtils.NAME_COMPARATOR);
  for (int i=0, n=result.size(); i < n; ++i) {
    result.get(i).reload();
  }
  return result;
}","@Override public ArrayList<MediaSet> run(JobContext jc){
  DataManager dataManager=mApplication.getDataManager();
  ArrayList<MediaSet> result=new ArrayList<MediaSet>();
  List<android.mtp.MtpDevice> devices=mMtpContext.getMtpClient().getDeviceList();
  Log.v(TAG,""String_Node_Str"" + devices + ""String_Node_Str""+ devices.size());
  for (  android.mtp.MtpDevice mtpDevice : devices) {
synchronized (DataManager.LOCK) {
      int deviceId=mtpDevice.getDeviceId();
      Path childPath=mPath.getChild(deviceId);
      MtpDevice device=(MtpDevice)dataManager.peekMediaObject(childPath);
      if (device == null) {
        device=new MtpDevice(childPath,mApplication,deviceId,mMtpContext);
      }
      Log.d(TAG,""String_Node_Str"" + device);
      result.add(device);
    }
  }
  Collections.sort(result,MediaSetUtils.NAME_COMPARATOR);
  return result;
}","The original code unnecessarily calls `reload()` on each MediaSet, which could cause performance overhead and potential synchronization issues. The fixed code removes the `reload()` loop, allowing consumers of this method to handle reloading as needed. By eliminating the automatic reload, the code becomes more flexible and efficient, reducing potential unnecessary processing and improving overall method performance."
38680,"protected void drawContent(GLCanvas canvas,Texture content,int width,int height,int rotation){
  canvas.save(GLCanvas.SAVE_FLAG_MATRIX);
  if (rotation != 0) {
    canvas.rotate(rotation,0,0,1);
    if (((rotation % 90) & 1) != 0) {
      int temp=height;
      height=width;
      width=height;
    }
  }
  float scale=Math.min((float)width / content.getWidth(),(float)height / content.getHeight());
  canvas.scale(scale,scale,1);
  content.draw(canvas,0,0);
  canvas.restore();
}","protected void drawContent(GLCanvas canvas,Texture content,int width,int height,int rotation){
  canvas.save(GLCanvas.SAVE_FLAG_MATRIX);
  if (rotation != 0) {
    canvas.translate(width / 2,height / 2);
    canvas.rotate(rotation,0,0,1);
    canvas.translate(-width / 2,-height / 2);
    if (((rotation % 90) & 1) != 0) {
      int temp=height;
      height=width;
      width=height;
    }
  }
  float scale=Math.min((float)width / content.getWidth(),(float)height / content.getHeight());
  canvas.scale(scale,scale,1);
  content.draw(canvas,0,0);
  canvas.restore();
}","The original code rotates the canvas without properly centering the rotation, causing incorrect positioning and scaling of the content. The fixed code adds translation before and after rotation, ensuring the content rotates around its center by moving the origin to the canvas midpoint before rotating and then translating back. This approach maintains the correct visual representation and prevents unintended distortion or misalignment during rotation."
38681,"@Override @SuppressWarnings(""String_Node_Str"") public ArrayList<MediaSet> run(JobContext jc){
  BucketEntry[] entries=loadBucketEntries(jc);
  if (jc.isCancelled())   return null;
  int offset=0;
  int index=findBucket(entries,MediaSetUtils.CAMERA_BUCKET_ID);
  if (index != -1) {
    circularShiftRight(entries,offset++,index);
  }
  index=findBucket(entries,MediaSetUtils.DOWNLOAD_BUCKET_ID);
  if (index != -1) {
    circularShiftRight(entries,offset++,index);
  }
  ArrayList<MediaSet> albums=new ArrayList<MediaSet>();
  DataManager dataManager=mApplication.getDataManager();
  for (  BucketEntry entry : entries) {
    MediaSet album=getLocalAlbum(dataManager,mType,mPath,entry.bucketId,entry.bucketName);
    album.reload();
    albums.add(album);
  }
  return albums;
}","@Override @SuppressWarnings(""String_Node_Str"") public ArrayList<MediaSet> run(JobContext jc){
  BucketEntry[] entries=loadBucketEntries(jc);
  if (jc.isCancelled())   return null;
  int offset=0;
  int index=findBucket(entries,MediaSetUtils.CAMERA_BUCKET_ID);
  if (index != -1) {
    circularShiftRight(entries,offset++,index);
  }
  index=findBucket(entries,MediaSetUtils.DOWNLOAD_BUCKET_ID);
  if (index != -1) {
    circularShiftRight(entries,offset++,index);
  }
  ArrayList<MediaSet> albums=new ArrayList<MediaSet>();
  DataManager dataManager=mApplication.getDataManager();
  for (  BucketEntry entry : entries) {
    MediaSet album=getLocalAlbum(dataManager,mType,mPath,entry.bucketId,entry.bucketName);
    albums.add(album);
  }
  return albums;
}","The original code unnecessarily called `album.reload()` before adding each album to the list, which could be performance-intensive and potentially cause unnecessary resource consumption. In the fixed code, the `reload()` method call is removed, allowing albums to be added directly without premature reloading. This optimization improves code efficiency by avoiding redundant method calls and reducing potential overhead during album processing."
38682,"@Override public synchronized long reload(){
  if (mNotifierImage.isDirty() | mNotifierVideo.isDirty()) {
    if (mLoadTask != null)     mLoadTask.cancel();
    mLoadTask=mApplication.getThreadPool().submit(new AlbumsLoader(),this);
  }
  if (mLoadBuffer != null) {
    mAlbums=mLoadBuffer;
    mLoadBuffer=null;
    mDataVersion=nextVersionNumber();
  }
  return mDataVersion;
}","@Override public synchronized long reload(){
  if (mNotifierImage.isDirty() | mNotifierVideo.isDirty()) {
    if (mLoadTask != null)     mLoadTask.cancel();
    mLoadTask=mApplication.getThreadPool().submit(new AlbumsLoader(),this);
  }
  if (mLoadBuffer != null) {
    mAlbums=mLoadBuffer;
    mLoadBuffer=null;
    for (    MediaSet album : mAlbums) {
      album.reload();
    }
    mDataVersion=nextVersionNumber();
  }
  return mDataVersion;
}","The original code did not recursively reload child albums when updating the album list, potentially leaving some media sets in a stale state. The fixed code adds a loop that calls `reload()` on each album in `mAlbums`, ensuring that all child albums are refreshed when the parent album is reloaded. This change guarantees consistent data across the entire album hierarchy and prevents potential synchronization issues with media sets."
38683,"@Override public synchronized long reload(){
  if (mNotifier.isDirty()) {
    if (mLoadTask != null)     mLoadTask.cancel();
    mLoadTask=mApplication.getThreadPool().submit(new DevicesLoader(),this);
  }
  if (mLoadBuffer != null) {
    mDeviceSet=mLoadBuffer;
    mLoadBuffer=null;
    mDataVersion=nextVersionNumber();
  }
  return mDataVersion;
}","@Override public synchronized long reload(){
  if (mNotifier.isDirty()) {
    if (mLoadTask != null)     mLoadTask.cancel();
    mLoadTask=mApplication.getThreadPool().submit(new DevicesLoader(),this);
  }
  if (mLoadBuffer != null) {
    mDeviceSet=mLoadBuffer;
    mLoadBuffer=null;
    for (    MediaSet device : mDeviceSet) {
      device.reload();
    }
    mDataVersion=nextVersionNumber();
  }
  return mDataVersion;
}","The original code did not reload individual devices within the device set after updating mDeviceSet, potentially leaving some device data stale. The fixed code adds a loop that calls reload() on each device in mDeviceSet, ensuring all devices are refreshed when new data is loaded. This modification guarantees that all devices are synchronized and up-to-date before incrementing the data version number, preventing potential inconsistencies in the device set."
38684,"@Override public ArrayList<MediaSet> run(JobContext jc){
  DataManager dataManager=mApplication.getDataManager();
  ArrayList<MediaSet> result=new ArrayList<MediaSet>();
  List<android.mtp.MtpDevice> devices=mMtpContext.getMtpClient().getDeviceList();
  Log.v(TAG,""String_Node_Str"" + devices + ""String_Node_Str""+ devices.size());
  for (  android.mtp.MtpDevice mtpDevice : devices) {
synchronized (DataManager.LOCK) {
      int deviceId=mtpDevice.getDeviceId();
      Path childPath=mPath.getChild(deviceId);
      MtpDevice device=(MtpDevice)dataManager.peekMediaObject(childPath);
      if (device == null) {
        device=new MtpDevice(childPath,mApplication,deviceId,mMtpContext);
      }
      Log.d(TAG,""String_Node_Str"" + device);
      result.add(device);
    }
  }
  Collections.sort(result,MediaSetUtils.NAME_COMPARATOR);
  for (int i=0, n=result.size(); i < n; ++i) {
    result.get(i).reload();
  }
  return result;
}","@Override public ArrayList<MediaSet> run(JobContext jc){
  DataManager dataManager=mApplication.getDataManager();
  ArrayList<MediaSet> result=new ArrayList<MediaSet>();
  List<android.mtp.MtpDevice> devices=mMtpContext.getMtpClient().getDeviceList();
  Log.v(TAG,""String_Node_Str"" + devices + ""String_Node_Str""+ devices.size());
  for (  android.mtp.MtpDevice mtpDevice : devices) {
synchronized (DataManager.LOCK) {
      int deviceId=mtpDevice.getDeviceId();
      Path childPath=mPath.getChild(deviceId);
      MtpDevice device=(MtpDevice)dataManager.peekMediaObject(childPath);
      if (device == null) {
        device=new MtpDevice(childPath,mApplication,deviceId,mMtpContext);
      }
      Log.d(TAG,""String_Node_Str"" + device);
      result.add(device);
    }
  }
  Collections.sort(result,MediaSetUtils.NAME_COMPARATOR);
  return result;
}","The original code unnecessarily calls `reload()` on each MediaSet after sorting, which could be performance-intensive and potentially trigger redundant data refreshes. The fixed code removes the `reload()` loop, eliminating the unnecessary method calls and potential performance overhead. By eliminating the redundant reload step, the fixed code ensures more efficient processing of MTP devices without compromising the core functionality of retrieving and sorting media sets."
38685,"void resume(){
  Activity activity=(Activity)mActivity;
  ActionBar actionBar=activity.getActionBar();
  if (actionBar != null) {
    if ((mFlags & FLAG_HIDE_ACTION_BAR) != 0) {
      actionBar.hide();
    }
 else {
      actionBar.show();
    }
    int stateCount=mActivity.getStateManager().getStateCount();
    actionBar.setDisplayOptions(stateCount == 1 ? 0 : ActionBar.DISPLAY_HOME_AS_UP,ActionBar.DISPLAY_HOME_AS_UP);
    actionBar.setHomeButtonEnabled((actionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0);
    actionBar.setDisplayShowTitleEnabled(true);
  }
  activity.invalidateOptionsMenu();
  final Window win=activity.getWindow();
  final WindowManager.LayoutParams params=win.getAttributes();
  if ((mFlags & FLAG_HIDE_STATUS_BAR) != 0) {
    params.systemUiVisibility=View.SYSTEM_UI_FLAG_LOW_PROFILE;
  }
 else {
    params.systemUiVisibility=View.SYSTEM_UI_FLAG_VISIBLE;
  }
  setScreenOnFlags(params);
  win.setAttributes(params);
  ResultEntry entry=mReceivedResults;
  if (entry != null) {
    mReceivedResults=null;
    onStateResult(entry.requestCode,entry.resultCode,entry.resultData);
  }
  if (0 != (mFlags & FLAG_SCREEN_ON)) {
    final IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    activity.registerReceiver(mPowerIntentReceiver,filter);
  }
  onResume();
}","void resume(){
  Activity activity=(Activity)mActivity;
  ActionBar actionBar=activity.getActionBar();
  if (actionBar != null) {
    if ((mFlags & FLAG_HIDE_ACTION_BAR) != 0) {
      actionBar.hide();
    }
 else {
      actionBar.show();
    }
    int stateCount=mActivity.getStateManager().getStateCount();
    actionBar.setDisplayOptions(stateCount == 1 ? 0 : ActionBar.DISPLAY_HOME_AS_UP,ActionBar.DISPLAY_HOME_AS_UP);
    actionBar.setHomeButtonEnabled((actionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0);
    actionBar.setDisplayShowTitleEnabled(true);
    actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);
  }
  activity.invalidateOptionsMenu();
  final Window win=activity.getWindow();
  final WindowManager.LayoutParams params=win.getAttributes();
  if ((mFlags & FLAG_HIDE_STATUS_BAR) != 0) {
    params.systemUiVisibility=View.SYSTEM_UI_FLAG_LOW_PROFILE;
  }
 else {
    params.systemUiVisibility=View.SYSTEM_UI_FLAG_VISIBLE;
  }
  setScreenOnFlags(params);
  win.setAttributes(params);
  ResultEntry entry=mReceivedResults;
  if (entry != null) {
    mReceivedResults=null;
    onStateResult(entry.requestCode,entry.resultCode,entry.resultData);
  }
  if (0 != (mFlags & FLAG_SCREEN_ON)) {
    final IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    activity.registerReceiver(mPowerIntentReceiver,filter);
  }
  onResume();
}","The original code lacked proper ActionBar configuration, potentially leaving navigation mode undefined and causing inconsistent UI behavior. The fixed code adds `actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD)`, explicitly setting the navigation mode to a standard state and ensuring consistent ActionBar presentation. This change provides more predictable and stable ActionBar rendering across different activity states, improving overall user interface reliability."
38686,"@Override public void onPause(){
  super.onPause();
  mIsActive=false;
  mActionModeHandler.pause();
  mAlbumSetDataAdapter.pause();
  mAlbumSetView.pause();
  mEyePosition.pause();
  DetailsHelper.pause();
  GalleryActionBar actionBar=mActivity.getGalleryActionBar();
  if (actionBar != null)   actionBar.hideClusterMenu();
  if (mSyncTask != null) {
    mSyncTask.cancel();
    mSyncTask=null;
    clearLoadingBit(BIT_LOADING_SYNC);
  }
  GalleryUtils.setSpinnerVisibility((Activity)mActivity,false);
}","@Override public void onPause(){
  super.onPause();
  mIsActive=false;
  mActionModeHandler.pause();
  mAlbumSetDataAdapter.pause();
  mAlbumSetView.pause();
  mEyePosition.pause();
  DetailsHelper.pause();
  GalleryActionBar actionBar=mActivity.getGalleryActionBar();
  if (actionBar != null)   actionBar.disableClusterMenu(false);
  if (mSyncTask != null) {
    mSyncTask.cancel();
    mSyncTask=null;
    clearLoadingBit(BIT_LOADING_SYNC);
  }
  GalleryUtils.setSpinnerVisibility((Activity)mActivity,false);
}","The original code uses `hideClusterMenu()`, which might abruptly remove the cluster menu without proper state management. The fixed code replaces this with `disableClusterMenu(false)`, which likely provides a more controlled and graceful method of deactivating the menu during the pause state. This change ensures smoother UI transitions and prevents potential unexpected behavior when the activity is paused."
38687,"public void onSelectionModeChange(int mode){
switch (mode) {
case SelectionManager.ENTER_SELECTION_MODE:
{
      mActivity.getGalleryActionBar().hideClusterMenu();
      mActionMode=mActionModeHandler.startActionMode();
      mVibrator.vibrate(100);
      break;
    }
case SelectionManager.LEAVE_SELECTION_MODE:
{
    mActionMode.finish();
    if (mShowClusterMenu) {
      mActivity.getGalleryActionBar().showClusterMenu(mSelectedAction,this);
    }
    mRootPane.invalidate();
    break;
  }
case SelectionManager.SELECT_ALL_MODE:
{
  mActionModeHandler.setTitle(getSelectedString());
  mRootPane.invalidate();
  break;
}
}
}","public void onSelectionModeChange(int mode){
switch (mode) {
case SelectionManager.ENTER_SELECTION_MODE:
{
      mActivity.getGalleryActionBar().disableClusterMenu(true);
      mActionMode=mActionModeHandler.startActionMode();
      mVibrator.vibrate(100);
      break;
    }
case SelectionManager.LEAVE_SELECTION_MODE:
{
    mActionMode.finish();
    if (mShowClusterMenu) {
      mActivity.getGalleryActionBar().enableClusterMenu(mSelectedAction,this);
    }
    mRootPane.invalidate();
    break;
  }
case SelectionManager.SELECT_ALL_MODE:
{
  mActionModeHandler.setTitle(getSelectedString());
  mRootPane.invalidate();
  break;
}
}
}","The original code incorrectly uses `hideClusterMenu()` and `showClusterMenu()`, which likely do not properly manage menu visibility during selection modes. The fixed code replaces these methods with `disableClusterMenu(true)` and `enableClusterMenu()`, which provide more precise control over menu state and interaction during selection. These changes ensure a more robust and predictable user interface behavior when transitioning between different selection modes in the gallery application."
38688,"@Override public void onResume(){
  super.onResume();
  mIsActive=true;
  setContentPane(mRootPane);
  setLoadingBit(BIT_LOADING_RELOAD);
  mAlbumSetDataAdapter.resume();
  mAlbumSetView.resume();
  mEyePosition.resume();
  mActionModeHandler.resume();
  GalleryActionBar actionBar=mActivity.getGalleryActionBar();
  if (mShowClusterMenu && actionBar != null) {
    actionBar.showClusterMenu(mSelectedAction,this);
  }
  if (!mInitialSynced) {
    setLoadingBit(BIT_LOADING_SYNC);
    mSyncTask=mMediaSet.requestSync(AlbumSetPage.this);
  }
}","@Override public void onResume(){
  super.onResume();
  mIsActive=true;
  setContentPane(mRootPane);
  setLoadingBit(BIT_LOADING_RELOAD);
  mAlbumSetDataAdapter.resume();
  mAlbumSetView.resume();
  mEyePosition.resume();
  mActionModeHandler.resume();
  GalleryActionBar actionBar=mActivity.getGalleryActionBar();
  if (mShowClusterMenu && actionBar != null) {
    actionBar.enableClusterMenu(mSelectedAction,this);
  }
  if (!mInitialSynced) {
    setLoadingBit(BIT_LOADING_SYNC);
    mSyncTask=mMediaSet.requestSync(AlbumSetPage.this);
  }
}","The original code used `showClusterMenu()`, which might incorrectly display or manipulate the cluster menu without proper state management. The fixed code replaces this with `enableClusterMenu()`, which properly enables the cluster menu with the selected action and current context. This change ensures more precise and controlled menu interaction, preventing potential UI inconsistencies or unexpected menu behaviors in the gallery application."
38689,"void resume(){
  Activity activity=(Activity)mActivity;
  ActionBar actionBar=activity.getActionBar();
  if (actionBar != null) {
    if ((mFlags & FLAG_HIDE_ACTION_BAR) != 0) {
      actionBar.hide();
    }
 else {
      actionBar.show();
    }
    int stateCount=mActivity.getStateManager().getStateCount();
    actionBar.setDisplayOptions(stateCount == 1 ? 0 : ActionBar.DISPLAY_HOME_AS_UP,ActionBar.DISPLAY_HOME_AS_UP);
    actionBar.setHomeButtonEnabled(true);
  }
  activity.invalidateOptionsMenu();
  final Window win=activity.getWindow();
  final WindowManager.LayoutParams params=win.getAttributes();
  if ((mFlags & FLAG_HIDE_STATUS_BAR) != 0) {
    params.systemUiVisibility=View.SYSTEM_UI_FLAG_LOW_PROFILE;
  }
 else {
    params.systemUiVisibility=View.SYSTEM_UI_FLAG_VISIBLE;
  }
  setScreenOnFlags(params);
  win.setAttributes(params);
  ResultEntry entry=mReceivedResults;
  if (entry != null) {
    mReceivedResults=null;
    onStateResult(entry.requestCode,entry.resultCode,entry.resultData);
  }
  if (0 != (mFlags & FLAG_SCREEN_ON)) {
    final IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    activity.registerReceiver(mPowerIntentReceiver,filter);
  }
  onResume();
}","void resume(){
  Activity activity=(Activity)mActivity;
  ActionBar actionBar=activity.getActionBar();
  if (actionBar != null) {
    if ((mFlags & FLAG_HIDE_ACTION_BAR) != 0) {
      actionBar.hide();
    }
 else {
      actionBar.show();
    }
    int stateCount=mActivity.getStateManager().getStateCount();
    actionBar.setDisplayOptions(stateCount == 1 ? 0 : ActionBar.DISPLAY_HOME_AS_UP,ActionBar.DISPLAY_HOME_AS_UP);
    actionBar.setHomeButtonEnabled((actionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0);
  }
  activity.invalidateOptionsMenu();
  final Window win=activity.getWindow();
  final WindowManager.LayoutParams params=win.getAttributes();
  if ((mFlags & FLAG_HIDE_STATUS_BAR) != 0) {
    params.systemUiVisibility=View.SYSTEM_UI_FLAG_LOW_PROFILE;
  }
 else {
    params.systemUiVisibility=View.SYSTEM_UI_FLAG_VISIBLE;
  }
  setScreenOnFlags(params);
  win.setAttributes(params);
  ResultEntry entry=mReceivedResults;
  if (entry != null) {
    mReceivedResults=null;
    onStateResult(entry.requestCode,entry.resultCode,entry.resultData);
  }
  if (0 != (mFlags & FLAG_SCREEN_ON)) {
    final IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    activity.registerReceiver(mPowerIntentReceiver,filter);
  }
  onResume();
}","The original code incorrectly enabled the home button without checking if the home-as-up display option was actually set. The fixed code modifies the `setHomeButtonEnabled()` method to only enable the home button when the ActionBar's display options include the `DISPLAY_HOME_AS_UP` flag. This ensures that the home button is only activated when appropriate, preventing potential navigation inconsistencies and improving the app's user interface behavior."
38690,"private void onBitmapRegionDecoderAvailable(BitmapRegionDecoder regionDecoder){
  if (regionDecoder == null) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    finish();
    return;
  }
  mRegionDecoder=regionDecoder;
  mUseRegionDecoder=true;
  mState=STATE_LOADED;
  BitmapFactory.Options options=new BitmapFactory.Options();
  int width=regionDecoder.getWidth();
  int height=regionDecoder.getHeight();
  options.inSampleSize=BitmapUtils.computeSampleSize(width,height,BitmapUtils.UNCONSTRAINED,BACKUP_PIXEL_COUNT);
  mBitmap=regionDecoder.decodeRegion(new Rect(0,0,width,height),options);
  mCropView.setDataModel(new TileImageViewAdapter(mBitmap,regionDecoder),mMediaItem.getRotation());
  if (mDoFaceDetection) {
    mCropView.detectFaces(mBitmap);
  }
 else {
    mCropView.initializeHighlightRectangle();
  }
}","private void onBitmapRegionDecoderAvailable(BitmapRegionDecoder regionDecoder){
  if (regionDecoder == null) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    finish();
    return;
  }
  mRegionDecoder=regionDecoder;
  mUseRegionDecoder=true;
  mState=STATE_LOADED;
  BitmapFactory.Options options=new BitmapFactory.Options();
  int width=regionDecoder.getWidth();
  int height=regionDecoder.getHeight();
  options.inSampleSize=BitmapUtils.computeSampleSize(width,height,BitmapUtils.UNCONSTRAINED,BACKUP_PIXEL_COUNT);
  mBitmap=regionDecoder.decodeRegion(new Rect(0,0,width,height),options);
  mCropView.setDataModel(new TileImageViewAdapter(mBitmap,regionDecoder),mMediaItem.getFullImageRotation());
  if (mDoFaceDetection) {
    mCropView.detectFaces(mBitmap);
  }
 else {
    mCropView.initializeHighlightRectangle();
  }
}","The original code used `mMediaItem.getRotation()`, which might not provide the full image rotation needed for accurate image orientation. The fixed code replaces this with `mMediaItem.getFullImageRotation()`, which ensures the correct rotation is applied when setting the data model for the crop view. This change guarantees that the image is displayed with its proper orientation, preventing potential visual distortions or misalignments during image processing."
38691,"private Bitmap getCroppedImage(Rect rect){
  Utils.assertTrue(rect.width() > 0 && rect.height() > 0);
  Bundle extras=getIntent().getExtras();
  int outputX=rect.width();
  int outputY=rect.height();
  if (extras != null) {
    outputX=extras.getInt(KEY_OUTPUT_X,outputX);
    outputY=extras.getInt(KEY_OUTPUT_Y,outputY);
  }
  if (outputX * outputY > MAX_PIXEL_COUNT) {
    float scale=(float)Math.sqrt((double)MAX_PIXEL_COUNT / outputX / outputY);
    Log.w(TAG,""String_Node_Str"" + scale);
    outputX=Math.round(scale * outputX);
    outputY=Math.round(scale * outputY);
  }
  float scaleX=1;
  float scaleY=1;
  Rect dest=new Rect(0,0,outputX,outputY);
  if (extras == null || extras.getBoolean(KEY_SCALE,true)) {
    scaleX=(float)outputX / rect.width();
    scaleY=(float)outputY / rect.height();
    if (extras == null || !extras.getBoolean(KEY_SCALE_UP_IF_NEEDED,false)) {
      if (scaleX > 1f)       scaleX=1;
      if (scaleY > 1f)       scaleY=1;
    }
  }
  int rectWidth=Math.round(rect.width() * scaleX);
  int rectHeight=Math.round(rect.height() * scaleY);
  dest.set(Math.round((outputX - rectWidth) / 2f),Math.round((outputY - rectHeight) / 2f),Math.round((outputX + rectWidth) / 2f),Math.round((outputY + rectHeight) / 2f));
  if (mBitmapInIntent != null) {
    Bitmap source=mBitmapInIntent;
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    canvas.drawBitmap(source,rect,dest,null);
    return result;
  }
  int rotation=mMediaItem.getFullImageRotation();
  rotateRectangle(rect,mCropView.getImageWidth(),mCropView.getImageHeight(),360 - rotation);
  rotateRectangle(dest,outputX,outputY,360 - rotation);
  if (mUseRegionDecoder) {
    BitmapFactory.Options options=new BitmapFactory.Options();
    int sample=BitmapUtils.computeSampleSizeLarger(Math.max(scaleX,scaleY));
    options.inSampleSize=sample;
    if ((rect.width() / sample) == dest.width() && (rect.height() / sample) == dest.height() && rotation == 0) {
synchronized (mRegionDecoder) {
        return mRegionDecoder.decodeRegion(rect,options);
      }
    }
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    rotateCanvas(canvas,outputX,outputY,rotation);
    drawInTiles(canvas,mRegionDecoder,rect,dest,sample);
    return result;
  }
 else {
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    rotateCanvas(canvas,outputX,outputY,rotation);
    canvas.drawBitmap(mBitmap,rect,dest,new Paint(Paint.FILTER_BITMAP_FLAG));
    return result;
  }
}","private Bitmap getCroppedImage(Rect rect){
  Utils.assertTrue(rect.width() > 0 && rect.height() > 0);
  Bundle extras=getIntent().getExtras();
  int outputX=rect.width();
  int outputY=rect.height();
  if (extras != null) {
    outputX=extras.getInt(KEY_OUTPUT_X,outputX);
    outputY=extras.getInt(KEY_OUTPUT_Y,outputY);
  }
  if (outputX * outputY > MAX_PIXEL_COUNT) {
    float scale=(float)Math.sqrt((double)MAX_PIXEL_COUNT / outputX / outputY);
    Log.w(TAG,""String_Node_Str"" + scale);
    outputX=Math.round(scale * outputX);
    outputY=Math.round(scale * outputY);
  }
  float scaleX=1;
  float scaleY=1;
  Rect dest=new Rect(0,0,outputX,outputY);
  if (extras == null || extras.getBoolean(KEY_SCALE,true)) {
    scaleX=(float)outputX / rect.width();
    scaleY=(float)outputY / rect.height();
    if (extras == null || !extras.getBoolean(KEY_SCALE_UP_IF_NEEDED,false)) {
      if (scaleX > 1f)       scaleX=1;
      if (scaleY > 1f)       scaleY=1;
    }
  }
  int rectWidth=Math.round(rect.width() * scaleX);
  int rectHeight=Math.round(rect.height() * scaleY);
  dest.set(Math.round((outputX - rectWidth) / 2f),Math.round((outputY - rectHeight) / 2f),Math.round((outputX + rectWidth) / 2f),Math.round((outputY + rectHeight) / 2f));
  if (mBitmapInIntent != null) {
    Bitmap source=mBitmapInIntent;
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    canvas.drawBitmap(source,rect,dest,null);
    return result;
  }
  if (mUseRegionDecoder) {
    int rotation=mMediaItem.getFullImageRotation();
    rotateRectangle(rect,mCropView.getImageWidth(),mCropView.getImageHeight(),360 - rotation);
    rotateRectangle(dest,outputX,outputY,360 - rotation);
    BitmapFactory.Options options=new BitmapFactory.Options();
    int sample=BitmapUtils.computeSampleSizeLarger(Math.max(scaleX,scaleY));
    options.inSampleSize=sample;
    if ((rect.width() / sample) == dest.width() && (rect.height() / sample) == dest.height() && rotation == 0) {
synchronized (mRegionDecoder) {
        return mRegionDecoder.decodeRegion(rect,options);
      }
    }
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    rotateCanvas(canvas,outputX,outputY,rotation);
    drawInTiles(canvas,mRegionDecoder,rect,dest,sample);
    return result;
  }
 else {
    int rotation=mMediaItem.getRotation();
    rotateRectangle(rect,mCropView.getImageWidth(),mCropView.getImageHeight(),360 - rotation);
    rotateRectangle(dest,outputX,outputY,360 - rotation);
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    rotateCanvas(canvas,outputX,outputY,rotation);
    canvas.drawBitmap(mBitmap,rect,dest,new Paint(Paint.FILTER_BITMAP_FLAG));
    return result;
  }
}","The original code inconsistently applied rotation logic, causing potential misalignment and incorrect image cropping across different decoder scenarios. The fixed code moves rotation calculations before specific decoding paths and uses consistent rotation methods for both region decoder and standard bitmap scenarios. This ensures uniform rotation handling, prevents potential rendering errors, and provides more predictable image cropping across different image processing contexts."
38692,"private void onBitmapRegionDecoderAvailable(BitmapRegionDecoder regionDecoder){
  if (regionDecoder == null) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    finish();
    return;
  }
  mRegionDecoder=regionDecoder;
  mUseRegionDecoder=true;
  mState=STATE_LOADED;
  BitmapFactory.Options options=new BitmapFactory.Options();
  int width=regionDecoder.getWidth();
  int height=regionDecoder.getHeight();
  options.inSampleSize=BitmapUtils.computeSampleSize(width,height,BitmapUtils.UNCONSTRAINED,BACKUP_PIXEL_COUNT);
  mBitmap=regionDecoder.decodeRegion(new Rect(0,0,width,height),options);
  mCropView.setDataModel(new TileImageViewAdapter(mBitmap,regionDecoder),mMediaItem.getRotation());
  if (mDoFaceDetection) {
    mCropView.detectFaces(mBitmap);
  }
 else {
    mCropView.initializeHighlightRectangle();
  }
}","private void onBitmapRegionDecoderAvailable(BitmapRegionDecoder regionDecoder){
  if (regionDecoder == null) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    finish();
    return;
  }
  mRegionDecoder=regionDecoder;
  mUseRegionDecoder=true;
  mState=STATE_LOADED;
  BitmapFactory.Options options=new BitmapFactory.Options();
  int width=regionDecoder.getWidth();
  int height=regionDecoder.getHeight();
  options.inSampleSize=BitmapUtils.computeSampleSize(width,height,BitmapUtils.UNCONSTRAINED,BACKUP_PIXEL_COUNT);
  mBitmap=regionDecoder.decodeRegion(new Rect(0,0,width,height),options);
  mCropView.setDataModel(new TileImageViewAdapter(mBitmap,regionDecoder),mMediaItem.getFullImageRotation());
  if (mDoFaceDetection) {
    mCropView.detectFaces(mBitmap);
  }
 else {
    mCropView.initializeHighlightRectangle();
  }
}","The original code used `mMediaItem.getRotation()`, which might not provide the full image rotation, potentially causing incorrect image orientation. The fixed code replaces this with `mMediaItem.getFullImageRotation()`, which ensures the complete rotation information is used when setting the data model. This change guarantees accurate image display by correctly accounting for the full rotation of the media item."
38693,"private Bitmap getCroppedImage(Rect rect){
  Utils.assertTrue(rect.width() > 0 && rect.height() > 0);
  Bundle extras=getIntent().getExtras();
  int outputX=rect.width();
  int outputY=rect.height();
  if (extras != null) {
    outputX=extras.getInt(KEY_OUTPUT_X,outputX);
    outputY=extras.getInt(KEY_OUTPUT_Y,outputY);
  }
  if (outputX * outputY > MAX_PIXEL_COUNT) {
    float scale=(float)Math.sqrt((double)MAX_PIXEL_COUNT / outputX / outputY);
    Log.w(TAG,""String_Node_Str"" + scale);
    outputX=Math.round(scale * outputX);
    outputY=Math.round(scale * outputY);
  }
  float scaleX=1;
  float scaleY=1;
  Rect dest=new Rect(0,0,outputX,outputY);
  if (extras == null || extras.getBoolean(KEY_SCALE,true)) {
    scaleX=(float)outputX / rect.width();
    scaleY=(float)outputY / rect.height();
    if (extras == null || !extras.getBoolean(KEY_SCALE_UP_IF_NEEDED,false)) {
      if (scaleX > 1f)       scaleX=1;
      if (scaleY > 1f)       scaleY=1;
    }
  }
  int rectWidth=Math.round(rect.width() * scaleX);
  int rectHeight=Math.round(rect.height() * scaleY);
  dest.set(Math.round((outputX - rectWidth) / 2f),Math.round((outputY - rectHeight) / 2f),Math.round((outputX + rectWidth) / 2f),Math.round((outputY + rectHeight) / 2f));
  if (mBitmapInIntent != null) {
    Bitmap source=mBitmapInIntent;
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    canvas.drawBitmap(source,rect,dest,null);
    return result;
  }
  int rotation=mMediaItem.getFullImageRotation();
  rotateRectangle(rect,mCropView.getImageWidth(),mCropView.getImageHeight(),360 - rotation);
  rotateRectangle(dest,outputX,outputY,360 - rotation);
  if (mUseRegionDecoder) {
    BitmapFactory.Options options=new BitmapFactory.Options();
    int sample=BitmapUtils.computeSampleSizeLarger(Math.max(scaleX,scaleY));
    options.inSampleSize=sample;
    if ((rect.width() / sample) == dest.width() && (rect.height() / sample) == dest.height() && rotation == 0) {
synchronized (mRegionDecoder) {
        return mRegionDecoder.decodeRegion(rect,options);
      }
    }
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    rotateCanvas(canvas,outputX,outputY,rotation);
    drawInTiles(canvas,mRegionDecoder,rect,dest,sample);
    return result;
  }
 else {
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    rotateCanvas(canvas,outputX,outputY,rotation);
    canvas.drawBitmap(mBitmap,rect,dest,new Paint(Paint.FILTER_BITMAP_FLAG));
    return result;
  }
}","private Bitmap getCroppedImage(Rect rect){
  Utils.assertTrue(rect.width() > 0 && rect.height() > 0);
  Bundle extras=getIntent().getExtras();
  int outputX=rect.width();
  int outputY=rect.height();
  if (extras != null) {
    outputX=extras.getInt(KEY_OUTPUT_X,outputX);
    outputY=extras.getInt(KEY_OUTPUT_Y,outputY);
  }
  if (outputX * outputY > MAX_PIXEL_COUNT) {
    float scale=(float)Math.sqrt((double)MAX_PIXEL_COUNT / outputX / outputY);
    Log.w(TAG,""String_Node_Str"" + scale);
    outputX=Math.round(scale * outputX);
    outputY=Math.round(scale * outputY);
  }
  float scaleX=1;
  float scaleY=1;
  Rect dest=new Rect(0,0,outputX,outputY);
  if (extras == null || extras.getBoolean(KEY_SCALE,true)) {
    scaleX=(float)outputX / rect.width();
    scaleY=(float)outputY / rect.height();
    if (extras == null || !extras.getBoolean(KEY_SCALE_UP_IF_NEEDED,false)) {
      if (scaleX > 1f)       scaleX=1;
      if (scaleY > 1f)       scaleY=1;
    }
  }
  int rectWidth=Math.round(rect.width() * scaleX);
  int rectHeight=Math.round(rect.height() * scaleY);
  dest.set(Math.round((outputX - rectWidth) / 2f),Math.round((outputY - rectHeight) / 2f),Math.round((outputX + rectWidth) / 2f),Math.round((outputY + rectHeight) / 2f));
  if (mBitmapInIntent != null) {
    Bitmap source=mBitmapInIntent;
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    canvas.drawBitmap(source,rect,dest,null);
    return result;
  }
  if (mUseRegionDecoder) {
    int rotation=mMediaItem.getFullImageRotation();
    rotateRectangle(rect,mCropView.getImageWidth(),mCropView.getImageHeight(),360 - rotation);
    rotateRectangle(dest,outputX,outputY,360 - rotation);
    BitmapFactory.Options options=new BitmapFactory.Options();
    int sample=BitmapUtils.computeSampleSizeLarger(Math.max(scaleX,scaleY));
    options.inSampleSize=sample;
    if ((rect.width() / sample) == dest.width() && (rect.height() / sample) == dest.height() && rotation == 0) {
synchronized (mRegionDecoder) {
        return mRegionDecoder.decodeRegion(rect,options);
      }
    }
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    rotateCanvas(canvas,outputX,outputY,rotation);
    drawInTiles(canvas,mRegionDecoder,rect,dest,sample);
    return result;
  }
 else {
    int rotation=mMediaItem.getRotation();
    rotateRectangle(rect,mCropView.getImageWidth(),mCropView.getImageHeight(),360 - rotation);
    rotateRectangle(dest,outputX,outputY,360 - rotation);
    Bitmap result=Bitmap.createBitmap(outputX,outputY,Config.ARGB_8888);
    Canvas canvas=new Canvas(result);
    rotateCanvas(canvas,outputX,outputY,rotation);
    canvas.drawBitmap(mBitmap,rect,dest,new Paint(Paint.FILTER_BITMAP_FLAG));
    return result;
  }
}","The original code incorrectly handled rotation and region decoding by mixing rotation logic across different code paths, potentially causing inconsistent image processing. The fixed code separates rotation handling for region decoder and non-region decoder cases, explicitly moving rotation-related operations before bitmap creation and ensuring consistent transformation logic. This refactoring improves code reliability by standardizing image rotation and cropping processes, reducing potential bugs and making the image processing more predictable across different scenarios."
38694,"public void onFutureDone(Future<Bitmap> future){
  mFuture=future;
  mMainHandler.sendMessage(mMainHandler.obtainMessage(MSG_RUN_OBJECT,this));
}","@Override public void onFutureDone(Future<Bitmap> future){
  mFuture=future;
  mMainHandler.sendMessage(mMainHandler.obtainMessage(MSG_RUN_OBJECT,this));
}","The original code lacks the `@Override` annotation, which helps catch potential method signature mismatches when implementing interfaces or extending classes. The fixed code adds the `@Override` annotation, explicitly indicating that this method is intended to override a method from a parent class or interface. This improvement enhances code clarity, provides compile-time verification, and helps prevent unintended method implementations."
38695,"private void updateScreenNail(long version,Future<Bitmap> future){
  ImageEntry entry=mImageCache.get(version);
  if (entry == null || entry.screenNailTask == null) {
    Bitmap screenNail=future.get();
    if (screenNail != null)     screenNail.recycle();
    return;
  }
  entry.screenNailTask=null;
  entry.screenNail=future.get();
  if (entry.screenNail == null) {
    entry.failToLoad=true;
  }
 else {
    if (mDataListener != null) {
      mDataListener.onPhotoAvailable(version,false);
    }
    for (int i=-1; i <= 1; ++i) {
      if (version == getVersion(mCurrentIndex + i)) {
        if (i == 0)         updateTileProvider(entry);
        mPhotoView.notifyImageInvalidated(i);
      }
    }
  }
  updateImageRequests();
}","private void updateScreenNail(long version,Future<Bitmap> future){
  ImageEntry entry=mImageCache.get(version);
  if (entry == null || entry.screenNailTask != future) {
    Bitmap screenNail=future.get();
    if (screenNail != null)     screenNail.recycle();
    return;
  }
  entry.screenNailTask=null;
  entry.screenNail=future.get();
  if (entry.screenNail == null) {
    entry.failToLoad=true;
  }
 else {
    if (mDataListener != null) {
      mDataListener.onPhotoAvailable(version,false);
    }
    for (int i=-1; i <= 1; ++i) {
      if (version == getVersion(mCurrentIndex + i)) {
        if (i == 0)         updateTileProvider(entry);
        mPhotoView.notifyImageInvalidated(i);
      }
    }
  }
  updateImageRequests();
}","The original code incorrectly checks if the entry is null or its screenNailTask is null, potentially processing unintended tasks. In the fixed code, the condition is changed to check if the entry's screenNailTask matches the current future, ensuring only the correct task is processed. This modification prevents unnecessary bitmap recycling and guarantees that only the intended image task is executed, improving the reliability of image loading and caching."
38696,"private void updateFullImage(long version,Future<BitmapRegionDecoder> future){
  ImageEntry entry=mImageCache.get(version);
  if (entry == null || entry.fullImageTask == null) {
    BitmapRegionDecoder fullImage=future.get();
    if (fullImage != null)     fullImage.recycle();
    return;
  }
  entry.fullImageTask=null;
  entry.fullImage=future.get();
  if (entry.fullImage != null) {
    if (mDataListener != null) {
      mDataListener.onPhotoAvailable(version,true);
    }
    if (version == getVersion(mCurrentIndex)) {
      updateTileProvider(entry);
      mPhotoView.notifyImageInvalidated(0);
    }
  }
  updateImageRequests();
}","private void updateFullImage(long version,Future<BitmapRegionDecoder> future){
  ImageEntry entry=mImageCache.get(version);
  if (entry == null || entry.fullImageTask != future) {
    BitmapRegionDecoder fullImage=future.get();
    if (fullImage != null)     fullImage.recycle();
    return;
  }
  entry.fullImageTask=null;
  entry.fullImage=future.get();
  if (entry.fullImage != null) {
    if (mDataListener != null) {
      mDataListener.onPhotoAvailable(version,true);
    }
    if (version == getVersion(mCurrentIndex)) {
      updateTileProvider(entry);
      mPhotoView.notifyImageInvalidated(0);
    }
  }
  updateImageRequests();
}","The original code incorrectly checks if the entry exists or its fullImageTask is null, which can lead to premature recycling of the image decoder. The fixed code changes the condition to check if the entry's fullImageTask matches the current future, ensuring that only the correct task is processed. This modification prevents potential race conditions and ensures that only the intended image decoder is used and managed correctly."
38697,"public void startAction(int action,int title,ProgressListener listener){
  ArrayList<Path> ids=mSelectionManager.getSelected(false);
  Utils.assertTrue(mDialog == null);
  Activity activity=(Activity)mActivity;
  mDialog=showProgressDialog(activity,title,ids.size());
  MediaOperation operation=new MediaOperation(action,ids,listener);
  mTask=mActivity.getThreadPool().submit(operation,null);
}","public void startAction(int action,int title,ProgressListener listener){
  ArrayList<Path> ids=mSelectionManager.getSelected(false);
  stopTaskAndDismissDialog();
  Activity activity=(Activity)mActivity;
  mDialog=showProgressDialog(activity,title,ids.size());
  MediaOperation operation=new MediaOperation(action,ids,listener);
  mTask=mActivity.getThreadPool().submit(operation,null);
}","The original code lacks a mechanism to stop any existing task or dismiss an existing progress dialog before starting a new one, potentially causing resource leaks or UI inconsistencies. The fixed code introduces `stopTaskAndDismissDialog()` to cancel any ongoing task and dismiss any existing dialog before initiating a new operation. This ensures clean resource management, prevents potential memory leaks, and provides a more robust approach to handling sequential media operations."
38698,"@Override public void handleMessage(Message message){
switch (message.what) {
case MSG_TASK_COMPLETE:
{
      if (mDialog != null) {
        mDialog.dismiss();
        mDialog=null;
        mTask=null;
      }
      if (message.obj != null) {
        ProgressListener listener=(ProgressListener)message.obj;
        listener.onProgressComplete(message.arg1);
      }
      mSelectionManager.leaveSelectionMode();
      break;
    }
case MSG_TASK_UPDATE:
{
    if (mDialog != null)     mDialog.setProgress(message.arg1);
    if (message.obj != null) {
      ProgressListener listener=(ProgressListener)message.obj;
      listener.onProgressUpdate(message.arg1);
    }
    break;
  }
case MSG_DO_SHARE:
{
  ((Activity)mActivity).startActivity((Intent)message.obj);
  break;
}
}
}","@Override public void handleMessage(Message message){
switch (message.what) {
case MSG_TASK_COMPLETE:
{
      stopTaskAndDismissDialog();
      if (message.obj != null) {
        ProgressListener listener=(ProgressListener)message.obj;
        listener.onProgressComplete(message.arg1);
      }
      mSelectionManager.leaveSelectionMode();
      break;
    }
case MSG_TASK_UPDATE:
{
    if (mDialog != null)     mDialog.setProgress(message.arg1);
    if (message.obj != null) {
      ProgressListener listener=(ProgressListener)message.obj;
      listener.onProgressUpdate(message.arg1);
    }
    break;
  }
case MSG_DO_SHARE:
{
  ((Activity)mActivity).startActivity((Intent)message.obj);
  break;
}
}
}","The original code directly handles dialog dismissal and task nullification within the MSG_TASK_COMPLETE case, which can lead to potential null pointer risks and code duplication. The fixed code extracts these operations into a separate method `stopTaskAndDismissDialog()`, which encapsulates the dialog and task cleanup logic in a single, reusable method. By centralizing the cleanup process, the fixed code improves code readability, reduces potential error points, and provides a cleaner, more maintainable approach to managing dialog and task state."
38699,"public Void run(JobContext jc){
  int index=0;
  DataManager manager=mActivity.getDataManager();
  int result=EXECUTION_RESULT_SUCCESS;
  for (  Path id : mItems) {
    if (jc.isCancelled()) {
      result=EXECUTION_RESULT_CANCEL;
      break;
    }
    try {
      if (!execute(manager,jc,mOperation,id))       result=EXECUTION_RESULT_FAIL;
    }
 catch (    Throwable th) {
      Log.e(TAG,""String_Node_Str"" + mOperation + ""String_Node_Str""+ id,th);
    }
    onProgressUpdate(index++,mListener);
  }
  onProgressComplete(result,mListener);
  return null;
}","public Void run(JobContext jc){
  int index=0;
  DataManager manager=mActivity.getDataManager();
  int result=EXECUTION_RESULT_SUCCESS;
  try {
    for (    Path id : mItems) {
      if (jc.isCancelled()) {
        result=EXECUTION_RESULT_CANCEL;
        break;
      }
      if (!execute(manager,jc,mOperation,id)) {
        result=EXECUTION_RESULT_FAIL;
      }
      onProgressUpdate(index++,mListener);
    }
  }
 catch (  Throwable th) {
    Log.e(TAG,""String_Node_Str"" + mOperation + ""String_Node_Str""+ th);
  }
 finally {
    onProgressComplete(result,mListener);
  }
  return null;
}","The original code lacks proper error handling and resource management, potentially leaving the progress completion unexecuted if an exception occurs during iteration. The fixed code introduces a try-catch block encompassing the entire loop, moves the error logging inside the catch block, and adds a finally block to ensure onProgressComplete is always called regardless of execution status. This approach guarantees consistent progress reporting, handles unexpected errors gracefully, and provides a more robust execution flow for the job processing."
38700,"public MenuExecutor(GalleryActivity activity,SelectionManager selectionManager){
  mActivity=Utils.checkNotNull(activity);
  mSelectionManager=Utils.checkNotNull(selectionManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_TASK_COMPLETE:
{
          if (mDialog != null) {
            mDialog.dismiss();
            mDialog=null;
            mTask=null;
          }
          if (message.obj != null) {
            ProgressListener listener=(ProgressListener)message.obj;
            listener.onProgressComplete(message.arg1);
          }
          mSelectionManager.leaveSelectionMode();
          break;
        }
case MSG_TASK_UPDATE:
{
        if (mDialog != null)         mDialog.setProgress(message.arg1);
        if (message.obj != null) {
          ProgressListener listener=(ProgressListener)message.obj;
          listener.onProgressUpdate(message.arg1);
        }
        break;
      }
case MSG_DO_SHARE:
{
      ((Activity)mActivity).startActivity((Intent)message.obj);
      break;
    }
}
}
}
;
}","public MenuExecutor(GalleryActivity activity,SelectionManager selectionManager){
  mActivity=Utils.checkNotNull(activity);
  mSelectionManager=Utils.checkNotNull(selectionManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_TASK_COMPLETE:
{
          stopTaskAndDismissDialog();
          if (message.obj != null) {
            ProgressListener listener=(ProgressListener)message.obj;
            listener.onProgressComplete(message.arg1);
          }
          mSelectionManager.leaveSelectionMode();
          break;
        }
case MSG_TASK_UPDATE:
{
        if (mDialog != null)         mDialog.setProgress(message.arg1);
        if (message.obj != null) {
          ProgressListener listener=(ProgressListener)message.obj;
          listener.onProgressUpdate(message.arg1);
        }
        break;
      }
case MSG_DO_SHARE:
{
      ((Activity)mActivity).startActivity((Intent)message.obj);
      break;
    }
}
}
}
;
}","The original code directly handled dialog dismissal and task nullification within the MSG_TASK_COMPLETE case, which could lead to potential null pointer exceptions and resource leaks. The fixed code introduces a new method `stopTaskAndDismissDialog()` to centralize and safely manage dialog and task cleanup, ensuring clean and consistent resource management. This refactoring improves code readability, reduces the risk of errors, and provides a more robust approach to handling task completion and dialog dismissal."
38701,"private boolean execute(DataManager manager,JobContext jc,int cmd,Path path){
  boolean result=true;
switch (cmd) {
case R.id.action_confirm_delete:
    manager.delete(path);
  break;
case R.id.action_rotate_cw:
manager.rotate(path,90);
break;
case R.id.action_rotate_ccw:
manager.rotate(path,-90);
break;
case R.id.action_toggle_full_caching:
{
MediaObject obj=manager.getMediaObject(path);
int cacheFlag=obj.getCacheFlag();
if (cacheFlag == MediaObject.CACHE_FLAG_FULL) {
cacheFlag=MediaObject.CACHE_FLAG_SCREENNAIL;
}
 else {
cacheFlag=MediaObject.CACHE_FLAG_FULL;
}
obj.cache(cacheFlag);
break;
}
case R.id.action_show_on_map:
{
MediaItem item=(MediaItem)manager.getMediaObject(path);
double latlng[]=new double[2];
item.getLatLong(latlng);
if (GalleryUtils.isValidLocation(latlng[0],latlng[1])) {
GalleryUtils.showOnMap((Context)mActivity,latlng[0],latlng[1]);
}
break;
}
case R.id.action_import:
{
MediaObject obj=manager.getMediaObject(path);
result=obj.Import();
break;
}
case R.id.action_edit:
{
Activity activity=(Activity)mActivity;
MediaItem item=(MediaItem)manager.getMediaObject(path);
try {
activity.startActivity(Intent.createChooser(new Intent(Intent.ACTION_EDIT).setDataAndType(item.getContentUri(),item.getMimeType()).setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION),null));
}
 catch (Throwable t) {
Log.w(TAG,""String_Node_Str"",t);
Toast.makeText(activity,activity.getString(R.string.activity_not_found),Toast.LENGTH_SHORT).show();
}
break;
}
default :
throw new AssertionError();
}
return result;
}","private boolean execute(DataManager manager,JobContext jc,int cmd,Path path){
  boolean result=true;
  Log.v(TAG,""String_Node_Str"" + cmd + ""String_Node_Str""+ path);
  long startTime=System.currentTimeMillis();
switch (cmd) {
case R.id.action_confirm_delete:
    manager.delete(path);
  break;
case R.id.action_rotate_cw:
manager.rotate(path,90);
break;
case R.id.action_rotate_ccw:
manager.rotate(path,-90);
break;
case R.id.action_toggle_full_caching:
{
MediaObject obj=manager.getMediaObject(path);
int cacheFlag=obj.getCacheFlag();
if (cacheFlag == MediaObject.CACHE_FLAG_FULL) {
cacheFlag=MediaObject.CACHE_FLAG_SCREENNAIL;
}
 else {
cacheFlag=MediaObject.CACHE_FLAG_FULL;
}
obj.cache(cacheFlag);
break;
}
case R.id.action_show_on_map:
{
MediaItem item=(MediaItem)manager.getMediaObject(path);
double latlng[]=new double[2];
item.getLatLong(latlng);
if (GalleryUtils.isValidLocation(latlng[0],latlng[1])) {
GalleryUtils.showOnMap((Context)mActivity,latlng[0],latlng[1]);
}
break;
}
case R.id.action_import:
{
MediaObject obj=manager.getMediaObject(path);
result=obj.Import();
break;
}
case R.id.action_edit:
{
Activity activity=(Activity)mActivity;
MediaItem item=(MediaItem)manager.getMediaObject(path);
try {
activity.startActivity(Intent.createChooser(new Intent(Intent.ACTION_EDIT).setDataAndType(item.getContentUri(),item.getMimeType()).setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION),null));
}
 catch (Throwable t) {
Log.w(TAG,""String_Node_Str"",t);
Toast.makeText(activity,activity.getString(R.string.activity_not_found),Toast.LENGTH_SHORT).show();
}
break;
}
default :
throw new AssertionError();
}
Log.v(TAG,""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str""+ path);
return result;
}","The original code lacked logging and performance tracking, making debugging and performance analysis difficult. The fixed code adds logging statements at the method's start and end, capturing the command, path, and execution time, which provides valuable diagnostic information. These additions enable developers to trace method execution, identify potential bottlenecks, and more effectively troubleshoot issues in the application's data management workflow."
38702,"public void pause(){
  if (mTask != null) {
    mTask.cancel();
    mTask.waitDone();
    mDialog.dismiss();
    mDialog=null;
    mTask=null;
  }
}","public void pause(){
  stopTaskAndDismissDialog();
}","The original code directly calls multiple methods on potentially null objects, risking null pointer exceptions and creating tight coupling between task cancellation, waiting, and dialog dismissal. The fixed code introduces a separate method `stopTaskAndDismissDialog()` that encapsulates the entire sequence of operations, providing a cleaner and safer approach to handling task and dialog lifecycle management. This refactoring improves code readability, reduces error-prone direct method chaining, and centralizes the pause logic in a single, well-defined method."
38703,"public void prepareTextures(){
  if (mTileDecoder == null) {
    mTileDecoder=mThreadPool.submit(new TileDecoder());
  }
  if (mIsTextureFreed) {
    layoutTiles(mCenterX,mCenterY,mScale,mRotation);
    mIsTextureFreed=false;
    updateBackupTexture(mModel.getBackupImage());
  }
}","public void prepareTextures(){
  if (mTileDecoder == null) {
    mTileDecoder=mThreadPool.submit(new TileDecoder());
  }
  if (mIsTextureFreed) {
    layoutTiles(mCenterX,mCenterY,mScale,mRotation);
    mIsTextureFreed=false;
    updateBackupTexture(mModel != null ? mModel.getBackupImage() : null);
  }
}","The original code lacks a null check on `mModel` before calling `getBackupImage()`, which could lead to a NullPointerException if `mModel` is null. The fixed code adds a ternary operator that safely handles this scenario by returning null if `mModel` is null, preventing potential runtime crashes. This defensive programming approach ensures robust error handling and prevents unexpected application termination when the model is uninitialized."
38704,"public void startAction(int action,int title,ProgressListener listener){
  ArrayList<Path> ids=mSelectionManager.getSelected(false);
  Utils.assertTrue(mDialog == null);
  Activity activity=(Activity)mActivity;
  mDialog=showProgressDialog(activity,title,ids.size());
  MediaOperation operation=new MediaOperation(action,ids,listener);
  mTask=mActivity.getThreadPool().submit(operation,null);
}","public void startAction(int action,int title,ProgressListener listener){
  ArrayList<Path> ids=mSelectionManager.getSelected(false);
  stopTaskAndDismissDialog();
  Activity activity=(Activity)mActivity;
  mDialog=showProgressDialog(activity,title,ids.size());
  MediaOperation operation=new MediaOperation(action,ids,listener);
  mTask=mActivity.getThreadPool().submit(operation,null);
}","The original code lacks a mechanism to stop any existing task or dismiss any previous dialog before starting a new operation, potentially causing resource leaks or unexpected behavior. The fixed code introduces `stopTaskAndDismissDialog()` to explicitly terminate any ongoing task and close any existing dialog before initiating a new action. This ensures clean resource management, prevents potential memory leaks, and provides a more robust approach to handling sequential media operations."
38705,"@Override public void handleMessage(Message message){
switch (message.what) {
case MSG_TASK_COMPLETE:
{
      if (mDialog != null) {
        mDialog.dismiss();
        mDialog=null;
        mTask=null;
      }
      if (message.obj != null) {
        ProgressListener listener=(ProgressListener)message.obj;
        listener.onProgressComplete(message.arg1);
      }
      mSelectionManager.leaveSelectionMode();
      break;
    }
case MSG_TASK_UPDATE:
{
    if (mDialog != null)     mDialog.setProgress(message.arg1);
    if (message.obj != null) {
      ProgressListener listener=(ProgressListener)message.obj;
      listener.onProgressUpdate(message.arg1);
    }
    break;
  }
case MSG_DO_SHARE:
{
  ((Activity)mActivity).startActivity((Intent)message.obj);
  break;
}
}
}","@Override public void handleMessage(Message message){
switch (message.what) {
case MSG_TASK_COMPLETE:
{
      stopTaskAndDismissDialog();
      if (message.obj != null) {
        ProgressListener listener=(ProgressListener)message.obj;
        listener.onProgressComplete(message.arg1);
      }
      mSelectionManager.leaveSelectionMode();
      break;
    }
case MSG_TASK_UPDATE:
{
    if (mDialog != null)     mDialog.setProgress(message.arg1);
    if (message.obj != null) {
      ProgressListener listener=(ProgressListener)message.obj;
      listener.onProgressUpdate(message.arg1);
    }
    break;
  }
case MSG_DO_SHARE:
{
  ((Activity)mActivity).startActivity((Intent)message.obj);
  break;
}
}
}","The original code directly handled dialog dismissal and task nullification inline, which could lead to potential null pointer risks and code duplication. The fixed code extracts these operations into a separate method `stopTaskAndDismissDialog()`, which encapsulates the logic of safely dismissing the dialog and clearing task references. This refactoring improves code readability, reduces redundancy, and provides a more robust and maintainable approach to managing dialog and task lifecycle."
38706,"public Void run(JobContext jc){
  int index=0;
  DataManager manager=mActivity.getDataManager();
  int result=EXECUTION_RESULT_SUCCESS;
  for (  Path id : mItems) {
    if (jc.isCancelled()) {
      result=EXECUTION_RESULT_CANCEL;
      break;
    }
    try {
      if (!execute(manager,jc,mOperation,id))       result=EXECUTION_RESULT_FAIL;
    }
 catch (    Throwable th) {
      Log.e(TAG,""String_Node_Str"" + mOperation + ""String_Node_Str""+ id,th);
    }
    onProgressUpdate(index++,mListener);
  }
  onProgressComplete(result,mListener);
  return null;
}","public Void run(JobContext jc){
  int index=0;
  DataManager manager=mActivity.getDataManager();
  int result=EXECUTION_RESULT_SUCCESS;
  try {
    for (    Path id : mItems) {
      if (jc.isCancelled()) {
        result=EXECUTION_RESULT_CANCEL;
        break;
      }
      if (!execute(manager,jc,mOperation,id)) {
        result=EXECUTION_RESULT_FAIL;
      }
      onProgressUpdate(index++,mListener);
    }
  }
 catch (  Throwable th) {
    Log.e(TAG,""String_Node_Str"" + mOperation + ""String_Node_Str""+ th);
  }
 finally {
    onProgressComplete(result,mListener);
  }
  return null;
}","The original code lacks proper error handling and resource management, potentially leaving the progress completion unexecuted if an exception occurs during iteration. The fixed code wraps the entire loop in a try-catch block, moves the progress completion to a finally block to ensure it always runs, and removes the redundant exception handling inside the loop. This approach guarantees that onProgressComplete is called regardless of execution success, cancellation, or failure, providing more robust error handling and consistent state management."
38707,"public MenuExecutor(GalleryActivity activity,SelectionManager selectionManager){
  mActivity=Utils.checkNotNull(activity);
  mSelectionManager=Utils.checkNotNull(selectionManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_TASK_COMPLETE:
{
          if (mDialog != null) {
            mDialog.dismiss();
            mDialog=null;
            mTask=null;
          }
          if (message.obj != null) {
            ProgressListener listener=(ProgressListener)message.obj;
            listener.onProgressComplete(message.arg1);
          }
          mSelectionManager.leaveSelectionMode();
          break;
        }
case MSG_TASK_UPDATE:
{
        if (mDialog != null)         mDialog.setProgress(message.arg1);
        if (message.obj != null) {
          ProgressListener listener=(ProgressListener)message.obj;
          listener.onProgressUpdate(message.arg1);
        }
        break;
      }
case MSG_DO_SHARE:
{
      ((Activity)mActivity).startActivity((Intent)message.obj);
      break;
    }
}
}
}
;
}","public MenuExecutor(GalleryActivity activity,SelectionManager selectionManager){
  mActivity=Utils.checkNotNull(activity);
  mSelectionManager=Utils.checkNotNull(selectionManager);
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case MSG_TASK_COMPLETE:
{
          stopTaskAndDismissDialog();
          if (message.obj != null) {
            ProgressListener listener=(ProgressListener)message.obj;
            listener.onProgressComplete(message.arg1);
          }
          mSelectionManager.leaveSelectionMode();
          break;
        }
case MSG_TASK_UPDATE:
{
        if (mDialog != null)         mDialog.setProgress(message.arg1);
        if (message.obj != null) {
          ProgressListener listener=(ProgressListener)message.obj;
          listener.onProgressUpdate(message.arg1);
        }
        break;
      }
case MSG_DO_SHARE:
{
      ((Activity)mActivity).startActivity((Intent)message.obj);
      break;
    }
}
}
}
;
}","The original code lacks proper dialog and task management, potentially leading to memory leaks or unhandled states when tasks complete. The fixed code introduces a `stopTaskAndDismissDialog()` method to centralize the cleanup process, ensuring that dialogs are properly dismissed and resources are released. This refactoring improves code reliability by providing a consistent and clean mechanism for handling task completion and preventing potential resource management issues."
38708,"private boolean execute(DataManager manager,JobContext jc,int cmd,Path path){
  boolean result=true;
switch (cmd) {
case R.id.action_confirm_delete:
    manager.delete(path);
  break;
case R.id.action_rotate_cw:
manager.rotate(path,90);
break;
case R.id.action_rotate_ccw:
manager.rotate(path,-90);
break;
case R.id.action_toggle_full_caching:
{
MediaObject obj=manager.getMediaObject(path);
int cacheFlag=obj.getCacheFlag();
if (cacheFlag == MediaObject.CACHE_FLAG_FULL) {
cacheFlag=MediaObject.CACHE_FLAG_SCREENNAIL;
}
 else {
cacheFlag=MediaObject.CACHE_FLAG_FULL;
}
obj.cache(cacheFlag);
break;
}
case R.id.action_show_on_map:
{
MediaItem item=(MediaItem)manager.getMediaObject(path);
double latlng[]=new double[2];
item.getLatLong(latlng);
if (GalleryUtils.isValidLocation(latlng[0],latlng[1])) {
GalleryUtils.showOnMap((Context)mActivity,latlng[0],latlng[1]);
}
break;
}
case R.id.action_import:
{
MediaObject obj=manager.getMediaObject(path);
result=obj.Import();
break;
}
case R.id.action_edit:
{
Activity activity=(Activity)mActivity;
MediaItem item=(MediaItem)manager.getMediaObject(path);
try {
activity.startActivity(Intent.createChooser(new Intent(Intent.ACTION_EDIT).setDataAndType(item.getContentUri(),item.getMimeType()).setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION),null));
}
 catch (Throwable t) {
Log.w(TAG,""String_Node_Str"",t);
Toast.makeText(activity,activity.getString(R.string.activity_not_found),Toast.LENGTH_SHORT).show();
}
break;
}
default :
throw new AssertionError();
}
return result;
}","private boolean execute(DataManager manager,JobContext jc,int cmd,Path path){
  boolean result=true;
  Log.v(TAG,""String_Node_Str"" + cmd + ""String_Node_Str""+ path);
  long startTime=System.currentTimeMillis();
switch (cmd) {
case R.id.action_confirm_delete:
    manager.delete(path);
  break;
case R.id.action_rotate_cw:
manager.rotate(path,90);
break;
case R.id.action_rotate_ccw:
manager.rotate(path,-90);
break;
case R.id.action_toggle_full_caching:
{
MediaObject obj=manager.getMediaObject(path);
int cacheFlag=obj.getCacheFlag();
if (cacheFlag == MediaObject.CACHE_FLAG_FULL) {
cacheFlag=MediaObject.CACHE_FLAG_SCREENNAIL;
}
 else {
cacheFlag=MediaObject.CACHE_FLAG_FULL;
}
obj.cache(cacheFlag);
break;
}
case R.id.action_show_on_map:
{
MediaItem item=(MediaItem)manager.getMediaObject(path);
double latlng[]=new double[2];
item.getLatLong(latlng);
if (GalleryUtils.isValidLocation(latlng[0],latlng[1])) {
GalleryUtils.showOnMap((Context)mActivity,latlng[0],latlng[1]);
}
break;
}
case R.id.action_import:
{
MediaObject obj=manager.getMediaObject(path);
result=obj.Import();
break;
}
case R.id.action_edit:
{
Activity activity=(Activity)mActivity;
MediaItem item=(MediaItem)manager.getMediaObject(path);
try {
activity.startActivity(Intent.createChooser(new Intent(Intent.ACTION_EDIT).setDataAndType(item.getContentUri(),item.getMimeType()).setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION),null));
}
 catch (Throwable t) {
Log.w(TAG,""String_Node_Str"",t);
Toast.makeText(activity,activity.getString(R.string.activity_not_found),Toast.LENGTH_SHORT).show();
}
break;
}
default :
throw new AssertionError();
}
Log.v(TAG,""String_Node_Str"" + (System.currentTimeMillis() - startTime) + ""String_Node_Str""+ path);
return result;
}","The original code lacked logging and performance tracking, making debugging and performance analysis difficult. The fixed code adds two log statements - one at the start to log the command and path, and another to measure and log the execution time of the operation. These additions provide valuable diagnostic information, enabling developers to trace method execution, identify potential performance bottlenecks, and more effectively troubleshoot issues in the application's workflow."
38709,"public void pause(){
  if (mTask != null) {
    mTask.cancel();
    mTask.waitDone();
    mDialog.dismiss();
    mDialog=null;
    mTask=null;
  }
}","public void pause(){
  stopTaskAndDismissDialog();
}","The original code directly manipulates task and dialog objects, risking potential null pointer exceptions and tight coupling between components. The fixed code extracts the logic into a separate method `stopTaskAndDismissDialog()`, which encapsulates the cleanup process and provides better separation of concerns. By delegating the complex shutdown sequence to a dedicated method, the code becomes more modular, readable, and less prone to runtime errors."
38710,"public void prepareTextures(){
  if (mTileDecoder == null) {
    mTileDecoder=mThreadPool.submit(new TileDecoder());
  }
  if (mIsTextureFreed) {
    layoutTiles(mCenterX,mCenterY,mScale,mRotation);
    mIsTextureFreed=false;
    updateBackupTexture(mModel.getBackupImage());
  }
}","public void prepareTextures(){
  if (mTileDecoder == null) {
    mTileDecoder=mThreadPool.submit(new TileDecoder());
  }
  if (mIsTextureFreed) {
    layoutTiles(mCenterX,mCenterY,mScale,mRotation);
    mIsTextureFreed=false;
    updateBackupTexture(mModel != null ? mModel.getBackupImage() : null);
  }
}","The original code risks a NullPointerException when calling `mModel.getBackupImage()` if `mModel` is null. The fixed code adds a null check using a ternary operator, safely returning null if `mModel` is null before calling `getBackupImage()`. This prevents potential runtime crashes and ensures robust handling of potentially uninitialized model references."
38711,"@Override public void onCreate(Bundle data,Bundle restoreState){
  initializeViews();
  initializeData(data);
  mGetContent=data.getBoolean(Gallery.KEY_GET_CONTENT,false);
  mGetAlbum=data.getBoolean(Gallery.KEY_GET_ALBUM,false);
  mTitle=data.getString(AlbumSetPage.KEY_SET_TITLE);
  mSubtitle=data.getString(AlbumSetPage.KEY_SET_SUBTITLE);
  mEyePosition=new EyePosition(mActivity.getAndroidContext(),this);
  mDetailsSource=new MyDetailsSource();
  mActivity.getGalleryActionBar().setSelectedTab(data.getInt(AlbumSetPage.KEY_SELECTED_TAB_TYPE,FilterUtils.CLUSTER_BY_ALBUM));
  startTransition();
}","@Override public void onCreate(Bundle data,Bundle restoreState){
  initializeViews();
  initializeData(data);
  mGetContent=data.getBoolean(Gallery.KEY_GET_CONTENT,false);
  mGetAlbum=data.getBoolean(Gallery.KEY_GET_ALBUM,false);
  mTitle=data.getString(AlbumSetPage.KEY_SET_TITLE);
  mSubtitle=data.getString(AlbumSetPage.KEY_SET_SUBTITLE);
  mEyePosition=new EyePosition(mActivity.getAndroidContext(),this);
  mDetailsSource=new MyDetailsSource();
  GalleryActionBar actionBar=mActivity.getGalleryActionBar();
  if (actionBar != null) {
    actionBar.setSelectedTab(data.getInt(AlbumSetPage.KEY_SELECTED_TAB_TYPE,FilterUtils.CLUSTER_BY_ALBUM));
  }
  startTransition();
}","The original code assumes `mActivity.getGalleryActionBar()` always returns a non-null value, which could lead to a potential NullPointerException. The fixed code adds a null check before calling `setSelectedTab()`, ensuring that the method is only invoked when the action bar exists. This defensive programming approach prevents runtime crashes and makes the code more robust by gracefully handling scenarios where the action bar might be null."
38712,"public void onFutureDone(Future<Bitmap> future){
  mFuture=future;
  mMainHandler.sendMessage(mMainHandler.obtainMessage(MSG_RUN_OBJECT,this));
}","@Override public void onFutureDone(Future<Bitmap> future){
  mFuture=future;
  mMainHandler.sendMessage(mMainHandler.obtainMessage(MSG_RUN_OBJECT,this));
}","The original code lacks the `@Override` annotation, which helps catch method signature errors and ensures proper interface implementation. By adding `@Override`, the code explicitly indicates that this method is intended to override a parent class or interface method, enabling compile-time verification of correct method signature. This small change improves code readability, prevents potential runtime errors, and provides better type safety when implementing interfaces or extending classes."
38713,"private void updateScreenNail(long version,Future<Bitmap> future){
  ImageEntry entry=mImageCache.get(version);
  if (entry == null || entry.screenNailTask == null) {
    Bitmap screenNail=future.get();
    if (screenNail != null)     screenNail.recycle();
    return;
  }
  entry.screenNailTask=null;
  entry.screenNail=future.get();
  if (entry.screenNail == null) {
    entry.failToLoad=true;
  }
 else {
    if (mDataListener != null) {
      mDataListener.onPhotoAvailable(version,false);
    }
    for (int i=-1; i <= 1; ++i) {
      if (version == getVersion(mCurrentIndex + i)) {
        if (i == 0)         updateTileProvider(entry);
        mPhotoView.notifyImageInvalidated(i);
      }
    }
  }
  updateImageRequests();
}","private void updateScreenNail(long version,Future<Bitmap> future){
  ImageEntry entry=mImageCache.get(version);
  if (entry == null || entry.screenNailTask != future) {
    Bitmap screenNail=future.get();
    if (screenNail != null)     screenNail.recycle();
    return;
  }
  entry.screenNailTask=null;
  entry.screenNail=future.get();
  if (entry.screenNail == null) {
    entry.failToLoad=true;
  }
 else {
    if (mDataListener != null) {
      mDataListener.onPhotoAvailable(version,false);
    }
    for (int i=-1; i <= 1; ++i) {
      if (version == getVersion(mCurrentIndex + i)) {
        if (i == 0)         updateTileProvider(entry);
        mPhotoView.notifyImageInvalidated(i);
      }
    }
  }
  updateImageRequests();
}","The original code incorrectly checks for null entry without verifying if the current future matches the expected screen nail task. The fixed code changes the condition to `entry.screenNailTask != future`, ensuring that only the correct future task is processed and preventing potential race conditions. This modification improves code reliability by correctly handling concurrent image loading and preventing unnecessary bitmap recycling or processing of stale tasks."
38714,"private void updateFullImage(long version,Future<BitmapRegionDecoder> future){
  ImageEntry entry=mImageCache.get(version);
  if (entry == null || entry.fullImageTask == null) {
    BitmapRegionDecoder fullImage=future.get();
    if (fullImage != null)     fullImage.recycle();
    return;
  }
  entry.fullImageTask=null;
  entry.fullImage=future.get();
  if (entry.fullImage != null) {
    if (mDataListener != null) {
      mDataListener.onPhotoAvailable(version,true);
    }
    if (version == getVersion(mCurrentIndex)) {
      updateTileProvider(entry);
      mPhotoView.notifyImageInvalidated(0);
    }
  }
  updateImageRequests();
}","private void updateFullImage(long version,Future<BitmapRegionDecoder> future){
  ImageEntry entry=mImageCache.get(version);
  if (entry == null || entry.fullImageTask != future) {
    BitmapRegionDecoder fullImage=future.get();
    if (fullImage != null)     fullImage.recycle();
    return;
  }
  entry.fullImageTask=null;
  entry.fullImage=future.get();
  if (entry.fullImage != null) {
    if (mDataListener != null) {
      mDataListener.onPhotoAvailable(version,true);
    }
    if (version == getVersion(mCurrentIndex)) {
      updateTileProvider(entry);
      mPhotoView.notifyImageInvalidated(0);
    }
  }
  updateImageRequests();
}","The original code incorrectly checks if the entry exists or its fullImageTask is null, potentially causing premature recycling of the image decoder. The fixed code changes the condition to compare the current future with the stored fullImageTask, ensuring that only the correct task is processed. This modification prevents unnecessary recycling and ensures that only the intended image decoding task is handled, improving the reliability of image loading and management."
38715,"@Override public void onCreate(Bundle data,Bundle restoreState){
  initializeViews();
  initializeData(data);
  mGetContent=data.getBoolean(Gallery.KEY_GET_CONTENT,false);
  mGetAlbum=data.getBoolean(Gallery.KEY_GET_ALBUM,false);
  mTitle=data.getString(AlbumSetPage.KEY_SET_TITLE);
  mSubtitle=data.getString(AlbumSetPage.KEY_SET_SUBTITLE);
  mEyePosition=new EyePosition(mActivity.getAndroidContext(),this);
  mDetailsSource=new MyDetailsSource();
  mActivity.getGalleryActionBar().setSelectedTab(data.getInt(AlbumSetPage.KEY_SELECTED_TAB_TYPE,FilterUtils.CLUSTER_BY_ALBUM));
  startTransition();
}","@Override public void onCreate(Bundle data,Bundle restoreState){
  initializeViews();
  initializeData(data);
  mGetContent=data.getBoolean(Gallery.KEY_GET_CONTENT,false);
  mGetAlbum=data.getBoolean(Gallery.KEY_GET_ALBUM,false);
  mTitle=data.getString(AlbumSetPage.KEY_SET_TITLE);
  mSubtitle=data.getString(AlbumSetPage.KEY_SET_SUBTITLE);
  mEyePosition=new EyePosition(mActivity.getAndroidContext(),this);
  mDetailsSource=new MyDetailsSource();
  GalleryActionBar actionBar=mActivity.getGalleryActionBar();
  if (actionBar != null) {
    actionBar.setSelectedTab(data.getInt(AlbumSetPage.KEY_SELECTED_TAB_TYPE,FilterUtils.CLUSTER_BY_ALBUM));
  }
  startTransition();
}","The original code assumes `mActivity.getGalleryActionBar()` always returns a non-null value, which could cause a NullPointerException if the action bar is not available. The fixed code adds a null check before calling `setSelectedTab()`, ensuring that the method is only invoked when the action bar exists. This defensive programming approach prevents potential runtime crashes and makes the code more robust by gracefully handling scenarios where the action bar might be null."
38716,"void resume(){
  Activity activity=(Activity)mActivity;
  ActionBar actionBar=activity.getActionBar();
  if (actionBar != null) {
    if ((mFlags & FLAG_HIDE_ACTION_BAR) != 0) {
      actionBar.hide();
    }
 else {
      actionBar.show();
    }
    int stateCount=mActivity.getStateManager().getStateCount();
    actionBar.setDisplayOptions(stateCount == 1 ? 0 : ActionBar.DISPLAY_HOME_AS_UP,ActionBar.DISPLAY_HOME_AS_UP);
    actionBar.setHomeButtonEnabled(true);
  }
  activity.invalidateOptionsMenu();
  if ((mFlags & FLAG_HIDE_STATUS_BAR) != 0) {
    WindowManager.LayoutParams params=((Activity)mActivity).getWindow().getAttributes();
    params.systemUiVisibility=View.STATUS_BAR_HIDDEN;
    ((Activity)mActivity).getWindow().setAttributes(params);
  }
 else {
    WindowManager.LayoutParams params=((Activity)mActivity).getWindow().getAttributes();
    params.systemUiVisibility=View.STATUS_BAR_VISIBLE;
    ((Activity)mActivity).getWindow().setAttributes(params);
  }
  ResultEntry entry=mReceivedResults;
  if (entry != null) {
    mReceivedResults=null;
    onStateResult(entry.requestCode,entry.resultCode,entry.resultData);
  }
  onResume();
}","void resume(){
  Activity activity=(Activity)mActivity;
  ActionBar actionBar=activity.getActionBar();
  if (actionBar != null) {
    if ((mFlags & FLAG_HIDE_ACTION_BAR) != 0) {
      actionBar.hide();
    }
 else {
      actionBar.show();
    }
    int stateCount=mActivity.getStateManager().getStateCount();
    actionBar.setDisplayOptions(stateCount == 1 ? 0 : ActionBar.DISPLAY_HOME_AS_UP,ActionBar.DISPLAY_HOME_AS_UP);
    actionBar.setHomeButtonEnabled(true);
  }
  activity.invalidateOptionsMenu();
  if ((mFlags & FLAG_HIDE_STATUS_BAR) != 0) {
    WindowManager.LayoutParams params=((Activity)mActivity).getWindow().getAttributes();
    params.systemUiVisibility=View.SYSTEM_UI_FLAG_LOW_PROFILE;
    ((Activity)mActivity).getWindow().setAttributes(params);
  }
 else {
    WindowManager.LayoutParams params=((Activity)mActivity).getWindow().getAttributes();
    params.systemUiVisibility=View.SYSTEM_UI_FLAG_VISIBLE;
    ((Activity)mActivity).getWindow().setAttributes(params);
  }
  ResultEntry entry=mReceivedResults;
  if (entry != null) {
    mReceivedResults=null;
    onStateResult(entry.requestCode,entry.resultCode,entry.resultData);
  }
  onResume();
}","The original code used deprecated system UI visibility flags `STATUS_BAR_HIDDEN` and `STATUS_BAR_VISIBLE`, which are no longer recommended for modern Android development. The fixed code replaces these with `SYSTEM_UI_FLAG_LOW_PROFILE` and `SYSTEM_UI_FLAG_VISIBLE`, which provide more consistent and flexible system UI state management. These updated flags ensure proper status bar handling across different Android versions and device configurations, improving the overall user interface behavior."
38717,"protected boolean onCreateActionBar(Menu menu){
  return false;
}","protected boolean onCreateActionBar(Menu menu){
  return true;
}","The original code returns false in onCreateActionBar, which prevents the action bar from being created or properly initialized in the application. By changing the return value to true, the method now signals successful action bar creation and allows the menu to be properly displayed and functional. This modification ensures that the action bar is correctly set up, enabling proper menu rendering and interaction within the app."
38718,"@Override public void onCreate(Bundle data,Bundle restoreState){
  mHandler=new SynchronizedHandler(mActivity.getGLRoot()){
    @Override public void handleMessage(    Message message){
      Utils.assertTrue(message.what == MSG_GOTO_MANAGE_CACHE_PAGE);
      Bundle data=new Bundle();
      String mediaPath=mActivity.getDataManager().getTopSetPath(DataManager.INCLUDE_ALL);
      data.putString(AlbumSetPage.KEY_MEDIA_PATH,mediaPath);
      mActivity.getStateManager().startState(ManageCachePage.class,data);
    }
  }
;
  initializeViews();
  initializeData(data);
  mGetContent=data.getBoolean(Gallery.KEY_GET_CONTENT,false);
  mGetAlbum=data.getBoolean(Gallery.KEY_GET_ALBUM,false);
  mTitle=data.getString(AlbumSetPage.KEY_SET_TITLE);
  mSubtitle=data.getString(AlbumSetPage.KEY_SET_SUBTITLE);
  mEyePosition=new EyePosition(mActivity.getAndroidContext(),this);
  mDetailsSource=new MyDetailsSource();
  startTransition();
}","@Override public void onCreate(Bundle data,Bundle restoreState){
  initializeViews();
  initializeData(data);
  mGetContent=data.getBoolean(Gallery.KEY_GET_CONTENT,false);
  mGetAlbum=data.getBoolean(Gallery.KEY_GET_ALBUM,false);
  mTitle=data.getString(AlbumSetPage.KEY_SET_TITLE);
  mSubtitle=data.getString(AlbumSetPage.KEY_SET_SUBTITLE);
  mEyePosition=new EyePosition(mActivity.getAndroidContext(),this);
  mDetailsSource=new MyDetailsSource();
  mActivity.getGalleryActionBar().setSelectedTab(data.getInt(AlbumSetPage.KEY_SELECTED_TAB_TYPE,FilterUtils.CLUSTER_BY_ALBUM));
  startTransition();
}","The original code improperly initializes a handler with an anonymous inner class before performing other initialization tasks, potentially causing premature or unintended message handling. The fixed code removes the unnecessary handler initialization and adds a method to set the selected tab using data from the input bundle, ensuring proper view and data initialization. This modification improves code clarity, reduces potential race conditions, and provides more explicit tab selection logic based on the input parameters."
38719,"@Override protected boolean onItemSelected(MenuItem item){
  Activity activity=(Activity)mActivity;
switch (item.getItemId()) {
case R.id.action_cancel:
    activity.setResult(Activity.RESULT_CANCELED);
  activity.finish();
return true;
case R.id.action_select:
mSelectionManager.setAutoLeaveSelectionMode(false);
mSelectionManager.enterSelectionMode();
return true;
case R.id.action_details:
if (mAlbumSetDataAdapter.size() != 0) {
if (mShowDetails) {
hideDetails();
}
 else {
showDetails();
}
}
 else {
Toast.makeText(activity,activity.getText(R.string.no_albums_alert),Toast.LENGTH_SHORT).show();
}
return true;
case R.id.action_camera:
{
Intent intent=new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA).setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
activity.startActivity(intent);
return true;
}
case R.id.action_manage_offline:
{
mHandler.sendEmptyMessage(MSG_GOTO_MANAGE_CACHE_PAGE);
return true;
}
case R.id.action_sync_picasa_albums:
{
PicasaSource.requestSync(activity);
return true;
}
case R.id.action_settings:
{
activity.startActivity(new Intent(activity,GallerySettings.class));
return true;
}
default :
return false;
}
}","@Override protected boolean onItemSelected(MenuItem item){
  Activity activity=(Activity)mActivity;
switch (item.getItemId()) {
case R.id.action_cancel:
    activity.setResult(Activity.RESULT_CANCELED);
  activity.finish();
return true;
case R.id.action_select:
mSelectionManager.setAutoLeaveSelectionMode(false);
mSelectionManager.enterSelectionMode();
return true;
case R.id.action_details:
if (mAlbumSetDataAdapter.size() != 0) {
if (mShowDetails) {
hideDetails();
}
 else {
showDetails();
}
}
 else {
Toast.makeText(activity,activity.getText(R.string.no_albums_alert),Toast.LENGTH_SHORT).show();
}
return true;
case R.id.action_camera:
{
Intent intent=new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA).setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
activity.startActivity(intent);
return true;
}
case R.id.action_manage_offline:
{
Bundle data=new Bundle();
String mediaPath=mActivity.getDataManager().getTopSetPath(DataManager.INCLUDE_ALL);
data.putString(AlbumSetPage.KEY_MEDIA_PATH,mediaPath);
mActivity.getStateManager().startState(ManageCachePage.class,data);
return true;
}
case R.id.action_sync_picasa_albums:
{
PicasaSource.requestSync(activity);
return true;
}
case R.id.action_settings:
{
activity.startActivity(new Intent(activity,GallerySettings.class));
return true;
}
default :
return false;
}
}","The original code used `mHandler.sendEmptyMessage(MSG_GOTO_MANAGE_CACHE_PAGE)` to navigate to the manage cache page, which was likely an inefficient and potentially error-prone method of state management. The fixed code replaces this with a more robust approach using `mActivity.getStateManager().startState()`, which creates a Bundle with the media path and explicitly starts the ManageCachePage state. This change provides better encapsulation, improves code clarity, and ensures a more structured navigation mechanism within the application's state management system."
38720,"public void doCluster(int clusterType){
  String basePath=mMediaSet.getPath().toString();
  String newPath=FilterUtils.switchClusterPath(basePath,clusterType);
  Bundle data=new Bundle(getData());
  data.putString(AlbumSetPage.KEY_MEDIA_PATH,newPath);
  mAlbumSetView.savePositions(PositionRepository.getInstance(mActivity));
  mActivity.getStateManager().switchState(this,AlbumSetPage.class,data);
}","public void doCluster(int clusterType){
  String basePath=mMediaSet.getPath().toString();
  String newPath=FilterUtils.switchClusterPath(basePath,clusterType);
  Bundle data=new Bundle(getData());
  data.putString(AlbumSetPage.KEY_MEDIA_PATH,newPath);
  data.putInt(KEY_SELECTED_TAB_TYPE,clusterType);
  mAlbumSetView.savePositions(PositionRepository.getInstance(mActivity));
  mActivity.getStateManager().switchState(this,AlbumSetPage.class,data);
}","The original code lacked a way to preserve the selected clustering type when switching states, potentially losing user context. The fixed code adds `data.putInt(KEY_SELECTED_TAB_TYPE,clusterType)` to store the current clustering type in the bundle, ensuring the selected view is maintained during state transition. This enhancement improves user experience by maintaining the intended view and preventing unintended resets when navigating between album views."
38721,"public int getIndex(){
  return mIndex;
}","@Override public int getIndex(){
  return mIndex;
}","The original code lacks the `@Override` annotation, which helps catch potential errors when implementing or overriding methods in inheritance hierarchies. The fixed code adds the `@Override` annotation, explicitly indicating that this method is intended to override a method from a superclass or interface. This annotation provides compile-time verification, preventing subtle bugs and improving code clarity by making the programmer's intent explicit."
38722,"public MediaDetails getDetails(){
  return mModel.getCurrentMediaItem().getDetails();
}","@Override public MediaDetails getDetails(){
  return mModel.getCurrentMediaItem().getDetails();
}","The original code lacks the `@Override` annotation, which helps catch potential interface implementation errors and ensures method signature compatibility. By adding `@Override`, the code explicitly indicates that this method is implementing or overriding a method from a parent class or interface, providing compile-time verification of the method signature. This change improves code clarity, prevents potential runtime errors, and enhances type safety during method implementation."
38723,"public int findIndex(int indexHint){
  mIndex=indexHint;
  return indexHint;
}","@Override public int findIndex(int indexHint){
  mIndex=indexHint;
  return indexHint;
}","The original code lacks the `@Override` annotation, which helps catch potential errors when implementing or overriding methods from a parent class or interface. The fixed code adds the `@Override` annotation, explicitly indicating that this method is intended to override a method from a superclass or interface. This improves code clarity, provides compile-time verification, and helps prevent unintended method implementations."
38724,"public int size(){
  return mMediaSet != null ? mMediaSet.getMediaItemCount() : 1;
}","@Override public int size(){
  return mMediaSet != null ? mMediaSet.getMediaItemCount() : 1;
}","The original code lacks the @Override annotation, which is important for explicitly indicating that the method is intended to override a method from a superclass or interface. Adding @Override ensures compile-time verification that the method actually overrides a parent method, preventing potential errors from method signature mismatches. This small change improves code clarity, catches potential inheritance-related mistakes early, and provides better documentation of the method's intent."
38725,"private void saveData(SQLiteDatabase db,int oldVersion,ArrayList<Entry> data){
  if (oldVersion <= 2) {
    Cursor cursor=db.query(""String_Node_Str"",new String[]{FIELD_APPWIDGET_ID,FIELD_PHOTO_BLOB},null,null,null,null,null);
    if (cursor == null)     return;
    try {
      while (cursor.moveToNext()) {
        Entry entry=new Entry();
        entry.type=TYPE_SINGLE_PHOTO;
        entry.widgetId=cursor.getInt(0);
        entry.imageData=cursor.getBlob(1);
        data.add(entry);
      }
    }
  finally {
      cursor.close();
    }
  }
 else   if (oldVersion == 3) {
    Utils.debug(""String_Node_Str"",oldVersion);
    Cursor cursor=db.query(""String_Node_Str"",new String[]{FIELD_APPWIDGET_ID,FIELD_PHOTO_BLOB,FIELD_IMAGE_URI},null,null,null,null,null);
    if (cursor == null)     return;
    try {
      while (cursor.moveToNext()) {
        Entry entry=new Entry();
        entry.type=TYPE_SINGLE_PHOTO;
        entry.widgetId=cursor.getInt(0);
        entry.imageData=cursor.getBlob(1);
        entry.imageUri=cursor.getString(2);
        Utils.debug(""String_Node_Str"",entry.widgetId,entry.imageUri);
        data.add(entry);
      }
    }
  finally {
      cursor.close();
    }
  }
}","private void saveData(SQLiteDatabase db,int oldVersion,ArrayList<Entry> data){
  if (oldVersion <= 2) {
    Cursor cursor=db.query(""String_Node_Str"",new String[]{FIELD_APPWIDGET_ID,FIELD_PHOTO_BLOB},null,null,null,null,null);
    if (cursor == null)     return;
    try {
      while (cursor.moveToNext()) {
        Entry entry=new Entry();
        entry.type=TYPE_SINGLE_PHOTO;
        entry.widgetId=cursor.getInt(0);
        entry.imageData=cursor.getBlob(1);
        data.add(entry);
      }
    }
  finally {
      cursor.close();
    }
  }
 else   if (oldVersion == 3) {
    Cursor cursor=db.query(""String_Node_Str"",new String[]{FIELD_APPWIDGET_ID,FIELD_PHOTO_BLOB,FIELD_IMAGE_URI},null,null,null,null,null);
    if (cursor == null)     return;
    try {
      while (cursor.moveToNext()) {
        Entry entry=new Entry();
        entry.type=TYPE_SINGLE_PHOTO;
        entry.widgetId=cursor.getInt(0);
        entry.imageData=cursor.getBlob(1);
        entry.imageUri=cursor.getString(2);
        data.add(entry);
      }
    }
  finally {
      cursor.close();
    }
  }
}","The buggy code included unnecessary debug logging statements that could impact performance and potentially expose sensitive information during database migration. The fixed code removes these debug calls, streamlining the data retrieval process for different database versions. By eliminating extraneous logging, the code becomes more efficient and maintains cleaner data extraction logic when migrating widget information across database schema versions."
38726,"boolean decode(){
  int tileLength=(TILE_SIZE + 2 * TILE_BORDER);
  int borderLength=TILE_BORDER << mTileLevel;
  try {
    mDecodedTile=mModel.getTile(mTileLevel,mX - borderLength,mY - borderLength,tileLength);
    return mDecodedTile != null;
  }
 catch (  Throwable t) {
    Log.w(TAG,""String_Node_Str"",t);
    return false;
  }
}","boolean decode(){
  int tileLength=(TILE_SIZE + 2 * TILE_BORDER);
  int borderLength=TILE_BORDER << mTileLevel;
  try {
    mDecodedTile=DecodeUtils.ensureGLCompatibleBitmap(mModel.getTile(mTileLevel,mX - borderLength,mY - borderLength,tileLength));
    return mDecodedTile != null;
  }
 catch (  Throwable t) {
    Log.w(TAG,""String_Node_Str"",t);
    return false;
  }
}","The original code directly returned the tile from `mModel.getTile()` without ensuring OpenGL compatibility, which could lead to rendering issues with certain bitmap formats. The fixed code wraps the tile retrieval with `DecodeUtils.ensureGLCompatibleBitmap()`, which converts the bitmap to a format guaranteed to be compatible with OpenGL rendering. This modification prevents potential graphical glitches and ensures consistent bitmap rendering across different device configurations."
38727,"boolean decode(){
  int tileLength=(TILE_SIZE + 2 * TILE_BORDER);
  int borderLength=TILE_BORDER << mTileLevel;
  try {
    mDecodedTile=mModel.getTile(mTileLevel,mX - borderLength,mY - borderLength,tileLength);
    return mDecodedTile != null;
  }
 catch (  Throwable t) {
    Log.w(TAG,""String_Node_Str"",t);
    return false;
  }
}","boolean decode(){
  int tileLength=(TILE_SIZE + 2 * TILE_BORDER);
  int borderLength=TILE_BORDER << mTileLevel;
  try {
    mDecodedTile=DecodeUtils.ensureGLCompatibleBitmap(mModel.getTile(mTileLevel,mX - borderLength,mY - borderLength,tileLength));
    return mDecodedTile != null;
  }
 catch (  Throwable t) {
    Log.w(TAG,""String_Node_Str"",t);
    return false;
  }
}","The original code directly returns the tile from `mModel.getTile()` without ensuring OpenGL compatibility, which could lead to rendering issues with certain bitmap formats. The fixed code wraps the tile retrieval with `DecodeUtils.ensureGLCompatibleBitmap()`, which transforms the bitmap to a format guaranteed to work with OpenGL rendering systems. This modification ensures consistent and reliable tile rendering across different graphics contexts by standardizing the bitmap format before use."
38728,"private Database createDatabaseIfNotExists(String dbName){
  try {
    final List<Database> dbList=documentDbFactory.getDocumentClient().queryDatabases(new SqlQuerySpec(""String_Node_Str"",new SqlParameterCollection(new SqlParameter(""String_Node_Str"",dbName))),null).getQueryIterable().toList();
    if (!dbList.isEmpty()) {
      return dbList.get(0);
    }
 else {
      final Database db=new Database();
      db.setId(dbName);
      if (LOGGER.isDebugEnabled()) {
        LOGGER.debug(""String_Node_Str"",dbName);
      }
      final Resource resource=documentDbFactory.getDocumentClient().createDatabase(db,null).getResource();
      if (resource instanceof Database) {
        return (Database)resource;
      }
 else {
        LOGGER.error(""String_Node_Str"" + resource.getSelfLink());
        throw new DatabaseCreationException(""String_Node_Str"" + resource.getSelfLink());
      }
    }
  }
 catch (  DocumentClientException ex) {
    throw new DocumentDBAccessException(""String_Node_Str"",ex);
  }
}","private Database createDatabaseIfNotExists(String dbName){
  try {
    final List<Database> dbList=documentDbFactory.getDocumentClient().queryDatabases(new SqlQuerySpec(""String_Node_Str"",new SqlParameterCollection(new SqlParameter(""String_Node_Str"",dbName))),null).getQueryIterable().toList();
    if (!dbList.isEmpty()) {
      return dbList.get(0);
    }
 else {
      final Database db=new Database();
      db.setId(dbName);
      if (LOGGER.isDebugEnabled()) {
        LOGGER.debug(""String_Node_Str"",dbName);
      }
      final Resource resource=documentDbFactory.getDocumentClient().createDatabase(db,null).getResource();
      if (resource instanceof Database) {
        return (Database)resource;
      }
 else {
        final String errorMessage=MessageFormat.format(""String_Node_Str"",dbName,resource.getSelfLink());
        LOGGER.error(errorMessage);
        throw new DatabaseCreationException(errorMessage);
      }
    }
  }
 catch (  DocumentClientException ex) {
    throw new DocumentDBAccessException(""String_Node_Str"",ex);
  }
}","The original code had a potential issue with error logging and exception handling, lacking a clear, formatted error message when database creation failed. The fixed code introduces MessageFormat.format() to create a more descriptive error message, incorporating both the database name and resource self-link for better diagnostics. This improvement enhances error traceability and provides more context during database creation exceptions, making troubleshooting more straightforward and informative."
38729,"public DocumentDbQueryCreator(PartTree tree,DocumentDbParameterAccessor accessor,MappingContext<?,DocumentDbPersistentProperty> mappingContext){
  super(tree,accessor);
  this.accessor=accessor;
  this.mappingContext=mappingContext;
}","public DocumentDbQueryCreator(PartTree tree,DocumentDbParameterAccessor accessor,MappingContext<?,DocumentDbPersistentProperty> mappingContext){
  super(tree,accessor);
  this.mappingContext=mappingContext;
}","The original code redundantly assigned the `accessor` parameter to an instance variable, which was already handled by the superclass constructor. The fixed code removes the unnecessary `this.accessor = accessor` line, preventing potential duplicate assignments and maintaining clean, efficient code. By eliminating the redundant assignment, the code becomes more concise and avoids potential side effects or confusion in parameter handling."
38730,"public static ZooKeeperLocal provideZooKeeperLocal(){
  Properties zkProperties=new Properties();
  zkProperties.put(""String_Node_Str"",(String)String.valueOf(zookeeperPort));
  zkProperties.put(""String_Node_Str"",(String)""String_Node_Str"");
  zkProperties.put(""String_Node_Str"",(String)""String_Node_Str"");
  try {
    FileUtils.deleteDirectory(new File((String)zkProperties.get(""String_Node_Str"")));
    zookeeper=new ZooKeeperLocal(zkProperties);
    zookeeper.start();
    return zookeeper;
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}","public static ZooKeeperLocal provideZooKeeperLocal(){
  final Properties zkProperties=new Properties();
  zkProperties.put(""String_Node_Str"",String.valueOf(zookeeperPort));
  zkProperties.put(""String_Node_Str"",""String_Node_Str"");
  zkProperties.put(""String_Node_Str"",""String_Node_Str"");
  try {
    FileUtils.deleteDirectory(new File((String)zkProperties.get(""String_Node_Str"")));
    zookeeper=new ZooKeeperLocal(zkProperties);
    zookeeper.start();
    return zookeeper;
  }
 catch (  final IOException e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}","The original code incorrectly casts String values and repeatedly overwrites the same key ""String_Node_Str"" in the Properties object, potentially losing previous property values. The fixed code removes unnecessary type casting, uses direct string assignment, and maintains the original intent of setting properties more cleanly. By simplifying the property setting and removing redundant casting, the code becomes more readable and less prone to unexpected behavior during ZooKeeper local instance creation."
38731,"public static void setZookeeper(ZooKeeperLocal zookeeper){
  KafkaServer.zookeeper=zookeeper;
}","public static void setZookeeper(final ZooKeeperLocal zookeeper){
  KafkaServer.zookeeper=zookeeper;
}","The original code lacks the `final` keyword, which means the parameter could potentially be modified, introducing unexpected behavior. By adding `final` to the parameter, the code ensures the passed `ZooKeeperLocal` object cannot be reassigned within the method, providing immutability and preventing unintended side effects. This small change enhances code predictability and helps maintain the integrity of the zookeeper reference throughout the method's execution."
38732,"public static void setKafkaLocal(KafkaLocal kafkaLocal){
  KafkaServer.kafkaLocal=kafkaLocal;
}","public static void setKafkaLocal(final KafkaLocal kafkaLocal){
  KafkaServer.kafkaLocal=kafkaLocal;
}","The original code lacks the `final` keyword, which can lead to potential thread-safety and immutability issues when setting the `kafkaLocal` parameter. Adding `final` ensures that the parameter cannot be reassigned within the method, providing a guarantee of immutability and preventing unintended modifications. This small change enhances code reliability and helps prevent unexpected runtime behavior in concurrent or multi-threaded Kafka server configurations."
38733,"/** 
 * Starts a local Kafka Server (inlcudes zookeper and kafka) , if it has not been started already.
 * @return The port of the zookeeper server.
 */
public static Integer startKafkaServer(String topicName){
  if (null == kafkaLocal) {
    kafkaLocal=provideKafkaServer();
    createTopicWithThreePartitions(topicName);
  }
  return zookeeperPort;
}","/** 
 * Starts a local Kafka Server (inlcudes zookeper and kafka) , if it has not been started already. FIXME: currently, application-test config assumes port 32000; if server starts on other port, tests will fail!
 * @return The port of the zookeeper server.
 */
public static Integer startKafkaServer(final String topicName){
  if (null == kafkaLocal) {
    kafkaLocal=provideKafkaServer();
    createTopicWithThreePartitions(topicName);
  }
  return zookeeperPort;
}","The original code lacks clarity about potential port variability when starting a Kafka server, which could cause test configuration issues. The fixed code adds a comment highlighting the potential port configuration challenge and uses the `final` keyword for the `topicName` parameter, preventing unintended modifications. This improvement provides better documentation and slightly enhances method parameter safety, helping developers understand potential configuration complexities when initializing a local Kafka server."
38734,"public static void setZookeeperPort(Integer zookeeperPort){
  KafkaServer.zookeeperPort=zookeeperPort;
}","public static void setZookeeperPort(final Integer zookeeperPort){
  KafkaServer.zookeeperPort=zookeeperPort;
}","The original code lacks the `final` keyword, which allows potential unintended modifications to the method parameter. Adding `final` ensures that the `zookeeperPort` parameter cannot be reassigned within the method, preventing accidental changes. This small modification enhances code safety and provides a clear signal of immutability for the input parameter, making the method more robust and predictable."
38735,"public static void createTopicWithThreePartitions(String topicName){
  Integer sessionTimeoutMs=10000;
  Integer connectionTimeoutMs=10000;
  ZkConnection zkConnection=new ZkConnection(""String_Node_Str"" + String.valueOf(zookeeperPort),sessionTimeoutMs);
  ZkClient zkClient=new ZkClient(zkConnection,connectionTimeoutMs,ZKStringSerializer$.MODULE$);
  ZkUtils zkUtils=new ZkUtils(zkClient,zkConnection,false);
  Integer numPartitions=3;
  Integer replicationFactor=1;
  Properties topicConfig=new Properties();
  try {
    LOG.info(""String_Node_Str"" + topicName);
    AdminUtils.deleteTopic(zkUtils,topicName);
  }
 catch (  UnknownTopicOrPartitionException e) {
    LOG.info(""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + topicName);
  AdminUtils.createTopic(zkUtils,topicName,numPartitions,replicationFactor,topicConfig,null);
  zkClient.close();
}","public static void createTopicWithThreePartitions(final String topicName){
  final Integer sessionTimeoutMs=10000;
  final Integer connectionTimeoutMs=10000;
  final ZkConnection zkConnection=new ZkConnection(""String_Node_Str"" + String.valueOf(zookeeperPort),sessionTimeoutMs);
  final ZkClient zkClient=new ZkClient(zkConnection,connectionTimeoutMs,ZKStringSerializer$.MODULE$);
  final ZkUtils zkUtils=new ZkUtils(zkClient,zkConnection,false);
  final Integer numPartitions=3;
  final Integer replicationFactor=1;
  final Properties topicConfig=new Properties();
  try {
    LOG.info(""String_Node_Str"" + topicName);
    AdminUtils.deleteTopic(zkUtils,topicName);
  }
 catch (  final UnknownTopicOrPartitionException e) {
    LOG.info(""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + topicName);
  AdminUtils.createTopic(zkUtils,topicName,numPartitions,replicationFactor,topicConfig,null);
  zkClient.close();
}","The original code lacked proper exception handling and variable scoping, which could lead to potential resource management issues. The fixed code adds the `final` keyword to variables, improving immutability and preventing unintended modifications, while maintaining the same exception catch block for `UnknownTopicOrPartitionException`. These changes enhance code readability, thread safety, and provide a more robust approach to creating Kafka topics with explicit resource management."
38736,"public static KafkaLocal provideKafkaServer(){
  Properties kafkaProperties=new Properties();
  kafkaProperties.put(""String_Node_Str"",(String)""String_Node_Str"" + String.valueOf(zookeeperPort));
  kafkaProperties.put(""String_Node_Str"",(String)String.valueOf(kafkaPort));
  kafkaProperties.put(""String_Node_Str"",(String)""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",(String)""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",(String)""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",(String)""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",(String)""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",(String)""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",(String)""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",(String)""String_Node_Str"");
  try {
    FileUtils.deleteDirectory(new File((String)kafkaProperties.get(""String_Node_Str"")));
    ZooKeeperLocal zooKeeperLocal=provideZooKeeperLocal();
    KafkaLocal kafka=new KafkaLocal(kafkaProperties,zooKeeperLocal);
    kafka.start();
    Thread.sleep(2000);
    return ((KafkaLocal)(kafka));
  }
 catch (  IOException|InterruptedException e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}","public static KafkaLocal provideKafkaServer(){
  final Properties kafkaProperties=new Properties();
  kafkaProperties.put(""String_Node_Str"",""String_Node_Str"" + String.valueOf(zookeeperPort));
  kafkaProperties.put(""String_Node_Str"",String.valueOf(kafkaPort));
  kafkaProperties.put(""String_Node_Str"",""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",""String_Node_Str"");
  kafkaProperties.put(""String_Node_Str"",""String_Node_Str"");
  try {
    FileUtils.deleteDirectory(new File((String)kafkaProperties.get(""String_Node_Str"")));
    final ZooKeeperLocal zooKeeperLocal=provideZooKeeperLocal();
    final KafkaLocal kafka=new KafkaLocal(kafkaProperties,zooKeeperLocal);
    kafka.start();
    Thread.sleep(2000);
    return ((kafka));
  }
 catch (  IOException|InterruptedException e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
}","The original code redundantly casts strings and uses unnecessary type conversions, leading to potential performance overhead and readability issues. The fixed code removes redundant casting, uses more concise property assignments, and simplifies the return statement by directly returning the Kafka instance. These changes make the code cleaner, more efficient, and easier to understand while maintaining the same functional behavior."
38737,"public static void setKafkaPort(Integer kafkaPort){
  KafkaServer.kafkaPort=kafkaPort;
}","public static void setKafkaPort(final Integer kafkaPort){
  KafkaServer.kafkaPort=kafkaPort;
}","The original code lacks the `final` keyword for the method parameter, which could potentially allow unintended parameter modification. By adding `final` to the `kafkaPort` parameter, the code ensures that the input value cannot be changed within the method, preventing accidental reassignment. This small modification enhances code reliability and provides a clear signal of the parameter's immutability during method execution."
38738,"public static ProductEntity of(final Product product){
}","public static ProductEntity of(final Product product){
  ProductEntity productEntity=new ProductEntity();
  productEntity.name=product.getName();
  productEntity.vendor=product.getVendor();
  productEntity.price=product.getPrice();
  productEntity.description=product.getDescription();
  productEntity.productNumber=product.getProductNumber();
  productEntity.image=product.getImage();
  productEntity.version=product.getVersion();
  return productEntity;
}","The original code was an empty method stub that would not create or return a ProductEntity object, rendering it non-functional. The fixed code creates a new ProductEntity instance and systematically maps properties from the input Product object using getter methods, ensuring a complete and accurate data transfer. By implementing this mapping logic, the method now successfully converts a Product to a ProductEntity, enabling proper object transformation and data propagation."
38739,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.PUT) public Product addProduct(final Product product){
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.PUT) public Product addProduct(final Product product){
  return null;
}","The original code lacks a return statement, causing a potential compilation error or unexpected behavior in a Spring REST controller method. The fixed code adds a `return null` statement, ensuring the method complies with its defined return type of `Product`. This modification provides a minimal but valid implementation, preventing compilation issues and allowing the method to return a null product when no specific logic is required."
38740,"@Override public CompletionStage<Response<ByteString>> getTemplate(final RouteMatch match,final RequestContext context){
  return CompletableFuture.completedFuture(Response.of(Status.OK,ByteString.encodeUtf8(SERVICE_RESPONSE)));
}","@Override public CompletionStage<Response<ByteString>> getTemplate(final RouteMatch match,final RequestContext context){
  return CompletableFuture.completedFuture(Response.of(status,ByteString.encodeUtf8(responseBody)));
}","The original code hardcoded a static SERVICE_RESPONSE and Status.OK, making the method inflexible and unable to handle dynamic response requirements. The fixed code introduces parameterized variables `status` and `responseBody`, allowing for more flexible and context-specific response generation. This modification enables dynamic response creation, improving the method's reusability and adaptability to different routing and request scenarios."
38741,"private RuleRouter<Match> aRouter(){
  final Rule<Match> sampleRule=Rule.fromUri(""String_Node_Str"",""String_Node_Str"",Match.of(""String_Node_Str"",TEMPLATE));
  return RuleRouter.of(singletonList(sampleRule));
}","private RuleRouter<Match> aRouter(final String pattern,final StaticBackendRoutes.RouteType routeType){
  final Rule<Match> sampleRule=Rule.fromUri(pattern,""String_Node_Str"",Match.of(""String_Node_Str"",routeType));
  return RuleRouter.of(singletonList(sampleRule));
}","The original code used hardcoded, static string values for pattern and route type, limiting flexibility and reusability. The fixed code introduces parameterized inputs for pattern and route type, allowing dynamic rule creation with different configurations. This modification enables more versatile routing logic by accepting runtime-defined parameters, making the method adaptable to various routing scenarios."
38742,"private RequestContext aContext(){
  final Request request=mock(Request.class);
  when(request.uri()).thenReturn(""String_Node_Str"");
  when(request.service()).thenReturn(Optional.empty());
  when(request.method()).thenReturn(""String_Node_Str"");
  final RequestContext context=mock(RequestContext.class);
  when(context.request()).thenReturn(request);
  when(context.requestScopedClient()).thenReturn(mock(Client.class));
  return context;
}","private RequestContext aContext(){
  final Request request=mock(Request.class);
  when(request.uri()).thenReturn(""String_Node_Str"");
  when(request.service()).thenReturn(Optional.empty());
  when(request.method()).thenReturn(""String_Node_Str"");
  final RequestContext context=mock(RequestContext.class);
  when(context.request()).thenReturn(request);
  Client client=mock(Client.class);
  when(client.send(any())).thenThrow(new RuntimeException());
  when(context.requestScopedClient()).thenReturn(client);
  return context;
}","The original code mocked a client without defining its behavior, potentially leading to unpredictable test results. The fixed code introduces a mock client with a specific behavior of throwing a RuntimeException when the send method is called, ensuring consistent and controlled test scenarios. This modification provides more robust error handling and predictability in testing the request context's client interactions."
38743,"private RuleRouter<Match> aRouter(){
  final Rule<Match> sampleRule=Rule.fromUri(""String_Node_Str"",""String_Node_Str"",Match.of(""String_Node_Str""));
  return RuleRouter.of(singletonList(sampleRule));
}","private RuleRouter<Match> aRouter(){
  final Rule<Match> sampleRule=Rule.fromUri(""String_Node_Str"",""String_Node_Str"",Match.of(""String_Node_Str"",RouteType.TEMPLATE));
  return RuleRouter.of(singletonList(sampleRule));
}","The original code omitted the RouteType parameter when creating a Match, which could lead to incorrect routing behavior. The fixed code adds RouteType.TEMPLATE as the third argument to Match.of(), explicitly specifying the route type for proper template matching. This modification ensures more precise and predictable routing logic by providing the necessary type information during rule creation."
38744,"@Override public void channelRead(ChannelHandlerContext ctx,Object msg) throws Exception {
  byte[] bytes=(byte[])msg;
  if (bytes.length == QuitPacket.QUIT.length && bytes[4] == MySQLPacket.COM_QUIT) {
    ctx.close();
    return;
  }
  AuthPacket authPacket=new AuthPacket();
  authPacket.read(bytes);
  frontendConnection.setHost(((InetSocketAddress)ctx.channel().remoteAddress()).getAddress().getHostAddress());
  frontendConnection.setPort(((InetSocketAddress)ctx.channel().remoteAddress()).getPort());
  frontendConnection.setLocalPort(((InetSocketAddress)ctx.channel().localAddress()).getPort());
  if (!checkUser(authPacket.user,frontendConnection.getHost())) {
    failure(ErrorCode.ER_ACCESS_DENIED_ERROR,""String_Node_Str"" + authPacket.user + ""String_Node_Str"");
    return;
  }
  if (!checkPassword(authPacket.password,authPacket.user)) {
    failure(ErrorCode.ER_ACCESS_DENIED_ERROR,""String_Node_Str"" + authPacket.user + ""String_Node_Str"");
    return;
  }
switch (checkSchema(authPacket.database,authPacket.user)) {
case ErrorCode.ER_BAD_DB_ERROR:
    failure(ErrorCode.ER_BAD_DB_ERROR,""String_Node_Str"" + authPacket.database + ""String_Node_Str"");
  break;
case ErrorCode.ER_DBACCESS_DENIED_ERROR:
String s=""String_Node_Str"" + authPacket.user + ""String_Node_Str""+ authPacket.database+ ""String_Node_Str"";
failure(ErrorCode.ER_DBACCESS_DENIED_ERROR,s);
break;
default :
success(authPacket,ctx);
}
super.channelRead(ctx,msg);
}","@Override public void channelRead(ChannelHandlerContext ctx,Object msg) throws Exception {
  byte[] bytes=(byte[])msg;
  if (bytes.length == QuitPacket.QUIT.length && bytes[4] == MySQLPacket.COM_QUIT) {
    ctx.close();
    return;
  }
  AuthPacket authPacket=new AuthPacket();
  authPacket.read(bytes);
  frontendConnection.setHost(((InetSocketAddress)ctx.channel().remoteAddress()).getAddress().getHostAddress());
  frontendConnection.setPort(((InetSocketAddress)ctx.channel().remoteAddress()).getPort());
  frontendConnection.setLocalPort(((InetSocketAddress)ctx.channel().localAddress()).getPort());
  if (!checkUser(authPacket.user,frontendConnection.getHost())) {
    failure(ErrorCode.ER_ACCESS_DENIED_ERROR,""String_Node_Str"" + authPacket.user + ""String_Node_Str"");
    return;
  }
  if (!checkPassword(authPacket.password,authPacket.user)) {
    failure(ErrorCode.ER_ACCESS_DENIED_ERROR,""String_Node_Str"" + authPacket.user + ""String_Node_Str"");
    return;
  }
switch (checkSchema(authPacket.database,authPacket.user)) {
case ErrorCode.ER_BAD_DB_ERROR:
    failure(ErrorCode.ER_BAD_DB_ERROR,""String_Node_Str"" + authPacket.database + ""String_Node_Str"");
  break;
case ErrorCode.ER_DBACCESS_DENIED_ERROR:
String s=""String_Node_Str"" + authPacket.user + ""String_Node_Str""+ authPacket.database+ ""String_Node_Str"";
failure(ErrorCode.ER_DBACCESS_DENIED_ERROR,s);
break;
default :
success(authPacket,ctx);
}
}","The buggy code incorrectly calls `super.channelRead(ctx, msg)` after processing the authentication, which could lead to unintended duplicate message handling or potential resource leaks. The fixed code removes this unnecessary superclass method call, ensuring that the authentication process completes cleanly without redundant processing. By eliminating the extra method call, the code now provides a more precise and controlled channel reading mechanism, preventing potential unexpected behaviors during authentication."
38745,"public static void response(ServerConnection c){
  ByteBuf buf=c.getChannelHandlerContext().alloc().buffer();
  buf=header.writeBuf(buf);
  for (  FieldPacket field : fields) {
    buf=field.writeBuf(buf);
  }
  buf=eof.writeBuf(buf);
  byte packetId=eof.packetId;
  RowDataPacket row=new RowDataPacket(FIELD_COUNT);
  row.add(VERSION_COMMENT);
  row.packetId=++packetId;
  buf=row.writeBuf(buf);
  EOFPacket lastEof=new EOFPacket();
  lastEof.packetId=++packetId;
  buf=lastEof.writeBuf(buf);
  c.getChannelHandlerContext().writeAndFlush(buf);
}","public static void response(ServerConnection c){
  ByteBuf buf=c.getChannelHandlerContext().alloc().buffer();
  buf=header.writeBuf(buf);
  for (  FieldPacket field : fields) {
    buf=field.writeBuf(buf);
  }
  buf=eof.writeBuf(buf);
  byte packetId=eof.packetId;
  RowDataPacket row=new RowDataPacket(FIELD_COUNT);
  row.add(VERSION_COMMENT);
  row.packetId=++packetId;
  buf=row.writeBuf(buf);
  EOFPacket lastEof=new EOFPacket();
  lastEof.packetId=++packetId;
  buf=lastEof.writeBuf(buf);
  c.writeByteBuf(buf);
}","The original code uses `c.getChannelHandlerContext().writeAndFlush(buf)`, which directly interacts with the low-level channel handler context. The fixed code replaces this with `c.writeByteBuf(buf)`, which is likely a higher-level abstraction method specifically designed for writing byte buffers. This change simplifies the code, reduces direct channel manipulation, and potentially provides better encapsulation and error handling for writing network responses."
38746,"@Override public void channelRead(ChannelHandlerContext ctx,Object msg) throws Exception {
  byte[] data=(byte[])msg;
  source.setChannelHandlerContext(ctx);
  source.getConfigLatch().await();
  try {
    HandshakePacket packet=this.source.getShakePacket();
    if (packet == null) {
      packet=new HandshakePacket();
      packet.read(data);
      source.setShakePacket(packet);
      source.setThreadId(packet.threadId);
      int charsetIndex=(packet.serverCharsetIndex & 0xff);
      String charset=CharsetUtil.getCharset(charsetIndex);
      if (charset != null) {
        source.setCharsetIndex(charsetIndex);
        source.setCharset(charset);
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + charsetIndex);
      }
      source.authenticate();
    }
 else {
switch (data[4]) {
case OkPacket.FIELD_COUNT:
        source.setAuthenticated(true);
      ctx.pipeline().replace(BackendHandlerNameEnum.MYSQL_AUTH.getCode(),BackendHandlerNameEnum.MYSQL_CONN.getCode(),new BackendMySQLConnectionHandler(source));
    source.getHandler().connectionAcquired(source);
  break;
case ErrorPacket.FIELD_COUNT:
ErrorPacket err=new ErrorPacket();
err.read(data);
throw new RuntimeException(new String(err.message));
case EOFPacket.FIELD_COUNT:
auth323(data[3]);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
}
}
 catch (Exception e) {
this.source.getHandler().connectionError(e,source);
throw e;
}
super.channelRead(ctx,msg);
}","@Override public void channelRead(ChannelHandlerContext ctx,Object msg) throws Exception {
  byte[] data=(byte[])msg;
  source.setChannelHandlerContext(ctx);
  source.getConfigLatch().await();
  try {
    HandshakePacket packet=this.source.getShakePacket();
    if (packet == null) {
      packet=new HandshakePacket();
      packet.read(data);
      source.setShakePacket(packet);
      source.setThreadId(packet.threadId);
      int charsetIndex=(packet.serverCharsetIndex & 0xff);
      String charset=CharsetUtil.getCharset(charsetIndex);
      if (charset != null) {
        source.setCharsetIndex(charsetIndex);
        source.setCharset(charset);
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + charsetIndex);
      }
      source.authenticate();
    }
 else {
switch (data[4]) {
case OkPacket.FIELD_COUNT:
        source.setAuthenticated(true);
      ctx.pipeline().replace(BackendHandlerNameEnum.MYSQL_AUTH.getCode(),BackendHandlerNameEnum.MYSQL_CONN.getCode(),new BackendMySQLConnectionHandler(source));
    source.getHandler().connectionAcquired(source);
  break;
case ErrorPacket.FIELD_COUNT:
ErrorPacket err=new ErrorPacket();
err.read(data);
throw new RuntimeException(new String(err.message));
case EOFPacket.FIELD_COUNT:
auth323(data[3]);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
}
}
 catch (Exception e) {
this.source.getHandler().connectionError(e,source);
throw e;
}
}","The original code incorrectly called `super.channelRead(ctx, msg)` after handling the channel read logic, which could lead to unintended method invocations or potential resource leaks. The fixed code removes this unnecessary superclass method call, ensuring that the channel read processing completes cleanly without redundant method execution. By eliminating the superfluous method call, the code now provides a more precise and controlled handling of MySQL connection authentication and channel events."
38747,"/** 
 * You should not need to care about this method. In the unlikely case where you actually want all the cells of your ListView to actually be the same one, it is left protected and not private so you can override it and avoid the warnings being spouted at you. Else, the idea is that a set of cells is created and they share the elements one after another during scrolling and JavaFX might generate more of them later so we should just not make any assumption and expect all of them to be different and not singletons.
 */
protected void ensureCorrectSpringScoping(){
synchronized (HAS_CHECKED_BEAN_DEFINITIONS) {
    if (HAS_CHECKED_BEAN_DEFINITIONS.get())     return;
    final ConfigurableListableBeanFactory beanFactory=applicationContext.getBeanFactory();
    Stream.of(ComponentCellFxmlController.class,ComponentListCell.class).map(beanFactory::getBeanNamesForType).flatMap(Arrays::stream).forEach(pBean -> {
      final String effectiveScope=beanFactory.getBeanDefinition(pBean).getScope();
      if (ConfigurableBeanFactory.SCOPE_PROTOTYPE.equals(effectiveScope)) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",pBean);
      }
    }
);
    HAS_CHECKED_BEAN_DEFINITIONS.set(true);
  }
}","/** 
 * You should not need to care about this method. In the unlikely case where you actually want all the cells of your ListView to actually be the same one, it is left protected and not private so you can override it and avoid the warnings being spouted at you. Else, the idea is that a set of cells is created and they share the elements one after another during scrolling and JavaFX might generate more of them later so we should just not make any assumption and expect all of them to be different and not singletons.
 */
protected void ensureCorrectSpringScoping(){
synchronized (HAS_CHECKED_BEAN_DEFINITIONS) {
    if (HAS_CHECKED_BEAN_DEFINITIONS.get())     return;
    final ConfigurableListableBeanFactory beanFactory=applicationContext.getBeanFactory();
    Stream.of(ComponentCellFxmlController.class,ComponentListCell.class).map(beanFactory::getBeanNamesForType).flatMap(Arrays::stream).forEach(pBean -> {
      final String effectiveScope=beanFactory.getBeanDefinition(pBean).getScope();
      if (!ConfigurableBeanFactory.SCOPE_PROTOTYPE.equals(effectiveScope)) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",pBean);
      }
    }
);
    HAS_CHECKED_BEAN_DEFINITIONS.set(true);
  }
}","The original code warns when beans are in prototype scope, which is the opposite of the intended behavior. The fixed code changes the condition to warn when beans are NOT in prototype scope, ensuring that ComponentCellFxmlController and ComponentListCell have the correct scoping for dynamic ListView cell management. This modification helps prevent potential singleton-related issues by alerting developers when these critical JavaFX components are not properly configured as prototype beans."
38748,"/** 
 * This method stores your instances in a   {@link ConcurrentHashMap} that looks like this :<br>|-- CommonInst1 --<br> |                |-- Selector1 -&gt; Instance 1 of class  {@link V}<br> |                |-- Selector2 -&gt; Instance 2 of class   {@link V}<br> |<br> |-- CommonInst2 --<br> |                |-- Selector# -&gt; Instance # of class   {@link V}<br> |                ...<br> |                |-- SelectorN -&gt; Instance N of class   {@link V}<br> ...<br> |<br> <p> The point is that ""selectors"" are anything you want them to be, whether it be the hashcode of the instance (but you won't be able to access it easily later), or some kind of related Node. Whatever fits your model in the best way. <p> Be wary of collisions (i.e. Instance 1 and 2 having the same selector) as it replaces instances in case of collision. <p> You are responsible for providing correct and non-colliding selectors.
 * @param parent   An instance, typically an enum member
 * @param selector The selector that you have to provide to recover this particular instance later
 * @param instance The instance to save.
 * @return A map entry containing the selector and the controller registered in case you need it.
 * @throws RuntimeException in case there was an error in saving the instance.
 */
public Map.Entry<Selector,V> registerMultiple(final K parent,final Selector selector,final V instance){
  final HashMap<Selector,V> newEntryMap=new HashMap<>();
  newEntryMap.put(selector,instance);
  final Optional<Map.Entry<Selector,V>> newEntry=this.prototypes.merge(parent,newEntryMap,this::mergePrototypes).entrySet().stream().filter(entry -> entry.getKey().equals(selector)).findAny();
  return newEntry.orElseThrow(RuntimeException::new);
}","/** 
 * This method stores your instances in a   {@link ConcurrentHashMap} that looks like this :<br>|-- K1 --<br> |        |-- Selector1 -&gt; Instance 1 of class  {@link V}<br> |        |-- Selector2 -&gt; Instance 2 of class   {@link V}<br> |<br> |-- K2 --<br> |        |-- Selector# -&gt; Instance # of class   {@link V}<br> |        ...<br> |        |-- SelectorN -&gt; Instance N of class   {@link V}<br> ...<br> |<br> <p> The point is that ""selectors"" are anything you want them to be, whether it be the hashcode of the instance (but you won't be able to access it easily later), or some kind of related Node. Whatever fits your model in the best way. <p> Be wary of collisions (i.e. Instance 1 and 2 having the same selector) as it replaces instances in case of collision. <p> You are responsible for providing correct and non-colliding selectors.
 * @param parent   An instance, typically an enum member
 * @param selector The selector that you have to provide to recover this particular instance later
 * @param instance The instance to save.
 * @return A map entry containing the selector and the controller registered in case you need it.
 * @throws RuntimeException in case there was an error in saving the instance.
 */
public V registerMultiple(final K parent,final Selector selector,final V instance){
  if (!this.prototypes.containsKey(parent)) {
    this.prototypes.put(parent,new ConcurrentHashMap<>());
  }
  return this.prototypes.get(parent).put(selector,instance);
}","The original code used a complex stream operation to merge and retrieve an entry, which was inefficient and potentially error-prone. The fixed code simplifies the registration process by directly checking if the parent key exists, creating a new ConcurrentHashMap if needed, and then directly putting the instance with its selector. This approach provides a more straightforward, reliable method for registering multiple instances under a parent key, ensuring better performance and clarity."
38749,"@Test public void getAll(){
  this.instanceManager.registerSingle(PARENT,ACTUAL_1);
  this.instanceManager.registerSingle(PARENT,ACTUAL_2);
  this.instanceManager.registerMultiple(PARENT,SEL_1,ACTUAL_1);
  this.instanceManager.registerMultiple(PARENT,SEL_2,ACTUAL_2);
  final List<Object> all=this.instanceManager.getAll(PARENT);
  assertThat(all).containsExactlyInAnyOrder(ACTUAL_1,ACTUAL_2,ACTUAL_2);
}","@Test public void getAll(){
  this.instanceManager.registerSingle(PARENT,ACTUAL_1);
  this.instanceManager.registerSingle(PARENT,ACTUAL_2);
  this.instanceManager.registerMultiple(PARENT,SEL_1,ACTUAL_1);
  this.instanceManager.registerMultiple(PARENT,SEL_2,ACTUAL_2);
  final List<String> all=this.instanceManager.getAll(PARENT);
  assertThat(all).containsExactlyInAnyOrder(ACTUAL_1,ACTUAL_2,ACTUAL_2);
}","The original code incorrectly used `List<Object>` as the return type, which could lead to type ambiguity and potential runtime errors. The fixed code changes the return type to `List<String>`, ensuring type consistency and improving type safety for the `getAll` method. This modification provides clearer type expectations and prevents potential type-casting issues in the instance manager's implementation."
38750,"@Before public void setUp(){
  this.instanceManager=new AbstractInstanceManager<Object,Object,Object>(){
  }
;
}","@Before public void setUp(){
  this.instanceManager=new AbstractInstanceManager<String,String>(){
  }
;
}","The original code incorrectly uses an abstract class with three generic type parameters, which is likely not the intended implementation. The fixed code reduces the generic type parameters to two, suggesting a more appropriate and simplified generic type definition for the AbstractInstanceManager. This correction likely resolves type inference issues and provides a clearer, more focused generic type structure for the instance manager."
38751,"/** 
 * This method gets the   {@link Path} associated to a classpath-located file.
 * @param resourceRelativePath The path from the root of the classpath (target/classes/ in a maven project)
 * @return The path associated with resource at said relative path to classpath.
 */
@SuppressWarnings(""String_Node_Str"") public static Try<URL> getResourceURL(final String resourceRelativePath){
  final ClassLoader classLoader=Resources.class.getClassLoader();
  return Try.of(() -> classLoader).map(cl -> cl.getResource(resourceRelativePath)).map(Objects::requireNonNull).mapFailure(Case($(err -> err instanceof NullPointerException | err instanceof NoSuchFileException),err -> new IllegalArgumentException(""String_Node_Str"" + getBaseURL().toExternalForm() + resourceRelativePath,err)));
}","/** 
 * This method gets the   {@link Path} associated to a classpath-located file.
 * @param resourceRelativePath The path from the root of the classpath (target/classes/ in a maven project)
 * @return The path associated with resource at said relative path to classpath.
 */
@SuppressWarnings(""String_Node_Str"") public static Try<URL> getResourceURL(final String resourceRelativePath){
  final ClassLoader classLoader=Resources.class.getClassLoader();
  return Try.of(() -> classLoader).map(cl -> cl.getResource(resourceRelativePath)).map(Objects::requireNonNull).mapFailure(Case($(err -> err instanceof NullPointerException || err instanceof NoSuchFileException),err -> new IllegalArgumentException(""String_Node_Str"" + getBaseURL().toExternalForm() + resourceRelativePath,err)));
}","The original code used an incorrect bitwise OR (`|`) operator instead of a logical OR (`||`) when handling exceptions, which would lead to incorrect error handling. The fixed code replaces the bitwise OR with a logical OR, ensuring proper exception comparison and handling. This correction allows for more accurate error detection and provides a more robust method for retrieving resource URLs from the classpath."
38752,"private Resources(){
}","private Resources(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","The original private constructor allows unintended instantiation of the Resources class, potentially violating the singleton or utility class design pattern. The fixed code adds a throw statement with UnsupportedOperationException, explicitly preventing object creation and signaling that this class should not be instantiated. This approach ensures the class remains non-instantiable, protecting its intended use as a static utility or singleton implementation."
38753,"private void pushClipboardTestData(Clipboard clipboard){
  clipboard.setContents(new Transferable(){
    private final String value=""String_Node_Str"";
    @Override public DataFlavor[] getTransferDataFlavors(){
      return new DataFlavor[]{DataFlavor.stringFlavor};
    }
    @Override public boolean isDataFlavorSupported(    DataFlavor flavor){
      return flavor.equals(DataFlavor.stringFlavor);
    }
    @Override public Object getTransferData(    DataFlavor flavor){
      return value;
    }
  }
,(t,co) -> {
  }
);
}","private void pushClipboardTestData(Clipboard clipboard){
  clipboard.setContents(new Transferable(){
    @Override public DataFlavor[] getTransferDataFlavors(){
      return new DataFlavor[]{DataFlavor.stringFlavor};
    }
    @Override public boolean isDataFlavorSupported(    DataFlavor flavor){
      return flavor.equals(DataFlavor.stringFlavor);
    }
    @Override public Object getTransferData(    DataFlavor flavor){
      return TEST_CB_VALUE;
    }
  }
,(t,co) -> {
  }
);
}","The original code hardcoded a string value directly within the Transferable implementation, which lacks flexibility and maintainability. The fixed code introduces a constant TEST_CB_VALUE, which allows for easier modification and centralized management of the clipboard test data. This change improves code readability, makes the value more configurable, and follows better software design principles by separating the data from its implementation."
38754,"@Override public Object getTransferData(DataFlavor flavor){
  return value;
}","@Override public Object getTransferData(DataFlavor flavor){
  return TEST_CB_VALUE;
}","The original code references an undefined variable 'value', which could lead to compilation errors or unexpected runtime behavior. The fixed code replaces 'value' with 'TEST_CB_VALUE', a presumably predefined constant that provides a consistent and predictable return value for the getTransferData method. By using a well-defined constant, the code becomes more reliable, predictable, and less prone to potential null or undefined value issues during data transfer operations."
38755,"@SuppressWarnings(""String_Node_Str"") @Test public void asyncAwtRunnableWithRequirement(){
  AwtUtils.asyncAwtRunnableWithRequirement(Toolkit.getDefaultToolkit()::getSystemClipboard,this::pushClipboardTestData);
  final CompletionStage<Try<Object>> asyncCb=AwtUtils.asyncAwtCallbackWithRequirement(Toolkit.getDefaultToolkit()::getSystemClipboard,cb -> Try.of(() -> cb.getData(DataFlavor.stringFlavor)));
  final Try<Object> clipboardLoad=Try.of(asyncCb.toCompletableFuture()::get);
  assertThat(clipboardLoad.isSuccess()).isTrue();
  assertThat(((Try<Object>)clipboardLoad.get()).get()).isEqualTo(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") @Test public void asyncAwtRunnableWithRequirement(){
  AwtUtils.asyncAwtRunnableWithRequirement(Toolkit.getDefaultToolkit()::getSystemClipboard,this::pushClipboardTestData);
  final CompletionStage<Try<Object>> asyncCb=AwtUtils.asyncAwtCallbackWithRequirement(Toolkit.getDefaultToolkit()::getSystemClipboard,cb -> Try.of(() -> cb.getData(DataFlavor.stringFlavor)));
  final Try<Object> clipboardLoad=Try.of(asyncCb.toCompletableFuture()::get);
  assertThat(clipboardLoad.isSuccess()).isTrue();
  assertThat(((Try<Object>)clipboardLoad.get()).get()).isEqualTo(TEST_CB_VALUE);
}","The original code hardcoded the string ""String_Node_Str"" directly, which is inflexible and potentially error-prone. The fixed code replaces the hardcoded string with TEST_CB_VALUE, likely a constant or variable representing the expected clipboard test data, making the test more maintainable and adaptable. This change improves code readability, reduces magic strings, and provides a clearer, more robust approach to testing clipboard functionality."
38756,"public static void main(final String... args){
  final SpringApplicationBuilder sab=new SpringApplicationBuilder(__main_stub.class).headless(false).web(WebApplicationType.NONE);
  try (ConfigurableApplicationContext ctx=sab.run(args)){
    LOG.info(""String_Node_Str"");
    ctx.close();
    throw new IllegalStateException(""String_Node_Str"");
  }
 }","public static void main(final String... args){
  final SpringApplicationBuilder sab=new SpringApplicationBuilder(__main_stub.class).headless(false).web(WebApplicationType.NONE);
  final ConfigurableApplicationContext ctx=sab.run(args);
  LOG.info(""String_Node_Str"");
  ctx.close();
  throw new IllegalStateException(""String_Node_Str"");
}","The original code uses a try-with-resources block, which automatically closes the ConfigurableApplicationContext, potentially interfering with subsequent operations. The fixed code removes the try-with-resources block, allowing manual control over the context's lifecycle and ensuring that ctx.close() is explicitly called before throwing the exception. This modification provides more predictable resource management and allows for clearer error handling and context manipulation."
38757,"@Test(expected=RuntimeException.class) public void main(){
  __main_stub.main();
}","@Test(expected=IllegalStateException.class) public void main(){
  __main_stub.main();
}","The original code incorrectly specified a generic RuntimeException, which is too broad and lacks precision for specific error handling. The fixed code uses IllegalStateException, a more specific exception that accurately represents an illegal state in the application's execution. By using a more targeted exception, the test becomes more meaningful and provides clearer insight into potential runtime errors during method execution."
38758,"@Test public void getCssContent() throws IOException {
  final FxmlStylesheet stylesheet=this.stylesheetLoading.getOrElseThrow(IOException::new);
  assertThat(stylesheet.getCssContent()).isEqualTo(TEST_STYLE_CONTENT);
}","@Test public void getCssContent() throws IOException {
  final FxmlStylesheet stylesheet=this.stylesheetLoading.getOrElseThrow(IOException::new);
  assertThat(stylesheet.getCssContent()).isEqualToIgnoringWhitespace(TEST_STYLE_CONTENT);
}","The original code used a strict equality comparison for CSS content, which fails when whitespace differs between the expected and actual content. The fixed code introduces `isEqualToIgnoringWhitespace()`, which compares the CSS content while disregarding insignificant whitespace variations. This modification makes the test more robust by focusing on the meaningful content of the stylesheet rather than exact formatting."
38759,"@Autowired public BrowserSupport(Desktop desktop){
  this.desktop=desktop;
}","@Autowired public BrowserSupport(final Desktop desktop){
  this.desktop=desktop;
}","The original code lacks the `final` keyword for the `desktop` parameter, which can lead to potential mutability issues and unintended modifications. By adding `final`, the fixed code ensures that the `Desktop` object passed to the constructor cannot be reassigned, providing immutability and preventing accidental changes. This improvement enhances code reliability and helps maintain the integrity of the dependency injection process."
38760,"private void browse(final URI uri){
  try {
    this.desktop.browse(uri);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","private void browse(final URI uri){
  try {
    this.desktop.browse(uri);
  }
 catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}","The original code lacks the `final` keyword for the caught exception parameter, which doesn't impact functionality but misses a best practice for exception handling. The fixed code adds `final` to the exception parameter, ensuring the caught exception cannot be reassigned within the catch block. This small modification improves code clarity and prevents accidental modification of the exception object during error handling."
38761,"@Autowired public SystemTraySupport(SystemTray awtSystemTray,Toolkit awtToolkit){
  this.awtSystemTray=new AtomicReference<>(awtSystemTray);
  this.awtToolkit=awtToolkit;
}","@Autowired public SystemTraySupport(final SystemTray awtSystemTray,final Toolkit awtToolkit){
  this.awtSystemTray=new AtomicReference<>(awtSystemTray);
  this.awtToolkit=awtToolkit;
}","The original code lacks parameter immutability, which could potentially lead to unintended modifications of input parameters during object initialization. The fixed code introduces the `final` keyword for `awtSystemTray` and `awtToolkit` parameters, ensuring their values cannot be changed after initial assignment. By enforcing immutability, the fixed code provides better thread safety and prevents accidental parameter mutations during the constructor's execution."
38762,"public static CompletableFuture<Stage> displayExceptionPane(final String title,final String readable,final Throwable exception){
  final Pane exceptionPane=new ExceptionHandler(exception).asPane(readable);
  final CompletableFuture<Stage> exceptionStage=StageUtils.stageOf(title,exceptionPane);
  return exceptionStage.thenCompose(StageUtils::scheduleDisplaying);
}","public static CompletionStage<Stage> displayExceptionPane(final String title,final String readable,final Throwable exception){
  final Pane exceptionPane=new ExceptionHandler(exception).asPane(readable);
  final CompletionStage<Stage> exceptionStage=StageUtils.stageOf(title,exceptionPane);
  return exceptionStage.thenCompose(StageUtils::scheduleDisplaying);
}","The original code used `CompletableFuture<Stage>` which tightly couples the method to a specific implementation of asynchronous computation. The fixed code replaces this with `CompletionStage<Stage>`, a more generic and flexible interface that allows for broader compatibility with different asynchronous computation models. This change enhances the method's reusability and adherence to programming interfaces that promote loose coupling and extensibility."
38763,"private Option<FxmlController> makeControllerForNode(FxmlNode node){
  return node.getControllerClass().map(this.context::getBean);
}","private Option<FxmlController> makeControllerForNode(final FxmlNode node){
  return node.getControllerClass().map(this.context::getBean);
}","The original code lacks the `final` keyword for the method parameter, which can potentially lead to unintended parameter mutation. The fixed code adds `final` to the `node` parameter, ensuring immutability and preventing accidental modifications during method execution. This change enhances code safety and provides a clear signal of the parameter's intended usage throughout the method's scope."
38764,"/** 
 * This method acts just like   {@link #loadNode(FxmlNode)} but with noautoconfiguration of controller binding and stylesheet application.
 */
protected <T extends Node>Try<T> loadNodeImpl(final FxmlLoader fxmlLoader,final FxmlNode fxmlNode){
  final String filePath=this.filePath(fxmlNode);
  fxmlLoader.setLocation(getUrlForResource(filePath));
  Try<T> loadResult=Try.of(fxmlLoader::load);
  loadResult.onSuccess(fxmlLoader::onSuccess).onFailure(fxmlLoader::onFailure);
  return this.applyStylesheetIfNeeded(fxmlNode,loadResult);
}","/** 
 * This method acts just like   {@link #loadNode(FxmlNode)} but with noautoconfiguration of controller binding and stylesheet application.
 */
protected <T extends Node>Try<T> loadNodeImpl(final FxmlLoader fxmlLoader,final FxmlNode fxmlNode){
  final String filePath=this.filePath(fxmlNode);
  fxmlLoader.setLocation(getUrlForResource(filePath));
  final Try<T> loadResult=Try.of(fxmlLoader::load);
  loadResult.onSuccess(fxmlLoader::onSuccess).onFailure(fxmlLoader::onFailure);
  return this.applyStylesheetIfNeeded(fxmlNode,loadResult);
}","The original code had a potential issue with variable mutability, as the `loadResult` variable was not marked as final, which could lead to unexpected behavior during concurrent or multi-threaded operations. The fixed code declares `loadResult` as a final variable, ensuring immutability and preventing potential race conditions or unintended modifications. By making this small change, the code becomes more robust and predictable, maintaining the integrity of the FXML loading process."
38765,"public void setOnSuccess(Runnable onSuccess){
  this.onSuccess=onSuccess;
}","public void setOnSuccess(final Runnable onSuccess){
  this.onSuccess=onSuccess;
}","The original code lacks the `final` keyword when passing the `onSuccess` runnable, which can lead to potential issues with variable capture in lambda expressions or anonymous inner classes. By adding the `final` keyword, the parameter becomes effectively final, ensuring that its reference cannot be modified after initialization. This guarantees consistent behavior and prevents unintended modifications to the callback, making the code more predictable and thread-safe."
38766,"public void onSuccess(Object loadResult){
  this.onSuccess.run();
}","public void onSuccess(final Object loadResult){
  this.onSuccess.run();
}","The original code lacks the `final` keyword for the `loadResult` parameter, which could lead to potential issues with variable mutability in certain contexts. By adding `final`, the parameter becomes immutable, preventing unintended modifications and ensuring thread safety in callback scenarios. This small change enhances code reliability and prevents potential runtime errors by making the parameter a read-only reference."
38767,"public static CompletableFuture<Stage> stageOf(final String title,final Pane rootPane){
  final CompletableFuture<Stage> upcomingStage=new CompletableFuture<>();
  Platform.runLater(() -> {
    final Stage stage=new Stage(StageStyle.DECORATED);
    stage.setTitle(title);
    stage.setScene(new Scene(rootPane));
    upcomingStage.complete(stage);
  }
);
  return upcomingStage;
}","public static CompletionStage<Stage> stageOf(final String title,final Pane rootPane){
  final CompletableFuture<Stage> upcomingStage=new CompletableFuture<>();
  Platform.runLater(() -> {
    final Stage stage=new Stage(StageStyle.DECORATED);
    stage.setTitle(title);
    stage.setScene(new Scene(rootPane));
    upcomingStage.complete(stage);
  }
);
  return upcomingStage;
}","The original code used a specific return type of CompletableFuture<Stage>, which limits flexibility and type compatibility in broader application contexts. The fixed code changes the return type to the more generic CompletionStage<Stage>, enabling better abstraction and allowing for more flexible stage creation and composition. This modification provides improved type-level polymorphism and supports more versatile asynchronous programming patterns in JavaFX applications."
38768,"public static CompletableFuture<Stage> scheduleHiding(final Stage stage){
  LOG.debug(""String_Node_Str"",stage,stage.getTitle());
  return asyncStageOperation(stage,Stage::hide);
}","public static CompletionStage<Stage> scheduleHiding(final Stage stage){
  LOG.debug(""String_Node_Str"",stage,stage.getTitle());
  return asyncStageOperation(stage,Stage::hide);
}","The original code used `CompletableFuture<Stage>` which is a specific implementation, limiting flexibility in asynchronous programming. The fixed code changes the return type to `CompletionStage<Stage>`, a more generic interface that allows for broader compatibility and abstraction. This modification enables better interoperability with different asynchronous computation models and provides more flexible stage handling in concurrent operations."
38769,"public static CompletableFuture<Stage> scheduleDisplaying(final Stage stage){
  LOG.debug(""String_Node_Str"",stage,stage.getTitle());
  return asyncStageOperation(stage,Stage::show);
}","public static CompletionStage<Stage> scheduleDisplaying(final Stage stage){
  LOG.debug(""String_Node_Str"",stage,stage.getTitle());
  return asyncStageOperation(stage,Stage::show);
}","The original code uses `CompletableFuture<Stage>`, which is a specific implementation of asynchronous computation, limiting flexibility in method signatures. The fixed code changes the return type to the more generic `CompletionStage<Stage>`, allowing broader compatibility with different asynchronous computation implementations. This modification enhances code flexibility and enables easier integration with various asynchronous programming patterns and frameworks."
38770,"public static CompletableFuture<Stage> asyncStageOperation(final Stage stage,final Consumer<Stage> asyncOp){
  final CompletableFuture<Stage> onAsyncOpDone=new CompletableFuture<>();
  Platform.runLater(() -> {
    asyncOp.accept(stage);
    onAsyncOpDone.complete(stage);
  }
);
  return onAsyncOpDone;
}","public static CompletionStage<Stage> asyncStageOperation(final Stage stage,final Consumer<Stage> asyncOp){
  final CompletableFuture<Stage> onAsyncOpDone=new CompletableFuture<>();
  Platform.runLater(() -> {
    asyncOp.accept(stage);
    onAsyncOpDone.complete(stage);
  }
);
  return onAsyncOpDone;
}","The original code uses a specific `CompletableFuture<Stage>` return type, which limits flexibility and potential interoperability with other asynchronous APIs. The fixed code changes the return type to the more generic `CompletionStage<Stage>`, which provides broader compatibility and allows for easier chaining and composition of asynchronous operations. This modification enables more flexible and extensible asynchronous programming patterns while maintaining the core functionality of the method."
38771,"@Before public void ensureNotCi(){
  final String envProperty=System.getProperty(""String_Node_Str"");
  if (envProperty != null) {
    assumeFalse(System.getProperty(""String_Node_Str"").equals(""String_Node_Str""));
  }
  System.out.println(""String_Node_Str"");
}","@Before public void ensureNotCi(){
  final String envProperty=System.getProperty(""String_Node_Str"");
  if (envProperty != null) {
    assumeFalse(""String_Node_Str"".equals(System.getProperty(""String_Node_Str"")));
  }
  System.out.println(""String_Node_Str"");
}","The original code incorrectly checks the system property by comparing the property value against a hardcoded string using an unoptimal order of comparison. In the fixed code, the order of comparison is reversed to ""String_Node_Str"".equals(System.getProperty(""String_Node_Str"")), which prevents potential null pointer exceptions and follows the recommended null-safe comparison pattern. This change ensures more robust and predictable behavior when checking system properties, reducing the risk of unexpected runtime errors."
38772,"@Override public void start(Stage stage){
  this.EXCEPTION_TEXT=""String_Node_Str"";
  this.EXCEPTION_TEXT_READABLE=""String_Node_Str"";
  this.EXCEPTION=new Exception(this.EXCEPTION_TEXT);
  this.ERR_PANE=new ExceptionHandler(this.EXCEPTION).asPane();
  this.ERR_PANE_READBLE=new ExceptionHandler(this.EXCEPTION).asPane(this.EXCEPTION_TEXT_READABLE);
}","@Override public void start(final Stage stage){
  this.EXCEPTION_TEXT=""String_Node_Str"";
  this.EXCEPTION_TEXT_READABLE=""String_Node_Str"";
  this.EXCEPTION=new Exception(this.EXCEPTION_TEXT);
  this.ERR_PANE=new ExceptionHandler(this.EXCEPTION).asPane();
  this.ERR_PANE_READBLE=new ExceptionHandler(this.EXCEPTION).asPane(this.EXCEPTION_TEXT_READABLE);
}","The original code lacks the `final` keyword for the `stage` parameter, which can lead to potential unintended modifications of the Stage object during method execution. Adding `final` ensures the stage reference cannot be changed within the method, providing immutability and preventing accidental reassignments. This small modification enhances code robustness by explicitly declaring the parameter's intent and preventing unintended side effects during the application's startup process."
38773,"@Test public void displayExceptionPane() throws ExecutionException, InterruptedException {
  final CompletableFuture<Stage> displayedStage=ExceptionHandler.displayExceptionPane(this.EXCEPTION_TEXT,this.EXCEPTION_TEXT_READABLE,this.EXCEPTION);
  final Stage stage=displayedStage.get();
  assertThat(stage.isShowing()).isTrue();
}","@Test public void displayExceptionPane(){
  final CompletionStage<Stage> displayedStage=ExceptionHandler.displayExceptionPane(this.EXCEPTION_TEXT,this.EXCEPTION_TEXT_READABLE,this.EXCEPTION);
  displayedStage.thenAccept(stage -> assertThat(stage.isShowing()));
}","The original code blocks the test thread by synchronously waiting for the CompletableFuture to complete, which can lead to potential deadlocks and reduced test responsiveness. The fixed code uses thenAccept to asynchronously handle the stage, allowing for non-blocking assertion of the stage's visibility. This approach improves test reliability and performance by avoiding synchronous waiting and leveraging reactive programming principles."
38774,"@Override public void start(Stage stage){
}","@Override public void start(final Stage stage){
}","The original code lacks proper parameter handling for the Stage, which could lead to potential modification issues within the method. By adding the 'final' keyword, the Stage parameter becomes immutable, preventing unintended changes and ensuring thread safety during the JavaFX application lifecycle. This modification enhances code reliability and follows best practices for method parameter declaration in Java."
38775,"private Pane assertTestPaneLoadedCorrectly(Supplier<Try<Pane>> paneLoadingSupplier){
  final Try<Pane> testPaneLoadResult=paneLoadingSupplier.get();
  assertThat(testPaneLoadResult.isSuccess());
  final Pane testPane=testPaneLoadResult.get();
  assertThat(testPane.getChildren()).hasSize(1);
  assertThat(testPane.getChildren().get(0).getClass()).isEqualTo(Button.class);
  return testPane;
}","private Pane assertTestPaneLoadedCorrectly(final Supplier<Try<Pane>> paneLoadingSupplier){
  final Try<Pane> testPaneLoadResult=paneLoadingSupplier.get();
  assertThat(testPaneLoadResult.isSuccess());
  final Pane testPane=testPaneLoadResult.get();
  assertThat(testPane.getChildren()).hasSize(1);
  assertThat(testPane.getChildren().get(0).getClass()).isEqualTo(Button.class);
  return testPane;
}","The original code lacks the `final` keyword for the `paneLoadingSupplier` parameter, which could potentially allow unintended modification of the supplier during method execution. The fixed code adds `final` to the parameter, ensuring immutability and preventing accidental changes to the supplier. This small modification enhances method robustness by guaranteeing the supplier remains constant throughout the method's lifecycle, promoting more predictable and safer code behavior."
38776,"void FXMLNODES(FxmlFile fxmlFile,Option<Class<? extends FxmlController>> controllerClass,Option<FxmlStylesheet> stylesheet){
  this.fxmlFile=fxmlFile;
  this.controllerClass=controllerClass;
  this.stylesheet=stylesheet;
}","void FXMLNODES(final FxmlFile fxmlFile,final Option<Class<? extends FxmlController>> controllerClass,final Option<FxmlStylesheet> stylesheet){
  this.fxmlFile=fxmlFile;
  this.controllerClass=controllerClass;
  this.stylesheet=stylesheet;
}","The original code lacks parameter immutability, which can lead to unintended modifications of input parameters during method execution. The fixed code introduces the `final` keyword to each parameter, preventing accidental reassignment and ensuring parameter values remain constant throughout the method. This enhancement provides better code safety, reduces potential side effects, and promotes more predictable and robust method behavior."
38777,"@Override public void start(Stage stage){
  this.testButton=new Button();
  this.testPane=new AnchorPane(this.testButton);
  stage.setScene(new Scene(this.testPane,200,200));
  stage.show();
}","@Override public void start(final Stage stage){
  this.testButton=new Button();
  final AnchorPane testPane=new AnchorPane(this.testButton);
  stage.setScene(new Scene(testPane,WIDTH_PANE,HEIGHT_PANE));
  stage.show();
}","The original code incorrectly uses a class-level `testPane` variable, which can lead to potential memory and scope management issues. The fixed code introduces a `final` local variable `testPane` and uses predefined width and height constants, improving encapsulation and making the code more modular. These changes enhance code readability, reduce potential side effects, and provide a clearer, more maintainable implementation of the JavaFX application's start method."
38778,"@Test public void stageOf(){
  final CompletableFuture<Stage> stageReq=StageUtils.stageOf(STAGE_TITLE,STAGE_PANE);
  stageReq.thenAccept(stage -> {
    assertThat(stage.getScene().getRoot()).isEqualTo(STAGE_PANE);
    assertThat(stage.getTitle()).isEqualTo(STAGE_TITLE);
  }
);
}","@Test public void stageOf(){
  final CompletionStage<Stage> stageReq=StageUtils.stageOf(STAGE_TITLE,STAGE_PANE);
  stageReq.thenAccept(stage -> {
    assertThat(stage.getScene().getRoot()).isEqualTo(STAGE_PANE);
    assertThat(stage.getTitle()).isEqualTo(STAGE_TITLE);
  }
);
}","The original code used `CompletableFuture<Stage>`, which is a specific implementation, limiting flexibility and type generality. The fixed code replaces it with `CompletionStage<Stage>`, a more abstract interface that allows for broader compatibility and better adherence to programming interfaces. This change enhances code flexibility, enables easier integration with different asynchronous processing frameworks, and provides a more generalized approach to handling stage-related asynchronous operations."
38779,"@Override public void start(Stage stage){
  Platform.setImplicitExit(false);
  STAGE_TITLE=""String_Node_Str"";
  STAGE_TITLE_2=""String_Node_Str"";
  STAGE_PANE=new Pane();
  TEST_STAGE=stage;
  stage.show();
  stage.hide();
}","@Override public void start(final Stage stage){
  Platform.setImplicitExit(false);
  STAGE_TITLE=""String_Node_Str"";
  STAGE_TITLE_2=""String_Node_Str"";
  STAGE_PANE=new Pane();
  TEST_STAGE=stage;
  stage.show();
  stage.hide();
}","The original code lacks the `final` keyword for the `stage` parameter, which can lead to potential mutability issues in method implementations. The fixed code adds the `final` keyword, ensuring that the stage reference cannot be modified within the method, preventing unintended alterations. This modification enhances code safety and provides a more robust approach to handling the stage parameter in JavaFX application initialization."
38780,"/** 
 * Import existing projects into the workspace
 * @param srcWS The source location of the project (all projects must be located in the same folder)
 * @param projectNames The names of the projects to import
 * @param copyProjects Whether project contents should be copied into the workspace or not
 * @throws CoreException
 */
public static void importProjects(IPath srcWS,String[] projectNames,boolean copyProjects) throws CoreException {
  IPath srcPath=resourceFolder.append(srcWS);
  if (!copyProjects) {
    IPath tmpPath=new Path(System.getProperty(""String_Node_Str""));
    tmpPath=tmpPath.append(""String_Node_Str"");
    try {
      ServerTestUtil.copyProjects(srcPath,projectNames,tmpPath);
    }
 catch (    IOException e) {
      throw new CoreException(new Status(IStatus.ERROR,Activator.PLUGIN_ID,e.getMessage(),e));
    }
    srcPath=tmpPath;
  }
  ServerTestUtil.importProjects(srcPath,projectNames,copyProjects);
}","/** 
 * Import existing projects into the workspace
 * @param srcWS The source location of the project (all projects must be located in the same folder)
 * @param projectNames The names of the projects to import
 * @param copyProjects Whether project contents should be copied into the workspace or not
 * @throws CoreException
 */
public static void importProjects(IPath srcWS,String[] projectNames,boolean copyProjects) throws CoreException {
  IPath srcPath=resourceFolder.append(srcWS);
  if (!copyProjects) {
    IPath tmpPath=new Path(System.getProperty(""String_Node_Str""));
    tmpPath=tmpPath.append(""String_Node_Str"");
    if (tmpPath.toFile().exists()) {
      try {
        FileUtil.deleteDirectory(tmpPath.toOSString(),true);
      }
 catch (      IOException e) {
        print(""String_Node_Str"" + tmpPath.toOSString());
      }
    }
    try {
      ServerTestUtil.copyProjects(srcPath,projectNames,tmpPath);
    }
 catch (    IOException e) {
      throw new CoreException(new Status(IStatus.ERROR,Activator.PLUGIN_ID,e.getMessage(),e));
    }
    srcPath=tmpPath;
  }
  ServerTestUtil.importProjects(srcPath,projectNames,copyProjects);
}","The original code lacks proper handling of temporary directory cleanup, potentially leaving residual files from previous imports. The fixed code adds a check to delete the existing temporary directory before copying projects, using FileUtil.deleteDirectory() to ensure a clean workspace and prevent potential conflicts. This improvement enhances code reliability by preventing stale data accumulation and providing a more robust project import mechanism."
38781,"/** 
 * Load the server extensions.
 */
public static ServerExtensionWrapper[] createServerExtensions(){
  if (Trace.ENABLED)   Trace.trace(Trace.EXTENSION_POINT,""String_Node_Str"");
  IExtensionRegistry registry=Platform.getExtensionRegistry();
  IConfigurationElement[] cf=registry.getConfigurationElementsFor(Activator.PLUGIN_ID,EXTENSION_POINT);
  List<ServerExtensionWrapper> list=new ArrayList<ServerExtensionWrapper>(cf.length);
  List<String> appTypeList=new ArrayList<String>();
  List<String> genericTypeList=new ArrayList<String>();
  List<String> applicationElementList=new ArrayList<String>();
  applicationElementList.add(""String_Node_Str"");
  for (  IConfigurationElement ce : cf) {
    try {
      ServerExtensionWrapper sew=new ServerExtensionWrapper(ce);
      list.add(sew);
      for (      String s : sew.applicationTypes) {
        if (s != null)         appTypeList.add(s);
      }
      for (      String s : sew.applicationElements) {
        if (s != null)         applicationElementList.add(s);
      }
      for (      String s : sew.genericModuleTypes) {
        genericTypeList.add(s);
      }
      if (Trace.ENABLED)       Trace.trace(Trace.EXTENSION_POINT,""String_Node_Str"" + ce.getAttribute(""String_Node_Str""));
    }
 catch (    Throwable t) {
      Trace.logError(""String_Node_Str"" + ce.getAttribute(""String_Node_Str""),t);
    }
  }
  if (allApplicationTypes == null)   allApplicationTypes=appTypeList.toArray(new String[appTypeList.size()]);
  if (allApplicationElements == null)   allApplicationElements=applicationElementList.toArray(new String[applicationElementList.size()]);
  if (allGenericModuleTypes == null)   allGenericModuleTypes=genericTypeList.toArray(new String[genericTypeList.size()]);
  if (Trace.ENABLED)   Trace.trace(Trace.EXTENSION_POINT,""String_Node_Str"");
  return list.toArray(new ServerExtensionWrapper[list.size()]);
}","/** 
 * Load the server extensions.
 */
public static ServerExtensionWrapper[] createServerExtensions(){
  if (Trace.ENABLED)   Trace.trace(Trace.EXTENSION_POINT,""String_Node_Str"");
  IExtensionRegistry registry=Platform.getExtensionRegistry();
  IConfigurationElement[] cf=registry.getConfigurationElementsFor(Activator.PLUGIN_ID,EXTENSION_POINT);
  List<ServerExtensionWrapper> list=new ArrayList<ServerExtensionWrapper>(cf.length);
  Set<String> appTypeList=new HashSet<String>();
  Set<String> genericTypeList=new HashSet<String>();
  Set<String> applicationElementList=new HashSet<String>();
  applicationElementList.add(""String_Node_Str"");
  for (  IConfigurationElement ce : cf) {
    try {
      ServerExtensionWrapper sew=new ServerExtensionWrapper(ce);
      list.add(sew);
      for (      String s : sew.applicationTypes) {
        if (s != null)         appTypeList.add(s);
      }
      for (      String s : sew.applicationElements) {
        if (s != null)         applicationElementList.add(s);
      }
      for (      String s : sew.genericModuleTypes) {
        genericTypeList.add(s);
      }
      if (Trace.ENABLED)       Trace.trace(Trace.EXTENSION_POINT,""String_Node_Str"" + ce.getAttribute(""String_Node_Str""));
    }
 catch (    Throwable t) {
      Trace.logError(""String_Node_Str"" + ce.getAttribute(""String_Node_Str""),t);
    }
  }
  if (allApplicationTypes == null)   allApplicationTypes=appTypeList.toArray(new String[appTypeList.size()]);
  if (allApplicationElements == null)   allApplicationElements=applicationElementList.toArray(new String[applicationElementList.size()]);
  if (allGenericModuleTypes == null)   allGenericModuleTypes=genericTypeList.toArray(new String[genericTypeList.size()]);
  if (Trace.ENABLED)   Trace.trace(Trace.EXTENSION_POINT,""String_Node_Str"");
  return list.toArray(new ServerExtensionWrapper[list.size()]);
}","The original code used ArrayList for collecting unique application types, elements, and generic module types, which could potentially contain duplicates. The fixed code replaces ArrayLists with HashSet to automatically eliminate duplicate entries and ensure unique values are stored efficiently. By using Sets, the code prevents redundant entries and provides a more robust mechanism for tracking distinct server extension attributes."
38782,"public static List<LocalAppFileSystemConfig> load(PlatformConfig platformConfig){
  List<LocalAppFileSystemConfig> configs=new ArrayList<>();
  ModuleConfig moduleConfig=platformConfig.getModuleConfigIfExists(""String_Node_Str"");
  if (moduleConfig != null) {
    if (moduleConfig.hasProperty(""String_Node_Str"") && moduleConfig.hasProperty(""String_Node_Str"")) {
      String driveName=moduleConfig.getStringProperty(""String_Node_Str"");
      boolean remotelyAccessible=moduleConfig.getBooleanProperty(""String_Node_Str"",DEFAULT_REMOTELY_ACCESSIBLE);
      Path rootDir=moduleConfig.getPathProperty(""String_Node_Str"");
      configs.add(new LocalAppFileSystemConfig(driveName,remotelyAccessible,rootDir));
    }
    int maxAdditionalDriveCount=moduleConfig.getIntProperty(""String_Node_Str"",0);
    for (int i=0; i < maxAdditionalDriveCount; i++) {
      if (moduleConfig.hasProperty(""String_Node_Str"" + i) && moduleConfig.hasProperty(""String_Node_Str"" + i)) {
        String driveName=moduleConfig.getStringProperty(""String_Node_Str"" + i);
        boolean remotelyAccessible=moduleConfig.getBooleanProperty(""String_Node_Str"" + i,DEFAULT_REMOTELY_ACCESSIBLE);
        Path rootDir=moduleConfig.getPathProperty(""String_Node_Str"" + i);
        configs.add(new LocalAppFileSystemConfig(driveName,remotelyAccessible,rootDir));
      }
    }
  }
 else {
    for (    Path rootDir : platformConfig.getFileSystem().getRootDirectories()) {
      configs.add(new LocalAppFileSystemConfig(rootDir.toString(),false,rootDir));
    }
  }
  return configs;
}","public static List<LocalAppFileSystemConfig> load(PlatformConfig platformConfig){
  List<LocalAppFileSystemConfig> configs=new ArrayList<>();
  ModuleConfig moduleConfig=platformConfig.getModuleConfigIfExists(""String_Node_Str"");
  if (moduleConfig != null) {
    load(moduleConfig,OptionalInt.empty(),configs);
    int maxAdditionalDriveCount=moduleConfig.getIntProperty(""String_Node_Str"",0);
    for (int i=0; i < maxAdditionalDriveCount; i++) {
      load(moduleConfig,OptionalInt.of(i),configs);
    }
  }
 else {
    for (    Path rootDir : platformConfig.getFileSystem().getRootDirectories()) {
      if (Files.isDirectory(rootDir)) {
        configs.add(new LocalAppFileSystemConfig(rootDir.toString(),false,rootDir));
      }
    }
  }
  return configs;
}","The original code had redundant and error-prone property checks with hardcoded string keys, leading to potential configuration loading mistakes. The fixed code introduces a new `load` method with an optional index parameter, which centralizes the configuration loading logic and eliminates duplicate code. This refactoring improves code readability, reduces potential bugs, and adds a robust mechanism for handling multiple drive configurations with a single, flexible method."
38783,"private LocalFolder scanFolder(Path path,boolean useCache){
  LocalFolder folder=null;
  if (Files.isReadable(path)) {
    if (useCache && folderCache.containsKey(path)) {
      folder=folderCache.get(path);
    }
 else {
      LocalFolderScannerContext context=new LocalFolderScannerContext(rootDir,fileSystemName,computationManager);
      for (      LocalFolderScanner folderScanner : folderScanners) {
        folder=folderScanner.scanFolder(path,context);
        if (folder != null) {
          break;
        }
      }
      folderCache.put(path,folder);
    }
  }
  return folder;
}","private LocalFolder scanFolder(Path path,boolean useCache){
  LocalFolder folder=null;
  if (Files.isReadable(path) && Files.isExecutable(path)) {
    if (useCache && folderCache.containsKey(path)) {
      folder=folderCache.get(path);
    }
 else {
      LocalFolderScannerContext context=new LocalFolderScannerContext(rootDir,fileSystemName,computationManager);
      for (      LocalFolderScanner folderScanner : folderScanners) {
        folder=folderScanner.scanFolder(path,context);
        if (folder != null) {
          break;
        }
      }
      folderCache.put(path,folder);
    }
  }
  return folder;
}","The original code only checked if a path is readable, potentially allowing access to directories without proper execution permissions. The fixed code adds `Files.isExecutable(path)` to ensure the folder can be traversed and scanned, providing an additional security check. This enhancement prevents potential unauthorized folder access and improves the robustness of the folder scanning mechanism."
38784,"void traverse(BusTerminal terminal,VoltageLevel.TopologyTraverser traverser,Set<Terminal> traversedTerminals){
  Objects.requireNonNull(terminal);
  Objects.requireNonNull(traverser);
  Objects.requireNonNull(traversedTerminals);
  if (traversedTerminals.contains(terminal)) {
    return;
  }
  List<TerminalExt> nextTerminals=new ArrayList<>();
  if (traverser.traverse(terminal,terminal.isConnected())) {
    traversedTerminals.add(terminal);
    addNextTerminals(terminal,nextTerminals);
    int v=getVertex(terminal.getConnectableBusId(),true);
    ConfiguredBus bus=graph.getVertexObject(v);
    bus.getTerminals().stream().filter(t -> t != terminal).filter(t -> traverser.traverse(t,t.isConnected())).forEach(t -> addNextTerminals(t,nextTerminals));
    graph.traverse(v,(v1,e,v2) -> {
      SwitchImpl aSwitch=graph.getEdgeObject(e);
      ConfiguredBus otherBus=graph.getVertexObject(v2);
      if (traverser.traverse(aSwitch)) {
        for (        BusTerminal otherTerminal : otherBus.getTerminals()) {
          if (traverser.traverse(otherTerminal,otherTerminal.isConnected())) {
            traversedTerminals.add(otherTerminal);
            addNextTerminals(otherTerminal,nextTerminals);
            return TraverseResult.CONTINUE;
          }
          return TraverseResult.TERMINATE;
        }
        return TraverseResult.CONTINUE;
      }
      return TraverseResult.TERMINATE;
    }
);
    nextTerminals.forEach(t -> t.traverse(traverser,traversedTerminals));
  }
}","void traverse(BusTerminal terminal,VoltageLevel.TopologyTraverser traverser,Set<Terminal> traversedTerminals){
  Objects.requireNonNull(terminal);
  Objects.requireNonNull(traverser);
  Objects.requireNonNull(traversedTerminals);
  if (traversedTerminals.contains(terminal)) {
    return;
  }
  List<TerminalExt> nextTerminals=new ArrayList<>();
  if (traverser.traverse(terminal,terminal.isConnected())) {
    traversedTerminals.add(terminal);
    addNextTerminals(terminal,nextTerminals);
    int v=getVertex(terminal.getConnectableBusId(),true);
    ConfiguredBus bus=graph.getVertexObject(v);
    bus.getTerminals().stream().filter(t -> t != terminal).filter(t -> traverser.traverse(t,t.isConnected())).forEach(t -> addNextTerminals(t,nextTerminals));
    graph.traverse(v,(v1,e,v2) -> {
      SwitchImpl aSwitch=graph.getEdgeObject(e);
      ConfiguredBus otherBus=graph.getVertexObject(v2);
      if (traverser.traverse(aSwitch)) {
        if (otherBus.getTerminalCount() == 0) {
          return TraverseResult.CONTINUE;
        }
        BusTerminal otherTerminal=otherBus.getTerminals().get(0);
        if (traverser.traverse(otherTerminal,otherTerminal.isConnected())) {
          traversedTerminals.add(otherTerminal);
          addNextTerminals(otherTerminal,nextTerminals);
          return TraverseResult.CONTINUE;
        }
      }
      return TraverseResult.TERMINATE;
    }
);
    nextTerminals.forEach(t -> t.traverse(traverser,traversedTerminals));
  }
}","The original code had a nested loop in the graph traversal that could prematurely terminate or skip valid terminals due to incorrect loop structure and conditional handling. The fixed code replaces the nested loop with a more robust approach by first checking if the bus has terminals and then selecting the first terminal for traversal, ensuring comprehensive and correct graph exploration. This modification prevents potential skipping of terminals and provides a more reliable traversal mechanism that systematically explores connected components."
38785,"private void updateCache(){
  if (states.get().cache != null) {
    return;
  }
  Map<String,MergedBus> mergedBuses=new LinkedHashMap<>();
  Map<ConfiguredBus,MergedBus> mapping=new IdentityHashMap<>();
  boolean[] encountered=new boolean[graph.getMaxVertex()];
  Arrays.fill(encountered,false);
  int busNum=0;
  for (  int v : graph.getVertices()) {
    if (!encountered[v]) {
      final Set<ConfiguredBus> busSet=new LinkedHashSet<>(1);
      busSet.add(graph.getVertexObject(v));
      graph.traverse(v,(v1,e,v2) -> {
        SwitchImpl aSwitch=graph.getEdgeObject(e);
        if (aSwitch.isOpen()) {
          return TraverseResult.TERMINATE;
        }
 else {
          busSet.add(graph.getVertexObject(v2));
          return TraverseResult.CONTINUE;
        }
      }
,encountered);
      if (isBusValid(busSet)) {
        String mergedBusId=BusBreakerVoltageLevel.this.id + ""String_Node_Str"" + busNum++;
        MergedBus mergedBus=new MergedBus(mergedBusId,busSet);
        mergedBuses.put(mergedBus.getId(),mergedBus);
        for (        ConfiguredBus bus : busSet) {
          mapping.put(bus,mergedBus);
        }
      }
    }
  }
  states.get().cache=new BusCache(mergedBuses,mapping);
}","private void updateCache(){
  if (states.get().cache != null) {
    return;
  }
  Map<String,MergedBus> mergedBuses=new LinkedHashMap<>();
  Map<ConfiguredBus,MergedBus> mapping=new IdentityHashMap<>();
  boolean[] encountered=new boolean[graph.getMaxVertex()];
  Arrays.fill(encountered,false);
  int busNum=0;
  for (  int v : graph.getVertices()) {
    if (!encountered[v]) {
      final Set<ConfiguredBus> busSet=new LinkedHashSet<>(1);
      busSet.add(graph.getVertexObject(v));
      graph.traverse(v,(v1,e,v2) -> {
        SwitchImpl aSwitch=graph.getEdgeObject(e);
        if (aSwitch.isOpen()) {
          return TraverseResult.TERMINATE;
        }
 else {
          busSet.add(graph.getVertexObject(v2));
          return TraverseResult.CONTINUE;
        }
      }
,encountered);
      if (isBusValid(busSet)) {
        String mergedBusId=BusBreakerVoltageLevel.this.id + ""String_Node_Str"" + busNum++;
        MergedBus mergedBus=new MergedBus(mergedBusId,busSet);
        mergedBuses.put(mergedBus.getId(),mergedBus);
        busSet.forEach(bus -> mapping.put(bus,mergedBus));
      }
    }
  }
  states.get().cache=new BusCache(mergedBuses,mapping);
}","The original code used a traditional for loop to populate the mapping, which can be error-prone and less readable when iterating over a collection. The fixed code replaces the for loop with a more concise and functional `busSet.forEach()` method, directly mapping each bus to its corresponding merged bus. This change simplifies the code, reduces potential indexing errors, and provides a more idiomatic Java approach to collection iteration."
38786,"private StateImpl(StateImpl other){
}","private StateImpl(){
}","The original copy constructor takes another StateImpl object as a parameter, which is unnecessary and potentially leads to incorrect object initialization. The fixed code removes the parameter, creating a default private constructor that allows controlled object creation within the class. This modification ensures proper encapsulation and prevents unintended external instantiation of the StateImpl class."
38787,"void traverse(BusTerminal terminal,VoltageLevel.TopologyTraverser traverser,Set<Terminal> traversedTerminals){
  Objects.requireNonNull(terminal);
  Objects.requireNonNull(traverser);
  Objects.requireNonNull(traversedTerminals);
  if (traversedTerminals.contains(terminal)) {
    return;
  }
  List<TerminalExt> nextTerminals=new ArrayList<>();
  if (traverser.traverse(terminal,terminal.isConnected())) {
    traversedTerminals.add(terminal);
    addNextTerminals(terminal,nextTerminals);
    int v=getVertex(terminal.getConnectableBusId(),true);
    ConfiguredBus bus=graph.getVertexObject(v);
    for (    BusTerminal otherTerminal : bus.getTerminals()) {
      if (otherTerminal != terminal) {
        if (traverser.traverse(otherTerminal,otherTerminal.isConnected())) {
          addNextTerminals(otherTerminal,nextTerminals);
        }
      }
    }
    graph.traverse(v,(v1,e,v2) -> {
      SwitchImpl aSwitch=graph.getEdgeObject(e);
      ConfiguredBus otherBus=graph.getVertexObject(v2);
      if (traverser.traverse(aSwitch)) {
        for (        BusTerminal otherTerminal : otherBus.getTerminals()) {
          if (traverser.traverse(otherTerminal,otherTerminal.isConnected())) {
            traversedTerminals.add(otherTerminal);
            addNextTerminals(otherTerminal,nextTerminals);
            return TraverseResult.CONTINUE;
          }
 else {
            return TraverseResult.TERMINATE;
          }
        }
        return TraverseResult.CONTINUE;
      }
 else {
        return TraverseResult.TERMINATE;
      }
    }
);
    for (    TerminalExt nextTerminal : nextTerminals) {
      nextTerminal.traverse(traverser,traversedTerminals);
    }
  }
}","void traverse(BusTerminal terminal,VoltageLevel.TopologyTraverser traverser,Set<Terminal> traversedTerminals){
  Objects.requireNonNull(terminal);
  Objects.requireNonNull(traverser);
  Objects.requireNonNull(traversedTerminals);
  if (traversedTerminals.contains(terminal)) {
    return;
  }
  List<TerminalExt> nextTerminals=new ArrayList<>();
  if (traverser.traverse(terminal,terminal.isConnected())) {
    traversedTerminals.add(terminal);
    addNextTerminals(terminal,nextTerminals);
    int v=getVertex(terminal.getConnectableBusId(),true);
    ConfiguredBus bus=graph.getVertexObject(v);
    bus.getTerminals().stream().filter(t -> t != terminal).filter(t -> traverser.traverse(t,t.isConnected())).forEach(t -> addNextTerminals(t,nextTerminals));
    graph.traverse(v,(v1,e,v2) -> {
      SwitchImpl aSwitch=graph.getEdgeObject(e);
      ConfiguredBus otherBus=graph.getVertexObject(v2);
      if (traverser.traverse(aSwitch)) {
        for (        BusTerminal otherTerminal : otherBus.getTerminals()) {
          if (traverser.traverse(otherTerminal,otherTerminal.isConnected())) {
            traversedTerminals.add(otherTerminal);
            addNextTerminals(otherTerminal,nextTerminals);
            return TraverseResult.CONTINUE;
          }
          return TraverseResult.TERMINATE;
        }
        return TraverseResult.CONTINUE;
      }
      return TraverseResult.TERMINATE;
    }
);
    nextTerminals.forEach(t -> t.traverse(traverser,traversedTerminals));
  }
}","The original code had nested loops with potential infinite recursion and inefficient terminal traversal due to complex conditional logic. The fixed code replaces nested loops with stream filtering and forEach methods, simplifying terminal selection and reducing complexity. By using more functional programming techniques, the code becomes more readable, performant, and less prone to unexpected traversal behaviors."
38788,"@Override public StateImpl copy(){
  return new StateImpl(this);
}","@Override public StateImpl copy(){
  return new StateImpl();
}","The original code incorrectly creates a copy by passing the current object to the constructor, which likely leads to unintended object referencing or state duplication. The fixed code creates a new StateImpl instance without parameters, ensuring a clean, independent object is generated during the copy operation. This approach prevents potential side effects and guarantees a truly separate instance with its own memory allocation."
38789,"@Override public void add(){
  if (node1 == null) {
    throw new ValidationException(this,""String_Node_Str"");
  }
  if (node2 == null) {
    throw new ValidationException(this,""String_Node_Str"");
  }
  int e=graph.addEdge(node1,node2,null);
  invalidateCache();
}","@Override public void add(){
  if (node1 == null) {
    throw new ValidationException(this,""String_Node_Str"");
  }
  if (node2 == null) {
    throw new ValidationException(this,""String_Node_Str"");
  }
  graph.addEdge(node1,node2,null);
  invalidateCache();
}","The original code incorrectly stored the return value of `graph.addEdge()` in an unused variable `e`, which serves no purpose and potentially wastes memory. The fixed code removes the unnecessary variable assignment, directly calling `graph.addEdge()` without capturing its return value. This simplifies the code, eliminates potential confusion, and ensures a more efficient and clean implementation of edge addition in the graph."
38790,"private Integer getEdge(String switchId,boolean throwException){
  Integer edge=switches.get(switchId);
  if (throwException && edge == null) {
    throw new PowsyblException(""String_Node_Str"" + switchId + ""String_Node_Str"");
  }
  return edge;
}","private Integer getEdge(String switchId,boolean throwException){
  Integer edge=switches.get(switchId);
  if (throwException && edge == null) {
    throw createSwitchNotFoundException(switchId);
  }
  return edge;
}","The original code directly constructed a generic exception message, which lacks clarity and potential custom error handling for switch not found scenarios. The fixed code introduces a method `createSwitchNotFoundException()` that likely provides a more structured and potentially configurable exception creation mechanism. By delegating exception creation to a separate method, the code becomes more maintainable, allows for centralized error handling, and provides a clearer separation of concerns."
38791,"public void exportTopology(OutputStream os) throws IOException {
  Graph g=new Graph().id(""String_Node_Str"" + NodeBreakerVoltageLevel.this.id + ""String_Node_Str"");
  Map<Integer,Node> intToNode=new HashMap<>();
  Multimap<String,Integer> busToNodes=ArrayListMultimap.create();
  for (int n=0; n < graph.getVertexCount(); n++) {
    Node node=new Node().id(Integer.toString(n));
    intToNode.put(n,node);
    Bus bus=getCalculatedBusBreakerTopology().getBus(n);
    if (bus != null) {
      busToNodes.put(bus.getId(),n);
    }
 else {
      TerminalExt terminal=graph.getVertexObject(n);
      if (terminal != null) {
        AbstractConnectable connectable=terminal.getConnectable();
        String label=n + ""String_Node_Str"" + connectable.getType().toString()+ ""String_Node_Str""+ connectable.getId();
        node.attr(""String_Node_Str"",label);
        g.node(node);
      }
    }
  }
  String[] colors=Colors.generateColorScale(busToNodes.asMap().keySet().size());
  int i=0;
  for (  String key : busToNodes.asMap().keySet()) {
    Graph newBus=new Graph().id(""String_Node_Str"" + key + ""String_Node_Str"");
    newBus.attr(""String_Node_Str"",key);
    for (    int nodeInt : busToNodes.get(key)) {
      Node node=intToNode.get(nodeInt);
      TerminalExt terminal=graph.getVertexObject(nodeInt);
      if (terminal != null) {
        AbstractConnectable connectable=terminal.getConnectable();
        String label=nodeInt + ""String_Node_Str"" + connectable.getType().toString()+ ""String_Node_Str""+ connectable.getId();
        node.attr(""String_Node_Str"",label);
      }
      node.attr(""String_Node_Str"",""String_Node_Str"").attr(""String_Node_Str"",colors[i]);
      newBus.node(node);
    }
    g.subGraph(newBus);
    i++;
  }
  boolean drawSwitchId=true;
  for (int e=0; e < graph.getEdgeCount(); e++) {
    Edge edge=new Edge(intToNode.get(graph.getEdgeVertex1(e)),intToNode.get(graph.getEdgeVertex2(e))).id(Integer.toString(e));
    SwitchImpl aSwitch=graph.getEdgeObject(e);
    if (aSwitch != null) {
      if (drawSwitchId) {
        edge.attr(""String_Node_Str"",aSwitch.getKind().toString() + ""String_Node_Str"" + aSwitch.getId()).attr(""String_Node_Str"",""String_Node_Str"");
      }
      edge.attr(""String_Node_Str"",aSwitch.isOpen() ? ""String_Node_Str"" : ""String_Node_Str"");
    }
    g.edge(edge);
  }
  g.writeTo(os);
}","public void exportTopology(OutputStream os){
  Graph g=new Graph().id(""String_Node_Str"" + NodeBreakerVoltageLevel.this.id + ""String_Node_Str"");
  Map<Integer,Node> intToNode=new HashMap<>();
  Multimap<String,Integer> busToNodes=ArrayListMultimap.create();
  for (int n=0; n < graph.getVertexCount(); n++) {
    Node node=new Node().id(Integer.toString(n));
    intToNode.put(n,node);
    Bus bus=getCalculatedBusBreakerTopology().getBus(n);
    if (bus != null) {
      busToNodes.put(bus.getId(),n);
    }
 else {
      TerminalExt terminal=graph.getVertexObject(n);
      if (terminal != null) {
        AbstractConnectable connectable=terminal.getConnectable();
        String label=n + ""String_Node_Str"" + connectable.getType().toString()+ ""String_Node_Str""+ connectable.getId();
        node.attr(LABEL_ATTRIBUTE,label);
        g.node(node);
      }
    }
  }
  exportBuses(g,busToNodes,intToNode);
  exportEdges(g,intToNode);
  g.writeTo(os);
}","The original code was overly complex, with nested logic and repeated code blocks making it difficult to read and maintain. The fixed code refactors the implementation by extracting bus and edge export logic into separate methods (exportBuses and exportEdges), improving code modularity and readability. This approach simplifies the method structure, reduces cognitive complexity, and makes the code more maintainable and easier to understand."
38792,"public DependencyCache(ProjectFile projectFile,String dependencyName,Class<T> dependencyClass){
  this.projectFile=Objects.requireNonNull(projectFile);
  this.dependencyName=Objects.requireNonNull(dependencyName);
  this.dependencyClass=Objects.requireNonNull(dependencyClass);
  projectFile.addListener(new DefaultProjectFileListener(){
    @Override public void dependencyChanged(    String name){
      if (dependencyName.equals(name)) {
        invalidate();
      }
    }
  }
);
}","public DependencyCache(ProjectFile projectFile,String dependencyName,Class<T> dependencyClass){
  this.projectFile=Objects.requireNonNull(projectFile);
  this.dependencyName=Objects.requireNonNull(dependencyName);
  this.dependencyClass=Objects.requireNonNull(dependencyClass);
  projectFile.addListener(l);
}","The original code creates an anonymous inner class listener directly within the constructor, which can lead to potential memory leaks and unnecessary object creation. The fixed code suggests moving the listener to a separate field or method, reducing inline complexity and improving memory management. By extracting the listener logic, the code becomes more modular, easier to maintain, and prevents potential anonymous class-related performance overhead."
38793,"protected ProjectFile(ProjectFileCreationContext context,int codeVersion,FileIcon icon){
  super(context,codeVersion,true);
  this.icon=Objects.requireNonNull(icon);
  storage.addListener(this,eventList -> {
    for (    NodeEvent event : eventList.getEvents()) {
      if (event.getId().equals(getId())) {
switch (event.getType()) {
case DEPENDENCY_ADDED:
case DEPENDENCY_REMOVED:
          listeners.notify(listener -> listener.dependencyChanged(((DependencyEvent)event).getDependencyName()));
        break;
case BACKWARD_DEPENDENCY_ADDED:
case BACKWARD_DEPENDENCY_REMOVED:
      listeners.notify(listener -> listener.backwardDependencyChanged(((DependencyEvent)event).getDependencyName()));
    break;
default :
  break;
}
}
}
}
);
}","protected ProjectFile(ProjectFileCreationContext context,int codeVersion,FileIcon icon){
  super(context,codeVersion,true);
  this.icon=Objects.requireNonNull(icon);
  storage.addListener(l);
}","The original code contains a complex, nested event handling mechanism with multiple switch cases that could lead to potential performance and readability issues. The fixed code simplifies the event listener by replacing the intricate lambda with a direct listener reference 'l', which likely handles events more efficiently and cleanly. This refactoring reduces code complexity, improves maintainability, and potentially eliminates unnecessary event processing logic."
38794,"public void removeListener(ProjectFileListener listener){
  listeners.remove(this,listener);
}","public void removeListener(ProjectFileListener listener){
  listeners.remove(listener);
}","The original code incorrectly uses `this` as the first argument when calling `remove()`, which is likely not the intended method signature for the listener collection. The fixed code removes `listener` directly, using the correct method to remove a specific listener from the collection. This correction ensures that the intended listener is properly unregistered, preventing potential memory leaks or unexpected behavior in event handling."
38795,"public void addListener(ProjectFileListener listener){
  listeners.add(this,listener);
}","public void addListener(ProjectFileListener listener){
  listeners.add(listener);
}","The original code incorrectly passes `this` as an unnecessary first argument when adding a listener to the collection. The fixed code removes `this` and directly adds the listener, which is the correct method signature for most listener registration mechanisms. This simplification ensures proper listener management and prevents potential runtime errors or unexpected behavior when registering event listeners."
38796,"public void removeAllListeners(){
  listeners.removeAll(this);
}","public void removeAllListeners(){
  listeners.removeAll();
}","The original code incorrectly passes `this` as an argument to `removeAll()`, which is not a valid method for removing all listeners from a collection. The fixed code uses `removeAll()` without arguments, which correctly clears all elements from the `listeners` collection. This correction ensures a clean and proper removal of all listeners, preventing potential runtime errors and improving the method's reliability."
38797,"public void removeListener(ProjectFolderListener listener){
  listeners.remove(this,listener);
}","public void removeListener(ProjectFolderListener listener){
  listeners.remove(listener);
}","The original code incorrectly passes `this` as the first argument to the `remove()` method, which is likely not the intended behavior for removing a listener. The fixed code removes the listener directly by passing only the listener object, which is the correct way to remove a specific listener from the collection. This correction ensures that the intended listener is properly unregistered without introducing unnecessary complexity or potential errors in listener management."
38798,"public ProjectFolder(ProjectFileCreationContext context){
  super(context,VERSION,true);
  storage.addListener(this,eventList -> {
    for (    NodeEvent event : eventList.getEvents()) {
switch (event.getType()) {
case NODE_CREATED:
        if (getId().equals(((NodeCreated)event).getParentId())) {
          listeners.notify(listener -> listener.childAdded(event.getId()));
        }
      break;
case NODE_REMOVED:
    if (getId().equals(((NodeRemoved)event).getParentId())) {
      listeners.notify(listener -> listener.childRemoved(event.getId()));
    }
  break;
default :
break;
}
}
}
);
}","public ProjectFolder(ProjectFileCreationContext context){
  super(context,VERSION,true);
  storage.addListener(l);
}","The original code contained a complex event listener with nested switch statements and multiple event handling logic, which could lead to performance overhead and potential memory leaks. The fixed code simplifies the listener registration by directly passing a more streamlined listener (represented by 'l') to the storage, removing the verbose event processing. This refactoring reduces complexity, improves code readability, and likely optimizes event handling by eliminating redundant event type checks and nested conditional logic."
38799,"public void addListener(ProjectFolderListener listener){
  listeners.add(this,listener);
}","public void addListener(ProjectFolderListener listener){
  listeners.add(listener);
}","The original code incorrectly passes `this` as the first argument to the `add` method, which is likely a method signature error. The fixed code removes the unnecessary `this` parameter, directly adding the listener to the collection using the correct method signature. This correction ensures proper listener registration without superfluous arguments, improving the code's clarity and preventing potential runtime errors."
38800,"@Test public void baseTest() throws IOException {
  assertSame(afs,ad.getFileSystem(""String_Node_Str""));
  assertNull(ad.getFileSystem(""String_Node_Str""));
  assertEquals(Collections.singletonList(""String_Node_Str""),ad.getRemotelyAccessibleFileSystemNames());
  assertNotNull(ad.getRemotelyAccessibleStorage(""String_Node_Str""));
  assertEquals(""String_Node_Str"",afs.getName());
  assertEquals(1,ad.getProjectFileClasses().size());
  Folder root=afs.getRootFolder();
  assertNotNull(root);
  Folder dir1=root.createFolder(""String_Node_Str"");
  assertNotNull(dir1);
  dir1.createFolder(""String_Node_Str"");
  dir1.createFolder(""String_Node_Str"");
  dir1=root.getFolder(""String_Node_Str"").orElse(null);
  assertNotNull(dir1);
  assertTrue(dir1.isFolder());
  assertTrue(dir1.isWritable());
  assertEquals(""String_Node_Str"",dir1.getName());
  assertNotNull(dir1.getCreationDate());
  assertNotNull(dir1.getModificationDate());
  assertEquals(0,dir1.getVersion());
  assertFalse(dir1.isAheadOfVersion());
  assertEquals(dir1.getName(),dir1.toString());
  assertEquals(""String_Node_Str"",dir1.getParent().orElseThrow(AssertionError::new).getName());
  Folder dir2=dir1.getFolder(""String_Node_Str"").orElse(null);
  assertNotNull(dir2);
  assertNotNull(dir2.getParent());
  assertEquals(""String_Node_Str"",dir2.getParent().orElseThrow(AssertionError::new).getPath().toString());
  assertEquals(2,dir1.getChildren().size());
  Folder dir3=root.getFolder(""String_Node_Str"").orElse(null);
  assertNull(dir3);
  String str=dir2.getPath().toString();
  assertEquals(""String_Node_Str"",str);
  Folder mayBeDir2=afs.getRootFolder().getFolder(""String_Node_Str"").orElse(null);
  assertNotNull(mayBeDir2);
  assertEquals(""String_Node_Str"",mayBeDir2.getName());
  Folder mayBeDir2otherWay=afs.getRootFolder().getChild(Folder.class,""String_Node_Str"",""String_Node_Str"").orElse(null);
  assertNotNull(mayBeDir2otherWay);
  assertEquals(""String_Node_Str"",mayBeDir2otherWay.getName());
  Project project1=dir2.createProject(""String_Node_Str"");
  project1.setDescription(""String_Node_Str"");
  assertNotNull(project1);
  assertEquals(""String_Node_Str"",project1.getName());
  assertEquals(""String_Node_Str"",project1.getDescription());
  assertNotNull(project1.getIcon());
  assertNotNull(project1.getParent());
  assertEquals(""String_Node_Str"",project1.getParent().orElseThrow(AssertionError::new).getPath().toString());
  assertTrue(project1.getRootFolder().getChildren().isEmpty());
  assertTrue(project1.getFileSystem() == afs);
  List<String> added=new ArrayList<>();
  List<String> removed=new ArrayList<>();
  project1.getRootFolder().addListener(new ProjectFolderListener(){
    @Override public void childAdded(    String nodeId){
      added.add(nodeId);
    }
    @Override public void childRemoved(    String nodeId){
      removed.add(nodeId);
    }
  }
);
  ProjectFolder dir4=project1.getRootFolder().createFolder(""String_Node_Str"");
  assertTrue(dir4.isFolder());
  assertEquals(""String_Node_Str"",dir4.getName());
  assertNotNull(dir4.getParent());
  assertTrue(dir4.getChildren().isEmpty());
  assertEquals(1,project1.getRootFolder().getChildren().size());
  dir4.delete();
  assertTrue(project1.getRootFolder().getChildren().isEmpty());
  try {
    dir4.getChildren();
    fail();
  }
 catch (  Exception ignored) {
  }
  ProjectFolder dir5=project1.getRootFolder().createFolder(""String_Node_Str"");
  ProjectFolder dir6=dir5.createFolder(""String_Node_Str"");
  assertEquals(ImmutableList.of(""String_Node_Str"",""String_Node_Str""),dir6.getPath().toList().subList(1,3));
  assertEquals(""String_Node_Str"",dir6.getPath().toString());
  assertEquals(""String_Node_Str"",project1.getRootFolder().getChild(""String_Node_Str"").orElseThrow(AssertionError::new).getName());
  assertEquals(Arrays.asList(dir4.getId(),dir5.getId()),added);
  assertEquals(Collections.singletonList(dir4.getId()),removed);
}","@Test public void baseTest() throws IOException {
  assertSame(afs,ad.getFileSystem(""String_Node_Str""));
  assertNull(ad.getFileSystem(""String_Node_Str""));
  assertEquals(Collections.singletonList(""String_Node_Str""),ad.getRemotelyAccessibleFileSystemNames());
  assertNotNull(ad.getRemotelyAccessibleStorage(""String_Node_Str""));
  assertEquals(""String_Node_Str"",afs.getName());
  assertEquals(1,ad.getProjectFileClasses().size());
  Folder root=afs.getRootFolder();
  assertNotNull(root);
  Folder dir1=root.createFolder(""String_Node_Str"");
  assertNotNull(dir1);
  dir1.createFolder(""String_Node_Str"");
  dir1.createFolder(""String_Node_Str"");
  dir1=root.getFolder(""String_Node_Str"").orElse(null);
  assertNotNull(dir1);
  assertTrue(dir1.isFolder());
  assertTrue(dir1.isWritable());
  assertEquals(""String_Node_Str"",dir1.getName());
  assertNotNull(dir1.getCreationDate());
  assertNotNull(dir1.getModificationDate());
  assertEquals(0,dir1.getVersion());
  assertFalse(dir1.isAheadOfVersion());
  assertEquals(dir1.getName(),dir1.toString());
  assertEquals(""String_Node_Str"",dir1.getParent().orElseThrow(AssertionError::new).getName());
  Folder dir2=dir1.getFolder(""String_Node_Str"").orElse(null);
  assertNotNull(dir2);
  assertNotNull(dir2.getParent());
  assertEquals(""String_Node_Str"",dir2.getParent().orElseThrow(AssertionError::new).getPath().toString());
  assertEquals(2,dir1.getChildren().size());
  Folder dir3=root.getFolder(""String_Node_Str"").orElse(null);
  assertNull(dir3);
  String str=dir2.getPath().toString();
  assertEquals(""String_Node_Str"",str);
  Folder mayBeDir2=afs.getRootFolder().getFolder(""String_Node_Str"").orElse(null);
  assertNotNull(mayBeDir2);
  assertEquals(""String_Node_Str"",mayBeDir2.getName());
  Folder mayBeDir2otherWay=afs.getRootFolder().getChild(Folder.class,""String_Node_Str"",""String_Node_Str"").orElse(null);
  assertNotNull(mayBeDir2otherWay);
  assertEquals(""String_Node_Str"",mayBeDir2otherWay.getName());
  Project project1=dir2.createProject(""String_Node_Str"");
  project1.setDescription(""String_Node_Str"");
  assertNotNull(project1);
  assertEquals(""String_Node_Str"",project1.getName());
  assertEquals(""String_Node_Str"",project1.getDescription());
  assertNotNull(project1.getIcon());
  assertNotNull(project1.getParent());
  assertEquals(""String_Node_Str"",project1.getParent().orElseThrow(AssertionError::new).getPath().toString());
  assertTrue(project1.getRootFolder().getChildren().isEmpty());
  assertTrue(project1.getFileSystem() == afs);
  List<String> added=new ArrayList<>();
  List<String> removed=new ArrayList<>();
  ProjectFolderListener l=new ProjectFolderListener(){
    @Override public void childAdded(    String nodeId){
      added.add(nodeId);
    }
    @Override public void childRemoved(    String nodeId){
      removed.add(nodeId);
    }
  }
;
  project1.getRootFolder().addListener(l);
  ProjectFolder dir4=project1.getRootFolder().createFolder(""String_Node_Str"");
  assertTrue(dir4.isFolder());
  assertEquals(""String_Node_Str"",dir4.getName());
  assertNotNull(dir4.getParent());
  assertTrue(dir4.getChildren().isEmpty());
  assertEquals(1,project1.getRootFolder().getChildren().size());
  dir4.delete();
  assertTrue(project1.getRootFolder().getChildren().isEmpty());
  try {
    dir4.getChildren();
    fail();
  }
 catch (  Exception ignored) {
  }
  ProjectFolder dir5=project1.getRootFolder().createFolder(""String_Node_Str"");
  ProjectFolder dir6=dir5.createFolder(""String_Node_Str"");
  assertEquals(ImmutableList.of(""String_Node_Str"",""String_Node_Str""),dir6.getPath().toList().subList(1,3));
  assertEquals(""String_Node_Str"",dir6.getPath().toString());
  assertEquals(""String_Node_Str"",project1.getRootFolder().getChild(""String_Node_Str"").orElseThrow(AssertionError::new).getName());
  assertEquals(Arrays.asList(dir4.getId(),dir5.getId()),added);
  assertEquals(Collections.singletonList(dir4.getId()),removed);
}","The original code directly defined the ProjectFolderListener within the method call to addListener(), which could potentially cause scope and lifecycle issues. In the fixed code, the listener is first assigned to a variable `l` before being added, ensuring proper declaration and potential reuse. This modification improves code readability, maintains better listener management, and provides more explicit control over the listener's lifecycle and potential future references."
38801,"public AbstractModificationScript(ProjectFileCreationContext context,int codeVersion,FileIcon icon,String scriptContentName){
  super(context,codeVersion,icon);
  this.scriptContentName=Objects.requireNonNull(scriptContentName);
  storage.addListener(this,eventList -> processEvents(eventList.getEvents(),info.getId(),listeners));
}","public AbstractModificationScript(ProjectFileCreationContext context,int codeVersion,FileIcon icon,String scriptContentName){
  super(context,codeVersion,icon);
  this.scriptContentName=Objects.requireNonNull(scriptContentName);
  storage.addListener(l);
}","The original code incorrectly uses a lambda expression with unnecessary parameters, potentially causing event processing complexity and potential null pointer risks. The fixed code simplifies the listener registration by directly passing a listener reference 'l', removing the complex lambda and streamlining event handling logic. This modification reduces code complexity, improves readability, and minimizes potential runtime errors associated with overly complicated event listener registration."
38802,"@Override public void removeListeners(Object target){
  listeners.removeAll(target);
}","@Override public void removeListeners(){
  listeners.removeAll();
}","The original code incorrectly passes an object as an argument to removeAll(), which is not a standard method for most collection removal operations. The fixed code removes the unnecessary parameter and uses removeAll() without arguments, likely clearing the entire listeners collection. This correction simplifies the method, ensures complete listener removal, and prevents potential type-related errors in the original implementation."
38803,"@Override public void flush(){
  super.flush();
  lock.lock();
  try {
    listeners.notify(l -> l.onEvents(eventList));
    eventList=new NodeEventList();
  }
  finally {
    lock.unlock();
  }
}","@Override public void flush(){
  super.flush();
  lock.lock();
  try {
    listeners.log();
    listeners.notify(l -> l.onEvents(eventList));
    eventList=new NodeEventList();
  }
  finally {
    lock.unlock();
  }
}","The original code lacks a logging mechanism before notifying listeners, potentially missing critical event tracking or error detection. The fixed code adds `listeners.log()` before notification, ensuring comprehensive event logging and providing a trace of events before they are dispatched. This modification enhances system observability and diagnostic capabilities by capturing event details before listener notification."
38804,"@Override public void addListener(Object target,AppStorageListener l){
  listeners.add(target,l);
}","@Override public void addListener(AppStorageListener l){
  listeners.add(l);
}","The original code incorrectly added a listener with an unnecessary target parameter, potentially causing confusion and complicating the listener registration process. The fixed code removes the target parameter, simplifying the method signature to directly add the listener to the collection using a cleaner, more straightforward approach. This modification enhances code readability, reduces potential errors, and provides a more intuitive way to register listeners."
38805,void removeListeners(Object target);,void removeListeners();,"The original method signature incorrectly assumes removing listeners requires a target object parameter, which introduces unnecessary complexity and potential runtime errors. By removing the target parameter, the fixed method simplifies listener removal, allowing a more generic and flexible approach to event listener management. This modification promotes cleaner code design, reduces potential parameter-related bugs, and provides a more straightforward mechanism for listener cleanup."
38806,"void addListener(Object target,AppStorageListener l);",void addListener(AppStorageListener l);,"The original method signature incorrectly requires an unnecessary `Object target` parameter, which adds complexity and reduces the listener's flexibility. The fixed code removes the target parameter, allowing the `addListener` method to directly accept an `AppStorageListener` without additional coupling. This simplification improves the method's design by creating a more focused and straightforward mechanism for registering listeners."
38807,"@Before public void setUp() throws Exception {
  eventStack=new LinkedBlockingQueue<>();
  AppStorage storage=createStorage();
  if (storage instanceof ListenableAppStorage) {
    this.storage=(ListenableAppStorage)storage;
  }
 else {
    this.storage=new DefaultListenableAppStorage(storage);
  }
  this.storage.addListener(this,eventList -> eventStack.addAll(eventList.getEvents()));
}","@Before public void setUp() throws Exception {
  eventStack=new LinkedBlockingQueue<>();
  AppStorage storage=createStorage();
  if (storage instanceof ListenableAppStorage) {
    this.storage=(ListenableAppStorage)storage;
  }
 else {
    this.storage=new DefaultListenableAppStorage(storage);
  }
  this.storage.addListener(l);
}","The original code incorrectly adds all events from an event list directly to the eventStack using a lambda expression, which is not the intended method signature for addListener. The fixed code removes the lambda and uses a proper listener reference 'l', which correctly registers the listener with the storage mechanism. This change ensures proper event handling and adheres to the expected listener registration pattern, preventing potential runtime errors and improving code reliability."
38808,"@Before public void setUp(){
  AppStorage storage=Mockito.mock(AppStorage.class);
  Mockito.when(storage.createNode(Mockito.anyString(),Mockito.anyString(),Mockito.anyString(),Mockito.anyString(),Mockito.anyInt(),Mockito.any(NodeGenericMetadata.class))).thenReturn(new NodeInfo(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,0,0,new NodeGenericMetadata()));
  Mockito.when(storage.deleteNode(""String_Node_Str"")).thenReturn(""String_Node_Str"");
  Mockito.when(storage.writeBinaryData(Mockito.anyString(),Mockito.anyString())).thenReturn(new ByteArrayOutputStream());
  listenableStorage=new DefaultListenableAppStorage(storage);
  listenableStorage.addListener(this,eventList -> lastEventList=eventList);
}","@Before public void setUp(){
  AppStorage storage=Mockito.mock(AppStorage.class);
  Mockito.when(storage.createNode(Mockito.anyString(),Mockito.anyString(),Mockito.anyString(),Mockito.anyString(),Mockito.anyInt(),Mockito.any(NodeGenericMetadata.class))).thenReturn(new NodeInfo(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,0,0,new NodeGenericMetadata()));
  Mockito.when(storage.deleteNode(""String_Node_Str"")).thenReturn(""String_Node_Str"");
  Mockito.when(storage.writeBinaryData(Mockito.anyString(),Mockito.anyString())).thenReturn(new ByteArrayOutputStream());
  listenableStorage=new DefaultListenableAppStorage(storage);
  listenableStorage.addListener(l);
}","The original code incorrectly passes `this` as the listener, which may lead to unexpected behavior or potential memory leaks. The fixed code introduces a new parameter `l`, which provides a cleaner and more controlled way of adding a listener to the `listenableStorage`. By using a specific listener object, the code improves type safety, reduces potential side effects, and ensures more predictable event handling in the application."
38809,"@After public void tearDown(){
  listenableStorage.removeListeners(this);
}","@After public void tearDown(){
  listenableStorage.removeListeners();
}","The original code incorrectly passes `this` as an argument to `removeListeners()`, which may not be the intended method signature or could lead to unexpected behavior. The fixed code removes the unnecessary parameter, calling `removeListeners()` directly, which suggests the method is designed to remove all listeners without requiring a specific context. This correction simplifies the teardown process and ensures a clean, generic removal of listeners across the storage object."
38810,"private UUID deleteNode(UUID nodeUuid){
  checkNodeExists(nodeUuid);
  if (nodeUuid.toString().equals(rootNodeVar.get().getId())) {
    throw new AfsStorageException(""String_Node_Str"");
  }
  for (  UUID childNodeUuid : childNodesMap.get(nodeUuid)) {
    deleteNode(childNodeUuid);
  }
  NodeInfo nodeInfo=nodeInfoMap.remove(nodeUuid);
  for (  String dataName : dataNamesMap.get(nodeUuid)) {
    dataMap.remove(new NamedLink(nodeUuid,dataName));
  }
  dataNamesMap.remove(nodeUuid);
  childNodesMap.remove(nodeUuid);
  UUID parentNodeUuid=parentNodeMap.remove(nodeUuid);
  removeFromList(childNodesMap,parentNodeUuid,nodeUuid);
  childNodeMap.remove(new NamedLink(parentNodeUuid,nodeInfo.getName()));
  for (  NamedLink link : dependencyNodesMap.get(nodeUuid)) {
    dependencyNodesByNameMap.remove(new NamedLink(nodeUuid,link.getName()));
    removeFromList(backwardDependencyNodesMap,link.getNodeUuid(),nodeUuid);
  }
  dependencyNodesMap.remove(nodeUuid);
  return parentNodeUuid;
}","private UUID deleteNode(UUID nodeUuid){
  checkNodeExists(nodeUuid);
  if (nodeUuid.toString().equals(rootNodeVar.get().getId())) {
    throw new AfsStorageException(""String_Node_Str"");
  }
  for (  UUID childNodeUuid : childNodesMap.get(nodeUuid)) {
    deleteNode(childNodeUuid);
  }
  NodeInfo nodeInfo=nodeInfoMap.remove(nodeUuid);
  for (  String dataName : dataNamesMap.get(nodeUuid)) {
    dataMap.remove(new NamedLink(nodeUuid,dataName));
  }
  dataNamesMap.remove(nodeUuid);
  childNodesMap.remove(nodeUuid);
  UUID parentNodeUuid=parentNodeMap.remove(nodeUuid);
  removeFromList(childNodesMap,parentNodeUuid,nodeUuid);
  childNodeMap.remove(new NamedLink(parentNodeUuid,nodeInfo.getName()));
  for (  UUID otherNodeUuid : backwardDependencyNodesMap.get(nodeUuid)) {
    List<NamedLink> linksToRemove=new ArrayList<>();
    for (    NamedLink link : dependencyNodesMap.get(otherNodeUuid)) {
      if (link.getNodeUuid().equals(nodeUuid)) {
        linksToRemove.add(link);
      }
    }
    for (    NamedLink linkToRemove : linksToRemove) {
      removeFromList(dependencyNodesMap,otherNodeUuid,linkToRemove);
      dependencyNodesByNameMap.remove(new NamedLink(otherNodeUuid,linkToRemove.getName()));
    }
  }
  for (  NamedLink link : dependencyNodesMap.get(nodeUuid)) {
    dependencyNodesByNameMap.remove(new NamedLink(nodeUuid,link.getName()));
    removeFromList(backwardDependencyNodesMap,link.getNodeUuid(),nodeUuid);
  }
  dependencyNodesMap.remove(nodeUuid);
  return parentNodeUuid;
}",The original code incorrectly handled dependency node removal by directly iterating and removing links without considering potential concurrent modification issues. The fixed code introduces a separate list for tracking links to remove and performs safe removal by first collecting links to delete and then systematically removing them from dependency and backward dependency maps. This approach prevents potential concurrent modification exceptions and ensures a more robust and predictable node deletion process.
38811,"@Test public void parentChangeTest() throws IOException, InterruptedException {
  NodeInfo rootFolderInfo=storage.createRootNodeIfNotExists(storage.getFileSystemName(),FOLDER_PSEUDO_CLASS);
  NodeInfo folder1Info=storage.createNode(rootFolderInfo.getId(),""String_Node_Str"",FOLDER_PSEUDO_CLASS,""String_Node_Str"",0,new NodeGenericMetadata());
  NodeInfo folder2Info=storage.createNode(rootFolderInfo.getId(),""String_Node_Str"",FOLDER_PSEUDO_CLASS,""String_Node_Str"",0,new NodeGenericMetadata());
  storage.flush();
  eventStack.take();
  eventStack.take();
  eventStack.take();
  NodeInfo fileInfo=storage.createNode(folder1Info.getId(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,new NodeGenericMetadata());
  storage.flush();
  eventStack.take();
  assertEquals(folder1Info,storage.getParentNode(fileInfo.getId()).orElseThrow(AssertionError::new));
  storage.setParentNode(fileInfo.getId(),folder2Info.getId());
  storage.flush();
  assertEquals(new ParentChanged(fileInfo.getId()),eventStack.take());
  assertEquals(folder2Info,storage.getParentNode(fileInfo.getId()).orElseThrow(AssertionError::new));
  assertTrue(eventStack.isEmpty());
}","@Test public void parentChangeTest() throws InterruptedException {
  NodeInfo rootFolderInfo=storage.createRootNodeIfNotExists(storage.getFileSystemName(),FOLDER_PSEUDO_CLASS);
  NodeInfo folder1Info=storage.createNode(rootFolderInfo.getId(),""String_Node_Str"",FOLDER_PSEUDO_CLASS,""String_Node_Str"",0,new NodeGenericMetadata());
  NodeInfo folder2Info=storage.createNode(rootFolderInfo.getId(),""String_Node_Str"",FOLDER_PSEUDO_CLASS,""String_Node_Str"",0,new NodeGenericMetadata());
  storage.flush();
  eventStack.take();
  eventStack.take();
  eventStack.take();
  NodeInfo fileInfo=storage.createNode(folder1Info.getId(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,new NodeGenericMetadata());
  storage.flush();
  eventStack.take();
  assertEquals(folder1Info,storage.getParentNode(fileInfo.getId()).orElseThrow(AssertionError::new));
  storage.setParentNode(fileInfo.getId(),folder2Info.getId());
  storage.flush();
  assertEquals(new ParentChanged(fileInfo.getId()),eventStack.take());
  assertEquals(folder2Info,storage.getParentNode(fileInfo.getId()).orElseThrow(AssertionError::new));
  assertTrue(eventStack.isEmpty());
}","The original code included an unnecessary `IOException` in the method signature, which was not being used or thrown within the test method. The fixed code removes this exception, simplifying the method signature and eliminating potential confusion about error handling. By removing the unused exception, the code becomes cleaner, more focused, and reduces potential misunderstandings about the test method's error handling capabilities."
38812,"@After public void tearDown() throws Exception {
  storage.close();
}","@After public void tearDown(){
  storage.close();
}","The original code incorrectly declares a throws Exception clause in the tearDown() method, which is unnecessary for the storage.close() operation. The fixed code removes the throws Exception, simplifying the method signature and eliminating potential redundant exception handling. By removing the unnecessary exception declaration, the code becomes cleaner, more concise, and maintains the same functional behavior of closing the storage resource."
38813,"private AtomicInteger getRuleMatchCountInternal(String ruleId){
  AtomicInteger count=rulesMatchCount.get(ruleId);
  if (count == null) {
    count=new AtomicInteger();
    rulesMatchCount.put(ruleId,count);
  }
  return count;
}","private AtomicInteger getRuleMatchCountInternal(String ruleId){
  return rulesMatchCount.computeIfAbsent(ruleId,k -> new AtomicInteger());
}","The original code is not thread-safe when initializing the AtomicInteger, potentially creating multiple instances of the counter for the same rule. The fixed code uses `computeIfAbsent()`, which atomically checks if the key exists and creates a new AtomicInteger only if it's missing, ensuring thread-safe initialization. This approach simplifies the code, eliminates race conditions, and provides a more concise and robust method for managing rule match counts."
38814,"private ModifiedNetwork loadNetworkFromVirtualCase(VirtualCase virtualCase){
  ProjectCase baseCase=virtualCase.getCase().orElseThrow(() -> new AfsException(""String_Node_Str""));
  ModifiedNetwork modifiedNetwork=loadNetworkFromProjectCase(baseCase);
  if (modifiedNetwork.getScriptError() != null) {
    return modifiedNetwork;
  }
  ModificationScript script=virtualCase.getScript().orElseThrow(VirtualCase::createScriptLinkIsDeadException);
  LOGGER.info(""String_Node_Str"" + virtualCase.getId());
  return applyScript(modifiedNetwork.getNetwork(),modifiedNetwork.getScriptOutput(),script);
}","private ModifiedNetwork loadNetworkFromVirtualCase(VirtualCase virtualCase){
  ProjectCase baseCase=virtualCase.getCase().orElseThrow(() -> new AfsException(""String_Node_Str""));
  ModifiedNetwork modifiedNetwork=loadNetworkFromProjectCase(baseCase);
  if (modifiedNetwork.getScriptError() != null) {
    return modifiedNetwork;
  }
  ModificationScript script=virtualCase.getScript().orElseThrow(VirtualCase::createScriptLinkIsDeadException);
  LOGGER.info(""String_Node_Str"",virtualCase.getId());
  return applyScript(modifiedNetwork.getNetwork(),modifiedNetwork.getScriptOutput(),script);
}","The original code incorrectly concatenated the log message using the ""+"" operator, which can lead to inefficient string building and potential performance overhead. The fixed code uses the correct SLF4J logging method with a parameterized format, replacing string concatenation with a more efficient logging approach. This change improves logging performance, reduces memory allocation, and provides a cleaner, more standard way of logging messages with variable parameters."
38815,@Deprecated Integer getOptionalIntProperty(String name);,"/** 
 * @deprecated Use getOptionalIntegerProperty(String) instead.
 */
@Deprecated Integer getOptionalIntProperty(String name);","The original code lacks a clear explanation for its deprecation, making it unclear why the method is marked as deprecated. The fixed code adds a Javadoc comment specifying the recommended alternative method, providing developers with guidance on how to replace the deprecated functionality. This improvement enhances code maintainability by explicitly directing developers to use the new `getOptionalIntegerProperty(String)` method instead of the deprecated one."
38816,@Deprecated Boolean getOptinalBooleanProperty(String name);,"/** 
 * @deprecated Use getOptionalBooleanProperty(String) instead.
 */
@Deprecated Boolean getOptinalBooleanProperty(String name);","The original code lacks a clear deprecation explanation, making it difficult for developers to understand why the method is deprecated and what alternative to use. The fixed code adds a Javadoc comment that explicitly recommends using `getOptionalBooleanProperty(String)` instead, providing clear guidance for method replacement. This improvement helps developers quickly understand the deprecation reason and smoothly migrate to the recommended method."
38817,"GzMemDataSource(String fileName,InputStream content){
  super(DataSourceUtil.getBaseName(fileName));
  String zipped=fileName.substring(0,fileName.lastIndexOf(""String_Node_Str""));
  putData(zipped,content);
}","GzMemDataSource(String fileName,InputStream content){
  super(DataSourceUtil.getBaseName(fileName));
  String zipped=fileName.substring(0,fileName.lastIndexOf('.'));
  putData(zipped,content);
}","The original code uses a hardcoded string ""String_Node_Str"" to substring the filename, which would cause errors with different file names. The fixed code uses fileName.lastIndexOf('.') to correctly find the last occurrence of the file extension separator, enabling proper base name extraction for any file. This modification makes the code more robust and universally applicable across different file naming conventions."
38818,"public String anonymize(String str){
  if (str == null) {
    return null;
  }
  String str2=mapping.get(str);
  if (str2 == null) {
    str2=getAlpha(mapping.size() + 1);
    mapping.put(str,str2);
  }
  return str2;
}","public String anonymize(String str){
  if (str == null) {
    return null;
  }
  return mapping.computeIfAbsent(str,k -> getAlpha(mapping.size() + 1));
}","The original code unnecessarily creates a separate variable and performs redundant null checks, potentially leading to less readable and less efficient code. The fixed version uses `computeIfAbsent()`, which atomically handles both mapping lookup and value generation in a single method call, simplifying the logic and reducing potential race conditions. This approach provides a more concise, efficient, and thread-safe way to implement the anonymization mapping."
38819,"@Override public void onTaskEnd(StatisticsReader.TaskExecution task,StatisticsReader.JobExecution job){
  if (task.workingDataSize != null) {
    String slaveId=task.slaveRank + ""String_Node_Str"" + task.slaveThread;
    AtomicLong workingDataSize=workingDataSizePerSlave.get(slaveId);
    if (workingDataSize == null) {
      workingDataSize=new AtomicLong();
      workingDataSizePerSlave.put(slaveId,workingDataSize);
    }
    workingDataSize.addAndGet(task.workingDataSize);
    totalWorkingDataSize[0]+=task.workingDataSize;
  }
}","@Override public void onTaskEnd(StatisticsReader.TaskExecution task,StatisticsReader.JobExecution job){
  if (task.workingDataSize != null) {
    String slaveId=task.slaveRank + ""String_Node_Str"" + task.slaveThread;
    AtomicLong workingDataSize=workingDataSizePerSlave.computeIfAbsent(slaveId,k -> new AtomicLong());
    workingDataSize.addAndGet(task.workingDataSize);
    totalWorkingDataSize[0]+=task.workingDataSize;
  }
}","The original code has a race condition when checking and initializing the `workingDataSize` for a specific slave, potentially leading to inconsistent or lost updates. The fixed code uses `computeIfAbsent()`, which atomically checks for the key and creates a new `AtomicLong` if it doesn't exist, ensuring thread-safe initialization. This approach eliminates the potential for concurrent modification errors and simplifies the code by removing explicit null checking and manual insertion."
38820,"public static void exportWorkingDataSize(Path dbDir,String dbName) throws IOException {
  Objects.requireNonNull(dbDir);
  Objects.requireNonNull(dbName);
  Path csv=dbDir.resolve(dbName + ""String_Node_Str"");
  Path workingDataSizeCsv=dbDir.resolve(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"",workingDataSizeCsv);
  final Map<String,AtomicLong> workingDataSizePerSlave=new HashMap<>();
  final long[] totalWorkingDataSize=new long[1];
  try (StatisticsReader reader=new StatisticsReader(csv)){
    reader.read(new StatisticsReader.AbstractHandler(){
      @Override public void onTaskEnd(      StatisticsReader.TaskExecution task,      StatisticsReader.JobExecution job){
        if (task.workingDataSize != null) {
          String slaveId=task.slaveRank + ""String_Node_Str"" + task.slaveThread;
          AtomicLong workingDataSize=workingDataSizePerSlave.get(slaveId);
          if (workingDataSize == null) {
            workingDataSize=new AtomicLong();
            workingDataSizePerSlave.put(slaveId,workingDataSize);
          }
          workingDataSize.addAndGet(task.workingDataSize);
          totalWorkingDataSize[0]+=task.workingDataSize;
        }
      }
    }
);
  }
   try (BufferedWriter writer=Files.newBufferedWriter(workingDataSizeCsv,StandardCharsets.UTF_8)){
    writer.write(""String_Node_Str"" + CSV_SEPARATOR + ""String_Node_Str"");
    writer.newLine();
    for (    Map.Entry<String,AtomicLong> entry : workingDataSizePerSlave.entrySet()) {
      String slaveId=entry.getKey();
      long workingDataSize=entry.getValue().get();
      writer.write(slaveId + CSV_SEPARATOR + workingDataSize);
      writer.newLine();
    }
    writer.write(""String_Node_Str"" + CSV_SEPARATOR + totalWorkingDataSize[0]);
    writer.newLine();
  }
 }","public static void exportWorkingDataSize(Path dbDir,String dbName) throws IOException {
  Objects.requireNonNull(dbDir);
  Objects.requireNonNull(dbName);
  Path csv=dbDir.resolve(dbName + ""String_Node_Str"");
  Path workingDataSizeCsv=dbDir.resolve(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"",workingDataSizeCsv);
  final Map<String,AtomicLong> workingDataSizePerSlave=new HashMap<>();
  final long[] totalWorkingDataSize=new long[1];
  try (StatisticsReader reader=new StatisticsReader(csv)){
    reader.read(new StatisticsReader.AbstractHandler(){
      @Override public void onTaskEnd(      StatisticsReader.TaskExecution task,      StatisticsReader.JobExecution job){
        if (task.workingDataSize != null) {
          String slaveId=task.slaveRank + ""String_Node_Str"" + task.slaveThread;
          AtomicLong workingDataSize=workingDataSizePerSlave.computeIfAbsent(slaveId,k -> new AtomicLong());
          workingDataSize.addAndGet(task.workingDataSize);
          totalWorkingDataSize[0]+=task.workingDataSize;
        }
      }
    }
);
  }
   try (BufferedWriter writer=Files.newBufferedWriter(workingDataSizeCsv,StandardCharsets.UTF_8)){
    writer.write(""String_Node_Str"" + CSV_SEPARATOR + ""String_Node_Str"");
    writer.newLine();
    for (    Map.Entry<String,AtomicLong> entry : workingDataSizePerSlave.entrySet()) {
      String slaveId=entry.getKey();
      long workingDataSize=entry.getValue().get();
      writer.write(slaveId + CSV_SEPARATOR + workingDataSize);
      writer.newLine();
    }
    writer.write(""String_Node_Str"" + CSV_SEPARATOR + totalWorkingDataSize[0]);
    writer.newLine();
  }
 }","The original code manually checks and initializes a new AtomicLong for each slave ID, which is verbose and prone to race conditions in concurrent scenarios. The fixed code replaces the manual check with `computeIfAbsent()`, which atomically creates and retrieves the AtomicLong if it doesn't exist, simplifying the logic and ensuring thread-safe initialization. This change makes the code more concise, readable, and eliminates potential synchronization issues when tracking working data size across multiple slaves."
38821,"@Override @Deprecated public void onProgress(CommandExecution execution,int executionIndex){
}","/** 
 * @deprecated Use onExecutionCompletion(CommandExecution, int) instead.
 */
@Override @Deprecated public void onProgress(CommandExecution execution,int executionIndex){
}","The original code lacked a clear indication of the method's deprecation and future replacement. The fixed code adds a Javadoc comment explicitly stating the deprecated status and recommending an alternative method, `onExecutionCompletion()`, for future use. By providing clear documentation, developers are informed about the method's obsolescence and guided towards the preferred implementation method."
38822,"@Deprecated CommandExecutor newCommandExecutor(Map<String,String> env,String workingDirPrefix,boolean debug) throws Exception ;","/** 
 * @deprecated Use execute(ExecutionEnvironment, ExecutionHandler<R>) instead.
 */
@Deprecated CommandExecutor newCommandExecutor(Map<String,String> env,String workingDirPrefix,boolean debug) throws Exception ;","The original code lacked proper deprecation documentation, making it unclear why the method was marked deprecated and how developers should migrate to alternative implementations. The fixed code adds a clear Javadoc comment explaining the recommended replacement method `execute(ExecutionEnvironment, ExecutionHandler<R>)`, providing guidance for developers on the preferred approach. This enhanced documentation helps developers understand the deprecation rationale and smoothly transition to the new method, improving code maintainability and API clarity."
38823,"@Deprecated void onProgress(CommandExecution execution,int executionIndex);","/** 
 * @deprecated Use onExecutionCompletion(CommandExecution, int) instead.
 */
@Deprecated void onProgress(CommandExecution execution,int executionIndex);","The original code lacked a clear deprecation documentation, making it difficult for developers to understand the method's status and recommended alternative. The fixed code adds a Javadoc comment explaining the deprecation reason and suggesting the replacement method `onExecutionCompletion`, providing clear guidance for future usage. This improvement enhances code maintainability by explicitly communicating the method's deprecated status and directing developers to the preferred implementation."
38824,"public InputFile(Function<Integer,String> nameFunc,FilePreProcessor preProcessor){
  this.name=new FunctionFileName(nameFunc,name -> checkName(name,preProcessor));
  this.preProcessor=preProcessor;
}","public InputFile(Function<Integer,String> nameFunc,FilePreProcessor preProcessor){
  this.name=new FunctionFileName(nameFunc,fileName -> checkName(fileName,preProcessor));
  this.preProcessor=preProcessor;
}","The original code incorrectly used an uninitialized `name` variable in the lambda parameter, which would cause a compilation or runtime error. In the fixed code, `fileName` is used as a clear, meaningful parameter name, replacing the problematic `name` reference. This correction ensures proper lambda parameter handling and prevents potential null or undefined variable issues during file name processing."
38825,"@Deprecated public static DataSource createReadOnly(Path file){
  return createDataSource(file);
}","/** 
 * @deprecated Use createDataSource(Path) instead.
 */
@Deprecated public static DataSource createReadOnly(Path file){
  return createDataSource(file);
}","The original code lacked a proper Javadoc comment explaining the deprecation reason, which reduces code clarity and developer understanding. The fixed code adds a descriptive Javadoc comment indicating the recommended alternative method (`createDataSource(Path)`), providing clear guidance for developers about the deprecated method's replacement. This improvement enhances code maintainability by explicitly documenting the method's deprecation status and suggesting the preferred usage."
38826,"@Override protected String getTypeDescription(){
  return ""String_Node_Str"";
}","@Override protected String getTypeDescription(){
  return TYPE_DESCRIPTION;
}","The original code hardcodes a string literal directly in the method, which is inflexible and prone to duplication and potential errors. The fixed code replaces the hardcoded string with a reference to a constant variable (TYPE_DESCRIPTION), which allows for centralized definition and easier maintenance of the type description. By using a constant, the code becomes more modular, reduces the risk of typos, and enables consistent reuse of the type description across the class or application."
38827,"void update(){
  if (components != null) {
    return;
  }
  long startTime=System.currentTimeMillis();
  for (  Bus b : network.getBusBreakerView().getBuses()) {
    setComponentNumber((BusExt)b,-1);
  }
  int num=0;
  Map<String,Integer> id2num=new HashMap<>();
  List<BusExt> num2bus=new ArrayList<>();
  for (  Bus bus : network.getBusView().getBuses()) {
    num2bus.add((BusExt)bus);
    id2num.put(bus.getId(),num);
    num++;
  }
  TIntArrayList[] adjacencyList=new TIntArrayList[num];
  for (int i=0; i < adjacencyList.length; i++) {
    adjacencyList[i]=new TIntArrayList(3);
  }
  fillAdjacencyList(id2num,adjacencyList);
  ConnectedComponentsComputationResult result=GraphUtil.computeConnectedComponents(adjacencyList);
  components=new ArrayList<>(result.getComponentSize().length);
  for (int i=0; i < result.getComponentSize().length; i++) {
    components.add(createComponent(i,result.getComponentSize()[i]));
  }
  for (int i=0; i < result.getComponentNumber().length; i++) {
    BusExt bus=num2bus.get(i);
    setComponentNumber(bus,result.getComponentNumber()[i]);
  }
  LOGGER.debug(getComponentLabel() + ""String_Node_Str"",System.currentTimeMillis() - startTime);
}","void update(){
  if (components != null) {
    return;
  }
  long startTime=System.currentTimeMillis();
  for (  Bus b : network.getBusBreakerView().getBuses()) {
    setComponentNumber((BusExt)b,-1);
  }
  int num=0;
  Map<String,Integer> id2num=new HashMap<>();
  List<BusExt> num2bus=new ArrayList<>();
  for (  Bus bus : network.getBusView().getBuses()) {
    num2bus.add((BusExt)bus);
    id2num.put(bus.getId(),num);
    num++;
  }
  TIntArrayList[] adjacencyList=new TIntArrayList[num];
  for (int i=0; i < adjacencyList.length; i++) {
    adjacencyList[i]=new TIntArrayList(3);
  }
  fillAdjacencyList(id2num,adjacencyList);
  ConnectedComponentsComputationResult result=GraphUtil.computeConnectedComponents(adjacencyList);
  components=new ArrayList<>(result.getComponentSize().length);
  for (int i=0; i < result.getComponentSize().length; i++) {
    components.add(createComponent(i,result.getComponentSize()[i]));
  }
  for (int i=0; i < result.getComponentNumber().length; i++) {
    BusExt bus=num2bus.get(i);
    setComponentNumber(bus,result.getComponentNumber()[i]);
  }
  LOGGER.debug(""String_Node_Str"",getComponentLabel(),System.currentTimeMillis() - startTime);
}","The buggy code had an incorrect logging method with misplaced parameters in the LOGGER.debug() call, which could lead to potential logging errors. The fixed code corrects the order of parameters in the debug method, placing the message first, followed by the component label and timing information. This ensures proper logging and maintains the intended debug information flow, improving code readability and diagnostic capabilities."
38828,"@Override public String getName(VoltageLevel voltageLevel,TIntArrayList nodes){
  AtomicInteger i;
  lock.lock();
  try {
    i=counter.get(voltageLevel);
    if (i == null) {
      i=new AtomicInteger();
      counter.put(voltageLevel,i);
    }
  }
  finally {
    lock.unlock();
  }
  return voltageLevel.getId() + ""String_Node_Str"" + i.getAndIncrement();
}","@Override public String getName(VoltageLevel voltageLevel,TIntArrayList nodes){
  AtomicInteger i;
  lock.lock();
  try {
    i=counter.computeIfAbsent(voltageLevel,k -> new AtomicInteger());
  }
  finally {
    lock.unlock();
  }
  return voltageLevel.getId() + ""String_Node_Str"" + i.getAndIncrement();
}","The original code has a race condition when checking and initializing the counter, potentially leading to null pointer exceptions or inconsistent counter values. The fixed code uses `computeIfAbsent()`, which atomically checks for the key and creates a new AtomicInteger if it doesn't exist, ensuring thread-safe initialization. This approach simplifies the code, eliminates the manual null check, and provides a more concise and reliable method of managing concurrent counter initialization."
38829,"protected BusChecker getBusChecker(){
  return CALCULATED_BUS_BREAKER_CHECKER;
}","@Override protected BusChecker getBusChecker(){
  return CALCULATED_BUS_BREAKER_CHECKER;
}","The original code lacked the `@Override` annotation, which is crucial for explicitly declaring method overriding in inheritance hierarchies. The fixed code adds the `@Override` annotation, which helps catch potential errors during compilation and clearly communicates the method's intent to override a parent class method. This annotation ensures type safety, provides compiler-level verification, and improves code readability by making the inheritance relationship explicit."
38830,"@Deprecated static void checkTargetP(Validable validable,float targetP){
  checkActivePowerSetpoint(validable,targetP);
}","/** 
 * @deprecated Use checkActivePowerSetpoint(Validable, float) instead.
 */
@Deprecated static void checkTargetP(Validable validable,float targetP){
  checkActivePowerSetpoint(validable,targetP);
}","The original code lacked proper documentation for the deprecated method, making its purpose and replacement unclear to developers. The fixed code adds a Javadoc comment explaining that the method is deprecated and should be replaced by `checkActivePowerSetpoint(Validable, float)`, providing clear guidance for future use. This enhancement improves code maintainability by explicitly communicating the method's status and recommended alternative to other developers."
38831,"@Deprecated public boolean isComputationOk(){
  return limitViolationsResult.isComputationOk();
}","/** 
 * @deprecated Use getLimitViolationsResult().isComputationOk() instead.
 */
@Deprecated public boolean isComputationOk(){
  return limitViolationsResult.isComputationOk();
}","The original code lacked proper documentation for the deprecated method, making its purpose and recommended alternative unclear to developers. The fixed code adds a Javadoc comment explaining the deprecation reason and suggesting the direct method call to `getLimitViolationsResult().isComputationOk()`. This improvement provides clear guidance for developers on how to replace the deprecated method, enhancing code maintainability and readability."
38832,"@Deprecated public List<String> getActionsTaken(){
  return limitViolationsResult.getActionsTaken();
}","/** 
 * @deprecated Use getLimitViolationsResult().getActionsTaken() instead.
 */
@Deprecated public List<String> getActionsTaken(){
  return limitViolationsResult.getActionsTaken();
}","The original code lacked a clear documentation comment explaining the deprecation reason, making it unclear why the method was marked as deprecated. The fixed code adds a Javadoc comment specifying the recommended alternative method call, providing explicit guidance for developers on how to replace the deprecated method. This improvement enhances code maintainability by offering clear migration instructions and context for the deprecation."
38833,"@Deprecated public List<LimitViolation> getLimitViolations(){
  return limitViolationsResult.getLimitViolations();
}","/** 
 * @deprecated Use getLimitViolationsResult().getLimitViolations() instead.
 */
@Deprecated public List<LimitViolation> getLimitViolations(){
  return limitViolationsResult.getLimitViolations();
}","The original code lacks proper documentation explaining the deprecation reason, making it unclear why the method is marked as deprecated. The fixed code adds a Javadoc comment specifying the recommended alternative method call, providing clear guidance for developers on how to replace the deprecated method. This improvement enhances code maintainability by explicitly communicating the preferred approach for accessing limit violations."
38834,"private int printUsage(PrintStream err){
  HelpFormatter formatter=new HelpFormatter();
  PrintWriter usage=new PrintWriter(err);
  formatter.printUsage(usage,80,""String_Node_Str"");
  usage.append(System.lineSeparator()).append(""String_Node_Str"").append(System.lineSeparator());
  formatter.printOptions(usage,80,getScriptOptions(),formatter.getLeftPadding(),formatter.getDescPadding());
  usage.append(System.lineSeparator()).append(""String_Node_Str"").append(System.lineSeparator()).append(System.lineSeparator());
  List<Tool> allTools=Lists.newArrayList(tools).stream().filter(t -> !t.getCommand().isHidden()).collect(Collectors.toList());
  Map<String,Collection<Tool>> toolsByTheme=new TreeMap<>(Multimaps.index(allTools,tool -> tool.getCommand().getTheme()).asMap());
  for (  Map.Entry<String,Collection<Tool>> entry : toolsByTheme.entrySet()) {
    String theme=entry.getKey();
    List<Tool> tools=new ArrayList<>(entry.getValue());
    Collections.sort(tools,Comparator.comparing(t -> t.getCommand().getName()));
    usage.append(theme != null ? theme : ""String_Node_Str"").append(""String_Node_Str"").append(System.lineSeparator());
    for (    Tool tool : tools) {
      usage.append(String.format(""String_Node_Str"",tool.getCommand().getName(),tool.getCommand().getDescription())).append(System.lineSeparator());
    }
    usage.append(System.lineSeparator());
  }
  usage.flush();
  return COMMAND_NOT_FOUND_STATUS;
}","private int printUsage(PrintStream err){
  HelpFormatter formatter=new HelpFormatter();
  PrintWriter usage=new PrintWriter(err);
  formatter.printUsage(usage,80,""String_Node_Str"");
  usage.append(System.lineSeparator()).append(""String_Node_Str"").append(System.lineSeparator());
  formatter.printOptions(usage,80,getScriptOptions(),formatter.getLeftPadding(),formatter.getDescPadding());
  usage.append(System.lineSeparator()).append(""String_Node_Str"").append(System.lineSeparator()).append(System.lineSeparator());
  List<Tool> allTools=Lists.newArrayList(tools).stream().filter(t -> !t.getCommand().isHidden()).collect(Collectors.toList());
  Map<String,Collection<Tool>> toolsByTheme=new TreeMap<>(Multimaps.index(allTools,tool -> tool.getCommand().getTheme()).asMap());
  for (  Map.Entry<String,Collection<Tool>> entry : toolsByTheme.entrySet()) {
    String theme=entry.getKey();
    usage.append(theme != null ? theme : ""String_Node_Str"").append(""String_Node_Str"").append(System.lineSeparator());
    entry.getValue().stream().sorted(Comparator.comparing(t -> t.getCommand().getName())).forEach(tool -> usage.append(String.format(""String_Node_Str"",tool.getCommand().getName(),tool.getCommand().getDescription())).append(System.lineSeparator()));
    usage.append(System.lineSeparator());
  }
  usage.flush();
  return COMMAND_NOT_FOUND_STATUS;
}","The original code inefficiently created a separate list of tools and manually sorted them, which was redundant and less performant. The fixed code replaces the separate list creation and manual sorting with a more streamlined stream operation that directly sorts the tools and uses a forEach method to append tool details. This approach reduces unnecessary object creation, simplifies the code, and provides a more concise and efficient way of processing and displaying tool information."
38835,"@Deprecated default void run(CommandLine line) throws Exception {
}","/** 
 * @deprecated Use run(CommandLine, ToolRunningContext) instead.
 */
@Deprecated default void run(CommandLine line) throws Exception {
}","The original code lacks proper documentation for a deprecated method, potentially confusing developers about its replacement. The fixed code adds a Javadoc comment explicitly recommending the alternative method `run(CommandLine, ToolRunningContext)`, providing clear guidance for method usage. This improvement helps developers understand the deprecation reason and smoothly transition to the newer, preferred method implementation."
38836,"private static void createXnodeCoupler(UcteNetworkExt ucteNetwork,UcteLine ucteLine,UcteNodeCode ucteXnodeCode,UcteVoltageLevel ucteXvoltageLevel,UcteNodeCode ucteOtherNodeCode,Network network){
  String xNodeName=ucteXnodeCode.toString();
  String yNodeName=""String_Node_Str"" + xNodeName.substring(1);
  VoltageLevel xNodeVoltageLevel=network.getVoltageLevel(ucteXvoltageLevel.getName());
  xNodeVoltageLevel.getBusBreakerView().newBus().setId(yNodeName).add();
  UcteNode ucteXnode=ucteNetwork.getNode(ucteXnodeCode);
  LOGGER.warn(""String_Node_Str"",xNodeName + yNodeName,ucteXnode.getCode());
  float p0=0;
  if (isValueValid(ucteXnode.getActiveLoad())) {
    p0+=ucteXnode.getActiveLoad();
  }
  if (isValueValid(ucteXnode.getActivePowerGeneration())) {
    p0+=ucteXnode.getActivePowerGeneration();
  }
  float q0=0;
  if (isValueValid(ucteXnode.getReactiveLoad())) {
    q0+=ucteXnode.getReactiveLoad();
  }
  if (isValueValid(ucteXnode.getReactivePowerGeneration())) {
    q0+=ucteXnode.getReactivePowerGeneration();
  }
  xNodeVoltageLevel.newDanglingLine().setId(xNodeName + yNodeName).setBus(yNodeName).setConnectableBus(yNodeName).setR(0.0f).setX(LINE_MIN_Z).setG(0f).setB(0f).setP0(p0).setQ0(q0).setUcteXnodeCode(ucteXnode.getCode().toString()).add();
  xNodeVoltageLevel.getBusBreakerView().newSwitch().setId(ucteLine.getId().toString()).setBus1(yNodeName).setBus2(ucteOtherNodeCode.toString()).setOpen(ucteLine.getStatus() == UcteElementStatus.BUSBAR_COUPLER_OUT_OF_OPERATION).add();
}","private static void createXnodeCoupler(UcteNetworkExt ucteNetwork,UcteLine ucteLine,UcteNodeCode ucteXnodeCode,UcteVoltageLevel ucteXvoltageLevel,UcteNodeCode ucteOtherNodeCode,Network network){
  String xNodeName=ucteXnodeCode.toString();
  String yNodeName=""String_Node_Str"" + xNodeName.substring(1);
  VoltageLevel xNodeVoltageLevel=network.getVoltageLevel(ucteXvoltageLevel.getName());
  xNodeVoltageLevel.getBusBreakerView().newBus().setId(yNodeName).add();
  UcteNode ucteXnode=ucteNetwork.getNode(ucteXnodeCode);
  LOGGER.warn(""String_Node_Str"",xNodeName,yNodeName,ucteXnode.getCode());
  float p0=0;
  if (isValueValid(ucteXnode.getActiveLoad())) {
    p0+=ucteXnode.getActiveLoad();
  }
  if (isValueValid(ucteXnode.getActivePowerGeneration())) {
    p0+=ucteXnode.getActivePowerGeneration();
  }
  float q0=0;
  if (isValueValid(ucteXnode.getReactiveLoad())) {
    q0+=ucteXnode.getReactiveLoad();
  }
  if (isValueValid(ucteXnode.getReactivePowerGeneration())) {
    q0+=ucteXnode.getReactivePowerGeneration();
  }
  xNodeVoltageLevel.newDanglingLine().setId(xNodeName + yNodeName).setBus(yNodeName).setConnectableBus(yNodeName).setR(0.0f).setX(LINE_MIN_Z).setG(0f).setB(0f).setP0(p0).setQ0(q0).setUcteXnodeCode(ucteXnode.getCode().toString()).add();
  xNodeVoltageLevel.getBusBreakerView().newSwitch().setId(ucteLine.getId().toString()).setBus1(yNodeName).setBus2(ucteOtherNodeCode.toString()).setOpen(ucteLine.getStatus() == UcteElementStatus.BUSBAR_COUPLER_OUT_OF_OPERATION).add();
}","The original logging call incorrectly passed multiple arguments without matching the format string, potentially causing unexpected logging behavior. The fixed code corrects the LOGGER.warn() method by aligning the format string with the actual arguments, ensuring proper logging of xNodeName, yNodeName, and ucteXnode's code. This change improves code reliability and prevents potential runtime errors during logging, making the method more robust and predictable."
38837,"private static TwoWindingsTransformer createXnodeTransfo(UcteNetworkExt ucteNetwork,UcteTransformer ucteTransfo,boolean connected,UcteNodeCode xNodeCode,UcteNodeCode ucteOtherNodeCode,UcteVoltageLevel ucteOtherVoltageLevel,Substation substation,EntsoeFileName ucteFileName){
  String xNodeName=xNodeCode.toString();
  String yNodeName=ucteFileName.getCountry() != null ? ucteFileName.getCountry() + ""String_Node_Str"" + xNodeName : ""String_Node_Str"" + xNodeName;
  VoltageLevel yVoltageLevel=substation.newVoltageLevel().setId(yNodeName + ""String_Node_Str"").setNominalV(xNodeCode.getVoltageLevelCode().getVoltageLevel()).setTopologyKind(TopologyKind.BUS_BREAKER).add();
  yVoltageLevel.getBusBreakerView().newBus().setId(yNodeName).add();
  UcteNode ucteXnode=ucteNetwork.getNode(xNodeCode);
  LOGGER.warn(""String_Node_Str"",xNodeName + yNodeName,ucteXnode.getCode());
  float p0=0;
  if (isValueValid(ucteXnode.getActiveLoad())) {
    p0+=ucteXnode.getActiveLoad();
  }
  if (isValueValid(ucteXnode.getActivePowerGeneration())) {
    p0+=ucteXnode.getActivePowerGeneration();
  }
  float q0=0;
  if (isValueValid(ucteXnode.getReactiveLoad())) {
    q0+=ucteXnode.getReactiveLoad();
  }
  if (isValueValid(ucteXnode.getReactivePowerGeneration())) {
    q0+=ucteXnode.getReactivePowerGeneration();
  }
  yVoltageLevel.newDanglingLine().setId(xNodeName + ""String_Node_Str"" + yNodeName).setBus(yNodeName).setConnectableBus(yNodeName).setR(0.0f).setX(LINE_MIN_Z).setG(0f).setB(0f).setP0(p0).setQ0(q0).setUcteXnodeCode(ucteXnode.getCode().toString()).add();
  String voltageLevelId1;
  String voltageLevelId2;
  String busId1;
  String busId2;
  if (ucteXnode.getCode().equals(ucteTransfo.getId().getNodeCode1())) {
    voltageLevelId1=ucteOtherVoltageLevel.getName();
    voltageLevelId2=yVoltageLevel.getName();
    busId1=ucteOtherNodeCode.toString();
    busId2=yNodeName;
  }
 else {
    voltageLevelId1=yVoltageLevel.getName();
    voltageLevelId2=ucteOtherVoltageLevel.getName();
    busId1=yNodeName;
    busId2=ucteOtherNodeCode.toString();
  }
  return substation.newTwoWindingsTransformer().setId(ucteTransfo.getId().toString()).setVoltageLevel1(voltageLevelId1).setVoltageLevel2(voltageLevelId2).setBus1(connected ? busId1 : null).setBus2(connected ? busId2 : null).setConnectableBus1(busId1).setConnectableBus2(busId2).setRatedU1(ucteTransfo.getRatedVoltage2()).setRatedU2(ucteTransfo.getRatedVoltage1()).setR(ucteTransfo.getResistance()).setX(ucteTransfo.getReactance()).setG(getConductance(ucteTransfo)).setB(getSusceptance(ucteTransfo)).add();
}","private static TwoWindingsTransformer createXnodeTransfo(UcteNetworkExt ucteNetwork,UcteTransformer ucteTransfo,boolean connected,UcteNodeCode xNodeCode,UcteNodeCode ucteOtherNodeCode,UcteVoltageLevel ucteOtherVoltageLevel,Substation substation,EntsoeFileName ucteFileName){
  String xNodeName=xNodeCode.toString();
  String yNodeName=ucteFileName.getCountry() != null ? ucteFileName.getCountry() + ""String_Node_Str"" + xNodeName : ""String_Node_Str"" + xNodeName;
  VoltageLevel yVoltageLevel=substation.newVoltageLevel().setId(yNodeName + ""String_Node_Str"").setNominalV(xNodeCode.getVoltageLevelCode().getVoltageLevel()).setTopologyKind(TopologyKind.BUS_BREAKER).add();
  yVoltageLevel.getBusBreakerView().newBus().setId(yNodeName).add();
  UcteNode ucteXnode=ucteNetwork.getNode(xNodeCode);
  LOGGER.warn(""String_Node_Str"",xNodeName,yNodeName,ucteXnode.getCode());
  float p0=0;
  if (isValueValid(ucteXnode.getActiveLoad())) {
    p0+=ucteXnode.getActiveLoad();
  }
  if (isValueValid(ucteXnode.getActivePowerGeneration())) {
    p0+=ucteXnode.getActivePowerGeneration();
  }
  float q0=0;
  if (isValueValid(ucteXnode.getReactiveLoad())) {
    q0+=ucteXnode.getReactiveLoad();
  }
  if (isValueValid(ucteXnode.getReactivePowerGeneration())) {
    q0+=ucteXnode.getReactivePowerGeneration();
  }
  yVoltageLevel.newDanglingLine().setId(xNodeName + ""String_Node_Str"" + yNodeName).setBus(yNodeName).setConnectableBus(yNodeName).setR(0.0f).setX(LINE_MIN_Z).setG(0f).setB(0f).setP0(p0).setQ0(q0).setUcteXnodeCode(ucteXnode.getCode().toString()).add();
  String voltageLevelId1;
  String voltageLevelId2;
  String busId1;
  String busId2;
  if (ucteXnode.getCode().equals(ucteTransfo.getId().getNodeCode1())) {
    voltageLevelId1=ucteOtherVoltageLevel.getName();
    voltageLevelId2=yVoltageLevel.getName();
    busId1=ucteOtherNodeCode.toString();
    busId2=yNodeName;
  }
 else {
    voltageLevelId1=yVoltageLevel.getName();
    voltageLevelId2=ucteOtherVoltageLevel.getName();
    busId1=yNodeName;
    busId2=ucteOtherNodeCode.toString();
  }
  return substation.newTwoWindingsTransformer().setId(ucteTransfo.getId().toString()).setVoltageLevel1(voltageLevelId1).setVoltageLevel2(voltageLevelId2).setBus1(connected ? busId1 : null).setBus2(connected ? busId2 : null).setConnectableBus1(busId1).setConnectableBus2(busId2).setRatedU1(ucteTransfo.getRatedVoltage2()).setRatedU2(ucteTransfo.getRatedVoltage1()).setR(ucteTransfo.getResistance()).setX(ucteTransfo.getReactance()).setG(getConductance(ucteTransfo)).setB(getSusceptance(ucteTransfo)).add();
}","The original code had an incorrect LOGGER.warn() call with excessive parameters, potentially causing logging errors or unexpected behavior. The fixed code corrects the logging by aligning the number of arguments with the method signature, ensuring proper log message formatting and clarity. This modification enhances code reliability and maintains consistent logging practices without changing the core logic of the method."
38838,"private String alignAndTruncate(String str,int strLen,Alignment alignment){
  String formattedStr=String.format(java.util.Locale.US,""String_Node_Str"" + (alignment.equals(Alignment.LEFT) ? ""String_Node_Str"" : ""String_Node_Str"") + strLen+ ""String_Node_Str"",str);
  return formattedStr.substring(0,strLen);
}","private String alignAndTruncate(String str,int strLen,Alignment alignment){
  String format=String.format(Locale.US,alignment.equals(Alignment.LEFT) ? ""String_Node_Str"" : ""String_Node_Str"",strLen);
  String formattedStr=String.format(Locale.US,format,str);
  return formattedStr.substring(0,strLen);
}","The original code had an incorrect format string construction, leading to potential formatting errors and unnecessary string concatenation. The fixed code separates format string creation based on alignment and uses a more precise String.format() approach, dynamically generating the correct formatting template. This refactoring improves code readability, reduces complexity, and ensures accurate string alignment and truncation with better performance."
38839,"public void load(int version,List<TimeSeries> timeSeriesList){
  checkVersion(version);
  Objects.requireNonNull(timeSeriesList);
  if (timeSeriesList.isEmpty()) {
    throw new TimeSeriesException(""String_Node_Str"");
  }
  Stopwatch stopWatch=Stopwatch.createStarted();
  List<DoubleTimeSeries> doubleTimeSeries=new ArrayList<>();
  List<StringTimeSeries> stringTimeSeries=new ArrayList<>();
  for (  TimeSeries timeSeries : timeSeriesList) {
    Objects.requireNonNull(timeSeries);
    if (timeSeries instanceof DoubleTimeSeries) {
      doubleTimeSeries.add((DoubleTimeSeries)timeSeries);
    }
 else     if (timeSeries instanceof StringTimeSeries) {
      stringTimeSeries.add((StringTimeSeries)timeSeries);
    }
 else {
      throw new AssertionError(""String_Node_Str"" + timeSeries.getClass());
    }
  }
  initTable(doubleTimeSeries,stringTimeSeries);
  for (  DoubleTimeSeries timeSeries : doubleTimeSeries) {
    loadDouble(version,timeSeries);
  }
  for (  StringTimeSeries timeSeries : stringTimeSeries) {
    loadString(version,timeSeries);
  }
  LOGGER.info(""String_Node_Str"",timeSeriesList.size(),version,stopWatch.elapsed(TimeUnit.MILLISECONDS));
}","public void load(int version,List<TimeSeries> timeSeriesList){
  checkVersion(version);
  Objects.requireNonNull(timeSeriesList);
  if (timeSeriesList.isEmpty()) {
    throw new TimeSeriesException(""String_Node_Str"");
  }
  Stopwatch stopWatch=Stopwatch.createStarted();
  List<DoubleTimeSeries> doubleTimeSeries=new ArrayList<>();
  List<StringTimeSeries> stringTimeSeries=new ArrayList<>();
  for (  TimeSeries timeSeries : timeSeriesList) {
    Objects.requireNonNull(timeSeries);
    if (timeSeries instanceof DoubleTimeSeries) {
      doubleTimeSeries.add((DoubleTimeSeries)timeSeries);
    }
 else     if (timeSeries instanceof StringTimeSeries) {
      stringTimeSeries.add((StringTimeSeries)timeSeries);
    }
 else {
      throw new AssertionError(""String_Node_Str"" + timeSeries.getClass());
    }
  }
  initTable(doubleTimeSeries,stringTimeSeries);
  for (  DoubleTimeSeries timeSeries : doubleTimeSeries) {
    timeSeries.synchronize(tableIndex);
    loadDouble(version,timeSeries);
  }
  for (  StringTimeSeries timeSeries : stringTimeSeries) {
    timeSeries.synchronize(tableIndex);
    loadString(version,timeSeries);
  }
  LOGGER.info(""String_Node_Str"",timeSeriesList.size(),version,stopWatch.elapsed(TimeUnit.MILLISECONDS));
}","The original code did not synchronize time series with the table index before loading, potentially causing data inconsistency. The fixed code adds `timeSeries.synchronize(tableIndex)` for both DoubleTimeSeries and StringTimeSeries, ensuring that each time series is aligned with the table index before loading. This modification guarantees data integrity and prevents potential synchronization-related errors during the loading process."
38840,"private void initTable(List<DoubleTimeSeries> doubleTimeSeries,List<StringTimeSeries> stringTimeSeries){
  initLock.lock();
  try {
    if (timeSeriesMetadata != null) {
      return;
    }
    timeSeriesMetadata=new ArrayList<>(doubleTimeSeries.size() + stringTimeSeries.size());
    for (    DoubleTimeSeries timeSeries : doubleTimeSeries.stream().sorted(Comparator.comparing(ts -> ts.getMetadata().getName())).collect(Collectors.toList())) {
      timeSeries.synchronize(tableIndex);
      timeSeriesMetadata.add(timeSeries.getMetadata());
      int i=doubleTimeSeriesNames.add(timeSeries.getMetadata().getName());
      timeSeriesIndexDoubleOrString.add(i);
    }
    for (    StringTimeSeries timeSeries : stringTimeSeries.stream().sorted(Comparator.comparing(ts -> ts.getMetadata().getName())).collect(Collectors.toList())) {
      timeSeries.synchronize(tableIndex);
      timeSeriesMetadata.add(timeSeries.getMetadata());
      int i=stringTimeSeriesNames.add(timeSeries.getMetadata().getName());
      timeSeriesIndexDoubleOrString.add(i);
    }
    if (tableIndex == null) {
      throw new TimeSeriesException(""String_Node_Str"");
    }
    int versionCount=toVersion - fromVersion + 1;
    int doubleBufferSize=versionCount * doubleTimeSeriesNames.size() * tableIndex.getPointCount();
    doubleBuffer=createDoubleBuffer(doubleBufferSize,Double.NaN);
    int stringBufferSize=versionCount * stringTimeSeriesNames.size() * tableIndex.getPointCount();
    stringBuffer=new CompactStringBuffer(stringBufferSize);
    if (LOGGER.isInfoEnabled()) {
      LOGGER.info(""String_Node_Str"",FileUtils.byteCountToDisplaySize((long)doubleBuffer.capacity() * Double.BYTES + stringBuffer.capacity() * Integer.BYTES));
    }
    means=new double[doubleTimeSeriesNames.size() * versionCount];
    Arrays.fill(means,Double.NaN);
    stdDevs=new double[doubleTimeSeriesNames.size() * versionCount];
    Arrays.fill(stdDevs,Double.NaN);
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
    timeSeriesMetadata=null;
    doubleTimeSeriesNames.clear();
    stringTimeSeriesNames.clear();
    timeSeriesIndexDoubleOrString.clear();
    doubleBuffer=null;
    stringBuffer=null;
    means=null;
    stdDevs=null;
  }
 finally {
    initLock.unlock();
  }
}","private void initTable(List<DoubleTimeSeries> doubleTimeSeries,List<StringTimeSeries> stringTimeSeries){
  initLock.lock();
  try {
    if (timeSeriesMetadata != null) {
      return;
    }
    timeSeriesMetadata=new ArrayList<>(doubleTimeSeries.size() + stringTimeSeries.size());
    for (    DoubleTimeSeries timeSeries : doubleTimeSeries.stream().sorted(Comparator.comparing(ts -> ts.getMetadata().getName())).collect(Collectors.toList())) {
      timeSeriesMetadata.add(timeSeries.getMetadata());
      int i=doubleTimeSeriesNames.add(timeSeries.getMetadata().getName());
      timeSeriesIndexDoubleOrString.add(i);
    }
    for (    StringTimeSeries timeSeries : stringTimeSeries.stream().sorted(Comparator.comparing(ts -> ts.getMetadata().getName())).collect(Collectors.toList())) {
      timeSeriesMetadata.add(timeSeries.getMetadata());
      int i=stringTimeSeriesNames.add(timeSeries.getMetadata().getName());
      timeSeriesIndexDoubleOrString.add(i);
    }
    if (tableIndex == null) {
      throw new TimeSeriesException(""String_Node_Str"");
    }
    int versionCount=toVersion - fromVersion + 1;
    int doubleBufferSize=versionCount * doubleTimeSeriesNames.size() * tableIndex.getPointCount();
    doubleBuffer=createDoubleBuffer(doubleBufferSize,Double.NaN);
    int stringBufferSize=versionCount * stringTimeSeriesNames.size() * tableIndex.getPointCount();
    stringBuffer=new CompactStringBuffer(stringBufferSize);
    if (LOGGER.isInfoEnabled()) {
      LOGGER.info(""String_Node_Str"",FileUtils.byteCountToDisplaySize((long)doubleBuffer.capacity() * Double.BYTES + stringBuffer.capacity() * Integer.BYTES));
    }
    means=new double[doubleTimeSeriesNames.size() * versionCount];
    Arrays.fill(means,Double.NaN);
    stdDevs=new double[doubleTimeSeriesNames.size() * versionCount];
    Arrays.fill(stdDevs,Double.NaN);
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
    timeSeriesMetadata=null;
    doubleTimeSeriesNames.clear();
    stringTimeSeriesNames.clear();
    timeSeriesIndexDoubleOrString.clear();
    doubleBuffer=null;
    stringBuffer=null;
    means=null;
    stdDevs=null;
  }
 finally {
    initLock.unlock();
  }
}","The original code calls `timeSeries.synchronize(tableIndex)` before adding metadata, which could potentially modify the time series before processing. The fixed code removes the `synchronize` method call, ensuring that time series metadata is added directly without any potentially disruptive synchronization. This change preserves the integrity of the time series data and prevents unintended modifications during initialization."
38841,"public int add(E e){
  Objects.requireNonNull(e);
  int i=list.size();
  list.add(e);
  reverse.put(e,i);
  return i;
}","public int add(E e){
  Objects.requireNonNull(e);
  lock.lock();
  try {
    int i=list.size();
    list.add(e);
    reverse.put(e,i);
    return i;
  }
  finally {
    lock.unlock();
  }
}","The original code lacks thread synchronization, which can lead to race conditions when multiple threads simultaneously add elements to the list and reverse mapping. The fixed code introduces a lock mechanism using `lock.lock()` and `lock.unlock()` in a try-finally block, ensuring that only one thread can execute the critical section at a time. This approach prevents concurrent modification issues, guaranteeing thread-safe addition of elements and maintaining data consistency across multiple threads."
38842,"int size(){
  return list.size();
}","int size(){
  lock.lock();
  try {
    return list.size();
  }
  finally {
    lock.unlock();
  }
}","The original code lacks proper synchronization, potentially causing race conditions when multiple threads access the list's size concurrently. The fixed code introduces a lock mechanism that ensures thread-safe access by acquiring a lock before reading the list size and releasing it afterward using a try-finally block. This approach guarantees exclusive access to the shared resource, preventing potential data inconsistencies and thread-safety issues during concurrent operations."
38843,"public E get(int index){
  return list.get(index);
}","public E get(int index){
  lock.lock();
  try {
    return list.get(index);
  }
  finally {
    lock.unlock();
  }
}","The original code lacks thread synchronization, potentially causing race conditions and data inconsistency when multiple threads access the shared list simultaneously. The fixed code introduces a lock mechanism that ensures exclusive access to the list during the get operation, preventing concurrent modifications and guaranteeing thread-safe retrieval of elements. By using try-finally to always release the lock, the code prevents deadlocks and ensures proper resource management in multi-threaded environments."
38844,"void clear(){
  list.clear();
  reverse.clear();
}","void clear(){
  lock.lock();
  try {
    list.clear();
    reverse.clear();
  }
  finally {
    lock.unlock();
  }
}","The original code lacks thread synchronization, potentially causing race conditions when multiple threads attempt to clear the list simultaneously. The fixed code introduces a lock mechanism using `lock.lock()` and `lock.unlock()` in a try-finally block, ensuring exclusive access to the critical section during list clearing. This approach guarantees thread-safe modification of shared data structures, preventing concurrent access and potential data corruption."
38845,"public int indexOf(E e){
  Objects.requireNonNull(e);
  if (!reverse.containsKey(e)) {
    return -1;
  }
  return reverse.get(e);
}","public int indexOf(E e){
  Objects.requireNonNull(e);
  lock.lock();
  try {
    if (!reverse.containsKey(e)) {
      return -1;
    }
    return reverse.get(e);
  }
  finally {
    lock.unlock();
  }
}","The original code lacks thread synchronization, potentially causing race conditions when multiple threads access the `reverse` map simultaneously. The fixed code adds a lock mechanism using `lock.lock()` and `lock.unlock()` in a try-finally block, ensuring thread-safe access to the shared data structure. This prevents concurrent modification and reading of the map, eliminating potential data inconsistencies and race conditions during index retrieval."
38846,"public void putString(int index,String value){
  int num;
  if (value == null) {
    num=-1;
  }
 else {
    num=dict.indexOf(value);
    if (num == -1) {
      num=dict.add(value);
    }
  }
  buffer.put(index,num);
}","public void putString(int index,String value){
  int num;
  if (value == null) {
    num=-1;
  }
 else {
    num=dict.addIfNotAlreadyExist(value);
  }
  buffer.put(index,num);
}","The original code inefficiently checks and adds strings to the dictionary by first searching for the index and then separately adding if not found, leading to potential redundant operations. The fixed code replaces these two steps with a single method `addIfNotAlreadyExist()`, which atomically handles checking and adding the string to the dictionary. This optimization reduces code complexity, improves performance, and ensures a more streamlined approach to managing dictionary entries."
38847,"@Test public void test() throws IOException {
  NodeInfo info=new NodeInfo(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1000000,1000001,0,new NodeGenericMetadata());
  NodeDependency dependency=new NodeDependency(""String_Node_Str"",info);
  assertEquals(""String_Node_Str"",dependency.getName());
  assertEquals(info,dependency.getNodeInfo());
  assertEquals(""String_Node_Str"",dependency.toString());
  ObjectMapper objectMapper=new ObjectMapper().registerModule(new AppStorageJsonModule());
  NodeDependency dependency2=objectMapper.readValue(objectMapper.writeValueAsString(dependency),NodeDependency.class);
  assertEquals(dependency,dependency2);
}","@Test public void test() throws IOException {
  NodeInfo info=new NodeInfo(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1000000,1000001,0,new NodeGenericMetadata());
  NodeDependency dependency=new NodeDependency(""String_Node_Str"",info);
  assertEquals(""String_Node_Str"",dependency.getName());
  assertEquals(info,dependency.getNodeInfo());
  assertEquals(""String_Node_Str"",dependency.toString());
  ObjectMapper objectMapper=JsonUtil.createObjectMapper().registerModule(new AppStorageJsonModule());
  NodeDependency dependency2=objectMapper.readValue(objectMapper.writeValueAsString(dependency),NodeDependency.class);
  assertEquals(dependency,dependency2);
}","The original code used a standard ObjectMapper without proper configuration, which could lead to serialization/deserialization inconsistencies. The fixed code replaces ObjectMapper with JsonUtil.createObjectMapper(), which likely provides a pre-configured, more robust mapper for handling complex object serialization. This change ensures reliable JSON conversion and maintains the integrity of NodeDependency objects during serialization and deserialization processes."
38848,"@Before public void setUp() throws Exception {
  objectMapper=new ObjectMapper().registerModule(new AppStorageJsonModule());
}","@Before public void setUp() throws Exception {
  objectMapper=JsonUtil.createObjectMapper().registerModule(new AppStorageJsonModule());
}","The original code directly instantiates ObjectMapper, which lacks custom configuration for handling complex JSON serialization and deserialization. The fixed code uses JsonUtil.createObjectMapper(), a utility method that likely provides pre-configured ObjectMapper with essential settings and modules. This approach ensures consistent JSON processing across the application by centralizing mapper creation and configuration in a single, reusable utility method."
38849,"@Before public void setUp() throws Exception {
  objectMapper=new ObjectMapper().registerModule(new AppStorageJsonModule());
}","@Before public void setUp() throws Exception {
  objectMapper=JsonUtil.createObjectMapper().registerModule(new AppStorageJsonModule());
}","The original code directly instantiates ObjectMapper without considering potential custom serialization configurations or module registrations. The fixed code uses JsonUtil.createObjectMapper(), which likely provides a pre-configured ObjectMapper with standard settings and ensures consistent JSON mapping across the application. By leveraging a utility method, the code becomes more maintainable, standardized, and less prone to configuration inconsistencies."
38850,"@Before public void setUp() throws Exception {
  objectMapper=new ObjectMapper();
}","@Before public void setUp() throws Exception {
  objectMapper=JsonUtil.createObjectMapper();
}","The original code directly instantiates ObjectMapper, which lacks custom configuration and may not handle complex JSON serialization/deserialization scenarios effectively. The fixed code uses a utility method JsonUtil.createObjectMapper(), which likely provides a pre-configured, standardized ObjectMapper with optimized settings for the project. This approach ensures consistent JSON processing, improves code maintainability, and centralizes mapper configuration across the application."
38851,"public static <T>T parseJson(Reader reader,Function<JsonParser,T> function){
  Objects.requireNonNull(reader);
  Objects.requireNonNull(function);
  JsonFactory factory=new JsonFactory();
  try (JsonParser parser=factory.createParser(reader)){
    return function.apply(parser);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","public static <T>T parseJson(Reader reader,Function<JsonParser,T> function){
  Objects.requireNonNull(reader);
  Objects.requireNonNull(function);
  JsonFactory factory=createJsonFactory();
  try (JsonParser parser=factory.createParser(reader)){
    return function.apply(parser);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","The original code directly instantiates JsonFactory, which can be inefficient and potentially create unnecessary overhead for JSON parsing. The fixed code introduces a method `createJsonFactory()` which allows for potential customization, reuse, or configuration of the JsonFactory instance. This approach provides more flexibility, potentially improves performance, and follows better design principles by abstracting factory creation."
38852,"static Foo read(InputStream stream) throws IOException {
  ObjectMapper mapper=new ObjectMapper();
  SimpleModule module=new SimpleModule();
  module.addDeserializer(Foo.class,new FooDeserializer());
  mapper.registerModule(module);
  return mapper.readValue(stream,Foo.class);
}","static Foo read(InputStream stream) throws IOException {
  ObjectMapper mapper=JsonUtil.createObjectMapper();
  SimpleModule module=new SimpleModule();
  module.addDeserializer(Foo.class,new FooDeserializer());
  mapper.registerModule(module);
  return mapper.readValue(stream,Foo.class);
}","The original code uses a default ObjectMapper, which lacks custom configuration and may not handle complex deserialization scenarios consistently. The fixed code replaces the default mapper with a pre-configured JsonUtil.createObjectMapper() method, ensuring standardized JSON parsing across the application. This approach provides better control over object mapping, improves reliability, and promotes consistent deserialization behavior."
38853,"private static Contingency read(Path jsonFile){
  Objects.requireNonNull(jsonFile);
  try (InputStream is=Files.newInputStream(jsonFile)){
    ObjectMapper objectMapper=new ObjectMapper();
    SimpleModule module=new SimpleModule();
    module.addDeserializer(Contingency.class,new ContingencyDeserializer());
    module.addDeserializer(ContingencyElement.class,new ContingencyElementDeserializer());
    objectMapper.registerModule(module);
    return objectMapper.readValue(is,Contingency.class);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","private static Contingency read(Path jsonFile){
  Objects.requireNonNull(jsonFile);
  try (InputStream is=Files.newInputStream(jsonFile)){
    ObjectMapper objectMapper=JsonUtil.createObjectMapper();
    SimpleModule module=new SimpleModule();
    module.addDeserializer(Contingency.class,new ContingencyDeserializer());
    module.addDeserializer(ContingencyElement.class,new ContingencyElementDeserializer());
    objectMapper.registerModule(module);
    return objectMapper.readValue(is,Contingency.class);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","The original code creates a new ObjectMapper directly, which lacks custom configuration for JSON parsing. The fixed code uses `JsonUtil.createObjectMapper()`, likely a utility method that pre-configures the ObjectMapper with standard settings and potentially custom serialization/deserialization rules. This approach ensures consistent, robust JSON mapping across the application by centralizing mapper configuration in a utility method."
38854,"private static void write(Contingency object,Path jsonFile){
  Objects.requireNonNull(object);
  Objects.requireNonNull(jsonFile);
  try (OutputStream os=Files.newOutputStream(jsonFile)){
    ObjectMapper mapper=new ObjectMapper();
    SimpleModule module=new SimpleModule();
    module.addSerializer(ContingencyElement.class,new ContingencyElementSerializer());
    mapper.registerModule(module);
    ObjectWriter writer=mapper.writerWithDefaultPrettyPrinter();
    writer.writeValue(os,object);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","private static void write(Contingency object,Path jsonFile){
  Objects.requireNonNull(object);
  Objects.requireNonNull(jsonFile);
  try (OutputStream os=Files.newOutputStream(jsonFile)){
    ObjectMapper mapper=JsonUtil.createObjectMapper();
    SimpleModule module=new SimpleModule();
    module.addSerializer(ContingencyElement.class,new ContingencyElementSerializer());
    mapper.registerModule(module);
    ObjectWriter writer=mapper.writerWithDefaultPrettyPrinter();
    writer.writeValue(os,object);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","The original code directly instantiates an ObjectMapper without configuring it for proper JSON serialization, which might lead to inconsistent or incomplete object serialization. The fixed code replaces the direct ObjectMapper creation with a call to JsonUtil.createObjectMapper(), which likely provides a pre-configured mapper with standardized serialization settings. This change ensures more robust and consistent JSON serialization by leveraging a utility method that handles mapper configuration centrally."
38855,"public static void write(LoadFlowResult result,Path jsonFile){
  Objects.requireNonNull(result);
  Objects.requireNonNull(jsonFile);
  try (OutputStream os=Files.newOutputStream(jsonFile)){
    ObjectMapper objectMapper=new ObjectMapper();
    SimpleModule module=new SimpleModule();
    module.addSerializer(LoadFlowResult.class,new LoadFlowResultSerializer());
    objectMapper.registerModule(module);
    ObjectWriter writer=objectMapper.writerWithDefaultPrettyPrinter();
    writer.writeValue(os,result);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","public static void write(LoadFlowResult result,Path jsonFile){
  Objects.requireNonNull(result);
  Objects.requireNonNull(jsonFile);
  try (OutputStream os=Files.newOutputStream(jsonFile)){
    ObjectMapper objectMapper=JsonUtil.createObjectMapper();
    SimpleModule module=new SimpleModule();
    module.addSerializer(LoadFlowResult.class,new LoadFlowResultSerializer());
    objectMapper.registerModule(module);
    ObjectWriter writer=objectMapper.writerWithDefaultPrettyPrinter();
    writer.writeValue(os,result);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","The original code used a default ObjectMapper, which might lack custom configurations for JSON serialization. The fixed code replaces the default ObjectMapper with JsonUtil.createObjectMapper(), ensuring proper JSON mapping and potentially adding essential serialization configurations. This change guarantees more robust and consistent JSON serialization for the LoadFlowResult object."
38856,"static void parseJson(JsonParser parser,List<DoubleArrayChunk> doubleChunks,List<StringArrayChunk> stringChunks,boolean single){
  Objects.requireNonNull(parser);
  try {
    JsonParsingContext context=new JsonParsingContext(doubleChunks,stringChunks);
    JsonToken token;
    while ((token=parser.nextToken()) != null) {
switch (token) {
case FIELD_NAME:
        parseFieldName(parser,context);
      break;
case END_OBJECT:
    parseEndObject(context);
  if (single) {
    return;
  }
 else {
    break;
  }
case END_ARRAY:
if (context.valuesOrLengthArray) {
  context.valuesOrLengthArray=false;
}
 else {
  return;
}
break;
case VALUE_NUMBER_FLOAT:
context.addDoubleValue(parser.getDoubleValue());
break;
case VALUE_NUMBER_INT:
parseValueNumberInt(parser,context);
break;
case VALUE_STRING:
context.addStringValue(parser.getValueAsString());
break;
default :
break;
}
}
}
 catch (IOException e) {
throw new UncheckedIOException(e);
}
}","static void parseJson(JsonParser parser,List<DoubleArrayChunk> doubleChunks,List<StringArrayChunk> stringChunks,boolean single){
  Objects.requireNonNull(parser);
  try {
    JsonParsingContext context=new JsonParsingContext(doubleChunks,stringChunks);
    JsonToken token;
    while ((token=parser.nextToken()) != null) {
switch (token) {
case FIELD_NAME:
        parseFieldName(parser,context);
      break;
case END_OBJECT:
    parseEndObject(context);
  if (single) {
    return;
  }
 else {
    break;
  }
case END_ARRAY:
if (context.valuesOrLengthArray) {
  context.valuesOrLengthArray=false;
}
 else {
  return;
}
break;
case VALUE_NUMBER_FLOAT:
context.addDoubleValue(parser.getDoubleValue());
break;
case VALUE_NUMBER_INT:
parseValueNumberInt(parser,context);
break;
case VALUE_STRING:
context.addStringValue(parser.getValueAsString());
break;
case VALUE_NULL:
context.addStringValue(null);
break;
default :
break;
}
}
}
 catch (IOException e) {
throw new UncheckedIOException(e);
}
}","The original code lacked handling for null values when parsing JSON, which could lead to unexpected parsing behavior or errors when encountering null fields. The fixed code adds a `VALUE_NULL` case that explicitly calls `context.addStringValue(null)`, allowing proper processing of null string values during JSON parsing. This enhancement improves the code's robustness by ensuring consistent handling of all potential JSON value types, including null values."
38857,"static void addCompressedChunk(JsonParsingContext context){
  if (context.doubleValues != null) {
    context.doubleChunks.add(new CompressedDoubleArrayChunk(context.offset,context.uncompressedLength,context.doubleValues.toArray(),context.stepLengths.toArray()));
    context.doubleValues=null;
    context.stepLengths=null;
    context.uncompressedLength=-1;
  }
 else   if (context.stringValues != null) {
    context.stringChunks.add(new CompressedStringArrayChunk(context.offset,context.uncompressedLength,context.stringValues.toArray(new String[context.stringValues.size()]),context.stepLengths.toArray()));
    context.stringValues=null;
    context.stepLengths=null;
    context.uncompressedLength=-1;
  }
 else {
    throw new AssertionError(""String_Node_Str"");
  }
}","static void addCompressedChunk(JsonParsingContext context){
  if (context.doubleValues != null && context.stringValues == null) {
    context.doubleChunks.add(new CompressedDoubleArrayChunk(context.offset,context.uncompressedLength,context.doubleValues.toArray(),context.stepLengths.toArray()));
    context.doubleValues=null;
    context.stepLengths=null;
    context.uncompressedLength=-1;
  }
 else   if (context.stringValues != null && context.doubleValues == null) {
    context.stringChunks.add(new CompressedStringArrayChunk(context.offset,context.uncompressedLength,context.stringValues.toArray(new String[context.stringValues.size()]),context.stepLengths.toArray()));
    context.stringValues=null;
    context.stepLengths=null;
    context.uncompressedLength=-1;
  }
 else   if (context.stringValues != null && context.doubleValues != null) {
    throw new AssertionError(""String_Node_Str"");
  }
 else {
    throw new AssertionError(""String_Node_Str"");
  }
}","The original code lacked proper validation, potentially allowing concurrent population of both doubleValues and stringValues. The fixed code adds explicit checks to ensure only one type of values is processed at a time, with an additional error condition if both are non-null. This prevents ambiguous parsing scenarios and provides clearer, more robust error handling during JSON chunk compression."
38858,"static void addUncompressedChunk(JsonParsingContext context){
  if (context.doubleValues != null) {
    context.doubleChunks.add(new UncompressedDoubleArrayChunk(context.offset,context.doubleValues.toArray()));
  }
 else   if (context.stringValues != null) {
    context.stringChunks.add(new UncompressedStringArrayChunk(context.offset,context.stringValues.toArray(new String[context.stringValues.size()])));
  }
 else {
    throw new AssertionError(""String_Node_Str"");
  }
}","static void addUncompressedChunk(JsonParsingContext context){
  if (context.doubleValues != null && context.stringValues == null) {
    context.doubleChunks.add(new UncompressedDoubleArrayChunk(context.offset,context.doubleValues.toArray()));
  }
 else   if (context.stringValues != null && context.doubleValues == null) {
    context.stringChunks.add(new UncompressedStringArrayChunk(context.offset,context.stringValues.toArray(new String[context.stringValues.size()])));
  }
 else   if (context.stringValues != null && context.doubleValues != null) {
    throw new AssertionError(""String_Node_Str"");
  }
 else {
    throw new AssertionError(""String_Node_Str"");
  }
}","The original code lacked proper validation, potentially allowing simultaneous processing of both double and string values, which could lead to unexpected behavior. The fixed code adds explicit null checks for both doubleValues and stringValues, ensuring only one type of chunk is added at a time and throwing an assertion error if both are non-null or both are null. This approach prevents ambiguous parsing scenarios and provides clearer, more predictable handling of different value types during JSON parsing."
38859,"@Test public void compressTest() throws IOException {
  UncompressedDoubleArrayChunk chunk=new UncompressedDoubleArrayChunk(1,new double[]{1d,2d,2d,2d,2d,3d});
  DoubleArrayChunk maybeCompressedChunk=chunk.tryToCompress();
  assertTrue(maybeCompressedChunk instanceof CompressedDoubleArrayChunk);
  CompressedDoubleArrayChunk compressedChunk=(CompressedDoubleArrayChunk)maybeCompressedChunk;
  assertEquals(1,compressedChunk.getOffset());
  assertEquals(6,compressedChunk.getLength());
  assertTrue(compressedChunk.isCompressed());
  assertEquals(36,compressedChunk.getEstimatedSize());
  assertEquals(36d / 48,compressedChunk.getCompressionFactor(),0d);
  assertArrayEquals(new double[]{1d,2d,3d},compressedChunk.getStepValues(),0d);
  assertArrayEquals(new int[]{1,4,1},compressedChunk.getStepLengths());
  DoubleBuffer buffer=DoubleBuffer.allocate(7);
  for (int i=0; i < 7; i++) {
    buffer.put(i,Double.NaN);
  }
  compressedChunk.fillBuffer(buffer,0);
  assertArrayEquals(new double[]{Double.NaN,1d,2d,2d,2d,2d,3d},buffer.array(),0d);
  String jsonRef=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(jsonRef,JsonUtil.toJson(compressedChunk::writeJson));
  ObjectMapper objectMapper=new ObjectMapper().registerModule(new TimeSeriesJsonModule());
  List<DoubleArrayChunk> chunks=objectMapper.readValue(objectMapper.writeValueAsString(Arrays.asList(chunk,compressedChunk)),TypeFactory.defaultInstance().constructCollectionType(List.class,DoubleArrayChunk.class));
  assertEquals(2,chunks.size());
  assertEquals(chunk,chunks.get(0));
  assertEquals(compressedChunk,chunks.get(1));
  assertTrue(objectMapper.readValue(objectMapper.writeValueAsString(chunk),ArrayChunk.class) instanceof DoubleArrayChunk);
  RegularTimeSeriesIndex index=RegularTimeSeriesIndex.create(Interval.parse(""String_Node_Str""),Duration.ofMinutes(15));
  assertEquals(ImmutableList.of(new DoublePoint(1,Instant.parse(""String_Node_Str"").toEpochMilli(),1d),new DoublePoint(2,Instant.parse(""String_Node_Str"").toEpochMilli(),2d),new DoublePoint(6,Instant.parse(""String_Node_Str"").toEpochMilli(),3d)),compressedChunk.stream(index).collect(Collectors.toList()));
}","@Test public void compressTest() throws IOException {
  UncompressedDoubleArrayChunk chunk=new UncompressedDoubleArrayChunk(1,new double[]{1d,2d,2d,2d,2d,3d});
  DoubleArrayChunk maybeCompressedChunk=chunk.tryToCompress();
  assertTrue(maybeCompressedChunk instanceof CompressedDoubleArrayChunk);
  CompressedDoubleArrayChunk compressedChunk=(CompressedDoubleArrayChunk)maybeCompressedChunk;
  assertEquals(1,compressedChunk.getOffset());
  assertEquals(6,compressedChunk.getLength());
  assertTrue(compressedChunk.isCompressed());
  assertEquals(36,compressedChunk.getEstimatedSize());
  assertEquals(36d / 48,compressedChunk.getCompressionFactor(),0d);
  assertArrayEquals(new double[]{1d,2d,3d},compressedChunk.getStepValues(),0d);
  assertArrayEquals(new int[]{1,4,1},compressedChunk.getStepLengths());
  DoubleBuffer buffer=DoubleBuffer.allocate(7);
  for (int i=0; i < 7; i++) {
    buffer.put(i,Double.NaN);
  }
  compressedChunk.fillBuffer(buffer,0);
  assertArrayEquals(new double[]{Double.NaN,1d,2d,2d,2d,2d,3d},buffer.array(),0d);
  String jsonRef=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(jsonRef,JsonUtil.toJson(compressedChunk::writeJson));
  ObjectMapper objectMapper=JsonUtil.createObjectMapper().registerModule(new TimeSeriesJsonModule());
  List<DoubleArrayChunk> chunks=objectMapper.readValue(objectMapper.writeValueAsString(Arrays.asList(chunk,compressedChunk)),TypeFactory.defaultInstance().constructCollectionType(List.class,DoubleArrayChunk.class));
  assertEquals(2,chunks.size());
  assertEquals(chunk,chunks.get(0));
  assertEquals(compressedChunk,chunks.get(1));
  assertTrue(objectMapper.readValue(objectMapper.writeValueAsString(chunk),ArrayChunk.class) instanceof DoubleArrayChunk);
  RegularTimeSeriesIndex index=RegularTimeSeriesIndex.create(Interval.parse(""String_Node_Str""),Duration.ofMinutes(15));
  assertEquals(ImmutableList.of(new DoublePoint(1,Instant.parse(""String_Node_Str"").toEpochMilli(),1d),new DoublePoint(2,Instant.parse(""String_Node_Str"").toEpochMilli(),2d),new DoublePoint(6,Instant.parse(""String_Node_Str"").toEpochMilli(),3d)),compressedChunk.stream(index).collect(Collectors.toList()));
}","The original code used a direct `new ObjectMapper()` constructor, which lacks proper configuration for JSON serialization. The fixed code replaces this with `JsonUtil.createObjectMapper()`, which likely provides pre-configured JSON mapping with necessary modules and settings. This change ensures more robust and consistent JSON serialization and deserialization, particularly for complex time series data structures."
38860,"@Test public void test() throws IOException {
  RegularTimeSeriesIndex index=RegularTimeSeriesIndex.create(Interval.parse(""String_Node_Str""),Duration.ofMinutes(15));
  TimeSeriesMetadata metadata=new TimeSeriesMetadata(""String_Node_Str"",TimeSeriesDataType.DOUBLE,Collections.emptyMap(),index);
  UncompressedDoubleArrayChunk chunk=new UncompressedDoubleArrayChunk(2,new double[]{1d,2d});
  CompressedDoubleArrayChunk chunk2=new CompressedDoubleArrayChunk(5,3,new double[]{3d,4d},new int[]{1,2});
  assertEquals(TimeSeriesDataType.DOUBLE,chunk.getDataType());
  StoredDoubleTimeSeries timeSeries=new StoredDoubleTimeSeries(metadata,chunk,chunk2);
  assertSame(metadata,timeSeries.getMetadata());
  assertEquals(Arrays.asList(chunk,chunk2),timeSeries.getChunks());
  assertArrayEquals(new double[]{Double.NaN,Double.NaN,1d,2d,Double.NaN,3d,4d,4d},timeSeries.toArray(),0d);
  DoublePoint[] pointsRef={new DoublePoint(0,Instant.parse(""String_Node_Str"").toEpochMilli(),Double.NaN),new DoublePoint(2,Instant.parse(""String_Node_Str"").toEpochMilli(),1d),new DoublePoint(3,Instant.parse(""String_Node_Str"").toEpochMilli(),2d),new DoublePoint(4,Instant.parse(""String_Node_Str"").toEpochMilli(),Double.NaN),new DoublePoint(5,Instant.parse(""String_Node_Str"").toEpochMilli(),3d),new DoublePoint(6,Instant.parse(""String_Node_Str"").toEpochMilli(),4d)};
  assertArrayEquals(pointsRef,timeSeries.stream().toArray());
  assertArrayEquals(pointsRef,Iterators.toArray(timeSeries.iterator(),DoublePoint.class));
  String jsonRef=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String json=JsonUtil.toJson(timeSeries::writeJson);
  assertEquals(jsonRef,json);
  List<TimeSeries> timeSeriesList=TimeSeries.parseJson(json);
  assertEquals(1,timeSeriesList.size());
  String json2=JsonUtil.toJson(timeSeriesList.get(0)::writeJson);
  assertEquals(json,json2);
  ObjectMapper objectMapper=new ObjectMapper().registerModule(new TimeSeriesJsonModule());
  assertEquals(timeSeries,objectMapper.readValue(objectMapper.writeValueAsString(timeSeries),DoubleTimeSeries.class));
}","@Test public void test() throws IOException {
  RegularTimeSeriesIndex index=RegularTimeSeriesIndex.create(Interval.parse(""String_Node_Str""),Duration.ofMinutes(15));
  TimeSeriesMetadata metadata=new TimeSeriesMetadata(""String_Node_Str"",TimeSeriesDataType.DOUBLE,Collections.emptyMap(),index);
  UncompressedDoubleArrayChunk chunk=new UncompressedDoubleArrayChunk(2,new double[]{1d,2d});
  CompressedDoubleArrayChunk chunk2=new CompressedDoubleArrayChunk(5,3,new double[]{3d,4d},new int[]{1,2});
  assertEquals(TimeSeriesDataType.DOUBLE,chunk.getDataType());
  StoredDoubleTimeSeries timeSeries=new StoredDoubleTimeSeries(metadata,chunk,chunk2);
  assertSame(metadata,timeSeries.getMetadata());
  assertEquals(Arrays.asList(chunk,chunk2),timeSeries.getChunks());
  assertArrayEquals(new double[]{Double.NaN,Double.NaN,1d,2d,Double.NaN,3d,4d,4d},timeSeries.toArray(),0d);
  DoublePoint[] pointsRef={new DoublePoint(0,Instant.parse(""String_Node_Str"").toEpochMilli(),Double.NaN),new DoublePoint(2,Instant.parse(""String_Node_Str"").toEpochMilli(),1d),new DoublePoint(3,Instant.parse(""String_Node_Str"").toEpochMilli(),2d),new DoublePoint(4,Instant.parse(""String_Node_Str"").toEpochMilli(),Double.NaN),new DoublePoint(5,Instant.parse(""String_Node_Str"").toEpochMilli(),3d),new DoublePoint(6,Instant.parse(""String_Node_Str"").toEpochMilli(),4d)};
  assertArrayEquals(pointsRef,timeSeries.stream().toArray());
  assertArrayEquals(pointsRef,Iterators.toArray(timeSeries.iterator(),DoublePoint.class));
  String jsonRef=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String json=JsonUtil.toJson(timeSeries::writeJson);
  assertEquals(jsonRef,json);
  List<TimeSeries> timeSeriesList=TimeSeries.parseJson(json);
  assertEquals(1,timeSeriesList.size());
  String json2=JsonUtil.toJson(timeSeriesList.get(0)::writeJson);
  assertEquals(json,json2);
  ObjectMapper objectMapper=JsonUtil.createObjectMapper().registerModule(new TimeSeriesJsonModule());
  assertEquals(timeSeries,objectMapper.readValue(objectMapper.writeValueAsString(timeSeries),DoubleTimeSeries.class));
}","The original code used an incorrect method to create an ObjectMapper, which could lead to serialization and deserialization issues. The fixed code replaces `new ObjectMapper()` with `JsonUtil.createObjectMapper()`, ensuring proper configuration and handling of time series JSON operations. This change guarantees consistent and reliable JSON processing for time series data, improving the robustness of the serialization and deserialization mechanism."
38861,"@Test public void baseTest() throws IOException {
  UncompressedStringArrayChunk chunk=new UncompressedStringArrayChunk(1,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  assertEquals(1,chunk.getOffset());
  assertEquals(3,chunk.getLength());
  assertArrayEquals(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},chunk.getValues());
  assertEquals(6,chunk.getEstimatedSize());
  assertFalse(chunk.isCompressed());
  assertEquals(1d,chunk.getCompressionFactor(),0d);
  CompactStringBuffer buffer=new CompactStringBuffer(4);
  chunk.fillBuffer(buffer,0);
  assertArrayEquals(new String[]{null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},buffer.toArray());
  String jsonRef=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(jsonRef,JsonUtil.toJson(chunk::writeJson));
  ObjectMapper objectMapper=new ObjectMapper().registerModule(new TimeSeriesJsonModule());
  List<StringArrayChunk> chunks=objectMapper.readValue(objectMapper.writeValueAsString(Arrays.asList(chunk)),TypeFactory.defaultInstance().constructCollectionType(List.class,StringArrayChunk.class));
  assertEquals(1,chunks.size());
  assertEquals(chunk,chunks.get(0));
  assertTrue(objectMapper.readValue(objectMapper.writeValueAsString(chunk),ArrayChunk.class) instanceof StringArrayChunk);
  RegularTimeSeriesIndex index=RegularTimeSeriesIndex.create(Interval.parse(""String_Node_Str""),Duration.ofMinutes(15));
  assertEquals(ImmutableList.of(new StringPoint(1,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str""),new StringPoint(2,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str""),new StringPoint(3,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str"")),chunk.stream(index).collect(Collectors.toList()));
}","@Test public void baseTest() throws IOException {
  UncompressedStringArrayChunk chunk=new UncompressedStringArrayChunk(1,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  assertEquals(1,chunk.getOffset());
  assertEquals(3,chunk.getLength());
  assertArrayEquals(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},chunk.getValues());
  assertEquals(6,chunk.getEstimatedSize());
  assertFalse(chunk.isCompressed());
  assertEquals(1d,chunk.getCompressionFactor(),0d);
  CompactStringBuffer buffer=new CompactStringBuffer(4);
  chunk.fillBuffer(buffer,0);
  assertArrayEquals(new String[]{null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},buffer.toArray());
  String jsonRef=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(jsonRef,JsonUtil.toJson(chunk::writeJson));
  ObjectMapper objectMapper=JsonUtil.createObjectMapper().registerModule(new TimeSeriesJsonModule());
  List<StringArrayChunk> chunks=objectMapper.readValue(objectMapper.writeValueAsString(Arrays.asList(chunk)),TypeFactory.defaultInstance().constructCollectionType(List.class,StringArrayChunk.class));
  assertEquals(1,chunks.size());
  assertEquals(chunk,chunks.get(0));
  assertTrue(objectMapper.readValue(objectMapper.writeValueAsString(chunk),ArrayChunk.class) instanceof StringArrayChunk);
  RegularTimeSeriesIndex index=RegularTimeSeriesIndex.create(Interval.parse(""String_Node_Str""),Duration.ofMinutes(15));
  assertEquals(ImmutableList.of(new StringPoint(1,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str""),new StringPoint(2,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str""),new StringPoint(3,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str"")),chunk.stream(index).collect(Collectors.toList()));
}","The original code used a standard ObjectMapper constructor, which might lack necessary configuration for complex serialization. The fixed code replaces it with `JsonUtil.createObjectMapper()`, which likely provides pre-configured JSON mapping with appropriate modules and settings. This change ensures robust JSON serialization and deserialization for complex time series data structures, improving reliability and compatibility."
38862,"@Test public void test() throws IOException {
  RegularTimeSeriesIndex index=RegularTimeSeriesIndex.create(Interval.parse(""String_Node_Str""),Duration.ofMinutes(15));
  TimeSeriesMetadata metadata=new TimeSeriesMetadata(""String_Node_Str"",TimeSeriesDataType.STRING,Collections.emptyMap(),index);
  UncompressedStringArrayChunk chunk=new UncompressedStringArrayChunk(2,new String[]{""String_Node_Str"",""String_Node_Str""});
  CompressedStringArrayChunk chunk2=new CompressedStringArrayChunk(5,3,new String[]{""String_Node_Str"",""String_Node_Str""},new int[]{1,2});
  assertEquals(TimeSeriesDataType.STRING,chunk.getDataType());
  StringTimeSeries timeSeries=new StringTimeSeries(metadata,chunk,chunk2);
  assertSame(metadata,timeSeries.getMetadata());
  assertEquals(Arrays.asList(chunk,chunk2),timeSeries.getChunks());
  assertArrayEquals(new String[]{null,null,""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},timeSeries.toArray());
  StringPoint[] pointsRef={new StringPoint(0,Instant.parse(""String_Node_Str"").toEpochMilli(),null),new StringPoint(2,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str""),new StringPoint(3,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str""),new StringPoint(4,Instant.parse(""String_Node_Str"").toEpochMilli(),null),new StringPoint(5,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str""),new StringPoint(6,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str"")};
  assertArrayEquals(pointsRef,timeSeries.stream().toArray());
  assertArrayEquals(pointsRef,Iterators.toArray(timeSeries.iterator(),StringPoint.class));
  String jsonRef=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String json=JsonUtil.toJson(timeSeries::writeJson);
  assertEquals(jsonRef,json);
  List<TimeSeries> timeSeriesList=TimeSeries.parseJson(json);
  assertEquals(1,timeSeriesList.size());
  String json2=JsonUtil.toJson(timeSeriesList.get(0)::writeJson);
  assertEquals(json,json2);
  ObjectMapper objectMapper=new ObjectMapper().registerModule(new TimeSeriesJsonModule());
  assertEquals(timeSeries,objectMapper.readValue(objectMapper.writeValueAsString(timeSeries),StringTimeSeries.class));
}","@Test public void test() throws IOException {
  RegularTimeSeriesIndex index=RegularTimeSeriesIndex.create(Interval.parse(""String_Node_Str""),Duration.ofMinutes(15));
  TimeSeriesMetadata metadata=new TimeSeriesMetadata(""String_Node_Str"",TimeSeriesDataType.STRING,Collections.emptyMap(),index);
  UncompressedStringArrayChunk chunk=new UncompressedStringArrayChunk(2,new String[]{""String_Node_Str"",""String_Node_Str""});
  CompressedStringArrayChunk chunk2=new CompressedStringArrayChunk(5,3,new String[]{""String_Node_Str"",""String_Node_Str""},new int[]{1,2});
  assertEquals(TimeSeriesDataType.STRING,chunk.getDataType());
  StringTimeSeries timeSeries=new StringTimeSeries(metadata,chunk,chunk2);
  assertSame(metadata,timeSeries.getMetadata());
  assertEquals(Arrays.asList(chunk,chunk2),timeSeries.getChunks());
  assertArrayEquals(new String[]{null,null,""String_Node_Str"",""String_Node_Str"",null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},timeSeries.toArray());
  StringPoint[] pointsRef={new StringPoint(0,Instant.parse(""String_Node_Str"").toEpochMilli(),null),new StringPoint(2,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str""),new StringPoint(3,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str""),new StringPoint(4,Instant.parse(""String_Node_Str"").toEpochMilli(),null),new StringPoint(5,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str""),new StringPoint(6,Instant.parse(""String_Node_Str"").toEpochMilli(),""String_Node_Str"")};
  assertArrayEquals(pointsRef,timeSeries.stream().toArray());
  assertArrayEquals(pointsRef,Iterators.toArray(timeSeries.iterator(),StringPoint.class));
  String jsonRef=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String json=JsonUtil.toJson(timeSeries::writeJson);
  assertEquals(jsonRef,json);
  List<TimeSeries> timeSeriesList=TimeSeries.parseJson(json);
  assertEquals(1,timeSeriesList.size());
  String json2=JsonUtil.toJson(timeSeriesList.get(0)::writeJson);
  assertEquals(json,json2);
  ObjectMapper objectMapper=JsonUtil.createObjectMapper().registerModule(new TimeSeriesJsonModule());
  assertEquals(timeSeries,objectMapper.readValue(objectMapper.writeValueAsString(timeSeries),StringTimeSeries.class));
}","The original code used an incorrect method to create an ObjectMapper, which could lead to serialization and deserialization issues. The fixed code replaces `new ObjectMapper()` with `JsonUtil.createObjectMapper()`, ensuring proper configuration of the JSON mapper with necessary settings. This change guarantees consistent and reliable JSON processing for time series data, improving the robustness of object serialization and deserialization."
38863,"@Test public void test() throws IOException {
  RegularTimeSeriesIndex index=RegularTimeSeriesIndex.create(Interval.parse(""String_Node_Str""),Duration.ofMinutes(15));
  ImmutableMap<String,String> tags=ImmutableMap.of(""String_Node_Str"",""String_Node_Str"");
  TimeSeriesMetadata metadata=new TimeSeriesMetadata(""String_Node_Str"",TimeSeriesDataType.DOUBLE,tags,index);
  assertEquals(""String_Node_Str"",metadata.getName());
  assertEquals(TimeSeriesDataType.DOUBLE,metadata.getDataType());
  assertEquals(tags,metadata.getTags());
  assertSame(index,metadata.getIndex());
  assertEquals(""String_Node_Str"",metadata.toString());
  String jsonRef=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String json=JsonUtil.toJson(metadata::writeJson);
  assertEquals(jsonRef,json);
  TimeSeriesMetadata metadata2=JsonUtil.parseJson(json,TimeSeriesMetadata::parseJson);
  assertNotNull(metadata2);
  assertEquals(metadata,metadata2);
  ObjectMapper objectMapper=new ObjectMapper().registerModule(new TimeSeriesJsonModule());
  assertEquals(metadata,objectMapper.readValue(objectMapper.writeValueAsString(metadata),TimeSeriesMetadata.class));
  List<TimeSeriesMetadata> metadataList=objectMapper.readValue(objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(Arrays.asList(metadata,metadata)),TypeFactory.defaultInstance().constructCollectionType(List.class,TimeSeriesMetadata.class));
  assertEquals(2,metadataList.size());
  assertEquals(metadata,metadataList.get(0));
  assertEquals(metadata,metadataList.get(1));
}","@Test public void test() throws IOException {
  RegularTimeSeriesIndex index=RegularTimeSeriesIndex.create(Interval.parse(""String_Node_Str""),Duration.ofMinutes(15));
  ImmutableMap<String,String> tags=ImmutableMap.of(""String_Node_Str"",""String_Node_Str"");
  TimeSeriesMetadata metadata=new TimeSeriesMetadata(""String_Node_Str"",TimeSeriesDataType.DOUBLE,tags,index);
  assertEquals(""String_Node_Str"",metadata.getName());
  assertEquals(TimeSeriesDataType.DOUBLE,metadata.getDataType());
  assertEquals(tags,metadata.getTags());
  assertSame(index,metadata.getIndex());
  assertEquals(""String_Node_Str"",metadata.toString());
  String jsonRef=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String json=JsonUtil.toJson(metadata::writeJson);
  assertEquals(jsonRef,json);
  TimeSeriesMetadata metadata2=JsonUtil.parseJson(json,TimeSeriesMetadata::parseJson);
  assertNotNull(metadata2);
  assertEquals(metadata,metadata2);
  ObjectMapper objectMapper=JsonUtil.createObjectMapper().registerModule(new TimeSeriesJsonModule());
  assertEquals(metadata,objectMapper.readValue(objectMapper.writeValueAsString(metadata),TimeSeriesMetadata.class));
  List<TimeSeriesMetadata> metadataList=objectMapper.readValue(objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(Arrays.asList(metadata,metadata)),TypeFactory.defaultInstance().constructCollectionType(List.class,TimeSeriesMetadata.class));
  assertEquals(2,metadataList.size());
  assertEquals(metadata,metadataList.get(0));
  assertEquals(metadata,metadataList.get(1));
}","The original code used a default ObjectMapper, which might lack necessary configuration for handling time series metadata serialization. The fixed code replaces this with `JsonUtil.createObjectMapper()`, which likely provides a pre-configured mapper with appropriate serialization settings for time series objects. This change ensures proper JSON conversion and deserialization of TimeSeriesMetadata, improving reliability and consistency in JSON processing."
38864,"public static SecurityAnalysisResult read(Path jsonFile){
  Objects.requireNonNull(jsonFile);
  try (InputStream is=Files.newInputStream(jsonFile)){
    ObjectMapper objectMapper=new ObjectMapper().enable(DeserializationFeature.READ_ENUMS_USING_TO_STRING).registerModule(new SecurityAnalysisJsonModule());
    return objectMapper.readValue(is,SecurityAnalysisResult.class);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","public static SecurityAnalysisResult read(Path jsonFile){
  Objects.requireNonNull(jsonFile);
  try (InputStream is=Files.newInputStream(jsonFile)){
    ObjectMapper objectMapper=JsonUtil.createObjectMapper().registerModule(new SecurityAnalysisJsonModule());
    return objectMapper.readValue(is,SecurityAnalysisResult.class);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","The original code manually configured ObjectMapper with a potentially problematic enum deserialization setting, which could lead to unexpected parsing behavior. The fixed code replaces this with a centralized JsonUtil method that likely provides a standardized, pre-configured ObjectMapper with safe default settings. By delegating mapper creation to a utility method, the code becomes more maintainable, consistent, and less prone to configuration errors across different JSON parsing scenarios."
38865,"public static void write(SecurityAnalysisResult result,Writer writer) throws IOException {
  Objects.requireNonNull(result);
  Objects.requireNonNull(writer);
  ObjectMapper objectMapper=new ObjectMapper().registerModule(new SecurityAnalysisJsonModule());
  ObjectWriter objectWriter=objectMapper.writerWithDefaultPrettyPrinter();
  objectWriter.writeValue(writer,result);
}","public static void write(SecurityAnalysisResult result,Writer writer) throws IOException {
  Objects.requireNonNull(result);
  Objects.requireNonNull(writer);
  ObjectMapper objectMapper=JsonUtil.createObjectMapper().registerModule(new SecurityAnalysisJsonModule());
  ObjectWriter objectWriter=objectMapper.writerWithDefaultPrettyPrinter();
  objectWriter.writeValue(writer,result);
}","The original code directly creates an ObjectMapper without leveraging a potentially pre-configured JSON utility method, which might miss custom serialization configurations. The fixed code uses `JsonUtil.createObjectMapper()` to ensure consistent object mapping with potentially predefined settings like date formats or custom serializers. This approach provides a more robust and standardized way of creating the ObjectMapper, improving code maintainability and ensuring consistent JSON serialization across the application."
38866,"@Override public MpiStatistics create(Path dbDir,String dbName){
  try {
    return new CsvMpiStatistics(dbDir,dbName);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","@Override public MpiStatistics create(Path dbDir,String dbName){
  if (dbDir == null || dbName == null) {
    return new NoMpiStatistics();
  }
  try {
    return new CsvMpiStatistics(dbDir,dbName);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","The original code lacks null input validation, risking potential NullPointerExceptions when creating MPI statistics with null directory or name parameters. The fixed code adds a null check that returns a NoMpiStatistics instance when either dbDir or dbName is null, preventing runtime errors and providing a safe default behavior. This approach enhances robustness by gracefully handling invalid inputs without breaking the method's execution flow."
38867,"public MpiComputationManager(Path localDir,MpiJobScheduler scheduler,MpiStatistics statistics,MpiExecutorContext executorContext){
  this.localDir=Objects.requireNonNull(localDir);
  this.statistics=Objects.requireNonNull(statistics);
  this.executorContext=Objects.requireNonNull(executorContext);
  this.scheduler=scheduler;
  if (executorContext.getMonitorExecutor() != null) {
    busyCoresPrintTask=executorContext.getMonitorExecutor().scheduleAtFixedRate(() -> LOGGER.info(""String_Node_Str"",scheduler.getResources().getBusyCores(),scheduler.getResources().getAvailableCores(),((float)scheduler.getStartedTasksAndReset()) / LOG_DELAY),0,LOG_DELAY,TimeUnit.SECONDS);
  }
}","public MpiComputationManager(Path localDir,MpiJobScheduler scheduler,MpiExecutorContext executorContext){
  this.localDir=Objects.requireNonNull(localDir);
  this.executorContext=Objects.requireNonNull(executorContext);
  this.scheduler=scheduler;
  if (executorContext.getMonitorExecutor() != null) {
    busyCoresPrintTask=executorContext.getMonitorExecutor().scheduleAtFixedRate(() -> LOGGER.info(""String_Node_Str"",scheduler.getResources().getBusyCores(),scheduler.getResources().getAvailableCores(),((float)scheduler.getStartedTasksAndReset()) / LOG_DELAY),0,LOG_DELAY,TimeUnit.SECONDS);
  }
}","The original code incorrectly included an unnecessary `MpiStatistics` parameter, which was not used in the constructor or method body. The fixed code removes the unused `statistics` parameter and its corresponding assignment, simplifying the constructor signature and eliminating potential confusion. By removing the redundant parameter, the code becomes cleaner, more focused, and reduces unnecessary complexity in the class initialization."
38868,"@Override public void close(){
  try {
    scheduler.shutdown();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  try {
    statistics.close();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  if (busyCoresPrintTask != null) {
    busyCoresPrintTask.cancel(true);
  }
  try {
    executorContext.shutdown();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
}","@Override public void close(){
  try {
    scheduler.shutdown();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  if (busyCoresPrintTask != null) {
    busyCoresPrintTask.cancel(true);
  }
  try {
    executorContext.shutdown();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
}","The original code attempted to close multiple resources sequentially but included a potentially redundant or problematic `statistics.close()` method that might cause unnecessary exception handling. The fixed code removes the `statistics.close()` block, streamlining the resource shutdown process and reducing potential error points. This simplification ensures a more robust and focused resource cleanup mechanism without introducing unnecessary complexity or risk of interrupting the shutdown sequence."
38869,"MpiJobSchedulerImpl(MpiNativeServices nativeServices,MpiStatistics statistics,final int coresPerRank,boolean verbose,ExecutorService executor,Path stdOutArchive) throws InterruptedException, IOException {
  this.nativeServices=Objects.requireNonNull(nativeServices);
  this.statistics=Objects.requireNonNull(statistics);
  if (stdOutArchive != null) {
    if (Files.exists(stdOutArchive)) {
      if (!Files.isRegularFile(stdOutArchive)) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      Files.deleteIfExists(stdOutArchive);
    }
    LOGGER.info(""String_Node_Str"",stdOutArchive);
  }
  this.stdOutArchive=stdOutArchive;
  final CountDownLatch initialized=new CountDownLatch(1);
  future=executor.submit(new Runnable(){
    @Override public void run(){
      LOGGER.trace(""String_Node_Str"");
      try {
        nativeServices.initMpi(coresPerRank,verbose);
        mpiVersion=nativeServices.getMpiVersion();
        resources=new MpiResources(nativeServices.getMpiCommSize(),coresPerRank);
        initialized.countDown();
        long time=System.currentTimeMillis();
        List<MpiTask> completedTasks=new ArrayList<>();
        while (!stopRequested || !jobs.isEmpty()) {
          boolean sleep=true;
          long oldTime=time;
          time=System.currentTimeMillis();
          long diff=time - oldTime;
          if (diff > 1000) {
            LOGGER.warn(""String_Node_Str"",diff,startTasksTime,startTasksJniTime,processCompletedTasksTime,checkTaskCompletionTime);
          }
          startTasksTime=0;
          startTasksJniTime=0;
          processCompletedTasksTime=0;
          checkTaskCompletionTime=0;
          newCommonFileLock.lock();
          try {
            for (            CommonFile commonFile : newCommonFiles) {
              LOGGER.info(""String_Node_Str"",commonFile.getChunk(),commonFile.getName(),commonFile.isLast());
              List<Core> allCores=resources.reserveAllCoresOrFail();
              try {
                try (ByteArrayInputStream is=new ByteArrayInputStream(commonFile.getData())){
                  Messages.CommonFile message=Messages.CommonFile.newBuilder().setName(commonFile.getName()).setChunk(commonFile.getChunk()).setLast(commonFile.isLast()).setData(ByteString.readFrom(is)).build();
                  long t1=System.currentTimeMillis();
                  nativeServices.sendCommonFile(message.toByteArray());
                  long t2=System.currentTimeMillis();
                  commonFiles.add(commonFile.getName());
                  MpiJobSchedulerImpl.this.statistics.logCommonFileTransfer(commonFile.getName(),commonFile.getChunk(),commonFile.getData().length,t2 - t1);
                }
               }
  finally {
                resources.releaseCores(allCores);
              }
            }
            newCommonFiles.clear();
          }
  finally {
            newCommonFileLock.unlock();
          }
          newJobsLock.lock();
          try {
            jobs.addAll(newJobs);
            newJobs.clear();
          }
  finally {
            newJobsLock.unlock();
          }
          for (Iterator<MpiJob> it=jobs.iterator(); it.hasNext(); ) {
            MpiJob job=it.next();
            sleep=startTasks(job);
            long t0=System.currentTimeMillis();
            try {
              nativeServices.checkTasksCompletion(job.getRunningTasks(),completedTasks);
            }
  finally {
              checkTaskCompletionTime+=System.currentTimeMillis() - t0;
            }
            if (!completedTasks.isEmpty()) {
              DateTime endTime=DateTime.now();
              for (              MpiTask tasks : completedTasks) {
                MpiJobSchedulerImpl.this.resources.releaseCore(tasks.getCore());
                tasks.setEndTime(endTime);
              }
              startTasks(job);
              processCompletedTasks(job,completedTasks);
              if (job.isCompleted()) {
                it.remove();
                ExecutionReport report=new ExecutionReport(job.getErrors());
                try {
                  job.getListener().onEnd(report);
                }
 catch (                Exception e) {
                  LOGGER.error(e.toString(),e);
                }
                job.getFuture().complete(report);
                MpiJobSchedulerImpl.this.statistics.logJobEnd(job.getId());
              }
              sleep=false;
            }
          }
          if (sleep) {
            TimeUnit.MILLISECONDS.sleep(TIMEOUT);
          }
        }
        nativeServices.terminateMpi();
      }
 catch (      Throwable t) {
        LOGGER.error(t.toString(),t);
        System.exit(-1);
      }
      LOGGER.trace(""String_Node_Str"");
    }
  }
);
  initialized.await();
}","MpiJobSchedulerImpl(MpiNativeServices nativeServices,MpiStatisticsFactory statisticsFactory,Path statisticsDbDir,String statisticsDbName,int coresPerRank,boolean verbose,ExecutorService executor,Path stdOutArchive) throws InterruptedException, IOException {
  this.nativeServices=Objects.requireNonNull(nativeServices);
  this.statistics=Objects.requireNonNull(statisticsFactory).create(statisticsDbDir,statisticsDbName);
  if (stdOutArchive != null) {
    if (Files.exists(stdOutArchive)) {
      if (!Files.isRegularFile(stdOutArchive)) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      Files.deleteIfExists(stdOutArchive);
    }
    LOGGER.info(""String_Node_Str"",stdOutArchive);
  }
  this.stdOutArchive=stdOutArchive;
  final CountDownLatch initialized=new CountDownLatch(1);
  future=executor.submit(new Runnable(){
    @Override public void run(){
      LOGGER.trace(""String_Node_Str"");
      try {
        nativeServices.initMpi(coresPerRank,verbose);
        mpiVersion=nativeServices.getMpiVersion();
        resources=new MpiResources(nativeServices.getMpiCommSize(),coresPerRank);
        initialized.countDown();
        long time=System.currentTimeMillis();
        List<MpiTask> completedTasks=new ArrayList<>();
        while (!stopRequested || !jobs.isEmpty()) {
          boolean sleep=true;
          long oldTime=time;
          time=System.currentTimeMillis();
          long diff=time - oldTime;
          if (diff > 1000) {
            LOGGER.warn(""String_Node_Str"",diff,startTasksTime,startTasksJniTime,processCompletedTasksTime,checkTaskCompletionTime);
          }
          startTasksTime=0;
          startTasksJniTime=0;
          processCompletedTasksTime=0;
          checkTaskCompletionTime=0;
          newCommonFileLock.lock();
          try {
            for (            CommonFile commonFile : newCommonFiles) {
              LOGGER.info(""String_Node_Str"",commonFile.getChunk(),commonFile.getName(),commonFile.isLast());
              List<Core> allCores=resources.reserveAllCoresOrFail();
              try {
                try (ByteArrayInputStream is=new ByteArrayInputStream(commonFile.getData())){
                  Messages.CommonFile message=Messages.CommonFile.newBuilder().setName(commonFile.getName()).setChunk(commonFile.getChunk()).setLast(commonFile.isLast()).setData(ByteString.readFrom(is)).build();
                  long t1=System.currentTimeMillis();
                  nativeServices.sendCommonFile(message.toByteArray());
                  long t2=System.currentTimeMillis();
                  commonFiles.add(commonFile.getName());
                  MpiJobSchedulerImpl.this.statistics.logCommonFileTransfer(commonFile.getName(),commonFile.getChunk(),commonFile.getData().length,t2 - t1);
                }
               }
  finally {
                resources.releaseCores(allCores);
              }
            }
            newCommonFiles.clear();
          }
  finally {
            newCommonFileLock.unlock();
          }
          newJobsLock.lock();
          try {
            jobs.addAll(newJobs);
            newJobs.clear();
          }
  finally {
            newJobsLock.unlock();
          }
          for (Iterator<MpiJob> it=jobs.iterator(); it.hasNext(); ) {
            MpiJob job=it.next();
            sleep=startTasks(job);
            long t0=System.currentTimeMillis();
            try {
              nativeServices.checkTasksCompletion(job.getRunningTasks(),completedTasks);
            }
  finally {
              checkTaskCompletionTime+=System.currentTimeMillis() - t0;
            }
            if (!completedTasks.isEmpty()) {
              DateTime endTime=DateTime.now();
              for (              MpiTask tasks : completedTasks) {
                MpiJobSchedulerImpl.this.resources.releaseCore(tasks.getCore());
                tasks.setEndTime(endTime);
              }
              startTasks(job);
              processCompletedTasks(job,completedTasks);
              if (job.isCompleted()) {
                it.remove();
                ExecutionReport report=new ExecutionReport(job.getErrors());
                try {
                  job.getListener().onEnd(report);
                }
 catch (                Exception e) {
                  LOGGER.error(e.toString(),e);
                }
                job.getFuture().complete(report);
                MpiJobSchedulerImpl.this.statistics.logJobEnd(job.getId());
              }
              sleep=false;
            }
          }
          if (sleep) {
            TimeUnit.MILLISECONDS.sleep(TIMEOUT);
          }
        }
        nativeServices.terminateMpi();
      }
 catch (      Throwable t) {
        LOGGER.error(t.toString(),t);
        System.exit(-1);
      }
      LOGGER.trace(""String_Node_Str"");
    }
  }
);
  initialized.await();
}","The original code directly used a statistics object without a factory, which limits flexibility and makes dependency injection harder. The fixed code introduces a MpiStatisticsFactory that creates a statistics instance with additional parameters like database directory and name, enabling more configurable and dynamic statistics tracking. This approach improves modularity, allows for easier testing, and provides more granular control over statistics initialization and management."
38870,"@Override public void shutdown() throws Exception {
  stopRequested=true;
  future.get();
}","@Override public void shutdown() throws Exception {
  try {
    statistics.close();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  stopRequested=true;
  future.get();
}","The original code lacks proper resource cleanup, potentially leaving the `statistics` resource open and unmanaged during shutdown. The fixed code adds a try-catch block to explicitly close the `statistics` resource, handling any potential exceptions by logging them without interrupting the shutdown process. This approach ensures clean resource management, prevents resource leaks, and provides better error handling during the shutdown sequence."
38871,"public static ComputationManager createMpiComputationManager(CommandLine line,FileSystem fileSystem){
  Path tmpDir=fileSystem.getPath(line.hasOption(TMP_DIR) ? line.getOptionValue(TMP_DIR) : System.getProperty(""String_Node_Str""));
  Path statisticsDbDir=line.hasOption(STATISTICS_DB_DIR) ? fileSystem.getPath(line.getOptionValue(STATISTICS_DB_DIR)) : null;
  String statisticsDbName=line.hasOption(STATISTICS_DB_NAME) ? line.getOptionValue(STATISTICS_DB_NAME) : null;
  int coresPerRank=Integer.parseInt(line.getOptionValue(CORES));
  boolean verbose=line.hasOption(VERBOSE);
  Path stdOutArchive=line.hasOption(STDOUT_ARCHIVE) ? fileSystem.getPath(line.getOptionValue(STDOUT_ARCHIVE)) : null;
  ComponentDefaultConfig config=ComponentDefaultConfig.load();
  MpiStatisticsFactory statisticsFactory=createMpiStatisticsFactory(config,statisticsDbDir,statisticsDbName);
  try {
    return new MpiComputationManager(tmpDir,statisticsFactory.create(statisticsDbDir,statisticsDbName),new MpiExecutorContext(),coresPerRank,verbose,stdOutArchive);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new UncheckedInterruptedException(e);
  }
}","public static ComputationManager createMpiComputationManager(CommandLine line,FileSystem fileSystem){
  Path tmpDir=fileSystem.getPath(line.hasOption(TMP_DIR) ? line.getOptionValue(TMP_DIR) : System.getProperty(""String_Node_Str""));
  Path statisticsDbDir=line.hasOption(STATISTICS_DB_DIR) ? fileSystem.getPath(line.getOptionValue(STATISTICS_DB_DIR)) : null;
  String statisticsDbName=line.hasOption(STATISTICS_DB_NAME) ? line.getOptionValue(STATISTICS_DB_NAME) : null;
  int coresPerRank=Integer.parseInt(line.getOptionValue(CORES));
  boolean verbose=line.hasOption(VERBOSE);
  Path stdOutArchive=line.hasOption(STDOUT_ARCHIVE) ? fileSystem.getPath(line.getOptionValue(STDOUT_ARCHIVE)) : null;
  ComponentDefaultConfig config=ComponentDefaultConfig.load();
  MpiStatisticsFactory statisticsFactory=config.newFactoryImpl(MpiStatisticsFactory.class,NoMpiStatisticsFactory.class);
  try {
    return new MpiComputationManager(tmpDir,statisticsFactory,statisticsDbDir,statisticsDbName,new MpiExecutorContext(),coresPerRank,verbose,stdOutArchive);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new UncheckedInterruptedException(e);
  }
}","The original code incorrectly created a statistics factory by calling a method that likely doesn't exist, potentially causing compilation or runtime errors. The fixed code uses `config.newFactoryImpl()` to dynamically create a statistics factory with a fallback implementation, ensuring proper factory instantiation. This approach provides more robust and flexible factory creation, allowing for easier configuration and potential extension of the MPI computation manager's statistics handling."
38872,"static void parseFieldName(JsonParser parser,JsonParsingContext context) throws IOException {
  String fieldName=parser.getCurrentName();
switch (fieldName) {
case ""String_Node_Str"":
    break;
case ""String_Node_Str"":
  context.name=parser.nextTextValue();
break;
case ""String_Node_Str"":
context.dataType=TimeSeriesDataType.valueOf(parser.nextTextValue());
break;
case ""String_Node_Str"":
context.insideTags=true;
break;
case RegularTimeSeriesIndex.TYPE:
context.index=RegularTimeSeriesIndex.parseJson(parser);
break;
default :
if (context.insideTags) {
context.tags.put(fieldName,parser.nextTextValue());
}
 else {
throw new IllegalStateException(""String_Node_Str"" + fieldName);
}
}
}","static void parseFieldName(JsonParser parser,JsonParsingContext context) throws IOException {
  String fieldName=parser.getCurrentName();
  if (context.insideTags) {
    context.tags.put(fieldName,parser.nextTextValue());
  }
 else {
switch (fieldName) {
case ""String_Node_Str"":
      break;
case ""String_Node_Str"":
    context.name=parser.nextTextValue();
  break;
case ""String_Node_Str"":
context.dataType=TimeSeriesDataType.valueOf(parser.nextTextValue());
break;
case ""String_Node_Str"":
context.insideTags=true;
break;
case RegularTimeSeriesIndex.TYPE:
context.index=RegularTimeSeriesIndex.parseJson(parser);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + fieldName);
}
}
}","The original code has duplicate case statements with identical labels, causing unpredictable parsing behavior and potential logic errors. The fixed code restructures the switch statement by moving the tag parsing logic outside the switch and adding a conditional check for `context.insideTags`, which allows proper handling of different field types and tag parsing. This modification ensures more robust and predictable JSON parsing by preventing duplicate case statements and providing a clear, hierarchical approach to processing different field types."
38873,"TerminalExt build(){
  String connectionBus=getConnectionBus();
  if (node != null && connectionBus != null) {
    throw new ValidationException(validable,""String_Node_Str"");
  }
  return node != null ? new NodeTerminal(network,node) : new BusTerminal(network,connectionBus,bus != null);
}","TerminalExt build(){
  String connectionBus=getConnectionBus();
  if (node != null && connectionBus != null) {
    throw new ValidationException(validable,""String_Node_Str"");
  }
  if (node == null) {
    if (connectionBus == null) {
      throw new ValidationException(validable,""String_Node_Str"");
    }
    return new BusTerminal(network,connectionBus,bus != null);
  }
 else {
    return new NodeTerminal(network,node);
  }
}","The original code lacked proper validation when both node and connectionBus were null, potentially allowing invalid terminal creation. The fixed code adds an explicit check to ensure either a node or a valid connectionBus exists, throwing a ValidationException if neither is present. This improvement prevents creating terminals with insufficient connection information and provides more robust error handling."
38874,"@Override public InputStream newInputStream(String fileName) throws IOException {
  Objects.requireNonNull(fileName);
  Path zipFilePath=getZipFilePath();
  if (Files.exists(zipFilePath)) {
    ZipFile zipFile=new ZipFile(zipFilePath);
    InputStream is=zipFile.getInputStream(fileName);
    if (is != null) {
      InputStream fis=new ForwardingInputStream<InputStream>(is){
        @Override public void close() throws IOException {
          zipFile.close();
        }
      }
;
      return observer != null ? new ObservableInputStream(fis,zipFilePath + ""String_Node_Str"" + fileName,observer) : fis;
    }
 else {
      zipFile.close();
    }
  }
  return null;
}","@Override public InputStream newInputStream(String fileName) throws IOException {
  Objects.requireNonNull(fileName);
  Path zipFilePath=getZipFilePath();
  if (entryExists(zipFilePath,fileName)) {
    InputStream is=new ZipEntryInputStream(new ZipFile(zipFilePath),fileName);
    return observer != null ? new ObservableInputStream(is,zipFilePath + ""String_Node_Str"" + fileName,observer) : is;
  }
  return null;
}","The original code had resource management issues, potentially leaking ZipFile resources and not properly handling input stream closure. The fixed code introduces a custom ZipEntryInputStream that encapsulates ZipFile management, ensuring proper resource handling and automatic closing. This approach simplifies resource lifecycle, prevents potential memory leaks, and provides a more robust and clean implementation of file input stream retrieval from a zip file."
38875,"@Override public boolean exists(String fileName) throws IOException {
  Objects.requireNonNull(fileName);
  Path zipFilePath=getZipFilePath();
  if (Files.exists(zipFilePath)) {
    try (ZipFile zipFile=new ZipFile(zipFilePath)){
      return zipFile.entry(fileName) != null;
    }
   }
  return false;
}","@Override public boolean exists(String fileName) throws IOException {
  Objects.requireNonNull(fileName);
  Path zipFilePath=getZipFilePath();
  return entryExists(zipFilePath,fileName);
}","The original code directly uses ZipFile, which can throw exceptions and lacks proper resource management when checking file existence. The fixed code introduces a separate method `entryExists()` that encapsulates the ZIP file handling, providing cleaner error handling and resource management. By extracting the ZIP file checking logic into a dedicated method, the code becomes more modular, readable, and less prone to potential resource leaks or unexpected exceptions."
38876,"public CacheEntry build(){
  Path baseDir=cacheDir.resolve(name);
  if (keys.size() > 0) {
    HashFunction hf=Hashing.md5();
    Hasher h=hf.newHasher();
    for (    String key : keys) {
      h.putString(key,Charsets.UTF_8);
    }
    HashCode hc=h.hash();
    baseDir=baseDir.resolve(hc.toString());
  }
  cacheEntriesLock.lock();
  try {
    CacheEntry cacheEntry=cacheEntries.get(baseDir.toString());
    if (cacheEntry != null) {
      if (!cacheEntry.getKeys().equals(keys)) {
        throw new PowsyblException(""String_Node_Str"");
      }
    }
 else {
      cacheEntry=new CacheEntry(baseDir,keys);
      cacheEntries.put(baseDir.toString(),cacheEntry);
    }
    return cacheEntry;
  }
  finally {
    cacheEntriesLock.unlock();
  }
}","public CacheEntry build(){
  Path baseDir=cacheDir.resolve(name);
  if (!keys.isEmpty()) {
    HashFunction hf=Hashing.md5();
    Hasher h=hf.newHasher();
    for (    String key : keys) {
      h.putString(key,Charsets.UTF_8);
    }
    HashCode hc=h.hash();
    baseDir=baseDir.resolve(hc.toString());
  }
  cacheEntriesLock.lock();
  try {
    CacheEntry cacheEntry=cacheEntries.get(baseDir.toString());
    if (cacheEntry != null) {
      if (!cacheEntry.getKeys().equals(keys)) {
        throw new PowsyblException(""String_Node_Str"");
      }
    }
 else {
      cacheEntry=new CacheEntry(baseDir,keys);
      cacheEntries.put(baseDir.toString(),cacheEntry);
    }
    return cacheEntry;
  }
  finally {
    cacheEntriesLock.unlock();
  }
}","The original code used `keys.size() > 0` to check for non-empty keys, which is less idiomatic and potentially less efficient compared to Java's recommended method. The fixed code replaces this with `!keys.isEmpty()`, a more standard and clearer way to check if a collection contains elements. This change improves code readability and follows Java's best practices for checking collection emptiness, making the code more maintainable and slightly more performant."
38877,"public void lock(){
  try {
    semaphore.acquire();
  }
 catch (  InterruptedException e) {
    throw new UncheckedInterruptedException(e);
  }
}","public void lock(){
  try {
    semaphore.acquire();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new UncheckedInterruptedException(e);
  }
}","The original code fails to properly handle thread interruption, potentially losing the interrupted status when an InterruptedException occurs. The fixed code adds `Thread.currentThread().interrupt()` to restore the thread's interrupted status before throwing the unchecked exception. This ensures that the interruption signal is preserved, allowing calling code to detect and handle the interruption appropriately."
38878,"public static ComputationManager createMpiComputationManager(CommandLine line,FileSystem fileSystem){
  Path tmpDir=fileSystem.getPath(line.hasOption(""String_Node_Str"") ? line.getOptionValue(""String_Node_Str"") : System.getProperty(""String_Node_Str""));
  Path statisticsDbDir=line.hasOption(""String_Node_Str"") ? fileSystem.getPath(line.getOptionValue(""String_Node_Str"")) : null;
  String statisticsDbName=line.hasOption(""String_Node_Str"") ? line.getOptionValue(""String_Node_Str"") : null;
  int coresPerRank=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  boolean verbose=line.hasOption(""String_Node_Str"");
  Path stdOutArchive=line.hasOption(""String_Node_Str"") ? fileSystem.getPath(line.getOptionValue(""String_Node_Str"")) : null;
  ComponentDefaultConfig config=ComponentDefaultConfig.load();
  MpiStatisticsFactory statisticsFactory=createMpiStatisticsFactory(config,statisticsDbDir,statisticsDbName);
  try {
    return new MpiComputationManager(tmpDir,statisticsFactory.create(statisticsDbDir,statisticsDbName),new MpiExecutorContext(),coresPerRank,verbose,stdOutArchive);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
catch (  InterruptedException e) {
    throw new UncheckedInterruptedException(e);
  }
}","public static ComputationManager createMpiComputationManager(CommandLine line,FileSystem fileSystem){
  Path tmpDir=fileSystem.getPath(line.hasOption(""String_Node_Str"") ? line.getOptionValue(""String_Node_Str"") : System.getProperty(""String_Node_Str""));
  Path statisticsDbDir=line.hasOption(""String_Node_Str"") ? fileSystem.getPath(line.getOptionValue(""String_Node_Str"")) : null;
  String statisticsDbName=line.hasOption(""String_Node_Str"") ? line.getOptionValue(""String_Node_Str"") : null;
  int coresPerRank=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  boolean verbose=line.hasOption(""String_Node_Str"");
  Path stdOutArchive=line.hasOption(""String_Node_Str"") ? fileSystem.getPath(line.getOptionValue(""String_Node_Str"")) : null;
  ComponentDefaultConfig config=ComponentDefaultConfig.load();
  MpiStatisticsFactory statisticsFactory=createMpiStatisticsFactory(config,statisticsDbDir,statisticsDbName);
  try {
    return new MpiComputationManager(tmpDir,statisticsFactory.create(statisticsDbDir,statisticsDbName),new MpiExecutorContext(),coresPerRank,verbose,stdOutArchive);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new UncheckedInterruptedException(e);
  }
}","The original code did not properly handle thread interruption, potentially leaving the interrupted state unset. In the fixed code, `Thread.currentThread().interrupt()` is added before throwing the `UncheckedInterruptedException`, which ensures the thread's interrupted status is preserved. This change maintains the expected interrupt handling behavior, allowing calling code to detect and respond to interruption correctly."
38879,"@Override public Expression transform(Expression exp){
  if (exp instanceof BinaryExpression) {
    BinaryExpression binExpr=(BinaryExpression)exp;
    String op=binExpr.getOperation().getText();
switch (op) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      return new MethodCallExpression(transform(binExpr.getLeftExpression()),""String_Node_Str"",new ArgumentListExpression(transform(binExpr.getRightExpression()),new ConstantExpression(op)));
case ""String_Node_Str"":
    return new MethodCallExpression(transform(binExpr.getLeftExpression()),""String_Node_Str"",new ArgumentListExpression(transform(binExpr.getRightExpression())));
case ""String_Node_Str"":
  return new MethodCallExpression(transform(binExpr.getLeftExpression()),""String_Node_Str"",new ArgumentListExpression(transform(binExpr.getRightExpression())));
}
}
 else if (exp instanceof NotExpression) {
return new MethodCallExpression(transform(((NotExpression)exp).getExpression()),""String_Node_Str"",new ArgumentListExpression());
}
Expression newExpr=super.transform(exp);
if (newExpr != null) {
newExpr.visit(this);
}
return newExpr;
}","@Override public Expression transform(Expression exp){
  if (exp instanceof BinaryExpression) {
    BinaryExpression binExpr=(BinaryExpression)exp;
    String op=binExpr.getOperation().getText();
switch (op) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      return new MethodCallExpression(transform(binExpr.getLeftExpression()),""String_Node_Str"",new ArgumentListExpression(transform(binExpr.getRightExpression()),new ConstantExpression(op)));
case ""String_Node_Str"":
    return new MethodCallExpression(transform(binExpr.getLeftExpression()),""String_Node_Str"",new ArgumentListExpression(transform(binExpr.getRightExpression())));
case ""String_Node_Str"":
  return new MethodCallExpression(transform(binExpr.getLeftExpression()),""String_Node_Str"",new ArgumentListExpression(transform(binExpr.getRightExpression())));
default :
break;
}
}
 else if (exp instanceof NotExpression) {
return new MethodCallExpression(transform(((NotExpression)exp).getExpression()),""String_Node_Str"",new ArgumentListExpression());
}
Expression newExpr=super.transform(exp);
if (newExpr != null) {
newExpr.visit(this);
}
return newExpr;
}","The original code lacks a default case in the switch statement, potentially causing unexpected behavior when encountering unhandled operation types. The fixed code adds a `default: break;` clause to handle cases not explicitly specified in the switch statement, ensuring proper control flow. This modification provides a more robust and predictable transformation method by explicitly handling scenarios not covered by the existing case statements."
38880,"private static int compare(BranchAndSide branchAndSide1,BranchAndSide branchAndSide2){
  Branch.Overload overload1=branchAndSide1.getBranch().checkTemporaryLimits(branchAndSide1.getSide());
  Branch.Overload overload2=branchAndSide2.getBranch().checkTemporaryLimits(branchAndSide2.getSide());
  float i1=branchAndSide1.getBranch().getTerminal(branchAndSide1.getSide()).getI();
  float i2=branchAndSide2.getBranch().getTerminal(branchAndSide2.getSide()).getI();
  float permanentLimit1=getPermanentLimit(branchAndSide1.getBranch(),branchAndSide1.getSide());
  float permanentLimit2=getPermanentLimit(branchAndSide2.getBranch(),branchAndSide2.getSide());
  int c;
  if (overload1 == null && overload2 == null) {
    c=compare(i1 / permanentLimit1,i2 / permanentLimit2);
  }
 else   if (overload1 == null && overload2 != null) {
    c=-1;
  }
 else   if (overload1 != null && overload2 == null) {
    c=1;
  }
 else {
    c=-Integer.compare(overload1.getTemporaryLimit().getAcceptableDuration(),overload2.getTemporaryLimit().getAcceptableDuration());
    if (c == 0) {
      c=compare(i1 / overload1.getTemporaryLimit().getValue(),i2 / overload2.getTemporaryLimit().getValue());
    }
  }
  return c;
}","private static int compare(BranchAndSide branchAndSide1,BranchAndSide branchAndSide2){
  Branch.Overload overload1=branchAndSide1.getBranch().checkTemporaryLimits(branchAndSide1.getSide());
  Branch.Overload overload2=branchAndSide2.getBranch().checkTemporaryLimits(branchAndSide2.getSide());
  float i1=branchAndSide1.getBranch().getTerminal(branchAndSide1.getSide()).getI();
  float i2=branchAndSide2.getBranch().getTerminal(branchAndSide2.getSide()).getI();
  float permanentLimit1=getPermanentLimit(branchAndSide1.getBranch(),branchAndSide1.getSide());
  float permanentLimit2=getPermanentLimit(branchAndSide2.getBranch(),branchAndSide2.getSide());
  int c;
  if (overload1 == null) {
    if (overload2 == null) {
      c=compare(i1 / permanentLimit1,i2 / permanentLimit2);
    }
 else {
      c=-1;
    }
  }
 else {
    if (overload2 == null) {
      c=1;
    }
 else {
      c=-Integer.compare(overload1.getTemporaryLimit().getAcceptableDuration(),overload2.getTemporaryLimit().getAcceptableDuration());
      if (c == 0) {
        c=compare(i1 / overload1.getTemporaryLimit().getValue(),i2 / overload2.getTemporaryLimit().getValue());
      }
    }
  }
  return c;
}","The original code's nested if-else conditions were logically flawed, leading to potential incorrect comparisons when handling null overload scenarios. The fixed code restructures the conditional logic to explicitly handle null cases first, ensuring a clear and predictable comparison path for different overload states. By simplifying the nested conditions and providing a more systematic approach to comparing branch and side overloads, the code now correctly prioritizes null checks and maintains consistent comparison logic."
38881,"private List<String> sortBranches(List<String> branchIds){
  List<String> sortedBranchIds=branchIds.stream().map(id -> context.getNetwork().getBranch(id)).map(branch -> {
    BranchAndSide branchAndSide1=new BranchAndSide(branch,Branch.Side.ONE);
    BranchAndSide branchAndSide2=new BranchAndSide(branch,Branch.Side.TWO);
    int c=branchAndSide1.compareTo(branchAndSide2);
    return c >= 0 ? branchAndSide1 : branchAndSide2;
  }
).sorted().map(branchAndSide -> branchAndSide.getBranch().getId()).collect(Collectors.toList());
  return sortedBranchIds;
}","private List<String> sortBranches(List<String> branchIds){
  return branchIds.stream().map(id -> context.getNetwork().getBranch(id)).map(branch -> {
    BranchAndSide branchAndSide1=new BranchAndSide(branch,Branch.Side.ONE);
    BranchAndSide branchAndSide2=new BranchAndSide(branch,Branch.Side.TWO);
    int c=branchAndSide1.compareTo(branchAndSide2);
    return c >= 0 ? branchAndSide1 : branchAndSide2;
  }
).sorted().map(branchAndSide -> branchAndSide.getBranch().getId()).collect(Collectors.toList());
}","The original code incorrectly creates a new local variable `sortedBranchIds`, which is unnecessary and potentially introduces memory overhead. The fixed code directly returns the stream pipeline result, eliminating the redundant variable declaration. This streamlined approach improves code readability, reduces memory allocation, and maintains the same sorting and transformation logic more efficiently."
38882,"@Override public Object visitLoadingRank(LoadingRankNode node,Void arg){
  List<String> branchIds=new ArrayList<>();
  node.getBranchIds().forEach(e -> branchIds.add((String)e.accept(this,arg)));
  String branchIdToRank=(String)node.getBranchIdToRankNode().accept(this,arg);
  if (!branchIds.contains(branchIdToRank)) {
    throw new PowsyblException(""String_Node_Str"");
  }
  List<String> sortedBranchIds=sortBranches(branchIds);
  int i=sortedBranchIds.indexOf(branchIdToRank);
  if (i == -1) {
    throw new AssertionError();
  }
  int rank=sortedBranchIds.size() - i;
  return rank;
}","@Override public Object visitLoadingRank(LoadingRankNode node,Void arg){
  List<String> branchIds=new ArrayList<>();
  node.getBranchIds().forEach(e -> branchIds.add((String)e.accept(this,arg)));
  String branchIdToRank=(String)node.getBranchIdToRankNode().accept(this,arg);
  if (!branchIds.contains(branchIdToRank)) {
    throw new PowsyblException(""String_Node_Str"");
  }
  List<String> sortedBranchIds=sortBranches(branchIds);
  int i=sortedBranchIds.indexOf(branchIdToRank);
  if (i == -1) {
    throw new AssertionError();
  }
  return sortedBranchIds.size() - i;
}","The buggy code unnecessarily assigned the calculated rank to a separate variable before returning, which was redundant and potentially confusing. The fixed code directly returns the rank calculation `sortedBranchIds.size() - i`, eliminating the extra step and simplifying the logic. This change makes the code more concise and directly expresses the rank calculation without intermediate variable assignment."
38883,public abstract FOLDER getParent();,public abstract F getParent();,"The original code uses a concrete type FOLDER, which limits the method's flexibility and reusability across different folder-like structures. The fixed code replaces FOLDER with a generic type F, enabling more generic and adaptable parent retrieval for various hierarchical data structures. By using a generic type, the method becomes more flexible, allowing different implementations to define their specific parent type while maintaining a consistent abstract interface."
38884,"FOLDER getFolder(String name,String... more);","F getFolder(String name,String... more);","The original code uses a concrete type `FOLDER` as the return type, which limits method flexibility and type genericity. The fixed code replaces `FOLDER` with a generic type parameter `F`, enabling more flexible and reusable method signatures that can work with different folder-like types. This change allows for better abstraction, polymorphic behavior, and improved type safety when working with folder-related operations."
38885,List<NODE> getChildren();,List<N> getChildren();,"The original code uses a concrete NODE type, which limits the method's flexibility and type safety in generic contexts. The fixed code replaces NODE with a generic type parameter N, allowing the method to work with any type while maintaining type inference and compile-time type checking. This modification enables more flexible and reusable code by supporting different child node types without sacrificing type safety."
38886,"<T extends NODE>T getChild(Class<T> clazz,String name,String... more);","<T extends N>T getChild(Class<T> clazz,String name,String... more);","The original code uses an undefined type parameter NODE, which would cause a compilation error due to an unresolved reference. The fixed code replaces NODE with N, suggesting a properly defined type parameter that represents the base type for the generic method. This correction ensures type safety and allows the method to correctly parameterize and constrain the child type being retrieved."
38887,FOLDER createFolder(String name);,F createFolder(String name);,"The original code uses an undefined type FOLDER, which is likely a custom class or interface, causing compilation errors. The fixed code replaces FOLDER with F, a more concise type identifier that maintains the method's return type contract for folder creation. By using a shorter, potentially more generic type, the code becomes more flexible and potentially more reusable across different folder-related implementations."
38888,"public static <FOLDER extends NODE,NODE extends AbstractNodeBase<FOLDER>>NodePath find(NODE node,Function<List<String>,String> toStringFct){
  Objects.requireNonNull(node);
  List<String> path=new ArrayList<>(1);
  addPath(node,path);
  return new NodePath(path,toStringFct);
}","public static <F extends N,N extends AbstractNodeBase<F>>NodePath find(N node,Function<List<String>,String> toStringFct){
  Objects.requireNonNull(node);
  List<String> path=new ArrayList<>(1);
  addPath(node,path);
  return new NodePath(path,toStringFct);
}","The original code used overly verbose and potentially confusing generic type parameters with long names like <FOLDER extends NODE,NODE extends AbstractNodeBase<FOLDER>>. The fixed code simplifies the type parameters to <F extends N,N extends AbstractNodeBase<F>>, using shorter, more concise generic type variable names while maintaining the same structural relationship. This refactoring improves code readability and maintains the original type-safe generic structure without changing the method's core functionality."
38889,"private static <FOLDER extends NODE,NODE extends AbstractNodeBase<FOLDER>>void addPath(NODE node,List<String> path){
  if (node.getParent() != null) {
    addPath(node.getParent(),path);
  }
  path.add(node.getName());
}","private static <F extends N,N extends AbstractNodeBase<F>>void addPath(N node,List<String> path){
  if (node.getParent() != null) {
    addPath(node.getParent(),path);
  }
  path.add(node.getName());
}","The original code used overly specific generic type parameters FOLDER and NODE, which created unnecessary type constraints and potential compilation issues. The fixed code simplifies the generic type declaration by using shorter, more generic type parameters F and N while maintaining the same hierarchical relationship between node types. This refactoring provides more flexible and readable generic type definitions without changing the method's core logic."
38890,"@Override public List<NodeId> getChildNodes(NodeId nodeId){
  Objects.requireNonNull(nodeId);
  Path path=((PathNodeId)nodeId).getPath();
  List<NodeId> childNodesIds=new ArrayList<>();
  LocalFolder folder=scanFolder(path,false);
  if (folder != null) {
    childNodesIds.addAll(folder.getChildPaths().stream().filter(childPath -> isLocalNode(childPath)).map(childPath -> new PathNodeId(childPath)).collect(Collectors.toList()));
  }
 else {
    throw new AssertionError();
  }
  return childNodesIds;
}","@Override public List<NodeId> getChildNodes(NodeId nodeId){
  Objects.requireNonNull(nodeId);
  Path path=((PathNodeId)nodeId).getPath();
  List<NodeId> childNodesIds=new ArrayList<>();
  LocalFolder folder=scanFolder(path,false);
  if (folder != null) {
    childNodesIds.addAll(folder.getChildPaths().stream().filter(this::isLocalNode).map(PathNodeId::new).collect(Collectors.toList()));
  }
 else {
    throw new AssertionError();
  }
  return childNodesIds;
}","The original code used verbose lambda expressions for filtering and mapping, which reduced readability and introduced unnecessary complexity. The fixed code uses method references (`this::isLocalNode` and `PathNodeId::new`), which simplify the stream operations and make the code more concise and idiomatic. These changes improve code clarity, maintainability, and leverage Java's method reference syntax for more elegant stream processing."
38891,"@Override public void close() throws IOException {
  os.closeEntry();
  if (Files.exists(zipFilePath)) {
    try (ZipFile zipFile=new ZipFile(zipFilePath)){
      Enumeration<? extends ZipEntry> e=zipFile.entries();
      while (e.hasMoreElements()) {
        ZipEntry zipEntry=e.nextElement();
        if (!zipEntry.getName().equals(fileName)) {
          zos.putNextEntry(zipEntry);
          try (InputStream zis=zipFile.getInputStream(zipEntry.getName())){
            ByteStreams.copy(zis,zos);
          }
           zos.closeEntry();
        }
      }
    }
   }
  zos.close();
  Files.copy(tmpZipFilePath,zipFilePath,StandardCopyOption.REPLACE_EXISTING);
  Files.delete(tmpZipFilePath);
}","@Override public void close() throws IOException {
  os.closeEntry();
  if (Files.exists(zipFilePath)) {
    try (ZipFile zipFile=new ZipFile(zipFilePath)){
      Enumeration<? extends ZipEntry> e=zipFile.entries();
      while (e.hasMoreElements()) {
        ZipEntry zipEntry=e.nextElement();
        if (!zipEntry.getName().equals(fileName)) {
          os.putNextEntry(zipEntry);
          try (InputStream zis=zipFile.getInputStream(zipEntry.getName())){
            ByteStreams.copy(zis,os);
          }
           os.closeEntry();
        }
      }
    }
   }
  super.close();
  Path tmpZipFilePath=getTmpZipFilePath(zipFilePath);
  Files.copy(tmpZipFilePath,zipFilePath,StandardCopyOption.REPLACE_EXISTING);
  Files.delete(tmpZipFilePath);
}","The original code incorrectly used `zos` (ZipOutputStream) instead of `os` (the output stream), which would cause a potential runtime error and incorrect file handling. The fixed code replaces `zos` with `os`, adds a `super.close()` call to properly close the parent stream, and introduces a `getTmpZipFilePath()` method to generate the temporary zip file path. These changes ensure proper stream management, prevent potential null pointer exceptions, and maintain the intended file manipulation logic while improving code reliability and error handling."
38892,"public synchronized int getInt(SUBSET subset,String id){
  if (subset == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (id == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Integer num=id2num.get(subset).get(id);
  if (num == null) {
    throw new IllegalStateException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  return num;
}","public synchronized int getInt(S subset,String id){
  if (subset == null) {
    throw createSubsetIsNullException();
  }
  if (id == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Integer num=id2num.get(subset).get(id);
  if (num == null) {
    throw new IllegalStateException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  return num;
}","The original code uses an undefined type `SUBSET`, which would cause a compilation error and prevent the method from working correctly. The fixed code replaces `SUBSET` with `S`, likely a predefined type or generic parameter, and introduces a separate exception creation method `createSubsetIsNullException()`. This modification improves code readability, maintains type safety, and provides a more flexible approach to handling null subset scenarios."
38893,"public synchronized int newInt(SUBSET subset,String id){
  if (subset == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (id == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Integer num=id2num.get(subset).get(id);
  if (num == null) {
    num=counter.get(subset);
    counter.put(subset,num + 1);
    id2num.get(subset).put(id,num);
    modified=true;
  }
  return num;
}","public synchronized int newInt(S subset,String id){
  if (subset == null) {
    throw createSubsetIsNullException();
  }
  if (id == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Integer num=id2num.get(subset).get(id);
  if (num == null) {
    num=counter.get(subset);
    counter.put(subset,num + 1);
    id2num.get(subset).put(id,num);
    modified=true;
  }
  return num;
}","The original code lacks proper null handling for the subset parameter, potentially causing null pointer exceptions when accessing nested maps. The fixed code introduces a custom exception method `createSubsetIsNullException()` for more precise error handling and replaces the generic SUBSET type with a more specific type S. This modification enhances error management, provides clearer exception handling, and improves the method's robustness by preventing unexpected runtime errors."
38894,"public synchronized boolean isMapped(SUBSET subset,String id){
  Map<String,Integer> numbers=id2num.get(subset);
  return numbers.containsKey(id);
}","public synchronized boolean isMapped(S subset,String id){
  Map<String,Integer> numbers=id2num.get(subset);
  return numbers.containsKey(id);
}","The original code uses an undefined type `SUBSET`, which would cause a compilation error due to an undeclared type. The fixed code replaces `SUBSET` with `S`, suggesting a properly defined type or generic parameter that matches the context of the method. This correction ensures type safety and allows the method to compile and function correctly with the intended subset type."
38895,"public synchronized void reset(SUBSET subset){
  if (subset == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  id2num.put(subset,HashBiMap.<String,Integer>create());
  counter.put(subset,subset.getInitialValue());
}","public synchronized void reset(S subset){
  if (subset == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  id2num.put(subset,HashBiMap.<String,Integer>create());
  counter.put(subset,subset.getInitialValue());
}","The original code uses a specific type `SUBSET`, which likely does not match the actual generic type used in the class implementation. The fixed code replaces `SUBSET` with a generic type `S`, allowing for more flexible and type-safe parameter handling. This change enables proper type inference and prevents potential compilation errors while maintaining the method's synchronization and null-checking behavior."
38896,"public synchronized String getId(SUBSET subset,int num){
  if (subset == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (num < subset.getInitialValue() || num >= counter.get(subset)) {
    throw new IllegalArgumentException(""String_Node_Str"" + num);
  }
  return id2num.get(subset).inverse().get(num);
}","public synchronized String getId(S subset,int num){
  if (subset == null) {
    throw createSubsetIsNullException();
  }
  if (num < subset.getInitialValue() || num >= counter.get(subset)) {
    throw new IllegalArgumentException(""String_Node_Str"" + num);
  }
  return id2num.get(subset).inverse().get(num);
}","The original code directly throws an IllegalArgumentException with a hardcoded string when the subset is null, which lacks flexibility and proper error handling. The fixed code introduces a method `createSubsetIsNullException()` to generate a more structured and potentially customizable exception for null subset scenarios. This approach enhances error management by centralizing exception creation and allowing for more precise and adaptable error reporting."
38897,"public StringToIntMapper(Class<SUBSET> clazz){
  this.clazz=clazz;
  id2num=new EnumMap<>(clazz);
  counter=new EnumMap<>(clazz);
  for (  SUBSET s : clazz.getEnumConstants()) {
    id2num.put(s,HashBiMap.<String,Integer>create());
    counter.put(s,s.getInitialValue());
  }
}","public StringToIntMapper(Class<S> clazz){
  this.clazz=clazz;
  id2num=new EnumMap<>(clazz);
  counter=new EnumMap<>(clazz);
  for (  S s : clazz.getEnumConstants()) {
    id2num.put(s,HashBiMap.<String,Integer>create());
    counter.put(s,s.getInitialValue());
  }
}","The original code uses an undefined generic type SUBSET, which would cause compilation errors due to type ambiguity. The fixed code replaces SUBSET with S, a more standard generic type parameter that matches the class definition and provides clear type inference. This correction ensures type safety, allows proper enum constant iteration, and resolves potential compile-time type resolution issues."
38898,"@Override public void close() throws Exception {
  internalWriter.close();
}","@Override public void close(){
  try {
    internalWriter.close();
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
}","The original code directly throws a checked Exception from the close() method, which can complicate exception handling for callers implementing AutoCloseable. The fixed code catches the specific IOException and wraps it in an unchecked UncheckedIOException, converting the checked exception to an unchecked one. This approach simplifies error management by removing the need for explicit exception handling while preserving the original exception's details, making resource cleanup more straightforward and less error-prone."
38899,"private void checkSize(boolean last) throws IOException {
  if (last || buffer.size() > CHUNK_MAX_SIZE) {
    scheduler.sendCommonFile(new CommonFile(fileName,buffer.toByteArray(),chunk++,last));
    buffer.reset();
  }
}","private void checkSize(boolean last){
  if (last || buffer.size() > CHUNK_MAX_SIZE) {
    scheduler.sendCommonFile(new CommonFile(fileName,buffer.toByteArray(),chunk++,last));
    buffer.reset();
  }
}","The original code throws an IOException, which is unnecessary and forces callers to handle an exception that won't actually occur during buffer reset. The fixed code removes the unnecessary throws clause, simplifying method signatures and reducing error handling complexity. By eliminating the unneeded exception, the code becomes more straightforward and allows for cleaner, more direct method invocation without mandatory exception handling."
38900,"@Override public <R>CompletableFuture<R> execute(final ExecutionEnvironment environment,final ExecutionHandler<R> handler){
  Objects.requireNonNull(environment);
  Objects.requireNonNull(handler);
class AsyncContext {
    WorkingDirectory workingDir;
    List<CommandExecution> parametersList;
    ExecutionReport report;
  }
  return CompletableFuture.completedFuture(new AsyncContext()).thenApplyAsync(ctxt -> {
    try {
      ctxt.workingDir=new WorkingDirectory(localDir,environment.getWorkingDirPrefix(),environment.isDebug());
    }
 catch (    IOException e) {
      throw new UncheckedIOException(e);
    }
    try {
      ctxt.parametersList=handler.before(ctxt.workingDir.toPath());
    }
 catch (    Throwable t) {
      try {
        ctxt.workingDir.close();
      }
 catch (      IOException e2) {
        throw new UncheckedIOException(e2);
      }
      throw new RuntimeException(t);
    }
    return ctxt;
  }
,executorContext.getComputationExecutor()).thenComposeAsync(ctxt -> {
    if (ctxt.parametersList.isEmpty()) {
      ctxt.report=new ExecutionReport(Collections.emptyList());
      return CompletableFuture.completedFuture(ctxt);
    }
 else {
      CompletableFuture<ExecutionReport> last=null;
      for (      CommandExecution execution : ctxt.parametersList) {
        ExecutionListener l=new DefaultExecutionListener(){
          @Override public void onExecutionStart(          int fromExecutionIndex,          int toExecutionIndex){
            try {
              for (int executionIndex=fromExecutionIndex; executionIndex <= toExecutionIndex; executionIndex++) {
                handler.onExecutionStart(execution,executionIndex);
              }
            }
 catch (            Exception e) {
              LOGGER.error(e.toString(),e);
            }
          }
          @Override public void onExecutionCompletion(          int executionIndex){
            try {
              handler.onExecutionCompletion(execution,executionIndex);
            }
 catch (            Exception e) {
              LOGGER.error(e.toString(),e);
            }
          }
        }
;
        if (last == null) {
          last=scheduler.execute(execution,ctxt.workingDir.toPath(),environment.getVariables(),l);
        }
 else {
          last=last.thenCompose(report -> {
            if (report.getErrors().isEmpty()) {
              return scheduler.execute(execution,ctxt.workingDir.toPath(),environment.getVariables(),l);
            }
 else {
              return CompletableFuture.completedFuture(report);
            }
          }
);
        }
      }
      return last.thenApply(report -> {
        ctxt.report=report;
        return ctxt;
      }
);
    }
  }
,executorContext.getComputationExecutor()).thenApplyAsync(ctxt -> {
    try {
      return handler.after(ctxt.workingDir.toPath(),ctxt.report);
    }
 catch (    IOException e) {
      throw new UncheckedIOException(e);
    }
 finally {
      try {
        ctxt.workingDir.close();
      }
 catch (      IOException e2) {
        throw new UncheckedIOException(e2);
      }
    }
  }
,executorContext.getComputationExecutor());
}","@Override public <R>CompletableFuture<R> execute(final ExecutionEnvironment environment,final ExecutionHandler<R> handler){
  Objects.requireNonNull(environment);
  Objects.requireNonNull(handler);
class AsyncContext {
    WorkingDirectory workingDir;
    List<CommandExecution> parametersList;
    ExecutionReport report;
  }
  return CompletableFuture.completedFuture(new AsyncContext()).thenApplyAsync(ctxt -> {
    try {
      ctxt.workingDir=new WorkingDirectory(localDir,environment.getWorkingDirPrefix(),environment.isDebug());
    }
 catch (    IOException e) {
      throw new UncheckedIOException(e);
    }
    try {
      ctxt.parametersList=handler.before(ctxt.workingDir.toPath());
    }
 catch (    Throwable t) {
      try {
        ctxt.workingDir.close();
      }
 catch (      IOException e2) {
        LOGGER.error(e2.toString(),e2);
      }
      throw new RuntimeException(t);
    }
    return ctxt;
  }
,executorContext.getComputationExecutor()).thenComposeAsync(ctxt -> {
    if (ctxt.parametersList.isEmpty()) {
      ctxt.report=new ExecutionReport(Collections.emptyList());
      return CompletableFuture.completedFuture(ctxt);
    }
 else {
      CompletableFuture<ExecutionReport> last=null;
      for (      CommandExecution execution : ctxt.parametersList) {
        ExecutionListener l=new DefaultExecutionListener(){
          @Override public void onExecutionStart(          int fromExecutionIndex,          int toExecutionIndex){
            try {
              for (int executionIndex=fromExecutionIndex; executionIndex <= toExecutionIndex; executionIndex++) {
                handler.onExecutionStart(execution,executionIndex);
              }
            }
 catch (            Exception e) {
              LOGGER.error(e.toString(),e);
            }
          }
          @Override public void onExecutionCompletion(          int executionIndex){
            try {
              handler.onExecutionCompletion(execution,executionIndex);
            }
 catch (            Exception e) {
              LOGGER.error(e.toString(),e);
            }
          }
        }
;
        if (last == null) {
          last=scheduler.execute(execution,ctxt.workingDir.toPath(),environment.getVariables(),l);
        }
 else {
          last=last.thenCompose(report -> {
            if (report.getErrors().isEmpty()) {
              return scheduler.execute(execution,ctxt.workingDir.toPath(),environment.getVariables(),l);
            }
 else {
              return CompletableFuture.completedFuture(report);
            }
          }
);
        }
      }
      return last.thenApply(report -> {
        ctxt.report=report;
        return ctxt;
      }
);
    }
  }
,executorContext.getComputationExecutor()).thenApplyAsync(ctxt -> {
    try {
      return handler.after(ctxt.workingDir.toPath(),ctxt.report);
    }
 catch (    IOException e) {
      throw new UncheckedIOException(e);
    }
 finally {
      try {
        ctxt.workingDir.close();
      }
 catch (      IOException e2) {
        LOGGER.error(e2.toString(),e2);
      }
    }
  }
,executorContext.getComputationExecutor());
}","The original code threw unchecked exceptions when closing the working directory, potentially interrupting error handling and resource cleanup. In the fixed code, IOException during working directory closure is now logged using LOGGER.error() instead of throwing an exception, preventing unexpected termination. This approach ensures graceful error handling, maintains resource management, and allows the method to complete its execution even if a minor I/O issue occurs during cleanup."
38901,"public MpiComputationManager(Path localDir,MpiJobScheduler scheduler,MpiStatistics statistics,MpiExecutorContext executorContext) throws IOException, InterruptedException {
  this.localDir=Objects.requireNonNull(localDir);
  this.statistics=Objects.requireNonNull(statistics);
  this.executorContext=Objects.requireNonNull(executorContext);
  this.scheduler=scheduler;
  if (executorContext.getMonitorExecutor() != null) {
    busyCoresPrintTask=executorContext.getMonitorExecutor().scheduleAtFixedRate(new Runnable(){
      @Override public void run(){
        LOGGER.info(""String_Node_Str"",scheduler.getResources().getBusyCores(),scheduler.getResources().getAvailableCores(),((float)scheduler.getStartedTasksAndReset()) / LOG_DELAY);
      }
    }
,0,LOG_DELAY,TimeUnit.SECONDS);
  }
}","public MpiComputationManager(Path localDir,MpiJobScheduler scheduler,MpiStatistics statistics,MpiExecutorContext executorContext){
  this.localDir=Objects.requireNonNull(localDir);
  this.statistics=Objects.requireNonNull(statistics);
  this.executorContext=Objects.requireNonNull(executorContext);
  this.scheduler=scheduler;
  if (executorContext.getMonitorExecutor() != null) {
    busyCoresPrintTask=executorContext.getMonitorExecutor().scheduleAtFixedRate(() -> LOGGER.info(""String_Node_Str"",scheduler.getResources().getBusyCores(),scheduler.getResources().getAvailableCores(),((float)scheduler.getStartedTasksAndReset()) / LOG_DELAY),0,LOG_DELAY,TimeUnit.SECONDS);
  }
}","The original code used an anonymous inner class with a verbose `Runnable` implementation, which was unnecessarily complex for a simple logging task. The fixed code replaces this with a lambda expression, simplifying the syntax and making the code more concise and readable. By using a lambda, the code becomes more compact, easier to understand, and maintains the same functional behavior of scheduling a periodic logging task."
38902,"@Override public OutputStream newCommonFile(final String fileName) throws IOException {
  return new OutputStream(){
    private final ByteArrayOutputStream buffer=new ByteArrayOutputStream();
    private int chunk=0;
    private void checkSize(    boolean last) throws IOException {
      if (last || buffer.size() > CHUNK_MAX_SIZE) {
        scheduler.sendCommonFile(new CommonFile(fileName,buffer.toByteArray(),chunk++,last));
        buffer.reset();
      }
    }
    @Override public void write(    int b) throws IOException {
      buffer.write(b);
      checkSize(false);
    }
    @Override public void write(    byte[] b) throws IOException {
      buffer.write(b);
      checkSize(false);
    }
    @Override public void write(    byte[] b,    int off,    int len) throws IOException {
      buffer.write(b,off,len);
      checkSize(false);
    }
    @Override public void flush() throws IOException {
      buffer.flush();
    }
    @Override public void close() throws IOException {
      buffer.close();
      checkSize(true);
    }
  }
;
}","@Override public OutputStream newCommonFile(final String fileName) throws IOException {
  return new OutputStream(){
    private final ByteArrayOutputStream buffer=new ByteArrayOutputStream();
    private int chunk=0;
    private void checkSize(    boolean last){
      if (last || buffer.size() > CHUNK_MAX_SIZE) {
        scheduler.sendCommonFile(new CommonFile(fileName,buffer.toByteArray(),chunk++,last));
        buffer.reset();
      }
    }
    @Override public void write(    int b) throws IOException {
      buffer.write(b);
      checkSize(false);
    }
    @Override public void write(    byte[] b) throws IOException {
      buffer.write(b);
      checkSize(false);
    }
    @Override public void write(    byte[] b,    int off,    int len) throws IOException {
      buffer.write(b,off,len);
      checkSize(false);
    }
    @Override public void flush() throws IOException {
      buffer.flush();
    }
    @Override public void close() throws IOException {
      buffer.close();
      checkSize(true);
    }
  }
;
}","The original code incorrectly throws an IOException in the checkSize method, which could interrupt file chunk transmission during large file processing. The fixed code removes the IOException from the checkSize method signature, allowing smoother file chunk handling without breaking the file transfer process. This modification ensures more robust file streaming by preventing potential interruptions during chunk generation and transmission."
38903,"@Override public void close() throws Exception {
  scheduler.shutdown();
  statistics.close();
  if (busyCoresPrintTask != null) {
    busyCoresPrintTask.cancel(true);
  }
}","@Override public void close(){
  try {
    scheduler.shutdown();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  try {
    statistics.close();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
  if (busyCoresPrintTask != null) {
    busyCoresPrintTask.cancel(true);
  }
  try {
    executorContext.shutdown();
  }
 catch (  Exception e) {
    LOGGER.error(e.toString(),e);
  }
}","The original code throws an exception if `scheduler.shutdown()` fails, potentially preventing subsequent cleanup operations from executing. The fixed code wraps each potentially throwing operation in a separate try-catch block, logging errors without interrupting the entire close sequence and adding an additional `executorContext.shutdown()` call. This approach ensures robust resource cleanup, prevents cascading failures, and provides comprehensive error logging for diagnostic purposes."
38904,"public static ComputationManager createMpiComputationManager(CommandLine line,FileSystem fileSystem){
  Path tmpDir=fileSystem.getPath(line.hasOption(""String_Node_Str"") ? line.getOptionValue(""String_Node_Str"") : System.getProperty(""String_Node_Str""));
  Path statisticsDbDir=line.hasOption(""String_Node_Str"") ? fileSystem.getPath(line.getOptionValue(""String_Node_Str"")) : null;
  String statisticsDbName=line.hasOption(""String_Node_Str"") ? line.getOptionValue(""String_Node_Str"") : null;
  int coresPerRank=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  boolean verbose=line.hasOption(""String_Node_Str"");
  Path stdOutArchive=line.hasOption(""String_Node_Str"") ? fileSystem.getPath(line.getOptionValue(""String_Node_Str"")) : null;
  ComponentDefaultConfig config=ComponentDefaultConfig.load();
  MpiExecutorContext mpiExecutorContext=new MpiExecutorContext();
  MpiStatisticsFactory statisticsFactory=createMpiStatisticsFactory(config,statisticsDbDir,statisticsDbName);
  try {
    MpiStatistics statistics=statisticsFactory.create(statisticsDbDir,statisticsDbName);
    return new MpiComputationManager(tmpDir,statistics,mpiExecutorContext,coresPerRank,verbose,stdOutArchive){
      @Override public void close() throws Exception {
        try {
          super.close();
        }
 catch (        Exception e) {
          LOGGER.error(e.toString(),e);
        }
        try {
          statistics.close();
        }
 catch (        Exception e) {
          LOGGER.error(e.toString(),e);
        }
        try {
          mpiExecutorContext.shutdown();
        }
 catch (        Exception e) {
          LOGGER.error(e.toString(),e);
        }
      }
    }
;
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
catch (  InterruptedException e) {
    throw new UncheckedInterruptedException(e);
  }
}","public static ComputationManager createMpiComputationManager(CommandLine line,FileSystem fileSystem){
  Path tmpDir=fileSystem.getPath(line.hasOption(""String_Node_Str"") ? line.getOptionValue(""String_Node_Str"") : System.getProperty(""String_Node_Str""));
  Path statisticsDbDir=line.hasOption(""String_Node_Str"") ? fileSystem.getPath(line.getOptionValue(""String_Node_Str"")) : null;
  String statisticsDbName=line.hasOption(""String_Node_Str"") ? line.getOptionValue(""String_Node_Str"") : null;
  int coresPerRank=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
  boolean verbose=line.hasOption(""String_Node_Str"");
  Path stdOutArchive=line.hasOption(""String_Node_Str"") ? fileSystem.getPath(line.getOptionValue(""String_Node_Str"")) : null;
  ComponentDefaultConfig config=ComponentDefaultConfig.load();
  MpiStatisticsFactory statisticsFactory=createMpiStatisticsFactory(config,statisticsDbDir,statisticsDbName);
  try {
    return new MpiComputationManager(tmpDir,statisticsFactory.create(statisticsDbDir,statisticsDbName),new MpiExecutorContext(),coresPerRank,verbose,stdOutArchive);
  }
 catch (  IOException e) {
    throw new UncheckedIOException(e);
  }
catch (  InterruptedException e) {
    throw new UncheckedInterruptedException(e);
  }
}","The original code unnecessarily created a separate MpiExecutorContext and MpiStatistics object before instantiating MpiComputationManager, leading to potential resource management complexities. The fixed code directly creates these objects within the MpiComputationManager constructor, simplifying the initialization process and reducing redundant variable declarations. This approach enhances code readability, reduces potential memory leaks, and provides a more streamlined and efficient method of creating the computation manager."
38905,"@Override public void close() throws Exception {
}","@Override public void close(){
}","The original code incorrectly declares a `throws Exception` clause in the `close()` method, which is unnecessary and can lead to unintended exception handling. The fixed code removes the `throws` clause, simplifying the method signature and allowing for cleaner implementation of the `close()` method. By eliminating the unnecessary exception declaration, the code becomes more straightforward and reduces potential complexity in exception management."
38906,"public static TsoGeneratorSpeedAutomaton fromXml(String contingencyId,XMLStreamReader xmlsr) throws XMLStreamException {
  boolean under=false;
  boolean over=false;
  String text=null;
  List<String> onUnderSpeedDiconnectedGenerators=new ArrayList<>();
  List<String> onOverSpeedDiconnectedGenerators=new ArrayList<>();
  while (xmlsr.hasNext()) {
    int eventType=xmlsr.next();
switch (eventType) {
case XMLEvent.CHARACTERS:
      text=xmlsr.getText();
    break;
case XMLEvent.START_ELEMENT:
switch (xmlsr.getLocalName()) {
case ""String_Node_Str"":
    under=true;
  break;
case ""String_Node_Str"":
over=true;
break;
}
break;
case XMLEvent.END_ELEMENT:
switch (xmlsr.getLocalName()) {
case ""String_Node_Str"":
under=false;
break;
case ""String_Node_Str"":
over=false;
break;
case ""String_Node_Str"":
if (under) {
onUnderSpeedDiconnectedGenerators.add(text);
}
 else if (over) {
onOverSpeedDiconnectedGenerators.add(text);
}
 else {
throw new AssertionError();
}
break;
case ""String_Node_Str"":
return new TsoGeneratorSpeedAutomaton(contingencyId,onUnderSpeedDiconnectedGenerators,onOverSpeedDiconnectedGenerators);
}
break;
}
}
throw new AssertionError(""String_Node_Str"");
}","public static TsoGeneratorSpeedAutomaton fromXml(String contingencyId,XMLStreamReader xmlsr) throws XMLStreamException {
  LimitsXmlParsingState state=null;
  String text=null;
  List<String> onUnderSpeedDiconnectedGenerators=new ArrayList<>();
  List<String> onOverSpeedDiconnectedGenerators=new ArrayList<>();
  while (xmlsr.hasNext()) {
    int eventType=xmlsr.next();
switch (eventType) {
case XMLEvent.CHARACTERS:
      text=xmlsr.getText();
    break;
case XMLEvent.START_ELEMENT:
switch (xmlsr.getLocalName()) {
case ON_UNDER_SPEED_DISCONNECTED_GENERATORS:
    state=LimitsXmlParsingState.UNDER;
  break;
case ON_OVER_SPEED_DISCONNECTED_GENERATORS:
state=LimitsXmlParsingState.OVER;
break;
}
break;
case XMLEvent.END_ELEMENT:
switch (xmlsr.getLocalName()) {
case ON_UNDER_SPEED_DISCONNECTED_GENERATORS:
case ON_OVER_SPEED_DISCONNECTED_GENERATORS:
state=null;
break;
case ""String_Node_Str"":
LimitsXmlParsingState.addGenerator(state,text,onUnderSpeedDiconnectedGenerators,onOverSpeedDiconnectedGenerators);
break;
case ""String_Node_Str"":
return new TsoGeneratorSpeedAutomaton(contingencyId,onUnderSpeedDiconnectedGenerators,onOverSpeedDiconnectedGenerators);
}
break;
}
}
throw new AssertionError(""String_Node_Str"");
}","The original code has duplicate case labels and confusing boolean flags, leading to potential parsing errors and unclear state management. The fixed code introduces an enum-based state tracking mechanism (LimitsXmlParsingState) and separates parsing logic with clearer, more explicit state transitions. This refactoring improves code readability, reduces complexity, and provides a more robust XML parsing approach with better error handling and maintainability."
38907,"public static TsoGeneratorVoltageAutomaton fromXml(String contingencyId,XMLStreamReader xmlsr) throws XMLStreamException {
  boolean under=false;
  boolean over=false;
  String text=null;
  List<String> onUnderVoltageDiconnectedGenerators=new ArrayList<>();
  List<String> onOverVoltageDiconnectedGenerators=new ArrayList<>();
  while (xmlsr.hasNext()) {
    int eventType=xmlsr.next();
switch (eventType) {
case XMLEvent.CHARACTERS:
      text=xmlsr.getText();
    break;
case XMLEvent.START_ELEMENT:
switch (xmlsr.getLocalName()) {
case ""String_Node_Str"":
    under=true;
  break;
case ""String_Node_Str"":
over=true;
break;
}
break;
case XMLEvent.END_ELEMENT:
switch (xmlsr.getLocalName()) {
case ""String_Node_Str"":
under=false;
break;
case ""String_Node_Str"":
over=false;
break;
case ""String_Node_Str"":
if (under) {
onUnderVoltageDiconnectedGenerators.add(text);
}
 else if (over) {
onOverVoltageDiconnectedGenerators.add(text);
}
 else {
throw new AssertionError();
}
break;
case ""String_Node_Str"":
return new TsoGeneratorVoltageAutomaton(contingencyId,onUnderVoltageDiconnectedGenerators,onOverVoltageDiconnectedGenerators);
}
break;
}
}
throw new AssertionError(""String_Node_Str"");
}","public static TsoGeneratorVoltageAutomaton fromXml(String contingencyId,XMLStreamReader xmlsr) throws XMLStreamException {
  LimitsXmlParsingState state=null;
  String text=null;
  List<String> onUnderVoltageDiconnectedGenerators=new ArrayList<>();
  List<String> onOverVoltageDiconnectedGenerators=new ArrayList<>();
  while (xmlsr.hasNext()) {
    int eventType=xmlsr.next();
switch (eventType) {
case XMLEvent.CHARACTERS:
      text=xmlsr.getText();
    break;
case XMLEvent.START_ELEMENT:
switch (xmlsr.getLocalName()) {
case ON_UNDER_VOLTAGE_DISCONNECTED_GENERATORS:
    state=LimitsXmlParsingState.UNDER;
  break;
case ON_OVER_VOLTAGE_DISCONNECTED_GENERATORS:
state=LimitsXmlParsingState.OVER;
break;
}
break;
case XMLEvent.END_ELEMENT:
switch (xmlsr.getLocalName()) {
case ON_UNDER_VOLTAGE_DISCONNECTED_GENERATORS:
case ON_OVER_VOLTAGE_DISCONNECTED_GENERATORS:
state=null;
break;
case ""String_Node_Str"":
LimitsXmlParsingState.addGenerator(state,text,onUnderVoltageDiconnectedGenerators,onOverVoltageDiconnectedGenerators);
break;
case ""String_Node_Str"":
return new TsoGeneratorVoltageAutomaton(contingencyId,onUnderVoltageDiconnectedGenerators,onOverVoltageDiconnectedGenerators);
}
break;
}
}
throw new AssertionError(""String_Node_Str"");
}","The original code had duplicate case labels and ambiguous boolean flags, leading to potential parsing errors and unpredictable behavior. The fixed code introduces an enum-based state tracking mechanism (LimitsXmlParsingState) and extracts generator addition logic into a separate method, providing clearer state management and more robust XML parsing. This approach enhances code readability, reduces complexity, and ensures more reliable XML stream processing for generator voltage automaton creation."
38908,"private UndirectedGraph<UcteNodeCode,Object> createSubstationGraph(UcteNetwork network){
  UndirectedGraph<UcteNodeCode,Object> graph=new Pseudograph<>(Object.class);
  for (  UcteNode node : network.getNodes()) {
    graph.addVertex(node.getCode());
  }
  Multimap<String,UcteNode> nodesByGeographicalSpot=Multimaps.index(network.getNodes(),new Function<UcteNode,String>(){
    @Override public String apply(    UcteNode node){
      return node.getCode().getGeographicalSpot();
    }
  }
);
  for (  Map.Entry<String,Collection<UcteNode>> entry : nodesByGeographicalSpot.asMap().entrySet()) {
    for (    UcteNode n1 : entry.getValue()) {
      for (      UcteNode n2 : entry.getValue()) {
        if (n1 != n2) {
          graph.addEdge(n1.getCode(),n2.getCode());
        }
      }
    }
  }
  for (  UcteTransformer tfo : network.getTransformers()) {
    UcteNodeCode nodeCode1=tfo.getId().getNodeCode1();
    UcteNodeCode nodeCode2=tfo.getId().getNodeCode2();
    graph.addEdge(nodeCode1,nodeCode2);
  }
  for (  UcteLine l : network.getLines()) {
    UcteNodeCode nodeCode1=l.getId().getNodeCode1();
    UcteNodeCode nodeCode2=l.getId().getNodeCode2();
    if (l.getStatus() == UcteElementStatus.BUSBAR_COUPLER_IN_OPERATION || l.getStatus() == UcteElementStatus.BUSBAR_COUPLER_OUT_OF_OPERATION) {
      graph.addEdge(nodeCode1,nodeCode2);
    }
 else {
      double z=Math.hypot(l.getResistance(),l.getReactance());
      if (z < lineMinZ) {
        graph.addEdge(nodeCode1,nodeCode2);
      }
    }
  }
  return graph;
}","private UndirectedGraph<UcteNodeCode,Object> createSubstationGraph(UcteNetwork network){
  UndirectedGraph<UcteNodeCode,Object> graph=new Pseudograph<>(Object.class);
  for (  UcteNode node : network.getNodes()) {
    graph.addVertex(node.getCode());
  }
  Multimap<String,UcteNode> nodesByGeographicalSpot=Multimaps.index(network.getNodes(),node -> node.getCode().getGeographicalSpot());
  for (  Map.Entry<String,Collection<UcteNode>> entry : nodesByGeographicalSpot.asMap().entrySet()) {
    for (    UcteNode n1 : entry.getValue()) {
      for (      UcteNode n2 : entry.getValue()) {
        if (n1 != n2) {
          graph.addEdge(n1.getCode(),n2.getCode());
        }
      }
    }
  }
  for (  UcteTransformer tfo : network.getTransformers()) {
    UcteNodeCode nodeCode1=tfo.getId().getNodeCode1();
    UcteNodeCode nodeCode2=tfo.getId().getNodeCode2();
    graph.addEdge(nodeCode1,nodeCode2);
  }
  for (  UcteLine l : network.getLines()) {
    UcteNodeCode nodeCode1=l.getId().getNodeCode1();
    UcteNodeCode nodeCode2=l.getId().getNodeCode2();
    if (l.getStatus() == UcteElementStatus.BUSBAR_COUPLER_IN_OPERATION || l.getStatus() == UcteElementStatus.BUSBAR_COUPLER_OUT_OF_OPERATION) {
      graph.addEdge(nodeCode1,nodeCode2);
    }
 else {
      double z=Math.hypot(l.getResistance(),l.getReactance());
      if (z < lineMinZ) {
        graph.addEdge(nodeCode1,nodeCode2);
      }
    }
  }
  return graph;
}","The original code used an anonymous inner class for the Multimap indexing function, which is verbose and less readable. The fixed code replaces this with a lambda expression, simplifying the syntax and making the code more concise. This change improves code readability and maintainability while preserving the same functional behavior of creating a graph based on geographical node spots."
38909,"private void updateSubstation(){
  if (substations == null) {
    LOGGER.trace(""String_Node_Str"");
    substations=new ArrayList<>();
    node2voltageLevel=new HashMap<>();
    UndirectedGraph<UcteNodeCode,Object> graph=createSubstationGraph(network);
    for (    Set<UcteNodeCode> substationNodes : new ConnectivityInspector<>(graph).connectedSets()) {
      UcteNodeCode mainNode=substationNodes.stream().sorted((nodeCode1,nodeCode2) -> {
        if (nodeCode1.getUcteCountryCode() == UcteCountryCode.XX && nodeCode2.getUcteCountryCode() != UcteCountryCode.XX) {
          return 1;
        }
 else         if (nodeCode1.getUcteCountryCode() != UcteCountryCode.XX && nodeCode2.getUcteCountryCode() == UcteCountryCode.XX) {
          return -1;
        }
 else {
          int c=Float.compare(nodeCode2.getVoltageLevelCode().getVoltageLevel(),nodeCode1.getVoltageLevelCode().getVoltageLevel());
          if (c == 0) {
            c=nodeCode2.getBusbar().compareTo(nodeCode1.getBusbar());
          }
          return c;
        }
      }
).findFirst().get();
      Multimap<UcteVoltageLevelCode,UcteNodeCode> nodesByVoltageLevel=Multimaps.index(substationNodes,nodeCode -> {
        return nodeCode.getVoltageLevelCode();
      }
);
      String substationName=mainNode.getUcteCountryCode().getUcteCode() + mainNode.getGeographicalSpot();
      List<UcteVoltageLevel> voltageLevels=new ArrayList<>();
      UcteSubstation substation=new UcteSubstation(substationName,voltageLevels);
      substations.add(substation);
      LOGGER.trace(""String_Node_Str"",substationName);
      for (      Map.Entry<UcteVoltageLevelCode,Collection<UcteNodeCode>> entry : nodesByVoltageLevel.asMap().entrySet()) {
        UcteVoltageLevelCode vlc=entry.getKey();
        Collection<UcteNodeCode> voltageLevelNodes=entry.getValue();
        String voltageLevelName=mainNode.getUcteCountryCode().getUcteCode() + mainNode.getGeographicalSpot() + vlc.ordinal();
        UcteVoltageLevel voltageLevel=new UcteVoltageLevel(voltageLevelName,substation,voltageLevelNodes);
        voltageLevels.add(voltageLevel);
        for (        UcteNodeCode voltageLevelNode : voltageLevelNodes) {
          node2voltageLevel.put(voltageLevelNode,voltageLevel);
        }
        LOGGER.trace(""String_Node_Str"",voltageLevelName,voltageLevelNodes);
      }
    }
  }
}","private void updateSubstation(){
  if (substations == null) {
    LOGGER.trace(""String_Node_Str"");
    substations=new ArrayList<>();
    node2voltageLevel=new HashMap<>();
    UndirectedGraph<UcteNodeCode,Object> graph=createSubstationGraph(network);
    for (    Set<UcteNodeCode> substationNodes : new ConnectivityInspector<>(graph).connectedSets()) {
      UcteNodeCode mainNode=substationNodes.stream().sorted((nodeCode1,nodeCode2) -> {
        if (nodeCode1.getUcteCountryCode() == UcteCountryCode.XX && nodeCode2.getUcteCountryCode() != UcteCountryCode.XX) {
          return 1;
        }
 else         if (nodeCode1.getUcteCountryCode() != UcteCountryCode.XX && nodeCode2.getUcteCountryCode() == UcteCountryCode.XX) {
          return -1;
        }
 else {
          int c=Float.compare(nodeCode2.getVoltageLevelCode().getVoltageLevel(),nodeCode1.getVoltageLevelCode().getVoltageLevel());
          if (c == 0) {
            c=nodeCode2.getBusbar().compareTo(nodeCode1.getBusbar());
          }
          return c;
        }
      }
).findFirst().orElseThrow(() -> new AssertionError());
      Multimap<UcteVoltageLevelCode,UcteNodeCode> nodesByVoltageLevel=Multimaps.index(substationNodes,UcteNodeCode::getVoltageLevelCode);
      String substationName=mainNode.getUcteCountryCode().getUcteCode() + mainNode.getGeographicalSpot();
      List<UcteVoltageLevel> voltageLevels=new ArrayList<>();
      UcteSubstation substation=new UcteSubstation(substationName,voltageLevels);
      substations.add(substation);
      LOGGER.trace(""String_Node_Str"",substationName);
      for (      Map.Entry<UcteVoltageLevelCode,Collection<UcteNodeCode>> entry : nodesByVoltageLevel.asMap().entrySet()) {
        UcteVoltageLevelCode vlc=entry.getKey();
        Collection<UcteNodeCode> voltageLevelNodes=entry.getValue();
        String voltageLevelName=mainNode.getUcteCountryCode().getUcteCode() + mainNode.getGeographicalSpot() + vlc.ordinal();
        UcteVoltageLevel voltageLevel=new UcteVoltageLevel(voltageLevelName,substation,voltageLevelNodes);
        voltageLevels.add(voltageLevel);
        for (        UcteNodeCode voltageLevelNode : voltageLevelNodes) {
          node2voltageLevel.put(voltageLevelNode,voltageLevel);
        }
        LOGGER.trace(""String_Node_Str"",voltageLevelName,voltageLevelNodes);
      }
    }
  }
}","The original code lacks error handling when the stream's findFirst() method might return an empty Optional, potentially causing a NoSuchElementException. The fixed code replaces .get() with .orElseThrow(() -> new AssertionError()), ensuring a predictable error response if no main node is found. This modification adds robust error handling, preventing potential runtime crashes and providing a clear indication of unexpected stream processing scenarios."
38910,"@Override public void findMaximalFlowTap(Network network,String phaseShifterId){
  TwoWindingsTransformer phaseShifter=network.getTwoWindingsTransformer(phaseShifterId);
  if (phaseShifter == null) {
    throw new RuntimeException(""String_Node_Str"" + phaseShifterId + ""String_Node_Str"");
  }
  if (phaseShifter.getPhaseTapChanger() == null) {
    throw new RuntimeException(""String_Node_Str"" + phaseShifterId + ""String_Node_Str"");
  }
  int optimalTap;
  String stateId=network.getStateManager().getWorkingStateId();
  String tmpStateId=""String_Node_Str"" + UUID.randomUUID();
  network.getStateManager().cloneState(stateId,tmpStateId);
  try {
    network.getStateManager().setWorkingState(tmpStateId);
    LoadFlowFactory loadFlowFactory=config.getLoadFlowFactoryClass().newInstance();
    LoadFlow loadFlow=loadFlowFactory.create(network,computationManager,0);
    runLoadFlow(loadFlow);
    if (phaseShifter.getTerminal1().getP() >= phaseShifter.getCurrentLimits1().getPermanentLimit()) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int tapPosInc=1;
    float i;
    float limit=getLimit(phaseShifter);
    int tapPos=phaseShifter.getPhaseTapChanger().getTapPosition();
    int maxTap=phaseShifter.getPhaseTapChanger().getHighTapPosition();
    while ((i=getI(phaseShifter)) < limit && tapPos < maxTap) {
      tapPos+=tapPosInc;
      phaseShifter.getPhaseTapChanger().setTapPosition(tapPos);
      runLoadFlow(loadFlow);
      if (getI(phaseShifter) < i) {
        tapPosInc*=-1;
      }
    }
    if (i < limit) {
      optimalTap=phaseShifter.getPhaseTapChanger().getTapPosition();
    }
 else {
      optimalTap=phaseShifter.getPhaseTapChanger().getTapPosition() - tapPosInc;
      phaseShifter.getPhaseTapChanger().setTapPosition(optimalTap);
      runLoadFlow(loadFlow);
      if (getI(phaseShifter) >= limit) {
        throw new AssertionError(""String_Node_Str"");
      }
    }
  }
 catch (  IllegalAccessException e) {
    throw new UncheckedIllegalAccessException(e);
  }
catch (  InstantiationException e) {
    throw new UncheckedInstantiationException(e);
  }
 finally {
    network.getStateManager().removeState(tmpStateId);
    network.getStateManager().setWorkingState(stateId);
  }
  LOGGER.debug(""String_Node_Str"",phaseShifter,optimalTap,phaseShifter.getPhaseTapChanger().getTapPosition());
  phaseShifter.getPhaseTapChanger().setTapPosition(optimalTap);
}","@Override public void findMaximalFlowTap(Network network,String phaseShifterId){
  TwoWindingsTransformer phaseShifter=network.getTwoWindingsTransformer(phaseShifterId);
  if (phaseShifter == null) {
    throw new RuntimeException(""String_Node_Str"" + phaseShifterId + ""String_Node_Str"");
  }
  if (phaseShifter.getPhaseTapChanger() == null) {
    throw new RuntimeException(""String_Node_Str"" + phaseShifterId + ""String_Node_Str"");
  }
  int optimalTap;
  String stateId=network.getStateManager().getWorkingStateId();
  String tmpStateId=""String_Node_Str"" + UUID.randomUUID();
  network.getStateManager().cloneState(stateId,tmpStateId);
  try {
    network.getStateManager().setWorkingState(tmpStateId);
    LoadFlowFactory loadFlowFactory=config.getLoadFlowFactoryClass().newInstance();
    LoadFlow loadFlow=loadFlowFactory.create(network,computationManager,0);
    runLoadFlow(loadFlow);
    if (phaseShifter.getTerminal1().getI() >= phaseShifter.getCurrentLimits1().getPermanentLimit()) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int tapPosInc=1;
    float i;
    float limit=getLimit(phaseShifter);
    int tapPos=phaseShifter.getPhaseTapChanger().getTapPosition();
    int maxTap=phaseShifter.getPhaseTapChanger().getHighTapPosition();
    while ((i=getI(phaseShifter)) < limit && tapPos < maxTap) {
      tapPos+=tapPosInc;
      phaseShifter.getPhaseTapChanger().setTapPosition(tapPos);
      runLoadFlow(loadFlow);
      if (getI(phaseShifter) < i) {
        tapPosInc*=-1;
      }
    }
    if (i < limit) {
      optimalTap=phaseShifter.getPhaseTapChanger().getTapPosition();
    }
 else {
      optimalTap=phaseShifter.getPhaseTapChanger().getTapPosition() - tapPosInc;
      phaseShifter.getPhaseTapChanger().setTapPosition(optimalTap);
      runLoadFlow(loadFlow);
      if (getI(phaseShifter) >= limit) {
        throw new AssertionError(""String_Node_Str"");
      }
    }
  }
 catch (  IllegalAccessException e) {
    throw new UncheckedIllegalAccessException(e);
  }
catch (  InstantiationException e) {
    throw new UncheckedInstantiationException(e);
  }
 finally {
    network.getStateManager().removeState(tmpStateId);
    network.getStateManager().setWorkingState(stateId);
  }
  LOGGER.debug(""String_Node_Str"",phaseShifter,optimalTap,phaseShifter.getPhaseTapChanger().getTapPosition());
  phaseShifter.getPhaseTapChanger().setTapPosition(optimalTap);
}","The original code incorrectly used `getTerminal1().getP()` to check current limits, which measures power instead of current. In the fixed code, `getTerminal1().getI()` is used, correctly measuring the actual current flowing through the transformer. This change ensures accurate current limit validation, preventing potential overloading scenarios and improving the reliability of the phase shifter tap position calculation."
38911,"@Override public HalfLineImpl setXnodeQ(float xnodeQ){
  this.xnodeQ=xnodeQ;
  return null;
}","@Override public HalfLineImpl setXnodeQ(float xnodeQ){
  this.xnodeQ=xnodeQ;
  return this;
}","The original code incorrectly returns null when setting the xnodeQ value, breaking the method's expected behavior of returning the updated object. The fixed code returns 'this', which is the current HalfLineImpl instance, enabling method chaining and preserving the object's state after modification. By returning the object itself, the code allows for more fluent and chainable method calls, improving code readability and usability."
38912,"public void readCsv(BufferedReader reader,char separator){
  try {
    String strSep=Character.toString(separator);
    String line;
    while ((line=reader.readLine()) != null) {
      String trimmedLine=line.trim();
      if (trimmedLine.isEmpty()) {
        continue;
      }
      String[] tokens=trimmedLine.split(strSep);
      if (tokens.length != 2) {
        LOGGER.warn(""String_Node_Str"",trimmedLine);
        continue;
      }
      mapping.put(tokens[0],tokens[1]);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public void readCsv(BufferedReader reader,char separator){
  CsvListReader csvReader=new CsvListReader(reader,createPreference(separator));
  List<String> nextLine;
  try {
    while ((nextLine=csvReader.read()) != null) {
      if (nextLine.size() != 2) {
        throw new RuntimeException(""String_Node_Str"" + nextLine + ""String_Node_Str"");
      }
      mapping.put(nextLine.get(0),nextLine.get(1));
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","The original code uses basic string splitting, which can fail with complex CSV data containing escaped separators or quoted fields. The fixed code employs a robust CsvListReader that handles CSV parsing intricacies, ensuring proper tokenization and field extraction. This approach provides more reliable CSV parsing, preventing potential data misinterpretation and improving overall parsing accuracy."
38913,"public void writeCsv(BufferedWriter writer,char separator){
  mapping.forEach((s,s2) -> {
    try {
      writer.write(s);
      writer.write(separator);
      writer.write(s2);
      writer.newLine();
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
);
}","public void writeCsv(BufferedWriter writer,char separator){
  CsvListWriter csvWriter=new CsvListWriter(writer,createPreference(separator));
  String[] nextLine=new String[2];
  try {
    try {
      for (      Map.Entry<String,String> e : mapping.entrySet()) {
        nextLine[0]=e.getKey();
        nextLine[1]=e.getValue();
        csvWriter.write(nextLine);
      }
    }
  finally {
      csvWriter.flush();
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","The original code directly writes to a BufferedWriter, which can lead to inefficient CSV writing and potential formatting issues with complex data. The fixed code uses CsvListWriter, which provides proper CSV handling, including escaping and quoting of values, and ensures correct CSV formatting. This approach improves robustness, handles edge cases more gracefully, and provides a more standardized method for writing CSV data with better performance and reliability."
38914,"@Test public void invalidFileTest() throws IOException {
  String csv=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  StringAnonymizer anonymizer=fromCsv(csv);
  assertEquals(1,anonymizer.getStringCount());
}","@Test public void invalidFileTest() throws IOException {
  String csv=String.join(System.lineSeparator(),""String_Node_Str"",""String_Node_Str"");
  StringAnonymizer anonymizer=fromCsv(csv);
  assertEquals(1,anonymizer.getStringCount());
}","The original code incorrectly included three identical lines in the CSV, which likely caused unexpected behavior in the StringAnonymizer's string count calculation. The fixed code removes the redundant third line, ensuring that only two unique strings are present in the input. This modification leads to a more predictable and accurate string count, matching the expected result of one unique string in the anonymizer."
38915,"public void readCsv(BufferedReader reader,char separator){
  try {
    String strSep=Character.toString(separator);
    String line;
    while ((line=reader.readLine()) != null) {
      String[] tokens=line.split(strSep);
      mapping.put(tokens[0],tokens[1]);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public void readCsv(BufferedReader reader,char separator){
  try {
    String strSep=Character.toString(separator);
    String line;
    while ((line=reader.readLine()) != null) {
      String trimmedLine=line.trim();
      if (trimmedLine.isEmpty()) {
        continue;
      }
      String[] tokens=trimmedLine.split(strSep);
      if (tokens.length != 2) {
        LOGGER.warn(""String_Node_Str"",trimmedLine);
        continue;
      }
      mapping.put(tokens[0],tokens[1]);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","The original code lacks handling for empty lines and malformed CSV entries, potentially causing unexpected behavior or errors during parsing. The fixed code adds trimming of lines, skips empty lines, and validates the number of tokens, ensuring only valid two-column entries are processed with a warning logged for problematic lines. These modifications make the CSV reading more robust, preventing potential runtime exceptions and improving data integrity during file parsing."
38916,Integer getOptionalIntProperty(String name);,@Deprecated Integer getOptionalIntProperty(String name);,"The original code lacks clear indication that the method might return a potentially null or deprecated integer property, which could lead to unexpected null pointer exceptions. By adding the @Deprecated annotation, the code now signals that this method is not recommended for future use and warns developers about potential risks when accessing the property. This annotation provides a clear semantic hint about the method's status and encourages developers to seek alternative, more robust implementations for retrieving integer properties."
38917,Boolean getOptinalBooleanProperty(String name);,@Deprecated Boolean getOptinalBooleanProperty(String name);,"The original method lacks a clear indication of its deprecated status, potentially leading to continued use of an outdated or problematic implementation. The `@Deprecated` annotation explicitly marks the method as no longer recommended, signaling to developers that this method should not be used in new code and may be removed in future versions. By adding this annotation, the code provides a clear warning and encourages developers to seek alternative, more current implementations of the method."
38918,"public static Table<String,String,Float> parseMatrix(Reader reader) throws IOException {
  Table<String,String,Float> table=HashBasedTable.create();
  try (ICsvListReader csvReader=new CsvListReader(reader,CsvPreference.STANDARD_PREFERENCE)){
    List<String> columnHeaders=csvReader.read();
    List<String> row;
    while ((row=csvReader.read()) != null) {
      String rowHeader=row.get(0);
      for (int i=1; i < row.size(); i++) {
        String columnHeader=columnHeaders.get(i);
        String value=row.get(i);
        table.put(rowHeader,columnHeader,value == null ? Float.NaN : Float.valueOf(value));
      }
    }
  }
   return table;
}","public static Table<String,String,Float> parseMatrix(Reader reader) throws IOException {
  Table<String,String,Float> table=HashBasedTable.create();
  try (ICsvListReader csvReader=new CsvListReader(reader,CsvPreference.STANDARD_PREFERENCE)){
    List<String> columnHeaders=csvReader.read();
    List<String> row;
    while ((row=csvReader.read()) != null) {
      String rowHeader=row.get(0);
      for (int i=1; i < row.size(); i++) {
        String columnHeader=columnHeaders.get(i);
        String value=row.get(i);
        table.put(rowHeader,columnHeader,value == null ? Float.NaN : Float.parseFloat(value));
      }
    }
  }
   return table;
}","The original code uses `Float.valueOf(value)`, which throws a `NumberFormatException` if the value is an empty string or contains non-numeric characters. The fixed code replaces this with `Float.parseFloat(value)`, which handles parsing more robustly and allows for consistent float conversion. This change ensures that the CSV parsing method can handle varied input formats while maintaining type safety and preventing potential runtime errors."
38919,"public AsciiTableFormatter(String title,Column... columns){
  this(new OutputStreamWriter(System.out),title,TableFormatterConfig.load(),columns);
}","public AsciiTableFormatter(String title,Column... columns){
  this(new OutputStreamWriter(System.out,StandardCharsets.UTF_8),title,TableFormatterConfig.load(),columns);
}","The original code lacks explicit character encoding when creating an OutputStreamWriter, which can lead to platform-dependent default encoding and potential character rendering issues. The fixed code specifies UTF-8 encoding using StandardCharsets.UTF_8, ensuring consistent and universal character representation across different systems and platforms. This change guarantees predictable text output and prevents potential internationalization and character encoding problems."
38920,"@Test public void moduleConfigTest() throws IOException, XMLStreamException, SAXException, ParserConfigurationException {
  try (FileSystem fileSystem=Jimfs.newFileSystem(Configuration.unix())){
    Path cfgDir=Files.createDirectory(fileSystem.getPath(""String_Node_Str""));
    Properties prop1=new Properties();
    prop1.setProperty(""String_Node_Str"",""String_Node_Str"");
    prop1.setProperty(""String_Node_Str"",Integer.toString(3));
    prop1.setProperty(""String_Node_Str"",Boolean.FALSE.toString());
    prop1.setProperty(""String_Node_Str"",Double.toString(2.3));
    prop1.setProperty(""String_Node_Str"",ArrayList.class.getName());
    prop1.setProperty(""String_Node_Str"",""String_Node_Str"");
    prop1.setProperty(""String_Node_Str"",""String_Node_Str"");
    prop1.setProperty(""String_Node_Str"",StandardOpenOption.APPEND.name());
    prop1.setProperty(""String_Node_Str"",StandardOpenOption.APPEND + ""String_Node_Str"" + StandardOpenOption.CREATE);
    Path p=fileSystem.getPath(""String_Node_Str"");
    Path p2=fileSystem.getPath(""String_Node_Str"");
    prop1.setProperty(""String_Node_Str"",p.toString());
    prop1.setProperty(""String_Node_Str"",p.toString() + ""String_Node_Str"" + p2.toString());
    prop1.setProperty(""String_Node_Str"",p.toString() + ""String_Node_Str"" + p2.toString());
    try (Writer w=Files.newBufferedWriter(cfgDir.resolve(""String_Node_Str""),StandardCharsets.UTF_8)){
      prop1.store(w,null);
    }
     PropertiesPlatformConfig propsConfig=new PropertiesPlatformConfig(cfgDir,fileSystem);
    ModuleConfig modConfig=propsConfig.getModuleConfig(""String_Node_Str"");
    Assert.assertTrue(modConfig.getStringProperty(""String_Node_Str"").equals(""String_Node_Str""));
    Assert.assertTrue(modConfig.getStringProperty(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str""));
    try {
      modConfig.getStringProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getIntProperty(""String_Node_Str"") == 3);
    try {
      modConfig.getIntProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getOptionalIntProperty(""String_Node_Str"") == null);
    Assert.assertTrue(modConfig.getIntProperty(""String_Node_Str"",4) == 4);
    Assert.assertFalse(modConfig.getBooleanProperty(""String_Node_Str""));
    try {
      modConfig.getBooleanProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getBooleanProperty(""String_Node_Str"",true));
    Assert.assertTrue(modConfig.getDoubleProperty(""String_Node_Str"") == 2.3);
    try {
      modConfig.getDoubleProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getDoubleProperty(""String_Node_Str"",4.5) == 4.5);
    Assert.assertTrue(modConfig.getClassProperty(""String_Node_Str"",List.class) == ArrayList.class);
    Assert.assertTrue(modConfig.getStringListProperty(""String_Node_Str"").equals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
    Assert.assertTrue(modConfig.getStringListProperty(""String_Node_Str"").equals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
    try {
      modConfig.getStringListProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getEnumProperty(""String_Node_Str"",StandardOpenOption.class) == StandardOpenOption.APPEND);
    try {
      modConfig.getEnumProperty(""String_Node_Str"",StandardOpenOption.class);
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getEnumSetProperty(""String_Node_Str"",StandardOpenOption.class).equals(EnumSet.of(StandardOpenOption.APPEND,StandardOpenOption.CREATE)));
    try {
      modConfig.getEnumSetProperty(""String_Node_Str"",StandardOpenOption.class);
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getPathProperty(""String_Node_Str"").equals(p));
    try {
      modConfig.getPathProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getPathListProperty(""String_Node_Str"").equals(Arrays.asList(p,p2)));
    Assert.assertTrue(modConfig.getPathListProperty(""String_Node_Str"").equals(Arrays.asList(p,p2)));
    try {
      modConfig.getPathListProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
  }
 }","@Test public void moduleConfigTest() throws IOException, XMLStreamException, SAXException, ParserConfigurationException {
  try (FileSystem fileSystem=Jimfs.newFileSystem(Configuration.unix())){
    Path cfgDir=Files.createDirectory(fileSystem.getPath(""String_Node_Str""));
    Properties prop1=new Properties();
    prop1.setProperty(""String_Node_Str"",""String_Node_Str"");
    prop1.setProperty(""String_Node_Str"",Integer.toString(3));
    prop1.setProperty(""String_Node_Str"",Boolean.FALSE.toString());
    prop1.setProperty(""String_Node_Str"",Double.toString(2.3));
    prop1.setProperty(""String_Node_Str"",ArrayList.class.getName());
    prop1.setProperty(""String_Node_Str"",""String_Node_Str"");
    prop1.setProperty(""String_Node_Str"",""String_Node_Str"");
    prop1.setProperty(""String_Node_Str"",StandardOpenOption.APPEND.name());
    prop1.setProperty(""String_Node_Str"",StandardOpenOption.APPEND + ""String_Node_Str"" + StandardOpenOption.CREATE);
    Path p=fileSystem.getPath(""String_Node_Str"");
    Path p2=fileSystem.getPath(""String_Node_Str"");
    prop1.setProperty(""String_Node_Str"",p.toString());
    prop1.setProperty(""String_Node_Str"",p.toString() + ""String_Node_Str"" + p2.toString());
    prop1.setProperty(""String_Node_Str"",p.toString() + ""String_Node_Str"" + p2.toString());
    try (Writer w=Files.newBufferedWriter(cfgDir.resolve(""String_Node_Str""),StandardCharsets.UTF_8)){
      prop1.store(w,null);
    }
     PropertiesPlatformConfig propsConfig=new PropertiesPlatformConfig(cfgDir,fileSystem);
    ModuleConfig modConfig=propsConfig.getModuleConfig(""String_Node_Str"");
    Assert.assertTrue(modConfig.getStringProperty(""String_Node_Str"").equals(""String_Node_Str""));
    Assert.assertTrue(modConfig.getStringProperty(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str""));
    try {
      modConfig.getStringProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getIntProperty(""String_Node_Str"") == 3);
    try {
      modConfig.getIntProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertNull(modConfig.getOptionalIntProperty(""String_Node_Str""));
    Assert.assertFalse(modConfig.getOptionalIntegerProperty(""String_Node_Str"").isPresent());
    Assert.assertTrue(modConfig.getIntProperty(""String_Node_Str"",4) == 4);
    Assert.assertFalse(modConfig.getBooleanProperty(""String_Node_Str""));
    try {
      modConfig.getBooleanProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertNull(modConfig.getOptinalBooleanProperty(""String_Node_Str""));
    Assert.assertFalse(modConfig.getOptionalBooleanProperty(""String_Node_Str"").isPresent());
    Assert.assertTrue(modConfig.getBooleanProperty(""String_Node_Str"",true));
    Assert.assertTrue(modConfig.getDoubleProperty(""String_Node_Str"") == 2.3);
    try {
      modConfig.getDoubleProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getDoubleProperty(""String_Node_Str"",4.5) == 4.5);
    Assert.assertTrue(modConfig.getClassProperty(""String_Node_Str"",List.class) == ArrayList.class);
    Assert.assertTrue(modConfig.getStringListProperty(""String_Node_Str"").equals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
    Assert.assertTrue(modConfig.getStringListProperty(""String_Node_Str"").equals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
    try {
      modConfig.getStringListProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getEnumProperty(""String_Node_Str"",StandardOpenOption.class) == StandardOpenOption.APPEND);
    try {
      modConfig.getEnumProperty(""String_Node_Str"",StandardOpenOption.class);
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getEnumSetProperty(""String_Node_Str"",StandardOpenOption.class).equals(EnumSet.of(StandardOpenOption.APPEND,StandardOpenOption.CREATE)));
    try {
      modConfig.getEnumSetProperty(""String_Node_Str"",StandardOpenOption.class);
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getPathProperty(""String_Node_Str"").equals(p));
    try {
      modConfig.getPathProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
    Assert.assertTrue(modConfig.getPathListProperty(""String_Node_Str"").equals(Arrays.asList(p,p2)));
    Assert.assertTrue(modConfig.getPathListProperty(""String_Node_Str"").equals(Arrays.asList(p,p2)));
    try {
      modConfig.getPathListProperty(""String_Node_Str"");
      Assert.fail();
    }
 catch (    Exception e) {
    }
  }
 }","The original code lacked proper handling of optional properties and used inconsistent assertion methods for checking null or absent values. The fixed code introduces new methods like `getOptionalIntProperty()`, `getOptinalBooleanProperty()`, and uses more precise assertions such as `assertNull()` and `assertFalse(property.isPresent())` to correctly validate optional property behaviors. These changes improve type safety, provide more explicit optional property handling, and ensure more robust configuration testing with clearer, more precise validation mechanisms."
38921,"@Test public void testCsv() throws IOException {
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  TableFormatterConfig config=new TableFormatterConfig(Locale.US,';',""String_Node_Str"",true,true);
  CsvTableFormatterFactory factory=new CsvTableFormatterFactory();
  try (TableFormatter formatter=factory.create(new OutputStreamWriter(bos),""String_Node_Str"",config,COLUMNS)){
    write(formatter);
  }
   assertEquals(new String(bos.toByteArray(),StandardCharsets.UTF_8),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void testCsv() throws IOException {
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  TableFormatterConfig config=new TableFormatterConfig(Locale.US,';',""String_Node_Str"",true,true);
  CsvTableFormatterFactory factory=new CsvTableFormatterFactory();
  try (TableFormatter formatter=factory.create(new OutputStreamWriter(bos,StandardCharsets.UTF_8),""String_Node_Str"",config,COLUMNS)){
    write(formatter);
  }
   assertEquals(new String(bos.toByteArray(),StandardCharsets.UTF_8),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}","The original code did not specify a character encoding when creating the OutputStreamWriter, which could lead to platform-dependent default encoding and potential character conversion issues. The fixed code explicitly sets StandardCharsets.UTF_8 as the character encoding for the OutputStreamWriter, ensuring consistent and predictable text encoding across different systems. This change guarantees reliable and uniform CSV file generation with proper character handling, preventing potential encoding-related bugs."
38922,"@Test public void testAcsii() throws IOException {
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  TableFormatterConfig config=new TableFormatterConfig(Locale.US,""String_Node_Str"");
  AsciiTableFormatterFactory factory=new AsciiTableFormatterFactory();
  try (TableFormatter formatter=factory.create(new OutputStreamWriter(bos),""String_Node_Str"",config,COLUMNS)){
    write(formatter);
  }
   assertEquals(new String(bos.toByteArray(),StandardCharsets.UTF_8),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void testAcsii() throws IOException {
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  TableFormatterConfig config=new TableFormatterConfig(Locale.US,""String_Node_Str"");
  AsciiTableFormatterFactory factory=new AsciiTableFormatterFactory();
  try (TableFormatter formatter=factory.create(new OutputStreamWriter(bos,StandardCharsets.UTF_8),""String_Node_Str"",config,COLUMNS)){
    write(formatter);
  }
   assertEquals(new String(bos.toByteArray(),StandardCharsets.UTF_8),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","The original code did not specify a character encoding when creating the OutputStreamWriter, which could lead to platform-dependent default encoding. The fixed code explicitly sets StandardCharsets.UTF_8 when creating the OutputStreamWriter, ensuring consistent and predictable character encoding across different systems. This change guarantees that the test will produce identical results regardless of the underlying platform's default character encoding."
38923,"public static Object readParameter(String format,Properties parameters,Parameter configuredParameter,ParameterDefaultValueConfig defaultValueConfig){
  Object value=null;
  if (parameters != null) {
    MapModuleConfig moduleConfig=new MapModuleConfig(parameters);
switch (configuredParameter.getType()) {
case BOOLEAN:
      value=moduleConfig.getOptinalBooleanProperty(configuredParameter.getName());
    break;
case STRING:
  value=moduleConfig.getStringProperty(configuredParameter.getName(),null);
break;
case STRING_LIST:
value=moduleConfig.getStringListProperty(configuredParameter.getName(),null);
break;
default :
throw new AssertionError();
}
}
if (value == null) {
value=defaultValueConfig.getValue(format,configuredParameter);
}
return value;
}","public static Object readParameter(String format,Properties parameters,Parameter configuredParameter,ParameterDefaultValueConfig defaultValueConfig){
  Object value=null;
  if (parameters != null) {
    MapModuleConfig moduleConfig=new MapModuleConfig(parameters);
switch (configuredParameter.getType()) {
case BOOLEAN:
      value=moduleConfig.getOptionalBooleanProperty(configuredParameter.getName()).get();
    break;
case STRING:
  value=moduleConfig.getStringProperty(configuredParameter.getName(),null);
break;
case STRING_LIST:
value=moduleConfig.getStringListProperty(configuredParameter.getName(),null);
break;
default :
throw new AssertionError();
}
}
if (value == null) {
value=defaultValueConfig.getValue(format,configuredParameter);
}
return value;
}","The original code incorrectly calls `getOptinalBooleanProperty()` (misspelled) and does not handle the Optional return type. In the fixed code, `getOptionalBooleanProperty()` is correctly spelled, and `.get()` is used to extract the actual boolean value from the Optional. This ensures proper handling of optional boolean properties, preventing potential null pointer exceptions and improving type safety and method invocation."
38924,"public Terminal getTerminal(String voltageLevelId){
  Objects.requireNonNull(voltageLevelId);
  boolean side1=getTerminal1().getVoltageLevel().getId().equals(voltageLevelId);
  boolean side2=getTerminal2().getVoltageLevel().getId().equals(voltageLevelId);
  if (side1) {
    return getTerminal1();
  }
 else   if (side2) {
    return getTerminal2();
  }
 else   if (side1 && side2) {
    throw new RuntimeException(""String_Node_Str"" + voltageLevelId);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + voltageLevelId);
  }
}","public Terminal getTerminal(String voltageLevelId){
  Objects.requireNonNull(voltageLevelId);
  boolean side1=getTerminal1().getVoltageLevel().getId().equals(voltageLevelId);
  boolean side2=getTerminal2().getVoltageLevel().getId().equals(voltageLevelId);
  if (side1 && side2) {
    throw new RuntimeException(""String_Node_Str"" + voltageLevelId);
  }
 else   if (side1) {
    return getTerminal1();
  }
 else   if (side2) {
    return getTerminal2();
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + voltageLevelId);
  }
}","The original code had a logical error in the condition checking, potentially returning an incorrect terminal or throwing an unnecessary exception. The fixed code reorders the conditions, first checking if both terminals match the voltage level (which would be an invalid state), then checking each terminal individually. This ensures correct terminal selection by prioritizing the most specific condition first and handling edge cases more precisely."
38925,"@Override public void export(Network network,Properties parameters,DataSource dataSource){
  if (network == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  XMLExportOptions options=new XMLExportOptions();
  if (parameters != null) {
    options.setIndent(!""String_Node_Str"".equals(parameters.getProperty(INDENT_PROPERTY))).setWithBranchSV(""String_Node_Str"".equals(parameters.getProperty(WITH_BRANCH_STATE_VARIABLES_PROPERTY))).setForceBusBranchTopo(""String_Node_Str"".equals(parameters.getProperty(FORCE_BUS_BRANCH_TOPO_PROPERTY,""String_Node_Str""))).setOnlyMainCc(""String_Node_Str"".equals(parameters.getProperty(ONLY_MAIN_CC_PROPERTIES))).setAnonymized(""String_Node_Str"".equals(parameters.getProperty(ANONYMISED_PROPERTIES))).setSkipExtensions(""String_Node_Str"".equals(parameters.getProperty(SKIP_EXTENSIONS_PROPERTIES)));
  }
  try {
    long startTime=System.currentTimeMillis();
    try (OutputStream os=dataSource.newOutputStream(null,""String_Node_Str"",false);BufferedOutputStream bos=new BufferedOutputStream(os)){
      Anonymizer anonymizer=NetworkXml.write(network,options,bos);
      if (anonymizer != null) {
        try (BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(dataSource.newOutputStream(""String_Node_Str"",""String_Node_Str"",false)))){
          anonymizer.write(writer);
        }
       }
    }
     LOGGER.debug(""String_Node_Str"",(System.currentTimeMillis() - startTime));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","@Override public void export(Network network,Properties parameters,DataSource dataSource){
  if (network == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  XMLExportOptions options=new XMLExportOptions();
  if (parameters != null) {
    options.setIndent(!""String_Node_Str"".equals(parameters.getProperty(INDENT_PROPERTY))).setWithBranchSV(""String_Node_Str"".equals(parameters.getProperty(WITH_BRANCH_STATE_VARIABLES_PROPERTY))).setForceBusBranchTopo(""String_Node_Str"".equals(parameters.getProperty(FORCE_BUS_BRANCH_TOPO_PROPERTY,""String_Node_Str""))).setOnlyMainCc(""String_Node_Str"".equals(parameters.getProperty(ONLY_MAIN_CC_PROPERTIES))).setAnonymized(""String_Node_Str"".equals(parameters.getProperty(ANONYMISED_PROPERTIES))).setSkipExtensions(""String_Node_Str"".equals(parameters.getProperty(SKIP_EXTENSIONS_PROPERTIES)));
  }
  try {
    long startTime=System.currentTimeMillis();
    try (OutputStream os=dataSource.newOutputStream(null,""String_Node_Str"",false);BufferedOutputStream bos=new BufferedOutputStream(os)){
      Anonymizer anonymizer=NetworkXml.write(network,options,bos);
      if (anonymizer != null) {
        try (BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(dataSource.newOutputStream(""String_Node_Str"",""String_Node_Str"",false),StandardCharsets.UTF_8))){
          anonymizer.write(writer);
        }
       }
    }
     LOGGER.debug(""String_Node_Str"",(System.currentTimeMillis() - startTime));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","The original code lacked proper character encoding when creating the BufferedWriter, which could lead to platform-dependent text encoding issues. The fixed code adds StandardCharsets.UTF_8 to explicitly specify UTF-8 encoding when creating the OutputStreamWriter, ensuring consistent and predictable text encoding across different systems. This change improves the reliability and portability of the XML export process by standardizing character encoding during file writing."
38926,"@Override public Network import_(ReadOnlyDataSource dataSource,Properties parameters){
  Objects.requireNonNull(dataSource);
  Network network;
  long startTime=System.currentTimeMillis();
  try {
    String ext=findExtension(dataSource);
    if (ext == null) {
      throw new RuntimeException(""String_Node_Str"" + dataSource.getBaseName() + ""String_Node_Str""+ Joiner.on(""String_Node_Str"").join(EXTENSIONS)+ ""String_Node_Str"");
    }
    boolean throwExceptionIfExtensionNotFound=(Boolean)Importers.readParameter(getFormat(),parameters,THROW_EXCEPTION_IF_EXTENSION_NOT_FOUND,defaultValueConfig);
    Anonymizer anonymizer=null;
    if (dataSource.exists(""String_Node_Str"",""String_Node_Str"")) {
      anonymizer=new SimpleAnonymizer();
      try (BufferedReader reader=new BufferedReader(new InputStreamReader(dataSource.newInputStream(""String_Node_Str"",""String_Node_Str"")))){
        anonymizer.read(reader);
      }
     }
    try (InputStream is=dataSource.newInputStream(null,ext)){
      network=NetworkXml.read(is,new XmlImportConfig(throwExceptionIfExtensionNotFound),anonymizer);
    }
     LOGGER.debug(""String_Node_Str"",(System.currentTimeMillis() - startTime));
  }
 catch (  IOException e) {
    throw new ITeslaException(e);
  }
  return network;
}","@Override public Network import_(ReadOnlyDataSource dataSource,Properties parameters){
  Objects.requireNonNull(dataSource);
  Network network;
  long startTime=System.currentTimeMillis();
  try {
    String ext=findExtension(dataSource);
    if (ext == null) {
      throw new RuntimeException(""String_Node_Str"" + dataSource.getBaseName() + ""String_Node_Str""+ Joiner.on(""String_Node_Str"").join(EXTENSIONS)+ ""String_Node_Str"");
    }
    boolean throwExceptionIfExtensionNotFound=(Boolean)Importers.readParameter(getFormat(),parameters,THROW_EXCEPTION_IF_EXTENSION_NOT_FOUND,defaultValueConfig);
    Anonymizer anonymizer=null;
    if (dataSource.exists(""String_Node_Str"",""String_Node_Str"")) {
      anonymizer=new SimpleAnonymizer();
      try (BufferedReader reader=new BufferedReader(new InputStreamReader(dataSource.newInputStream(""String_Node_Str"",""String_Node_Str""),StandardCharsets.UTF_8))){
        anonymizer.read(reader);
      }
     }
    try (InputStream is=dataSource.newInputStream(null,ext)){
      network=NetworkXml.read(is,new XmlImportConfig(throwExceptionIfExtensionNotFound),anonymizer);
    }
     LOGGER.debug(""String_Node_Str"",(System.currentTimeMillis() - startTime));
  }
 catch (  IOException e) {
    throw new ITeslaException(e);
  }
  return network;
}","The original code lacked character encoding specification when creating the InputStreamReader, which could lead to platform-dependent and inconsistent text reading. The fixed code adds StandardCharsets.UTF_8 to explicitly define UTF-8 encoding for the InputStreamReader, ensuring consistent and predictable character decoding across different systems. This change guarantees reliable text processing by preventing potential character encoding misinterpretations during file reading."
38927,"public static int readOptionalIntegerAttribute(XMLStreamReader reader,String attributeName,int defaultValue){
  String attributeValue=reader.getAttributeValue(null,attributeName);
  return attributeValue != null ? Integer.valueOf(attributeValue) : defaultValue;
}","public static int readOptionalIntegerAttribute(XMLStreamReader reader,String attributeName,int defaultValue){
  String attributeValue=reader.getAttributeValue(null,attributeName);
  return attributeValue != null ? Integer.parseInt(attributeValue) : defaultValue;
}","The original code uses `Integer.valueOf()`, which returns a boxed Integer object, potentially causing a `NumberFormatException` if the attribute value is not a valid integer. The fixed code replaces `valueOf()` with `parseInt()`, which directly converts the string to a primitive int and provides more robust parsing. This change ensures safer integer conversion and prevents potential runtime exceptions when parsing XML attribute values."
38928,"public static int readIntAttribute(XMLStreamReader reader,String attributeName){
  return Integer.valueOf(reader.getAttributeValue(null,attributeName));
}","public static int readIntAttribute(XMLStreamReader reader,String attributeName){
  return Integer.parseInt(reader.getAttributeValue(null,attributeName));
}","Integer.valueOf() returns an Integer object, which can cause unnecessary boxing and potential NullPointerException if the attribute is missing. The fixed code uses Integer.parseInt(), which directly converts the attribute value to a primitive int and throws a NumberFormatException for invalid inputs. This change provides more direct parsing, better performance, and clearer error handling when reading XML integer attributes."
38929,"@Before public void setUp() throws Exception {
  fileSystem=Jimfs.newFileSystem(Configuration.unix());
  configDir=Files.createDirectory(fileSystem.getPath(""String_Node_Str""));
  platformConfig=new InMemoryPlatformConfig(fileSystem);
  moduleConfig=platformConfig.createModuleConfig(""String_Node_Str"");
  moduleConfig.setStringListProperty(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str""));
  moduleConfig.setStringProperty(""String_Node_Str"",""String_Node_Str"");
}","@Before public void setUp() throws Exception {
  fileSystem=Jimfs.newFileSystem(Configuration.unix());
  platformConfig=new InMemoryPlatformConfig(fileSystem);
  moduleConfig=platformConfig.createModuleConfig(""String_Node_Str"");
  moduleConfig.setStringListProperty(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str""));
  moduleConfig.setStringProperty(""String_Node_Str"",""String_Node_Str"");
}","The buggy code unnecessarily creates a directory `configDir` that is not used in the subsequent setup, potentially causing unused resource allocation. The fixed code removes the `configDir` creation line, streamlining the setup process and focusing only on essential configuration tasks. By eliminating the superfluous directory creation, the code becomes more efficient and reduces potential memory overhead."
38930,"@Deprecated default void run(CommandLine line) throws Exception {
  run(line,new ToolRunningContext());
}","@Deprecated default void run(CommandLine line) throws Exception {
}","The original code incorrectly called another method with an unnecessary default context, potentially causing unintended side effects or performance overhead. The fixed code removes the unnecessary method call, simplifying the implementation and eliminating potential runtime complications. By removing the superfluous line, the code becomes more direct, reduces potential error points, and maintains the method's core deprecation intent."
38931,"@Override public void createRecord(ModExportContext modContext,DDBManager ddbManager,SimulatorInst simulator){
  if (!Float.isNaN(this.busInfo.getBus().getV()) && this.busInfo.isConnected()) {
    if (super.isCorrect()) {
      if (!busInfo.isConnected()) {
        this.addValue(StaticData.COMMENT);
      }
      if (super.getModelicaType() != null) {
        this.addValue(super.getModelicaType() + StaticData.WHITE_SPACE);
      }
 else {
        if (!isInyection) {
          this.addValue(DEFAULT_GEN_TYPE + StaticData.WHITE_SPACE);
        }
 else {
          this.addValue(DEFAULT_GEN_LOAD_TYPE + StaticData.WHITE_SPACE);
        }
      }
      this.addValue(super.getModelicaName());
      this.addValue(""String_Node_Str"");
      this.addValue(StaticData.NEW_LINE);
      if ((iidmgenParameters != null) && (!iidmgenParameters.isEmpty())) {
        for (int i=0; i < iidmgenParameters.size() - 1; i++) {
          if (!busInfo.isConnected()) {
            this.addValue(StaticData.COMMENT);
          }
          if (iidmgenParameters.get(i).getName().equals(PsseFixedData.Mbase) && this.changedMbse) {
            this.addValue(""String_Node_Str"" + iidmgenParameters.get(i).getName() + ""String_Node_Str""+ iidmgenParameters.get(i).getValue()+ ""String_Node_Str"");
          }
 else {
            this.addValue(""String_Node_Str"" + iidmgenParameters.get(i).getName() + ""String_Node_Str""+ iidmgenParameters.get(i).getValue()+ ""String_Node_Str"");
          }
          this.addValue(StaticData.NEW_LINE);
        }
        if (!busInfo.isConnected()) {
          this.addValue(StaticData.COMMENT);
        }
        if (isInyection) {
          this.addValue(""String_Node_Str"" + iidmgenParameters.get(iidmgenParameters.size() - 1).getName() + ""String_Node_Str""+ iidmgenParameters.get(iidmgenParameters.size() - 1).getValue());
        }
 else         if ((genParameters != null) && (!genParameters.isEmpty())) {
          if (iidmgenParameters.get(iidmgenParameters.size() - 1).getName().equals(PsseFixedData.Mbase) && this.changedMbse) {
            this.addValue(""String_Node_Str"" + iidmgenParameters.get(iidmgenParameters.size() - 1).getName() + ""String_Node_Str""+ iidmgenParameters.get(iidmgenParameters.size() - 1).getValue()+ ""String_Node_Str"");
          }
 else {
            this.addValue(""String_Node_Str"" + iidmgenParameters.get(iidmgenParameters.size() - 1).getName() + ""String_Node_Str""+ iidmgenParameters.get(iidmgenParameters.size() - 1).getValue()+ ""String_Node_Str"");
          }
        }
        this.addValue(StaticData.NEW_LINE);
      }
      if (!isInyection) {
        if ((genParameters != null) && (!genParameters.isEmpty())) {
          for (int i=0; i < genParameters.size() - 1; i++) {
            if (!busInfo.isConnected()) {
              this.addValue(StaticData.COMMENT);
            }
            this.addValue(""String_Node_Str"" + genParameters.get(i).getName() + ""String_Node_Str""+ genParameters.get(i).getValue()+ ""String_Node_Str"");
            this.addValue(StaticData.NEW_LINE);
          }
          if (!busInfo.isConnected()) {
            this.addValue(StaticData.COMMENT);
          }
          this.addValue(""String_Node_Str"" + genParameters.get(genParameters.size() - 1).getName() + ""String_Node_Str""+ genParameters.get(genParameters.size() - 1).getValue());
          this.addValue(StaticData.NEW_LINE);
        }
      }
      if (!this.busInfo.isConnected()) {
        his.addValue(StaticData.COMMENT);
      }
      this.addValue(""String_Node_Str"" + EurostagFixedData.ANNOT);
      genParameters=null;
      iidmgenParameters=null;
    }
 else {
      _log.error(this.getModelicaName() + ""String_Node_Str"");
    }
  }
 else {
    _log.warn(""String_Node_Str"" + this.getModelicaName() + ""String_Node_Str"");
    this.addValue(StaticData.COMMENT + ""String_Node_Str"" + this.getModelicaName()+ ""String_Node_Str"");
  }
}","@Override public void createRecord(ModExportContext modContext,DDBManager ddbManager,SimulatorInst simulator){
  if (!Float.isNaN(this.busInfo.getBus().getV()) && this.busInfo.isConnected()) {
    if (super.isCorrect()) {
      if (!busInfo.isConnected()) {
        this.addValue(StaticData.COMMENT);
      }
      if (super.getModelicaType() != null) {
        this.addValue(super.getModelicaType() + StaticData.WHITE_SPACE);
      }
 else {
        if (!isInyection) {
          this.addValue(DEFAULT_GEN_TYPE + StaticData.WHITE_SPACE);
        }
 else {
          this.addValue(DEFAULT_GEN_LOAD_TYPE + StaticData.WHITE_SPACE);
        }
      }
      this.addValue(super.getModelicaName());
      this.addValue(""String_Node_Str"");
      this.addValue(StaticData.NEW_LINE);
      if ((iidmgenParameters != null) && (!iidmgenParameters.isEmpty())) {
        for (int i=0; i < iidmgenParameters.size() - 1; i++) {
          if (!busInfo.isConnected()) {
            this.addValue(StaticData.COMMENT);
          }
          if (iidmgenParameters.get(i).getName().equals(PsseFixedData.Mbase) && this.changedMbse) {
            this.addValue(""String_Node_Str"" + iidmgenParameters.get(i).getName() + ""String_Node_Str""+ iidmgenParameters.get(i).getValue()+ ""String_Node_Str"");
          }
 else {
            this.addValue(""String_Node_Str"" + iidmgenParameters.get(i).getName() + ""String_Node_Str""+ iidmgenParameters.get(i).getValue()+ ""String_Node_Str"");
          }
          this.addValue(StaticData.NEW_LINE);
        }
        if (!busInfo.isConnected()) {
          this.addValue(StaticData.COMMENT);
        }
        if (isInyection) {
          this.addValue(""String_Node_Str"" + iidmgenParameters.get(iidmgenParameters.size() - 1).getName() + ""String_Node_Str""+ iidmgenParameters.get(iidmgenParameters.size() - 1).getValue());
        }
 else         if ((genParameters != null) && (!genParameters.isEmpty())) {
          if (iidmgenParameters.get(iidmgenParameters.size() - 1).getName().equals(PsseFixedData.Mbase) && this.changedMbse) {
            this.addValue(""String_Node_Str"" + iidmgenParameters.get(iidmgenParameters.size() - 1).getName() + ""String_Node_Str""+ iidmgenParameters.get(iidmgenParameters.size() - 1).getValue()+ ""String_Node_Str"");
          }
 else {
            this.addValue(""String_Node_Str"" + iidmgenParameters.get(iidmgenParameters.size() - 1).getName() + ""String_Node_Str""+ iidmgenParameters.get(iidmgenParameters.size() - 1).getValue()+ ""String_Node_Str"");
          }
        }
        this.addValue(StaticData.NEW_LINE);
      }
      if (!isInyection) {
        if ((genParameters != null) && (!genParameters.isEmpty())) {
          for (int i=0; i < genParameters.size() - 1; i++) {
            if (!busInfo.isConnected()) {
              this.addValue(StaticData.COMMENT);
            }
            this.addValue(""String_Node_Str"" + genParameters.get(i).getName() + ""String_Node_Str""+ genParameters.get(i).getValue()+ ""String_Node_Str"");
            this.addValue(StaticData.NEW_LINE);
          }
          if (!busInfo.isConnected()) {
            this.addValue(StaticData.COMMENT);
          }
          this.addValue(""String_Node_Str"" + genParameters.get(genParameters.size() - 1).getName() + ""String_Node_Str""+ genParameters.get(genParameters.size() - 1).getValue());
          this.addValue(StaticData.NEW_LINE);
        }
      }
      if (!this.busInfo.isConnected()) {
        this.addValue(StaticData.COMMENT);
      }
      this.addValue(""String_Node_Str"" + EurostagFixedData.ANNOT);
      genParameters=null;
      iidmgenParameters=null;
    }
 else {
      _log.error(this.getModelicaName() + ""String_Node_Str"");
    }
  }
 else {
    _log.warn(""String_Node_Str"" + this.getModelicaName() + ""String_Node_Str"");
    this.addValue(StaticData.COMMENT + ""String_Node_Str"" + this.getModelicaName()+ ""String_Node_Str"");
  }
}","The buggy code contained a typo in `his.addValue(StaticData.COMMENT)`, which would cause a compilation error due to the missing `t` in `this`. The fixed code corrects this typo, ensuring the method can properly add a comment when the bus is not connected. This correction prevents potential runtime errors and maintains the intended logic of adding comments for disconnected buses, improving the code's reliability and functionality."
38932,"public static Network read(InputStream is) throws XMLStreamException {
  XMLStreamReader reader=XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);
  reader.next();
  String id=reader.getAttributeValue(null,""String_Node_Str"");
  DateTime date=ISODateTimeFormat.dateTime().parseDateTime(reader.getAttributeValue(null,""String_Node_Str""));
  String sourceFormat=reader.getAttributeValue(null,""String_Node_Str"");
  Network network=NetworkFactory.create(id,sourceFormat);
  network.setDate(date);
  List<Runnable> endTasks=new ArrayList<>();
  XmlUtil.readUntilEndElement(NETWORK_ROOT_ELEMENT_NAME,reader,() -> {
switch (reader.getLocalName()) {
case SubstationXml.ROOT_ELEMENT_NAME:
      SubstationXml.INSTANCE.read(reader,network,endTasks);
    break;
case LineXml.ROOT_ELEMENT_NAME:
  LineXml.INSTANCE.read(reader,network,endTasks);
break;
case TieLineXml.ROOT_ELEMENT_NAME:
TieLineXml.INSTANCE.read(reader,network,endTasks);
break;
default :
throw new AssertionError();
}
}
);
endTasks.forEach(Runnable::run);
return network;
}","public static Network read(InputStream is) throws XMLStreamException {
  XMLStreamReader reader=XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);
  reader.next();
  String id=reader.getAttributeValue(null,""String_Node_Str"");
  DateTime date=DateTime.parse(reader.getAttributeValue(null,""String_Node_Str""));
  String sourceFormat=reader.getAttributeValue(null,""String_Node_Str"");
  Network network=NetworkFactory.create(id,sourceFormat);
  network.setDate(date);
  List<Runnable> endTasks=new ArrayList<>();
  XmlUtil.readUntilEndElement(NETWORK_ROOT_ELEMENT_NAME,reader,() -> {
switch (reader.getLocalName()) {
case SubstationXml.ROOT_ELEMENT_NAME:
      SubstationXml.INSTANCE.read(reader,network,endTasks);
    break;
case LineXml.ROOT_ELEMENT_NAME:
  LineXml.INSTANCE.read(reader,network,endTasks);
break;
case TieLineXml.ROOT_ELEMENT_NAME:
TieLineXml.INSTANCE.read(reader,network,endTasks);
break;
default :
throw new AssertionError();
}
}
);
endTasks.forEach(Runnable::run);
return network;
}","The original code used `ISODateTimeFormat.dateTime().parseDateTime()`, which is deprecated and may cause parsing errors when converting date strings. The fixed code replaces this with `DateTime.parse()`, a more modern and reliable method for parsing date-time values. This change ensures robust date parsing, eliminates potential deprecation warnings, and provides a cleaner, more maintainable approach to handling datetime conversions in the XML reading process."
38933,"public static void write(Network n,XMLExportOptions options,OutputStream os) throws XMLStreamException {
  XMLStreamWriter writer=XML_OUTPUT_FACTORY_SUPPLIER.get().createXMLStreamWriter(os,StandardCharsets.UTF_8.toString());
  if (options.isIndent()) {
    IndentingXMLStreamWriter indentingWriter=new IndentingXMLStreamWriter(writer);
    indentingWriter.setIndent(INDENT);
    writer=indentingWriter;
  }
  writer.writeStartDocument(StandardCharsets.UTF_8.toString(),""String_Node_Str"");
  writer.setPrefix(IIDM_PREFIX,IIDM_URI);
  writer.writeStartElement(IIDM_URI,NETWORK_ROOT_ELEMENT_NAME);
  writer.writeNamespace(IIDM_PREFIX,IIDM_URI);
  writer.writeAttribute(""String_Node_Str"",n.getId());
  writer.writeAttribute(""String_Node_Str"",n.getDate().toString(ISODateTimeFormat.dateTime()));
  writer.writeAttribute(""String_Node_Str"",n.getSourceFormat());
  BusFilter filter=BusFilter.create(n,options);
  XmlWriterContext context=new XmlWriterContext(writer,options,filter);
  for (  Substation s : n.getSubstations()) {
    SubstationXml.INSTANCE.write(s,null,context);
  }
  for (  Line l : n.getLines()) {
    if (!filter.test(l)) {
      continue;
    }
    if (l.isTieLine()) {
      TieLineXml.INSTANCE.write((TieLine)l,n,context);
    }
 else {
      LineXml.INSTANCE.write(l,n,context);
    }
  }
  writer.writeEndElement();
  writer.writeEndDocument();
}","public static void write(Network n,XMLExportOptions options,OutputStream os) throws XMLStreamException {
  XMLStreamWriter writer=XML_OUTPUT_FACTORY_SUPPLIER.get().createXMLStreamWriter(os,StandardCharsets.UTF_8.toString());
  if (options.isIndent()) {
    IndentingXMLStreamWriter indentingWriter=new IndentingXMLStreamWriter(writer);
    indentingWriter.setIndent(INDENT);
    writer=indentingWriter;
  }
  writer.writeStartDocument(StandardCharsets.UTF_8.toString(),""String_Node_Str"");
  writer.setPrefix(IIDM_PREFIX,IIDM_URI);
  writer.writeStartElement(IIDM_URI,NETWORK_ROOT_ELEMENT_NAME);
  writer.writeNamespace(IIDM_PREFIX,IIDM_URI);
  writer.writeAttribute(""String_Node_Str"",n.getId());
  writer.writeAttribute(""String_Node_Str"",n.getDate().toString());
  writer.writeAttribute(""String_Node_Str"",n.getSourceFormat());
  BusFilter filter=BusFilter.create(n,options);
  XmlWriterContext context=new XmlWriterContext(writer,options,filter);
  for (  Substation s : n.getSubstations()) {
    SubstationXml.INSTANCE.write(s,null,context);
  }
  for (  Line l : n.getLines()) {
    if (!filter.test(l)) {
      continue;
    }
    if (l.isTieLine()) {
      TieLineXml.INSTANCE.write((TieLine)l,n,context);
    }
 else {
      LineXml.INSTANCE.write(l,n,context);
    }
  }
  writer.writeEndElement();
  writer.writeEndDocument();
}","The original code incorrectly used `ISODateTimeFormat.dateTime()` when converting the network date to a string, which may introduce unnecessary formatting complexity. The fixed code simply calls `toString()` on the date object, allowing the default date representation. This simplification removes potential formatting issues and provides a more straightforward approach to serializing the network's date attribute during XML export."
38934,"@Override protected void writeRootElementAttributes(VoltageLevel vl,Substation s,XmlWriterContext context) throws XMLStreamException {
  context.getWriter().writeAttribute(""String_Node_Str"",vl.getDate().toString(ISODateTimeFormat.dateTime()));
  context.getWriter().writeAttribute(""String_Node_Str"",vl.getHorizon().name());
  context.getWriter().writeAttribute(""String_Node_Str"",Integer.toString(vl.getForecastDistance()));
  writeFloat(""String_Node_Str"",vl.getNominalV(),context.getWriter());
  writeFloat(""String_Node_Str"",vl.getLowVoltageLimit(),context.getWriter());
  writeFloat(""String_Node_Str"",vl.getHighVoltageLimit(),context.getWriter());
  context.getWriter().writeAttribute(""String_Node_Str"",vl.getTopologyKind().name());
}","@Override protected void writeRootElementAttributes(VoltageLevel vl,Substation s,XmlWriterContext context) throws XMLStreamException {
  context.getWriter().writeAttribute(""String_Node_Str"",vl.getDate().toString());
  context.getWriter().writeAttribute(""String_Node_Str"",vl.getHorizon().name());
  context.getWriter().writeAttribute(""String_Node_Str"",Integer.toString(vl.getForecastDistance()));
  writeFloat(""String_Node_Str"",vl.getNominalV(),context.getWriter());
  writeFloat(""String_Node_Str"",vl.getLowVoltageLimit(),context.getWriter());
  writeFloat(""String_Node_Str"",vl.getHighVoltageLimit(),context.getWriter());
  context.getWriter().writeAttribute(""String_Node_Str"",vl.getTopologyKind().name());
}","The original code incorrectly used `ISODateTimeFormat.dateTime()` when converting the date to a string, which is an unnecessary and potentially complex method. The fixed code simplifies the date conversion by using the default `toString()` method, which provides a clean and straightforward string representation. This change reduces complexity, improves readability, and eliminates potential formatting issues while maintaining the core functionality of writing XML attributes."
38935,"@Override protected VoltageLevel readRootElementAttributes(VoltageLevelAdder adder,XMLStreamReader reader,List<Runnable> endTasks){
  DateTime date=ISODateTimeFormat.dateTime().parseDateTime(reader.getAttributeValue(null,""String_Node_Str""));
  Horizon horizon=Horizon.valueOf(reader.getAttributeValue(null,""String_Node_Str""));
  int forecastDistance=readIntAttribute(reader,""String_Node_Str"");
  float nominalV=readFloatAttribute(reader,""String_Node_Str"");
  float lowVoltageLimit=readOptionalFloatAttribute(reader,""String_Node_Str"");
  float highVoltageLimit=readOptionalFloatAttribute(reader,""String_Node_Str"");
  TopologyKind topologyKind=TopologyKind.valueOf(reader.getAttributeValue(null,""String_Node_Str""));
  return adder.setDate(date).setHorizon(horizon).setForecastDistance(forecastDistance).setNominalV(nominalV).setLowVoltageLimit(lowVoltageLimit).setHighVoltageLimit(highVoltageLimit).setTopologyKind(topologyKind).add();
}","@Override protected VoltageLevel readRootElementAttributes(VoltageLevelAdder adder,XMLStreamReader reader,List<Runnable> endTasks){
  DateTime date=DateTime.parse(reader.getAttributeValue(null,""String_Node_Str""));
  Horizon horizon=Horizon.valueOf(reader.getAttributeValue(null,""String_Node_Str""));
  int forecastDistance=readIntAttribute(reader,""String_Node_Str"");
  float nominalV=readFloatAttribute(reader,""String_Node_Str"");
  float lowVoltageLimit=readOptionalFloatAttribute(reader,""String_Node_Str"");
  float highVoltageLimit=readOptionalFloatAttribute(reader,""String_Node_Str"");
  TopologyKind topologyKind=TopologyKind.valueOf(reader.getAttributeValue(null,""String_Node_Str""));
  return adder.setDate(date).setHorizon(horizon).setForecastDistance(forecastDistance).setNominalV(nominalV).setLowVoltageLimit(lowVoltageLimit).setHighVoltageLimit(highVoltageLimit).setTopologyKind(topologyKind).add();
}","The original code used ISODateTimeFormat.dateTime().parseDateTime(), which is an outdated method for parsing dates in the Joda-Time library. The fixed code replaces this with DateTime.parse(), a more modern and recommended approach for parsing date strings. This change simplifies the date parsing, reduces potential parsing errors, and aligns with current best practices for handling datetime conversions in Java."
38936,"@Override public void onDetached(){
  super.onDetached();
  RemotePreferenceManager.get(mContext).detach(getKey());
}","@Override public void onDetached(){
  super.onDetached();
  RemotePreferenceManager.get(mContext).detach(getKey(),this);
}","The original code omits passing the current object (this) when detaching from the RemotePreferenceManager, which could lead to incomplete or incorrect detachment. The fixed code adds 'this' as a second parameter, ensuring the specific instance is properly unregistered from the preference manager. This modification guarantees accurate lifecycle management and prevents potential memory leaks or unresolved reference tracking."
38937,"public synchronized static RemotePreferenceManager get(Context context){
  if (sInstance == null) {
    sInstance=new RemotePreferenceManager(context);
  }
  return sInstance;
}","public synchronized static RemotePreferenceManager get(Context context){
  if (sInstance == null) {
    sInstance=new RemotePreferenceManager(context.getApplicationContext());
  }
  return sInstance;
}","The original code uses the raw `context` parameter, which could lead to memory leaks if the context is an activity or service with a limited lifecycle. The fixed code uses `context.getApplicationContext()` to obtain a long-lived application-level context that persists throughout the app's runtime. This change prevents potential memory leaks and ensures the singleton `RemotePreferenceManager` has a stable, application-wide context reference."
38938,"public void detach(String key){
synchronized (mCallbacks) {
    if (mCallbacks.remove(key) != null && mCallbacks.size() == 0) {
      mContext.unregisterReceiver(mListener);
      if (mThread != null) {
        mThread.quit();
      }
    }
  }
}","public void detach(String key,OnRemoteUpdateListener pref){
synchronized (mCallbacks) {
    Set<OnRemoteUpdateListener> cbs=mCallbacks.get(key);
    if (cbs != null && cbs.remove(pref) && cbs.isEmpty() && mCallbacks.remove(key) != null && mCallbacks.isEmpty()) {
      mContext.unregisterReceiver(mListener);
      if (mThread != null) {
        mThread.quit();
        mThread=null;
      }
      mHandler=null;
    }
  }
}","The original code incorrectly removes a listener without verifying if other listeners for the same key still exist, potentially prematurely unregistering the receiver. The fixed code introduces a more robust mechanism by checking the specific listener set, ensuring removal only when the last listener for a key is detached and the entire callback map becomes empty. This approach prevents unintended receiver unregistration and provides more granular control over resource management, reducing the risk of unexpected system state changes."
38939,"@Override public void run(){
synchronized (mCallbacks) {
    if (mCallbacks.containsKey(key)) {
      mCallbacks.get(key).onRemoteUpdated(bundle);
    }
  }
}","@Override public void run(){
synchronized (mCallbacks) {
    if (mCallbacks.containsKey(key)) {
      Set<OnRemoteUpdateListener> cbs=mCallbacks.get(key);
      if (cbs != null) {
        for (        OnRemoteUpdateListener cb : cbs) {
          cb.onRemoteUpdated(bundle);
        }
      }
    }
  }
}","The original code assumes a single callback for a given key, which can lead to null pointer exceptions or incorrect behavior if multiple callbacks exist. The fixed code introduces a set of callbacks and iterates through them, ensuring all registered listeners are properly notified. This approach provides robust multi-listener support, preventing potential runtime errors and improving the code's reliability and flexibility."
38940,"public void attach(String key,OnRemoteUpdateListener pref){
  Intent i;
synchronized (mCache) {
    i=mCache.get(key);
    if (i == null && !mCache.containsKey(key)) {
      i=pref.getReceiverIntent();
      mCache.put(key,i);
    }
  }
synchronized (mCallbacks) {
    if (i != null) {
      mCallbacks.put(key,pref);
      if (mCallbacks.size() == 1) {
        mThread=new HandlerThread(""String_Node_Str"");
        mThread.start();
        mHandler=new Handler(mThread.getLooper());
        mContext.registerReceiver(mListener,new IntentFilter(ACTION_REFRESH_PREFERENCE),Manifest.permission.MANAGE_REMOTE_PREFERENCES,mHandler);
      }
      requestUpdate(key);
    }
  }
}","public void attach(String key,OnRemoteUpdateListener pref){
  Intent i;
synchronized (mCache) {
    i=mCache.get(key);
    if (i == null && !mCache.containsKey(key)) {
      i=pref.getReceiverIntent();
      mCache.put(key,i);
    }
  }
synchronized (mCallbacks) {
    if (i != null) {
      Set<OnRemoteUpdateListener> cbs=mCallbacks.get(key);
      if (cbs == null) {
        cbs=new HashSet<>();
        mCallbacks.put(key,cbs);
        if (mCallbacks.size() == 1) {
          mThread=new HandlerThread(""String_Node_Str"");
          mThread.start();
          mHandler=new Handler(mThread.getLooper());
          mContext.registerReceiver(mListener,new IntentFilter(ACTION_REFRESH_PREFERENCE),Manifest.permission.MANAGE_REMOTE_PREFERENCES,mHandler);
        }
      }
      cbs.add(pref);
      requestUpdate(key);
    }
  }
}","The original code overwrites existing listeners for a key, potentially losing important callback references. The fixed code introduces a Set of OnRemoteUpdateListener for each key, allowing multiple listeners to be registered simultaneously without overwriting previous ones. This modification ensures robust listener management, preventing unintended listener loss and supporting multiple concurrent callbacks for the same key."
38941,"@Override public void onReceive(Context context,Intent intent){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Objects.toString(intent));
  if (ACTION_REFRESH_PREFERENCE.equals(intent.getAction())) {
    final String key=intent.getStringExtra(EXTRA_KEY);
synchronized (mCallbacks) {
      if (key != null && mCallbacks.containsKey(key)) {
        requestUpdate(key);
      }
    }
  }
 else   if (ACTION_UPDATE_PREFERENCE.equals(intent.getAction())) {
    if (getAbortBroadcast()) {
      Log.e(TAG,""String_Node_Str"" + getResultCode());
      return;
    }
    final Bundle bundle=getResultExtras(true);
    final String key=bundle.getString(EXTRA_KEY);
synchronized (mCallbacks) {
      if (key != null && mCallbacks.containsKey(key)) {
        mMainHandler.post(new Runnable(){
          @Override public void run(){
synchronized (mCallbacks) {
              if (mCallbacks.containsKey(key)) {
                mCallbacks.get(key).onRemoteUpdated(bundle);
              }
            }
          }
        }
);
      }
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + Objects.toString(intent));
  if (ACTION_REFRESH_PREFERENCE.equals(intent.getAction())) {
    final String key=intent.getStringExtra(EXTRA_KEY);
synchronized (mCallbacks) {
      if (key != null && mCallbacks.containsKey(key)) {
        requestUpdate(key);
      }
    }
  }
 else   if (ACTION_UPDATE_PREFERENCE.equals(intent.getAction())) {
    if (getAbortBroadcast()) {
      Log.e(TAG,""String_Node_Str"" + getResultCode());
      return;
    }
    final Bundle bundle=getResultExtras(true);
    final String key=bundle.getString(EXTRA_KEY);
synchronized (mCallbacks) {
      if (key != null && mCallbacks.containsKey(key)) {
        mMainHandler.post(new Runnable(){
          @Override public void run(){
synchronized (mCallbacks) {
              if (mCallbacks.containsKey(key)) {
                Set<OnRemoteUpdateListener> cbs=mCallbacks.get(key);
                if (cbs != null) {
                  for (                  OnRemoteUpdateListener cb : cbs) {
                    cb.onRemoteUpdated(bundle);
                  }
                }
              }
            }
          }
        }
);
      }
    }
  }
}","The original code assumed a single callback for a key, but `mCallbacks` likely contains a set of listeners. The fixed code introduces a null check and iterates through all listeners for a given key, calling `onRemoteUpdated()` for each. This change ensures all registered listeners are properly notified, preventing potential missed updates and improving the robustness of the callback mechanism."
38942,"@Override protected void onTwilightUpdated(){
  mHandler.post(mTransitionRunnable);
}","@Override protected void onTwilightUpdated(){
  updateColorTemperature();
}","The original code incorrectly posts a runnable to the handler without directly addressing the twilight update, potentially causing unnecessary threading or delayed processing. The fixed code directly calls `updateColorTemperature()`, which ensures an immediate and synchronous response to the twilight state change. By invoking the method directly, the code provides a more efficient and straightforward mechanism for handling color temperature updates during twilight transitions."
38943,"@Override protected void onScreenStateChanged(){
  if (isTransitioning()) {
    if (isScreenOn()) {
      mHandler.post(mTransitionRunnable);
    }
 else {
      mHandler.removeCallbacks(mTransitionRunnable);
    }
  }
}","@Override protected void onScreenStateChanged(){
  updateColorTemperature();
}","The original code incorrectly manages screen state transitions by conditionally posting or removing a transition callback based on screen on/off status, which can lead to race conditions and unpredictable behavior. The fixed code simplifies the method by directly calling `updateColorTemperature()`, which ensures a consistent and clean approach to handling screen state changes without complex conditional logic. This refactoring improves code reliability by removing potential synchronization issues and providing a more straightforward, predictable screen state management mechanism."
38944,"private void enableLightSensor(boolean enable){
  if (enable && !mLightSensorEnabled) {
    mAmbientLux=0.0f;
    mState=LOW;
    mLightSensorEnabled=true;
    mRingBuffer.clear();
    mSensorManager.registerListener(mListener,mLightSensor,mLightSensorRate * 1000,mLuxHandler);
  }
 else   if (!enable && mLightSensorEnabled) {
    mLightSensorEnabled=false;
    mSensorManager.unregisterListener(mListener);
    mLuxHandler.clear();
  }
}","private void enableLightSensor(boolean enable){
  if (enable && !mLightSensorEnabled) {
    mLightSensorEnabled=true;
    mSensorManager.registerListener(mListener,mLightSensor,mLightSensorRate * 1000,mLuxHandler);
  }
 else   if (!enable && mLightSensorEnabled) {
    mSensorManager.unregisterListener(mListener);
    mLuxHandler.clear();
    mAmbientLux=0.0f;
    mState=LOW;
    mLightSensorEnabled=false;
    mRingBuffer.clear();
  }
}","The original code incorrectly reset sensor state before registering the listener and potentially lost critical initialization steps when enabling the light sensor. The fixed code reorders operations, ensuring mLightSensorEnabled is set first, then registering the listener, and when disabling, unregistering the listener before resetting state variables. This approach prevents potential race conditions and ensures a more predictable and reliable sensor management process, maintaining proper initialization and cleanup sequences."
38945,"@Override public void onTwilightUpdated(TwilightState twilight){
  super.onTwilightUpdated(twilight);
  mHandler.post(mTransitionRunnable);
}","@Override protected void onTwilightUpdated(){
  mHandler.post(mTransitionRunnable);
}","The original code incorrectly overrides the method signature by including a TwilightState parameter, which likely does not match the parent class method definition. The fixed code removes the unnecessary parameter and simplifies the method signature to align with the expected implementation. By eliminating the extraneous parameter and directly posting the transition runnable, the code becomes more concise and adheres to the expected method contract."
38946,"/** 
 * Where is the sun anyway? This calculation determines day or night, and scales the value around sunset/sunrise for a smooth transition.
 * @param now
 * @param sunset
 * @param sunrise
 * @return float between 0 and 1
 */
private static float adj(long now,long sunset,long sunrise){
  if (sunset < 0 || sunrise < 0 || now < sunset || now > sunrise) {
    return 1.0f;
  }
  if (now < sunset + TWILIGHT_ADJUSTMENT_TIME) {
    return MathUtils.lerp(1.0f,0.0f,(float)(now - sunset) / TWILIGHT_ADJUSTMENT_TIME);
  }
  if (now > sunrise - TWILIGHT_ADJUSTMENT_TIME) {
    return MathUtils.lerp(1.0f,0.0f,(float)(sunrise - now) / TWILIGHT_ADJUSTMENT_TIME);
  }
  return 0.0f;
}","/** 
 * Where is the sun anyway? This calculation determines day or night, and scales the value around sunset/sunrise for a smooth transition.
 * @param now
 * @param sunset
 * @param sunrise
 * @return float between 0 and 1
 */
private static float adj(long now,long sunset,long sunrise){
  if (sunset < 0 || sunrise < 0 || now < sunset || now > (sunrise + TWILIGHT_ADJUSTMENT_TIME)) {
    return 1.0f;
  }
  if (now <= (sunset + TWILIGHT_ADJUSTMENT_TIME)) {
    return MathUtils.lerp(1.0f,0.0f,(float)(now - sunset) / TWILIGHT_ADJUSTMENT_TIME);
  }
  if (now >= sunrise) {
    return MathUtils.lerp(1.0f,0.0f,(float)((sunrise + TWILIGHT_ADJUSTMENT_TIME) - now) / TWILIGHT_ADJUSTMENT_TIME);
  }
  return 0.0f;
}","The original code incorrectly handled edge cases around sunrise and sunset, potentially returning incorrect lighting values outside the expected time ranges. The fixed code adjusts the conditional logic to properly handle the twilight transition periods by extending the sunrise boundary and modifying comparison conditions to ensure smooth interpolation between day and night. These changes provide more accurate and consistent light scaling during dawn and dusk, preventing abrupt lighting shifts and ensuring a more natural day-night transition."
38947,"private void updateColorTemperature(){
  mHandler.removeCallbacks(mTransitionRunnable);
  int temperature=mDayTemperature;
  int mode=getMode();
  if (mode == MODE_OFF || isLowPowerMode()) {
    temperature=OFF_TEMPERATURE;
  }
 else   if (mode == MODE_NIGHT) {
    temperature=mNightTemperature;
  }
 else   if (mode == MODE_AUTO) {
    temperature=getTwilightK();
  }
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + mode + ""String_Node_Str""+ temperature+ ""String_Node_Str""+ mColorTemperature);
  }
  if (mAnimator != null) {
    mAnimator.cancel();
    mAnimator.removeAllUpdateListeners();
  }
  mAnimator=ValueAnimator.ofInt(mColorTemperature,temperature);
  mAnimator.setDuration(Math.abs(mColorTemperature - temperature) / 2);
  mAnimator.addUpdateListener(new AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    final ValueAnimator animation){
      mHandler.post(new Runnable(){
        @Override public void run(){
          setDisplayTemperature((Integer)animation.getAnimatedValue());
        }
      }
);
    }
  }
);
  mAnimator.start();
}","private synchronized void updateColorTemperature(){
  if (!mUseTemperatureAdjustment || !isScreenOn()) {
    return;
  }
  int temperature=mDayTemperature;
  int mode=getMode();
  if (mode == MODE_OFF || isLowPowerMode()) {
    temperature=mDefaultDayTemperature;
  }
 else   if (mode == MODE_NIGHT) {
    temperature=mNightTemperature;
  }
 else   if (mode == MODE_AUTO) {
    temperature=getTwilightK();
  }
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + mode + ""String_Node_Str""+ temperature+ ""String_Node_Str""+ mColorTemperature);
  }
  setDisplayTemperature(temperature);
}","The original code unnecessarily used complex animation and handler mechanisms for color temperature updates, potentially causing performance overhead and synchronization issues. The fixed code simplifies the process by directly setting the display temperature based on mode and removing unnecessary animation and threading complexities. This approach ensures more efficient, straightforward color temperature management with reduced computational overhead and improved code readability."
38948,"@Override public void run(){
  setDisplayTemperature((Integer)animation.getAnimatedValue());
}","@Override public void run(){
synchronized (ColorTemperatureController.this) {
    updateColorTemperature();
    mTransitioning=getMode() == MODE_AUTO && mColorTemperature != mDayTemperature && mColorTemperature != mNightTemperature;
    if (mTransitioning) {
      mHandler.postDelayed(mTransitionRunnable,DateUtils.MINUTE_IN_MILLIS);
    }
  }
}","The original code lacks synchronization and context, potentially causing race conditions when updating color temperature. The fixed code introduces synchronized block, adds comprehensive temperature update logic with mode checking, and implements a delayed transition mechanism using a handler. This approach ensures thread-safe temperature updates, provides more robust state management, and prevents potential concurrent modification issues during color temperature transitions."
38949,"void getCapabilities(final BitSet caps){
  if (mUseTemperatureAdjustment) {
    caps.set(MODE_AUTO);
    caps.set(MODE_DAY);
    caps.set(MODE_NIGHT);
  }
}","@Override public boolean getCapabilities(final BitSet caps){
  if (mUseTemperatureAdjustment) {
    caps.set(MODE_AUTO);
    caps.set(MODE_DAY);
    caps.set(MODE_NIGHT);
  }
  return mUseTemperatureAdjustment;
}","The original method lacks a return value, making it impossible to indicate whether temperature adjustment capabilities are available. The fixed code adds a boolean return type and returns `mUseTemperatureAdjustment`, which provides a clear indication of the feature's availability. This modification allows callers to check the temperature adjustment status programmatically, enhancing the method's functionality and providing more informative feedback."
38950,"private synchronized void setDisplayTemperature(int temperature){
  mColorTemperature=temperature;
  final float[] rgb=ColorUtils.temperatureToRGB(temperature);
  mDisplayHardware.setAdditionalAdjustment(rgb);
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + temperature + ""String_Node_Str"");
  }
}","private synchronized void setDisplayTemperature(int temperature){
  mColorTemperature=temperature;
  final float[] rgb=ColorUtils.temperatureToRGB(temperature);
  if (mDisplayHardware.setAdditionalAdjustment(rgb)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + temperature + ""String_Node_Str"");
    }
  }
}","The original code logs a debug message regardless of whether the hardware adjustment was successful, potentially masking important error conditions. The fixed code adds a conditional check to ensure the debug log is only printed if the `setAdditionalAdjustment` method returns true, indicating a successful hardware adjustment. This change improves error handling and provides more precise debugging information by logging only when the temperature adjustment is confirmed to be applied correctly."
38951,"@Override public boolean onStart(){
  if (!mDisplayHardware.hasColorAdjustment()) {
    return false;
  }
  mUseTemperatureAdjustment=true;
  mDefaultDayTemperature=mContext.getResources().getInteger(org.cyanogenmod.platform.internal.R.integer.config_dayColorTemperature);
  mDefaultNightTemperature=mContext.getResources().getInteger(org.cyanogenmod.platform.internal.R.integer.config_nightColorTemperature);
  registerSettings(CMSettings.System.getUriFor(CMSettings.System.DISPLAY_TEMPERATURE_DAY),CMSettings.System.getUriFor(CMSettings.System.DISPLAY_TEMPERATURE_NIGHT));
  return true;
}","@Override public void onStart(){
  if (!mUseTemperatureAdjustment) {
    return;
  }
  mDayTemperature=getDayColorTemperature();
  mNightTemperature=getNightColorTemperature();
  registerSettings(DISPLAY_TEMPERATURE_DAY,DISPLAY_TEMPERATURE_NIGHT);
}","The original code incorrectly checks hardware capabilities before setting temperature adjustment and uses resource-intensive direct resource retrieval. The fixed code first checks if temperature adjustment is enabled, uses getter methods for day and night temperatures, and simplifies the settings registration process. This approach reduces unnecessary hardware checks, improves modularity, and makes the code more robust and maintainable by decoupling temperature retrieval from direct resource access."
38952,"@Override public synchronized void onSettingsChanged(Uri uri){
  mDayTemperature=getDayColorTemperature();
  mNightTemperature=getNightColorTemperature();
  updateColorTemperature();
}","@Override protected synchronized void onSettingsChanged(Uri uri){
  if (uri == null || uri.equals(DISPLAY_TEMPERATURE_DAY)) {
    mDayTemperature=getDayColorTemperature();
  }
  if (uri == null || uri.equals(DISPLAY_TEMPERATURE_NIGHT)) {
    mNightTemperature=getNightColorTemperature();
  }
  updateColorTemperature();
}","The original code always updates both day and night temperatures, potentially causing unnecessary computations and side effects when only one setting changes. The fixed code checks the specific URI before updating each temperature, allowing selective updates based on the changed setting. This approach reduces computational overhead, prevents redundant method calls, and ensures more precise and efficient temperature management."
38953,"public ColorTemperatureController(Context context,Handler handler,DisplayHardwareController displayHardware){
  super(context,handler);
  mDisplayHardware=displayHardware;
}","public ColorTemperatureController(Context context,Handler handler,DisplayHardwareController displayHardware){
  super(context,handler);
  mDisplayHardware=displayHardware;
  mUseTemperatureAdjustment=mDisplayHardware.hasColorAdjustment();
  mDefaultDayTemperature=mContext.getResources().getInteger(org.cyanogenmod.platform.internal.R.integer.config_dayColorTemperature);
  mDefaultNightTemperature=mContext.getResources().getInteger(org.cyanogenmod.platform.internal.R.integer.config_nightColorTemperature);
}","The original code lacks critical initialization of color temperature-related parameters, leaving essential configuration settings unset. The fixed code adds initialization of `mUseTemperatureAdjustment` by checking hardware capabilities, and sets default day and night color temperatures from resource configurations. These additions ensure proper configuration of the color temperature controller, enabling more robust and context-aware display color management."
38954,"@Override public void dump(PrintWriter pw){
  pw.println();
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mDayTemperature);
  pw.println(""String_Node_Str"" + mNightTemperature);
  pw.println();
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mColorTemperature);
  if (getTwilight() != null) {
    pw.println(""String_Node_Str"" + getTwilight().toString());
  }
  pw.println(""String_Node_Str"" + mHandler.hasCallbacks(mTransitionRunnable));
}","@Override public void dump(PrintWriter pw){
  pw.println();
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mDayTemperature);
  pw.println(""String_Node_Str"" + mNightTemperature);
  pw.println();
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mColorTemperature);
  pw.println(""String_Node_Str"" + mTransitioning);
}","The original code incorrectly checks for null on getTwilight() and prints its toString() method, which may introduce unnecessary complexity and potential null pointer risks. The fixed code replaces this with a direct print of mTransitioning, a more straightforward and reliable state indicator. By removing the conditional null check and using a simpler state variable, the code becomes more predictable and reduces the likelihood of runtime errors."
38955,"/** 
 * @hide to prevent subclassing from outside of the framework
 */
private LiveDisplayManager(Context context){
  Context appContext=context.getApplicationContext();
  if (appContext != null) {
    mContext=appContext;
  }
 else {
    mContext=context;
  }
  sService=getService();
  if (context.getPackageManager().hasSystemFeature(CMContextConstants.Features.LIVEDISPLAY) && !checkService()) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  try {
    mConfig=sService.getConfig();
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","/** 
 * @hide to prevent subclassing from outside of the framework
 */
private LiveDisplayManager(Context context){
  Context appContext=context.getApplicationContext();
  if (appContext != null) {
    mContext=appContext;
  }
 else {
    mContext=context;
  }
  sService=getService();
  if (!context.getPackageManager().hasSystemFeature(CMContextConstants.Features.LIVEDISPLAY) || !checkService()) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  try {
    mConfig=sService.getConfig();
    if (mConfig == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","The original code incorrectly throws an exception only when the system feature exists and the service check fails, which is logically inverted. The fixed code changes the condition to throw an exception when the system feature is absent OR the service check fails, ensuring proper error handling. This modification provides more robust error detection and prevents potential runtime issues by explicitly checking for both system feature availability and service validity."
38956,"private synchronized void updateColorAdjustment(){
  if (!mUseColorAdjustment) {
    return;
  }
  final float[] rgb=getDefaultAdjustment();
  if (!isLowPowerMode()) {
    System.arraycopy(mAdditionalAdjustment,0,rgb,0,3);
    rgb[0]*=mColorAdjustment[0];
    rgb[1]*=mColorAdjustment[1];
    rgb[2]*=mColorAdjustment[2];
  }
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(rgb));
  }
  if (validateColors(rgb)) {
    animateDisplayColor(rgb);
  }
}","private synchronized void updateColorAdjustment(){
  if (!mUseColorAdjustment) {
    return;
  }
  final float[] rgb=getDefaultAdjustment();
  if (!isLowPowerMode()) {
    copyColors(mColorAdjustment,rgb);
    rgb[0]*=mAdditionalAdjustment[0];
    rgb[1]*=mAdditionalAdjustment[1];
    rgb[2]*=mAdditionalAdjustment[2];
  }
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(rgb));
  }
  if (validateColors(rgb)) {
    animateDisplayColor(rgb);
  }
}","The original code incorrectly copies additional adjustment values over color adjustment values, potentially overwriting intended color modifications. The fixed code introduces a `copyColors()` method that correctly transfers color adjustment values before multiplying by additional adjustment factors, preserving the intended color transformation. This change ensures accurate color calculation by maintaining the original color adjustment values and applying multiplicative adjustments more precisely."
38957,"@Override public synchronized void onSettingsChanged(Uri uri){
  if (uri == null || uri.equals(DISPLAY_CABC)) {
    updateCABCMode();
  }
  if (uri == null || uri.equals(DISPLAY_AUTO_CONTRAST)) {
    updateAutoContrast();
  }
  if (uri == null || uri.equals(DISPLAY_COLOR_ENHANCE)) {
    updateColorEnhancement();
  }
  if (uri == null || uri.equals(DISPLAY_COLOR_ADJUSTMENT) && parseColorAdjustment(getString(CMSettings.System.DISPLAY_COLOR_ADJUSTMENT),mColorAdjustment)) {
    updateColorAdjustment();
  }
}","@Override public synchronized void onSettingsChanged(Uri uri){
  if (uri == null || uri.equals(DISPLAY_CABC)) {
    updateCABCMode();
  }
  if (uri == null || uri.equals(DISPLAY_AUTO_CONTRAST)) {
    updateAutoContrast();
  }
  if (uri == null || uri.equals(DISPLAY_COLOR_ENHANCE)) {
    updateColorEnhancement();
  }
  if (uri == null || uri.equals(DISPLAY_COLOR_ADJUSTMENT)) {
    copyColors(getColorAdjustment(),mColorAdjustment);
    updateColorAdjustment();
  }
}","The original code incorrectly combined a parsing condition with the color adjustment update, potentially causing unexpected behavior when checking the URI. The fixed code separates the color adjustment parsing by removing the inline parsing and instead uses a separate method `copyColors()` to transfer color adjustment settings before updating. This modification improves code readability, reduces complexity, and ensures a clearer, more modular approach to handling display settings changes."
38958,"/** 
 * Ensure all values are within range
 * @param colors
 * @return true if valid
 */
private boolean validateColors(float[] colors){
  if (colors != null && colors.length == 3 && !(colors[0] <= 0.0f && colors[1] <= 0.0f && colors[2] <= 0.0f)) {
    for (int i=0; i < 3; i++) {
      if (colors[i] > 1.0f) {
        colors[i]=1.0f;
      }
    }
    return true;
  }
  colors[0]=1.0f;
  colors[1]=1.0f;
  colors[2]=1.0f;
  return false;
}","/** 
 * Ensure all values are within range
 * @param colors
 * @return true if valid
 */
private boolean validateColors(float[] colors){
  if (colors == null || colors.length != 3) {
    return false;
  }
  for (int i=0; i < 3; i++) {
    colors[i]=MathUtils.constrain(colors[i],0.0f,1.0f);
  }
  return true;
}","The original code had a complex, error-prone validation logic with incorrect boolean conditions that could lead to unexpected behavior when checking color ranges. The fixed code simplifies validation by using a straightforward null/length check and applying a constrain method to ensure each color value is between 0.0f and 1.0f, regardless of input. This approach provides more robust and predictable color validation with cleaner, more readable code that handles edge cases more effectively."
38959,"/** 
 * Additional adjustments provided by night mode
 * @param adj
 */
synchronized boolean setAdditionalAdjustment(float[] adj){
  if (!mUseColorAdjustment) {
    return false;
  }
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(adj));
  }
  if (validateColors(adj)) {
    System.arraycopy(adj,0,mAdditionalAdjustment,0,3);
    updateColorAdjustment();
    return true;
  }
  return false;
}","/** 
 * Additional adjustments provided by night mode
 * @param adj
 */
synchronized boolean setAdditionalAdjustment(float[] adj){
  if (!mUseColorAdjustment) {
    return false;
  }
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(adj));
  }
  if (validateColors(adj)) {
    copyColors(adj,mAdditionalAdjustment);
    updateColorAdjustment();
    return true;
  }
  return false;
}","The original code uses `System.arraycopy()` directly, which can lead to potential array index out-of-bounds errors if the input array's length is less than 3. The fixed code replaces this with a custom `copyColors()` method, likely implementing safer bounds checking and preventing potential runtime exceptions. This change ensures robust color adjustment by providing a more controlled and defensive approach to copying color adjustment values."
38960,"/** 
 * Smoothly animate the current display colors to the new value.
 */
private synchronized void animateDisplayColor(float[] targetColors){
  int[] currentInts=mHardware.getDisplayColorCalibration();
  float[] currentColors=new float[]{(float)currentInts[0] / (float)mMaxColor,(float)currentInts[1] / (float)mMaxColor,(float)currentInts[2] / (float)mMaxColor};
  if (currentColors[0] == targetColors[0] && currentColors[1] == targetColors[1] && currentColors[2] == targetColors[2]) {
    return;
  }
  long duration=(long)(750 * (Math.max(Math.max(Math.abs(currentColors[0] - targetColors[0]),Math.abs(currentColors[1] - targetColors[1])),Math.abs(currentColors[2] - targetColors[2]))));
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(currentColors) + ""String_Node_Str""+ Arrays.toString(targetColors)+ ""String_Node_Str""+ duration);
  }
  if (mAnimator != null) {
    mAnimator.cancel();
    mAnimator.removeAllUpdateListeners();
  }
  mAnimator=ValueAnimator.ofObject(new FloatArrayEvaluator(new float[3]),currentColors,targetColors);
  mAnimator.setDuration(duration);
  mAnimator.setInterpolator(new LinearInterpolator());
  mAnimator.addUpdateListener(new AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    final ValueAnimator animation){
synchronized (DisplayHardwareController.this) {
        float[] value=(float[])animation.getAnimatedValue();
        mHardware.setDisplayColorCalibration(new int[]{(int)(value[0] * mMaxColor),(int)(value[1] * mMaxColor),(int)(value[2] * mMaxColor)});
        screenRefresh();
      }
    }
  }
);
  mAnimator.start();
}","/** 
 * Smoothly animate the current display colors to the new value.
 */
private synchronized void animateDisplayColor(float[] targetColors){
  int[] currentInts=mHardware.getDisplayColorCalibration();
  float[] currentColors=new float[]{(float)currentInts[0] / (float)mMaxColor,(float)currentInts[1] / (float)mMaxColor,(float)currentInts[2] / (float)mMaxColor};
  if (currentColors[0] == targetColors[0] && currentColors[1] == targetColors[1] && currentColors[2] == targetColors[2]) {
    return;
  }
  long duration=(long)(750 * (Math.max(Math.max(Math.abs(currentColors[0] - targetColors[0]),Math.abs(currentColors[1] - targetColors[1])),Math.abs(currentColors[2] - targetColors[2]))));
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + Arrays.toString(currentColors) + ""String_Node_Str""+ Arrays.toString(targetColors)+ ""String_Node_Str""+ duration);
  }
  if (mAnimator != null) {
    mAnimator.cancel();
    mAnimator.removeAllUpdateListeners();
  }
  mAnimator=ValueAnimator.ofObject(new FloatArrayEvaluator(new float[3]),currentColors,targetColors);
  mAnimator.setDuration(duration);
  mAnimator.setInterpolator(new LinearInterpolator());
  mAnimator.addUpdateListener(new AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    final ValueAnimator animation){
synchronized (DisplayHardwareController.this) {
        if (isScreenOn()) {
          float[] value=(float[])animation.getAnimatedValue();
          mHardware.setDisplayColorCalibration(new int[]{(int)(value[0] * mMaxColor),(int)(value[1] * mMaxColor),(int)(value[2] * mMaxColor)});
          screenRefresh();
        }
      }
    }
  }
);
  mAnimator.start();
}","The original code lacks a screen state check, potentially causing unnecessary color calibration updates when the screen is off. The fixed code adds an `isScreenOn()` condition inside the animation update listener, ensuring color changes occur only when the screen is active. This prevents wasteful processing and potential battery drain by synchronizing color updates strictly with screen state."
38961,"@Override public void onAnimationUpdate(final ValueAnimator animation){
synchronized (DisplayHardwareController.this) {
    float[] value=(float[])animation.getAnimatedValue();
    mHardware.setDisplayColorCalibration(new int[]{(int)(value[0] * mMaxColor),(int)(value[1] * mMaxColor),(int)(value[2] * mMaxColor)});
    screenRefresh();
  }
}","@Override public void onAnimationUpdate(final ValueAnimator animation){
synchronized (DisplayHardwareController.this) {
    if (isScreenOn()) {
      float[] value=(float[])animation.getAnimatedValue();
      mHardware.setDisplayColorCalibration(new int[]{(int)(value[0] * mMaxColor),(int)(value[1] * mMaxColor),(int)(value[2] * mMaxColor)});
      screenRefresh();
    }
  }
}","The original code attempts to update display color calibration without checking if the screen is on, potentially causing unnecessary or erroneous operations. The fixed code adds an `isScreenOn()` check before performing color calibration, ensuring that updates only occur when the screen is active. This prevents potential resource waste and unexpected behavior by conditionally executing screen-related operations only when the screen is powered on."
38962,"public DisplayHardwareController(Context context,Handler handler){
  super(context,handler);
  mHardware=CMHardwareManager.getInstance(mContext);
  mUseCABC=mHardware.isSupported(CMHardwareManager.FEATURE_ADAPTIVE_BACKLIGHT);
  mDefaultCABC=mContext.getResources().getBoolean(org.cyanogenmod.platform.internal.R.bool.config_defaultCABC);
  mUseColorEnhancement=mHardware.isSupported(CMHardwareManager.FEATURE_COLOR_ENHANCEMENT);
  mDefaultColorEnhancement=mContext.getResources().getBoolean(org.cyanogenmod.platform.internal.R.bool.config_defaultColorEnhancement);
  mUseAutoContrast=mHardware.isSupported(CMHardwareManager.FEATURE_AUTO_CONTRAST);
  mDefaultAutoContrast=mContext.getResources().getBoolean(org.cyanogenmod.platform.internal.R.bool.config_defaultAutoContrast);
  mUseColorAdjustment=mHardware.isSupported(CMHardwareManager.FEATURE_DISPLAY_COLOR_CALIBRATION);
  mMaxColor=mHardware.getDisplayColorCalibrationMax();
}","public DisplayHardwareController(Context context,Handler handler){
  super(context,handler);
  mHardware=CMHardwareManager.getInstance(mContext);
  mUseCABC=mHardware.isSupported(CMHardwareManager.FEATURE_ADAPTIVE_BACKLIGHT);
  mDefaultCABC=mContext.getResources().getBoolean(org.cyanogenmod.platform.internal.R.bool.config_defaultCABC);
  mUseColorEnhancement=mHardware.isSupported(CMHardwareManager.FEATURE_COLOR_ENHANCEMENT);
  mDefaultColorEnhancement=mContext.getResources().getBoolean(org.cyanogenmod.platform.internal.R.bool.config_defaultColorEnhancement);
  mUseAutoContrast=mHardware.isSupported(CMHardwareManager.FEATURE_AUTO_CONTRAST);
  mDefaultAutoContrast=mContext.getResources().getBoolean(org.cyanogenmod.platform.internal.R.bool.config_defaultAutoContrast);
  mUseColorAdjustment=mHardware.isSupported(CMHardwareManager.FEATURE_DISPLAY_COLOR_CALIBRATION);
  if (mUseColorAdjustment) {
    mMaxColor=mHardware.getDisplayColorCalibrationMax();
    copyColors(getColorAdjustment(),mColorAdjustment);
  }
 else {
    mMaxColor=0;
  }
}","The original code assumes color adjustment is always supported without checking, which could lead to potential null pointer exceptions or unexpected behavior. The fixed code adds a conditional check for color adjustment support before accessing related methods, ensuring safe method calls and preventing potential runtime errors. By adding this validation and handling both supported and unsupported scenarios, the code becomes more robust and gracefully manages different hardware configurations."
38963,"@Override protected synchronized void onScreenStateChanged(){
  if (mUseColorAdjustment) {
    if (mAnimator != null && mAnimator.isRunning() && !isScreenOn()) {
      mAnimator.cancel();
      mDirty=true;
    }
 else     if (mDirty && isScreenOn()) {
      updateColorAdjustment();
      mDirty=false;
    }
  }
}","@Override protected synchronized void onScreenStateChanged(){
  if (mUseColorAdjustment) {
    if (mAnimator != null && mAnimator.isRunning() && !isScreenOn()) {
      mAnimator.cancel();
    }
 else     if (isScreenOn()) {
      updateColorAdjustment();
    }
  }
}","The original code incorrectly tracked screen state with a redundant `mDirty` flag, potentially causing unnecessary color adjustment updates or missed state changes. The fixed code removes the `mDirty` flag and simplifies the logic, directly calling `updateColorAdjustment()` when the screen is on, eliminating potential synchronization and state tracking errors. This streamlined approach ensures more reliable and predictable screen state handling with cleaner, more direct conditional logic."
38964,"private synchronized boolean setPowerProfileInternal(int profile,boolean fromUser){
  if (profile == mCurrentProfile) {
    return false;
  }
  if (profile < 0 || profile > mNumProfiles) {
    Slog.e(TAG,""String_Node_Str"" + profile);
    return false;
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  long token=Binder.clearCallingIdentity();
  if (fromUser) {
    CMSettings.Secure.putInt(mContext.getContentResolver(),CMSettings.Secure.PERFORMANCE_PROFILE,profile);
  }
  mCurrentProfile=profile;
  mHandler.removeMessages(MSG_CPU_BOOST);
  mHandler.removeMessages(MSG_LAUNCH_BOOST);
  mHandler.sendMessage(Message.obtain(mHandler,MSG_SET_PROFILE,profile,(fromUser ? 1 : 0)));
  Binder.restoreCallingIdentity(token);
  return true;
}","/** 
 * Apply a power profile and persist if fromUser = true
 * @param profile  power profile
 * @param fromUser true to persist the profile
 * @return          true if the active profile changed
 */
private synchronized boolean setPowerProfileInternal(int profile,boolean fromUser){
  if (DEBUG) {
    Slog.v(TAG,String.format(""String_Node_Str"",profile,fromUser));
  }
  if (profile < 0 || profile > mNumProfiles) {
    Slog.e(TAG,""String_Node_Str"" + profile);
    return false;
  }
  if (fromUser) {
    CMSettings.Secure.putInt(mContext.getContentResolver(),CMSettings.Secure.PERFORMANCE_PROFILE,profile);
  }
  if (profile == mCurrentProfile) {
    return false;
  }
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  long token=Binder.clearCallingIdentity();
  mCurrentProfile=profile;
  mHandler.removeMessages(MSG_CPU_BOOST);
  mHandler.removeMessages(MSG_LAUNCH_BOOST);
  mHandler.sendMessage(Message.obtain(mHandler,MSG_SET_PROFILE,profile,(fromUser ? 1 : 0)));
  Binder.restoreCallingIdentity(token);
  return true;
}","The original code checked the current profile after clearing the calling identity, potentially allowing unnecessary permission checks and setting an invalid profile. The fixed code moves the current profile check before permission enforcement, adds optional debug logging, and ensures profile validation occurs before any state changes. This improves the method's robustness by preventing invalid profile settings and providing better error handling and potential diagnostic information."
38965,"@Override public void activityResumed(Intent intent){
  if (!hasAppProfiles() || intent == null || mProfileSetByUser) {
    return;
  }
  final ComponentName cn=intent.getComponent();
  if (cn == null) {
    return;
  }
  int forApp=getProfileForActivity(cn.flattenToString());
  if (forApp == mCurrentProfile) {
    return;
  }
  setPowerProfileInternal(forApp,false);
}","@Override public void activityResumed(Intent intent){
  String activityName=null;
  if (intent != null) {
    final ComponentName cn=intent.getComponent();
    if (cn != null) {
      activityName=cn.flattenToString();
    }
  }
  mCurrentActivityName=activityName;
  applyProfile();
}","The original code had complex, nested conditional logic that made profile switching fragile and error-prone, with multiple early return paths that could prevent proper profile application. The fixed code simplifies the logic by extracting the activity name, storing it in a member variable, and calling a centralized `applyProfile()` method, which provides a more robust and straightforward approach to profile management. This refactoring improves code readability, reduces conditional complexity, and ensures a more consistent and predictable profile switching mechanism."
38966,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mPm=getLocalService(PowerManagerInternal.class);
      mNumProfiles=mPm.getFeature(POWER_FEATURE_SUPPORTED_PROFILES);
      Slog.d(TAG,""String_Node_Str"" + mNumProfiles);
      if (mNumProfiles > 0) {
        int profile=CMSettings.Secure.getInt(mContext.getContentResolver(),CMSettings.Secure.PERFORMANCE_PROFILE,PerformanceManager.PROFILE_BALANCED);
        if (profile == PerformanceManager.PROFILE_HIGH_PERFORMANCE) {
          profile=PerformanceManager.PROFILE_BALANCED;
        }
        setPowerProfileInternal(profile,true);
        mPm.registerLowPowerModeObserver(mLowPowerModeListener);
      }
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mPm=getLocalService(PowerManagerInternal.class);
      mNumProfiles=mPm.getFeature(POWER_FEATURE_SUPPORTED_PROFILES);
      if (mNumProfiles > 0) {
        int profile=getUserProfile();
        if (profile == PerformanceManager.PROFILE_HIGH_PERFORMANCE) {
          Slog.i(TAG,String.format(""String_Node_Str"",profile,PerformanceManager.PROFILE_BALANCED));
          setPowerProfileInternal(PerformanceManager.PROFILE_BALANCED,true);
        }
 else {
          setPowerProfileInternal(profile,false);
        }
        mPm.registerLowPowerModeObserver(mLowPowerModeListener);
      }
    }
  }
}","The original code directly set the performance profile without proper validation, potentially forcing an unintended profile change. The fixed code introduces a getUserProfile() method to retrieve the current profile and adds conditional logic to handle high-performance scenarios more gracefully, logging the profile change and setting a balanced profile when necessary. This approach provides better profile management, ensures more predictable system behavior, and adds logging for improved diagnostics."
38967,"@Override public int getPowerProfile(){
  return CMSettings.Secure.getInt(mContext.getContentResolver(),CMSettings.Secure.PERFORMANCE_PROFILE,PerformanceManager.PROFILE_BALANCED);
}","@Override public int getPowerProfile(){
  return getUserProfile();
}","The original code directly retrieves a performance profile from system settings, which can lead to inconsistent or unintended power management behavior. The fixed code calls `getUserProfile()`, which likely encapsulates a more robust method of determining the appropriate power profile for the current context. By delegating profile selection to a dedicated method, the code becomes more flexible, maintainable, and capable of implementing more sophisticated profile selection logic."
38968,"@Override public void onLowPowerModeChanged(boolean enabled){
  if (mNumProfiles < 1) {
    return;
  }
  if (enabled == mLowPowerModeEnabled) {
    return;
  }
  if (enabled && mCurrentProfile != PerformanceManager.PROFILE_POWER_SAVE) {
    setPowerProfileInternal(PerformanceManager.PROFILE_POWER_SAVE,true);
  }
 else   if (!enabled && mCurrentProfile == PerformanceManager.PROFILE_POWER_SAVE) {
    setPowerProfileInternal(PerformanceManager.PROFILE_BALANCED,true);
  }
}","@Override public void onLowPowerModeChanged(boolean enabled){
  if (enabled == mLowPowerModeEnabled) {
    return;
  }
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + enabled);
  }
  mLowPowerModeEnabled=enabled;
  applyProfile();
}","The original code had complex conditional logic with multiple checks and manual profile switching, leading to potential state management issues and reduced readability. The fixed code simplifies the method by removing unnecessary conditions, directly updating the low power mode state, and calling a centralized `applyProfile()` method to handle profile changes. This approach enhances code maintainability, reduces complexity, and provides a more robust mechanism for managing performance profiles during low power mode transitions."
38969,"public PerformanceManagerService(Context context){
  super(context);
  mContext=context;
  String[] activities=context.getResources().getStringArray(R.array.config_auto_perf_activities);
  if (activities != null && activities.length > 0) {
    mPatterns=new Pattern[activities.length];
    mProfiles=new int[activities.length];
    for (int i=0; i < activities.length; i++) {
      String[] info=activities[i].split(""String_Node_Str"");
      if (info.length == 2) {
        mPatterns[i]=Pattern.compile(info[0]);
        mProfiles[i]=Integer.valueOf(info[1]);
      }
    }
  }
  mHandlerThread=new ServiceThread(TAG,Process.THREAD_PRIORITY_URGENT_DISPLAY + 1,false);
  mHandlerThread.start();
  mHandler=new PerformanceManagerHandler(mHandlerThread.getLooper());
}","public PerformanceManagerService(Context context){
  super(context);
  mContext=context;
  String[] activities=context.getResources().getStringArray(R.array.config_auto_perf_activities);
  if (activities != null && activities.length > 0) {
    mPatterns=new Pattern[activities.length];
    mProfiles=new int[activities.length];
    for (int i=0; i < activities.length; i++) {
      String[] info=activities[i].split(""String_Node_Str"");
      if (info.length == 2) {
        mPatterns[i]=Pattern.compile(info[0]);
        mProfiles[i]=Integer.valueOf(info[1]);
        if (DEBUG) {
          Slog.d(TAG,String.format(""String_Node_Str"",i,info[0],info[1]));
        }
      }
    }
  }
  mHandlerThread=new ServiceThread(TAG,Process.THREAD_PRIORITY_URGENT_DISPLAY + 1,false);
  mHandlerThread.start();
  mHandler=new PerformanceManagerHandler(mHandlerThread.getLooper());
}","The original code lacks debugging visibility, making it difficult to trace potential parsing or configuration issues with activity patterns. The fixed code adds a conditional debug logging statement using `Slog.d()` that prints out the index, pattern, and profile details when the `DEBUG` flag is enabled. This enhancement provides runtime insight into the configuration process, allowing developers to more easily diagnose and understand how activity patterns are being compiled and processed during service initialization."
38970,"private void testMigrateSettingsForUser(int userId){
  Bundle arg=new Bundle();
  arg.putInt(CMSettings.CALL_METHOD_USER_KEY,userId);
  IContentProvider contentProvider=mContentResolver.acquireProvider(CMSettings.AUTHORITY);
  try {
    contentProvider.call(mContentResolver.getPackageName(),CMSettings.CALL_METHOD_MIGRATE_SETTINGS_FOR_USER,null,arg);
  }
 catch (  RemoteException ex) {
    fail(""String_Node_Str"");
  }
  final String actualPullDownValue=CMSettings.System.getStringForUser(mContentResolver,CMSettings.System.QS_QUICK_PULLDOWN,userId);
  assertEquals(expectedPullDownValue,actualPullDownValue);
  final int actualKeyboardBrightness=CMSettings.Secure.getIntForUser(mContentResolver,CMSettings.Secure.KEYBOARD_BRIGHTNESS,-1,userId);
  assertEquals(expectedKeyboardBrightness,actualKeyboardBrightness);
}","private void testMigrateSettingsForUser(int userId){
}","The original code attempts to migrate settings for a user but lacks proper error handling and validation, potentially causing runtime exceptions or unexpected behavior. The fixed code removes the entire implementation, suggesting that the migration logic was fundamentally flawed or unnecessary for the current system requirements. By eliminating the problematic code, the fixed version prevents potential errors and simplifies the method, ensuring more robust and predictable test behavior."
38971,"/** 
 * Set the display gamma calibration for a specific control
 * @param idx the control to set
 * @param rgb RGB color calibration.  Each value must be between{@link getDisplayGammaCalibrationMin()} and {@link getDisplayGammaCalibrationMax()}, inclusive.
 * @return true on success, false otherwise.
 */
@Deprecated public boolean setDisplayGammaCalibration(int idx,int[] rgb){
  try {
    return getService().setDisplayGammaCalibration(idx,rgb);
  }
 catch (  RemoteException e) {
  }
  return false;
}","/** 
 * Set the display gamma calibration for a specific control
 * @param idx the control to set
 * @param rgb RGB color calibration.  Each value must be between{@link getDisplayGammaCalibrationMin()} and {@link getDisplayGammaCalibrationMax()}, inclusive.
 * @return true on success, false otherwise.
 */
@Deprecated public boolean setDisplayGammaCalibration(int idx,int[] rgb){
  try {
    if (checkService()) {
      return sService.setDisplayGammaCalibration(idx,rgb);
    }
  }
 catch (  RemoteException e) {
  }
  return false;
}","The original code lacks a service availability check before calling the remote method, which could lead to a null pointer exception if the service is not initialized. The fixed code adds a `checkService()` method call to verify service availability and uses `sService` instead of `getService()` for more direct service access. This modification enhances error handling and prevents potential runtime crashes by ensuring the service exists before attempting to invoke its method."
38972,"private int[] getDisplayColorCalibrationArray(){
  try {
    return getService().getDisplayColorCalibration();
  }
 catch (  RemoteException e) {
  }
  return null;
}","private int[] getDisplayColorCalibrationArray(){
  try {
    if (checkService()) {
      return sService.getDisplayColorCalibration();
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","The original code lacks service validation before attempting to retrieve display color calibration, which could lead to null pointer exceptions or unexpected behavior. The fixed code adds a `checkService()` method call to verify service availability and uses a local service reference `sService` before invoking `getDisplayColorCalibration()`. This approach ensures safer method execution by preventing potential remote service access errors and providing a more robust error-handling mechanism."
38973,"private int[] getDisplayGammaCalibrationArray(int idx){
  try {
    return getService().getDisplayGammaCalibration(idx);
  }
 catch (  RemoteException e) {
  }
  return null;
}","private int[] getDisplayGammaCalibrationArray(int idx){
  try {
    if (checkService()) {
      return sService.getDisplayGammaCalibration(idx);
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","The original code lacks a null service check before calling getDisplayGammaCalibration(), which could lead to a NullPointerException if the service is not available. The fixed code adds a checkService() method call to verify service availability before attempting to retrieve the gamma calibration array. This modification prevents potential runtime errors and ensures safer method execution by only calling the service method when the service is confirmed to be initialized and accessible."
38974,"/** 
 * @return the number of RGB controls the device supports
 */
@Deprecated public int getNumGammaControls(){
  try {
    return getService().getNumGammaControls();
  }
 catch (  RemoteException e) {
  }
  return 0;
}","/** 
 * @return the number of RGB controls the device supports
 */
@Deprecated public int getNumGammaControls(){
  try {
    if (checkService()) {
      return sService.getNumGammaControls();
    }
  }
 catch (  RemoteException e) {
  }
  return 0;
}","The original code lacks a null service check before calling getNumGammaControls(), which could lead to a NullPointerException if the service is not initialized. The fixed code adds a checkService() method call to verify service availability before invoking getNumGammaControls(), ensuring safe method access. This modification prevents potential runtime errors and provides a more robust error-handling approach by safely returning 0 if the service is unavailable."
38975,"/** 
 * Determine if the given feature is enabled or disabled. Only used for features which have simple enable/disable controls.
 * @param feature the CM Hardware feature to query
 * @return true if the feature is enabled, false otherwise.
 */
public boolean get(int feature){
  if (!BOOLEAN_FEATURES.contains(feature)) {
    throw new IllegalArgumentException(feature + ""String_Node_Str"");
  }
  try {
    return getService().get(feature);
  }
 catch (  RemoteException e) {
  }
  return false;
}","/** 
 * Determine if the given feature is enabled or disabled. Only used for features which have simple enable/disable controls.
 * @param feature the CM Hardware feature to query
 * @return true if the feature is enabled, false otherwise.
 */
public boolean get(int feature){
  if (!BOOLEAN_FEATURES.contains(feature)) {
    throw new IllegalArgumentException(feature + ""String_Node_Str"");
  }
  try {
    if (checkService()) {
      return sService.get(feature);
    }
  }
 catch (  RemoteException e) {
  }
  return false;
}","The original code lacks proper service validation before attempting to retrieve a feature, which could lead to null pointer exceptions or unhandled remote service errors. The fixed code introduces a `checkService()` method and uses a local `sService` variable to ensure the service is available before calling `get()`, providing a more robust error-handling approach. This modification prevents potential runtime crashes and ensures safer feature retrieval by adding an explicit service availability check before executing the remote method."
38976,"/** 
 * @return the interval, in milliseconds, to trigger LTO data download
 */
public long getLtoDownloadInterval(){
  try {
    return getService().getLtoDownloadInterval();
  }
 catch (  RemoteException e) {
  }
  return 0;
}","/** 
 * @return the interval, in milliseconds, to trigger LTO data download
 */
public long getLtoDownloadInterval(){
  try {
    if (checkService()) {
      return sService.getLtoDownloadInterval();
    }
  }
 catch (  RemoteException e) {
  }
  return 0;
}","The original code lacks proper service validation before calling getLtoDownloadInterval(), which could lead to a null pointer exception or unexpected behavior if the service is not available. The fixed code introduces a checkService() method to verify service availability before attempting to retrieve the download interval, ensuring a safe method call. This approach prevents potential runtime errors and provides a more robust mechanism for handling service-related method invocations."
38977,"/** 
 * @return the serial number to display instead of ro.serialno, or null on failure
 */
public String getSerialNumber(){
  try {
    return getService().getSerialNumber();
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * @return the serial number to display instead of ro.serialno, or null on failure
 */
public String getSerialNumber(){
  try {
    if (checkService()) {
      return sService.getSerialNumber();
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","The original code lacks a null service check before calling getSerialNumber(), which could potentially cause a NullPointerException if the service is not available. The fixed code introduces a checkService() method to verify service availability before attempting to retrieve the serial number, ensuring safe method invocation. This modification adds a critical layer of defensive programming, preventing potential runtime errors and improving the method's robustness and reliability."
38978,"/** 
 * Enable or disable the given feature Only used for features which have simple enable/disable controls.
 * @param feature the CM Hardware feature to set
 * @param enable true to enable, false to disale
 * @return true if the feature is enabled, false otherwise.
 */
public boolean set(int feature,boolean enable){
  if (!BOOLEAN_FEATURES.contains(feature)) {
    throw new IllegalArgumentException(feature + ""String_Node_Str"");
  }
  try {
    return getService().set(feature,enable);
  }
 catch (  RemoteException e) {
  }
  return false;
}","/** 
 * Enable or disable the given feature Only used for features which have simple enable/disable controls.
 * @param feature the CM Hardware feature to set
 * @param enable true to enable, false to disale
 * @return true if the feature is enabled, false otherwise.
 */
public boolean set(int feature,boolean enable){
  if (!BOOLEAN_FEATURES.contains(feature)) {
    throw new IllegalArgumentException(feature + ""String_Node_Str"");
  }
  try {
    if (checkService()) {
      return sService.set(feature,enable);
    }
  }
 catch (  RemoteException e) {
  }
  return false;
}","The original code lacks a service availability check before attempting to call the remote service method, which could lead to null pointer exceptions or unhandled errors. The fixed code adds a `checkService()` method call to verify service availability before invoking the `set()` method, ensuring a safer and more robust implementation. This change prevents potential runtime exceptions and provides a more controlled approach to interacting with the remote service."
38979,"/** 
 * @return the destination location of LTO data, or null on failure
 */
public String getLtoDestination(){
  try {
    return getService().getLtoDestination();
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * @return the destination location of LTO data, or null on failure
 */
public String getLtoDestination(){
  try {
    if (checkService()) {
      return sService.getLtoDestination();
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","The original code lacks a service validation check before calling getLtoDestination(), which could lead to a null pointer exception if the service is not properly initialized. The fixed code introduces a checkService() method to verify service availability before invoking getLtoDestination(), and uses a local service reference (sService) for safer access. This approach prevents potential runtime errors and ensures more robust error handling by conditionally executing the service method only when the service is confirmed to be valid."
38980,"/** 
 * @return true if adaptive backlight should be enabled when sunlight enhancementis enabled.
 */
public boolean requireAdaptiveBacklightForSunlightEnhancement(){
  try {
    return getService().requireAdaptiveBacklightForSunlightEnhancement();
  }
 catch (  RemoteException e) {
  }
  return false;
}","/** 
 * @return true if adaptive backlight should be enabled when sunlight enhancementis enabled.
 */
public boolean requireAdaptiveBacklightForSunlightEnhancement(){
  try {
    if (checkService()) {
      return sService.requireAdaptiveBacklightForSunlightEnhancement();
    }
  }
 catch (  RemoteException e) {
  }
  return false;
}","The original code lacks a null service check before calling the method, which could lead to a NullPointerException if the service is not initialized. The fixed code adds a `checkService()` method call to verify service availability before invoking `requireAdaptiveBacklightForSunlightEnhancement()`, ensuring safe method execution. This modification prevents potential runtime errors and provides a more robust error-handling approach by gracefully handling scenarios where the service might be unavailable."
38981,"/** 
 * @return true if setting the mode was successful
 */
public boolean setDisplayMode(DisplayMode mode,boolean makeDefault){
  try {
    return getService().setDisplayMode(mode,makeDefault);
  }
 catch (  RemoteException e) {
  }
  return false;
}","/** 
 * @return true if setting the mode was successful
 */
public boolean setDisplayMode(DisplayMode mode,boolean makeDefault){
  try {
    if (checkService()) {
      return sService.setDisplayMode(mode,makeDefault);
    }
  }
 catch (  RemoteException e) {
  }
  return false;
}","The original code lacks a null service check before calling setDisplayMode, which could lead to a potential NullPointerException. The fixed code adds a checkService() method call to verify the service's availability before invoking setDisplayMode, ensuring safe method execution. This modification prevents null reference errors and provides a more robust error-handling approach for remote service interactions."
38982,"/** 
 * @return the supported features bitmask
 */
public int getSupportedFeatures(){
  try {
    return getService().getSupportedFeatures();
  }
 catch (  RemoteException e) {
  }
  return 0;
}","/** 
 * @return the supported features bitmask
 */
public int getSupportedFeatures(){
  try {
    if (checkService()) {
      return sService.getSupportedFeatures();
    }
  }
 catch (  RemoteException e) {
  }
  return 0;
}","The original code lacks a null service check before calling `getService().getSupportedFeatures()`, which could potentially cause a null pointer exception. The fixed code introduces a `checkService()` method and uses `sService` instead of `getService()`, ensuring the service exists before attempting to retrieve supported features. This modification adds a critical safety layer, preventing potential runtime errors and improving the method's robustness by gracefully handling service unavailability."
38983,"/** 
 * Set the display color calibration to the given rgb triplet
 * @param rgb RGB color calibration.  Each value must be between{@link getDisplayColorCalibrationMin()} and {@link getDisplayColorCalibrationMax()}, inclusive.
 * @return true on success, false otherwise.
 */
public boolean setDisplayColorCalibration(int[] rgb){
  try {
    return getService().setDisplayColorCalibration(rgb);
  }
 catch (  RemoteException e) {
  }
  return false;
}","/** 
 * Set the display color calibration to the given rgb triplet
 * @param rgb RGB color calibration.  Each value must be between{@link getDisplayColorCalibrationMin()} and {@link getDisplayColorCalibrationMax()}, inclusive.
 * @return true on success, false otherwise.
 */
public boolean setDisplayColorCalibration(int[] rgb){
  try {
    if (checkService()) {
      return sService.setDisplayColorCalibration(rgb);
    }
  }
 catch (  RemoteException e) {
  }
  return false;
}","The original code lacks a service availability check before calling `setDisplayColorCalibration()`, which could lead to potential null pointer exceptions or unexpected behavior. The fixed code adds a `checkService()` method call to verify service availability and uses `sService` instead of `getService()`, ensuring a safer method invocation. This modification prevents potential runtime errors and provides a more robust implementation by validating the service before attempting to execute the color calibration method."
38984,"private int[] getVibratorIntensityArray(){
  try {
    return getService().getVibratorIntensity();
  }
 catch (  RemoteException e) {
  }
  return null;
}","private int[] getVibratorIntensityArray(){
  try {
    if (checkService()) {
      return sService.getVibratorIntensity();
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","The original code lacks a service availability check before calling getVibratorIntensity(), which could lead to potential null pointer exceptions or unexpected behavior if the service is not initialized. The fixed code introduces a checkService() method to verify service availability before invoking getVibratorIntensity(), ensuring safe method execution. This approach prevents potential runtime errors and provides a more robust mechanism for handling service-related method calls."
38985,"/** 
 * @return the default display mode to be set on boot
 */
public DisplayMode getDefaultDisplayMode(){
  try {
    return getService().getDefaultDisplayMode();
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * @return the default display mode to be set on boot
 */
public DisplayMode getDefaultDisplayMode(){
  try {
    if (checkService()) {
      return sService.getDefaultDisplayMode();
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","The original code lacks service validation before calling getDefaultDisplayMode(), which could lead to a null pointer exception if the service is not properly initialized. The fixed code adds a checkService() method call to ensure the service exists before attempting to retrieve the default display mode. This approach prevents potential runtime errors and provides a more robust mechanism for safely accessing the display mode service."
38986,"/** 
 * @return the source location of LTO data, or null on failure
 */
public String getLtoSource(){
  try {
    return getService().getLtoSource();
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * @return the source location of LTO data, or null on failure
 */
public String getLtoSource(){
  try {
    if (checkService()) {
      return sService.getLtoSource();
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","The original code lacks proper service validation before attempting to retrieve LTO source, potentially causing null pointer exceptions or unexpected behavior. The fixed code adds a `checkService()` method call to ensure the service is available and valid before invoking `getLtoSource()`, preventing potential runtime errors. By adding this validation step, the code becomes more robust and handles potential service unavailability gracefully."
38987,"/** 
 * @return the currently active display mode
 */
public DisplayMode getCurrentDisplayMode(){
  try {
    return getService().getCurrentDisplayMode();
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * @return the currently active display mode
 */
public DisplayMode getCurrentDisplayMode(){
  try {
    if (checkService()) {
      return sService.getCurrentDisplayMode();
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","The original code lacks a service availability check before calling `getCurrentDisplayMode()`, which could lead to a null pointer exception or unexpected behavior if the service is not properly initialized. The fixed code introduces a `checkService()` method (presumably validating service readiness) and uses a local service reference `sService` before invoking the method, ensuring safe service access. This approach prevents potential runtime errors and provides a more robust mechanism for retrieving the current display mode."
38988,"/** 
 * Set the current vibrator intensity
 * @param intensity the intensity to set, between {@link #getVibratorMinIntensity()} and{@link #getVibratorMaxIntensity()} inclusive.
 * @return true on success, false otherwise.
 */
public boolean setVibratorIntensity(int intensity){
  try {
    return getService().setVibratorIntensity(intensity);
  }
 catch (  RemoteException e) {
  }
  return false;
}","/** 
 * Set the current vibrator intensity
 * @param intensity the intensity to set, between {@link #getVibratorMinIntensity()} and{@link #getVibratorMaxIntensity()} inclusive.
 * @return true on success, false otherwise.
 */
public boolean setVibratorIntensity(int intensity){
  try {
    if (checkService()) {
      return sService.setVibratorIntensity(intensity);
    }
  }
 catch (  RemoteException e) {
  }
  return false;
}","The original code lacks a service availability check before attempting to call the vibrator intensity method, which could lead to null pointer exceptions or unexpected behavior. The fixed code adds a `checkService()` method to verify the service's existence before invoking `setVibratorIntensity()`, ensuring a safe and controlled method call. This modification prevents potential runtime errors and provides a more robust approach to interacting with the vibrator service."
38989,"/** 
 * @return a list of available display modes on the devices
 */
public DisplayMode[] getDisplayModes(){
  try {
    return getService().getDisplayModes();
  }
 catch (  RemoteException e) {
  }
  return null;
}","/** 
 * @return a list of available display modes on the devices
 */
public DisplayMode[] getDisplayModes(){
  try {
    if (checkService()) {
      return sService.getDisplayModes();
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","The original code lacks a null service check before calling getDisplayModes(), which could potentially cause a null pointer exception if the service is not initialized. The fixed code adds a checkService() method call to verify service availability before invoking getDisplayModes(), ensuring safe method execution. This modification prevents potential runtime errors and provides a more robust error-handling approach by conditionally accessing the service only when it is valid."
38990,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  init();
  testSetColor();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  init();
}","The original code calls `testSetColor()` method, which likely contains unnecessary or problematic logic that should not be executed during activity initialization. The fixed code removes the `testSetColor()` method call, ensuring a clean and focused `onCreate()` method that only performs essential setup tasks like `init()`. By eliminating the extraneous method call, the code becomes more maintainable and prevents potential runtime errors or unintended side effects during activity creation."
38991,"@Override public String secureCloneUrl(Configuration configuration){
  if (configuration.isUseHttpsTransport()) {
    String username=configuration.getGithubUsername();
    String password=configuration.getGithubPassword();
    if (Strings.empty(username)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
 else     if (Strings.empty(password)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    URL url=repository.getHtmlUrl();
    String host=username + ""String_Node_Str"" + password+ ""String_Node_Str""+ url.getHost();
    String file=url.getFile();
    if (!file.startsWith(""String_Node_Str"")) {
      file=""String_Node_Str"" + file;
    }
    String answer=""String_Node_Str"" + host + file;
    if (!answer.endsWith(""String_Node_Str"")) {
      answer+=""String_Node_Str"";
    }
    return answer;
  }
  return getCloneUrl();
}","@Override public String secureCloneUrl(Configuration configuration){
  if (configuration.isUseHttpsTransport()) {
    String username=configuration.getGithubUsername();
    String password=configuration.getGithubPassword();
    if (Strings.empty(username)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
 else     if (Strings.empty(password)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    URL url=repository.getHtmlUrl();
    String host=username + ""String_Node_Str"" + password+ ""String_Node_Str""+ url.getHost();
    String file=url.getFile();
    if (!file.startsWith(""String_Node_Str"")) {
      file=""String_Node_Str"" + file;
    }
    String answer=""String_Node_Str"" + host + file;
    if (!answer.endsWith(""String_Node_Str"")) {
      answer+=""String_Node_Str"";
    }
    return answer;
  }
 else {
    return repository.getSshUrl();
  }
}","The original code incorrectly returned the default clone URL when HTTPS transport was not used, potentially exposing an incorrect repository URL. The fixed code replaces the generic `getCloneUrl()` method with `repository.getSshUrl()`, ensuring the correct SSH URL is returned when HTTPS is not enabled. This modification provides a more precise and reliable method for retrieving the repository's clone URL based on the transport configuration."
38992,"protected static void logOutput(Configuration configuration,Logger log,String output,boolean error){
  if (Strings.notEmpty(output)) {
    String[] lines=output.split(""String_Node_Str"");
    for (    String line : lines) {
      if (error) {
        configuration.info(log,line);
      }
 else {
        configuration.warn(log,line);
      }
    }
  }
}","protected static void logOutput(Configuration configuration,Logger log,String output,boolean error){
  if (Strings.notEmpty(output)) {
    String[] lines=output.split(""String_Node_Str"");
    for (    String line : lines) {
      if (error) {
        configuration.info(log,line);
      }
 else {
        configuration.error(log,line);
      }
    }
  }
}","The original code incorrectly used `configuration.warn()` for error logging, which may not appropriately capture critical error messages. The fixed code replaces `warn()` with `error()`, ensuring that serious error conditions are logged at the appropriate severity level. This change provides more accurate and meaningful error tracking, helping developers quickly identify and diagnose critical issues in the application."
38993,"public static boolean runCommandAndLogOutput(Configuration configuration,Logger log,File dir,String... commands){
  File outputFile=new File(dir,""String_Node_Str"");
  File errorFile=new File(dir,""String_Node_Str"");
  try (FileDeleter ignored=new FileDeleter(outputFile,errorFile)){
    outputFile.getParentFile().mkdirs();
    boolean answer=true;
    if (runCommand(dir,outputFile,errorFile,commands) != 0) {
      LOG.warn(""String_Node_Str"" + String.join(""String_Node_Str"",commands));
      answer=false;
    }
    logOutput(configuration,log,outputFile,false);
    logOutput(configuration,log,errorFile,true);
    return answer;
  }
 catch (  IOException e) {
    LOG.warn(""String_Node_Str"" + e,e);
    return false;
  }
}","public static boolean runCommandAndLogOutput(Configuration configuration,Logger log,File dir,String... commands){
  File outputFile=new File(dir,""String_Node_Str"");
  File errorFile=new File(dir,""String_Node_Str"");
  try (FileDeleter ignored=new FileDeleter(outputFile,errorFile)){
    outputFile.getParentFile().mkdirs();
    boolean answer=true;
    if (runCommand(dir,outputFile,errorFile,commands) != 0) {
      LOG.error(""String_Node_Str"" + String.join(""String_Node_Str"",commands));
      answer=false;
    }
    logOutput(configuration,log,outputFile,false);
    logOutput(configuration,log,errorFile,true);
    return answer;
  }
 catch (  IOException e) {
    LOG.warn(""String_Node_Str"" + e,e);
    return false;
  }
}","The original code used LOG.warn() for command execution failures, which might understate the severity of the error. The fixed code changes the logging level to LOG.error(), appropriately signaling a more critical issue during command execution. This modification ensures better error visibility and helps developers quickly identify and diagnose potential problems in the command execution process."
38994,"public RFResult getMatchesFromContentSteam(Reader reader,int start,int rows,List<Query> filters,int flags,Sort lsort,Query mainQuery) throws IOException, SyntaxError {
  RFResult RFResult=rf.like(reader);
  rawRFQuery=RFResult.rawRFQuery;
  boostedRFQuery=getBoostedFunctionQuery(rawRFQuery);
  Query finalQuery=null;
  if (mainQuery != null) {
    BooleanQuery tmpQuery=new BooleanQuery();
    tmpQuery.add(mainQuery,BooleanClause.Occur.MUST);
    tmpQuery.add(boostedRFQuery,BooleanClause.Occur.SHOULD);
    finalQuery=tmpQuery;
  }
 else {
    finalQuery=boostedRFQuery;
  }
  RFResult.setFinalQuery(finalQuery);
  DocListAndSet results=new DocListAndSet();
  if (this.needDocSet) {
    results=searcher.getDocListAndSet(finalQuery,filters,lsort,start,rows,flags);
  }
 else {
    results.docList=searcher.getDocList(finalQuery,filters,lsort,start,rows,flags);
  }
  RFResult.setDoclist(results);
  return RFResult;
}","public RFResult getMatchesFromContentSteam(Reader reader,int start,int rows,List<Query> filters,int flags,Sort lsort,Query userQuery) throws IOException, SyntaxError {
  RFResult RFResult=rf.like(reader);
  rawRFQuery=RFResult.rawRFQuery;
  boostedRFQuery=getBoostedFunctionQuery(rawRFQuery);
  Query finalQuery=null;
  if (userQuery != null) {
    BooleanQuery tmpQuery=new BooleanQuery();
    tmpQuery.add(userQuery,BooleanClause.Occur.MUST);
    tmpQuery.add(boostedRFQuery,BooleanClause.Occur.SHOULD);
    finalQuery=tmpQuery;
  }
 else {
    finalQuery=boostedRFQuery;
  }
  RFResult.setFinalQuery(finalQuery);
  DocListAndSet results=new DocListAndSet();
  if (this.needDocSet) {
    results=searcher.getDocListAndSet(finalQuery,filters,lsort,start,rows,flags);
  }
 else {
    results.docList=searcher.getDocList(finalQuery,filters,lsort,start,rows,flags);
  }
  RFResult.setDoclist(results);
  return RFResult;
}","The original code used an ambiguous parameter name ""mainQuery"" which could lead to misunderstanding of its purpose and intent. The fixed code renames the parameter to ""userQuery"", providing clearer semantic meaning about the query's origin and role in the method. This improvement enhances code readability and makes the method's logic more explicit, helping developers better understand the query construction and filtering process."
38995,"public RFResult getMatchesFromDocs(DocIterator iterator,int start,int rows,List<Query> filters,int flags,Sort lsort,Query mainQuery) throws IOException, SyntaxError {
  realRFQuery=new BooleanQuery();
  List<Integer> ids=new ArrayList<Integer>();
  while (iterator.hasNext()) {
    int id=iterator.nextDoc();
    Document doc=reader.document(id);
    ids.add(id);
    TermQuery tq=new TermQuery(new Term(uniqueKeyField.getName(),uniqueKeyField.getType().storedToIndexed(doc.getField(uniqueKeyField.getName()))));
    realRFQuery.add(tq,BooleanClause.Occur.MUST_NOT);
  }
  RFResult RFResult=rf.like(ids);
  rawRFQuery=RFResult.rawRFQuery;
  if (RFResult.getMustMatchQuery() != null) {
    filters.add(RFResult.getMustMatchQuery());
  }
  if (RFResult.getMustNOTMatchQuery() != null) {
    filters.add(RFResult.getMustNOTMatchQuery());
  }
  boostedRFQuery=getBoostedFunctionQuery(rawRFQuery);
  realRFQuery.add(boostedRFQuery,BooleanClause.Occur.MUST);
  BooleanQuery finalQuery=null;
  if (mainQuery != null) {
    finalQuery=new BooleanQuery();
    finalQuery.add(mainQuery,BooleanClause.Occur.MUST);
    finalQuery.add(realRFQuery,BooleanClause.Occur.SHOULD);
  }
 else {
    finalQuery=realRFQuery;
  }
  RFResult.setFinalQuery(finalQuery);
  DocListAndSet results=new DocListAndSet();
  if (this.needDocSet) {
    results=searcher.getDocListAndSet(finalQuery,filters,lsort,start,rows,flags);
  }
 else {
    results.docList=searcher.getDocList(finalQuery,filters,lsort,start,rows,flags);
  }
  RFResult.setDoclist(results);
  return RFResult;
}","public RFResult getMatchesFromDocs(DocIterator iterator,int start,int rows,List<Query> filters,int flags,Sort lsort,Query userQuery) throws IOException, SyntaxError {
  realRFQuery=new BooleanQuery();
  List<Integer> ids=new ArrayList<Integer>();
  while (iterator.hasNext()) {
    int id=iterator.nextDoc();
    Document doc=reader.document(id);
    ids.add(id);
    TermQuery tq=new TermQuery(new Term(uniqueKeyField.getName(),uniqueKeyField.getType().storedToIndexed(doc.getField(uniqueKeyField.getName()))));
    realRFQuery.add(tq,BooleanClause.Occur.MUST_NOT);
  }
  RFResult RFResult=rf.like(ids);
  rawRFQuery=RFResult.rawRFQuery;
  if (RFResult.getMustMatchQuery() != null) {
    filters.add(RFResult.getMustMatchQuery());
  }
  if (RFResult.getMustNOTMatchQuery() != null) {
    filters.add(RFResult.getMustNOTMatchQuery());
  }
  boostedRFQuery=getBoostedFunctionQuery(rawRFQuery);
  realRFQuery.add(boostedRFQuery,BooleanClause.Occur.MUST);
  BooleanQuery finalQuery=null;
  if (userQuery != null) {
    finalQuery=new BooleanQuery();
    finalQuery.add(userQuery,BooleanClause.Occur.MUST);
    finalQuery.add(realRFQuery,BooleanClause.Occur.SHOULD);
  }
 else {
    finalQuery=realRFQuery;
  }
  RFResult.setFinalQuery(finalQuery);
  DocListAndSet results=new DocListAndSet();
  if (this.needDocSet) {
    results=searcher.getDocListAndSet(finalQuery,filters,lsort,start,rows,flags);
  }
 else {
    results.docList=searcher.getDocList(finalQuery,filters,lsort,start,rows,flags);
  }
  RFResult.setDoclist(results);
  return RFResult;
}","The original code used `mainQuery` as a parameter name, which could be misleading and potentially cause confusion with query handling. In the fixed code, the parameter was renamed to `userQuery`, providing a clearer semantic meaning and improving code readability. This small but meaningful change enhances code understanding and reduces potential misinterpretation of the method's purpose and query processing logic."
38996,"@Override public void handleRequestBody(SolrQueryRequest req,SolrQueryResponse rsp) throws Exception {
  SolrIndexSearcher searcher=req.getSearcher();
  SchemaField uniqueKeyField=searcher.getSchema().getUniqueKeyField();
  ModifiableSolrParams params=new ModifiableSolrParams(req.getParams());
  configureSolrParameters(req,params,uniqueKeyField.getName());
  ReturnFields returnFields=new SolrReturnFields(req);
  rsp.setReturnFields(returnFields);
  int flags=0;
  if (returnFields.wantsScore()) {
    flags|=SolrIndexSearcher.GET_SCORES;
  }
  String defType=params.get(QueryParsing.DEFTYPE,EDISMAX);
  String mainQueryDefType=params.get(RFParams.RF_DEFTYPE,EDISMAX);
  String q=params.get(CommonParams.Q);
  String mainQ=params.get(RFParams.RF_QUERY);
  Query query=null;
  Query mainQuery=null;
  SortSpec sortSpec=null;
  QParser parser=null;
  QParser mainQueryParser=null;
  List<Query> targetFqFilters=null;
  List<Query> rfFqFilters=null;
  try {
    if (q != null) {
      parser=QParser.getParser(q,defType,req);
      query=parser.getQuery();
      sortSpec=parser.getSort(true);
    }
 else {
      parser=QParser.getParser(null,defType,req);
      sortSpec=parser.getSort(true);
    }
    targetFqFilters=getFilters(req,CommonParams.FQ);
    rfFqFilters=getFilters(req,RFParams.FQ);
  }
 catch (  SyntaxError e) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,e);
  }
  try {
    if (mainQ != null) {
      mainQueryParser=QParser.getParser(mainQ,mainQueryDefType,req);
      mainQuery=mainQueryParser.getQuery();
    }
  }
 catch (  SyntaxError e) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,e);
  }
  RFHelper rfhelper=new RFHelper(params,searcher,uniqueKeyField,parser);
  RFParams.TermStyle termStyle=RFParams.TermStyle.get(params.get(RFParams.INTERESTING_TERMS));
  RFResult RFResult=null;
  DocListAndSet rfDocs=null;
  Reader reader=null;
  try {
    int start=params.getInt(CommonParams.START,0);
    int rows=params.getInt(CommonParams.ROWS,10);
    if (q == null || q.trim().length() < 1) {
      reader=getContentStreamReader(req,reader);
      q=""String_Node_Str"";
    }
    if (reader != null) {
      RFResult=rfhelper.getMatchesFromContentSteam(reader,start,rows,rfFqFilters,flags,sortSpec.getSort(),mainQuery);
    }
 else     if (q != null) {
      RFResult=getMoreLikeTheseFromQuery(rsp,params,flags,q,query,mainQuery,sortSpec,targetFqFilters,rfFqFilters,searcher,rfhelper,start,rows);
    }
 else {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,""String_Node_Str"");
    }
    if (RFResult != null) {
      rfDocs=RFResult.getDoclist();
    }
  }
  finally {
    if (reader != null) {
      reader.close();
    }
  }
  if (rfDocs == null) {
    rfDocs=new DocListAndSet();
  }
  rsp.add(""String_Node_Str"",rfDocs.docList);
  if (RFResult != null && RFResult.rawRFQuery != null) {
    rsp.add(RFParams.PREFIX + ""String_Node_Str"",RFResult.rawRFQuery.toString());
  }
  if (RFResult != null && termStyle != RFParams.TermStyle.NONE) {
    addInterestingTerms(rsp,termStyle,RFResult);
  }
  if (params.getBool(FacetParams.FACET,false)) {
    addFacet(req,rsp,params,rfDocs);
  }
  addDebugInfo(req,rsp,q,rfFqFilters,rfhelper,RFResult,rfDocs);
}","@Override public void handleRequestBody(SolrQueryRequest req,SolrQueryResponse rsp) throws Exception {
  SolrIndexSearcher searcher=req.getSearcher();
  SchemaField uniqueKeyField=searcher.getSchema().getUniqueKeyField();
  ModifiableSolrParams params=new ModifiableSolrParams(req.getParams());
  configureSolrParameters(req,params,uniqueKeyField.getName());
  ReturnFields returnFields=new SolrReturnFields(req);
  rsp.setReturnFields(returnFields);
  int flags=0;
  if (returnFields.wantsScore()) {
    flags|=SolrIndexSearcher.GET_SCORES;
  }
  String defType=params.get(QueryParsing.DEFTYPE,EDISMAX);
  String mainQueryDefType=params.get(RFParams.RF_DEFTYPE,EDISMAX);
  String userQ=params.get(CommonParams.Q);
  String rfQ=params.get(RFParams.RF_QUERY);
  Query rfQuery=null;
  Query userQuery=null;
  SortSpec sortSpec=null;
  QParser rfQueryParser=null;
  QParser userQueryParser=null;
  List<Query> targetFqFilters=null;
  List<Query> rfFqFilters=null;
  try {
    if (rfQ != null) {
      rfQueryParser=QParser.getParser(rfQ,defType,req);
      rfQuery=rfQueryParser.getQuery();
      sortSpec=rfQueryParser.getSort(true);
    }
 else {
      rfQueryParser=QParser.getParser(null,defType,req);
      sortSpec=rfQueryParser.getSort(true);
    }
    targetFqFilters=getFilters(req,CommonParams.FQ);
    rfFqFilters=getFilters(req,RFParams.FQ);
  }
 catch (  SyntaxError e) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,e);
  }
  try {
    if (userQ != null) {
      userQueryParser=QParser.getParser(userQ,mainQueryDefType,req);
      userQuery=userQueryParser.getQuery();
    }
  }
 catch (  SyntaxError e) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,e);
  }
  RFHelper rfhelper=new RFHelper(params,searcher,uniqueKeyField,rfQueryParser);
  RFParams.TermStyle termStyle=RFParams.TermStyle.get(params.get(RFParams.INTERESTING_TERMS));
  RFResult RFResult=null;
  DocListAndSet rfDocs=null;
  Reader reader=null;
  try {
    int start=params.getInt(CommonParams.START,0);
    int rows=params.getInt(CommonParams.ROWS,10);
    if (rfQ == null || rfQ.trim().length() < 1) {
      reader=getContentStreamReader(req,reader);
    }
    if (reader != null) {
      rfQ=""String_Node_Str"";
      RFResult=rfhelper.getMatchesFromContentSteam(reader,start,rows,rfFqFilters,flags,sortSpec.getSort(),userQuery);
    }
 else     if (rfQ != null) {
      RFResult=getMoreLikeTheseFromQuery(rsp,params,flags,rfQ,rfQuery,userQuery,sortSpec,targetFqFilters,rfFqFilters,searcher,rfhelper,start,rows);
    }
 else {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,""String_Node_Str"");
    }
    if (RFResult != null) {
      rfDocs=RFResult.getDoclist();
    }
  }
  finally {
    if (reader != null) {
      reader.close();
    }
  }
  if (rfDocs == null) {
    rfDocs=new DocListAndSet();
  }
  rsp.add(""String_Node_Str"",rfDocs.docList);
  if (RFResult != null && RFResult.rawRFQuery != null) {
    rsp.add(RFParams.PREFIX + ""String_Node_Str"",RFResult.rawRFQuery.toString());
  }
  if (RFResult != null && termStyle != RFParams.TermStyle.NONE) {
    addInterestingTerms(rsp,termStyle,RFResult);
  }
  if (params.getBool(FacetParams.FACET,false)) {
    addFacet(req,rsp,params,rfDocs);
  }
  addDebugInfo(req,rsp,rfQ,rfFqFilters,rfhelper,RFResult,rfDocs);
}","The original code incorrectly used the generic query parameter 'q' for both user and relevance feedback queries, causing potential parsing and filtering issues. The fixed code introduces distinct variables 'userQ' and 'rfQ' to separate user and relevance feedback queries, ensuring proper query parsing and filter application. This modification enhances query handling flexibility, improves code readability, and prevents potential conflicts in query processing."
38997,"private RFResult getMoreLikeTheseFromQuery(SolrQueryResponse rsp,SolrParams params,int flags,String q,Query query,Query mainQuery,SortSpec sortSpec,List<Query> targetFqFilters,List<Query> rfFqFilters,SolrIndexSearcher searcher,RFHelper rfhelper,int start,int rows) throws IOException, SyntaxError {
  boolean includeMatch=params.getBool(RFParams.MATCH_INCLUDE,true);
  int matchOffset=params.getInt(RFParams.MATCH_OFFSET,0);
  DocList match=searcher.getDocList(query,targetFqFilters,null,matchOffset,10000,flags);
  if (match.matches() == 0 && mainQuery == null) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,String.format(""String_Node_Str"",q));
  }
  if (includeMatch) {
    rsp.add(""String_Node_Str"",match);
  }
  DocIterator iterator=match.iterator();
  if (iterator.hasNext() || mainQuery != null) {
    return rfhelper.getMatchesFromDocs(iterator,start,rows,rfFqFilters,flags,sortSpec.getSort(),mainQuery);
  }
  return null;
}","private RFResult getMoreLikeTheseFromQuery(SolrQueryResponse rsp,SolrParams params,int flags,String q,Query query,Query userQuery,SortSpec sortSpec,List<Query> targetFqFilters,List<Query> rfFqFilters,SolrIndexSearcher searcher,RFHelper rfhelper,int start,int rows) throws IOException, SyntaxError {
  boolean includeMatch=params.getBool(RFParams.MATCH_INCLUDE,true);
  int matchOffset=params.getInt(RFParams.MATCH_OFFSET,0);
  DocList match=searcher.getDocList(query,targetFqFilters,null,matchOffset,10000,flags);
  if (match.matches() == 0 && userQuery == null) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,String.format(""String_Node_Str"",q));
  }
  if (includeMatch) {
    rsp.add(""String_Node_Str"",match);
  }
  DocIterator iterator=match.iterator();
  if (iterator.hasNext() || userQuery != null) {
    return rfhelper.getMatchesFromDocs(iterator,start,rows,rfFqFilters,flags,sortSpec.getSort(),userQuery);
  }
  return null;
}","The original code used ambiguous parameter names like `mainQuery`, which could lead to confusion about the query's purpose and potential misuse. The fixed code renames `mainQuery` to `userQuery`, providing clearer semantic meaning and improving code readability. This renaming helps developers understand the query's intent and reduces the likelihood of incorrect implementation or misinterpretation of the method's functionality."
38998,"@Override public void handleRequestBody(SolrQueryRequest req,SolrQueryResponse rsp) throws Exception {
  SolrIndexSearcher searcher=req.getSearcher();
  SchemaField uniqueKeyField=searcher.getSchema().getUniqueKeyField();
  ModifiableSolrParams params=new ModifiableSolrParams(req.getParams());
  configureSolrParameters(req,params,uniqueKeyField.getName());
  ReturnFields returnFields=new SolrReturnFields(req);
  rsp.setReturnFields(returnFields);
  int flags=0;
  if (returnFields.wantsScore()) {
    flags|=SolrIndexSearcher.GET_SCORES;
  }
  String defType=params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);
  int maxDocumentsToMatch=params.getInt(UnsupervisedFeedbackParams.MAX_DOCUMENTS_TO_PROCESS,DEFAULT_MAX_NUM_DOCUMENTS_TO_PROCESS);
  String q=params.get(CommonParams.Q);
  Query query=null;
  SortSpec sortSpec=null;
  QParser parser=null;
  List<Query> targetFqFilters=null;
  List<Query> ufFqFilters=null;
  try {
    parser=QParser.getParser(q,defType,req);
    query=parser.getQuery();
    sortSpec=parser.getSort(true);
    targetFqFilters=getFilters(req,CommonParams.FQ);
    ufFqFilters=getFilters(req,UnsupervisedFeedbackParams.FQ);
  }
 catch (  SyntaxError e) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,e);
  }
  UnsupervisedFeedbackHelper usfdbkHelper=new UnsupervisedFeedbackHelper(params,searcher,uniqueKeyField,parser);
  UnsupervisedFeedbackParams.TermStyle termStyle=UnsupervisedFeedbackParams.TermStyle.get(params.get(UnsupervisedFeedbackParams.INTERESTING_TERMS));
  List<InterestingTerm> interesting=(termStyle == UnsupervisedFeedbackParams.TermStyle.NONE) ? null : new ArrayList<InterestingTerm>(usfdbkHelper.relevancyFeedback.getMaxQueryTermsPerField());
  RFResult usfdbkResult=null;
  Reader reader=null;
  try {
    int start=params.getInt(CommonParams.START,0);
    int rows=params.getInt(CommonParams.ROWS,10);
    if (q == null) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,""String_Node_Str"");
    }
 else {
      usfdbkResult=expandQueryAndReExecute(rsp,params,maxDocumentsToMatch,flags,q,query,sortSpec,targetFqFilters,ufFqFilters,searcher,usfdbkHelper,start,rows);
    }
  }
  finally {
    if (reader != null) {
      reader.close();
    }
  }
  DocListAndSet results=new DocListAndSet();
  if (usfdbkResult != null) {
    results=usfdbkResult.getResults();
  }
  rsp.add(""String_Node_Str"",results);
  if (usfdbkResult != null && termStyle != UnsupervisedFeedbackParams.TermStyle.NONE) {
    addInterestingTerms(rsp,termStyle,usfdbkResult);
  }
  if (params.getBool(FacetParams.FACET,false)) {
    addFacet(req,rsp,params,results);
  }
  addDebugInfo(req,rsp,q,ufFqFilters,usfdbkResult);
}","@Override public void handleRequestBody(SolrQueryRequest req,SolrQueryResponse rsp) throws Exception {
  SolrIndexSearcher searcher=req.getSearcher();
  SchemaField uniqueKeyField=searcher.getSchema().getUniqueKeyField();
  ModifiableSolrParams params=new ModifiableSolrParams(req.getParams());
  configureSolrParameters(req,params,uniqueKeyField.getName());
  ReturnFields returnFields=new SolrReturnFields(req);
  rsp.setReturnFields(returnFields);
  int flags=0;
  if (returnFields.wantsScore()) {
    flags|=SolrIndexSearcher.GET_SCORES;
  }
  String defType=params.get(QueryParsing.DEFTYPE,QParserPlugin.DEFAULT_QTYPE);
  int maxDocumentsToMatch=params.getInt(UnsupervisedFeedbackParams.MAX_DOCUMENTS_TO_PROCESS,DEFAULT_MAX_NUM_DOCUMENTS_TO_PROCESS);
  String q=params.get(CommonParams.Q);
  Query query=null;
  SortSpec sortSpec=null;
  QParser parser=null;
  List<Query> targetFqFilters=null;
  List<Query> ufFqFilters=null;
  try {
    parser=QParser.getParser(q,defType,req);
    query=parser.getQuery();
    sortSpec=parser.getSort(true);
    targetFqFilters=getFilters(req,CommonParams.FQ);
    ufFqFilters=getFilters(req,UnsupervisedFeedbackParams.FQ);
  }
 catch (  SyntaxError e) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,e);
  }
  UnsupervisedFeedbackHelper usfdbkHelper=new UnsupervisedFeedbackHelper(params,searcher,uniqueKeyField,parser);
  UnsupervisedFeedbackParams.TermStyle termStyle=UnsupervisedFeedbackParams.TermStyle.get(params.get(UnsupervisedFeedbackParams.INTERESTING_TERMS));
  List<InterestingTerm> interesting=(termStyle == UnsupervisedFeedbackParams.TermStyle.NONE) ? null : new ArrayList<InterestingTerm>(usfdbkHelper.relevancyFeedback.getMaxQueryTermsPerField());
  RFResult usfdbkResult=null;
  Reader reader=null;
  try {
    int start=params.getInt(CommonParams.START,0);
    int rows=params.getInt(CommonParams.ROWS,10);
    if (q == null) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,""String_Node_Str"");
    }
 else {
      usfdbkResult=expandQueryAndReExecute(rsp,params,maxDocumentsToMatch,flags,q,query,sortSpec,targetFqFilters,ufFqFilters,searcher,usfdbkHelper,start,rows);
    }
  }
  finally {
    if (reader != null) {
      reader.close();
    }
  }
  DocListAndSet results=new DocListAndSet();
  if (usfdbkResult != null) {
    results=usfdbkResult.getResults();
  }
  rsp.add(""String_Node_Str"",results.docList);
  if (usfdbkResult != null && termStyle != UnsupervisedFeedbackParams.TermStyle.NONE) {
    addInterestingTerms(rsp,termStyle,usfdbkResult);
  }
  if (params.getBool(FacetParams.FACET,false)) {
    addFacet(req,rsp,params,results);
  }
  addDebugInfo(req,rsp,q,ufFqFilters,usfdbkResult);
}","The original code incorrectly added the entire `results` object to the response, which includes both document list and document set. In the fixed code, `results.docList` is specifically added, ensuring only the document list is returned. This change prevents unnecessary data transmission and improves response efficiency by precisely selecting the required document information."
38999,"public UnsupervisedFeedbackHelper(SolrParams params,SolrIndexSearcher searcher,SchemaField uniqueKeyField,QParser qParser){
  this.searcher=searcher;
  this.qParser=qParser;
  this.reader=searcher.getIndexReader();
  this.uniqueKeyField=uniqueKeyField;
  this.needDocSet=params.getBool(FacetParams.FACET,false);
  SolrParams required=params.required();
  String[] fields=splitList.split(required.get(UnsupervisedFeedbackParams.SIMILARITY_FIELDS));
  if (fields.length < 1) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,""String_Node_Str"" + UnsupervisedFeedbackParams.SIMILARITY_FIELDS);
  }
  this.relevancyFeedback=new RelevancyFeedback(reader);
  relevancyFeedback.setFieldNames(fields);
  final String sPayloadFieldList=params.get(UnsupervisedFeedbackParams.PAYLOAD_FIELDS);
  if (sPayloadFieldList != null && sPayloadFieldList.trim().length() > 0) {
    String[] payloadFields=splitList.split(sPayloadFieldList);
    relevancyFeedback.setPayloadFields(payloadFields);
  }
  relevancyFeedback.setAnalyzer(searcher.getSchema().getIndexAnalyzer());
  relevancyFeedback.setMinTermFreq(params.getInt(UnsupervisedFeedbackParams.MIN_TERM_FREQ,RelevancyFeedback.DEFAULT_MIN_TERM_FREQ));
  relevancyFeedback.setMinDocFreq(params.getInt(UnsupervisedFeedbackParams.MIN_DOC_FREQ,RelevancyFeedback.DEFAULT_MIN_DOC_FREQ));
  relevancyFeedback.setMaxDocFreq(params.getInt(UnsupervisedFeedbackParams.MAX_DOC_FREQ,RelevancyFeedback.DEFAULT_MAX_DOC_FREQ));
  relevancyFeedback.setMinWordLen(params.getInt(UnsupervisedFeedbackParams.MIN_WORD_LEN,RelevancyFeedback.DEFAULT_MIN_WORD_LENGTH));
  relevancyFeedback.setMaxWordLen(params.getInt(UnsupervisedFeedbackParams.MAX_WORD_LEN,RelevancyFeedback.DEFAULT_MAX_WORD_LENGTH));
  relevancyFeedback.setBoostFn(params.get(UnsupervisedFeedbackParams.BOOST_FN));
  relevancyFeedback.setNormalizeFieldBoosts(params.getBool(UnsupervisedFeedbackParams.NORMALIZE_FIELD_BOOSTS,RelevancyFeedback.DEFAULT_NORMALIZE_FIELD_BOOSTS));
  relevancyFeedback.setMaxQueryTermsPerField(params.getInt(UnsupervisedFeedbackParams.MAX_QUERY_TERMS_PER_FIELD,RelevancyFeedback.DEFAULT_MAX_QUERY_TERMS_PER_FIELD));
  relevancyFeedback.setMaxNumTokensParsedPerField(params.getInt(UnsupervisedFeedbackParams.MAX_NUM_TOKENS_PARSED_PER_FIELD,RelevancyFeedback.DEFAULT_MAX_NUM_TOKENS_PARSED_PER_FIELD));
  relevancyFeedback.setLogTf(params.getBool(UnsupervisedFeedbackParams.IS_LOG_TF,RelevancyFeedback.DEFAULT_IS_LOG_TF));
  relevancyFeedback.setBoostFields(SolrPluginUtils.parseFieldBoosts(params.getParams(UnsupervisedFeedbackParams.QF)));
}","public UnsupervisedFeedbackHelper(SolrParams params,SolrIndexSearcher searcher,SchemaField uniqueKeyField,QParser qParser){
  this.searcher=searcher;
  this.qParser=qParser;
  this.reader=searcher.getIndexReader();
  this.uniqueKeyField=uniqueKeyField;
  this.needDocSet=params.getBool(FacetParams.FACET,false);
  SolrParams required=params.required();
  String[] fields=splitList.split(required.get(UnsupervisedFeedbackParams.SIMILARITY_FIELDS));
  if (fields.length < 1) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,""String_Node_Str"" + UnsupervisedFeedbackParams.SIMILARITY_FIELDS);
  }
  this.relevancyFeedback=new RelevancyFeedback(reader);
  relevancyFeedback.setFieldNames(fields);
  final String sPayloadFieldList=params.get(UnsupervisedFeedbackParams.PAYLOAD_FIELDS);
  if (sPayloadFieldList != null && sPayloadFieldList.trim().length() > 0) {
    String[] payloadFields=splitList.split(sPayloadFieldList);
    relevancyFeedback.setPayloadFields(payloadFields);
  }
  relevancyFeedback.setAnalyzer(searcher.getSchema().getIndexAnalyzer());
  relevancyFeedback.setMm(params.get(UnsupervisedFeedbackParams.MM,RelevancyFeedback.DEFAULT_MM));
  relevancyFeedback.setMinTermFreq(params.getInt(UnsupervisedFeedbackParams.MIN_TERM_FREQ,RelevancyFeedback.DEFAULT_MIN_TERM_FREQ));
  relevancyFeedback.setMinDocFreq(params.getInt(UnsupervisedFeedbackParams.MIN_DOC_FREQ,RelevancyFeedback.DEFAULT_MIN_DOC_FREQ));
  relevancyFeedback.setMaxDocFreq(params.getInt(UnsupervisedFeedbackParams.MAX_DOC_FREQ,RelevancyFeedback.DEFAULT_MAX_DOC_FREQ));
  relevancyFeedback.setMinWordLen(params.getInt(UnsupervisedFeedbackParams.MIN_WORD_LEN,RelevancyFeedback.DEFAULT_MIN_WORD_LENGTH));
  relevancyFeedback.setMaxWordLen(params.getInt(UnsupervisedFeedbackParams.MAX_WORD_LEN,RelevancyFeedback.DEFAULT_MAX_WORD_LENGTH));
  relevancyFeedback.setBoostFn(params.get(UnsupervisedFeedbackParams.BOOST_FN));
  relevancyFeedback.setNormalizeFieldBoosts(params.getBool(UnsupervisedFeedbackParams.NORMALIZE_FIELD_BOOSTS,RelevancyFeedback.DEFAULT_NORMALIZE_FIELD_BOOSTS));
  relevancyFeedback.setMaxQueryTermsPerField(params.getInt(UnsupervisedFeedbackParams.MAX_QUERY_TERMS_PER_FIELD,RelevancyFeedback.DEFAULT_MAX_QUERY_TERMS_PER_FIELD));
  relevancyFeedback.setMaxNumTokensParsedPerField(params.getInt(UnsupervisedFeedbackParams.MAX_NUM_TOKENS_PARSED_PER_FIELD,RelevancyFeedback.DEFAULT_MAX_NUM_TOKENS_PARSED_PER_FIELD));
  relevancyFeedback.setLogTf(params.getBool(UnsupervisedFeedbackParams.IS_LOG_TF,RelevancyFeedback.DEFAULT_IS_LOG_TF));
  relevancyFeedback.setBoostFields(SolrPluginUtils.parseFieldBoosts(params.getParams(UnsupervisedFeedbackParams.QF)));
}","The original code lacked a crucial configuration parameter `setMm()` for minimum match criteria in relevancy feedback processing. The fixed code adds `relevancyFeedback.setMm(params.get(UnsupervisedFeedbackParams.MM,RelevancyFeedback.DEFAULT_MM))`, which allows setting a minimum match threshold with a default value if not explicitly specified. This enhancement provides more flexible and configurable query matching behavior, improving the overall query processing capabilities of the UnsupervisedFeedbackHelper."
39000,"private RobotDashboard(Context ctx){
  prefs=ctx.getSharedPreferences(CONFIG_PREFS,Context.MODE_PRIVATE);
  sockets=new ArrayList<>();
  fieldOverlay=new Canvas();
  configuration=new Configuration();
  telemetry=new DashboardTelemetry(this);
  ClasspathScanner scanner=new ClasspathScanner(new ClassFilter(){
    @Override public boolean shouldProcessClass(    String className){
      return className.startsWith(""String_Node_Str"");
    }
    @Override public void processClass(    Class clazz){
      if (clazz.isAnnotationPresent(Config.class)) {
        Log.i(TAG,String.format(""String_Node_Str"",clazz.getCanonicalName()));
        configuration.addOptionsFromClass(clazz);
      }
    }
  }
);
  scanner.scanClasspath();
  server=new RobotWebSocketServer(this);
  try {
    server.start();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private RobotDashboard(Context ctx){
  prefs=ctx.getSharedPreferences(CONFIG_PREFS,Context.MODE_PRIVATE);
  sockets=new ArrayList<>();
  fieldOverlay=new Canvas();
  configuration=new Configuration();
  telemetry=new DashboardTelemetry(this);
  ClasspathScanner scanner=new ClasspathScanner(new ClassFilter(){
    @Override public boolean shouldProcessClass(    String className){
      return className.startsWith(""String_Node_Str"");
    }
    @Override public void processClass(    Class klass){
      if (klass.isAnnotationPresent(Config.class)) {
        Log.i(TAG,String.format(""String_Node_Str"",klass.getCanonicalName()));
        configuration.addOptionsFromClass(klass);
      }
    }
  }
);
  scanner.scanClasspath();
  server=new RobotWebSocketServer(this);
  try {
    server.start();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","The original code used an inconsistent parameter name `clazz` in the `processClass` method, which could lead to potential naming confusion and readability issues. The fixed code renames the parameter to `klass`, maintaining a clear and consistent naming convention while preserving the method's original functionality. This small but meaningful change improves code clarity and reduces the potential for misunderstandings during development and maintenance."
