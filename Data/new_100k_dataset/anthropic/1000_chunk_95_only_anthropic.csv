record_number,buggy_code,fixed_code,anthropic_explanation
94001,"public void onServiceAdded(final int gattStatus,final BluetoothGattService service){
  if (m_cancelledInTheMiddleOfExecuting) {
    final BluetoothGattServer server_native_nullable=getServer().getNative();
    if (server_native_nullable != null) {
      server_native_nullable.removeService(service);
    }
    fail();
  }
 else {
    if (Utils.isSuccess(gattStatus)) {
      succeed();
    }
 else {
      fail(BleServer.ServiceAddListener.Status.FAILED_EVENTUALLY,gattStatus);
    }
  }
}","public void onServiceAdded(final int gattStatus,final BluetoothGattService service){
  if (m_cancelledInTheMiddleOfExecuting) {
    final BluetoothGattServer server_native_nullable=getServer().getNative();
    if (server_native_nullable != null) {
      server_native_nullable.removeService(service);
    }
    fail();
  }
 else {
    if (Utils.isSuccess(gattStatus)) {
      succeed(gattStatus);
    }
 else {
      fail(BleServer.ServiceAddListener.Status.FAILED_EVENTUALLY,gattStatus);
    }
  }
}","The original code's `succeed()` method was called without passing the `gattStatus`, potentially losing important status information during service addition. The fixed code adds `succeed(gattStatus)`, ensuring the status is properly propagated when a service is successfully added. This modification provides more comprehensive error tracking and diagnostic capabilities in Bluetooth GATT service management."
94002,"@Override protected void update(double timeStep){
  final double timeToSuccess=.5d;
  if (getTotalTimeExecuting() >= timeToSuccess) {
    succeed();
  }
}","@Override protected void update(double timeStep){
  final double timeToSuccess=.5d;
  if (getState() == PE_TaskState.EXECUTING && getTotalTimeExecuting() >= timeToSuccess) {
    succeed();
  }
}","The original code lacks a state check, potentially calling succeed() inappropriately when the task might not be in the executing state. The fixed code adds a state validation condition using getState() == PE_TaskState.EXECUTING before calling succeed(), ensuring the method only triggers success when the task is actively executing and has met the time threshold. This modification prevents premature or incorrect task completion and adds a critical layer of state-based logic to the update method."
94003,"private void BleManager(Context context,BleManagerConfig config){
  m_context=context.getApplicationContext();
  m_config=config.clone();
  initLogger();
  m_historicalDatabase=PU_HistoricalData.newDatabase(context,this);
  m_diskOptionsMngr=new P_DiskOptionsManager(m_context);
  m_filterMngr=new P_ScanFilterManager(m_config.defaultScanFilter);
  m_btMngr=(BluetoothManager)m_context.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
  BleManagerState nativeState;
  if (m_btMngr == null) {
    nativeState=BleManagerState.get(BluetoothAdapter.STATE_ON);
  }
 else {
    nativeState=BleManagerState.get(m_btMngr.getAdapter().getState());
  }
  m_stateTracker=new P_BleStateTracker(this);
  m_stateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_nativeStateTracker=new P_NativeBleStateTracker(this);
  m_nativeStateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_mainThreadHandler=new Handler(m_context.getMainLooper());
  m_taskQueue=new P_TaskQueue(this);
  m_crashResolver=new P_BluetoothCrashResolver(m_context);
  m_deviceMngr=new P_DeviceManager(this);
  m_serverMngr=new P_ServerManager(this);
  m_deviceMngr_cache=new P_DeviceManager(this);
  m_listeners=new P_BleManager_Listeners(this);
  initConfigDependentMembers();
  m_logger.printBuildInfo();
}","private void BleManager(Context context,BleManagerConfig config){
  m_context=context.getApplicationContext();
  m_config=config.clone();
  initLogger();
  m_historicalDatabase=PU_HistoricalData.newDatabase(context,this);
  m_diskOptionsMngr=new P_DiskOptionsManager(m_context);
  m_filterMngr=new P_ScanFilterManager(m_config.defaultScanFilter);
  m_btMngr=(BluetoothManager)m_context.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
  BleManagerState nativeState;
  if (m_btMngr == null) {
    nativeState=BleManagerState.get(BluetoothAdapter.STATE_ON);
  }
 else {
    nativeState=BleManagerState.get(m_btMngr.getAdapter().getState());
  }
  m_stateTracker=new P_BleStateTracker(this);
  m_stateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_nativeStateTracker=new P_NativeBleStateTracker(this);
  m_nativeStateTracker.append(nativeState,E_Intent.UNINTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
  m_mainThreadHandler=new Handler(m_context.getMainLooper());
  m_taskQueue=new P_TaskQueue(this);
  m_crashResolver=new P_BluetoothCrashResolver(m_context);
  m_deviceMngr=new P_DeviceManager(this);
  m_deviceMngr_cache=new P_DeviceManager(this);
  m_listeners=new P_BleManager_Listeners(this);
  initConfigDependentMembers();
  m_logger.printBuildInfo();
}","The original code redundantly created a second device manager (`m_deviceMngr_cache`) without clear purpose, potentially leading to unnecessary resource allocation and potential synchronization issues. The fixed code removes the unnecessary duplicate device manager, streamlining the initialization process and reducing potential memory overhead. This simplification ensures more efficient and clean code structure without compromising the Bluetooth management functionality."
94004,"/** 
 */
public BleServer newServer(final IncomingListener incomingListener){
  BleServer bleServer=new BleServer(this);
  m_serverMngr.add(bleServer);
  return bleServer;
}","/** 
 */
public BleServer newServer(final BleServerConfig config,final IncomingListener incomingListener){
  final BleServer bleServer=new BleServer(this,false);
  bleServer.setConfig(config);
  bleServer.setListener_Incoming(incomingListener);
  return bleServer;
}","The original code lacks proper configuration and listener setup when creating a BleServer, potentially leading to an improperly initialized server. The fixed code introduces explicit configuration through BleServerConfig and sets an incoming listener, ensuring the server is fully configured before use. These modifications enhance server initialization robustness, providing more control and predictability in Bluetooth Low Energy server creation."
94005,"/** 
 * Disconnects this server completely, disconnecting all connected clients and shutting things down. To disconnect individual clients use   {@link #disconnect(String)}.
 */
public void disconnect(){
  getClients(new ForEach_Void<String>(){
    @Override public void next(    final String next){
      disconnect(next);
    }
  }
,CONNECTING,CONNECTED);
  m_nativeWrapper.closeServer();
}","/** 
 * Disconnects this server completely, disconnecting all connected clients and shutting things down. To disconnect individual clients use   {@link #disconnect(String)}.
 */
public void disconnect(){
  getClients(new ForEach_Void<String>(){
    @Override public void next(    final String next){
      disconnect(next);
    }
  }
,CONNECTING,CONNECTED);
  m_nativeWrapper.closeServer();
  m_serviceMngr.removeAll(ServiceAddListener.Status.CANCELLED_FROM_DISCONNECT);
}","The original code failed to properly clean up services after server disconnection, potentially leaving lingering service states. The fixed code adds `m_serviceMngr.removeAll(ServiceAddListener.Status.CANCELLED_FROM_DISCONNECT)` to explicitly remove all services with a specific cancellation status during server shutdown. This ensures comprehensive cleanup, preventing potential resource leaks and improving overall system stability by fully terminating all associated services when the server disconnects."
94006,"/** 
 * Returns the native service for the given UUID. <br><br> WARNING: Please see the WARNING for   {@link #getNative()}.
 */
public @Nullable(Nullable.Prevalence.NORMAL) BluetoothGattService getNativeService(final UUID uuid){
  return m_serviceMngr.getService(uuid);
}","/** 
 * Returns the native service for the given UUID. <br><br> WARNING: Please see the WARNING for   {@link #getNative()}.
 */
public @Nullable(Nullable.Prevalence.NORMAL) BluetoothGattService getNativeService(final UUID uuid){
  return m_serviceMngr.getServiceDirectlyFromNativeServer(uuid);
}","The original code used an incorrect method `getService()` which likely did not retrieve the service directly from the native Bluetooth server. The fixed code replaces this with `getServiceDirectlyFromNativeServer()`, which explicitly fetches the service from the native server, ensuring accurate and direct service retrieval. This change guarantees more reliable and precise access to the Bluetooth GATT service by directly interacting with the native server implementation."
94007,"void BleServer(final BleManager mngr,final boolean isNull){
  m_mngr=mngr;
  m_isNull=isNull;
  if (isNull) {
    m_queue=null;
    m_logger=null;
    m_stateTracker=new P_ServerStateTracker(this);
    m_listeners=null;
    m_nativeWrapper=new P_NativeServerWrapper(this);
    m_connectionFailMngr=new P_ServerConnectionFailManager(this);
    m_clientMngr=new P_ClientManager(this);
    m_serviceMngr=new P_ServerServiceManager(this);
  }
 else {
    m_queue=m_mngr.getTaskQueue();
    m_logger=m_mngr.getLogger();
    m_stateTracker=new P_ServerStateTracker(this);
    m_listeners=new P_BleServer_Listeners(this);
    m_nativeWrapper=new P_NativeServerWrapper(this);
    m_connectionFailMngr=new P_ServerConnectionFailManager(this);
    m_clientMngr=new P_ClientManager(this);
    m_serviceMngr=new P_ServerServiceManager(this);
  }
}","void BleServer(final BleManager mngr,final boolean isNull){
  m_mngr=mngr;
  m_isNull=isNull;
  if (isNull) {
    m_queue=null;
    m_stateTracker=new P_ServerStateTracker(this);
    m_listeners=null;
    m_nativeWrapper=new P_NativeServerWrapper(this);
    m_connectionFailMngr=new P_ServerConnectionFailManager(this);
    m_clientMngr=new P_ClientManager(this);
    m_serviceMngr=new P_ServerServiceManager(this);
  }
 else {
    m_queue=m_mngr.getTaskQueue();
    m_stateTracker=new P_ServerStateTracker(this);
    m_listeners=new P_BleServer_Listeners(this);
    m_nativeWrapper=new P_NativeServerWrapper(this);
    m_connectionFailMngr=new P_ServerConnectionFailManager(this);
    m_clientMngr=new P_ClientManager(this);
    m_serviceMngr=new P_ServerServiceManager(this);
  }
}","The original code redundantly initialized m_logger in both null and non-null conditions, which was unnecessary and potentially led to unused object creation. In the fixed code, m_logger initialization was removed, ensuring that only essential components are instantiated based on the isNull flag. This optimization reduces memory overhead and improves code efficiency by creating only the required objects for each initialization scenario."
94008,"void invokeOutgoingListeners(final OutgoingListener.OutgoingEvent e,final OutgoingListener listener_specific_nullable){
  if (listener_specific_nullable != null) {
    listener_specific_nullable.onEvent(e);
  }
  if (m_outgoingListener_default != null) {
    m_outgoingListener_default.onEvent(e);
  }
  if (m_mngr.m_defaultServerOutgoingListener != null) {
    m_mngr.m_defaultServerOutgoingListener.onEvent(e);
  }
}","void invokeOutgoingListeners(final OutgoingListener.OutgoingEvent e,final OutgoingListener listener_specific_nullable){
  if (listener_specific_nullable != null) {
    listener_specific_nullable.onEvent(e);
  }
  if (m_outgoingListener_default != null) {
    m_outgoingListener_default.onEvent(e);
  }
  if (getManager().m_defaultServerOutgoingListener != null) {
    getManager().m_defaultServerOutgoingListener.onEvent(e);
  }
}","The buggy code directly accesses `m_mngr.m_defaultServerOutgoingListener`, which could lead to potential null pointer exceptions or tight coupling. The fixed code replaces this with `getManager().m_defaultServerOutgoingListener`, introducing a method call that likely provides safer manager access and potential additional validation. This change improves code robustness by adding an abstraction layer and potentially preventing direct field access, enhancing maintainability and reducing the risk of unexpected errors."
94009,"protected final BleServer.OutgoingListener.Status getCancelStatusType(){
  BleManager mngr=this.getManager();
  if (mngr.is(BleManagerState.TURNING_OFF)) {
    return BleServer.OutgoingListener.Status.CANCELLED_FROM_BLE_TURNING_OFF;
  }
 else {
    return BleServer.OutgoingListener.Status.CANCELLED_FROM_DISCONNECT;
  }
}","protected final BleServer.OutgoingListener.Status getCancelStatusType(){
  BleManager mngr=this.getManager();
  if (mngr.isAny(BleManagerState.TURNING_OFF,BleManagerState.OFF)) {
    return BleServer.OutgoingListener.Status.CANCELLED_FROM_BLE_TURNING_OFF;
  }
 else {
    return BleServer.OutgoingListener.Status.CANCELLED_FROM_DISCONNECT;
  }
}","The original code only checks for the BLE manager being in the TURNING_OFF state, potentially missing scenarios where the manager is completely OFF. The fixed code uses `isAny()` method to check for both TURNING_OFF and OFF states, ensuring comprehensive state coverage. This modification provides more robust handling of Bluetooth state transitions, preventing potential edge-case failures during disconnection or shutdown processes."
94010,"protected final BleDevice.ReadWriteListener.Status getCancelType(){
  BleManager mngr=this.getManager();
  if (mngr.is(BleManagerState.TURNING_OFF)) {
    return BleDevice.ReadWriteListener.Status.CANCELLED_FROM_BLE_TURNING_OFF;
  }
 else {
    return BleDevice.ReadWriteListener.Status.CANCELLED_FROM_DISCONNECT;
  }
}","protected final BleDevice.ReadWriteListener.Status getCancelType(){
  BleManager mngr=this.getManager();
  if (mngr.isAny(BleManagerState.TURNING_OFF,BleManagerState.OFF)) {
    return BleDevice.ReadWriteListener.Status.CANCELLED_FROM_BLE_TURNING_OFF;
  }
 else {
    return BleDevice.ReadWriteListener.Status.CANCELLED_FROM_DISCONNECT;
  }
}","The original code only checks for the BLE manager being in the TURNING_OFF state, potentially missing scenarios where the manager is already OFF. The fixed code uses isAny() method to check for both TURNING_OFF and OFF states, ensuring comprehensive state coverage for cancellation. This modification provides a more robust handling of BLE manager states, preventing potential edge cases where the manager might have already transitioned to the OFF state."
94011,"public void closeServer(){
  if (m_native == null) {
    m_mngr.ASSERT(false,""String_Node_Str"");
  }
 else {
    final BluetoothGattServer native_local=m_native;
    m_native=null;
    native_local.clearServices();
    native_local.close();
  }
}","public void closeServer(){
  if (m_native == null) {
    m_mngr.ASSERT(false,""String_Node_Str"");
  }
 else {
    final BluetoothGattServer native_local=m_native;
    m_native=null;
    native_local.close();
  }
}","The original code calls `clearServices()` before `close()`, which can potentially cause resource leak or unexpected behavior in Bluetooth GATT server management. The fixed code removes the `clearServices()` method call, directly invoking `close()` to properly shut down the Bluetooth GATT server. This modification ensures clean and efficient server closure without unnecessary intermediate steps that might interfere with the closing process."
94012,"public P_NativeServerWrapper(BleServer server){
  m_server=server;
  m_logger=m_server.getManager().getLogger();
  m_mngr=m_server.getManager();
  if (server.isNull()) {
    m_name=BleDevice.NULL_STRING();
    m_native=null;
  }
 else {
    m_name=""String_Node_Str"";
  }
}","public P_NativeServerWrapper(BleServer server){
  m_server=server;
  m_mngr=m_server.getManager();
  if (server.isNull()) {
    m_name=BleDevice.NULL_STRING();
    m_native=null;
  }
 else {
    m_name=""String_Node_Str"";
  }
}","The original code redundantly retrieves the logger from the server manager before checking server nullability, potentially causing a null pointer exception. The fixed code removes the unnecessary logger retrieval, ensuring safer initialization by accessing the manager only after verifying the server's validity. This modification simplifies the constructor, reduces potential runtime errors, and maintains cleaner, more robust initialization logic."
94013,"/** 
 * Same as   {@link #connect(BleTransaction.Auth,BleTransaction.Init)} but calls {@link #setListener_State(StateListener)} and{@link #setListener_ConnectionFail(ConnectionFailListener)} for you.
 * @return	If the attempt could not even ""leave the gate"" for some resaon, a valid {@link ConnectionFailEvent} is returned telling you why. Otherwisethis method will still return a non-null instance but  {@link ConnectionFailEvent#isNull()} will be <code>true</code>.<br><br> NOTE: your  {@link ConnectionFailListener} will still be called even if this method early-outs.<br><br> TIP:	You can use the return value as an optimization. Many apps will call this method (or its overloads) and throw up a spinner until receiving a callback to  {@link ConnectionFailListener}. However if   {@link ConnectionFailEvent#isNull()} for the return value is <code>false</code>, meaningthe connection attempt couldn't even start for some reason, then you don't have to throw up the spinner in the first place.
 */
public @Nullable(Prevalence.NEVER) ConnectionFailListener.ConnectionFailEvent connect(BleTransaction.Auth authenticationTxn,BleTransaction.Init initTxn,StateListener stateListener,ConnectionFailListener failListener){
  if (stateListener != null) {
    setListener_State(stateListener);
  }
  if (failListener != null) {
    setListener_ConnectionFail(failListener);
  }
  m_connectionFailMngr.onExplicitConnectionStarted();
  final ConnectionFailListener.ConnectionFailEvent info_earlyOut=connect_earlyOut();
  if (info_earlyOut != null)   return info_earlyOut;
  m_lastConnectOrDisconnectWasUserExplicit=true;
  if (isAny(CONNECTED,CONNECTING,CONNECTING_OVERALL)) {
    final ConnectionFailListener.ConnectionFailEvent info_alreadyConnected=ConnectionFailListener.ConnectionFailEvent.DUMMY(this,Status.ALREADY_CONNECTING_OR_CONNECTED);
    m_connectionFailMngr.invokeCallback(info_alreadyConnected);
    return info_alreadyConnected;
  }
  connect_private(authenticationTxn,initTxn,false);
  return NULL_CONNECTIONFAIL_INFO();
}","/** 
 * Same as   {@link #connect(BleTransaction.Auth,BleTransaction.Init)} but calls {@link #setListener_State(StateListener)} and{@link #setListener_ConnectionFail(ConnectionFailListener)} for you.
 * @return	If the attempt could not even ""leave the gate"" for some resaon, a valid {@link ConnectionFailEvent} is returned telling you why. Otherwisethis method will still return a non-null instance but  {@link ConnectionFailEvent#isNull()} will be <code>true</code>.<br><br> NOTE: your  {@link ConnectionFailListener} will still be called even if this method early-outs.<br><br> TIP:	You can use the return value as an optimization. Many apps will call this method (or its overloads) and throw up a spinner until receiving a callback to  {@link ConnectionFailListener}. However if   {@link ConnectionFailEvent#isNull()} for the return value is <code>false</code>, meaningthe connection attempt couldn't even start for some reason, then you don't have to throw up the spinner in the first place.
 */
public @Nullable(Prevalence.NEVER) ConnectionFailListener.ConnectionFailEvent connect(BleTransaction.Auth authenticationTxn,BleTransaction.Init initTxn,StateListener stateListener,ConnectionFailListener failListener){
  if (stateListener != null) {
    setListener_State(stateListener);
  }
  if (failListener != null) {
    setListener_ConnectionFail(failListener);
  }
  m_connectionFailMngr.onExplicitConnectionStarted();
  final ConnectionFailListener.ConnectionFailEvent info_earlyOut=connect_earlyOut();
  if (info_earlyOut != null)   return info_earlyOut;
  m_lastConnectOrDisconnectWasUserExplicit=true;
  if (isAny(CONNECTED,CONNECTING,CONNECTING_OVERALL)) {
    stateTracker_main().remove(RECONNECTING_LONG_TERM,E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE);
    final ConnectionFailListener.ConnectionFailEvent info_alreadyConnected=ConnectionFailListener.ConnectionFailEvent.DUMMY(this,Status.ALREADY_CONNECTING_OR_CONNECTED);
    m_connectionFailMngr.invokeCallback(info_alreadyConnected);
    return info_alreadyConnected;
  }
  connect_private(authenticationTxn,initTxn,false);
  return NULL_CONNECTIONFAIL_INFO();
}","The original code lacked proper handling when already in a connecting or connected state, potentially leaving the device in an inconsistent state. The fixed code adds a critical step by removing the RECONNECTING_LONG_TERM state tracker before generating the already connected event, ensuring clean state management. This modification prevents potential race conditions and improves the robustness of the connection process by explicitly clearing previous reconnection states before handling duplicate connection attempts."
94014,"void onConnecting(boolean definitelyExplicit,boolean isReconnect,final Object[] extraBondingStates){
  m_lastConnectOrDisconnectWasUserExplicit=definitelyExplicit;
  if (is_internal(CONNECTING)) {
    P_Task_Connect task=getTaskQueue().getCurrent(P_Task_Connect.class,this);
    boolean mostDefinitelyExplicit=task != null && task.isExplicit();
    m_mngr.ASSERT(definitelyExplicit || mostDefinitelyExplicit);
    stateTracker_main().update(E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,extraBondingStates);
  }
 else {
    final E_Intent intent;
    if (definitelyExplicit && !isReconnect) {
      m_reconnectMngr_longTerm.stop();
      intent=E_Intent.INTENTIONAL;
      stateTracker().update(intent,BluetoothGatt.GATT_SUCCESS,RECONNECTING_LONG_TERM,false,CONNECTING,true,CONNECTING_OVERALL,true,DISCONNECTED,false,ADVERTISING,false,extraBondingStates);
    }
 else {
      intent=lastConnectDisconnectIntent();
      stateTracker().update(intent,BluetoothGatt.GATT_SUCCESS,CONNECTING,true,CONNECTING_OVERALL,true,DISCONNECTED,false,ADVERTISING,false,extraBondingStates);
    }
    if (stateTracker() != stateTracker_main()) {
      stateTracker_main().update(intent,BleStatuses.GATT_STATUS_NOT_APPLICABLE,extraBondingStates);
    }
  }
}","void onConnecting(boolean definitelyExplicit,boolean isReconnect,final Object[] extraBondingStates,final boolean bleConnect){
  m_lastConnectOrDisconnectWasUserExplicit=definitelyExplicit;
  if (bleConnect && is_internal(CONNECTING)) {
    P_Task_Connect task=getTaskQueue().getCurrent(P_Task_Connect.class,this);
    boolean mostDefinitelyExplicit=task != null && task.isExplicit();
    m_mngr.ASSERT(definitelyExplicit || mostDefinitelyExplicit);
    stateTracker_main().update(E_Intent.INTENTIONAL,BleStatuses.GATT_STATUS_NOT_APPLICABLE,extraBondingStates);
  }
 else {
    final E_Intent intent;
    if (definitelyExplicit && !isReconnect) {
      m_reconnectMngr_longTerm.stop();
      intent=E_Intent.INTENTIONAL;
      stateTracker().update(intent,BluetoothGatt.GATT_SUCCESS,RECONNECTING_LONG_TERM,false,CONNECTING,bleConnect,CONNECTING_OVERALL,true,DISCONNECTED,false,ADVERTISING,false,extraBondingStates);
    }
 else {
      intent=lastConnectDisconnectIntent();
      stateTracker().update(intent,BluetoothGatt.GATT_SUCCESS,CONNECTING,bleConnect,CONNECTING_OVERALL,true,DISCONNECTED,false,ADVERTISING,false,extraBondingStates);
    }
    if (stateTracker() != stateTracker_main()) {
      stateTracker_main().update(intent,BleStatuses.GATT_STATUS_NOT_APPLICABLE,UNBONDED,stateTracker().is(UNBONDED),BONDING,stateTracker().is(BONDING),BONDED,stateTracker().is(BONDED));
    }
  }
}","The original code lacked a critical parameter to differentiate between Bluetooth Low Energy (BLE) connect states, leading to potential state tracking errors. The fixed code introduces a `bleConnect` parameter that enables more precise state management, allowing conditional updates to connection states based on explicit connection types. This enhancement improves state tracking accuracy by providing granular control over connection tracking and ensuring correct bonding state transitions during BLE connection processes."
94015,"private void connect_private(BleTransaction.Auth authenticationTxn,BleTransaction.Init initTxn,boolean isReconnect){
  if (is_internal(INITIALIZED)) {
    m_mngr.ASSERT(false,""String_Node_Str"");
    return;
  }
  m_txnMngr.onConnect(authenticationTxn,initTxn);
  final Object[] extraBondingStates;
  if (is(UNBONDED)) {
    final boolean tryBondingWhileDisconnected_manageOnDisk=BleDeviceConfig.bool(conf_device().tryBondingWhileDisconnected_manageOnDisk,conf_mngr().tryBondingWhileDisconnected_manageOnDisk);
    final boolean doPreBond=getManager().m_diskOptionsMngr.loadNeedsBonding(getMacAddress(),tryBondingWhileDisconnected_manageOnDisk);
    if (doPreBond) {
      bond_justAddTheTask(E_TransactionLockBehavior.PASSES);
      extraBondingStates=P_BondManager.OVERRIDE_BONDING_STATES;
    }
 else {
      extraBondingStates=P_BondManager.OVERRIDE_EMPTY_STATES;
    }
  }
 else {
    extraBondingStates=P_BondManager.OVERRIDE_EMPTY_STATES;
  }
  m_queue.add(new P_Task_Connect(this,m_taskStateListener));
  onConnecting(true,isReconnect,extraBondingStates);
}","private void connect_private(BleTransaction.Auth authenticationTxn,BleTransaction.Init initTxn,final boolean isReconnect){
  if (is_internal(INITIALIZED)) {
    m_mngr.ASSERT(false,""String_Node_Str"");
    return;
  }
  m_txnMngr.onConnect(authenticationTxn,initTxn);
  final Object[] extraBondingStates;
  if (is(UNBONDED)) {
    final boolean tryBondingWhileDisconnected_manageOnDisk=BleDeviceConfig.bool(conf_device().tryBondingWhileDisconnected_manageOnDisk,conf_mngr().tryBondingWhileDisconnected_manageOnDisk);
    final boolean doPreBond=getManager().m_diskOptionsMngr.loadNeedsBonding(getMacAddress(),tryBondingWhileDisconnected_manageOnDisk);
    if (doPreBond) {
      bond_justAddTheTask(E_TransactionLockBehavior.PASSES);
      extraBondingStates=P_BondManager.OVERRIDE_BONDING_STATES;
    }
 else {
      extraBondingStates=P_BondManager.OVERRIDE_EMPTY_STATES;
    }
  }
 else {
    extraBondingStates=P_BondManager.OVERRIDE_EMPTY_STATES;
  }
  onConnecting(true,isReconnect,extraBondingStates,false);
  if (!is_internal(CONNECTING_OVERALL)) {
    return;
  }
  m_queue.add(new P_Task_Connect(this,m_taskStateListener));
  onConnecting(true,isReconnect,extraBondingStates,true);
}","The original code lacked proper connection state management, potentially causing race conditions and inconsistent device connection behaviors. The fixed code introduces additional checks with `is_internal(CONNECTING_OVERALL)` and adds a second `onConnecting()` call with a final parameter to ensure more robust connection initialization and state tracking. These modifications improve the reliability of the connection process by preventing potential synchronization issues and providing more controlled device connection logic."
94016,"/** 
 * The gattStatus returned, if applicable, from native callbacks like   {@link BluetoothGattCallback#onConnectionStateChange(BluetoothGatt,int,int)}or   {@link BluetoothGattCallback#onServicesDiscovered(BluetoothGatt,int)}. If not applicable, for example if   {@link ConnectionFailEvent#reason()} is {@link Status#EXPLICIT_DISCONNECT}, then this is set to  {@link BleDeviceConfig#GATT_STATUS_NOT_APPLICABLE}.  <br><br> See   {@link ReadWriteEvent#gattStatus()} for more information about gatt status codes in general.
 * @see ReadWriteEvent#gattStatus
 */
public int gattStatus(){
  return m_gattStatus;
}","/** 
 * The gattStatus returned, if applicable, from native callbacks like   {@link BluetoothGattCallback#onConnectionStateChange(BluetoothGatt,int,int)}or   {@link BluetoothGattCallback#onServicesDiscovered(BluetoothGatt,int)}. If not applicable, for example if   {@link ConnectionFailEvent#reason()} is {@link Status#EXPLICIT_DISCONNECT}, then this is set to  {@link BleStatuses#GATT_STATUS_NOT_APPLICABLE}.  <br><br> See   {@link ReadWriteEvent#gattStatus()} for more information about gatt status codes in general.
 * @see ReadWriteEvent#gattStatus
 */
public int gattStatus(){
  return m_gattStatus;
}","The original code referenced an undefined `BleDeviceConfig.GATT_STATUS_NOT_APPLICABLE` constant, which could lead to compilation errors or incorrect status handling. The fixed code corrects this by using `BleStatuses.GATT_STATUS_NOT_APPLICABLE`, which is likely the correct and defined constant for representing inapplicable GATT statuses. This change ensures proper status reporting and maintains consistency with the library's intended status management approach."
94017,"private void onConnectionStateChange_synchronized(final BluetoothGatt gatt,final int gattStatus,final int newState){
  if (newState == BluetoothProfile.STATE_DISCONNECTED) {
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
    final P_Task_Connect connectTask=m_queue.getCurrent(P_Task_Connect.class,m_device);
    if (connectTask != null) {
      connectTask.onNativeFail(gattStatus);
    }
 else {
      final P_Task_Disconnect disconnectTask=m_queue.getCurrent(P_Task_Disconnect.class,m_device);
      if (disconnectTask != null) {
        disconnectTask.onNativeSuccess(gattStatus);
      }
 else {
        m_device.onNativeDisconnect(false,gattStatus,true);
      }
    }
    m_device.m_nativeWrapper.closeGattIfNeeded(false);
  }
 else   if (newState == BluetoothProfile.STATE_CONNECTING) {
    if (Utils.isSuccess(gattStatus)) {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
      m_device.onConnecting(false,false,P_BondManager.OVERRIDE_EMPTY_STATES);
      if (!m_queue.isCurrent(P_Task_Connect.class,m_device)) {
        P_Task_Connect task=new P_Task_Connect(m_device,m_taskStateListener,false,PE_TaskPriority.FOR_IMPLICIT_BONDING_AND_CONNECTING);
        m_queue.add(task);
      }
      m_queue.fail(P_Task_Disconnect.class,m_device);
    }
 else {
      onNativeConnectFail(gatt,gattStatus);
    }
  }
 else   if (newState == BluetoothProfile.STATE_CONNECTED) {
    if (Utils.isSuccess(gattStatus)) {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
      m_queue.fail(P_Task_Disconnect.class,m_device);
      if (!m_queue.succeed(P_Task_Connect.class,m_device)) {
        m_device.onNativeConnect(false);
      }
    }
 else {
      onNativeConnectFail(gatt,gattStatus);
    }
  }
 else   if (newState == BluetoothProfile.STATE_DISCONNECTING) {
    m_logger.e(""String_Node_Str"");
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
    if (!m_queue.isCurrent(P_Task_Disconnect.class,m_device)) {
      P_Task_Disconnect task=new P_Task_Disconnect(m_device,m_taskStateListener,false,PE_TaskPriority.FOR_IMPLICIT_BONDING_AND_CONNECTING,true);
      m_queue.add(task);
    }
    m_queue.fail(P_Task_Connect.class,m_device);
  }
 else {
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt);
  }
}","private void onConnectionStateChange_synchronized(final BluetoothGatt gatt,final int gattStatus,final int newState){
  if (newState == BluetoothProfile.STATE_DISCONNECTED) {
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
    final P_Task_Connect connectTask=m_queue.getCurrent(P_Task_Connect.class,m_device);
    if (connectTask != null) {
      connectTask.onNativeFail(gattStatus);
    }
 else {
      final P_Task_Disconnect disconnectTask=m_queue.getCurrent(P_Task_Disconnect.class,m_device);
      if (disconnectTask != null) {
        disconnectTask.onNativeSuccess(gattStatus);
      }
 else {
        m_device.onNativeDisconnect(false,gattStatus,true);
      }
    }
    m_device.m_nativeWrapper.closeGattIfNeeded(false);
  }
 else   if (newState == BluetoothProfile.STATE_CONNECTING) {
    if (Utils.isSuccess(gattStatus)) {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
      m_device.onConnecting(false,false,P_BondManager.OVERRIDE_EMPTY_STATES,true);
      if (!m_queue.isCurrent(P_Task_Connect.class,m_device)) {
        P_Task_Connect task=new P_Task_Connect(m_device,m_taskStateListener,false,PE_TaskPriority.FOR_IMPLICIT_BONDING_AND_CONNECTING);
        m_queue.add(task);
      }
      m_queue.fail(P_Task_Disconnect.class,m_device);
    }
 else {
      onNativeConnectFail(gatt,gattStatus);
    }
  }
 else   if (newState == BluetoothProfile.STATE_CONNECTED) {
    if (Utils.isSuccess(gattStatus)) {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
      m_queue.fail(P_Task_Disconnect.class,m_device);
      if (!m_queue.succeed(P_Task_Connect.class,m_device)) {
        m_device.onNativeConnect(false);
      }
    }
 else {
      onNativeConnectFail(gatt,gattStatus);
    }
  }
 else   if (newState == BluetoothProfile.STATE_DISCONNECTING) {
    m_logger.e(""String_Node_Str"");
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
    if (!m_queue.isCurrent(P_Task_Disconnect.class,m_device)) {
      P_Task_Disconnect task=new P_Task_Disconnect(m_device,m_taskStateListener,false,PE_TaskPriority.FOR_IMPLICIT_BONDING_AND_CONNECTING,true);
      m_queue.add(task);
    }
    m_queue.fail(P_Task_Connect.class,m_device);
  }
 else {
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt);
  }
}","The original code lacked a crucial parameter in the `onConnecting` method, potentially causing incomplete state tracking during Bluetooth connection attempts. The fixed code adds a fourth boolean parameter (likely indicating explicit/implicit connection) to the `onConnecting` method, ensuring more comprehensive connection state management. This enhancement provides more detailed and accurate tracking of connection states, improving the robustness of the Bluetooth connection handling mechanism."
94018,"/** 
 * Returns the device's name and current state for logging and debugging purposes.
 */
@Override public String toString(){
  if (isNull()) {
    return ""String_Node_Str"";
  }
 else {
    return getName_debug() + ""String_Node_Str"" + m_stateTracker.toString();
  }
}","/** 
 * Returns the device's name and current state for logging and debugging purposes.
 */
@Override public String toString(){
  if (isNull()) {
    return NULL_STRING();
  }
 else {
    return getName_debug() + ""String_Node_Str"" + m_stateTracker.toString();
  }
}","The original code returns a hardcoded ""String_Node_Str"" when the object is null, which lacks meaningful information and reduces debugging utility. The fixed code replaces this with a call to NULL_STRING(), which likely provides a more descriptive or context-aware null representation. This modification enhances code readability and provides more informative logging by returning a more meaningful null string representation when the object is in a null state."
94019,"/** 
 * Kicks off an OTA transaction if it's not already taking place and the device is   {@link BleDeviceState#INITIALIZED}. This will put the device into the   {@link BleDeviceState#PERFORMING_OTA} state if <code>true</code> is returned.<br><br> TIP: Use the  {@link TimeEstimator} class to let your users know roughly how much time it will take for the ota to complete.
 * @return	{@link Boolean#TRUE} if firmware update has started, otherwise {@link Boolean#FALSE} if device is either already{@link BleDeviceState#PERFORMING_OTA} or is not {@link BleDeviceState#INITIALIZED}.
 * @see BleManagerConfig#includeOtaReadWriteTimesInAverage
 * @see BleManagerConfig#autoScanDuringOta
 */
public boolean performOta(BleTransaction.Ota txn){
  if (isNull())   return false;
  if (is(PERFORMING_OTA))   return false;
  if (!is(INITIALIZED))   return false;
  m_txnMngr.startOta(txn);
  return true;
}","/** 
 * Kicks off an ""over the air"" long-term transaction if it's not already taking place and the device is   {@link BleDeviceState#INITIALIZED}. This will put the device into the   {@link BleDeviceState#PERFORMING_OTA} state if <code>true</code> is returned.You can use this to do firmware updates, file transfers, etc. <br><br> TIP: Use the  {@link TimeEstimator} class to let your users know roughly how much time it will take for the ota to complete.
 * @return	{@link Boolean#TRUE} if firmware update has started, otherwise {@link Boolean#FALSE} if device is either already{@link BleDeviceState#PERFORMING_OTA} or is not {@link BleDeviceState#INITIALIZED}.
 * @see BleManagerConfig#includeOtaReadWriteTimesInAverage
 * @see BleManagerConfig#autoScanDuringOta
 */
public boolean performOta(BleTransaction.Ota txn){
  if (isNull())   return false;
  if (is(PERFORMING_OTA))   return false;
  if (!is(INITIALIZED))   return false;
  m_txnMngr.startOta(txn);
  return true;
}","The original code lacked clarity in the method's purpose and documentation, potentially causing confusion about the OTA (over-the-air) transaction's scope and functionality. The fixed code enhances the documentation by explicitly stating that the method can be used for firmware updates, file transfers, and other long-term transactions, providing more context about its versatility. The improved documentation helps developers better understand the method's intended use and potential applications, making the code more readable and maintainable."
94020,"/** 
 * Return this from   {@link ReconnectFilter#onEvent(ReconnectFilter.ReconnectEvent)} to stop a reconnect attempt loop.Note that  {@link BleDevice#disconnect()} will also stop any ongoing reconnect loop.
 */
public static Please stopRetrying(){
  return new Please(STOP);
}","/** 
 * Return this from   {@link ReconnectRequestFilter#onEvent(ReconnectRequestFilter.ReconnectRequestEvent)} to stop a reconnect attempt loop.Note that  {@link BleDevice#disconnect()} will also stop any ongoing reconnect loop.
 */
public static Please stopRetrying(){
  return new Please(STOP);
}","The original code references an incorrect class name `ReconnectFilter`, which likely does not exist or is not the intended class for this method. The fixed code updates the class name to `ReconnectRequestFilter`, which appears to be the correct and intended class for handling reconnect request events. This change ensures the documentation and code accurately reflect the proper class and method context, improving code clarity and preventing potential confusion or runtime errors."
94021,"/** 
 * Return this from   {@link ReconnectFilter#onEvent(ReconnectFilter.ReconnectEvent)} to retry after the given amount of time.
 */
public static Please retryIn(Interval interval){
  return new Please(interval != null ? interval : INSTANTLY);
}","/** 
 * Return this from   {@link ReconnectRequestFilter#onEvent(ReconnectRequestFilter.ReconnectRequestEvent)} to retry after the given amount of time.
 */
public static Please retryIn(Interval interval){
  return new Please(interval != null ? interval : INSTANTLY);
}","The original code referenced an incorrect class and method name, potentially causing confusion and preventing proper event handling. The fixed code corrects the class name from `ReconnectFilter` to `ReconnectRequestFilter` and updates the method reference accordingly, ensuring accurate documentation and clarity. This change helps developers understand the correct context and usage of the `retryIn` method within the reconnection request workflow."
94022,"/** 
 * Return this from   {@link ReconnectFilter#onEvent(ReconnectFilter.ReconnectEvent)} to instantly reconnect.
 */
public static Please retryInstantly(){
  return new Please(INSTANTLY);
}","/** 
 * Return this from   {@link ReconnectRequestFilter#onEvent(ReconnectRequestFilter.ReconnectRequestEvent)} to instantly reconnect.
 */
public static Please retryInstantly(){
  return new Please(INSTANTLY);
}","The original code references an incorrect class name `ReconnectFilter`, which likely does not match the actual implementation. The fixed code updates the class reference to `ReconnectRequestFilter`, ensuring accurate documentation and method linkage. This correction provides precise class referencing, preventing potential confusion and improving code clarity by using the correct class name in the Javadoc comment."
94023,"/** 
 * The previous   {@link Interval} returned from {@link ReconnectFilter#onEvent(ReconnectEvent)}, or   {@link Interval#ZERO}for the first invocation.
 */
public Interval previousDelay(){
  return m_previousDelay;
}","/** 
 * The previous   {@link Interval} returned from {@link ReconnectRequestFilter#onEvent(ReconnectRequestEvent)}, or   {@link Interval#ZERO}for the first invocation.
 */
public Interval previousDelay(){
  return m_previousDelay;
}","The original code incorrectly referenced a non-existent class `ReconnectFilter` instead of the actual `ReconnectRequestFilter` in the JavaDoc comment. The fixed code corrects the class name and updates the event type from `ReconnectEvent` to `ReconnectRequestEvent` to accurately reflect the method's context and documentation. These changes ensure precise and correct documentation, preventing potential misunderstandings about the method's purpose and implementation."
94024,"/** 
 * Returns the more detailed information about why the connection failed. This is passed to   {@link BleDevice.ConnectionFailListener#onEvent(com.idevicesinc.sweetblue.BleDevice.ConnectionFailListener.ConnectionFailEvent)}before the call is made to   {@link ReconnectFilter#onEvent(ReconnectEvent)}. For the first call to   {@link ReconnectFilter#onEvent(ReconnectEvent)}, right after a spontaneous disconnect occurred, the connection didn't fail, so   {@link ConnectionFailListener.ConnectionFailEvent#isNull()} will return <code>true</code>.
 */
public ConnectionFailListener.ConnectionFailEvent connectionFailInfo(){
  return m_connectionFailInfo;
}","/** 
 * Returns the more detailed information about why the connection failed. This is passed to   {@link BleDevice.ConnectionFailListener#onEvent(com.idevicesinc.sweetblue.BleDevice.ConnectionFailListener.ConnectionFailEvent)}before the call is made to   {@link ReconnectRequestFilter#onEvent(ReconnectRequestEvent)}. For the first call to   {@link ReconnectRequestFilter#onEvent(ReconnectRequestEvent)}, right after a spontaneous disconnect occurred, the connection didn't fail, so   {@link ConnectionFailListener.ConnectionFailEvent#isNull()} will return <code>true</code>.
 */
public ConnectionFailListener.ConnectionFailEvent connectionFailInfo(){
  return m_connectionFailInfo;
}","The original code contained incorrect references to `ReconnectFilter` and `ReconnectEvent`, which are likely outdated or incorrect terminology for the library's connection handling mechanism. The fixed code updates these references to `ReconnectRequestFilter` and `ReconnectRequestEvent`, which appear to be the correct, current class and event names used in the library. These changes ensure accurate documentation and prevent potential confusion about the connection reconnection process, maintaining the code's clarity and technical precision."
94025,"void BleDevice(BleManager mngr,BluetoothDevice device_native,String normalizedName,String nativeName,BleDeviceOrigin origin,BleDeviceConfig config_nullable){
  m_mngr=mngr;
  m_origin=origin;
  setConfig(config_nullable);
  m_nativeWrapper=new P_NativeDeviceWrapper(this,device_native,normalizedName,nativeName);
  m_queue=m_mngr.getTaskQueue();
  m_listeners=new P_BleDevice_Listeners(this);
  m_logger=m_mngr.getLogger();
  m_serviceMngr=new P_ServiceManager(this);
  m_stateTracker=new P_DeviceStateTracker(this);
  m_stateTracker.set(E_Intent.IMPLICIT,BleDeviceState.UNDISCOVERED,true,BleDeviceState.DISCONNECTED,true);
  m_pollMngr=new P_PollManager(this);
  m_txnMngr=new P_TransactionManager(this);
  m_taskStateListener=m_listeners.m_taskStateListener;
  m_reconnectMngr=new P_ReconnectManager(this);
  m_connectionFailMngr=new P_ConnectionFailManager(this,m_reconnectMngr);
  m_rssiPollMngr=new P_RssiPollManager(this);
  m_bondMngr=new P_BondManager(this);
  m_dummyDisconnectTask=new P_Task_Disconnect(this,null,false,PE_TaskPriority.FOR_EXPLICIT_BONDING_AND_CONNECTING);
}","void BleDevice(BleManager mngr,BluetoothDevice device_native,String normalizedName,String nativeName,BleDeviceOrigin origin,BleDeviceConfig config_nullable){
  m_mngr=mngr;
  m_origin=origin;
  setConfig(config_nullable);
  m_nativeWrapper=new P_NativeDeviceWrapper(this,device_native,normalizedName,nativeName);
  m_queue=m_mngr.getTaskQueue();
  m_listeners=new P_BleDevice_Listeners(this);
  m_logger=m_mngr.getLogger();
  m_serviceMngr=new P_ServiceManager(this);
  m_stateTracker=new P_DeviceStateTracker(this);
  m_bondMngr=new P_BondManager(this);
  m_stateTracker.set(E_Intent.IMPLICIT,BleDeviceState.UNDISCOVERED,true,BleDeviceState.DISCONNECTED,true);
  m_pollMngr=new P_PollManager(this);
  m_txnMngr=new P_TransactionManager(this);
  m_taskStateListener=m_listeners.m_taskStateListener;
  m_reconnectMngr=new P_ReconnectManager(this);
  m_connectionFailMngr=new P_ConnectionFailManager(this,m_reconnectMngr);
  m_rssiPollMngr=new P_RssiPollManager(this);
  m_dummyDisconnectTask=new P_Task_Disconnect(this,null,false,PE_TaskPriority.FOR_EXPLICIT_BONDING_AND_CONNECTING);
}","The original code had an incorrect initialization order, potentially causing race conditions or uninitialized state when creating a BLE device object. The fixed code reorders the initialization, specifically moving the m_bondMngr creation before the state tracker set method, ensuring proper initialization sequence and dependency management. This modification enhances object creation reliability by establishing critical managers in a more logical and predictable order, reducing potential runtime initialization errors."
94026,"/** 
 * Same as   {@link #RETRY_WITH_AUTOCONNECT_TRUE} but forces <code>autoConnect=false</code>.
 */
@Advanced public static Please retryWithAutoConnectFalse(){
  return new Please(PE_Please.RETRY_WITH_AUTOCONNECT_FALSE);
}","/** 
 * Opposite of  {@link #retryWithAutoConnectTrue()}.
 */
@Advanced public static Please retryWithAutoConnectFalse(){
  return new Please(PE_Please.RETRY_WITH_AUTOCONNECT_FALSE);
}","The original code's JavaDoc comment incorrectly referenced another method with a misleading description that did not accurately reflect the method's purpose. The fixed code updates the comment to clearly explain the method as the opposite of `retryWithAutoConnectTrue()`, providing a more precise and meaningful description. This change helps developers understand the method's intent by explicitly stating its relationship to the related method, improving code readability and maintainability."
94027,"/** 
 * Same as   {@link #RETRY}, but <code>autoConnect=true</code> will be passed to   {@link BluetoothDevice#connectGatt(Context,boolean,android.bluetooth.BluetoothGattCallback)}. See more discussion at   {@link BleDeviceConfig#alwaysUseAutoConnect}.
 */
@Advanced public static Please retryWithAutoConnectTrue(){
  return new Please(PE_Please.RETRY_WITH_AUTOCONNECT_TRUE);
}","/** 
 * Same as   {@link #retry()}, but <code>autoConnect=true</code> will be passed to   {@link BluetoothDevice#connectGatt(Context,boolean,android.bluetooth.BluetoothGattCallback)}. See more discussion at   {@link BleDeviceConfig#alwaysUseAutoConnect}.
 */
@Advanced public static Please retryWithAutoConnectTrue(){
  return new Please(PE_Please.RETRY_WITH_AUTOCONNECT_TRUE);
}","The original code had a syntax error with the method signature ""Please retryWithAutoConnectTrue()"" lacking a return type specification. The fixed code correctly declares the return type as ""static Please"", ensuring the method properly returns a Please object with the RETRY_WITH_AUTOCONNECT_TRUE parameter. This correction resolves the compilation issue and maintains the method's intended functionality of creating a retry configuration with auto-connect enabled."
94028,"/** 
 * Kicks off an OTA transaction if it's not already taking place and the device is   {@link BleDeviceState#INITIALIZED}. This will put the device into the   {@link BleDeviceState#PERFORMING_OTA} state.<br><br> TIP: Use the  {@link TimeEstimator} class to let your users know roughly how much time it will take for the ota to complete.
 * @return	{@link Boolean#TRUE} if firmware update has started, otherwise {@link Boolean#FALSE} if device is either already{@link BleDeviceState#PERFORMING_OTA} or is not {@link BleDeviceState#INITIALIZED}.
 * @see BleManagerConfig#includeOtaReadWriteTimesInAverage
 * @see BleManagerConfig#autoScanDuringOta
 */
public boolean performOta(BleTransaction.Ota txn){
  if (is(PERFORMING_OTA))   return false;
  if (!is(INITIALIZED))   return false;
  m_txnMngr.onOta(txn);
  return true;
}","/** 
 * Kicks off an OTA transaction if it's not already taking place and the device is   {@link BleDeviceState#INITIALIZED}. This will put the device into the   {@link BleDeviceState#PERFORMING_OTA} state.<br><br> TIP: Use the  {@link TimeEstimator} class to let your users know roughly how much time it will take for the ota to complete.
 * @return	{@link Boolean#TRUE} if firmware update has started, otherwise {@link Boolean#FALSE} if device is either already{@link BleDeviceState#PERFORMING_OTA} or is not {@link BleDeviceState#INITIALIZED}.
 * @see BleManagerConfig#includeOtaReadWriteTimesInAverage
 * @see BleManagerConfig#autoScanDuringOta
 */
public boolean performOta(BleTransaction.Ota txn){
  if (is(PERFORMING_OTA))   return false;
  if (!is(INITIALIZED))   return false;
  m_txnMngr.startOta(txn);
  return true;
}","The original code uses an incorrect method call `m_txnMngr.onOta(txn)`, which likely does not properly initiate the OTA (Over-The-Air) transaction. The fixed code replaces this with `m_txnMngr.startOta(txn)`, which more explicitly signals the start of an OTA update and follows a more standard method naming convention. By using a more descriptive and purposeful method name, the fixed code ensures a clearer and more reliable mechanism for beginning the firmware update process."
94029,"/** 
 * Same as   {@link #ASSERT(boolean)} but with an added message.
 */
@Advanced public boolean ASSERT(boolean condition,String message){
  if (!condition) {
    Exception dummyException=null;
    message=message != null ? message : ""String_Node_Str"";
    if (m_config.loggingEnabled || m_assertionListener != null) {
      dummyException=new Exception();
    }
    if (m_config.loggingEnabled) {
      Log.e(BleManager.class.getSimpleName(),""String_Node_Str"" + message,dummyException);
    }
    if (m_assertionListener != null) {
      Info info=new Info(this,message,dummyException.getStackTrace());
      m_assertionListener.onAssertFailed(info);
    }
    return false;
  }
  return true;
}","/** 
 * Same as   {@link #ASSERT(boolean)} but with an added message.
 */
@Advanced public boolean ASSERT(boolean condition,String message){
  if (!condition) {
    Exception dummyException=null;
    message=message != null ? message : ""String_Node_Str"";
    if (m_config.loggingEnabled || m_assertionListener != null) {
      dummyException=new Exception();
    }
    if (m_config.loggingEnabled) {
      Log.e(BleManager.class.getSimpleName(),""String_Node_Str"" + message,dummyException);
    }
    if (m_assertionListener != null) {
      AssertListener.Info info=new AssertListener.Info(this,message,dummyException.getStackTrace());
      m_assertionListener.onAssertFailed(info);
    }
    return false;
  }
  return true;
}","The original code lacks proper qualification for the `Info` class, potentially causing compilation errors or type ambiguity. In the fixed code, `AssertListener.Info` explicitly references the `Info` class within the `AssertListener` context, ensuring correct class resolution and preventing potential naming conflicts. This change improves code clarity, type safety, and helps maintain a more structured and predictable codebase by clearly defining the namespace for the `Info` class."
94030,"/** 
 * Acknowledges the discovery if there's an overlap between the given advertisedServices and the   {@link Collection} passed into {@link BleManagerConfig.DefaultScanFilter#DefaultAdvertisingFilter(Collection)}.
 */
@Override public Please onScanResult(Result result){
  if (Utils.haveMatchingIds(result.advertisedServices(),m_whitelist)) {
    return Please.acknowledge();
  }
 else {
    return Please.ignore();
  }
}","/** 
 * Acknowledges the discovery if there's an overlap between the given advertisedServices and the   {@link Collection} passed into {@link BleManagerConfig.DefaultScanFilter#DefaultScanFilter(Collection)}.
 */
@Override public Please onScanResult(Result result){
  if (Utils.haveMatchingIds(result.advertisedServices(),m_whitelist)) {
    return Please.acknowledge();
  }
 else {
    return Please.ignore();
  }
}","The original code had an incorrect method comment referencing a non-existent `DefaultAdvertisingFilter` instead of the correct `DefaultScanFilter`. The fixed code corrects the Javadoc comment to accurately reflect the actual class and method name, improving documentation clarity. This change ensures that developers reading the code understand the correct context and purpose of the scan filter implementation."
94031,"/** 
 * Returns true for certain Sony and Motorola products, which may have problems managing bonding state and so this method is used to set   {@link #autoUnbond_onStateEnter}.
 */
public static boolean phoneHasBondingIssues(){
  return Utils.isManufacturer(""String_Node_Str"") || Utils.isManufacturer(""String_Node_Str"") && Utils.isProduct(""String_Node_Str"");
}","/** 
 * Returns true for certain Sony and Motorola products, which may have problems managing bonding state and so this method is used in   {@link BleDeviceConfig.DefaultBondFilter}. 
 */
public static boolean phoneHasBondingIssues(){
  return Utils.isManufacturer(""String_Node_Str"") || Utils.isManufacturer(""String_Node_Str"") && Utils.isProduct(""String_Node_Str"");
}","The original code's comment was unclear and potentially misleading about the method's purpose and usage. The fixed code updates the comment to accurately describe the method's role in managing bonding state issues for specific device configurations. By providing a more precise documentation reference, the updated code improves code clarity and helps developers understand the method's intended functionality within the BleDeviceConfig context."
94032,"/** 
 * Convenience method that does a bitwise OR of the given states to   {@link #autoUnbond_stateEnter}.
 */
public void autoUnbondWhenEntering(BleDeviceState... states){
  autoUnbond_stateEnter=autoUnbond_stateEnter != null ? autoUnbond_stateEnter : 0x0;
  for (int i=0; i < states.length; i++) {
    autoUnbond_stateEnter|=states[i].bit();
  }
}","/** 
 * Convenience method that does a bitwise OR of the given states to   {@link #autoUnbond_onStateEnter}.
 */
public void autoUnbondWhenEntering(BleDeviceState... states){
  autoUnbond_onStateEnter=autoUnbond_onStateEnter != null ? autoUnbond_onStateEnter : 0x0;
  for (int i=0; i < states.length; i++) {
    autoUnbond_onStateEnter|=states[i].bit();
  }
}","The original code uses an inconsistent variable name `autoUnbond_stateEnter`, which could lead to confusion and potential bugs in the codebase. The fixed code renames the variable to `autoUnbond_onStateEnter`, providing a more descriptive and clear identifier that follows naming conventions. This change improves code readability and reduces the likelihood of misunderstandings or errors when working with the variable."
94033,"/** 
 * Convenience method that does a bitwise OR of the given states to   {@link #autoUnbond_stateExit}.
 */
public void autoUnbondWhenExiting(BleDeviceState... states){
  autoUnbond_stateExit=autoUnbond_stateExit != null ? autoUnbond_stateExit : 0x0;
  for (int i=0; i < states.length; i++) {
    autoUnbond_stateExit|=states[i].bit();
  }
}","/** 
 * Convenience method that does a bitwise OR of the given states to   {@link #autoUnbond_onStateExit}.
 */
public void autoUnbondWhenExiting(BleDeviceState... states){
  autoUnbond_onStateExit=autoUnbond_onStateExit != null ? autoUnbond_onStateExit : 0x0;
  for (int i=0; i < states.length; i++) {
    autoUnbond_onStateExit|=states[i].bit();
  }
}","The original code used an ambiguously named variable `autoUnbond_stateExit`, which likely led to confusion and potential misuse. The fixed code renames the variable to `autoUnbond_onStateExit`, providing clearer semantic meaning about when the auto-unbonding occurs. This improvement enhances code readability and reduces the likelihood of misinterpretation by developers maintaining or using the method."
94034,"static boolean autoUnbond(final int oldStateBits,final int newStateBits,final BleDeviceConfig conf_device,final BleManagerConfig conf_mngr){
  final int autoUnbond_stateEnter=integerOrZero(integer(conf_device.autoUnbond_stateEnter,conf_mngr.autoUnbond_stateEnter));
  final int autoUnbond_stateExit=integerOrZero(integer(conf_device.autoUnbond_stateExit,conf_mngr.autoUnbond_stateExit));
  return autoBondOrUnbond(oldStateBits,newStateBits,autoUnbond_stateEnter,autoUnbond_stateExit);
}","static boolean autoUnbond(final int oldStateBits,final int newStateBits,final BleDeviceConfig conf_device,final BleManagerConfig conf_mngr){
  final int autoUnbond_stateEnter=integerOrZero(integer(conf_device.autoUnbond_onStateEnter,conf_mngr.autoUnbond_onStateEnter));
  final int autoUnbond_stateExit=integerOrZero(integer(conf_device.autoUnbond_onStateExit,conf_mngr.autoUnbond_onStateExit));
  return autoBondOrUnbond(oldStateBits,newStateBits,autoUnbond_stateEnter,autoUnbond_stateExit);
}","The original code used incorrect field names `autoUnbond_stateEnter` and `autoUnbond_stateExit`, which likely did not match the actual configuration properties. The fixed code corrects these to `autoUnbond_onStateEnter` and `autoUnbond_onStateExit`, ensuring the correct configuration fields are accessed. These changes guarantee that the auto-unbonding logic retrieves the intended configuration values, preventing potential configuration mismatches or silent failures."
94035,"static boolean autoBond(final int oldStateBits,final int newStateBits,final BleDeviceConfig conf_device,final BleManagerConfig conf_mngr){
  final int autoBond_stateEnter=integerOrZero(integer(conf_device.autoBond_stateEnter,conf_mngr.autoBond_stateEnter));
  final int autoBond_stateExit=integerOrZero(integer(conf_device.autoBond_stateExit,conf_mngr.autoBond_stateExit));
  return autoBondOrUnbond(oldStateBits,newStateBits,autoBond_stateEnter,autoBond_stateExit);
}","static boolean autoBond(final int oldStateBits,final int newStateBits,final BleDeviceConfig conf_device,final BleManagerConfig conf_mngr){
  final int autoBond_stateEnter=integerOrZero(integer(conf_device.autoBond_onStateEnter,conf_mngr.autoBond_onStateEnter));
  final int autoBond_stateExit=integerOrZero(integer(conf_device.autoBond_onStateExit,conf_mngr.autoBond_onStateExit));
  return autoBondOrUnbond(oldStateBits,newStateBits,autoBond_stateEnter,autoBond_stateExit);
}","The original code used incorrect field names `autoBond_stateEnter` and `autoBond_stateExit`, which likely did not match the actual configuration properties. The fixed code corrects these to `autoBond_onStateEnter` and `autoBond_onStateExit`, ensuring proper access to the intended configuration settings. These changes resolve potential configuration retrieval errors and improve the method's accuracy in determining auto-bonding behavior based on device and manager configurations."
94036,"/** 
 * Returns true for certain Sony and Motorola products, which may have problems managing bonding state and so this method is used to set   {@link #autoUnbond_stateEnter}.
 */
public boolean phoneHasBondingIssues(){
  return Utils.isManufacturer(""String_Node_Str"") || Utils.isManufacturer(""String_Node_Str"") && Utils.isProduct(""String_Node_Str"");
}","/** 
 * Returns true for certain Sony and Motorola products, which may have problems managing bonding state and so this method is used to set   {@link #autoUnbond_onStateEnter}.
 */
public boolean phoneHasBondingIssues(){
  return Utils.isManufacturer(""String_Node_Str"") || Utils.isManufacturer(""String_Node_Str"") && Utils.isProduct(""String_Node_Str"");
}","The buggy code appears to be identical to the fixed code, with only a minor Javadoc comment change from ""autoUnbond_stateEnter"" to ""autoUnbond_onStateEnter"". The implementation of the method remains the same, suggesting there might be no actual functional change or bug fix in the provided code snippet. Without additional context or specific details about the intended improvement, it's difficult to definitively explain the rationale behind the supposed code correction."
94037,"/** 
 * Convenience method that does a bitwise OR of the given states to   {@link #autoBond_stateExit}.
 */
public void autoBondWhenExiting(BleDeviceState... states){
  autoBond_stateExit=autoBond_stateExit != null ? autoBond_stateExit : 0x0;
  for (int i=0; i < states.length; i++) {
    autoBond_stateExit|=states[i].bit();
  }
}","/** 
 * Convenience method that does a bitwise OR of the given states to   {@link #autoBond_onStateExit}.
 */
public void autoBondWhenExiting(BleDeviceState... states){
  autoBond_onStateExit=autoBond_onStateExit != null ? autoBond_onStateExit : 0x0;
  for (int i=0; i < states.length; i++) {
    autoBond_onStateExit|=states[i].bit();
  }
}","The original code used an inconsistent variable name `autoBond_stateExit`, which could lead to confusion and potential naming conflicts in the codebase. The fixed code renames the variable to `autoBond_onStateExit`, providing a more descriptive and semantically clear identifier that indicates the variable's purpose of tracking bonding states during state exits. This naming improvement enhances code readability and reduces the likelihood of misunderstandings when other developers interact with this method."
94038,"/** 
 * Convenience method that does a bitwise OR of the given states to   {@link #autoBond_stateEnter}.
 */
public void autoBondWhenEntering(BleDeviceState... states){
  autoBond_stateEnter=autoBond_stateEnter != null ? autoBond_stateEnter : 0x0;
  for (int i=0; i < states.length; i++) {
    autoBond_stateEnter|=states[i].bit();
  }
}","/** 
 * Convenience method that does a bitwise OR of the given states to   {@link #autoBond_onStateEnter}.
 */
public void autoBondWhenEntering(BleDeviceState... states){
  autoBond_onStateEnter=autoBond_onStateEnter != null ? autoBond_onStateEnter : 0x0;
  for (int i=0; i < states.length; i++) {
    autoBond_onStateEnter|=states[i].bit();
  }
}","The original code uses an incorrectly named variable `autoBond_stateEnter`, which likely causes confusion and potential bugs in the code's logic. The fixed code renames the variable to `autoBond_onStateEnter`, making the naming more descriptive and aligned with the method's purpose of setting bonding behavior when entering specific states. This naming improvement enhances code readability and reduces the likelihood of misunderstandings or misuse of the method."
94039,"public PA_Task(BleManager manager,I_StateListener listener,double timeout){
  m_device=null;
  m_manager=manager;
  m_maxRetries=0;
  m_timeout=timeout;
  m_logger=m_manager.getLogger();
  m_timeCreated=System.currentTimeMillis();
  if (listener == null && this instanceof I_StateListener) {
    m_stateListener=(I_StateListener)this;
  }
 else {
    m_stateListener=listener;
  }
}","public PA_Task(BleManager manager,I_StateListener listener,double timeout){
  m_device=null;
  m_manager=manager;
  m_timeout=timeout;
  m_logger=m_manager.getLogger();
  m_timeCreated=System.currentTimeMillis();
  if (listener == null && this instanceof I_StateListener) {
    m_stateListener=(I_StateListener)this;
  }
 else {
    m_stateListener=listener;
  }
}","The original code incorrectly initialized m_maxRetries to 0, which was an unnecessary variable assignment not used elsewhere in the method. The fixed code removes the m_maxRetries initialization, simplifying the constructor and eliminating the unused variable. This streamlines the code, reducing potential confusion and maintaining cleaner, more focused initialization logic for the PA_Task class."
94040,"void resetTimeout(double newTimeout){
synchronized (this) {
    m_timeout=newTimeout;
    m_resettableTimeExecuting=0.0;
  }
}","void resetTimeout(double newTimeout){
synchronized (this) {
    m_timeout=newTimeout;
    m_resetableExecuteStartTime=System.currentTimeMillis();
  }
}","The original code incorrectly resets an execution timer to zero, which fails to capture the actual start time of the operation. The fixed code replaces the zero reset with `System.currentTimeMillis()`, which records the precise moment when the timeout is reset, providing an accurate reference point for tracking elapsed time. This modification ensures proper timeout tracking by capturing the current system timestamp, enabling more reliable time-based synchronization and execution monitoring."
94041,"void onAddedToQueue(P_TaskQueue queue){
  m_queue=queue;
  setState(PE_TaskState.QUEUED);
  m_retryCount=0;
  m_updateCount=0;
  m_addedToQueueTime=m_addedToQueueTime == -1.0 ? m_queue.getTime() : m_addedToQueueTime;
}","void onAddedToQueue(P_TaskQueue queue){
  m_queue=queue;
  setState(PE_TaskState.QUEUED);
  m_updateCount=0;
  m_addedToQueueTime=m_addedToQueueTime == -1.0 ? m_queue.getTime() : m_addedToQueueTime;
}","The original code unnecessarily resets `m_retryCount` to zero, potentially losing important retry information for task management. In the fixed code, the `m_retryCount` line is removed, preserving the existing retry state before adding the task to the queue. This change ensures that task retry tracking remains consistent and prevents unintentional reset of retry attempts, maintaining the task's historical context and resilience."
94042,"void arm(Handler executeHandler){
  setState(PE_TaskState.ARMED);
  m_executeHandler=executeHandler;
  m_totalTimeArmedAndExecuting=0.0;
  m_resettableTimeExecuting=0.0;
  m_retryCount=0;
  m_updateCount=0;
}","void arm(Handler executeHandler){
  setState(PE_TaskState.ARMED);
  m_executeHandler=executeHandler;
  m_totalTimeArmedAndExecuting=0.0;
  m_resetableExecuteStartTime=System.currentTimeMillis();
  m_updateCount=0;
}","The buggy code incorrectly reset multiple time-tracking variables without establishing a clear baseline for measuring execution time. The fixed code introduces `m_resetableExecuteStartTime` to capture the precise moment of task arming, replacing redundant time-tracking variables with a single, clear timestamp initialization. By simplifying time measurement and removing unnecessary variable resets, the fixed code provides a more streamlined and accurate method for tracking task execution duration."
94043,"private void execute_wrapper(){
  m_timeExecuted=System.currentTimeMillis();
  execute();
}","private void execute_wrapper(){
  m_resetableExecuteStartTime=System.currentTimeMillis();
  m_timeExecuted=System.currentTimeMillis();
  execute();
}","The original code only tracked the execution time without storing the initial start time, which could lead to inaccurate timing measurements. The fixed code introduces m_resetableExecuteStartTime to capture the precise initial timestamp before execution, ensuring a more accurate tracking of elapsed time. By adding this additional timestamp, the code now provides a reliable mechanism for measuring and potentially resetting the execution start time, enhancing timing precision and flexibility."
94044,"protected void softlyCancel(){
  m_maxRetries=0;
  m_queue.tryEndingTask(this,PE_TaskState.SOFTLY_CANCELLED);
}","protected void softlyCancel(){
  m_queue.tryEndingTask(this,PE_TaskState.SOFTLY_CANCELLED);
}","The original code unnecessarily sets `m_maxRetries` to 0 before attempting to end the task, which could interfere with task management logic. The fixed code removes this redundant line, directly calling `tryEndingTask()` with the current task and `SOFTLY_CANCELLED` state. By eliminating the superfluous assignment, the code now more cleanly and directly handles task cancellation, preserving the intended state transition without introducing potential side effects."
94045,"void update_internal(double timeStep){
synchronized (this) {
    m_totalTimeArmedAndExecuting+=timeStep;
    m_updateCount++;
    if (m_totalTimeArmedAndExecuting >= m_executionDelay) {
      if (m_state == PE_TaskState.ARMED) {
        if (m_updateCount > 1) {
          if (m_softlyCancelled) {
            softlyCancel();
            return;
          }
          if (isExecutable()) {
            setState(PE_TaskState.EXECUTING);
            if (executeOnSeperateThread()) {
              m_executeHandler.post(m_executeRunnable);
            }
 else {
              execute_wrapper();
            }
            return;
          }
 else {
            failWithoutRetry();
            return;
          }
        }
      }
 else       if (m_state == PE_TaskState.EXECUTING) {
        m_resettableTimeExecuting+=timeStep;
        if (!Interval.isDisabled(m_timeout) && m_timeout != Interval.INFINITE.secs()) {
          if (m_resettableTimeExecuting >= m_timeout) {
            timeout();
            return;
          }
        }
      }
    }
    this.update(timeStep);
  }
}","void update_internal(double timeStep){
synchronized (this) {
    m_totalTimeArmedAndExecuting+=timeStep;
    m_updateCount++;
    if (m_totalTimeArmedAndExecuting >= m_executionDelay) {
      if (m_state == PE_TaskState.ARMED) {
        if (m_updateCount > 1) {
          if (m_softlyCancelled) {
            softlyCancel();
            return;
          }
          if (isExecutable()) {
            setState(PE_TaskState.EXECUTING);
            if (executeOnSeperateThread()) {
              m_executeHandler.post(m_executeRunnable);
            }
 else {
              execute_wrapper();
            }
            return;
          }
 else {
            failWithoutRetry();
            return;
          }
        }
      }
 else       if (m_state == PE_TaskState.EXECUTING) {
        if (!Interval.isDisabled(m_timeout) && m_timeout != Interval.INFINITE.secs()) {
          double timeExecuting=(System.currentTimeMillis() - m_resetableExecuteStartTime) / 1000.0;
          if (timeExecuting >= m_timeout) {
            timeout();
            return;
          }
        }
      }
    }
    this.update(timeStep);
  }
}","The original code incorrectly tracked execution time using a local variable `m_resettableTimeExecuting`, which accumulates time incrementally and can lead to inaccurate timeout calculations. The fixed code replaces this with a time-based calculation using `System.currentTimeMillis()` and the start time of execution, providing a more precise and reliable method of measuring elapsed time. This approach ensures accurate timeout detection by directly measuring real-time duration instead of relying on potentially imprecise accumulated time increments."
94046,"protected void failWithoutRetry(){
  m_maxRetries=0;
  fail();
}","protected void failWithoutRetry(){
  fail();
}","The original code unnecessarily sets `m_maxRetries` to zero before calling `fail()`, which is redundant and potentially confusing. The fixed code directly calls `fail()` without modifying the retry counter, simplifying the method and removing an unnecessary assignment. By eliminating the superfluous line, the code becomes cleaner, more straightforward, and maintains the intended behavior of immediately failing without retries."
94047,"private void onStateChange_synchronized(PA_Task task,PE_TaskState state){
  if (task.getClass() == P_Task_Connect.class) {
    P_Task_Connect connectTask=(P_Task_Connect)task;
    if (state.isEndingState()) {
      BluetoothGatt gatt=connectTask.getGatt();
      if (gatt != null) {
        m_device.m_nativeWrapper.updateGattInstance(gatt);
      }
      if (state == PE_TaskState.SUCCEEDED || state == PE_TaskState.REDUNDANT) {
        if (state == PE_TaskState.SUCCEEDED) {
          m_device.setToAlwaysUseAutoConnectIfItWorked();
        }
        m_device.onNativeConnect(connectTask.isExplicit());
      }
 else {
        m_device.onNativeConnectFail(state,connectTask.getGattStatus(),connectTask.getAutoConnectUsage());
      }
    }
  }
 else   if (task.getClass() == P_Task_Disconnect.class) {
    if (state == PE_TaskState.SUCCEEDED || state == PE_TaskState.REDUNDANT || state == PE_TaskState.NO_OP) {
      P_Task_Disconnect task_cast=(P_Task_Disconnect)task;
      m_device.onNativeDisconnect(task_cast.isExplicit());
    }
  }
 else   if (task.getClass() == P_Task_DiscoverServices.class) {
    P_Task_DiscoverServices discoverTask=(P_Task_DiscoverServices)task;
    if (state == PE_TaskState.EXECUTING) {
    }
 else     if (state == PE_TaskState.SUCCEEDED) {
      m_device.onServicesDiscovered();
    }
 else     if (state.isEndingState()) {
      if (state == PE_TaskState.SOFTLY_CANCELLED) {
      }
      if (state == PE_TaskState.FAILED_IMMEDIATELY) {
        m_device.disconnectWithReason(Reason.GETTING_SERVICES_FAILED_IMMEDIATELY,discoverTask.getGattStatus());
      }
 else       if (state == PE_TaskState.TIMED_OUT) {
        m_device.disconnectWithReason(Reason.GETTING_SERVICES_TIMED_OUT,discoverTask.getGattStatus());
      }
 else {
        m_device.disconnectWithReason(Reason.GETTING_SERVICES_FAILED_EVENTUALLY,discoverTask.getGattStatus());
      }
    }
  }
 else   if (task.getClass() == P_Task_Bond.class) {
    m_device.onBondTaskStateChange(task,state);
  }
}","private void onStateChange_synchronized(PA_Task task,PE_TaskState state){
  if (task.getClass() == P_Task_Connect.class) {
    P_Task_Connect connectTask=(P_Task_Connect)task;
    if (state.isEndingState()) {
      BluetoothGatt gatt=connectTask.getGatt();
      if (gatt != null) {
        m_device.m_nativeWrapper.updateGattInstance(gatt);
      }
      if (state == PE_TaskState.SUCCEEDED || state == PE_TaskState.REDUNDANT) {
        if (state == PE_TaskState.SUCCEEDED) {
          m_device.setToAlwaysUseAutoConnectIfItWorked();
        }
        m_device.onNativeConnect(connectTask.isExplicit());
      }
 else {
        m_device.onNativeConnectFail(state,connectTask.getGattStatus(),connectTask.getAutoConnectUsage());
      }
    }
  }
 else   if (task.getClass() == P_Task_Disconnect.class) {
    if (state == PE_TaskState.SUCCEEDED || state == PE_TaskState.REDUNDANT || state == PE_TaskState.NO_OP) {
      P_Task_Disconnect task_cast=(P_Task_Disconnect)task;
      m_device.onNativeDisconnect(task_cast.isExplicit());
    }
  }
 else   if (task.getClass() == P_Task_DiscoverServices.class) {
    P_Task_DiscoverServices discoverTask=(P_Task_DiscoverServices)task;
    if (state == PE_TaskState.EXECUTING) {
    }
 else     if (state == PE_TaskState.SUCCEEDED) {
      m_device.onServicesDiscovered();
    }
 else     if (state.isEndingState()) {
      if (state == PE_TaskState.SOFTLY_CANCELLED) {
      }
 else       if (state == PE_TaskState.FAILED_IMMEDIATELY) {
        m_device.disconnectWithReason(Reason.GETTING_SERVICES_FAILED_IMMEDIATELY,discoverTask.getGattStatus());
      }
 else       if (state == PE_TaskState.TIMED_OUT) {
        m_device.disconnectWithReason(Reason.GETTING_SERVICES_TIMED_OUT,discoverTask.getGattStatus());
      }
 else {
        m_device.disconnectWithReason(Reason.GETTING_SERVICES_FAILED_EVENTUALLY,discoverTask.getGattStatus());
      }
    }
  }
 else   if (task.getClass() == P_Task_Bond.class) {
    m_device.onBondTaskStateChange(task,state);
  }
}","The original code had a nested `if` statement within the `state.isEndingState()` block for service discovery that included an unnecessary and potentially confusing nested `if` statement for `SOFTLY_CANCELLED`. The fixed code removes the redundant nested `if (state == PE_TaskState.SOFTLY_CANCELLED)` block, simplifying the logic and removing an empty conditional branch. This streamlines the error handling for service discovery tasks, making the code more readable and reducing potential confusion in state management logic."
94048,"/** 
 * Creates a new   {@link BleDevice} or returns an existing one if the macAddress matches.{@link DiscoveryListener#onDeviceDiscovered(BleDevice)} will be called if a new deviceis created.
 */
public BleDevice newDevice(String macAddress,String name){
  final BleDevice existingDevice=this.getDevice(macAddress);
  if (existingDevice != null)   return existingDevice;
  final BluetoothDevice device_native=getNative().getAdapter().getRemoteDevice(macAddress);
  if (device_native == null)   return null;
  final String name_normalized=Utils.normalizeDeviceName(name);
  final BleDevice newDevice=newDevice_private(device_native,name_normalized,name,BleDevice.Origin.EXPLICIT);
  onDiscovered_wrapItUp(newDevice,true,null,null,0);
  return newDevice;
}","/** 
 * Creates a new   {@link BleDevice} or returns an existing one if the macAddress matches.{@link DiscoveryListener#onDiscoveryEvent(DiscoveryEvent)} will be called if a new deviceis created.
 */
public BleDevice newDevice(String macAddress,String name){
  final BleDevice existingDevice=this.getDevice(macAddress);
  if (existingDevice != null)   return existingDevice;
  final BluetoothDevice device_native=getNative().getAdapter().getRemoteDevice(macAddress);
  if (device_native == null)   return null;
  final String name_normalized=Utils.normalizeDeviceName(name);
  final BleDevice newDevice=newDevice_private(device_native,name_normalized,name,BleDevice.Origin.EXPLICIT);
  onDiscovered_wrapItUp(newDevice,true,null,null,0);
  return newDevice;
}","The original code incorrectly referenced `onDeviceDiscovered()` in the comment, which does not match the actual method call `onDiscovered_wrapItUp()`. The fixed code updates the comment to accurately reflect the `onDiscoveryEvent()` method, ensuring documentation consistency with the implementation. This change improves code readability and prevents potential confusion for developers by providing a more precise description of the device discovery process."
94049,"/** 
 * Forcefully undiscovers a device, disconnecting it first if needed and removing it from this manager's internal list.  {@link BleManager.DiscoveryListener_Full#onDeviceUndiscovered(BleDevice)} will be called.No clear use case has been thought of but the method is here just in case anyway.
 * @return	true if the device was undiscovered, false if device is already {@link BleDeviceState#UNDISCOVERED} or managerdoesn't contain an instance, checked referentially, not through  {@link BleDevice#equals(BleDevice)} (i.e. by mac address).
 */
public boolean undiscover(BleDevice device){
  if (device == null)   return false;
  if (!hasDevice(device))   return false;
  if (device.is(BleDeviceState.UNDISCOVERED))   return false;
  if (device.is(BleDeviceState.CONNECTED)) {
    device.disconnect();
  }
  m_deviceMngr.undiscoverAndRemove(device,m_discoveryListener,E_Intent.EXPLICIT);
  return true;
}","/** 
 * Forcefully undiscovers a device, disconnecting it first if needed and removing it from this manager's internal list.  {@link BleManager.DiscoveryListener#onDiscoveryEvent(DiscoveryEvent)} with {@link LifeCycle#UNDISCOVERED} will be called.No clear use case has been thought of but the method is here just in case anyway.
 * @return	true if the device was undiscovered, false if device is already {@link BleDeviceState#UNDISCOVERED} or managerdoesn't contain an instance, checked referentially, not through  {@link BleDevice#equals(BleDevice)} (i.e. by mac address).
 */
public boolean undiscover(BleDevice device){
  if (device == null)   return false;
  if (!hasDevice(device))   return false;
  if (device.is(BleDeviceState.UNDISCOVERED))   return false;
  if (device.is(BleDeviceState.CONNECTED)) {
    device.disconnect();
  }
  m_deviceMngr.undiscoverAndRemove(device,m_discoveryListener,E_Intent.EXPLICIT);
  return true;
}","The buggy code's Javadoc comment references an incorrect listener method, creating potential misunderstanding about the discovery event handling. The fixed code updates the Javadoc to reference the correct listener method `onDiscoveryEvent(DiscoveryEvent)` with `LifeCycle#UNDISCOVERED`, aligning documentation with the actual implementation. This correction ensures clear and accurate documentation, improving code readability and preventing potential misinterpretation of the method's behavior."
94050,"/** 
 * Get a UUID string by transforming shorthand ids into long form ids.
 * @param shorthandIf Short of long form UUID string for a service/characteristic
 * @return UUID string.
 */
public static String uuidStringFromShorthand(String shorthandUuid){
  if (shorthandUuid.length() <= SHORTHAND_LENGTH) {
    long l=Long.parseLong(shorthandUuid,16);
    shorthandUuid=String.format(""String_Node_Str"" + SHORTHAND_LENGTH + ""String_Node_Str"",l);
    String result=shorthandUuid + SHORTHAND_UUID_TEMPLATE.substring(SHORTHAND_LENGTH);
    return result;
  }
 else {
    return shorthandUuid;
  }
}","/** 
 * Get a UUID string by transforming shorthand ids into long form ids.
 * @param shorthandUuid Short of long form UUID string for a service/characteristic
 * @return UUID string.
 */
public static String uuidStringFromShorthand(String shorthandUuid){
  if (shorthandUuid.length() <= SHORTHAND_LENGTH) {
    long l=Long.parseLong(shorthandUuid,16);
    shorthandUuid=String.format(""String_Node_Str"" + SHORTHAND_LENGTH + ""String_Node_Str"",l);
    String result=shorthandUuid + SHORTHAND_UUID_TEMPLATE.substring(SHORTHAND_LENGTH);
    return result;
  }
 else {
    return shorthandUuid;
  }
}","The original code contains a placeholder `String_Node_Str` which would likely cause runtime errors and doesn't properly format the UUID. The fixed code would replace this placeholder with the correct formatting method, using `String.format()` with the hexadecimal long value and the standard UUID template. This ensures correct UUID conversion by maintaining the expected string length and utilizing proper hexadecimal parsing and string construction mechanisms."
94051,"public void onCharacteristicWrite(BluetoothGatt gatt,UUID uuid,int status){
  getManager().ASSERT(gatt == getDevice().getNativeGatt());
  if (!this.isFor(uuid))   return;
  if (!acknowledgeCallback(status))   return;
  if (Utils.isSuccess(status)) {
    if (weBeChunkin()) {
      if (m_offset >= m_data.length) {
        if (!getDevice().getNativeGatt().executeReliableWrite()) {
          fail(Status.REMOTE_GATT_FAILURE,Target.CHARACTERISTIC,uuid,Result.NON_APPLICABLE_UUID);
          return;
        }
      }
 else {
        writeNextChunk();
        resetTimeout(TIMEOUT_DEFAULT);
      }
    }
 else {
      succeed();
    }
  }
 else {
    fail(Status.REMOTE_GATT_FAILURE,Target.CHARACTERISTIC,uuid,Result.NON_APPLICABLE_UUID);
  }
}","public void onCharacteristicWrite(BluetoothGatt gatt,UUID uuid,int status){
  getManager().ASSERT(gatt == getDevice().getNativeGatt());
  if (!this.isFor(uuid))   return;
  if (!acknowledgeCallback(status))   return;
  if (Utils.isSuccess(status)) {
    if (weBeChunkin()) {
      if (m_offset >= m_data.length) {
        if (!gatt.executeReliableWrite()) {
          fail(Status.REMOTE_GATT_FAILURE,Target.CHARACTERISTIC,uuid,Result.NON_APPLICABLE_UUID);
          return;
        }
      }
 else {
        writeNextChunk();
        resetTimeout(TIMEOUT_DEFAULT);
      }
    }
 else {
      succeed();
    }
  }
 else {
    if (weBeChunkin()) {
      gatt.abortReliableWrite();
    }
    fail(Status.REMOTE_GATT_FAILURE,Target.CHARACTERISTIC,uuid,Result.NON_APPLICABLE_UUID);
  }
}","The original code lacked proper error handling when a characteristic write operation fails during chunked transmission, potentially leaving the reliable write transaction in an inconsistent state. The fixed code adds an explicit `gatt.abortReliableWrite()` when the write status is unsuccessful and uses `gatt` directly instead of `getDevice().getNativeGatt()` for more robust error management. These changes ensure cleaner error recovery, prevent potential GATT transaction hanging, and provide more predictable Bluetooth Low Energy communication behavior."
94052,"public void onReliableWriteCompleted(BluetoothGatt gatt,int status){
  if (Utils.isSuccess(status)) {
    succeed();
  }
 else {
    fail(Status.REMOTE_GATT_FAILURE,Target.CHARACTERISTIC,m_char_native.getUuid(),Result.NON_APPLICABLE_UUID);
  }
}","public void onReliableWriteCompleted(BluetoothGatt gatt,int status){
  if (Utils.isSuccess(status)) {
    succeed();
  }
 else {
    abortReliableWriteIfNeeded();
    fail(Status.REMOTE_GATT_FAILURE,Target.CHARACTERISTIC,m_char_native.getUuid(),Result.NON_APPLICABLE_UUID);
  }
}","The original code lacks proper error handling during a reliable write operation, potentially leaving the Bluetooth connection in an inconsistent state if a write fails. The fixed code adds `abortReliableWriteIfNeeded()` before calling `fail()`, which ensures that any pending reliable write is properly terminated in case of a failure. This change prevents potential Bluetooth communication issues and provides a more robust error recovery mechanism for GATT characteristic write operations."
94053,"@Override public void onStateChange(PA_Task task,PE_TaskState state){
  if (state == PE_TaskState.TIMED_OUT) {
    m_logger.w(m_logger.charName(m_characteristic.getUuid()) + ""String_Node_Str"");
    if (m_readWriteListener != null) {
      m_readWriteListener.onReadOrWriteComplete(newResult(Status.TIMED_OUT,Target.CHARACTERISTIC,m_characteristic.getUuid(),Result.NON_APPLICABLE_UUID));
    }
    getManager().uhOh(UhOh.WRITE_TIMED_OUT);
  }
 else   if (state == PE_TaskState.SOFTLY_CANCELLED) {
    if (m_readWriteListener != null) {
      m_readWriteListener.onReadOrWriteComplete(newResult(Status.CANCELLED,Target.CHARACTERISTIC,m_characteristic.getUuid(),Result.NON_APPLICABLE_UUID));
    }
  }
}","@Override public void onStateChange(PA_Task task,PE_TaskState state){
  if (state == PE_TaskState.TIMED_OUT) {
    m_logger.w(m_logger.charName(m_characteristic.getUuid()) + ""String_Node_Str"");
    abortReliableWriteIfNeeded();
    if (m_readWriteListener != null) {
      m_readWriteListener.onReadOrWriteComplete(newResult(Status.TIMED_OUT,Target.CHARACTERISTIC,m_characteristic.getUuid(),Result.NON_APPLICABLE_UUID));
    }
    getManager().uhOh(UhOh.WRITE_TIMED_OUT);
  }
 else   if (state == PE_TaskState.SOFTLY_CANCELLED) {
    abortReliableWriteIfNeeded();
    if (m_readWriteListener != null) {
      m_readWriteListener.onReadOrWriteComplete(newResult(Status.CANCELLED,Target.CHARACTERISTIC,m_characteristic.getUuid(),Result.NON_APPLICABLE_UUID));
    }
  }
}","The original code lacks proper handling of reliable write transactions during timeout and cancellation scenarios. The fixed code adds `abortReliableWriteIfNeeded()` method calls in both TIMED_OUT and SOFTLY_CANCELLED states to ensure clean termination of ongoing write operations. This change prevents potential resource leaks and ensures proper state management, improving the robustness of Bluetooth Low Energy characteristic write operations."
94054,"public static boolean isSuccess(int gattStatus){
  return gattStatus == 0 || gattStatus == 1;
}","public static boolean isSuccess(int gattStatus){
  return gattStatus == 0;
}","The original code incorrectly considered both 0 and 1 as successful GATT status codes, which may lead to misinterpreting error conditions. The fixed code restricts success to only status code 0, which is the standard indicator of a successful operation in GATT communication. By narrowing the success criteria, the revised implementation ensures more precise error handling and prevents potential misinterpretation of underlying Bluetooth communication states."
94055,"private void onNativeBondStateChanged_private(int previousState,int newState){
  if (newState == BluetoothDevice.ERROR) {
    P_TaskQueue queue=m_device.getTaskQueue();
    queue.fail(P_Task_Bond.class,m_device);
    queue.fail(P_Task_Unbond.class,m_device);
  }
 else   if (newState == BluetoothDevice.BOND_NONE) {
    m_queue.fail(P_Task_Bond.class,m_device);
    if (!m_queue.succeed(P_Task_Unbond.class,m_device)) {
      m_device.onNativeUnbond();
    }
  }
 else   if (newState == BluetoothDevice.BOND_BONDING) {
    m_device.onNativeBonding();
    if (!m_queue.isCurrent(P_Task_Bond.class,m_device)) {
      m_queue.add(new P_Task_Bond(m_device,false,false,m_taskStateListener,PE_TaskPriority.FOR_IMPLICIT_BONDING_CONNECTING));
    }
    m_queue.fail(P_Task_Unbond.class,m_device);
  }
 else   if (newState == BluetoothDevice.BOND_BONDED) {
    m_queue.fail(P_Task_Unbond.class,m_device);
    if (!m_queue.succeed(P_Task_Bond.class,m_device)) {
      m_device.onNativeBond();
    }
  }
}","private void onNativeBondStateChanged_private(int previousState,int newState){
  if (newState == BluetoothDevice.ERROR) {
    P_TaskQueue queue=m_device.getTaskQueue();
    queue.fail(P_Task_Bond.class,m_device);
    queue.fail(P_Task_Unbond.class,m_device);
  }
 else   if (newState == BluetoothDevice.BOND_NONE) {
    m_queue.fail(P_Task_Bond.class,m_device);
    if (!m_queue.succeed(P_Task_Unbond.class,m_device)) {
      m_device.onNativeUnbond();
    }
  }
 else   if (newState == BluetoothDevice.BOND_BONDING) {
    m_device.onNativeBonding();
    if (!m_queue.isCurrent(P_Task_Bond.class,m_device)) {
      m_queue.add(new P_Task_Bond(m_device,false,false,m_taskStateListener,PE_TaskPriority.FOR_IMPLICIT_BONDING_AND_CONNECTING));
    }
    m_queue.fail(P_Task_Unbond.class,m_device);
  }
 else   if (newState == BluetoothDevice.BOND_BONDED) {
    m_queue.fail(P_Task_Unbond.class,m_device);
    if (!m_queue.succeed(P_Task_Bond.class,m_device)) {
      m_device.onNativeBond();
    }
  }
}","The original code used an incorrect task priority constant `PE_TaskPriority.FOR_IMPLICIT_BONDING_CONNECTING`, which likely caused unexpected task scheduling behavior. In the fixed code, the constant was corrected to `PE_TaskPriority.FOR_IMPLICIT_BONDING_AND_CONNECTING`, ensuring proper task prioritization during Bluetooth device bonding. This modification improves the reliability of task queue management and prevents potential synchronization issues during the bonding process."
94056,"private void onConnectionStateChange_synchronized(BluetoothGatt gatt,int status,int newState){
  if (newState == BluetoothProfile.STATE_DISCONNECTED) {
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
    if (!m_queue.fail(P_Task_Connect.class,m_device)) {
      if (!m_queue.succeed(P_Task_Disconnect.class,m_device)) {
        m_device.onNativeDisconnect(false);
      }
    }
  }
 else   if (newState == BluetoothProfile.STATE_CONNECTING) {
    if (Utils.isSuccess(status)) {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
      m_device.onConnecting(false,false);
      if (!m_queue.isCurrent(P_Task_Connect.class,m_device)) {
        P_Task_Connect task=new P_Task_Connect(m_device,m_taskStateListener,false,PE_TaskPriority.FOR_IMPLICIT_BONDING_CONNECTING);
        m_queue.add(task);
      }
      m_queue.fail(P_Task_Disconnect.class,m_device);
    }
 else {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt);
      m_queue.fail(P_Task_Connect.class,m_device);
    }
  }
 else   if (newState == BluetoothProfile.STATE_CONNECTED) {
    if (Utils.isSuccess(status)) {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
      m_queue.fail(P_Task_Disconnect.class,m_device);
      if (!m_queue.succeed(P_Task_Connect.class,m_device)) {
        m_device.onNativeConnect();
      }
    }
 else {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt);
      if (!m_queue.fail(P_Task_Connect.class,m_device)) {
        m_device.onConnectFail((PE_TaskState)null);
      }
      if (status == PS_GattStatus.UNKNOWN_STATUS_FOR_IMMEDIATE_CONNECTION_FAILURE) {
      }
    }
  }
 else   if (newState == BluetoothProfile.STATE_DISCONNECTING) {
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt);
    m_device.onDisconnecting();
    if (!m_queue.isCurrent(P_Task_Disconnect.class,m_device)) {
      P_Task_Disconnect task=new P_Task_Disconnect(m_device,m_taskStateListener,false,PE_TaskPriority.FOR_IMPLICIT_BONDING_CONNECTING);
      m_queue.add(task);
    }
    m_queue.fail(P_Task_Connect.class,m_device);
  }
 else {
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt);
  }
}","private void onConnectionStateChange_synchronized(BluetoothGatt gatt,int status,int newState){
  if (newState == BluetoothProfile.STATE_DISCONNECTED) {
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
    if (!m_queue.fail(P_Task_Connect.class,m_device)) {
      if (!m_queue.succeed(P_Task_Disconnect.class,m_device)) {
        m_device.onNativeDisconnect(false);
      }
    }
  }
 else   if (newState == BluetoothProfile.STATE_CONNECTING) {
    if (Utils.isSuccess(status)) {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
      m_device.onConnecting(false,false);
      if (!m_queue.isCurrent(P_Task_Connect.class,m_device)) {
        P_Task_Connect task=new P_Task_Connect(m_device,m_taskStateListener,false,PE_TaskPriority.FOR_IMPLICIT_BONDING_AND_CONNECTING);
        m_queue.add(task);
      }
      m_queue.fail(P_Task_Disconnect.class,m_device);
    }
 else {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt);
      m_queue.fail(P_Task_Connect.class,m_device);
    }
  }
 else   if (newState == BluetoothProfile.STATE_CONNECTED) {
    if (Utils.isSuccess(status)) {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt,newState);
      m_queue.fail(P_Task_Disconnect.class,m_device);
      if (!m_queue.succeed(P_Task_Connect.class,m_device)) {
        m_device.onNativeConnect();
      }
    }
 else {
      m_device.m_nativeWrapper.updateNativeConnectionState(gatt);
      if (!m_queue.fail(P_Task_Connect.class,m_device)) {
        m_device.onConnectFail((PE_TaskState)null);
      }
      if (status == PS_GattStatus.UNKNOWN_STATUS_FOR_IMMEDIATE_CONNECTION_FAILURE) {
      }
    }
  }
 else   if (newState == BluetoothProfile.STATE_DISCONNECTING) {
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt);
    m_device.onDisconnecting();
    if (!m_queue.isCurrent(P_Task_Disconnect.class,m_device)) {
      P_Task_Disconnect task=new P_Task_Disconnect(m_device,m_taskStateListener,false,PE_TaskPriority.FOR_IMPLICIT_BONDING_AND_CONNECTING);
      m_queue.add(task);
    }
    m_queue.fail(P_Task_Connect.class,m_device);
  }
 else {
    m_device.m_nativeWrapper.updateNativeConnectionState(gatt);
  }
}","The original code used an ambiguous priority constant `FOR_IMPLICIT_BONDING_CONNECTING` which might lead to incorrect task prioritization in Bluetooth connection management. The fixed code replaces this with `FOR_IMPLICIT_BONDING_AND_CONNECTING`, creating a more semantically clear and precise task priority definition. This subtle change improves code readability and reduces potential misinterpretation during Bluetooth device connection and task queuing processes."
94057,"public P_Task_Connect(BleDevice device,I_StateListener listener,boolean explicit,PE_TaskPriority priority){
  super(device,listener,TIMEOUT_CONNECTION);
  m_explicit=explicit;
  m_priority=priority == null ? PE_TaskPriority.FOR_EXPLICIT_BONDING_CONNECTING : priority;
}","public P_Task_Connect(BleDevice device,I_StateListener listener,boolean explicit,PE_TaskPriority priority){
  super(device,listener,TIMEOUT_CONNECTION);
  m_explicit=explicit;
  m_priority=priority == null ? PE_TaskPriority.FOR_EXPLICIT_BONDING_AND_CONNECTING : priority;
}","The original code used an incorrect enum value `FOR_EXPLICIT_BONDING_CONNECTING`, which likely did not exist or represent the intended task priority. The fixed code changes this to `FOR_EXPLICIT_BONDING_AND_CONNECTING`, which appears to be the correct enum value for handling explicit bonding and connection tasks. By using the proper enum, the fixed code ensures accurate task prioritization and prevents potential runtime errors or unexpected behavior during Bluetooth device connection."
94058,"public P_Task_Disconnect(BleDevice device,I_StateListener listener,boolean explicit,PE_TaskPriority priority){
  super(device,listener);
  m_priority=priority == null ? PE_TaskPriority.FOR_EXPLICIT_BONDING_CONNECTING : priority;
  m_explicit=explicit;
}","public P_Task_Disconnect(BleDevice device,I_StateListener listener,boolean explicit,PE_TaskPriority priority){
  super(device,listener);
  m_priority=priority == null ? PE_TaskPriority.FOR_EXPLICIT_BONDING_AND_CONNECTING : priority;
  m_explicit=explicit;
}","The original code used an incorrect enum value `FOR_EXPLICIT_BONDING_CONNECTING`, which likely does not exist in the enumeration. The fixed code corrects this by using `FOR_EXPLICIT_BONDING_AND_CONNECTING`, which appears to be the proper enum constant for handling explicit bonding and connection tasks. This change ensures the correct priority is set when no specific priority is provided, improving the task's reliability and preventing potential runtime errors."
94059,"@Override public boolean isInterruptableBy(PA_Task otherTask){
  if (otherTask instanceof P_Task_Read || otherTask instanceof P_Task_Write) {
    if (otherTask.getPriority().ordinal() > PE_TaskPriority.FOR_NORMAL_READS_WRITES.ordinal()) {
      return true;
    }
 else     if (otherTask.getPriority().ordinal() >= this.getPriority().ordinal()) {
      return this.getTotalTimeExecuting() >= getMinimumScanTime();
    }
  }
 else {
    return otherTask.getPriority().ordinal() > this.getPriority().ordinal();
  }
  return super.isInterruptableBy(otherTask);
}","@Override public boolean isInterruptableBy(PA_Task otherTask){
  if (otherTask instanceof P_Task_Read || otherTask instanceof P_Task_Write || otherTask instanceof P_Task_ReadRssi) {
    if (otherTask.getPriority().ordinal() > PE_TaskPriority.FOR_NORMAL_READS_WRITES.ordinal()) {
      return true;
    }
 else     if (otherTask.getPriority().ordinal() >= this.getPriority().ordinal()) {
      return this.getTotalTimeExecuting() >= getMinimumScanTime();
    }
  }
 else {
    return otherTask.getPriority().ordinal() > this.getPriority().ordinal();
  }
  return super.isInterruptableBy(otherTask);
}","The original code did not account for P_Task_ReadRssi tasks when determining interruptability, potentially causing incorrect task prioritization. The fixed code adds P_Task_ReadRssi to the instanceof check, ensuring that RSSI read tasks are treated similarly to read and write tasks with respect to interruption rules. This enhancement provides more comprehensive task management by consistently handling RSSI read tasks within the existing priority and execution time evaluation framework."
94060,"@Override public boolean isInterruptableBy(PA_Task task){
  if (task instanceof PA_Task_ReadOrWrite) {
    PA_Task_ReadOrWrite task_cast=(PA_Task_ReadOrWrite)task;
    if (this.getDevice() == task_cast.getDevice() && this.getTxn() == task_cast.getTxn()) {
      return true;
    }
  }
  return super.isInterruptableBy(task);
}","@Override public boolean isInterruptableBy(PA_Task task){
  if (task instanceof PA_Task_Transactionable) {
    PA_Task_Transactionable task_cast=(PA_Task_Transactionable)task;
    if (this.getDevice() == task_cast.getDevice() && this.getTxn() == task_cast.getTxn()) {
      return true;
    }
  }
  return super.isInterruptableBy(task);
}","The original code incorrectly assumes that all interruptible tasks are of type PA_Task_ReadOrWrite, which limits the method's flexibility and may cause type casting errors. The fixed code uses PA_Task_Transactionable, a more generic interface that likely encompasses various transactional tasks, allowing broader task compatibility. This modification improves type safety and extensibility by supporting a wider range of task types while maintaining the core device and transaction comparison logic."
94061,"@Override public PE_TaskPriority getPriority(){
  return PE_TaskPriority.FOR_EXPLICIT_BONDING_CONNECTING;
}","@Override public PE_TaskPriority getPriority(){
  return PE_TaskPriority.FOR_EXPLICIT_BONDING_AND_CONNECTING;
}","The original code used an incorrect enum value ""FOR_EXPLICIT_BONDING_CONNECTING"", which likely represents an improperly named or incomplete priority designation. The fixed code corrects the enum value to ""FOR_EXPLICIT_BONDING_AND_CONNECTING"", which appears to be the grammatically and semantically correct representation of the task priority. This correction ensures accurate and precise task priority classification, preventing potential misinterpretation or incorrect handling of the bonding and connecting task priority."
94062,"public static SpotifyError fromRetrofitError(RetrofitError error){
  ErrorResponse errorResponse=(ErrorResponse)error.getBodyAs(ErrorResponse.class);
  if (errorResponse != null && errorResponse.error != null) {
    String message=errorResponse.error.status + ""String_Node_Str"" + errorResponse.error.message;
    return new SpotifyError(error,errorResponse.error,message);
  }
 else {
    return new SpotifyError(error);
  }
}","public static SpotifyError fromRetrofitError(RetrofitError error){
  ErrorResponse errorResponse=null;
  try {
    errorResponse=(ErrorResponse)error.getBodyAs(ErrorResponse.class);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (errorResponse != null && errorResponse.error != null) {
    String message=errorResponse.error.status + ""String_Node_Str"" + errorResponse.error.message;
    return new SpotifyError(error,errorResponse.error,message);
  }
 else {
    return new SpotifyError(error);
  }
}","The original code might throw an uncaught exception when parsing the error response, potentially causing application crashes. The fixed code adds a try-catch block to handle potential parsing errors gracefully, converting the risky direct cast to a safer error-handling mechanism. By preventing unexpected exceptions and ensuring robust error parsing, the modified implementation provides more stable error handling for Spotify error responses."
94063,"static void initPremium(final XC_LoadPackage.LoadPackageParam lpparam){
  final ClassLoader cl=lpparam.classLoader;
  final boolean blockPresence=Preferences.getBool(Prefs.HIDE_TYPING_AND_PRESENCE) && Preferences.getLicence() >= 1;
  final boolean stealthViewing=Preferences.getBool(Prefs.STEALTH_VIEWING) && Preferences.getLicence() >= 2;
  final boolean stealthSaving=Preferences.getBool(Prefs.STEALTH_CHAT_SAVING) && Preferences.getLicence() >= 2;
  if (blockPresence || stealthViewing || stealthSaving) {
    findAndHookMethod(""String_Node_Str"",cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),findClass(""String_Node_Str"",cl),findClass(""String_Node_Str"",cl),new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object packet=param.args[1];
        String type=(String)getObjectField(packet,""String_Node_Str"");
switch (type) {
case ""String_Node_Str"":
          if (blockPresence) {
            Logger.log(""String_Node_Str"",LogType.PREMIUM);
            initPresenceBlocking(lpparam.classLoader,packet);
          }
        break;
case ""String_Node_Str"":
      boolean isReplayed=(boolean)getObjectField(packet,""String_Node_Str"");
    if (stealthViewing && !isReplayed) {
      Logger.log(""String_Node_Str"",LogType.PREMIUM);
      setObjectField(packet,""String_Node_Str"",false);
    }
  break;
case ""String_Node_Str"":
if (stealthViewing) {
  Logger.log(""String_Node_Str"",LogType.PREMIUM);
  param.setResult(null);
}
break;
case ""String_Node_Str"":
if (stealthSaving) {
Logger.log(""String_Node_Str"",LogType.PREMIUM);
setObjectField(packet,""String_Node_Str"",""String_Node_Str"");
}
break;
}
}
}
);
}
}","static void initPremium(final XC_LoadPackage.LoadPackageParam lpparam){
  final ClassLoader cl=lpparam.classLoader;
  final boolean blockPresence=Preferences.getBool(Prefs.HIDE_TYPING_AND_PRESENCE) && Preferences.getLicence() >= 1;
  final boolean stealthViewing=Preferences.getBool(Prefs.STEALTH_VIEWING) && Preferences.getLicence() >= 2;
  final boolean stealthSaving=Preferences.getBool(Prefs.STEALTH_CHAT_SAVING) && Preferences.getLicence() >= 2;
  if (blockPresence || stealthViewing || stealthSaving) {
    findAndHookMethod(""String_Node_Str"",cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),findClass(""String_Node_Str"",cl),findClass(""String_Node_Str"",cl),new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object packet=param.args[1];
        Logger.log(""String_Node_Str"" + packet.toString(),LogType.PREMIUM);
        performPacketBlocking(lpparam,param,packet,blockPresence,stealthViewing,stealthSaving);
      }
    }
);
    findAndHookMethod(""String_Node_Str"",cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object packet=param.args[0];
        Logger.log(""String_Node_Str"" + packet.toString(),LogType.PREMIUM);
        performPacketBlocking(lpparam,param,packet,blockPresence,stealthViewing,stealthSaving);
      }
    }
);
    String strNetworkManager=""String_Node_Str"";
    final Class snapUpdateClass=findClass(""String_Node_Str"",cl);
    final Class chatTypingClass=findClass(""String_Node_Str"",cl);
    findAndHookMethod(strNetworkManager,cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),findClass(strNetworkManager + ""String_Node_Str"",cl),Executor.class,new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object packet=param.args[0];
        if ((snapUpdateClass.isInstance(packet) && stealthViewing) || (chatTypingClass.isInstance(packet) && blockPresence))         param.setResult(true);
      }
    }
);
  }
}","The original code had redundant switch cases with identical placeholder strings and lacked clear packet handling logic, leading to potential undefined behavior. The fixed code refactors the method by introducing a centralized `performPacketBlocking` method, adding multiple hook points for different packet types, and implementing more robust type checking and blocking mechanisms. This approach provides better modularity, improved error handling, and more precise control over premium feature implementations across different packet scenarios."
94064,"@Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
  super.beforeHookedMethod(param);
  Object packet=param.args[1];
  String type=(String)getObjectField(packet,""String_Node_Str"");
switch (type) {
case ""String_Node_Str"":
    if (blockPresence) {
      Logger.log(""String_Node_Str"",LogType.PREMIUM);
      initPresenceBlocking(lpparam.classLoader,packet);
    }
  break;
case ""String_Node_Str"":
boolean isReplayed=(boolean)getObjectField(packet,""String_Node_Str"");
if (stealthViewing && !isReplayed) {
Logger.log(""String_Node_Str"",LogType.PREMIUM);
setObjectField(packet,""String_Node_Str"",false);
}
break;
case ""String_Node_Str"":
if (stealthViewing) {
Logger.log(""String_Node_Str"",LogType.PREMIUM);
param.setResult(null);
}
break;
case ""String_Node_Str"":
if (stealthSaving) {
Logger.log(""String_Node_Str"",LogType.PREMIUM);
setObjectField(packet,""String_Node_Str"",""String_Node_Str"");
}
break;
}
}","@Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
  super.beforeHookedMethod(param);
  Object packet=param.args[0];
  if ((snapUpdateClass.isInstance(packet) && stealthViewing) || (chatTypingClass.isInstance(packet) && blockPresence))   param.setResult(true);
}","The original code contains duplicate case labels, redundant string comparisons, and unclear logic for handling different packet types. The fixed code simplifies the method by checking packet instance types directly and applying conditional logic for stealth viewing and presence blocking. This refactoring improves code readability, reduces complexity, and provides a more straightforward approach to handling specific packet interactions."
94065,"static void initPremium(final XC_LoadPackage.LoadPackageParam lpparam){
  final ClassLoader cl=lpparam.classLoader;
  final boolean blockPresence=Preferences.getBool(Prefs.HIDE_TYPING_AND_PRESENCE) && Preferences.getLicence() >= 1;
  final boolean stealthViewing=Preferences.getBool(Prefs.STEALTH_VIEWING) && Preferences.getLicence() >= 2;
  final boolean stealthSaving=Preferences.getBool(Prefs.STEALTH_CHAT_SAVING) && Preferences.getLicence() >= 2;
  if (blockPresence || stealthViewing || stealthSaving) {
    findAndHookMethod(""String_Node_Str"",cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),findClass(""String_Node_Str"",cl),findClass(""String_Node_Str"",cl),new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object packet=param.args[1];
        Logger.log(""String_Node_Str"" + packet.toString(),LogType.PREMIUM);
        performPacketBlocking(lpparam,param,packet,blockPresence,stealthViewing,stealthSaving);
      }
    }
);
    findAndHookMethod(""String_Node_Str"",cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object packet=param.args[0];
        Logger.log(""String_Node_Str"" + packet.toString(),LogType.PREMIUM);
        performPacketBlocking(lpparam,param,packet,blockPresence,stealthViewing,stealthSaving);
      }
    }
);
    String strNetworkManager=""String_Node_Str"";
    final Class snapUpdateClass=findClass(""String_Node_Str"",cl);
    final Class chatTypingClass=findClass(""String_Node_Str"",cl);
    findAndHookMethod(strNetworkManager,cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),findClass(strNetworkManager + ""String_Node_Str"",cl),Executor.class,new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object packet=param.args[0];
        if ((snapUpdateClass.isInstance(packet) && stealthViewing) || (chatTypingClass.isInstance(packet) && blockPresence))         param.setResult(true);
      }
    }
);
  }
}","static void initPremium(final XC_LoadPackage.LoadPackageParam lpparam){
  final ClassLoader cl=lpparam.classLoader;
  final boolean blockPresence=Preferences.getBool(Prefs.HIDE_TYPING_AND_PRESENCE) && Preferences.getLicence() >= 1;
  final boolean stealthViewing=Preferences.getBool(Prefs.STEALTH_VIEWING) && Preferences.getLicence() >= 2;
  final boolean stealthSaving=Preferences.getBool(Prefs.STEALTH_CHAT_SAVING) && Preferences.getLicence() >= 2;
  if (blockPresence || stealthViewing || stealthSaving) {
    findAndHookMethod(""String_Node_Str"",cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),findClass(""String_Node_Str"",cl),findClass(""String_Node_Str"",cl),new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object packet=param.args[1];
        performPacketBlocking(lpparam,param,packet,blockPresence,stealthViewing,stealthSaving);
      }
    }
);
    findAndHookMethod(""String_Node_Str"",cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object packet=param.args[0];
        performPacketBlocking(lpparam,param,packet,blockPresence,stealthViewing,stealthSaving);
      }
    }
);
    String strNetworkManager=""String_Node_Str"";
    final Class snapUpdateClass=findClass(""String_Node_Str"",cl);
    final Class chatTypingClass=findClass(""String_Node_Str"",cl);
    findAndHookMethod(strNetworkManager,cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),findClass(strNetworkManager + ""String_Node_Str"",cl),Executor.class,new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object packet=param.args[0];
        if ((snapUpdateClass.isInstance(packet) && stealthViewing) || (chatTypingClass.isInstance(packet) && blockPresence))         param.setResult(true);
      }
    }
);
  }
}","The original code unnecessarily logged packet information using `Logger.log()`, which could introduce performance overhead and potential security risks. The fixed code removes these logging statements, focusing solely on the core `performPacketBlocking()` method execution. By eliminating redundant logging, the code becomes more efficient and reduces potential information exposure while maintaining the same core functionality of packet blocking and stealth features."
94066,"public static String stripKey(String input){
  String finalOutput=input;
  if (finalOutput.contains(""String_Node_Str""))   finalOutput=finalOutput.replace(""String_Node_Str"",""String_Node_Str"");
 else   if (finalOutput.contains(""String_Node_Str"")) {
    String[] split=input.split(""String_Node_Str"");
    if (split.length > 0)     finalOutput=split[split.length - 1];
  }
  if (finalOutput.contains(""String_Node_Str"")) {
    String[] split=finalOutput.split(""String_Node_Str"");
    if (split.length > 0)     finalOutput=split[0];
  }
  return finalOutput;
}","public static String stripKey(String input){
  String finalOutput=input;
  if (finalOutput.contains(""String_Node_Str""))   finalOutput=finalOutput.replace(""String_Node_Str"",""String_Node_Str"");
 else   if (finalOutput.contains(""String_Node_Str"")) {
    String[] split=input.split(""String_Node_Str"");
    if (split.length > 0)     finalOutput=split[split.length - 1];
  }
 else   if (finalOutput.contains(""String_Node_Str"")) {
    String[] split=finalOutput.split(""String_Node_Str"");
    if (split.length > 0) {
      finalOutput=split[split.length - 1];
      finalOutput=finalOutput.substring(1);
    }
  }
  if (finalOutput.contains(""String_Node_Str"")) {
    String[] split=finalOutput.split(""String_Node_Str"");
    if (split.length > 0)     finalOutput=split[0];
  }
  return finalOutput;
}","The original code contains redundant and logically inconsistent conditions when handling the ""String_Node_Str"" substring, leading to potential incorrect string manipulation. The fixed code adds an additional else-if condition that splits the string and removes the first character, ensuring more robust string processing. These modifications provide a more predictable and comprehensive approach to stripping the key from the input string, addressing potential edge cases in string parsing."
94067,"@Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
  super.beforeHookedMethod(param);
  Logger.log(""String_Node_Str"",LogType.CHAT);
  Uri videoUri=(Uri)getObjectField(param.thisObject,""String_Node_Str"");
  if (videoUri == null) {
    Logger.log(""String_Node_Str"",LogType.CHAT);
    return;
  }
  String strVideoUrl=videoUri.getPath();
  String[] arrSplitUrl=strVideoUrl.split(""String_Node_Str"");
  if (arrSplitUrl.length <= 0) {
    Logger.log(""String_Node_Str"",LogType.CHAT);
    return;
  }
  String splitUrl=arrSplitUrl[1];
  setAdditionalInstanceField(param.thisObject,""String_Node_Str"",splitUrl);
  Logger.log(""String_Node_Str"",LogType.CHAT);
}","@Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
  super.beforeHookedMethod(param);
  Logger.log(""String_Node_Str"",LogType.CHAT);
  Uri videoUri=(Uri)getObjectField(param.thisObject,""String_Node_Str"");
  if (videoUri == null) {
    Logger.log(""String_Node_Str"",LogType.CHAT);
    return;
  }
  String strVideoUrl=videoUri.getPath();
  String[] arrSplitUrl=strVideoUrl.split(""String_Node_Str"");
  if (arrSplitUrl.length <= 1) {
    Logger.log(""String_Node_Str"",LogType.CHAT);
    return;
  }
  String splitUrl=arrSplitUrl[1];
  setAdditionalInstanceField(param.thisObject,""String_Node_Str"",splitUrl);
  Logger.log(""String_Node_Str"",LogType.CHAT);
}","The buggy code incorrectly checks array length with `arrSplitUrl.length <= 0`, which would always prevent accessing the second array element. The fixed code changes the condition to `arrSplitUrl.length <= 1`, ensuring that the array has at least two elements before attempting to access the second index. This modification prevents potential `ArrayIndexOutOfBoundsException` and allows proper extraction of the split URL when the split operation results in multiple elements."
94068,"static void initImageSave(final XC_LoadPackage.LoadPackageParam lpparam,final XModuleResources modRes){
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",List.class,findClass(""String_Node_Str"",lpparam.classLoader),List.class,View.class,findClass(""String_Node_Str"",lpparam.classLoader),new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      super.beforeHookedMethod(param);
      if (!Preferences.getBool(Prefs.CHAT_MEDIA_SAVE))       return;
      Logger.log(""String_Node_Str"",LogType.CHAT);
      Object chatMedia=param.args[1];
      String mKey=(String)getObjectField(chatMedia,""String_Node_Str"");
      if (mKey == null) {
        Logger.log(""String_Node_Str"",LogType.CHAT);
        return;
      }
      Logger.log(""String_Node_Str"" + mKey,LogType.CHAT);
      if (!chatMediaMap.containsKey(mKey))       chatMediaMap.put(mKey,chatMedia);
 else       Logger.log(""String_Node_Str"",LogType.CHAT);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      super.beforeHookedMethod(param);
      if (!Preferences.getBool(Prefs.CHAT_MEDIA_SAVE))       return;
      Logger.log(""String_Node_Str"",LogType.CHAT);
      Object godPacket=getObjectField(param.thisObject,""String_Node_Str"");
      Map<String,Object> map=(Map<String,Object>)getObjectField(godPacket,""String_Node_Str"");
      String mKey=(String)map.get(""String_Node_Str"");
      String mMediaUrl=(String)map.get(""String_Node_Str"");
      String[] arrSplitUrl=mMediaUrl.split(""String_Node_Str"");
      if (arrSplitUrl.length <= 0) {
        Logger.log(""String_Node_Str"",LogType.CHAT);
        return;
      }
      String splitUrl=arrSplitUrl[1];
      Logger.log(String.format(""String_Node_Str"",mKey,splitUrl),LogType.CHAT);
      Object chatMedia=chatMediaMap.get(mKey);
      if (chatMedia == null) {
        Logger.log(""String_Node_Str"",LogType.CHAT);
        return;
      }
      chatMediaMap.remove(mKey);
      chatMediaMap.put(splitUrl,chatMedia);
      Logger.log(""String_Node_Str"" + splitUrl,LogType.CHAT);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",MotionEvent.class,new XC_MethodHook(){
    private GestureDetector gestureDetector;
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      super.beforeHookedMethod(param);
      if (!Preferences.getBool(Prefs.CHAT_MEDIA_SAVE))       return;
      MotionEvent event=(MotionEvent)param.args[0];
      ViewGroup viewGroup=(ViewGroup)param.thisObject;
      if (gestureDetector == null) {
        gestureDetector=new GestureDetector(new MediaGestureListener((ViewGroup)param.thisObject){
          @Override public void onLongPress(          MotionEvent e){
            Logger.log(""String_Node_Str"",LogType.CHAT);
            try {
              int childCount=this.mediaLayout.getChildCount();
              if (childCount > 0) {
                FrameLayout videoLayout=(FrameLayout)this.mediaLayout.getChildAt(0);
                for (int i=0; i < videoLayout.getChildCount(); i++) {
                  View view=videoLayout.getChildAt(i);
                  if (view.getId() != +2131690096)                   return;
                  Logger.log(""String_Node_Str"",LogType.CHAT);
                  Uri videoUri=(Uri)getObjectField(view,""String_Node_Str"");
                  String splitUrl;
                  if (videoUri == null) {
                    Logger.log(""String_Node_Str"",LogType.CHAT);
                    splitUrl=(String)getAdditionalInstanceField(view,""String_Node_Str"");
                    if (splitUrl == null) {
                      Logger.log(""String_Node_Str"",LogType.CHAT);
                      return;
                    }
                  }
 else {
                    String strVideoUrl=videoUri.getPath();
                    String[] arrSplitUrl=strVideoUrl.split(""String_Node_Str"");
                    if (arrSplitUrl.length <= 0) {
                      Logger.log(""String_Node_Str"",LogType.CHAT);
                      return;
                    }
                    splitUrl=arrSplitUrl[1];
                  }
                  Logger.log(""String_Node_Str"" + splitUrl);
                  Object chatMedia=chatMediaMap.get(splitUrl);
                  if (chatMedia == null) {
                    Logger.log(""String_Node_Str"" + splitUrl,LogType.CHAT);
                    return;
                  }
                  Logger.log(""String_Node_Str"",LogType.CHAT);
                  Long timestamp=(Long)callMethod(chatMedia,""String_Node_Str"");
                  Logger.log(""String_Node_Str"" + timestamp,LogType.CHAT);
                  String sender=(String)getObjectField(chatMedia,""String_Node_Str"");
                  Logger.log(""String_Node_Str"" + sender,LogType.CHAT);
                  String formattedTimestamp=savingDateFormat.format(timestamp);
                  String mId=(String)getObjectField(chatMedia,""String_Node_Str"");
                  String filename=String.format(""String_Node_Str"",sender,formattedTimestamp,mId.hashCode() % 999999);
                  Logger.log(""String_Node_Str"" + obfus(sender) + ""String_Node_Str""+ formattedTimestamp,LogType.CHAT);
                  FileInputStream video=new FileInputStream(videoUri.getPath());
                  Saving.SaveResponse response=Saving.saveSnap(Saving.SnapType.CHAT,Saving.MediaType.VIDEO,view.getContext(),null,video,filename,sender);
                  if (response == Saving.SaveResponse.SUCCESS) {
                    Logger.log(""String_Node_Str"",LogType.CHAT);
                    Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.GOOD);
                  }
 else                   if (response == Saving.SaveResponse.EXISTING) {
                    Logger.log(""String_Node_Str"",LogType.CHAT);
                    Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.WARNING);
                  }
 else                   if (response == Saving.SaveResponse.FAILED) {
                    Logger.log(""String_Node_Str"",LogType.CHAT);
                    Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.BAD);
                  }
 else {
                    Logger.log(""String_Node_Str"",LogType.CHAT);
                    Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.WARNING);
                  }
                }
              }
            }
 catch (            Exception ex) {
              Logger.log(""String_Node_Str"",ex,LogType.CHAT.setForced());
              Saving.createStatefulToast(""String_Node_Str"",ToastType.BAD);
            }
          }
        }
);
      }
      if (gestureDetector.onTouchEvent(event))       return;
      if (event.getAction() != MotionEvent.ACTION_UP)       param.setResult(true);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      super.beforeHookedMethod(param);
      Logger.log(""String_Node_Str"",LogType.CHAT);
      Uri videoUri=(Uri)getObjectField(param.thisObject,""String_Node_Str"");
      if (videoUri == null) {
        Logger.log(""String_Node_Str"",LogType.CHAT);
        return;
      }
      String strVideoUrl=videoUri.getPath();
      String[] arrSplitUrl=strVideoUrl.split(""String_Node_Str"");
      if (arrSplitUrl.length <= 0) {
        Logger.log(""String_Node_Str"",LogType.CHAT);
        return;
      }
      String splitUrl=arrSplitUrl[1];
      setAdditionalInstanceField(param.thisObject,""String_Node_Str"",splitUrl);
      Logger.log(""String_Node_Str"",LogType.CHAT);
    }
  }
);
  findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,findClass(""String_Node_Str"",lpparam.classLoader),findClass(""String_Node_Str"",lpparam.classLoader),Context.class,findClass(""String_Node_Str"",lpparam.classLoader),findClass(""String_Node_Str"",lpparam.classLoader),findClass(""String_Node_Str"",lpparam.classLoader),new XC_MethodHook(){
    @Override protected void afterHookedMethod(    final MethodHookParam param) throws Throwable {
      super.afterHookedMethod(param);
      if (!Preferences.getBool(Prefs.CHAT_MEDIA_SAVE))       return;
      final ImageView imageView=(ImageView)getObjectField(param.thisObject,""String_Node_Str"");
      imageView.setOnLongClickListener(new View.OnLongClickListener(){
        @Override public boolean onLongClick(        View v){
          try {
            Logger.log(""String_Node_Str"",LogType.CHAT);
            Bitmap chatImage=((BitmapDrawable)imageView.getDrawable()).getBitmap();
            if (chatImage == null) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              return true;
            }
            final Object godPacket=getObjectField(param.thisObject,""String_Node_Str"");
            final Map<String,Object> map=(Map<String,Object>)getObjectField(godPacket,""String_Node_Str"");
            if (map == null) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              return true;
            }
            final String mKey=(String)map.get(""String_Node_Str"");
            if (mKey == null) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              return true;
            }
            Logger.log(""String_Node_Str"" + mKey,LogType.CHAT);
            final Object chatMedia=chatMediaMap.get(mKey);
            if (chatMedia == null) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              return true;
            }
            Long timestamp=(Long)callMethod(chatMedia,""String_Node_Str"");
            Logger.log(""String_Node_Str"" + timestamp,LogType.CHAT);
            String sender=(String)getObjectField(chatMedia,""String_Node_Str"");
            Logger.log(""String_Node_Str"" + obfus(sender),LogType.CHAT);
            String formattedTimestamp=savingDateFormat.format(timestamp);
            String mId=(String)getObjectField(chatMedia,""String_Node_Str"");
            String filename=String.format(""String_Node_Str"",sender,formattedTimestamp,mId.hashCode() % 999999);
            Logger.log(""String_Node_Str"" + obfus(sender) + ""String_Node_Str""+ formattedTimestamp+ ""String_Node_Str""+ (mId.hashCode() % 999999),LogType.CHAT);
            Saving.SaveResponse response=Saving.saveSnap(Saving.SnapType.CHAT,Saving.MediaType.IMAGE,imageView.getContext(),chatImage,null,filename,sender);
            if (response == Saving.SaveResponse.SUCCESS) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.GOOD);
            }
 else             if (response == Saving.SaveResponse.EXISTING) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.WARNING);
            }
 else             if (response == Saving.SaveResponse.FAILED) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.BAD);
            }
 else {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.WARNING);
            }
            return false;
          }
 catch (          Exception e) {
            Logger.log(""String_Node_Str"",e,LogType.CHAT.setForced());
            Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.BAD);
            return true;
          }
        }
      }
);
    }
  }
);
}","static void initImageSave(final XC_LoadPackage.LoadPackageParam lpparam,final XModuleResources modRes){
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",List.class,findClass(""String_Node_Str"",lpparam.classLoader),List.class,View.class,findClass(""String_Node_Str"",lpparam.classLoader),new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      super.beforeHookedMethod(param);
      if (!Preferences.getBool(Prefs.CHAT_MEDIA_SAVE))       return;
      Logger.log(""String_Node_Str"",LogType.CHAT);
      Object chatMedia=param.args[1];
      String mKey=(String)getObjectField(chatMedia,""String_Node_Str"");
      if (mKey == null) {
        Logger.log(""String_Node_Str"",LogType.CHAT);
        return;
      }
      Logger.log(""String_Node_Str"" + mKey,LogType.CHAT);
      if (!chatMediaMap.containsKey(mKey))       chatMediaMap.put(mKey,chatMedia);
 else       Logger.log(""String_Node_Str"",LogType.CHAT);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      super.beforeHookedMethod(param);
      if (!Preferences.getBool(Prefs.CHAT_MEDIA_SAVE))       return;
      Logger.log(""String_Node_Str"",LogType.CHAT);
      Object godPacket=getObjectField(param.thisObject,""String_Node_Str"");
      Map<String,Object> map=(Map<String,Object>)getObjectField(godPacket,""String_Node_Str"");
      String mKey=(String)map.get(""String_Node_Str"");
      String mMediaUrl=(String)map.get(""String_Node_Str"");
      String[] arrSplitUrl=mMediaUrl.split(""String_Node_Str"");
      if (arrSplitUrl.length <= 1) {
        Logger.log(""String_Node_Str"",LogType.CHAT);
        return;
      }
      String splitUrl=arrSplitUrl[1];
      Logger.log(String.format(""String_Node_Str"",mKey,splitUrl),LogType.CHAT);
      Object chatMedia=chatMediaMap.get(mKey);
      if (chatMedia == null) {
        Logger.log(""String_Node_Str"",LogType.CHAT);
        return;
      }
      chatMediaMap.remove(mKey);
      chatMediaMap.put(splitUrl,chatMedia);
      Logger.log(""String_Node_Str"" + splitUrl,LogType.CHAT);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",MotionEvent.class,new XC_MethodHook(){
    private GestureDetector gestureDetector;
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      super.beforeHookedMethod(param);
      if (!Preferences.getBool(Prefs.CHAT_MEDIA_SAVE))       return;
      MotionEvent event=(MotionEvent)param.args[0];
      ViewGroup viewGroup=(ViewGroup)param.thisObject;
      if (gestureDetector == null) {
        gestureDetector=new GestureDetector(new MediaGestureListener((ViewGroup)param.thisObject){
          @Override public void onLongPress(          MotionEvent e){
            Logger.log(""String_Node_Str"",LogType.CHAT);
            try {
              int childCount=this.mediaLayout.getChildCount();
              if (childCount > 0) {
                FrameLayout videoLayout=(FrameLayout)this.mediaLayout.getChildAt(0);
                for (int i=0; i < videoLayout.getChildCount(); i++) {
                  View view=videoLayout.getChildAt(i);
                  if (view.getId() != +2131690096)                   return;
                  Logger.log(""String_Node_Str"",LogType.CHAT);
                  Uri videoUri=(Uri)getObjectField(view,""String_Node_Str"");
                  String splitUrl;
                  if (videoUri == null) {
                    Logger.log(""String_Node_Str"",LogType.CHAT);
                    splitUrl=(String)getAdditionalInstanceField(view,""String_Node_Str"");
                    if (splitUrl == null) {
                      Logger.log(""String_Node_Str"",LogType.CHAT);
                      return;
                    }
                  }
 else {
                    String strVideoUrl=videoUri.getPath();
                    String[] arrSplitUrl=strVideoUrl.split(""String_Node_Str"");
                    if (arrSplitUrl.length <= 0) {
                      Logger.log(""String_Node_Str"",LogType.CHAT);
                      return;
                    }
                    splitUrl=arrSplitUrl[1];
                  }
                  Logger.log(""String_Node_Str"" + splitUrl);
                  Object chatMedia=chatMediaMap.get(splitUrl);
                  if (chatMedia == null) {
                    Logger.log(""String_Node_Str"" + splitUrl,LogType.CHAT);
                    return;
                  }
                  Logger.log(""String_Node_Str"",LogType.CHAT);
                  Long timestamp=(Long)callMethod(chatMedia,""String_Node_Str"");
                  Logger.log(""String_Node_Str"" + timestamp,LogType.CHAT);
                  String sender=(String)getObjectField(chatMedia,""String_Node_Str"");
                  Logger.log(""String_Node_Str"" + sender,LogType.CHAT);
                  String formattedTimestamp=savingDateFormat.format(timestamp);
                  String mId=(String)getObjectField(chatMedia,""String_Node_Str"");
                  String filename=String.format(""String_Node_Str"",sender,formattedTimestamp,mId.hashCode() % 999999);
                  Logger.log(""String_Node_Str"" + obfus(sender) + ""String_Node_Str""+ formattedTimestamp,LogType.CHAT);
                  FileInputStream video=new FileInputStream(videoUri.getPath());
                  Saving.SaveResponse response=Saving.saveSnap(Saving.SnapType.CHAT,Saving.MediaType.VIDEO,view.getContext(),null,video,filename,sender);
                  if (response == Saving.SaveResponse.SUCCESS) {
                    Logger.log(""String_Node_Str"",LogType.CHAT);
                    Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.GOOD);
                  }
 else                   if (response == Saving.SaveResponse.EXISTING) {
                    Logger.log(""String_Node_Str"",LogType.CHAT);
                    Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.WARNING);
                  }
 else                   if (response == Saving.SaveResponse.FAILED) {
                    Logger.log(""String_Node_Str"",LogType.CHAT);
                    Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.BAD);
                  }
 else {
                    Logger.log(""String_Node_Str"",LogType.CHAT);
                    Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.WARNING);
                  }
                }
              }
            }
 catch (            Exception ex) {
              Logger.log(""String_Node_Str"",ex,LogType.CHAT.setForced());
              Saving.createStatefulToast(""String_Node_Str"",ToastType.BAD);
            }
          }
        }
);
      }
      if (gestureDetector.onTouchEvent(event))       return;
      if (event.getAction() != MotionEvent.ACTION_UP)       param.setResult(true);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      super.beforeHookedMethod(param);
      Logger.log(""String_Node_Str"",LogType.CHAT);
      Uri videoUri=(Uri)getObjectField(param.thisObject,""String_Node_Str"");
      if (videoUri == null) {
        Logger.log(""String_Node_Str"",LogType.CHAT);
        return;
      }
      String strVideoUrl=videoUri.getPath();
      String[] arrSplitUrl=strVideoUrl.split(""String_Node_Str"");
      if (arrSplitUrl.length <= 1) {
        Logger.log(""String_Node_Str"",LogType.CHAT);
        return;
      }
      String splitUrl=arrSplitUrl[1];
      setAdditionalInstanceField(param.thisObject,""String_Node_Str"",splitUrl);
      Logger.log(""String_Node_Str"",LogType.CHAT);
    }
  }
);
  findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,findClass(""String_Node_Str"",lpparam.classLoader),findClass(""String_Node_Str"",lpparam.classLoader),Context.class,findClass(""String_Node_Str"",lpparam.classLoader),findClass(""String_Node_Str"",lpparam.classLoader),findClass(""String_Node_Str"",lpparam.classLoader),new XC_MethodHook(){
    @Override protected void afterHookedMethod(    final MethodHookParam param) throws Throwable {
      super.afterHookedMethod(param);
      if (!Preferences.getBool(Prefs.CHAT_MEDIA_SAVE))       return;
      final ImageView imageView=(ImageView)getObjectField(param.thisObject,""String_Node_Str"");
      imageView.setOnLongClickListener(new View.OnLongClickListener(){
        @Override public boolean onLongClick(        View v){
          try {
            Logger.log(""String_Node_Str"",LogType.CHAT);
            Bitmap chatImage=((BitmapDrawable)imageView.getDrawable()).getBitmap();
            if (chatImage == null) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              return true;
            }
            final Object godPacket=getObjectField(param.thisObject,""String_Node_Str"");
            final Map<String,Object> map=(Map<String,Object>)getObjectField(godPacket,""String_Node_Str"");
            if (map == null) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              return true;
            }
            final String mKey=(String)map.get(""String_Node_Str"");
            if (mKey == null) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              return true;
            }
            Logger.log(""String_Node_Str"" + mKey,LogType.CHAT);
            final Object chatMedia=chatMediaMap.get(mKey);
            if (chatMedia == null) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              return true;
            }
            Long timestamp=(Long)callMethod(chatMedia,""String_Node_Str"");
            Logger.log(""String_Node_Str"" + timestamp,LogType.CHAT);
            String sender=(String)getObjectField(chatMedia,""String_Node_Str"");
            Logger.log(""String_Node_Str"" + obfus(sender),LogType.CHAT);
            String formattedTimestamp=savingDateFormat.format(timestamp);
            String mId=(String)getObjectField(chatMedia,""String_Node_Str"");
            String filename=String.format(""String_Node_Str"",sender,formattedTimestamp,mId.hashCode() % 999999);
            Logger.log(""String_Node_Str"" + obfus(sender) + ""String_Node_Str""+ formattedTimestamp+ ""String_Node_Str""+ (mId.hashCode() % 999999),LogType.CHAT);
            Saving.SaveResponse response=Saving.saveSnap(Saving.SnapType.CHAT,Saving.MediaType.IMAGE,imageView.getContext(),chatImage,null,filename,sender);
            if (response == Saving.SaveResponse.SUCCESS) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.GOOD);
            }
 else             if (response == Saving.SaveResponse.EXISTING) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.WARNING);
            }
 else             if (response == Saving.SaveResponse.FAILED) {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.BAD);
            }
 else {
              Logger.log(""String_Node_Str"",LogType.CHAT);
              Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.WARNING);
            }
            return false;
          }
 catch (          Exception e) {
            Logger.log(""String_Node_Str"",e,LogType.CHAT.setForced());
            Saving.createStatefulToast(""String_Node_Str"",NotificationUtils.ToastType.BAD);
            return true;
          }
        }
      }
);
    }
  }
);
}","The original code had potential array index out-of-bounds errors when splitting URLs, risking runtime exceptions. The fixed code adds length checks before accessing array indices (e.g., `arrSplitUrl.length <= 1` instead of `<= 0`), ensuring robust array access and preventing potential null pointer or index-related crashes. These defensive programming changes make the code more resilient by gracefully handling edge cases and preventing unexpected runtime failures during media processing."
94069,"private void displayDebugMenu(LayoutInflater inflater){
  View view=inflater.inflate(R.layout.debug_layout,null,false);
  LinearLayout layout=(LinearLayout)view.findViewById(R.id.scroll_logtype_container);
  applyLogTypeSwitches(layout);
  AlertDialog.Builder builder=new AlertDialog.Builder(this.getContext());
  builder.setView(view);
  builder.setPositiveButton(""String_Node_Str"",null);
  builder.show();
}","private void displayDebugMenu(LayoutInflater inflater){
  View view=inflater.inflate(R.layout.debug_layout,null,false);
  Switch debugSwitch=(Switch)view.findViewById(R.id.switch_debug_master);
  debugSwitch.setChecked(Preferences.getBool(Preferences.Prefs.DEBUGGING));
  debugSwitch.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      Preferences.putBool(Preferences.Prefs.DEBUGGING.key,isChecked);
    }
  }
);
  LinearLayout layout=(LinearLayout)view.findViewById(R.id.scroll_logtype_container);
  applyLogTypeSwitches(layout);
  AlertDialog.Builder builder=new AlertDialog.Builder(this.getContext());
  builder.setView(view);
  builder.setPositiveButton(""String_Node_Str"",null);
  builder.show();
}","The original code lacked proper handling of the debug switch functionality, missing user interaction and preference management for the debugging settings. The fixed code introduces a Switch widget with an OnCheckedChangeListener that dynamically updates the debugging preference when toggled, and initializes the switch state based on the current preference value. This improvement provides users with a direct, interactive method to enable or disable debugging through the dialog interface, enhancing user control and configuration flexibility."
94070,"private static void buildModifiedList(List<Object> list,LensType type){
  Logger.log(""String_Node_Str"" + list.size(),LogType.LENS);
  final LinkedHashMap<String,Object> queriedList=(LinkedHashMap<String,Object>)getLensDatabase().getAllActive();
  final boolean canInjectLenses=queriedList != null;
  if (!canInjectLenses)   Logger.log(""String_Node_Str"" + type,LogType.LENS);
  HashSet<String> containedList=new HashSet<>();
  for (  Object lens : list) {
    String mCode=(String)getObjectField(lens,""String_Node_Str"");
    if (Preferences.getBool(Prefs.LENSES_COLLECT) && (!canInjectLenses || !queriedList.containsKey(mCode))) {
      performLensSave(lens,type);
    }
    if (!Preferences.getBool(Prefs.LENSES_HIDE_CURRENTLY_PROVIDED_SC_LENSES) && canInjectLenses)     containedList.add(mCode);
  }
  if (Preferences.getBool(Prefs.LENSES_HIDE_CURRENTLY_PROVIDED_SC_LENSES))   list.clear();
  if (!Preferences.getBool(Prefs.LENSES_LOAD) || !canInjectLenses)   return;
  Logger.log(""String_Node_Str"" + queriedList.size(),LogType.LENS);
  int injectedLensCount=0;
  for (  Object lensObj : queriedList.values()) {
    LensData lensData=(LensData)lensObj;
    String mCode=lensData.mCode;
    if (!lensData.mActive || containedList.contains(mCode))     continue;
    Object lens=buildModifiedLens(lensData,type);
    list.add(lens);
    injectedLensCount++;
  }
  Logger.log(String.format(""String_Node_Str"",injectedLensCount,String.valueOf(type)),LogType.LENS);
}","private static void buildModifiedList(List<Object> list,LensType type){
  Logger.log(""String_Node_Str"" + list.size(),LogType.LENS);
  final LinkedHashMap<String,Object> queriedList=(LinkedHashMap<String,Object>)getLensDatabase().getAllActive();
  final boolean canInjectLenses=queriedList != null;
  if (!canInjectLenses)   Logger.log(""String_Node_Str"" + type,LogType.LENS);
  HashSet<String> containedList=new HashSet<>();
  for (  Object lens : list) {
    String mCode=(String)getObjectField(lens,""String_Node_Str"");
    if (Preferences.getBool(Prefs.LENSES_COLLECT) && (!canInjectLenses || !queriedList.containsKey(mCode)) && !getLensDatabase().containsLens(mCode)) {
      performLensSave(lens,type);
    }
    if (!Preferences.getBool(Prefs.LENSES_HIDE_CURRENTLY_PROVIDED_SC_LENSES) && canInjectLenses)     containedList.add(mCode);
  }
  if (Preferences.getBool(Prefs.LENSES_HIDE_CURRENTLY_PROVIDED_SC_LENSES))   list.clear();
  if (!Preferences.getBool(Prefs.LENSES_LOAD) || !canInjectLenses)   return;
  Logger.log(""String_Node_Str"" + queriedList.size(),LogType.LENS);
  int injectedLensCount=0;
  for (  Object lensObj : queriedList.values()) {
    LensData lensData=(LensData)lensObj;
    String mCode=lensData.mCode;
    if (!lensData.mActive || containedList.contains(mCode))     continue;
    Object lens=buildModifiedLens(lensData,type);
    list.add(lens);
    injectedLensCount++;
  }
  Logger.log(String.format(""String_Node_Str"",injectedLensCount,String.valueOf(type)),LogType.LENS);
}","The original code lacked a critical validation check when collecting lenses, potentially allowing duplicate or already existing lenses to be saved. The fixed code adds `!getLensDatabase().containsLens(mCode)` to ensure that only truly new lenses are collected and saved, preventing redundant database entries. This improvement enhances data integrity and prevents unnecessary lens duplication during the collection process."
94071,"private void displayDebugMenu(LayoutInflater inflater){
  View view=inflater.inflate(R.layout.debug_layout,null,false);
  LinearLayout layout=(LinearLayout)view.findViewById(R.id.scroll_logtype_container);
  applyLogTypeSwitches(layout);
  AlertDialog.Builder builder=new AlertDialog.Builder(this.getContext());
  builder.setView(view);
  builder.setPositiveButton(""String_Node_Str"",null);
  builder.show();
}","private void displayDebugMenu(LayoutInflater inflater){
  View view=inflater.inflate(R.layout.debug_layout,null,false);
  Switch debugSwitch=(Switch)view.findViewById(R.id.switch_debug_master);
  debugSwitch.setChecked(Preferences.getBool(Preferences.Prefs.DEBUGGING));
  debugSwitch.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      Preferences.putBool(Preferences.Prefs.DEBUGGING.key,isChecked);
    }
  }
);
  LinearLayout layout=(LinearLayout)view.findViewById(R.id.scroll_logtype_container);
  applyLogTypeSwitches(layout);
  AlertDialog.Builder builder=new AlertDialog.Builder(this.getContext());
  builder.setView(view);
  builder.setPositiveButton(""String_Node_Str"",null);
  builder.show();
}","The original code merely inflated a layout without handling the debug switch functionality, leaving user preferences unmanaged. The fixed code adds a Switch widget listener that captures and persists the debugging state through Preferences, correctly initializing the switch with the current preference value. By implementing this change, the code now provides interactive debug settings control with proper state management and persistence."
94072,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder alert=new AlertDialog.Builder(getActivity()).setTitle(""String_Node_Str"").setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      Toast.makeText(HookMethods.SnapContext,""String_Node_Str"",Toast.LENGTH_LONG).show();
      onCancel(dialog);
      Groups.sendStoriesUpdateEvent();
    }
  }
);
  LinearLayout.LayoutParams linearparams=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT,LinearLayout.LayoutParams.WRAP_CONTENT);
  final LinearLayout v=new LinearLayout(HookMethods.SnapContext);
  v.setOrientation(LinearLayout.VERTICAL);
  v.setLayoutParams(linearparams);
  final Handler handler=new Handler(HookMethods.SnapContext.getMainLooper());
  new Thread(new Runnable(){
    @Override public void run(){
      File[] files=Groups.groupsDir.listFiles();
      if (files == null) {
        Groups.groupsDir.mkdir();
        files=Groups.groupsDir.listFiles();
      }
      Arrays.sort(files);
      List<String> al=new ArrayList<>();
      Set<Groups.Group> linkedHashSet=new LinkedHashSet<>();
      linkedHashSet.addAll(Groups.groups);
      Groups.groups.clear();
      Groups.groups.addAll(linkedHashSet);
      final int N=Groups.groups.size();
      for (int i=0; i < N; i++) {
        final File[] finalFiles=files;
        final int finalI=i;
        Runnable addRowsRunnable=new Runnable(){
          @Override public void run(){
            final TextView rowTextView=new TextView(HookMethods.context);
            rowTextView.setText(finalFiles[finalI].getName());
            rowTextView.setPadding(HookMethods.px(5),HookMethods.px(5),HookMethods.px(5),HookMethods.px(5));
            rowTextView.setTextSize(20);
            rowTextView.setTextColor(Color.BLACK);
            v.addView(rowTextView);
            rowTextView.setId(finalI);
            final int id_=rowTextView.getId();
            rowTextView.setOnClickListener(new View.OnClickListener(){
              public void onClick(              View view){
                FragmentTransaction ft=HookMethods.SnapContext.getFragmentManager().beginTransaction();
                Fragment prev=HookMethods.SnapContext.getFragmentManager().findFragmentByTag(""String_Node_Str"");
                if (prev != null) {
                  ft.remove(prev);
                }
                ft.addToBackStack(null);
                DialogFragment newFragment=GroupDialogList.newInstance((String)rowTextView.getText());
                Groups.readGroups();
                GroupDialogList.setGroup(Groups.groups.get(id_));
                newFragment.show(ft,""String_Node_Str"");
                Groups.sendStoriesUpdateEvent();
              }
            }
);
          }
        }
;
        handler.post(addRowsRunnable);
      }
      Runnable addButtonRunnable=new Runnable(){
        @Override public void run(){
          Button add=new Button(HookMethods.SnapContext);
          add.setText(""String_Node_Str"");
          add.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
          boolean shouldShowAdd=true;
          if (Groups.groups.size() == 3 && Preferences.getLicence() == 0) {
            shouldShowAdd=false;
          }
          if (Preferences.getLicence() != 0 && !Preferences.getBool(Prefs.UNLIM_GROUPS)) {
            shouldShowAdd=false;
          }
          if (shouldShowAdd) {
            v.addView(add);
          }
          add.setOnClickListener(new View.OnClickListener(){
            @Override public void onClick(            View view){
              FragmentTransaction ft=HookMethods.SnapContext.getFragmentManager().beginTransaction();
              Fragment prev=HookMethods.SnapContext.getFragmentManager().findFragmentByTag(""String_Node_Str"");
              if (prev != null) {
                ft.remove(prev);
              }
              ft.addToBackStack(null);
              DialogFragment newFragment=GroupDialogList.newInstance(""String_Node_Str"");
              GroupDialogList.setGroup(null);
              newFragment.show(ft,""String_Node_Str"");
            }
          }
);
        }
      }
;
      handler.post(addButtonRunnable);
    }
  }
).start();
  alert.setView(v);
  return alert.create();
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder alert=new AlertDialog.Builder(getActivity()).setTitle(""String_Node_Str"").setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      Toast.makeText(HookMethods.SnapContext,""String_Node_Str"",Toast.LENGTH_LONG).show();
      onCancel(dialog);
      Groups.sendStoriesUpdateEvent();
    }
  }
);
  LinearLayout.LayoutParams linearparams=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT,LinearLayout.LayoutParams.WRAP_CONTENT);
  final LinearLayout v=new LinearLayout(HookMethods.SnapContext);
  v.setOrientation(LinearLayout.VERTICAL);
  v.setLayoutParams(linearparams);
  final Handler handler=new Handler(HookMethods.SnapContext.getMainLooper());
  new Thread(new Runnable(){
    @Override public void run(){
      File[] files=Groups.groupsDir.listFiles();
      if (files == null) {
        if (Groups.groupsDir.mkdir())         Logger.log(""String_Node_Str"",LogType.GROUPS);
 else         Logger.log(""String_Node_Str"",LogType.GROUPS);
        return;
      }
      Arrays.sort(files);
      List<String> al=new ArrayList<>();
      Set<Groups.Group> linkedHashSet=new LinkedHashSet<>();
      linkedHashSet.addAll(Groups.groups);
      Groups.groups.clear();
      Groups.groups.addAll(linkedHashSet);
      final int N=Groups.groups.size();
      final File[] finalFiles=files;
      for (int i=0; i < N; i++) {
        final int finalI=i;
        if (finalI >= finalFiles.length) {
          Logger.log(String.format(""String_Node_Str"",finalI,finalFiles.length - 1),LogType.GROUPS);
          break;
        }
        Runnable addRowsRunnable=new Runnable(){
          @Override public void run(){
            final TextView rowTextView=new TextView(HookMethods.context);
            rowTextView.setText(finalFiles[finalI].getName());
            rowTextView.setPadding(HookMethods.px(5),HookMethods.px(5),HookMethods.px(5),HookMethods.px(5));
            rowTextView.setTextSize(20);
            rowTextView.setTextColor(Color.BLACK);
            v.addView(rowTextView);
            rowTextView.setId(finalI);
            final int id_=rowTextView.getId();
            rowTextView.setOnClickListener(new View.OnClickListener(){
              public void onClick(              View view){
                FragmentTransaction ft=HookMethods.SnapContext.getFragmentManager().beginTransaction();
                Fragment prev=HookMethods.SnapContext.getFragmentManager().findFragmentByTag(""String_Node_Str"");
                if (prev != null) {
                  ft.remove(prev);
                }
                ft.addToBackStack(null);
                DialogFragment newFragment=GroupDialogList.newInstance((String)rowTextView.getText());
                Groups.readGroups();
                GroupDialogList.setGroup(Groups.groups.get(id_));
                newFragment.show(ft,""String_Node_Str"");
                Groups.sendStoriesUpdateEvent();
              }
            }
);
          }
        }
;
        handler.post(addRowsRunnable);
      }
      Runnable addButtonRunnable=new Runnable(){
        @Override public void run(){
          Button add=new Button(HookMethods.SnapContext);
          add.setText(""String_Node_Str"");
          add.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
          boolean shouldShowAdd=true;
          if (Groups.groups.size() == 3 && Preferences.getLicence() == 0)           shouldShowAdd=false;
          if (Preferences.getLicence() != 0 && !Preferences.getBool(Prefs.UNLIM_GROUPS))           shouldShowAdd=false;
          if (shouldShowAdd)           v.addView(add);
          add.setOnClickListener(new View.OnClickListener(){
            @Override public void onClick(            View view){
              FragmentTransaction ft=HookMethods.SnapContext.getFragmentManager().beginTransaction();
              Fragment prev=HookMethods.SnapContext.getFragmentManager().findFragmentByTag(""String_Node_Str"");
              if (prev != null) {
                ft.remove(prev);
              }
              ft.addToBackStack(null);
              DialogFragment newFragment=GroupDialogList.newInstance(""String_Node_Str"");
              GroupDialogList.setGroup(null);
              newFragment.show(ft,""String_Node_Str"");
            }
          }
);
        }
      }
;
      handler.post(addButtonRunnable);
    }
  }
).start();
  alert.setView(v);
  return alert.create();
}","The original code lacked proper error handling when creating the groups directory and risked array index out-of-bounds exceptions when iterating through files. The fixed code adds explicit null checks, logs directory creation attempts, and includes a safeguard to prevent index overflow by breaking the loop if the file index exceeds array bounds. These changes enhance robustness by preventing potential crashes and providing better logging for debugging, making the code more resilient and predictable during group management operations."
94073,"@Override public void run(){
  Button add=new Button(HookMethods.SnapContext);
  add.setText(""String_Node_Str"");
  add.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
  boolean shouldShowAdd=true;
  if (Groups.groups.size() == 3 && Preferences.getLicence() == 0) {
    shouldShowAdd=false;
  }
  if (Preferences.getLicence() != 0 && !Preferences.getBool(Prefs.UNLIM_GROUPS)) {
    shouldShowAdd=false;
  }
  if (shouldShowAdd) {
    v.addView(add);
  }
  add.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      FragmentTransaction ft=HookMethods.SnapContext.getFragmentManager().beginTransaction();
      Fragment prev=HookMethods.SnapContext.getFragmentManager().findFragmentByTag(""String_Node_Str"");
      if (prev != null) {
        ft.remove(prev);
      }
      ft.addToBackStack(null);
      DialogFragment newFragment=GroupDialogList.newInstance(""String_Node_Str"");
      GroupDialogList.setGroup(null);
      newFragment.show(ft,""String_Node_Str"");
    }
  }
);
}","@Override public void run(){
  Button add=new Button(HookMethods.SnapContext);
  add.setText(""String_Node_Str"");
  add.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
  boolean shouldShowAdd=true;
  if (Groups.groups.size() == 3 && Preferences.getLicence() == 0)   shouldShowAdd=false;
  if (Preferences.getLicence() != 0 && !Preferences.getBool(Prefs.UNLIM_GROUPS))   shouldShowAdd=false;
  if (shouldShowAdd)   v.addView(add);
  add.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      FragmentTransaction ft=HookMethods.SnapContext.getFragmentManager().beginTransaction();
      Fragment prev=HookMethods.SnapContext.getFragmentManager().findFragmentByTag(""String_Node_Str"");
      if (prev != null) {
        ft.remove(prev);
      }
      ft.addToBackStack(null);
      DialogFragment newFragment=GroupDialogList.newInstance(""String_Node_Str"");
      GroupDialogList.setGroup(null);
      newFragment.show(ft,""String_Node_Str"");
    }
  }
);
}","The original code had unnecessary line breaks and complex boolean logic with multiple conditions, making it less readable and potentially error-prone. The fixed code simplifies the conditional statements by removing unnecessary line breaks and condensing the boolean checks into more concise, single-line statements. These changes improve code readability, maintainability, and make the logic more straightforward without altering the underlying functionality of controlling the visibility of the add button."
94074,"public static void readGroups(){
  new Thread(new Runnable(){
    @Override public void run(){
      File groupFolder=groupsDir;
      if (!groupFolder.exists()) {
        groupFolder.mkdir();
      }
      File[] groupFiles=groupFolder.listFiles();
      if (groupFiles == null || groupFiles.length == 0) {
        groups.clear();
        return;
      }
      groups.clear();
      int numGroups=0;
      for (      File group : groupFiles) {
        String data=FileUtils.readFromSD(group);
        if (!data.equalsIgnoreCase(""String_Node_Str"")) {
          String[] groupData=data.split(""String_Node_Str"");
          String name=groupData[0];
          ArrayList<String> users=new ArrayList<>(Arrays.asList(groupData));
          users.remove(0);
          Group currentGroup=new Group(name,users);
          if (numGroups == 3 && Preferences.getLicence() == 0) {
            NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGTH_SHORT,HookMethods.classLoader);
            return;
          }
          if (Preferences.getLicence() != 0 && !Preferences.getBool(Preferences.Prefs.UNLIM_GROUPS) && numGroups > 3) {
            NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGTH_SHORT,HookMethods.classLoader);
            return;
          }
          if (!groups.contains(currentGroup)) {
            groups.add(currentGroup);
            numGroups++;
          }
        }
      }
      Collections.sort(groups,new Groups.groupComparator());
    }
  }
).start();
}","public static void readGroups(){
  new Thread(new Runnable(){
    @Override public void run(){
      File groupFolder=groupsDir;
      if (!groupFolder.exists()) {
        groupFolder.mkdir();
      }
      File[] groupFiles=groupFolder.listFiles();
      if (groupFiles == null || groupFiles.length == 0) {
        groups.clear();
        return;
      }
      groups.clear();
      int numGroups=0;
      for (      File group : groupFiles) {
        String data=FileUtils.readFromSD(group);
        if (!data.equalsIgnoreCase(""String_Node_Str"")) {
          String[] groupData=data.split(""String_Node_Str"");
          String name=groupData[0];
          ArrayList<String> users=new ArrayList<>(Arrays.asList(groupData));
          users.remove(0);
          Group currentGroup=new Group(name,users);
          if (numGroups == 3 && Preferences.getLicence() == 0) {
            NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGTH_SHORT,HookMethods.classLoader);
            return;
          }
          if (Preferences.getLicence() != 0 && !Preferences.getBool(Preferences.Prefs.UNLIM_GROUPS) && numGroups > 3) {
            NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGTH_SHORT,HookMethods.classLoader);
            return;
          }
          if (!groups.add(currentGroup))           numGroups++;
        }
      }
      Collections.sort(groups,new Groups.groupComparator());
    }
  }
).start();
}","The original code incorrectly checked group addition using `!groups.contains(currentGroup)`, which could potentially add duplicate groups and increment `numGroups` inconsistently. The fixed code replaces this with `!groups.add(currentGroup)`, which directly attempts to add the group and increments `numGroups` only if the addition is successful. This change ensures more reliable group tracking, preventing duplicate entries and maintaining accurate group count while leveraging the `Set`-like behavior of the `add()` method."
94075,"@Override public void run(){
  File groupFolder=groupsDir;
  if (!groupFolder.exists()) {
    groupFolder.mkdir();
  }
  File[] groupFiles=groupFolder.listFiles();
  if (groupFiles == null || groupFiles.length == 0) {
    groups.clear();
    return;
  }
  groups.clear();
  int numGroups=0;
  for (  File group : groupFiles) {
    String data=FileUtils.readFromSD(group);
    if (!data.equalsIgnoreCase(""String_Node_Str"")) {
      String[] groupData=data.split(""String_Node_Str"");
      String name=groupData[0];
      ArrayList<String> users=new ArrayList<>(Arrays.asList(groupData));
      users.remove(0);
      Group currentGroup=new Group(name,users);
      if (numGroups == 3 && Preferences.getLicence() == 0) {
        NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGTH_SHORT,HookMethods.classLoader);
        return;
      }
      if (Preferences.getLicence() != 0 && !Preferences.getBool(Preferences.Prefs.UNLIM_GROUPS) && numGroups > 3) {
        NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGTH_SHORT,HookMethods.classLoader);
        return;
      }
      if (!groups.contains(currentGroup)) {
        groups.add(currentGroup);
        numGroups++;
      }
    }
  }
  Collections.sort(groups,new Groups.groupComparator());
}","@Override public void run(){
  File groupFolder=groupsDir;
  if (!groupFolder.exists()) {
    groupFolder.mkdir();
  }
  File[] groupFiles=groupFolder.listFiles();
  if (groupFiles == null || groupFiles.length == 0) {
    groups.clear();
    return;
  }
  groups.clear();
  int numGroups=0;
  for (  File group : groupFiles) {
    String data=FileUtils.readFromSD(group);
    if (!data.equalsIgnoreCase(""String_Node_Str"")) {
      String[] groupData=data.split(""String_Node_Str"");
      String name=groupData[0];
      ArrayList<String> users=new ArrayList<>(Arrays.asList(groupData));
      users.remove(0);
      Group currentGroup=new Group(name,users);
      if (numGroups == 3 && Preferences.getLicence() == 0) {
        NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGTH_SHORT,HookMethods.classLoader);
        return;
      }
      if (Preferences.getLicence() != 0 && !Preferences.getBool(Preferences.Prefs.UNLIM_GROUPS) && numGroups > 3) {
        NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGTH_SHORT,HookMethods.classLoader);
        return;
      }
      if (!groups.add(currentGroup))       numGroups++;
    }
  }
  Collections.sort(groups,new Groups.groupComparator());
}","The original code incorrectly increments `numGroups` before checking if the group is unique, potentially overcounting groups and triggering license restrictions prematurely. The fixed code replaces `groups.add(currentGroup)` with a conditional increment of `numGroups`, ensuring that only new, unique groups are counted. This modification prevents duplicate group counting and more accurately tracks the number of groups, maintaining the intended license-based group limitation logic."
94076,"public static void initGroups(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {
  readGroups();
  final Class<?> Friend=findClass(Obfuscator.select.FRIEND_CLASS,lpparam.classLoader);
  final Class<?> Ly=findClass(Obfuscator.groups.STORY_CLASS,lpparam.classLoader);
  XposedHelpers.findAndHookMethod(Obfuscator.groups.STORYARRAY_CLASS,lpparam.classLoader,Obfuscator.groups.STORYARRAY_METHOD,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      readGroups();
      ArrayList result=(ArrayList)param.getResult();
      ArrayList newResult=new ArrayList();
      Object edit=XposedHelpers.newInstance(Ly,""String_Node_Str"",""String_Node_Str"");
      XposedHelpers.setAdditionalInstanceField(edit,""String_Node_Str"",true);
      if (!result.contains(edit)) {
        newResult.add(edit);
      }
      for (      Group g : groups) {
        Object group=XposedHelpers.newInstance(Ly,""String_Node_Str"" + g.name,g.name);
        XposedHelpers.setAdditionalInstanceField(group,""String_Node_Str"",g);
        if (!result.contains(group)) {
          newResult.add(group);
        }
      }
      newResult.addAll(result);
      param.setResult(newResult);
    }
  }
);
  XposedHelpers.findAndHookMethod(Obfuscator.groups.STORYSECTION_CLASS,lpparam.classLoader,""String_Node_Str"",findClass(""String_Node_Str"",lpparam.classLoader),int.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    final MethodHookParam param) throws Throwable {
      Object element=callMethod(XposedHelpers.getObjectField(param.thisObject,""String_Node_Str""),""String_Node_Str"",param.args[1]);
      if (XposedHelpers.getAdditionalInstanceField(element,""String_Node_Str"") != null) {
        CheckBox k=(CheckBox)XposedHelpers.getObjectField(param.args[0],""String_Node_Str"");
        k.setVisibility(View.GONE);
        k.setOnCheckedChangeListener(null);
        k.setOnClickListener(null);
        ((View)XposedHelpers.getObjectField(param.args[0],""String_Node_Str"")).setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            FragmentTransaction ft=HookMethods.SnapContext.getFragmentManager().beginTransaction();
            Fragment prev=HookMethods.SnapContext.getFragmentManager().findFragmentByTag(""String_Node_Str"");
            if (prev != null) {
              ft.remove(prev);
            }
            ft.addToBackStack(null);
            DialogFragment newFragment=GroupDialog.newInstance();
            newFragment.show(ft,""String_Node_Str"");
          }
        }
);
      }
      final Group group=(Group)XposedHelpers.getAdditionalInstanceField(element,""String_Node_Str"");
      if (group == null)       return;
      HashMap<String,Boolean> checks=(HashMap<String,Boolean>)XposedHelpers.getAdditionalInstanceField(param.thisObject,""String_Node_Str"");
      if (checks == null) {
        checks=new HashMap<>();
        XposedHelpers.setAdditionalInstanceField(param.thisObject,""String_Node_Str"",checks);
      }
      final CheckBox check=(CheckBox)XposedHelpers.getObjectField(param.args[0],""String_Node_Str"");
      if (!checks.containsKey(group.name)) {
        checks.put(group.name,false);
      }
 else {
        check.setOnCheckedChangeListener(null);
        check.setChecked(checks.get(group.name));
      }
      final HashMap<String,Boolean> finalChecks=checks;
      check.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
        @Override public void onCheckedChanged(        CompoundButton buttonView,        boolean isChecked){
          finalChecks.put(group.name,isChecked);
          List f=(List)XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"");
          for (          String user : group.users) {
            for (            Object ii : f) {
              if (Friend.isInstance(ii) && ((String)XposedHelpers.getObjectField(ii,""String_Node_Str"")).equalsIgnoreCase(user)) {
                callMethod(XposedHelpers.getObjectField(param.thisObject,""String_Node_Str""),""String_Node_Str"",new Class[]{int.class,findClass(Obfuscator.groups.INTERFACE,lpparam.classLoader),boolean.class},callMethod(param.args[0],""String_Node_Str""),ii,isChecked);
                break;
              }
            }
          }
        }
      }
);
    }
  }
);
}","public static void initGroups(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {
  readGroups();
  final Class<?> Friend=findClass(Obfuscator.select.FRIEND_CLASS,lpparam.classLoader);
  final Class<?> Ly=findClass(Obfuscator.groups.STORY_CLASS,lpparam.classLoader);
  XposedHelpers.findAndHookMethod(Obfuscator.groups.STORYARRAY_CLASS,lpparam.classLoader,Obfuscator.groups.STORYARRAY_METHOD,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      readGroups();
      ArrayList result=(ArrayList)param.getResult();
      ArrayList<Object> newResult=new ArrayList<>();
      Object edit=XposedHelpers.newInstance(Ly,""String_Node_Str"",""String_Node_Str"");
      XposedHelpers.setAdditionalInstanceField(edit,""String_Node_Str"",true);
      if (!result.contains(edit))       newResult.add(edit);
      for (      Group g : groups) {
        Object group=XposedHelpers.newInstance(Ly,""String_Node_Str"" + g.name,g.name);
        XposedHelpers.setAdditionalInstanceField(group,""String_Node_Str"",g);
        if (!result.contains(group))         newResult.add(group);
      }
      newResult.addAll(result);
      param.setResult(newResult);
    }
  }
);
  XposedHelpers.findAndHookMethod(Obfuscator.groups.STORYSECTION_CLASS,lpparam.classLoader,""String_Node_Str"",findClass(""String_Node_Str"",lpparam.classLoader),int.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    final MethodHookParam param) throws Throwable {
      Object element=callMethod(XposedHelpers.getObjectField(param.thisObject,""String_Node_Str""),""String_Node_Str"",param.args[1]);
      if (XposedHelpers.getAdditionalInstanceField(element,""String_Node_Str"") != null) {
        CheckBox k=(CheckBox)XposedHelpers.getObjectField(param.args[0],""String_Node_Str"");
        k.setVisibility(View.GONE);
        k.setOnCheckedChangeListener(null);
        k.setOnClickListener(null);
        ((View)XposedHelpers.getObjectField(param.args[0],""String_Node_Str"")).setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            FragmentTransaction ft=HookMethods.SnapContext.getFragmentManager().beginTransaction();
            Fragment prev=HookMethods.SnapContext.getFragmentManager().findFragmentByTag(""String_Node_Str"");
            if (prev != null) {
              ft.remove(prev);
            }
            ft.addToBackStack(null);
            DialogFragment newFragment=GroupDialog.newInstance();
            newFragment.show(ft,""String_Node_Str"");
          }
        }
);
      }
      final Group group=(Group)XposedHelpers.getAdditionalInstanceField(element,""String_Node_Str"");
      if (group == null)       return;
      HashMap<String,Boolean> checks=(HashMap<String,Boolean>)XposedHelpers.getAdditionalInstanceField(param.thisObject,""String_Node_Str"");
      if (checks == null) {
        checks=new HashMap<>();
        XposedHelpers.setAdditionalInstanceField(param.thisObject,""String_Node_Str"",checks);
      }
      final CheckBox check=(CheckBox)XposedHelpers.getObjectField(param.args[0],""String_Node_Str"");
      if (!checks.containsKey(group.name)) {
        checks.put(group.name,false);
      }
 else {
        check.setOnCheckedChangeListener(null);
        check.setChecked(checks.get(group.name));
      }
      final HashMap<String,Boolean> finalChecks=checks;
      check.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
        @Override public void onCheckedChanged(        CompoundButton buttonView,        boolean isChecked){
          finalChecks.put(group.name,isChecked);
          List f=(List)XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"");
          for (          String user : group.users) {
            for (            Object ii : f) {
              if (Friend.isInstance(ii) && ((String)XposedHelpers.getObjectField(ii,""String_Node_Str"")).equalsIgnoreCase(user)) {
                callMethod(XposedHelpers.getObjectField(param.thisObject,""String_Node_Str""),""String_Node_Str"",new Class[]{int.class,findClass(Obfuscator.groups.INTERFACE,lpparam.classLoader),boolean.class},callMethod(param.args[0],""String_Node_Str""),ii,isChecked);
                break;
              }
            }
          }
        }
      }
);
    }
  }
);
}","The original code had an unchecked ArrayList without type specification, which could lead to potential runtime type casting errors. The fixed code explicitly declares the ArrayList as `ArrayList<Object>`, providing type safety and preventing potential ClassCastExceptions during runtime. By adding explicit type generics, the code becomes more robust, enabling better compile-time type checking and reducing the risk of unexpected type-related runtime errors."
94077,"@Override public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  try {
    if (!lpparam.packageName.equals(Common.PACKAGE_SNAP))     return;
    try {
      XposedUtils.log(""String_Node_Str"",false);
      Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
      context=(Context)callMethod(activityThread,""String_Node_Str"");
      classLoader=lpparam.classLoader;
      PackageInfo piSnapChat=context.getPackageManager().getPackageInfo(lpparam.packageName,0);
      XposedUtils.log(""String_Node_Str"" + piSnapChat.versionName + ""String_Node_Str""+ piSnapChat.versionCode+ ""String_Node_Str"",false);
      XposedUtils.log(""String_Node_Str"" + BuildConfig.VERSION_NAME + ""String_Node_Str""+ BuildConfig.VERSION_CODE+ ""String_Node_Str"",false);
      if (!Obfuscator.isSupported(piSnapChat.versionCode)) {
        Logger.log(""String_Node_Str"",true,true);
        Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        return;
      }
    }
 catch (    Exception e) {
      XposedUtils.log(""String_Node_Str"",e);
      return;
    }
    Logger.loadSelectedLogTypes();
    Logger.log(""String_Node_Str"");
    Preferences.loadMapFromXposed();
    findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",int.class,new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param){
        Logger.printFinalMessage(""String_Node_Str"" + param.args[0]);
        param.args[0]=12000000;
      }
    }
);
    final int maxRecordTime=30000;
    if (maxRecordTime > 10000) {
      try {
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Message.class,new XC_MethodHook(){
          boolean internallyCalled=false;
          @Override protected void beforeHookedMethod(          MethodHookParam param) throws Throwable {
            super.beforeHookedMethod(param);
            Message message=(Message)param.args[0];
            Logger.log(""String_Node_Str"" + message.what);
            if (message.what == 15 && !internallyCalled) {
              if (maxRecordTime > 10000) {
                internallyCalled=true;
                Handler handler=message.getTarget();
                Message newMessage=Message.obtain(handler,15);
                handler.sendMessageDelayed(newMessage,maxRecordTime - 10000);
                Logger.log(String.format(""String_Node_Str"",maxRecordTime - 10000));
              }
              param.setResult(null);
            }
 else             if (internallyCalled)             internallyCalled=false;
          }
        }
);
      }
 catch (      Throwable t) {
        Logger.log(""String_Node_Str"",t,LogType.FORCED);
      }
    }
    findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Context.class,new XC_MethodHook(){
      @Override protected void afterHookedMethod(      MethodHookParam param) throws Throwable {
        Friendmojis.init(lpparam);
        DebugHelper.init(lpparam);
        Logger.log(""String_Node_Str"" + param.thisObject.getClass().getCanonicalName());
        XC_MethodHook initHook=new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param) throws Throwable {
            SnapContext=(Activity)param.thisObject;
            if (!Preferences.getBool(Prefs.ACCEPTED_TOU)) {
              AlertDialog.Builder builder=new AlertDialog.Builder(SnapContext).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setIcon(android.R.drawable.ic_dialog_alert);
              builder.setCancelable(false);
              final AlertDialog dialog=builder.create();
              dialog.setCanceledOnTouchOutside(false);
              dialog.show();
              return;
            }
            boolean isNull=SnapContext == null;
            Logger.log(""String_Node_Str"" + isNull,true);
            Saving.initSaving(lpparam,mResources,SnapContext);
            Lens.initLens(lpparam,mResources,SnapContext);
            File vfilters=new File(Preferences.getExternalPath() + ""String_Node_Str"");
            if (vfilters.exists()) {
              VisualFilters.initVisualFilters(lpparam);
            }
 else {
              Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
            }
            if (Preferences.getBool(Prefs.HIDE_LIVE) || Preferences.getBool(Prefs.HIDE_PEOPLE) || Preferences.getBool(Prefs.DISCOVER_UI)) {
              Stories.initStories(lpparam);
            }
            Groups.initGroups(lpparam);
            if (Preferences.shouldAddGhost()) {
              HookedLayouts.initVisiblity(lpparam);
            }
            if (Preferences.getBool(Prefs.MULTI_FILTER)) {
              MultiFilter.initMultiFilter(lpparam,mResources,SnapContext);
            }
            if (Preferences.getBool(Prefs.DISCOVER_SNAP)) {
              DataSaving.blockDsnap(lpparam);
            }
            if (Preferences.getBool(Prefs.STORY_PRELOAD)) {
              DataSaving.blockStoryPreLoad(lpparam);
            }
            if (Preferences.getBool(Prefs.DISCOVER_UI)) {
              DataSaving.blockFromUi(lpparam);
            }
            if (Preferences.getBool(Prefs.SPEED)) {
              Spoofing.initSpeed(lpparam,SnapContext);
            }
            if (Preferences.getBool(Prefs.LOCATION)) {
              Spoofing.initLocation(lpparam,SnapContext);
            }
            if (Preferences.getBool(Prefs.WEATHER)) {
              Spoofing.initWeather(lpparam,SnapContext);
            }
            if (Preferences.getBool(Prefs.PAINT_TOOLS)) {
              PaintTools.initPaint(lpparam,mResources);
            }
            if (Preferences.getBool(Prefs.TIMER_COUNTER)) {
              Misc.initTimer(lpparam,mResources);
            }
            ClassLoader cl=lpparam.classLoader;
            if (Preferences.getBool(Prefs.CHAT_AUTO_SAVE)) {
              Chat.initTextSave(lpparam,SnapContext);
            }
            if (Preferences.getBool(Prefs.CHAT_LOGGING))             Chat.initChatLogging(lpparam,SnapContext);
            if (Preferences.getBool(Prefs.CHAT_MEDIA_SAVE)) {
              Chat.initImageSave(lpparam,mResources);
            }
            if (Preferences.getBool(Prefs.INTEGRATION)) {
              HookedLayouts.initIntegration(lpparam,mResources);
            }
            Misc.forceNavBar(lpparam,Preferences.getInt(Prefs.FORCE_NAVBAR));
            getEditText(lpparam);
            findAndHookMethod(Obfuscator.save.SCREENSHOTDETECTOR_CLASS,lpparam.classLoader,Obfuscator.save.SCREENSHOTDETECTOR_RUN,LinkedHashMap.class,XC_MethodReplacement.DO_NOTHING);
            findAndHookMethod(Obfuscator.save.SNAPSTATEMESSAGE_CLASS,lpparam.classLoader,Obfuscator.save.SNAPSTATEMESSAGE_SETSCREENSHOTCOUNT,Long.class,new XC_MethodHook(){
              @Override protected void beforeHookedMethod(              MethodHookParam param){
                param.args[0]=0L;
                Logger.log(""String_Node_Str"",true);
              }
            }
);
            if (Preferences.getBool(Prefs.CUSTOM_STICKER)) {
              Stickers.initStickers(lpparam,modRes,SnapContext);
            }
            if (Preferences.getLicence() > 0)             Premium.initPremium(lpparam);
            findAndHookMethod(""String_Node_Str"",cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),new XC_MethodHook(){
              @Override protected void beforeHookedMethod(              MethodHookParam param) throws Throwable {
                super.beforeHookedMethod(param);
                Logger.log(""String_Node_Str"" + param.args[0].toString());
              }
            }
);
            findAndHookMethod(""String_Node_Str"",cl,""String_Node_Str"",findClass(""String_Node_Str"",cl),findClass(""String_Node_Str"",cl),new XC_MethodHook(){
              @Override protected void beforeHookedMethod(              MethodHookParam param) throws Throwable {
                super.beforeHookedMethod(param);
                Object packet=param.args[0];
                Logger.log(""String_Node_Str"" + packet.toString(),LogType.PREMIUM);
              }
            }
);
            HookMethods.hookAllMethods(""String_Node_Str"",cl,false,false);
            HookMethods.hookAllMethods(""String_Node_Str"",cl,false,false);
          }
        }
;
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Bundle.class,initHook);
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",initHook);
        for (        String s : Obfuscator.ROOTDETECTOR_METHODS) {
          findAndHookMethod(Obfuscator.ROOTDETECTOR_CLASS,lpparam.classLoader,s,XC_MethodReplacement.returnConstant(false));
          Logger.log(""String_Node_Str"" + s,true);
        }
        final Class<?> receivedSnapClass=findClass(Obfuscator.save.RECEIVEDSNAP_CLASS,lpparam.classLoader);
        try {
          XposedHelpers.setStaticIntField(receivedSnapClass,""String_Node_Str"",99999);
          final Class<?> snapMediaUtils=findClass(""String_Node_Str"",lpparam.classLoader);
          XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
          XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
          final Class<?> profileImageUtils=findClass(""String_Node_Str"",lpparam.classLoader);
          XposedHelpers.setStaticIntField(profileImageUtils,""String_Node_Str"",100);
          final Class<?> snapImageBryo=findClass(Obfuscator.save.SNAPIMAGEBRYO_CLASS,lpparam.classLoader);
          XposedHelpers.setStaticIntField(snapImageBryo,""String_Node_Str"",100);
          Logger.log(""String_Node_Str"",true);
        }
 catch (        Throwable t) {
          Logger.log(""String_Node_Str"",true);
          Logger.log(t.toString());
        }
        if (Preferences.getBool(Prefs.CAPTION_UNLIMITED_VANILLA)) {
          XposedHelpers.findAndHookMethod(Obfuscator.misc.CAPTIONVIEW,lpparam.classLoader,Obfuscator.misc.CAPTIONVIEW_TEXT_LIMITER,int.class,new XC_MethodHook(){
            @Override protected void beforeHookedMethod(            MethodHookParam param) throws Throwable {
              param.args[0]=999999999;
            }
          }
);
        }
        String snapCaptionView=""String_Node_Str"";
        hookAllConstructors(findClass(snapCaptionView,lpparam.classLoader),new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if (Preferences.getBool(Prefs.CAPTION_UNLIMITED_VANILLA)) {
              XposedUtils.log(""String_Node_Str"");
              EditText vanillaCaptionEditText=(EditText)param.thisObject;
              vanillaCaptionEditText.setSingleLine(false);
              vanillaCaptionEditText.setFilters(new InputFilter[0]);
              vanillaCaptionEditText.setImeOptions(EditorInfo.IME_ACTION_NONE);
              vanillaCaptionEditText.setOnEditorActionListener(null);
              setObjectField(vanillaCaptionEditText,""String_Node_Str"",null);
            }
          }
        }
);
        XposedHelpers.findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",EditorInfo.class,new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param) throws Throwable {
            if (Preferences.getBool(Prefs.CAPTION_UNLIMITED_VANILLA)) {
              XposedUtils.log(""String_Node_Str"");
              EditorInfo editorInfo=(EditorInfo)param.args[0];
              editorInfo.imeOptions=EditorInfo.IME_ACTION_NONE;
            }
          }
        }
);
        XposedHelpers.findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",TextView.class,int.class,KeyEvent.class,new XC_MethodHook(){
          @Override protected void beforeHookedMethod(          MethodHookParam param) throws Throwable {
            Logger.printFinalMessage(""String_Node_Str"" + param.args[1]);
          }
        }
);
        Sharing.initSharing(lpparam,mResources);
        if (Preferences.getBool(Prefs.HIDE_BF)) {
          findAndHookMethod(""String_Node_Str"",lpparam.classLoader,Obfuscator.FRIENDS_BF,new XC_MethodReplacement(){
            @Override protected Object replaceHookedMethod(            MethodHookParam param){
              return false;
            }
          }
);
        }
        if (Preferences.getBool(Prefs.CUSTOM_FILTER)) {
          addFilter(lpparam);
        }
        if (Preferences.getBool(Prefs.SELECT_ALL)) {
          HookSendList.initSelectAll(lpparam);
        }
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",XposedHelpers.findClass(Obfuscator.flash.KEYEVENT_CLASS,lpparam.classLoader),new XC_MethodHook(){
          public boolean frontFlash=false;
          public long lastChange=System.currentTimeMillis();
          @Override protected void beforeHookedMethod(          MethodHookParam param) throws Throwable {
            boolean isVisible=XposedHelpers.getBooleanField(param.thisObject,Obfuscator.flash.ISVISIBLE_FIELD);
            Object swipeLayout=getObjectField(param.thisObject,Obfuscator.flash.SWIPELAYOUT_FIELD);
            int resId=(int)getObjectField(swipeLayout,Obfuscator.flash.GETRESID_OBJECT);
            boolean c=(boolean)XposedHelpers.callMethod(swipeLayout,Obfuscator.flash.ISSCROLLED_METHOD);
            if (isVisible && resId != 0 && resId != 2 && !c) {
              int keycode=XposedHelpers.getIntField(param.args[0],Obfuscator.flash.KEYCODE_FIELD);
              if (keycode == KeyEvent.KEYCODE_VOLUME_UP) {
                if (System.currentTimeMillis() - lastChange > 500) {
                  lastChange=System.currentTimeMillis();
                  frontFlash=!frontFlash;
                  XposedHelpers.callMethod(getObjectField(param.thisObject,Obfuscator.flash.OVERLAY_FIELD),Obfuscator.flash.FLASH_METHOD,new Class[]{boolean.class},frontFlash);
                }
                param.setResult(null);
              }
            }
          }
        }
);
        if (Preferences.getBool(Prefs.AUTO_ADVANCE))         XposedHelpers.findAndHookMethod(Obfuscator.stories.AUTOADVANCE_CLASS,lpparam.classLoader,Obfuscator.stories.AUTOADVANCE_METHOD,XC_MethodReplacement.returnConstant(false));
      }
    }
);
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"",e);
  }
}","@Override public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  try {
    if (!lpparam.packageName.equals(Common.PACKAGE_SNAP))     return;
    try {
      XposedUtils.log(""String_Node_Str"",false);
      Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
      context=(Context)callMethod(activityThread,""String_Node_Str"");
      classLoader=lpparam.classLoader;
      PackageInfo piSnapChat=context.getPackageManager().getPackageInfo(lpparam.packageName,0);
      XposedUtils.log(""String_Node_Str"" + piSnapChat.versionName + ""String_Node_Str""+ piSnapChat.versionCode+ ""String_Node_Str"",false);
      XposedUtils.log(""String_Node_Str"" + BuildConfig.VERSION_NAME + ""String_Node_Str""+ BuildConfig.VERSION_CODE+ ""String_Node_Str"",false);
      if (!Obfuscator.isSupported(piSnapChat.versionCode)) {
        Logger.log(""String_Node_Str"",true,true);
        Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        return;
      }
    }
 catch (    Exception e) {
      XposedUtils.log(""String_Node_Str"",e);
      return;
    }
    Logger.loadSelectedLogTypes();
    Logger.log(""String_Node_Str"");
    Preferences.loadMapFromXposed();
    findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",int.class,new XC_MethodHook(){
      @Override protected void beforeHookedMethod(      MethodHookParam param){
        Logger.printFinalMessage(""String_Node_Str"" + param.args[0]);
        param.args[0]=12000000;
      }
    }
);
    final int maxRecordTime=30000;
    if (maxRecordTime > 10000) {
      try {
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Message.class,new XC_MethodHook(){
          boolean internallyCalled=false;
          @Override protected void beforeHookedMethod(          MethodHookParam param) throws Throwable {
            super.beforeHookedMethod(param);
            Message message=(Message)param.args[0];
            Logger.log(""String_Node_Str"" + message.what);
            if (message.what == 15 && !internallyCalled) {
              if (maxRecordTime > 10000) {
                internallyCalled=true;
                Handler handler=message.getTarget();
                Message newMessage=Message.obtain(handler,15);
                handler.sendMessageDelayed(newMessage,maxRecordTime - 10000);
                Logger.log(String.format(""String_Node_Str"",maxRecordTime - 10000));
              }
              param.setResult(null);
            }
 else             if (internallyCalled)             internallyCalled=false;
          }
        }
);
      }
 catch (      Throwable t) {
        Logger.log(""String_Node_Str"",t,LogType.FORCED);
      }
    }
    findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Context.class,new XC_MethodHook(){
      @Override protected void afterHookedMethod(      MethodHookParam param) throws Throwable {
        Friendmojis.init(lpparam);
        DebugHelper.init(lpparam);
        Logger.log(""String_Node_Str"" + param.thisObject.getClass().getCanonicalName());
        XC_MethodHook initHook=new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param) throws Throwable {
            SnapContext=(Activity)param.thisObject;
            if (!Preferences.getBool(Prefs.ACCEPTED_TOU)) {
              AlertDialog.Builder builder=new AlertDialog.Builder(SnapContext).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setIcon(android.R.drawable.ic_dialog_alert);
              builder.setCancelable(false);
              final AlertDialog dialog=builder.create();
              dialog.setCanceledOnTouchOutside(false);
              dialog.show();
              return;
            }
            boolean isNull=SnapContext == null;
            Logger.log(""String_Node_Str"" + isNull,true);
            Saving.initSaving(lpparam,mResources,SnapContext);
            Lens.initLens(lpparam,mResources,SnapContext);
            File vfilters=new File(Preferences.getExternalPath() + ""String_Node_Str"");
            if (vfilters.exists()) {
              VisualFilters.initVisualFilters(lpparam);
            }
 else {
              Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
            }
            if (Preferences.getBool(Prefs.HIDE_LIVE) || Preferences.getBool(Prefs.HIDE_PEOPLE) || Preferences.getBool(Prefs.DISCOVER_UI)) {
              Stories.initStories(lpparam);
            }
            if (Preferences.getBool(Prefs.GROUPS)) {
              Groups.initGroups(lpparam);
            }
            if (Preferences.shouldAddGhost()) {
              HookedLayouts.initVisiblity(lpparam);
            }
            if (Preferences.getBool(Prefs.MULTI_FILTER)) {
              MultiFilter.initMultiFilter(lpparam,mResources,SnapContext);
            }
            if (Preferences.getBool(Prefs.DISCOVER_SNAP)) {
              DataSaving.blockDsnap(lpparam);
            }
            if (Preferences.getBool(Prefs.STORY_PRELOAD)) {
              DataSaving.blockStoryPreLoad(lpparam);
            }
            if (Preferences.getBool(Prefs.DISCOVER_UI)) {
              DataSaving.blockFromUi(lpparam);
            }
            if (Preferences.getBool(Prefs.SPEED)) {
              Spoofing.initSpeed(lpparam,SnapContext);
            }
            if (Preferences.getBool(Prefs.LOCATION)) {
              Spoofing.initLocation(lpparam,SnapContext);
            }
            if (Preferences.getBool(Prefs.WEATHER)) {
              Spoofing.initWeather(lpparam,SnapContext);
            }
            if (Preferences.getBool(Prefs.PAINT_TOOLS)) {
              PaintTools.initPaint(lpparam,mResources);
            }
            if (Preferences.getBool(Prefs.TIMER_COUNTER)) {
              Misc.initTimer(lpparam,mResources);
            }
            ClassLoader cl=lpparam.classLoader;
            if (Preferences.getBool(Prefs.CHAT_AUTO_SAVE)) {
              Chat.initTextSave(lpparam,SnapContext);
            }
            if (Preferences.getBool(Prefs.CHAT_LOGGING))             Chat.initChatLogging(lpparam,SnapContext);
            if (Preferences.getBool(Prefs.CHAT_MEDIA_SAVE)) {
              Chat.initImageSave(lpparam,mResources);
            }
            if (Preferences.getBool(Prefs.INTEGRATION)) {
              HookedLayouts.initIntegration(lpparam,mResources);
            }
            Misc.forceNavBar(lpparam,Preferences.getInt(Prefs.FORCE_NAVBAR));
            getEditText(lpparam);
            findAndHookMethod(Obfuscator.save.SCREENSHOTDETECTOR_CLASS,lpparam.classLoader,Obfuscator.save.SCREENSHOTDETECTOR_RUN,LinkedHashMap.class,XC_MethodReplacement.DO_NOTHING);
            findAndHookMethod(Obfuscator.save.SNAPSTATEMESSAGE_CLASS,lpparam.classLoader,Obfuscator.save.SNAPSTATEMESSAGE_SETSCREENSHOTCOUNT,Long.class,new XC_MethodHook(){
              @Override protected void beforeHookedMethod(              MethodHookParam param){
                param.args[0]=0L;
                Logger.log(""String_Node_Str"",true);
              }
            }
);
            if (Preferences.getBool(Prefs.CUSTOM_STICKER)) {
              Stickers.initStickers(lpparam,modRes,SnapContext);
            }
            if (Preferences.getLicence() > 0)             Premium.initPremium(lpparam);
          }
        }
;
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Bundle.class,initHook);
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",initHook);
        for (        String s : Obfuscator.ROOTDETECTOR_METHODS) {
          findAndHookMethod(Obfuscator.ROOTDETECTOR_CLASS,lpparam.classLoader,s,XC_MethodReplacement.returnConstant(false));
          Logger.log(""String_Node_Str"" + s,true);
        }
        final Class<?> receivedSnapClass=findClass(Obfuscator.save.RECEIVEDSNAP_CLASS,lpparam.classLoader);
        try {
          XposedHelpers.setStaticIntField(receivedSnapClass,""String_Node_Str"",99999);
          final Class<?> snapMediaUtils=findClass(""String_Node_Str"",lpparam.classLoader);
          XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
          XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
          final Class<?> profileImageUtils=findClass(""String_Node_Str"",lpparam.classLoader);
          XposedHelpers.setStaticIntField(profileImageUtils,""String_Node_Str"",100);
          final Class<?> snapImageBryo=findClass(Obfuscator.save.SNAPIMAGEBRYO_CLASS,lpparam.classLoader);
          XposedHelpers.setStaticIntField(snapImageBryo,""String_Node_Str"",100);
          Logger.log(""String_Node_Str"",true);
        }
 catch (        Throwable t) {
          Logger.log(""String_Node_Str"",true);
          Logger.log(t.toString());
        }
        if (Preferences.getBool(Prefs.CAPTION_UNLIMITED_VANILLA)) {
          XposedHelpers.findAndHookMethod(Obfuscator.misc.CAPTIONVIEW,lpparam.classLoader,Obfuscator.misc.CAPTIONVIEW_TEXT_LIMITER,int.class,new XC_MethodHook(){
            @Override protected void beforeHookedMethod(            MethodHookParam param) throws Throwable {
              param.args[0]=999999999;
            }
          }
);
        }
        String snapCaptionView=""String_Node_Str"";
        hookAllConstructors(findClass(snapCaptionView,lpparam.classLoader),new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if (Preferences.getBool(Prefs.CAPTION_UNLIMITED_VANILLA)) {
              XposedUtils.log(""String_Node_Str"");
              EditText vanillaCaptionEditText=(EditText)param.thisObject;
              vanillaCaptionEditText.setSingleLine(false);
              vanillaCaptionEditText.setFilters(new InputFilter[0]);
              vanillaCaptionEditText.setImeOptions(EditorInfo.IME_ACTION_NONE);
              vanillaCaptionEditText.setOnEditorActionListener(null);
              setObjectField(vanillaCaptionEditText,""String_Node_Str"",null);
            }
          }
        }
);
        XposedHelpers.findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",EditorInfo.class,new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param) throws Throwable {
            if (Preferences.getBool(Prefs.CAPTION_UNLIMITED_VANILLA)) {
              XposedUtils.log(""String_Node_Str"");
              EditorInfo editorInfo=(EditorInfo)param.args[0];
              editorInfo.imeOptions=EditorInfo.IME_ACTION_NONE;
            }
          }
        }
);
        XposedHelpers.findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",TextView.class,int.class,KeyEvent.class,new XC_MethodHook(){
          @Override protected void beforeHookedMethod(          MethodHookParam param) throws Throwable {
            Logger.printFinalMessage(""String_Node_Str"" + param.args[1]);
          }
        }
);
        Sharing.initSharing(lpparam,mResources);
        if (Preferences.getBool(Prefs.HIDE_BF)) {
          findAndHookMethod(""String_Node_Str"",lpparam.classLoader,Obfuscator.FRIENDS_BF,new XC_MethodReplacement(){
            @Override protected Object replaceHookedMethod(            MethodHookParam param){
              return false;
            }
          }
);
        }
        if (Preferences.getBool(Prefs.CUSTOM_FILTER)) {
          addFilter(lpparam);
        }
        if (Preferences.getBool(Prefs.SELECT_ALL)) {
          HookSendList.initSelectAll(lpparam);
        }
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",XposedHelpers.findClass(Obfuscator.flash.KEYEVENT_CLASS,lpparam.classLoader),new XC_MethodHook(){
          public boolean frontFlash=false;
          public long lastChange=System.currentTimeMillis();
          @Override protected void beforeHookedMethod(          MethodHookParam param) throws Throwable {
            boolean isVisible=XposedHelpers.getBooleanField(param.thisObject,Obfuscator.flash.ISVISIBLE_FIELD);
            Object swipeLayout=getObjectField(param.thisObject,Obfuscator.flash.SWIPELAYOUT_FIELD);
            int resId=(int)getObjectField(swipeLayout,Obfuscator.flash.GETRESID_OBJECT);
            boolean c=(boolean)XposedHelpers.callMethod(swipeLayout,Obfuscator.flash.ISSCROLLED_METHOD);
            if (isVisible && resId != 0 && resId != 2 && !c) {
              int keycode=XposedHelpers.getIntField(param.args[0],Obfuscator.flash.KEYCODE_FIELD);
              if (keycode == KeyEvent.KEYCODE_VOLUME_UP) {
                if (System.currentTimeMillis() - lastChange > 500) {
                  lastChange=System.currentTimeMillis();
                  frontFlash=!frontFlash;
                  XposedHelpers.callMethod(getObjectField(param.thisObject,Obfuscator.flash.OVERLAY_FIELD),Obfuscator.flash.FLASH_METHOD,new Class[]{boolean.class},frontFlash);
                }
                param.setResult(null);
              }
            }
          }
        }
);
        if (Preferences.getBool(Prefs.AUTO_ADVANCE))         XposedHelpers.findAndHookMethod(Obfuscator.stories.AUTOADVANCE_CLASS,lpparam.classLoader,Obfuscator.stories.AUTOADVANCE_METHOD,XC_MethodReplacement.returnConstant(false));
      }
    }
);
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"",e);
  }
}","The original code unconditionally called Groups.initGroups() without checking if the Groups preference was enabled, potentially executing unnecessary initialization. The fixed code adds a conditional check `if (Preferences.getBool(Prefs.GROUPS))` before calling Groups.initGroups(), ensuring the method is only invoked when the user has explicitly enabled the Groups feature. This change improves code efficiency and prevents potential unintended method executions by respecting user preferences and reducing unnecessary runtime operations."
94078,"public static void addShareIcon(final XC_InitPackageResources.InitPackageResourcesParam resparam){
  try {
    resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
      public void handleLayoutInflated(      LayoutInflatedParam liparam) throws Throwable {
        final int padding=px(10f);
        final int topMargin=0;
        final int size=px((int)resparam.res.getDimension(resparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)));
        final RelativeLayout relativeLayout=(RelativeLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP));
        final RelativeLayout.LayoutParams layoutParams=new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);
        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT | RelativeLayout.ALIGN_PARENT_TOP);
        layoutParams.rightMargin=px(50);
        layoutParams.topMargin=topMargin;
        upload=new ImageButton(HookMethods.SnapContext);
        upload.setLayoutParams(layoutParams);
        upload.setPadding(padding,padding,padding,padding);
        upload.setBackgroundColor(0);
        String[] projection=new String[]{MediaStore.Images.ImageColumns._ID,MediaStore.Images.ImageColumns.DATA,MediaStore.Images.ImageColumns.BUCKET_DISPLAY_NAME,MediaStore.Images.ImageColumns.DATE_TAKEN,MediaStore.Images.ImageColumns.MIME_TYPE};
        final Cursor cursor=HookMethods.SnapContext.getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,projection,null,null,MediaStore.Images.ImageColumns.DATE_TAKEN + ""String_Node_Str"");
        if (cursor != null && cursor.moveToFirst()) {
          String imageLocation=cursor.getString(1);
          File imageFile=new File(imageLocation);
          if (imageFile.exists()) {
            Bitmap bm=BitmapFactory.decodeFile(imageLocation);
            Bitmap resized=Bitmap.createScaledBitmap(bm,size,size,false);
            int w=resized.getWidth();
            int h=resized.getHeight();
            int radius=Math.min(h / 2,w / 2);
            Bitmap output=Bitmap.createBitmap(w + 8,h + 8,Bitmap.Config.ARGB_8888);
            Paint p=new Paint();
            p.setAntiAlias(true);
            Canvas c=new Canvas(output);
            c.drawARGB(0,0,0,0);
            p.setStyle(Paint.Style.FILL);
            c.drawCircle((w / 2) + 4,(h / 2) + 4,radius,p);
            p.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
            c.drawBitmap(resized,4,4,p);
            p.setXfermode(null);
            p.setStyle(Paint.Style.STROKE);
            p.setColor(Color.WHITE);
            p.setStrokeWidth(px(4));
            c.drawCircle((w / 2) + 4,(h / 2) + 4,radius,p);
            upload.setImageDrawable(new BitmapDrawable(output));
          }
          cursor.close();
        }
        upload.setScaleX((float)0.65);
        upload.setScaleY((float)0.65);
        upload.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            Intent launchIntent=new Intent(Intent.ACTION_RUN);
            launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
            launchIntent.setComponent(new ComponentName(""String_Node_Str"",""String_Node_Str""));
            HookMethods.context.startActivity(launchIntent);
          }
        }
);
        relativeLayout.addView(upload);
      }
    }
);
  }
 catch (  Resources.NotFoundException ignore) {
  }
}","public static void addShareIcon(final XC_InitPackageResources.InitPackageResourcesParam resparam){
  try {
    resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
      public void handleLayoutInflated(      LayoutInflatedParam liparam) throws Throwable {
        final int padding=px(10f);
        final int topMargin=0;
        final int size=px((int)resparam.res.getDimension(resparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)));
        final RelativeLayout relativeLayout=(RelativeLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP));
        final RelativeLayout.LayoutParams layoutParams=new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);
        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT | RelativeLayout.ALIGN_PARENT_TOP);
        layoutParams.rightMargin=px(50);
        layoutParams.topMargin=topMargin;
        upload=new ImageButton(HookMethods.SnapContext);
        upload.setLayoutParams(layoutParams);
        upload.setPadding(padding,padding,padding,padding);
        upload.setBackgroundColor(0);
        String[] projection=new String[]{MediaStore.Images.ImageColumns._ID,MediaStore.Images.ImageColumns.DATA,MediaStore.Images.ImageColumns.BUCKET_DISPLAY_NAME,MediaStore.Images.ImageColumns.DATE_TAKEN,MediaStore.Images.ImageColumns.MIME_TYPE};
        final Cursor cursor=HookMethods.SnapContext.getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,projection,null,null,MediaStore.Images.ImageColumns.DATE_TAKEN + ""String_Node_Str"");
        if (cursor != null && cursor.moveToFirst()) {
          String imageLocation=cursor.getString(1);
          File imageFile=new File(imageLocation);
          if (imageFile.exists()) {
            Bitmap bm=BitmapFactory.decodeFile(imageLocation);
            Bitmap resized=Bitmap.createScaledBitmap(bm,size,size,false);
            int w=resized.getWidth();
            int h=resized.getHeight();
            int radius=Math.min(h / 2,w / 2);
            Bitmap output=Bitmap.createBitmap(w + 8,h + 8,Bitmap.Config.ARGB_8888);
            Paint p=new Paint();
            p.setAntiAlias(true);
            Canvas c=new Canvas(output);
            c.drawARGB(0,0,0,0);
            p.setStyle(Paint.Style.FILL);
            c.drawCircle((w / 2) + 4,(h / 2) + 4,radius,p);
            p.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
            c.drawBitmap(resized,4,4,p);
            p.setXfermode(null);
            p.setStyle(Paint.Style.STROKE);
            p.setColor(Color.WHITE);
            p.setStrokeWidth(px(8));
            c.drawCircle((w / 2) + 4,(h / 2) + 4,radius,p);
            upload.setImageDrawable(new BitmapDrawable(output));
          }
          cursor.close();
        }
        upload.setScaleX((float)0.65);
        upload.setScaleY((float)0.65);
        upload.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View v){
            Intent launchIntent=new Intent(Intent.ACTION_RUN);
            launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
            launchIntent.setComponent(new ComponentName(""String_Node_Str"",""String_Node_Str""));
            HookMethods.context.startActivity(launchIntent);
          }
        }
);
        relativeLayout.addView(upload);
      }
    }
);
  }
 catch (  Resources.NotFoundException ignore) {
  }
}","The original code used an inconsistent stroke width of 4 pixels, which might appear too thin on different screen densities. In the fixed code, the stroke width is increased to 8 pixels, providing better visibility and a more prominent border around the circular image. This change enhances the visual clarity and ensures the share icon looks consistent and well-defined across various device screens."
94079,"private static void showStealthToast(ToastType type){
  if (statusDrawable == null)   return;
  final int offset=20;
  if (lastToastType == null || type != lastToastType) {
    lastToastType=type;
    statusDrawable.setColorFilter(new PorterDuffColorFilter(type.color,PorterDuff.Mode.MULTIPLY));
  }
  final ImageView view=new ImageView(HookMethods.SnapContext);
  view.setImageDrawable(statusDrawable);
  view.bringToFront();
  HookMethods.SnapContext.runOnUiThread(new Runnable(){
    @Override public void run(){
      Toast statusToast=new Toast(HookMethods.SnapContext);
      statusToast.setView(view);
      statusToast.setGravity(Gravity.BOTTOM | Gravity.START,offset,offset);
      statusToast.setDuration(Toast.LENGTH_LONG);
      statusToast.show();
    }
  }
);
}","private static void showStealthToast(ToastType type){
  if (statusDrawable == null)   return;
  final int offset=20;
  final boolean longLength=Preferences.getInt(Prefs.TOAST_LENGTH) == Preferences.TOAST_LENGTH_LONG;
  if (lastToastType == null || type != lastToastType) {
    lastToastType=type;
    statusDrawable.setColorFilter(new PorterDuffColorFilter(type.color,PorterDuff.Mode.MULTIPLY));
  }
  final ImageView view=new ImageView(HookMethods.SnapContext);
  view.setImageDrawable(statusDrawable);
  view.bringToFront();
  HookMethods.SnapContext.runOnUiThread(new Runnable(){
    @Override public void run(){
      Toast statusToast=new Toast(HookMethods.SnapContext);
      statusToast.setView(view);
      statusToast.setGravity(Gravity.BOTTOM | Gravity.START,offset,offset);
      statusToast.setDuration(longLength ? Toast.LENGTH_LONG : Toast.LENGTH_SHORT);
      statusToast.show();
    }
  }
);
}","The original code hardcoded the toast duration to Toast.LENGTH_LONG without considering user preferences. The fixed code introduces a `longLength` variable that dynamically sets the toast duration based on a user-defined preference, allowing for more flexible toast display times. This enhancement provides users with greater control over toast notification length, improving the overall user experience by respecting individual display preferences."
94080,"@Override public void run(){
  Toast statusToast=new Toast(HookMethods.SnapContext);
  statusToast.setView(view);
  statusToast.setGravity(Gravity.BOTTOM | Gravity.START,offset,offset);
  statusToast.setDuration(Toast.LENGTH_LONG);
  statusToast.show();
}","@Override public void run(){
  Toast statusToast=new Toast(HookMethods.SnapContext);
  statusToast.setView(view);
  statusToast.setGravity(Gravity.BOTTOM | Gravity.START,offset,offset);
  statusToast.setDuration(longLength ? Toast.LENGTH_LONG : Toast.LENGTH_SHORT);
  statusToast.show();
}","The original code rigidly sets the toast duration to Toast.LENGTH_LONG, which doesn't provide flexibility for different toast display scenarios. The fixed code introduces a conditional parameter `longLength` that dynamically selects between Toast.LENGTH_LONG and Toast.LENGTH_SHORT based on the desired duration. This modification allows more precise control over toast display time, enabling developers to choose appropriate toast lengths according to specific use cases."
94081,"public Object getAllBuiltObjectsExcept(String tableName,String columnName,String orderBy,ArrayList<String> blacklist,CallbackHandler callbackHandler){
  String strBlacklist=formatExclusionList(blacklist);
  String query=""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str""+ ""String_Node_Str""+ strBlacklist+ ""String_Node_Str""+ (orderBy != null ? ""String_Node_Str"" + orderBy : ""String_Node_Str"");
  Logger.log(""String_Node_Str"" + query);
  Cursor cursor=getDatabase().rawQuery(query,null);
  callbackHandler.addParams(cursor);
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  Logger.log(""String_Node_Str"" + cursor.getCount());
  Object invocationResponse=invokeCallback(callbackHandler);
  cursor.close();
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName());
    return null;
  }
  return invocationResponse;
}","public Object getAllBuiltObjectsExcept(String tableName,String columnName,String orderBy,ArrayList<String> blacklist,CallbackHandler callbackHandler){
  String strBlacklist=formatExclusionList(blacklist);
  String query=""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str""+ ""String_Node_Str""+ strBlacklist+ ""String_Node_Str""+ (orderBy != null ? ""String_Node_Str"" + orderBy : ""String_Node_Str"");
  Logger.log(""String_Node_Str"" + query,LogType.DATABASE);
  Cursor cursor=getDatabase().rawQuery(query,null);
  callbackHandler.addParams(cursor);
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"",LogType.DATABASE);
    return null;
  }
  Logger.log(""String_Node_Str"" + cursor.getCount(),LogType.DATABASE);
  Object invocationResponse=invokeCallback(callbackHandler);
  cursor.close();
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName(),LogType.DATABASE);
    return null;
  }
  return invocationResponse;
}","The original code lacked proper logging context, potentially making debug tracing difficult and less informative. The fixed code adds LogType.DATABASE parameter to Logger.log() calls, which provides specific context for database-related log entries and enables more granular logging. This enhancement improves error tracking, diagnostic capabilities, and overall code maintainability by clearly distinguishing database-specific log messages from other system logs."
94082,"Object getAllBuiltObjects(String tableName,String where,String orderBy,CallbackHandler callbackHandler){
  Logger.log(""String_Node_Str"");
  Cursor cursor=getDatabase().rawQuery(""String_Node_Str"" + tableName + (where != null ? ""String_Node_Str"" + where : ""String_Node_Str"")+ (orderBy != null ? ""String_Node_Str"" + orderBy : ""String_Node_Str""),null);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  callbackHandler.addParams(cursor);
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  Object invocationResponse=invokeCallback(callbackHandler);
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName());
    return null;
  }
  cursor.close();
  return invocationResponse;
}","Object getAllBuiltObjects(String tableName,String where,String orderBy,CallbackHandler callbackHandler){
  Logger.log(""String_Node_Str"",LogType.DATABASE);
  Cursor cursor=getDatabase().rawQuery(""String_Node_Str"" + tableName + (where != null ? ""String_Node_Str"" + where : ""String_Node_Str"")+ (orderBy != null ? ""String_Node_Str"" + orderBy : ""String_Node_Str""),null);
  Logger.log(""String_Node_Str"" + cursor.getCount(),LogType.DATABASE);
  callbackHandler.addParams(cursor);
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"",LogType.DATABASE);
    return null;
  }
  Object invocationResponse=invokeCallback(callbackHandler);
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName(),LogType.DATABASE);
    return null;
  }
  cursor.close();
  return invocationResponse;
}","The original code lacks proper logging context, using generic ""String_Node_Str"" without specifying the log type, which can make debugging difficult. The fixed code adds LogType.DATABASE to each Logger.log() call, providing clearer and more meaningful logging information about database operations. This enhancement improves code readability and diagnostic capabilities by explicitly categorizing log messages related to database interactions."
94083,"@SuppressWarnings(""String_Node_Str"") private Object invokeCallback(CallbackHandler callbackHandler){
  try {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName() + ""String_Node_Str""+ Arrays.toString(callbackHandler.parameters));
    return callbackHandler.method.invoke(callbackHandler.caller,callbackHandler.parameters);
  }
 catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") private Object invokeCallback(CallbackHandler callbackHandler){
  try {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName() + ""String_Node_Str""+ Arrays.toString(callbackHandler.parameters),LogType.DATABASE);
    return callbackHandler.method.invoke(callbackHandler.caller,callbackHandler.parameters);
  }
 catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
  return null;
}","The original code lacks a log type specification when calling Logger.log(), which may result in incomplete or improperly categorized logging. The fixed code adds LogType.DATABASE as a second parameter to the log method, ensuring precise log categorization and providing context for database-related method invocations. This enhancement improves logging clarity and allows for more targeted log filtering and debugging in database-related operations."
94084,"public ContentValues getContent(String tableName,String columnName,String[] selectionArgs,String sortOrder,String[] projection){
  Logger.log(""String_Node_Str"");
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  ContentValues content=getValuesFromCursor(cursor,projection);
  cursor.close();
  if (content == null) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  Logger.log(""String_Node_Str"" + content.size());
  return content;
}","public ContentValues getContent(String tableName,String columnName,String[] selectionArgs,String sortOrder,String[] projection){
  Logger.log(""String_Node_Str"",LogType.DATABASE);
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  Logger.log(""String_Node_Str"" + cursor.getCount(),LogType.DATABASE);
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"",LogType.DATABASE);
    return null;
  }
  ContentValues content=getValuesFromCursor(cursor,projection);
  cursor.close();
  if (content == null) {
    Logger.log(""String_Node_Str"",LogType.DATABASE);
    return null;
  }
  Logger.log(""String_Node_Str"" + content.size(),LogType.DATABASE);
  return content;
}","The original code lacked proper logging context and used a generic logging method without specifying log types. The fixed code introduces LogType.DATABASE to provide more precise logging, improving traceability and debugging capabilities. This enhancement allows for better error tracking and systematic logging in database-related operations, making the code more maintainable and easier to diagnose potential issues."
94085,"CoreDatabaseHandler(Context context,String databaseName,String[] entries,int DATABASE_VERSION){
  super(context,databaseName,null,DATABASE_VERSION);
  DATABASE_NAME=databaseName;
  SQL_CREATE_ENTRIES=entries;
}","CoreDatabaseHandler(Context context,String databaseName,String[] entries,int DATABASE_VERSION){
  super(context,databaseName,null,DATABASE_VERSION);
  DATABASE_NAME=databaseName;
  SQL_CREATE_ENTRIES=entries;
  writableDatabase=getDatabase();
}","The original code lacks initialization of the writableDatabase, which could lead to potential null reference errors when trying to perform database operations. The fixed code adds writableDatabase=getDatabase(), ensuring the database is prepared and ready for use immediately after object creation. This proactive database preparation prevents potential null pointer exceptions and enhances the robustness of database interaction in the application."
94086,"public int getCount(String tableName,String columnName,String[] selectionArgs,String[] projection){
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,null);
  int count=cursor.getCount();
  cursor.close();
  Logger.log(""String_Node_Str"" + count);
  return count;
}","public int getCount(String tableName,String columnName,String[] selectionArgs,String[] projection){
  String selection=columnName + ""String_Node_Str"";
  Logger.log(""String_Node_Str"",Logger.LogType.DATABASE);
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,null);
  int count=cursor.getCount();
  cursor.close();
  Logger.log(""String_Node_Str"" + count,LogType.DATABASE);
  return count;
}","The buggy code lacks proper logging context, using an incomplete logger method without specifying the log type. The fixed code adds a specific LogType.DATABASE parameter to the Logger.log() method, ensuring more precise and traceable logging of database operations. This improvement enhances debugging capabilities by providing clearer, type-specific log entries for database-related activities."
94087,"public Object performQueryForBuiltObjects(String tableName,String selection,String[] selectionArgs,String[] projection,String sortOrder,CallbackHandler callbackHandler){
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  callbackHandler.addParams(cursor);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  Object invocationResponse=invokeCallback(callbackHandler);
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName());
    return null;
  }
  cursor.close();
  return invocationResponse;
}","public Object performQueryForBuiltObjects(String tableName,String selection,String[] selectionArgs,String[] projection,String sortOrder,CallbackHandler callbackHandler){
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  callbackHandler.addParams(cursor);
  Logger.log(""String_Node_Str"" + cursor.getCount(),LogType.DATABASE);
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"",LogType.DATABASE);
    return null;
  }
  Object invocationResponse=invokeCallback(callbackHandler);
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName(),LogType.DATABASE);
    return null;
  }
  cursor.close();
  return invocationResponse;
}","The original code lacks proper logging context, which can make debugging database operations difficult. The fixed code adds a LogType.DATABASE parameter to Logger.log calls, providing clearer and more structured log entries for database-related events. This enhancement improves code maintainability by ensuring consistent and meaningful logging during database query operations."
94088,"public void onCreate(SQLiteDatabase db){
  for (  String entry : SQL_CREATE_ENTRIES)   db.execSQL(entry);
}","@Override public void onCreate(SQLiteDatabase db){
  for (  String entry : SQL_CREATE_ENTRIES)   db.execSQL(entry);
}","The original code lacks the `@Override` annotation, which helps catch potential method signature errors and ensures proper inheritance from the parent class. The fixed code adds `@Override`, explicitly indicating that the method is intentionally overriding a method from the parent class and providing compile-time verification. This annotation improves code readability, prevents unintended method definitions, and helps catch potential errors early in the development process."
94089,"public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion){
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion){
}","The original code lacks the `@Override` annotation, which is crucial for properly implementing the SQLiteOpenHelper's onUpgrade method. The fixed code adds the `@Override` annotation, ensuring that the method correctly overrides the parent class's method and provides compile-time verification of method signature. This improvement helps prevent potential errors and makes the code more robust by explicitly indicating the method's intent to override a superclass method."
94090,"Object[] addParams(Object... newParams){
  int newParamLength=newParams.length;
  Object[] newParamList=new Object[parameters.length + newParamLength];
  System.arraycopy(parameters,0,newParamList,0,parameters.length);
  System.arraycopy(newParams,0,newParamList,parameters.length,newParamLength);
  this.parameters=newParamList;
  for (  Object param : parameters)   Logger.log(""String_Node_Str"" + param.getClass().getCanonicalName());
  return newParamList;
}","Object[] addParams(Object... newParams){
  int newParamLength=newParams.length;
  Object[] newParamList=new Object[parameters.length + newParamLength];
  System.arraycopy(parameters,0,newParamList,0,parameters.length);
  System.arraycopy(newParams,0,newParamList,parameters.length,newParamLength);
  this.parameters=newParamList;
  for (  Object param : parameters)   Logger.log(""String_Node_Str"" + param.getClass().getCanonicalName(),LogType.DATABASE);
  return newParamList;
}","The original code lacks a log type parameter when calling Logger.log(), which may cause logging inconsistencies or potential runtime errors. The fixed code adds LogType.DATABASE as a second argument, ensuring proper log categorization and following the Logger method's expected signature. This modification provides more precise logging, improving code reliability and making log entries more structured and traceable."
94091,"public ContentValues getValuesFromCursor(Cursor cursor,String[] arrProjection){
  ContentValues contentValues=new ContentValues();
  for (  String projection : arrProjection) {
    int index;
    try {
      index=cursor.getColumnIndexOrThrow(projection);
    }
 catch (    IllegalArgumentException e) {
      Logger.log(""String_Node_Str"",e);
      continue;
    }
    int type=cursor.getType(index);
switch (type) {
case Cursor.FIELD_TYPE_STRING:
      contentValues.put(projection,cursor.getString(index));
    break;
case Cursor.FIELD_TYPE_INTEGER:
  contentValues.put(projection,cursor.getInt(index));
break;
case Cursor.FIELD_TYPE_FLOAT:
contentValues.put(projection,cursor.getFloat(index));
break;
case Cursor.FIELD_TYPE_BLOB:
contentValues.put(projection,cursor.getBlob(index));
break;
case Cursor.FIELD_TYPE_NULL:
Logger.log(""String_Node_Str"");
break;
default :
Logger.log(""String_Node_Str"");
}
}
return contentValues;
}","public ContentValues getValuesFromCursor(Cursor cursor,String[] arrProjection){
  ContentValues contentValues=new ContentValues();
  for (  String projection : arrProjection) {
    int index;
    try {
      index=cursor.getColumnIndexOrThrow(projection);
    }
 catch (    IllegalArgumentException e) {
      Logger.log(""String_Node_Str"",e,LogType.DATABASE);
      continue;
    }
    int type=cursor.getType(index);
switch (type) {
case Cursor.FIELD_TYPE_STRING:
      contentValues.put(projection,cursor.getString(index));
    break;
case Cursor.FIELD_TYPE_INTEGER:
  contentValues.put(projection,cursor.getInt(index));
break;
case Cursor.FIELD_TYPE_FLOAT:
contentValues.put(projection,cursor.getFloat(index));
break;
case Cursor.FIELD_TYPE_BLOB:
contentValues.put(projection,cursor.getBlob(index));
break;
case Cursor.FIELD_TYPE_NULL:
Logger.log(""String_Node_Str"",LogType.DATABASE);
break;
default :
Logger.log(""String_Node_Str"",LogType.DATABASE);
}
}
return contentValues;
}","The original code lacks proper logging context when handling column index errors and null/unknown field types, potentially masking important diagnostic information. The fixed code adds a `LogType.DATABASE` parameter to the `Logger.log()` method, providing more structured and meaningful logging for database-related operations. This enhancement improves error tracking and debugging capabilities by categorizing log messages with a specific context, making it easier to diagnose and troubleshoot database interactions."
94092,"public ArrayList<ContentValues> getAllContent(String tableName,String[] projection){
  Logger.log(""String_Node_Str"");
  Cursor cursor=getDatabase().rawQuery(""String_Node_Str"" + tableName,null);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  ArrayList<ContentValues> contentList=new ArrayList<>();
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  while (!cursor.isAfterLast())   contentList.add(this.getValuesFromCursor(cursor,projection));
  return contentList;
}","public ArrayList<ContentValues> getAllContent(String tableName,String[] projection){
  Logger.log(""String_Node_Str"",LogType.DATABASE);
  Cursor cursor=getDatabase().rawQuery(""String_Node_Str"" + tableName,null);
  Logger.log(""String_Node_Str"" + cursor.getCount(),LogType.DATABASE);
  ArrayList<ContentValues> contentList=new ArrayList<>();
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"",LogType.DATABASE);
    return null;
  }
  while (!cursor.isAfterLast())   contentList.add(this.getValuesFromCursor(cursor,projection));
  return contentList;
}","The original code lacks proper logging context, potentially making debugging difficult by not specifying the log type for debugging purposes. The fixed code adds `LogType.DATABASE` to the `Logger.log()` method calls, ensuring clear and structured logging with a specific database-related context. This enhancement improves code maintainability and provides more precise tracing during database operations by explicitly categorizing log messages."
94093,"/** 
 * Usage: getCallback(""methodToCall"", ParameterClassTypes...);
 * @param methodName - The name of the method to call
 * @param classType  - The list of Classes called as the method parameters
 * @return CallbackHandler - The object holding the callback data
 */
static CallbackHandler getCallback(Object clazz,String methodName,Class<?>... classType){
  try {
    Logger.log(""String_Node_Str"");
    return new CallbackHandler(clazz,clazz.getClass().getMethod(methodName,classType));
  }
 catch (  NoSuchMethodException e) {
    Logger.log(""String_Node_Str"",e);
    return null;
  }
}","/** 
 * Usage: getCallback(""methodToCall"", ParameterClassTypes...);
 * @param methodName - The name of the method to call
 * @param classType  - The list of Classes called as the method parameters
 * @return CallbackHandler - The object holding the callback data
 */
static CallbackHandler getCallback(Object clazz,String methodName,Class<?>... classType){
  try {
    Logger.log(""String_Node_Str"",LogType.DATABASE);
    return new CallbackHandler(clazz,clazz.getClass().getMethod(methodName,classType));
  }
 catch (  NoSuchMethodException e) {
    Logger.log(""String_Node_Str"",e,LogType.DATABASE);
    return null;
  }
}","The original code lacked proper logging configuration for different log types, potentially losing important error context during method callback resolution. The fixed code adds explicit LogType.DATABASE parameter to Logger.log() method calls, ensuring consistent and targeted logging for database-related method invocations. This modification enhances error traceability and provides more precise diagnostic information when method reflection encounters issues."
94094,"public void onDowngrade(SQLiteDatabase db,int oldVersion,int newVersion){
  onUpgrade(db,oldVersion,newVersion);
}","@Override public void onDowngrade(SQLiteDatabase db,int oldVersion,int newVersion){
  onUpgrade(db,oldVersion,newVersion);
}","The original code lacks the `@Override` annotation, which means the method might not properly override the parent class's method or could be silently ignored. The fixed code adds `@Override`, ensuring that the method explicitly overrides the parent class method and will trigger a compile-time error if the method signature is incorrect. This annotation provides better type safety and clearly communicates the intention to override the parent class method during database downgrade."
94095,"boolean checkIfColumnExists(SQLiteDatabase db,String tableName,String columnName){
  Cursor emptyCursor=null;
  Logger.log(String.format(""String_Node_Str"",columnName,tableName));
  try {
    emptyCursor=db.rawQuery(""String_Node_Str"" + tableName + ""String_Node_Str"",null);
    return emptyCursor.getColumnIndex(tableName) != -1;
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"");
  }
 finally {
    if (emptyCursor != null)     emptyCursor.close();
  }
  return false;
}","boolean checkIfColumnExists(SQLiteDatabase db,String tableName,String columnName){
  Cursor emptyCursor=null;
  Logger.log(String.format(""String_Node_Str"",columnName,tableName),LogType.DATABASE);
  try {
    emptyCursor=db.rawQuery(""String_Node_Str"" + tableName + ""String_Node_Str"",null);
    Logger.log(""String_Node_Str"" + emptyCursor.getColumnIndex(columnName),LogType.DATABASE);
    return emptyCursor.getColumnIndex(columnName) != -1;
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"",e,LogType.DATABASE);
  }
 finally {
    if (emptyCursor != null)     emptyCursor.close();
  }
  return false;
}","The original code incorrectly checks for table existence by using the table name instead of the column name when verifying column presence, leading to potential false negatives. The fixed code corrects this by changing `tableName` to `columnName` in the `getColumnIndex()` method and adding more robust logging with specific log type and error tracking. These modifications ensure accurate column existence checking and provide better diagnostic information for database operations."
94096,"public boolean containsObject(String tableName,String columnName,String[] selectionArgs,String sortOrder,String[] projection){
  Logger.log(""String_Node_Str"");
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  cursor.close();
  return cursor.getCount() != 0;
}","public boolean containsObject(String tableName,String columnName,String[] selectionArgs,String sortOrder,String[] projection){
  Logger.log(""String_Node_Str"",LogType.DATABASE);
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  cursor.close();
  return cursor.getCount() != 0;
}","The original code lacks a logging type for the `Logger.log()` method, which may lead to ambiguous or incomplete logging. The fixed code adds `LogType.DATABASE` to provide explicit context and improve logging precision. This enhancement ensures more accurate and traceable database operation logging, making debugging and monitoring easier."
94097,"public Object getBuiltContent(String tableName,String columnName,String[] selectionArgs,String sortOrder,String[] projection,CallbackHandler callbackHandler){
  Logger.log(""String_Node_Str"");
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  callbackHandler.addParams(cursor);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  Object invocationResponse=invokeCallback(callbackHandler);
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName());
    return null;
  }
  cursor.close();
  return invocationResponse;
}","public Object getBuiltContent(String tableName,String columnName,String[] selectionArgs,String sortOrder,String[] projection,CallbackHandler callbackHandler){
  Logger.log(""String_Node_Str"",LogType.DATABASE);
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  callbackHandler.addParams(cursor);
  Logger.log(""String_Node_Str"" + cursor.getCount(),LogType.DATABASE);
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"",LogType.DATABASE);
    return null;
  }
  Object invocationResponse=invokeCallback(callbackHandler);
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName(),LogType.DATABASE);
    return null;
  }
  cursor.close();
  return invocationResponse;
}","The original code lacked proper logging context, potentially masking important debugging information during database operations. The fixed code adds a LogType.DATABASE parameter to the Logger.log() method, ensuring that database-related logging is correctly categorized and traceable. This enhancement improves code maintainability and debugging capabilities by providing more structured and meaningful logging for database query operations."
94098,"public ArrayList<ContentValues> getAllContentExcept(String tableName,String columnName,String[] projection,ArrayList<String> blacklist){
  Logger.log(""String_Node_Str"");
  String strBlacklist=formatExclusionList(blacklist);
  String query=""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str""+ strBlacklist+ ""String_Node_Str"";
  Logger.log(""String_Node_Str"" + query);
  Cursor cursor=getDatabase().rawQuery(query,null);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  ArrayList<ContentValues> content=new ArrayList<>();
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  while (!cursor.isAfterLast()) {
    Logger.log(""String_Node_Str"");
    ContentValues value=getValuesFromCursor(cursor,projection);
    if (value.size() > 0)     content.add(value);
    cursor.moveToNext();
  }
  Logger.log(""String_Node_Str"");
  cursor.close();
  return content;
}","public ArrayList<ContentValues> getAllContentExcept(String tableName,String columnName,String[] projection,ArrayList<String> blacklist){
  Logger.log(""String_Node_Str"",LogType.DATABASE);
  String strBlacklist=formatExclusionList(blacklist);
  String query=""String_Node_Str"" + tableName + ""String_Node_Str""+ columnName+ ""String_Node_Str""+ strBlacklist+ ""String_Node_Str"";
  Logger.log(""String_Node_Str"" + query,LogType.DATABASE);
  Cursor cursor=getDatabase().rawQuery(query,null);
  Logger.log(""String_Node_Str"" + cursor.getCount(),LogType.DATABASE);
  ArrayList<ContentValues> content=new ArrayList<>();
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"",LogType.DATABASE);
    return null;
  }
  while (!cursor.isAfterLast()) {
    Logger.log(""String_Node_Str"",LogType.DATABASE);
    ContentValues value=getValuesFromCursor(cursor,projection);
    if (value.size() > 0)     content.add(value);
    cursor.moveToNext();
  }
  Logger.log(""String_Node_Str"",LogType.DATABASE);
  cursor.close();
  return content;
}","The original code lacked proper logging with log type specification, which could lead to inconsistent or incomplete logging during database operations. The fixed code adds LogType.DATABASE to each Logger.log() call, ensuring consistent and traceable logging with a specific context for database-related events. This improvement enhances debugging capabilities and provides more structured and meaningful log entries for database interactions."
94099,"@Override public void handleInitPackageResources(InitPackageResourcesParam resparam) throws Throwable {
  try {
    if (!resparam.packageName.equals(Common.PACKAGE_SNAP))     return;
    Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
    Context localContext=(Context)callMethod(activityThread,""String_Node_Str"");
    int name=R.id.name;
    int checkBox=R.id.checkBox;
    int friend_item=R.layout.friend_item;
    int group_item=R.layout.group_item;
    modRes=XModuleResources.createInstance(MODULE_PATH,resparam.res);
    FriendListDialog.name=XResources.getFakeResId(modRes,name);
    resparam.res.setReplacement(FriendListDialog.name,modRes.fwd(name));
    FriendListDialog.checkBox=XResources.getFakeResId(modRes,checkBox);
    resparam.res.setReplacement(FriendListDialog.checkBox,modRes.fwd(checkBox));
    FriendListDialog.friend_item=XResources.getFakeResId(modRes,checkBox);
    resparam.res.setReplacement(FriendListDialog.friend_item,modRes.fwd(friend_item));
    GroupDialog.group_item=XResources.getFakeResId(modRes,group_item);
    resparam.res.setReplacement(GroupDialog.group_item,modRes.fwd(group_item));
    Logger.log(""String_Node_Str"");
    try {
      if (Preferences.getMap() == null || Preferences.getMap().isEmpty()) {
        Logger.log(""String_Node_Str"");
        Preferences.loadMapFromXposed();
      }
    }
 catch (    Exception e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
    }
    resParam=resparam;
    HookedLayouts.addSaveButtonsAndGestures(resparam,mResources,localContext);
    if (Preferences.shouldAddGhost()) {
      HookedLayouts.addIcons(resparam,mResources);
    }
    if (Preferences.getBool(Prefs.INTEGRATION)) {
      HookedLayouts.addShareIcon(resparam);
    }
    if (Preferences.getBool(Prefs.HIDE_PEOPLE)) {
      Stories.addSnapprefsBtn(resparam,mResources);
    }
    HookedLayouts.fullScreenFilter(resparam);
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"",e);
  }
}","@Override public void handleInitPackageResources(InitPackageResourcesParam resparam) throws Throwable {
  try {
    if (!resparam.packageName.equals(Common.PACKAGE_SNAP))     return;
    Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
    Context localContext=(Context)callMethod(activityThread,""String_Node_Str"");
    int name=R.id.name;
    int checkBox=R.id.checkBox;
    int friend_item=R.layout.friend_item;
    int group_item=R.layout.group_item;
    modRes=XModuleResources.createInstance(MODULE_PATH,resparam.res);
    FriendListDialog.name=XResources.getFakeResId(modRes,name);
    resparam.res.setReplacement(FriendListDialog.name,modRes.fwd(name));
    FriendListDialog.checkBox=XResources.getFakeResId(modRes,checkBox);
    resparam.res.setReplacement(FriendListDialog.checkBox,modRes.fwd(checkBox));
    FriendListDialog.friend_item=XResources.getFakeResId(modRes,checkBox);
    resparam.res.setReplacement(FriendListDialog.friend_item,modRes.fwd(friend_item));
    GroupDialog.group_item=XResources.getFakeResId(modRes,group_item);
    resparam.res.setReplacement(GroupDialog.group_item,modRes.fwd(group_item));
    Logger.log(""String_Node_Str"");
    try {
      if (Preferences.getMap() == null || Preferences.getMap().isEmpty()) {
        Logger.log(""String_Node_Str"");
        Preferences.loadMapFromXposed();
      }
    }
 catch (    Exception e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
    }
    resParam=resparam;
    try {
      HookedLayouts.addSaveButtonsAndGestures(resparam,mResources,localContext);
    }
 catch (    Throwable t) {
      Logger.log(t);
    }
    if (Preferences.shouldAddGhost()) {
      HookedLayouts.addIcons(resparam,mResources);
    }
    if (Preferences.getBool(Prefs.INTEGRATION)) {
      HookedLayouts.addShareIcon(resparam);
    }
    if (Preferences.getBool(Prefs.HIDE_PEOPLE)) {
      Stories.addSnapprefsBtn(resparam,mResources);
    }
    HookedLayouts.fullScreenFilter(resparam);
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"",e);
  }
}","The original code lacked error handling for the `HookedLayouts.addSaveButtonsAndGestures()` method, which could cause the entire method to fail if an unexpected exception occurred. The fixed code introduces a try-catch block specifically around this method call, catching any potential `Throwable` and logging the error without interrupting the subsequent operations. This approach enhances the code's robustness by preventing a single method failure from breaking the entire resource initialization process, thereby improving the module's overall stability and error resilience."
94100,"public static void addShareIcon(final XC_InitPackageResources.InitPackageResourcesParam resparam){
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      final RelativeLayout relativeLayout=(RelativeLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP));
      final RelativeLayout.LayoutParams layoutParams=new RelativeLayout.LayoutParams((int)resparam.res.getDimension(resparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)),(int)resparam.res.getDimension(resparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)));
      layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      layoutParams.rightMargin=px(50);
      layoutParams.topMargin=px(12);
      upload=new ImageButton(HookMethods.SnapContext);
      upload.setLayoutParams(layoutParams);
      upload.setBackgroundColor(0);
      Drawable uploadimg=HookMethods.SnapContext.getResources().getDrawable(+(int)Long.parseLong(Obfuscator.sharing.UPLOAD_ICON.substring(2),16));
      upload.setImageDrawable(uploadimg);
      upload.setScaleX((float)0.55);
      upload.setScaleY((float)0.55);
      upload.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Intent launchIntent=new Intent(Intent.ACTION_RUN);
          launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
          launchIntent.setComponent(new ComponentName(""String_Node_Str"",""String_Node_Str""));
          HookMethods.context.startActivity(launchIntent);
        }
      }
);
      relativeLayout.addView(upload);
    }
  }
);
}","public static void addShareIcon(final XC_InitPackageResources.InitPackageResourcesParam resparam){
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      final RelativeLayout relativeLayout=(RelativeLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP));
      final RelativeLayout.LayoutParams layoutParams=new RelativeLayout.LayoutParams((int)resparam.res.getDimension(resparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)),(int)resparam.res.getDimension(resparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)));
      layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      layoutParams.rightMargin=px(50);
      layoutParams.topMargin=px(12);
      upload=new ImageButton(HookMethods.SnapContext);
      upload.setLayoutParams(layoutParams);
      upload.setBackgroundColor(0);
      Drawable uploading=HookMethods.SnapContext.getResources().getDrawable(+(int)Long.parseLong(Obfuscator.sharing.UPLOAD_ICON.substring(2),16));
      upload.setImageDrawable(uploading);
      upload.setScaleX((float)0.55);
      upload.setScaleY((float)0.55);
      upload.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Intent launchIntent=new Intent(Intent.ACTION_RUN);
          launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
          launchIntent.setComponent(new ComponentName(""String_Node_Str"",""String_Node_Str""));
          HookMethods.context.startActivity(launchIntent);
        }
      }
);
      relativeLayout.addView(upload);
    }
  }
);
}","The original code used the variable name `uploadimg`, which could cause confusion or potential naming conflicts. In the fixed code, the variable was renamed to `uploading`, providing a clearer and more descriptive name that indicates the purpose of the drawable. This small change enhances code readability and reduces the likelihood of misunderstandings or errors when working with the image resource."
94101,"public static void addSaveButtonsAndGestures(XC_InitPackageResources.InitPackageResourcesParam resparam,XModuleResources mResources,final Context localContext){
  final GestureEvent gestureEvent=new GestureEvent();
  Logger.log(""String_Node_Str"",false,true);
  final Bitmap saveImg=BitmapFactory.decodeResource(mResources,R.drawable.save_button);
  if (saveImg == null)   throw new NullPointerException(""String_Node_Str"");
  int horizontalPosition=Preferences.getBool(Prefs.BUTTON_POSITION) ? Gravity.START : Gravity.END;
  final FrameLayout.LayoutParams layoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,FrameLayout.LayoutParams.WRAP_CONTENT,Gravity.BOTTOM | horizontalPosition);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      Logger.log(""String_Node_Str"");
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      ViewGroup overlay_group=(ViewGroup)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP));
      saveStoryButton=new ImageButton(localContext);
      saveStoryButton.setLayoutParams(layoutParams);
      saveStoryButton.setBackgroundColor(0);
      saveStoryButton.setImageBitmap(saveImg);
      saveStoryButton.setAlpha(0.8f);
      saveStoryButton.setVisibility(Preferences.getInt(Prefs.SAVEMODE_STORY) == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          return Preferences.getInt(Prefs.SAVEMODE_STORY) == Preferences.SAVE_S2S && gestureEvent.onTouch(v,event,Saving.SnapType.STORY);
        }
      }
);
      frameLayout.addView(saveStoryButton);
      overlay_group.bringToFront();
      saveStoryButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      Logger.log(""String_Node_Str"");
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveSnapButton=new ImageButton(localContext);
      saveSnapButton.setLayoutParams(layoutParams);
      saveSnapButton.setBackgroundColor(0);
      saveSnapButton.setAlpha(1f);
      saveSnapButton.setImageBitmap(saveImg);
      saveSnapButton.setVisibility(Preferences.getInt(Prefs.SAVEMODE_SNAP) == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          return Preferences.getInt(Prefs.SAVEMODE_SNAP) == Preferences.SAVE_S2S && gestureEvent.onTouch(v,event,Saving.SnapType.SNAP);
        }
      }
);
      frameLayout.addView(saveSnapButton);
      saveSnapButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
}","public static void addSaveButtonsAndGestures(XC_InitPackageResources.InitPackageResourcesParam resparam,XModuleResources mResources,final Context localContext){
  final GestureEvent gestureEvent=new GestureEvent();
  Logger.log(""String_Node_Str"");
  final Bitmap saveImg=BitmapFactory.decodeResource(mResources,R.drawable.save_button);
  if (saveImg == null)   throw new NullPointerException(""String_Node_Str"");
  int horizontalPosition=Preferences.getBool(Prefs.BUTTON_POSITION) ? Gravity.START : Gravity.END;
  final FrameLayout.LayoutParams layoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,FrameLayout.LayoutParams.WRAP_CONTENT,Gravity.BOTTOM | horizontalPosition);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      Logger.log(""String_Node_Str"");
      final RelativeLayout frameLayout=(RelativeLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getRootView();
      Logger.log(""String_Node_Str"" + frameLayout);
      ViewGroup overlay_group=(ViewGroup)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP));
      saveStoryButton=new ImageButton(localContext);
      saveStoryButton.setLayoutParams(layoutParams);
      saveStoryButton.setBackgroundColor(0);
      saveStoryButton.setImageBitmap(saveImg);
      saveStoryButton.setAlpha(0.8f);
      saveStoryButton.setVisibility(Preferences.getInt(Prefs.SAVEMODE_STORY) == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          return Preferences.getInt(Prefs.SAVEMODE_STORY) == Preferences.SAVE_S2S && gestureEvent.onTouch(v,event,Saving.SnapType.STORY);
        }
      }
);
      frameLayout.addView(saveStoryButton);
      saveStoryButton.bringToFront();
      overlay_group.bringToFront();
      saveStoryButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Saving.performButtonSave();
        }
      }
);
      saveStoryButton.setOnFocusChangeListener(new View.OnFocusChangeListener(){
        @Override public void onFocusChange(        View view,        boolean b){
          Logger.log(""String_Node_Str"" + b);
          if (!b)           saveStoryButton.bringToFront();
        }
      }
);
    }
  }
);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      Logger.log(""String_Node_Str"");
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveSnapButton=new ImageButton(localContext);
      saveSnapButton.setLayoutParams(layoutParams);
      saveSnapButton.setBackgroundColor(0);
      saveSnapButton.setAlpha(1f);
      saveSnapButton.setImageBitmap(saveImg);
      saveSnapButton.setVisibility(Preferences.getInt(Prefs.SAVEMODE_SNAP) == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          return Preferences.getInt(Prefs.SAVEMODE_SNAP) == Preferences.SAVE_S2S && gestureEvent.onTouch(v,event,Saving.SnapType.SNAP);
        }
      }
);
      frameLayout.addView(saveSnapButton);
      saveSnapButton.bringToFront();
      saveSnapButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
}","The original code had potential layout and view manipulation issues, particularly with parent view selection and button positioning. The fixed code resolves these by using more precise view hierarchy methods like getRootView(), adding explicit bringing-to-front for buttons, and introducing an OnFocusChangeListener to maintain button visibility. These modifications improve UI interaction reliability and ensure consistent button placement across different Snapchat view contexts."
94102,"/** 
 * @param directoryPath The full path to the directory to place the .nomedia file
 * @return Returns true if the file was successfully written or appears to already exist
 */
public boolean writeNoMediaFile(String directoryPath){
  String storageState=Environment.getExternalStorageState();
  if (Environment.MEDIA_MOUNTED.equals(storageState)) {
    try {
      File noMedia=new File(directoryPath,""String_Node_Str"");
      if (noMedia.exists()) {
        return true;
      }
      FileOutputStream noMediaOutStream=new FileOutputStream(noMedia);
      noMediaOutStream.write(0);
      noMediaOutStream.close();
    }
 catch (    Exception e) {
      return false;
    }
  }
 else {
    return false;
  }
  return true;
}","/** 
 * @param directoryPath The full path to the directory to place the .nomedia file
 * @return Returns true if the file was successfully written or appears to already exist
 */
public static boolean writeNoMediaFile(String directoryPath){
  String storageState=Environment.getExternalStorageState();
  if (Environment.MEDIA_MOUNTED.equals(storageState)) {
    try {
      File noMedia=new File(directoryPath,""String_Node_Str"");
      if (noMedia.exists()) {
        return true;
      }
      FileOutputStream noMediaOutStream=new FileOutputStream(noMedia);
      noMediaOutStream.write(0);
      noMediaOutStream.close();
    }
 catch (    Exception e) {
      return false;
    }
  }
 else {
    return false;
  }
  return true;
}","The original code lacks the `static` keyword for the method, potentially causing issues with method invocation and object instantiation. The fixed code adds `static` to the method signature, allowing it to be called directly on the class without creating an instance. This modification improves code flexibility and ensures proper method accessibility in static contexts."
94103,"public static Bitmap retrieveAppropriateBitmap(String url,Context context){
  File iconDirectory=new File(Preferences.getSavePath(),""String_Node_Str"");
  if (!iconDirectory.exists() && !iconDirectory.mkdirs()) {
    return getBitmapFromURL(url,1);
  }
  String hashedFileName=hashBuilder(url);
  File iconFile=new File(iconDirectory,hashedFileName + ""String_Node_Str"");
  Logger.log(""String_Node_Str"" + iconFile.getPath());
  if (iconFile.exists()) {
    Bitmap bmp=loadBitmapFromFile(iconFile);
    if (bmp != null)     return bmp;
  }
  Bitmap bmp=getBitmapFromURL(url,1);
  SavingUtils.savePNGAsync(iconFile,bmp,context,false);
  return bmp;
}","public static Bitmap retrieveAppropriateBitmap(String url,Context context){
  File iconDirectory=new File(Preferences.getSavePath(),""String_Node_Str"");
  if (!iconDirectory.exists() && !iconDirectory.mkdirs()) {
    return getBitmapFromURL(url,1);
  }
  String hashedFileName=hashBuilder(url);
  File iconFile=new File(iconDirectory,hashedFileName + ""String_Node_Str"");
  Logger.log(""String_Node_Str"" + iconFile.getPath());
  if (iconFile.exists()) {
    Bitmap bmp=loadBitmapFromFile(iconFile);
    if (bmp != null)     return bmp;
  }
  Bitmap bmp=getBitmapFromURL(url,1);
  SavingUtils.savePNGAsync(iconFile,bmp,context,false);
  File nomediaFile=new File(Preferences.getSavePath(),""String_Node_Str"");
  if (!nomediaFile.exists())   MainActivity.writeNoMediaFile(Preferences.getSavePath() + ""String_Node_Str"");
  return bmp;
}","The original code lacks a mechanism to prevent media files from being indexed by media scanners, potentially exposing cached images in media galleries. The fixed code adds a `.nomedia` file creation step using `MainActivity.writeNoMediaFile()`, which prevents media scanners from indexing files in the specified directory. This enhancement ensures privacy by keeping cached images hidden from the user's media gallery and maintaining a clean, uncluttered storage environment."
94104,"public ContentValues getContent(String tableName,String columnName,String[] selectionArgs,String sortOrder,String[] projection){
  Logger.log(""String_Node_Str"");
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  if (cursor.getCount() == 0)   return null;
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  ContentValues content=getValuesFromCursor(cursor,projection);
  cursor.close();
  if (content == null) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  Logger.log(""String_Node_Str"" + content.size());
  return content;
}","public ContentValues getContent(String tableName,String columnName,String[] selectionArgs,String sortOrder,String[] projection){
  Logger.log(""String_Node_Str"");
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  ContentValues content=getValuesFromCursor(cursor,projection);
  cursor.close();
  if (content == null) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  Logger.log(""String_Node_Str"" + content.size());
  return content;
}","The original code redundantly checked cursor count before moving to first row, potentially causing unnecessary null return. The fixed code removes the redundant count check, directly attempting to move to the first row and returning null if no data exists. This simplifies the logic, reduces unnecessary checks, and provides a more straightforward approach to handling empty cursors while maintaining the same error handling and data retrieval functionality."
94105,"public ArrayList<Object> performQueryForBuiltObjects(String tableName,String selection,String[] selectionArgs,String[] projection,String sortOrder,CallbackHandler callbackHandler){
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  callbackHandler.addParams(cursor);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  if (cursor.getCount() == 0)   return null;
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  ArrayList<Object> invocationResponse;
  try {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName() + ""String_Node_Str""+ callbackHandler.parameters);
    invocationResponse=(ArrayList<Object>)callbackHandler.method.invoke(callbackHandler.caller,callbackHandler.parameters);
  }
 catch (  IllegalAccessException e) {
    e.printStackTrace();
    cursor.close();
    return null;
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
    cursor.close();
    return null;
  }
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName());
    return null;
  }
  cursor.close();
  return invocationResponse;
}","public ArrayList<Object> performQueryForBuiltObjects(String tableName,String selection,String[] selectionArgs,String[] projection,String sortOrder,CallbackHandler callbackHandler){
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  callbackHandler.addParams(cursor);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  ArrayList<Object> invocationResponse;
  try {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName() + ""String_Node_Str""+ callbackHandler.parameters);
    invocationResponse=(ArrayList<Object>)callbackHandler.method.invoke(callbackHandler.caller,callbackHandler.parameters);
  }
 catch (  IllegalAccessException e) {
    e.printStackTrace();
    cursor.close();
    return null;
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
    cursor.close();
    return null;
  }
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName());
    return null;
  }
  cursor.close();
  return invocationResponse;
}","The original code unnecessarily checks `cursor.getCount() == 0` before checking `cursor.moveToFirst()`, which is redundant and can lead to inefficient cursor handling. The fixed code removes this redundant check, directly attempting to move to the first row and immediately returning null if no rows exist. This streamlines the cursor navigation process, making the code more concise and efficient while maintaining the same logical flow and error handling."
94106,"public Object getBuiltContent(String tableName,String columnName,String[] selectionArgs,String sortOrder,String[] projection,CallbackHandler callbackHandler){
  Logger.log(""String_Node_Str"");
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  callbackHandler.addParams(cursor);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  if (cursor.getCount() == 0)   return null;
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  Object invocationResponse;
  try {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName() + ""String_Node_Str""+ callbackHandler.parameters);
    invocationResponse=callbackHandler.method.invoke(callbackHandler.caller,callbackHandler.parameters);
  }
 catch (  IllegalAccessException e) {
    e.printStackTrace();
    cursor.close();
    return null;
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
    cursor.close();
    return null;
  }
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName());
    return null;
  }
  cursor.close();
  return invocationResponse;
}","public Object getBuiltContent(String tableName,String columnName,String[] selectionArgs,String sortOrder,String[] projection,CallbackHandler callbackHandler){
  Logger.log(""String_Node_Str"");
  String selection=columnName + ""String_Node_Str"";
  Cursor cursor=getDatabase().query(tableName,projection,selection,selectionArgs,null,null,sortOrder);
  callbackHandler.addParams(cursor);
  Logger.log(""String_Node_Str"" + cursor.getCount());
  if (!cursor.moveToFirst()) {
    Logger.log(""String_Node_Str"");
    return null;
  }
  Object invocationResponse;
  try {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName() + ""String_Node_Str""+ callbackHandler.parameters);
    invocationResponse=callbackHandler.method.invoke(callbackHandler.caller,callbackHandler.parameters);
  }
 catch (  IllegalAccessException e) {
    e.printStackTrace();
    cursor.close();
    return null;
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
    cursor.close();
    return null;
  }
  if (invocationResponse == null) {
    Logger.log(""String_Node_Str"" + callbackHandler.method.getName());
    return null;
  }
  cursor.close();
  return invocationResponse;
}","The buggy code redundantly checks `cursor.getCount() == 0` before attempting to move the cursor, which is unnecessary and can lead to premature null returns. The fixed code removes this redundant check, directly attempting to move the cursor to the first row using `moveToFirst()`. By eliminating the redundant condition, the code becomes more streamlined and ensures a single, consistent path for cursor handling and method invocation."
94107,"public LensData getLens(String mCode){
  Logger.log(""String_Node_Str"");
  String[] selectionArgs={mCode};
  String sortOrder=LensEntry.COLUMN_NAME_MCODE + ""String_Node_Str"";
  CallbackHandler callback=getCallback(""String_Node_Str"",LensDatabaseHelper.class,Cursor.class);
  LensData lensData=(LensData)super.getBuiltContent(LensEntry.TABLE_NAME,LensEntry.COLUMN_NAME_MCODE,selectionArgs,sortOrder,fullProjection,callback);
  if (lensData == null)   return null;
  Logger.log(""String_Node_Str"" + lensData.mCode);
  return lensData;
}","public LensData getLens(String mCode){
  Logger.log(""String_Node_Str"");
  String[] selectionArgs={mCode};
  String sortOrder=LensEntry.COLUMN_NAME_MCODE + ""String_Node_Str"";
  CallbackHandler callback=getCallback(""String_Node_Str"",LensDatabaseHelper.class,Cursor.class);
  LensData lensData=(LensData)super.getBuiltContent(LensEntry.TABLE_NAME,LensEntry.COLUMN_NAME_MCODE,selectionArgs,sortOrder,fullProjection,callback);
  Logger.log(""String_Node_Str"" + lensData.mCode);
  return lensData;
}","The original code unnecessarily checks if `lensData` is null before returning, potentially hiding important error scenarios or database retrieval issues. In the fixed code, the null check is removed, allowing potential null returns to propagate and be handled by the caller. This change simplifies the method, enables more transparent error handling, and ensures that any database retrieval problems are immediately visible to the calling method."
94108,"public View onCreateView(final LayoutInflater inflater,final ViewGroup container,Bundle savedInstanceState){
  int lensListSize=(int)MainActivity.lensDBHelper.getRowCount();
  int selectedLensSize=MainActivity.lensDBHelper.getActiveLensCount();
  View view=inflater.inflate(R.layout.lensloader_layout,container,false);
  Button lensLoaderButton=(Button)view.findViewById(R.id.btnLensSelector);
  TextView totalLensesTextView=(TextView)view.findViewById(R.id.textview_total_lens_count);
  final TextView loadedLensesTextView=(TextView)view.findViewById(R.id.textview_loaded_lens_count);
  Switch loadLensSwitch=(Switch)view.findViewById(R.id.lensloader_toggle);
  Switch collectLensSwitch=(Switch)view.findViewById(R.id.lenscollector_toggle);
  Switch autoEnableSwitch=(Switch)view.findViewById(R.id.autoenable_switch);
  loadLensSwitch.setChecked(Preferences.getBool(Prefs.LENSES_LOAD));
  collectLensSwitch.setChecked(Preferences.getBool(Prefs.LENSES_COLLECT));
  autoEnableSwitch.setChecked(Preferences.getBool(Prefs.LENSES_AUTO_ENABLE));
  loadLensSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      Preferences.putBool(Prefs.LENSES_LOAD.key,isChecked);
    }
  }
);
  collectLensSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      Preferences.putBool(Prefs.LENSES_COLLECT.key,isChecked);
    }
  }
);
  autoEnableSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton compoundButton,    boolean isChecked){
      Preferences.putBool(Prefs.LENSES_AUTO_ENABLE.key,isChecked);
    }
  }
);
  totalLensesTextView.setText(String.format(""String_Node_Str"",lensListSize));
  loadedLensesTextView.setText(String.format(""String_Node_Str"",selectedLensSize));
  lensLoaderButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      DialogHelper.lensDialog(getContext(),loadedLensesTextView,inflater,container);
    }
  }
);
  return view;
}","public View onCreateView(final LayoutInflater inflater,final ViewGroup container,Bundle savedInstanceState){
  final int lensListSize=(int)MainActivity.lensDBHelper.getRowCount();
  int selectedLensSize=MainActivity.lensDBHelper.getActiveLensCount();
  View view=inflater.inflate(R.layout.lensloader_layout,container,false);
  Button lensLoaderButton=(Button)view.findViewById(R.id.btnLensSelector);
  TextView totalLensesTextView=(TextView)view.findViewById(R.id.textview_total_lens_count);
  final TextView loadedLensesTextView=(TextView)view.findViewById(R.id.textview_loaded_lens_count);
  Switch loadLensSwitch=(Switch)view.findViewById(R.id.lensloader_toggle);
  Switch collectLensSwitch=(Switch)view.findViewById(R.id.lenscollector_toggle);
  Switch autoEnableSwitch=(Switch)view.findViewById(R.id.autoenable_switch);
  loadLensSwitch.setChecked(Preferences.getBool(Prefs.LENSES_LOAD));
  collectLensSwitch.setChecked(Preferences.getBool(Prefs.LENSES_COLLECT));
  autoEnableSwitch.setChecked(Preferences.getBool(Prefs.LENSES_AUTO_ENABLE));
  loadLensSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      Preferences.putBool(Prefs.LENSES_LOAD.key,isChecked);
    }
  }
);
  collectLensSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      Preferences.putBool(Prefs.LENSES_COLLECT.key,isChecked);
    }
  }
);
  autoEnableSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton compoundButton,    boolean isChecked){
      Preferences.putBool(Prefs.LENSES_AUTO_ENABLE.key,isChecked);
    }
  }
);
  totalLensesTextView.setText(String.format(""String_Node_Str"",lensListSize));
  loadedLensesTextView.setText(String.format(""String_Node_Str"",selectedLensSize));
  lensLoaderButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (lensListSize > 0)       DialogHelper.lensDialog(getContext(),loadedLensesTextView,inflater,container);
 else       Toast.makeText(v.getContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
  }
);
  return view;
}","The original code lacked a check for lens list size before opening the lens dialog, potentially causing errors when no lenses were available. The fixed code adds a conditional check that verifies the lens list size is greater than zero, and includes a fallback Toast message if no lenses exist. This improvement prevents potential null pointer exceptions and provides better user feedback by gracefully handling scenarios with an empty lens collection."
94109,"public static void lensDialog(final Context context,final TextView loadedLensesTextView,LayoutInflater inflater,ViewGroup container){
  if (MainActivity.lensDBHelper == null)   MainActivity.lensDBHelper=new LensDatabaseHelper(context);
  ArrayList<Object> lensList=MainActivity.lensDBHelper.getAllLenses();
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  builder.setTitle(""String_Node_Str"");
  View view=inflater.inflate(R.layout.lenslist_layout,container,false);
  GridLayout gridLayout=(GridLayout)view.findViewById(R.id.lensloader_gridholder);
  for (  Object lensObj : lensList) {
    final LensData lensData=(LensData)lensObj;
    final LinearLayout inflatedLayout=(LinearLayout)inflater.inflate(R.layout.lensholder_layout,gridLayout,false);
    inflatedLayout.setBackgroundResource(lensData.mActive ? R.drawable.lens_bg_selected : R.drawable.lens_bg_unselected);
    inflatedLayout.setTag(lensData.mCode);
    inflatedLayout.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        LinearLayout btn=(LinearLayout)v;
        String mCode=(String)btn.getTag();
        Logger.log(""String_Node_Str"" + mCode);
        try {
          boolean activeState=MainActivity.lensDBHelper.toggleLensActiveState(mCode);
          inflatedLayout.setBackgroundResource(activeState ? R.drawable.lens_bg_selected : R.drawable.lens_bg_unselected);
          inflatedLayout.invalidate();
        }
 catch (        Exception e) {
          Logger.log(""String_Node_Str"" + mCode + ""String_Node_Str""+ e.getMessage());
        }
      }
    }
);
    ImageView iconImageView=(ImageView)inflatedLayout.findViewById(R.id.lensIconView);
    TextView iconName=(TextView)inflatedLayout.findViewById(R.id.lensTextView);
    String nameBuilder=lensData.mCode;
    for (    String filter : stringFilter)     nameBuilder=nameBuilder.replace(filter,""String_Node_Str"");
    nameBuilder=nameBuilder.replaceAll(""String_Node_Str"",""String_Node_Str"");
    iconName.setText(nameBuilder.trim());
    iconName.setMaxWidth(5);
    LensContainerData containerData=iconMap.get(lensData.mCode);
    if (containerData == null || containerData.bmp == null) {
      containerData=new LensContainerData(inflatedLayout,iconImageView,iconName,lensData.mIconLink,null);
      iconMap.put(lensData.mCode,containerData);
      new LensIconLoader.AsyncLensIconDownloader().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,containerData,context);
    }
 else {
      iconImageView.setImageBitmap(containerData.bmp);
      iconImageView.invalidate();
      iconName.setMaxWidth(containerData.bmp.getWidth());
      iconName.invalidate();
      inflatedLayout.invalidate();
    }
    gridLayout.addView(inflatedLayout);
  }
  builder.setView(view);
  builder.setPositiveButton(Common.dialog_done,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      int selectedLensSize=MainActivity.lensDBHelper.getActiveLensCount();
      loadedLensesTextView.setText(String.format(""String_Node_Str"",selectedLensSize));
    }
  }
);
  builder.setNegativeButton(Common.dialog_cancel,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      int selectedLensSize=MainActivity.lensDBHelper.getActiveLensCount();
      loadedLensesTextView.setText(String.format(""String_Node_Str"",selectedLensSize));
    }
  }
);
  builder.show();
}","public static void lensDialog(final Context context,final TextView loadedLensesTextView,LayoutInflater inflater,ViewGroup container){
  if (MainActivity.lensDBHelper == null)   MainActivity.lensDBHelper=new LensDatabaseHelper(context);
  ArrayList<Object> lensList=MainActivity.lensDBHelper.getAllLenses();
  if (lensList == null) {
    Logger.log(""String_Node_Str"");
    return;
  }
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  builder.setTitle(""String_Node_Str"");
  View view=inflater.inflate(R.layout.lenslist_layout,container,false);
  GridLayout gridLayout=(GridLayout)view.findViewById(R.id.lensloader_gridholder);
  for (  Object lensObj : lensList) {
    final LensData lensData=(LensData)lensObj;
    final LinearLayout inflatedLayout=(LinearLayout)inflater.inflate(R.layout.lensholder_layout,gridLayout,false);
    inflatedLayout.setBackgroundResource(lensData.mActive ? R.drawable.lens_bg_selected : R.drawable.lens_bg_unselected);
    inflatedLayout.setTag(lensData.mCode);
    inflatedLayout.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        LinearLayout btn=(LinearLayout)v;
        String mCode=(String)btn.getTag();
        Logger.log(""String_Node_Str"" + mCode);
        try {
          boolean activeState=MainActivity.lensDBHelper.toggleLensActiveState(mCode);
          inflatedLayout.setBackgroundResource(activeState ? R.drawable.lens_bg_selected : R.drawable.lens_bg_unselected);
          inflatedLayout.invalidate();
        }
 catch (        Exception e) {
          Logger.log(""String_Node_Str"" + mCode + ""String_Node_Str""+ e.getMessage());
        }
      }
    }
);
    ImageView iconImageView=(ImageView)inflatedLayout.findViewById(R.id.lensIconView);
    TextView iconName=(TextView)inflatedLayout.findViewById(R.id.lensTextView);
    String nameBuilder=lensData.mCode;
    for (    String filter : stringFilter)     nameBuilder=nameBuilder.replace(filter,""String_Node_Str"");
    nameBuilder=nameBuilder.replaceAll(""String_Node_Str"",""String_Node_Str"");
    iconName.setText(nameBuilder.trim());
    iconName.setMaxWidth(5);
    LensContainerData containerData=iconMap.get(lensData.mCode);
    if (containerData == null || containerData.bmp == null) {
      containerData=new LensContainerData(inflatedLayout,iconImageView,iconName,lensData.mIconLink,null);
      iconMap.put(lensData.mCode,containerData);
      new LensIconLoader.AsyncLensIconDownloader().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,containerData,context);
    }
 else {
      iconImageView.setImageBitmap(containerData.bmp);
      iconImageView.invalidate();
      iconName.setMaxWidth(containerData.bmp.getWidth());
      iconName.invalidate();
      inflatedLayout.invalidate();
    }
    gridLayout.addView(inflatedLayout);
  }
  builder.setView(view);
  builder.setPositiveButton(Common.dialog_done,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      int selectedLensSize=MainActivity.lensDBHelper.getActiveLensCount();
      loadedLensesTextView.setText(String.format(""String_Node_Str"",selectedLensSize));
    }
  }
);
  builder.setNegativeButton(Common.dialog_cancel,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      int selectedLensSize=MainActivity.lensDBHelper.getActiveLensCount();
      loadedLensesTextView.setText(String.format(""String_Node_Str"",selectedLensSize));
    }
  }
);
  builder.show();
}","The original code lacked a null check for the lensList, which could lead to potential NullPointerExceptions when retrieving lenses from the database. The fixed code adds a null check and returns early with a log message if no lenses are found, preventing potential crashes and providing graceful error handling. This modification improves the method's robustness by ensuring that the code only proceeds when valid lens data is available, enhancing the overall stability of the lens dialog functionality."
94110,"public static ArrayList<Object> buildModifiedList(ArrayList<Object> list,ArrayList<String> lensBlacklist){
  Logger.log(""String_Node_Str"" + list.size());
  ArrayList<Object> lensList=MainActivity.lensDBHelper.getAllExcept(lensBlacklist);
  Logger.log(""String_Node_Str"" + lensList.size());
  for (  Object lensObj : lensList) {
    LensData lensData=(LensData)lensObj;
    if (!lensData.mActive)     continue;
    Object lens=buildModifiedLens(lensData);
    list.add(lens);
  }
  Logger.log(""String_Node_Str"" + list.size());
  return list;
}","public static ArrayList<Object> buildModifiedList(ArrayList<Object> list,ArrayList<String> lensBlacklist){
  Logger.log(""String_Node_Str"" + list.size());
  ArrayList<Object> lensList=MainActivity.lensDBHelper.getAllExcept(lensBlacklist);
  if (lensList == null) {
    Logger.log(""String_Node_Str"");
    return list;
  }
  Logger.log(""String_Node_Str"" + lensList.size());
  for (  Object lensObj : lensList) {
    LensData lensData=(LensData)lensObj;
    if (!lensData.mActive)     continue;
    Object lens=buildModifiedLens(lensData);
    list.add(lens);
  }
  Logger.log(""String_Node_Str"" + list.size());
  return list;
}","The original code lacks null checking for the lensList, which could cause a NullPointerException if getAllExcept() returns null. The fixed code adds a null check that logs a message and returns the original list if lensList is null, preventing potential runtime crashes. This defensive programming approach ensures robust error handling and graceful degradation when database operations fail to return expected results."
94111,"@Override public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  try {
    if (!lpparam.packageName.equals(Common.PACKAGE_SNAP))     return;
    try {
      Preferences.mSavePath=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
      Preferences.mCustomFilterLocation=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
      XposedUtils.log(""String_Node_Str"",false);
      Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
      context=(Context)callMethod(activityThread,""String_Node_Str"");
      classLoader=lpparam.classLoader;
      PackageInfo piSnapChat=context.getPackageManager().getPackageInfo(lpparam.packageName,0);
      XposedUtils.log(""String_Node_Str"" + piSnapChat.versionName + ""String_Node_Str""+ piSnapChat.versionCode+ ""String_Node_Str"",false);
      XposedUtils.log(""String_Node_Str"" + BuildConfig.VERSION_NAME + ""String_Node_Str""+ BuildConfig.VERSION_CODE+ ""String_Node_Str"",false);
      if (!Obfuscator.isSupported(piSnapChat.versionCode)) {
        Logger.log(""String_Node_Str"",true,true);
        Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        return;
      }
    }
 catch (    Exception e) {
      XposedUtils.log(""String_Node_Str"",e);
      return;
    }
    findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Context.class,new XC_MethodHook(){
      @Override protected void afterHookedMethod(      MethodHookParam param) throws Throwable {
        Preferences.refreshPreferences();
        Preferences.printSettings();
        if (Preferences.mLicense == 1 || Preferences.mLicense == 2) {
          if (Preferences.mReplay) {
          }
          if (Preferences.mTyping) {
            Premium.initTyping(lpparam,modRes,SnapContext);
          }
          if (Preferences.mStealth && Preferences.mLicense == 2) {
            Premium.initViewed(lpparam,modRes,SnapContext);
          }
        }
        Preferences.prefs.reload();
        Preferences.refreshPreferences();
        XC_MethodHook initHook=new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param) throws Throwable {
            Preferences.prefs.reload();
            Preferences.refreshPreferences();
            SnapContext=(Activity)param.thisObject;
            if (!Preferences.acceptedToU) {
              AlertDialog.Builder builder=new AlertDialog.Builder(SnapContext).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setIcon(android.R.drawable.ic_dialog_alert);
              builder.setCancelable(false);
              final AlertDialog dialog=builder.create();
              dialog.setCanceledOnTouchOutside(false);
              dialog.show();
              return;
            }
            boolean isNull;
            isNull=SnapContext == null;
            Logger.log(""String_Node_Str"" + isNull,true);
            Preferences.prefs.reload();
            Preferences.refreshPreferences();
            Saving.initSaving(lpparam,mResources,SnapContext);
            Lens.initLens(lpparam,mResources,SnapContext);
            File vfilters=new File(Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"");
            if (vfilters.exists()) {
              VisualFilters.initVisualFilters(lpparam);
            }
 else {
              Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
            }
            if (Preferences.mHideLive || Preferences.mHidePeople || Preferences.mDiscoverUI) {
              Stories.initStories(lpparam);
            }
            Groups.initGroups(lpparam);
            if (Preferences.shouldAddGhost) {
              HookedLayouts.initVisiblity(lpparam);
            }
            if (Preferences.mMultiFilterBoolean) {
              MultiFilter.initMultiFilter(lpparam,mResources,SnapContext);
            }
            if (Preferences.mDiscoverSnap) {
              DataSaving.blockDsnap(lpparam);
            }
            if (Preferences.mStoryPreload) {
              DataSaving.blockStoryPreLoad(lpparam);
            }
            if (Preferences.mDiscoverUI) {
              DataSaving.blockFromUi(lpparam);
            }
            if (Preferences.mSpeed) {
              Spoofing.initSpeed(lpparam,SnapContext);
            }
            if (Preferences.mLocation) {
              Spoofing.initLocation(lpparam,SnapContext);
            }
            if (Preferences.mWeather) {
              Spoofing.initWeather(lpparam,SnapContext);
            }
            if (Preferences.mPaintTools) {
              PaintTools.initPaint(lpparam,mResources);
            }
            if (Preferences.mTimerCounter) {
              Misc.initTimer(lpparam,mResources);
            }
            if (Preferences.mChatAutoSave) {
              Chat.initTextSave(lpparam,mResources);
            }
            if (Preferences.mChatMediaSave) {
              Chat.initImageSave(lpparam,mResources);
            }
            if (Preferences.mIntegration) {
              HookedLayouts.initIntegration(lpparam,mResources);
            }
            Misc.forceNavBar(lpparam,Preferences.mForceNavbar);
            getEditText(lpparam);
            findAndHookMethod(Obfuscator.save.SCREENSHOTDETECTOR_CLASS,lpparam.classLoader,Obfuscator.save.SCREENSHOTDETECTOR_RUN,LinkedHashMap.class,XC_MethodReplacement.DO_NOTHING);
            findAndHookMethod(Obfuscator.save.SNAPSTATEMESSAGE_CLASS,lpparam.classLoader,Obfuscator.save.SNAPSTATEMESSAGE_SETSCREENSHOTCOUNT,Long.class,new XC_MethodHook(){
              @Override protected void beforeHookedMethod(              MethodHookParam param){
                param.args[0]=0L;
                Logger.log(""String_Node_Str"",true);
              }
            }
);
            if (Preferences.mCustomSticker) {
              Stickers.initStickers(lpparam,modRes,SnapContext);
            }
          }
        }
;
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Bundle.class,initHook);
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",initHook);
        findAndHookMethod(Obfuscator.icons.ICON_HANDLER_CLASS,lpparam.classLoader,Obfuscator.icons.SHOW_LENS,boolean.class,boolean.class,new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if ((boolean)param.args[0]) {
              HookedLayouts.upload.setVisibility(View.INVISIBLE);
            }
 else {
              HookedLayouts.upload.setVisibility(View.VISIBLE);
            }
          }
        }
);
        findAndHookMethod(Obfuscator.icons.ICON_HANDLER_CLASS,lpparam.classLoader,Obfuscator.icons.RECORDING_VIDEO,boolean.class,new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            HookedLayouts.upload.setVisibility(View.VISIBLE);
          }
        }
);
        for (        String s : Obfuscator.ROOTDETECTOR_METHODS) {
          findAndHookMethod(Obfuscator.ROOTDETECTOR_CLASS,lpparam.classLoader,s,XC_MethodReplacement.returnConstant(false));
          Logger.log(""String_Node_Str"" + s,true);
        }
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",int.class,new XC_MethodHook(){
          @Override protected void beforeHookedMethod(          MethodHookParam param){
            param.args[0]=12000000;
          }
        }
);
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",long.class,new XC_MethodHook(){
          @Override protected void beforeHookedMethod(          MethodHookParam param){
            param.args[0]=5190453;
          }
        }
);
        final Class<?> receivedSnapClass=findClass(Obfuscator.save.RECEIVEDSNAP_CLASS,lpparam.classLoader);
        try {
          XposedHelpers.setStaticIntField(receivedSnapClass,""String_Node_Str"",99999);
          final Class<?> snapMediaUtils=findClass(""String_Node_Str"",lpparam.classLoader);
          XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
          XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
          final Class<?> profileImageUtils=findClass(""String_Node_Str"",lpparam.classLoader);
          XposedHelpers.setStaticIntField(profileImageUtils,""String_Node_Str"",100);
          final Class<?> snapImageBryo=findClass(Obfuscator.save.SNAPIMAGEBRYO_CLASS,lpparam.classLoader);
          XposedHelpers.setStaticIntField(snapImageBryo,""String_Node_Str"",100);
          Logger.log(""String_Node_Str"",true);
        }
 catch (        Throwable t) {
          Logger.log(""String_Node_Str"",true);
          Logger.log(t.toString());
        }
        if (Common.CAPTION_UNLIMITED_VANILLA) {
          findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",XC_MethodReplacement.DO_NOTHING);
        }
        String vanillaCaptionEditTextClassName=""String_Node_Str"";
        hookAllConstructors(findClass(vanillaCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if (Common.CAPTION_UNLIMITED_VANILLA) {
              XposedUtils.log(""String_Node_Str"");
              EditText vanillaCaptionEditText=(EditText)param.thisObject;
              vanillaCaptionEditText.setSingleLine(false);
              vanillaCaptionEditText.setFilters(new InputFilter[0]);
              vanillaCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
              vanillaCaptionEditText.setOnEditorActionListener(null);
              setObjectField(vanillaCaptionEditText,""String_Node_Str"",null);
            }
          }
        }
);
        String fatCaptionEditTextClassName=""String_Node_Str"";
        hookAllConstructors(findClass(fatCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if (Common.CAPTION_UNLIMITED_FAT) {
              XposedUtils.log(""String_Node_Str"");
              EditText fatCaptionEditText=(EditText)param.thisObject;
              fatCaptionEditText.setFilters(new InputFilter[0]);
              fatCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
              fatCaptionEditText.setOnEditorActionListener(null);
              setObjectField(fatCaptionEditText,""String_Node_Str"",null);
            }
          }
        }
);
        Sharing.initSharing(lpparam,mResources);
        if (Preferences.hideBf) {
          findAndHookMethod(""String_Node_Str"",lpparam.classLoader,Obfuscator.FRIENDS_BF,new XC_MethodReplacement(){
            @Override protected Object replaceHookedMethod(            MethodHookParam param){
              return false;
            }
          }
);
        }
        if (Preferences.mCustomFilterBoolean) {
          addFilter(lpparam);
        }
        if (Preferences.selectAll) {
          HookSendList.initSelectAll(lpparam);
        }
      }
    }
);
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"",e);
  }
}","@Override public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  try {
    if (!lpparam.packageName.equals(Common.PACKAGE_SNAP))     return;
    try {
      Preferences.mSavePath=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
      Preferences.mCustomFilterLocation=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
      XposedUtils.log(""String_Node_Str"",false);
      Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
      context=(Context)callMethod(activityThread,""String_Node_Str"");
      classLoader=lpparam.classLoader;
      PackageInfo piSnapChat=context.getPackageManager().getPackageInfo(lpparam.packageName,0);
      XposedUtils.log(""String_Node_Str"" + piSnapChat.versionName + ""String_Node_Str""+ piSnapChat.versionCode+ ""String_Node_Str"",false);
      XposedUtils.log(""String_Node_Str"" + BuildConfig.VERSION_NAME + ""String_Node_Str""+ BuildConfig.VERSION_CODE+ ""String_Node_Str"",false);
      if (!Obfuscator.isSupported(piSnapChat.versionCode)) {
        Logger.log(""String_Node_Str"",true,true);
        Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        return;
      }
    }
 catch (    Exception e) {
      XposedUtils.log(""String_Node_Str"",e);
      return;
    }
    findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Context.class,new XC_MethodHook(){
      @Override protected void afterHookedMethod(      MethodHookParam param) throws Throwable {
        Preferences.refreshPreferences();
        Logger.log(""String_Node_Str"" + Preferences.prefs.makeWorldReadable(),true);
        Preferences.printSettings();
        if (Preferences.mLicense == 1 || Preferences.mLicense == 2) {
          if (Preferences.mReplay) {
          }
          if (Preferences.mTyping) {
            Premium.initTyping(lpparam,modRes,SnapContext);
          }
          if (Preferences.mStealth && Preferences.mLicense == 2) {
            Premium.initViewed(lpparam,modRes,SnapContext);
          }
        }
        Preferences.prefs.reload();
        Preferences.refreshPreferences();
        XC_MethodHook initHook=new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param) throws Throwable {
            Preferences.prefs.reload();
            Preferences.refreshPreferences();
            Preferences.prefs.makeWorldReadable();
            SnapContext=(Activity)param.thisObject;
            if (!Preferences.acceptedToU) {
              AlertDialog.Builder builder=new AlertDialog.Builder(SnapContext).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setIcon(android.R.drawable.ic_dialog_alert);
              builder.setCancelable(false);
              final AlertDialog dialog=builder.create();
              dialog.setCanceledOnTouchOutside(false);
              dialog.show();
              return;
            }
            boolean isNull;
            isNull=SnapContext == null;
            Logger.log(""String_Node_Str"" + isNull,true);
            Preferences.prefs.reload();
            Preferences.refreshPreferences();
            Saving.initSaving(lpparam,mResources,SnapContext);
            Lens.initLens(lpparam,mResources,SnapContext);
            File vfilters=new File(Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"");
            if (vfilters.exists()) {
              VisualFilters.initVisualFilters(lpparam);
            }
 else {
              Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
            }
            if (Preferences.mHideLive || Preferences.mHidePeople || Preferences.mDiscoverUI) {
              Stories.initStories(lpparam);
            }
            Groups.initGroups(lpparam);
            if (Preferences.shouldAddGhost) {
              HookedLayouts.initVisiblity(lpparam);
            }
            if (Preferences.mMultiFilterBoolean) {
              MultiFilter.initMultiFilter(lpparam,mResources,SnapContext);
            }
            if (Preferences.mDiscoverSnap) {
              DataSaving.blockDsnap(lpparam);
            }
            if (Preferences.mStoryPreload) {
              DataSaving.blockStoryPreLoad(lpparam);
            }
            if (Preferences.mDiscoverUI) {
              DataSaving.blockFromUi(lpparam);
            }
            if (Preferences.mSpeed) {
              Spoofing.initSpeed(lpparam,SnapContext);
            }
            if (Preferences.mLocation) {
              Spoofing.initLocation(lpparam,SnapContext);
            }
            if (Preferences.mWeather) {
              Spoofing.initWeather(lpparam,SnapContext);
            }
            if (Preferences.mPaintTools) {
              PaintTools.initPaint(lpparam,mResources);
            }
            if (Preferences.mTimerCounter) {
              Misc.initTimer(lpparam,mResources);
            }
            if (Preferences.mChatAutoSave) {
              Chat.initTextSave(lpparam,mResources);
            }
            if (Preferences.mChatMediaSave) {
              Chat.initImageSave(lpparam,mResources);
            }
            if (Preferences.mIntegration) {
              HookedLayouts.initIntegration(lpparam,mResources);
            }
            Misc.forceNavBar(lpparam,Preferences.mForceNavbar);
            getEditText(lpparam);
            findAndHookMethod(Obfuscator.save.SCREENSHOTDETECTOR_CLASS,lpparam.classLoader,Obfuscator.save.SCREENSHOTDETECTOR_RUN,LinkedHashMap.class,XC_MethodReplacement.DO_NOTHING);
            findAndHookMethod(Obfuscator.save.SNAPSTATEMESSAGE_CLASS,lpparam.classLoader,Obfuscator.save.SNAPSTATEMESSAGE_SETSCREENSHOTCOUNT,Long.class,new XC_MethodHook(){
              @Override protected void beforeHookedMethod(              MethodHookParam param){
                param.args[0]=0L;
                Logger.log(""String_Node_Str"",true);
              }
            }
);
            if (Preferences.mCustomSticker) {
              Stickers.initStickers(lpparam,modRes,SnapContext);
            }
          }
        }
;
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Bundle.class,initHook);
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",initHook);
        findAndHookMethod(Obfuscator.icons.ICON_HANDLER_CLASS,lpparam.classLoader,Obfuscator.icons.SHOW_LENS,boolean.class,boolean.class,new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if ((boolean)param.args[0]) {
              HookedLayouts.upload.setVisibility(View.INVISIBLE);
            }
 else {
              HookedLayouts.upload.setVisibility(View.VISIBLE);
            }
          }
        }
);
        findAndHookMethod(Obfuscator.icons.ICON_HANDLER_CLASS,lpparam.classLoader,Obfuscator.icons.RECORDING_VIDEO,boolean.class,new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            HookedLayouts.upload.setVisibility(View.VISIBLE);
          }
        }
);
        for (        String s : Obfuscator.ROOTDETECTOR_METHODS) {
          findAndHookMethod(Obfuscator.ROOTDETECTOR_CLASS,lpparam.classLoader,s,XC_MethodReplacement.returnConstant(false));
          Logger.log(""String_Node_Str"" + s,true);
        }
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",int.class,new XC_MethodHook(){
          @Override protected void beforeHookedMethod(          MethodHookParam param){
            param.args[0]=12000000;
          }
        }
);
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",long.class,new XC_MethodHook(){
          @Override protected void beforeHookedMethod(          MethodHookParam param){
            param.args[0]=5190453;
          }
        }
);
        final Class<?> receivedSnapClass=findClass(Obfuscator.save.RECEIVEDSNAP_CLASS,lpparam.classLoader);
        try {
          XposedHelpers.setStaticIntField(receivedSnapClass,""String_Node_Str"",99999);
          final Class<?> snapMediaUtils=findClass(""String_Node_Str"",lpparam.classLoader);
          XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
          XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
          final Class<?> profileImageUtils=findClass(""String_Node_Str"",lpparam.classLoader);
          XposedHelpers.setStaticIntField(profileImageUtils,""String_Node_Str"",100);
          final Class<?> snapImageBryo=findClass(Obfuscator.save.SNAPIMAGEBRYO_CLASS,lpparam.classLoader);
          XposedHelpers.setStaticIntField(snapImageBryo,""String_Node_Str"",100);
          Logger.log(""String_Node_Str"",true);
        }
 catch (        Throwable t) {
          Logger.log(""String_Node_Str"",true);
          Logger.log(t.toString());
        }
        if (Common.CAPTION_UNLIMITED_VANILLA) {
          findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",XC_MethodReplacement.DO_NOTHING);
        }
        String vanillaCaptionEditTextClassName=""String_Node_Str"";
        hookAllConstructors(findClass(vanillaCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if (Common.CAPTION_UNLIMITED_VANILLA) {
              XposedUtils.log(""String_Node_Str"");
              EditText vanillaCaptionEditText=(EditText)param.thisObject;
              vanillaCaptionEditText.setSingleLine(false);
              vanillaCaptionEditText.setFilters(new InputFilter[0]);
              vanillaCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
              vanillaCaptionEditText.setOnEditorActionListener(null);
              setObjectField(vanillaCaptionEditText,""String_Node_Str"",null);
            }
          }
        }
);
        String fatCaptionEditTextClassName=""String_Node_Str"";
        hookAllConstructors(findClass(fatCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if (Common.CAPTION_UNLIMITED_FAT) {
              XposedUtils.log(""String_Node_Str"");
              EditText fatCaptionEditText=(EditText)param.thisObject;
              fatCaptionEditText.setFilters(new InputFilter[0]);
              fatCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
              fatCaptionEditText.setOnEditorActionListener(null);
              setObjectField(fatCaptionEditText,""String_Node_Str"",null);
            }
          }
        }
);
        Sharing.initSharing(lpparam,mResources);
        if (Preferences.hideBf) {
          findAndHookMethod(""String_Node_Str"",lpparam.classLoader,Obfuscator.FRIENDS_BF,new XC_MethodReplacement(){
            @Override protected Object replaceHookedMethod(            MethodHookParam param){
              return false;
            }
          }
);
        }
        if (Preferences.mCustomFilterBoolean) {
          addFilter(lpparam);
        }
        if (Preferences.selectAll) {
          HookSendList.initSelectAll(lpparam);
        }
      }
    }
);
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"",e);
  }
}","The original code lacked proper preference management and did not consistently handle preferences across method hooks. The fixed code adds `Preferences.prefs.makeWorldReadable()` and ensures preferences are reloaded and refreshed consistently in multiple locations, improving configuration synchronization. This enhancement provides more reliable preference handling, ensuring that configuration changes are accurately reflected throughout the Xposed module's execution."
94112,"@Override public void initZygote(StartupParam startupParam) throws Throwable {
  MODULE_PATH=startupParam.modulePath;
  mResources=XModuleResources.createInstance(startupParam.modulePath,null);
}","@Override public void initZygote(StartupParam startupParam) throws Throwable {
  MODULE_PATH=startupParam.modulePath;
  mResources=XModuleResources.createInstance(startupParam.modulePath,null);
  File prefsFile=new File(Environment.getDataDirectory(),""String_Node_Str"" + HookMethods.PACKAGE_NAME + ""String_Node_Str""+ HookMethods.PACKAGE_NAME+ ""String_Node_Str""+ ""String_Node_Str"");
  prefsFile.setReadable(true,false);
}","The original code lacks file permission management, potentially causing security or access issues when working with module resources. The fixed code adds a file creation step with explicit readable permissions, ensuring proper access to the preferences file across different contexts. This modification enhances file accessibility and security by setting readable permissions for the created file while maintaining the module's resource initialization process."
94113,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  final TelephonyManager tm=(TelephonyManager)getBaseContext().getSystemService(Context.TELEPHONY_SERVICE);
  final String tmDevice, tmSerial, androidId;
  tmDevice=""String_Node_Str"" + tm.getDeviceId();
  tmSerial=""String_Node_Str"" + tm.getSimSerialNumber();
  androidId=""String_Node_Str"" + android.provider.Settings.Secure.getString(getContentResolver(),android.provider.Settings.Secure.ANDROID_ID);
  UUID deviceUuid=new UUID(androidId.hashCode(),((long)tmDevice.hashCode() << 32) | tmSerial.hashCode());
  String deviceId=deviceUuid.toString();
  final String confirmationID=readStringPreference(""String_Node_Str"");
  final Context context=this;
  ChangeLog cl=new ChangeLog(context);
  if (cl.isFirstRun()) {
    cl.getLogDialog().show();
  }
  final SharedPreferences prefs=context.getSharedPreferences(""String_Node_Str"",Context.MODE_WORLD_READABLE);
  acceptedToU=prefs.getBoolean(""String_Node_Str"",false);
  if (!acceptedToU) {
    AlertDialog.Builder builder=new AlertDialog.Builder(context).setTitle(""String_Node_Str"").setView(R.layout.tos).setMessage(""String_Node_Str"").setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        SharedPreferences.Editor editor=prefs.edit();
        editor.putBoolean(""String_Node_Str"",true);
        editor.apply();
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
).setIcon(android.R.drawable.ic_dialog_alert);
    builder.setCancelable(false);
    final AlertDialog dialog=builder.create();
    dialog.setCanceledOnTouchOutside(false);
    dialog.show();
    Button privacypolicy=(Button)dialog.findViewById(R.id.privacypolicy);
    Button tou=(Button)dialog.findViewById(R.id.tou);
    CheckBox accepted=(CheckBox)dialog.findViewById(R.id.readandaccepted);
    privacypolicy.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        try {
          Intent myIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
          startActivity(myIntent);
        }
 catch (        ActivityNotFoundException e) {
          Toast.makeText(MainActivity.this,""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
          e.printStackTrace();
        }
      }
    }
);
    tou.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        try {
          Intent myIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
          startActivity(myIntent);
        }
 catch (        ActivityNotFoundException e) {
          Toast.makeText(MainActivity.this,""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
          e.printStackTrace();
        }
      }
    }
);
    dialog.getButton(DialogInterface.BUTTON_POSITIVE).setEnabled(false);
    accepted.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
      @Override public void onCheckedChanged(      CompoundButton compoundButton,      boolean b){
        dialog.getButton(DialogInterface.BUTTON_POSITIVE).setEnabled(b);
      }
    }
);
  }
  if (isGooglePlayInstalled()) {
    gcm=GoogleCloudMessaging.getInstance(getApplicationContext());
    gcmRegId=getSharedPreferences().getString(PREF_GCM_REG_ID,""String_Node_Str"");
    if (TextUtils.isEmpty(gcmRegId)) {
      handler.sendEmptyMessage(MSG_REGISTER_WITH_GCM);
    }
 else {
    }
  }
  sharedPreferences=PreferenceManager.getDefaultSharedPreferences(this);
  setContentView(R.layout.activity_main);
  AdView mAdView=(AdView)findViewById(R.id.adView);
  TextView pugs=(TextView)findViewById(R.id.pugs);
  if (readLicense(deviceId,confirmationID) == 1 || readLicense(deviceId,confirmationID) == 2) {
    mAdView.destroy();
    pugs.setVisibility(View.GONE);
    mAdView.setVisibility(View.GONE);
  }
 else {
    AdRequest adRequest=new AdRequest.Builder().addTestDevice(""String_Node_Str"").build();
    mAdView.loadAd(adRequest);
    pugs.setVisibility(View.VISIBLE);
    pugs.setText(""String_Node_Str"" + ""String_Node_Str"" + pugs.getText() + ""String_Node_Str""+ ""String_Node_Str"");
    mAdView.setVisibility(View.VISIBLE);
  }
  mDrawerLayout=(DrawerLayout)findViewById(R.id.drawerLayout);
  mNavigationView=(NavigationView)findViewById(R.id.fuckyou);
  if (readLicense(deviceId,confirmationID) == 1 || readLicense(deviceId,confirmationID) == 2) {
    mNavigationView.getMenu().getItem(1).getSubMenu().getItem(1).setEnabled(true);
    LinearLayout.LayoutParams lp=(LinearLayout.LayoutParams)mDrawerLayout.getLayoutParams();
    lp.setMargins(0,0,0,0);
    mDrawerLayout.setLayoutParams(lp);
  }
  mFragmentManager=getSupportFragmentManager();
  mFragmentManager.beginTransaction().replace(R.id.containerView,getForId(R.id.nav_item_main)).commit();
  mNavigationView.getMenu().getItem(0).setCheckable(true);
  mNavigationView.getMenu().getItem(0).setChecked(true);
  items.add(mNavigationView.getMenu().getItem(0));
  mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener(){
    @Override public boolean onNavigationItemSelected(    MenuItem menuItem){
      mDrawerLayout.closeDrawers();
      menuItem.setCheckable(true);
      menuItem.setChecked(true);
      Iterator<MenuItem> it=items.iterator();
      while (it.hasNext()) {
        MenuItem item=it.next();
        if (!item.equals(menuItem)) {
          item.setChecked(false);
        }
      }
      items.add(menuItem);
      mFragmentManager.beginTransaction().replace(R.id.containerView,getForId(menuItem.getItemId())).commit();
      return false;
    }
  }
);
  android.support.v7.widget.Toolbar toolbar=(android.support.v7.widget.Toolbar)findViewById(R.id.toolbar);
  ActionBarDrawerToggle mDrawerToggle=new ActionBarDrawerToggle(this,mDrawerLayout,toolbar,R.string.app_name,R.string.app_name);
  mDrawerLayout.setDrawerListener(mDrawerToggle);
  mDrawerToggle.syncState();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  final TelephonyManager tm=(TelephonyManager)getBaseContext().getSystemService(Context.TELEPHONY_SERVICE);
  final String tmDevice, tmSerial, androidId;
  tmDevice=""String_Node_Str"" + tm.getDeviceId();
  tmSerial=""String_Node_Str"" + tm.getSimSerialNumber();
  androidId=""String_Node_Str"" + android.provider.Settings.Secure.getString(getContentResolver(),android.provider.Settings.Secure.ANDROID_ID);
  UUID deviceUuid=new UUID(androidId.hashCode(),((long)tmDevice.hashCode() << 32) | tmSerial.hashCode());
  String deviceId=deviceUuid.toString();
  final String confirmationID=readStringPreference(""String_Node_Str"");
  final Context context=this;
  ChangeLog cl=new ChangeLog(context);
  if (cl.isFirstRun()) {
    cl.getLogDialog().show();
  }
  final SharedPreferences prefs=context.getSharedPreferences(""String_Node_Str"",Context.MODE_WORLD_READABLE);
  File prefsFile=new File(Environment.getDataDirectory(),""String_Node_Str"" + getPackageName() + ""String_Node_Str""+ getPackageName()+ ""String_Node_Str""+ ""String_Node_Str"");
  prefsFile.setReadable(true,false);
  acceptedToU=prefs.getBoolean(""String_Node_Str"",false);
  if (!acceptedToU) {
    AlertDialog.Builder builder=new AlertDialog.Builder(context).setTitle(""String_Node_Str"").setView(R.layout.tos).setMessage(""String_Node_Str"").setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        SharedPreferences.Editor editor=prefs.edit();
        editor.putBoolean(""String_Node_Str"",true);
        editor.apply();
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
).setIcon(android.R.drawable.ic_dialog_alert);
    builder.setCancelable(false);
    final AlertDialog dialog=builder.create();
    dialog.setCanceledOnTouchOutside(false);
    dialog.show();
    Button privacypolicy=(Button)dialog.findViewById(R.id.privacypolicy);
    Button tou=(Button)dialog.findViewById(R.id.tou);
    CheckBox accepted=(CheckBox)dialog.findViewById(R.id.readandaccepted);
    privacypolicy.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        try {
          Intent myIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
          startActivity(myIntent);
        }
 catch (        ActivityNotFoundException e) {
          Toast.makeText(MainActivity.this,""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
          e.printStackTrace();
        }
      }
    }
);
    tou.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        try {
          Intent myIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
          startActivity(myIntent);
        }
 catch (        ActivityNotFoundException e) {
          Toast.makeText(MainActivity.this,""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
          e.printStackTrace();
        }
      }
    }
);
    dialog.getButton(DialogInterface.BUTTON_POSITIVE).setEnabled(false);
    accepted.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
      @Override public void onCheckedChanged(      CompoundButton compoundButton,      boolean b){
        dialog.getButton(DialogInterface.BUTTON_POSITIVE).setEnabled(b);
      }
    }
);
  }
  if (isGooglePlayInstalled()) {
    gcm=GoogleCloudMessaging.getInstance(getApplicationContext());
    gcmRegId=getSharedPreferences().getString(PREF_GCM_REG_ID,""String_Node_Str"");
    if (TextUtils.isEmpty(gcmRegId)) {
      handler.sendEmptyMessage(MSG_REGISTER_WITH_GCM);
    }
 else {
    }
  }
  sharedPreferences=PreferenceManager.getDefaultSharedPreferences(this);
  setContentView(R.layout.activity_main);
  AdView mAdView=(AdView)findViewById(R.id.adView);
  TextView pugs=(TextView)findViewById(R.id.pugs);
  if (readLicense(deviceId,confirmationID) == 1 || readLicense(deviceId,confirmationID) == 2) {
    mAdView.destroy();
    pugs.setVisibility(View.GONE);
    mAdView.setVisibility(View.GONE);
  }
 else {
    AdRequest adRequest=new AdRequest.Builder().addTestDevice(""String_Node_Str"").build();
    mAdView.loadAd(adRequest);
    pugs.setVisibility(View.VISIBLE);
    pugs.setText(""String_Node_Str"" + ""String_Node_Str"" + pugs.getText() + ""String_Node_Str""+ ""String_Node_Str"");
    mAdView.setVisibility(View.VISIBLE);
  }
  mDrawerLayout=(DrawerLayout)findViewById(R.id.drawerLayout);
  mNavigationView=(NavigationView)findViewById(R.id.fuckyou);
  if (readLicense(deviceId,confirmationID) == 1 || readLicense(deviceId,confirmationID) == 2) {
    mNavigationView.getMenu().getItem(1).getSubMenu().getItem(1).setEnabled(true);
    LinearLayout.LayoutParams lp=(LinearLayout.LayoutParams)mDrawerLayout.getLayoutParams();
    lp.setMargins(0,0,0,0);
    mDrawerLayout.setLayoutParams(lp);
  }
  mFragmentManager=getSupportFragmentManager();
  mFragmentManager.beginTransaction().replace(R.id.containerView,getForId(R.id.nav_item_main)).commit();
  mNavigationView.getMenu().getItem(0).setCheckable(true);
  mNavigationView.getMenu().getItem(0).setChecked(true);
  items.add(mNavigationView.getMenu().getItem(0));
  mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener(){
    @Override public boolean onNavigationItemSelected(    MenuItem menuItem){
      mDrawerLayout.closeDrawers();
      menuItem.setCheckable(true);
      menuItem.setChecked(true);
      Iterator<MenuItem> it=items.iterator();
      while (it.hasNext()) {
        MenuItem item=it.next();
        if (!item.equals(menuItem)) {
          item.setChecked(false);
        }
      }
      items.add(menuItem);
      mFragmentManager.beginTransaction().replace(R.id.containerView,getForId(menuItem.getItemId())).commit();
      return false;
    }
  }
);
  android.support.v7.widget.Toolbar toolbar=(android.support.v7.widget.Toolbar)findViewById(R.id.toolbar);
  ActionBarDrawerToggle mDrawerToggle=new ActionBarDrawerToggle(this,mDrawerLayout,toolbar,R.string.app_name,R.string.app_name);
  mDrawerLayout.setDrawerListener(mDrawerToggle);
  mDrawerToggle.syncState();
}","The original code used a world-readable SharedPreferences mode, which potentially exposes sensitive app data to other applications. The fixed code adds a File object for the preferences file and explicitly sets it to be readable only to the system, improving security by restricting unauthorized access. This change prevents potential data leakage and enhances the app's overall data protection mechanism by implementing more restrictive file permissions."
94114,"@Override public View getView(final int position,View convertView,ViewGroup parent){
  final int[] colorsBg=new int[]{Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE};
  final int[] currentItemBg={2};
  final int[] colorsText=new int[]{Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE};
  final int[] currentItemText={2};
  Holder holder=new Holder();
  View rowView;
  rowView=inflater.inflate(mRes.getLayout(R.layout.optionlayout),null);
  holder.tv=(TextView)rowView.findViewById(mRes.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  holder.img=(ImageView)rowView.findViewById(mRes.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  holder.tv.setText(options[position]);
  holder.img.setImageDrawable(mRes.getDrawable(optionImageId[position]));
  rowView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
switch (position) {
case 0:
{
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,HookMethods.editText.getCurrentTextColor(),new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int color){
              HookMethods.editText.setTextColor(color);
            }
          }
);
          colorPickerDialog.setButton(-3,Common.dialog_default,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialogInterface,            int which){
              HookMethods.editText.setTextColor(Color.WHITE);
              HookMethods.editText.setAlpha(1);
            }
          }
);
          colorPickerDialog.setTitle(Common.dialog_txtcolour);
          colorPickerDialog.show();
          return;
        }
case 1:
{
        AlertDialog.Builder builder=new AlertDialog.Builder(context);
        SeekBar seekBar=new SeekBar(context);
        seekBar.setMax(150);
        seekBar.setProgress((int)HookMethods.editText.getTextSize());
        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
          public void onProgressChanged(          SeekBar seekBar,          int n,          boolean bl){
            HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_DIP,n);
          }
          @Override public void onStartTrackingTouch(          SeekBar arg0){
          }
          @Override public void onStopTrackingTouch(          SeekBar arg0){
          }
        }
);
        builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
          @Override public void onClick(          DialogInterface dialog,          int which){
            HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_PX,32.5125f);
          }
        }
);
        builder.setPositiveButton(Common.dialog_done,null);
        builder.setView(seekBar);
        builder.show();
        return;
      }
case 2:
{
      AlertDialog.Builder builder=new AlertDialog.Builder(context);
      SeekBar seekBar=new SeekBar(context);
      seekBar.setMax(100);
      seekBar.setProgress((int)HookMethods.editText.getAlpha() * 100);
      seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
        public void onProgressChanged(        SeekBar seekBar2,        int n,        boolean bl){
          float alpha=(float)n / 100;
          HookMethods.editText.setAlpha(alpha);
        }
        @Override public void onStartTrackingTouch(        SeekBar arg0){
        }
        @Override public void onStopTrackingTouch(        SeekBar arg0){
        }
      }
);
      builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          HookMethods.editText.setAlpha(1);
        }
      }
);
      builder.setPositiveButton(Common.dialog_done,null);
      builder.setView(seekBar);
      builder.show();
      return;
    }
case 3:
{
    AlertDialog.Builder builder=new AlertDialog.Builder(context);
    builder.setTitle(""String_Node_Str"");
    builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
      }
    }
);
    LinearLayout rootLayout=new LinearLayout(context);
    LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
    LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.gradient_layout),null),rootParams);
    final RadioGroup orientation=(RadioGroup)rootLayout.findViewById(R.id.orientation);
    final LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.itemLayout);
    final LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT);
    for (int i=1; i <= 5; i++) {
      Button btn=new Button(context);
      btn.setId(i);
      final int id_=btn.getId();
      btn.setText(""String_Node_Str"" + id_);
      btn.setBackgroundColor(colorsText[i - 1]);
      listLayout.addView(btn,params);
      final Button btn1=((Button)listLayout.findViewById(id_));
      btn1.setOnClickListener(new View.OnClickListener(){
        public void onClick(        View view){
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,colorsText[id_ - 1],new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int color){
              colorsText[id_ - 1]=color;
              btn1.setBackgroundColor(colorsText[id_ - 1]);
            }
          }
);
          colorPickerDialog.setTitle(""String_Node_Str"" + id_);
          colorPickerDialog.show();
        }
      }
);
      if (btn1.getId() <= currentItemText[0]) {
        btn1.setVisibility(View.VISIBLE);
      }
 else {
        btn1.setVisibility(View.GONE);
      }
    }
    Button add=(Button)rootLayout.findViewById(R.id.add);
    add.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (currentItemText[0] < 5) {
          currentItemText[0]++;
          listLayout.findViewById(currentItemText[0]).setVisibility(View.VISIBLE);
        }
 else {
          Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
    }
);
    Button remove=(Button)rootLayout.findViewById(R.id.remove);
    remove.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (currentItemText[0] > 2) {
          listLayout.findViewById(currentItemText[0]).setVisibility(View.GONE);
          currentItemText[0]--;
        }
 else {
          Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
    }
);
    builder.setView(rootLayout);
    builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        final int[] usedColors=new int[currentItemText[0]];
        System.arraycopy(colorsText,0,usedColors,0,currentItemText[0]);
        Shader textShader=null;
        int checkedID=orientation.getCheckedRadioButtonId();
        if (checkedID == R.id.horizontal) {
          double angleInRadians=Math.toRadians(90);
          double length=100;
          double endX=Math.cos(angleInRadians) * length;
          double endY=Math.sin(angleInRadians) * HookMethods.editText.getHeight();
          WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
          Display display=wm.getDefaultDisplay();
          Point size=new Point();
          display.getSize(size);
          int width=size.x;
          textShader=new LinearGradient(0,0,width,0,usedColors,null,Shader.TileMode.CLAMP);
        }
 else         if (checkedID == R.id.vertical) {
          textShader=new LinearGradient(0,0,0,HookMethods.editText.getHeight(),usedColors,null,Shader.TileMode.CLAMP);
        }
        HookMethods.editText.getPaint().setShader(textShader);
        HookMethods.editText.setText(HookMethods.editText.getText());
      }
    }
);
    builder.show();
    return;
  }
case 4:
{
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  Button button_left=new Button(context);
  Button button_center=new Button(context);
  Button button_right=new Button(context);
  LinearLayout linearLayout=new LinearLayout(context);
  linearLayout.setOrientation(LinearLayout.VERTICAL);
  button_left.setText(Common.dialog_left);
  button_left.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.START);
    }
  }
);
  button_center.setText(Common.dialog_center);
  button_center.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.CENTER);
    }
  }
);
  button_right.setText(Common.dialog_right);
  button_right.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.END);
    }
  }
);
  linearLayout.addView(button_left);
  linearLayout.addView(button_center);
  linearLayout.addView(button_right);
  builder.setView(linearLayout);
  builder.setPositiveButton(Common.dialog_done,null);
  builder.show();
  return;
}
case 5:
{
AlertDialog.Builder builder=new AlertDialog.Builder(context);
Button button_bold=new Button(context);
Button button_italic=new Button(context);
Button button_bolditalic=new Button(context);
Button button_normal=new Button(context);
LinearLayout linearLayout=new LinearLayout(context);
linearLayout.setOrientation(LinearLayout.VERTICAL);
button_bold.setText(Common.dialog_bold);
button_bold.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.BOLD);
  }
}
);
button_italic.setText(Common.dialog_italic);
button_italic.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.ITALIC);
  }
}
);
button_bolditalic.setText(Common.dialog_bolditalic);
button_bolditalic.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.BOLD_ITALIC);
  }
}
);
button_normal.setText(Common.dialog_normal);
button_normal.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.NORMAL);
  }
}
);
linearLayout.addView(button_bold);
linearLayout.addView(button_italic);
linearLayout.addView(button_bolditalic);
linearLayout.addView(button_normal);
builder.setView(linearLayout);
builder.setPositiveButton(Common.dialog_done,null);
builder.show();
return;
}
case 6:
{
File folder=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"");
if (folder.exists()) {
FilenameFilter filter=new FilenameFilter(){
  @Override public boolean accept(  File dir,  String filename){
    if (filename.lastIndexOf('.') > 0) {
      int lastIndex=filename.lastIndexOf('.');
      String extension=filename.substring(lastIndex);
      if (extension.equalsIgnoreCase(""String_Node_Str"") || extension.equalsIgnoreCase(""String_Node_Str"")) {
        return true;
      }
    }
    return false;
  }
}
;
File[] fonts=folder.listFiles(filter);
if (fonts.length > 0) {
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  builder.setTitle(""String_Node_Str"");
  builder.setNeutralButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      HookMethods.editText.setTypeface(HookMethods.defTypeface);
    }
  }
);
  builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialogInterface,    int i){
    }
  }
);
  LinearLayout rootLayout=new LinearLayout(context);
  LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.font_list),null),rootParams);
  LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.fontLayout);
  for (  final File font : fonts) {
    String fontname=font.getName().substring(0,font.getName().toLowerCase().lastIndexOf(""String_Node_Str""));
    TextView item=new TextView(context);
    item.setLayoutParams(new TableLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
    item.setPadding(0,0,0,2);
    item.setText(fontname);
    item.setTextSize(TypedValue.COMPLEX_UNIT_DIP,22.0f);
    item.setGravity(Gravity.CENTER_HORIZONTAL);
    item.setTypeface(TypefaceUtil.get(font));
    item.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        HookMethods.editText.setTypeface(TypefaceUtil.get(font));
      }
    }
);
    listLayout.addView(item);
  }
  builder.setView(rootLayout);
  builder.show();
}
 else {
  NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGHT_SHORT,HookMethods.classLoader);
}
}
 else {
NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGHT_SHORT,HookMethods.classLoader);
}
return;
}
case 7:
{
ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,HookMethods.editText.getSolidColor(),new ColorPickerDialog.OnColorSelectedListener(){
@Override public void onColorSelected(int color){
HookMethods.editText.setBackgroundColor(color);
}
}
);
colorPickerDialog.setButton(-3,Common.dialog_default,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int which){
HookMethods.editText.setBackgroundColor((Color.parseColor(""String_Node_Str"")));
HookMethods.editText.setAlpha(1);
}
}
);
colorPickerDialog.setTitle(Common.dialog_bgcolour);
colorPickerDialog.show();
return;
}
case 8:
{
AlertDialog.Builder builder=new AlertDialog.Builder(HookMethods.SnapContext);
SeekBar seekBar=new SeekBar(HookMethods.SnapContext);
seekBar.setMax(255);
int currentapiVersion=android.os.Build.VERSION.SDK_INT;
if (currentapiVersion >= Build.VERSION_CODES.KITKAT) {
seekBar.setProgress(HookMethods.editText.getBackground().getAlpha());
}
 else {
seekBar.setProgress(255);
}
seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
public void onProgressChanged(SeekBar seekBar3,int n,boolean bl){
HookMethods.editText.getBackground().setAlpha(n);
}
@Override public void onStartTrackingTouch(SeekBar arg0){
}
@Override public void onStopTrackingTouch(SeekBar arg0){
}
}
);
builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
HookMethods.editText.getBackground().setAlpha(153);
}
}
);
builder.setPositiveButton(Common.dialog_done,null);
builder.setView(seekBar);
builder.show();
return;
}
case 9:
{
AlertDialog.Builder builder=new AlertDialog.Builder(context);
builder.setTitle(""String_Node_Str"");
builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
}
}
);
final LinearLayout rootLayout=new LinearLayout(context);
LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.gradient_layout),null),rootParams);
final RadioGroup orientation=(RadioGroup)rootLayout.findViewById(R.id.orientation);
final LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.itemLayout);
final LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT);
for (int i=1; i <= 5; i++) {
Button btn=new Button(context);
btn.setId(i);
final int id_=btn.getId();
btn.setText(""String_Node_Str"" + id_);
btn.setBackgroundColor(colorsBg[i - 1]);
listLayout.addView(btn,params);
final Button btn1=((Button)listLayout.findViewById(id_));
btn1.setOnClickListener(new View.OnClickListener(){
public void onClick(View view){
ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,colorsBg[id_ - 1],new ColorPickerDialog.OnColorSelectedListener(){
@Override public void onColorSelected(int color){
  colorsBg[id_ - 1]=color;
  btn1.setBackgroundColor(colorsBg[id_ - 1]);
}
}
);
colorPickerDialog.setTitle(""String_Node_Str"" + id_);
colorPickerDialog.show();
}
}
);
if (btn1.getId() <= currentItemBg[0]) {
btn1.setVisibility(View.VISIBLE);
}
 else {
btn1.setVisibility(View.GONE);
}
}
Button add=(Button)rootLayout.findViewById(R.id.add);
add.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View view){
if (currentItemBg[0] < 5) {
currentItemBg[0]++;
listLayout.findViewById(currentItemBg[0]).setVisibility(View.VISIBLE);
}
 else {
Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
}
}
);
Button remove=(Button)rootLayout.findViewById(R.id.remove);
remove.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View view){
if (currentItemBg[0] > 2) {
listLayout.findViewById(currentItemBg[0]).setVisibility(View.GONE);
currentItemBg[0]--;
}
 else {
Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
}
}
);
builder.setView(rootLayout);
builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
final int[] usedColors=new int[currentItemBg[0]];
System.arraycopy(colorsBg,0,usedColors,0,currentItemBg[0]);
PaintDrawable p=new PaintDrawable();
p.setShape(new RectShape());
ShapeDrawable.ShaderFactory sf=new ShapeDrawable.ShaderFactory(){
@Override public Shader resize(int width,int height){
LinearGradient returnGradient=null;
int checkedID=orientation.getCheckedRadioButtonId();
if (checkedID == R.id.horizontal) {
  returnGradient=new LinearGradient(0,0,width,height,usedColors,null,Shader.TileMode.MIRROR);
}
 else if (checkedID == R.id.vertical) {
  double angleInRadians=Math.toRadians(90);
  double length=100;
  double endX=Math.cos(angleInRadians) * length;
  double endY=Math.sin(angleInRadians) * HookMethods.editText.getHeight();
  returnGradient=new LinearGradient(0,0,(float)endX,(float)endY,usedColors,null,Shader.TileMode.MIRROR);
}
return returnGradient;
}
}
;
p.setShaderFactory(sf);
HookMethods.editText.setBackgroundDrawable(p);
}
}
);
builder.show();
return;
}
case 10:
{
HookMethods.editText.setBackgroundDrawable(null);
HookMethods.editText.getPaint().reset();
HookMethods.editText.setTextColor(Color.WHITE);
HookMethods.editText.setBackgroundColor((Color.parseColor(""String_Node_Str"")));
HookMethods.editText.setGravity(Gravity.CENTER);
HookMethods.editText.setAlpha(1);
HookMethods.editText.getBackground().setAlpha(153);
HookMethods.editText.setTypeface(HookMethods.defTypeface);
HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_PX,32.5125f);
return;
}
default :
return;
}
}
}
);
return rowView;
}","@Override public View getView(final int position,View convertView,ViewGroup parent){
  final int[] colorsBg=new int[]{Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE};
  final int[] currentItemBg={2};
  final int[] colorsText=new int[]{Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE};
  final int[] currentItemText={2};
  Holder holder=new Holder();
  View rowView;
  rowView=inflater.inflate(mRes.getLayout(R.layout.optionlayout),null);
  holder.tv=(TextView)rowView.findViewById(mRes.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  holder.img=(ImageView)rowView.findViewById(mRes.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  holder.tv.setText(options[position]);
  holder.img.setImageDrawable(mRes.getDrawable(optionImageId[position]));
  rowView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
switch (position) {
case 0:
{
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,HookMethods.editText.getCurrentTextColor(),new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int color){
              HookMethods.editText.setTextColor(color);
            }
          }
);
          colorPickerDialog.setButton(-3,Common.dialog_default,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialogInterface,            int which){
              HookMethods.editText.setTextColor(Color.WHITE);
              HookMethods.editText.setAlpha(1);
            }
          }
);
          colorPickerDialog.setTitle(Common.dialog_txtcolour);
          colorPickerDialog.show();
          return;
        }
case 1:
{
        AlertDialog.Builder builder=new AlertDialog.Builder(context);
        SeekBar seekBar=new SeekBar(context);
        seekBar.setMax(150);
        seekBar.setProgress((int)HookMethods.editText.getTextSize());
        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
          public void onProgressChanged(          SeekBar seekBar,          int n,          boolean bl){
            HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_DIP,n);
          }
          @Override public void onStartTrackingTouch(          SeekBar arg0){
          }
          @Override public void onStopTrackingTouch(          SeekBar arg0){
          }
        }
);
        builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
          @Override public void onClick(          DialogInterface dialog,          int which){
            HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_PX,32.5125f);
          }
        }
);
        builder.setPositiveButton(Common.dialog_done,null);
        builder.setView(seekBar);
        builder.show();
        return;
      }
case 2:
{
      AlertDialog.Builder builder=new AlertDialog.Builder(context);
      SeekBar seekBar=new SeekBar(context);
      seekBar.setMax(100);
      seekBar.setProgress((int)HookMethods.editText.getAlpha() * 100);
      seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
        public void onProgressChanged(        SeekBar seekBar2,        int n,        boolean bl){
          float alpha=(float)n / 100;
          HookMethods.editText.setAlpha(alpha);
        }
        @Override public void onStartTrackingTouch(        SeekBar arg0){
        }
        @Override public void onStopTrackingTouch(        SeekBar arg0){
        }
      }
);
      builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          HookMethods.editText.setAlpha(1);
        }
      }
);
      builder.setPositiveButton(Common.dialog_done,null);
      builder.setView(seekBar);
      builder.show();
      return;
    }
case 3:
{
    AlertDialog.Builder builder=new AlertDialog.Builder(context);
    builder.setTitle(""String_Node_Str"");
    builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
      }
    }
);
    LinearLayout rootLayout=new LinearLayout(context);
    LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
    LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.gradient_layout),null),rootParams);
    final RadioGroup orientation=(RadioGroup)rootLayout.findViewById(R.id.orientation);
    final LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.itemLayout);
    final LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT);
    for (int i=1; i <= 5; i++) {
      Button btn=new Button(context);
      btn.setId(i);
      final int id_=btn.getId();
      btn.setText(""String_Node_Str"" + id_);
      btn.setBackgroundColor(colorsText[i - 1]);
      listLayout.addView(btn,params);
      final Button btn1=((Button)listLayout.findViewById(id_));
      btn1.setOnClickListener(new View.OnClickListener(){
        public void onClick(        View view){
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,colorsText[id_ - 1],new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int color){
              colorsText[id_ - 1]=color;
              btn1.setBackgroundColor(colorsText[id_ - 1]);
            }
          }
);
          colorPickerDialog.setTitle(""String_Node_Str"" + id_);
          colorPickerDialog.show();
        }
      }
);
      if (btn1.getId() <= currentItemText[0]) {
        btn1.setVisibility(View.VISIBLE);
      }
 else {
        btn1.setVisibility(View.GONE);
      }
    }
    Button add=(Button)rootLayout.findViewById(R.id.add);
    add.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (currentItemText[0] < 5) {
          currentItemText[0]++;
          listLayout.findViewById(currentItemText[0]).setVisibility(View.VISIBLE);
        }
 else {
          Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
    }
);
    Button remove=(Button)rootLayout.findViewById(R.id.remove);
    remove.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (currentItemText[0] > 2) {
          listLayout.findViewById(currentItemText[0]).setVisibility(View.GONE);
          currentItemText[0]--;
        }
 else {
          Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
    }
);
    builder.setView(rootLayout);
    builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        final int[] usedColors=new int[currentItemText[0]];
        System.arraycopy(colorsText,0,usedColors,0,currentItemText[0]);
        Shader textShader=null;
        int checkedID=orientation.getCheckedRadioButtonId();
        if (checkedID == R.id.horizontal) {
          double angleInRadians=Math.toRadians(90);
          double length=100;
          double endX=Math.cos(angleInRadians) * length;
          double endY=Math.sin(angleInRadians) * HookMethods.editText.getHeight();
          WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
          Display display=wm.getDefaultDisplay();
          Point size=new Point();
          display.getSize(size);
          int width=size.x;
          textShader=new LinearGradient(0,0,width,0,usedColors,null,Shader.TileMode.CLAMP);
        }
 else         if (checkedID == R.id.vertical) {
          textShader=new LinearGradient(0,0,0,HookMethods.editText.getHeight(),usedColors,null,Shader.TileMode.CLAMP);
        }
        HookMethods.editText.getPaint().setShader(textShader);
        HookMethods.editText.setText(HookMethods.editText.getText());
      }
    }
);
    builder.show();
    return;
  }
case 4:
{
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  Button button_left=new Button(context);
  Button button_center=new Button(context);
  Button button_right=new Button(context);
  LinearLayout linearLayout=new LinearLayout(context);
  linearLayout.setOrientation(LinearLayout.VERTICAL);
  button_left.setText(Common.dialog_left);
  button_left.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.START);
    }
  }
);
  button_center.setText(Common.dialog_center);
  button_center.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.CENTER);
    }
  }
);
  button_right.setText(Common.dialog_right);
  button_right.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.END);
    }
  }
);
  linearLayout.addView(button_left);
  linearLayout.addView(button_center);
  linearLayout.addView(button_right);
  builder.setView(linearLayout);
  builder.setPositiveButton(Common.dialog_done,null);
  builder.show();
  return;
}
case 5:
{
AlertDialog.Builder builder=new AlertDialog.Builder(context);
Button button_bold=new Button(context);
Button button_italic=new Button(context);
Button button_bolditalic=new Button(context);
Button button_normal=new Button(context);
LinearLayout linearLayout=new LinearLayout(context);
linearLayout.setOrientation(LinearLayout.VERTICAL);
button_bold.setText(Common.dialog_bold);
button_bold.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.BOLD);
  }
}
);
button_italic.setText(Common.dialog_italic);
button_italic.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.ITALIC);
  }
}
);
button_bolditalic.setText(Common.dialog_bolditalic);
button_bolditalic.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.BOLD_ITALIC);
  }
}
);
button_normal.setText(Common.dialog_normal);
button_normal.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.NORMAL);
  }
}
);
linearLayout.addView(button_bold);
linearLayout.addView(button_italic);
linearLayout.addView(button_bolditalic);
linearLayout.addView(button_normal);
builder.setView(linearLayout);
builder.setPositiveButton(Common.dialog_done,null);
builder.show();
return;
}
case 6:
{
File folder=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"");
if (folder.exists()) {
FilenameFilter filter=new FilenameFilter(){
  @Override public boolean accept(  File dir,  String filename){
    if (filename.lastIndexOf('.') > 0) {
      int lastIndex=filename.lastIndexOf('.');
      String extension=filename.substring(lastIndex);
      if (extension.equalsIgnoreCase(""String_Node_Str"") || extension.equalsIgnoreCase(""String_Node_Str"")) {
        return true;
      }
    }
    return false;
  }
}
;
File[] fonts=folder.listFiles(filter);
if (fonts.length > 0) {
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  builder.setTitle(""String_Node_Str"");
  builder.setNeutralButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      HookMethods.editText.setTypeface(HookMethods.defTypeface);
    }
  }
);
  builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialogInterface,    int i){
    }
  }
);
  LinearLayout rootLayout=new LinearLayout(context);
  LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.font_list),null),rootParams);
  LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.fontLayout);
  for (  final File font : fonts) {
    String fontname=font.getName().substring(0,font.getName().toLowerCase().lastIndexOf(""String_Node_Str""));
    TextView item=new TextView(context);
    item.setLayoutParams(new TableLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
    item.setPadding(0,0,0,2);
    item.setText(fontname);
    item.setTextSize(TypedValue.COMPLEX_UNIT_DIP,22.0f);
    item.setGravity(Gravity.CENTER_HORIZONTAL);
    item.setTypeface(TypefaceUtil.get(font));
    item.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        HookMethods.editText.setTypeface(TypefaceUtil.get(font));
      }
    }
);
    listLayout.addView(item);
  }
  builder.setView(rootLayout);
  builder.show();
}
 else {
  NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGHT_SHORT,HookMethods.classLoader);
}
}
 else {
NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGHT_SHORT,HookMethods.classLoader);
}
return;
}
case 7:
{
ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,HookMethods.editText.getSolidColor(),new ColorPickerDialog.OnColorSelectedListener(){
@Override public void onColorSelected(int color){
HookMethods.editText.setBackgroundColor(color);
}
}
);
colorPickerDialog.setButton(-3,Common.dialog_default,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int which){
HookMethods.editText.setBackgroundColor((Color.parseColor(""String_Node_Str"")));
HookMethods.editText.setAlpha(1);
}
}
);
colorPickerDialog.setTitle(Common.dialog_bgcolour);
colorPickerDialog.show();
return;
}
case 8:
{
AlertDialog.Builder builder=new AlertDialog.Builder(HookMethods.SnapContext);
SeekBar seekBar=new SeekBar(HookMethods.SnapContext);
seekBar.setMax(255);
int currentapiVersion=Build.VERSION.SDK_INT;
if (currentapiVersion >= Build.VERSION_CODES.KITKAT) {
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
seekBar.setProgress(HookMethods.editText.getBackground().getAlpha());
}
}
 else {
seekBar.setProgress(255);
}
seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
public void onProgressChanged(SeekBar seekBar3,int n,boolean bl){
HookMethods.editText.getBackground().setAlpha(n);
}
@Override public void onStartTrackingTouch(SeekBar arg0){
}
@Override public void onStopTrackingTouch(SeekBar arg0){
}
}
);
builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
HookMethods.editText.getBackground().setAlpha(153);
}
}
);
builder.setPositiveButton(Common.dialog_done,null);
builder.setView(seekBar);
builder.show();
return;
}
case 9:
{
AlertDialog.Builder builder=new AlertDialog.Builder(context);
builder.setTitle(""String_Node_Str"");
builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
}
}
);
final LinearLayout rootLayout=new LinearLayout(context);
LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.gradient_layout),null),rootParams);
final RadioGroup orientation=(RadioGroup)rootLayout.findViewById(R.id.orientation);
final LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.itemLayout);
final LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT);
for (int i=1; i <= 5; i++) {
Button btn=new Button(context);
btn.setId(i);
final int id_=btn.getId();
btn.setText(""String_Node_Str"" + id_);
btn.setBackgroundColor(colorsBg[i - 1]);
listLayout.addView(btn,params);
final Button btn1=((Button)listLayout.findViewById(id_));
btn1.setOnClickListener(new View.OnClickListener(){
public void onClick(View view){
ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,colorsBg[id_ - 1],new ColorPickerDialog.OnColorSelectedListener(){
@Override public void onColorSelected(int color){
  colorsBg[id_ - 1]=color;
  btn1.setBackgroundColor(colorsBg[id_ - 1]);
}
}
);
colorPickerDialog.setTitle(""String_Node_Str"" + id_);
colorPickerDialog.show();
}
}
);
if (btn1.getId() <= currentItemBg[0]) {
btn1.setVisibility(View.VISIBLE);
}
 else {
btn1.setVisibility(View.GONE);
}
}
Button add=(Button)rootLayout.findViewById(R.id.add);
add.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View view){
if (currentItemBg[0] < 5) {
currentItemBg[0]++;
listLayout.findViewById(currentItemBg[0]).setVisibility(View.VISIBLE);
}
 else {
Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
}
}
);
Button remove=(Button)rootLayout.findViewById(R.id.remove);
remove.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View view){
if (currentItemBg[0] > 2) {
listLayout.findViewById(currentItemBg[0]).setVisibility(View.GONE);
currentItemBg[0]--;
}
 else {
Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
}
}
);
builder.setView(rootLayout);
builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
final int[] usedColors=new int[currentItemBg[0]];
System.arraycopy(colorsBg,0,usedColors,0,currentItemBg[0]);
PaintDrawable p=new PaintDrawable();
p.setShape(new RectShape());
ShapeDrawable.ShaderFactory sf=new ShapeDrawable.ShaderFactory(){
@Override public Shader resize(int width,int height){
LinearGradient returnGradient=null;
int checkedID=orientation.getCheckedRadioButtonId();
if (checkedID == R.id.horizontal) {
  returnGradient=new LinearGradient(0,0,width,height,usedColors,null,Shader.TileMode.MIRROR);
}
 else if (checkedID == R.id.vertical) {
  double angleInRadians=Math.toRadians(90);
  double length=100;
  double endX=Math.cos(angleInRadians) * length;
  double endY=Math.sin(angleInRadians) * HookMethods.editText.getHeight();
  returnGradient=new LinearGradient(0,0,(float)endX,(float)endY,usedColors,null,Shader.TileMode.MIRROR);
}
return returnGradient;
}
}
;
p.setShaderFactory(sf);
HookMethods.editText.setBackgroundDrawable(p);
}
}
);
builder.show();
return;
}
case 10:
{
HookMethods.editText.setBackgroundDrawable(null);
HookMethods.editText.getPaint().reset();
HookMethods.editText.setTextColor(Color.WHITE);
HookMethods.editText.setBackgroundColor((Color.parseColor(""String_Node_Str"")));
HookMethods.editText.setGravity(Gravity.CENTER);
HookMethods.editText.setAlpha(1);
HookMethods.editText.getBackground().setAlpha(153);
HookMethods.editText.setTypeface(HookMethods.defTypeface);
HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_PX,32.5125f);
return;
}
default :
return;
}
}
}
);
return rowView;
}","The original code had potential API version-related issues in the background alpha setting, particularly in case 8 where the version check was incomplete. The fixed code adds an extra version check using `Build.VERSION.SDK_INT` and wraps the background alpha setting in a version-specific conditional block, ensuring compatibility across different Android API levels. This improvement prevents potential runtime exceptions and provides more robust handling of background alpha settings across various Android device versions."
94115,"public static void addSaveButtonsAndGestures(XC_InitPackageResources.InitPackageResourcesParam resparam,XModuleResources mResources,final Context localContext){
  final GestureEvent gestureEvent=new GestureEvent();
  Logger.log(""String_Node_Str"",false,true);
  final Bitmap saveImg=BitmapFactory.decodeResource(mResources,R.mipmap.save_button);
  if (saveImg == null)   throw new NullPointerException(""String_Node_Str"");
  int horizontalPosition=Preferences.mButtonPosition ? Gravity.START : Gravity.END;
  final FrameLayout.LayoutParams layoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,FrameLayout.LayoutParams.WRAP_CONTENT,Gravity.BOTTOM | horizontalPosition);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      Logger.log(""String_Node_Str"");
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      ViewGroup overlay_group=(ViewGroup)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP));
      saveStoryButton=new ImageButton(localContext);
      saveStoryButton.setLayoutParams(layoutParams);
      saveStoryButton.setBackgroundColor(0);
      saveStoryButton.setImageBitmap(saveImg);
      saveStoryButton.setAlpha(0.8f);
      saveStoryButton.setVisibility(Preferences.mModeStory == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          return Preferences.mModeStory == Preferences.SAVE_S2S && gestureEvent.onTouch(v,event,Saving.SnapType.STORY);
        }
      }
);
      frameLayout.addView(saveStoryButton);
      overlay_group.bringToFront();
      saveStoryButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      Logger.log(""String_Node_Str"");
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveSnapButton=new ImageButton(localContext);
      saveSnapButton.setLayoutParams(layoutParams);
      saveSnapButton.setBackgroundColor(0);
      saveSnapButton.setAlpha(1f);
      saveSnapButton.setImageBitmap(saveImg);
      saveSnapButton.setVisibility(Preferences.mModeSave == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          return Preferences.mModeSave == Preferences.SAVE_S2S && gestureEvent.onTouch(v,event,Saving.SnapType.SNAP);
        }
      }
);
      frameLayout.addView(saveSnapButton);
      saveSnapButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
}","public static void addSaveButtonsAndGestures(XC_InitPackageResources.InitPackageResourcesParam resparam,XModuleResources mResources,final Context localContext){
  final GestureEvent gestureEvent=new GestureEvent();
  Logger.log(""String_Node_Str"",false,true);
  final Bitmap saveImg=BitmapFactory.decodeResource(mResources,R.drawable.save_button);
  if (saveImg == null)   throw new NullPointerException(""String_Node_Str"");
  int horizontalPosition=Preferences.mButtonPosition ? Gravity.START : Gravity.END;
  final FrameLayout.LayoutParams layoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,FrameLayout.LayoutParams.WRAP_CONTENT,Gravity.BOTTOM | horizontalPosition);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      Logger.log(""String_Node_Str"");
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      ViewGroup overlay_group=(ViewGroup)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP));
      saveStoryButton=new ImageButton(localContext);
      saveStoryButton.setLayoutParams(layoutParams);
      saveStoryButton.setBackgroundColor(0);
      saveStoryButton.setImageBitmap(saveImg);
      saveStoryButton.setAlpha(0.8f);
      saveStoryButton.setVisibility(Preferences.mModeStory == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          return Preferences.mModeStory == Preferences.SAVE_S2S && gestureEvent.onTouch(v,event,Saving.SnapType.STORY);
        }
      }
);
      frameLayout.addView(saveStoryButton);
      overlay_group.bringToFront();
      saveStoryButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      Logger.log(""String_Node_Str"");
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveSnapButton=new ImageButton(localContext);
      saveSnapButton.setLayoutParams(layoutParams);
      saveSnapButton.setBackgroundColor(0);
      saveSnapButton.setAlpha(1f);
      saveSnapButton.setImageBitmap(saveImg);
      saveSnapButton.setVisibility(Preferences.mModeSave == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          return Preferences.mModeSave == Preferences.SAVE_S2S && gestureEvent.onTouch(v,event,Saving.SnapType.SNAP);
        }
      }
);
      frameLayout.addView(saveSnapButton);
      saveSnapButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
}","The original code used an incorrect resource reference (R.mipmap.save_button) for loading the save button image. The fixed code changes this to R.drawable.save_button, which is the correct resource type for loading bitmap images in Android. By using the proper resource type, the code now correctly loads the save button image, preventing potential null pointer exceptions and ensuring the visual element displays as intended."
94116,"static void refreshPreferences(){
  prefs=new XSharedPreferences(new File(Environment.getDataDirectory(),""String_Node_Str"" + PACKAGE_NAME + ""String_Node_Str""+ PACKAGE_NAME+ ""String_Node_Str""+ ""String_Node_Str""));
  prefs.reload();
  prefs.makeWorldReadable();
  selectAll=prefs.getBoolean(""String_Node_Str"",false);
  selectStory=prefs.getBoolean(""String_Node_Str"",false);
  selectVenue=prefs.getBoolean(""String_Node_Str"",false);
  hideBf=prefs.getBoolean(""String_Node_Str"",false);
  hideRecent=prefs.getBoolean(""String_Node_Str"",false);
  mTextTools=prefs.getBoolean(""String_Node_Str"",false);
  mPaintTools=prefs.getBoolean(""String_Node_Str"",mPaintTools);
  mTimerCounter=prefs.getBoolean(""String_Node_Str"",true);
  mChatAutoSave=prefs.getBoolean(""String_Node_Str"",true);
  mChatMediaSave=prefs.getBoolean(""String_Node_Str"",true);
  mIntegration=prefs.getBoolean(""String_Node_Str"",true);
  mCustomFilterBoolean=prefs.getBoolean(""String_Node_Str"",mCustomFilterBoolean);
  mMultiFilterBoolean=prefs.getBoolean(""String_Node_Str"",mMultiFilterBoolean);
  mCustomFilterLocation=Environment.getExternalStorageDirectory().toString() + ""String_Node_Str"";
  mCustomFilterType=prefs.getInt(""String_Node_Str"",0);
  mSpeed=prefs.getBoolean(""String_Node_Str"",false);
  mWeather=prefs.getBoolean(""String_Node_Str"",false);
  mLocation=prefs.getBoolean(""String_Node_Str"",false);
  mStoryPreload=prefs.getBoolean(""String_Node_Str"",false);
  mDiscoverSnap=prefs.getBoolean(""String_Node_Str"",false);
  mDiscoverUI=prefs.getBoolean(""String_Node_Str"",false);
  mCustomSticker=prefs.getBoolean(""String_Node_Str"",false);
  mHideLive=prefs.getBoolean(""String_Node_Str"",false);
  mHidePeople=prefs.getBoolean(""String_Node_Str"",false);
  mReplay=prefs.getBoolean(""String_Node_Str"",false);
  mStealth=prefs.getBoolean(""String_Node_Str"",false);
  mTyping=prefs.getBoolean(""String_Node_Str"",false);
  mUnlimGroups=prefs.getBoolean(""String_Node_Str"",false);
  mForceNavbar=prefs.getInt(""String_Node_Str"",0);
  mConfirmationID=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  debug=prefs.getBoolean(""String_Node_Str"",false);
  mDeviceID=prefs.getString(""String_Node_Str"",null);
  mLicense=prefs.getInt(mDeviceID,0);
  mModeSave=prefs.getInt(""String_Node_Str"",mModeSave);
  mModeStory=prefs.getInt(""String_Node_Str"",mModeStory);
  mTimerMinimum=prefs.getInt(""String_Node_Str"",mTimerMinimum);
  mToastEnabled=prefs.getBoolean(""String_Node_Str"",mToastEnabled);
  mVibrationEnabled=prefs.getBoolean(""String_Node_Str"",mVibrationEnabled);
  mToastLength=prefs.getInt(""String_Node_Str"",mToastLength);
  mSavePath=prefs.getString(""String_Node_Str"",mSavePath);
  mSaveSentSnaps=prefs.getBoolean(""String_Node_Str"",mSaveSentSnaps);
  mSortByCategory=prefs.getBoolean(""String_Node_Str"",mSortByCategory);
  mSortByUsername=prefs.getBoolean(""String_Node_Str"",mSortByUsername);
  mDebugging=prefs.getBoolean(""String_Node_Str"",mDebugging);
  mOverlays=prefs.getBoolean(""String_Node_Str"",mOverlays);
  mTimerUnlimited=prefs.getBoolean(""String_Node_Str"",mTimerUnlimited);
  mHideTimerStory=prefs.getBoolean(""String_Node_Str"",mHideTimerStory);
  mLoopingVids=prefs.getBoolean(""String_Node_Str"",mLoopingVids);
  mHideTimer=prefs.getBoolean(""String_Node_Str"",mHideTimer);
  Common.ROTATION_MODE=Integer.parseInt(prefs.getString(""String_Node_Str"",Integer.toString(Common.ROTATION_MODE)));
  Common.ADJUST_METHOD=Integer.parseInt(prefs.getString(""String_Node_Str"",Integer.toString(Common.ADJUST_METHOD)));
  Common.CAPTION_UNLIMITED_VANILLA=prefs.getBoolean(""String_Node_Str"",Common.CAPTION_UNLIMITED_VANILLA);
  Common.CAPTION_UNLIMITED_FAT=prefs.getBoolean(""String_Node_Str"",Common.CAPTION_UNLIMITED_FAT);
  Common.DEBUGGING=prefs.getBoolean(""String_Node_Str"",Common.DEBUGGING);
  Common.CHECK_SIZE=!prefs.getBoolean(""String_Node_Str"",!Common.CHECK_SIZE);
  Common.TIMBER=prefs.getBoolean(""String_Node_Str"",Common.TIMBER);
  shouldAddGhost=mSpeed || mTextTools || mLocation|| mWeather;
  acceptedToU=prefs.getBoolean(""String_Node_Str"",false);
}","static void refreshPreferences(){
  prefs=new XSharedPreferences(new File(Environment.getDataDirectory(),""String_Node_Str"" + PACKAGE_NAME + ""String_Node_Str""+ PACKAGE_NAME+ ""String_Node_Str""+ ""String_Node_Str""));
  prefs.reload();
  prefs.makeWorldReadable();
  selectAll=prefs.getBoolean(""String_Node_Str"",false);
  selectStory=prefs.getBoolean(""String_Node_Str"",false);
  selectVenue=prefs.getBoolean(""String_Node_Str"",false);
  hideBf=prefs.getBoolean(""String_Node_Str"",false);
  hideRecent=prefs.getBoolean(""String_Node_Str"",false);
  mTextTools=prefs.getBoolean(""String_Node_Str"",false);
  mPaintTools=prefs.getBoolean(""String_Node_Str"",mPaintTools);
  mTimerCounter=prefs.getBoolean(""String_Node_Str"",true);
  mChatAutoSave=prefs.getBoolean(""String_Node_Str"",true);
  mChatMediaSave=prefs.getBoolean(""String_Node_Str"",true);
  mIntegration=prefs.getBoolean(""String_Node_Str"",true);
  mCustomFilterBoolean=prefs.getBoolean(""String_Node_Str"",mCustomFilterBoolean);
  mMultiFilterBoolean=prefs.getBoolean(""String_Node_Str"",mMultiFilterBoolean);
  mCustomFilterLocation=Environment.getExternalStorageDirectory().toString() + ""String_Node_Str"";
  mCustomFilterType=prefs.getInt(""String_Node_Str"",0);
  mSpeed=prefs.getBoolean(""String_Node_Str"",false);
  mWeather=prefs.getBoolean(""String_Node_Str"",false);
  mLocation=prefs.getBoolean(""String_Node_Str"",false);
  mStoryPreload=prefs.getBoolean(""String_Node_Str"",false);
  mDiscoverSnap=prefs.getBoolean(""String_Node_Str"",false);
  mDiscoverUI=prefs.getBoolean(""String_Node_Str"",false);
  mCustomSticker=prefs.getBoolean(""String_Node_Str"",false);
  mHideLive=prefs.getBoolean(""String_Node_Str"",false);
  mHidePeople=prefs.getBoolean(""String_Node_Str"",false);
  mReplay=prefs.getBoolean(""String_Node_Str"",false);
  mStealth=prefs.getBoolean(""String_Node_Str"",false);
  mTyping=prefs.getBoolean(""String_Node_Str"",false);
  mUnlimGroups=prefs.getBoolean(""String_Node_Str"",false);
  mForceNavbar=prefs.getInt(""String_Node_Str"",0);
  mConfirmationID=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  debug=prefs.getBoolean(""String_Node_Str"",false);
  mDeviceID=prefs.getString(""String_Node_Str"",null);
  mLicense=prefs.getInt(mDeviceID,0);
  mModeSave=prefs.getInt(""String_Node_Str"",mModeSave);
  mModeStory=prefs.getInt(""String_Node_Str"",mModeStory);
  mTimerMinimum=prefs.getInt(""String_Node_Str"",mTimerMinimum);
  mToastEnabled=prefs.getBoolean(""String_Node_Str"",mToastEnabled);
  mVibrationEnabled=prefs.getBoolean(""String_Node_Str"",mVibrationEnabled);
  mToastLength=prefs.getInt(""String_Node_Str"",mToastLength);
  mSavePath=prefs.getString(""String_Node_Str"",mSavePath);
  mSaveSentSnaps=prefs.getBoolean(""String_Node_Str"",mSaveSentSnaps);
  mSortByCategory=prefs.getBoolean(""String_Node_Str"",mSortByCategory);
  mSortByUsername=prefs.getBoolean(""String_Node_Str"",mSortByUsername);
  mDebugging=prefs.getBoolean(""String_Node_Str"",mDebugging);
  mOverlays=prefs.getBoolean(""String_Node_Str"",mOverlays);
  mTimerUnlimited=prefs.getBoolean(""String_Node_Str"",mTimerUnlimited);
  mHideTimerStory=prefs.getBoolean(""String_Node_Str"",mHideTimerStory);
  mLoopingVids=prefs.getBoolean(""String_Node_Str"",mLoopingVids);
  mHideTimer=prefs.getBoolean(""String_Node_Str"",mHideTimer);
  Common.ROTATION_MODE=Integer.parseInt(prefs.getString(""String_Node_Str"",Integer.toString(Common.ROTATION_MODE)));
  Common.ADJUST_METHOD=Integer.parseInt(prefs.getString(""String_Node_Str"",Integer.toString(Common.ADJUST_METHOD)));
  Common.CAPTION_UNLIMITED_VANILLA=prefs.getBoolean(""String_Node_Str"",Common.CAPTION_UNLIMITED_VANILLA);
  Common.CAPTION_UNLIMITED_FAT=prefs.getBoolean(""String_Node_Str"",Common.CAPTION_UNLIMITED_FAT);
  Common.DEBUGGING=prefs.getBoolean(""String_Node_Str"",Common.DEBUGGING);
  Common.CHECK_SIZE=!prefs.getBoolean(""String_Node_Str"",!Common.CHECK_SIZE);
  Common.TIMBER=prefs.getBoolean(""String_Node_Str"",Common.TIMBER);
  shouldAddGhost=mSpeed || mTextTools || mLocation|| mWeather;
  acceptedToU=prefs.getBoolean(""String_Node_Str"",false);
  if (HookedLayouts.saveSnapButton != null)   HookedLayouts.saveSnapButton.setVisibility(mModeSave == SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
  if (HookedLayouts.saveStoryButton != null)   HookedLayouts.saveStoryButton.setVisibility(mModeStory == SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
}","The original code lacked visibility control for save buttons, potentially leaving critical UI elements unmanaged. The fixed code adds conditional visibility settings for `saveSnapButton` and `saveStoryButton` based on `mModeSave` and `mModeStory` values, ensuring appropriate button display. This enhancement provides dynamic UI control, improving user interaction and interface responsiveness by correctly showing or hiding save buttons according to specific mode configurations."
94117,"private void printSettings(){
  Logger.log(""String_Node_Str"",true);
  logging(""String_Node_Str"");
  logging(""String_Node_Str"" + selectAll);
  logging(""String_Node_Str"" + selectStory);
  logging(""String_Node_Str"" + selectVenue);
  logging(""String_Node_Str"" + hideBf);
  logging(""String_Node_Str"" + hideRecent);
  logging(""String_Node_Str"" + shouldAddGhost);
  logging(""String_Node_Str"" + mTextTools);
  logging(""String_Node_Str"" + mTimerCounter);
  logging(""String_Node_Str"" + mChatAutoSave);
  logging(""String_Node_Str"" + mChatMediaSave);
  logging(""String_Node_Str"" + mIntegration);
  logging(""String_Node_Str"" + mPaintTools);
  logging(""String_Node_Str"" + mCustomFilterBoolean);
  logging(""String_Node_Str"" + mMultiFilterBoolean);
  logging(""String_Node_Str"" + mCustomFilterLocation);
  logging(""String_Node_Str"" + mCustomFilterType);
  logging(""String_Node_Str"" + mSpeed);
  logging(""String_Node_Str"" + mWeather);
  logging(""String_Node_Str"" + mLocation);
  logging(""String_Node_Str"" + mStoryPreload);
  logging(""String_Node_Str"" + mDiscoverSnap);
  logging(""String_Node_Str"" + mDiscoverUI);
  logging(""String_Node_Str"" + mCustomSticker);
  logging(""String_Node_Str"" + mHideLive);
  logging(""String_Node_Str"" + mHidePeople);
  logging(""String_Node_Str"" + mReplay);
  logging(""String_Node_Str"" + mStealth);
  logging(""String_Node_Str"" + mTyping);
  logging(""String_Node_Str"" + mUnlimGroups);
  logging(""String_Node_Str"" + mForceNavbar);
  logging(""String_Node_Str"" + debug + ""String_Node_Str"");
  logging(""String_Node_Str"" + mLicense);
  logging(""String_Node_Str"");
  Logger.setDebuggingEnabled(mDebugging);
  logging(""String_Node_Str"");
  logging(""String_Node_Str"");
  String[] saveModes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  logging(""String_Node_Str"" + saveModes[mModeSave]);
  logging(""String_Node_Str"" + mOverlays);
  logging(""String_Node_Str"" + mTimerMinimum);
  logging(""String_Node_Str"" + mToastEnabled);
  logging(""String_Node_Str"" + mVibrationEnabled);
  logging(""String_Node_Str"" + mToastLength);
  logging(""String_Node_Str"" + mSavePath);
  logging(""String_Node_Str"" + mSaveSentSnaps);
  logging(""String_Node_Str"" + mSortByCategory);
  logging(""String_Node_Str"" + mSortByUsername);
  logging(""String_Node_Str"" + mTimerUnlimited);
  logging(""String_Node_Str"" + mHideTimerStory);
  logging(""String_Node_Str"" + mLoopingVids);
  logging(""String_Node_Str"" + mHideTimer);
}","private void printSettings(){
  Logger.log(""String_Node_Str"",true);
  logging(""String_Node_Str"");
  logging(""String_Node_Str"" + selectAll);
  logging(""String_Node_Str"" + selectStory);
  logging(""String_Node_Str"" + selectVenue);
  logging(""String_Node_Str"" + hideBf);
  logging(""String_Node_Str"" + hideRecent);
  logging(""String_Node_Str"" + shouldAddGhost);
  logging(""String_Node_Str"" + mTextTools);
  logging(""String_Node_Str"" + mTimerCounter);
  logging(""String_Node_Str"" + mChatAutoSave);
  logging(""String_Node_Str"" + mChatMediaSave);
  logging(""String_Node_Str"" + mIntegration);
  logging(""String_Node_Str"" + mPaintTools);
  logging(""String_Node_Str"" + mCustomFilterBoolean);
  logging(""String_Node_Str"" + mMultiFilterBoolean);
  logging(""String_Node_Str"" + mCustomFilterLocation);
  logging(""String_Node_Str"" + mCustomFilterType);
  logging(""String_Node_Str"" + mSpeed);
  logging(""String_Node_Str"" + mWeather);
  logging(""String_Node_Str"" + mLocation);
  logging(""String_Node_Str"" + mStoryPreload);
  logging(""String_Node_Str"" + mDiscoverSnap);
  logging(""String_Node_Str"" + mDiscoverUI);
  logging(""String_Node_Str"" + mCustomSticker);
  logging(""String_Node_Str"" + mHideLive);
  logging(""String_Node_Str"" + mHidePeople);
  logging(""String_Node_Str"" + mReplay);
  logging(""String_Node_Str"" + mStealth);
  logging(""String_Node_Str"" + mTyping);
  logging(""String_Node_Str"" + mUnlimGroups);
  logging(""String_Node_Str"" + mForceNavbar);
  logging(""String_Node_Str"" + debug + ""String_Node_Str"");
  logging(""String_Node_Str"" + mLicense);
  logging(""String_Node_Str"");
  Logger.setDebuggingEnabled(mDebugging);
  logging(""String_Node_Str"");
  logging(""String_Node_Str"");
  String[] saveModes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  logging(""String_Node_Str"" + saveModes[mModeSave]);
  logging(""String_Node_Str"" + saveModes[mModeSave]);
  logging(""String_Node_Str"" + mOverlays);
  logging(""String_Node_Str"" + mTimerMinimum);
  logging(""String_Node_Str"" + mToastEnabled);
  logging(""String_Node_Str"" + mVibrationEnabled);
  logging(""String_Node_Str"" + mToastLength);
  logging(""String_Node_Str"" + mSavePath);
  logging(""String_Node_Str"" + mSaveSentSnaps);
  logging(""String_Node_Str"" + mSortByCategory);
  logging(""String_Node_Str"" + mSortByUsername);
  logging(""String_Node_Str"" + mTimerUnlimited);
  logging(""String_Node_Str"" + mHideTimerStory);
  logging(""String_Node_Str"" + mLoopingVids);
  logging(""String_Node_Str"" + mHideTimer);
}","The buggy code lacked a repeated logging statement for the save modes array, potentially missing important logging information. In the fixed code, an additional `logging(""String_Node_Str"" + saveModes[mModeSave]);` was added to ensure comprehensive logging of the save mode. This change improves code completeness by capturing all relevant settings information, providing more thorough diagnostic and debugging capabilities."
94118,"public static void addSaveButtons(XC_InitPackageResources.InitPackageResourcesParam resparam,final XModuleResources mResources,final Context localContext,final boolean mModeSave,final boolean mModeStory){
  Logger.log(""String_Node_Str"");
  final FrameLayout.LayoutParams layoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,FrameLayout.LayoutParams.WRAP_CONTENT,Gravity.BOTTOM | Gravity.START);
  final Bitmap saveImg=BitmapFactory.decodeResource(mResources,R.mipmap.snap_button);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveStoryButton=new ImageButton(localContext);
      saveStoryButton.setLayoutParams(layoutParams);
      saveStoryButton.setBackgroundColor(0);
      saveStoryButton.setImageBitmap(saveImg);
      saveStoryButton.setVisibility(mModeSave ? View.VISIBLE : View.INVISIBLE);
      frameLayout.addView(saveStoryButton);
      saveStoryButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.saveSnapButtonPress();
        }
      }
);
    }
  }
);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveSnapButton=new ImageButton(localContext);
      saveSnapButton.setLayoutParams(layoutParams);
      saveSnapButton.setBackgroundColor(0);
      saveSnapButton.setImageBitmap(saveImg);
      saveSnapButton.setVisibility(mModeStory ? View.VISIBLE : View.INVISIBLE);
      frameLayout.addView(saveSnapButton);
      saveSnapButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.saveSnapButtonPress();
        }
      }
);
    }
  }
);
}","public static void addSaveButtons(XC_InitPackageResources.InitPackageResourcesParam resparam,final XModuleResources mResources,final Context localContext,final boolean mModeSave,final boolean mModeStory){
  Logger.log(""String_Node_Str"");
  final FrameLayout.LayoutParams layoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,FrameLayout.LayoutParams.WRAP_CONTENT,Gravity.BOTTOM | Gravity.START);
  final Bitmap saveImg=BitmapFactory.decodeResource(mResources,R.mipmap.snap_button);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveStoryButton=new ImageButton(localContext);
      saveStoryButton.setLayoutParams(layoutParams);
      saveStoryButton.setBackgroundColor(0);
      saveStoryButton.setImageBitmap(saveImg);
      saveStoryButton.setAlpha(0.8f);
      saveStoryButton.setVisibility(mModeSave ? View.VISIBLE : View.INVISIBLE);
      frameLayout.addView(saveStoryButton);
      saveStoryButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.saveSnapButtonPress();
        }
      }
);
    }
  }
);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveSnapButton=new ImageButton(localContext);
      saveSnapButton.setLayoutParams(layoutParams);
      saveSnapButton.setBackgroundColor(0);
      saveSnapButton.setAlpha(0.8f);
      saveSnapButton.setImageBitmap(saveImg);
      saveSnapButton.setVisibility(mModeStory ? View.VISIBLE : View.INVISIBLE);
      frameLayout.addView(saveSnapButton);
      saveSnapButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.saveSnapButtonPress();
        }
      }
);
    }
  }
);
}","The original code lacked visual feedback for save buttons by not setting any transparency, which could make them appear harsh or indistinct. The fixed code adds `setAlpha(0.8f)` to both save buttons, providing a softer, more visually appealing appearance while maintaining clear visibility. This subtle transparency enhancement improves user interaction by creating a more refined and intuitive button design that blends seamlessly with the interface."
94119,"@Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable {
  return false;
}","@Override protected Object replaceHookedMethod(MethodHookParam param){
  return false;
}","The original code incorrectly declares a `throws Throwable` clause in the method signature, which is unnecessary for this specific method implementation. The fixed code removes the `throws Throwable` declaration, simplifying the method signature and eliminating potential unnecessary exception handling. By removing the superfluous exception clause, the code becomes cleaner, more concise, and maintains the same functional behavior of returning `false`."
94120,"@Override public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  if (!lpparam.packageName.equals(Common.PACKAGE_SNAP))   return;
  try {
    Preferences.mSavePath=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
    Preferences.mCustomFilterLocation=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
    XposedUtils.log(""String_Node_Str"",false);
    Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
    context=(Context)callMethod(activityThread,""String_Node_Str"");
    classLoader=lpparam.classLoader;
    PackageInfo piSnapChat=context.getPackageManager().getPackageInfo(lpparam.packageName,0);
    XposedUtils.log(""String_Node_Str"" + piSnapChat.versionName + ""String_Node_Str""+ piSnapChat.versionCode+ ""String_Node_Str"",false);
    XposedUtils.log(""String_Node_Str"" + BuildConfig.VERSION_NAME + ""String_Node_Str""+ BuildConfig.VERSION_CODE+ ""String_Node_Str"",false);
    if (!Obfuscator.isSupported(piSnapChat.versionCode)) {
      Logger.log(""String_Node_Str"",true,true);
      Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
  }
 catch (  Exception e) {
    XposedUtils.log(""String_Node_Str"",e);
    return;
  }
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Context.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      Preferences.refreshPreferences();
      Preferences.printSettings();
      if (Preferences.mLicense == 1 || Preferences.mLicense == 2) {
        if (Preferences.mReplay == true) {
        }
        if (Preferences.mTyping == true) {
          Premium.initTyping(lpparam,modRes,SnapContext);
        }
        if (Preferences.mStealth == true && Preferences.mLicense == 2) {
          Premium.initViewed(lpparam,modRes,SnapContext);
        }
      }
      Preferences.prefs.reload();
      Preferences.refreshPreferences();
      XC_MethodHook initHook=new XC_MethodHook(){
        @Override protected void afterHookedMethod(        MethodHookParam param) throws Throwable {
          Preferences.prefs.reload();
          Preferences.refreshPreferences();
          SnapContext=(Activity)param.thisObject;
          if (!Preferences.acceptedToU) {
            AlertDialog.Builder builder=new AlertDialog.Builder(SnapContext).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setIcon(android.R.drawable.ic_dialog_alert);
            builder.setCancelable(false);
            final AlertDialog dialog=builder.create();
            dialog.setCanceledOnTouchOutside(false);
            dialog.show();
            return;
          }
          boolean isNull;
          isNull=SnapContext == null;
          Logger.log(""String_Node_Str"" + isNull,true);
          Preferences.prefs.reload();
          Preferences.refreshPreferences();
          Saving.initSaving(lpparam,mResources,SnapContext);
          Lens.initLens(lpparam,mResources,SnapContext);
          File vfilters=new File(Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"");
          if (vfilters.exists()) {
            VisualFilters.initVisualFilters(lpparam);
          }
 else {
            Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
          }
          if (Preferences.mHideLive || Preferences.mHidePeople || Preferences.mDiscoverUI) {
            Stories.initStories(lpparam);
          }
          Groups.initGroups(lpparam);
          if (Preferences.shouldAddGhost) {
            HookedLayouts.initVisiblity(lpparam);
          }
          if (Preferences.mMultiFilterBoolean) {
            MultiFilter.initMultiFilter(lpparam,mResources,SnapContext);
          }
          if (Preferences.mDiscoverSnap) {
            DataSaving.blockDsnap(lpparam);
          }
          if (Preferences.mStoryPreload) {
            DataSaving.blockStoryPreLoad(lpparam);
          }
          if (Preferences.mDiscoverUI) {
            DataSaving.blockFromUi(lpparam);
          }
          if (Preferences.mSpeed) {
            Spoofing.initSpeed(lpparam,SnapContext);
          }
          if (Preferences.mLocation) {
            Spoofing.initLocation(lpparam,SnapContext);
          }
          if (Preferences.mWeather) {
            Spoofing.initWeather(lpparam,SnapContext);
          }
          if (Preferences.mPaintTools) {
            PaintTools.initPaint(lpparam,mResources);
          }
          if (Preferences.mTimerCounter) {
            Misc.initTimer(lpparam,mResources);
          }
          if (Preferences.mChatAutoSave) {
            Chat.initTextSave(lpparam,mResources);
          }
          if (Preferences.mChatMediaSave) {
            Chat.initImageSave(lpparam,mResources);
          }
          if (Preferences.mIntegration) {
            HookedLayouts.initIntegration(lpparam,mResources);
          }
          Misc.forceNavBar(lpparam,Preferences.mForceNavbar);
          getEditText(lpparam);
          findAndHookMethod(Obfuscator.save.SCREENSHOTDETECTOR_CLASS,lpparam.classLoader,Obfuscator.save.SCREENSHOTDETECTOR_RUN,LinkedHashMap.class,XC_MethodReplacement.DO_NOTHING);
          findAndHookMethod(Obfuscator.save.SNAPSTATEMESSAGE_CLASS,lpparam.classLoader,Obfuscator.save.SNAPSTATEMESSAGE_SETSCREENSHOTCOUNT,Long.class,new XC_MethodHook(){
            @Override protected void beforeHookedMethod(            MethodHookParam param) throws Throwable {
              param.args[0]=0L;
              Logger.log(""String_Node_Str"",true);
            }
          }
);
          if (Preferences.mCustomSticker) {
            Stickers.initStickers(lpparam,modRes,SnapContext);
          }
        }
      }
;
      findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Bundle.class,initHook);
      findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",initHook);
      findAndHookMethod(Obfuscator.icons.ICON_HANDLER_CLASS,lpparam.classLoader,Obfuscator.icons.SHOW_LENS,boolean.class,boolean.class,new XC_MethodHook(){
        @Override protected void afterHookedMethod(        MethodHookParam param) throws Throwable {
          if ((boolean)param.args[0]) {
            HookedLayouts.upload.setVisibility(View.INVISIBLE);
          }
 else {
            HookedLayouts.upload.setVisibility(View.VISIBLE);
          }
        }
      }
);
      findAndHookMethod(Obfuscator.icons.ICON_HANDLER_CLASS,lpparam.classLoader,Obfuscator.icons.RECORDING_VIDEO,boolean.class,new XC_MethodHook(){
        @Override protected void afterHookedMethod(        MethodHookParam param) throws Throwable {
          HookedLayouts.upload.setVisibility(View.VISIBLE);
        }
      }
);
      for (      String s : Obfuscator.ROOTDETECTOR_METHODS) {
        findAndHookMethod(Obfuscator.ROOTDETECTOR_CLASS,lpparam.classLoader,s,XC_MethodReplacement.returnConstant(false));
        Logger.log(""String_Node_Str"" + s,true);
      }
      findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",int.class,new XC_MethodHook(){
        @Override protected void beforeHookedMethod(        MethodHookParam param) throws Throwable {
          param.args[0]=12000000;
        }
      }
);
      findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",long.class,new XC_MethodHook(){
        @Override protected void beforeHookedMethod(        MethodHookParam param) throws Throwable {
          param.args[0]=5190453;
        }
      }
);
      final Class<?> receivedSnapClass=findClass(Obfuscator.save.RECEIVEDSNAP_CLASS,lpparam.classLoader);
      try {
        XposedHelpers.setStaticIntField(receivedSnapClass,""String_Node_Str"",99999);
        final Class<?> snapMediaUtils=findClass(""String_Node_Str"",lpparam.classLoader);
        XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
        XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
        final Class<?> profileImageUtils=findClass(""String_Node_Str"",lpparam.classLoader);
        XposedHelpers.setStaticIntField(profileImageUtils,""String_Node_Str"",100);
        final Class<?> snapImageBryo=findClass(Obfuscator.save.SNAPIMAGEBRYO_CLASS,lpparam.classLoader);
        XposedHelpers.setStaticIntField(snapImageBryo,""String_Node_Str"",100);
        Logger.log(""String_Node_Str"",true);
      }
 catch (      Throwable t) {
        Logger.log(""String_Node_Str"",true);
        Logger.log(t.toString());
      }
      if (Common.CAPTION_UNLIMITED_VANILLA) {
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",XC_MethodReplacement.DO_NOTHING);
      }
      String vanillaCaptionEditTextClassName=""String_Node_Str"";
      hookAllConstructors(findClass(vanillaCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
        @Override protected void afterHookedMethod(        MethodHookParam param) throws Throwable {
          if (Common.CAPTION_UNLIMITED_VANILLA) {
            XposedUtils.log(""String_Node_Str"");
            EditText vanillaCaptionEditText=(EditText)param.thisObject;
            vanillaCaptionEditText.setSingleLine(false);
            vanillaCaptionEditText.setFilters(new InputFilter[0]);
            vanillaCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
            vanillaCaptionEditText.setOnEditorActionListener(null);
            setObjectField(vanillaCaptionEditText,""String_Node_Str"",null);
          }
        }
      }
);
      String fatCaptionEditTextClassName=""String_Node_Str"";
      hookAllConstructors(findClass(fatCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
        @Override protected void afterHookedMethod(        MethodHookParam param) throws Throwable {
          if (Common.CAPTION_UNLIMITED_FAT) {
            XposedUtils.log(""String_Node_Str"");
            EditText fatCaptionEditText=(EditText)param.thisObject;
            fatCaptionEditText.setFilters(new InputFilter[0]);
            fatCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
            fatCaptionEditText.setOnEditorActionListener(null);
            setObjectField(fatCaptionEditText,""String_Node_Str"",null);
          }
        }
      }
);
      Sharing.initSharing(lpparam,mResources);
      if (Preferences.hideBf == true) {
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,Obfuscator.FRIENDS_BF,new XC_MethodReplacement(){
          @Override protected Object replaceHookedMethod(          MethodHookParam param) throws Throwable {
            return false;
          }
        }
);
      }
      if (Preferences.mCustomFilterBoolean == true) {
        addFilter(lpparam);
      }
      if (Preferences.selectAll == true) {
        HookSendList.initSelectAll(lpparam);
      }
    }
  }
);
}","@Override public void handleLoadPackage(final LoadPackageParam lpparam){
  try {
    if (!lpparam.packageName.equals(Common.PACKAGE_SNAP))     return;
    try {
      Preferences.mSavePath=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
      Preferences.mCustomFilterLocation=Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"";
      XposedUtils.log(""String_Node_Str"",false);
      Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
      context=(Context)callMethod(activityThread,""String_Node_Str"");
      classLoader=lpparam.classLoader;
      PackageInfo piSnapChat=context.getPackageManager().getPackageInfo(lpparam.packageName,0);
      XposedUtils.log(""String_Node_Str"" + piSnapChat.versionName + ""String_Node_Str""+ piSnapChat.versionCode+ ""String_Node_Str"",false);
      XposedUtils.log(""String_Node_Str"" + BuildConfig.VERSION_NAME + ""String_Node_Str""+ BuildConfig.VERSION_CODE+ ""String_Node_Str"",false);
      if (!Obfuscator.isSupported(piSnapChat.versionCode)) {
        Logger.log(""String_Node_Str"",true,true);
        Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        return;
      }
    }
 catch (    Exception e) {
      XposedUtils.log(""String_Node_Str"",e);
      return;
    }
    findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Context.class,new XC_MethodHook(){
      @Override protected void afterHookedMethod(      MethodHookParam param) throws Throwable {
        Preferences.refreshPreferences();
        Preferences.printSettings();
        if (Preferences.mLicense == 1 || Preferences.mLicense == 2) {
          if (Preferences.mReplay) {
          }
          if (Preferences.mTyping) {
            Premium.initTyping(lpparam,modRes,SnapContext);
          }
          if (Preferences.mStealth && Preferences.mLicense == 2) {
            Premium.initViewed(lpparam,modRes,SnapContext);
          }
        }
        Preferences.prefs.reload();
        Preferences.refreshPreferences();
        XC_MethodHook initHook=new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param) throws Throwable {
            Preferences.prefs.reload();
            Preferences.refreshPreferences();
            SnapContext=(Activity)param.thisObject;
            if (!Preferences.acceptedToU) {
              AlertDialog.Builder builder=new AlertDialog.Builder(SnapContext).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setIcon(android.R.drawable.ic_dialog_alert);
              builder.setCancelable(false);
              final AlertDialog dialog=builder.create();
              dialog.setCanceledOnTouchOutside(false);
              dialog.show();
              return;
            }
            boolean isNull;
            isNull=SnapContext == null;
            Logger.log(""String_Node_Str"" + isNull,true);
            Preferences.prefs.reload();
            Preferences.refreshPreferences();
            Saving.initSaving(lpparam,mResources,SnapContext);
            Lens.initLens(lpparam,mResources,SnapContext);
            File vfilters=new File(Environment.getExternalStorageDirectory().getAbsolutePath() + ""String_Node_Str"");
            if (vfilters.exists()) {
              VisualFilters.initVisualFilters(lpparam);
            }
 else {
              Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
            }
            if (Preferences.mHideLive || Preferences.mHidePeople || Preferences.mDiscoverUI) {
              Stories.initStories(lpparam);
            }
            Groups.initGroups(lpparam);
            if (Preferences.shouldAddGhost) {
              HookedLayouts.initVisiblity(lpparam);
            }
            if (Preferences.mMultiFilterBoolean) {
              MultiFilter.initMultiFilter(lpparam,mResources,SnapContext);
            }
            if (Preferences.mDiscoverSnap) {
              DataSaving.blockDsnap(lpparam);
            }
            if (Preferences.mStoryPreload) {
              DataSaving.blockStoryPreLoad(lpparam);
            }
            if (Preferences.mDiscoverUI) {
              DataSaving.blockFromUi(lpparam);
            }
            if (Preferences.mSpeed) {
              Spoofing.initSpeed(lpparam,SnapContext);
            }
            if (Preferences.mLocation) {
              Spoofing.initLocation(lpparam,SnapContext);
            }
            if (Preferences.mWeather) {
              Spoofing.initWeather(lpparam,SnapContext);
            }
            if (Preferences.mPaintTools) {
              PaintTools.initPaint(lpparam,mResources);
            }
            if (Preferences.mTimerCounter) {
              Misc.initTimer(lpparam,mResources);
            }
            if (Preferences.mChatAutoSave) {
              Chat.initTextSave(lpparam,mResources);
            }
            if (Preferences.mChatMediaSave) {
              Chat.initImageSave(lpparam,mResources);
            }
            if (Preferences.mIntegration) {
              HookedLayouts.initIntegration(lpparam,mResources);
            }
            Misc.forceNavBar(lpparam,Preferences.mForceNavbar);
            getEditText(lpparam);
            findAndHookMethod(Obfuscator.save.SCREENSHOTDETECTOR_CLASS,lpparam.classLoader,Obfuscator.save.SCREENSHOTDETECTOR_RUN,LinkedHashMap.class,XC_MethodReplacement.DO_NOTHING);
            findAndHookMethod(Obfuscator.save.SNAPSTATEMESSAGE_CLASS,lpparam.classLoader,Obfuscator.save.SNAPSTATEMESSAGE_SETSCREENSHOTCOUNT,Long.class,new XC_MethodHook(){
              @Override protected void beforeHookedMethod(              MethodHookParam param){
                param.args[0]=0L;
                Logger.log(""String_Node_Str"",true);
              }
            }
);
            if (Preferences.mCustomSticker) {
              Stickers.initStickers(lpparam,modRes,SnapContext);
            }
          }
        }
;
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Bundle.class,initHook);
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",initHook);
        findAndHookMethod(Obfuscator.icons.ICON_HANDLER_CLASS,lpparam.classLoader,Obfuscator.icons.SHOW_LENS,boolean.class,boolean.class,new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if ((boolean)param.args[0]) {
              HookedLayouts.upload.setVisibility(View.INVISIBLE);
            }
 else {
              HookedLayouts.upload.setVisibility(View.VISIBLE);
            }
          }
        }
);
        findAndHookMethod(Obfuscator.icons.ICON_HANDLER_CLASS,lpparam.classLoader,Obfuscator.icons.RECORDING_VIDEO,boolean.class,new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            HookedLayouts.upload.setVisibility(View.VISIBLE);
          }
        }
);
        for (        String s : Obfuscator.ROOTDETECTOR_METHODS) {
          findAndHookMethod(Obfuscator.ROOTDETECTOR_CLASS,lpparam.classLoader,s,XC_MethodReplacement.returnConstant(false));
          Logger.log(""String_Node_Str"" + s,true);
        }
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",int.class,new XC_MethodHook(){
          @Override protected void beforeHookedMethod(          MethodHookParam param){
            param.args[0]=12000000;
          }
        }
);
        findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",long.class,new XC_MethodHook(){
          @Override protected void beforeHookedMethod(          MethodHookParam param){
            param.args[0]=5190453;
          }
        }
);
        final Class<?> receivedSnapClass=findClass(Obfuscator.save.RECEIVEDSNAP_CLASS,lpparam.classLoader);
        try {
          XposedHelpers.setStaticIntField(receivedSnapClass,""String_Node_Str"",99999);
          final Class<?> snapMediaUtils=findClass(""String_Node_Str"",lpparam.classLoader);
          XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
          XposedHelpers.setStaticIntField(snapMediaUtils,""String_Node_Str"",100);
          final Class<?> profileImageUtils=findClass(""String_Node_Str"",lpparam.classLoader);
          XposedHelpers.setStaticIntField(profileImageUtils,""String_Node_Str"",100);
          final Class<?> snapImageBryo=findClass(Obfuscator.save.SNAPIMAGEBRYO_CLASS,lpparam.classLoader);
          XposedHelpers.setStaticIntField(snapImageBryo,""String_Node_Str"",100);
          Logger.log(""String_Node_Str"",true);
        }
 catch (        Throwable t) {
          Logger.log(""String_Node_Str"",true);
          Logger.log(t.toString());
        }
        if (Common.CAPTION_UNLIMITED_VANILLA) {
          findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",XC_MethodReplacement.DO_NOTHING);
        }
        String vanillaCaptionEditTextClassName=""String_Node_Str"";
        hookAllConstructors(findClass(vanillaCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if (Common.CAPTION_UNLIMITED_VANILLA) {
              XposedUtils.log(""String_Node_Str"");
              EditText vanillaCaptionEditText=(EditText)param.thisObject;
              vanillaCaptionEditText.setSingleLine(false);
              vanillaCaptionEditText.setFilters(new InputFilter[0]);
              vanillaCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
              vanillaCaptionEditText.setOnEditorActionListener(null);
              setObjectField(vanillaCaptionEditText,""String_Node_Str"",null);
            }
          }
        }
);
        String fatCaptionEditTextClassName=""String_Node_Str"";
        hookAllConstructors(findClass(fatCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
          @Override protected void afterHookedMethod(          MethodHookParam param){
            if (Common.CAPTION_UNLIMITED_FAT) {
              XposedUtils.log(""String_Node_Str"");
              EditText fatCaptionEditText=(EditText)param.thisObject;
              fatCaptionEditText.setFilters(new InputFilter[0]);
              fatCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
              fatCaptionEditText.setOnEditorActionListener(null);
              setObjectField(fatCaptionEditText,""String_Node_Str"",null);
            }
          }
        }
);
        Sharing.initSharing(lpparam,mResources);
        if (Preferences.hideBf) {
          findAndHookMethod(""String_Node_Str"",lpparam.classLoader,Obfuscator.FRIENDS_BF,new XC_MethodReplacement(){
            @Override protected Object replaceHookedMethod(            MethodHookParam param){
              return false;
            }
          }
);
        }
        if (Preferences.mCustomFilterBoolean) {
          addFilter(lpparam);
        }
        if (Preferences.selectAll) {
          HookSendList.initSelectAll(lpparam);
        }
      }
    }
);
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"",e);
  }
}","The original code had an unstructured error handling approach with nested try-catch blocks and potential resource leaks. The fixed code consolidates error handling by wrapping the entire method in a single try-catch block, ensuring comprehensive exception management and preventing potential method execution interruptions. This restructuring improves code robustness by providing a more centralized and predictable error handling mechanism, reducing the risk of unhandled exceptions and enhancing overall code reliability."
94121,"@Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
  param.args[0]=5190453;
}","@Override protected void beforeHookedMethod(MethodHookParam param){
  param.args[0]=5190453;
}","The original code incorrectly declares a `throws Throwable` clause in the method signature, which unnecessarily propagates potential exceptions. The fixed code removes this clause, simplifying error handling and allowing the method to handle exceptions internally without mandatory external exception management. By eliminating the `throws` declaration, the code becomes more flexible and reduces unnecessary exception propagation in the method implementation."
94122,"private void addFilter(LoadPackageParam lpparam){
  findAndHookMethod(ImageView.class,""String_Node_Str"",int.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param){
      try {
        XModuleResources modRes=XModuleResources.createInstance(MODULE_PATH,null);
        ImageView iv=(ImageView)param.thisObject;
        int resId=(Integer)param.args[0];
        if (iv != null)         if (iv.getContext().getPackageName().equals(""String_Node_Str""))         if (resId == iv.getContext().getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))         if (Preferences.mCustomFilterLocation == null) {
          iv.setImageDrawable(modRes.getDrawable(R.drawable.custom_filter_1));
          Logger.log(""String_Node_Str"",true);
        }
 else {
          if (Preferences.mCustomFilterType == 0) {
            iv.setImageDrawable(Drawable.createFromPath(Preferences.mCustomFilterLocation + ""String_Node_Str""));
          }
 else           if (Preferences.mCustomFilterType == 1) {
            iv.setImageDrawable(Drawable.createFromPath(Preferences.mCustomFilterLocation + ""String_Node_Str""));
          }
          Logger.log(""String_Node_Str"" + Preferences.mCustomFilterLocation + ""String_Node_Str""+ Preferences.mCustomFilterType,true);
        }
      }
 catch (      Throwable t) {
        XposedBridge.log(t);
      }
    }
  }
);
  final Class<?> batteryInfoProviderEnum=findClass(""String_Node_Str"",lpparam.classLoader);
  findAndHookMethod(Obfuscator.spoofing.BATTERY_FILTER,lpparam.classLoader,""String_Node_Str"",new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      Object battery=getStaticObjectField(batteryInfoProviderEnum,""String_Node_Str"");
      param.setResult(battery);
    }
  }
);
}","private void addFilter(LoadPackageParam lpparam){
  findAndHookMethod(ImageView.class,""String_Node_Str"",int.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param){
      try {
        XModuleResources modRes=XModuleResources.createInstance(MODULE_PATH,null);
        ImageView iv=(ImageView)param.thisObject;
        int resId=(Integer)param.args[0];
        if (iv != null)         if (iv.getContext().getPackageName().equals(""String_Node_Str""))         if (resId == iv.getContext().getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))         if (Preferences.mCustomFilterLocation == null) {
          iv.setImageDrawable(modRes.getDrawable(R.drawable.custom_filter_1));
          Logger.log(""String_Node_Str"",true);
        }
 else {
          if (Preferences.mCustomFilterType == 0) {
            iv.setImageDrawable(Drawable.createFromPath(Preferences.mCustomFilterLocation + ""String_Node_Str""));
          }
 else           if (Preferences.mCustomFilterType == 1) {
            iv.setImageDrawable(Drawable.createFromPath(Preferences.mCustomFilterLocation + ""String_Node_Str""));
          }
          Logger.log(""String_Node_Str"" + Preferences.mCustomFilterLocation + ""String_Node_Str""+ Preferences.mCustomFilterType,true);
        }
      }
 catch (      Throwable t) {
        XposedBridge.log(t);
      }
    }
  }
);
  final Class<?> batteryInfoProviderEnum=findClass(""String_Node_Str"",lpparam.classLoader);
  findAndHookMethod(Obfuscator.spoofing.BATTERY_FILTER,lpparam.classLoader,""String_Node_Str"",new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param){
      Object battery=getStaticObjectField(batteryInfoProviderEnum,""String_Node_Str"");
      param.setResult(battery);
    }
  }
);
}","The original code had a potential issue with throwing an uncaught exception in the second method hook due to the ""throws Throwable"" clause. The fixed code removes the ""throws Throwable"" declaration, allowing the method to handle exceptions more gracefully without explicitly propagating them. This modification ensures more robust error handling and prevents unexpected method termination, improving the overall stability of the code's exception management mechanism."
94123,"@Override public void handleInitPackageResources(InitPackageResourcesParam resparam) throws Throwable {
  if (!resparam.packageName.equals(Common.PACKAGE_SNAP))   return;
  int name=R.id.name;
  int checkBox=R.id.checkBox;
  int friend_item=R.layout.friend_item;
  int group_item=R.layout.group_item;
  modRes=XModuleResources.createInstance(MODULE_PATH,resparam.res);
  FriendListDialog.name=XResources.getFakeResId(modRes,name);
  resparam.res.setReplacement(FriendListDialog.name,modRes.fwd(name));
  FriendListDialog.checkBox=XResources.getFakeResId(modRes,checkBox);
  resparam.res.setReplacement(FriendListDialog.checkBox,modRes.fwd(checkBox));
  FriendListDialog.friend_item=XResources.getFakeResId(modRes,checkBox);
  resparam.res.setReplacement(FriendListDialog.friend_item,modRes.fwd(friend_item));
  GroupDialog.group_item=XResources.getFakeResId(modRes,group_item);
  resparam.res.setReplacement(GroupDialog.group_item,modRes.fwd(group_item));
  Preferences.refreshPreferences();
  resParam=resparam;
  Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
  Context localContext=(Context)callMethod(activityThread,""String_Node_Str"");
  HookedLayouts.addSaveButtonsAndGestures(resparam,mResources,localContext);
  if (Preferences.shouldAddGhost) {
    HookedLayouts.addIcons(resparam,mResources);
  }
  if (Preferences.mIntegration) {
    HookedLayouts.addShareIcon(resparam);
  }
  if (Preferences.mHidePeople) {
    Stories.addSnapprefsBtn(resparam,mResources);
  }
  HookedLayouts.fullScreenFilter(resparam);
}","@Override public void handleInitPackageResources(InitPackageResourcesParam resparam){
  try {
    if (!resparam.packageName.equals(Common.PACKAGE_SNAP)) {
      Logger.log(""String_Node_Str"");
      return;
    }
    int name=R.id.name;
    int checkBox=R.id.checkBox;
    int friend_item=R.layout.friend_item;
    int group_item=R.layout.group_item;
    modRes=XModuleResources.createInstance(MODULE_PATH,resparam.res);
    FriendListDialog.name=XResources.getFakeResId(modRes,name);
    resparam.res.setReplacement(FriendListDialog.name,modRes.fwd(name));
    FriendListDialog.checkBox=XResources.getFakeResId(modRes,checkBox);
    resparam.res.setReplacement(FriendListDialog.checkBox,modRes.fwd(checkBox));
    FriendListDialog.friend_item=XResources.getFakeResId(modRes,checkBox);
    resparam.res.setReplacement(FriendListDialog.friend_item,modRes.fwd(friend_item));
    GroupDialog.group_item=XResources.getFakeResId(modRes,group_item);
    resparam.res.setReplacement(GroupDialog.group_item,modRes.fwd(group_item));
    Preferences.refreshPreferences();
    resParam=resparam;
    Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
    Context localContext=(Context)callMethod(activityThread,""String_Node_Str"");
    HookedLayouts.addSaveButtonsAndGestures(resparam,mResources,localContext);
    if (Preferences.shouldAddGhost) {
      HookedLayouts.addIcons(resparam,mResources);
    }
    if (Preferences.mIntegration) {
      HookedLayouts.addShareIcon(resparam);
    }
    if (Preferences.mHidePeople) {
      Stories.addSnapprefsBtn(resparam,mResources);
    }
    HookedLayouts.fullScreenFilter(resparam);
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"",e);
  }
}","The original code lacked proper exception handling, which could lead to unhandled runtime errors and potential app crashes during resource initialization. The fixed code introduces a try-catch block that wraps the entire method, capturing and logging any exceptions that might occur during the process, with a specific error logging mechanism through the `Logger.log()` method. This approach provides robust error management, prevents unexpected terminations, and allows for better debugging by capturing and recording potential issues during the Snapchat package resources initialization."
94124,"@Override public void initZygote(StartupParam startupParam) throws Throwable {
  MODULE_PATH=startupParam.modulePath;
  mResources=XModuleResources.createInstance(startupParam.modulePath,null);
}","@Override public void initZygote(StartupParam startupParam){
  MODULE_PATH=startupParam.modulePath;
  mResources=XModuleResources.createInstance(startupParam.modulePath,null);
}","The original code incorrectly declares a `throws Throwable` clause, which is unnecessary for this method and can lead to unnecessary exception handling. The fixed code removes the `throws Throwable` clause, simplifying the method signature and allowing cleaner initialization of `MODULE_PATH` and `mResources`. By eliminating the superfluous exception handling, the code becomes more straightforward and reduces potential overhead in the Zygote initialization process."
94125,"public boolean postData(){
  HttpClient httpclient=new DefaultHttpClient();
  HttpPost httppost=new HttpPost(""String_Node_Str"");
  try {
    List nameValuePairs=new ArrayList(2);
    nameValuePairs.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
    httppost.setEntity(new UrlEncodedFormEntity(nameValuePairs));
    HttpResponse response=httpclient.execute(httppost);
    InputStream is=response.getEntity().getContent();
    BufferedInputStream bis=new BufferedInputStream(is);
    final ByteArrayBuffer baf=new ByteArrayBuffer(20);
    int current=0;
    while ((current=bis.read()) != -1) {
      baf.append((byte)current);
    }
    String text=new String(baf.toByteArray());
    String status=null;
    String error_msg=null;
    try {
      JSONObject obj=new JSONObject(text);
      status=obj.getString(""String_Node_Str"");
      error_msg=obj.getString(""String_Node_Str"");
      if (status.equals(""String_Node_Str"") && !error_msg.isEmpty()) {
        latest=true;
      }
      if (status.equals(""String_Node_Str"") && error_msg.isEmpty()) {
        latest=false;
      }
    }
 catch (    Throwable t) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + text + ""String_Node_Str"");
      latest=false;
    }
  }
 catch (  ClientProtocolException e) {
    latest=false;
  }
catch (  IOException e) {
    latest=false;
  }
  return latest;
}","public boolean postData(){
  HttpClient httpclient=new DefaultHttpClient();
  HttpPost httppost=new HttpPost(""String_Node_Str"");
  try {
    List<BasicNameValuePair> nameValuePairs=new ArrayList<BasicNameValuePair>(2);
    nameValuePairs.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
    httppost.setEntity(new UrlEncodedFormEntity(nameValuePairs));
    HttpResponse response=httpclient.execute(httppost);
    InputStream is=response.getEntity().getContent();
    BufferedInputStream bis=new BufferedInputStream(is);
    final ByteArrayBuffer baf=new ByteArrayBuffer(20);
    int current;
    while ((current=bis.read()) != -1) {
      baf.append((byte)current);
    }
    String text=new String(baf.toByteArray());
    String status;
    String error_msg;
    try {
      JSONObject obj=new JSONObject(text);
      status=obj.getString(""String_Node_Str"");
      error_msg=obj.getString(""String_Node_Str"");
      if (status.equals(""String_Node_Str"") && !error_msg.isEmpty()) {
        latest=true;
      }
      if (status.equals(""String_Node_Str"") && error_msg.isEmpty()) {
        latest=false;
      }
    }
 catch (    Throwable t) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + text + ""String_Node_Str"");
      latest=false;
    }
  }
 catch (  IOException e2) {
    latest=false;
  }
  return latest;
}","The buggy code had uninitialized variables and an overly broad exception handling that could mask underlying issues. The fixed code adds type safety with generics for the `nameValuePairs` list, removes redundant `ClientProtocolException` catch block, and simplifies variable initialization. These changes improve code robustness, make exception handling more precise, and reduce potential runtime errors during HTTP post operations."
94126,"public static void addSaveButtonsAndGestures(XC_InitPackageResources.InitPackageResourcesParam resparam,final XModuleResources mResources,final Context localContext){
  final GestureEvent gestureEvent=new GestureEvent();
  Logger.log(""String_Node_Str"");
  final FrameLayout.LayoutParams layoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,FrameLayout.LayoutParams.WRAP_CONTENT,Gravity.BOTTOM | Gravity.START);
  final Bitmap saveImg=BitmapFactory.decodeResource(mResources,R.mipmap.snap_button);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveStoryButton=new ImageButton(localContext);
      saveStoryButton.setLayoutParams(layoutParams);
      saveStoryButton.setBackgroundColor(0);
      saveStoryButton.setImageBitmap(saveImg);
      saveStoryButton.setAlpha(0.8f);
      saveStoryButton.setVisibility(Preferences.mModeStory == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          if (Preferences.mModeStory != Preferences.SAVE_S2S)           return false;
          return gestureEvent.onTouch(v,event);
        }
      }
);
      frameLayout.addView(saveStoryButton);
      saveStoryButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveSnapButton=new ImageButton(localContext);
      saveSnapButton.setLayoutParams(layoutParams);
      saveSnapButton.setBackgroundColor(0);
      saveSnapButton.setAlpha(0.8f);
      saveSnapButton.setImageBitmap(saveImg);
      saveSnapButton.setVisibility(Preferences.mModeSave == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          if (Preferences.mModeSave != Preferences.SAVE_S2S)           return false;
          return gestureEvent.onTouch(v,event);
        }
      }
);
      frameLayout.addView(saveSnapButton);
      saveSnapButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
}","public static void addSaveButtonsAndGestures(XC_InitPackageResources.InitPackageResourcesParam resparam,final XModuleResources mResources,final Context localContext){
  final GestureEvent gestureEvent=new GestureEvent();
  Logger.log(""String_Node_Str"",false,true);
  Logger.log(""String_Node_Str"" + resparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP),false,true);
  Logger.log(""String_Node_Str"" + resparam.res.getResourceName(+2130837625),false,true);
  int intIconID=resparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP);
  final BitmapDrawable saveImg=(BitmapDrawable)resparam.res.getDrawable(intIconID);
  saveImg.setBounds(0,0,50,50);
  if (saveImg == null)   throw new NullPointerException(""String_Node_Str"");
  final FrameLayout.LayoutParams layoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,FrameLayout.LayoutParams.WRAP_CONTENT,Gravity.BOTTOM | Gravity.START);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveStoryButton=new ImageButton(localContext);
      saveStoryButton.setLayoutParams(layoutParams);
      saveStoryButton.setBackgroundColor(Color.argb(50,255,255,255));
      saveStoryButton.setImageDrawable(saveImg);
      saveStoryButton.setAlpha(0.8f);
      saveStoryButton.setVisibility(Preferences.mModeStory == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          return Preferences.mModeStory == Preferences.SAVE_S2S && gestureEvent.onTouch(v,event);
        }
      }
);
      frameLayout.addView(saveStoryButton);
      saveStoryButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
  resparam.res.hookLayout(Common.PACKAGE_SNAP,""String_Node_Str"",""String_Node_Str"",new XC_LayoutInflated(){
    @Override public void handleLayoutInflated(    LayoutInflatedParam liparam) throws Throwable {
      final FrameLayout frameLayout=(FrameLayout)liparam.view.findViewById(liparam.res.getIdentifier(""String_Node_Str"",""String_Node_Str"",Common.PACKAGE_SNAP)).getParent();
      saveSnapButton=new ImageButton(localContext);
      saveSnapButton.setLayoutParams(layoutParams);
      saveSnapButton.setBackgroundColor(0);
      saveSnapButton.setAlpha(0.8f);
      saveSnapButton.setImageDrawable(saveImg);
      saveSnapButton.setVisibility(Preferences.mModeSave == Preferences.SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
      frameLayout.setOnTouchListener(new View.OnTouchListener(){
        @Override public boolean onTouch(        View v,        MotionEvent event){
          if (Preferences.mModeSave != Preferences.SAVE_S2S)           return false;
          return gestureEvent.onTouch(v,event);
        }
      }
);
      frameLayout.addView(saveSnapButton);
      saveSnapButton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          Logger.printTitle(""String_Node_Str"");
          Saving.performButtonSave();
        }
      }
);
    }
  }
);
}","The original code had potential resource loading and error handling issues with hardcoded strings and bitmap decoding. The fixed code improves resource retrieval by using getIdentifier(), converting to BitmapDrawable, adding explicit error checking, and implementing more robust resource loading mechanisms. These changes enhance code reliability, provide better error handling, and ensure more consistent image button initialization across different scenarios."
94127,"static void refreshPreferences(){
  prefs=new XSharedPreferences(new File(Environment.getDataDirectory(),""String_Node_Str"" + HookMethods.PACKAGE_NAME + ""String_Node_Str""+ HookMethods.PACKAGE_NAME+ ""String_Node_Str""+ ""String_Node_Str""));
  prefs.reload();
  prefs.makeWorldReadable();
  selectAll=prefs.getBoolean(""String_Node_Str"",false);
  selectStory=prefs.getBoolean(""String_Node_Str"",false);
  selectVenue=prefs.getBoolean(""String_Node_Str"",false);
  hideBf=prefs.getBoolean(""String_Node_Str"",false);
  hideRecent=prefs.getBoolean(""String_Node_Str"",false);
  mTextTools=prefs.getBoolean(""String_Node_Str"",false);
  mPaintTools=prefs.getBoolean(""String_Node_Str"",mPaintTools);
  mTimerCounter=prefs.getBoolean(""String_Node_Str"",true);
  mChatAutoSave=prefs.getBoolean(""String_Node_Str"",true);
  mChatMediaSave=prefs.getBoolean(""String_Node_Str"",true);
  mIntegration=prefs.getBoolean(""String_Node_Str"",true);
  mCustomFilterBoolean=prefs.getBoolean(""String_Node_Str"",mCustomFilterBoolean);
  mMultiFilterBoolean=prefs.getBoolean(""String_Node_Str"",mMultiFilterBoolean);
  mCustomFilterLocation=Environment.getExternalStorageDirectory().toString() + ""String_Node_Str"";
  mCustomFilterType=prefs.getInt(""String_Node_Str"",0);
  mSpeed=prefs.getBoolean(""String_Node_Str"",false);
  mWeather=prefs.getBoolean(""String_Node_Str"",false);
  mLocation=prefs.getBoolean(""String_Node_Str"",false);
  mStoryPreload=prefs.getBoolean(""String_Node_Str"",false);
  mDiscoverSnap=prefs.getBoolean(""String_Node_Str"",false);
  mDiscoverUI=prefs.getBoolean(""String_Node_Str"",false);
  mCustomSticker=prefs.getBoolean(""String_Node_Str"",false);
  mHideLive=prefs.getBoolean(""String_Node_Str"",false);
  mHidePeople=prefs.getBoolean(""String_Node_Str"",false);
  mReplay=prefs.getBoolean(""String_Node_Str"",false);
  mStealth=prefs.getBoolean(""String_Node_Str"",false);
  mTyping=prefs.getBoolean(""String_Node_Str"",false);
  mUnlimGroups=prefs.getBoolean(""String_Node_Str"",false);
  mForceNavbar=prefs.getInt(""String_Node_Str"",0);
  mConfirmationID=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  debug=prefs.getBoolean(""String_Node_Str"",false);
  mDeviceID=prefs.getString(""String_Node_Str"",null);
  mLicense=prefs.getInt(mDeviceID,0);
  mModeSave=prefs.getInt(""String_Node_Str"",mModeSave);
  mModeStory=prefs.getInt(""String_Node_Str"",mModeStory);
  mTimerMinimum=prefs.getInt(""String_Node_Str"",mTimerMinimum);
  mToastEnabled=prefs.getBoolean(""String_Node_Str"",mToastEnabled);
  mVibrationEnabled=prefs.getBoolean(""String_Node_Str"",mVibrationEnabled);
  mToastLength=prefs.getInt(""String_Node_Str"",mToastLength);
  mSavePath=prefs.getString(""String_Node_Str"",mSavePath);
  mSaveSentSnaps=prefs.getBoolean(""String_Node_Str"",mSaveSentSnaps);
  mSortByCategory=prefs.getBoolean(""String_Node_Str"",mSortByCategory);
  mSortByUsername=prefs.getBoolean(""String_Node_Str"",mSortByUsername);
  mDebugging=prefs.getBoolean(""String_Node_Str"",mDebugging);
  mOverlays=prefs.getBoolean(""String_Node_Str"",mOverlays);
  mTimerUnlimited=prefs.getBoolean(""String_Node_Str"",mTimerUnlimited);
  mHideTimerStory=prefs.getBoolean(""String_Node_Str"",mHideTimerStory);
  mLoopingVids=prefs.getBoolean(""String_Node_Str"",mLoopingVids);
  mHideTimer=prefs.getBoolean(""String_Node_Str"",mHideTimer);
  Common.ROTATION_MODE=Integer.parseInt(prefs.getString(""String_Node_Str"",Integer.toString(Common.ROTATION_MODE)));
  Common.ADJUST_METHOD=Integer.parseInt(prefs.getString(""String_Node_Str"",Integer.toString(Common.ADJUST_METHOD)));
  Common.CAPTION_UNLIMITED_VANILLA=prefs.getBoolean(""String_Node_Str"",Common.CAPTION_UNLIMITED_VANILLA);
  Common.CAPTION_UNLIMITED_FAT=prefs.getBoolean(""String_Node_Str"",Common.CAPTION_UNLIMITED_FAT);
  Common.DEBUGGING=prefs.getBoolean(""String_Node_Str"",Common.DEBUGGING);
  Common.CHECK_SIZE=!prefs.getBoolean(""String_Node_Str"",!Common.CHECK_SIZE);
  Common.TIMBER=prefs.getBoolean(""String_Node_Str"",Common.TIMBER);
  shouldAddGhost=mSpeed || mTextTools || mLocation|| mWeather;
  acceptedToU=prefs.getBoolean(""String_Node_Str"",false);
  if (HookedLayouts.saveSnapButton != null)   HookedLayouts.saveSnapButton.setVisibility(mModeSave == SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
  if (HookedLayouts.saveStoryButton != null)   HookedLayouts.saveStoryButton.setVisibility(mModeStory == SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
}","static void refreshPreferences(){
  prefs=new XSharedPreferences(new File(Environment.getDataDirectory(),""String_Node_Str"" + HookMethods.PACKAGE_NAME + ""String_Node_Str""+ HookMethods.PACKAGE_NAME+ ""String_Node_Str""+ ""String_Node_Str""));
  prefs.reload();
  prefs.makeWorldReadable();
  selectAll=prefs.getBoolean(""String_Node_Str"",false);
  selectStory=prefs.getBoolean(""String_Node_Str"",false);
  selectVenue=prefs.getBoolean(""String_Node_Str"",false);
  hideBf=prefs.getBoolean(""String_Node_Str"",false);
  hideRecent=prefs.getBoolean(""String_Node_Str"",false);
  mTextTools=prefs.getBoolean(""String_Node_Str"",false);
  mPaintTools=prefs.getBoolean(""String_Node_Str"",mPaintTools);
  mTimerCounter=prefs.getBoolean(""String_Node_Str"",true);
  mChatAutoSave=prefs.getBoolean(""String_Node_Str"",true);
  mChatMediaSave=prefs.getBoolean(""String_Node_Str"",true);
  mIntegration=prefs.getBoolean(""String_Node_Str"",true);
  mCustomFilterBoolean=prefs.getBoolean(""String_Node_Str"",mCustomFilterBoolean);
  mMultiFilterBoolean=prefs.getBoolean(""String_Node_Str"",mMultiFilterBoolean);
  mCustomFilterLocation=getExternalPath() + ""String_Node_Str"";
  mCustomFilterType=prefs.getInt(""String_Node_Str"",0);
  mSpeed=prefs.getBoolean(""String_Node_Str"",false);
  mWeather=prefs.getBoolean(""String_Node_Str"",false);
  mLocation=prefs.getBoolean(""String_Node_Str"",false);
  mStoryPreload=prefs.getBoolean(""String_Node_Str"",false);
  mDiscoverSnap=prefs.getBoolean(""String_Node_Str"",false);
  mDiscoverUI=prefs.getBoolean(""String_Node_Str"",false);
  mCustomSticker=prefs.getBoolean(""String_Node_Str"",false);
  mHideLive=prefs.getBoolean(""String_Node_Str"",false);
  mHidePeople=prefs.getBoolean(""String_Node_Str"",false);
  mReplay=prefs.getBoolean(""String_Node_Str"",false);
  mStealth=prefs.getBoolean(""String_Node_Str"",false);
  mTyping=prefs.getBoolean(""String_Node_Str"",false);
  mUnlimGroups=prefs.getBoolean(""String_Node_Str"",false);
  mForceNavbar=prefs.getInt(""String_Node_Str"",0);
  mConfirmationID=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  debug=prefs.getBoolean(""String_Node_Str"",false);
  mDeviceID=prefs.getString(""String_Node_Str"",null);
  mLicense=prefs.getInt(mDeviceID,0);
  mModeSave=prefs.getInt(""String_Node_Str"",mModeSave);
  mModeStory=prefs.getInt(""String_Node_Str"",mModeStory);
  mTimerMinimum=prefs.getInt(""String_Node_Str"",mTimerMinimum);
  mToastEnabled=prefs.getBoolean(""String_Node_Str"",mToastEnabled);
  mVibrationEnabled=prefs.getBoolean(""String_Node_Str"",mVibrationEnabled);
  mToastLength=prefs.getInt(""String_Node_Str"",mToastLength);
  mSavePath=prefs.getString(""String_Node_Str"",mSavePath);
  mSaveSentSnaps=prefs.getBoolean(""String_Node_Str"",mSaveSentSnaps);
  mSortByCategory=prefs.getBoolean(""String_Node_Str"",mSortByCategory);
  mSortByUsername=prefs.getBoolean(""String_Node_Str"",mSortByUsername);
  mDebugging=prefs.getBoolean(""String_Node_Str"",mDebugging);
  mOverlays=prefs.getBoolean(""String_Node_Str"",mOverlays);
  mTimerUnlimited=prefs.getBoolean(""String_Node_Str"",mTimerUnlimited);
  mHideTimerStory=prefs.getBoolean(""String_Node_Str"",mHideTimerStory);
  mLoopingVids=prefs.getBoolean(""String_Node_Str"",mLoopingVids);
  mHideTimer=prefs.getBoolean(""String_Node_Str"",mHideTimer);
  Common.ROTATION_MODE=Integer.parseInt(prefs.getString(""String_Node_Str"",Integer.toString(Common.ROTATION_MODE)));
  Common.ADJUST_METHOD=Integer.parseInt(prefs.getString(""String_Node_Str"",Integer.toString(Common.ADJUST_METHOD)));
  Common.CAPTION_UNLIMITED_VANILLA=prefs.getBoolean(""String_Node_Str"",Common.CAPTION_UNLIMITED_VANILLA);
  Common.CAPTION_UNLIMITED_FAT=prefs.getBoolean(""String_Node_Str"",Common.CAPTION_UNLIMITED_FAT);
  Common.DEBUGGING=prefs.getBoolean(""String_Node_Str"",Common.DEBUGGING);
  Common.CHECK_SIZE=!prefs.getBoolean(""String_Node_Str"",!Common.CHECK_SIZE);
  Common.TIMBER=prefs.getBoolean(""String_Node_Str"",Common.TIMBER);
  shouldAddGhost=mSpeed || mTextTools || mLocation|| mWeather;
  acceptedToU=prefs.getBoolean(""String_Node_Str"",false);
  if (HookedLayouts.saveSnapButton != null)   HookedLayouts.saveSnapButton.setVisibility(mModeSave == SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
  if (HookedLayouts.saveStoryButton != null)   HookedLayouts.saveStoryButton.setVisibility(mModeStory == SAVE_BUTTON ? View.VISIBLE : View.INVISIBLE);
}","The original code directly used `Environment.getExternalStorageDirectory().toString()`, which can pose security and permission risks in modern Android versions. The fixed code introduces a new method `getExternalPath()` (presumably a safer wrapper method) to retrieve the external storage path. By abstracting the path retrieval, the fixed code provides better encapsulation, improves potential permission handling, and makes the external storage access more robust and adaptable to different Android versions."
94128,"private static void handleSnapHeader(Context context,Object receivedSnap) throws Exception {
  Logger.printTitle(""String_Node_Str"");
  Logger.printMessage(""String_Node_Str"" + receivedSnap.getClass().getCanonicalName());
  String mId=(String)getObjectField(receivedSnap,""String_Node_Str"");
  SnapType snapType=receivedSnap.getClass().getCanonicalName().equals(""String_Node_Str"") ? SnapType.STORY : SnapType.SNAP;
  Logger.printMessage(""String_Node_Str"" + snapType.name);
  String mKey=mId;
  String strSender;
  Logger.log(""String_Node_Str"" + getObjectField(receivedSnap,""String_Node_Str""));
  if (snapType == SnapType.SNAP) {
    mKey+=(String)getObjectField(receivedSnap,""String_Node_Str"");
    strSender=(String)getObjectField(receivedSnap,""String_Node_Str"");
  }
 else   strSender=(String)getObjectField(receivedSnap,""String_Node_Str"");
  Logger.printMessage(""String_Node_Str"" + mKey);
  Logger.printMessage(""String_Node_Str"" + strSender);
  SnapData snapData=hashSnapData.get(mKey);
  if (snapData != null && scanForExisting(snapData,FlagState.HEADER)) {
    Logger.printFinalMessage(""String_Node_Str"");
    return;
  }
 else   if (snapData == null) {
    snapData=new SnapData(mKey);
    hashSnapData.put(mKey,snapData);
  }
  printFlags(snapData);
  long lngTimestamp=(Long)callMethod(receivedSnap,Obfuscator.save.SNAP_GETTIMESTAMP);
  Date timestamp=new Date(lngTimestamp);
  String strTimestamp=dateFormat.format(timestamp);
  Logger.printMessage(""String_Node_Str"" + strTimestamp);
  snapData.setHeader(mId,mKey,strSender,strTimestamp,snapType);
  if (shouldSave(snapData)) {
    if (asyncSaveMode)     new AsyncSaveSnapData().execute(context,snapData);
 else     handleSave(context,snapData);
  }
 else {
    currentSnapData=snapData;
    relativeContext=context;
    Logger.printFinalMessage(""String_Node_Str"");
  }
}","private static void handleSnapHeader(Context context,Object receivedSnap) throws Exception {
  Logger.printTitle(""String_Node_Str"");
  Logger.printMessage(""String_Node_Str"" + receivedSnap.getClass().getCanonicalName());
  String mId=(String)getObjectField(receivedSnap,""String_Node_Str"");
  SnapType snapType=receivedSnap.getClass().getCanonicalName().equals(""String_Node_Str"") ? SnapType.STORY : SnapType.SNAP;
  Logger.printMessage(""String_Node_Str"" + snapType.name);
  String mKey=mId;
  String strSender;
  if (snapType == SnapType.SNAP) {
    mKey+=(String)getObjectField(receivedSnap,""String_Node_Str"");
    strSender=(String)getObjectField(receivedSnap,""String_Node_Str"");
  }
 else   strSender=(String)getObjectField(receivedSnap,""String_Node_Str"");
  Logger.printMessage(""String_Node_Str"" + mKey);
  Logger.printMessage(""String_Node_Str"" + strSender);
  SnapData snapData=hashSnapData.get(mKey);
  if (snapData != null && scanForExisting(snapData,FlagState.HEADER)) {
    Logger.printFinalMessage(""String_Node_Str"");
    return;
  }
 else   if (snapData == null) {
    snapData=new SnapData(mKey);
    hashSnapData.put(mKey,snapData);
  }
  printFlags(snapData);
  long lngTimestamp=(Long)callMethod(receivedSnap,Obfuscator.save.SNAP_GETTIMESTAMP);
  Date timestamp=new Date(lngTimestamp);
  String strTimestamp=dateFormat.format(timestamp);
  Logger.printMessage(""String_Node_Str"" + strTimestamp);
  snapData.setHeader(mId,mKey,strSender,strTimestamp,snapType);
  if (shouldSave(snapData)) {
    if (asyncSaveMode)     new AsyncSaveSnapData().execute(context,snapData);
 else     handleSave(context,snapData);
  }
 else {
    currentSnapData=snapData;
    relativeContext=context;
    Logger.printFinalMessage(""String_Node_Str"");
  }
}","The original code contained an unnecessary logging statement `Logger.log(""String_Node_Str"" + getObjectField(receivedSnap,""String_Node_Str""))` that was redundant and potentially impacting performance. The fixed code removes this unnecessary logging line, maintaining the core logic while eliminating superfluous code execution. By removing the extraneous log statement, the code becomes more efficient and cleaner, reducing potential performance overhead and maintaining the intended functionality of the method."
94129,"private void checkForCompletion(){
  if (flags.contains(FlagState.COMPLETED))   return;
  boolean isComplete=flags.contains(FlagState.HEADER) && flags.contains(FlagState.HEADER);
  if (isComplete)   flags.add(FlagState.COMPLETED);
}","private void checkForCompletion(){
  if (flags.contains(FlagState.COMPLETED))   return;
  boolean isComplete=flags.contains(FlagState.HEADER) && flags.contains(FlagState.PAYLOAD);
  if (isComplete)   flags.add(FlagState.COMPLETED);
}","The original code had a logical error where it checked for `FlagState.HEADER` twice, effectively creating a redundant condition that would never evaluate true. The fixed code corrects this by replacing the second `FlagState.HEADER` with `FlagState.PAYLOAD`, ensuring a proper check for both header and payload flags. This modification allows the `COMPLETED` flag to be added only when both header and payload states are present, making the completion check more accurate and meaningful."
94130,"@Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
  Logger.log(""String_Node_Str"" + param.args[0],true);
  String str=(String)param.args[0];
  if (str.contains(""String_Node_Str"")) {
    String url=Environment.getExternalStorageDirectory() + ""String_Node_Str"" + str;
    Logger.log(""String_Node_Str"" + url,true);
    File file=new File(url);
    InputStream is=null;
    is=new BufferedInputStream(new FileInputStream(file));
    param.setResult(is);
    Logger.log(""String_Node_Str"",true);
  }
}","@Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
  Logger.log(""String_Node_Str"" + param.args[0],true);
  String str=(String)param.args[0];
  if (str.contains(""String_Node_Str"")) {
    String url=Environment.getExternalStorageDirectory() + ""String_Node_Str"" + str;
    Logger.log(""String_Node_Str"" + url,true);
    File file=new File(url);
    if (!file.exists()) {
      Logger.log(""String_Node_Str"" + str);
      return;
    }
    InputStream is=null;
    is=new BufferedInputStream(new FileInputStream(file));
    param.setResult(is);
    Logger.log(""String_Node_Str"",true);
  }
}","The original code lacks file existence checking, potentially causing a FileNotFoundException if the specified file does not exist. The fixed code adds a file existence check using `file.exists()`, which prevents the method from attempting to open non-existent files and includes error logging. By gracefully handling missing files and logging the error, the fixed code provides more robust and predictable behavior, preventing unexpected runtime exceptions."
94131,"static void initStickers(final XC_LoadPackage.LoadPackageParam lpparam,final XModuleResources modRes,final Context snapContext){
  initEmojiNames();
  File myFile=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"");
  File[] files=myFile.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String filename){
      return filename.endsWith(""String_Node_Str"") && new File(dir,filename.substring(0,filename.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"").exists();
    }
  }
);
  for (  File f : files) {
    String s=f.getName().substring(0,f.getName().lastIndexOf(""String_Node_Str""));
    existing.add(s);
  }
  XposedHelpers.findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",MotionEvent.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      if (XposedHelpers.getAdditionalInstanceField(param.thisObject,""String_Node_Str"") == null)       XposedHelpers.setAdditionalInstanceField(param.thisObject,""String_Node_Str"",1.0F);
      float diff=((ImageView)param.thisObject).getScaleY() - (float)XposedHelpers.getAdditionalInstanceField(param.thisObject,""String_Node_Str"");
      if (diff > .5F && !isResizing) {
        XposedHelpers.setAdditionalInstanceField(param.thisObject,""String_Node_Str"",((ImageView)param.thisObject).getScaleY());
        Object aet=XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"");
        Object agm=XposedHelpers.getObjectField(aet,""String_Node_Str"");
        byte[] bArr=null;
        try {
          bArr=(byte[])XposedHelpers.callMethod(agm,""String_Node_Str"",XposedHelpers.callMethod(aet,""String_Node_Str"",XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"")) + ""String_Node_Str"");
        }
 catch (        NoSuchMethodError e) {
          Logger.log(""String_Node_Str"",true);
          return;
        }
        Object gz=newInstance(findClass(Obfuscator.stickers.SVG_CLASS,lpparam.classLoader));
        Object svg=XposedHelpers.callMethod(gz,""String_Node_Str"",new ByteArrayInputStream(bArr));
        Bitmap emoji=Bitmap.createBitmap((int)(((ImageView)param.thisObject).getHeight() * ((ImageView)param.thisObject).getScaleY()),(int)(((ImageView)param.thisObject).getHeight() * ((ImageView)param.thisObject).getScaleY()),Bitmap.Config.ARGB_8888);
        new ResizeTask(param.thisObject,svg,emoji).execute();
      }
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",String.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      Logger.log(""String_Node_Str"" + param.args[0],true);
      String str=(String)param.args[0];
      if (str.contains(""String_Node_Str"")) {
        String url=Environment.getExternalStorageDirectory() + ""String_Node_Str"" + str;
        Logger.log(""String_Node_Str"" + url,true);
        File file=new File(url);
        InputStream is=null;
        is=new BufferedInputStream(new FileInputStream(file));
        param.setResult(is);
        Logger.log(""String_Node_Str"",true);
      }
    }
  }
);
}","static void initStickers(final XC_LoadPackage.LoadPackageParam lpparam,final XModuleResources modRes,final Context snapContext){
  initEmojiNames();
  File myFile=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"");
  File[] files=myFile.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String filename){
      return filename.endsWith(""String_Node_Str"") && new File(dir,filename.substring(0,filename.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"").exists();
    }
  }
);
  for (  File f : files) {
    String s=f.getName().substring(0,f.getName().lastIndexOf(""String_Node_Str""));
    existing.add(s);
  }
  XposedHelpers.findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",MotionEvent.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      if (XposedHelpers.getAdditionalInstanceField(param.thisObject,""String_Node_Str"") == null)       XposedHelpers.setAdditionalInstanceField(param.thisObject,""String_Node_Str"",1.0F);
      float diff=((ImageView)param.thisObject).getScaleY() - (float)XposedHelpers.getAdditionalInstanceField(param.thisObject,""String_Node_Str"");
      if (diff > .5F && !isResizing) {
        XposedHelpers.setAdditionalInstanceField(param.thisObject,""String_Node_Str"",((ImageView)param.thisObject).getScaleY());
        Object aet=XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"");
        Object agm=XposedHelpers.getObjectField(aet,""String_Node_Str"");
        byte[] bArr=null;
        try {
          bArr=(byte[])XposedHelpers.callMethod(agm,""String_Node_Str"",XposedHelpers.callMethod(aet,""String_Node_Str"",XposedHelpers.getObjectField(param.thisObject,""String_Node_Str"")) + ""String_Node_Str"");
        }
 catch (        NoSuchMethodError e) {
          Logger.log(""String_Node_Str"",true);
          return;
        }
        Object gz=newInstance(findClass(Obfuscator.stickers.SVG_CLASS,lpparam.classLoader));
        Object svg=XposedHelpers.callMethod(gz,""String_Node_Str"",new ByteArrayInputStream(bArr));
        Bitmap emoji=Bitmap.createBitmap((int)(((ImageView)param.thisObject).getHeight() * ((ImageView)param.thisObject).getScaleY()),(int)(((ImageView)param.thisObject).getHeight() * ((ImageView)param.thisObject).getScaleY()),Bitmap.Config.ARGB_8888);
        new ResizeTask(param.thisObject,svg,emoji).execute();
      }
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",String.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      Logger.log(""String_Node_Str"" + param.args[0],true);
      String str=(String)param.args[0];
      if (str.contains(""String_Node_Str"")) {
        String url=Environment.getExternalStorageDirectory() + ""String_Node_Str"" + str;
        Logger.log(""String_Node_Str"" + url,true);
        File file=new File(url);
        if (!file.exists()) {
          Logger.log(""String_Node_Str"" + str);
          return;
        }
        InputStream is=null;
        is=new BufferedInputStream(new FileInputStream(file));
        param.setResult(is);
        Logger.log(""String_Node_Str"",true);
      }
    }
  }
);
}","The original code lacked a critical file existence check before attempting to access a file, which could cause potential runtime exceptions. In the fixed code, a file existence verification is added using `if (!file.exists())`, preventing null pointer or file not found errors and providing a graceful logging mechanism. This modification enhances error handling, ensures more robust file processing, and prevents potential application crashes when dealing with missing files."
94132,"private static void applyFilter(Bitmap source,Bitmap result,FilterType type){
  GPUImage gpuImage=new GPUImage(context);
  gpuImage.setImage(source);
  gpuImage.setFilter(type.getFilter());
  Bitmap filtered=gpuImage.getBitmapWithFilterApplied();
  int[] pixels=new int[filtered.getHeight() * filtered.getWidth()];
  filtered.getPixels(pixels,0,filtered.getWidth(),0,0,filtered.getWidth(),filtered.getHeight());
  result.setPixels(pixels,0,filtered.getWidth(),0,0,filtered.getWidth(),filtered.getHeight());
}","private static void applyFilter(Bitmap source,Bitmap result,FilterType type){
  GPUImage gpuImage=new GPUImage(context);
  gpuImage.setImage(source);
  gpuImage.setFilter(type.getFilter());
  try {
    Bitmap filtered=gpuImage.getBitmapWithFilterApplied();
    int[] pixels=new int[filtered.getHeight() * filtered.getWidth()];
    filtered.getPixels(pixels,0,filtered.getWidth(),0,0,filtered.getWidth(),filtered.getHeight());
    result.setPixels(pixels,0,filtered.getWidth(),0,0,filtered.getWidth(),filtered.getHeight());
  }
 catch (  NullPointerException e) {
    Logger.log(""String_Node_Str"" + type.toString());
    return;
  }
}","The original code lacks error handling for potential null bitmap returns from `getBitmapWithFilterApplied()`, which could cause unexpected crashes when filter application fails. The fixed code introduces a try-catch block to handle `NullPointerException`, logging the filter type and gracefully returning if the filtered bitmap is null. This approach prevents application crashes and provides basic error tracking, improving the method's robustness and reliability during image filtering operations."
94133,"@Override public View getView(final int position,View convertView,ViewGroup parent){
  final int[] colorsBg=new int[]{Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE};
  final int[] currentItemBg={2};
  final int[] colorsText=new int[]{Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE};
  final int[] currentItemText={2};
  Holder holder=new Holder();
  View rowView;
  rowView=inflater.inflate(mRes.getLayout(R.layout.optionlayout),null);
  holder.tv=(TextView)rowView.findViewById(mRes.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  holder.img=(ImageView)rowView.findViewById(mRes.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  holder.tv.setText(options[position]);
  holder.img.setImageDrawable(mRes.getDrawable(optionImageId[position]));
  rowView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
switch (position) {
case 0:
{
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,HookMethods.editText.getCurrentTextColor(),new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int color){
              HookMethods.editText.setTextColor(color);
            }
          }
);
          colorPickerDialog.setButton(-3,Common.dialog_default,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialogInterface,            int which){
              HookMethods.editText.setTextColor(Color.WHITE);
              HookMethods.editText.setAlpha(1);
            }
          }
);
          colorPickerDialog.setTitle(Common.dialog_txtcolour);
          colorPickerDialog.show();
          return;
        }
case 1:
{
        AlertDialog.Builder builder=new AlertDialog.Builder(context);
        SeekBar seekBar=new SeekBar(context);
        seekBar.setMax(150);
        seekBar.setProgress((int)HookMethods.editText.getTextSize());
        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
          public void onProgressChanged(          SeekBar seekBar,          int n,          boolean bl){
            HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_DIP,n);
          }
          @Override public void onStartTrackingTouch(          SeekBar arg0){
          }
          @Override public void onStopTrackingTouch(          SeekBar arg0){
          }
        }
);
        builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
          @Override public void onClick(          DialogInterface dialog,          int which){
            HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_PX,32.5125f);
          }
        }
);
        builder.setPositiveButton(Common.dialog_done,null);
        builder.setView((View)seekBar);
        builder.show();
        return;
      }
case 2:
{
      AlertDialog.Builder builder=new AlertDialog.Builder(context);
      SeekBar seekBar=new SeekBar(context);
      seekBar.setMax(100);
      seekBar.setProgress((int)HookMethods.editText.getAlpha() * 100);
      seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
        public void onProgressChanged(        SeekBar seekBar2,        int n,        boolean bl){
          float alpha=(float)n / 100;
          HookMethods.editText.setAlpha(alpha);
        }
        @Override public void onStartTrackingTouch(        SeekBar arg0){
        }
        @Override public void onStopTrackingTouch(        SeekBar arg0){
        }
      }
);
      builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          HookMethods.editText.setAlpha(1);
        }
      }
);
      builder.setPositiveButton(Common.dialog_done,null);
      builder.setView((View)seekBar);
      builder.show();
      return;
    }
case 3:
{
    AlertDialog.Builder builder=new AlertDialog.Builder(context);
    builder.setTitle(""String_Node_Str"");
    builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
      }
    }
);
    LinearLayout rootLayout=new LinearLayout(context);
    LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
    LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.gradient_layout),null),rootParams);
    final RadioGroup orientation=(RadioGroup)rootLayout.findViewById(R.id.orientation);
    final LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.itemLayout);
    final LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT);
    for (int i=1; i <= 5; i++) {
      Button btn=new Button(context);
      btn.setId(i);
      final int id_=btn.getId();
      btn.setText(""String_Node_Str"" + id_);
      btn.setBackgroundColor(colorsText[i - 1]);
      listLayout.addView(btn,params);
      final Button btn1=((Button)listLayout.findViewById(id_));
      btn1.setOnClickListener(new View.OnClickListener(){
        public void onClick(        View view){
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,colorsText[id_ - 1],new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int color){
              colorsText[id_ - 1]=color;
              btn1.setBackgroundColor(colorsText[id_ - 1]);
            }
          }
);
          colorPickerDialog.setTitle(""String_Node_Str"" + id_);
          colorPickerDialog.show();
        }
      }
);
      if (btn1.getId() <= currentItemText[0]) {
        btn1.setVisibility(View.VISIBLE);
      }
 else {
        btn1.setVisibility(View.GONE);
      }
    }
    Button add=(Button)rootLayout.findViewById(R.id.add);
    add.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (currentItemText[0] < 5) {
          currentItemText[0]++;
          listLayout.findViewById(currentItemText[0]).setVisibility(View.VISIBLE);
        }
 else {
          Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
    }
);
    Button remove=(Button)rootLayout.findViewById(R.id.remove);
    remove.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (currentItemText[0] > 2) {
          listLayout.findViewById(currentItemText[0]).setVisibility(View.GONE);
          currentItemText[0]--;
        }
 else {
          Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
    }
);
    builder.setView(rootLayout);
    builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        final int[] usedColors=new int[currentItemText[0]];
        System.arraycopy(colorsText,0,usedColors,0,currentItemText[0]);
        Shader textShader=null;
        int checkedID=orientation.getCheckedRadioButtonId();
        if (checkedID == R.id.horizontal) {
          double angleInRadians=Math.toRadians(90);
          double length=100;
          double endX=Math.cos(angleInRadians) * length;
          double endY=Math.sin(angleInRadians) * HookMethods.editText.getHeight();
          WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
          Display display=wm.getDefaultDisplay();
          Point size=new Point();
          display.getSize(size);
          int width=size.x;
          textShader=new LinearGradient(0,0,width,0,usedColors,null,Shader.TileMode.CLAMP);
        }
 else         if (checkedID == R.id.vertical) {
          textShader=new LinearGradient(0,0,0,HookMethods.editText.getHeight(),usedColors,null,Shader.TileMode.CLAMP);
        }
        HookMethods.editText.getPaint().setShader(textShader);
        HookMethods.editText.setText(HookMethods.editText.getText());
      }
    }
);
    builder.show();
    return;
  }
case 4:
{
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  Button button_left=new Button(context);
  Button button_center=new Button(context);
  Button button_right=new Button(context);
  LinearLayout linearLayout=new LinearLayout(context);
  linearLayout.setOrientation(LinearLayout.VERTICAL);
  button_left.setText(Common.dialog_left);
  button_left.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.LEFT);
    }
  }
);
  button_center.setText(Common.dialog_center);
  button_center.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.CENTER);
    }
  }
);
  button_right.setText(Common.dialog_right);
  button_right.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.RIGHT);
    }
  }
);
  linearLayout.addView((View)button_left);
  linearLayout.addView((View)button_center);
  linearLayout.addView((View)button_right);
  builder.setView((View)linearLayout);
  builder.setPositiveButton(Common.dialog_done,null);
  builder.show();
  return;
}
case 5:
{
AlertDialog.Builder builder=new AlertDialog.Builder(context);
Button button_bold=new Button(context);
Button button_italic=new Button(context);
Button button_bolditalic=new Button(context);
Button button_normal=new Button(context);
LinearLayout linearLayout=new LinearLayout(context);
linearLayout.setOrientation(LinearLayout.VERTICAL);
button_bold.setText(Common.dialog_bold);
button_bold.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.BOLD);
  }
}
);
button_italic.setText(Common.dialog_italic);
button_italic.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.ITALIC);
  }
}
);
button_bolditalic.setText(Common.dialog_bolditalic);
button_bolditalic.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.BOLD_ITALIC);
  }
}
);
button_normal.setText(Common.dialog_normal);
button_normal.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.NORMAL);
  }
}
);
linearLayout.addView((View)button_bold);
linearLayout.addView((View)button_italic);
linearLayout.addView((View)button_bolditalic);
linearLayout.addView((View)button_normal);
builder.setView((View)linearLayout);
builder.setPositiveButton(Common.dialog_done,null);
builder.show();
return;
}
case 6:
{
File folder=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"");
if (folder.exists()) {
FilenameFilter filter=new FilenameFilter(){
  @Override public boolean accept(  File dir,  String filename){
    if (filename.lastIndexOf('.') > 0) {
      int lastIndex=filename.lastIndexOf('.');
      String extension=filename.substring(lastIndex);
      if (extension.equalsIgnoreCase(""String_Node_Str"") || extension.equalsIgnoreCase(""String_Node_Str"")) {
        return true;
      }
    }
    return false;
  }
}
;
File[] fonts=folder.listFiles(filter);
if (fonts.length > 0) {
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  builder.setTitle(""String_Node_Str"");
  builder.setNeutralButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      HookMethods.editText.setTypeface(HookMethods.defTypeface);
    }
  }
);
  builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialogInterface,    int i){
    }
  }
);
  LinearLayout rootLayout=new LinearLayout(context);
  LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.font_list),null),rootParams);
  LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.fontLayout);
  for (  final File font : fonts) {
    String fontname=font.getName().substring(0,font.getName().toLowerCase().lastIndexOf(""String_Node_Str""));
    TextView item=new TextView(context);
    item.setLayoutParams(new TableLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
    item.setPadding(0,0,0,2);
    item.setText(fontname);
    item.setTextSize(TypedValue.COMPLEX_UNIT_DIP,22.0f);
    item.setGravity(Gravity.CENTER_HORIZONTAL);
    item.setTypeface(TypefaceUtil.get(font));
    item.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        HookMethods.editText.setTypeface(TypefaceUtil.get(font));
      }
    }
);
    listLayout.addView(item);
  }
  builder.setView(rootLayout);
  builder.show();
}
 else {
  NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGHT_SHORT,HookMethods.classLoader);
}
}
 else {
NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGHT_SHORT,HookMethods.classLoader);
}
return;
}
case 7:
{
ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,HookMethods.editText.getSolidColor(),new ColorPickerDialog.OnColorSelectedListener(){
@Override public void onColorSelected(int color){
HookMethods.editText.setBackgroundColor(color);
}
}
);
colorPickerDialog.setButton(-3,Common.dialog_default,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int which){
HookMethods.editText.setBackgroundColor((Color.parseColor(""String_Node_Str"")));
HookMethods.editText.setAlpha(1);
}
}
);
colorPickerDialog.setTitle(Common.dialog_bgcolour);
colorPickerDialog.show();
return;
}
case 8:
{
AlertDialog.Builder builder=new AlertDialog.Builder(HookMethods.SnapContext);
SeekBar seekBar=new SeekBar(HookMethods.SnapContext);
seekBar.setMax(255);
seekBar.setProgress((int)HookMethods.editText.getBackground().getAlpha());
seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
public void onProgressChanged(SeekBar seekBar3,int n,boolean bl){
HookMethods.editText.getBackground().setAlpha(n);
}
@Override public void onStartTrackingTouch(SeekBar arg0){
}
@Override public void onStopTrackingTouch(SeekBar arg0){
}
}
);
builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
HookMethods.editText.getBackground().setAlpha(153);
}
}
);
builder.setPositiveButton(Common.dialog_done,null);
builder.setView((View)seekBar);
builder.show();
return;
}
case 9:
{
AlertDialog.Builder builder=new AlertDialog.Builder(context);
builder.setTitle(""String_Node_Str"");
builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
}
}
);
final LinearLayout rootLayout=new LinearLayout(context);
LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.gradient_layout),null),rootParams);
final RadioGroup orientation=(RadioGroup)rootLayout.findViewById(R.id.orientation);
final LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.itemLayout);
final LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT);
for (int i=1; i <= 5; i++) {
Button btn=new Button(context);
btn.setId(i);
final int id_=btn.getId();
btn.setText(""String_Node_Str"" + id_);
btn.setBackgroundColor(colorsBg[i - 1]);
listLayout.addView(btn,params);
final Button btn1=((Button)listLayout.findViewById(id_));
btn1.setOnClickListener(new View.OnClickListener(){
public void onClick(View view){
ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,colorsBg[id_ - 1],new ColorPickerDialog.OnColorSelectedListener(){
@Override public void onColorSelected(int color){
  colorsBg[id_ - 1]=color;
  btn1.setBackgroundColor(colorsBg[id_ - 1]);
}
}
);
colorPickerDialog.setTitle(""String_Node_Str"" + id_);
colorPickerDialog.show();
}
}
);
if (btn1.getId() <= currentItemBg[0]) {
btn1.setVisibility(View.VISIBLE);
}
 else {
btn1.setVisibility(View.GONE);
}
}
Button add=(Button)rootLayout.findViewById(R.id.add);
add.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View view){
if (currentItemBg[0] < 5) {
currentItemBg[0]++;
listLayout.findViewById(currentItemBg[0]).setVisibility(View.VISIBLE);
}
 else {
Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
}
}
);
Button remove=(Button)rootLayout.findViewById(R.id.remove);
remove.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View view){
if (currentItemBg[0] > 2) {
listLayout.findViewById(currentItemBg[0]).setVisibility(View.GONE);
currentItemBg[0]--;
}
 else {
Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
}
}
);
builder.setView(rootLayout);
builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
final int[] usedColors=new int[currentItemBg[0]];
System.arraycopy(colorsBg,0,usedColors,0,currentItemBg[0]);
PaintDrawable p=new PaintDrawable();
p.setShape(new RectShape());
ShapeDrawable.ShaderFactory sf=new ShapeDrawable.ShaderFactory(){
@Override public Shader resize(int width,int height){
LinearGradient returnGradient=null;
int checkedID=orientation.getCheckedRadioButtonId();
if (checkedID == R.id.horizontal) {
  returnGradient=new LinearGradient(0,0,width,height,usedColors,null,Shader.TileMode.MIRROR);
}
 else if (checkedID == R.id.vertical) {
  double angleInRadians=Math.toRadians(90);
  double length=100;
  double endX=Math.cos(angleInRadians) * length;
  double endY=Math.sin(angleInRadians) * HookMethods.editText.getHeight();
  returnGradient=new LinearGradient(0,0,(float)endX,(float)endY,usedColors,null,Shader.TileMode.MIRROR);
}
return returnGradient;
}
}
;
p.setShaderFactory(sf);
HookMethods.editText.setBackgroundDrawable(p);
}
}
);
builder.show();
return;
}
case 10:
{
HookMethods.editText.setBackgroundDrawable(null);
HookMethods.editText.getPaint().reset();
HookMethods.editText.setTextColor(Color.WHITE);
HookMethods.editText.setBackgroundColor((Color.parseColor(""String_Node_Str"")));
HookMethods.editText.setGravity(Gravity.CENTER);
HookMethods.editText.setAlpha(1);
HookMethods.editText.getBackground().setAlpha(153);
HookMethods.editText.setTypeface(HookMethods.defTypeface);
HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_PX,32.5125f);
return;
}
default :
return;
}
}
}
);
return rowView;
}","@Override public View getView(final int position,View convertView,ViewGroup parent){
  final int[] colorsBg=new int[]{Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE};
  final int[] currentItemBg={2};
  final int[] colorsText=new int[]{Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE,Color.WHITE};
  final int[] currentItemText={2};
  Holder holder=new Holder();
  View rowView;
  rowView=inflater.inflate(mRes.getLayout(R.layout.optionlayout),null);
  holder.tv=(TextView)rowView.findViewById(mRes.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  holder.img=(ImageView)rowView.findViewById(mRes.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  holder.tv.setText(options[position]);
  holder.img.setImageDrawable(mRes.getDrawable(optionImageId[position]));
  rowView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
switch (position) {
case 0:
{
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,HookMethods.editText.getCurrentTextColor(),new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int color){
              HookMethods.editText.setTextColor(color);
            }
          }
);
          colorPickerDialog.setButton(-3,Common.dialog_default,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialogInterface,            int which){
              HookMethods.editText.setTextColor(Color.WHITE);
              HookMethods.editText.setAlpha(1);
            }
          }
);
          colorPickerDialog.setTitle(Common.dialog_txtcolour);
          colorPickerDialog.show();
          return;
        }
case 1:
{
        AlertDialog.Builder builder=new AlertDialog.Builder(context);
        SeekBar seekBar=new SeekBar(context);
        seekBar.setMax(150);
        seekBar.setProgress((int)HookMethods.editText.getTextSize());
        seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
          public void onProgressChanged(          SeekBar seekBar,          int n,          boolean bl){
            HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_DIP,n);
          }
          @Override public void onStartTrackingTouch(          SeekBar arg0){
          }
          @Override public void onStopTrackingTouch(          SeekBar arg0){
          }
        }
);
        builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
          @Override public void onClick(          DialogInterface dialog,          int which){
            HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_PX,32.5125f);
          }
        }
);
        builder.setPositiveButton(Common.dialog_done,null);
        builder.setView((View)seekBar);
        builder.show();
        return;
      }
case 2:
{
      AlertDialog.Builder builder=new AlertDialog.Builder(context);
      SeekBar seekBar=new SeekBar(context);
      seekBar.setMax(100);
      seekBar.setProgress((int)HookMethods.editText.getAlpha() * 100);
      seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
        public void onProgressChanged(        SeekBar seekBar2,        int n,        boolean bl){
          float alpha=(float)n / 100;
          HookMethods.editText.setAlpha(alpha);
        }
        @Override public void onStartTrackingTouch(        SeekBar arg0){
        }
        @Override public void onStopTrackingTouch(        SeekBar arg0){
        }
      }
);
      builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          HookMethods.editText.setAlpha(1);
        }
      }
);
      builder.setPositiveButton(Common.dialog_done,null);
      builder.setView((View)seekBar);
      builder.show();
      return;
    }
case 3:
{
    AlertDialog.Builder builder=new AlertDialog.Builder(context);
    builder.setTitle(""String_Node_Str"");
    builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
      }
    }
);
    LinearLayout rootLayout=new LinearLayout(context);
    LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
    LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.gradient_layout),null),rootParams);
    final RadioGroup orientation=(RadioGroup)rootLayout.findViewById(R.id.orientation);
    final LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.itemLayout);
    final LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT);
    for (int i=1; i <= 5; i++) {
      Button btn=new Button(context);
      btn.setId(i);
      final int id_=btn.getId();
      btn.setText(""String_Node_Str"" + id_);
      btn.setBackgroundColor(colorsText[i - 1]);
      listLayout.addView(btn,params);
      final Button btn1=((Button)listLayout.findViewById(id_));
      btn1.setOnClickListener(new View.OnClickListener(){
        public void onClick(        View view){
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,colorsText[id_ - 1],new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int color){
              colorsText[id_ - 1]=color;
              btn1.setBackgroundColor(colorsText[id_ - 1]);
            }
          }
);
          colorPickerDialog.setTitle(""String_Node_Str"" + id_);
          colorPickerDialog.show();
        }
      }
);
      if (btn1.getId() <= currentItemText[0]) {
        btn1.setVisibility(View.VISIBLE);
      }
 else {
        btn1.setVisibility(View.GONE);
      }
    }
    Button add=(Button)rootLayout.findViewById(R.id.add);
    add.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (currentItemText[0] < 5) {
          currentItemText[0]++;
          listLayout.findViewById(currentItemText[0]).setVisibility(View.VISIBLE);
        }
 else {
          Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
    }
);
    Button remove=(Button)rootLayout.findViewById(R.id.remove);
    remove.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (currentItemText[0] > 2) {
          listLayout.findViewById(currentItemText[0]).setVisibility(View.GONE);
          currentItemText[0]--;
        }
 else {
          Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
    }
);
    builder.setView(rootLayout);
    builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        final int[] usedColors=new int[currentItemText[0]];
        System.arraycopy(colorsText,0,usedColors,0,currentItemText[0]);
        Shader textShader=null;
        int checkedID=orientation.getCheckedRadioButtonId();
        if (checkedID == R.id.horizontal) {
          double angleInRadians=Math.toRadians(90);
          double length=100;
          double endX=Math.cos(angleInRadians) * length;
          double endY=Math.sin(angleInRadians) * HookMethods.editText.getHeight();
          WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
          Display display=wm.getDefaultDisplay();
          Point size=new Point();
          display.getSize(size);
          int width=size.x;
          textShader=new LinearGradient(0,0,width,0,usedColors,null,Shader.TileMode.CLAMP);
        }
 else         if (checkedID == R.id.vertical) {
          textShader=new LinearGradient(0,0,0,HookMethods.editText.getHeight(),usedColors,null,Shader.TileMode.CLAMP);
        }
        HookMethods.editText.getPaint().setShader(textShader);
        HookMethods.editText.setText(HookMethods.editText.getText());
      }
    }
);
    builder.show();
    return;
  }
case 4:
{
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  Button button_left=new Button(context);
  Button button_center=new Button(context);
  Button button_right=new Button(context);
  LinearLayout linearLayout=new LinearLayout(context);
  linearLayout.setOrientation(LinearLayout.VERTICAL);
  button_left.setText(Common.dialog_left);
  button_left.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.LEFT);
    }
  }
);
  button_center.setText(Common.dialog_center);
  button_center.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.CENTER);
    }
  }
);
  button_right.setText(Common.dialog_right);
  button_right.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View view){
      HookMethods.editText.setGravity(Gravity.RIGHT);
    }
  }
);
  linearLayout.addView((View)button_left);
  linearLayout.addView((View)button_center);
  linearLayout.addView((View)button_right);
  builder.setView((View)linearLayout);
  builder.setPositiveButton(Common.dialog_done,null);
  builder.show();
  return;
}
case 5:
{
AlertDialog.Builder builder=new AlertDialog.Builder(context);
Button button_bold=new Button(context);
Button button_italic=new Button(context);
Button button_bolditalic=new Button(context);
Button button_normal=new Button(context);
LinearLayout linearLayout=new LinearLayout(context);
linearLayout.setOrientation(LinearLayout.VERTICAL);
button_bold.setText(Common.dialog_bold);
button_bold.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.BOLD);
  }
}
);
button_italic.setText(Common.dialog_italic);
button_italic.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.ITALIC);
  }
}
);
button_bolditalic.setText(Common.dialog_bolditalic);
button_bolditalic.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.BOLD_ITALIC);
  }
}
);
button_normal.setText(Common.dialog_normal);
button_normal.setOnClickListener(new View.OnClickListener(){
  public void onClick(  View view){
    HookMethods.editText.setTypeface(null,Typeface.NORMAL);
  }
}
);
linearLayout.addView((View)button_bold);
linearLayout.addView((View)button_italic);
linearLayout.addView((View)button_bolditalic);
linearLayout.addView((View)button_normal);
builder.setView((View)linearLayout);
builder.setPositiveButton(Common.dialog_done,null);
builder.show();
return;
}
case 6:
{
File folder=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"");
if (folder.exists()) {
FilenameFilter filter=new FilenameFilter(){
  @Override public boolean accept(  File dir,  String filename){
    if (filename.lastIndexOf('.') > 0) {
      int lastIndex=filename.lastIndexOf('.');
      String extension=filename.substring(lastIndex);
      if (extension.equalsIgnoreCase(""String_Node_Str"") || extension.equalsIgnoreCase(""String_Node_Str"")) {
        return true;
      }
    }
    return false;
  }
}
;
File[] fonts=folder.listFiles(filter);
if (fonts.length > 0) {
  AlertDialog.Builder builder=new AlertDialog.Builder(context);
  builder.setTitle(""String_Node_Str"");
  builder.setNeutralButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      HookMethods.editText.setTypeface(HookMethods.defTypeface);
    }
  }
);
  builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialogInterface,    int i){
    }
  }
);
  LinearLayout rootLayout=new LinearLayout(context);
  LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.font_list),null),rootParams);
  LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.fontLayout);
  for (  final File font : fonts) {
    String fontname=font.getName().substring(0,font.getName().toLowerCase().lastIndexOf(""String_Node_Str""));
    TextView item=new TextView(context);
    item.setLayoutParams(new TableLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT));
    item.setPadding(0,0,0,2);
    item.setText(fontname);
    item.setTextSize(TypedValue.COMPLEX_UNIT_DIP,22.0f);
    item.setGravity(Gravity.CENTER_HORIZONTAL);
    item.setTypeface(TypefaceUtil.get(font));
    item.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        HookMethods.editText.setTypeface(TypefaceUtil.get(font));
      }
    }
);
    listLayout.addView(item);
  }
  builder.setView(rootLayout);
  builder.show();
}
 else {
  NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGHT_SHORT,HookMethods.classLoader);
}
}
 else {
NotificationUtils.showMessage(""String_Node_Str"",Color.RED,NotificationUtils.LENGHT_SHORT,HookMethods.classLoader);
}
return;
}
case 7:
{
ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,HookMethods.editText.getSolidColor(),new ColorPickerDialog.OnColorSelectedListener(){
@Override public void onColorSelected(int color){
HookMethods.editText.setBackgroundColor(color);
}
}
);
colorPickerDialog.setButton(-3,Common.dialog_default,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int which){
HookMethods.editText.setBackgroundColor((Color.parseColor(""String_Node_Str"")));
HookMethods.editText.setAlpha(1);
}
}
);
colorPickerDialog.setTitle(Common.dialog_bgcolour);
colorPickerDialog.show();
return;
}
case 8:
{
AlertDialog.Builder builder=new AlertDialog.Builder(HookMethods.SnapContext);
SeekBar seekBar=new SeekBar(HookMethods.SnapContext);
seekBar.setMax(255);
int currentapiVersion=android.os.Build.VERSION.SDK_INT;
if (currentapiVersion >= Build.VERSION_CODES.KITKAT) {
seekBar.setProgress((int)HookMethods.editText.getBackground().getAlpha());
}
 else {
seekBar.setProgress(255);
}
seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
public void onProgressChanged(SeekBar seekBar3,int n,boolean bl){
HookMethods.editText.getBackground().setAlpha(n);
}
@Override public void onStartTrackingTouch(SeekBar arg0){
}
@Override public void onStopTrackingTouch(SeekBar arg0){
}
}
);
builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
HookMethods.editText.getBackground().setAlpha(153);
}
}
);
builder.setPositiveButton(Common.dialog_done,null);
builder.setView((View)seekBar);
builder.show();
return;
}
case 9:
{
AlertDialog.Builder builder=new AlertDialog.Builder(context);
builder.setTitle(""String_Node_Str"");
builder.setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
}
}
);
final LinearLayout rootLayout=new LinearLayout(context);
LinearLayout.LayoutParams rootParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
rootLayout.addView(inflater.inflate(HookMethods.modRes.getLayout(R.layout.gradient_layout),null),rootParams);
final RadioGroup orientation=(RadioGroup)rootLayout.findViewById(R.id.orientation);
final LinearLayout listLayout=(LinearLayout)rootLayout.findViewById(R.id.itemLayout);
final LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT);
for (int i=1; i <= 5; i++) {
Button btn=new Button(context);
btn.setId(i);
final int id_=btn.getId();
btn.setText(""String_Node_Str"" + id_);
btn.setBackgroundColor(colorsBg[i - 1]);
listLayout.addView(btn,params);
final Button btn1=((Button)listLayout.findViewById(id_));
btn1.setOnClickListener(new View.OnClickListener(){
public void onClick(View view){
ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,colorsBg[id_ - 1],new ColorPickerDialog.OnColorSelectedListener(){
@Override public void onColorSelected(int color){
  colorsBg[id_ - 1]=color;
  btn1.setBackgroundColor(colorsBg[id_ - 1]);
}
}
);
colorPickerDialog.setTitle(""String_Node_Str"" + id_);
colorPickerDialog.show();
}
}
);
if (btn1.getId() <= currentItemBg[0]) {
btn1.setVisibility(View.VISIBLE);
}
 else {
btn1.setVisibility(View.GONE);
}
}
Button add=(Button)rootLayout.findViewById(R.id.add);
add.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View view){
if (currentItemBg[0] < 5) {
currentItemBg[0]++;
listLayout.findViewById(currentItemBg[0]).setVisibility(View.VISIBLE);
}
 else {
Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
}
}
);
Button remove=(Button)rootLayout.findViewById(R.id.remove);
remove.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View view){
if (currentItemBg[0] > 2) {
listLayout.findViewById(currentItemBg[0]).setVisibility(View.GONE);
currentItemBg[0]--;
}
 else {
Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
}
}
);
builder.setView(rootLayout);
builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
final int[] usedColors=new int[currentItemBg[0]];
System.arraycopy(colorsBg,0,usedColors,0,currentItemBg[0]);
PaintDrawable p=new PaintDrawable();
p.setShape(new RectShape());
ShapeDrawable.ShaderFactory sf=new ShapeDrawable.ShaderFactory(){
@Override public Shader resize(int width,int height){
LinearGradient returnGradient=null;
int checkedID=orientation.getCheckedRadioButtonId();
if (checkedID == R.id.horizontal) {
  returnGradient=new LinearGradient(0,0,width,height,usedColors,null,Shader.TileMode.MIRROR);
}
 else if (checkedID == R.id.vertical) {
  double angleInRadians=Math.toRadians(90);
  double length=100;
  double endX=Math.cos(angleInRadians) * length;
  double endY=Math.sin(angleInRadians) * HookMethods.editText.getHeight();
  returnGradient=new LinearGradient(0,0,(float)endX,(float)endY,usedColors,null,Shader.TileMode.MIRROR);
}
return returnGradient;
}
}
;
p.setShaderFactory(sf);
HookMethods.editText.setBackgroundDrawable(p);
}
}
);
builder.show();
return;
}
case 10:
{
HookMethods.editText.setBackgroundDrawable(null);
HookMethods.editText.getPaint().reset();
HookMethods.editText.setTextColor(Color.WHITE);
HookMethods.editText.setBackgroundColor((Color.parseColor(""String_Node_Str"")));
HookMethods.editText.setGravity(Gravity.CENTER);
HookMethods.editText.setAlpha(1);
HookMethods.editText.getBackground().setAlpha(153);
HookMethods.editText.setTypeface(HookMethods.defTypeface);
HookMethods.editText.setTextSize(TypedValue.COMPLEX_UNIT_PX,32.5125f);
return;
}
default :
return;
}
}
}
);
return rowView;
}","The original code lacked proper version compatibility handling for background alpha settings, which could cause crashes on older Android versions. In the fixed code, a version check is added using `android.os.Build.VERSION.SDK_INT` to safely retrieve and set background alpha, defaulting to full opacity for pre-Kitkat devices. This modification ensures robust functionality across different Android API levels, preventing potential runtime exceptions and improving the app's compatibility and stability."
94134,"protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ColorDrawable colorDrawable=new ColorDrawable(Color.parseColor(""String_Node_Str""));
  final TelephonyManager tm=(TelephonyManager)getBaseContext().getSystemService(Context.TELEPHONY_SERVICE);
  final String tmDevice, tmSerial, androidId;
  tmDevice=""String_Node_Str"" + tm.getDeviceId();
  tmSerial=""String_Node_Str"" + tm.getSimSerialNumber();
  androidId=""String_Node_Str"" + android.provider.Settings.Secure.getString(getContentResolver(),android.provider.Settings.Secure.ANDROID_ID);
  UUID deviceUuid=new UUID(androidId.hashCode(),((long)tmDevice.hashCode() << 32) | tmSerial.hashCode());
  String deviceId=deviceUuid.toString();
  final String confirmationID=readStringPreference(""String_Node_Str"");
  final Context context=this;
  ChangeLog cl=new ChangeLog(context);
  if (cl.isFirstRun()) {
    cl.getLogDialog().show();
  }
  setContentView(R.layout.activity_main);
  getSupportActionBar().setDisplayShowCustomEnabled(true);
  getSupportActionBar().setCustomView(R.layout.abs);
  getSupportActionBar().setBackgroundDrawable(colorDrawable);
  Button settings=(Button)findViewById(R.id.settings);
  Button filterStore=(Button)findViewById(R.id.filterStore);
  Button reedem=(Button)findViewById(R.id.reedem);
  Button donate=(Button)findViewById(R.id.donate);
  Button about=(Button)findViewById(R.id.about);
  Button legal=(Button)findViewById(R.id.legal);
  Button visual=(Button)findViewById(R.id.visualbtn);
  TextView SC_text=(TextView)findViewById(R.id.SC_text);
  SC_text.setPaintFlags(SC_text.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);
  settings.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      getFragmentManager().beginTransaction().replace(R.id.frame_layout,new Settings()).commit();
      PreferenceManager.setDefaultValues(getApplicationContext(),R.xml.preferences,false);
    }
  }
);
  filterStore.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      Intent intent=new Intent(getApplicationContext(),TabsFragmentActivity.class);
      startActivity(intent);
    }
  }
);
  visual.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      Intent intent=new Intent(getApplicationContext(),VisualActivity.class);
      startActivity(intent);
    }
  }
);
  reedem.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      Intent intent=new Intent(getApplicationContext(),Reedem.class);
      startActivity(intent);
    }
  }
);
  about.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      new AlertDialog.Builder(context).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"" + getResources().getString(R.string.pref_thanks_summary) + ""String_Node_Str""+ BuildConfig.VERSION_NAME+ ""String_Node_Str""+ Obfuscator.SUPPORTED_VERSION_CODENAME).setPositiveButton(android.R.string.yes,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          return;
        }
      }
).setIcon(android.R.drawable.ic_dialog_alert).show();
    }
  }
);
  legal.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      new AlertDialog.Builder(context).setTitle(""String_Node_Str"").setMessage(Html.fromHtml(""String_Node_Str"")).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          return;
        }
      }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          try {
            Intent myIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
            startActivity(myIntent);
          }
 catch (          ActivityNotFoundException e) {
            Toast.makeText(getApplicationContext(),""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
            e.printStackTrace();
          }
        }
      }
).setNeutralButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          try {
            Intent myIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
            startActivity(myIntent);
          }
 catch (          ActivityNotFoundException e) {
            Toast.makeText(getApplicationContext(),""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
            e.printStackTrace();
          }
        }
      }
).setIcon(android.R.drawable.ic_dialog_alert).show();
    }
  }
);
  donate.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      new AlertDialog.Builder(context).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          try {
            Intent myIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
            startActivity(myIntent);
          }
 catch (          ActivityNotFoundException e) {
            Toast.makeText(getApplicationContext(),""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
            e.printStackTrace();
          }
        }
      }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          return;
        }
      }
).setIcon(android.R.drawable.ic_dialog_alert).show();
    }
  }
);
  AdView mAdView=(AdView)findViewById(R.id.adView);
  if (readLicense(deviceId,confirmationID) == 1 || readLicense(deviceId,confirmationID) == 2) {
    mAdView.destroy();
    mAdView.setVisibility(View.GONE);
  }
 else {
    AdRequest adRequest=new AdRequest.Builder().addTestDevice(""String_Node_Str"").build();
    mAdView.loadAd(adRequest);
    mAdView.setVisibility(View.VISIBLE);
  }
}","protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ColorDrawable colorDrawable=new ColorDrawable(Color.parseColor(""String_Node_Str""));
  final TelephonyManager tm=(TelephonyManager)getBaseContext().getSystemService(Context.TELEPHONY_SERVICE);
  final String tmDevice, tmSerial, androidId;
  tmDevice=""String_Node_Str"" + tm.getDeviceId();
  tmSerial=""String_Node_Str"" + tm.getSimSerialNumber();
  androidId=""String_Node_Str"" + android.provider.Settings.Secure.getString(getContentResolver(),android.provider.Settings.Secure.ANDROID_ID);
  UUID deviceUuid=new UUID(androidId.hashCode(),((long)tmDevice.hashCode() << 32) | tmSerial.hashCode());
  String deviceId=deviceUuid.toString();
  final String confirmationID=readStringPreference(""String_Node_Str"");
  final Context context=this;
  ChangeLog cl=new ChangeLog(context);
  if (cl.isFirstRun()) {
    cl.getLogDialog().show();
  }
  setContentView(R.layout.activity_main);
  getActionBar().setDisplayShowCustomEnabled(true);
  getActionBar().setCustomView(R.layout.abs);
  getActionBar().setBackgroundDrawable(colorDrawable);
  Button settings=(Button)findViewById(R.id.settings);
  Button filterStore=(Button)findViewById(R.id.filterStore);
  Button reedem=(Button)findViewById(R.id.reedem);
  Button donate=(Button)findViewById(R.id.donate);
  Button about=(Button)findViewById(R.id.about);
  Button legal=(Button)findViewById(R.id.legal);
  Button visual=(Button)findViewById(R.id.visualbtn);
  TextView SC_text=(TextView)findViewById(R.id.SC_text);
  SC_text.setPaintFlags(SC_text.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);
  settings.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      getFragmentManager().beginTransaction().replace(R.id.frame_layout,new Settings()).addToBackStack(""String_Node_Str"").commit();
      PreferenceManager.setDefaultValues(getApplicationContext(),R.xml.preferences,false);
    }
  }
);
  filterStore.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      Intent intent=new Intent(getApplicationContext(),TabsFragmentActivity.class);
      startActivity(intent);
    }
  }
);
  visual.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      Intent intent=new Intent(getApplicationContext(),VisualActivity.class);
      startActivity(intent);
    }
  }
);
  reedem.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      Intent intent=new Intent(getApplicationContext(),Reedem.class);
      startActivity(intent);
    }
  }
);
  about.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      new AlertDialog.Builder(context).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"" + getResources().getString(R.string.pref_thanks_summary) + ""String_Node_Str""+ BuildConfig.VERSION_NAME+ ""String_Node_Str""+ Obfuscator.SUPPORTED_VERSION_CODENAME).setPositiveButton(android.R.string.yes,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          return;
        }
      }
).setIcon(android.R.drawable.ic_dialog_alert).show();
    }
  }
);
  legal.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      new AlertDialog.Builder(context).setTitle(""String_Node_Str"").setMessage(Html.fromHtml(""String_Node_Str"")).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          return;
        }
      }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          try {
            Intent myIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
            startActivity(myIntent);
          }
 catch (          ActivityNotFoundException e) {
            Toast.makeText(getApplicationContext(),""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
            e.printStackTrace();
          }
        }
      }
).setNeutralButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          try {
            Intent myIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
            startActivity(myIntent);
          }
 catch (          ActivityNotFoundException e) {
            Toast.makeText(getApplicationContext(),""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
            e.printStackTrace();
          }
        }
      }
).setIcon(android.R.drawable.ic_dialog_alert).show();
    }
  }
);
  donate.setOnClickListener(new Button.OnClickListener(){
    public void onClick(    View v){
      new AlertDialog.Builder(context).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          try {
            Intent myIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str""));
            startActivity(myIntent);
          }
 catch (          ActivityNotFoundException e) {
            Toast.makeText(getApplicationContext(),""String_Node_Str"" + ""String_Node_Str"",Toast.LENGTH_LONG).show();
            e.printStackTrace();
          }
        }
      }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          return;
        }
      }
).setIcon(android.R.drawable.ic_dialog_alert).show();
    }
  }
);
  AdView mAdView=(AdView)findViewById(R.id.adView);
  if (readLicense(deviceId,confirmationID) == 1 || readLicense(deviceId,confirmationID) == 2) {
    mAdView.destroy();
    mAdView.setVisibility(View.GONE);
  }
 else {
    AdRequest adRequest=new AdRequest.Builder().addTestDevice(""String_Node_Str"").build();
    mAdView.loadAd(adRequest);
    mAdView.setVisibility(View.VISIBLE);
  }
}","The original code used `getSupportActionBar()`, which is specific to the AppCompatActivity, but the context suggests a standard Activity implementation. The fixed code replaces `getSupportActionBar()` with `getActionBar()` to match the base Activity class and added `.addToBackStack(""String_Node_Str"")` to the fragment transaction for proper back navigation. These changes ensure compatibility with the standard Android action bar and improve fragment management by allowing users to return to the previous screen."
94135,"public static String readFromSDFile(String filename){
  String aBuffer=""String_Node_Str"";
  try {
    File myFile=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"" + filename+ ""String_Node_Str"");
    FileInputStream fIn=new FileInputStream(myFile);
    BufferedReader myReader=new BufferedReader(new InputStreamReader(fIn));
    String aDataRow=""String_Node_Str"";
    while ((aDataRow=myReader.readLine()) != null) {
      aBuffer+=aDataRow + ""String_Node_Str"";
    }
    myReader.close();
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"" + e.toString());
  }
  return aBuffer;
}","public static String readFromSDFile(String filename){
  String aBuffer=""String_Node_Str"";
  try {
    File myFile=new File(Environment.getExternalStorageDirectory() + ""String_Node_Str"" + filename+ ""String_Node_Str"");
    FileInputStream fIn=new FileInputStream(myFile);
    BufferedReader myReader=new BufferedReader(new InputStreamReader(fIn));
    String aDataRow=""String_Node_Str"";
    while ((aDataRow=myReader.readLine()) != null) {
      aBuffer+=aDataRow + ""String_Node_Str"";
    }
    myReader.close();
  }
 catch (  Exception e) {
    Logger.log(""String_Node_Str"" + e.toString(),true);
  }
  return aBuffer;
}","The original code lacks proper error logging, potentially silencing critical exceptions during file reading operations. The fixed code adds a second parameter (true) to the Logger.log method, which likely enables more comprehensive error tracking and ensures exceptions are fully captured. This modification improves error handling and debugging capabilities, making the file reading process more robust and transparent."
94136,"@Override public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  if (!lpparam.packageName.equals(Common.PACKAGE_SNAP))   return;
  try {
    XposedUtils.log(""String_Node_Str"",false);
    Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
    Context context=(Context)callMethod(activityThread,""String_Node_Str"");
    PackageInfo piSnapChat=context.getPackageManager().getPackageInfo(lpparam.packageName,0);
    XposedUtils.log(""String_Node_Str"" + piSnapChat.versionName + ""String_Node_Str""+ piSnapChat.versionCode+ ""String_Node_Str"",false);
    XposedUtils.log(""String_Node_Str"" + BuildConfig.VERSION_NAME + ""String_Node_Str""+ BuildConfig.VERSION_CODE+ ""String_Node_Str"",false);
  }
 catch (  Exception e) {
    XposedUtils.log(""String_Node_Str"",e);
    return;
  }
  prefs.reload();
  refreshPreferences();
  printSettings();
  getEditText(lpparam);
  findAndHookMethod(Obfuscator.save.SCREENSHOTDETECTOR_CLASS,lpparam.classLoader,Obfuscator.save.SCREENSHOTDETECTOR_RUN,List.class,XC_MethodReplacement.DO_NOTHING);
  findAndHookMethod(Obfuscator.save.SNAPSTATEMESSAGE_CLASS,lpparam.classLoader,Obfuscator.save.SNAPSTATEMESSAGE_SETSCREENSHOTCOUNT,Long.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      param.args[0]=0L;
      Logger.log(""String_Node_Str"",true);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Bundle.class,new XC_MethodHook(){
    protected void afterHookedMethod(    MethodHookParam methodHookParam) throws Throwable {
      if (SnapContext == null)       SnapContext=(Activity)methodHookParam.thisObject;
      prefs.reload();
      refreshPreferences();
      Saving.initSaving(lpparam,mResources,SnapContext);
      if (mDiscover == true) {
        DataSaving.initMethod(lpparam,mResources,SnapContext);
      }
      if (mSpeed == true) {
        Spoofing.initSpeed(lpparam,SnapContext);
      }
      if (mLocation == true) {
        Spoofing.initLocation(lpparam,SnapContext);
      }
      PaintTools.initPaint(lpparam,mResources,SnapContext);
    }
  }
);
  String vanillaCaptionEditTextClassName=""String_Node_Str"";
  hookAllConstructors(findClass(vanillaCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      if (Common.CAPTION_UNLIMITED_VANILLA) {
        XposedUtils.log(""String_Node_Str"");
        EditText vanillaCaptionEditText=(EditText)param.thisObject;
        vanillaCaptionEditText.setSingleLine(false);
        vanillaCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
        vanillaCaptionEditText.setOnEditorActionListener(null);
        setObjectField(vanillaCaptionEditText,""String_Node_Str"",null);
      }
    }
  }
);
  String fatCaptionEditTextClassName=""String_Node_Str"";
  hookAllConstructors(findClass(fatCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      if (Common.CAPTION_UNLIMITED_FAT) {
        XposedUtils.log(""String_Node_Str"");
        EditText fatCaptionEditText=(EditText)param.thisObject;
        fatCaptionEditText.setFilters(new InputFilter[0]);
        fatCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
        fatCaptionEditText.setOnEditorActionListener(null);
        setObjectField(fatCaptionEditText,""String_Node_Str"",null);
      }
    }
  }
);
  Sharing.initSharing(lpparam,mResources);
  if (hideBf == true) {
    findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",new XC_MethodReplacement(){
      @Override protected Object replaceHookedMethod(      MethodHookParam param) throws Throwable {
        logging(""String_Node_Str"");
        return false;
      }
    }
);
  }
  if (mCustomFilterBoolean == true) {
    addFilter(lpparam);
  }
  if (selectAll == true) {
    HookSendList.initSelectAll(lpparam);
  }
}","@Override public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
  if (!lpparam.packageName.equals(Common.PACKAGE_SNAP))   return;
  try {
    XposedUtils.log(""String_Node_Str"",false);
    Object activityThread=callStaticMethod(findClass(""String_Node_Str"",null),""String_Node_Str"");
    Context context=(Context)callMethod(activityThread,""String_Node_Str"");
    PackageInfo piSnapChat=context.getPackageManager().getPackageInfo(lpparam.packageName,0);
    XposedUtils.log(""String_Node_Str"" + piSnapChat.versionName + ""String_Node_Str""+ piSnapChat.versionCode+ ""String_Node_Str"",false);
    XposedUtils.log(""String_Node_Str"" + BuildConfig.VERSION_NAME + ""String_Node_Str""+ BuildConfig.VERSION_CODE+ ""String_Node_Str"",false);
  }
 catch (  Exception e) {
    XposedUtils.log(""String_Node_Str"",e);
    return;
  }
  prefs.reload();
  refreshPreferences();
  printSettings();
  getEditText(lpparam);
  findAndHookMethod(Obfuscator.save.SCREENSHOTDETECTOR_CLASS,lpparam.classLoader,Obfuscator.save.SCREENSHOTDETECTOR_RUN,List.class,XC_MethodReplacement.DO_NOTHING);
  findAndHookMethod(Obfuscator.save.SNAPSTATEMESSAGE_CLASS,lpparam.classLoader,Obfuscator.save.SNAPSTATEMESSAGE_SETSCREENSHOTCOUNT,Long.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      param.args[0]=0L;
      Logger.log(""String_Node_Str"",true);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",Bundle.class,new XC_MethodHook(){
    protected void afterHookedMethod(    MethodHookParam methodHookParam) throws Throwable {
      if (SnapContext == null)       SnapContext=(Activity)methodHookParam.thisObject;
      prefs.reload();
      refreshPreferences();
      Saving.initSaving(lpparam,mResources,SnapContext);
      if (mDiscover == true) {
        DataSaving.initMethod(lpparam,mResources,SnapContext);
      }
      if (mSpeed == true) {
        Spoofing.initSpeed(lpparam,SnapContext);
      }
      if (mLocation == true) {
        Spoofing.initLocation(lpparam,SnapContext);
      }
      PaintTools.initPaint(lpparam,mResources);
    }
  }
);
  String vanillaCaptionEditTextClassName=""String_Node_Str"";
  hookAllConstructors(findClass(vanillaCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      if (Common.CAPTION_UNLIMITED_VANILLA) {
        XposedUtils.log(""String_Node_Str"");
        EditText vanillaCaptionEditText=(EditText)param.thisObject;
        vanillaCaptionEditText.setSingleLine(false);
        vanillaCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
        vanillaCaptionEditText.setOnEditorActionListener(null);
        setObjectField(vanillaCaptionEditText,""String_Node_Str"",null);
      }
    }
  }
);
  String fatCaptionEditTextClassName=""String_Node_Str"";
  hookAllConstructors(findClass(fatCaptionEditTextClassName,lpparam.classLoader),new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      if (Common.CAPTION_UNLIMITED_FAT) {
        XposedUtils.log(""String_Node_Str"");
        EditText fatCaptionEditText=(EditText)param.thisObject;
        fatCaptionEditText.setFilters(new InputFilter[0]);
        fatCaptionEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
        fatCaptionEditText.setOnEditorActionListener(null);
        setObjectField(fatCaptionEditText,""String_Node_Str"",null);
      }
    }
  }
);
  Sharing.initSharing(lpparam,mResources);
  if (hideBf == true) {
    findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",new XC_MethodReplacement(){
      @Override protected Object replaceHookedMethod(      MethodHookParam param) throws Throwable {
        logging(""String_Node_Str"");
        return false;
      }
    }
);
  }
  if (mCustomFilterBoolean == true) {
    addFilter(lpparam);
  }
  if (selectAll == true) {
    HookSendList.initSelectAll(lpparam);
  }
}","The original code passed `SnapContext` to `PaintTools.initPaint()` incorrectly, potentially causing method signature mismatches. In the fixed code, `PaintTools.initPaint()` is called with only `lpparam` and `mResources` parameters, aligning with its expected method signature. This correction ensures proper initialization of paint tools without runtime errors and maintains cleaner, more consistent method invocation across the Xposed module's implementation."
94137,"public static void initPaint(XC_LoadPackage.LoadPackageParam lpparam,final XModuleResources modRes,final Context context){
  Class<?> legacyCanvasView=findClass(""String_Node_Str"",lpparam.classLoader);
  XposedHelpers.findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,legacyCanvasView,int.class,float.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      Logger.log(""String_Node_Str"" + param.args[1] + ""String_Node_Str""+ param.args[2],true);
      param.args[1]=color;
      param.args[2]=width;
    }
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      paint=(Paint)getObjectField(param.thisObject,""String_Node_Str"");
      if (paint == null) {
        Logger.log(""String_Node_Str"",true);
      }
 else {
        if (shouldErase) {
          paint.setColor(0x00000000);
          paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
          paint.setAlpha(0x00);
        }
 else {
          paint.setXfermode(null);
          paint.setAlpha(alpha);
        }
        if (easterEgg) {
          int[] rainbow=getRainbowColors();
          Shader shader=new LinearGradient(0,0,0,720,rainbow,null,Shader.TileMode.MIRROR);
          Matrix matrix=new Matrix();
          matrix.setRotate(90);
          shader.setLocalMatrix(matrix);
          paint.setShader(shader);
        }
      }
    }
  }
);
  XposedHelpers.findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,Context.class,AttributeSet.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    final MethodHookParam param) throws Throwable {
      View colorpickerview=(View)getObjectField(param.thisObject,""String_Node_Str"");
      if (colorpickerview == null) {
        Logger.log(""String_Node_Str"",true);
      }
 else {
        Logger.log(""String_Node_Str"",true);
      }
      eraserbutton=new ImageButton(context);
      eraserbutton.setBackgroundColor(0);
      eraserbutton.setImageDrawable(modRes.getDrawable(R.drawable.eraser));
      eraserbutton.setScaleX((float)0.4);
      eraserbutton.setScaleY((float)0.4);
      eraserbutton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          shouldErase=true;
          eraserbutton.setImageDrawable(modRes.getDrawable(R.drawable.eraser_clicked));
        }
      }
);
      RelativeLayout.LayoutParams paramsErase=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsErase.topMargin=HookMethods.px(5.0f);
      paramsErase.rightMargin=HookMethods.px(5.0f);
      paramsErase.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ImageButton colorpicker=new ImageButton(context);
      colorpicker.setBackgroundColor(0);
      colorpicker.setImageDrawable(modRes.getDrawable(R.drawable.colorpicker));
      colorpicker.setScaleX((float)0.4);
      colorpicker.setScaleY((float)0.4);
      colorpicker.setOnLongClickListener(new View.OnLongClickListener(){
        @Override public boolean onLongClick(        View v){
          Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
          easterEgg=true;
          return true;
        }
      }
);
      colorpicker.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          eraserbutton.setImageDrawable(modRes.getDrawable(R.drawable.eraser));
          easterEgg=false;
          shouldErase=false;
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,color,new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int n){
              color=n;
            }
          }
);
          colorPickerDialog.setTitle(""String_Node_Str"");
          colorPickerDialog.show();
        }
      }
);
      RelativeLayout.LayoutParams paramsPicker=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsPicker.topMargin=HookMethods.px(-40.0f);
      paramsPicker.rightMargin=HookMethods.px(5.0f);
      paramsPicker.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ImageButton widthpicker=new ImageButton(context);
      widthpicker.setBackgroundColor(0);
      widthpicker.setImageDrawable(modRes.getDrawable(R.drawable.width));
      widthpicker.setScaleX((float)0.4);
      widthpicker.setScaleY((float)0.4);
      widthpicker.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          AlertDialog.Builder builder=new AlertDialog.Builder(context);
          LinearLayout linearLayout=new LinearLayout(context);
          linearLayout.setOrientation(LinearLayout.VERTICAL);
          LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
          final TextView tv=new TextView(context);
          tv.setText(""String_Node_Str"" + width);
          final SeekBar seekBar2=new SeekBar(context);
          seekBar2.setMax(30);
          seekBar2.setProgress(width);
          seekBar2.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
            public void onProgressChanged(            SeekBar seekBar2,            int n,            boolean bl){
              if (n == 0) {
                n=n + 1;
              }
              tv.setText(""String_Node_Str"" + n);
            }
            @Override public void onStartTrackingTouch(            SeekBar arg0){
            }
            @Override public void onStopTrackingTouch(            SeekBar arg0){
            }
          }
);
          builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              width=2;
            }
          }
);
          builder.setPositiveButton(Common.dialog_done,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              width=seekBar2.getProgress();
              if (width == 0) {
                width=width + 1;
              }
            }
          }
);
          linearLayout.addView(tv,params);
          linearLayout.addView(seekBar2,params);
          builder.setView((View)linearLayout);
          builder.show();
        }
      }
);
      RelativeLayout.LayoutParams paramsWidth=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsWidth.topMargin=HookMethods.px(-40.0f);
      paramsWidth.rightMargin=HookMethods.px(55.0f);
      paramsWidth.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ImageButton alphabutton=new ImageButton(context);
      alphabutton.setBackgroundColor(0);
      alphabutton.setImageDrawable(modRes.getDrawable(R.drawable.alpha));
      alphabutton.getDrawable().setDither(true);
      alphabutton.setScaleX((float)0.4);
      alphabutton.setScaleY((float)0.4);
      alphabutton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          AlertDialog.Builder builder=new AlertDialog.Builder(context);
          LinearLayout linearLayout=new LinearLayout(context);
          linearLayout.setOrientation(LinearLayout.VERTICAL);
          LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
          final TextView tv=new TextView(context);
          tv.setText(""String_Node_Str"" + alpha);
          final SeekBar seekBar2=new SeekBar(context);
          seekBar2.setMax(255);
          seekBar2.setProgress(alpha);
          seekBar2.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
            public void onProgressChanged(            SeekBar seekBar2,            int n,            boolean bl){
              int m=n + 1;
              tv.setText(""String_Node_Str"" + m);
            }
            @Override public void onStartTrackingTouch(            SeekBar arg0){
            }
            @Override public void onStopTrackingTouch(            SeekBar arg0){
            }
          }
);
          builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              alpha=255;
            }
          }
);
          builder.setPositiveButton(Common.dialog_done,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              alpha=seekBar2.getProgress();
            }
          }
);
          linearLayout.addView(tv,params);
          linearLayout.addView(seekBar2,params);
          builder.setView((View)linearLayout);
          builder.show();
        }
      }
);
      RelativeLayout.LayoutParams paramsAlpha=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsAlpha.topMargin=HookMethods.px(5.0f);
      paramsAlpha.rightMargin=HookMethods.px(55.0f);
      paramsAlpha.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(alphabutton,paramsAlpha);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(eraserbutton,paramsErase);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(colorpicker,paramsPicker);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(widthpicker,paramsWidth);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",int.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      Logger.log(""String_Node_Str"" + param.args[0],true);
      color=(Integer)param.args[0];
      if (shouldErase == true) {
        eraserbutton.setImageDrawable(modRes.getDrawable(R.drawable.eraser));
        shouldErase=false;
      }
    }
  }
);
}","public static void initPaint(XC_LoadPackage.LoadPackageParam lpparam,final XModuleResources modRes){
  XposedHelpers.findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,Context.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      if (param.args[0] != null) {
        context=(Context)param.args[0];
      }
 else {
        Logger.log(""String_Node_Str"",true);
      }
    }
  }
);
  Class<?> legacyCanvasView=findClass(""String_Node_Str"",lpparam.classLoader);
  XposedHelpers.findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,legacyCanvasView,int.class,float.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      Logger.log(""String_Node_Str"" + param.args[1] + ""String_Node_Str""+ param.args[2],true);
      param.args[1]=color;
      param.args[2]=width;
    }
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      paint=(Paint)getObjectField(param.thisObject,""String_Node_Str"");
      if (paint == null) {
        Logger.log(""String_Node_Str"",true);
      }
 else {
        if (shouldErase) {
          paint.setColor(0x00000000);
          paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
          paint.setAlpha(0x00);
        }
 else {
          paint.setXfermode(null);
          paint.setAlpha(alpha);
        }
        if (easterEgg) {
          int[] rainbow=getRainbowColors();
          Shader shader=new LinearGradient(0,0,0,720,rainbow,null,Shader.TileMode.MIRROR);
          Matrix matrix=new Matrix();
          matrix.setRotate(90);
          shader.setLocalMatrix(matrix);
          paint.setShader(shader);
        }
      }
    }
  }
);
  XposedHelpers.findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,Context.class,AttributeSet.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    final MethodHookParam param) throws Throwable {
      View colorpickerview=(View)getObjectField(param.thisObject,""String_Node_Str"");
      if (colorpickerview == null) {
        Logger.log(""String_Node_Str"",true);
      }
 else {
        Logger.log(""String_Node_Str"",true);
      }
      eraserbutton=new ImageButton(context);
      eraserbutton.setBackgroundColor(0);
      eraserbutton.setImageDrawable(modRes.getDrawable(R.drawable.eraser));
      eraserbutton.setScaleX((float)0.4);
      eraserbutton.setScaleY((float)0.4);
      eraserbutton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          shouldErase=true;
          eraserbutton.setImageDrawable(modRes.getDrawable(R.drawable.eraser_clicked));
        }
      }
);
      RelativeLayout.LayoutParams paramsErase=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsErase.topMargin=HookMethods.px(5.0f);
      paramsErase.rightMargin=HookMethods.px(5.0f);
      paramsErase.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ImageButton colorpicker=new ImageButton(context);
      colorpicker.setBackgroundColor(0);
      colorpicker.setImageDrawable(modRes.getDrawable(R.drawable.colorpicker));
      colorpicker.setScaleX((float)0.4);
      colorpicker.setScaleY((float)0.4);
      colorpicker.setOnLongClickListener(new View.OnLongClickListener(){
        @Override public boolean onLongClick(        View v){
          Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_SHORT).show();
          easterEgg=true;
          return true;
        }
      }
);
      colorpicker.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          eraserbutton.setImageDrawable(modRes.getDrawable(R.drawable.eraser));
          easterEgg=false;
          shouldErase=false;
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,color,new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int n){
              color=n;
            }
          }
);
          colorPickerDialog.setTitle(""String_Node_Str"");
          colorPickerDialog.show();
        }
      }
);
      RelativeLayout.LayoutParams paramsPicker=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsPicker.topMargin=HookMethods.px(-40.0f);
      paramsPicker.rightMargin=HookMethods.px(5.0f);
      paramsPicker.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ImageButton widthpicker=new ImageButton(context);
      widthpicker.setBackgroundColor(0);
      widthpicker.setImageDrawable(modRes.getDrawable(R.drawable.width));
      widthpicker.setScaleX((float)0.4);
      widthpicker.setScaleY((float)0.4);
      widthpicker.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          AlertDialog.Builder builder=new AlertDialog.Builder(context);
          LinearLayout linearLayout=new LinearLayout(context);
          linearLayout.setOrientation(LinearLayout.VERTICAL);
          LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
          final TextView tv=new TextView(context);
          tv.setText(""String_Node_Str"" + width);
          final SeekBar seekBar2=new SeekBar(context);
          seekBar2.setMax(30);
          seekBar2.setProgress(width);
          seekBar2.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
            public void onProgressChanged(            SeekBar seekBar2,            int n,            boolean bl){
              if (n == 0) {
                n=n + 1;
              }
              tv.setText(""String_Node_Str"" + n);
            }
            @Override public void onStartTrackingTouch(            SeekBar arg0){
            }
            @Override public void onStopTrackingTouch(            SeekBar arg0){
            }
          }
);
          builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              width=2;
            }
          }
);
          builder.setPositiveButton(Common.dialog_done,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              width=seekBar2.getProgress();
              if (width == 0) {
                width=width + 1;
              }
            }
          }
);
          linearLayout.addView(tv,params);
          linearLayout.addView(seekBar2,params);
          builder.setView((View)linearLayout);
          builder.show();
        }
      }
);
      RelativeLayout.LayoutParams paramsWidth=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsWidth.topMargin=HookMethods.px(-40.0f);
      paramsWidth.rightMargin=HookMethods.px(55.0f);
      paramsWidth.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ImageButton alphabutton=new ImageButton(context);
      alphabutton.setBackgroundColor(0);
      alphabutton.setImageDrawable(modRes.getDrawable(R.drawable.alpha));
      alphabutton.getDrawable().setDither(true);
      alphabutton.setScaleX((float)0.4);
      alphabutton.setScaleY((float)0.4);
      alphabutton.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          AlertDialog.Builder builder=new AlertDialog.Builder(context);
          LinearLayout linearLayout=new LinearLayout(context);
          linearLayout.setOrientation(LinearLayout.VERTICAL);
          LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
          final TextView tv=new TextView(context);
          tv.setText(""String_Node_Str"" + alpha);
          final SeekBar seekBar2=new SeekBar(context);
          seekBar2.setMax(255);
          seekBar2.setProgress(alpha);
          seekBar2.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
            public void onProgressChanged(            SeekBar seekBar2,            int n,            boolean bl){
              int m=n + 1;
              tv.setText(""String_Node_Str"" + m);
            }
            @Override public void onStartTrackingTouch(            SeekBar arg0){
            }
            @Override public void onStopTrackingTouch(            SeekBar arg0){
            }
          }
);
          builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              alpha=255;
            }
          }
);
          builder.setPositiveButton(Common.dialog_done,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              alpha=seekBar2.getProgress();
            }
          }
);
          linearLayout.addView(tv,params);
          linearLayout.addView(seekBar2,params);
          builder.setView((View)linearLayout);
          builder.show();
        }
      }
);
      RelativeLayout.LayoutParams paramsAlpha=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsAlpha.topMargin=HookMethods.px(5.0f);
      paramsAlpha.rightMargin=HookMethods.px(55.0f);
      paramsAlpha.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(alphabutton,paramsAlpha);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(eraserbutton,paramsErase);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(colorpicker,paramsPicker);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(widthpicker,paramsWidth);
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",int.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      Logger.log(""String_Node_Str"" + param.args[0],true);
      color=(Integer)param.args[0];
      if (shouldErase == true) {
        eraserbutton.setImageDrawable(modRes.getDrawable(R.drawable.eraser));
        shouldErase=false;
      }
    }
  }
);
}","The original code passed a hard-coded context parameter, which could lead to null pointer exceptions and unreliable context handling. The fixed code adds a new constructor hook that safely captures the context from method arguments, ensuring a valid context is always available. This modification improves robustness by dynamically obtaining the context, preventing potential runtime errors and making the code more flexible across different execution scenarios."
94138,"@Override public void onClick(DialogInterface dialog,int which){
  width=seekBar2.getProgress();
}","@Override public void onClick(DialogInterface dialog,int which){
  width=seekBar2.getProgress();
  if (width == 0) {
    width=width + 1;
  }
}","The original code allows zero width, which might cause issues in certain applications where a minimum non-zero value is required. The fixed code checks if the width is zero and increments it by 1, ensuring a minimum width of 1. This modification prevents potential rendering or calculation problems by guaranteeing a non-zero width value in subsequent operations."
94139,"public void onProgressChanged(SeekBar seekBar2,int n,boolean bl){
}","public void onProgressChanged(SeekBar seekBar2,int n,boolean bl){
  if (n == 0) {
    n=n + 1;
  }
  tv.setText(""String_Node_Str"" + n);
}","The original code lacks any implementation, making the method functionally useless and unable to handle SeekBar progress changes. In the fixed code, a conditional check ensures that when the progress is zero, the value is incremented to one, and the TextView (tv) is updated with a dynamic text that includes the current progress value. This modification prevents potential display issues and provides meaningful feedback to the user by showing the current progress state."
94140,"public static void initPaint(XC_LoadPackage.LoadPackageParam lpparam,final XModuleResources modRes,final Context context){
  Class<?> legacyCanvasView=findClass(""String_Node_Str"",lpparam.classLoader);
  XposedHelpers.findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,legacyCanvasView,int.class,float.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      Logger.log(""String_Node_Str"" + param.args[1] + ""String_Node_Str""+ param.args[2],true);
      param.args[1]=color;
      param.args[2]=width;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",int.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      Logger.log(""String_Node_Str"" + param.args[0],true);
      color=(Integer)param.args[0];
    }
  }
);
  XposedHelpers.findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,Context.class,AttributeSet.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    MethodHookParam param) throws Throwable {
      View colorpickerview=(View)getObjectField(param.thisObject,""String_Node_Str"");
      if (colorpickerview == null) {
        Logger.log(""String_Node_Str"",true);
      }
 else {
        Logger.log(""String_Node_Str"",true);
      }
      ImageButton colorpicker=new ImageButton(context);
      colorpicker.setBackgroundColor(0);
      colorpicker.setImageDrawable(modRes.getDrawable(R.drawable.colorpicker));
      colorpicker.setScaleX((float)0.4);
      colorpicker.setScaleY((float)0.4);
      colorpicker.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,color,new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int n){
              color=n;
            }
          }
);
          colorPickerDialog.setTitle(""String_Node_Str"");
          colorPickerDialog.show();
        }
      }
);
      RelativeLayout.LayoutParams paramsPicker=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsPicker.topMargin=HookMethods.px(-40.0f);
      paramsPicker.rightMargin=HookMethods.px(5.0f);
      paramsPicker.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ImageButton widthpicker=new ImageButton(context);
      widthpicker.setBackgroundColor(0);
      widthpicker.setImageDrawable(modRes.getDrawable(R.drawable.width));
      widthpicker.setScaleX((float)0.4);
      widthpicker.setScaleY((float)0.4);
      widthpicker.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          AlertDialog.Builder builder=new AlertDialog.Builder(context);
          final SeekBar seekBar2=new SeekBar(context);
          seekBar2.setMax(50);
          seekBar2.setProgress(width);
          seekBar2.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
            public void onProgressChanged(            SeekBar seekBar2,            int n,            boolean bl){
            }
            @Override public void onStartTrackingTouch(            SeekBar arg0){
            }
            @Override public void onStopTrackingTouch(            SeekBar arg0){
            }
          }
);
          builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              width=2;
            }
          }
);
          builder.setPositiveButton(Common.dialog_done,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              width=seekBar2.getProgress();
            }
          }
);
          builder.setView((View)seekBar2);
          builder.show();
        }
      }
);
      RelativeLayout.LayoutParams paramsWidth=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsWidth.topMargin=HookMethods.px(-40.0f);
      paramsWidth.rightMargin=HookMethods.px(55.0f);
      paramsWidth.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(colorpicker,paramsPicker);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(widthpicker,paramsWidth);
    }
  }
);
}","public static void initPaint(XC_LoadPackage.LoadPackageParam lpparam,final XModuleResources modRes,final Context context){
  Class<?> legacyCanvasView=findClass(""String_Node_Str"",lpparam.classLoader);
  XposedHelpers.findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,legacyCanvasView,int.class,float.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      Logger.log(""String_Node_Str"" + param.args[1] + ""String_Node_Str""+ param.args[2],true);
      param.args[1]=color;
      param.args[2]=width;
    }
  }
);
  findAndHookMethod(""String_Node_Str"",lpparam.classLoader,""String_Node_Str"",int.class,new XC_MethodHook(){
    @Override protected void beforeHookedMethod(    MethodHookParam param) throws Throwable {
      Logger.log(""String_Node_Str"" + param.args[0],true);
      color=(Integer)param.args[0];
    }
  }
);
  XposedHelpers.findAndHookConstructor(""String_Node_Str"",lpparam.classLoader,Context.class,AttributeSet.class,new XC_MethodHook(){
    @Override protected void afterHookedMethod(    final MethodHookParam param) throws Throwable {
      View colorpickerview=(View)getObjectField(param.thisObject,""String_Node_Str"");
      if (colorpickerview == null) {
        Logger.log(""String_Node_Str"",true);
      }
 else {
        Logger.log(""String_Node_Str"",true);
      }
      ImageButton colorpicker=new ImageButton(context);
      colorpicker.setBackgroundColor(0);
      colorpicker.setImageDrawable(modRes.getDrawable(R.drawable.colorpicker));
      colorpicker.setScaleX((float)0.4);
      colorpicker.setScaleY((float)0.4);
      colorpicker.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,color,new ColorPickerDialog.OnColorSelectedListener(){
            @Override public void onColorSelected(            int n){
              color=n;
            }
          }
);
          colorPickerDialog.setTitle(""String_Node_Str"");
          colorPickerDialog.show();
        }
      }
);
      RelativeLayout.LayoutParams paramsPicker=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsPicker.topMargin=HookMethods.px(-40.0f);
      paramsPicker.rightMargin=HookMethods.px(5.0f);
      paramsPicker.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ImageButton widthpicker=new ImageButton(context);
      widthpicker.setBackgroundColor(0);
      widthpicker.setImageDrawable(modRes.getDrawable(R.drawable.width));
      widthpicker.setScaleX((float)0.4);
      widthpicker.setScaleY((float)0.4);
      widthpicker.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          AlertDialog.Builder builder=new AlertDialog.Builder(context);
          LinearLayout linearLayout=new LinearLayout(context);
          linearLayout.setOrientation(LinearLayout.VERTICAL);
          LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
          final TextView tv=new TextView(context);
          tv.setText(""String_Node_Str"" + width);
          final SeekBar seekBar2=new SeekBar(context);
          seekBar2.setMax(30);
          seekBar2.setProgress(width);
          seekBar2.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
            public void onProgressChanged(            SeekBar seekBar2,            int n,            boolean bl){
              if (n == 0) {
                n=n + 1;
              }
              tv.setText(""String_Node_Str"" + n);
            }
            @Override public void onStartTrackingTouch(            SeekBar arg0){
            }
            @Override public void onStopTrackingTouch(            SeekBar arg0){
            }
          }
);
          builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              width=2;
            }
          }
);
          builder.setPositiveButton(Common.dialog_done,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              width=seekBar2.getProgress();
              if (width == 0) {
                width=width + 1;
              }
            }
          }
);
          linearLayout.addView(tv,params);
          linearLayout.addView(seekBar2,params);
          builder.setView((View)linearLayout);
          builder.show();
        }
      }
);
      RelativeLayout.LayoutParams paramsWidth=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
      paramsWidth.topMargin=HookMethods.px(-40.0f);
      paramsWidth.rightMargin=HookMethods.px(55.0f);
      paramsWidth.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(colorpicker,paramsPicker);
      ((RelativeLayout)colorpickerview.getParent().getParent()).addView(widthpicker,paramsWidth);
    }
  }
);
}","The original code lacked proper width selection handling in the SeekBar, allowing zero width and not updating the TextView dynamically. The fixed code adds a TextView to display current width, prevents zero width by incrementing to 1, and updates the display in real-time during SeekBar changes. These modifications ensure a more robust and user-friendly width selection experience with immediate visual feedback and preventing invalid width settings."
94141,"@Override protected void afterHookedMethod(MethodHookParam param) throws Throwable {
  View colorpickerview=(View)getObjectField(param.thisObject,""String_Node_Str"");
  if (colorpickerview == null) {
    Logger.log(""String_Node_Str"",true);
  }
 else {
    Logger.log(""String_Node_Str"",true);
  }
  ImageButton colorpicker=new ImageButton(context);
  colorpicker.setBackgroundColor(0);
  colorpicker.setImageDrawable(modRes.getDrawable(R.drawable.colorpicker));
  colorpicker.setScaleX((float)0.4);
  colorpicker.setScaleY((float)0.4);
  colorpicker.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,color,new ColorPickerDialog.OnColorSelectedListener(){
        @Override public void onColorSelected(        int n){
          color=n;
        }
      }
);
      colorPickerDialog.setTitle(""String_Node_Str"");
      colorPickerDialog.show();
    }
  }
);
  RelativeLayout.LayoutParams paramsPicker=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
  paramsPicker.topMargin=HookMethods.px(-40.0f);
  paramsPicker.rightMargin=HookMethods.px(5.0f);
  paramsPicker.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
  ImageButton widthpicker=new ImageButton(context);
  widthpicker.setBackgroundColor(0);
  widthpicker.setImageDrawable(modRes.getDrawable(R.drawable.width));
  widthpicker.setScaleX((float)0.4);
  widthpicker.setScaleY((float)0.4);
  widthpicker.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      AlertDialog.Builder builder=new AlertDialog.Builder(context);
      final SeekBar seekBar2=new SeekBar(context);
      seekBar2.setMax(50);
      seekBar2.setProgress(width);
      seekBar2.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
        public void onProgressChanged(        SeekBar seekBar2,        int n,        boolean bl){
        }
        @Override public void onStartTrackingTouch(        SeekBar arg0){
        }
        @Override public void onStopTrackingTouch(        SeekBar arg0){
        }
      }
);
      builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          width=2;
        }
      }
);
      builder.setPositiveButton(Common.dialog_done,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          width=seekBar2.getProgress();
        }
      }
);
      builder.setView((View)seekBar2);
      builder.show();
    }
  }
);
  RelativeLayout.LayoutParams paramsWidth=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
  paramsWidth.topMargin=HookMethods.px(-40.0f);
  paramsWidth.rightMargin=HookMethods.px(55.0f);
  paramsWidth.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
  ((RelativeLayout)colorpickerview.getParent().getParent()).addView(colorpicker,paramsPicker);
  ((RelativeLayout)colorpickerview.getParent().getParent()).addView(widthpicker,paramsWidth);
}","@Override protected void afterHookedMethod(final MethodHookParam param) throws Throwable {
  View colorpickerview=(View)getObjectField(param.thisObject,""String_Node_Str"");
  if (colorpickerview == null) {
    Logger.log(""String_Node_Str"",true);
  }
 else {
    Logger.log(""String_Node_Str"",true);
  }
  ImageButton colorpicker=new ImageButton(context);
  colorpicker.setBackgroundColor(0);
  colorpicker.setImageDrawable(modRes.getDrawable(R.drawable.colorpicker));
  colorpicker.setScaleX((float)0.4);
  colorpicker.setScaleY((float)0.4);
  colorpicker.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      ColorPickerDialog colorPickerDialog=new ColorPickerDialog(context,color,new ColorPickerDialog.OnColorSelectedListener(){
        @Override public void onColorSelected(        int n){
          color=n;
        }
      }
);
      colorPickerDialog.setTitle(""String_Node_Str"");
      colorPickerDialog.show();
    }
  }
);
  RelativeLayout.LayoutParams paramsPicker=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
  paramsPicker.topMargin=HookMethods.px(-40.0f);
  paramsPicker.rightMargin=HookMethods.px(5.0f);
  paramsPicker.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
  ImageButton widthpicker=new ImageButton(context);
  widthpicker.setBackgroundColor(0);
  widthpicker.setImageDrawable(modRes.getDrawable(R.drawable.width));
  widthpicker.setScaleX((float)0.4);
  widthpicker.setScaleY((float)0.4);
  widthpicker.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      AlertDialog.Builder builder=new AlertDialog.Builder(context);
      LinearLayout linearLayout=new LinearLayout(context);
      linearLayout.setOrientation(LinearLayout.VERTICAL);
      LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
      final TextView tv=new TextView(context);
      tv.setText(""String_Node_Str"" + width);
      final SeekBar seekBar2=new SeekBar(context);
      seekBar2.setMax(30);
      seekBar2.setProgress(width);
      seekBar2.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
        public void onProgressChanged(        SeekBar seekBar2,        int n,        boolean bl){
          if (n == 0) {
            n=n + 1;
          }
          tv.setText(""String_Node_Str"" + n);
        }
        @Override public void onStartTrackingTouch(        SeekBar arg0){
        }
        @Override public void onStopTrackingTouch(        SeekBar arg0){
        }
      }
);
      builder.setNeutralButton(Common.dialog_default,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          width=2;
        }
      }
);
      builder.setPositiveButton(Common.dialog_done,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          width=seekBar2.getProgress();
          if (width == 0) {
            width=width + 1;
          }
        }
      }
);
      linearLayout.addView(tv,params);
      linearLayout.addView(seekBar2,params);
      builder.setView((View)linearLayout);
      builder.show();
    }
  }
);
  RelativeLayout.LayoutParams paramsWidth=new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
  paramsWidth.topMargin=HookMethods.px(-40.0f);
  paramsWidth.rightMargin=HookMethods.px(55.0f);
  paramsWidth.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
  ((RelativeLayout)colorpickerview.getParent().getParent()).addView(colorpicker,paramsPicker);
  ((RelativeLayout)colorpickerview.getParent().getParent()).addView(widthpicker,paramsWidth);
}","The original code lacked proper user feedback and had an inflexible width selection mechanism with potential zero-width issues. The fixed code introduces a TextView to display the current width, ensures the width is always at least 1 by preventing zero values, and uses a LinearLayout to improve dialog layout and user interaction. These changes enhance user experience by providing real-time width feedback and preventing invalid width selections."
94142,"Request(RequestBuilder builder){
  method=builder.method;
  headers=builder.headers;
  cookies=builder.cookies;
  userAgent=builder.userAgent;
  charset=builder.requestCharset;
  body=builder.body;
  socksTimeout=builder.socksTimeout;
  connectTimeout=builder.connectTimeout;
  proxy=builder.proxy;
  followRedirect=builder.followRedirect;
  compress=builder.compress;
  verify=builder.verify;
  certs=builder.certs;
  basicAuth=builder.basicAuth;
  sessionContext=builder.sessionContext;
  keepAlive=builder.keepAlive;
  this.url=joinUrl(builder.url,builder.params,charset);
}","Request(RequestBuilder builder){
  method=builder.method;
  headers=builder.headers;
  cookies=builder.cookies;
  userAgent=builder.userAgent;
  charset=builder.charset;
  body=builder.body;
  socksTimeout=builder.socksTimeout;
  connectTimeout=builder.connectTimeout;
  proxy=builder.proxy;
  followRedirect=builder.followRedirect;
  compress=builder.compress;
  verify=builder.verify;
  certs=builder.certs;
  basicAuth=builder.basicAuth;
  sessionContext=builder.sessionContext;
  keepAlive=builder.keepAlive;
  this.url=builder.url;
  this.params=builder.params;
}","The original code incorrectly used `builder.requestCharset` instead of `builder.charset` and improperly handled URL and parameter joining within the constructor. In the fixed code, the correct charset is used, and URL and params are separately assigned, allowing more precise control over request configuration. This modification ensures accurate parameter handling and provides greater flexibility in constructing HTTP requests with the correct character encoding."
94143,"/** 
 * Set charset used to encode request params or forms. Default UTF8.
 */
public RequestBuilder charset(Charset charset){
  requestCharset=charset;
  return this;
}","/** 
 * Set charset used to encode request params or forms. Default UTF8.
 */
public RequestBuilder charset(Charset charset){
  this.charset=charset;
  return this;
}","The original code incorrectly used a local variable assignment, which would not update the class field for charset. The fixed version uses `this.charset` to correctly assign the input charset to the class-level field, ensuring the setter method properly updates the instance variable. This change guarantees that subsequent method calls will use the correct charset value, maintaining the expected behavior of the RequestBuilder."
94144,"RequestBuilder(@Nullable SessionContext sessionContext){
  this.sessionContext=sessionContext;
}","RequestBuilder(Request request){
  method=request.getMethod();
  headers=request.getHeaders();
  cookies=request.getCookies();
  userAgent=request.getUserAgent();
  charset=request.getCharset();
  body=request.getBody();
  socksTimeout=request.getSocksTimeout();
  connectTimeout=request.getConnectTimeout();
  proxy=request.getProxy();
  followRedirect=request.isFollowRedirect();
  compress=request.isCompress();
  verify=request.isVerify();
  certs=request.getCerts();
  basicAuth=request.getBasicAuth();
  sessionContext=request.getSessionContext();
  keepAlive=request.isKeepAlive();
  this.url=request.getUrl();
  this.params=request.getParams();
}","The original code merely initialized a SessionContext without properly setting or utilizing request-related attributes. The fixed code comprehensively copies all relevant request properties from a provided Request object, ensuring complete data transfer and initialization of the RequestBuilder. This approach creates a robust, fully-configured RequestBuilder that maintains all original request characteristics, improving flexibility and reducing potential configuration errors."
94145,"/** 
 * Set charset used to encode request params or forms. Default UTF8.
 */
public RequestBuilder requestCharset(Charset charset){
  requestCharset=charset;
  return this;
}","/** 
 * Set charset used to encode request params or forms. Default UTF8.
 */
public RequestBuilder requestCharset(Charset charset){
  this.charset=charset;
  return this;
}","The original code mistakenly used an unqualified variable assignment, which could lead to potential naming conflicts or unintended behavior. The fixed code uses `this.charset` to explicitly reference the instance variable, ensuring the correct field is updated within the current object's context. This change provides clear, precise attribute setting and maintains proper encapsulation of the `RequestBuilder` class."
94146,"public RequestBuilder url(String url){
  this.url=Objects.requireNonNull(url);
  return this;
}","public RequestBuilder url(URL url){
  this.url=Objects.requireNonNull(url);
  return this;
}","The original code accepts a String for the URL, which can lead to runtime errors and does not guarantee a valid URL format. The fixed code uses the java.net.URL class, which provides built-in validation and parsing of URLs during object creation. By switching to the URL type and using Objects.requireNonNull(), the code ensures type safety, prevents null values, and guarantees a well-formed URL before further processing."
94147,"/** 
 * Create new request with method and url
 */
public static RequestBuilder newRequest(String method,String url){
  return new RequestBuilder(null).method(method).url(url);
}","/** 
 * Create new request with method and url
 */
public static RequestBuilder newRequest(String method,String url){
  return new RequestBuilder().method(method).url(url);
}","The buggy code incorrectly passes `null` as the initial parameter when creating a `RequestBuilder`, which likely leads to a null pointer exception or improper initialization. The fixed code removes the `null` argument, instead calling the default constructor of `RequestBuilder()`, which ensures a clean and valid object instantiation. This correction guarantees a properly initialized `RequestBuilder` that can reliably chain method and URL configuration without risking null-related errors."
94148,"public RequestBuilder newRequest(String method,String url){
  return new RequestBuilder(context).url(url).method(method);
}","public RequestBuilder newRequest(String method,String url){
  return new RequestBuilder().sessionContext(context).url(url).method(method);
}","The original code incorrectly passed the context directly to the RequestBuilder constructor, potentially causing initialization issues. The fixed code uses the `sessionContext()` method to properly set the context, ensuring correct configuration of the request builder. This change improves method chaining and provides a more robust and flexible approach to creating request builders with the necessary context."
94149,"/** 
 * Encode key-value query parameter
 */
public static String encodeQuery(Parameter<String> query,Charset charset){
  return encodeParam(query.getName(),charset) + ""String_Node_Str"" + encodeParam(query.getValue(),charset);
}","/** 
 * Encode key-value query parameter
 */
public static String encodeQuery(Map.Entry<String,String> query,Charset charset){
  return encodeParam(query.getKey(),charset) + ""String_Node_Str"" + encodeParam(query.getValue(),charset);
}","The original code used a custom `Parameter<String>` type, which is likely a non-standard generic class, making method invocation and parameter access problematic. The fixed code replaces this with the standard Java `Map.Entry<String,String>` interface, which provides clearer and more idiomatic key-value pair access through `getKey()` and `getValue()` methods. This change improves code readability, compatibility, and adheres to Java's established collection framework conventions."
94150,"/** 
 * Encode multi queries
 */
public static String encodeQueries(Collection<? extends Parameter<String>> queries,Charset charset){
  StringBuilder sb=new StringBuilder();
  for (  Parameter<String> query : queries) {
    sb.append(encodeParam(query.getName(),charset));
    sb.append('=');
    sb.append(encodeParam(query.getValue(),charset));
    sb.append('&');
  }
  if (sb.length() > 0) {
    sb.deleteCharAt(sb.length() - 1);
  }
  return sb.toString();
}","/** 
 * Encode multi queries
 */
public static String encodeQueries(Collection<? extends Map.Entry<String,String>> queries,Charset charset){
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<String,String> query : queries) {
    sb.append(encodeParam(query.getKey(),charset));
    sb.append('=');
    sb.append(encodeParam(query.getValue(),charset));
    sb.append('&');
  }
  if (sb.length() > 0) {
    sb.deleteCharAt(sb.length() - 1);
  }
  return sb.toString();
}","The original code uses a custom `Parameter` interface, which may not be a standard Java interface and could limit flexibility. The fixed code replaces `Parameter` with `Map.Entry`, a standard Java interface for key-value pairs, allowing more generic and widely compatible query handling. This change enables easier integration with various map implementations and provides a more robust and standard approach to encoding query parameters."
94151,"private RawResponse doRequest(Request request){
  Charset charset=request.getCharset();
  URL url=request.getUrl();
  @Nullable RequestBody body=request.getBody();
  @Nullable URLConnectionSessionContext sessionContext=(URLConnectionSessionContext)request.getSessionContext();
  CookieJar cookieJar;
  if (sessionContext == null) {
    cookieJar=NopCookieJar.instance;
  }
 else {
    cookieJar=sessionContext.getCookieJar();
  }
  HttpURLConnection conn;
  try {
    @Nullable Proxy proxy=request.getProxy();
    if (proxy != null) {
      conn=(HttpURLConnection)url.openConnection(proxy);
    }
 else {
      conn=(HttpURLConnection)url.openConnection();
    }
  }
 catch (  IOException e) {
    throw new RequestsException(e);
  }
  conn.setUseCaches(false);
  if (conn instanceof HttpsURLConnection) {
    SSLSocketFactory ssf=null;
    if (!request.isVerify()) {
      ssf=SSLSocketFactories.getTrustAllSSLSocketFactory();
      ((HttpsURLConnection)conn).setHostnameVerifier(NopHostnameVerifier.getInstance());
    }
 else     if (!request.getCerts().isEmpty()) {
      ssf=SSLSocketFactories.getCustomSSLSocketFactory(request.getCerts());
    }
    if (ssf != null) {
      ((HttpsURLConnection)conn).setSSLSocketFactory(ssf);
    }
  }
  try {
    conn.setRequestMethod(request.getMethod());
  }
 catch (  ProtocolException e) {
    throw new RequestsException(e);
  }
  conn.setReadTimeout(request.getSocksTimeout());
  conn.setConnectTimeout(request.getConnectTimeout());
  conn.setInstanceFollowRedirects(false);
  if (body != null) {
    conn.setDoOutput(true);
    String contentType=body.getContentType();
    if (contentType != null) {
      if (body.isIncludeCharset()) {
        contentType+=""String_Node_Str"" + request.getCharset().name().toLowerCase();
      }
      conn.setRequestProperty(NAME_CONTENT_TYPE,contentType);
    }
  }
  if (!request.getUserAgent().isEmpty()) {
    conn.setRequestProperty(NAME_USER_AGENT,request.getUserAgent());
  }
  if (request.isCompress()) {
    conn.setRequestProperty(NAME_ACCEPT_ENCODING,""String_Node_Str"");
  }
  if (request.getBasicAuth() != null) {
    conn.setRequestProperty(NAME_AUTHORIZATION,request.getBasicAuth().encode());
  }
  Collection<Cookie> sessionCookies=cookieJar.getCookies(url);
  if (!request.getCookies().isEmpty() || !sessionCookies.isEmpty()) {
    StringBuilder sb=new StringBuilder();
    for (    Map.Entry<String,?> entry : request.getCookies()) {
      sb.append(entry.getKey()).append(""String_Node_Str"").append(String.valueOf(entry.getValue())).append(""String_Node_Str"");
    }
    for (    Cookie cookie : sessionCookies) {
      sb.append(cookie.getName()).append(""String_Node_Str"").append(cookie.getValue()).append(""String_Node_Str"");
    }
    if (sb.length() > 2) {
      sb.setLength(sb.length() - 2);
      String cookieStr=sb.toString();
      conn.setRequestProperty(NAME_COOKIE,cookieStr);
    }
  }
  for (  Map.Entry<String,?> header : request.getHeaders()) {
    conn.setRequestProperty(header.getKey(),String.valueOf(header.getValue()));
  }
  if (!request.isKeepAlive()) {
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  }
  try {
    conn.connect();
  }
 catch (  IOException e) {
    throw new RequestsException(e);
  }
  try {
    if (body != null) {
      sendBody(body,conn,charset);
    }
    return getResponse(url,conn,cookieJar,request.isCompress(),request.getMethod());
  }
 catch (  IOException e) {
    conn.disconnect();
    throw new RequestsException(e);
  }
catch (  Throwable e) {
    conn.disconnect();
    throw e;
  }
}","private RawResponse doRequest(Request request){
  Charset charset=request.getCharset();
  URL url=URIEncoder.joinUrl(request.getUrl(),URIEncoder.toStringParameters(request.getParams()),request.getCharset());
  @Nullable RequestBody body=request.getBody();
  @Nullable URLConnectionSessionContext sessionContext=(URLConnectionSessionContext)request.getSessionContext();
  CookieJar cookieJar;
  if (sessionContext == null) {
    cookieJar=NopCookieJar.instance;
  }
 else {
    cookieJar=sessionContext.getCookieJar();
  }
  HttpURLConnection conn;
  try {
    @Nullable Proxy proxy=request.getProxy();
    if (proxy != null) {
      conn=(HttpURLConnection)url.openConnection(proxy);
    }
 else {
      conn=(HttpURLConnection)url.openConnection();
    }
  }
 catch (  IOException e) {
    throw new RequestsException(e);
  }
  conn.setUseCaches(false);
  if (conn instanceof HttpsURLConnection) {
    SSLSocketFactory ssf=null;
    if (!request.isVerify()) {
      ssf=SSLSocketFactories.getTrustAllSSLSocketFactory();
      ((HttpsURLConnection)conn).setHostnameVerifier(NopHostnameVerifier.getInstance());
    }
 else     if (!request.getCerts().isEmpty()) {
      ssf=SSLSocketFactories.getCustomSSLSocketFactory(request.getCerts());
    }
    if (ssf != null) {
      ((HttpsURLConnection)conn).setSSLSocketFactory(ssf);
    }
  }
  try {
    conn.setRequestMethod(request.getMethod());
  }
 catch (  ProtocolException e) {
    throw new RequestsException(e);
  }
  conn.setReadTimeout(request.getSocksTimeout());
  conn.setConnectTimeout(request.getConnectTimeout());
  conn.setInstanceFollowRedirects(false);
  if (body != null) {
    conn.setDoOutput(true);
    String contentType=body.getContentType();
    if (contentType != null) {
      if (body.isIncludeCharset()) {
        contentType+=""String_Node_Str"" + request.getCharset().name().toLowerCase();
      }
      conn.setRequestProperty(NAME_CONTENT_TYPE,contentType);
    }
  }
  if (!request.getUserAgent().isEmpty()) {
    conn.setRequestProperty(NAME_USER_AGENT,request.getUserAgent());
  }
  if (request.isCompress()) {
    conn.setRequestProperty(NAME_ACCEPT_ENCODING,""String_Node_Str"");
  }
  if (request.getBasicAuth() != null) {
    conn.setRequestProperty(NAME_AUTHORIZATION,request.getBasicAuth().encode());
  }
  Collection<Cookie> sessionCookies=cookieJar.getCookies(url);
  if (!request.getCookies().isEmpty() || !sessionCookies.isEmpty()) {
    StringBuilder sb=new StringBuilder();
    for (    Map.Entry<String,?> entry : request.getCookies()) {
      sb.append(entry.getKey()).append(""String_Node_Str"").append(String.valueOf(entry.getValue())).append(""String_Node_Str"");
    }
    for (    Cookie cookie : sessionCookies) {
      sb.append(cookie.getName()).append(""String_Node_Str"").append(cookie.getValue()).append(""String_Node_Str"");
    }
    if (sb.length() > 2) {
      sb.setLength(sb.length() - 2);
      String cookieStr=sb.toString();
      conn.setRequestProperty(NAME_COOKIE,cookieStr);
    }
  }
  for (  Map.Entry<String,?> header : request.getHeaders()) {
    conn.setRequestProperty(header.getKey(),String.valueOf(header.getValue()));
  }
  if (!request.isKeepAlive()) {
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  }
  try {
    conn.connect();
  }
 catch (  IOException e) {
    throw new RequestsException(e);
  }
  try {
    if (body != null) {
      sendBody(body,conn,charset);
    }
    return getResponse(url,conn,cookieJar,request.isCompress(),request.getMethod());
  }
 catch (  IOException e) {
    conn.disconnect();
    throw new RequestsException(e);
  }
catch (  Throwable e) {
    conn.disconnect();
    throw e;
  }
}","The original code did not handle URL parameter encoding, which could lead to malformed URLs and potential request failures. The fixed code introduces `URIEncoder.joinUrl()` to properly encode and append request parameters to the URL, ensuring valid and correctly formatted URLs. This modification enhances request reliability by standardizing URL construction and preventing potential encoding-related errors during HTTP requests."
94152,"public void start(){
  server=new Server();
  HttpConfiguration http_config=new HttpConfiguration();
  http_config.setSecureScheme(""String_Node_Str"");
  http_config.setSecurePort(8443);
  http_config.setOutputBufferSize(32768);
  ServerConnector http=new ServerConnector(server,new HttpConnectionFactory(http_config));
  http.setPort(8080);
  http.setIdleTimeout(30000);
  SslContextFactory sslContextFactory=new SslContextFactory();
  sslContextFactory.setKeyStorePath(this.getClass().getResource(""String_Node_Str"").toExternalForm());
  sslContextFactory.setKeyStorePassword(""String_Node_Str"");
  sslContextFactory.setKeyManagerPassword(""String_Node_Str"");
  HttpConfiguration httpsConfig=new HttpConfiguration(http_config);
  httpsConfig.addCustomizer(new SecureRequestCustomizer());
  ServerConnector https=new ServerConnector(server,new SslConnectionFactory(sslContextFactory,HttpVersion.HTTP_1_1.asString()),new HttpConnectionFactory(httpsConfig));
  https.setPort(8443);
  https.setIdleTimeout(500000);
  server.setConnectors(new Connector[]{http,https});
  ServletHandler handler=new ServletHandler();
  server.setHandler(handler);
  handler.addServletWithMapping(MockGetServlet.class,""String_Node_Str"");
  handler.addServletWithMapping(MockPostServlet.class,""String_Node_Str"");
  handler.addServletWithMapping(MockBasicAuthenticationServlet.class,""String_Node_Str"");
  handler.addServletWithMapping(MockMultiPartServlet.class,""String_Node_Str"");
  try {
    server.start();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","public void start(){
  server=new Server();
  HttpConfiguration http_config=new HttpConfiguration();
  http_config.setSecureScheme(""String_Node_Str"");
  http_config.setSecurePort(8443);
  http_config.setOutputBufferSize(32768);
  ServerConnector http=new ServerConnector(server,new HttpConnectionFactory(http_config));
  http.setPort(8080);
  http.setIdleTimeout(30000);
  SslContextFactory sslContextFactory=new SslContextFactory();
  sslContextFactory.setKeyStorePath(this.getClass().getResource(""String_Node_Str"").toExternalForm());
  sslContextFactory.setKeyStorePassword(""String_Node_Str"");
  sslContextFactory.setKeyManagerPassword(""String_Node_Str"");
  HttpConfiguration httpsConfig=new HttpConfiguration(http_config);
  httpsConfig.addCustomizer(new SecureRequestCustomizer());
  ServerConnector https=new ServerConnector(server,new SslConnectionFactory(sslContextFactory,HttpVersion.HTTP_1_1.asString()),new HttpConnectionFactory(httpsConfig));
  https.setPort(8443);
  https.setIdleTimeout(500000);
  server.setConnectors(new Connector[]{http,https});
  ServletHandler handler=new ServletHandler();
  server.setHandler(handler);
  handler.addServletWithMapping(MockGetServlet.class,""String_Node_Str"");
  handler.addServletWithMapping(MockPostServlet.class,""String_Node_Str"");
  handler.addServletWithMapping(MockBasicAuthenticationServlet.class,""String_Node_Str"");
  handler.addServletWithMapping(MockPartServlet.class,""String_Node_Str"");
  try {
    server.start();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","The original code incorrectly mapped a servlet class named MockMultiPartServlet, which likely does not exist or is incorrectly named. In the fixed code, this was replaced with MockPartServlet, ensuring the correct servlet class is referenced for handling multipart requests. This correction prevents potential ClassNotFoundExceptions and ensures proper servlet mapping, improving the reliability and functionality of the server configuration."
94153,"@Override protected void handleMessageInternal(final Message<?> message) throws Exception {
  String topic=this.topicExpression != null ? this.topicExpression.getValue(this.evaluationContext,message,String.class) : message.getHeaders().get(KafkaHeaders.TOPIC,String.class);
  Integer partitionId=this.partitionExpression != null ? this.partitionExpression.getValue(this.evaluationContext,message,Integer.class) : message.getHeaders().get(KafkaHeaders.PARTITION_ID,Integer.class);
  Object messageKey=this.messageKeyExpression != null ? this.messageKeyExpression.getValue(this.evaluationContext,message) : message.getHeaders().get(KafkaHeaders.MESSAGE_KEY);
  this.kafkaProducerContext.send(topic,partitionId,messageKey,message.getPayload());
}","@Override protected void handleMessageInternal(final Message<?> message) throws Exception {
  String topic=this.topicExpression != null ? this.topicExpression.getValue(this.evaluationContext,message,String.class) : message.getHeaders().get(KafkaHeaders.TOPIC,String.class);
  Integer partitionId=this.partitionIdExpression != null ? this.partitionIdExpression.getValue(this.evaluationContext,message,Integer.class) : message.getHeaders().get(KafkaHeaders.PARTITION_ID,Integer.class);
  Object messageKey=this.messageKeyExpression != null ? this.messageKeyExpression.getValue(this.evaluationContext,message) : message.getHeaders().get(KafkaHeaders.MESSAGE_KEY);
  this.kafkaProducerContext.send(topic,partitionId,messageKey,message.getPayload());
}","The original code used an incorrect variable name `partitionExpression` instead of `partitionIdExpression`, which could lead to a compilation error or unexpected behavior. The fixed code correctly uses `partitionIdExpression` when evaluating the partition ID, ensuring proper method invocation and consistent naming. This correction improves code reliability by preventing potential runtime errors and maintaining clear, semantically accurate variable references."
94154,"public Future<RecordMetadata> send(String topic,Integer partition,K messageKey,V messagePayload){
  String targetTopic=StringUtils.hasText(topic) ? topic : this.producerMetadata.getTopic();
  Future<RecordMetadata> future=this.producer.send(new ProducerRecord<>(targetTopic,partition,messageKey,messagePayload));
  if (!producerMetadata.isSync()) {
    return future;
  }
 else {
    try {
      if (producerMetadata.getSendTimeout() <= 0) {
        future.get();
      }
 else {
        future.get(producerMetadata.getSendTimeout(),TimeUnit.MILLISECONDS);
      }
    }
 catch (    InterruptedException|ExecutionException|TimeoutException e) {
      throw new KafkaException(e);
    }
    return future;
  }
}","public Future<RecordMetadata> send(String topic,Integer partition,K messageKey,V messagePayload){
  String targetTopic=StringUtils.hasText(topic) ? topic : this.producerMetadata.getTopic();
  if (partition == null && this.getProducerMetadata().getPartitioner() != null) {
    partition=this.getProducerMetadata().getPartitioner().partition(messageKey,this.producer.partitionsFor(targetTopic).size());
  }
  Future<RecordMetadata> future=this.producer.send(new ProducerRecord<>(targetTopic,partition,messageKey,messagePayload));
  if (!producerMetadata.isSync()) {
    return future;
  }
 else {
    try {
      if (producerMetadata.getSendTimeout() <= 0) {
        future.get();
      }
 else {
        future.get(producerMetadata.getSendTimeout(),TimeUnit.MILLISECONDS);
      }
    }
 catch (    InterruptedException|ExecutionException|TimeoutException e) {
      throw new KafkaException(e);
    }
    return future;
  }
}","The original code lacked partition selection logic when no explicit partition was provided, potentially leading to unpredictable message distribution. The fixed code adds a custom partitioning mechanism by using a configurable partitioner to dynamically assign partitions based on the message key and total number of topic partitions. This enhancement ensures more controlled and predictable message routing, improving the producer's flexibility and message placement strategy."
94155,"@SuppressWarnings(""String_Node_Str"") public Map<String,List<KafkaStream<byte[],byte[]>>> getConsumerMapWithMessageStreams(){
  if (consumerMetadata.getValueDecoder() != null) {
    return getConsumerConnector().createMessageStreams(consumerMetadata.getTopicStreamMap(),consumerMetadata.getValueDecoder(),consumerMetadata.getValueDecoder());
  }
  return getConsumerConnector().createMessageStreams(consumerMetadata.getTopicStreamMap());
}","@SuppressWarnings(""String_Node_Str"") public Map<String,List<KafkaStream<byte[],byte[]>>> getConsumerMapWithMessageStreams(){
  if (consumerMetadata.getValueDecoder() != null && consumerMetadata.getKeyDecoder() != null) {
    return getConsumerConnector().createMessageStreams(consumerMetadata.getTopicStreamMap(),consumerMetadata.getKeyDecoder(),consumerMetadata.getValueDecoder());
  }
  return getConsumerConnector().createMessageStreams(consumerMetadata.getTopicStreamMap());
}","The original code only checks for a value decoder, potentially causing incorrect message stream creation when key and value decoders are required. The fixed code adds a condition to verify both key and value decoders are present before calling `createMessageStreams` with both decoder parameters. This ensures proper message stream initialization by using appropriate decoders for both key and value types, preventing potential decoding errors or incomplete stream configurations."
94156,"@ProtobufRPC(serviceName=""String_Node_Str"",methodName=""String_Node_Str"",onceTalkTimeout=1000000) Future<EchoInfo> echoAsync(EchoInfo info);","@ProtobufRPC(serviceName=""String_Node_Str"",methodName=""String_Node_Str"",onceTalkTimeout=500000) Future<EchoInfo> echoAsync(EchoInfo info);","The original code used an excessively long onceTalkTimeout of 1,000,000 milliseconds, which could potentially cause unnecessary resource blocking and slower response times. The fixed code reduces the timeout to 500,000 milliseconds, providing a more reasonable and efficient timeout duration for the RPC method. This adjustment optimizes network communication by reducing potential wait times while maintaining adequate time for request processing."
94157,"@ProtobufRPCService(serviceName=""String_Node_Str"",methodName=""String_Node_Str"",description=""String_Node_Str"") public EchoInfo doEcho(EchoInfo info){
  EchoInfo ret=new EchoInfo();
  ret.setMessage(""String_Node_Str"" + info.getMessage() + (order == null ? ""String_Node_Str"" : order));
  return ret;
}","@ProtobufRPCService(serviceName=""String_Node_Str"",methodName=""String_Node_Str"",description=""String_Node_Str"") public EchoInfo doEcho(EchoInfo info){
  EchoInfo ret=new EchoInfo();
  ret.setMessage(""String_Node_Str"" + info.getMessage() + (order == null ? ""String_Node_Str"" : order));
  SleepUtils.dummySleep(2000000);
  return ret;
}","The original code lacks a deliberate time delay mechanism, potentially causing rapid successive executions without any processing pause. The fixed code introduces `SleepUtils.dummySleep(2000000)`, which adds a significant time delay of approximately 2 seconds, potentially preventing race conditions or allowing time for background processing. This modification enhances the method's reliability by introducing a controlled pause, which can help manage resource allocation and prevent potential concurrent execution issues."
94158,"/** 
 * Checks if is current channel.
 * @param channel the channel
 * @return true, if is current channel
 */
public boolean isCurrentChannel(Channel channel){
  if (this.channel == null) {
    return false;
  }
  return channel.equals(channel);
}","/** 
 * Checks if is current channel.
 * @param channel the channel
 * @return true, if is current channel
 */
public boolean isCurrentChannel(Channel channel){
  if (this.channel == null) {
    return false;
  }
  return this.channel.equals(channel);
}","The original code incorrectly compares the input channel with itself, causing a self-comparison that fails to check against the actual instance channel. In the fixed code, `this.channel.equals(channel)` correctly compares the current instance's channel with the input channel, ensuring proper comparison. This correction prevents potential logical errors and ensures accurate channel identification by using the correct reference point for comparison."
94159,"public static void main(String[] args){
  RpcClientOptions options=new RpcClientOptions();
  options.setThreadPoolSize(10);
  options.setMaxIdleSize(10);
  options.setMinIdleSize(10);
  options.setMaxWait(1000);
  options.setShortConnection(false);
  RpcClient rpcClient=new RpcClient(options);
  ProtobufRpcProxy<EchoService> pbrpcProxy=new ProtobufRpcProxy<EchoService>(rpcClient,EchoService.class);
  pbrpcProxy.setPort(Integer.valueOf(args[0]));
  pbrpcProxy.setHost(""String_Node_Str"");
  EchoService echoService=pbrpcProxy.proxy();
  EchoInfo echoInfo=new EchoInfo();
  long time=System.currentTimeMillis();
  for (int i=0; i < 1000; i++) {
    echoInfo.setMessage(""String_Node_Str"" + i);
    echoInfo=echoService.echo(echoInfo);
    System.out.println(echoInfo.getMessage());
  }
  System.out.println(System.currentTimeMillis() - time);
  pbrpcProxy.close();
  rpcClient.shutdown();
}","public static void main(String[] args){
  RpcClientOptions options=new RpcClientOptions();
  options.setThreadPoolSize(10);
  options.setMaxIdleSize(10);
  options.setMinIdleSize(10);
  options.setMaxWait(1000);
  options.setShortConnection(false);
  RpcClient rpcClient=new RpcClient(options);
  ProtobufRpcProxy<EchoService> pbrpcProxy=new ProtobufRpcProxy<EchoService>(rpcClient,EchoService.class);
  pbrpcProxy.setPort(8000);
  pbrpcProxy.setHost(""String_Node_Str"");
  EchoService echoService=pbrpcProxy.proxy();
  EchoInfo echoInfo=new EchoInfo();
  long time=System.currentTimeMillis();
  for (int i=0; i < 1000; i++) {
    try {
      echoInfo.setMessage(""String_Node_Str"" + i);
      Future<EchoInfo> echoInfo2=echoService.echoAsync(echoInfo);
      EchoInfo echoInfo3=echoInfo2.get();
      System.out.println(echoInfo3);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  System.out.println(System.currentTimeMillis() - time);
  pbrpcProxy.close();
  rpcClient.shutdown();
}","The original code directly calls the synchronous `echo()` method, which can block execution and cause performance bottlenecks during repeated RPC calls. The fixed code introduces asynchronous processing using `echoAsync()` and `Future`, allowing non-blocking concurrent request handling with proper error management via try-catch. This approach improves responsiveness, enables parallel execution, and provides better error handling for the RPC client operations."
94160,"@SuppressWarnings(""String_Node_Str"") public T getResource(){
  try {
    return (T)internalPool.borrowObject();
  }
 catch (  Exception e) {
    throw new JedisConnectionException(""String_Node_Str"",e);
  }
}","@SuppressWarnings(""String_Node_Str"") public T getResource(){
  try {
    return (T)internalPool.borrowObject();
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","The original code throws a custom JedisConnectionException, which might mask underlying connection issues or create unnecessary dependency on Jedis-specific error handling. The fixed code replaces the specific exception with a more generic RuntimeException, providing a standard way to handle and propagate unexpected errors during resource borrowing. This modification improves error reporting flexibility and reduces tight coupling with specific library exceptions."
94161,"public void returnResource(final T resource){
  try {
    internalPool.returnObject(resource);
  }
 catch (  Exception e) {
    throw new JedisException(""String_Node_Str"",e);
  }
}","public void returnResource(final T resource){
  try {
    internalPool.returnObject(resource);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","The original code throws a custom `JedisException`, which might not be the most appropriate exception for general resource return errors. The fixed code replaces `JedisException` with a more generic `RuntimeException`, providing a standard way to handle unexpected errors during resource return. This change allows for more flexible error handling and ensures that unexpected exceptions are propagated without introducing a specific dependency on Jedis-related exception handling."
94162,"public void destroy(){
  try {
    internalPool.close();
  }
 catch (  Exception e) {
    throw new JedisException(""String_Node_Str"",e);
  }
}","public void destroy(){
  try {
    internalPool.close();
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","The original code incorrectly throws a custom JedisException, which can unnecessarily complicate error handling and potentially mask underlying issues during pool closure. The fixed code replaces JedisException with RuntimeException, providing a more standard and flexible approach to exception handling that allows calling methods to decide how to handle the error. By using RuntimeException, the code ensures clearer error propagation and maintains better compatibility with existing error management strategies."
94163,"public void returnBrokenResource(final T resource){
  try {
    internalPool.invalidateObject(resource);
  }
 catch (  Exception e) {
    throw new JedisException(""String_Node_Str"",e);
  }
}","public void returnBrokenResource(final T resource){
  try {
    internalPool.invalidateObject(resource);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","The original code throws a custom `JedisException`, which might be too specific and potentially mask underlying issues when returning a broken resource. The fixed code changes the exception to a more generic `RuntimeException`, providing a broader error-handling mechanism that can propagate unexpected problems during resource invalidation. This modification ensures better error visibility and allows calling code to handle resource return failures more flexibly without being constrained by a specific exception type."
94164,"@Test public void testGetRpcMethodMeta(){
  RpcClient rpcClient=new RpcClient();
  ProtobufRpcProxy<RpcServiceMetaService> pbrpcProxy=new ProtobufRpcProxy<RpcServiceMetaService>(rpcClient,RpcServiceMetaService.class);
  pbrpcProxy.setPort(PORT);
  RpcServiceMetaService proxy=pbrpcProxy.proxy();
  RpcServiceMetaList rpcServiceMetaInfo=proxy.getRpcServiceMetaInfo();
  Assert.assertEquals(4,rpcServiceMetaInfo.getRpcServiceMetas().size());
  List<RpcServiceMeta> rpcServiceMetas=rpcServiceMetaInfo.getRpcServiceMetas();
  for (  RpcServiceMeta rpcServiceMeta : rpcServiceMetas) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getServiceName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getMethodName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getInputObjName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getOutputObjName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getInputProto());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getOutputProto());
  }
  System.out.println(""String_Node_Str"");
  System.out.println(rpcServiceMetaInfo.getTypesIDL());
  System.out.println(rpcServiceMetaInfo.getRpcsIDL());
}","@Test public void testGetRpcMethodMeta(){
  RpcClient rpcClient=new RpcClient();
  ProtobufRpcProxy<RpcServiceMetaService> pbrpcProxy=new ProtobufRpcProxy<RpcServiceMetaService>(rpcClient,RpcServiceMetaService.class);
  pbrpcProxy.setPort(PORT);
  RpcServiceMetaService proxy=pbrpcProxy.proxy();
  RpcServiceMetaList rpcServiceMetaInfo=proxy.getRpcServiceMetaInfo();
  Assert.assertEquals(5,rpcServiceMetaInfo.getRpcServiceMetas().size());
  List<RpcServiceMeta> rpcServiceMetas=rpcServiceMetaInfo.getRpcServiceMetas();
  for (  RpcServiceMeta rpcServiceMeta : rpcServiceMetas) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getServiceName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getMethodName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getInputObjName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getOutputObjName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getInputProto());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getOutputProto());
  }
  System.out.println(""String_Node_Str"");
  System.out.println(rpcServiceMetaInfo.getTypesIDL());
  System.out.println(rpcServiceMetaInfo.getRpcsIDL());
}","The original code incorrectly asserted that the RpcServiceMetaList should contain 4 service metas, potentially masking the true number of services. The fixed code changes the assertion to 5, reflecting the actual number of RpcServiceMetas in the list. This correction ensures accurate validation of the RPC service metadata, preventing potential false-positive test results and improving the reliability of the test method."
94165,"@Test public void testRpcMetaQuery() throws Exception {
  RpcProxyFactoryBean proxyBean=new RpcProxyFactoryBean();
  proxyBean.setServiceInterface(RpcServiceMetaService.class);
  proxyBean.setPort(servicePort);
  proxyBean.afterPropertiesSet();
  Object object=proxyBean.getObject();
  Assert.assertTrue(object instanceof RpcServiceMetaService);
  RpcServiceMetaService rpcServiceMetaService=(RpcServiceMetaService)object;
  RpcServiceMetaList rpcServiceMetaInfo=rpcServiceMetaService.getRpcServiceMetaInfo();
  List<RpcServiceMeta> rpcServiceMetas=rpcServiceMetaInfo.getRpcServiceMetas();
  Assert.assertEquals(4,rpcServiceMetas.size());
}","@Test public void testRpcMetaQuery() throws Exception {
  RpcProxyFactoryBean proxyBean=new RpcProxyFactoryBean();
  proxyBean.setServiceInterface(RpcServiceMetaService.class);
  proxyBean.setPort(servicePort);
  proxyBean.afterPropertiesSet();
  Object object=proxyBean.getObject();
  Assert.assertTrue(object instanceof RpcServiceMetaService);
  RpcServiceMetaService rpcServiceMetaService=(RpcServiceMetaService)object;
  RpcServiceMetaList rpcServiceMetaInfo=rpcServiceMetaService.getRpcServiceMetaInfo();
  List<RpcServiceMeta> rpcServiceMetas=rpcServiceMetaInfo.getRpcServiceMetas();
  Assert.assertEquals(5,rpcServiceMetas.size());
}","The original test incorrectly asserted that the RPC service metadata list should contain 4 service metas, which was likely outdated or inaccurate. The fixed code updates the assertion to expect 5 service metas, reflecting the current correct number of registered services. This change ensures the test accurately validates the RPC service metadata list, preventing potential false negative test results and maintaining the test's reliability."
94166,"public Object invoke(MethodInvocation invocation) throws Throwable {
  String beanKey=elect(invocation);
  Object bean=targetBeans.get(beanKey);
  if (isFailOver()) {
    boolean isAvailable;
    try {
      isAvailable=failOverInterceptor.isAvailable(bean,getMethod(bean,invocation),beanKey);
    }
 catch (    Exception e) {
      isAvailable=false;
    }
    if (!isAvailable) {
      failedTarget(bean,invocation,beanKey);
      return invoke(invocation);
    }
  }
  if (bean != null) {
    try {
      return doInvoke(bean,invocation);
    }
 catch (    Throwable e) {
      Throwable t=getRealException(e);
      if (isFailOver() && failOverInterceptor.isDoFailover(t,beanKey)) {
        LOGGER.error(""String_Node_Str"" + t.getLocalizedMessage());
        failedTarget(bean,invocation,beanKey);
        return invoke(invocation);
      }
      throw t;
    }
  }
  throw new NullPointerException(""String_Node_Str"");
}","public Object invoke(MethodInvocation invocation) throws Throwable {
  String beanKey=elect(invocation);
  Object bean=targetBeans.get(beanKey);
  if (isFailOver()) {
    boolean isAvailable;
    try {
      isAvailable=failOverInterceptor.isAvailable(bean,getMethod(bean,invocation),beanKey);
    }
 catch (    Exception e) {
      isAvailable=false;
    }
    if (!isAvailable) {
      failedTarget(bean,invocation,beanKey);
      return invoke(invocation);
    }
  }
  if (bean != null) {
    try {
      return doInvoke(bean,invocation);
    }
 catch (    Throwable e) {
      Throwable t=getRealException(e);
      if (isFailOver() && failOverInterceptor.isDoFailover(t,beanKey)) {
        LOGGER.log(Level.SEVERE,""String_Node_Str"" + t.getLocalizedMessage());
        failedTarget(bean,invocation,beanKey);
        return invoke(invocation);
      }
      throw t;
    }
  }
  throw new NullPointerException(""String_Node_Str"");
}","The original code used `LOGGER.error()`, which is not a standard logging method and may not properly capture exception details. The fixed code replaces this with `LOGGER.log(Level.SEVERE, ...)`, which provides a more robust and standard logging approach for severe-level exceptions. This change ensures proper exception logging, improves error traceability, and maintains the method's failover mechanism with more reliable error reporting."
94167,"public void afterPropertiesSet() throws Exception {
  if (getServiceInterface() == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (targetBeans == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  Map.Entry<String,Object> entry : targetBeans.entrySet()) {
    Object o=entry.getValue();
    if (!getServiceInterface().isAssignableFrom(o.getClass())) {
      throw new IllegalArgumentException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
    if (!isAssignableFrom(getExtraServiceInterfaces(),o.getClass())) {
      throw new IllegalArgumentException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
  }
  ProxyFactory pf=new ProxyFactory(getServiceInterface(),this);
  if (getExtraServiceInterfaces() != null) {
    for (    Class clazz : getExtraServiceInterfaces()) {
      pf.addInterface(clazz);
    }
  }
  this.serviceProxy=pf.getProxy(getBeanClassLoader());
  if (loadBalanceStrategy == null) {
    Map<String,Integer> lbFactors=new HashMap<String,Integer>();
    for (    String key : targetBeans.keySet()) {
      lbFactors.put(key,DEFAULT_LB_FACTOR);
    }
    loadBalanceStrategy=new RoundRobinLoadBalanceStrategy(lbFactors);
  }
 else {
    Set<String> targets=loadBalanceStrategy.getTargets();
    if (targets == null || targets.isEmpty()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    for (    String key : targets) {
      if (!targetBeans.containsKey(key)) {
        throw new IllegalArgumentException(""String_Node_Str"" + key + ""String_Node_Str"");
      }
    }
  }
  targetBeans=Collections.synchronizedMap(targetBeans);
  if (!isFailOver()) {
    LOGGER.warn(""String_Node_Str"");
  }
}","public void afterPropertiesSet() throws Exception {
  if (getServiceInterface() == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (targetBeans == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  Map.Entry<String,Object> entry : targetBeans.entrySet()) {
    Object o=entry.getValue();
    if (!getServiceInterface().isAssignableFrom(o.getClass())) {
      throw new IllegalArgumentException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
    if (!isAssignableFrom(getExtraServiceInterfaces(),o.getClass())) {
      throw new IllegalArgumentException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
  }
  ProxyFactory pf=new ProxyFactory(getServiceInterface(),this);
  if (getExtraServiceInterfaces() != null) {
    for (    Class clazz : getExtraServiceInterfaces()) {
      pf.addInterface(clazz);
    }
  }
  this.serviceProxy=pf.getProxy(getBeanClassLoader());
  if (loadBalanceStrategy == null) {
    Map<String,Integer> lbFactors=new HashMap<String,Integer>();
    for (    String key : targetBeans.keySet()) {
      lbFactors.put(key,DEFAULT_LB_FACTOR);
    }
    loadBalanceStrategy=new RoundRobinLoadBalanceStrategy(lbFactors);
  }
 else {
    Set<String> targets=loadBalanceStrategy.getTargets();
    if (targets == null || targets.isEmpty()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    for (    String key : targets) {
      if (!targetBeans.containsKey(key)) {
        throw new IllegalArgumentException(""String_Node_Str"" + key + ""String_Node_Str"");
      }
    }
  }
  targetBeans=Collections.synchronizedMap(targetBeans);
  if (!isFailOver()) {
    LOGGER.log(Level.WARNING,""String_Node_Str"");
  }
}","The original code used `LOGGER.warn()`, which is not a standard logging method and could lead to potential logging errors. The fixed code replaces this with `LOGGER.log(Level.WARNING, ""String_Node_Str"")`, which is the correct way to log a warning message using the standard Java logging framework. This change ensures proper logging behavior and maintains consistent error reporting across the application."
94168,"/** 
 * @param heartBeat the heartBeat to set
 */
public void setHeartBeat(boolean heartBeat){
  this.heartBeat=heartBeat;
  if (!heartBeat) {
    LOGGER.warn(""String_Node_Str"");
  }
}","/** 
 * @param heartBeat the heartBeat to set
 */
public void setHeartBeat(boolean heartBeat){
  this.heartBeat=heartBeat;
  if (!heartBeat) {
    LOGGER.log(Level.WARNING,""String_Node_Str"");
  }
}","The buggy code uses an incorrect logging method `LOGGER.warn()`, which may not provide proper log level control. The fixed code replaces it with `LOGGER.log(Level.WARNING, ""String_Node_Str"")`, which explicitly specifies the warning log level using the standard Java logging mechanism. This change ensures more consistent and standardized logging behavior, allowing better log management and filtering in the application."
94169,"/** 
 * get heart bean recover interval. unit 
 * @return
 */
private long getRecoverInterval(){
  long recoverInterval=proxyFactoryBean.getRecoverInterval();
  if (recoverInterval <= TOO_FREQUENT) {
    LOGGER.warn(""String_Node_Str"" + recoverInterval + ""String_Node_Str""+ DEFAULT_RECOVER_INTERVAL);
    recoverInterval=DEFAULT_RECOVER_INTERVAL;
  }
  return recoverInterval;
}","/** 
 * get heart bean recover interval. unit 
 * @return
 */
private long getRecoverInterval(){
  long recoverInterval=proxyFactoryBean.getRecoverInterval();
  if (recoverInterval <= TOO_FREQUENT) {
    LOGGER.log(Level.WARNING,""String_Node_Str"" + recoverInterval + ""String_Node_Str""+ DEFAULT_RECOVER_INTERVAL);
    recoverInterval=DEFAULT_RECOVER_INTERVAL;
  }
  return recoverInterval;
}","The original code used an incorrect logging method, likely causing potential logging errors or ineffective warning generation. The fixed code replaces `LOGGER.warn()` with `LOGGER.log(Level.WARNING)`, which is the proper Java logging approach for specifying warning log levels explicitly. This change ensures accurate, standardized logging with precise severity level reporting, improving the method's error tracking and diagnostic capabilities."
94170,"/** 
 * main entry for thread running.
 */
public void run(){
  runing=true;
  LOGGER.info(""String_Node_Str"");
  Map<String,FactoryBeanInvokeInfo> failedBeans;
  FailOverInterceptor interceptor=proxyFactoryBean.getFailOverInterceptor();
  while (proxyFactoryBean.hasFactoryBeanFailed() && !close) {
    failedBeans=proxyFactoryBean.getFailedFactoryBeans();
    if (failedBeans == null || failedBeans.isEmpty()) {
      return;
    }
    FactoryBeanInvokeInfo invokeInfo;
    for (    Map.Entry<String,FactoryBeanInvokeInfo> entry : failedBeans.entrySet()) {
      invokeInfo=entry.getValue();
      boolean available;
      try {
        available=interceptor.isRecover(invokeInfo.getBean(),invokeInfo.getInvocation(),invokeInfo.getBeanKey());
      }
 catch (      Exception e) {
        if (LOGGER.isDebugEnabled()) {
          LOGGER.debug(e);
        }
        available=false;
      }
      if (available) {
        proxyFactoryBean.recoverFactoryBean(entry.getKey());
        LOGGER.info(invokeInfo.getBeanKey() + ""String_Node_Str"");
      }
 else {
        LOGGER.warn(invokeInfo.getBeanKey() + ""String_Node_Str"");
      }
    }
    try {
      Thread.sleep(getRecoverInterval());
    }
 catch (    Exception e) {
      if (LOGGER.isDebugEnabled()) {
        LOGGER.debug(e);
      }
    }
  }
  runing=false;
  LOGGER.info(""String_Node_Str"");
}","/** 
 * main entry for thread running.
 */
public void run(){
  runing=true;
  LOGGER.info(""String_Node_Str"");
  Map<String,FactoryBeanInvokeInfo> failedBeans;
  FailOverInterceptor interceptor=proxyFactoryBean.getFailOverInterceptor();
  while (proxyFactoryBean.hasFactoryBeanFailed() && !close) {
    failedBeans=proxyFactoryBean.getFailedFactoryBeans();
    if (failedBeans == null || failedBeans.isEmpty()) {
      return;
    }
    FactoryBeanInvokeInfo invokeInfo;
    for (    Map.Entry<String,FactoryBeanInvokeInfo> entry : failedBeans.entrySet()) {
      invokeInfo=entry.getValue();
      boolean available;
      try {
        available=interceptor.isRecover(invokeInfo.getBean(),invokeInfo.getInvocation(),invokeInfo.getBeanKey());
      }
 catch (      Exception e) {
        if (LOGGER.isLoggable(Level.FINE)) {
          LOGGER.log(Level.FINE,e.getMessage());
        }
        available=false;
      }
      if (available) {
        proxyFactoryBean.recoverFactoryBean(entry.getKey());
        LOGGER.info(invokeInfo.getBeanKey() + ""String_Node_Str"");
      }
 else {
        LOGGER.log(Level.WARNING,invokeInfo.getBeanKey() + ""String_Node_Str"");
      }
    }
    try {
      Thread.sleep(getRecoverInterval());
    }
 catch (    Exception e) {
      if (LOGGER.isLoggable(Level.FINE)) {
        LOGGER.log(Level.FINE,e.getMessage());
      }
    }
  }
  runing=false;
  LOGGER.info(""String_Node_Str"");
}","The buggy code used non-standard logging methods like `isDebugEnabled()` and direct debug calls, which may not provide consistent error handling and logging across different logging frameworks. The fixed code replaces these with standard Java logging methods like `isLoggable(Level.FINE)` and `LOGGER.log()`, ensuring better log level management and exception message capturing. These changes improve error tracking, provide more robust logging, and enhance the method's overall exception handling and diagnostic capabilities."
94171,"public HaProtobufRpcProxy(RpcClient rpcClient,Class<T> interfaceClass,NamingService namingService,NamingServiceLoadBalanceStrategy loadBalanceStrategy,FailOverInterceptor failOverInterceptor){
  this.rpcClient=rpcClient;
  this.interfaceClass=interfaceClass;
  this.namingService=namingService;
  this.loadBalanceStrategy=loadBalanceStrategy;
  this.failOverInterceptor=failOverInterceptor;
  if (namingService == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  proxyInstance=(T)new ProxyFactory(interfaceClass,this).getProxy();
}","public HaProtobufRpcProxy(RpcClient rpcClient,Class<T> interfaceClass,NamingService namingService,NamingServiceLoadBalanceStrategyFactory loadBalanceStrategyFactory,FailOverInterceptor failOverInterceptor){
  this.rpcClient=rpcClient;
  this.interfaceClass=interfaceClass;
  this.namingService=namingService;
  this.loadBalanceStrategyFactory=loadBalanceStrategyFactory;
  this.failOverInterceptor=failOverInterceptor;
  if (namingService == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  proxyInstance=(T)new ProxyFactory(interfaceClass,this).getProxy();
}","The original code incorrectly used a direct `NamingServiceLoadBalanceStrategy` parameter, which likely limits flexibility in load balancing strategy selection. The fixed code introduces a `NamingServiceLoadBalanceStrategyFactory`, enabling dynamic strategy creation and more flexible load balancing configuration. This modification allows for runtime strategy selection and enhanced extensibility of the RPC proxy's load balancing mechanism."
94172,"/** 
 * @param servers
 * @return
 * @throws Exception
 */
private void doProxy(String service,List<InetSocketAddress> serversList) throws Exception {
  List<InetSocketAddress> servers=serversList;
  if (CollectionUtils.isEmpty(servers)) {
    servers=new ArrayList<InetSocketAddress>();
  }
  LoadBalanceProxyFactoryBean lbProxyBean=new LoadBalanceProxyFactoryBean();
  lbProxyBean.setServiceInterface(interfaceClass);
  List<ProtobufRpcProxy<T>> protobufRpcProxyList=new ArrayList<ProtobufRpcProxy<T>>();
  Map<String,String> serverUrls=new HashMap<String,String>(servers.size());
  Map<String,Object> targetBeans=new HashMap<String,Object>();
  for (  InetSocketAddress address : servers) {
    String serviceUrl=address.getHostName() + ""String_Node_Str"" + address.getPort();
    serverUrls.put(serviceUrl,serviceUrl);
    ProtobufRpcProxy<T> protobufRpcProxy=onBuildProtobufRpcProxy(rpcClient,interfaceClass);
    protobufRpcProxy.setHost(address.getHostName());
    protobufRpcProxy.setPort(address.getPort());
    protobufRpcProxy.setLookupStubOnStartup(lookupStubOnStartup);
    T rpc=protobufRpcProxy.proxy();
    protobufRpcProxyList.add(protobufRpcProxy);
    targetBeans.put(serviceUrl,rpc);
  }
  if (loadBalanceStrategy == null) {
    loadBalanceStrategy=new RoundRobinLoadBalanceStrategy(service,namingService);
  }
  lbProxyBean.setLoadBalanceStrategy(loadBalanceStrategy);
  if (failOverInterceptor == null) {
    SocketFailOverInterceptor socketFailOverInterceptor=new SocketFailOverInterceptor();
    socketFailOverInterceptor.setRecoverServiceUrls(serverUrls);
    failOverInterceptor=socketFailOverInterceptor;
  }
  lbProxyBean.setFailOverInterceptor(failOverInterceptor);
  lbProxyBean.setTargetBeans(targetBeans);
  lbProxyBean.afterPropertiesSet();
  protobufRpcProxyListMap.put(service,protobufRpcProxyList);
  lbMap.put(service,lbProxyBean);
  instancesMap.put(service,(T)lbProxyBean.getObject());
}","/** 
 * @param servers
 * @return
 * @throws Exception
 */
private void doProxy(String service,List<InetSocketAddress> serversList) throws Exception {
  List<InetSocketAddress> servers=serversList;
  if (CollectionUtils.isEmpty(servers)) {
    servers=new ArrayList<InetSocketAddress>();
  }
  LoadBalanceProxyFactoryBean lbProxyBean=new LoadBalanceProxyFactoryBean();
  lbProxyBean.setServiceInterface(interfaceClass);
  List<ProtobufRpcProxy<T>> protobufRpcProxyList=new ArrayList<ProtobufRpcProxy<T>>();
  Map<String,String> serverUrls=new HashMap<String,String>(servers.size());
  Map<String,Object> targetBeans=new HashMap<String,Object>();
  for (  InetSocketAddress address : servers) {
    String serviceUrl=address.getHostName() + ""String_Node_Str"" + address.getPort();
    serverUrls.put(serviceUrl,serviceUrl);
    ProtobufRpcProxy<T> protobufRpcProxy=onBuildProtobufRpcProxy(rpcClient,interfaceClass);
    protobufRpcProxy.setHost(address.getHostName());
    protobufRpcProxy.setPort(address.getPort());
    protobufRpcProxy.setLookupStubOnStartup(lookupStubOnStartup);
    T rpc=protobufRpcProxy.proxy();
    protobufRpcProxyList.add(protobufRpcProxy);
    targetBeans.put(serviceUrl,rpc);
  }
  if (loadBalanceStrategyFactory == null) {
    loadBalanceStrategyFactory=new RRNamingServiceLoadBalanceStrategyFactory();
  }
  lbProxyBean.setLoadBalanceStrategy(loadBalanceStrategyFactory.create(service,namingService));
  if (failOverInterceptor == null) {
    SocketFailOverInterceptor socketFailOverInterceptor=new SocketFailOverInterceptor();
    socketFailOverInterceptor.setRecoverServiceUrls(serverUrls);
    failOverInterceptor=socketFailOverInterceptor;
  }
  lbProxyBean.setFailOverInterceptor(failOverInterceptor);
  lbProxyBean.setTargetBeans(targetBeans);
  lbProxyBean.afterPropertiesSet();
  protobufRpcProxyListMap.put(service,protobufRpcProxyList);
  lbMap.put(service,lbProxyBean);
  instancesMap.put(service,(T)lbProxyBean.getObject());
}","The original code directly assigned a null load balance strategy without using a strategy factory, which could lead to inflexible load balancing configuration. The fixed code introduces a `loadBalanceStrategyFactory` that dynamically creates load balance strategies based on service and naming service, providing more flexibility and configuration options. This approach enables better service discovery and load balancing by decoupling strategy creation from direct instantiation, making the code more adaptable and maintainable."
94173,"@Override protected void reInit(final String service,final List<InetSocketAddress> list) throws Exception {
  LoadBalanceProxyFactoryBean oldLbProxyBean=lbMap.get(service);
  List<ProtobufRpcProxy<T>> oldProtobufRpcProxyList=new ArrayList<ProtobufRpcProxy<T>>(protobufRpcProxyListMap.get(service));
  loadBalanceStrategy.doReInit(service,new NamingService(){
    @Override public Map<String,List<InetSocketAddress>> list(    Set<String> serviceSignatures) throws Exception {
      Map<String,List<InetSocketAddress>> ret=new HashMap<String,List<InetSocketAddress>>();
      ret.put(service,list);
      return ret;
    }
  }
);
  doProxy(service,list);
  try {
    doClose(oldLbProxyBean,oldProtobufRpcProxyList);
  }
 catch (  Exception e) {
    LOGGER.fatal(e.getMessage(),e);
  }
}","@Override protected void reInit(final String service,final List<InetSocketAddress> list) throws Exception {
  LoadBalanceProxyFactoryBean oldLbProxyBean=lbMap.get(service);
  List<ProtobufRpcProxy<T>> oldProtobufRpcProxyList=new ArrayList<ProtobufRpcProxy<T>>(protobufRpcProxyListMap.get(service));
  doProxy(service,list);
  try {
    doClose(oldLbProxyBean,oldProtobufRpcProxyList);
  }
 catch (  Exception e) {
    LOGGER.fatal(e.getMessage(),e);
  }
}","The original code unnecessarily called `loadBalanceStrategy.doReInit()` with an anonymous `NamingService`, which added complexity without providing additional functionality. In the fixed code, this method call was removed, simplifying the logic and removing redundant service initialization. By eliminating the unnecessary service registration, the code becomes more straightforward, reduces potential points of failure, and maintains the core functionality of reinitializing the proxy for a given service."
94174,"private Method getMethod(Object bean,MethodInvocation invocation) throws Throwable {
  String methodName=invocation.getMethod().getName();
  Method m=bean.getClass().getMethod(methodName,invocation.getMethod().getParameterTypes());
  return m;
}","private Method getMethod(Object bean,MethodInvocation invocation) throws Throwable {
  String methodName=invocation.getMethod().getName();
  if (bean == null) {
    System.out.println(""String_Node_Str"");
  }
  Class<? extends Object> cls=bean.getClass();
  Method m=cls.getMethod(methodName,invocation.getMethod().getParameterTypes());
  return m;
}","The original code lacks a null check for the bean parameter, which could lead to a NullPointerException when attempting to retrieve its class. The fixed code introduces a null check and explicitly retrieves the bean's class using `bean.getClass()`, ensuring safer method invocation. This modification prevents potential runtime errors and adds a basic error logging mechanism, making the method more robust and defensive against unexpected input."
94175,"@Test public void testDynamicServerListChangesAdd() throws Exception {
  testNoServerFail();
  list.add(new InetSocketAddress(1036));
  SleepUtils.dummySleep(2000);
  int serverSize=getNamingService().list(defaultServices).get(DEFAULT_KEY).size();
  Assert.assertEquals(6,serverSize);
  EchoInfo echoInfo=new EchoInfo(DEFAULT_KEY);
  Set<String> returnValues=new HashSet<String>();
  for (int i=0; i < serverSize * 2; i++) {
    EchoInfo echo=proxy.echo(echoInfo);
    returnValues.add(echo.getMessage());
  }
  Assert.assertEquals(6,returnValues.size());
}","@Test public void testDynamicServerListChangesAdd() throws Exception {
  testNoServerFail();
  list.add(new InetSocketAddress(1036));
  SleepUtils.dummySleep(6000);
  int serverSize=getNamingService().list(defaultServices).get(DEFAULT_KEY).size();
  Assert.assertEquals(6,serverSize);
  EchoInfo echoInfo=new EchoInfo(DEFAULT_KEY);
  Set<String> returnValues=new HashSet<String>();
  for (int i=0; i < serverSize * 5; i++) {
    EchoInfo echo=proxy.echo(echoInfo);
    returnValues.add(echo.getMessage());
  }
  Assert.assertEquals(6,returnValues.size());
}","The original code's short sleep time and limited iteration count might not fully capture the dynamic server list update, potentially causing test instability. The fixed code increases sleep duration to 6000ms and expands the iteration count to serverSize * 5, ensuring sufficient time for server list synchronization and comprehensive testing. These modifications enhance test reliability by providing more robust mechanisms to verify dynamic server list changes and load balancing behavior."
94176,"public void run(){
  while (!stopChunkPackageTimeoutClean) {
    if (!tempTrunkPackages.isEmpty()) {
      Map<Long,RpcDataPackage> currentCheckPackage;
      currentCheckPackage=new HashMap<Long,RpcDataPackage>(tempTrunkPackages);
      Iterator<Entry<Long,RpcDataPackage>> iter=currentCheckPackage.entrySet().iterator();
      while (iter.hasNext()) {
        Entry<Long,RpcDataPackage> entry=iter.next();
        if (entry.getValue().getTimeStamp() + chunkPackageTimeout > System.currentTimeMillis()) {
          tempTrunkPackages.remove(entry.getValue());
          LOG.log(Level.SEVERE,""String_Node_Str"" + chunkPackageTimeout + ""String_Node_Str""+ entry.getValue().getRpcMeta().getCorrelationId());
        }
      }
    }
    try {
      Thread.sleep(DEFAULT_CLEANUP_INTERVAL);
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,e.getMessage(),e);
    }
  }
}","public void run(){
  while (!stopChunkPackageTimeoutClean) {
    if (!tempTrunkPackages.isEmpty()) {
      Map<Long,RpcDataPackage> currentCheckPackage;
      currentCheckPackage=new HashMap<Long,RpcDataPackage>(tempTrunkPackages);
      Iterator<Entry<Long,RpcDataPackage>> iter=currentCheckPackage.entrySet().iterator();
      while (iter.hasNext()) {
        Entry<Long,RpcDataPackage> entry=iter.next();
        if (entry.getValue().getTimeStamp() > System.currentTimeMillis() + chunkPackageTimeout) {
          tempTrunkPackages.remove(entry.getKey());
          LOG.log(Level.SEVERE,""String_Node_Str"" + chunkPackageTimeout + ""String_Node_Str""+ entry.getValue().getRpcMeta().getCorrelationId());
        }
      }
    }
    try {
      Thread.sleep(DEFAULT_CLEANUP_INTERVAL);
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,e.getMessage(),e);
    }
  }
}","The original code incorrectly removes packages based on a flawed timeout condition, potentially removing packages prematurely or keeping expired packages in the collection. The fixed code corrects the timeout logic by checking if the package's timestamp exceeds the current time plus the timeout duration, and uses `entry.getKey()` instead of `entry.getValue()` when removing from `tempTrunkPackages`. This ensures accurate timeout detection and proper package removal, preventing potential memory leaks and improving the reliability of package management."
94177,"/** 
 * @param chunkPackageTimeout
 */
public RpcDataPackageDecoder(final int chunkPackageTimeout){
  super();
  if (chunkPackageTimeout <= 0) {
    return;
  }
  es=Executors.newSingleThreadExecutor();
  es.execute(new Runnable(){
    public void run(){
      while (!stopChunkPackageTimeoutClean) {
        if (!tempTrunkPackages.isEmpty()) {
          Map<Long,RpcDataPackage> currentCheckPackage;
          currentCheckPackage=new HashMap<Long,RpcDataPackage>(tempTrunkPackages);
          Iterator<Entry<Long,RpcDataPackage>> iter=currentCheckPackage.entrySet().iterator();
          while (iter.hasNext()) {
            Entry<Long,RpcDataPackage> entry=iter.next();
            if (entry.getValue().getTimeStamp() + chunkPackageTimeout > System.currentTimeMillis()) {
              tempTrunkPackages.remove(entry.getValue());
              LOG.log(Level.SEVERE,""String_Node_Str"" + chunkPackageTimeout + ""String_Node_Str""+ entry.getValue().getRpcMeta().getCorrelationId());
            }
          }
        }
        try {
          Thread.sleep(DEFAULT_CLEANUP_INTERVAL);
        }
 catch (        Exception e) {
          LOG.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
);
}","/** 
 * @param chunkPackageTimeout
 */
public RpcDataPackageDecoder(final int chunkPackageTimeout){
  super();
  if (chunkPackageTimeout <= 0) {
    return;
  }
  es=Executors.newSingleThreadExecutor();
  es.execute(new Runnable(){
    public void run(){
      while (!stopChunkPackageTimeoutClean) {
        if (!tempTrunkPackages.isEmpty()) {
          Map<Long,RpcDataPackage> currentCheckPackage;
          currentCheckPackage=new HashMap<Long,RpcDataPackage>(tempTrunkPackages);
          Iterator<Entry<Long,RpcDataPackage>> iter=currentCheckPackage.entrySet().iterator();
          while (iter.hasNext()) {
            Entry<Long,RpcDataPackage> entry=iter.next();
            if (entry.getValue().getTimeStamp() > System.currentTimeMillis() + chunkPackageTimeout) {
              tempTrunkPackages.remove(entry.getKey());
              LOG.log(Level.SEVERE,""String_Node_Str"" + chunkPackageTimeout + ""String_Node_Str""+ entry.getValue().getRpcMeta().getCorrelationId());
            }
          }
        }
        try {
          Thread.sleep(DEFAULT_CLEANUP_INTERVAL);
        }
 catch (        Exception e) {
          LOG.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
);
}","The original code incorrectly removed packages based on an inverted timestamp condition, potentially keeping expired packages in the collection. In the fixed code, the condition is corrected to `entry.getValue().getTimeStamp() > System.currentTimeMillis() + chunkPackageTimeout`, and packages are removed using `tempTrunkPackages.remove(entry.getKey())` to properly clean up timed-out packages. This ensures accurate package timeout management and prevents memory leaks by correctly identifying and removing packages that have exceeded the specified timeout."
94178,"@Override protected Object encode(ChannelHandlerContext ctx,Channel channel,Object msg) throws Exception {
  if (!(msg instanceof RpcDataPackage)) {
    return msg;
  }
  RpcDataPackage dataPackage=(RpcDataPackage)msg;
  byte[] encodeBytes=dataPackage.write();
  if (encodeBytes != null) {
    LOG.log(Level.FINE,""String_Node_Str"" + encodeBytes.length);
  }
  ChannelBuffer encodedMessage=ChannelBuffers.copiedBuffer(ctx.getChannel().getConfig().getBufferFactory().getDefaultOrder(),encodeBytes);
  if (chunkSize < 0) {
    return encodedMessage;
  }
  List<RpcDataPackage> list=dataPackage.chunk(chunkSize);
  LOG.log(Level.SEVERE,""String_Node_Str"" + dataPackage.getRpcMeta().getCorrelationId() + ""String_Node_Str""+ list.size()+ ""String_Node_Str"");
  for (  RpcDataPackage rpcDataPackage : list) {
    encodeBytes=rpcDataPackage.write();
    encodedMessage=ChannelBuffers.copiedBuffer(ctx.getChannel().getConfig().getBufferFactory().getDefaultOrder(),encodeBytes);
    write(channel,encodedMessage);
  }
  return null;
}","@Override protected Object encode(ChannelHandlerContext ctx,Channel channel,Object msg) throws Exception {
  if (!(msg instanceof RpcDataPackage)) {
    return msg;
  }
  RpcDataPackage dataPackage=(RpcDataPackage)msg;
  byte[] encodeBytes=dataPackage.write();
  if (encodeBytes != null) {
    LOG.log(Level.FINE,""String_Node_Str"" + encodeBytes.length);
  }
  ChannelBuffer encodedMessage=ChannelBuffers.copiedBuffer(ctx.getChannel().getConfig().getBufferFactory().getDefaultOrder(),encodeBytes);
  if (chunkSize < 0) {
    return encodedMessage;
  }
  List<RpcDataPackage> list=dataPackage.chunk(chunkSize);
  LOG.log(Level.FINE,""String_Node_Str"" + dataPackage.getRpcMeta().getCorrelationId() + ""String_Node_Str""+ list.size()+ ""String_Node_Str""+ chunkSize+ ""String_Node_Str"");
  for (  RpcDataPackage rpcDataPackage : list) {
    encodeBytes=rpcDataPackage.write();
    encodedMessage=ChannelBuffers.copiedBuffer(ctx.getChannel().getConfig().getBufferFactory().getDefaultOrder(),encodeBytes);
    write(channel,encodedMessage);
  }
  return null;
}","The original code logged chunking errors at a severe level, which could mask important system warnings. The fixed code changes the log level to FINE and adds the chunkSize to the log message, providing more context for debugging. This modification allows for better traceability and understanding of the chunking process without raising unnecessary alarm levels."
94179,"@Test public void testGetRpcMethodMeta(){
  RpcClient rpcClient=new RpcClient();
  ProtobufRpcProxy<RpcServiceMetaService> pbrpcProxy=new ProtobufRpcProxy<RpcServiceMetaService>(rpcClient,RpcServiceMetaService.class);
  pbrpcProxy.setPort(PORT);
  RpcServiceMetaService proxy=pbrpcProxy.proxy();
  RpcServiceMetaList rpcServiceMetaInfo=proxy.getRpcServiceMetaInfo();
  Assert.assertEquals(4,rpcServiceMetaInfo.getRpcServiceMetas().size());
  List<RpcServiceMeta> rpcServiceMetas=rpcServiceMetaInfo.getRpcServiceMetas();
  for (  RpcServiceMeta rpcServiceMeta : rpcServiceMetas) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getServiceName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getMethodName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getInputProto());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getOutputProto());
  }
}","@Test public void testGetRpcMethodMeta(){
  RpcClient rpcClient=new RpcClient();
  ProtobufRpcProxy<RpcServiceMetaService> pbrpcProxy=new ProtobufRpcProxy<RpcServiceMetaService>(rpcClient,RpcServiceMetaService.class);
  pbrpcProxy.setPort(PORT);
  RpcServiceMetaService proxy=pbrpcProxy.proxy();
  RpcServiceMetaList rpcServiceMetaInfo=proxy.getRpcServiceMetaInfo();
  Assert.assertEquals(5,rpcServiceMetaInfo.getRpcServiceMetas().size());
  List<RpcServiceMeta> rpcServiceMetas=rpcServiceMetaInfo.getRpcServiceMetas();
  for (  RpcServiceMeta rpcServiceMeta : rpcServiceMetas) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getServiceName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getMethodName());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getInputProto());
    System.out.println(""String_Node_Str"" + rpcServiceMeta.getOutputProto());
  }
}","The original code incorrectly asserted that the RPC service meta list contained 4 service metas. The fixed code updates the assertion to 5, reflecting the correct number of service metadata entries in the list. This change ensures the test accurately validates the complete set of RPC service metadata, preventing potential false test passes and improving the reliability of the service meta retrieval verification."
94180,"/** 
 * @param method
 * @param protobufPRC
 */
public PojoRpcMethodInfo(Method method,ProtobufPRC protobufPRC){
  super(method,protobufPRC);
  Class<? extends Object> inputClass=getInputClass();
  if (inputClass != null) {
    inputCodec=ProtobufProxy.create(inputClass);
  }
  Class<? extends Object> outputClass=getOutputClass();
  if (inputClass != null) {
    outputCodec=ProtobufProxy.create(outputClass);
  }
}","/** 
 * @param method
 * @param protobufPRC
 */
public PojoRpcMethodInfo(Method method,ProtobufPRC protobufPRC){
  super(method,protobufPRC);
  Class<? extends Object> inputClass=getInputClass();
  if (inputClass != null) {
    inputCodec=ProtobufProxy.create(inputClass);
  }
  Class<? extends Object> outputClass=getOutputClass();
  if (outputClass != null) {
    outputCodec=ProtobufProxy.create(outputClass);
  }
}","The buggy code incorrectly checked `inputClass` instead of `outputClass` when creating the output codec, potentially leading to null pointer exceptions or incorrect codec initialization. The fixed code replaces the incorrect condition with `if (outputClass != null)`, ensuring that the output codec is created only when the output class is present. This correction prevents potential runtime errors and ensures proper codec creation for both input and output classes."
94181,"/** 
 * @param method
 * @param protobufPRC
 */
public PojoRpcMethodInfo(Method method,ProtobufPRC protobufPRC){
  super(method,protobufPRC);
  Class<? extends Object> inputClass=getInputClass();
  if (inputClass != null) {
    inputCodec=ProtobufProxy.create(inputClass);
  }
  Class<? extends Object> outputClass=getOutputClass();
  if (inputClass != null) {
    outputCodec=ProtobufProxy.create(outputClass);
  }
}","/** 
 * @param method
 * @param protobufPRC
 */
public PojoRpcMethodInfo(Method method,ProtobufPRC protobufPRC){
  super(method,protobufPRC);
  Class<? extends Object> inputClass=getInputClass();
  if (inputClass != null) {
    inputCodec=ProtobufProxy.create(inputClass);
  }
  Class<? extends Object> outputClass=getOutputClass();
  if (outputClass != null) {
    outputCodec=ProtobufProxy.create(outputClass);
  }
}","The original code incorrectly checked `inputClass` instead of `outputClass` when creating the output codec, potentially leading to null pointer exceptions or incorrect codec generation. In the fixed code, the condition is corrected to check `outputClass != null` before creating the output codec, ensuring proper null validation. This modification prevents potential runtime errors and ensures that output codecs are created only when the output class is available."
94182,"public RpcData doHandle(RpcData data) throws Exception {
  Object input=null;
  Object[] param;
  Object ret;
  if (data.getData() != null && parseFromMethod != null) {
    input=parseFromMethod.invoke(getInputClass(),new ByteArrayInputStream(data.getData()));
    ;
    param=new Object[]{input};
  }
 else {
    param=new Object[0];
  }
  RpcData retData=new RpcData();
  if (getAttachmentHandler() != null) {
    byte[] responseAttachment=getAttachmentHandler().handleAttachement(data.getAttachment(),getServiceName(),getMethodName(),param);
    retData.setAttachment(responseAttachment);
  }
  ret=getMethod().invoke(getService(),param);
  if (ret == null) {
    return retData;
  }
  if (ret != null && ret instanceof GeneratedMessage) {
    byte[] response=((GeneratedMessage)input).toByteArray();
    retData.setData(response);
  }
  return retData;
}","public RpcData doHandle(RpcData data) throws Exception {
  Object input=null;
  Object[] param;
  Object ret;
  if (data.getData() != null && parseFromMethod != null) {
    input=parseFromMethod.invoke(getInputClass(),new ByteArrayInputStream(data.getData()));
    ;
    param=new Object[]{input};
  }
 else {
    param=new Object[0];
  }
  RpcData retData=new RpcData();
  if (getAttachmentHandler() != null) {
    byte[] responseAttachment=getAttachmentHandler().handleAttachement(data.getAttachment(),getServiceName(),getMethodName(),param);
    retData.setAttachment(responseAttachment);
  }
  ret=getMethod().invoke(getService(),param);
  if (ret == null) {
    return retData;
  }
  if (ret != null && ret instanceof GeneratedMessage) {
    byte[] response=((GeneratedMessage)ret).toByteArray();
    retData.setData(response);
  }
  return retData;
}","The buggy code incorrectly used `input` instead of `ret` when converting the response to a byte array, which would cause a ClassCastException or return incorrect data. In the fixed code, `((GeneratedMessage)ret).toByteArray()` correctly serializes the method's return value to bytes. This ensures the response is properly converted and set in the RpcData, resolving the potential runtime error and maintaining the intended data transformation logic."
94183,"private void doRegiterService(Method method,Object service,ProtobufPRCService protobufPRCService){
  boolean messageType=RpcMethodInfo.isMessageType(method);
  if (!messageType) {
    AnnotationRpcHandler rpcHandler=new AnnotationRpcHandler(method,service,protobufPRCService);
    if (StringUtils.isEmpty(rpcHandler.getServiceName())) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    serviceMap.put(getMethodSignature(rpcHandler.getServiceName(),rpcHandler.getMethodName()),rpcHandler);
  }
 else {
  }
}","private void doRegiterService(Method method,Object service,ProtobufPRCService protobufPRCService){
  boolean messageType=RpcMethodInfo.isMessageType(method);
  AbstractRpcHandler rpcHandler;
  if (!messageType) {
    rpcHandler=new AnnotationRpcHandler(method,service,protobufPRCService);
  }
 else {
    rpcHandler=new MessageGeneratedRpcHandler(method,service,protobufPRCService);
  }
  if (StringUtils.isEmpty(rpcHandler.getServiceName())) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  serviceMap.put(getMethodSignature(rpcHandler.getServiceName(),rpcHandler.getMethodName()),rpcHandler);
}","The original code had an incomplete handling of message type methods, leaving the else branch empty and potentially skipping important registration logic. The fixed code introduces a new MessageGeneratedRpcHandler for message type methods, ensuring consistent handler creation across different method types. This modification provides a more robust and comprehensive service registration mechanism by treating both annotation and message-generated methods uniformly."
94184,"public static TvInput getTvInput(){
  return sTvInput;
}","public static TvInput getTvInput(Context context){
  if (sTvInput == null) {
    getRichChannels(context);
  }
  return sTvInput;
}","The original code lacks proper initialization checks for the `sTvInput` static variable, potentially returning null or uninitialized data. The fixed code introduces a context parameter and adds a null check that triggers initialization through the `getRichChannels()` method before returning the value. By conditionally initializing `sTvInput` only when needed and ensuring a valid context is available, the revised implementation provides a more robust and safe method for retrieving TV input data."
94185,"@Override public void onCreate(Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  super.onCreate(savedInstanceState);
  mInputId=getActivity().getIntent().getStringExtra(TvInputInfo.EXTRA_INPUT_ID);
  getChannels();
  mDorPresenter=new DetailsOverviewRowPresenter(new DetailsDescriptionPresenter());
  BackgroundManager backgroundManager=BackgroundManager.getInstance(getActivity());
  backgroundManager.attach(getActivity().getWindow());
  mBackgroundTarget=new PicassoBackgroundManagerTarget(backgroundManager);
  mDefaultBackground=getResources().getDrawable(R.drawable.default_background);
  mMetrics=new DisplayMetrics();
  getActivity().getWindowManager().getDefaultDisplay().getMetrics(mMetrics);
  Log.d(TAG,""String_Node_Str"" + mInputId);
  new SetupRowTask().execute(mChannels);
  mDorPresenter.setSharedElementEnterTransition(getActivity(),""String_Node_Str"");
  boolean hasChannels=TvContractUtils.getChannelCount(getActivity().getContentResolver(),mInputId) > 0;
  mAddChannelAction=new Action(ACTION_ADD_CHANNELS,getResources().getString(hasChannels ? R.string.rich_setup_update_channel : R.string.rich_setup_add_channel));
  mCancelAction=new Action(ACTION_CANCEL,getResources().getString(R.string.rich_setup_cancel));
  mInProgressAction=new Action(ACTION_IN_PROGRESS,getResources().getString(R.string.rich_setup_in_progress));
}","@Override public void onCreate(Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  super.onCreate(savedInstanceState);
  mInputId=getActivity().getIntent().getStringExtra(TvInputInfo.EXTRA_INPUT_ID);
  new SetupRowTask().execute();
}","The original code was overly complex, performing multiple unnecessary operations like background management, metrics calculation, and creating multiple actions before executing the SetupRowTask. The fixed code simplifies the onCreate method by removing extraneous setup steps and directly executing SetupRowTask with no parameters, focusing on the core task of initializing the setup process. This streamlined approach reduces potential points of failure, improves code readability, and ensures a more focused and efficient initialization of the activity or fragment."
94186,"protected void updateBackground(String uri){
  Picasso.with(getActivity()).load(uri).resize(mMetrics.widthPixels,mMetrics.heightPixels).error(mDefaultBackground).into(mBackgroundTarget);
}","protected void updateBackground(String uri){
  BackgroundManager backgroundManager=BackgroundManager.getInstance(getActivity());
  backgroundManager.attach(getActivity().getWindow());
  mBackgroundTarget=new PicassoBackgroundManagerTarget(backgroundManager);
  mDefaultBackground=getResources().getDrawable(R.drawable.default_background);
  mMetrics=new DisplayMetrics();
  getActivity().getWindowManager().getDefaultDisplay().getMetrics(mMetrics);
  Picasso.with(getActivity()).load(uri).resize(mMetrics.widthPixels,mMetrics.heightPixels).error(mDefaultBackground).into(mBackgroundTarget);
}","The original code lacked proper initialization of background management components, potentially causing null pointer exceptions and rendering issues. The fixed code properly initializes the BackgroundManager, creates a custom background target, sets the default background drawable, and retrieves display metrics before loading the image. These changes ensure robust background image loading with proper error handling and device-specific scaling, improving the reliability and visual consistency of the background display."
94187,"@Override protected DetailsOverviewRow doInBackground(List<ChannelInfo>... channels){
  while (running) {
    Log.d(TAG,""String_Node_Str"" + mInputId);
    DetailsOverviewRow row=new DetailsOverviewRow(mTvInput);
    try {
      Bitmap poster=Picasso.with(getActivity()).load(mTvInput.logoBackgroundUrl).resize(convertDpToPixel(getActivity().getApplicationContext(),DETAIL_THUMB_WIDTH),convertDpToPixel(getActivity().getApplicationContext(),DETAIL_THUMB_HEIGHT)).centerCrop().get();
      row.setImageBitmap(getActivity(),poster);
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
    row.addAction(mAddChannelAction);
    row.addAction(mCancelAction);
    return row;
  }
  return null;
}","@Override protected Bitmap doInBackground(Uri... params){
  mChannels=RichFeedUtil.getRichChannels(getActivity());
  mTvInput=RichFeedUtil.getTvInput(getActivity());
  if (mTvInput != null) {
    return getPoster();
  }
 else {
    publishProgress(getResources().getString(R.string.feed_error_message));
    return null;
  }
}","The original code had a problematic infinite loop with no exit condition, risked potential null pointer exceptions, and did not handle background processing efficiently. The fixed code replaces the loop with a more focused background task that retrieves TV input and channels using utility methods, and conditionally processes the poster image. By introducing robust error handling, proper method signature, and streamlined background processing, the revised implementation provides a more reliable and predictable asynchronous task execution."
94188,"@Override protected void onPostExecute(final DetailsOverviewRow detailRow){
  if (!running) {
    return;
  }
  ClassPresenterSelector presenterSelector=new ClassPresenterSelector();
  mDorPresenter.setBackgroundColor(getResources().getColor(R.color.detail_background));
  mDorPresenter.setStyleLarge(true);
  updateBackground(mTvInput.logoBackgroundUrl);
  mDorPresenter.setOnActionClickedListener(new OnActionClickedListener(){
    @Override public void onActionClicked(    Action action){
      if (action.getId() == ACTION_ADD_CHANNELS) {
        setupChannels(mInputId);
      }
 else       if (action.getId() == ACTION_CANCEL) {
        getActivity().finish();
      }
    }
  }
);
  presenterSelector.addClassPresenter(DetailsOverviewRow.class,mDorPresenter);
  presenterSelector.addClassPresenter(ListRow.class,new ListRowPresenter());
  mAdapter=new ArrayObjectAdapter(presenterSelector);
  mAdapter.add(detailRow);
  setAdapter(mAdapter);
}","@Override protected void onPostExecute(Bitmap poster){
  if (poster != null) {
    addSetupChannelDetailedRow(poster);
    updateBackground(mTvInput.logoBackgroundUrl);
  }
}","The original code lacks proper error handling and has an overly complex implementation with multiple responsibilities in the onPostExecute method. The fixed code simplifies the method by checking for a valid poster bitmap and directly calling a focused method to add a detailed row, removing unnecessary complexity. This refactoring improves code readability, reduces potential errors, and provides a more streamlined approach to handling post-execution tasks in an asynchronous operation."
94189,"private void setupChannels(String inputId){
  if (mChannels == null || mServiceClass == null) {
    return;
  }
  TvContractUtils.updateChannels(getActivity(),inputId,mChannels);
  SyncUtils.setUpPeriodicSync(getActivity(),inputId);
  SyncUtils.requestSync(inputId);
  mSyncRequested=true;
  if (mSyncObserverHandle == null) {
    final int mask=ContentResolver.SYNC_OBSERVER_TYPE_PENDING | ContentResolver.SYNC_OBSERVER_TYPE_ACTIVE;
    mSyncObserverHandle=ContentResolver.addStatusChangeListener(mask,mSyncStatusObserver);
  }
}","private void setupChannels(String inputId){
  if (mChannels == null) {
    return;
  }
  TvContractUtils.updateChannels(getActivity(),inputId,mChannels);
  SyncUtils.setUpPeriodicSync(getActivity(),inputId);
  SyncUtils.requestSync(inputId);
  mSyncRequested=true;
  if (mSyncObserverHandle == null) {
    final int mask=ContentResolver.SYNC_OBSERVER_TYPE_PENDING | ContentResolver.SYNC_OBSERVER_TYPE_ACTIVE;
    mSyncObserverHandle=ContentResolver.addStatusChangeListener(mask,mSyncStatusObserver);
  }
}","The original code unnecessarily checks for `mServiceClass` before proceeding, which is irrelevant to channel setup and could prevent valid channel synchronization. The fixed code removes the redundant `mServiceClass` check, focusing only on verifying that `mChannels` is not null before performing channel updates and synchronization. This modification ensures more precise and reliable channel setup by eliminating an unnecessary condition that might block legitimate synchronization processes."
94190,"/** 
 * Called periodically by the system in every   {@code SYNC_FREQUENCY_SEC}.
 */
@Override public void onPerformSync(Account account,Bundle extras,String authority,ContentProviderClient provider,SyncResult syncResult){
  Log.d(TAG,""String_Node_Str"" + account + ""String_Node_Str""+ authority+ ""String_Node_Str""+ extras+ ""String_Node_Str"");
  String inputId=extras.getString(SyncAdapter.BUNDLE_KEY_INPUT_ID);
  if (inputId == null) {
    return;
  }
  List<ChannelInfo> channels=RichFeedUtil.createRichChannelsStatic(mContext);
  LongSparseArray<ChannelInfo> channelMap=TvContractUtils.buildChannelMap(mContext.getContentResolver(),inputId,channels);
  for (int i=0; i < channelMap.size(); ++i) {
    Uri channelUri=TvContract.buildChannelUri(channelMap.keyAt(i));
    insertPrograms(channelUri,channelMap.valueAt(i));
  }
}","/** 
 * Called periodically by the system in every   {@code SYNC_FREQUENCY_SEC}.
 */
@Override public void onPerformSync(Account account,Bundle extras,String authority,ContentProviderClient provider,SyncResult syncResult){
  Log.d(TAG,""String_Node_Str"" + account + ""String_Node_Str""+ authority+ ""String_Node_Str""+ extras+ ""String_Node_Str"");
  String inputId=extras.getString(SyncAdapter.BUNDLE_KEY_INPUT_ID);
  if (inputId == null) {
    return;
  }
  List<ChannelInfo> channels=RichFeedUtil.getRichChannels(mContext);
  LongSparseArray<ChannelInfo> channelMap=TvContractUtils.buildChannelMap(mContext.getContentResolver(),inputId,channels);
  for (int i=0; i < channelMap.size(); ++i) {
    Uri channelUri=TvContract.buildChannelUri(channelMap.keyAt(i));
    insertPrograms(channelUri,channelMap.valueAt(i));
  }
}","The original code used `RichFeedUtil.createRichChannelsStatic()`, which likely does not exist or is an incorrect method for retrieving channels. The fixed code replaces this with `RichFeedUtil.getRichChannels()`, a proper method for fetching channel information from the context. This change ensures correct channel retrieval, preventing potential null pointer exceptions or incomplete channel data, and maintains the sync adapter's reliability in populating channel programs."
94191,"public static TvInput getTvInput(){
  return sTvInput;
}","public static TvInput getTvInput(Context context){
  if (sTvInput == null) {
    getRichChannels(context);
  }
  return sTvInput;
}","The original code assumes sTvInput is always initialized, potentially leading to null pointer exceptions if not properly set beforehand. The fixed code introduces a context parameter and adds a null check that calls getRichChannels() to ensure sTvInput is initialized before returning. This approach provides a more robust getter method that automatically handles initialization, preventing potential runtime errors and improving the method's reliability."
94192,"@Override public void onCreate(Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  super.onCreate(savedInstanceState);
  mInputId=getActivity().getIntent().getStringExtra(TvInputInfo.EXTRA_INPUT_ID);
  getChannels();
  mDorPresenter=new DetailsOverviewRowPresenter(new DetailsDescriptionPresenter());
  BackgroundManager backgroundManager=BackgroundManager.getInstance(getActivity());
  backgroundManager.attach(getActivity().getWindow());
  mBackgroundTarget=new PicassoBackgroundManagerTarget(backgroundManager);
  mDefaultBackground=getResources().getDrawable(R.drawable.default_background);
  mMetrics=new DisplayMetrics();
  getActivity().getWindowManager().getDefaultDisplay().getMetrics(mMetrics);
  Log.d(TAG,""String_Node_Str"" + mInputId);
  new SetupRowTask().execute(mChannels);
  mDorPresenter.setSharedElementEnterTransition(getActivity(),""String_Node_Str"");
  boolean hasChannels=TvContractUtils.getChannelCount(getActivity().getContentResolver(),mInputId) > 0;
  mAddChannelAction=new Action(ACTION_ADD_CHANNELS,getResources().getString(hasChannels ? R.string.rich_setup_update_channel : R.string.rich_setup_add_channel));
  mCancelAction=new Action(ACTION_CANCEL,getResources().getString(R.string.rich_setup_cancel));
  mInProgressAction=new Action(ACTION_IN_PROGRESS,getResources().getString(R.string.rich_setup_in_progress));
}","@Override public void onCreate(Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  super.onCreate(savedInstanceState);
  mInputId=getActivity().getIntent().getStringExtra(TvInputInfo.EXTRA_INPUT_ID);
  new SetupRowTask().execute();
}","The original code contained multiple unnecessary method calls and setup tasks that cluttered the onCreate() method, potentially causing performance and initialization issues. The fixed code streamlines the method by removing extraneous setup logic and simplifying the execution of SetupRowTask with an empty parameter. This refactoring reduces code complexity, improves method readability, and minimizes potential runtime overhead by eliminating redundant initialization steps."
94193,"protected void updateBackground(String uri){
  Picasso.with(getActivity()).load(uri).resize(mMetrics.widthPixels,mMetrics.heightPixels).error(mDefaultBackground).into(mBackgroundTarget);
}","protected void updateBackground(String uri){
  BackgroundManager backgroundManager=BackgroundManager.getInstance(getActivity());
  backgroundManager.attach(getActivity().getWindow());
  mBackgroundTarget=new PicassoBackgroundManagerTarget(backgroundManager);
  mDefaultBackground=getResources().getDrawable(R.drawable.default_background);
  mMetrics=new DisplayMetrics();
  getActivity().getWindowManager().getDefaultDisplay().getMetrics(mMetrics);
  Picasso.with(getActivity()).load(uri).resize(mMetrics.widthPixels,mMetrics.heightPixels).error(mDefaultBackground).into(mBackgroundTarget);
}","The original code lacked proper initialization of background-related components like BackgroundManager and metrics, leading to potential null pointer exceptions or incorrect background rendering. The fixed code explicitly initializes BackgroundManager, creates a custom background target, retrieves display metrics, and sets a default background drawable before loading the image. These changes ensure robust background loading, prevent runtime errors, and provide a more reliable method for updating the activity's background image."
94194,"@Override protected DetailsOverviewRow doInBackground(List<ChannelInfo>... channels){
  while (running) {
    Log.d(TAG,""String_Node_Str"" + mInputId);
    DetailsOverviewRow row=new DetailsOverviewRow(mTvInput);
    try {
      Bitmap poster=Picasso.with(getActivity()).load(mTvInput.logoBackgroundUrl).resize(convertDpToPixel(getActivity().getApplicationContext(),DETAIL_THUMB_WIDTH),convertDpToPixel(getActivity().getApplicationContext(),DETAIL_THUMB_HEIGHT)).centerCrop().get();
      row.setImageBitmap(getActivity(),poster);
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
    row.addAction(mAddChannelAction);
    row.addAction(mCancelAction);
    return row;
  }
  return null;
}","@Override protected Bitmap doInBackground(Uri... params){
  mChannels=RichFeedUtil.getRichChannels(getActivity());
  mTvInput=RichFeedUtil.getTvInput(getActivity());
  if (mTvInput != null) {
    return getPoster();
  }
 else {
    publishProgress(getResources().getString(R.string.feed_error_message));
    return null;
  }
}","The original code has an infinite loop and improperly handles background processing, with inconsistent parameter types and potential resource leaks. The fixed code replaces the problematic implementation with a more robust approach, introducing proper parameter handling, extracting logo retrieval into a separate method, and adding error checking for TV input availability. By implementing a cleaner background task with clear parameter validation and streamlined logic, the revised code ensures more reliable and predictable asynchronous image loading and processing."
94195,"@Override protected void onPostExecute(final DetailsOverviewRow detailRow){
  if (!running) {
    return;
  }
  ClassPresenterSelector presenterSelector=new ClassPresenterSelector();
  mDorPresenter.setBackgroundColor(getResources().getColor(R.color.detail_background));
  mDorPresenter.setStyleLarge(true);
  updateBackground(mTvInput.logoBackgroundUrl);
  mDorPresenter.setOnActionClickedListener(new OnActionClickedListener(){
    @Override public void onActionClicked(    Action action){
      if (action.getId() == ACTION_ADD_CHANNELS) {
        setupChannels(mInputId);
      }
 else       if (action.getId() == ACTION_CANCEL) {
        getActivity().finish();
      }
    }
  }
);
  presenterSelector.addClassPresenter(DetailsOverviewRow.class,mDorPresenter);
  presenterSelector.addClassPresenter(ListRow.class,new ListRowPresenter());
  mAdapter=new ArrayObjectAdapter(presenterSelector);
  mAdapter.add(detailRow);
  setAdapter(mAdapter);
}","@Override protected void onPostExecute(Bitmap poster){
  if (poster != null) {
    addSetupChannelDetailedRow(poster);
    updateBackground(mTvInput.logoBackgroundUrl);
  }
}","The original code lacks proper error handling and contains multiple responsibilities within a single method, making it complex and hard to maintain. The fixed code simplifies the method by focusing on poster validation, creating a dedicated row only when a valid bitmap is available, and separating concerns more cleanly. This approach improves code readability, reduces potential runtime errors, and ensures more robust handling of detail row creation with a poster image."
94196,"private void setupChannels(String inputId){
  if (mChannels == null || mServiceClass == null) {
    return;
  }
  TvContractUtils.updateChannels(getActivity(),inputId,mChannels);
  SyncUtils.setUpPeriodicSync(getActivity(),inputId);
  SyncUtils.requestSync(inputId);
  mSyncRequested=true;
  if (mSyncObserverHandle == null) {
    final int mask=ContentResolver.SYNC_OBSERVER_TYPE_PENDING | ContentResolver.SYNC_OBSERVER_TYPE_ACTIVE;
    mSyncObserverHandle=ContentResolver.addStatusChangeListener(mask,mSyncStatusObserver);
  }
}","private void setupChannels(String inputId){
  if (mChannels == null) {
    return;
  }
  TvContractUtils.updateChannels(getActivity(),inputId,mChannels);
  SyncUtils.setUpPeriodicSync(getActivity(),inputId);
  SyncUtils.requestSync(inputId);
  mSyncRequested=true;
  if (mSyncObserverHandle == null) {
    final int mask=ContentResolver.SYNC_OBSERVER_TYPE_PENDING | ContentResolver.SYNC_OBSERVER_TYPE_ACTIVE;
    mSyncObserverHandle=ContentResolver.addStatusChangeListener(mask,mSyncStatusObserver);
  }
}","The original code unnecessarily checks for `mServiceClass` before proceeding, which is an irrelevant condition for channel setup. The fixed code removes the `mServiceClass` check, focusing only on verifying that `mChannels` is not null before updating channels and initiating synchronization. This simplifies the method, making it more focused and reducing potential unnecessary complexity while maintaining the core synchronization logic."
94197,"/** 
 * Called periodically by the system in every   {@code SYNC_FREQUENCY_SEC}.
 */
@Override public void onPerformSync(Account account,Bundle extras,String authority,ContentProviderClient provider,SyncResult syncResult){
  Log.d(TAG,""String_Node_Str"" + account + ""String_Node_Str""+ authority+ ""String_Node_Str""+ extras+ ""String_Node_Str"");
  String inputId=extras.getString(SyncAdapter.BUNDLE_KEY_INPUT_ID);
  if (inputId == null) {
    return;
  }
  List<ChannelInfo> channels=RichFeedUtil.createRichChannelsStatic(mContext);
  LongSparseArray<ChannelInfo> channelMap=TvContractUtils.buildChannelMap(mContext.getContentResolver(),inputId,channels);
  for (int i=0; i < channelMap.size(); ++i) {
    Uri channelUri=TvContract.buildChannelUri(channelMap.keyAt(i));
    insertPrograms(channelUri,channelMap.valueAt(i));
  }
}","/** 
 * Called periodically by the system in every   {@code SYNC_FREQUENCY_SEC}.
 */
@Override public void onPerformSync(Account account,Bundle extras,String authority,ContentProviderClient provider,SyncResult syncResult){
  Log.d(TAG,""String_Node_Str"" + account + ""String_Node_Str""+ authority+ ""String_Node_Str""+ extras+ ""String_Node_Str"");
  String inputId=extras.getString(SyncAdapter.BUNDLE_KEY_INPUT_ID);
  if (inputId == null) {
    return;
  }
  List<ChannelInfo> channels=RichFeedUtil.getRichChannels(mContext);
  LongSparseArray<ChannelInfo> channelMap=TvContractUtils.buildChannelMap(mContext.getContentResolver(),inputId,channels);
  for (int i=0; i < channelMap.size(); ++i) {
    Uri channelUri=TvContract.buildChannelUri(channelMap.keyAt(i));
    insertPrograms(channelUri,channelMap.valueAt(i));
  }
}","The buggy code uses `RichFeedUtil.createRichChannelsStatic()`, which likely doesn't exist or is an incorrect method for retrieving channel information. The fixed code replaces this with `RichFeedUtil.getRichChannels()`, which appears to be the correct method for fetching channel data from the context. This change ensures proper channel retrieval, preventing potential null or incorrect channel lists and improving the reliability of the sync process by using the appropriate channel generation method."
94198,"private static ChannelInfo parseChannel(XmlPullParser parser) throws XmlPullParserException, IOException {
  String displayNumber=null;
  String displayName=null;
  int videoWidth=0;
  int videoHeight=0;
  int audioChannelCount=0;
  boolean hasClosedCaption=false;
  String logoUrl=null;
  StringBuilder hashString=new StringBuilder();
  for (int i=0; i < parser.getAttributeCount(); ++i) {
    String attr=parser.getAttributeName(i);
    String value=parser.getAttributeValue(i);
    hashString.append(attr).append(""String_Node_Str"").append(value).append(""String_Node_Str"");
    if (ATTR_DISPLAY_NUMBER.equals(attr)) {
      displayNumber=value;
    }
 else     if (ATTR_DISPLAY_NAME.equals(attr)) {
      displayName=value;
    }
 else     if (ATTR_VIDEO_WIDTH.equals(attr)) {
      videoWidth=Integer.parseInt(value);
    }
 else     if (ATTR_VIDEO_HEIGHT.equals(attr)) {
      videoHeight=Integer.parseInt(value);
    }
 else     if (ATTR_LOGO_URL.equals(attr)) {
      logoUrl=value;
    }
  }
  List<ProgramInfo> programs=new ArrayList<>();
  while (parser.next() != XmlPullParser.END_DOCUMENT) {
    if (parser.getEventType() == XmlPullParser.START_TAG) {
      if (TAG_PROGRAM.equals(parser.getName())) {
        programs.add(parseProgram(parser));
      }
    }
 else     if (TAG_CHANNEL.equals(parser.getName()) && parser.getEventType() == XmlPullParser.END_TAG) {
      break;
    }
  }
  int fakeOriginalNetworkId=hashString.toString().hashCode();
  return new ChannelInfo(displayNumber,displayName,logoUrl,0,0,fakeOriginalNetworkId,videoWidth,videoHeight,audioChannelCount,hasClosedCaption,programs);
}","private static ChannelInfo parseChannel(XmlPullParser parser) throws XmlPullParserException, IOException {
  String displayNumber=null;
  String displayName=null;
  int videoWidth=0;
  int videoHeight=0;
  int audioChannelCount=0;
  boolean hasClosedCaption=false;
  String logoUrl=null;
  StringBuilder hashString=new StringBuilder();
  for (int i=0; i < parser.getAttributeCount(); ++i) {
    String attr=parser.getAttributeName(i);
    String value=parser.getAttributeValue(i);
    hashString.append(attr).append(""String_Node_Str"").append(value).append(""String_Node_Str"");
    if (ATTR_DISPLAY_NUMBER.equals(attr)) {
      displayNumber=value;
    }
 else     if (ATTR_DISPLAY_NAME.equals(attr)) {
      displayName=value;
    }
 else     if (ATTR_VIDEO_WIDTH.equals(attr)) {
      videoWidth=Integer.parseInt(value);
    }
 else     if (ATTR_VIDEO_HEIGHT.equals(attr)) {
      videoHeight=Integer.parseInt(value);
    }
 else     if (ATTR_LOGO_URL.equals(attr)) {
      logoUrl=value;
    }
  }
  List<ProgramInfo> programs=new ArrayList<>();
  while (parser.next() != XmlPullParser.END_DOCUMENT) {
    if (parser.getEventType() == XmlPullParser.START_TAG) {
      if (TAG_PROGRAM.equals(parser.getName())) {
        programs.add(parseProgram(parser));
      }
    }
 else     if (TAG_CHANNEL.equals(parser.getName()) && parser.getEventType() == XmlPullParser.END_TAG) {
      break;
    }
  }
  int fakeOriginalNetworkId=hashString.toString().hashCode();
  return new ChannelInfo(displayNumber,displayName,logoUrl,fakeOriginalNetworkId,0,0,videoWidth,videoHeight,audioChannelCount,hasClosedCaption,programs);
}","The original code had incorrect parameter ordering when creating the ChannelInfo object, potentially causing data misalignment. In the fixed code, the parameters for fakeOriginalNetworkId, network ID, and service ID were reordered to match the correct constructor signature. This ensures that channel information is accurately mapped and prevents potential runtime errors or unexpected data placement."
94199,"private void loadRows(){
  String inputId=getActivity().getIntent().getStringExtra(TvInputInfo.EXTRA_INPUT_ID);
  String serviceName=Utils.getServiceNameFromInputId(getActivity(),inputId);
  if (!TextUtils.isEmpty(serviceName)) {
    String[] a=serviceName.split(""String_Node_Str"");
    serviceName=a[a.length - 1];
  }
  GridItemPresenter mGridPresenter=new GridItemPresenter();
  mRowsAdapter=new ArrayObjectAdapter(new ListRowPresenter());
  HeaderItem gridHeader=new HeaderItem(0,""String_Node_Str"",null);
  ArrayObjectAdapter gridRowAdapter=new ArrayObjectAdapter(mGridPresenter);
  gridRowAdapter.add(serviceName + ""String_Node_Str"");
  if (serviceName.equals(RichTvInputService.class.getName())) {
    gridRowAdapter.add(""String_Node_Str"");
    gridRowAdapter.add(""String_Node_Str"");
  }
  mRowsAdapter.add(new ListRow(gridHeader,gridRowAdapter));
  setAdapter(mRowsAdapter);
}","private void loadRows(){
  String inputId=getActivity().getIntent().getStringExtra(TvInputInfo.EXTRA_INPUT_ID);
  String serviceName=Utils.getServiceNameFromInputId(getActivity(),inputId);
  if (!TextUtils.isEmpty(serviceName)) {
    String[] a=serviceName.split(""String_Node_Str"");
    serviceName=a[a.length - 1];
  }
  GridItemPresenter mGridPresenter=new GridItemPresenter();
  mRowsAdapter=new ArrayObjectAdapter(new ListRowPresenter());
  HeaderItem gridHeader=new HeaderItem(0,""String_Node_Str"",null);
  ArrayObjectAdapter gridRowAdapter=new ArrayObjectAdapter(mGridPresenter);
  gridRowAdapter.add(serviceName + ""String_Node_Str"");
  if (RichTvInputService.class.getName().contains(serviceName)) {
    gridRowAdapter.add(""String_Node_Str"");
    gridRowAdapter.add(""String_Node_Str"");
  }
  mRowsAdapter.add(new ListRow(gridHeader,gridRowAdapter));
  setAdapter(mRowsAdapter);
}","The original code incorrectly checks service name equality using `serviceName.equals(RichTvInputService.class.getName())`, which might fail due to potential string mismatch. The fixed code changes the comparison to `RichTvInputService.class.getName().contains(serviceName)`, which provides a more flexible and robust matching approach. This modification ensures that partial matches are considered, making the code more resilient to variations in service name representation."
94200,"private boolean startPlayback(int resource){
  if (mPlayer == null) {
    mPlayer=new MediaPlayer();
    mPlayer.setOnInfoListener(new MediaPlayer.OnInfoListener(){
      @Override public boolean onInfo(      MediaPlayer player,      int what,      int arg){
        if (what == MediaPlayer.MEDIA_INFO_BUFFERING_START) {
          notifyVideoUnavailable(TvInputManager.VIDEO_UNAVAILABLE_REASON_BUFFERING);
          return true;
        }
 else         if (what == MediaPlayer.MEDIA_INFO_BUFFERING_END || what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
          notifyVideoAvailable();
          return true;
        }
        return false;
      }
    }
);
    mPlayer.setSurface(mSurface);
    mPlayer.setVolume(mVolume,mVolume);
    mPlayer.setLooping(true);
  }
 else {
    mPlayer.reset();
  }
  AssetFileDescriptor afd=getResources().openRawResourceFd(resource);
  if (afd == null) {
    return false;
  }
  try {
    mPlayer.setDataSource(afd.getFileDescriptor(),afd.getStartOffset(),afd.getDeclaredLength());
    mPlayer.prepare();
    mPlayer.start();
  }
 catch (  IOException e) {
    return false;
  }
 finally {
    try {
      afd.close();
    }
 catch (    IOException e) {
    }
  }
  notifyContentAllowed();
  return true;
}","private boolean startPlayback(int resource){
  if (mPlayer == null) {
    mPlayer=new MediaPlayer();
    mPlayer.setOnInfoListener(new MediaPlayer.OnInfoListener(){
      @Override public boolean onInfo(      MediaPlayer player,      int what,      int arg){
        if (what == MediaPlayer.MEDIA_INFO_BUFFERING_START) {
          notifyVideoUnavailable(TvInputManager.VIDEO_UNAVAILABLE_REASON_BUFFERING);
          return true;
        }
 else         if (what == MediaPlayer.MEDIA_INFO_BUFFERING_END || what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
          notifyVideoAvailable();
          return true;
        }
        return false;
      }
    }
);
    mPlayer.setSurface(mSurface);
    mPlayer.setVolume(mVolume,mVolume);
  }
 else {
    mPlayer.reset();
  }
  mPlayer.setLooping(true);
  AssetFileDescriptor afd=getResources().openRawResourceFd(resource);
  if (afd == null) {
    return false;
  }
  try {
    mPlayer.setDataSource(afd.getFileDescriptor(),afd.getStartOffset(),afd.getDeclaredLength());
    mPlayer.prepare();
    mPlayer.start();
  }
 catch (  IOException e) {
    return false;
  }
 finally {
    try {
      afd.close();
    }
 catch (    IOException e) {
    }
  }
  notifyContentAllowed();
  return true;
}","The original code sets `setLooping(true)` only when creating a new MediaPlayer, which could lead to inconsistent looping behavior when resetting an existing player. In the fixed code, `setLooping(true)` is moved outside the initialization block, ensuring that looping is always set regardless of whether a new MediaPlayer is created or an existing one is reset. This change guarantees consistent looping behavior and prevents potential playback configuration issues across different player states."
94201,"@Override public void onConnect(){
  System.out.println(""String_Node_Str"");
  mMeteor.registerAndLogin(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new ResultListener(){
    @Override public void onSuccess(    String result){
      System.out.println(""String_Node_Str"" + result);
    }
    @Override public void onError(    String error,    String reason,    String details){
      System.out.println(""String_Node_Str"" + error + ""String_Node_Str""+ reason+ ""String_Node_Str""+ details);
    }
  }
);
  mMeteor.loginWithUsername(""String_Node_Str"",""String_Node_Str"",new ResultListener(){
    @Override public void onSuccess(    String result){
      System.out.println(""String_Node_Str"" + result);
    }
    @Override public void onError(    String error,    String reason,    String details){
      System.out.println(""String_Node_Str"" + error + ""String_Node_Str""+ reason+ ""String_Node_Str""+ details);
    }
  }
);
  String subscriptionId=mMeteor.subscribe(""String_Node_Str"");
  mMeteor.unsubscribe(subscriptionId);
  Map<String,Object> insertValues=new HashMap<String,Object>();
  insertValues.put(""String_Node_Str"",""String_Node_Str"");
  insertValues.put(""String_Node_Str"",3);
  mMeteor.insert(""String_Node_Str"",insertValues);
  Map<String,Object> updateQuery=new HashMap<String,Object>();
  updateQuery.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,Object> updateValues=new HashMap<String,Object>();
  insertValues.put(""String_Node_Str"",""String_Node_Str"");
  insertValues.put(""String_Node_Str"",5);
  mMeteor.update(""String_Node_Str"",updateQuery,updateValues);
  mMeteor.remove(""String_Node_Str"",""String_Node_Str"");
  mMeteor.call(""String_Node_Str"");
}","@Override public void onConnect(){
  System.out.println(""String_Node_Str"");
  mMeteor.registerAndLogin(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new ResultListener(){
    @Override public void onSuccess(    String result){
      System.out.println(""String_Node_Str"" + result);
    }
    @Override public void onError(    String error,    String reason,    String details){
      System.out.println(""String_Node_Str"" + error + ""String_Node_Str""+ reason+ ""String_Node_Str""+ details);
    }
  }
);
  mMeteor.loginWithUsername(""String_Node_Str"",""String_Node_Str"",new ResultListener(){
    @Override public void onSuccess(    String result){
      System.out.println(""String_Node_Str"" + result);
    }
    @Override public void onError(    String error,    String reason,    String details){
      System.out.println(""String_Node_Str"" + error + ""String_Node_Str""+ reason+ ""String_Node_Str""+ details);
    }
  }
);
  String subscriptionId=mMeteor.subscribe(""String_Node_Str"");
  mMeteor.unsubscribe(subscriptionId);
  Map<String,Object> insertValues=new HashMap<String,Object>();
  insertValues.put(""String_Node_Str"",""String_Node_Str"");
  insertValues.put(""String_Node_Str"",3);
  mMeteor.insert(""String_Node_Str"",insertValues);
  Map<String,Object> updateQuery=new HashMap<String,Object>();
  updateQuery.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,Object> updateValues=new HashMap<String,Object>();
  updateValues.put(""String_Node_Str"",""String_Node_Str"");
  updateValues.put(""String_Node_Str"",5);
  mMeteor.update(""String_Node_Str"",updateQuery,updateValues);
  mMeteor.remove(""String_Node_Str"",""String_Node_Str"");
  mMeteor.call(""String_Node_Str"");
}","The original code contained a bug in the `updateValues` map, where it incorrectly used `insertValues.put()` instead of `updateValues.put()`. In the fixed code, the `put()` methods are corrected to use the appropriate map (`updateValues`) with the correct key-value pairs. This ensures that the update operation uses the intended values, preventing potential data inconsistencies and improving the reliability of the Meteor database operation."
94202,"@Override public void onConnect(){
  System.out.println(""String_Node_Str"");
  mMeteor.registerAndLogin(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new ResultListener(){
    @Override public void onSuccess(    String result){
      System.out.println(""String_Node_Str"" + result);
    }
    @Override public void onError(    String error,    String reason,    String details){
      System.out.println(""String_Node_Str"" + error + ""String_Node_Str""+ reason+ ""String_Node_Str""+ details);
    }
  }
);
  mMeteor.loginWithUsername(""String_Node_Str"",""String_Node_Str"",new ResultListener(){
    @Override public void onSuccess(    String result){
      System.out.println(""String_Node_Str"" + result);
    }
    @Override public void onError(    String error,    String reason,    String details){
      System.out.println(""String_Node_Str"" + error + ""String_Node_Str""+ reason+ ""String_Node_Str""+ details);
    }
  }
);
  String subscriptionId=mMeteor.subscribe(""String_Node_Str"");
  mMeteor.unsubscribe(subscriptionId);
  Map<String,Object> insertValues=new HashMap<String,Object>();
  insertValues.put(""String_Node_Str"",""String_Node_Str"");
  insertValues.put(""String_Node_Str"",3);
  mMeteor.insert(""String_Node_Str"",insertValues);
  Map<String,Object> updateQuery=new HashMap<String,Object>();
  updateQuery.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,Object> updateValues=new HashMap<String,Object>();
  insertValues.put(""String_Node_Str"",""String_Node_Str"");
  insertValues.put(""String_Node_Str"",5);
  mMeteor.update(""String_Node_Str"",updateQuery,updateValues);
  mMeteor.remove(""String_Node_Str"",""String_Node_Str"");
  mMeteor.call(""String_Node_Str"");
}","@Override public void onConnect(){
  System.out.println(""String_Node_Str"");
  mMeteor.registerAndLogin(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new ResultListener(){
    @Override public void onSuccess(    String result){
      System.out.println(""String_Node_Str"" + result);
    }
    @Override public void onError(    String error,    String reason,    String details){
      System.out.println(""String_Node_Str"" + error + ""String_Node_Str""+ reason+ ""String_Node_Str""+ details);
    }
  }
);
  mMeteor.loginWithUsername(""String_Node_Str"",""String_Node_Str"",new ResultListener(){
    @Override public void onSuccess(    String result){
      System.out.println(""String_Node_Str"" + result);
    }
    @Override public void onError(    String error,    String reason,    String details){
      System.out.println(""String_Node_Str"" + error + ""String_Node_Str""+ reason+ ""String_Node_Str""+ details);
    }
  }
);
  String subscriptionId=mMeteor.subscribe(""String_Node_Str"");
  mMeteor.unsubscribe(subscriptionId);
  Map<String,Object> insertValues=new HashMap<String,Object>();
  insertValues.put(""String_Node_Str"",""String_Node_Str"");
  insertValues.put(""String_Node_Str"",3);
  mMeteor.insert(""String_Node_Str"",insertValues);
  Map<String,Object> updateQuery=new HashMap<String,Object>();
  updateQuery.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,Object> updateValues=new HashMap<String,Object>();
  updateValues.put(""String_Node_Str"",""String_Node_Str"");
  updateValues.put(""String_Node_Str"",5);
  mMeteor.update(""String_Node_Str"",updateQuery,updateValues);
  mMeteor.remove(""String_Node_Str"",""String_Node_Str"");
  mMeteor.call(""String_Node_Str"");
}","The original code contains a bug in the `updateValues` map, where it incorrectly uses `insertValues` instead of creating a separate `updateValues` map. The fixed code creates a new `updateValues` map and populates it correctly with the intended key-value pairs using `updateValues.put()` instead of modifying `insertValues`. This correction ensures proper update operations by using the correct map and preventing unintended modifications to the insert values."
94203,"@Override public void run(){
  while (!mIsLoopExit) {
    byte[] buffer=new byte[mMinBufferSize];
    int ret=mAudioRecord.read(buffer,0,mMinBufferSize);
    if (ret == AudioRecord.ERROR_INVALID_OPERATION) {
      Log.e(TAG,""String_Node_Str"");
    }
 else     if (ret == AudioRecord.ERROR_BAD_VALUE) {
      Log.e(TAG,""String_Node_Str"");
    }
 else     if (ret == AudioRecord.ERROR_INVALID_OPERATION) {
      Log.e(TAG,""String_Node_Str"");
    }
 else {
      if (mAudioFrameCapturedListener != null) {
        mAudioFrameCapturedListener.onAudioFrameCaptured(buffer);
      }
      Log.d(TAG,""String_Node_Str"" + ret + ""String_Node_Str"");
    }
  }
}","@Override public void run(){
  while (!mIsLoopExit) {
    byte[] buffer=new byte[mMinBufferSize];
    int ret=mAudioRecord.read(buffer,0,mMinBufferSize);
    if (ret == AudioRecord.ERROR_INVALID_OPERATION) {
      Log.e(TAG,""String_Node_Str"");
    }
 else     if (ret == AudioRecord.ERROR_BAD_VALUE) {
      Log.e(TAG,""String_Node_Str"");
    }
 else {
      if (mAudioFrameCapturedListener != null) {
        mAudioFrameCapturedListener.onAudioFrameCaptured(buffer);
      }
      Log.d(TAG,""String_Node_Str"" + ret + ""String_Node_Str"");
    }
    SystemClock.sleep(10);
  }
}","The original code had a redundant error check for `ERROR_INVALID_OPERATION`, which was already defined in the first condition. The fixed code removes this duplicate check and adds a `SystemClock.sleep(10)` to prevent tight looping and reduce CPU usage. This modification improves the code's efficiency by avoiding unnecessary error checks and introducing a small delay to manage resource consumption during audio recording."
94204,"public void stopCapture(){
  if (!mIsCaptureStarted) {
    return;
  }
  mIsLoopExit=false;
  try {
    mCaptureThread.interrupt();
    mCaptureThread.join(1000);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  if (mAudioRecord.getRecordingState() == AudioRecord.RECORDSTATE_RECORDING) {
    mAudioRecord.stop();
  }
  mAudioRecord.release();
  mIsCaptureStarted=false;
  mAudioFrameCapturedListener=null;
  Log.d(TAG,""String_Node_Str"");
}","public void stopCapture(){
  if (!mIsCaptureStarted) {
    return;
  }
  mIsLoopExit=true;
  try {
    mCaptureThread.interrupt();
    mCaptureThread.join(1000);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  if (mAudioRecord.getRecordingState() == AudioRecord.RECORDSTATE_RECORDING) {
    mAudioRecord.stop();
  }
  mAudioRecord.release();
  mIsCaptureStarted=false;
  mAudioFrameCapturedListener=null;
  Log.d(TAG,""String_Node_Str"");
}","The original code sets `mIsLoopExit` to `false`, which might prevent the capture thread from properly terminating. In the fixed code, `mIsLoopExit` is set to `true`, signaling the thread to exit gracefully and allowing for a clean shutdown of the audio capture process. This modification ensures a more reliable and controlled thread termination, preventing potential resource leaks or hanging threads."
94205,"public void loadExtensions(ClassLoader classLoader,List<String> extensions,List<Settings.ConfiguredExtension> extensionsWithConfiguration){
  this.extensions=new ArrayList<>();
  if (extensions != null) {
    this.extensions.addAll(loadInstances(classLoader,extensions,Extension.class));
  }
  if (extensionsWithConfiguration != null) {
    for (    ConfiguredExtension configuredExtension : extensionsWithConfiguration) {
      final Extension extension=loadInstance(classLoader,configuredExtension.className,Extension.class);
      extension.setConfiguration(Utils.mapFromNullable(configuredExtension.configuration));
      this.extensions.add(extension);
    }
  }
}","public void loadExtensions(ClassLoader classLoader,List<String> extensions,List<Settings.ConfiguredExtension> extensionsWithConfiguration){
  this.extensions=new ArrayList<>();
  if (extensions != null) {
    this.extensions.addAll(loadInstances(classLoader,extensions,EmitterExtension.class));
  }
  if (extensionsWithConfiguration != null) {
    for (    ConfiguredExtension configuredExtension : extensionsWithConfiguration) {
      final EmitterExtension emitterExtension=loadInstance(classLoader,configuredExtension.className,EmitterExtension.class);
      if (emitterExtension instanceof Extension) {
        final Extension extension=(Extension)emitterExtension;
        extension.setConfiguration(Utils.mapFromNullable(configuredExtension.configuration));
      }
      this.extensions.add(emitterExtension);
    }
  }
}","The original code incorrectly assumed all extensions were of type `Extension`, potentially causing type casting errors when working with different extension types. The fixed code introduces `EmitterExtension` as the base class and adds a type check before setting configuration, ensuring safe handling of different extension implementations. This approach provides more robust and flexible extension loading, preventing potential runtime exceptions and allowing for more diverse extension types."
94206,"@TaskAction public void generate() throws Exception {
  if (outputKind == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (jsonLibrary == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  TypeScriptGenerator.printVersion();
  final List<URL> urls=new ArrayList<>();
  for (  String taskName : Arrays.asList(""String_Node_Str"",""String_Node_Str"")) {
    for (    Task task : getProject().getTasksByName(taskName,false)) {
      for (      File file : task.getOutputs().getFiles()) {
        urls.add(file.toURI().toURL());
      }
    }
  }
  for (  File file : getProject().getConfigurations().getAt(""String_Node_Str"").getFiles()) {
    urls.add(file.toURI().toURL());
  }
  final URLClassLoader classLoader=Settings.createClassLoader(getProject().getName(),urls.toArray(new URL[0]),Thread.currentThread().getContextClassLoader());
  final Settings settings=new Settings();
  if (outputFileType != null) {
    settings.outputFileType=outputFileType;
  }
  settings.outputKind=outputKind;
  settings.module=module;
  settings.namespace=namespace;
  settings.mapPackagesToNamespaces=mapPackagesToNamespaces;
  settings.umdNamespace=umdNamespace;
  settings.setExcludeFilter(excludeClasses,excludeClassPatterns);
  settings.jsonLibrary=jsonLibrary;
  settings.declarePropertiesAsOptional=declarePropertiesAsOptional;
  settings.optionalProperties=optionalProperties;
  settings.declarePropertiesAsReadOnly=declarePropertiesAsReadOnly;
  settings.removeTypeNamePrefix=removeTypeNamePrefix;
  settings.removeTypeNameSuffix=removeTypeNameSuffix;
  settings.addTypeNamePrefix=addTypeNamePrefix;
  settings.addTypeNameSuffix=addTypeNameSuffix;
  settings.customTypeNaming=Settings.convertToMap(customTypeNaming);
  settings.customTypeNamingFunction=customTypeNamingFunction;
  settings.referencedFiles=referencedFiles;
  settings.importDeclarations=importDeclarations;
  settings.customTypeMappings=Settings.convertToMap(customTypeMappings);
  settings.mapDate=mapDate;
  settings.mapEnum=mapEnum;
  settings.nonConstEnums=nonConstEnums;
  settings.mapClasses=mapClasses;
  settings.mapClassesAsClassesPatterns=mapClassesAsClassesPatterns;
  settings.disableTaggedUnions=disableTaggedUnions;
  settings.ignoreSwaggerAnnotations=ignoreSwaggerAnnotations;
  settings.generateJaxrsApplicationInterface=generateJaxrsApplicationInterface;
  settings.generateJaxrsApplicationClient=generateJaxrsApplicationClient;
  settings.jaxrsNamespacing=jaxrsNamespacing;
  settings.setJaxrsNamespacingAnnotation(classLoader,jaxrsNamespacingAnnotation);
  settings.restResponseType=restResponseType;
  settings.setRestOptionsType(restOptionsType);
  settings.loadCustomTypeProcessor(classLoader,customTypeProcessor);
  settings.sortDeclarations=sortDeclarations;
  settings.sortTypeDeclarations=sortTypeDeclarations;
  settings.noFileComment=noFileComment;
  settings.javadocXmlFiles=javadocXmlFiles;
  settings.loadExtensions(classLoader,Utils.concat(extensionClasses,extensions),extensionsWithConfiguration);
  settings.loadIncludePropertyAnnotations(classLoader,includePropertyAnnotations);
  settings.loadOptionalAnnotations(classLoader,optionalAnnotations);
  settings.generateNpmPackageJson=generateNpmPackageJson;
  settings.npmName=npmName != null ? npmName : getProject().getName();
  settings.npmVersion=npmVersion != null ? npmVersion : settings.getDefaultNpmVersion();
  settings.setStringQuotes(stringQuotes);
  settings.setIndentString(indentString);
  settings.displaySerializerWarning=displaySerializerWarning;
  settings.disableJackson2ModuleDiscovery=disableJackson2ModuleDiscovery;
  settings.jackson2ModuleDiscovery=jackson2ModuleDiscovery;
  settings.loadJackson2Modules(classLoader,jackson2Modules);
  settings.classLoader=classLoader;
  final File output=outputFile != null ? getProject().file(outputFile) : new File(new File(getProject().getBuildDir(),""String_Node_Str""),getProject().getName() + settings.getExtension());
  settings.validateFileName(output);
  new TypeScriptGenerator(settings).generateTypeScript(Input.fromClassNamesAndJaxrsApplication(classes,classPatterns,classesFromJaxrsApplication,classesFromAutomaticJaxrsApplication,settings.getExcludeFilter(),classLoader,debug),Output.to(output));
}","@TaskAction public void generate() throws Exception {
  if (outputKind == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (jsonLibrary == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  TypeScriptGenerator.printVersion();
  final List<URL> urls=new ArrayList<>();
  for (  String taskName : Arrays.asList(""String_Node_Str"",""String_Node_Str"")) {
    for (    Task task : getProject().getTasksByName(taskName,false)) {
      for (      File file : task.getOutputs().getFiles()) {
        urls.add(file.toURI().toURL());
      }
    }
  }
  for (  File file : getProject().getConfigurations().getAt(""String_Node_Str"").getFiles()) {
    urls.add(file.toURI().toURL());
  }
  final URLClassLoader classLoader=Settings.createClassLoader(getProject().getName(),urls.toArray(new URL[0]),Thread.currentThread().getContextClassLoader());
  final Settings settings=new Settings();
  if (outputFileType != null) {
    settings.outputFileType=outputFileType;
  }
  settings.outputKind=outputKind;
  settings.module=module;
  settings.namespace=namespace;
  settings.mapPackagesToNamespaces=mapPackagesToNamespaces;
  settings.umdNamespace=umdNamespace;
  settings.setExcludeFilter(excludeClasses,excludeClassPatterns);
  settings.jsonLibrary=jsonLibrary;
  settings.declarePropertiesAsOptional=declarePropertiesAsOptional;
  settings.optionalProperties=optionalProperties;
  settings.declarePropertiesAsReadOnly=declarePropertiesAsReadOnly;
  settings.removeTypeNamePrefix=removeTypeNamePrefix;
  settings.removeTypeNameSuffix=removeTypeNameSuffix;
  settings.addTypeNamePrefix=addTypeNamePrefix;
  settings.addTypeNameSuffix=addTypeNameSuffix;
  settings.customTypeNaming=Settings.convertToMap(customTypeNaming);
  settings.customTypeNamingFunction=customTypeNamingFunction;
  settings.referencedFiles=referencedFiles;
  settings.importDeclarations=importDeclarations;
  settings.customTypeMappings=Settings.convertToMap(customTypeMappings);
  settings.mapDate=mapDate;
  settings.mapEnum=mapEnum;
  settings.nonConstEnums=nonConstEnums;
  settings.mapClasses=mapClasses;
  settings.mapClassesAsClassesPatterns=mapClassesAsClassesPatterns;
  settings.disableTaggedUnions=disableTaggedUnions;
  settings.ignoreSwaggerAnnotations=ignoreSwaggerAnnotations;
  settings.generateJaxrsApplicationInterface=generateJaxrsApplicationInterface;
  settings.generateJaxrsApplicationClient=generateJaxrsApplicationClient;
  settings.jaxrsNamespacing=jaxrsNamespacing;
  settings.setJaxrsNamespacingAnnotation(classLoader,jaxrsNamespacingAnnotation);
  settings.restResponseType=restResponseType;
  settings.setRestOptionsType(restOptionsType);
  settings.loadCustomTypeProcessor(classLoader,customTypeProcessor);
  settings.sortDeclarations=sortDeclarations;
  settings.sortTypeDeclarations=sortTypeDeclarations;
  settings.noFileComment=noFileComment;
  settings.javadocXmlFiles=javadocXmlFiles;
  settings.loadExtensions(classLoader,Utils.concat(extensionClasses,extensions),extensionsWithConfiguration);
  settings.loadIncludePropertyAnnotations(classLoader,includePropertyAnnotations);
  settings.loadOptionalAnnotations(classLoader,optionalAnnotations);
  settings.generateNpmPackageJson=generateNpmPackageJson;
  settings.npmName=npmName == null && generateNpmPackageJson ? getProject().getName() : npmName;
  settings.npmVersion=npmVersion == null && generateNpmPackageJson ? settings.getDefaultNpmVersion() : npmVersion;
  settings.setStringQuotes(stringQuotes);
  settings.setIndentString(indentString);
  settings.displaySerializerWarning=displaySerializerWarning;
  settings.disableJackson2ModuleDiscovery=disableJackson2ModuleDiscovery;
  settings.jackson2ModuleDiscovery=jackson2ModuleDiscovery;
  settings.loadJackson2Modules(classLoader,jackson2Modules);
  settings.classLoader=classLoader;
  final File output=outputFile != null ? getProject().file(outputFile) : new File(new File(getProject().getBuildDir(),""String_Node_Str""),getProject().getName() + settings.getExtension());
  settings.validateFileName(output);
  new TypeScriptGenerator(settings).generateTypeScript(Input.fromClassNamesAndJaxrsApplication(classes,classPatterns,classesFromJaxrsApplication,classesFromAutomaticJaxrsApplication,settings.getExcludeFilter(),classLoader,debug),Output.to(output));
}","The original code had incorrect default handling for `npmName` and `npmVersion`, potentially causing unexpected behavior when generating npm package JSON. The fixed code adds a condition to use project name and default version only when `generateNpmPackageJson` is true, ensuring proper configuration. This improvement provides more predictable and flexible npm package generation with explicit control over naming and versioning."
94207,"private static TsBeanModel getBeanModelByType(TsModel model,TsType type){
  TsType originalType=extractOriginalTsType(type);
  for (  TsBeanModel curBean : model.getBeans()) {
    if (curBean.getName().equals(originalType)) {
      return curBean;
    }
  }
  return null;
}","private static TsBeanModel getBeanModelByType(TsModel model,TsType type){
  TsType originalType=extractOriginalTsType(type);
  if (!(originalType instanceof TsType.ReferenceType)) {
    return null;
  }
  TsType.ReferenceType originalTypeBean=(TsType.ReferenceType)originalType;
  for (  TsBeanModel curBean : model.getBeans()) {
    if (curBean.getName().equals(originalTypeBean.symbol)) {
      return curBean;
    }
  }
  return null;
}","The original code assumes all types can be directly compared to bean names, which can lead to runtime errors when non-reference types are passed. The fixed code first checks if the type is a ReferenceType, casting it appropriately and comparing against the reference symbol instead of the original type. This modification prevents potential null pointer exceptions and ensures type-safe bean model retrieval by explicitly handling reference type comparisons."
94208,"@Test public void basicTest(){
  final StringBuilder data=new StringBuilder();
  final EmitterExtension.Writer writer=new EmitterExtension.Writer(){
    @Override public void writeIndentedLine(    String line){
      data.append(line + ""String_Node_Str"");
    }
  }
;
  final Settings settings=new Settings();
  settings.sortDeclarations=true;
  final TypeProcessor typeProcessor=new DefaultTypeProcessor();
  final Model model=new Jackson2Parser(settings,typeProcessor).parseModel(ClassA.class);
  final TsModel tsModel=new ModelCompiler(settings,typeProcessor).javaToTypeScript(model);
  new BeanPropertyPathExtension().emitElements(writer,settings,false,tsModel);
  String dataStr=data.toString();
  Assert.assertEquals(29,dataStr.split(""String_Node_Str"").length);
  Assert.assertTrue(dataStr.contains(""String_Node_Str""));
  Assert.assertTrue(dataStr.contains(""String_Node_Str""));
}","@Test public void basicTest() throws Exception {
  final StringBuilder data=new StringBuilder();
  final EmitterExtension.Writer writer=new EmitterExtension.Writer(){
    @Override public void writeIndentedLine(    String line){
      data.append(line + ""String_Node_Str"");
    }
  }
;
  final Settings settings=new Settings();
  settings.sortDeclarations=true;
  final TypeProcessor typeProcessor=new DefaultTypeProcessor();
  final Model model=new Jackson2Parser(settings,typeProcessor).parseModel(ClassA.class);
  final TsModel tsModel=new ModelCompiler(settings,typeProcessor).javaToTypeScript(model);
  new BeanPropertyPathExtension().emitElements(writer,settings,false,tsModel);
  String dataStr=data.toString();
  final String expected=new String(Files.readAllBytes(Paths.get(getClass().getClassLoader().getResource(""String_Node_Str"").toURI())));
  Assert.assertEquals(expected,dataStr);
}","The original code used a brittle, hardcoded assertion comparing string splits and occurrences, which made the test fragile and less reliable. The fixed code replaces the static assertions with a dynamic comparison against an expected output loaded from a resource file, providing a more flexible and maintainable test approach. By reading the expected content from an external file, the test becomes more adaptable to changes and ensures precise verification of the generated output."
94209,"private static Map<Type,TsType> getKnownTypes(){
  final Map<Type,TsType> knownTypes=new LinkedHashMap<>();
  knownTypes.put(Object.class,TsType.Any);
  knownTypes.put(Byte.class,TsType.Number);
  knownTypes.put(Byte.TYPE,TsType.Number);
  knownTypes.put(Short.class,TsType.Number);
  knownTypes.put(Short.TYPE,TsType.Number);
  knownTypes.put(Integer.class,TsType.Number);
  knownTypes.put(Integer.TYPE,TsType.Number);
  knownTypes.put(Long.class,TsType.Number);
  knownTypes.put(Long.TYPE,TsType.Number);
  knownTypes.put(Float.class,TsType.Number);
  knownTypes.put(Float.TYPE,TsType.Number);
  knownTypes.put(Double.class,TsType.Number);
  knownTypes.put(Double.TYPE,TsType.Number);
  knownTypes.put(Boolean.class,TsType.Boolean);
  knownTypes.put(Boolean.TYPE,TsType.Boolean);
  knownTypes.put(Character.class,TsType.String);
  knownTypes.put(Character.TYPE,TsType.String);
  knownTypes.put(String.class,TsType.String);
  knownTypes.put(Date.class,TsType.Date);
  return knownTypes;
}","private static Map<Type,TsType> getKnownTypes(){
  final Map<Type,TsType> knownTypes=new LinkedHashMap<>();
  knownTypes.put(Object.class,TsType.Any);
  knownTypes.put(Byte.class,TsType.Number);
  knownTypes.put(Byte.TYPE,TsType.Number);
  knownTypes.put(Short.class,TsType.Number);
  knownTypes.put(Short.TYPE,TsType.Number);
  knownTypes.put(Integer.class,TsType.Number);
  knownTypes.put(Integer.TYPE,TsType.Number);
  knownTypes.put(Long.class,TsType.Number);
  knownTypes.put(Long.TYPE,TsType.Number);
  knownTypes.put(Float.class,TsType.Number);
  knownTypes.put(Float.TYPE,TsType.Number);
  knownTypes.put(Double.class,TsType.Number);
  knownTypes.put(Double.TYPE,TsType.Number);
  knownTypes.put(Boolean.class,TsType.Boolean);
  knownTypes.put(Boolean.TYPE,TsType.Boolean);
  knownTypes.put(Character.class,TsType.String);
  knownTypes.put(Character.TYPE,TsType.String);
  knownTypes.put(String.class,TsType.String);
  knownTypes.put(Date.class,TsType.Date);
  knownTypes.put(void.class,TsType.Void);
  knownTypes.put(Void.class,TsType.Void);
  return knownTypes;
}","The original code lacked mapping for void and Void types, potentially causing type conversion issues in TypeScript generation. The fixed code adds `knownTypes.put(void.class,TsType.Void)` and `knownTypes.put(Void.class,TsType.Void)` to explicitly handle void return types. These additions ensure comprehensive type mapping, preventing potential runtime errors and improving the robustness of type conversion between Java and TypeScript."
94210,"@Test public void testTypeConversion(){
  TypeProcessor converter=new DefaultTypeProcessor();
  final TypeProcessor.Context context=getTestContext(converter);
  assertEquals(""String_Node_Str"",converter.processType(A.class,context).getTsType().toString());
  assertEquals(""String_Node_Str"",converter.processType(B.class,context).getTsType().toString());
}","@Test public void testTypeConversion(){
  TypeProcessor converter=new DefaultTypeProcessor();
  final TypeProcessor.Context context=getTestContext(converter);
  assertEquals(""String_Node_Str"",converter.processType(A.class,context).getTsType().toString());
  assertEquals(""String_Node_Str"",converter.processType(B.class,context).getTsType().toString());
  assertEquals(TsType.Void,converter.processType(void.class,context).getTsType());
}","The original code lacked test coverage for void type conversion, potentially missing important type processing scenarios. The fixed code adds an assertion to verify the conversion of void.class, ensuring that the TypeProcessor correctly handles primitive void types. This enhancement improves the comprehensiveness of type conversion testing by explicitly checking the behavior with void types."
94211,"private static Map<Type,TsType> getKnownTypes(){
  final Map<Type,TsType> knownTypes=new LinkedHashMap<>();
  knownTypes.put(Object.class,TsType.Any);
  knownTypes.put(Byte.class,TsType.Number);
  knownTypes.put(Byte.TYPE,TsType.Number);
  knownTypes.put(Short.class,TsType.Number);
  knownTypes.put(Short.TYPE,TsType.Number);
  knownTypes.put(Integer.class,TsType.Number);
  knownTypes.put(Integer.TYPE,TsType.Number);
  knownTypes.put(Long.class,TsType.Number);
  knownTypes.put(Long.TYPE,TsType.Number);
  knownTypes.put(Float.class,TsType.Number);
  knownTypes.put(Float.TYPE,TsType.Number);
  knownTypes.put(Double.class,TsType.Number);
  knownTypes.put(Double.TYPE,TsType.Number);
  knownTypes.put(Boolean.class,TsType.Boolean);
  knownTypes.put(Boolean.TYPE,TsType.Boolean);
  knownTypes.put(Character.class,TsType.String);
  knownTypes.put(Character.TYPE,TsType.String);
  knownTypes.put(String.class,TsType.String);
  knownTypes.put(Date.class,TsType.Date);
  return knownTypes;
}","private static Map<Type,TsType> getKnownTypes(){
  final Map<Type,TsType> knownTypes=new LinkedHashMap<>();
  knownTypes.put(Object.class,TsType.Any);
  knownTypes.put(Byte.class,TsType.Number);
  knownTypes.put(Byte.TYPE,TsType.Number);
  knownTypes.put(Short.class,TsType.Number);
  knownTypes.put(Short.TYPE,TsType.Number);
  knownTypes.put(Integer.class,TsType.Number);
  knownTypes.put(Integer.TYPE,TsType.Number);
  knownTypes.put(Long.class,TsType.Number);
  knownTypes.put(Long.TYPE,TsType.Number);
  knownTypes.put(Float.class,TsType.Number);
  knownTypes.put(Float.TYPE,TsType.Number);
  knownTypes.put(Double.class,TsType.Number);
  knownTypes.put(Double.TYPE,TsType.Number);
  knownTypes.put(Boolean.class,TsType.Boolean);
  knownTypes.put(Boolean.TYPE,TsType.Boolean);
  knownTypes.put(Character.class,TsType.String);
  knownTypes.put(Character.TYPE,TsType.String);
  knownTypes.put(String.class,TsType.String);
  knownTypes.put(Date.class,TsType.Date);
  knownTypes.put(void.class,TsType.Void);
  knownTypes.put(Void.class,TsType.Void);
  return knownTypes;
}","The original code lacked support for void return types, which are important in method mapping. The fixed code adds `void.class` and `Void.class` mappings to `TsType.Void`, ensuring comprehensive type coverage for TypeScript generation. This enhancement provides more robust handling of method return types, particularly for methods that do not return a value."
94212,"@Test public void testTypeConversion(){
  TypeProcessor converter=new DefaultTypeProcessor();
  final TypeProcessor.Context context=getTestContext(converter);
  assertEquals(""String_Node_Str"",converter.processType(A.class,context).getTsType().toString());
  assertEquals(""String_Node_Str"",converter.processType(B.class,context).getTsType().toString());
}","@Test public void testTypeConversion(){
  TypeProcessor converter=new DefaultTypeProcessor();
  final TypeProcessor.Context context=getTestContext(converter);
  assertEquals(""String_Node_Str"",converter.processType(A.class,context).getTsType().toString());
  assertEquals(""String_Node_Str"",converter.processType(B.class,context).getTsType().toString());
  assertEquals(TsType.Void,converter.processType(void.class,context).getTsType());
}","The original code lacked test coverage for void type conversion, potentially missing an important edge case in type processing. The fixed code adds an assertion to check the void type conversion, ensuring that the TypeProcessor correctly handles primitive void types by comparing the result to TsType.Void. This enhancement improves test comprehensiveness and validates the type conversion mechanism's robustness across different type scenarios."
94213,"private void handleCompleted(CompletedFrom comp){
  completed(comp.source);
  final boolean done;
  if (comp.source == Source.A) {
    aSub.unsubscribe();
    done=(completed == COMPLETED_BOTH) || (completed == COMPLETED_A && as.isEmpty());
  }
 else {
    bSub.unsubscribe();
    done=(completed == COMPLETED_BOTH) || (completed == COMPLETED_B && bs.isEmpty());
  }
  if (done) {
    clear();
    child.onCompleted();
  }
}","private void handleCompleted(CompletedFrom comp){
  completed(comp.source);
  final boolean done;
  if (comp.source == Source.A) {
    aSub.unsubscribe();
    done=(completed == COMPLETED_BOTH) || (completed == COMPLETED_A && as.isEmpty());
  }
 else {
    bSub.unsubscribe();
    done=(completed == COMPLETED_BOTH) || (completed == COMPLETED_B && bs.isEmpty());
  }
  if (done) {
    clear();
    child.onCompleted();
  }
 else {
    checkToRequestMore();
  }
}","The original code lacked a mechanism to request more data when the completion conditions were not fully met, potentially leaving the stream in an incomplete state. The fixed code adds a `checkToRequestMore()` method call when the completion conditions are not satisfied, ensuring continuous data flow and preventing potential stalling. This enhancement guarantees more robust stream processing by dynamically managing subscription and data request behavior based on the current stream state."
94214,"private int handleItem(Object value,Source source){
  int numEmitted=0;
  if (source == Source.A) {
    @SuppressWarnings(""String_Node_Str"") A a=(A)value;
    K key=aKey.call(a);
    Queue<B> q=bs.get(key);
    if (q == null) {
      add(as,key,a);
    }
 else {
      B b=poll(bs,q,key);
      C c=combiner.call(a,b);
      child.onNext(c);
      numEmitted=1;
    }
    if (completed == COMPLETED_B && bs.isEmpty()) {
      clear();
      child.onCompleted();
    }
 else {
      requestFromA+=1;
    }
  }
 else {
    @SuppressWarnings(""String_Node_Str"") B b=(B)value;
    K key=bKey.call(b);
    Queue<A> q=as.get(key);
    if (q == null) {
      add(bs,key,b);
    }
 else {
      A a=poll(as,q,key);
      C c=combiner.call(a,b);
      child.onNext(c);
      numEmitted=1;
    }
    if (completed == COMPLETED_A && as.isEmpty()) {
      clear();
      child.onCompleted();
    }
 else {
      requestFromB+=1;
    }
  }
  if (requestFromA == requestSize && completed == COMPLETED_B) {
    requestFromA=0;
    aSub.requestMore(requestSize);
  }
 else   if (requestFromB == requestSize && completed == COMPLETED_A) {
    requestFromB=0;
    bSub.requestMore(requestSize);
  }
 else   if (requestFromA == requestSize && requestFromB == requestSize) {
    requestFromA=0;
    requestFromB=0;
    aSub.requestMore(requestSize);
    bSub.requestMore(requestSize);
  }
  return numEmitted;
}","private int handleItem(Object value,Source source){
  int numEmitted=0;
  if (source == Source.A) {
    @SuppressWarnings(""String_Node_Str"") A a=(A)value;
    K key=aKey.call(a);
    Queue<B> q=bs.get(key);
    if (q == null) {
      add(as,key,a);
    }
 else {
      B b=poll(bs,q,key);
      C c=combiner.call(a,b);
      child.onNext(c);
      numEmitted=1;
    }
    if (completed == COMPLETED_B && bs.isEmpty()) {
      clear();
      child.onCompleted();
    }
 else {
      requestFromA+=1;
    }
  }
 else {
    @SuppressWarnings(""String_Node_Str"") B b=(B)value;
    K key=bKey.call(b);
    Queue<A> q=as.get(key);
    if (q == null) {
      add(bs,key,b);
    }
 else {
      A a=poll(as,q,key);
      C c=combiner.call(a,b);
      child.onNext(c);
      numEmitted=1;
    }
    if (completed == COMPLETED_A && as.isEmpty()) {
      clear();
      child.onCompleted();
    }
 else {
      requestFromB+=1;
    }
  }
  checkToRequestMore();
  return numEmitted;
}","The original code had complex, redundant logic for requesting more items, leading to potential race conditions and inefficient request handling. The fixed code extracts the request logic into a separate method `checkToRequestMore()`, which centralizes and simplifies the request management strategy. This refactoring improves code readability, reduces the chance of request-related bugs, and provides a cleaner, more maintainable approach to handling item requests across different sources."
94215,"private int handleItem(Object value,Source source){
  int numEmitted=0;
  if (source == Source.A) {
    @SuppressWarnings(""String_Node_Str"") A a=(A)value;
    K key=aKey.call(a);
    Queue<B> q=bs.get(key);
    if (q == null) {
      add(as,key,a);
    }
 else {
      B b=poll(bs,q,key);
      C c=combiner.call(a,b);
      child.onNext(c);
      numEmitted=1;
    }
    if (completed == COMPLETED_B && bs.isEmpty()) {
      clear();
      child.onCompleted();
    }
 else {
      requestFromA+=1;
    }
  }
 else {
    @SuppressWarnings(""String_Node_Str"") B b=(B)value;
    K key=bKey.call(b);
    Queue<A> q=as.get(key);
    if (q == null) {
      add(bs,key,b);
    }
 else {
      A a=poll(as,q,key);
      C c=combiner.call(a,b);
      child.onNext(c);
      numEmitted=1;
    }
    if (completed == COMPLETED_A && as.isEmpty()) {
      clear();
      child.onCompleted();
    }
 else {
      requestFromB+=1;
    }
  }
  if (requestFromA == requestSize && requestFromB == requestSize) {
    requestFromA=0;
    requestFromB=0;
    aSub.requestMore(requestSize);
    bSub.requestMore(requestSize);
  }
  return numEmitted;
}","private int handleItem(Object value,Source source){
  int numEmitted=0;
  if (source == Source.A) {
    @SuppressWarnings(""String_Node_Str"") A a=(A)value;
    K key=aKey.call(a);
    Queue<B> q=bs.get(key);
    if (q == null) {
      add(as,key,a);
    }
 else {
      B b=poll(bs,q,key);
      C c=combiner.call(a,b);
      child.onNext(c);
      numEmitted=1;
    }
    if (completed == COMPLETED_B && bs.isEmpty()) {
      clear();
      child.onCompleted();
    }
 else {
      requestFromA+=1;
    }
  }
 else {
    @SuppressWarnings(""String_Node_Str"") B b=(B)value;
    K key=bKey.call(b);
    Queue<A> q=as.get(key);
    if (q == null) {
      add(bs,key,b);
    }
 else {
      A a=poll(as,q,key);
      C c=combiner.call(a,b);
      child.onNext(c);
      numEmitted=1;
    }
    if (completed == COMPLETED_A && as.isEmpty()) {
      clear();
      child.onCompleted();
    }
 else {
      requestFromB+=1;
    }
  }
  if (requestFromA == requestSize && completed == COMPLETED_B) {
    requestFromA=0;
    aSub.requestMore(requestSize);
  }
 else   if (requestFromB == requestSize && completed == COMPLETED_A) {
    requestFromB=0;
    bSub.requestMore(requestSize);
  }
 else   if (requestFromA == requestSize && requestFromB == requestSize) {
    requestFromA=0;
    requestFromB=0;
    aSub.requestMore(requestSize);
    bSub.requestMore(requestSize);
  }
  return numEmitted;
}","The original code incorrectly requested more items from both sources simultaneously without considering their completion status, potentially leading to unnecessary requests or premature termination. The fixed code adds conditional checks to request items only when a specific source is incomplete, ensuring that requests are made strategically based on the current state of each source. This modification improves the code's robustness by preventing potential race conditions and providing more precise control over data streaming and completion."
94216,"@Override public void call(final Subscriber<? super T> child){
  Subscriber<T> parent=createSubscriber(child,onEmpty);
  child.add(parent);
  observable.unsafeSubscribe(subscriber);
}","@Override public void call(final Subscriber<? super T> child){
  Subscriber<T> parent=createSubscriber(child,onEmpty);
  observable.unsafeSubscribe(parent);
}","The buggy code incorrectly subscribes the original `subscriber` instead of the newly created `parent` subscriber, which breaks the intended subscription chain and could lead to unexpected behavior. In the fixed code, `observable.unsafeSubscribe(parent)` correctly uses the newly created parent subscriber, ensuring proper event propagation and subscriber lifecycle management. This change guarantees that the created subscriber handles the observable's events correctly, maintaining the expected reactive stream behavior."
94217,"@Override public T poll(){
synchronized (queues) {
    if (queues.isEmpty())     return null;
 else {
      while (true) {
        T value=queues.peekFirst().poll();
        if (value == null) {
          if (queues.size() <= 1) {
            return null;
          }
 else {
            Queue2<T> removed=queues.pollFirst();
            removed.dispose();
          }
        }
 else {
          return value;
        }
      }
    }
  }
}","@Override public T poll(){
  if (queues.isEmpty())   return null;
 else {
    while (true) {
      T value=queues.peekFirst().poll();
      if (value == null) {
        if (queues.size() <= 1) {
          return null;
        }
 else {
          Queue2<T> removed=queues.pollFirst();
          removed.dispose();
        }
      }
 else {
        return value;
      }
    }
  }
}","The buggy code unnecessarily synchronizes the entire method, causing potential performance bottlenecks and unnecessary locking when accessing the queue. The fixed code removes the synchronized block, allowing more efficient and concurrent access to the queue operations. By eliminating the synchronization, the code becomes more performant and reduces the risk of thread contention while maintaining the same logical behavior of polling elements from a multi-queue structure."
94218,"@Override public T peek(){
synchronized (queues) {
    return queues.peekFirst().peek();
  }
}","@Override public T peek(){
  return queues.peekFirst().peek();
}","The original code unnecessarily synchronizes the entire method for a simple peek operation, which can introduce performance bottlenecks and potential deadlocks. The fixed code removes the synchronized block, allowing direct access to the first queue's peek method without locking, which is appropriate for non-modifying operations. This change improves method efficiency by eliminating unneeded thread synchronization and reducing potential contention in concurrent scenarios."
94219,"@Override public boolean offer(T t){
synchronized (queues) {
    count++;
    if (count == 1 || count == maxItemsPerQueue) {
      count=1;
      queues.add(queueFactory.call());
    }
    return queues.peekLast().offer(t);
  }
}","@Override public boolean offer(T t){
  long c=count.incrementAndGet();
  if (c == 1 || c == maxItemsPerQueue) {
    count.set(1);
    queues.add(queueFactory.call());
  }
  return queues.peekLast().offer(t);
}","The original code uses unsynchronized concurrent increment of a non-atomic `count` variable, leading to potential race conditions and inconsistent queue management. The fixed code uses `AtomicLong` with `incrementAndGet()` and `set()` methods, ensuring thread-safe atomic operations and preventing potential data corruption during concurrent access. By using atomic operations, the improved implementation guarantees consistent and reliable queue creation and item insertion in a multi-threaded environment."
94220,"private Action0 onUnsubscribe(){
  return new Action0(){
    @Override public void call(){
      Worker worker=Schedulers.computation().createWorker();
      worker.schedule(new Action0(){
        @Override public void call(){
          subscriberCount.decrementAndGet();
        }
      }
);
    }
  }
;
}","private Action0 onUnsubscribe(){
  return new Action0(){
    @Override public void call(){
      subscriberCount.decrementAndGet();
    }
  }
;
}","The original code unnecessarily creates a worker and schedules a separate action to decrement the subscriber count, introducing complexity and potential resource overhead. The fixed code directly decrements the subscriber count within the immediate call method, eliminating the redundant worker and scheduling. This simplifies the unsubscribe logic, reduces resource allocation, and provides a more direct and efficient approach to managing subscriber count."
94221,"public TransformerLimitSubscribers(AtomicInteger subscriberCount,int maxSubscribers,long delayMs){
  this.subscriberCount=subscriberCount;
  this.maxSubscribers=maxSubscribers;
  this.delayMs=delayMs;
}","public TransformerLimitSubscribers(AtomicInteger subscriberCount,int maxSubscribers){
  this.subscriberCount=subscriberCount;
  this.maxSubscribers=maxSubscribers;
}","The original constructor included an unnecessary `delayMs` parameter, which was likely unused and added complexity without serving a clear purpose. In the fixed code, the `delayMs` parameter is removed, simplifying the constructor to focus on essential parameters `subscriberCount` and `maxSubscribers`. This modification improves code clarity, reduces potential confusion, and makes the constructor more straightforward and maintainable."
94222,"public Func1<Observable<? extends Throwable>,Observable<?>> build(){
  Preconditions.checkArgument(waits.isPresent());
  if (maxRetries.isPresent()) {
    waits=of(waits.get().take(maxRetries.get()));
  }
  return notificationHandler(waits.get(),scheduler.get(),action,retryExceptions,failExceptions,exceptionPredicate);
}","public Func1<Observable<? extends Throwable>,Observable<?>> build(){
  Preconditions.checkArgument(waits.isPresent(),""String_Node_Str"");
  if (maxRetries.isPresent()) {
    waits=of(waits.get().take(maxRetries.get()));
  }
  return notificationHandler(waits.get(),scheduler.get(),action,retryExceptions,failExceptions,exceptionPredicate);
}","The original code lacked a descriptive error message in the Preconditions.checkArgument() method, which could lead to unclear debugging when an argument check fails. The fixed code adds ""String_Node_Str"" as an error message, providing context about the argument validation failure. This improvement enhances code maintainability by offering more informative error reporting during runtime checks."
94223,"/** 
 * Returns the deserialized objects from the given   {@link File} as an{@link Observable} stream. A buffer size of 8192 bytes is used by default.
 * @param file the input file containing serialized java objects
 * @param < T > the generic type of the deserialized objects returned in the stream
 * @return the stream of deserialized objects from the {@link InputStream}as an   {@link Observable}.
 */
public static <T extends Serializable>Observable<T> read(final File file){
  return read(file,DEFAULT_BUFFER_SIZE);
}","/** 
 * Returns the deserialized objects from the given   {@link File} as an{@link Observable} stream. A buffer size of 8192 bytes is used bydefault.
 * @param file the input file containing serialized java objects
 * @param < T > the generic type of the deserialized objects returned in the stream
 * @return the stream of deserialized objects from the {@link InputStream}as an   {@link Observable}.
 */
public static <T extends Serializable>Observable<T> read(final File file){
  return read(file,DEFAULT_BUFFER_SIZE);
}","The original code appears identical to the ""fixed"" code, suggesting no actual bug or modification was made. Both code snippets have the same method signature, implementation, and docstring. Without additional context or highlighted differences, it is impossible to explain a specific code correction or improvement in this scenario."
94224,"@Override public Observable<Integer> call(Observable<Integer> o){
  return o.mergeWith(MERGE_WITH);
}","@Override public Observable<Integer> call(Observable<Integer> o){
  return o.mergeWith(MERGE_WITH.subscribeOn(Schedulers.computation())).subscribeOn(Schedulers.computation());
}","The original code lacks proper scheduling, potentially causing the merged Observable to run on the same thread, which can lead to performance bottlenecks. The fixed code adds `subscribeOn(Schedulers.computation())` to both the merged Observable and the source Observable, ensuring concurrent execution on a computation scheduler. This improvement allows for better parallel processing and prevents potential blocking of the main thread during Observable merging."
94225,"public Vector3f localCharPos(int charIndex){
  float[] verts=this.mesh().vertices();
  int quad=Bdx.VERT_STRIDE * 6;
  return new Vector3f(verts[charIndex * quad],verts[charIndex * quad + 1],0);
}","public Vector3f localCharPos(int charIndex){
  if (charIndex < 0 || charIndex >= capacity)   throw new RuntimeException(""String_Node_Str"" + charIndex + ""String_Node_Str""+ name+ ""String_Node_Str""+ capacity+ ""String_Node_Str"");
  float[] verts=this.mesh().vertices();
  int quad=Bdx.VERT_STRIDE * 6;
  return new Vector3f(verts[charIndex * quad],verts[charIndex * quad + 1],0);
}","The original code lacks bounds checking, potentially allowing access to out-of-range indices in the vertex array, which could cause memory corruption or unexpected behavior. The fixed code adds a boundary validation check using `charIndex < 0 || charIndex >= capacity` to ensure the index is within valid limits, throwing a descriptive runtime exception if violated. This modification prevents potential array index out-of-bounds errors and provides clear diagnostic information about the invalid index and context."
94226,"public Vector3f localCharSize(int charIndex){
  float[] verts=this.mesh().vertices();
  int quad=Bdx.VERT_STRIDE * 6;
  return new Vector3f(verts[charIndex * quad + Bdx.VERT_STRIDE] - verts[charIndex * quad],verts[charIndex * quad + (Bdx.VERT_STRIDE * 2) + 1] - verts[charIndex * quad + 1],0);
}","public Vector3f localCharSize(int charIndex){
  if (charIndex < 0 || charIndex >= capacity)   throw new RuntimeException(""String_Node_Str"" + charIndex + ""String_Node_Str""+ name+ ""String_Node_Str""+ capacity+ ""String_Node_Str"");
  float[] verts=this.mesh().vertices();
  int quad=Bdx.VERT_STRIDE * 6;
  return new Vector3f(verts[charIndex * quad + Bdx.VERT_STRIDE] - verts[charIndex * quad],verts[charIndex * quad + (Bdx.VERT_STRIDE * 2) + 1] - verts[charIndex * quad + 1],0);
}","The original code lacks bounds checking, risking potential array index out-of-bounds exceptions when accessing vertices for characters beyond the allocated space. The fixed code adds a critical validation check that throws a runtime exception if the character index is invalid, preventing access to unintended memory locations. This modification enhances code robustness by explicitly preventing potential memory access violations and providing clear diagnostic information about the index and capacity limitation."
94227,"@Override public void set(ShaderProgram program){
  program.setUniformf(""String_Node_Str"",Bdx.time);
  program.setUniformi(""String_Node_Str"",1);
  program.setUniformi(""String_Node_Str"",2);
  program.setUniformf(""String_Node_Str"",vpw);
  program.setUniformf(""String_Node_Str"",vph);
  program.setUniformf(""String_Node_Str"",scene.camera.near());
  program.setUniformf(""String_Node_Str"",scene.camera.far());
}","@Override public void set(ShaderProgram program){
  program.setUniformf(""String_Node_Str"",Bdx.time);
  program.setUniformi(""String_Node_Str"",1);
  program.setUniformi(""String_Node_Str"",2);
  program.setUniformf(""String_Node_Str"",vpw * display.downsample());
  program.setUniformf(""String_Node_Str"",vph * display.downsample());
  program.setUniformf(""String_Node_Str"",scene.camera.near());
  program.setUniformf(""String_Node_Str"",scene.camera.far());
}","The original code lacks proper scaling for viewport width and height, potentially causing rendering inconsistencies across different display configurations. The fixed code multiplies viewport dimensions by `display.downsample()`, ensuring accurate pixel scaling and maintaining visual fidelity across various screen resolutions. By incorporating this scaling factor, the code now adapts dynamically to different display settings, providing more robust and consistent rendering behavior."
94228,"public static void main(){
  profiler.stop(""String_Node_Str"");
  if (restartOnExport && Gdx.files.internal(""String_Node_Str"").lastModified() > startMillis) {
    startMillis=System.currentTimeMillis();
    restart();
  }
  boolean screenShadersUsed=false;
  for (  Scene scene : scenes) {
    if (scene.screenShaders.size() > 0) {
      screenShadersUsed=true;
      break;
    }
  }
  profiler.start(""String_Node_Str"");
  Gdx.gl.glClearColor(display.clearColor.r,display.clearColor.g,display.clearColor.b,display.clearColor.a);
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  Gdx.gl.glClearColor(0,0,0,0);
  Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
  profiler.stop(""String_Node_Str"");
  time+=TICK_TIME * timeSpeed;
  ++GdxProcessor.currentTick;
  fingers.clear();
  for (  Finger f : allocatedFingers) {
    if (f.down() || f.up())     fingers.add(f);
  }
  profiler.stop(""String_Node_Str"");
  for (  Component c : components) {
    if (c.state != null)     c.state.main();
  }
  profiler.stop(""String_Node_Str"");
  Viewport vp;
  ArrayListScenes newSceneList=(ArrayListScenes)scenes.clone();
  boolean depthBufferCleared=false;
  boolean colorBufferCleared=false;
  ArrayList<Scene> depthRenderScenes=new ArrayList<Scene>();
  for (int s=0; s < scenes.size(); s++) {
    Scene scene=scenes.get(s);
    for (    ScreenShader filter : scene.screenShaders) {
      if (filter.usingDepthTexture()) {
        depthRenderScenes.add(scene);
        for (int ns=s; ns >= 0; ns--) {
          if (scenes.get(ns).renderPassthrough)           depthRenderScenes.add(scenes.get(ns));
 else           break;
        }
        break;
      }
    }
  }
  for (int i=0; i < newSceneList.size(); i++) {
    final Scene scene=newSceneList.get(i);
    boolean prevSceneRenderPassthrough=false;
    boolean nextSceneRenderPassthrough=false;
    if (i > 0)     prevSceneRenderPassthrough=newSceneList.get(i - 1).renderPassthrough;
    if (i < newSceneList.size() - 1)     nextSceneRenderPassthrough=newSceneList.get(i + 1).renderPassthrough;
    if (!prevSceneRenderPassthrough) {
      colorBufferCleared=false;
      depthBufferCleared=false;
    }
    scene.update();
    profiler.stop(""String_Node_Str"");
    if (!scene.valid() || !scene.visible)     continue;
    vp=scene.viewport;
    vp.apply();
    final float vpw=vp.w;
    final float vph=vp.h;
    if (defaultScreenShaderUniformSet == null) {
      defaultScreenShaderUniformSet=new UniformSet(){
        @Override public void set(        ShaderProgram program){
          program.setUniformf(""String_Node_Str"",Bdx.time);
          program.setUniformi(""String_Node_Str"",1);
          program.setUniformi(""String_Node_Str"",2);
          program.setUniformf(""String_Node_Str"",vpw);
          program.setUniformf(""String_Node_Str"",vph);
          program.setUniformf(""String_Node_Str"",scene.camera.near());
          program.setUniformf(""String_Node_Str"",scene.camera.far());
        }
      }
;
    }
    depthShaderProvider.update(scene);
    shaderProvider.update(scene);
    for (    Camera cam : scene.cameras) {
      if (cam.renderToTexture) {
        cam.update();
        if (cam.renderBuffer == null) {
          cam.initRenderBuffer();
        }
        cam.renderBuffer.begin();
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT | GL20.GL_COLOR_BUFFER_BIT);
        renderWorld(modelBatch,scene,cam);
        cam.renderBuffer.end();
      }
    }
    boolean frameBufferInUse=false;
    if (display.downsample != 1 || scene.screenShaders.size() > 0 || (screenShadersUsed && scene.renderPassthrough)) {
      frameBuffer.begin();
      frameBufferInUse=true;
      if (!colorBufferCleared) {
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        colorBufferCleared=true;
      }
    }
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
    renderWorld(modelBatch,scene,scene.camera);
    if (frameBufferInUse) {
      frameBuffer.end();
      if (depthRenderScenes.contains(scene)) {
        Gdx.gl.glClearColor(1,1,1,1);
        depthBuffer.begin();
        if (!depthBufferCleared) {
          Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
          depthBufferCleared=true;
        }
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
        renderWorld(depthBatch,scene,scene.camera);
        depthBuffer.end();
        depthBuffer.getColorBufferTexture().bind(2);
      }
      scene.lastFrameBuffer.getColorBufferTexture().bind(1);
      Gdx.gl.glActiveTexture(GL20.GL_TEXTURE0);
      Gdx.gl.glClearColor(0,0,0,0);
      for (      ScreenShader filter : scene.screenShaders) {
        filter.compile();
        if (!filter.active)         continue;
        if (!filter.uniformSets.contains(defaultScreenShaderUniformSet))         filter.uniformSets.add(defaultScreenShaderUniformSet);
        if (!availableTempBuffers.containsKey(filter.renderScale.x * display.downsample())) {
          int fx=Math.max(1,(int)(Gdx.graphics.getWidth() * display.downsample()));
          int fy=Math.max(1,(int)(Gdx.graphics.getHeight() * display.downsample()));
          availableTempBuffers.put(filter.renderScale.x * display.downsample(),new RenderBuffer(spriteBatch,fx,fy));
        }
        RenderBuffer tempBuffer=availableTempBuffers.get(filter.renderScale.x * display.downsample);
        tempBuffer.clear();
        frameBuffer.drawTo(tempBuffer,filter,0,0,Gdx.graphics.getWidth(),Gdx.graphics.getHeight());
        if (!filter.overlay)         frameBuffer.clear();
        tempBuffer.drawTo(frameBuffer);
      }
      if (!scene.renderPassthrough || scene == newSceneList.get(newSceneList.size() - 1) || !nextSceneRenderPassthrough)       frameBuffer.drawTo(null,null,vp.x,vp.y,vp.w,vp.h);
      scene.lastFrameBuffer.clear();
      frameBuffer.drawTo(scene.lastFrameBuffer);
    }
    scene.executeDrawCommands();
    Bullet.DebugDrawer debugDrawer=(Bullet.DebugDrawer)scene.world.getDebugDrawer();
    debugDrawer.drawWorld(scene.world,scene.camera.data);
    profiler.stop(""String_Node_Str"");
  }
  mouse.wheelMove=0;
  Bdx.display.changed=false;
  profiler.stop(""String_Node_Str"");
  if (profiler.active()) {
    if (profiler.gl.active()) {
      profiler.gl.updateStats();
    }
    profiler.updateVariables();
    profiler.updateSubsystems();
    if (profiler.visible()) {
      profiler.updateVisible();
      profiler.scene.update();
      Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
      renderWorld(modelBatch,profiler.scene,profiler.scene.camera);
      profiler.scene.executeDrawCommands();
    }
    if (profiler.gl.active()) {
      profiler.gl.reset();
      profiler.gl.updateFields();
    }
  }
  if (requestedRestart) {
    requestedRestart=false;
    Scene.clearColorDefaultSet=false;
    dispose();
    for (    Scene scene : new ArrayList<Scene>(scenes)) {
      scenes.remove(scene);
      scene.end();
    }
    profiler.end();
    init();
    scenes.add(firstScene);
  }
  shaderProvider.handleMaterialShaderChanges();
  profiler.start(""String_Node_Str"");
}","public static void main(){
  profiler.stop(""String_Node_Str"");
  if (restartOnExport && Gdx.files.internal(""String_Node_Str"").lastModified() > startMillis) {
    startMillis=System.currentTimeMillis();
    restart();
  }
  boolean screenShadersUsed=false;
  for (  Scene scene : scenes) {
    if (scene.screenShaders.size() > 0) {
      screenShadersUsed=true;
      break;
    }
  }
  profiler.start(""String_Node_Str"");
  Gdx.gl.glClearColor(display.clearColor.r,display.clearColor.g,display.clearColor.b,display.clearColor.a);
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  Gdx.gl.glClearColor(0,0,0,0);
  Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
  profiler.stop(""String_Node_Str"");
  time+=TICK_TIME * timeSpeed;
  ++GdxProcessor.currentTick;
  fingers.clear();
  for (  Finger f : allocatedFingers) {
    if (f.down() || f.up())     fingers.add(f);
  }
  profiler.stop(""String_Node_Str"");
  for (  Component c : components) {
    if (c.state != null)     c.state.main();
  }
  profiler.stop(""String_Node_Str"");
  Viewport vp;
  ArrayListScenes newSceneList=(ArrayListScenes)scenes.clone();
  boolean depthBufferCleared=false;
  boolean colorBufferCleared=false;
  ArrayList<Scene> depthRenderScenes=new ArrayList<Scene>();
  for (int s=0; s < scenes.size(); s++) {
    Scene scene=scenes.get(s);
    for (    ScreenShader filter : scene.screenShaders) {
      if (filter.usingDepthTexture()) {
        depthRenderScenes.add(scene);
        for (int ns=s; ns >= 0; ns--) {
          if (scenes.get(ns).renderPassthrough)           depthRenderScenes.add(scenes.get(ns));
 else           break;
        }
        break;
      }
    }
  }
  for (int i=0; i < newSceneList.size(); i++) {
    final Scene scene=newSceneList.get(i);
    boolean prevSceneRenderPassthrough=false;
    boolean nextSceneRenderPassthrough=false;
    if (i > 0)     prevSceneRenderPassthrough=newSceneList.get(i - 1).renderPassthrough;
    if (i < newSceneList.size() - 1)     nextSceneRenderPassthrough=newSceneList.get(i + 1).renderPassthrough;
    if (!prevSceneRenderPassthrough) {
      colorBufferCleared=false;
      depthBufferCleared=false;
    }
    scene.update();
    profiler.stop(""String_Node_Str"");
    if (!scene.valid() || !scene.visible)     continue;
    vp=scene.viewport;
    vp.apply();
    final float vpw=vp.w;
    final float vph=vp.h;
    if (defaultScreenShaderUniformSet == null) {
      defaultScreenShaderUniformSet=new UniformSet(){
        @Override public void set(        ShaderProgram program){
          program.setUniformf(""String_Node_Str"",Bdx.time);
          program.setUniformi(""String_Node_Str"",1);
          program.setUniformi(""String_Node_Str"",2);
          program.setUniformf(""String_Node_Str"",vpw * display.downsample());
          program.setUniformf(""String_Node_Str"",vph * display.downsample());
          program.setUniformf(""String_Node_Str"",scene.camera.near());
          program.setUniformf(""String_Node_Str"",scene.camera.far());
        }
      }
;
    }
    depthShaderProvider.update(scene);
    shaderProvider.update(scene);
    for (    Camera cam : scene.cameras) {
      if (cam.renderToTexture) {
        cam.update();
        if (cam.renderBuffer == null)         cam.updateRenderBuffer();
        cam.renderBuffer.begin();
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT | GL20.GL_COLOR_BUFFER_BIT);
        renderWorld(modelBatch,scene,cam);
        cam.renderBuffer.end();
      }
    }
    boolean frameBufferInUse=false;
    if (display.downsample != 1 || scene.screenShaders.size() > 0 || (screenShadersUsed && scene.renderPassthrough)) {
      frameBuffer.begin();
      frameBufferInUse=true;
      if (!colorBufferCleared) {
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        colorBufferCleared=true;
      }
    }
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
    renderWorld(modelBatch,scene,scene.camera);
    if (frameBufferInUse) {
      frameBuffer.end();
      if (depthRenderScenes.contains(scene)) {
        Gdx.gl.glClearColor(1,1,1,1);
        depthBuffer.begin();
        if (!depthBufferCleared) {
          Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
          depthBufferCleared=true;
        }
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
        renderWorld(depthBatch,scene,scene.camera);
        depthBuffer.end();
        depthBuffer.getColorBufferTexture().bind(2);
      }
      scene.lastFrameBuffer.getColorBufferTexture().bind(1);
      Gdx.gl.glActiveTexture(GL20.GL_TEXTURE0);
      Gdx.gl.glClearColor(0,0,0,0);
      for (      ScreenShader filter : scene.screenShaders) {
        filter.compile();
        if (!filter.active)         continue;
        if (!filter.uniformSets.contains(defaultScreenShaderUniformSet))         filter.uniformSets.add(defaultScreenShaderUniformSet);
        if (!availableTempBuffers.containsKey(filter.renderScale.x)) {
          int fx=Math.max(1,(int)(vp.size().x * filter.renderScale.x * display.downsample()));
          int fy=Math.max(1,(int)(vp.size().y * filter.renderScale.y * display.downsample()));
          availableTempBuffers.put(filter.renderScale.x,new RenderBuffer(spriteBatch,fx,fy));
        }
        RenderBuffer tempBuffer=availableTempBuffers.get(filter.renderScale.x);
        tempBuffer.clear();
        frameBuffer.drawTo(tempBuffer,filter,0,0,Gdx.graphics.getWidth(),Gdx.graphics.getHeight());
        if (!filter.overlay)         frameBuffer.clear();
        tempBuffer.drawTo(frameBuffer);
      }
      if (!scene.renderPassthrough || scene == newSceneList.get(newSceneList.size() - 1) || !nextSceneRenderPassthrough)       frameBuffer.drawTo(null,null,vp.x,vp.y,vp.w,vp.h);
      scene.lastFrameBuffer.clear();
      frameBuffer.drawTo(scene.lastFrameBuffer);
    }
    scene.executeDrawCommands();
    Bullet.DebugDrawer debugDrawer=(Bullet.DebugDrawer)scene.world.getDebugDrawer();
    debugDrawer.drawWorld(scene.world,scene.camera.data);
    profiler.stop(""String_Node_Str"");
  }
  mouse.wheelMove=0;
  Bdx.display.changed=false;
  profiler.stop(""String_Node_Str"");
  if (profiler.active()) {
    if (profiler.gl.active()) {
      profiler.gl.updateStats();
    }
    profiler.updateVariables();
    profiler.updateSubsystems();
    if (profiler.visible()) {
      profiler.updateVisible();
      profiler.scene.update();
      Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
      renderWorld(modelBatch,profiler.scene,profiler.scene.camera);
      profiler.scene.executeDrawCommands();
    }
    if (profiler.gl.active()) {
      profiler.gl.reset();
      profiler.gl.updateFields();
    }
  }
  if (requestedRestart) {
    requestedRestart=false;
    Scene.clearColorDefaultSet=false;
    dispose();
    for (    Scene scene : new ArrayList<Scene>(scenes)) {
      scenes.remove(scene);
      scene.end();
    }
    profiler.end();
    init();
    scenes.add(firstScene);
  }
  shaderProvider.handleMaterialShaderChanges();
  profiler.start(""String_Node_Str"");
}","The original code had incorrect uniform and buffer scaling, leading to potential rendering inaccuracies and performance issues. The fixed code corrects uniform scaling by multiplying viewport dimensions with display downsampling and adjusts buffer creation to use precise viewport and filter render scales. These modifications ensure more accurate rendering, better shader uniform handling, and improved visual consistency across different display configurations."
94229,"public static void resize(int width,int height){
  spriteBatch.getProjectionMatrix().setToOrtho2D(0,0,width,height);
  if (frameBuffer != null)   frameBuffer.dispose();
  if (depthBuffer != null)   depthBuffer.dispose();
  int fx=Math.max(1,(int)(Gdx.graphics.getWidth() * display.downsample()));
  int fy=Math.max(1,(int)(Gdx.graphics.getHeight() * display.downsample()));
  frameBuffer=new RenderBuffer(spriteBatch,fx,fy);
  depthBuffer=new RenderBuffer(spriteBatch,fx,fy);
  for (  RenderBuffer b : availableTempBuffers.values())   b.dispose();
  availableTempBuffers.clear();
  for (  Scene scene : scenes) {
    for (    Camera cam : scene.cameras) {
      if (cam.renderBuffer != null)       cam.renderBuffer.dispose();
      cam.renderBuffer=null;
    }
    if (scene.lastFrameBuffer != null)     scene.lastFrameBuffer.dispose();
    scene.lastFrameBuffer=new RenderBuffer(spriteBatch,fx,fy);
    scene.viewport.update(width,height);
  }
  if (profiler.visible()) {
    profiler.updateViewport(width,height);
  }
  Bdx.display.changed=true;
}","public static void resize(int width,int height){
  spriteBatch.getProjectionMatrix().setToOrtho2D(0,0,width,height);
  if (frameBuffer != null)   frameBuffer.dispose();
  if (depthBuffer != null)   depthBuffer.dispose();
  int fx=Math.max(1,(int)(Gdx.graphics.getWidth() * display.downsample()));
  int fy=Math.max(1,(int)(Gdx.graphics.getHeight() * display.downsample()));
  frameBuffer=new RenderBuffer(spriteBatch,fx,fy);
  depthBuffer=new RenderBuffer(spriteBatch,fx,fy);
  for (  RenderBuffer b : availableTempBuffers.values())   b.dispose();
  availableTempBuffers.clear();
  for (  Scene scene : scenes) {
    for (    Camera cam : scene.cameras)     cam.updateRenderBuffer();
    if (scene.lastFrameBuffer != null)     scene.lastFrameBuffer.dispose();
    scene.lastFrameBuffer=new RenderBuffer(spriteBatch,fx,fy);
    scene.viewport.update(width,height);
  }
  if (profiler.visible()) {
    profiler.updateViewport(width,height);
  }
  Bdx.display.changed=true;
}","The original code manually disposed of camera render buffers and set them to null, which could lead to resource leaks and inefficient memory management. The fixed code introduces a method `updateRenderBuffer()` for cameras, which likely handles proper resource management and buffer updates more systematically. This change simplifies the resize logic, reduces potential memory-related errors, and provides a more modular approach to handling render buffer updates across scenes."
94230,"public void updateRenderBuffer(){
  if (renderBuffer != null)   renderBuffer.dispose();
  initRenderBuffer();
}","public void updateRenderBuffer(){
  int targetX=Math.max(1,Math.round(resolution.x * Bdx.display.downsample()));
  int targetY=Math.max(1,Math.round(resolution.y * Bdx.display.downsample()));
  if (renderBuffer == null || (renderBuffer.getWidth() != targetX || renderBuffer.getHeight() != targetY)) {
    if (renderBuffer != null)     renderBuffer.dispose();
    renderBuffer=new RenderBuffer(null,targetX,targetY);
  }
}","The original code blindly disposes of the render buffer without checking if a new buffer is actually needed, potentially causing unnecessary resource reallocation. The fixed code introduces dynamic size calculations based on resolution and display downsampling, and only recreates the render buffer when its dimensions have changed or it doesn't exist. This approach optimizes resource management by preventing redundant buffer disposals and recreations, ensuring efficient rendering performance."
94231,"private void removeObjects(){
  for (  GameObject g : toBeRemoved) {
    g.parent(null);
    if (g.body.isInWorld())     world.removeRigidBody(g.body);
    g.body.setUserPointer(null);
    objects.remove(g);
    if (g instanceof Light)     lights.remove(g);
    if (g.mesh().instances.size() == 0 && g.mesh().autoDispose)     g.mesh().dispose();
    scene=null;
  }
  toBeRemoved.clear();
}","private void removeObjects(){
  for (  GameObject g : toBeRemoved) {
    g.parent(null);
    if (g.body.isInWorld())     world.removeRigidBody(g.body);
    g.body.setUserPointer(null);
    objects.remove(g);
    if (g instanceof Light)     lights.remove(g);
    if (g.mesh().instances.size() == 0 && g.mesh().autoDispose)     g.mesh().dispose();
    g.scene=null;
  }
  toBeRemoved.clear();
}","The original code attempts to modify the `scene` reference, but incorrectly tries to set `scene=null` directly on the loop variable, which is not possible. The fixed code changes `scene=null` to `g.scene=null`, correctly setting the scene reference to null for each individual game object being removed. This correction ensures proper scene management and prevents potential null pointer or reference errors during object removal."
94232,"public void update(){
  if (!paused) {
    Bdx.profiler.start(""String_Node_Str"");
    runObjectLogic();
    Bdx.profiler.stop(""String_Node_Str"");
    updateVisuals();
    for (    Camera cam : cameras) {
      if (cam == camera || cam.renderToTexture)       cam.update();
    }
    Bdx.profiler.stop(""String_Node_Str"");
    try {
      world.stepSimulation(Bdx.TICK_TIME * Bdx.physicsSpeed,0);
    }
 catch (    NullPointerException e) {
      throw new RuntimeException(""String_Node_Str"");
    }
    Bdx.profiler.stop(""String_Node_Str"");
    updateChildBodies();
    Bdx.profiler.stop(""String_Node_Str"");
    detectCollisions();
    Bdx.profiler.stop(""String_Node_Str"");
  }
}","public void update(){
  if (requestedRestart) {
    for (    GameObject g : objects) {
      g.endNoChildren();
    }
    dispose();
    init();
  }
  if (requestedEnd) {
    valid=false;
    dispose();
    if (Bdx.scenes.contains(this))     Bdx.scenes.remove(this);
  }
 else   if (!paused) {
    Bdx.profiler.start(""String_Node_Str"");
    runObjectLogic();
    Bdx.profiler.stop(""String_Node_Str"");
    updateVisuals();
    for (    Camera cam : cameras) {
      if (cam == camera || cam.renderToTexture)       cam.update();
    }
    Bdx.profiler.stop(""String_Node_Str"");
    try {
      world.stepSimulation(Bdx.TICK_TIME * Bdx.physicsSpeed,0);
    }
 catch (    NullPointerException e) {
      throw new RuntimeException(""String_Node_Str"");
    }
    Bdx.profiler.stop(""String_Node_Str"");
    updateChildBodies();
    Bdx.profiler.stop(""String_Node_Str"");
    detectCollisions();
    Bdx.profiler.stop(""String_Node_Str"");
  }
}","The original code lacked proper scene management logic, with multiple unnecessary `Bdx.profiler.stop()` calls and no handling for scene restart or end scenarios. The fixed code adds two critical conditional blocks to handle `requestedRestart` and `requestedEnd` states, enabling proper scene lifecycle management and object cleanup before physics and rendering updates. These changes ensure robust scene transitions, preventing potential memory leaks and providing a cleaner mechanism for scene state management."
94233,"private void runObjectLogic(){
  if (requestedRestart) {
    for (    GameObject g : objects) {
      g.endNoChildren();
    }
    dispose();
    init();
  }
  Bdx.mouse.init(this);
  for (  Finger f : Bdx.fingers) {
    f.init(this);
  }
  for (  GameObject g : objects) {
    if (g.bodyType() == GameObject.BodyType.SENSOR)     g.body.activate(true);
    if (!g.valid())     continue;
    if (g instanceof Light)     ((Light)g).updateLight();
    for (    Component c : g.components) {
      if (c.state != null) {
        if (c.logicCounter >= 1) {
          c.logicCounter-=1;
          c.state.main();
        }
        c.logicCounter+=c.logicFrequency * Bdx.TICK_TIME;
      }
    }
    if (g.logicCounter >= 1) {
      g.logicCounter-=1;
      g.main();
    }
    g.logicCounter+=g.logicFrequency * Bdx.TICK_TIME;
  }
  for (  GameObject g : toBeAdded) {
    objects.add(g);
    if (g instanceof Light)     lights.add((Light)g);
  }
  toBeAdded.clear();
  for (  GameObject g : toBeRemoved) {
    g.parent(null);
    world.removeRigidBody(g.body);
    objects.remove(g);
    if (g instanceof Light)     lights.remove(g);
  }
  toBeRemoved.clear();
  if (requestedEnd) {
    valid=false;
    dispose();
    if (Bdx.scenes.contains(this))     Bdx.scenes.remove(this);
  }
}","private void runObjectLogic(){
  Bdx.mouse.init(this);
  for (  Finger f : Bdx.fingers) {
    f.init(this);
  }
  for (  GameObject g : objects) {
    if (g.bodyType() == GameObject.BodyType.SENSOR)     g.body.activate(true);
    if (!g.valid())     continue;
    if (g instanceof Light)     ((Light)g).updateLight();
    for (    Component c : g.components) {
      if (c.state != null) {
        if (c.logicCounter >= 1) {
          c.logicCounter-=1;
          c.state.main();
        }
        c.logicCounter+=c.logicFrequency * Bdx.TICK_TIME;
      }
    }
    if (g.logicCounter >= 1) {
      g.logicCounter-=1;
      g.main();
    }
    g.logicCounter+=g.logicFrequency * Bdx.TICK_TIME;
  }
  for (  GameObject g : toBeAdded) {
    objects.add(g);
    if (g instanceof Light)     lights.add((Light)g);
  }
  toBeAdded.clear();
  for (  GameObject g : toBeRemoved) {
    g.parent(null);
    world.removeRigidBody(g.body);
    objects.remove(g);
    if (g instanceof Light)     lights.remove(g);
  }
  toBeRemoved.clear();
}","The original code had potential issues with scene restart and termination logic, which could lead to unpredictable behavior during scene transitions. The fixed code removes the `requestedRestart` and `requestedEnd` conditional blocks, streamlining the object logic execution without interrupting the core processing flow. By eliminating these conditional branches, the code now ensures a more consistent and predictable object update mechanism across scene management operations."
94234,"public void end(){
  if (gl.active()) {
    gl.active(false);
  }
  scene.end();
}","public void end(){
  if (gl.active())   gl.active(false);
  if (scene != null)   scene.end();
}","The original code lacks null-checking for the scene object, which could potentially cause a NullPointerException if scene is null. The fixed code adds an explicit null check for scene before calling scene.end(), and simplifies the gl.active() method call by removing unnecessary braces. These changes make the method more robust by preventing runtime errors and improving code readability while maintaining the same core functionality."
94235,"public void update(){
  if (requestedRestart) {
    for (    GameObject g : objects) {
      g.endNoChildren();
    }
    dispose();
    init();
  }
  if (requestedEnd) {
    valid=false;
    dispose();
    if (Bdx.scenes.contains(this))     Bdx.scenes.remove(this);
  }
 else   if (!paused) {
    Bdx.profiler.start(""String_Node_Str"");
    runObjectLogic();
    Bdx.profiler.stop(""String_Node_Str"");
    updateVisuals();
    for (    Camera cam : cameras) {
      if (cam == camera || cam.renderToTexture)       cam.update();
    }
    Bdx.profiler.stop(""String_Node_Str"");
    try {
      world.stepSimulation(Bdx.TICK_TIME * Bdx.physicsSpeed,0);
    }
 catch (    NullPointerException e) {
      throw new RuntimeException(""String_Node_Str"");
    }
    Bdx.profiler.stop(""String_Node_Str"");
    updateChildBodies();
    Bdx.profiler.stop(""String_Node_Str"");
    detectCollisions();
    Bdx.profiler.stop(""String_Node_Str"");
  }
}","public void update(){
  if (!paused) {
    Bdx.profiler.start(""String_Node_Str"");
    runObjectLogic();
    Bdx.profiler.stop(""String_Node_Str"");
    updateVisuals();
    for (    Camera cam : cameras) {
      if (cam == camera || cam.renderToTexture)       cam.update();
    }
    Bdx.profiler.stop(""String_Node_Str"");
    try {
      world.stepSimulation(Bdx.TICK_TIME * Bdx.physicsSpeed,0);
    }
 catch (    NullPointerException e) {
      throw new RuntimeException(""String_Node_Str"");
    }
    Bdx.profiler.stop(""String_Node_Str"");
    updateChildBodies();
    Bdx.profiler.stop(""String_Node_Str"");
    detectCollisions();
    Bdx.profiler.stop(""String_Node_Str"");
  }
  if (requestedEnd) {
    valid=false;
    dispose();
    if (Bdx.scenes.contains(this))     Bdx.scenes.remove(this);
  }
 else   if (requestedRestart) {
    dispose();
    init();
  }
}","The original code erroneously executed scene restart and end logic before the main update sequence, potentially causing unintended interruptions to game state. The fixed code reorders the conditional blocks, moving scene management logic after the primary update process and ensuring that game logic completes before scene-level changes occur. This restructuring prevents premature scene termination and maintains a more predictable and stable game update cycle."
94236,"public static void main(){
  profiler.stop(""String_Node_Str"");
  profiler.deltaTimes.put(""String_Node_Str"",(long)Math.max(profiler.deltaTimes.get(""String_Node_Str"") - (TICK_TIME * 1000000000),0));
  if (restartOnExport) {
    FileHandle done=Gdx.files.internal(""String_Node_Str"");
    if (done.exists()) {
      done.file().delete();
      restart();
    }
  }
  boolean screenShadersUsed=false;
  for (  Scene scene : scenes) {
    if (scene.screenShaders.size() > 0) {
      screenShadersUsed=true;
      break;
    }
  }
  profiler.start(""String_Node_Str"");
  Gdx.gl.glClearColor(display.clearColor.r,display.clearColor.g,display.clearColor.b,display.clearColor.a);
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  Gdx.gl.glClearColor(0,0,0,0);
  Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
  profiler.stop(""String_Node_Str"");
  time+=TICK_TIME * timeSpeed;
  ++GdxProcessor.currentTick;
  fingers.clear();
  for (  Finger f : allocatedFingers) {
    if (f.down() || f.up())     fingers.add(f);
  }
  profiler.stop(""String_Node_Str"");
  for (  Component c : components) {
    if (c.state != null)     c.state.main();
  }
  profiler.stop(""String_Node_Str"");
  Viewport vp;
  ArrayListScenes newSceneList=(ArrayListScenes)scenes.clone();
  boolean depthBufferCleared=false;
  boolean colorBufferCleared=false;
  for (int i=0; i < newSceneList.size(); i++) {
    Scene scene=newSceneList.get(i);
    boolean prevSceneRenderPassthrough=false;
    boolean nextSceneRenderPassthrough=false;
    if (i > 0)     prevSceneRenderPassthrough=newSceneList.get(i - 1).renderPassthrough;
    if (i < newSceneList.size() - 1)     nextSceneRenderPassthrough=newSceneList.get(i + 1).renderPassthrough;
    if (!prevSceneRenderPassthrough) {
      colorBufferCleared=false;
      depthBufferCleared=false;
    }
    scene.update();
    profiler.stop(""String_Node_Str"");
    if (!scene.valid() || !scene.visible)     continue;
    vp=scene.viewport;
    vp.apply();
    depthShaderProvider.update(scene);
    shaderProvider.update(scene);
    boolean frameBufferInUse=false;
    if (scene.screenShaders.size() > 0 || (screenShadersUsed && scene.renderPassthrough)) {
      frameBuffer.begin();
      frameBufferInUse=true;
      if (!colorBufferCleared) {
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        colorBufferCleared=true;
      }
    }
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
    renderWorld(modelBatch,scene,scene.camera);
    for (    Camera cam : scene.cameras) {
      if (cam.renderToTexture) {
        cam.update();
        if (cam.renderBuffer == null) {
          cam.initRenderBuffer();
        }
        cam.renderBuffer.begin();
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT | GL20.GL_COLOR_BUFFER_BIT);
        renderWorld(modelBatch,scene,cam);
        cam.renderBuffer.end();
      }
    }
    if (frameBufferInUse) {
      frameBuffer.end();
      boolean usingDepth=false;
      for (      ScreenShader filter : scene.screenShaders) {
        if (filter.usingDepthTexture())         usingDepth=true;
      }
      if (usingDepth || scene.renderPassthrough) {
        Gdx.gl.glClearColor(1,1,1,1);
        depthBuffer.begin();
        if (!depthBufferCleared) {
          Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
          depthBufferCleared=true;
        }
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
        renderWorld(depthBatch,scene,scene.camera);
        depthBuffer.end();
        depthBuffer.getColorBufferTexture().bind(2);
      }
      scene.lastFrameBuffer.getColorBufferTexture().bind(1);
      Gdx.gl.glActiveTexture(GL20.GL_TEXTURE0);
      Gdx.gl.glClearColor(0,0,0,0);
      for (      ScreenShader filter : scene.screenShaders) {
        if (!filter.active)         continue;
        filter.begin();
        filter.setUniformf(""String_Node_Str"",Bdx.time);
        filter.setUniformi(""String_Node_Str"",1);
        filter.setUniformi(""String_Node_Str"",2);
        filter.setUniformf(""String_Node_Str"",vp.w);
        filter.setUniformf(""String_Node_Str"",vp.h);
        filter.setUniformf(""String_Node_Str"",scene.camera.near());
        filter.setUniformf(""String_Node_Str"",scene.camera.far());
        filter.end();
        if (!availableTempBuffers.containsKey(filter.renderScale.x))         availableTempBuffers.put(filter.renderScale.x,new RenderBuffer(spriteBatch,Math.round(vp.size().x * filter.renderScale.x),Math.round(vp.size().y * filter.renderScale.y)));
        RenderBuffer tempBuffer=availableTempBuffers.get(filter.renderScale.x);
        tempBuffer.clear();
        frameBuffer.drawTo(tempBuffer,filter,0,0,frameBuffer.getWidth(),frameBuffer.getHeight());
        if (!filter.overlay)         frameBuffer.clear();
        tempBuffer.drawTo(frameBuffer);
      }
      if (!scene.renderPassthrough || scene == newSceneList.get(newSceneList.size() - 1) || !nextSceneRenderPassthrough)       frameBuffer.drawTo(null,null,vp.x,vp.y,vp.w,vp.h);
      scene.lastFrameBuffer.clear();
      frameBuffer.drawTo(scene.lastFrameBuffer);
    }
    scene.executeDrawCommands();
    Bullet.DebugDrawer debugDrawer=(Bullet.DebugDrawer)scene.world.getDebugDrawer();
    debugDrawer.drawWorld(scene.world,scene.camera.data);
    profiler.stop(""String_Node_Str"");
  }
  mouse.wheelMove=0;
  Bdx.display.changed=false;
  profiler.stop(""String_Node_Str"");
  profiler.updateVariables();
  if (profiler.visible()) {
    profiler.updateVisible();
    profiler.scene.update();
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
    renderWorld(modelBatch,profiler.scene,profiler.scene.camera);
    profiler.scene.executeDrawCommands();
  }
  if (profiler.gl.isEnabled()) {
    profiler.gl.updateFields();
  }
  if (requestedRestart) {
    requestedRestart=false;
    Scene.clearColorDefaultSet=false;
    dispose();
    for (    Scene scene : new ArrayList<Scene>(scenes)) {
      scenes.remove(scene);
      scene.end();
    }
    if (profiler.visible()) {
      profiler.scene.end();
    }
    init();
    scenes.add(firstScene);
  }
  profiler.start(""String_Node_Str"");
}","public static void main(){
  profiler.stop(""String_Node_Str"");
  profiler.deltaTimes.put(""String_Node_Str"",(long)Math.max(profiler.deltaTimes.get(""String_Node_Str"") - (TICK_TIME * 1000000000),0));
  if (restartOnExport && Gdx.files.internal(""String_Node_Str"").lastModified() > startMillis) {
    startMillis=System.currentTimeMillis();
    restart();
  }
  boolean screenShadersUsed=false;
  for (  Scene scene : scenes) {
    if (scene.screenShaders.size() > 0) {
      screenShadersUsed=true;
      break;
    }
  }
  profiler.start(""String_Node_Str"");
  Gdx.gl.glClearColor(display.clearColor.r,display.clearColor.g,display.clearColor.b,display.clearColor.a);
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  Gdx.gl.glClearColor(0,0,0,0);
  Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
  profiler.stop(""String_Node_Str"");
  time+=TICK_TIME * timeSpeed;
  ++GdxProcessor.currentTick;
  fingers.clear();
  for (  Finger f : allocatedFingers) {
    if (f.down() || f.up())     fingers.add(f);
  }
  profiler.stop(""String_Node_Str"");
  for (  Component c : components) {
    if (c.state != null)     c.state.main();
  }
  profiler.stop(""String_Node_Str"");
  Viewport vp;
  ArrayListScenes newSceneList=(ArrayListScenes)scenes.clone();
  boolean depthBufferCleared=false;
  boolean colorBufferCleared=false;
  for (int i=0; i < newSceneList.size(); i++) {
    Scene scene=newSceneList.get(i);
    boolean prevSceneRenderPassthrough=false;
    boolean nextSceneRenderPassthrough=false;
    if (i > 0)     prevSceneRenderPassthrough=newSceneList.get(i - 1).renderPassthrough;
    if (i < newSceneList.size() - 1)     nextSceneRenderPassthrough=newSceneList.get(i + 1).renderPassthrough;
    if (!prevSceneRenderPassthrough) {
      colorBufferCleared=false;
      depthBufferCleared=false;
    }
    scene.update();
    profiler.stop(""String_Node_Str"");
    if (!scene.valid() || !scene.visible)     continue;
    vp=scene.viewport;
    vp.apply();
    depthShaderProvider.update(scene);
    shaderProvider.update(scene);
    boolean frameBufferInUse=false;
    if (scene.screenShaders.size() > 0 || (screenShadersUsed && scene.renderPassthrough)) {
      frameBuffer.begin();
      frameBufferInUse=true;
      if (!colorBufferCleared) {
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        colorBufferCleared=true;
      }
    }
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
    renderWorld(modelBatch,scene,scene.camera);
    for (    Camera cam : scene.cameras) {
      if (cam.renderToTexture) {
        cam.update();
        if (cam.renderBuffer == null) {
          cam.initRenderBuffer();
        }
        cam.renderBuffer.begin();
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT | GL20.GL_COLOR_BUFFER_BIT);
        renderWorld(modelBatch,scene,cam);
        cam.renderBuffer.end();
      }
    }
    if (frameBufferInUse) {
      frameBuffer.end();
      boolean usingDepth=false;
      for (      ScreenShader filter : scene.screenShaders) {
        if (filter.usingDepthTexture())         usingDepth=true;
      }
      if (usingDepth || scene.renderPassthrough) {
        Gdx.gl.glClearColor(1,1,1,1);
        depthBuffer.begin();
        if (!depthBufferCleared) {
          Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
          depthBufferCleared=true;
        }
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
        renderWorld(depthBatch,scene,scene.camera);
        depthBuffer.end();
        depthBuffer.getColorBufferTexture().bind(2);
      }
      scene.lastFrameBuffer.getColorBufferTexture().bind(1);
      Gdx.gl.glActiveTexture(GL20.GL_TEXTURE0);
      Gdx.gl.glClearColor(0,0,0,0);
      for (      ScreenShader filter : scene.screenShaders) {
        if (!filter.active)         continue;
        filter.begin();
        filter.setUniformf(""String_Node_Str"",Bdx.time);
        filter.setUniformi(""String_Node_Str"",1);
        filter.setUniformi(""String_Node_Str"",2);
        filter.setUniformf(""String_Node_Str"",vp.w);
        filter.setUniformf(""String_Node_Str"",vp.h);
        filter.setUniformf(""String_Node_Str"",scene.camera.near());
        filter.setUniformf(""String_Node_Str"",scene.camera.far());
        filter.end();
        if (!availableTempBuffers.containsKey(filter.renderScale.x))         availableTempBuffers.put(filter.renderScale.x,new RenderBuffer(spriteBatch,Math.round(vp.size().x * filter.renderScale.x),Math.round(vp.size().y * filter.renderScale.y)));
        RenderBuffer tempBuffer=availableTempBuffers.get(filter.renderScale.x);
        tempBuffer.clear();
        frameBuffer.drawTo(tempBuffer,filter,0,0,frameBuffer.getWidth(),frameBuffer.getHeight());
        if (!filter.overlay)         frameBuffer.clear();
        tempBuffer.drawTo(frameBuffer);
      }
      if (!scene.renderPassthrough || scene == newSceneList.get(newSceneList.size() - 1) || !nextSceneRenderPassthrough)       frameBuffer.drawTo(null,null,vp.x,vp.y,vp.w,vp.h);
      scene.lastFrameBuffer.clear();
      frameBuffer.drawTo(scene.lastFrameBuffer);
    }
    scene.executeDrawCommands();
    Bullet.DebugDrawer debugDrawer=(Bullet.DebugDrawer)scene.world.getDebugDrawer();
    debugDrawer.drawWorld(scene.world,scene.camera.data);
    profiler.stop(""String_Node_Str"");
  }
  mouse.wheelMove=0;
  Bdx.display.changed=false;
  profiler.stop(""String_Node_Str"");
  profiler.updateVariables();
  if (profiler.visible()) {
    profiler.updateVisible();
    profiler.scene.update();
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
    renderWorld(modelBatch,profiler.scene,profiler.scene.camera);
    profiler.scene.executeDrawCommands();
  }
  if (profiler.gl.isEnabled()) {
    profiler.gl.updateFields();
  }
  if (requestedRestart) {
    requestedRestart=false;
    Scene.clearColorDefaultSet=false;
    dispose();
    for (    Scene scene : new ArrayList<Scene>(scenes)) {
      scenes.remove(scene);
      scene.end();
    }
    if (profiler.visible()) {
      profiler.scene.end();
    }
    init();
    scenes.add(firstScene);
  }
  profiler.start(""String_Node_Str"");
}","The original code had a potential file-based restart mechanism that could lead to unintended behavior due to improper file existence checking. The fixed code replaces the direct file deletion with a more robust check using `lastModified()` and introduces a `startMillis` timestamp to track and control restart conditions more precisely. This improvement ensures a more reliable and controlled restart process, preventing potential race conditions and providing better synchronization between file modification and restart triggers."
94237,"public Gamepad(int i){
  index=i;
  Array controllers=Controllers.getControllers();
  if (controllers.size > index)   controller=(Controller)controllers.get(index);
 else   throw new IndexOutOfBoundsException(""String_Node_Str"" + index);
  controller.addListener(new GdxProcessor.GamepadAdapter(this));
  profiles=new HashMap<String,Profile>();
  Profile p=new Profile(""String_Node_Str"");
  p.btnToCode.put(""String_Node_Str"",3);
  p.btnToCode.put(""String_Node_Str"",4);
  p.btnToCode.put(""String_Node_Str"",0);
  p.btnToCode.put(""String_Node_Str"",1);
  p.btnToCode.put(""String_Node_Str"",5);
  p.btnToCode.put(""String_Node_Str"",2);
  p.btnToCode.put(""String_Node_Str"",6);
  p.btnToCode.put(""String_Node_Str"",7);
  p.btnToCode.put(""String_Node_Str"",8);
  p.btnToCode.put(""String_Node_Str"",9);
  p.axes.put(""String_Node_Str"",new Axis(0));
  p.axes.put(""String_Node_Str"",new Axis(1));
  p.axes.put(""String_Node_Str"",new Axis(3));
  p.axes.put(""String_Node_Str"",new Axis(4));
  p.axes.put(""String_Node_Str"",new Axis(2));
  p.axes.put(""String_Node_Str"",new Axis(5));
  p.sticks.put(""String_Node_Str"",new Stick(p.axes.get(""String_Node_Str""),p.axes.get(""String_Node_Str"")));
  p.sticks.put(""String_Node_Str"",new Stick(p.axes.get(""String_Node_Str""),p.axes.get(""String_Node_Str"")));
  p.processAxis=new Profile.FnProcessAxis(){
    public float[] eval(    int axis,    float value){
      if (axis == 2 || axis == 5) {
        value=(value + 1) / 2;
      }
      return new float[]{axis,value};
    }
  }
;
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.west.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.east.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.north.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.south.ordinal());
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  profiles.put(p.name,p);
  p=new Profile(""String_Node_Str"");
  p.btnToCode=new HashMap<String,Integer>(profiles.get(""String_Node_Str"").btnToCode);
  p.btnToCode.remove(""String_Node_Str"");
  p.btnToCode.remove(""String_Node_Str"");
  p.btnToCode.put(""String_Node_Str"",2);
  p.btnToCode.put(""String_Node_Str"",3);
  p.btnToCode.put(""String_Node_Str"",4);
  p.btnToCode.put(""String_Node_Str"",5);
  p.btnToCode.put(""String_Node_Str"",8);
  p.btnToCode.put(""String_Node_Str"",9);
  if (SharedLibraryLoader.isLinux) {
    p.btnToCode.put(""String_Node_Str"",9);
    p.btnToCode.put(""String_Node_Str"",10);
  }
  p.axes.put(""String_Node_Str"",new Axis(1));
  p.axes.put(""String_Node_Str"",new Axis(0));
  if (SharedLibraryLoader.isLinux) {
    p.axes.put(""String_Node_Str"",new Axis(0));
    p.axes.put(""String_Node_Str"",new Axis(1));
  }
  p.axes.put(""String_Node_Str"",new Axis(3));
  p.axes.put(""String_Node_Str"",new Axis(2));
  if (SharedLibraryLoader.isLinux) {
    p.axes.put(""String_Node_Str"",new Axis(3));
    p.axes.put(""String_Node_Str"",new Axis(4));
  }
  p.axes.put(""String_Node_Str"",new Axis(4));
  p.axes.put(""String_Node_Str"",new Axis(5));
  if (SharedLibraryLoader.isLinux) {
    p.axes.put(""String_Node_Str"",new Axis(2));
    p.axes.put(""String_Node_Str"",new Axis(5));
  }
  p.sticks.put(""String_Node_Str"",new Stick(p.axes.get(""String_Node_Str""),p.axes.get(""String_Node_Str"")));
  p.sticks.put(""String_Node_Str"",new Stick(p.axes.get(""String_Node_Str""),p.axes.get(""String_Node_Str"")));
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.processAxis=new Profile.FnProcessAxis(){
    public float[] eval(    int axis,    float value){
      if (SharedLibraryLoader.isWindows) {
        if (axis == 4 && value < 0) {
          axis=5;
          value=-value;
        }
      }
 else       if ((SharedLibraryLoader.isLinux) && (axis == axes.get(""String_Node_Str"").code || axis == axes.get(""String_Node_Str"").code)) {
        value+=1;
        value/=2;
        value=Math.min(Math.max(value,0),1);
      }
      return new float[]{axis,value};
    }
  }
;
  profiles.put(p.name,p);
  p=new Profile(""String_Node_Str"");
  for (int a=0; a < 32; a++)   p.btnToCode.put(""String_Node_Str"" + String.valueOf(a),a);
  for (int a=0; a < 16; a++) {
    String axisName=""String_Node_Str"" + String.valueOf(a);
    Axis axis=new Axis(a);
    p.axes.put(axisName,axis);
    p.btnToCode.put(axisName + ""String_Node_Str"",-200 - axis.code);
    p.btnToCode.put(axisName + ""String_Node_Str"",200 + axis.code);
  }
  for (int a=0; a < 8; a++) {
    Stick s=new Stick(p.axes.get(""String_Node_Str"" + String.valueOf(a * 2)),p.axes.get(""String_Node_Str"" + String.valueOf(a * 2 + 1)));
    p.sticks.put(""String_Node_Str"" + String.valueOf(a),s);
  }
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.west.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.east.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.north.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.south.ordinal());
  profiles.put(p.name,p);
  profile(""String_Node_Str"");
}","public Gamepad(int i){
  index=i;
  Array controllers=Controllers.getControllers();
  if (controllers.size > index)   controller=(Controller)controllers.get(index);
 else   throw new IndexOutOfBoundsException(""String_Node_Str"" + index);
  controller.addListener(new GdxProcessor.GamepadAdapter(this));
  profiles=new HashMap<String,Profile>();
  Profile p=new Profile(""String_Node_Str"");
  p.btnToCode.put(""String_Node_Str"",3);
  p.btnToCode.put(""String_Node_Str"",4);
  p.btnToCode.put(""String_Node_Str"",0);
  p.btnToCode.put(""String_Node_Str"",1);
  p.btnToCode.put(""String_Node_Str"",5);
  p.btnToCode.put(""String_Node_Str"",2);
  p.btnToCode.put(""String_Node_Str"",6);
  p.btnToCode.put(""String_Node_Str"",7);
  p.btnToCode.put(""String_Node_Str"",8);
  p.btnToCode.put(""String_Node_Str"",9);
  p.axes.put(""String_Node_Str"",new Axis(0));
  p.axes.put(""String_Node_Str"",new Axis(1));
  p.axes.put(""String_Node_Str"",new Axis(3));
  p.axes.put(""String_Node_Str"",new Axis(4));
  p.axes.put(""String_Node_Str"",new Axis(2));
  p.axes.put(""String_Node_Str"",new Axis(5));
  p.sticks.put(""String_Node_Str"",new Stick(p.axes.get(""String_Node_Str""),p.axes.get(""String_Node_Str"")));
  p.sticks.put(""String_Node_Str"",new Stick(p.axes.get(""String_Node_Str""),p.axes.get(""String_Node_Str"")));
  p.processAxis=new Profile.FnProcessAxis(){
    public float[] eval(    int axis,    float value){
      if (axis == 2 || axis == 5) {
        value=(value + 1) / 2;
      }
      return new float[]{axis,value};
    }
  }
;
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.west.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.east.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.north.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.south.ordinal());
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  profiles.put(p.name,p);
  p=new Profile(""String_Node_Str"");
  p.btnToCode=new HashMap<String,Integer>(profiles.get(""String_Node_Str"").btnToCode);
  p.btnToCode.remove(""String_Node_Str"");
  p.btnToCode.remove(""String_Node_Str"");
  p.btnToCode.put(""String_Node_Str"",2);
  p.btnToCode.put(""String_Node_Str"",3);
  p.btnToCode.put(""String_Node_Str"",4);
  p.btnToCode.put(""String_Node_Str"",5);
  p.btnToCode.put(""String_Node_Str"",8);
  p.btnToCode.put(""String_Node_Str"",9);
  String os=System.getProperty(""String_Node_Str"");
  if (os.contains(""String_Node_Str"")) {
    p.btnToCode.put(""String_Node_Str"",9);
    p.btnToCode.put(""String_Node_Str"",10);
  }
  p.axes.put(""String_Node_Str"",new Axis(1));
  p.axes.put(""String_Node_Str"",new Axis(0));
  if (os.contains(""String_Node_Str"")) {
    p.axes.put(""String_Node_Str"",new Axis(0));
    p.axes.put(""String_Node_Str"",new Axis(1));
  }
  p.axes.put(""String_Node_Str"",new Axis(3));
  p.axes.put(""String_Node_Str"",new Axis(2));
  if (os.contains(""String_Node_Str"")) {
    p.axes.put(""String_Node_Str"",new Axis(3));
    p.axes.put(""String_Node_Str"",new Axis(4));
  }
  p.axes.put(""String_Node_Str"",new Axis(4));
  p.axes.put(""String_Node_Str"",new Axis(5));
  if (os.contains(""String_Node_Str"")) {
    p.axes.put(""String_Node_Str"",new Axis(2));
    p.axes.put(""String_Node_Str"",new Axis(5));
  }
  p.sticks.put(""String_Node_Str"",new Stick(p.axes.get(""String_Node_Str""),p.axes.get(""String_Node_Str"")));
  p.sticks.put(""String_Node_Str"",new Stick(p.axes.get(""String_Node_Str""),p.axes.get(""String_Node_Str"")));
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",-200 - p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.btnToCode.put(""String_Node_Str"",200 + p.axes.get(""String_Node_Str"").code);
  p.processAxis=new Profile.FnProcessAxis(){
    public float[] eval(    int axis,    float value){
      String os=System.getProperty(""String_Node_Str"");
      if (os.contains(""String_Node_Str"")) {
        if (axis == 4 && value < 0) {
          axis=5;
          value=-value;
        }
      }
 else       if ((os.contains(""String_Node_Str"")) && (axis == axes.get(""String_Node_Str"").code || axis == axes.get(""String_Node_Str"").code)) {
        value+=1;
        value/=2;
        value=Math.min(Math.max(value,0),1);
      }
      return new float[]{axis,value};
    }
  }
;
  profiles.put(p.name,p);
  p=new Profile(""String_Node_Str"");
  for (int a=0; a < 32; a++)   p.btnToCode.put(""String_Node_Str"" + String.valueOf(a),a);
  for (int a=0; a < 16; a++) {
    String axisName=""String_Node_Str"" + String.valueOf(a);
    Axis axis=new Axis(a);
    p.axes.put(axisName,axis);
    p.btnToCode.put(axisName + ""String_Node_Str"",-200 - axis.code);
    p.btnToCode.put(axisName + ""String_Node_Str"",200 + axis.code);
  }
  for (int a=0; a < 8; a++) {
    Stick s=new Stick(p.axes.get(""String_Node_Str"" + String.valueOf(a * 2)),p.axes.get(""String_Node_Str"" + String.valueOf(a * 2 + 1)));
    p.sticks.put(""String_Node_Str"" + String.valueOf(a),s);
  }
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.west.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.east.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.north.ordinal());
  p.btnToCode.put(""String_Node_Str"",100 + PovDirection.south.ordinal());
  profiles.put(p.name,p);
  profile(""String_Node_Str"");
}","The original code relied on hardcoded platform-specific checks like `SharedLibraryLoader.isLinux`, which were inflexible and potentially error-prone. The fixed code replaces these checks with `System.getProperty(""os.name"")` to dynamically detect the operating system, allowing more robust and adaptable platform-specific configuration. This approach provides better cross-platform compatibility and makes the code more maintainable by using a standard Java method for OS detection."
94238,"public float[] eval(int axis,float value){
  if (SharedLibraryLoader.isWindows) {
    if (axis == 4 && value < 0) {
      axis=5;
      value=-value;
    }
  }
 else   if ((SharedLibraryLoader.isLinux) && (axis == axes.get(""String_Node_Str"").code || axis == axes.get(""String_Node_Str"").code)) {
    value+=1;
    value/=2;
    value=Math.min(Math.max(value,0),1);
  }
  return new float[]{axis,value};
}","public float[] eval(int axis,float value){
  String os=System.getProperty(""String_Node_Str"");
  if (os.contains(""String_Node_Str"")) {
    if (axis == 4 && value < 0) {
      axis=5;
      value=-value;
    }
  }
 else   if ((os.contains(""String_Node_Str"")) && (axis == axes.get(""String_Node_Str"").code || axis == axes.get(""String_Node_Str"").code)) {
    value+=1;
    value/=2;
    value=Math.min(Math.max(value,0),1);
  }
  return new float[]{axis,value};
}","The original code relies on static platform checks using SharedLibraryLoader, which is an unreliable method for determining the operating system. The fixed code uses System.getProperty() to dynamically retrieve the operating system name, replacing hardcoded platform detection with a more robust method. This approach provides more accurate and flexible OS detection, making the code more reliable across different system environments."
94239,"public static void init(){
  time=0;
  physicsSpeed=1;
  timeSpeed=1;
  profiler=new Profiler();
  display=new Display();
  scenes=new ArrayListScenes();
  sounds=new Sounds();
  music=new Music();
  mouse=new Mouse();
  imaps=new InputMaps();
  keyboard=new Keyboard();
  fingers=new ArrayList<Finger>();
  components=new ArrayList<Component>();
  allocatedFingers=new ArrayList<Finger>();
  for (int i=0; i < 10; ++i) {
    allocatedFingers.add(new Finger(i));
  }
  gamepads=new ArrayListNamed<Gamepad>();
  for (int i=0; i < Controllers.getControllers().size; i++)   gamepads.add(new Gamepad(i));
  com.badlogic.gdx.graphics.glutils.ShaderProgram.pedantic=false;
  shaderProvider=new BDXShaderProvider();
  modelBatch=new ModelBatch(shaderProvider);
  spriteBatch=new SpriteBatch();
  spriteBatch.setBlendFunction(Gdx.gl.GL_SRC_ALPHA,Gdx.gl.GL_ONE_MINUS_SRC_ALPHA);
  frameBuffer=new RenderBuffer(spriteBatch);
  depthBuffer=new RenderBuffer(spriteBatch);
  depthShaderProvider=new BDXDepthShaderProvider(Gdx.files.internal(""String_Node_Str""),Gdx.files.internal(""String_Node_Str""));
  depthBatch=new ModelBatch(depthShaderProvider);
  clearColor=new Color();
  advancedLightingOn=true;
  Gdx.input.setInputProcessor(new GdxProcessor(keyboard,mouse,allocatedFingers,gamepads));
  availableTempBuffers=new HashMap<Float,RenderBuffer>();
  requestedRestart=false;
}","public static void init(){
  time=0;
  physicsSpeed=1;
  timeSpeed=1;
  profiler=new Profiler();
  display=new Display();
  scenes=new ArrayListScenes();
  sounds=new Sounds();
  music=new Music();
  mouse=new Mouse();
  imaps=new InputMaps();
  keyboard=new Keyboard();
  fingers=new ArrayList<Finger>();
  components=new ArrayList<Component>();
  allocatedFingers=new ArrayList<Finger>();
  for (int i=0; i < 10; ++i) {
    allocatedFingers.add(new Finger(i));
  }
  gamepads=new ArrayListNamed<Gamepad>();
  for (int i=0; i < Controllers.getControllers().size; i++)   gamepads.add(new Gamepad(i));
  com.badlogic.gdx.graphics.glutils.ShaderProgram.pedantic=false;
  shaderProvider=new BDXShaderProvider();
  modelBatch=new ModelBatch(shaderProvider);
  spriteBatch=new SpriteBatch();
  spriteBatch.setBlendFunction(Gdx.gl.GL_SRC_ALPHA,Gdx.gl.GL_ONE_MINUS_SRC_ALPHA);
  frameBuffer=new RenderBuffer(spriteBatch);
  depthBuffer=new RenderBuffer(spriteBatch);
  depthShaderProvider=new BDXDepthShaderProvider(Gdx.files.internal(""String_Node_Str""),Gdx.files.internal(""String_Node_Str""));
  depthBatch=new ModelBatch(depthShaderProvider);
  advancedLightingOn=true;
  Gdx.input.setInputProcessor(new GdxProcessor(keyboard,mouse,allocatedFingers,gamepads));
  availableTempBuffers=new HashMap<Float,RenderBuffer>();
  requestedRestart=false;
}","The buggy code contains an unnecessary initialization of `clearColor` variable, which serves no purpose and potentially wastes memory. In the fixed code, this line has been removed, eliminating the redundant object creation. By removing the superfluous initialization, the code becomes more efficient and clean, reducing potential memory overhead and maintaining a more streamlined initialization process."
94240,"public static void main(){
  profiler.start(""String_Node_Str"");
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  profiler.stop(""String_Node_Str"");
  time+=TICK_TIME * timeSpeed;
  ++GdxProcessor.currentTick;
  fingers.clear();
  for (  Finger f : allocatedFingers) {
    if (f.down() || f.up())     fingers.add(f);
  }
  profiler.stop(""String_Node_Str"");
  for (  Component c : components) {
    if (c.state != null)     c.state.main();
  }
  profiler.stop(""String_Node_Str"");
  Viewport vp;
  for (  Scene scene : (ArrayListScenes)scenes.clone()) {
    scene.update();
    profiler.stop(""String_Node_Str"");
    if (!scene.valid())     continue;
    vp=scene.viewport;
    vp.apply();
    depthShaderProvider.update(scene);
    shaderProvider.update(scene);
    if (scene.screenShaders.size() > 0) {
      frameBuffer.begin();
      Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
    }
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
    renderWorld(modelBatch,scene,scene.camera);
    for (    Camera cam : scene.cameras) {
      if (cam.renderingToTexture) {
        cam.update();
        if (cam.renderBuffer == null) {
          cam.initRenderBuffer();
        }
        cam.renderBuffer.begin();
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        renderWorld(modelBatch,scene,cam);
        cam.renderBuffer.end();
      }
    }
    if (scene.screenShaders.size() > 0) {
      frameBuffer.end();
      boolean usingDepth=false;
      for (      ScreenShader filter : scene.screenShaders) {
        if (filter.usingDepthTexture())         usingDepth=true;
      }
      if (usingDepth) {
        Gdx.gl.glClearColor(1,1,1,1);
        depthBuffer.begin();
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT | GL20.GL_COLOR_BUFFER_BIT);
        renderWorld(depthBatch,scene,scene.camera);
        depthBuffer.end();
        depthBuffer.getColorBufferTexture().bind(2);
      }
      scene.lastFrameBuffer.getColorBufferTexture().bind(1);
      Gdx.gl.glActiveTexture(GL20.GL_TEXTURE0);
      Gdx.gl.glClearColor(0,0,0,0);
      for (      ScreenShader filter : scene.screenShaders) {
        if (!filter.active)         continue;
        filter.begin();
        filter.setUniformf(""String_Node_Str"",Bdx.time);
        filter.setUniformi(""String_Node_Str"",1);
        filter.setUniformi(""String_Node_Str"",2);
        filter.setUniformf(""String_Node_Str"",vp.w);
        filter.setUniformf(""String_Node_Str"",vp.h);
        filter.setUniformf(""String_Node_Str"",scene.camera.near());
        filter.setUniformf(""String_Node_Str"",scene.camera.far());
        filter.end();
        if (!availableTempBuffers.containsKey(filter.renderScale.x))         availableTempBuffers.put(filter.renderScale.x,new RenderBuffer(spriteBatch,Math.round(vp.size().x * filter.renderScale.x),Math.round(vp.size().y * filter.renderScale.y)));
        RenderBuffer tempBuffer=availableTempBuffers.get(filter.renderScale.x);
        tempBuffer.clear();
        frameBuffer.drawTo(tempBuffer,filter,0,0,frameBuffer.getWidth(),frameBuffer.getHeight());
        if (!filter.overlay)         frameBuffer.clear();
        tempBuffer.drawTo(frameBuffer);
      }
      frameBuffer.drawTo(null,null,vp.x,vp.y,vp.w,vp.h);
      scene.lastFrameBuffer.clear();
      frameBuffer.drawTo(scene.lastFrameBuffer);
    }
    scene.executeDrawCommands();
    display.clearColor(display.clearColor());
    Bullet.DebugDrawer debugDrawer=(Bullet.DebugDrawer)scene.world.getDebugDrawer();
    debugDrawer.drawWorld(scene.world,scene.camera.data);
    profiler.stop(""String_Node_Str"");
  }
  mouse.wheelMove=0;
  Bdx.display.changed=false;
  profiler.stop(""String_Node_Str"");
  profiler.updateVariables();
  if (profiler.visible()) {
    profiler.updateVisible();
    profiler.scene.update();
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
    renderWorld(modelBatch,profiler.scene,profiler.scene.camera);
    profiler.scene.executeDrawCommands();
  }
  if (profiler.gl.isEnabled()) {
    profiler.gl.updateFields();
  }
  if (requestedRestart) {
    requestedRestart=false;
    Scene.clearColorDefaultSet=false;
    dispose();
    for (    Scene scene : new ArrayList<Scene>(scenes)) {
      scenes.remove(scene);
      scene.end();
    }
    if (profiler.visible()) {
      profiler.scene.end();
    }
    init();
    scenes.add(firstScene);
  }
}","public static void main(){
  boolean screenShadersUsed=false;
  for (  Scene scene : scenes) {
    if (scene.screenShaders.size() > 0) {
      screenShadersUsed=true;
      break;
    }
  }
  profiler.start(""String_Node_Str"");
  Gdx.gl.glClearColor(display.clearColor.r,display.clearColor.g,display.clearColor.b,display.clearColor.a);
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  Gdx.gl.glClearColor(0,0,0,0);
  Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
  profiler.stop(""String_Node_Str"");
  time+=TICK_TIME * timeSpeed;
  ++GdxProcessor.currentTick;
  fingers.clear();
  for (  Finger f : allocatedFingers) {
    if (f.down() || f.up())     fingers.add(f);
  }
  profiler.stop(""String_Node_Str"");
  for (  Component c : components) {
    if (c.state != null)     c.state.main();
  }
  profiler.stop(""String_Node_Str"");
  Viewport vp;
  ArrayListScenes newSceneList=(ArrayListScenes)scenes.clone();
  boolean depthBufferCleared=false;
  boolean colorBufferCleared=false;
  for (int i=0; i < newSceneList.size(); i++) {
    Scene scene=newSceneList.get(i);
    boolean prevSceneRenderPassthrough=false;
    boolean nextSceneRenderPassthrough=false;
    if (i > 0)     prevSceneRenderPassthrough=newSceneList.get(i - 1).renderPassthrough;
    if (i < newSceneList.size() - 1)     nextSceneRenderPassthrough=newSceneList.get(i + 1).renderPassthrough;
    if (!prevSceneRenderPassthrough) {
      colorBufferCleared=false;
      depthBufferCleared=false;
    }
    scene.update();
    profiler.stop(""String_Node_Str"");
    if (!scene.valid())     continue;
    vp=scene.viewport;
    vp.apply();
    depthShaderProvider.update(scene);
    shaderProvider.update(scene);
    boolean frameBufferInUse=false;
    if (scene.screenShaders.size() > 0 || (screenShadersUsed && scene.renderPassthrough)) {
      frameBuffer.begin();
      frameBufferInUse=true;
      if (!colorBufferCleared) {
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        colorBufferCleared=true;
      }
    }
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
    renderWorld(modelBatch,scene,scene.camera);
    for (    Camera cam : scene.cameras) {
      if (cam.renderingToTexture) {
        cam.update();
        if (cam.renderBuffer == null) {
          cam.initRenderBuffer();
        }
        cam.renderBuffer.begin();
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT | GL20.GL_COLOR_BUFFER_BIT);
        renderWorld(modelBatch,scene,cam);
        cam.renderBuffer.end();
      }
    }
    if (frameBufferInUse) {
      frameBuffer.end();
      boolean usingDepth=false;
      for (      ScreenShader filter : scene.screenShaders) {
        if (filter.usingDepthTexture())         usingDepth=true;
      }
      if (usingDepth || scene.renderPassthrough) {
        Gdx.gl.glClearColor(1,1,1,1);
        depthBuffer.begin();
        if (!depthBufferCleared) {
          Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
          depthBufferCleared=true;
        }
        Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
        renderWorld(depthBatch,scene,scene.camera);
        depthBuffer.end();
        depthBuffer.getColorBufferTexture().bind(2);
      }
      scene.lastFrameBuffer.getColorBufferTexture().bind(1);
      Gdx.gl.glActiveTexture(GL20.GL_TEXTURE0);
      Gdx.gl.glClearColor(0,0,0,0);
      for (      ScreenShader filter : scene.screenShaders) {
        if (!filter.active)         continue;
        filter.begin();
        filter.setUniformf(""String_Node_Str"",Bdx.time);
        filter.setUniformi(""String_Node_Str"",1);
        filter.setUniformi(""String_Node_Str"",2);
        filter.setUniformf(""String_Node_Str"",vp.w);
        filter.setUniformf(""String_Node_Str"",vp.h);
        filter.setUniformf(""String_Node_Str"",scene.camera.near());
        filter.setUniformf(""String_Node_Str"",scene.camera.far());
        filter.end();
        if (!availableTempBuffers.containsKey(filter.renderScale.x))         availableTempBuffers.put(filter.renderScale.x,new RenderBuffer(spriteBatch,Math.round(vp.size().x * filter.renderScale.x),Math.round(vp.size().y * filter.renderScale.y)));
        RenderBuffer tempBuffer=availableTempBuffers.get(filter.renderScale.x);
        tempBuffer.clear();
        frameBuffer.drawTo(tempBuffer,filter,0,0,frameBuffer.getWidth(),frameBuffer.getHeight());
        if (!filter.overlay)         frameBuffer.clear();
        tempBuffer.drawTo(frameBuffer);
      }
      if (!scene.renderPassthrough || scene == newSceneList.get(newSceneList.size() - 1) || !nextSceneRenderPassthrough)       frameBuffer.drawTo(null,null,vp.x,vp.y,vp.w,vp.h);
      scene.lastFrameBuffer.clear();
      frameBuffer.drawTo(scene.lastFrameBuffer);
    }
    scene.executeDrawCommands();
    Bullet.DebugDrawer debugDrawer=(Bullet.DebugDrawer)scene.world.getDebugDrawer();
    debugDrawer.drawWorld(scene.world,scene.camera.data);
    profiler.stop(""String_Node_Str"");
  }
  mouse.wheelMove=0;
  Bdx.display.changed=false;
  profiler.stop(""String_Node_Str"");
  profiler.updateVariables();
  if (profiler.visible()) {
    profiler.updateVisible();
    profiler.scene.update();
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT);
    renderWorld(modelBatch,profiler.scene,profiler.scene.camera);
    profiler.scene.executeDrawCommands();
  }
  if (profiler.gl.isEnabled()) {
    profiler.gl.updateFields();
  }
  if (requestedRestart) {
    requestedRestart=false;
    Scene.clearColorDefaultSet=false;
    dispose();
    for (    Scene scene : new ArrayList<Scene>(scenes)) {
      scenes.remove(scene);
      scene.end();
    }
    if (profiler.visible()) {
      profiler.scene.end();
    }
    init();
    scenes.add(firstScene);
  }
}","The original code had multiple issues with buffer clearing, scene rendering, and inconsistent state management during rendering passes. The fixed code introduces more robust buffer and rendering state tracking, adding flags like `screenShadersUsed`, `colorBufferCleared`, and `depthBufferCleared` to ensure proper OpenGL state management across multiple scenes. These changes prevent redundant buffer clears, handle render passthrough scenarios more elegantly, and provide a more predictable rendering pipeline with improved performance and clarity."
94241,"public void init(){
  requestedRestart=false;
  requestedEnd=false;
  paused=false;
  if (shapeRenderer == null)   shapeRenderer=new ShapeRenderer();
  drawCommands=new ArrayList<ArrayList<Object>>();
  lastFrameBuffer=new RenderBuffer(null);
  environment=new Environment();
  environment.set(new ColorAttribute(ColorAttribute.AmbientLight,0,0,0,1));
  environment.set(new PointLightsAttribute());
  environment.set(new SpotLightsAttribute());
  environment.set(new DirectionalLightsAttribute());
  screenShaders=new ArrayList<ScreenShader>();
  defaultMaterial=new Material(""String_Node_Str"");
  defaultMaterial.set(new ColorAttribute(ColorAttribute.AmbientLight,1,1,1,1));
  defaultMaterial.set(new ColorAttribute(ColorAttribute.Diffuse,1,1,1,1));
  defaultMaterial.set(new BlendingAttribute());
  defaultMaterial.set(new BDXColorAttribute(BDXColorAttribute.Tint,0,0,0));
  defaultMesh=new Mesh(new ModelBuilder().createBox(1.0f,1.0f,1.0f,defaultMaterial,Usage.Position | Usage.Normal | Usage.TextureCoordinates),this);
  meshes=new HashMap<String,Mesh>();
  textures=new HashMap<String,Texture>();
  materials=new HashMap<String,Material>();
  modelToFrame=new HashMap<>();
  materials.put(defaultMaterial.id,defaultMaterial);
  BroadphaseInterface broadphase=new DbvtBroadphase();
  DefaultCollisionConfiguration collisionConfiguration=new DefaultCollisionConfiguration();
  SequentialImpulseConstraintSolver solver=new SequentialImpulseConstraintSolver();
  CollisionDispatcher dispatcher=new CollisionDispatcher(collisionConfiguration);
  toBeAdded=new ArrayList<GameObject>();
  toBeRemoved=new ArrayList<GameObject>();
  objects=new LinkedListNamed<GameObject>();
  lights=new LinkedListNamed<Light>();
  templates=new HashMap<String,GameObject>();
  json=new JsonReader().parse(scene);
  name=json.get(""String_Node_Str"").asString();
  world=new DiscreteDynamicsWorld(dispatcher,broadphase,solver,collisionConfiguration);
  world.setDebugDrawer(new Bullet.DebugDrawer(json.get(""String_Node_Str"").asBoolean()));
  gravity(new Vector3f(0,0,-json.get(""String_Node_Str"").asFloat()));
  float[] ac=json.get(""String_Node_Str"").asFloatArray();
  ambientLight(new Color(ac[0],ac[1],ac[2],1));
  if (!clearColorDefaultSet) {
    float[] cc=json.get(""String_Node_Str"").asFloatArray();
    Bdx.display.clearColor(new Color(cc[0],cc[1],cc[2],0));
    clearColorDefaultSet=true;
  }
  if (json.get(""String_Node_Str"").asBoolean()) {
    Bdx.profiler.init();
  }
  float[] fc=json.get(""String_Node_Str"").asFloatArray();
  fogColor=new Color(fc[0],fc[1],fc[2],1);
  fog(json.get(""String_Node_Str"").asBoolean());
  fogRange(json.get(""String_Node_Str"").asFloat(),json.get(""String_Node_Str"").asFloat());
  for (  JsonValue mat : json.get(""String_Node_Str"")) {
    String texName=mat.get(""String_Node_Str"").asString();
    boolean hasAlpha=mat.get(""String_Node_Str"").asString().equals(""String_Node_Str"");
    float opacity=hasAlpha ? mat.get(""String_Node_Str"").asFloat() : 1;
    Material material=new Material(mat.name);
    float[] c=mat.get(""String_Node_Str"").asFloatArray();
    material.set(ColorAttribute.createDiffuse(c[0],c[1],c[2],opacity));
    float[] s=mat.get(""String_Node_Str"").asFloatArray();
    material.set(ColorAttribute.createSpecular(s[0],s[1],s[2],1));
    material.set(FloatAttribute.createShininess(mat.get(""String_Node_Str"").asFloat()));
    material.set(new BDXColorAttribute(BDXColorAttribute.Tint,0,0,0));
    IntAttribute shadeless=(IntAttribute)new BDXIntAttribute();
    if (mat.get(""String_Node_Str"").asBoolean())     shadeless.value=1;
    material.set(shadeless);
    float emitStrength=mat.get(""String_Node_Str"").asFloat();
    material.set(new BDXColorAttribute(BDXColorAttribute.Emit,emitStrength,emitStrength,emitStrength));
    if (mat.get(""String_Node_Str"").asBoolean())     material.set(new IntAttribute(IntAttribute.CullFace,GL20.GL_BACK));
 else     material.set(new IntAttribute(IntAttribute.CullFace,GL20.GL_NONE));
    if (texName != null) {
      Texture texture=textures.get(texName);
      if (texture == null) {
        texture=new Texture(Gdx.files.internal(""String_Node_Str"" + texName));
        textures.put(texName,texture);
      }
      texture.setWrap(TextureWrap.Repeat,TextureWrap.Repeat);
      material.texture(texture);
    }
    if (hasAlpha) {
      BlendingAttribute ba=new BlendingAttribute(GL20.GL_SRC_ALPHA,GL20.GL_ONE_MINUS_SRC_ALPHA);
      ba.opacity=opacity;
      material.set(ba);
      material.set(FloatAttribute.createAlphaTest(0.01f));
    }
 else {
      BlendingAttribute ba=new BlendingAttribute();
      ba.blended=false;
      material.set(ba);
    }
    materials.put(mat.name,material);
  }
  for (  JsonValue model : json.get(""String_Node_Str"")) {
    meshes.put(model.name,new Mesh(createModel(model),this,model.name));
  }
  HashMap<String,JsonValue> fonts=new HashMap<>();
  for (  JsonValue fontj : json.get(""String_Node_Str"")) {
    String font=fontj.asString();
    fonts.put(font,new JsonReader().parse(Gdx.files.internal(""String_Node_Str"" + font + ""String_Node_Str"")));
  }
  FAnim.loadActions(json.get(""String_Node_Str""));
  for (  JsonValue gobj : json.get(""String_Node_Str"")) {
    GameObject g=instantiator.newObject(gobj);
    g.json=gobj;
    g.name=gobj.name;
    g.scene=this;
    g.props=new HashMap<String,JsonValue>();
    for (    JsonValue prop : gobj.get(""String_Node_Str"")) {
      g.props.put(prop.name,prop);
    }
    String meshName=gobj.get(""String_Node_Str"").asString();
    if (meshName != null) {
      g.visibleNoChildren(gobj.get(""String_Node_Str"").asBoolean());
      g.mesh(meshName);
    }
 else {
      g.visibleNoChildren(false);
      g.mesh(defaultMesh);
    }
    com.badlogic.gdx.graphics.Mesh mesh=g.modelInstance.model.meshes.first();
    float[] trans=gobj.get(""String_Node_Str"").asFloatArray();
    JsonValue origin=json.get(""String_Node_Str"").get(meshName);
    JsonValue dimensions=json.get(""String_Node_Str"").get(meshName);
    g.origin=origin == null ? new Vector3f() : new Vector3f(origin.asFloatArray());
    g.dimensionsNoScale=dimensions == null ? new Vector3f(1,1,1) : new Vector3f(dimensions.asFloatArray());
    JsonValue physics=gobj.get(""String_Node_Str"");
    g.currBodyType=GameObject.BodyType.valueOf(physics.get(""String_Node_Str"").asString());
    g.currBoundsType=GameObject.BoundsType.valueOf(physics.get(""String_Node_Str"").asString());
    g.body=Bullet.makeBody(mesh,trans,g.origin,g.currBodyType,g.currBoundsType,physics);
    g.body.setUserPointer(g);
    g.scale(getGLMatrixScale(trans));
    String type=gobj.get(""String_Node_Str"").asString();
    if (type.equals(""String_Node_Str"")) {
      Text t=(Text)g;
      t.font=fonts.get(gobj.get(""String_Node_Str"").asString());
      t.text(gobj.get(""String_Node_Str"").asString());
      t.capacity=t.text().length();
      String align=gobj.get(""String_Node_Str"").asString();
      if (align.equals(""String_Node_Str""))       t.alignment(Text.Alignment.RIGHT);
 else       if (align.equals(""String_Node_Str""))       t.alignment(Text.Alignment.CENTER);
 else       t.alignment(Text.Alignment.LEFT);
    }
 else     if (type.equals(""String_Node_Str"")) {
      JsonValue settings=gobj.get(""String_Node_Str"");
      Light l=(Light)g;
      if (settings.getString(""String_Node_Str"").equals(""String_Node_Str""))       l.type=Light.Type.SUN;
 else       if (settings.getString(""String_Node_Str"").equals(""String_Node_Str""))       l.type=Light.Type.SPOT;
 else       l.type=Light.Type.POINT;
      l.energy(settings.getFloat(""String_Node_Str""));
      float[] c=settings.get(""String_Node_Str"").asFloatArray();
      l.color(new Color(c[0],c[1],c[2],c[3]));
      if (l.type.equals(Light.Type.SPOT)) {
        l.spotSize(settings.getFloat(""String_Node_Str""));
      }
    }
 else     if (type.equals(""String_Node_Str"")) {
      Camera c=(Camera)g;
      float[] projection=gobj.get(""String_Node_Str"").get(""String_Node_Str"").asFloatArray();
      Vector2f resolution=new Vector2f(json.get(""String_Node_Str"").asFloatArray());
      if (gobj.get(""String_Node_Str"").get(""String_Node_Str"").asString().equals(""String_Node_Str"")) {
        c.initData(Camera.Type.PERSPECTIVE);
        c.size(resolution);
        c.resolution(resolution);
        c.projection(new Matrix4f(projection));
        c.fov(c.fov());
      }
 else {
        c.initData(Camera.Type.ORTHOGRAPHIC);
        c.size(resolution);
        c.resolution(resolution);
        c.zoom(2 / projection[0]);
      }
      Matrix4 pm=new Matrix4(projection);
      pm.inv();
      Vector3 vec=new Vector3(0,0,-1);
      vec.prj(pm);
      c.near(-vec.z);
      vec.set(0,0,1);
      vec.prj(pm);
      c.far(-vec.z);
    }
    templates.put(g.name,g);
  }
  hookParentChild();
  cameras=new ArrayListNamed<Camera>();
  addInstances();
  camera=(Camera)objects.get(json.get(""String_Node_Str"").asStringArray()[0]);
  String frameType=json.get(""String_Node_Str"").asString();
  Viewport.Type viewportType;
  if (frameType.equals(""String_Node_Str"")) {
    viewportType=Viewport.Type.LETTERBOX;
  }
 else   if (frameType.equals(""String_Node_Str"")) {
    viewportType=Viewport.Type.EXTEND;
  }
 else {
    viewportType=Viewport.Type.SCALE;
  }
  viewport=new Viewport(this,viewportType);
  for (  GameObject g : sortByPriority(new ArrayList<GameObject>(objects))) {
    initGameObject(g);
  }
  valid=true;
}","public void init(){
  requestedRestart=false;
  requestedEnd=false;
  paused=false;
  if (shapeRenderer == null)   shapeRenderer=new ShapeRenderer();
  drawCommands=new ArrayList<ArrayList<Object>>();
  lastFrameBuffer=new RenderBuffer(null);
  environment=new Environment();
  environment.set(new ColorAttribute(ColorAttribute.AmbientLight,0,0,0,1));
  environment.set(new PointLightsAttribute());
  environment.set(new SpotLightsAttribute());
  environment.set(new DirectionalLightsAttribute());
  screenShaders=new ArrayList<ScreenShader>();
  defaultMaterial=new Material(""String_Node_Str"");
  defaultMaterial.set(new ColorAttribute(ColorAttribute.AmbientLight,1,1,1,1));
  defaultMaterial.set(new ColorAttribute(ColorAttribute.Diffuse,1,1,1,1));
  defaultMaterial.set(new BlendingAttribute());
  defaultMaterial.set(new BDXColorAttribute(BDXColorAttribute.Tint,0,0,0));
  defaultMesh=new Mesh(new ModelBuilder().createBox(1.0f,1.0f,1.0f,defaultMaterial,Usage.Position | Usage.Normal | Usage.TextureCoordinates),this);
  meshes=new HashMap<String,Mesh>();
  textures=new HashMap<String,Texture>();
  materials=new HashMap<String,Material>();
  modelToFrame=new HashMap<>();
  materials.put(defaultMaterial.id,defaultMaterial);
  BroadphaseInterface broadphase=new DbvtBroadphase();
  DefaultCollisionConfiguration collisionConfiguration=new DefaultCollisionConfiguration();
  SequentialImpulseConstraintSolver solver=new SequentialImpulseConstraintSolver();
  CollisionDispatcher dispatcher=new CollisionDispatcher(collisionConfiguration);
  toBeAdded=new ArrayList<GameObject>();
  toBeRemoved=new ArrayList<GameObject>();
  objects=new LinkedListNamed<GameObject>();
  lights=new LinkedListNamed<Light>();
  templates=new HashMap<String,GameObject>();
  json=new JsonReader().parse(scene);
  name=json.get(""String_Node_Str"").asString();
  world=new DiscreteDynamicsWorld(dispatcher,broadphase,solver,collisionConfiguration);
  world.setDebugDrawer(new Bullet.DebugDrawer(json.get(""String_Node_Str"").asBoolean()));
  gravity(new Vector3f(0,0,-json.get(""String_Node_Str"").asFloat()));
  float[] ac=json.get(""String_Node_Str"").asFloatArray();
  ambientLight(new Color(ac[0],ac[1],ac[2],1));
  if (!clearColorDefaultSet) {
    float[] cc=json.get(""String_Node_Str"").asFloatArray();
    Bdx.display.clearColor.set(cc[0],cc[1],cc[2],0);
    clearColorDefaultSet=true;
  }
  if (json.get(""String_Node_Str"").asBoolean()) {
    Bdx.profiler.init();
  }
  float[] fc=json.get(""String_Node_Str"").asFloatArray();
  fogColor=new Color(fc[0],fc[1],fc[2],1);
  fog(json.get(""String_Node_Str"").asBoolean());
  fogRange(json.get(""String_Node_Str"").asFloat(),json.get(""String_Node_Str"").asFloat());
  for (  JsonValue mat : json.get(""String_Node_Str"")) {
    String texName=mat.get(""String_Node_Str"").asString();
    boolean hasAlpha=mat.get(""String_Node_Str"").asString().equals(""String_Node_Str"");
    float opacity=hasAlpha ? mat.get(""String_Node_Str"").asFloat() : 1;
    Material material=new Material(mat.name);
    float[] c=mat.get(""String_Node_Str"").asFloatArray();
    material.set(ColorAttribute.createDiffuse(c[0],c[1],c[2],opacity));
    float[] s=mat.get(""String_Node_Str"").asFloatArray();
    material.set(ColorAttribute.createSpecular(s[0],s[1],s[2],1));
    material.set(FloatAttribute.createShininess(mat.get(""String_Node_Str"").asFloat()));
    material.set(new BDXColorAttribute(BDXColorAttribute.Tint,0,0,0));
    IntAttribute shadeless=(IntAttribute)new BDXIntAttribute();
    if (mat.get(""String_Node_Str"").asBoolean())     shadeless.value=1;
    material.set(shadeless);
    float emitStrength=mat.get(""String_Node_Str"").asFloat();
    material.set(new BDXColorAttribute(BDXColorAttribute.Emit,emitStrength,emitStrength,emitStrength));
    if (mat.get(""String_Node_Str"").asBoolean())     material.set(new IntAttribute(IntAttribute.CullFace,GL20.GL_BACK));
 else     material.set(new IntAttribute(IntAttribute.CullFace,GL20.GL_NONE));
    if (texName != null) {
      Texture texture=textures.get(texName);
      if (texture == null) {
        texture=new Texture(Gdx.files.internal(""String_Node_Str"" + texName));
        textures.put(texName,texture);
      }
      texture.setWrap(TextureWrap.Repeat,TextureWrap.Repeat);
      material.texture(texture);
    }
    if (hasAlpha) {
      BlendingAttribute ba=new BlendingAttribute(GL20.GL_SRC_ALPHA,GL20.GL_ONE_MINUS_SRC_ALPHA);
      ba.opacity=opacity;
      material.set(ba);
      material.set(FloatAttribute.createAlphaTest(0.01f));
    }
 else {
      BlendingAttribute ba=new BlendingAttribute();
      ba.blended=false;
      material.set(ba);
    }
    materials.put(mat.name,material);
  }
  for (  JsonValue model : json.get(""String_Node_Str"")) {
    meshes.put(model.name,new Mesh(createModel(model),this,model.name));
  }
  HashMap<String,JsonValue> fonts=new HashMap<>();
  for (  JsonValue fontj : json.get(""String_Node_Str"")) {
    String font=fontj.asString();
    fonts.put(font,new JsonReader().parse(Gdx.files.internal(""String_Node_Str"" + font + ""String_Node_Str"")));
  }
  FAnim.loadActions(json.get(""String_Node_Str""));
  for (  JsonValue gobj : json.get(""String_Node_Str"")) {
    GameObject g=instantiator.newObject(gobj);
    g.json=gobj;
    g.name=gobj.name;
    g.scene=this;
    g.props=new HashMap<String,JsonValue>();
    for (    JsonValue prop : gobj.get(""String_Node_Str"")) {
      g.props.put(prop.name,prop);
    }
    String meshName=gobj.get(""String_Node_Str"").asString();
    if (meshName != null) {
      g.visibleNoChildren(gobj.get(""String_Node_Str"").asBoolean());
      g.mesh(meshName);
    }
 else {
      g.visibleNoChildren(false);
      g.mesh(defaultMesh);
    }
    com.badlogic.gdx.graphics.Mesh mesh=g.modelInstance.model.meshes.first();
    float[] trans=gobj.get(""String_Node_Str"").asFloatArray();
    JsonValue origin=json.get(""String_Node_Str"").get(meshName);
    JsonValue dimensions=json.get(""String_Node_Str"").get(meshName);
    g.origin=origin == null ? new Vector3f() : new Vector3f(origin.asFloatArray());
    g.dimensionsNoScale=dimensions == null ? new Vector3f(1,1,1) : new Vector3f(dimensions.asFloatArray());
    JsonValue physics=gobj.get(""String_Node_Str"");
    g.currBodyType=GameObject.BodyType.valueOf(physics.get(""String_Node_Str"").asString());
    g.currBoundsType=GameObject.BoundsType.valueOf(physics.get(""String_Node_Str"").asString());
    g.body=Bullet.makeBody(mesh,trans,g.origin,g.currBodyType,g.currBoundsType,physics);
    g.body.setUserPointer(g);
    g.scale(getGLMatrixScale(trans));
    String type=gobj.get(""String_Node_Str"").asString();
    if (type.equals(""String_Node_Str"")) {
      Text t=(Text)g;
      t.font=fonts.get(gobj.get(""String_Node_Str"").asString());
      t.text(gobj.get(""String_Node_Str"").asString());
      t.capacity=t.text().length();
      String align=gobj.get(""String_Node_Str"").asString();
      if (align.equals(""String_Node_Str""))       t.alignment(Text.Alignment.RIGHT);
 else       if (align.equals(""String_Node_Str""))       t.alignment(Text.Alignment.CENTER);
 else       t.alignment(Text.Alignment.LEFT);
    }
 else     if (type.equals(""String_Node_Str"")) {
      JsonValue settings=gobj.get(""String_Node_Str"");
      Light l=(Light)g;
      if (settings.getString(""String_Node_Str"").equals(""String_Node_Str""))       l.type=Light.Type.SUN;
 else       if (settings.getString(""String_Node_Str"").equals(""String_Node_Str""))       l.type=Light.Type.SPOT;
 else       l.type=Light.Type.POINT;
      l.energy(settings.getFloat(""String_Node_Str""));
      float[] c=settings.get(""String_Node_Str"").asFloatArray();
      l.color(new Color(c[0],c[1],c[2],c[3]));
      if (l.type.equals(Light.Type.SPOT)) {
        l.spotSize(settings.getFloat(""String_Node_Str""));
      }
    }
 else     if (type.equals(""String_Node_Str"")) {
      Camera c=(Camera)g;
      float[] projection=gobj.get(""String_Node_Str"").get(""String_Node_Str"").asFloatArray();
      Vector2f resolution=new Vector2f(json.get(""String_Node_Str"").asFloatArray());
      if (gobj.get(""String_Node_Str"").get(""String_Node_Str"").asString().equals(""String_Node_Str"")) {
        c.initData(Camera.Type.PERSPECTIVE);
        c.size(resolution);
        c.resolution(resolution);
        c.projection(new Matrix4f(projection));
        c.fov(c.fov());
      }
 else {
        c.initData(Camera.Type.ORTHOGRAPHIC);
        c.size(resolution);
        c.resolution(resolution);
        c.zoom(2 / projection[0]);
      }
      Matrix4 pm=new Matrix4(projection);
      pm.inv();
      Vector3 vec=new Vector3(0,0,-1);
      vec.prj(pm);
      c.near(-vec.z);
      vec.set(0,0,1);
      vec.prj(pm);
      c.far(-vec.z);
    }
    templates.put(g.name,g);
  }
  hookParentChild();
  cameras=new ArrayListNamed<Camera>();
  addInstances();
  camera=(Camera)objects.get(json.get(""String_Node_Str"").asStringArray()[0]);
  String frameType=json.get(""String_Node_Str"").asString();
  Viewport.Type viewportType;
  if (frameType.equals(""String_Node_Str"")) {
    viewportType=Viewport.Type.LETTERBOX;
  }
 else   if (frameType.equals(""String_Node_Str"")) {
    viewportType=Viewport.Type.EXTEND;
  }
 else {
    viewportType=Viewport.Type.SCALE;
  }
  viewport=new Viewport(this,viewportType);
  for (  GameObject g : sortByPriority(new ArrayList<GameObject>(objects))) {
    initGameObject(g);
  }
  valid=true;
}","The original code incorrectly used `Bdx.display.clearColor(new Color(...))`, which likely doesn't modify the clear color property correctly. The fixed code uses `Bdx.display.clearColor.set(...)`, directly setting the color components of the clearColor attribute. This change ensures proper color configuration for the display's background, providing a more reliable and direct method of setting the clear color with precise color control."
94242,"public void render(Renderable renderable,Attributes combinedAttributes){
  super.render(renderable,combinedAttributes);
  if (scene != null) {
    program.setUniformf(""String_Node_Str"",scene.camera.far());
    program.setUniformf(""String_Node_Str"",scene.camera.near());
  }
}","public void render(Renderable renderable,Attributes combinedAttributes){
  if (scene != null) {
    program.setUniformf(""String_Node_Str"",scene.camera.far());
    program.setUniformf(""String_Node_Str"",scene.camera.near());
  }
  super.render(renderable,combinedAttributes);
}","The original code calls the superclass render method before checking scene nullability, which could cause potential null pointer exceptions. In the fixed code, the scene null check is performed first, ensuring uniform values are set only when the scene is not null, and then calling the superclass render method. This approach improves code safety by preventing potential runtime errors and maintaining proper method execution sequence."
94243,"public void blendMode(int src,int dest){
  BlendingAttribute ba=(BlendingAttribute)get(BlendingAttribute.Type);
  ba.sourceFunction=src;
  ba.destFunction=dest;
}","public void blendMode(int src,int dest){
  BlendingAttribute ba=(BlendingAttribute)get(BlendingAttribute.Type);
  ba.sourceFunction=src;
  ba.destFunction=dest;
  ba.blended=true;
}","The original code sets blend mode parameters but fails to activate blending, potentially causing rendering issues where blending effects are not applied. The fixed code adds `ba.blended=true`, explicitly enabling the blending attribute and ensuring that the specified source and destination functions are actually utilized. This small change guarantees that the blend mode configuration takes effect, preventing unintended rendering behaviors."
94244,"public void init(){
  requestedRestart=false;
  requestedEnd=false;
  paused=false;
  if (shapeRenderer == null)   shapeRenderer=new ShapeRenderer();
  drawCommands=new ArrayList<ArrayList<Object>>();
  lastFrameBuffer=new RenderBuffer(null);
  environment=new Environment();
  environment.set(new ColorAttribute(ColorAttribute.AmbientLight,0,0,0,1));
  environment.set(new PointLightsAttribute());
  environment.set(new SpotLightsAttribute());
  environment.set(new DirectionalLightsAttribute());
  screenShaders=new ArrayList<ScreenShader>();
  defaultMaterial=new Material(""String_Node_Str"");
  defaultMaterial.set(new ColorAttribute(ColorAttribute.AmbientLight,1,1,1,1));
  defaultMaterial.set(new ColorAttribute(ColorAttribute.Diffuse,1,1,1,1));
  defaultMaterial.set(new BlendingAttribute());
  defaultMaterial.set(new BDXColorAttribute(BDXColorAttribute.Tint,0,0,0));
  defaultMesh=new Mesh(new ModelBuilder().createBox(1.0f,1.0f,1.0f,defaultMaterial,Usage.Position | Usage.Normal | Usage.TextureCoordinates),this);
  meshes=new HashMap<String,Mesh>();
  textures=new HashMap<String,Texture>();
  materials=new HashMap<String,Material>();
  modelToFrame=new HashMap<>();
  materials.put(defaultMaterial.id,defaultMaterial);
  BroadphaseInterface broadphase=new DbvtBroadphase();
  DefaultCollisionConfiguration collisionConfiguration=new DefaultCollisionConfiguration();
  SequentialImpulseConstraintSolver solver=new SequentialImpulseConstraintSolver();
  CollisionDispatcher dispatcher=new CollisionDispatcher(collisionConfiguration);
  toBeAdded=new ArrayList<GameObject>();
  toBeRemoved=new ArrayList<GameObject>();
  objects=new LinkedListNamed<GameObject>();
  lights=new LinkedListNamed<Light>();
  templates=new HashMap<String,GameObject>();
  json=new JsonReader().parse(scene);
  name=json.get(""String_Node_Str"").asString();
  world=new DiscreteDynamicsWorld(dispatcher,broadphase,solver,collisionConfiguration);
  world.setDebugDrawer(new Bullet.DebugDrawer(json.get(""String_Node_Str"").asBoolean()));
  gravity(new Vector3f(0,0,-json.get(""String_Node_Str"").asFloat()));
  float[] ac=json.get(""String_Node_Str"").asFloatArray();
  ambientLight(new Color(ac[0],ac[1],ac[2],1));
  if (!clearColorDefaultSet) {
    float[] cc=json.get(""String_Node_Str"").asFloatArray();
    Bdx.display.clearColor(new Color(cc[0],cc[1],cc[2],0));
    clearColorDefaultSet=true;
  }
  if (json.get(""String_Node_Str"").asBoolean()) {
    Bdx.profiler.init();
  }
  float[] fc=json.get(""String_Node_Str"").asFloatArray();
  fogColor=new Color(fc[0],fc[1],fc[2],1);
  fog(json.get(""String_Node_Str"").asBoolean());
  fogRange(json.get(""String_Node_Str"").asFloat(),json.get(""String_Node_Str"").asFloat());
  for (  JsonValue mat : json.get(""String_Node_Str"")) {
    String texName=mat.get(""String_Node_Str"").asString();
    boolean hasAlpha=mat.get(""String_Node_Str"").asString().equals(""String_Node_Str"");
    float opacity=hasAlpha ? mat.get(""String_Node_Str"").asFloat() : 1;
    Material material=new Material(mat.name);
    float[] c=mat.get(""String_Node_Str"").asFloatArray();
    material.set(ColorAttribute.createDiffuse(c[0],c[1],c[2],opacity));
    float[] s=mat.get(""String_Node_Str"").asFloatArray();
    material.set(ColorAttribute.createSpecular(s[0],s[1],s[2],1));
    material.set(FloatAttribute.createShininess(mat.get(""String_Node_Str"").asFloat()));
    material.set(new BDXColorAttribute(BDXColorAttribute.Tint,0,0,0));
    IntAttribute shadeless=(IntAttribute)new BDXIntAttribute();
    if (mat.get(""String_Node_Str"").asBoolean())     shadeless.value=1;
    material.set(shadeless);
    float emitStrength=mat.get(""String_Node_Str"").asFloat();
    material.set(new BDXColorAttribute(BDXColorAttribute.Emit,emitStrength,emitStrength,emitStrength));
    if (mat.get(""String_Node_Str"").asBoolean())     material.set(new IntAttribute(IntAttribute.CullFace,GL20.GL_BACK));
 else     material.set(new IntAttribute(IntAttribute.CullFace,GL20.GL_NONE));
    if (texName != null) {
      Texture texture=textures.get(texName);
      if (texture == null) {
        texture=new Texture(Gdx.files.internal(""String_Node_Str"" + texName));
        textures.put(texName,texture);
      }
      texture.setWrap(TextureWrap.Repeat,TextureWrap.Repeat);
      material.texture(texture);
    }
    if (hasAlpha) {
      BlendingAttribute ba=new BlendingAttribute(GL20.GL_SRC_ALPHA,GL20.GL_ONE_MINUS_SRC_ALPHA);
      ba.opacity=opacity;
      material.set(ba);
      material.set(FloatAttribute.createAlphaTest(0.01f));
    }
 else {
      BlendingAttribute ba=new BlendingAttribute();
      ba.blended=false;
      material.set(ba);
    }
    materials.put(mat.name,material);
  }
  for (  JsonValue model : json.get(""String_Node_Str"")) {
    meshes.put(model.name,new Mesh(createModel(model),this,model.name));
  }
  HashMap<String,JsonValue> fonts=new HashMap<>();
  for (  JsonValue fontj : json.get(""String_Node_Str"")) {
    String font=fontj.asString();
    fonts.put(font,new JsonReader().parse(Gdx.files.internal(""String_Node_Str"" + font + ""String_Node_Str"")));
  }
  FAnim.loadActions(json.get(""String_Node_Str""));
  for (  JsonValue gobj : json.get(""String_Node_Str"")) {
    GameObject g=instantiator.newObject(gobj);
    g.json=gobj;
    g.name=gobj.name;
    g.scene=this;
    g.props=new HashMap<String,JsonValue>();
    for (    JsonValue prop : gobj.get(""String_Node_Str"")) {
      g.props.put(prop.name,prop);
    }
    String meshName=gobj.get(""String_Node_Str"").asString();
    if (meshName != null) {
      g.visibleNoChildren(gobj.get(""String_Node_Str"").asBoolean());
      g.mesh(meshName);
    }
 else {
      g.visibleNoChildren(false);
      g.mesh(defaultMesh);
    }
    com.badlogic.gdx.graphics.Mesh mesh=g.modelInstance.model.meshes.first();
    float[] trans=gobj.get(""String_Node_Str"").asFloatArray();
    JsonValue origin=json.get(""String_Node_Str"").get(meshName);
    JsonValue dimensions=json.get(""String_Node_Str"").get(meshName);
    g.origin=origin == null ? new Vector3f() : new Vector3f(origin.asFloatArray());
    g.dimensionsNoScale=dimensions == null ? new Vector3f(1,1,1) : new Vector3f(dimensions.asFloatArray());
    JsonValue physics=gobj.get(""String_Node_Str"");
    g.currBodyType=GameObject.BodyType.valueOf(physics.get(""String_Node_Str"").asString());
    g.currBoundsType=GameObject.BoundsType.valueOf(physics.get(""String_Node_Str"").asString());
    g.body=Bullet.makeBody(mesh,trans,g.origin,g.currBodyType,g.currBoundsType,physics);
    g.body.setUserPointer(g);
    g.scale(getGLMatrixScale(trans));
    String type=gobj.get(""String_Node_Str"").asString();
    if (type.equals(""String_Node_Str"")) {
      Text t=(Text)g;
      t.font=fonts.get(gobj.get(""String_Node_Str"").asString());
      t.text(gobj.get(""String_Node_Str"").asString());
      t.capacity=t.text().length();
    }
 else     if (type.equals(""String_Node_Str"")) {
      JsonValue settings=gobj.get(""String_Node_Str"");
      Light l=(Light)g;
      if (settings.getString(""String_Node_Str"").equals(""String_Node_Str""))       l.type=Light.Type.POINT;
 else       if (settings.getString(""String_Node_Str"").equals(""String_Node_Str""))       l.type=Light.Type.SUN;
 else       if (settings.getString(""String_Node_Str"").equals(""String_Node_Str""))       l.type=Light.Type.SPOT;
      l.energy(settings.getFloat(""String_Node_Str""));
      float[] c=settings.get(""String_Node_Str"").asFloatArray();
      l.color(new Color(c[0],c[1],c[2],c[3]));
      if (l.type.equals(Light.Type.SPOT)) {
        l.spotSize(settings.getFloat(""String_Node_Str""));
      }
    }
 else     if (type.equals(""String_Node_Str"")) {
      Camera c=(Camera)g;
      float[] projection=gobj.get(""String_Node_Str"").get(""String_Node_Str"").asFloatArray();
      Vector2f resolution=new Vector2f(json.get(""String_Node_Str"").asFloatArray());
      if (gobj.get(""String_Node_Str"").get(""String_Node_Str"").asString().equals(""String_Node_Str"")) {
        c.initData(Camera.Type.PERSPECTIVE);
        c.size(resolution);
        c.resolution(resolution);
        c.projection(new Matrix4f(projection));
        c.fov(c.fov());
      }
 else {
        c.initData(Camera.Type.ORTHOGRAPHIC);
        c.size(resolution);
        c.resolution(resolution);
        c.zoom(2 / projection[0]);
      }
      Matrix4 pm=new Matrix4(projection);
      pm.inv();
      Vector3 vec=new Vector3(0,0,-1);
      vec.prj(pm);
      c.near(-vec.z);
      vec.set(0,0,1);
      vec.prj(pm);
      c.far(-vec.z);
    }
    templates.put(g.name,g);
  }
  hookParentChild();
  cameras=new ArrayListNamed<Camera>();
  addInstances();
  camera=(Camera)objects.get(json.get(""String_Node_Str"").asStringArray()[0]);
  String frameType=json.get(""String_Node_Str"").asString();
  Viewport.Type viewportType;
  if (frameType.equals(""String_Node_Str"")) {
    viewportType=Viewport.Type.LETTERBOX;
  }
 else   if (frameType.equals(""String_Node_Str"")) {
    viewportType=Viewport.Type.EXTEND;
  }
 else {
    viewportType=Viewport.Type.SCALE;
  }
  viewport=new Viewport(this,viewportType);
  for (  GameObject g : sortByPriority(new ArrayList<GameObject>(objects))) {
    initGameObject(g);
  }
  valid=true;
}","public void init(){
  requestedRestart=false;
  requestedEnd=false;
  paused=false;
  if (shapeRenderer == null)   shapeRenderer=new ShapeRenderer();
  drawCommands=new ArrayList<ArrayList<Object>>();
  lastFrameBuffer=new RenderBuffer(null);
  environment=new Environment();
  environment.set(new ColorAttribute(ColorAttribute.AmbientLight,0,0,0,1));
  environment.set(new PointLightsAttribute());
  environment.set(new SpotLightsAttribute());
  environment.set(new DirectionalLightsAttribute());
  screenShaders=new ArrayList<ScreenShader>();
  defaultMaterial=new Material(""String_Node_Str"");
  defaultMaterial.set(new ColorAttribute(ColorAttribute.AmbientLight,1,1,1,1));
  defaultMaterial.set(new ColorAttribute(ColorAttribute.Diffuse,1,1,1,1));
  defaultMaterial.set(new BlendingAttribute());
  defaultMaterial.set(new BDXColorAttribute(BDXColorAttribute.Tint,0,0,0));
  defaultMesh=new Mesh(new ModelBuilder().createBox(1.0f,1.0f,1.0f,defaultMaterial,Usage.Position | Usage.Normal | Usage.TextureCoordinates),this);
  meshes=new HashMap<String,Mesh>();
  textures=new HashMap<String,Texture>();
  materials=new HashMap<String,Material>();
  modelToFrame=new HashMap<>();
  materials.put(defaultMaterial.id,defaultMaterial);
  BroadphaseInterface broadphase=new DbvtBroadphase();
  DefaultCollisionConfiguration collisionConfiguration=new DefaultCollisionConfiguration();
  SequentialImpulseConstraintSolver solver=new SequentialImpulseConstraintSolver();
  CollisionDispatcher dispatcher=new CollisionDispatcher(collisionConfiguration);
  toBeAdded=new ArrayList<GameObject>();
  toBeRemoved=new ArrayList<GameObject>();
  objects=new LinkedListNamed<GameObject>();
  lights=new LinkedListNamed<Light>();
  templates=new HashMap<String,GameObject>();
  json=new JsonReader().parse(scene);
  name=json.get(""String_Node_Str"").asString();
  world=new DiscreteDynamicsWorld(dispatcher,broadphase,solver,collisionConfiguration);
  world.setDebugDrawer(new Bullet.DebugDrawer(json.get(""String_Node_Str"").asBoolean()));
  gravity(new Vector3f(0,0,-json.get(""String_Node_Str"").asFloat()));
  float[] ac=json.get(""String_Node_Str"").asFloatArray();
  ambientLight(new Color(ac[0],ac[1],ac[2],1));
  if (!clearColorDefaultSet) {
    float[] cc=json.get(""String_Node_Str"").asFloatArray();
    Bdx.display.clearColor(new Color(cc[0],cc[1],cc[2],0));
    clearColorDefaultSet=true;
  }
  if (json.get(""String_Node_Str"").asBoolean()) {
    Bdx.profiler.init();
  }
  float[] fc=json.get(""String_Node_Str"").asFloatArray();
  fogColor=new Color(fc[0],fc[1],fc[2],1);
  fog(json.get(""String_Node_Str"").asBoolean());
  fogRange(json.get(""String_Node_Str"").asFloat(),json.get(""String_Node_Str"").asFloat());
  for (  JsonValue mat : json.get(""String_Node_Str"")) {
    String texName=mat.get(""String_Node_Str"").asString();
    boolean hasAlpha=mat.get(""String_Node_Str"").asString().equals(""String_Node_Str"");
    float opacity=hasAlpha ? mat.get(""String_Node_Str"").asFloat() : 1;
    Material material=new Material(mat.name);
    float[] c=mat.get(""String_Node_Str"").asFloatArray();
    material.set(ColorAttribute.createDiffuse(c[0],c[1],c[2],opacity));
    float[] s=mat.get(""String_Node_Str"").asFloatArray();
    material.set(ColorAttribute.createSpecular(s[0],s[1],s[2],1));
    material.set(FloatAttribute.createShininess(mat.get(""String_Node_Str"").asFloat()));
    material.set(new BDXColorAttribute(BDXColorAttribute.Tint,0,0,0));
    IntAttribute shadeless=(IntAttribute)new BDXIntAttribute();
    if (mat.get(""String_Node_Str"").asBoolean())     shadeless.value=1;
    material.set(shadeless);
    float emitStrength=mat.get(""String_Node_Str"").asFloat();
    material.set(new BDXColorAttribute(BDXColorAttribute.Emit,emitStrength,emitStrength,emitStrength));
    if (mat.get(""String_Node_Str"").asBoolean())     material.set(new IntAttribute(IntAttribute.CullFace,GL20.GL_BACK));
 else     material.set(new IntAttribute(IntAttribute.CullFace,GL20.GL_NONE));
    if (texName != null) {
      Texture texture=textures.get(texName);
      if (texture == null) {
        texture=new Texture(Gdx.files.internal(""String_Node_Str"" + texName));
        textures.put(texName,texture);
      }
      texture.setWrap(TextureWrap.Repeat,TextureWrap.Repeat);
      material.texture(texture);
    }
    if (hasAlpha) {
      BlendingAttribute ba=new BlendingAttribute(GL20.GL_SRC_ALPHA,GL20.GL_ONE_MINUS_SRC_ALPHA);
      ba.opacity=opacity;
      material.set(ba);
      material.set(FloatAttribute.createAlphaTest(0.01f));
    }
 else {
      BlendingAttribute ba=new BlendingAttribute();
      ba.blended=false;
      material.set(ba);
    }
    materials.put(mat.name,material);
  }
  for (  JsonValue model : json.get(""String_Node_Str"")) {
    meshes.put(model.name,new Mesh(createModel(model),this,model.name));
  }
  HashMap<String,JsonValue> fonts=new HashMap<>();
  for (  JsonValue fontj : json.get(""String_Node_Str"")) {
    String font=fontj.asString();
    fonts.put(font,new JsonReader().parse(Gdx.files.internal(""String_Node_Str"" + font + ""String_Node_Str"")));
  }
  FAnim.loadActions(json.get(""String_Node_Str""));
  for (  JsonValue gobj : json.get(""String_Node_Str"")) {
    GameObject g=instantiator.newObject(gobj);
    g.json=gobj;
    g.name=gobj.name;
    g.scene=this;
    g.props=new HashMap<String,JsonValue>();
    for (    JsonValue prop : gobj.get(""String_Node_Str"")) {
      g.props.put(prop.name,prop);
    }
    String meshName=gobj.get(""String_Node_Str"").asString();
    if (meshName != null) {
      g.visibleNoChildren(gobj.get(""String_Node_Str"").asBoolean());
      g.mesh(meshName);
    }
 else {
      g.visibleNoChildren(false);
      g.mesh(defaultMesh);
    }
    com.badlogic.gdx.graphics.Mesh mesh=g.modelInstance.model.meshes.first();
    float[] trans=gobj.get(""String_Node_Str"").asFloatArray();
    JsonValue origin=json.get(""String_Node_Str"").get(meshName);
    JsonValue dimensions=json.get(""String_Node_Str"").get(meshName);
    g.origin=origin == null ? new Vector3f() : new Vector3f(origin.asFloatArray());
    g.dimensionsNoScale=dimensions == null ? new Vector3f(1,1,1) : new Vector3f(dimensions.asFloatArray());
    JsonValue physics=gobj.get(""String_Node_Str"");
    g.currBodyType=GameObject.BodyType.valueOf(physics.get(""String_Node_Str"").asString());
    g.currBoundsType=GameObject.BoundsType.valueOf(physics.get(""String_Node_Str"").asString());
    g.body=Bullet.makeBody(mesh,trans,g.origin,g.currBodyType,g.currBoundsType,physics);
    g.body.setUserPointer(g);
    g.scale(getGLMatrixScale(trans));
    String type=gobj.get(""String_Node_Str"").asString();
    if (type.equals(""String_Node_Str"")) {
      Text t=(Text)g;
      t.font=fonts.get(gobj.get(""String_Node_Str"").asString());
      t.text(gobj.get(""String_Node_Str"").asString());
      t.capacity=t.text().length();
    }
 else     if (type.equals(""String_Node_Str"")) {
      JsonValue settings=gobj.get(""String_Node_Str"");
      Light l=(Light)g;
      if (settings.getString(""String_Node_Str"").equals(""String_Node_Str""))       l.type=Light.Type.SUN;
 else       if (settings.getString(""String_Node_Str"").equals(""String_Node_Str""))       l.type=Light.Type.SPOT;
 else       l.type=Light.Type.POINT;
      l.energy(settings.getFloat(""String_Node_Str""));
      float[] c=settings.get(""String_Node_Str"").asFloatArray();
      l.color(new Color(c[0],c[1],c[2],c[3]));
      if (l.type.equals(Light.Type.SPOT)) {
        l.spotSize(settings.getFloat(""String_Node_Str""));
      }
    }
 else     if (type.equals(""String_Node_Str"")) {
      Camera c=(Camera)g;
      float[] projection=gobj.get(""String_Node_Str"").get(""String_Node_Str"").asFloatArray();
      Vector2f resolution=new Vector2f(json.get(""String_Node_Str"").asFloatArray());
      if (gobj.get(""String_Node_Str"").get(""String_Node_Str"").asString().equals(""String_Node_Str"")) {
        c.initData(Camera.Type.PERSPECTIVE);
        c.size(resolution);
        c.resolution(resolution);
        c.projection(new Matrix4f(projection));
        c.fov(c.fov());
      }
 else {
        c.initData(Camera.Type.ORTHOGRAPHIC);
        c.size(resolution);
        c.resolution(resolution);
        c.zoom(2 / projection[0]);
      }
      Matrix4 pm=new Matrix4(projection);
      pm.inv();
      Vector3 vec=new Vector3(0,0,-1);
      vec.prj(pm);
      c.near(-vec.z);
      vec.set(0,0,1);
      vec.prj(pm);
      c.far(-vec.z);
    }
    templates.put(g.name,g);
  }
  hookParentChild();
  cameras=new ArrayListNamed<Camera>();
  addInstances();
  camera=(Camera)objects.get(json.get(""String_Node_Str"").asStringArray()[0]);
  String frameType=json.get(""String_Node_Str"").asString();
  Viewport.Type viewportType;
  if (frameType.equals(""String_Node_Str"")) {
    viewportType=Viewport.Type.LETTERBOX;
  }
 else   if (frameType.equals(""String_Node_Str"")) {
    viewportType=Viewport.Type.EXTEND;
  }
 else {
    viewportType=Viewport.Type.SCALE;
  }
  viewport=new Viewport(this,viewportType);
  for (  GameObject g : sortByPriority(new ArrayList<GameObject>(objects))) {
    initGameObject(g);
  }
  valid=true;
}","The original code had incorrect light type assignment logic, potentially misclassifying light types due to an error in conditional ordering. In the fixed code, the light type assignment was restructured to correctly prioritize SUN and SPOT types before defaulting to POINT, ensuring proper light type classification. This modification provides more predictable and accurate light type initialization, preventing potential runtime errors or unexpected rendering behaviors."
94245,"public ArrayList<String> hitKeys(){
  ArrayList<String> keyNames=new ArrayList<String>();
  for (  String keyName : keyToCode.keySet()) {
    if (Gdx.input.isKeyJustPressed(keyToCode.get(keyName)))     keyNames.add(keyName);
  }
  return keyNames;
}","public ArrayList<String> hitKeys(){
  ArrayList<String> keyNames=new ArrayList<String>();
  for (  String keyName : keyToCode.keySet()) {
    if (!keyName.equals(""String_Node_Str"") && Gdx.input.isKeyJustPressed(keyToCode.get(keyName)))     keyNames.add(keyName);
  }
  return keyNames;
}","The original code could potentially include an unintended key with the value ""String_Node_Str"" that might trigger unexpected input detection. The fixed code adds an explicit check to exclude this specific key before checking for key presses, preventing potential false positives. By filtering out the problematic key, the method now provides a more reliable and precise list of actually pressed keys."
94246,"public ArrayList<String> downKeys(){
  ArrayList<String> keyNames=new ArrayList<String>();
  for (  String keyName : keyToCode.keySet()) {
    if (Gdx.input.isKeyPressed(keyToCode.get(keyName)))     keyNames.add(keyName);
  }
  return keyNames;
}","public ArrayList<String> downKeys(){
  ArrayList<String> keyNames=new ArrayList<String>();
  for (  String keyName : keyToCode.keySet()) {
    if (!keyName.equals(""String_Node_Str"") && Gdx.input.isKeyPressed(keyToCode.get(keyName)))     keyNames.add(keyName);
  }
  return keyNames;
}","The original code did not filter out a specific key (""String_Node_Str"") that might cause unintended behavior when checking key presses. The fixed code adds an explicit check to exclude this specific key before processing key code mapping, preventing potential issues with irrelevant key detection. By adding the condition `!keyName.equals(""String_Node_Str"")`, the method now safely filters out unwanted keys while maintaining the original key press detection logic."
94247,"public ArrayList<String> hitInputs(){
  ArrayList<String> inputs=new ArrayList<String>();
  if (profile != null) {
    for (    String s : profile.btnToCode.keySet()) {
      if (btnDown(s))       inputs.add(s);
    }
  }
  return inputs;
}","public ArrayList<String> hitInputs(){
  ArrayList<String> inputs=new ArrayList<String>();
  if (profile != null) {
    for (    String s : profile.btnToCode.keySet()) {
      if (btnHit(s))       inputs.add(s);
    }
  }
  return inputs;
}","The original code used `btnDown(s)`, which continuously detects a button being held down, potentially registering multiple inputs during a single press. The fixed code replaces `btnDown(s)` with `btnHit(s)`, which only registers a single input when a button is first pressed. This change ensures that each button press is counted exactly once, preventing duplicate or continuous input registrations and providing more precise input tracking."
94248,"public Vector3f scale(){
  return scale;
}","public Vector3f scale(){
  return new Vector3f(scale);
}","The original code directly returns the `scale` vector, which could allow external code to modify the internal state of the object. The fixed code creates and returns a new `Vector3f` instance using the copy constructor, effectively creating a defensive copy that prevents direct manipulation of the original vector. This approach ensures encapsulation and protects the object's internal data from unintended modifications, maintaining the integrity of the class's state."
94249,"public void remove(GameObject g){
  toBeAdded.remove(g);
  world.removeRigidBody(g.body);
  toBeRemoved.add(g);
}","public void remove(GameObject g){
  toBeAdded.remove(g);
  toBeRemoved.add(g);
}","The original code incorrectly attempts to remove a rigid body from the world after marking the object for removal, which could lead to potential memory management or synchronization issues. The fixed code removes the unnecessary `world.removeRigidBody(g.body)` line, focusing solely on removing the object from the `toBeAdded` list and adding it to the `toBeRemoved` list. This simplifies the removal process, preventing potential side effects and ensuring a cleaner, more controlled object lifecycle management."
94250,"private void runObjectLogic(){
  if (requestedRestart) {
    for (    GameObject g : objects) {
      g.endNoChildren();
    }
    dispose();
    init();
  }
  Bdx.mouse.scene=this;
  for (  Finger f : Bdx.fingers) {
    f.scene=this;
  }
  for (  GameObject g : objects) {
    if (!g.valid())     continue;
    if (g instanceof Light)     ((Light)g).updateLight();
    for (    Component c : g.components) {
      if (c.state != null) {
        if (c.logicCounter >= 1) {
          c.logicCounter-=1;
          c.state.main();
        }
        c.logicCounter+=c.logicFrequency * Bdx.TICK_TIME;
      }
    }
    if (g.logicCounter >= 1) {
      g.logicCounter-=1;
      g.main();
    }
    g.logicCounter+=g.logicFrequency * Bdx.TICK_TIME;
  }
  for (  GameObject g : toBeAdded) {
    objects.add(g);
    if (g instanceof Light)     lights.add((Light)g);
  }
  toBeAdded.clear();
  for (  GameObject g : toBeRemoved) {
    objects.remove(g);
    if (g instanceof Light)     lights.remove(g);
  }
  toBeRemoved.clear();
  if (requestedEnd) {
    valid=false;
    for (    GameObject g : objects)     g.end();
    dispose();
    if (Bdx.scenes.contains(this)) {
      if (Bdx.scenes.size() > 1)       Bdx.scenes.remove(this);
 else       Bdx.end();
    }
  }
}","private void runObjectLogic(){
  if (requestedRestart) {
    for (    GameObject g : objects) {
      g.endNoChildren();
    }
    dispose();
    init();
  }
  Bdx.mouse.scene=this;
  for (  Finger f : Bdx.fingers) {
    f.scene=this;
  }
  for (  GameObject g : objects) {
    if (!g.valid())     continue;
    if (g instanceof Light)     ((Light)g).updateLight();
    for (    Component c : g.components) {
      if (c.state != null) {
        if (c.logicCounter >= 1) {
          c.logicCounter-=1;
          c.state.main();
        }
        c.logicCounter+=c.logicFrequency * Bdx.TICK_TIME;
      }
    }
    if (g.logicCounter >= 1) {
      g.logicCounter-=1;
      g.main();
    }
    g.logicCounter+=g.logicFrequency * Bdx.TICK_TIME;
  }
  for (  GameObject g : toBeAdded) {
    objects.add(g);
    if (g instanceof Light)     lights.add((Light)g);
  }
  toBeAdded.clear();
  for (  GameObject g : toBeRemoved) {
    world.removeRigidBody(g.body);
    objects.remove(g);
    if (g instanceof Light)     lights.remove(g);
  }
  toBeRemoved.clear();
  if (requestedEnd) {
    valid=false;
    for (    GameObject g : objects)     g.end();
    dispose();
    if (Bdx.scenes.contains(this)) {
      if (Bdx.scenes.size() > 1)       Bdx.scenes.remove(this);
 else       Bdx.end();
    }
  }
}","The original code lacked proper rigid body removal when deleting game objects from the scene, which could lead to memory leaks and physics simulation inconsistencies. The fixed code adds `world.removeRigidBody(g.body)` in the removal loop, ensuring that corresponding physics bodies are correctly detached from the physics world when game objects are removed. This modification prevents potential memory management issues and maintains clean synchronization between game objects and their associated physics representations."
94251,"public float time(){
  if (paused)   return delta;
  return Bdx.time - timeLast;
}","public float time(){
  float f=Bdx.time - timeLast;
  if (paused)   f=delta;
  return Math.round(f * 10000.0f) / 10000.0f;
}","The original code incorrectly returns a potentially uninitialized delta value when paused, which could lead to unpredictable behavior. The fixed code calculates the time difference first, then optionally uses the delta value if paused, and rounds the result to four decimal places for precision. This approach ensures consistent and predictable time tracking by handling the paused state more robustly and preventing potential floating-point inconsistencies."
94252,"public void dispose(){
  lastFrameBuffer.dispose();
  defaultModel.dispose();
  for (  Model m : models.values())   m.dispose();
  for (  Texture t : textures.values())   t.dispose();
  for (  ScreenShader s : screenShaders)   s.dispose();
  for (  Camera c : cameras)   c.renderBuffer.dispose();
  for (  Material m : materials.values()) {
    if (m.currentTexture != null)     m.currentTexture.dispose();
  }
}","public void dispose(){
  lastFrameBuffer.dispose();
  defaultModel.dispose();
  for (  Model m : models.values())   m.dispose();
  for (  Texture t : textures.values())   t.dispose();
  for (  ScreenShader s : screenShaders)   s.dispose();
  for (  Camera c : cameras) {
    if (c.renderBuffer != null)     c.renderBuffer.dispose();
  }
  for (  Material m : materials.values()) {
    if (m.currentTexture != null)     m.currentTexture.dispose();
  }
}","The original code risked a NullPointerException when disposing of camera render buffers without first checking if the renderBuffer exists. The fixed code adds a null check before calling dispose() on the camera's renderBuffer, ensuring safe resource cleanup. This modification prevents potential runtime errors and provides more robust memory management when releasing graphics-related resources."
94253,"public static void dispose(){
  modelBatch.dispose();
  spriteBatch.dispose();
  frameBuffer.dispose();
  tempBuffer.dispose();
  for (  ShaderProgram sp : matShaders.values()) {
    sp.disposeAll();
  }
}","public static void dispose(){
  modelBatch.dispose();
  spriteBatch.dispose();
  frameBuffer.dispose();
  tempBuffer.dispose();
}","The original code attempts to dispose of shader programs from a collection, but `disposeAll()` is not a standard method for `ShaderProgram`, potentially causing runtime errors. The fixed code removes the problematic shader disposal loop, ensuring only known, safe dispose methods are called on standard LibGDX objects. This simplifies the disposal process, prevents potential exceptions, and maintains clean resource management."
94254,"private GameObject cloneNoChildren(GameObject gobj){
  GameObject g=instantiator.newObject(gobj.json);
  g.json=gobj.json;
  g.name=gobj.name;
  g.visibleNoChildren(gobj.visible());
  g.modelInstance=new ModelInstance(gobj.modelInstance);
  g.body=Bullet.cloneBody(gobj.body);
  g.currBodyType=gobj.currBodyType;
  g.currBoundsType=gobj.currBoundsType;
  g.origin=gobj.origin;
  g.dimensionsNoScale=gobj.dimensionsNoScale;
  g.body.setUserPointer(g);
  g.scale(gobj.scale());
  g.props=gobj.props;
  g.scene=this;
  if (g instanceof Camera) {
    Camera c=(Camera)g;
    Camera cc=(Camera)gobj;
  }
 else   if (g instanceof Text) {
    Text t=(Text)g;
    Text tt=(Text)gobj;
    t.font=tt.font;
    t.useUniqueModel();
  }
 else   if (g instanceof Light) {
    Light l=(Light)g;
    Light ll=(Light)gobj;
    l.energy(ll.energy());
    l.color(ll.color());
    l.type=ll.type;
    l.makeLightData();
    environment.add(l.lightData);
  }
  return g;
}","private GameObject cloneNoChildren(GameObject gobj){
  GameObject g=instantiator.newObject(gobj.json);
  g.json=gobj.json;
  g.name=gobj.name;
  g.visibleNoChildren(gobj.visible());
  g.modelInstance=new ModelInstance(gobj.modelInstance);
  g.body=Bullet.cloneBody(gobj.body);
  g.currBodyType=gobj.currBodyType;
  g.currBoundsType=gobj.currBoundsType;
  g.origin=gobj.origin;
  g.dimensionsNoScale=gobj.dimensionsNoScale;
  g.body.setUserPointer(g);
  g.scale(gobj.scale());
  g.props=gobj.props;
  g.scene=this;
  if (g instanceof Camera) {
    Camera c=(Camera)g;
    Camera cc=(Camera)gobj;
  }
 else   if (g instanceof Text) {
    Text t=(Text)g;
    Text tt=(Text)gobj;
    t.font=tt.font;
    t.useUniqueModel();
  }
 else   if (g instanceof Light) {
    Light l=(Light)g;
    Light ll=(Light)gobj;
    l.energy(ll.energy());
    l.color(ll.color());
    l.type=ll.type;
    l.makeLightData();
    l.updateLight();
    environment.add(l.lightData);
  }
  return g;
}","The original code lacks a crucial method call `updateLight()` for Light objects, potentially leaving light properties unsynchronized. The fixed code adds `l.updateLight()` before adding the light to the environment, ensuring that light data is properly refreshed and synchronized. This change guarantees that any modifications to light properties are correctly applied before being integrated into the scene's lighting environment."
94255,"private void runObjectLogic(){
  if (requestedRestart) {
    for (    GameObject g : objects) {
      g.endNoChildren();
    }
    for (    Model m : models.values()) {
      m.dispose();
    }
    for (    Texture t : textures.values()) {
      t.dispose();
    }
    init();
  }
  Bdx.mouse.scene=this;
  for (  Finger f : Bdx.fingers) {
    f.scene=this;
  }
  for (  GameObject g : objects) {
    if (!g.valid())     continue;
    for (    Component c : g.components) {
      if (c.state != null)       c.state.main();
    }
    g.main();
  }
  if (toBeAdded.size() > 0) {
    objects.addAll(toBeAdded);
    toBeAdded.clear();
  }
  if (toBeRemoved.size() > 0) {
    objects.removeAll(toBeRemoved);
    toBeRemoved.clear();
  }
}","private void runObjectLogic(){
  if (requestedRestart) {
    for (    GameObject g : objects) {
      g.endNoChildren();
    }
    for (    Model m : models.values()) {
      m.dispose();
    }
    for (    Texture t : textures.values()) {
      t.dispose();
    }
    for (    ShaderProgram s : filters) {
      s.dispose();
    }
    init();
  }
  Bdx.mouse.scene=this;
  for (  Finger f : Bdx.fingers) {
    f.scene=this;
  }
  for (  GameObject g : objects) {
    if (!g.valid())     continue;
    if (g instanceof Light)     ((Light)g).updateLight();
    for (    Component c : g.components) {
      if (c.state != null)       c.state.main();
    }
    g.main();
  }
  if (toBeAdded.size() > 0) {
    objects.addAll(toBeAdded);
    toBeAdded.clear();
  }
  if (toBeRemoved.size() > 0) {
    objects.removeAll(toBeRemoved);
    toBeRemoved.clear();
  }
}","The original code lacked proper handling of ShaderProgram disposal during scene restart, which could lead to resource leaks. The fixed code adds a disposal loop for filters (ShaderPrograms) and includes an additional check to update Light objects during the main loop, ensuring comprehensive resource management. These modifications improve scene restart robustness and prevent potential memory and rendering issues by systematically cleaning up and updating all scene-related resources."
94256,"public void dispose(){
  lastFrameBuffer.dispose();
  for (  ShaderProgram sp : filters) {
    sp.disposeAll();
  }
}","public void dispose(){
  lastFrameBuffer.dispose();
  for (  ShaderProgram s : filters) {
    s.dispose();
  }
}","The original code incorrectly calls a non-existent `disposeAll()` method on `ShaderProgram` objects, which would likely cause a compilation error or runtime exception. The fixed code replaces `disposeAll()` with the standard `dispose()` method, which is the correct way to release resources for individual shader programs. This change ensures proper resource management by calling the appropriate disposal method on each shader program, preventing potential memory leaks and improving code reliability."
94257,"public void mass(float mass){
  Vector3f inertia=new Vector3f();
  body.getCollisionShape().calculateLocalInertia(mass,inertia);
  body.setMassProps(mass,inertia);
  lastNonZeroMass=mass;
}","public void mass(float mass){
  Vector3f inertia=new Vector3f();
  body.getCollisionShape().calculateLocalInertia(mass,inertia);
  body.setMassProps(mass,inertia);
}","The original code stored the last non-zero mass in a `lastNonZeroMass` variable, which was unnecessary and potentially misleading. The fixed code removes this redundant line, focusing solely on calculating and setting the mass and inertia properties of the physics body. By eliminating the extraneous variable, the code becomes cleaner, more focused, and avoids potential side effects or unintended state tracking."
94258,"private GameObject cloneNoChildren(GameObject gobj){
  GameObject g=instantiator.newObject(gobj.json);
  g.json=gobj.json;
  g.name=gobj.name;
  g.visibleNoChildren(gobj.visible());
  g.modelInstance=new ModelInstance(gobj.modelInstance);
  g.body=Bullet.cloneBody(gobj.body);
  g.body.setUserPointer(g);
  g.scale(gobj.scale());
  g.props=gobj.props;
  g.scene=this;
  if (g instanceof Camera) {
    Camera c=(Camera)g;
    Camera cc=(Camera)gobj;
  }
 else   if (g instanceof Text) {
    Text t=(Text)g;
    Text tt=(Text)gobj;
    t.font=tt.font;
    t.useUniqueModel();
  }
 else   if (g instanceof Light) {
    Light l=(Light)g;
    Light ll=(Light)gobj;
    l.energy(ll.energy());
    l.color(ll.color());
    l.type=ll.type;
    l.makeLightData();
    environment.add(l.lightData);
  }
  return g;
}","private GameObject cloneNoChildren(GameObject gobj){
  GameObject g=instantiator.newObject(gobj.json);
  g.json=gobj.json;
  g.name=gobj.name;
  g.visibleNoChildren(gobj.visible());
  g.modelInstance=new ModelInstance(gobj.modelInstance);
  g.body=Bullet.cloneBody(gobj.body);
  g.mass(gobj.mass());
  g.body.setUserPointer(g);
  g.scale(gobj.scale());
  g.props=gobj.props;
  g.scene=this;
  if (g instanceof Camera) {
    Camera c=(Camera)g;
    Camera cc=(Camera)gobj;
  }
 else   if (g instanceof Text) {
    Text t=(Text)g;
    Text tt=(Text)gobj;
    t.font=tt.font;
    t.useUniqueModel();
  }
 else   if (g instanceof Light) {
    Light l=(Light)g;
    Light ll=(Light)gobj;
    l.energy(ll.energy());
    l.color(ll.color());
    l.type=ll.type;
    l.makeLightData();
    environment.add(l.lightData);
  }
  return g;
}","The original code missed setting the mass of the cloned GameObject, which could lead to inconsistent physical behavior. In the fixed version, `g.mass(gobj.mass())` is added to ensure that the cloned object inherits the exact mass of the original object. This change guarantees accurate physics simulation and maintains the physical properties of the source GameObject during cloning."
94259,"public static RigidBody cloneBody(RigidBody body){
  GameObject gobj=(GameObject)body.getUserPointer();
  JsonValue physics=gobj.json.get(""String_Node_Str"");
  float mass=physics.get(""String_Node_Str"").asFloat();
  Vector3f inertia=new Vector3f();
  body.getCollisionShape().calculateLocalInertia(mass,inertia);
  CollisionShape shape;
  if (gobj.modelInstance != null) {
    shape=makeShape(gobj.modelInstance.model.meshes.first(),physics.get(""String_Node_Str"").asString(),physics.get(""String_Node_Str"").asBoolean());
  }
 else {
    shape=new BoxShape(new Vector3f(0.25f,0.25f,0.25f));
  }
  RigidBody b=new RigidBody(mass,new DefaultMotionState(new Transform(gobj.transform())),shape,inertia);
  b.setCollisionFlags(gobj.body.getCollisionFlags());
  b.setAngularFactor(gobj.body.getAngularFactor());
  b.setRestitution(gobj.body.getRestitution());
  b.setFriction(gobj.body.getFriction());
  return b;
}","public static RigidBody cloneBody(RigidBody body){
  GameObject gobj=(GameObject)body.getUserPointer();
  JsonValue physics=gobj.json.get(""String_Node_Str"");
  float mass=gobj.mass();
  Vector3f inertia=new Vector3f();
  body.getCollisionShape().calculateLocalInertia(mass,inertia);
  CollisionShape shape;
  if (gobj.modelInstance != null) {
    shape=makeShape(gobj.modelInstance.model.meshes.first(),physics.get(""String_Node_Str"").asString(),physics.get(""String_Node_Str"").asBoolean());
  }
 else {
    shape=new BoxShape(new Vector3f(0.25f,0.25f,0.25f));
  }
  RigidBody b=new RigidBody(mass,new DefaultMotionState(new Transform(gobj.transform())),shape,inertia);
  b.setCollisionFlags(gobj.body.getCollisionFlags());
  b.setAngularFactor(gobj.body.getAngularFactor());
  b.setRestitution(gobj.body.getRestitution());
  b.setFriction(gobj.body.getFriction());
  return b;
}","The original code incorrectly retrieves the mass by accessing a nested JSON value multiple times, which is likely to cause errors or return incorrect data. In the fixed version, `mass` is directly obtained using `gobj.mass()`, providing a more reliable and straightforward method of mass retrieval. This change ensures proper mass calculation for the cloned rigid body, improving the code's accuracy and reducing potential runtime exceptions."
94260,"public void mass(float mass){
  Vector3f inertia=new Vector3f();
  body.getCollisionShape().calculateLocalInertia(mass,inertia);
  body.setMassProps(mass,inertia);
  lastNonZeroMass=mass;
}","public void mass(float mass){
  Vector3f inertia=new Vector3f();
  body.getCollisionShape().calculateLocalInertia(mass,inertia);
  body.setMassProps(mass,inertia);
}","The buggy code introduced an unnecessary assignment of `mass` to `lastNonZeroMass`, which could potentially lead to unintended side effects or tracking of mass changes. The fixed code removes this extra line, focusing solely on calculating and setting the mass properties of the physics body using the `calculateLocalInertia()` and `setMassProps()` methods. By eliminating the extraneous variable assignment, the code becomes cleaner, more straightforward, and maintains the core functionality of updating the body's mass characteristics."
94261,"private GameObject cloneNoChildren(GameObject gobj){
  GameObject g=instantiator.newObject(gobj.json);
  g.json=gobj.json;
  g.name=gobj.name;
  g.visibleNoChildren(gobj.visible());
  g.modelInstance=new ModelInstance(gobj.modelInstance);
  g.body=Bullet.cloneBody(gobj.body);
  g.body.setUserPointer(g);
  g.scale(gobj.scale());
  g.props=gobj.props;
  g.scene=this;
  if (g instanceof Camera) {
    Camera c=(Camera)g;
    Camera cc=(Camera)gobj;
  }
 else   if (g instanceof Text) {
    Text t=(Text)g;
    Text tt=(Text)gobj;
    t.font=tt.font;
    t.useUniqueModel();
  }
 else   if (g instanceof Light) {
    Light l=(Light)g;
    Light ll=(Light)gobj;
    l.energy(ll.energy());
    l.color(ll.color());
    l.type=ll.type;
    l.makeLightData();
    environment.add(l.lightData);
  }
  return g;
}","private GameObject cloneNoChildren(GameObject gobj){
  GameObject g=instantiator.newObject(gobj.json);
  g.json=gobj.json;
  g.name=gobj.name;
  g.visibleNoChildren(gobj.visible());
  g.modelInstance=new ModelInstance(gobj.modelInstance);
  g.body=Bullet.cloneBody(gobj.body);
  g.mass(gobj.mass());
  g.body.setUserPointer(g);
  g.scale(gobj.scale());
  g.props=gobj.props;
  g.scene=this;
  if (g instanceof Camera) {
    Camera c=(Camera)g;
    Camera cc=(Camera)gobj;
  }
 else   if (g instanceof Text) {
    Text t=(Text)g;
    Text tt=(Text)gobj;
    t.font=tt.font;
    t.useUniqueModel();
  }
 else   if (g instanceof Light) {
    Light l=(Light)g;
    Light ll=(Light)gobj;
    l.energy(ll.energy());
    l.color(ll.color());
    l.type=ll.type;
    l.makeLightData();
    environment.add(l.lightData);
  }
  return g;
}","The original code missed setting the mass of the cloned GameObject, which could lead to incorrect physics behavior. The fixed code adds `g.mass(gobj.mass());`, ensuring that the cloned object inherits the original object's mass property. This change guarantees more accurate physical simulation and consistent object duplication by preserving all critical properties during cloning."
94262,"public static RigidBody cloneBody(RigidBody body){
  GameObject gobj=(GameObject)body.getUserPointer();
  JsonValue physics=gobj.json.get(""String_Node_Str"");
  float mass=physics.get(""String_Node_Str"").asFloat();
  Vector3f inertia=new Vector3f();
  body.getCollisionShape().calculateLocalInertia(mass,inertia);
  CollisionShape shape;
  if (gobj.modelInstance != null) {
    shape=makeShape(gobj.modelInstance.model.meshes.first(),physics.get(""String_Node_Str"").asString(),physics.get(""String_Node_Str"").asBoolean());
  }
 else {
    shape=new BoxShape(new Vector3f(0.25f,0.25f,0.25f));
  }
  RigidBody b=new RigidBody(mass,new DefaultMotionState(new Transform(gobj.transform())),shape,inertia);
  b.setCollisionFlags(gobj.body.getCollisionFlags());
  b.setAngularFactor(gobj.body.getAngularFactor());
  b.setRestitution(gobj.body.getRestitution());
  b.setFriction(gobj.body.getFriction());
  return b;
}","public static RigidBody cloneBody(RigidBody body){
  GameObject gobj=(GameObject)body.getUserPointer();
  JsonValue physics=gobj.json.get(""String_Node_Str"");
  float mass=gobj.mass();
  Vector3f inertia=new Vector3f();
  body.getCollisionShape().calculateLocalInertia(mass,inertia);
  CollisionShape shape;
  if (gobj.modelInstance != null) {
    shape=makeShape(gobj.modelInstance.model.meshes.first(),physics.get(""String_Node_Str"").asString(),physics.get(""String_Node_Str"").asBoolean());
  }
 else {
    shape=new BoxShape(new Vector3f(0.25f,0.25f,0.25f));
  }
  RigidBody b=new RigidBody(mass,new DefaultMotionState(new Transform(gobj.transform())),shape,inertia);
  b.setCollisionFlags(gobj.body.getCollisionFlags());
  b.setAngularFactor(gobj.body.getAngularFactor());
  b.setRestitution(gobj.body.getRestitution());
  b.setFriction(gobj.body.getFriction());
  return b;
}","The buggy code incorrectly attempts to retrieve mass by accessing a nested JSON value, which likely leads to a runtime error or incorrect mass calculation. The fixed code replaces this with a direct call to `gobj.mass()`, which provides a more reliable and straightforward method of obtaining the object's mass. By using a dedicated mass retrieval method, the code becomes more robust, reduces potential JSON parsing errors, and ensures accurate mass assignment for the cloned rigid body."
94263,"public void init(){
  requestedRestart=false;
  paused=false;
  defaultMaterial=new Material();
  defaultModel=new ModelBuilder().createBox(1.0f,1.0f,1.0f,defaultMaterial,Usage.Position | Usage.TextureCoordinates);
  models=new HashMap<String,Model>();
  textures=new HashMap<String,Texture>();
  materials=new HashMap<String,Material>();
  modelToFrame=new HashMap<>();
  materials.put(""String_Node_Str"",defaultMaterial);
  BroadphaseInterface broadphase=new DbvtBroadphase();
  DefaultCollisionConfiguration collisionConfiguration=new DefaultCollisionConfiguration();
  SequentialImpulseConstraintSolver solver=new SequentialImpulseConstraintSolver();
  CollisionDispatcher dispatcher=new CollisionDispatcher(collisionConfiguration);
  toBeAdded=new ArrayList<GameObject>();
  toBeRemoved=new ArrayList<GameObject>();
  objects=new LinkedListNamed<GameObject>();
  templates=new HashMap<String,GameObject>();
  JsonValue json=new JsonReader().parse(scene);
  name=json.get(""String_Node_Str"").asString();
  world=new DiscreteDynamicsWorld(dispatcher,broadphase,solver,collisionConfiguration);
  world.setGravity(new Vector3f(0,0,-json.get(""String_Node_Str"").asFloat()));
  for (  JsonValue mat : json.get(""String_Node_Str"")) {
    String texName=mat.get(""String_Node_Str"").asString();
    float[] c=mat.get(""String_Node_Str"").asFloatArray();
    Material material=new Material(ColorAttribute.createDiffuse(c[0],c[1],c[2],1));
    if (texName != null) {
      Texture texture=textures.get(texName);
      if (texture == null) {
        texture=new Texture(Gdx.files.internal(""String_Node_Str"" + texName));
        textures.put(texName,texture);
      }
      material.set(TextureAttribute.createDiffuse(texture));
      texture.setWrap(TextureWrap.Repeat,TextureWrap.Repeat);
    }
    if (mat.get(""String_Node_Str"").asString().equals(""String_Node_Str"")) {
      BlendingAttribute ba=new BlendingAttribute(GL20.GL_SRC_ALPHA,GL20.GL_ONE_MINUS_SRC_ALPHA);
      ba.opacity=mat.get(""String_Node_Str"").asFloat();
      material.set(ba);
      material.set(FloatAttribute.createAlphaTest(0));
    }
    materials.put(mat.name,material);
  }
  for (  JsonValue model : json.get(""String_Node_Str"")) {
    models.put(model.name,createModel(model.name,model));
  }
  HashMap<String,JsonValue> fonts=new HashMap<>();
  for (  JsonValue fontj : json.get(""String_Node_Str"")) {
    String font=fontj.asString();
    fonts.put(font,new JsonReader().parse(Gdx.files.internal(""String_Node_Str"" + font + ""String_Node_Str"")));
  }
  FAnim.loadActions(json.get(""String_Node_Str""));
  for (  JsonValue gobj : json.get(""String_Node_Str"")) {
    GameObject g=instantiator.newObject(gobj);
    String type=gobj.get(""String_Node_Str"").asString();
    if (type.equals(""String_Node_Str"")) {
      Text t=(Text)g;
      t.font=fonts.get(gobj.get(""String_Node_Str"").asString());
    }
    g.name=gobj.name;
    JsonValue mesh=gobj.get(""String_Node_Str"");
    String meshName=mesh.asString();
    if (meshName != null) {
      g.visibleNoChildren(gobj.get(""String_Node_Str"").asBoolean());
      g.modelInstance=new ModelInstance(models.get(meshName));
    }
 else {
      g.visibleNoChildren(false);
      g.modelInstance=new ModelInstance(defaultModel);
    }
    Mesh m=g.modelInstance.model.meshes.first();
    float[] trans=gobj.get(""String_Node_Str"").asFloatArray();
    g.body=Bullet.makeBody(m,trans,gobj.get(""String_Node_Str""));
    g.body.setUserPointer(g);
    g.props=gobj.get(""String_Node_Str"");
    g._json=gobj;
    g.scene=this;
    g.scale(getGLMatrixScale(trans));
    templates.put(g.name,g);
  }
  hookParentChild();
  addInstances();
  cameras=new ArrayList<Camera>();
  String[] cameraNames=json.get(""String_Node_Str"").asStringArray();
  for (  String cn : cameraNames)   cameras.add((Camera)objects.get(cn));
  camera=cameras.get(0);
  cam=new PerspectiveCamera();
  cam.projection.set(camera._json.get(""String_Node_Str"").get(""String_Node_Str"").asFloatArray());
  ArrayList<GameObject> rootParents=new ArrayList<GameObject>();
  for (  GameObject g : objects) {
    if (g.parent() == null) {
      rootParents.add(g);
    }
  }
  for (  GameObject g : rootParents) {
    initGameObject(g);
  }
}","public void init(){
  requestedRestart=false;
  paused=false;
  defaultMaterial=new Material();
  defaultModel=new ModelBuilder().createBox(1.0f,1.0f,1.0f,defaultMaterial,Usage.Position | Usage.TextureCoordinates);
  models=new HashMap<String,Model>();
  textures=new HashMap<String,Texture>();
  materials=new HashMap<String,Material>();
  modelToFrame=new HashMap<>();
  materials.put(""String_Node_Str"",defaultMaterial);
  BroadphaseInterface broadphase=new DbvtBroadphase();
  DefaultCollisionConfiguration collisionConfiguration=new DefaultCollisionConfiguration();
  SequentialImpulseConstraintSolver solver=new SequentialImpulseConstraintSolver();
  CollisionDispatcher dispatcher=new CollisionDispatcher(collisionConfiguration);
  toBeAdded=new ArrayList<GameObject>();
  toBeRemoved=new ArrayList<GameObject>();
  objects=new LinkedListNamed<GameObject>();
  templates=new HashMap<String,GameObject>();
  JsonValue json=new JsonReader().parse(scene);
  name=json.get(""String_Node_Str"").asString();
  world=new DiscreteDynamicsWorld(dispatcher,broadphase,solver,collisionConfiguration);
  world.setGravity(new Vector3f(0,0,-json.get(""String_Node_Str"").asFloat()));
  for (  JsonValue mat : json.get(""String_Node_Str"")) {
    String texName=mat.get(""String_Node_Str"").asString();
    float[] c=mat.get(""String_Node_Str"").asFloatArray();
    Material material=new Material(ColorAttribute.createDiffuse(c[0],c[1],c[2],1));
    if (texName != null) {
      Texture texture=textures.get(texName);
      if (texture == null) {
        texture=new Texture(Gdx.files.internal(""String_Node_Str"" + texName));
        textures.put(texName,texture);
      }
      material.set(TextureAttribute.createDiffuse(texture));
      texture.setWrap(TextureWrap.Repeat,TextureWrap.Repeat);
    }
    if (mat.get(""String_Node_Str"").asString().equals(""String_Node_Str"")) {
      BlendingAttribute ba=new BlendingAttribute(GL20.GL_SRC_ALPHA,GL20.GL_ONE_MINUS_SRC_ALPHA);
      ba.opacity=mat.get(""String_Node_Str"").asFloat();
      material.set(ba);
      material.set(FloatAttribute.createAlphaTest(0));
    }
    materials.put(mat.name,material);
  }
  for (  JsonValue model : json.get(""String_Node_Str"")) {
    models.put(model.name,createModel(model.name,model));
  }
  HashMap<String,JsonValue> fonts=new HashMap<>();
  for (  JsonValue fontj : json.get(""String_Node_Str"")) {
    String font=fontj.asString();
    fonts.put(font,new JsonReader().parse(Gdx.files.internal(""String_Node_Str"" + font + ""String_Node_Str"")));
  }
  FAnim.loadActions(json.get(""String_Node_Str""));
  for (  JsonValue gobj : json.get(""String_Node_Str"")) {
    GameObject g=instantiator.newObject(gobj);
    String type=gobj.get(""String_Node_Str"").asString();
    if (type.equals(""String_Node_Str"")) {
      Text t=(Text)g;
      t.font=fonts.get(gobj.get(""String_Node_Str"").asString());
    }
    g.name=gobj.name;
    JsonValue mesh=gobj.get(""String_Node_Str"");
    String meshName=mesh.asString();
    if (meshName != null) {
      g.visibleNoChildren(gobj.get(""String_Node_Str"").asBoolean());
      g.modelInstance=new ModelInstance(models.get(meshName));
    }
 else {
      g.visibleNoChildren(false);
      g.modelInstance=new ModelInstance(defaultModel);
    }
    Mesh m=g.modelInstance.model.meshes.first();
    float[] trans=gobj.get(""String_Node_Str"").asFloatArray();
    g.body=Bullet.makeBody(m,trans,gobj.get(""String_Node_Str""));
    g.body.setUserPointer(g);
    g.props=new HashMap<String,JsonValue>();
    for (    JsonValue prop : gobj.get(""String_Node_Str"")) {
      g.props.put(prop.name,prop);
    }
    g._json=gobj;
    g.scene=this;
    g.scale(getGLMatrixScale(trans));
    templates.put(g.name,g);
  }
  hookParentChild();
  addInstances();
  cameras=new ArrayList<Camera>();
  String[] cameraNames=json.get(""String_Node_Str"").asStringArray();
  for (  String cn : cameraNames)   cameras.add((Camera)objects.get(cn));
  camera=cameras.get(0);
  cam=new PerspectiveCamera();
  cam.projection.set(camera._json.get(""String_Node_Str"").get(""String_Node_Str"").asFloatArray());
  ArrayList<GameObject> rootParents=new ArrayList<GameObject>();
  for (  GameObject g : objects) {
    if (g.parent() == null) {
      rootParents.add(g);
    }
  }
  for (  GameObject g : rootParents) {
    initGameObject(g);
  }
}","The original code directly assigned `gobj.get(""String_Node_Str"")` to `g.props`, which could lead to potential null or unexpected behavior with object properties. In the fixed code, a new `HashMap` is created, and properties are iteratively added by parsing each property from the JSON value, ensuring a robust and safe property initialization. This approach provides better error handling, allows dynamic property addition, and creates a more flexible and predictable way of storing game object properties."
94264,"private GameObject clone(GameObject gobj){
  String instance=gobj._json.get(""String_Node_Str"").asString();
  GameObject inst=gobj;
  if (instance != null)   gobj=templates.get(instance);
  GameObject g=cloneNoChildren(gobj);
  for (  GameObject c : gobj.children) {
    GameObject nc=clone(c);
    nc.parent(g);
  }
  if (instance != null) {
    g.position(inst.position());
    Matrix3f ori=inst.orientation();
    ori.mul(g.orientation());
    g.orientation(ori);
    g.props=inst.props;
    for (    GameObject c : inst.children) {
      GameObject nc=clone(c);
      nc.parent(g);
    }
  }
  return g;
}","private GameObject clone(GameObject gobj){
  String instance=gobj._json.get(""String_Node_Str"").asString();
  GameObject inst=gobj;
  if (instance != null)   gobj=templates.get(instance);
  GameObject g=cloneNoChildren(gobj);
  for (  GameObject c : gobj.children) {
    GameObject nc=clone(c);
    nc.parent(g);
  }
  if (instance != null) {
    g.position(inst.position());
    Matrix3f ori=inst.orientation();
    ori.mul(g.orientation());
    g.orientation(ori);
    g.props=new HashMap<String,JsonValue>(g.props);
    g.props.putAll(inst.props);
    for (    GameObject c : inst.children) {
      GameObject nc=clone(c);
      nc.parent(g);
    }
  }
  return g;
}","The buggy code directly assigns `inst.props` to `g.props`, which creates a reference instead of a deep copy, potentially causing unintended side effects across different object instances. In the fixed code, `g.props` is initialized as a new `HashMap` with the original properties, then updated with `inst.props` using `putAll()`, ensuring a proper independent copy. This change prevents shared property references and provides clean, isolated property management for cloned game objects."
94265,"public boolean keyUp(int code){
  Keyboard.Log k=keyboard.codeToLog.get(code);
  k.up=Keyboard.t + 1;
  return true;
}","public boolean keyUp(int code){
  Keyboard.Log k=keyboard.codeToLog.get(code);
  if (k != null)   k.up=Keyboard.t + 1;
  return true;
}","The original code assumes the key code always exists in the map, potentially causing a NullPointerException if the key is not present. The fixed code adds a null check before updating the key's up time, preventing runtime errors by only modifying the log entry when it exists. This defensive programming approach ensures the method can handle cases where a key code might not be mapped, improving the code's robustness and error handling."
94266,"public boolean keyDown(int code){
  Keyboard.Log k=keyboard.codeToLog.get(code);
  k.hit=Keyboard.t + 1;
  return true;
}","public boolean keyDown(int code){
  Keyboard.Log k=keyboard.codeToLog.get(code);
  if (k != null)   k.hit=Keyboard.t + 1;
  return true;
}","The original code assumes that a key code always exists in the map, which can lead to a NullPointerException if the key is not present. The fixed code adds a null check before accessing the Log object, preventing potential runtime errors by ensuring the key exists before attempting to modify its hit value. This defensive programming approach makes the method more robust and prevents unexpected crashes when handling keyboard input."
94267,"public void main(){
  if (active == null)   return;
  active.fps=Math.abs(active.fps);
  speed=Math.abs(speed);
  tick.delta(1f / nz(active.fps * speed));
  if (tick.time()) {
    showNextVector2f();
  }
}","public void main(){
  if (active == null)   return;
  active.fps=Math.abs(active.fps);
  speed=Math.abs(speed);
  tick.delta(1f / nz(active.fps * speed));
  if (tick.time()) {
    showNextFrame();
  }
}","The original code called `showNextVector2f()`, which likely represents an incorrect method name or implementation for frame progression. The fixed code replaces this with `showNextFrame()`, suggesting a more appropriate and standard method for advancing to the next frame in a rendering or animation context. This correction ensures proper frame management and aligns the method call with expected animation or rendering behavior."
94268,"private void download(String path,HttpServletResponse response){
  try {
    File file=new File(path);
    String filename=file.getName();
    InputStream fis=new BufferedInputStream(new FileInputStream(path));
    byte[] buffer=new byte[fis.available()];
    fis.read(buffer);
    fis.close();
    response.reset();
    response.addHeader(""String_Node_Str"",""String_Node_Str"" + new String(filename.getBytes()));
    response.addHeader(""String_Node_Str"",""String_Node_Str"" + file.length());
    OutputStream toClient=new BufferedOutputStream(response.getOutputStream());
    response.setContentType(""String_Node_Str"");
    toClient.write(buffer);
    toClient.flush();
    toClient.close();
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
}","private void download(String path,HttpServletResponse response){
  try {
    File file=new File(path);
    String filename=file.getName();
    InputStream fis=new BufferedInputStream(new FileInputStream(path));
    byte[] buffer=new byte[fis.available()];
    fis.read(buffer);
    fis.close();
    response.reset();
    response.addHeader(""String_Node_Str"",""String_Node_Str"" + new String(filename.getBytes(),""String_Node_Str""));
    response.addHeader(""String_Node_Str"",""String_Node_Str"" + file.length());
    OutputStream toClient=new BufferedOutputStream(response.getOutputStream());
    response.setContentType(""String_Node_Str"");
    toClient.write(buffer);
    toClient.flush();
    toClient.close();
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
}","The original code lacks proper character encoding when converting filename bytes, which can lead to potential encoding issues and unpredictable file naming behavior. The fixed code introduces an explicit character encoding parameter (""String_Node_Str"") when converting filename bytes, ensuring consistent and reliable character transformation across different systems and locales. By adding precise encoding handling, the updated implementation prevents potential character corruption and improves the robustness of file download functionality."
94269,"private void download(String path,HttpServletResponse response){
  try {
    File file=new File(path);
    String filename=file.getName();
    InputStream fis=new BufferedInputStream(new FileInputStream(path));
    byte[] buffer=new byte[fis.available()];
    fis.read(buffer);
    fis.close();
    response.reset();
    response.addHeader(""String_Node_Str"",""String_Node_Str"" + new String(filename.getBytes()));
    response.addHeader(""String_Node_Str"",""String_Node_Str"" + file.length());
    OutputStream toClient=new BufferedOutputStream(response.getOutputStream());
    response.setContentType(""String_Node_Str"");
    toClient.write(buffer);
    toClient.flush();
    toClient.close();
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
}","private void download(String path,HttpServletResponse response){
  try {
    File file=new File(path);
    String filename=file.getName();
    InputStream fis=new BufferedInputStream(new FileInputStream(path));
    byte[] buffer=new byte[fis.available()];
    fis.read(buffer);
    fis.close();
    response.reset();
    response.addHeader(""String_Node_Str"",""String_Node_Str"" + new String(filename.getBytes(),""String_Node_Str""));
    response.addHeader(""String_Node_Str"",""String_Node_Str"" + file.length());
    OutputStream toClient=new BufferedOutputStream(response.getOutputStream());
    response.setContentType(""String_Node_Str"");
    toClient.write(buffer);
    toClient.flush();
    toClient.close();
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
}","The original code lacks proper character encoding when converting filename bytes, which can lead to potential encoding-related issues during file downloads. The fixed code adds an explicit character encoding (""String_Node_Str"") when converting filename bytes, ensuring consistent and predictable byte-to-string conversion across different platforms and character sets. This modification enhances file download reliability by preventing potential character encoding mismatches that could corrupt or incorrectly represent filename metadata."
94270,"/** 
 * Creates the table for the given replication group member, if it does not exist. Otherwise, if the table exists but has an incorrect  {@link StreamSpecification}, update the table with the correct   {@link StreamSpecification}.
 * @param group the replication group containing the table that needs to be created
 * @param createMember the replication group member representing the table that needs to be created
 * @param awsAccess AWS access class providing DynamoDB clients to create the table
 */
public static void createTableIfNotExists(DynamoDBReplicationGroup group,DynamoDBReplicationGroupMember createMember,AccountMapToAwsAccess awsAccess) throws Exception {
  String accountNumber=new DynamoDBArn().withArnString(createMember.getArn()).getAccountNumber();
  AwsAccess accountAccess=awsAccess.getAccessAccount(accountNumber);
  coordinatorAssert(accountAccess != null,""String_Node_Str"" + accountNumber);
  AmazonDynamoDB ddbClient=accountAccess.getDynamoDB(createMember.getEndpoint());
  String tableName=new DynamoDBArn().withArnString(createMember.getArn()).getTableName();
  StreamSpecification replicationStreamSpec=new StreamSpecification().withStreamEnabled(defaultStreamEnabled).withStreamViewType(defaultStreamViewType);
  try {
    DescribeTableResult result=ddbClient.describeTable(tableName);
    TableDescription table=result.getTable();
    coordinatorAssert(table.getAttributeDefinitions().equals(AttributeDefinitionDescription.convertToAttributeDefinitions(group.getAttributeDefinitions())),""String_Node_Str"");
    coordinatorAssert(table.getKeySchema().equals(KeySchemaElementDescription.convertToKeySchemaElements(group.getKeySchema())),""String_Node_Str"");
    if (createMember.getStreamsEnabled()) {
      StreamSpecification streamSpec=result.getTable().getStreamSpecification();
      if (streamSpec == null || !replicationStreamSpec.equals(streamSpec)) {
        ddbClient.updateTable(new UpdateTableRequest().withTableName(tableName).withStreamSpecification(replicationStreamSpec));
      }
    }
  }
 catch (  ResourceNotFoundException e) {
    coordinatorAssert(createMember.getProvisionedThroughput() != null,""String_Node_Str"");
    CreateTableRequest createTableRequest=new CreateTableRequest().withTableName(tableName).withAttributeDefinitions(AttributeDefinitionDescription.convertToAttributeDefinitions(group.getAttributeDefinitions())).withKeySchema(KeySchemaElementDescription.convertToKeySchemaElements(group.getKeySchema())).withProvisionedThroughput(createMember.getProvisionedThroughput().toProvisionedThroughput());
    if (createMember.getGlobalSecondaryIndexes() != null && !createMember.getGlobalSecondaryIndexes().isEmpty()) {
      createTableRequest.setGlobalSecondaryIndexes(SecondaryIndexDesc.toGSIList(createMember.getGlobalSecondaryIndexes()));
    }
    if (createMember.getLocalSecondaryIndexes() != null && !createMember.getLocalSecondaryIndexes().isEmpty()) {
      createTableRequest.setLocalSecondaryIndexes(SecondaryIndexDesc.toLSIList(createMember.getLocalSecondaryIndexes()));
    }
    if (createMember.getStreamsEnabled()) {
      createTableRequest.setStreamSpecification(replicationStreamSpec);
    }
    ddbClient.createTable(createTableRequest);
  }
  waitForTableActive(ddbClient,tableName,WAITING_TIME_OUT);
}","/** 
 * Creates the table for the given replication group member, if it does not exist. Otherwise, if the table exists but has an incorrect  {@link StreamSpecification}, update the table with the correct   {@link StreamSpecification}.
 * @param group the replication group containing the table that needs to be created
 * @param createMember the replication group member representing the table that needs to be created
 * @param awsAccess AWS access class providing DynamoDB clients to create the table
 */
public static void createTableIfNotExists(DynamoDBReplicationGroup group,DynamoDBReplicationGroupMember createMember,AccountMapToAwsAccess awsAccess) throws Exception {
  String accountNumber=new DynamoDBArn().withArnString(createMember.getArn()).getAccountNumber();
  AwsAccess accountAccess=awsAccess.getAccessAccount(accountNumber);
  coordinatorAssert(accountAccess != null,""String_Node_Str"" + accountNumber);
  AmazonDynamoDB ddbClient=accountAccess.getDynamoDB(createMember.getEndpoint());
  String tableName=new DynamoDBArn().withArnString(createMember.getArn()).getTableName();
  StreamSpecification replicationStreamSpec=new StreamSpecification().withStreamEnabled(defaultStreamEnabled).withStreamViewType(defaultStreamViewType);
  try {
    DescribeTableResult result=ddbClient.describeTable(tableName);
    TableDescription table=result.getTable();
    coordinatorAssert(table.getKeySchema().equals(KeySchemaElementDescription.convertToKeySchemaElements(group.getKeySchema())),""String_Node_Str"");
    if (createMember.getStreamsEnabled()) {
      StreamSpecification streamSpec=result.getTable().getStreamSpecification();
      if (streamSpec == null || !replicationStreamSpec.equals(streamSpec)) {
        ddbClient.updateTable(new UpdateTableRequest().withTableName(tableName).withStreamSpecification(replicationStreamSpec));
      }
    }
  }
 catch (  ResourceNotFoundException e) {
    coordinatorAssert(createMember.getProvisionedThroughput() != null,""String_Node_Str"");
    CreateTableRequest createTableRequest=new CreateTableRequest().withTableName(tableName).withProvisionedThroughput(createMember.getProvisionedThroughput().toProvisionedThroughput());
    List<KeySchemaElement> keySchemaList=KeySchemaElementDescription.convertToKeySchemaElements(group.getKeySchema());
    createTableRequest.setKeySchema(keySchemaList);
    Set<String> requiredAttributeNames=new HashSet<String>();
    for (    KeySchemaElement keySchema : keySchemaList) {
      requiredAttributeNames.add(keySchema.getAttributeName());
    }
    if (createMember.getGlobalSecondaryIndexes() != null && !createMember.getGlobalSecondaryIndexes().isEmpty()) {
      List<GlobalSecondaryIndex> gsiList=SecondaryIndexDesc.toGSIList(createMember.getGlobalSecondaryIndexes());
      createTableRequest.setGlobalSecondaryIndexes(gsiList);
      for (      GlobalSecondaryIndex index : gsiList) {
        for (        KeySchemaElement keySchema : index.getKeySchema()) {
          requiredAttributeNames.add(keySchema.getAttributeName());
        }
      }
    }
    if (createMember.getLocalSecondaryIndexes() != null && !createMember.getLocalSecondaryIndexes().isEmpty()) {
      List<LocalSecondaryIndex> lsiList=SecondaryIndexDesc.toLSIList(createMember.getLocalSecondaryIndexes());
      createTableRequest.setLocalSecondaryIndexes(lsiList);
      for (      LocalSecondaryIndex index : lsiList) {
        for (        KeySchemaElement keySchema : index.getKeySchema()) {
          requiredAttributeNames.add(keySchema.getAttributeName());
        }
      }
    }
    if (createMember.getStreamsEnabled()) {
      createTableRequest.setStreamSpecification(replicationStreamSpec);
    }
    List<AttributeDefinition> attrDefnList=AttributeDefinitionDescription.convertToAttributeDefinitions(group.getAttributeDefinitions());
    Iterator<AttributeDefinition> iter=attrDefnList.iterator();
    while (iter.hasNext()) {
      AttributeDefinition attrDefn=iter.next();
      if (!requiredAttributeNames.contains(attrDefn.getAttributeName())) {
        iter.remove();
      }
    }
    createTableRequest.setAttributeDefinitions(attrDefnList);
    ddbClient.createTable(createTableRequest);
  }
  waitForTableActive(ddbClient,tableName,WAITING_TIME_OUT);
}","The original code incorrectly assumed all attribute definitions were required when creating a DynamoDB table, potentially causing table creation failures. The fixed code introduces a dynamic filtering mechanism that identifies and includes only attribute definitions necessary for key schemas and indexes. This improvement ensures more robust and flexible table creation by precisely matching required attributes, preventing unnecessary attribute definition errors and enhancing the method's reliability when working with complex table structures."
94271,"@Test public void testCreateTableIfNotExists() throws Exception {
  List<KeySchemaElementDescription> tableKeySchema=new ArrayList<KeySchemaElementDescription>();
  tableKeySchema.add(new KeySchemaElementDescription(""String_Node_Str"",""String_Node_Str""));
  tableKeySchema.add(new KeySchemaElementDescription(""String_Node_Str"",""String_Node_Str""));
  List<KeySchemaElementDescription> localIndexKeySchema=new ArrayList<KeySchemaElementDescription>();
  localIndexKeySchema.add(new KeySchemaElementDescription(""String_Node_Str"",""String_Node_Str""));
  localIndexKeySchema.add(new KeySchemaElementDescription(""String_Node_Str"",""String_Node_Str""));
  List<KeySchemaElementDescription> globalIndexKeySchema=new ArrayList<KeySchemaElementDescription>();
  globalIndexKeySchema.add(new KeySchemaElementDescription(""String_Node_Str"",""String_Node_Str""));
  globalIndexKeySchema.add(new KeySchemaElementDescription(""String_Node_Str"",""String_Node_Str""));
  List<AttributeDefinitionDescription> attributeDefinitions=new ArrayList<AttributeDefinitionDescription>();
  attributeDefinitions.add(new AttributeDefinitionDescription(""String_Node_Str"",""String_Node_Str""));
  attributeDefinitions.add(new AttributeDefinitionDescription(""String_Node_Str"",""String_Node_Str""));
  attributeDefinitions.add(new AttributeDefinitionDescription(""String_Node_Str"",""String_Node_Str""));
  attributeDefinitions.add(new AttributeDefinitionDescription(""String_Node_Str"",""String_Node_Str""));
  DynamoDBArn arn=new DynamoDBArn().withAccountNumber(""String_Node_Str"").withRegion(""String_Node_Str"").withTableName(""String_Node_Str"");
  ProvisionedThroughputDesc provisionedThroughput=new ProvisionedThroughputDesc(1l,1l);
  List<SecondaryIndexDesc> LSIs=new ArrayList<SecondaryIndexDesc>();
  LSIs.add(new SecondaryIndexDesc().withIndexName(""String_Node_Str"").withKeySchema(localIndexKeySchema).withProjection(new ProjectionDescription().withProjectionType(""String_Node_Str"")).withProvisionedThroughput(provisionedThroughput));
  List<SecondaryIndexDesc> GSIs=new ArrayList<SecondaryIndexDesc>();
  GSIs.add(new SecondaryIndexDesc().withIndexName(""String_Node_Str"").withKeySchema(globalIndexKeySchema).withProjection(new ProjectionDescription().withProjectionType(""String_Node_Str"")).withProvisionedThroughput(provisionedThroughput));
  DynamoDBReplicationGroupMember member=new DynamoDBReplicationGroupMember().withARN(arn.getArnString()).withEndpoint(DYNAMODB_LOCAL_ENDPOINT).withGlobalSecondaryIndexes(GSIs).withLocalSecondaryIndexes(LSIs).withProvisionedThroughput(provisionedThroughput).withStreamsEnabled(true);
  DynamoDBReplicationGroup group=new DynamoDBReplicationGroup().withAttributeDefinitions(attributeDefinitions).withKeySchema(tableKeySchema).withReplicationGroupStatus(DynamoDBReplicationGroupStatus.CREATING).withReplicationGroupUUID(""String_Node_Str"").withReplicationGroupMembers(new HashMap<String,DynamoDBReplicationGroupMember>());
  group.addReplicationGroupMember(member);
  DynamoDBReplicationUtilities.createTableIfNotExists(group,member,accounts);
}","@Test public void testCreateTableIfNotExists() throws Exception {
  List<KeySchemaElementDescription> tableKeySchema=new ArrayList<KeySchemaElementDescription>();
  tableKeySchema.add(new KeySchemaElementDescription(""String_Node_Str"",""String_Node_Str""));
  tableKeySchema.add(new KeySchemaElementDescription(""String_Node_Str"",""String_Node_Str""));
  List<AttributeDefinitionDescription> attributeDefinitions=new ArrayList<AttributeDefinitionDescription>();
  attributeDefinitions.add(new AttributeDefinitionDescription(""String_Node_Str"",""String_Node_Str""));
  attributeDefinitions.add(new AttributeDefinitionDescription(""String_Node_Str"",""String_Node_Str""));
  attributeDefinitions.add(new AttributeDefinitionDescription(""String_Node_Str"",""String_Node_Str""));
  attributeDefinitions.add(new AttributeDefinitionDescription(""String_Node_Str"",""String_Node_Str""));
  DynamoDBArn arn=new DynamoDBArn().withAccountNumber(""String_Node_Str"").withRegion(""String_Node_Str"").withTableName(""String_Node_Str"");
  ProvisionedThroughputDesc provisionedThroughput=new ProvisionedThroughputDesc(1l,1l);
  DynamoDBReplicationGroupMember member=new DynamoDBReplicationGroupMember().withARN(arn.getArnString()).withEndpoint(DYNAMODB_LOCAL_ENDPOINT).withProvisionedThroughput(provisionedThroughput).withStreamsEnabled(true);
  DynamoDBReplicationGroup group=new DynamoDBReplicationGroup().withAttributeDefinitions(attributeDefinitions).withKeySchema(tableKeySchema).withReplicationGroupStatus(DynamoDBReplicationGroupStatus.CREATING).withReplicationGroupUUID(""String_Node_Str"").withReplicationGroupMembers(new HashMap<String,DynamoDBReplicationGroupMember>());
  group.addReplicationGroupMember(member);
  DynamoDBReplicationUtilities.createTableIfNotExists(group,member,accounts);
}","The original code created unnecessary and unused local and global secondary indexes, which added complexity and potential performance overhead. The fixed code removes these unused indexes, simplifying the table creation process by focusing only on essential attributes and key schema. By eliminating redundant index configurations, the updated implementation becomes more streamlined, reducing potential errors and improving the efficiency of table creation in the DynamoDB replication group."
94272,"public static void getParcelable(Bundle savedInstanceState,Anthology anthology){
  if (savedInstanceState != null) {
    anthology=savedInstanceState.getParcelable(PARCELABLE_KEY);
  }
 else {
    throw new IllegalArgumentException(TAG + ""String_Node_Str"");
  }
}","public static Anthology getParcelable(Bundle savedInstanceState){
  if (savedInstanceState != null) {
    return savedInstanceState.getParcelable(PARCELABLE_KEY);
  }
 else {
    throw new IllegalArgumentException(TAG + ""String_Node_Str"");
  }
}","The original code incorrectly modifies the input `anthology` parameter within the method, which does not return or persist the modified object. The fixed code returns the `Parcelable` directly from the `savedInstanceState` and changes the method signature to return the `Anthology` object, allowing the caller to receive the retrieved parcelable. This approach provides a clearer, more predictable method that directly returns the desired object instead of attempting to modify an input parameter."
94273,"public static void putParcelable(Bundle savedInstanceState,Anthology anthology){
  if (savedInstanceState != null && anthology != null) {
    savedInstanceState.putParcelable(PARCELABLE_KEY,anthology);
  }
 else {
    throw new IllegalArgumentException(TAG + ""String_Node_Str"");
  }
}","public static void putParcelable(Bundle savedInstanceState,Anthology anthology){
  if (savedInstanceState != null && anthology != null) {
    savedInstanceState.putParcelable(PARCELABLE_KEY,anthology);
  }
}","The original code unnecessarily throws an IllegalArgumentException when either savedInstanceState or anthology is null, potentially disrupting the method's intended flow. The fixed code removes the exception, allowing the method to silently handle null inputs without causing abrupt termination. This modification provides more flexible and graceful error handling, enabling calling methods to decide how to manage scenarios with null parameters."
94274,"public static void getParcelable(Bundle savedInstanceState,Story story){
  if (savedInstanceState != null) {
    story=savedInstanceState.getParcelable(PARCELABLE_KEY);
  }
 else {
    throw new IllegalArgumentException(TAG + ""String_Node_Str"");
  }
}","public static Story getParcelable(Bundle savedInstanceState){
  if (savedInstanceState != null) {
    return savedInstanceState.getParcelable(PARCELABLE_KEY);
  }
 else {
    throw new IllegalArgumentException(TAG + ""String_Node_Str"");
  }
}","The original method incorrectly modifies the input `story` parameter without returning the retrieved Parcelable, which prevents the caller from accessing the restored data. The fixed code changes the method to return the Parcelable directly and removes the input `story` parameter, making it a proper getter method that retrieves and returns the saved state. This improvement ensures that the Parcelable object can be successfully retrieved and used by the calling code, enhancing method reliability and clarity."
94275,"public static void putParcelable(Bundle savedInstanceState,Story story){
  if (savedInstanceState != null && story != null) {
    savedInstanceState.putParcelable(PARCELABLE_KEY,story);
  }
 else {
    throw new IllegalArgumentException(TAG + ""String_Node_Str"");
  }
}","public static void putParcelable(Bundle savedInstanceState,Story story){
  if (savedInstanceState != null && story != null) {
    savedInstanceState.putParcelable(PARCELABLE_KEY,story);
  }
}","The original code unnecessarily throws an IllegalArgumentException when either savedInstanceState or story is null, which can disrupt the normal flow of the application. The fixed code removes the exception, allowing the method to silently handle null inputs without interrupting the program execution. This improvement provides more graceful error handling and prevents potential crashes, making the code more robust and flexible."
94276,"private void restoreInstanceState(Bundle savedInstanceState){
  Anthology.getParcelable(savedInstanceState,mHotAnthology);
  mHotAdapter=new HotAdapter(mHotView.getContext(),mHotAnthology.getStories());
  mHotView.setAdapterForRecyclerView(mHotAdapter);
}","private void restoreInstanceState(Bundle savedInstanceState){
  mHotAnthology=Anthology.getParcelable(savedInstanceState);
  mHotAdapter=new HotAdapter(mHotView.getContext(),mHotAnthology.getStories());
  mHotView.setAdapterForRecyclerView(mHotAdapter);
}","The buggy code incorrectly attempts to retrieve a Parcelable object by passing the anthology object as a parameter, which is an invalid method call. In the fixed code, the method correctly assigns the Parcelable object directly to `mHotAnthology` using the proper `Anthology.getParcelable()` method with only the `savedInstanceState`. This correction ensures proper restoration of the instance state, allowing the adapter to be correctly initialized with the retrieved anthology's stories."
94277,"private void pullHotAnthologyFromNetwork(){
  if (mGetHotAnthologySubscription != null) {
    mGetHotAnthologySubscription.unsubscribe();
    mGetHotAnthologySubscription=null;
  }
  mIsLoading=true;
  mGetHotAnthologyObservable=mGMHService.getHotAnthology(mHotAnthology.getNextPageUrl()).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).doOnTerminate(new Action0(){
    @Override public void call(){
      mGetHotAnthologyObservable=null;
    }
  }
).cache();
  mGetHotAnthologySubscription=mGetHotAnthologyObservable.subscribe(mGetHotAnthologyObserver);
}","private void pullHotAnthologyFromNetwork(){
  if (mGetHotAnthologySubscription != null) {
    mGetHotAnthologySubscription.unsubscribe();
    mGetHotAnthologySubscription=null;
  }
  mIsLoading=true;
  mGetHotAnthologyObservable=mGMHService.getHotAnthology(mHotAnthology.getNextPageUrl()).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).cache();
  mGetHotAnthologySubscription=mGetHotAnthologyObservable.subscribe(mGetHotAnthologyObserver);
}","The original code unnecessarily added a doOnTerminate() block that set mGetHotAnthologyObservable to null, potentially causing unnecessary null checks and complicating observable management. The fixed code removes this redundant block, simplifying the code and maintaining the core functionality of network request and subscription handling. By eliminating the extra action, the code becomes cleaner, more predictable, and reduces potential memory management complexities in the RxJava observable chain."
94278,"@Override public void onError(Throwable e){
  if (BuildConfig.DEBUG) {
    e.printStackTrace();
  }
  mIsLoading=false;
  mHotView.hideHotProgressBar();
  mHotView.hideHotSwipeRefreshLayout();
  if (mHotAdapter.getItemCount() == 0) {
    mHotView.showNetworkingErrorImageView();
  }
}","@Override public void onError(Throwable e){
  mGetHotAnthologyObservable=null;
  if (BuildConfig.DEBUG) {
    e.printStackTrace();
  }
  mIsLoading=false;
  mHotView.hideHotProgressBar();
  mHotView.hideHotSwipeRefreshLayout();
  if (mHotAdapter.getItemCount() == 0) {
    mHotView.showNetworkingErrorImageView();
  }
}","The original code lacked proper cleanup of the observable reference, potentially causing memory leaks or unexpected behavior during error handling. The fixed code adds `mGetHotAnthologyObservable=null;` to explicitly clear the observable reference, ensuring proper resource management and preventing potential reference-related issues. By nullifying the observable, the code improves memory efficiency and prevents potential lingering references that could interfere with subsequent network calls or view updates."
94279,"@Override public void onCompleted(){
  if (mHotAdapter != null) {
    mHotAdapter.addStories(mHotAnthology.getStories());
  }
  mIsLoading=false;
  mHotView.hideHotProgressBar();
  mHotView.hideHotSwipeRefreshLayout();
  mHotView.hideNetworkingErrorImageView();
}","@Override public void onCompleted(){
  mGetHotAnthologyObservable=null;
  if (mHotAdapter != null) {
    mHotAdapter.addStories(mHotAnthology.getStories());
  }
  mIsLoading=false;
  mHotView.hideHotProgressBar();
  mHotView.hideHotSwipeRefreshLayout();
  mHotView.hideNetworkingErrorImageView();
}","The original code lacks cleanup of the observable reference after completion, potentially leading to memory leaks or unintended repeated calls. The fixed code adds `mGetHotAnthologyObservable=null` to explicitly nullify the observable reference, ensuring proper resource management and preventing potential memory-related issues. This simple addition improves code reliability by preventing stale observable references and supporting clean memory handling during the observable's lifecycle."
94280,"@Override public void onNext(Anthology anthology){
  mHotAnthology=anthology;
}","@Override public void onNext(Anthology anthology){
  mHotAnthology.setNextPageUrl(anthology.getNextPageUrl());
  mHotAnthology.getStories().addAll(anthology.getStories());
}","The original code simply overwrites the entire `mHotAnthology` object, potentially losing existing data and breaking any ongoing pagination or data collection process. The fixed code preserves the existing `mHotAnthology` by updating its next page URL and appending new stories to its existing collection, maintaining data continuity. This approach ensures that subsequent API calls can seamlessly accumulate stories while keeping track of the pagination state."
94281,"@Override public void onActivityCreated(Bundle savedInstanceState){
  mHotView.initializeHotSwipeRefreshLayout();
  mHotView.initializeHotNetworkingErrorImageView();
  mHotView.initializeHotRecyclerView();
  mHotView.hideHotSwipeRefreshLayout();
  mHotView.showHotProgressBar();
  mHotView.hideNetworkingErrorImageView();
  if (savedInstanceState == null) {
    initializeInstanceState();
    pullHotAnthologyFromNetwork();
  }
 else {
    restoreInstanceState(savedInstanceState);
    pullHotAnthologyFromCache();
  }
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  mHotView.initializeHotSwipeRefreshLayout();
  mHotView.initializeHotNetworkingErrorImageView();
  mHotView.initializeHotRecyclerView();
  mHotView.hideHotSwipeRefreshLayout();
  mHotView.hideNetworkingErrorImageView();
  if (savedInstanceState == null) {
    mHotView.showHotProgressBar();
    initializeInstanceState();
    pullHotAnthologyFromNetwork();
  }
 else {
    restoreInstanceState(savedInstanceState);
    pullHotAnthologyFromCache();
  }
}","The original code redundantly called `showHotProgressBar()` outside the conditional block, potentially displaying the progress bar even when restoring state from a saved instance. In the fixed code, `showHotProgressBar()` is moved inside the `savedInstanceState == null` condition, ensuring the progress bar is only shown when initially loading data from the network. This change prevents unnecessary UI flickering and provides a more precise control over the progress bar's visibility during different app lifecycle scenarios."
94282,"private void restoreInstanceState(Bundle savedInstanceState){
  Anthology.getParcelable(savedInstanceState,mTrendingAnthology);
  mTrendingAdapter=new TrendingAdapter(mTrendingAnthology.getStories());
  mTrendingView.setAdapterForRecyclerView(mTrendingAdapter);
}","private void restoreInstanceState(Bundle savedInstanceState){
  mTrendingAnthology=Anthology.getParcelable(savedInstanceState);
  mTrendingAdapter=new TrendingAdapter(mTrendingAnthology.getStories());
  mTrendingView.setAdapterForRecyclerView(mTrendingAdapter);
}","The original code incorrectly attempts to restore the Anthology object by passing both the bundle and object parameters to the getParcelable method, which is syntactically wrong. The fixed code correctly retrieves the Anthology object from the savedInstanceState bundle by passing only the bundle as an argument, properly assigning the result to mTrendingAnthology. This correction ensures proper state restoration, allowing the subsequent adapter initialization and RecyclerView setup to work with the correctly retrieved Anthology object."
94283,"private void pullTrendingAnthologyFromNetwork(){
  if (mGetTrendingAnthologySubscription != null) {
    mGetTrendingAnthologySubscription.unsubscribe();
    mGetTrendingAnthologySubscription=null;
  }
  mIsLoading=true;
  mGetTrendingAnthologyObservable=mGMHService.getTrendingAnthology(mTrendingAnthology.getNextPageUrl()).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).doOnTerminate(new Action0(){
    @Override public void call(){
      mGetTrendingAnthologyObservable=null;
    }
  }
).cache();
  mGetTrendingAnthologySubscription=mGetTrendingAnthologyObservable.subscribe(mGetTrendingAnthologyObserver);
}","private void pullTrendingAnthologyFromNetwork(){
  if (mGetTrendingAnthologySubscription != null) {
    mGetTrendingAnthologySubscription.unsubscribe();
    mGetTrendingAnthologySubscription=null;
  }
  mIsLoading=true;
  mGetTrendingAnthologyObservable=mGMHService.getTrendingAnthology(mTrendingAnthology.getNextPageUrl()).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).cache();
  mGetTrendingAnthologySubscription=mGetTrendingAnthologyObservable.subscribe(mGetTrendingAnthologyObserver);
}","The original code included an unnecessary and potentially memory-leaking doOnTerminate() block that was incorrectly setting the Observable to null. The fixed code removes this redundant callback, simplifying the method and preventing potential null pointer risks. By eliminating the extra callback, the code becomes more straightforward, maintains the core functionality of fetching trending anthology data, and ensures cleaner resource management during network operations."
94284,"@Override public void onError(Throwable e){
  if (BuildConfig.DEBUG) {
    e.printStackTrace();
  }
  mIsLoading=false;
  mTrendingView.hideTrendingProgressBar();
  mTrendingView.hideTrendingSwipeRefreshLayout();
  if (mTrendingAdapter.getItemCount() == 0) {
    mTrendingView.showNetworkingErrorImageView();
  }
}","@Override public void onError(Throwable e){
  mGetTrendingAnthologyObservable=null;
  if (BuildConfig.DEBUG) {
    e.printStackTrace();
  }
  mIsLoading=false;
  mTrendingView.hideTrendingProgressBar();
  mTrendingView.hideTrendingSwipeRefreshLayout();
  if (mTrendingAdapter.getItemCount() == 0) {
    mTrendingView.showNetworkingErrorImageView();
  }
}","The original code lacked proper observable cleanup, potentially causing memory leaks or unintended continuation of network requests. The fixed code adds `mGetTrendingAnthologyObservable=null`, ensuring the observable reference is reset after an error, preventing potential ghost requests or stale network operations. This change improves resource management and prevents potential unexpected behavior during error handling scenarios."
94285,"@Override public void onCompleted(){
  if (mTrendingAdapter != null) {
    mTrendingAdapter.addStories(mTrendingAnthology.getStories());
  }
  mIsLoading=false;
  mTrendingView.hideTrendingProgressBar();
  mTrendingView.hideTrendingSwipeRefreshLayout();
  mTrendingView.hideNetworkingErrorImageView();
}","@Override public void onCompleted(){
  mGetTrendingAnthologyObservable=null;
  if (mTrendingAdapter != null) {
    mTrendingAdapter.addStories(mTrendingAnthology.getStories());
  }
  mIsLoading=false;
  mTrendingView.hideTrendingProgressBar();
  mTrendingView.hideTrendingSwipeRefreshLayout();
  mTrendingView.hideNetworkingErrorImageView();
}","The original code lacks proper resource management by not nullifying the observable after completion, potentially leading to memory leaks or unintended repeated callbacks. The fixed code adds `mGetTrendingAnthologyObservable=null;` to explicitly clear the reference, preventing potential retain cycles and ensuring clean observable state. This modification improves memory efficiency and prevents potential unexpected behavior in subsequent method calls by properly managing the observable's lifecycle."
94286,"@Override public void onNext(Anthology anthology){
  mTrendingAnthology=anthology;
}","@Override public void onNext(Anthology anthology){
  mTrendingAnthology.setNextPageUrl(anthology.getNextPageUrl());
  mTrendingAnthology.getStories().addAll(anthology.getStories());
}","The original code simply replaces the entire mTrendingAnthology object, potentially losing existing data and breaking any references. The fixed code preserves the existing mTrendingAnthology by updating its next page URL and appending new stories from the incoming anthology, maintaining data continuity. This approach ensures that pagination works correctly and all previously loaded stories are retained while incorporating new content."
94287,"@Override public void onActivityCreated(Bundle savedInstanceState){
  mTrendingView.initializeTrendingSwipeRefreshLayout();
  mTrendingView.initializeTrendingNetworkingErrorImageView();
  mTrendingView.initializeTrendingRecyclerView();
  mTrendingView.hideTrendingSwipeRefreshLayout();
  mTrendingView.showTrendingProgressBar();
  mTrendingView.hideNetworkingErrorImageView();
  if (savedInstanceState == null) {
    initializeInstanceState();
    pullTrendingAnthologyFromNetwork();
  }
 else {
    restoreInstanceState(savedInstanceState);
    pullTrendingAnthologyFromCache();
  }
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  mTrendingView.initializeTrendingSwipeRefreshLayout();
  mTrendingView.initializeTrendingNetworkingErrorImageView();
  mTrendingView.initializeTrendingRecyclerView();
  mTrendingView.hideTrendingSwipeRefreshLayout();
  mTrendingView.hideNetworkingErrorImageView();
  if (savedInstanceState == null) {
    mTrendingView.showTrendingProgressBar();
    initializeInstanceState();
    pullTrendingAnthologyFromNetwork();
  }
 else {
    restoreInstanceState(savedInstanceState);
    pullTrendingAnthologyFromCache();
  }
}","The original code showed the progress bar unconditionally before checking the savedInstanceState, which could lead to unnecessary UI updates and potential synchronization issues. In the fixed code, `showTrendingProgressBar()` is moved inside the `savedInstanceState == null` condition, ensuring the progress bar is only displayed when fetching fresh network data. This change ensures a more precise and context-aware UI management, preventing redundant progress bar visibility and improving the overall user experience during activity recreation."
94288,"private void pullVoteStoryFromNetwork(){
  if (mGetVoteStorySubscription != null) {
    mGetVoteStorySubscription.unsubscribe();
    mGetVoteStorySubscription=null;
  }
  mGetVoteStoryObservable=mGMHService.getVoteStory(ApiModule.VOTE_URL).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).doOnTerminate(new Action0(){
    @Override public void call(){
      mGetVoteStoryObservable=null;
    }
  }
).cache();
  mGetVoteStorySubscription=mGetVoteStoryObservable.subscribe(mGetVoteStoryObserver);
}","private void pullVoteStoryFromNetwork(){
  if (mGetVoteStorySubscription != null) {
    mGetVoteStorySubscription.unsubscribe();
    mGetVoteStorySubscription=null;
  }
  mGetVoteStoryObservable=mGMHService.getVoteStory(ApiModule.VOTE_URL).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).cache();
  mGetVoteStorySubscription=mGetVoteStoryObservable.subscribe(mGetVoteStoryObserver);
}","The original code incorrectly used `.doOnTerminate()` with a redundant action that sets `mGetVoteStoryObservable` to null, which is unnecessary and could potentially interfere with observable lifecycle management. The fixed code removes the `.doOnTerminate()` method, simplifying the observable chain and eliminating the superfluous null assignment. By removing the unnecessary method, the code becomes more straightforward, maintains the core functionality of fetching and caching the vote story, and reduces potential side effects in the observable stream."
94289,"private void restoreInstanceState(Bundle savedInstanceState){
  Story.getParcelable(savedInstanceState,mVoteStory);
  if (mVoteStory != null) {
    mVoteView.setVoteImageView(mVoteStory.getImageUrl());
    mVoteView.setVoteFooterTextView(mVoteStory.getFooter());
    mVoteView.showVoteCardView();
  }
}","private void restoreInstanceState(Bundle savedInstanceState){
  mVoteStory=Story.getParcelable(savedInstanceState);
  if (mVoteStory != null) {
    mVoteView.setVoteImageView(mVoteStory.getImageUrl());
    mVoteView.setVoteFooterTextView(mVoteStory.getFooter());
    mVoteView.showVoteCardView();
  }
}","The original code incorrectly used `Story.getParcelable()` with wrong parameter order, attempting to modify `mVoteStory` in-place instead of retrieving it from the saved instance state. The fixed code correctly assigns the restored parcelable object to `mVoteStory` by calling `Story.getParcelable(savedInstanceState)` and storing the returned value. This correction ensures proper state restoration, allowing the method to correctly retrieve and display the saved story data when the activity is recreated."
94290,"@Override public void call(){
  mGetVoteStoryObservable=null;
}","@Override public void call(){
  mIsVoting=false;
}","Setting `mGetVoteStoryObservable` to null does not properly handle voting state and may lead to unintended side effects in the method's execution. The fixed code sets `mIsVoting` to false, which explicitly signals that the voting process has concluded and allows for proper state management. This change ensures a more predictable and clear representation of the voting status, preventing potential race conditions or unexpected behavior in the voting workflow."
94291,"@Override public void onActivityCreated(Bundle savedInstanceState){
  mVoteView.initializeVoteSwipeRefreshLayout();
  mVoteView.initializeVoteNetworkingErrorImageView();
  mVoteView.hideVoteSwipeRefreshLayout();
  mVoteView.hideVoteCardView();
  mVoteView.showVoteProgressBar();
  mVoteView.hideNetworkingErrorImageView();
  if (savedInstanceState == null) {
    pullVoteStoryFromNetwork();
  }
 else {
    restoreInstanceState(savedInstanceState);
    pullVoteStoryFromCache();
  }
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  mVoteView.initializeVoteSwipeRefreshLayout();
  mVoteView.initializeVoteNetworkingErrorImageView();
  mVoteView.hideVoteSwipeRefreshLayout();
  mVoteView.hideVoteCardView();
  mVoteView.hideNetworkingErrorImageView();
  if (savedInstanceState == null) {
    mVoteView.showVoteProgressBar();
    pullVoteStoryFromNetwork();
  }
 else {
    restoreInstanceState(savedInstanceState);
    pullVoteStoryFromCache();
  }
}","The original code incorrectly shows the progress bar before checking if the instance state is null, which could lead to unnecessary UI updates. In the fixed code, `showVoteProgressBar()` is moved inside the null instance state condition, ensuring the progress bar is only displayed when initially loading data from the network. This change prevents redundant progress bar visibility and provides a more precise user experience during app state restoration and initial data loading."
94292,"public void addStories(List<Story> newStories){
  int currentSize=mStories.size();
  int amountInserted=newStories.size();
  mStories.addAll(newStories);
  notifyItemRangeChanged(currentSize,amountInserted);
}","public void addStories(List<Story> newStories){
  int currentSize=mStories.size();
  int amountInserted=newStories.size();
  mStories.addAll(newStories);
  notifyItemRangeInserted(currentSize,amountInserted);
}","The original code uses `notifyItemRangeChanged()`, which incorrectly signals updates to existing items instead of new insertions. The fixed code replaces this with `notifyItemRangeInserted()`, which properly notifies the adapter about newly added items at the specified position. This correction ensures accurate UI updates when new stories are added to the list, preventing potential rendering issues and maintaining proper synchronization between the data and the view."
94293,"public void addStories(List<Story> newStories){
  int currentSize=mStories.size();
  int amountInserted=newStories.size();
  mStories.addAll(newStories);
  notifyItemRangeChanged(currentSize,amountInserted);
}","public void addStories(List<Story> newStories){
  int currentSize=mStories.size();
  int amountInserted=newStories.size();
  mStories.addAll(newStories);
  notifyItemRangeInserted(currentSize,amountInserted);
}","The original code uses `notifyItemRangeChanged()`, which incorrectly signals existing items were modified instead of new items being inserted. The fixed code replaces this with `notifyItemRangeInserted()`, which properly indicates that new items have been added to the list at a specific position. This change ensures the adapter correctly updates the view, reflecting the new stories without mistakenly suggesting existing items were altered."
94294,"@Override public void onCompleted(){
  mGetHotAnthologyObservable=null;
  if (mHotAdapter != null) {
    mHotAdapter.addStories(mHotAnthology.getStories());
  }
  mIsLoading=false;
  mHotView.hideHotProgressBar();
  mHotView.hideHotSwipeRefreshLayout();
  mHotView.hideNetworkingErrorImageView();
}","@Override public void onCompleted(){
  mGetHotAnthologyObservable=null;
  mIsLoading=false;
  mHotView.hideHotProgressBar();
  mHotView.hideHotSwipeRefreshLayout();
  mHotView.hideNetworkingErrorImageView();
}","The original code had a potential null pointer risk by attempting to add stories to the adapter even if the anthology might be null. The fixed code removes the conditional check, preventing a potential null pointer exception and ensuring more robust error handling. This simplified version provides a cleaner, safer approach to handling the observable completion process without risking unexpected runtime errors."
94295,"@Override public void onNext(Anthology anthology){
  mHotAnthology.setNextPageUrl(anthology.getNextPageUrl());
  mHotAnthology.getStories().addAll(anthology.getStories());
}","@Override public void onNext(Anthology anthology){
  mHotAnthology.setNextPageUrl(anthology.getNextPageUrl());
  mHotAnthology.getStories().addAll(anthology.getStories());
  if (mHotAdapter != null) {
    mHotAdapter.addStories(anthology.getStories());
  }
}","The original code updates the anthology data model but fails to notify the adapter about the new stories, preventing UI updates. The fixed code adds a null check and calls `mHotAdapter.addStories()` to explicitly inform the adapter of the new stories, ensuring the UI reflects the latest data. This approach synchronizes the data model with the view, maintaining consistency and preventing potential null pointer exceptions."
94296,"@Override public void onCompleted(){
  mGetTrendingAnthologyObservable=null;
  if (mTrendingAdapter != null) {
    mTrendingAdapter.addStories(mTrendingAnthology.getStories());
  }
  mIsLoading=false;
  mTrendingView.hideTrendingProgressBar();
  mTrendingView.hideTrendingSwipeRefreshLayout();
  mTrendingView.hideNetworkingErrorImageView();
}","@Override public void onCompleted(){
  mGetTrendingAnthologyObservable=null;
  mIsLoading=false;
  mTrendingView.hideTrendingProgressBar();
  mTrendingView.hideTrendingSwipeRefreshLayout();
  mTrendingView.hideNetworkingErrorImageView();
}","The original code attempts to add stories to the adapter after potentially nullifying the anthology, which could lead to a null pointer exception. The fixed code removes the conditional addition of stories, preventing potential null reference errors and ensuring more robust error handling. By simplifying the logic and eliminating the risky conditional block, the code becomes more stable and less prone to runtime crashes."
94297,"@Override public void onNext(Anthology anthology){
  mTrendingAnthology.setNextPageUrl(anthology.getNextPageUrl());
  mTrendingAnthology.getStories().addAll(anthology.getStories());
}","@Override public void onNext(Anthology anthology){
  mTrendingAnthology.setNextPageUrl(anthology.getNextPageUrl());
  mTrendingAnthology.getStories().addAll(anthology.getStories());
  if (mTrendingAdapter != null) {
    mTrendingAdapter.addStories(anthology.getStories());
  }
}","The original code updates the anthology's stories but fails to notify the adapter about the new data, potentially leaving the UI not reflecting the added stories. The fixed code adds a check for the adapter's existence and calls `addStories()`, which ensures the new stories are properly integrated into the view. This modification guarantees that the UI is synchronized with the data model, providing a seamless and responsive user experience."
94298,"private void pullHotAnthologyFromCache(){
  if (mGetHotAnthologySubscription != null) {
    mGetHotAnthologySubscription.unsubscribe();
    mGetHotAnthologySubscription=null;
  }
  if (mGetHotAnthologyObservable != null) {
    mGetHotAnthologySubscription=mGetHotAnthologyObservable.subscribe(mGetHotAnthologyObserver);
  }
}","private void pullHotAnthologyFromCache(){
  if (mGetHotAnthologySubscription != null) {
    mGetHotAnthologySubscription.unsubscribe();
    mGetHotAnthologySubscription=null;
  }
  if (mGetHotAnthologyObservable != null) {
    mIsLoading=true;
    mGetHotAnthologySubscription=mGetHotAnthologyObservable.subscribe(mGetHotAnthologyObserver);
  }
}","The original code lacked a loading state flag, potentially causing race conditions or inconsistent UI during data retrieval. The fixed code introduces `mIsLoading=true` before subscription, explicitly marking the start of the loading process and enabling proper loading state management. This improvement ensures better UI responsiveness and prevents potential synchronization issues during hot anthology cache pulling."
94299,"@Override public void onNext(Anthology anthology){
  mHotAnthology.setNextPageUrl(anthology.getNextPageUrl());
  mHotAnthology.getStories().addAll(anthology.getStories());
  if (mHotAdapter != null) {
    mHotAdapter.addStories(anthology.getStories());
  }
}","@Override public void onNext(Anthology anthology){
  mHotAnthology.setNextPageUrl(anthology.getNextPageUrl());
  if (mHotAdapter != null) {
    mHotAdapter.addStories(anthology.getStories());
    mHotAnthology.setStories(mHotAdapter.getStories());
  }
}","The buggy code directly adds stories to both `mHotAnthology` and `mHotAdapter` independently, potentially causing data inconsistency and duplicate entries. The fixed code ensures that stories are first added to the adapter, then the `mHotAnthology` is updated with the adapter's complete story list, maintaining synchronization between data sources. This approach prevents potential data misalignment and ensures a single, consistent source of truth for the anthology's stories."
94300,"@Override public void onNext(Anthology anthology){
  mTrendingAnthology.setNextPageUrl(anthology.getNextPageUrl());
  mTrendingAnthology.getStories().addAll(anthology.getStories());
  if (mTrendingAdapter != null) {
    mTrendingAdapter.addStories(anthology.getStories());
  }
}","@Override public void onNext(Anthology anthology){
  mTrendingAnthology.setNextPageUrl(anthology.getNextPageUrl());
  if (mTrendingAdapter != null) {
    mTrendingAdapter.addStories(anthology.getStories());
    mTrendingAnthology.setStories(mTrendingAdapter.getStories());
  }
}","The original code directly adds new stories to `mTrendingAnthology` without maintaining a consistent state with the adapter, potentially causing data synchronization issues. The fixed code first adds stories to the adapter and then updates `mTrendingAnthology` with the adapter's complete story list, ensuring data consistency and preventing potential duplicate or mismatched entries. This approach guarantees that the anthology's stories always reflect the current state of the adapter, creating a more reliable and synchronized data management strategy."
94301,"private void pullTrendingAnthologyFromCache(){
  if (mGetTrendingAnthologySubscription != null) {
    mGetTrendingAnthologySubscription.unsubscribe();
    mGetTrendingAnthologySubscription=null;
  }
  if (mGetTrendingAnthologyObservable != null) {
    mGetTrendingAnthologySubscription=mGetTrendingAnthologyObservable.subscribe(mGetTrendingAnthologyObserver);
  }
}","private void pullTrendingAnthologyFromCache(){
  if (mGetTrendingAnthologySubscription != null) {
    mGetTrendingAnthologySubscription.unsubscribe();
    mGetTrendingAnthologySubscription=null;
  }
  if (mGetTrendingAnthologyObservable != null) {
    mIsLoading=true;
    mGetTrendingAnthologySubscription=mGetTrendingAnthologyObservable.subscribe(mGetTrendingAnthologyObserver);
  }
}","The original code lacks a loading state indicator, potentially leading to unclear UI behavior during data retrieval. The fixed code introduces `mIsLoading=true`, which signals the start of the data loading process and allows for proper UI state management during the subscription. By explicitly setting the loading flag, the code provides a clear mechanism to track and respond to the ongoing data fetching operation, improving user experience and application responsiveness."
94302,"private static final String truncate(final Object o,final int w){
  final String value=String.valueOf(o);
  return value.length() > w ? value.substring(0,w - 3) + ELLIPSES : value;
}","private static final String truncate(final Object o,final int w){
  final String value=String.valueOf(o);
  return value.length() - ELLIPSES.length() > w ? value.substring(0,w - ELLIPSES.length()) + ELLIPSES : value;
}","The original code incorrectly truncates strings by cutting off characters without accounting for the length of the ELLIPSES, potentially resulting in shorter output than intended. The fixed code adjusts the substring length by subtracting the ELLIPSES length before truncating, ensuring that the total length including the ellipses matches the specified width. This correction guarantees more accurate string truncation, maintaining the desired display width while properly appending the ellipses."
94303,"public static BitSet nonnumeric(final DataFrame<?> df){
  final BitSet nonnumeric=numeric(df);
  nonnumeric.flip(0,nonnumeric.length());
  return nonnumeric;
}","public static BitSet nonnumeric(final DataFrame<?> df){
  final BitSet nonnumeric=numeric(df);
  nonnumeric.flip(0,df.size());
  return nonnumeric;
}","The original code used `nonnumeric.length()` which may not correspond to the actual size of the DataFrame, potentially causing incorrect bit manipulation. The fixed code replaces `nonnumeric.length()` with `df.size()`, ensuring the flip operation matches the DataFrame's actual dimension. This correction guarantees accurate identification of non-numeric columns by properly inverting the numeric column bitset across the precise number of DataFrame elements."
94304,"@Override public void onCreate(){
  super.onCreate();
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  mBinder=new DMBinder();
  if (mManager == null) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"");
    }
    mManager=new DownloadManager(this,""String_Node_Str"");
  }
  Intent i=new Intent();
  i.setAction(Intent.ACTION_MAIN);
  i.setClass(this,MainActivity.class);
  mNotification=new Notification.Builder(this).setContentIntent(PendingIntent.getActivity(this,0,i,0)).setContentTitle(getString(R.string.msg_running)).setContentText(getString(R.string.msg_running_detail)).setLargeIcon(((BitmapDrawable)getDrawable(R.drawable.gigaget)).getBitmap()).setSmallIcon(android.R.drawable.stat_sys_download).build();
  HandlerThread thread=new HandlerThread(""String_Node_Str"");
  thread.start();
  mHandler=new Handler(thread.getLooper()){
    @Override public void handleMessage(    Message msg){
      if (msg.what == 0) {
        int runningCount=0;
        for (int i=0; i < mManager.getCount(); i++) {
          if (mManager.getMission(i).running) {
            runningCount++;
          }
        }
        updateState(runningCount);
      }
    }
  }
;
}","@Override public void onCreate(){
  super.onCreate();
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"");
  }
  mBinder=new DMBinder();
  if (mManager == null) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"");
    }
    mManager=new DownloadManager(this,""String_Node_Str"");
  }
  Intent i=new Intent();
  i.setAction(Intent.ACTION_MAIN);
  i.setClass(this,MainActivity.class);
  mNotification=new Notification.Builder(this).setContentIntent(PendingIntent.getActivity(this,0,i,0)).setContentTitle(getString(R.string.msg_running)).setContentText(getString(R.string.msg_running_detail)).setLargeIcon(((BitmapDrawable)getResources().getDrawable(R.drawable.gigaget)).getBitmap()).setSmallIcon(android.R.drawable.stat_sys_download).build();
  HandlerThread thread=new HandlerThread(""String_Node_Str"");
  thread.start();
  mHandler=new Handler(thread.getLooper()){
    @Override public void handleMessage(    Message msg){
      if (msg.what == 0) {
        int runningCount=0;
        for (int i=0; i < mManager.getCount(); i++) {
          if (mManager.getMission(i).running) {
            runningCount++;
          }
        }
        updateState(runningCount);
      }
    }
  }
;
}","The buggy code uses `getDrawable()` directly, which is deprecated and can cause runtime errors on older Android versions. The fixed code replaces this with `getResources().getDrawable()`, which is the recommended method for retrieving drawable resources across different Android API levels. This change ensures better compatibility and prevents potential crashes when loading the large icon for the notification."
94305,"private int insertMission(DownloadMission mission){
  int i=-1;
  DownloadMission m=null;
  if (mMissions.size() > 0) {
    do {
      m=mMissions.get(++i);
    }
 while (m.timestamp < mission.timestamp && i < mMissions.size() - 1);
    if (i > 0)     i--;
  }
 else {
    i=0;
  }
  mMissions.add(i,mission);
  return i;
}","private int insertMission(DownloadMission mission){
  int i=-1;
  DownloadMission m=null;
  if (mMissions.size() > 0) {
    do {
      m=mMissions.get(++i);
    }
 while (m.timestamp > mission.timestamp && i < mMissions.size() - 1);
  }
 else {
    i=0;
  }
  mMissions.add(i,mission);
  return i;
}","The original code incorrectly used `m.timestamp < mission.timestamp`, which would sort missions in ascending order when the intention was likely descending order. The fixed code changes the comparison to `m.timestamp > mission.timestamp`, ensuring missions are inserted in descending order of timestamp. This correction allows the method to properly insert missions from most recent to oldest, maintaining the intended chronological sorting of download missions."
94306,"private int insertMission(DownloadMission mission){
  int i=-1;
  DownloadMission m=null;
  if (mMissions.size() > 0) {
    do {
      m=mMissions.get(++i);
    }
 while (m.timestamp < mission.timestamp && i < mMissions.size() - 1);
  }
 else {
    i=0;
  }
  mMissions.add(i,mission);
  return i;
}","private int insertMission(DownloadMission mission){
  int i=-1;
  DownloadMission m=null;
  if (mMissions.size() > 0) {
    do {
      m=mMissions.get(++i);
    }
 while (m.timestamp < mission.timestamp && i < mMissions.size() - 1);
    if (i > 0)     i--;
  }
 else {
    i=0;
  }
  mMissions.add(i,mission);
  return i;
}","The original code incorrectly handles inserting a mission when its timestamp is greater than existing missions, potentially inserting at an incorrect index. The fixed code adds an `i--` adjustment when the loop terminates, ensuring the correct insertion point before the first mission with a timestamp greater than or equal to the new mission. This modification guarantees precise chronological ordering and prevents misplacement of download missions in the list."
94307,"private void loadMissions(){
  File f=new File(mLocation);
  if (f.exists() && f.isDirectory()) {
    File[] subs=f.listFiles();
    for (    File sub : subs) {
      if (sub.isDirectory()) {
        continue;
      }
      if (sub.getName().endsWith(""String_Node_Str"")) {
        String str=Utility.readFromFile(sub.getAbsolutePath());
        if (str != null) {
          if (DEBUG) {
            Log.d(TAG,""String_Node_Str"" + sub.getName());
            Log.d(TAG,str);
          }
          DownloadMission mis=new Gson().fromJson(str,DownloadMission.class);
          if (mis.finished) {
            sub.delete();
            continue;
          }
          mis.running=false;
          mis.recovered=true;
          insertMission(mis);
        }
      }
 else       if (!sub.getName().startsWith(""String_Node_Str"")) {
        DownloadMission mis=new DownloadMission();
        mis.length=sub.length();
        mis.done=mis.length;
        mis.finished=true;
        mis.running=false;
        mis.name=sub.getName();
        mis.location=mLocation;
        mis.timestamp=sub.lastModified();
        insertMission(mis);
      }
    }
  }
}","private void loadMissions(){
  File f=new File(mLocation);
  if (f.exists() && f.isDirectory()) {
    File[] subs=f.listFiles();
    for (    File sub : subs) {
      if (sub.isDirectory()) {
        continue;
      }
      if (sub.getName().endsWith(""String_Node_Str"")) {
        String str=Utility.readFromFile(sub.getAbsolutePath());
        if (str != null) {
          if (DEBUG) {
            Log.d(TAG,""String_Node_Str"" + sub.getName());
            Log.d(TAG,str);
          }
          DownloadMission mis=new Gson().fromJson(str,DownloadMission.class);
          if (mis.finished) {
            sub.delete();
            continue;
          }
          mis.running=false;
          mis.recovered=true;
          insertMission(mis);
        }
      }
 else       if (!sub.getName().startsWith(""String_Node_Str"") && !new File(sub.getPath() + ""String_Node_Str"").exists()) {
        DownloadMission mis=new DownloadMission();
        mis.length=sub.length();
        mis.done=mis.length;
        mis.finished=true;
        mis.running=false;
        mis.name=sub.getName();
        mis.location=mLocation;
        mis.timestamp=sub.lastModified();
        insertMission(mis);
      }
    }
  }
}","The original code incorrectly creates a new download mission for files without checking if a corresponding metadata file already exists. The fixed code adds a crucial check `!new File(sub.getPath() + ""String_Node_Str"").exists()` to prevent duplicate mission creation for files that already have metadata. This prevents redundant mission entries and ensures more accurate tracking of download missions by only creating new missions for files without existing metadata."
94308,"/** 
 * Test method: byte[] extractUntil(int offset, char delim)
 * @throws Exception
 */
public void testExtractBytesUntil() throws Exception {
  byte[] buf=sFile.extractBytesUntil(0,(byte)'\n');
  for (int i=0; i < buf.length; i++) {
    assertEquals(fileData.get(i),buf[i]);
    assertFalse(buf[i] == '\n');
  }
  assertEquals(fileData.get(buf.length),'\n');
}","/** 
 * Test method: byte[] extractUntil(int offset, char delim)
 * @throws Exception
 */
public void testExtractBytesUntil() throws Exception {
  String buf=sFile.extractUntil(0,'\n');
  for (int i=0; i < buf.length(); i++) {
    assertEquals(fileData.get(i),buf.charAt(i));
    assertFalse(buf.charAt(i) == '\n');
  }
  assertEquals(fileData.get(buf.length()),'\n');
}","The original code incorrectly used byte[] for extraction, which doesn't handle character-based operations effectively and may lead to potential encoding issues. The fixed code replaces byte[] with a String method extractUntil(), which directly returns a string and allows proper character-level iteration and comparison using charAt(). This approach provides more robust string handling, ensuring accurate character extraction and comparison while maintaining the original test logic of finding characters until a delimiter."
94309,"/** 
 * Test method: long count(byte[] query)
 * @throws Exception
 */
public void testCount() throws Exception {
  for (int i=0; i < numQueryStrings(); i++) {
    String query=getQueryString(i);
    long count=sFile.count(query.toCharArray());
    assertEquals(getQueryStringCount(i),count);
  }
}","/** 
 * Test method: long count(byte[] query)
 * @throws Exception
 */
public void testCount() throws Exception {
  for (int i=0; i < numQueryStrings(); i++) {
    String query=getQueryString(i);
    long count=sFile.count(query.toCharArray());
    long expected=stringCount(getData(),query);
    assertEquals(expected,count);
  }
}","The original code used `getQueryStringCount(i)` as a hardcoded expected value, which might not accurately reflect the actual count of query strings in the dataset. The fixed code introduces `stringCount(getData(), query)` to dynamically calculate the expected count by searching through the data. This change ensures the test method correctly verifies the count method by comparing the result against a computed, accurate expected value."
94310,"/** 
 * Test method: Iterator<Long> searchIterator(byte[] query)
 * @throws Exception
 */
public void testSearchIterator() throws Exception {
  for (int i=0; i < numQueryStrings(); i++) {
    String query=getQueryString(i);
    Iterator<Long> positions=sFile.searchIterator(query.toCharArray());
    long count=0;
    while (positions.hasNext()) {
      long pos=positions.next();
      for (int j=0; j < query.length(); j++) {
        assertEquals(query.charAt(j),fileData.get((int)(pos + j)));
      }
      count++;
    }
    assertEquals(getQueryStringCount(i),count);
  }
}","/** 
 * Test method: Iterator<Long> searchIterator(byte[] query)
 * @throws Exception
 */
public void testSearchIterator() throws Exception {
  for (int i=0; i < numQueryStrings(); i++) {
    String query=getQueryString(i);
    Iterator<Long> positions=sFile.searchIterator(query.toCharArray());
    long count=0;
    while (positions.hasNext()) {
      long pos=positions.next();
      for (int j=0; j < query.length(); j++) {
        assertEquals(query.charAt(j),fileData.get((int)(pos + j)));
      }
      count++;
    }
    assertEquals(stringCount(getData(),query),count);
  }
}","The original code used `getQueryStringCount(i)` to verify the count of query string occurrences, which likely provided an incorrect or hardcoded count. The fixed code replaces this with `stringCount(getData(),query)`, a method that dynamically calculates the actual number of occurrences of the query string in the data. This change ensures accurate verification of search results by computing the true count directly from the file data, making the test more reliable and precise."
94311,"/** 
 * Test method: long[] search(byte[] query)
 * @throws Exception
 */
public void testSearch() throws Exception {
  for (int i=0; i < numQueryStrings(); i++) {
    String query=getQueryString(i);
    Long[] positions=sFile.search(query.toCharArray());
    assertEquals(getQueryStringCount(i),positions.length);
    for (    Long pos : positions) {
      for (int j=0; j < query.length(); j++) {
        assertEquals(query.charAt(j),fileData.get((int)(pos + j)));
      }
    }
  }
}","/** 
 * Test method: long[] search(byte[] query)
 * @throws Exception
 */
public void testSearch() throws Exception {
  for (int i=0; i < numQueryStrings(); i++) {
    String query=getQueryString(i);
    Long[] positions=sFile.search(query.toCharArray());
    assertEquals(stringCount(getData(),query),positions.length);
    for (    Long pos : positions) {
      for (int j=0; j < query.length(); j++) {
        assertEquals(query.charAt(j),fileData.get((int)(pos + j)));
      }
    }
  }
}","The original code incorrectly uses `getQueryStringCount(i)` to validate search result length, which may not accurately reflect the actual number of occurrences in the file. The fixed code replaces this with `stringCount(getData(),query)`, a method that reliably counts actual string occurrences in the file data. This change ensures precise verification of search results by dynamically calculating the correct match count during test execution."
94312,"/** 
 * Test method: Iterator<Integer> recordSearchIdIterator(byte[] query)
 * @throws Exception
 */
public void testRecordSearchIdIterator() throws Exception {
  for (int i=0; i < numQueryStrings(); i++) {
    String query=getQueryString(i);
    Iterator<Integer> recordSearchIds=sIFile.recordSearchIdIterator(query.toCharArray());
    int count=0;
    while (recordSearchIds.hasNext()) {
      Integer recordId=recordSearchIds.next();
      String buf=sIFile.getRecord(recordId);
      assertTrue(buf.contains(query));
      count++;
    }
    assertEquals(getQueryStringCount(i),count);
  }
}","/** 
 * Test method: Iterator<Integer> recordSearchIdIterator(byte[] query)
 * @throws Exception
 */
public void testRecordSearchIdIterator() throws Exception {
  for (int i=0; i < numQueryStrings(); i++) {
    String query=getQueryString(i);
    Iterator<Integer> recordSearchIds=sIFile.recordSearchIdIterator(query.toCharArray());
    int count=0;
    while (recordSearchIds.hasNext()) {
      Integer recordId=recordSearchIds.next();
      String buf=sIFile.getRecord(recordId);
      assertTrue(buf.contains(query));
      count++;
    }
    assertEquals(stringRecordCount(getData(),offsets,query),count);
  }
}","The original code used `getQueryStringCount(i)` as a hardcoded comparison, which might not accurately reflect the actual number of record matches. The fixed code replaces this with `stringRecordCount(getData(),offsets,query)`, a dynamic method that accurately counts the number of records containing the query string. This change ensures a more reliable and flexible test verification by dynamically calculating the expected record count based on the current data and query."
94313,"/** 
 * Test method: Integer[] recordSearchIds(byte[] query)
 * @throws Exception
 */
public void testRecordSearchIds() throws Exception {
  for (int i=0; i < numQueryStrings(); i++) {
    String query=getQueryString(i);
    Integer[] recordSearchIds=sIFile.recordSearchIds(query.toCharArray());
    assertEquals(getQueryStringCount(i),recordSearchIds.length);
    for (    Integer recordId : recordSearchIds) {
      String buf=sIFile.getRecord(recordId);
      assertTrue(buf.contains(query));
    }
  }
}","/** 
 * Test method: Integer[] recordSearchIds(byte[] query)
 * @throws Exception
 */
public void testRecordSearchIds() throws Exception {
  for (int i=0; i < numQueryStrings(); i++) {
    String query=getQueryString(i);
    Integer[] recordSearchIds=sIFile.recordSearchIds(query.toCharArray());
    assertEquals(stringRecordCount(getData(),offsets,query),recordSearchIds.length);
    for (    Integer recordId : recordSearchIds) {
      String buf=sIFile.getRecord(recordId);
      assertTrue(buf.contains(query));
    }
  }
}","The original code used a hardcoded `getQueryStringCount(i)` to validate the search results, which might not accurately reflect the actual number of matching records. The fixed code replaces this with `stringRecordCount(getData(),offsets,query)`, a method that dynamically calculates the correct number of matching records based on the data, offsets, and query. By using a more robust and dynamic counting mechanism, the fixed code ensures accurate verification of search result lengths across different queries and datasets."
94314,"/** 
 * Set up test.
 * @throws Exception
 */
public void setUp() throws Exception {
  super.setUp();
  File inputFile=new File(testFileRaw);
  byte[] fileData=new byte[(int)inputFile.length()];
  DataInputStream dis=new DataInputStream(new FileInputStream(inputFile));
  dis.readFully(fileData);
  SuccinctBuffer sBuf=new SuccinctBuffer(fileData,3);
  sBuf.writeToFile(testFileSuccinct);
  sCore=new SuccinctStream(new Path(testFileSuccinct));
}","/** 
 * Set up test.
 * @throws Exception
 */
public void setUp() throws Exception {
  super.setUp();
  File inputFile=new File(testFileRaw);
  byte[] fileData=new byte[(int)inputFile.length()];
  DataInputStream dis=new DataInputStream(new FileInputStream(inputFile));
  dis.readFully(fileData);
  SuccinctBuffer sBuf=new SuccinctBuffer(fileData);
  sBuf.writeToFile(testFileSuccinct);
  sCore=new SuccinctStream(new Path(testFileSuccinct));
}","The original code incorrectly passed a hardcoded parameter ""3"" to the SuccinctBuffer constructor, which might have been an arbitrary or incorrect configuration. The fixed code removes this unnecessary parameter, using the default constructor that likely handles buffer creation more appropriately. This modification ensures proper buffer initialization and prevents potential issues with incorrect buffer configuration during the file processing and conversion workflow."
94315,"/** 
 * Set up test.
 * @throws Exception
 */
public void setUp() throws Exception {
  super.setUp();
  File inputFile=new File(testFileRaw);
  byte[] fileData=new byte[(int)inputFile.length()];
  DataInputStream dis=new DataInputStream(new FileInputStream(inputFile));
  dis.readFully(fileData);
  sCore=new SuccinctBuffer(fileData,3);
}","/** 
 * Set up test.
 * @throws Exception
 */
public void setUp() throws Exception {
  super.setUp();
  File inputFile=new File(testFileRaw);
  byte[] fileData=new byte[(int)inputFile.length()];
  DataInputStream dis=new DataInputStream(new FileInputStream(inputFile));
  dis.readFully(fileData);
}","The original code incorrectly creates a SuccinctBuffer object (sCore) after reading file data, which appears to be unnecessary and potentially introduces an unused variable. The fixed code removes the line creating the SuccinctBuffer, eliminating the superfluous object instantiation and potential memory overhead. By removing the unnecessary object creation, the code becomes cleaner, more focused, and avoids potential side effects or unintended memory usage."
94316,"/** 
 * Test method: void readObject(ObjectInputStream ois) Test method: void writeObject(ObjectOutputStream oos)
 * @throws Exception
 */
public void testSerializeDeserialize() throws Exception {
  System.out.println(""String_Node_Str"");
  FileOutputStream fOut=new FileOutputStream(testFileSuccinct);
  ObjectOutputStream oos=new ObjectOutputStream(fOut);
  oos.writeObject(sCore);
  oos.close();
  FileInputStream fIn=new FileInputStream(testFileSuccinct);
  ObjectInputStream ois=new ObjectInputStream(fIn);
  SuccinctBuffer sCoreRead=(SuccinctBuffer)ois.readObject();
  ois.close();
  assertNotNull(sCoreRead);
  assertEquals(sCore.getOriginalSize(),sCoreRead.getOriginalSize());
  assertEquals(sCore.getCompressedSize(),sCoreRead.getCompressedSize());
  for (int i=0; i < sCore.getOriginalSize(); i++) {
    assertEquals(sCore.lookupNPA(i),sCoreRead.lookupNPA(i));
    assertEquals(sCore.lookupSA(i),sCoreRead.lookupSA(i));
    assertEquals(sCore.lookupISA(i),sCoreRead.lookupISA(i));
  }
}","/** 
 * Test method: void readObject(ObjectInputStream ois) Test method: void writeObject(ObjectOutputStream oos)
 * @throws Exception
 */
public void testSerializeDeserialize() throws Exception {
  System.out.println(""String_Node_Str"");
  FileOutputStream fOut=new FileOutputStream(testFileSuccinct);
  ObjectOutputStream oos=new ObjectOutputStream(fOut);
  oos.writeObject(sCore);
  oos.close();
  FileInputStream fIn=new FileInputStream(testFileSuccinct);
  ObjectInputStream ois=new ObjectInputStream(fIn);
  SuccinctBuffer sCoreRead=(SuccinctBuffer)ois.readObject();
  ois.close();
  assertNotNull(sCoreRead);
  assertEquals(sCore.getOriginalSize(),sCoreRead.getOriginalSize());
  for (int i=0; i < sCore.getOriginalSize(); i++) {
    assertEquals(sCore.lookupNPA(i),sCoreRead.lookupNPA(i));
    assertEquals(sCore.lookupSA(i),sCoreRead.lookupSA(i));
    assertEquals(sCore.lookupISA(i),sCoreRead.lookupISA(i));
  }
}","The original code unnecessarily compared compressed sizes, which might not always be consistent during serialization and deserialization. The fixed code removes the `assertEquals(sCore.getCompressedSize(),sCoreRead.getCompressedSize())` line, focusing only on verifying the original size and index mappings. By eliminating the potentially unstable compressed size comparison, the test now more robustly validates the core serialization process by checking fundamental structural integrity."
94317,"/** 
 * Performs regular expression search for an input expression using Succinct data-structures.
 * @param query Regular expression pattern to be matched. (UTF-8 encoded)
 * @return All locations and lengths of matching patterns in original input.
 * @throws RegExParsingException
 */
@Override public Map<Long,Integer> regexSearch(String query) throws RegExParsingException {
  RegExParser parser=new RegExParser(new String(query));
  RegEx regEx;
  regEx=parser.parse();
  RegExPlanner planner=new NaiveRegExPlanner(this,regEx);
  RegEx optRegEx=planner.plan();
  RegExExecutor regExExecutor=new RegExExecutor(this,optRegEx);
  regExExecutor.execute();
  Map<Long,Integer> chunkResults=regExExecutor.getFinalResults();
  Map<Long,Integer> results=new TreeMap<Long,Integer>();
  for (  Map.Entry<Long,Integer> result : chunkResults.entrySet()) {
    results.put(result.getKey() + fileOffset,result.getValue());
  }
  return results;
}","/** 
 * Performs regular expression search for an input expression using Succinct data-structures.
 * @param query Regular expression pattern to be matched. (UTF-8 encoded)
 * @return All locations and lengths of matching patterns in original input.
 * @throws RegExParsingException
 */
@Override public Map<Long,Integer> regexSearch(String query) throws RegExParsingException {
  RegExParser parser=new RegExParser(new String(query));
  RegEx regEx;
  regEx=parser.parse();
  RegExPlanner planner=new NaiveRegExPlanner(this,regEx);
  RegEx optRegEx=planner.plan();
  RegExExecutor regExExecutor=new RegExExecutor(this,optRegEx);
  regExExecutor.execute();
  Set<RegexMatch> chunkResults=regExExecutor.getFinalResults();
  Map<Long,Integer> results=new TreeMap<Long,Integer>();
  for (  RegexMatch result : chunkResults) {
    results.put(result.getOffset() + fileOffset,result.getLength());
  }
  return results;
}","The original code incorrectly assumed a `Map<Long,Integer>` return type from `getFinalResults()`, which likely changed to a `Set<RegexMatch>` in the implementation. The fixed code adapts by iterating through `RegexMatch` objects, extracting offset and length directly from each match, and constructing a new results map. This modification ensures type compatibility, preserves search result semantics, and provides a more robust way of processing regex search results by using a dedicated match object."
94318,"/** 
 * Expands character range, i.e., converts abbreviated ranges into full ranges.
 * @param charRange Character range to be expanded.
 * @return The expanded character range.
 */
private String expandCharRange(String charRange){
  String expandedCharRange=""String_Node_Str"";
  for (int i=0; i < charRange.length(); i++) {
    if (charRange.charAt(i) == '-') {
      for (char c=(char)(charRange.charAt(i - 1) + 1); c < charRange.charAt(i + 1); i++) {
        expandedCharRange+=c;
      }
      i++;
    }
    if (charRange.charAt(i) == '\\') {
      i++;
    }
    expandedCharRange+=charRange.charAt(i);
  }
  return expandedCharRange;
}","/** 
 * Expands character range, i.e., converts abbreviated ranges into full ranges.
 * @param charRange Character range to be expanded.
 * @return The expanded character range.
 */
private String expandCharRange(String charRange){
  String expandedCharRange=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + charRange);
  for (int i=0; i < charRange.length(); i++) {
    if (charRange.charAt(i) == '-') {
      char begChar=charRange.charAt(i - 1);
      char endChar=charRange.charAt(i + 1);
      System.out.println(""String_Node_Str"" + begChar + ""String_Node_Str""+ endChar);
      for (char c=(char)(begChar + 1); c < endChar; c++) {
        expandedCharRange+=c;
      }
      i++;
    }
    if (charRange.charAt(i) == '\\') {
      i++;
    }
    expandedCharRange+=charRange.charAt(i);
  }
  return expandedCharRange;
}","The original code had a flawed nested loop with an incorrectly incrementing index, causing potential infinite loops and incorrect character range expansion. The fixed code introduces separate variables `begChar` and `endChar` to clearly define the start and end of character ranges, and adjusts the loop logic to correctly expand ranges. These changes ensure precise character range generation, preventing indexing errors and providing more reliable and predictable character expansion."
94319,"/** 
 * Search for all records that contain a particular regular expression.
 * @param query The regular expression (UTF-8 encoded).
 * @return The records that contain the regular search expression.
 * @throws RegExParsingException
 */
public byte[][] recordSearchRegex(String query) throws RegExParsingException {
  Map<Long,Integer> regexOffsetResults=regexSearch(query);
  Set<Long> offsetResults=new HashSet<Long>();
  ArrayList<byte[]> results=new ArrayList<byte[]>();
  for (  Long offset : regexOffsetResults.keySet()) {
    int offsetIdx=searchOffset(offset);
    long recordOffset=offsets[offsetIdx];
    if (!offsetResults.contains(recordOffset)) {
      results.add(extractUntil(offset.intValue(),RECORD_DELIM));
      offsetResults.add(offset);
    }
  }
  return results.toArray(new byte[results.size()][]);
}","/** 
 * Search for all records that contain a particular regular expression.
 * @param query The regular expression (UTF-8 encoded).
 * @return The records that contain the regular search expression.
 * @throws RegExParsingException
 */
public byte[][] recordSearchRegex(String query) throws RegExParsingException {
  Map<Long,Integer> regexOffsetResults=regexSearch(query);
  Set<Long> offsetResults=new HashSet<Long>();
  ArrayList<byte[]> results=new ArrayList<byte[]>();
  for (  Long offset : regexOffsetResults.keySet()) {
    int offsetIdx=searchOffset(offset);
    long recordOffset=offsets[offsetIdx];
    if (!offsetResults.contains(recordOffset)) {
      results.add(extractUntil((int)recordOffset,RECORD_DELIM));
      offsetResults.add(offset);
    }
  }
  return results.toArray(new byte[results.size()][]);
}","The original code incorrectly used `offset` instead of `recordOffset` when extracting record data, potentially returning incomplete or incorrect records. The fixed code changes `extractUntil(offset.intValue(), RECORD_DELIM)` to `extractUntil((int)recordOffset, RECORD_DELIM)`, ensuring extraction starts from the correct record boundary. This modification guarantees complete and accurate record retrieval by using the precise record start offset."
94320,"/** 
 * Get range of SA positions using Backward search
 * @param buf Input query to be searched.
 * @return Range of indices into the SA.
 */
public Range<Long,Long> getRange(byte[] buf){
  Range<Long,Long> range=new Range<Long,Long>(0L,-1L);
  int m=buf.length;
  long c1, c2;
  if (alphabetMap.containsKey(buf[m - 1])) {
    range.first=alphabetMap.get(buf[m - 1]).first;
    range.second=alphabetMap.get((alphabet.get(alphabetMap.get(buf[m - 1]).second + 1))).first - 1;
  }
 else {
    return range;
  }
  if (range.first > range.second) {
    return range;
  }
  for (int i=m - 2; i >= 0; i--) {
    if (alphabetMap.containsKey(buf[i])) {
      c1=alphabetMap.get(buf[i]).first;
      c2=alphabetMap.get((alphabet.get(alphabetMap.get(buf[i]).second + 1))).first - 1;
    }
 else {
      return range;
    }
    range.first=binSearchNPA(range.first,c1,c2,false);
    range.second=binSearchNPA(range.second,c1,c2,true);
    if (range.first > range.second) {
      return range;
    }
  }
  return range;
}","/** 
 * Get range of SA positions using Backward search
 * @param buf Input query to be searched.
 * @return Range of indices into the SA.
 */
public Range<Long,Long> getRange(byte[] buf){
  Range<Long,Long> range=new Range<Long,Long>(0L,-1L);
  int m=buf.length;
  long c1, c2;
  if (alphabetMap.containsKey(buf[m - 1])) {
    range.first=alphabetMap.get(buf[m - 1]).first;
    range.second=alphabetMap.get((alphabet.get(alphabetMap.get(buf[m - 1]).second + 1))).first - 1;
  }
 else {
    return range;
  }
  for (int i=m - 2; i >= 0; i--) {
    if (alphabetMap.containsKey(buf[i])) {
      c1=alphabetMap.get(buf[i]).first;
      c2=alphabetMap.get((alphabet.get(alphabetMap.get(buf[i]).second + 1))).first - 1;
    }
 else {
      return range;
    }
    range.first=binSearchNPA(range.first,c1,c2,false);
    range.second=binSearchNPA(range.second,c1,c2,true);
  }
  return range;
}","The original code incorrectly added an unnecessary range check after the first iteration, which could prematurely terminate the backward search before processing all characters. The fixed code removes this redundant range validation inside the loop, allowing the full backward search algorithm to complete its iterations consistently. By eliminating the premature exit condition, the fixed implementation ensures a more robust and complete range computation for suffix array searching."
94321,"/** 
 * Search for all records that contain a particular regular expression.
 * @param query The regular expression (UTF-8 encoded).
 * @return The records that contain the regular search expression.
 * @throws RegExParsingException
 */
public byte[][] recordSearchRegex(String query) throws RegExParsingException {
  Map<Long,Integer> regexOffsetResults=regexSearch(query);
  Set<Long> offsetResults=new HashSet<Long>();
  ArrayList<byte[]> results=new ArrayList<byte[]>();
  for (  Long offset : regexOffsetResults.keySet()) {
    int offsetIdx=searchOffset(offset);
    long recordOffset=offsets[offsetIdx];
    if (!offsetResults.contains(recordOffset)) {
      results.add(extractUntil((int)recordOffset,RECORD_DELIM));
      offsetResults.add(offset);
    }
  }
  return results.toArray(new byte[results.size()][]);
}","/** 
 * Search for all records that contain a particular regular expression.
 * @param query The regular expression (UTF-8 encoded).
 * @return The records that contain the regular search expression.
 * @throws RegExParsingException
 */
public byte[][] recordSearchRegex(String query) throws RegExParsingException {
  Map<Long,Integer> regexOffsetResults=regexSearch(query);
  Set<Long> offsetResults=new HashSet<Long>();
  ArrayList<byte[]> results=new ArrayList<byte[]>();
  for (  Long offset : regexOffsetResults.keySet()) {
    int offsetIdx=searchOffset(offset);
    long recordOffset=offsets[offsetIdx];
    if (!offsetResults.contains(recordOffset)) {
      results.add(extractUntil((int)recordOffset,RECORD_DELIM));
      offsetResults.add(recordOffset);
    }
  }
  return results.toArray(new byte[results.size()][]);
}","The original code incorrectly added the search offset to `offsetResults` instead of the record offset, potentially causing duplicate record extractions. In the fixed code, `offsetResults.add(recordOffset)` replaces `offsetResults.add(offset)`, ensuring unique record identification based on their actual record offsets. This modification prevents redundant record extraction and guarantees that each distinct record is added to the results exactly once."
94322,"/** 
 * Get range of SA positions using Backward search
 * @param buf Input query to be searched.
 * @return Range of indices into the SA.
 */
protected Range<Long,Long> getRange(byte[] buf){
  int m=buf.length;
  if (m <= contextLen) {
    return getRangeSlow(buf);
  }
  Range<Long,Long> range=new Range<Long,Long>(0L,-1L);
  int sigma_id;
  long c1, c2;
  int start_off;
  long context_val, context_id;
  if (alphabetMap.containsKey(buf[m - contextLen - 1])) {
    sigma_id=alphabetMap.get(buf[m - contextLen - 1]).second;
    context_val=computeContextVal(buf,m - contextLen);
    if (context_val == -1) {
      return range;
    }
    if (!contextMap.containsKey(context_val)) {
      return range;
    }
    context_id=contextMap.get(context_val);
    start_off=SerializedOperations.ArrayOps.getRank1(neccol,coff.get(sigma_id),colsizes.get(sigma_id),context_id) - 1;
    range.first=coloffsets.get(sigma_id) + celloffsets.get(coff.get(sigma_id) + start_off);
    if (start_off + 1 < colsizes.get(sigma_id)) {
      range.second=coloffsets.get(sigma_id) + celloffsets.get(coff.get(sigma_id) + start_off + 1) - 1;
    }
 else     if (sigma_id + 1 < sigmaSize) {
      range.second=coloffsets.get(sigma_id + 1) - 1;
    }
 else {
      range.second=Long.valueOf(getOriginalSize() - 1);
    }
  }
 else {
    return range;
  }
  if (range.first > range.second) {
    return range;
  }
  for (int i=m - contextLen - 2; i >= 0; i--) {
    if (alphabetMap.containsKey(buf[i])) {
      sigma_id=alphabetMap.get(buf[i]).second;
      context_val=computeContextVal(buf,i + 1);
      if (context_val == -1) {
        return range;
      }
      if (!contextMap.containsKey(context_val)) {
        return range;
      }
      context_id=contextMap.get(context_val);
      start_off=SerializedOperations.ArrayOps.getRank1(neccol,coff.get(sigma_id),colsizes.get(sigma_id),context_id) - 1;
      c1=coloffsets.get(sigma_id) + celloffsets.get(coff.get(sigma_id) + start_off);
      if (start_off + 1 < colsizes.get(sigma_id)) {
        c2=coloffsets.get(sigma_id) + celloffsets.get(coff.get(sigma_id) + start_off + 1) - 1;
      }
 else       if (sigma_id + 1 < sigmaSize) {
        c2=coloffsets.get(sigma_id + 1) - 1;
      }
 else {
        c2=getOriginalSize() - 1;
      }
    }
 else {
      return range;
    }
    range.first=binSearchNPA(range.first,c1,c2,false);
    range.second=binSearchNPA(range.second,c1,c2,true);
    if (range.first > range.second) {
      return range;
    }
  }
  return range;
}","/** 
 * Get range of SA positions using Backward search
 * @param buf Input query to be searched.
 * @return Range of indices into the SA.
 */
public Range<Long,Long> getRange(byte[] buf){
  Range<Long,Long> range=new Range<Long,Long>(0L,-1L);
  int m=buf.length;
  long c1, c2;
  if (alphabetMap.containsKey(buf[m - 1])) {
    range.first=alphabetMap.get(buf[m - 1]).first;
    range.second=alphabetMap.get((alphabet.get(alphabetMap.get(buf[m - 1]).second + 1))).first - 1;
  }
 else {
    return range;
  }
  if (range.first > range.second) {
    return range;
  }
  for (int i=m - 2; i >= 0; i--) {
    if (alphabetMap.containsKey(buf[i])) {
      c1=alphabetMap.get(buf[i]).first;
      c2=alphabetMap.get((alphabet.get(alphabetMap.get(buf[i]).second + 1))).first - 1;
    }
 else {
      return range;
    }
    range.first=binSearchNPA(range.first,c1,c2,false);
    range.second=binSearchNPA(range.second,c1,c2,true);
    if (range.first > range.second) {
      return range;
    }
  }
  return range;
}","The original code's complex context-based search mechanism with multiple nested conditions and special handling made it error-prone and difficult to understand. The fixed code simplifies the backward search by directly using alphabet mapping and boundary calculations, leveraging a more straightforward range computation based on character positions in the alphabet. This streamlined approach reduces complexity, improves readability, and provides a more robust and efficient implementation of the range search algorithm."
94323,"public PinEntryView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray array=getContext().obtainStyledAttributes(attrs,R.styleable.PinEntryView);
  mDigits=array.getInt(R.styleable.PinEntryView_numDigits,4);
  mAccentType=array.getInt(R.styleable.PinEntryView_accentType,ACCENT_NONE);
  DisplayMetrics metrics=getResources().getDisplayMetrics();
  mDigitWidth=array.getDimensionPixelSize(R.styleable.PinEntryView_digitWidth,(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,50,metrics));
  mDigitHeight=array.getDimensionPixelSize(R.styleable.PinEntryView_digitHeight,(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,50,metrics));
  mDigitSpacing=array.getDimensionPixelSize(R.styleable.PinEntryView_digitSpacing,(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,20,metrics));
  mDigitTextSize=array.getDimensionPixelSize(R.styleable.PinEntryView_digitTextSize,(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,15,metrics));
  mAccentWidth=array.getDimensionPixelSize(R.styleable.PinEntryView_accentWidth,(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,3,metrics));
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    mDigitElevation=array.getDimensionPixelSize(R.styleable.PinEntryView_digitElevation,0);
  }
  Resources.Theme theme=getContext().getTheme();
  TypedValue background=new TypedValue();
  theme.resolveAttribute(android.R.attr.windowBackground,background,true);
  mDigitBackground=array.getResourceId(R.styleable.PinEntryView_digitBackground,background.resourceId);
  TypedValue textColor=new TypedValue();
  theme.resolveAttribute(android.R.attr.textColorPrimary,textColor,true);
  mDigitTextColor=array.getColor(R.styleable.PinEntryView_digitTextColor,textColor.resourceId > 0 ? getResources().getColor(textColor.resourceId) : textColor.data);
  TypedValue accentColor=new TypedValue();
  theme.resolveAttribute(R.attr.colorAccent,accentColor,true);
  mAccentColor=array.getColor(R.styleable.PinEntryView_accentColor,accentColor.resourceId > 0 ? getResources().getColor(accentColor.resourceId) : accentColor.data);
  String maskCharacter=array.getString(R.styleable.PinEntryView_mask);
  if (maskCharacter != null) {
    mMask=maskCharacter;
  }
  addViews();
}","public PinEntryView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray array=getContext().obtainStyledAttributes(attrs,R.styleable.PinEntryView);
  mDigits=array.getInt(R.styleable.PinEntryView_numDigits,4);
  mAccentType=array.getInt(R.styleable.PinEntryView_accentType,ACCENT_NONE);
  DisplayMetrics metrics=getResources().getDisplayMetrics();
  mDigitWidth=array.getDimensionPixelSize(R.styleable.PinEntryView_digitWidth,(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,50,metrics));
  mDigitHeight=array.getDimensionPixelSize(R.styleable.PinEntryView_digitHeight,(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,50,metrics));
  mDigitSpacing=array.getDimensionPixelSize(R.styleable.PinEntryView_digitSpacing,(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,20,metrics));
  mDigitTextSize=array.getDimensionPixelSize(R.styleable.PinEntryView_digitTextSize,(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,15,metrics));
  mAccentWidth=array.getDimensionPixelSize(R.styleable.PinEntryView_accentWidth,(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,3,metrics));
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    mDigitElevation=array.getDimensionPixelSize(R.styleable.PinEntryView_digitElevation,0);
  }
  Resources.Theme theme=getContext().getTheme();
  TypedValue background=new TypedValue();
  theme.resolveAttribute(android.R.attr.windowBackground,background,true);
  mDigitBackground=array.getResourceId(R.styleable.PinEntryView_digitBackground,background.resourceId);
  TypedValue textColor=new TypedValue();
  theme.resolveAttribute(android.R.attr.textColorPrimary,textColor,true);
  mDigitTextColor=array.getColor(R.styleable.PinEntryView_digitTextColor,textColor.resourceId > 0 ? getResources().getColor(textColor.resourceId) : textColor.data);
  TypedValue accentColor=new TypedValue();
  theme.resolveAttribute(R.attr.colorAccent,accentColor,true);
  mAccentColor=array.getColor(R.styleable.PinEntryView_accentColor,accentColor.resourceId > 0 ? getResources().getColor(accentColor.resourceId) : accentColor.data);
  String maskCharacter=array.getString(R.styleable.PinEntryView_mask);
  if (maskCharacter != null) {
    mMask=maskCharacter;
  }
  array.recycle();
  addViews();
}","The original code fails to recycle the TypedArray after use, which can lead to resource leaks and potential performance issues. The fixed code adds `array.recycle()` before `addViews()`, properly releasing the system resources associated with the TypedArray. This ensures efficient memory management and prevents potential memory-related problems in Android application development."
94324,"/** 
 * Create views and add them to the view group
 */
private void addViews(){
  for (int i=0; i < mDigits; i++) {
    DigitView digitView=new DigitView(getContext());
    digitView.setWidth(mDigitWidth);
    digitView.setHeight(mDigitHeight);
    digitView.setBackgroundResource(mDigitBackground);
    digitView.setTextColor(mDigitTextColor);
    digitView.setTextSize(mDigitTextSize);
    digitView.setGravity(Gravity.CENTER);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      digitView.setElevation(mDigitElevation);
    }
    addView(digitView);
  }
  mEditText=new EditText(getContext());
  mEditText.setBackgroundColor(getResources().getColor(android.R.color.transparent));
  mEditText.setTextColor(getResources().getColor(android.R.color.transparent));
  mEditText.setCursorVisible(false);
  mEditText.setFilters(new InputFilter[]{new InputFilter.LengthFilter(mDigits)});
  mEditText.setInputType(InputType.TYPE_CLASS_NUMBER);
  mEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
  mEditText.setOnFocusChangeListener(new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      int length=mEditText.getText().length();
      for (int i=0; i < mDigits; i++) {
        getChildAt(i).setSelected(hasFocus && (mAccentType == ACCENT_ALL || (mAccentType == ACCENT_CHARACTER && (i == length || (i == mDigits - 1 && length == mDigits)))));
      }
      mEditText.setSelection(length);
      if (mOnFocusChangeListener != null) {
        mOnFocusChangeListener.onFocusChange(PinEntryView.this,hasFocus);
      }
    }
  }
);
  mEditText.addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      int length=s.length();
      for (int i=0; i < mDigits; i++) {
        if (s.length() > i) {
          String mask=mMask == null || mMask.length() == 0 ? String.valueOf(s.charAt(i)) : mMask;
          ((TextView)getChildAt(i)).setText(mask);
        }
 else {
          ((TextView)getChildAt(i)).setText(""String_Node_Str"");
        }
        if (mEditText.hasFocus()) {
          getChildAt(i).setSelected(mAccentType == ACCENT_ALL || (mAccentType == ACCENT_CHARACTER && (i == length || (i == mDigits - 1 && length == mDigits))));
        }
      }
    }
  }
);
  addView(mEditText);
}","/** 
 * Create views and add them to the view group
 */
@TargetApi(21) private void addViews(){
  for (int i=0; i < mDigits; i++) {
    DigitView digitView=new DigitView(getContext());
    digitView.setWidth(mDigitWidth);
    digitView.setHeight(mDigitHeight);
    digitView.setBackgroundResource(mDigitBackground);
    digitView.setTextColor(mDigitTextColor);
    digitView.setTextSize(mDigitTextSize);
    digitView.setGravity(Gravity.CENTER);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      digitView.setElevation(mDigitElevation);
    }
    addView(digitView);
  }
  mEditText=new EditText(getContext());
  mEditText.setBackgroundColor(getResources().getColor(android.R.color.transparent));
  mEditText.setTextColor(getResources().getColor(android.R.color.transparent));
  mEditText.setCursorVisible(false);
  mEditText.setFilters(new InputFilter[]{new InputFilter.LengthFilter(mDigits)});
  mEditText.setInputType(InputType.TYPE_CLASS_NUMBER);
  mEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
  mEditText.setOnFocusChangeListener(new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      int length=mEditText.getText().length();
      for (int i=0; i < mDigits; i++) {
        getChildAt(i).setSelected(hasFocus && (mAccentType == ACCENT_ALL || (mAccentType == ACCENT_CHARACTER && (i == length || (i == mDigits - 1 && length == mDigits)))));
      }
      mEditText.setSelection(length);
      if (mOnFocusChangeListener != null) {
        mOnFocusChangeListener.onFocusChange(PinEntryView.this,hasFocus);
      }
    }
  }
);
  mEditText.addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      int length=s.length();
      for (int i=0; i < mDigits; i++) {
        if (s.length() > i) {
          String mask=mMask == null || mMask.length() == 0 ? String.valueOf(s.charAt(i)) : mMask;
          ((TextView)getChildAt(i)).setText(mask);
        }
 else {
          ((TextView)getChildAt(i)).setText(""String_Node_Str"");
        }
        if (mEditText.hasFocus()) {
          getChildAt(i).setSelected(mAccentType == ACCENT_ALL || (mAccentType == ACCENT_CHARACTER && (i == length || (i == mDigits - 1 && length == mDigits))));
        }
      }
    }
  }
);
  addView(mEditText);
}","The original code lacked the @TargetApi(21) annotation, which is necessary for using Lollipop-specific API calls like setElevation() on older Android versions. The fixed code adds the @TargetApi(21) annotation to the method, explicitly indicating compatibility with Android 5.0 and allowing safe usage of elevation-related methods. This modification ensures better version compatibility and prevents potential runtime exceptions when running on devices with different Android API levels."
94325,"/** 
 * Create views and add them to the view group
 */
private void addViews(){
  for (int i=0; i < digits; i++) {
    DigitView digitView=new DigitView(getContext());
    digitView.setWidth(digitWidth);
    digitView.setHeight(digitHeight);
    digitView.setBackgroundResource(digitBackground);
    digitView.setTextColor(digitTextColor);
    digitView.setTextSize(digitTextSize);
    digitView.setGravity(Gravity.CENTER);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      digitView.setElevation(digitElevation);
    }
    addView(digitView);
  }
  editText=new EditText(getContext());
  editText.setBackgroundColor(getResources().getColor(android.R.color.transparent));
  editText.setTextColor(getResources().getColor(android.R.color.transparent));
  editText.setCursorVisible(false);
  editText.setFilters(new InputFilter[]{new InputFilter.LengthFilter(digits)});
  editText.setInputType(inputType);
  editText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
  editText.setOnFocusChangeListener(new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      int length=editText.getText().length();
      for (int i=0; i < digits; i++) {
        getChildAt(i).setSelected(hasFocus && (accentType == ACCENT_ALL || (accentType == ACCENT_CHARACTER && (i == length || (i == digits - 1 && length == digits)))));
      }
      editText.setSelection(length);
      if (onFocusChangeListener != null) {
        onFocusChangeListener.onFocusChange(PinEntryView.this,hasFocus);
      }
    }
  }
);
  editText.addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      int length=s.length();
      for (int i=0; i < digits; i++) {
        if (s.length() > i) {
          String mask=PinEntryView.this.mask == null || PinEntryView.this.mask.length() == 0 ? String.valueOf(s.charAt(i)) : PinEntryView.this.mask;
          ((TextView)getChildAt(i)).setText(mask);
        }
 else {
          ((TextView)getChildAt(i)).setText(""String_Node_Str"");
        }
        if (editText.hasFocus()) {
          getChildAt(i).setSelected(accentType == ACCENT_ALL || (accentType == ACCENT_CHARACTER && (i == length || (i == digits - 1 && length == digits))));
        }
      }
      if (length == digits && onPinEnteredListener != null) {
        onPinEnteredListener.onPinEntered(s.toString());
      }
    }
  }
);
  addView(editText);
}","/** 
 * Create views and add them to the view group
 */
private void addViews(){
  for (int i=0; i < digits; i++) {
    DigitView digitView=new DigitView(getContext());
    digitView.setWidth(digitWidth);
    digitView.setHeight(digitHeight);
    digitView.setBackgroundResource(digitBackground);
    digitView.setTextColor(digitTextColor);
    digitView.setTextSize(TypedValue.COMPLEX_UNIT_PX,digitTextSize);
    digitView.setGravity(Gravity.CENTER);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      digitView.setElevation(digitElevation);
    }
    addView(digitView);
  }
  editText=new EditText(getContext());
  editText.setBackgroundColor(getResources().getColor(android.R.color.transparent));
  editText.setTextColor(getResources().getColor(android.R.color.transparent));
  editText.setCursorVisible(false);
  editText.setFilters(new InputFilter[]{new InputFilter.LengthFilter(digits)});
  editText.setInputType(inputType);
  editText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
  editText.setOnFocusChangeListener(new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      int length=editText.getText().length();
      for (int i=0; i < digits; i++) {
        getChildAt(i).setSelected(hasFocus && (accentType == ACCENT_ALL || (accentType == ACCENT_CHARACTER && (i == length || (i == digits - 1 && length == digits)))));
      }
      editText.setSelection(length);
      if (onFocusChangeListener != null) {
        onFocusChangeListener.onFocusChange(PinEntryView.this,hasFocus);
      }
    }
  }
);
  editText.addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      int length=s.length();
      for (int i=0; i < digits; i++) {
        if (s.length() > i) {
          String mask=PinEntryView.this.mask == null || PinEntryView.this.mask.length() == 0 ? String.valueOf(s.charAt(i)) : PinEntryView.this.mask;
          ((TextView)getChildAt(i)).setText(mask);
        }
 else {
          ((TextView)getChildAt(i)).setText(""String_Node_Str"");
        }
        if (editText.hasFocus()) {
          getChildAt(i).setSelected(accentType == ACCENT_ALL || (accentType == ACCENT_CHARACTER && (i == length || (i == digits - 1 && length == digits))));
        }
      }
      if (length == digits && onPinEnteredListener != null) {
        onPinEnteredListener.onPinEntered(s.toString());
      }
    }
  }
);
  addView(editText);
}","The original code used `setTextSize()` without specifying the unit, which could lead to inconsistent text sizing across different devices and Android versions. In the fixed code, `setTextSize(TypedValue.COMPLEX_UNIT_PX, digitTextSize)` explicitly sets the text size in pixels, ensuring consistent rendering. This change provides more predictable and precise text sizing for the digit views, improving the visual consistency of the PIN entry interface."
94326,"public void onClick(View v){
  if (whitelist.isChecked()) {
    if (white_me.isChecked()) {
      if (wlan.getText().toString() == ""String_Node_Str"") {
        exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
      }
 else {
        exe.RunAsRootOutput(""String_Node_Str"");
        exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
      }
    }
 else {
      if (wlan.getText().toString() == ""String_Node_Str"") {
        exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
      }
 else {
        exe.RunAsRootOutput(""String_Node_Str"");
        exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
      }
    }
  }
 else {
    white_me.setChecked(false);
  }
}","public void onClick(View v){
  if (whitelist.isChecked()) {
    if (white_me.isChecked()) {
      if (wlan.getText().toString() == ""String_Node_Str"") {
        exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
      }
 else {
        exe.RunAsRootOutput(""String_Node_Str"" + getmac(""String_Node_Str"") + ""String_Node_Str"");
        exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
      }
    }
 else {
      if (wlan.getText().toString() == ""String_Node_Str"") {
        exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
      }
 else {
        exe.RunAsRootOutput(""String_Node_Str"");
        exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
      }
    }
  }
 else {
    white_me.setChecked(false);
  }
}","The original code had redundant and potentially incorrect conditional logic when handling MAC address retrieval and command execution. In the fixed version, a key change is adding `getmac(""String_Node_Str"")` when the WLAN text is not ""String_Node_Str"", ensuring a consistent MAC address retrieval approach. This modification simplifies the code, reduces potential runtime errors, and provides more predictable behavior by standardizing the command execution process across different conditions."
94327,"public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  final View rootView=inflater.inflate(R.layout.deauth,container,false);
  SharedPreferences sharedpreferences=getActivity().getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE);
  Context mContext=getActivity().getApplicationContext();
  setHasOptionsMenu(true);
  final Button scan=(Button)rootView.findViewById(R.id.scan_networks);
  final EditText wlan=(EditText)rootView.findViewById(R.id.wlan_interface);
  final EditText term=(EditText)rootView.findViewById(R.id.TerminalOutputDeAuth);
  final Button start=(Button)rootView.findViewById(R.id.StartDeAuth);
  final EditText pkt=(EditText)rootView.findViewById(R.id.time);
  final EditText channel=(EditText)rootView.findViewById(R.id.channel);
  final CheckBox whitelist=(CheckBox)rootView.findViewById(R.id.deauth_whitelist);
  final CheckBox white_me=(CheckBox)rootView.findViewById(R.id.deauth_me);
  whitelist.setChecked(false);
  start.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      String whitelist_command;
      new BootKali(""String_Node_Str"" + wlan.getText() + ""String_Node_Str"");
      try {
        Thread.sleep(1000);
        new BootKali(""String_Node_Str"" + wlan.getText()).run_bg();
        Thread.sleep(2000);
        if (whitelist.isChecked()) {
          whitelist_command=""String_Node_Str"";
        }
 else {
          whitelist_command=""String_Node_Str"";
        }
        intentClickListener_NH(""String_Node_Str"" + wlan.getText() + ""String_Node_Str""+ whitelist_command+ ""String_Node_Str""+ channel.getText());
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
);
  scan.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      new BootKali(""String_Node_Str"").run_bg();
      String cmd=""String_Node_Str"" + wlan.getText() + ""String_Node_Str"";
      try {
        new BootKali(""String_Node_Str"" + wlan.getText() + ""String_Node_Str"").run_bg();
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      new BootKali(cmd).run_bg();
      try {
        Thread.sleep(5000);
        nh=new NhPaths();
        String output=exe.RunAsRootOutput(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
        term.setText(output);
      }
 catch (      Exception e) {
        e.printStackTrace();
        term.setText(e.toString());
      }
    }
  }
);
  whitelist.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      if (whitelist.isChecked()) {
        white_me.setClickable(true);
        String check_me=exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
        if (check_me.contains(""String_Node_Str"")) {
          white_me.setChecked(true);
        }
 else {
          white_me.setChecked(false);
        }
      }
 else {
        white_me.setChecked(false);
        white_me.setClickable(false);
      }
    }
  }
);
  white_me.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      if (whitelist.isChecked()) {
        if (white_me.isChecked()) {
          if (wlan.getText().toString() == ""String_Node_Str"") {
            exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
          }
 else {
            exe.RunAsRootOutput(""String_Node_Str"");
            exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
          }
        }
 else {
          if (wlan.getText().toString() == ""String_Node_Str"") {
            exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
          }
 else {
            exe.RunAsRootOutput(""String_Node_Str"");
            exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
          }
        }
      }
 else {
        white_me.setChecked(false);
      }
    }
  }
);
  return rootView;
}","public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  final View rootView=inflater.inflate(R.layout.deauth,container,false);
  SharedPreferences sharedpreferences=getActivity().getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE);
  Context mContext=getActivity().getApplicationContext();
  setHasOptionsMenu(true);
  final Button scan=(Button)rootView.findViewById(R.id.scan_networks);
  final EditText wlan=(EditText)rootView.findViewById(R.id.wlan_interface);
  final EditText term=(EditText)rootView.findViewById(R.id.TerminalOutputDeAuth);
  final Button start=(Button)rootView.findViewById(R.id.StartDeAuth);
  final EditText pkt=(EditText)rootView.findViewById(R.id.time);
  final EditText channel=(EditText)rootView.findViewById(R.id.channel);
  final CheckBox whitelist=(CheckBox)rootView.findViewById(R.id.deauth_whitelist);
  final CheckBox white_me=(CheckBox)rootView.findViewById(R.id.deauth_me);
  whitelist.setChecked(false);
  start.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      String whitelist_command;
      new BootKali(""String_Node_Str"" + wlan.getText() + ""String_Node_Str"");
      try {
        Thread.sleep(1000);
        new BootKali(""String_Node_Str"" + wlan.getText()).run_bg();
        Thread.sleep(2000);
        if (whitelist.isChecked()) {
          whitelist_command=""String_Node_Str"";
        }
 else {
          whitelist_command=""String_Node_Str"";
        }
        intentClickListener_NH(""String_Node_Str"" + wlan.getText() + ""String_Node_Str""+ whitelist_command+ ""String_Node_Str""+ channel.getText());
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
);
  scan.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      new BootKali(""String_Node_Str"").run_bg();
      String cmd=""String_Node_Str"" + wlan.getText() + ""String_Node_Str"";
      try {
        new BootKali(""String_Node_Str"" + wlan.getText() + ""String_Node_Str"").run_bg();
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      new BootKali(cmd).run_bg();
      try {
        Thread.sleep(5000);
        nh=new NhPaths();
        String output=exe.RunAsRootOutput(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
        term.setText(output);
      }
 catch (      Exception e) {
        e.printStackTrace();
        term.setText(e.toString());
      }
    }
  }
);
  whitelist.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      if (whitelist.isChecked()) {
        white_me.setClickable(true);
        String check_me=exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
        if (check_me.contains(""String_Node_Str"")) {
          white_me.setChecked(true);
        }
 else {
          white_me.setChecked(false);
        }
      }
 else {
        white_me.setChecked(false);
        white_me.setClickable(false);
      }
    }
  }
);
  white_me.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      if (whitelist.isChecked()) {
        if (white_me.isChecked()) {
          if (wlan.getText().toString() == ""String_Node_Str"") {
            exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
          }
 else {
            exe.RunAsRootOutput(""String_Node_Str"" + getmac(""String_Node_Str"") + ""String_Node_Str"");
            exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
          }
        }
 else {
          if (wlan.getText().toString() == ""String_Node_Str"") {
            exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
          }
 else {
            exe.RunAsRootOutput(""String_Node_Str"");
            exe.RunAsRootOutput(""String_Node_Str"" + getmac(wlan.getText().toString()) + ""String_Node_Str"");
          }
        }
      }
 else {
        white_me.setChecked(false);
      }
    }
  }
);
  return rootView;
}","The original code had a potential null pointer issue when comparing wlan text with a hardcoded string using `==` instead of `.equals()`. In the fixed code, the second branch of the `white_me` click listener now correctly uses `getmac(""String_Node_Str"")` instead of an implicit null comparison. The modification ensures more robust string handling and prevents potential runtime exceptions by using a more reliable string comparison and MAC address retrieval method."
94328,"public void openLanguageDialog(){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  builder.setTitle(""String_Node_Str"");
  builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
);
  builder.setSingleChoiceItems(languages,selectedLanguageIndex,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      selectedLanguageIndex=which;
    }
  }
);
  builder.show();
}","public void openLanguageDialog(){
  int keyboardLayoutIndex=sharedpreferences.getInt(""String_Node_Str"",0);
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  builder.setTitle(""String_Node_Str"");
  builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
);
  builder.setSingleChoiceItems(languages,keyboardLayoutIndex,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      Editor editor=sharedpreferences.edit();
      editor.putInt(""String_Node_Str"",which);
      editor.commit();
    }
  }
);
  builder.show();
}","The original code lacks a mechanism to persist the selected language index across dialog interactions, causing the selection to reset each time. The fixed code introduces SharedPreferences to store and retrieve the selected language index, with the `sharedpreferences.getInt()` method initializing the dialog's selected item and `editor.putInt()` saving the user's choice. This modification ensures that the selected language is remembered between dialog opens, providing a more consistent and user-friendly experience."
94329,"private void start(){
  String lang;
switch (selectedLanguageIndex) {
case 1:
    lang=""String_Node_Str"";
  break;
case 2:
lang=""String_Node_Str"";
break;
case 3:
lang=""String_Node_Str"";
break;
case 4:
lang=""String_Node_Str"";
break;
case 5:
lang=""String_Node_Str"";
break;
case 6:
lang=""String_Node_Str"";
break;
case 7:
lang=""String_Node_Str"";
break;
case 8:
lang=""String_Node_Str"";
break;
case 9:
lang=""String_Node_Str"";
break;
case 10:
lang=""String_Node_Str"";
break;
case 11:
lang=""String_Node_Str"";
break;
default :
lang=""String_Node_Str"";
break;
}
String[] command=new String[1];
int pageNum=mViewPager.getCurrentItem();
if (pageNum == 0) {
switch (selectedPlatformIndex) {
case 0:
command[0]=""String_Node_Str"" + lang;
break;
case 1:
command[0]=""String_Node_Str"" + lang;
break;
default :
command[0]=""String_Node_Str"" + lang;
break;
}
}
 else if (pageNum == 1) {
switch (selectedPlatformIndex) {
case 0:
command[0]=""String_Node_Str"" + lang;
break;
case 1:
command[0]=""String_Node_Str"" + lang;
break;
default :
command[0]=""String_Node_Str"" + lang;
break;
}
}
ShellExecuter exe=new ShellExecuter();
exe.RunAsRoot(command);
((AppNavHomeActivity)getActivity()).showMessage(""String_Node_Str"");
}","private void start(){
  int keyboardLayoutIndex=sharedpreferences.getInt(""String_Node_Str"",0);
  String lang;
switch (keyboardLayoutIndex) {
case 1:
    lang=""String_Node_Str"";
  break;
case 2:
lang=""String_Node_Str"";
break;
case 3:
lang=""String_Node_Str"";
break;
case 4:
lang=""String_Node_Str"";
break;
case 5:
lang=""String_Node_Str"";
break;
case 6:
lang=""String_Node_Str"";
break;
case 7:
lang=""String_Node_Str"";
break;
case 8:
lang=""String_Node_Str"";
break;
case 9:
lang=""String_Node_Str"";
break;
case 10:
lang=""String_Node_Str"";
break;
case 11:
lang=""String_Node_Str"";
break;
default :
lang=""String_Node_Str"";
break;
}
int UACBypassIndex=sharedpreferences.getInt(""String_Node_Str"",0);
String[] command=new String[1];
int pageNum=mViewPager.getCurrentItem();
if (pageNum == 0) {
switch (UACBypassIndex) {
case 0:
command[0]=""String_Node_Str"" + lang;
break;
case 1:
command[0]=""String_Node_Str"" + lang;
break;
default :
command[0]=""String_Node_Str"" + lang;
break;
}
}
 else if (pageNum == 1) {
switch (UACBypassIndex) {
case 0:
command[0]=""String_Node_Str"" + lang;
break;
case 1:
command[0]=""String_Node_Str"" + lang;
break;
default :
command[0]=""String_Node_Str"" + lang;
break;
}
}
ShellExecuter exe=new ShellExecuter();
exe.RunAsRoot(command);
((AppNavHomeActivity)getActivity()).showMessage(""String_Node_Str"");
}","The original code used a hardcoded `selectedLanguageIndex` and `selectedPlatformIndex` without clear context or dynamic configuration. The fixed code introduces `sharedpreferences` to retrieve dynamic indexes for keyboard layout and UAC bypass, allowing more flexible and configurable runtime behavior. By using shared preferences, the code becomes more adaptable, enabling runtime configuration changes without modifying the core logic."
94330,"public void openDialog(){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  builder.setTitle(""String_Node_Str"");
  builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
);
  builder.setSingleChoiceItems(platforms,selectedPlatformIndex,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      selectedPlatformIndex=which;
    }
  }
);
  builder.show();
}","public void openDialog(){
  int UACBypassIndex=sharedpreferences.getInt(""String_Node_Str"",0);
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  builder.setTitle(""String_Node_Str"");
  builder.setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
);
  builder.setSingleChoiceItems(platforms,UACBypassIndex,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      Editor editor=sharedpreferences.edit();
      editor.putInt(""String_Node_Str"",which);
      editor.commit();
    }
  }
);
  builder.show();
}","The original code used a hardcoded index for single choice dialog selection, which failed to persist user preferences across dialog interactions. The fixed code introduces shared preferences to retrieve and save the selected index, allowing the dialog to remember the previously chosen option. By utilizing SharedPreferences, the code now maintains state and provides a more persistent user experience when selecting platform options."
94331,"private static boolean isAllowed(List<Object> source,List<Object> destination){
  boolean isSame=source.equals(destination);
  int i=0;
  int j=0;
  while (i < source.size() && j < destination.size()) {
    Object srcValue=source.get(i);
    Object dstValue=destination.get(j);
    if (isInteger(srcValue.toString()) && isInteger(dstValue.toString())) {
      Integer srcInt=Integer.parseInt(srcValue.toString());
      Integer dstInt=Integer.parseInt(dstValue.toString());
      if (srcInt > dstInt) {
        return false;
      }
    }
    i++;
    j++;
  }
  return !isSame;
}","private static boolean isAllowed(List<Object> source,List<Object> destination){
  boolean isSame=source.equals(destination);
  int i=0;
  int j=0;
  while (i < source.size() && j < destination.size()) {
    Object srcValue=source.get(i);
    Object dstValue=destination.get(j);
    String srcStr=srcValue.toString();
    String dstStr=dstValue.toString();
    if (isNumber(srcStr) && isNumber(dstStr)) {
      if (srcStr.compareTo(dstStr) > 0) {
        return false;
      }
    }
    i++;
    j++;
  }
  return !isSame;
}","The original code incorrectly parses integer values from toString() and uses Integer.parseInt(), which can fail for non-numeric strings and cause potential runtime exceptions. The fixed code uses string comparison (compareTo()) and a more robust isNumber() check, ensuring safe and flexible numeric comparison across different string representations. This approach provides a more resilient method for comparing list elements, handling various input types without throwing unexpected parsing errors."
94332,"private void testError() throws JsonProcessingException, ClassNotFoundException {
  JsonNode node=p.getNode();
  JsonNode first=node.get(""String_Node_Str"");
  JsonNode patch=node.get(""String_Node_Str"");
  JsonNode message=node.get(""String_Node_Str"");
  Class<?> type=node.has(""String_Node_Str"") ? exceptionType(node.get(""String_Node_Str"").textValue()) : JsonPatchApplicationException.class;
  try {
    JsonPatch.apply(patch,first);
    fail(errorMessage(""String_Node_Str"" + message));
  }
 catch (  Exception e) {
    assertThat(errorMessage(""String_Node_Str""),e,instanceOf(type));
    if (message != null) {
      assertThat(errorMessage(""String_Node_Str""),e.getMessage(),containsString(message.textValue()));
    }
  }
}","private void testError() throws JsonProcessingException, ClassNotFoundException {
  JsonNode node=p.getNode();
  JsonNode first=node.get(""String_Node_Str"");
  JsonNode patch=node.get(""String_Node_Str"");
  JsonNode message=node.get(""String_Node_Str"");
  Class<?> type=node.has(""String_Node_Str"") ? exceptionType(node.get(""String_Node_Str"").textValue()) : JsonPatchApplicationException.class;
  try {
    JsonPatch.apply(patch,first);
    fail(errorMessage(""String_Node_Str"" + message));
  }
 catch (  Exception e) {
    if (matchOnErrors()) {
      assertThat(errorMessage(""String_Node_Str""),e,instanceOf(type));
      if (message != null) {
        assertThat(errorMessage(""String_Node_Str""),e.getMessage(),containsString(message.textValue()));
      }
    }
  }
}","The original code lacked a conditional check before asserting error details, potentially causing test failures even when error matching was not intended. The fixed code introduces a `matchOnErrors()` method that allows selective error verification, enabling more flexible test behavior. This modification provides better control over error assertion, making the test more robust and adaptable to different testing scenarios."
94333,"private static void introduceCopyOperation(JsonNode source,JsonNode target,List<Diff> diffs){
  Map<JsonNode,List<Object>> unchangedValues=getUnchangedPart(source,target);
  for (int i=0; i < diffs.size(); i++) {
    Diff diff=diffs.get(i);
    if (Operation.ADD.equals(diff.getOperation())) {
      List<Object> matchingValuePath=getMatchingValuePath(unchangedValues,diff.getValue());
      if (matchingValuePath != null) {
        diffs.set(i,new Diff(Operation.COPY,matchingValuePath,diff.getPath()));
      }
    }
  }
}","private static void introduceCopyOperation(JsonNode source,JsonNode target,List<Diff> diffs){
  Map<JsonNode,List<Object>> unchangedValues=getUnchangedPart(source,target);
  for (int i=0; i < diffs.size(); i++) {
    Diff diff=diffs.get(i);
    if (Operation.ADD.equals(diff.getOperation())) {
      List<Object> matchingValuePath=getMatchingValuePath(unchangedValues,diff.getValue());
      if (matchingValuePath != null && !isSame(matchingValuePath,diff.getPath())) {
        diffs.set(i,new Diff(Operation.COPY,matchingValuePath,diff.getPath()));
      }
    }
  }
}","The original code could introduce unnecessary copy operations without verifying path uniqueness, potentially creating incorrect diff transformations. The fixed code adds an additional check with `!isSame(matchingValuePath,diff.getPath())` to ensure the copied path is genuinely different from the original path. This prevents redundant or incorrect copy operations, improving the accuracy of the diff transformation process by only replacing truly unique and distinct paths."
94334,"@Test public void applyInPlaceMutatesSource() throws Exception {
  JsonNode patch=readTree(""String_Node_Str"");
  ObjectNode source=newObjectNode();
  JsonPatch.applyInPlace(patch,source);
  assertThat(source.findValue(""String_Node_Str"").asText(),is(""String_Node_Str""));
}","@Test public void applyInPlaceMutatesSource() throws Exception {
  JsonNode patch=readTree(""String_Node_Str"");
  ObjectNode source=newObjectNode();
  ObjectNode beforeApplication=source.deepCopy();
  JsonPatch.apply(patch,source);
  assertThat(source,is(beforeApplication));
}","The original code incorrectly assumes that JsonPatch.applyInPlace() would modify the source node as expected, which may not reflect actual patch behavior. The fixed code introduces a deepCopy() of the source before patch application and uses JsonPatch.apply() to ensure predictable and correct transformation. This approach provides a more reliable method for verifying patch operations by capturing the initial state and comparing the result against expected modifications."
94335,"private void setTypeFace(Context context,AttributeSet attrs){
  TypedArray a=context.getTheme().obtainStyledAttributes(attrs,R.styleable.Typefaceable,0,0);
  try {
    isHtml=a.getBoolean(R.styleable.Typefaceable_html,false);
    letterSpace=a.getFloat(R.styleable.Typefaceable_letterSpace,NO_LETTER_SPACE);
    textTransform=TRANSFORM.findByValue(a.getInt(R.styleable.Typefaceable_textTransform,TRANSFORM.NONE.value));
    String typefaceName=a.getString(R.styleable.Typefaceable_font);
    if (typefaceName != null && !TextUtils.isEmpty(typefaceName)) {
      Typeface typeface=TypefaceLoader.get(context,typefaceName);
      if (!view.isInEditMode()) {
        view.setTypeface(typeface);
      }
      view.setPaintFlags(view.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG);
    }
  }
  finally {
    a.recycle();
  }
  createLetterSpacing(view.getText());
}","private void setTypeFace(Context context,AttributeSet attrs){
  TypedArray a=context.getTheme().obtainStyledAttributes(attrs,R.styleable.Typefaceable,0,0);
  try {
    isHtml=a.getBoolean(R.styleable.Typefaceable_html,false);
    letterSpace=a.getFloat(R.styleable.Typefaceable_letterSpace,NO_LETTER_SPACE);
    textTransform=TRANSFORM.findByValue(a.getInt(R.styleable.Typefaceable_textTransform,TRANSFORM.NONE.value));
    String typefaceName=a.getString(R.styleable.Typefaceable_font);
    if (typefaceName != null && !TextUtils.isEmpty(typefaceName)) {
      Typeface typeface=TypefaceLoader.get(context,typefaceName);
      view.setTypeface(typeface);
      view.setPaintFlags(view.getPaintFlags() | Paint.SUBPIXEL_TEXT_FLAG);
    }
  }
  finally {
    a.recycle();
  }
  createLetterSpacing(view.getText());
}","The buggy code conditionally sets the typeface only when not in edit mode, potentially preventing custom font display during design-time preview. The fixed code removes the `!view.isInEditMode()` condition, ensuring the typeface is set consistently in both runtime and design environments. This modification provides a more reliable font application across different development and rendering contexts."
94336,"public void attemptConnection(){
  mBluetoothManager=(BluetoothManager)getSystemService(Context.BLUETOOTH_SERVICE);
  if (device != null) {
    for (    BluetoothDevice bluetoothDevice : mBluetoothManager.getConnectedDevices(BluetoothProfile.GATT)) {
      if (bluetoothDevice.getAddress().compareTo(device.getAddress()) == 0) {
        mConnectionState=STATE_CONNECTED;
      }
    }
  }
  Log.w(TAG,""String_Node_Str"" + mConnectionState);
  if (mConnectionState == STATE_DISCONNECTED || mConnectionState == STATE_DISCONNECTING) {
    ActiveBluetoothDevice btDevice=ActiveBluetoothDevice.first();
    if (btDevice != null) {
      mDeviceName=btDevice.name;
      mDeviceAddress=btDevice.address;
      mBluetoothAdapter=mBluetoothManager.getAdapter();
      if (mBluetoothAdapter.isEnabled() && mBluetoothAdapter.getRemoteDevice(mDeviceAddress) != null) {
        connect(mDeviceAddress);
        return;
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        setRetryTimer();
        return;
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      setRetryTimer();
      return;
    }
  }
 else   if (mConnectionState == STATE_CONNECTED && mBluetoothGatt != null) {
    attemptRead();
    return;
  }
 else {
    setRetryTimer();
    return;
  }
}","public void attemptConnection(){
  mBluetoothManager=(BluetoothManager)getSystemService(Context.BLUETOOTH_SERVICE);
  if (device != null) {
    mConnectionState=STATE_DISCONNECTED;
    for (    BluetoothDevice bluetoothDevice : mBluetoothManager.getConnectedDevices(BluetoothProfile.GATT)) {
      if (bluetoothDevice.getAddress().compareTo(device.getAddress()) == 0) {
        mConnectionState=STATE_CONNECTED;
      }
    }
  }
  Log.w(TAG,""String_Node_Str"" + mConnectionState);
  if (mConnectionState == STATE_DISCONNECTED || mConnectionState == STATE_DISCONNECTING) {
    ActiveBluetoothDevice btDevice=ActiveBluetoothDevice.first();
    if (btDevice != null) {
      mDeviceName=btDevice.name;
      mDeviceAddress=btDevice.address;
      mBluetoothAdapter=mBluetoothManager.getAdapter();
      if (mBluetoothAdapter.isEnabled() && mBluetoothAdapter.getRemoteDevice(mDeviceAddress) != null) {
        connect(mDeviceAddress);
        return;
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        setRetryTimer();
        return;
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      setRetryTimer();
      return;
    }
  }
 else   if (mConnectionState == STATE_CONNECTED) {
    Log.w(TAG,""String_Node_Str"");
    attemptRead();
    return;
  }
 else {
    setRetryTimer();
    return;
  }
}",The original code had a potential null pointer risk when checking mBluetoothGatt and incorrectly assumed a connection state without proper initialization. The fixed code explicitly sets the initial connection state to STATE_DISCONNECTED before checking connected devices and removes the redundant mBluetoothGatt null check. This ensures more reliable connection state management and prevents potential null reference exceptions during Bluetooth device connection attempts.
94337,"@Override public void onCreate(){
  super.onCreate();
}","@Override public void onCreate(){
  super.onCreate();
  readData=new ReadDataShare(this);
  final IntentFilter bondintent=new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  registerReceiver(mPairReceiver,bondintent);
  prefs=PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
  listenForChangeInSettings();
}","The original code merely calls the superclass constructor without initializing critical components needed for the activity's functionality. The fixed code adds essential initialization steps, including creating a ReadDataShare instance, registering a Bluetooth bond state receiver, and setting up shared preferences with a settings change listener. These additions ensure proper setup of bluetooth-related services and preference monitoring, making the activity fully prepared for its intended operations."
94338,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  if (CollectionServiceStarter.isBTShare(getApplicationContext())) {
    setFailoverTimer();
  }
  if (Sensor.currentSensor() == null) {
    setRetryTimer();
    return START_NOT_STICKY;
  }
  final IntentFilter bondintent=new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  registerReceiver(mPairReceiver,bondintent);
  prefs=PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
  listenForChangeInSettings();
  Log.w(TAG,""String_Node_Str"");
  attemptConnection();
  return START_STICKY;
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  if (CollectionServiceStarter.isBTShare(getApplicationContext())) {
    setFailoverTimer();
  }
  if (Sensor.currentSensor() == null) {
    setRetryTimer();
    return START_NOT_STICKY;
  }
  Log.w(TAG,""String_Node_Str"");
  attemptConnection();
  return START_STICKY;
}","The original code had unnecessary receiver registration and preference management that could lead to resource leaks and potential context-related issues. The fixed code removes the redundant `registerReceiver()` and `listenForChangeInSettings()` calls, eliminating potential memory and context management problems. By simplifying the method, the fixed code ensures a more streamlined and focused service startup process with reduced potential for unintended side effects."
94339,"public void attemptRead(){
  final ReadDataShare readData=new ReadDataShare(this);
  final Action1<Long> systemTimeListener=new Action1<Long>(){
    @Override public void call(    Long s){
      if (s != null) {
        Log.d(TAG,""String_Node_Str"" + s + ""String_Node_Str"");
        final long addativeSystemTimeOffset=new Date().getTime() - s;
        final Action1<EGVRecord[]> evgRecordListener=new Action1<EGVRecord[]>(){
          @Override public void call(          EGVRecord[] egvRecords){
            if (egvRecords != null) {
              Log.d(TAG,""String_Node_Str"" + egvRecords.length + ""String_Node_Str"");
              BgReading.create(egvRecords,addativeSystemTimeOffset,getApplicationContext());
              setRetryTimer();
            }
          }
        }
;
        final Action1<SensorRecord[]> sensorRecordListener=new Action1<SensorRecord[]>(){
          @Override public void call(          SensorRecord[] sensorRecords){
            if (sensorRecords != null) {
              Log.d(TAG,""String_Node_Str"" + sensorRecords.length + ""String_Node_Str"");
              BgReading.create(sensorRecords,addativeSystemTimeOffset,getApplicationContext());
              readData.getRecentEGVs(evgRecordListener);
            }
          }
        }
;
        final Action1<CalRecord[]> calRecordListener=new Action1<CalRecord[]>(){
          @Override public void call(          CalRecord[] calRecords){
            if (calRecords != null) {
              Log.d(TAG,""String_Node_Str"" + calRecords.length + ""String_Node_Str"");
              Calibration.create(calRecords,addativeSystemTimeOffset,getApplicationContext());
              readData.getRecentSensorRecords(sensorRecordListener);
            }
          }
        }
;
        readData.getRecentCalRecords(calRecordListener);
      }
    }
  }
;
  readData.readSystemTime(systemTimeListener);
}","public void attemptRead(){
  Log.d(TAG,""String_Node_Str"");
  final Action1<Long> systemTimeListener=new Action1<Long>(){
    @Override public void call(    Long s){
      if (s != null) {
        Log.d(TAG,""String_Node_Str"" + s + ""String_Node_Str"");
        final long addativeSystemTimeOffset=new Date().getTime() - s;
        final Action1<EGVRecord[]> evgRecordListener=new Action1<EGVRecord[]>(){
          @Override public void call(          EGVRecord[] egvRecords){
            if (egvRecords != null) {
              Log.d(TAG,""String_Node_Str"" + egvRecords.length + ""String_Node_Str"");
              BgReading.create(egvRecords,addativeSystemTimeOffset,getApplicationContext());
              setRetryTimer();
            }
          }
        }
;
        final Action1<SensorRecord[]> sensorRecordListener=new Action1<SensorRecord[]>(){
          @Override public void call(          SensorRecord[] sensorRecords){
            if (sensorRecords != null) {
              Log.d(TAG,""String_Node_Str"" + sensorRecords.length + ""String_Node_Str"");
              BgReading.create(sensorRecords,addativeSystemTimeOffset,getApplicationContext());
              readData.getRecentEGVs(evgRecordListener);
            }
          }
        }
;
        final Action1<CalRecord[]> calRecordListener=new Action1<CalRecord[]>(){
          @Override public void call(          CalRecord[] calRecords){
            if (calRecords != null) {
              Log.d(TAG,""String_Node_Str"" + calRecords.length + ""String_Node_Str"");
              Calibration.create(calRecords,addativeSystemTimeOffset,getApplicationContext());
              readData.getRecentSensorRecords(sensorRecordListener);
            }
          }
        }
;
        readData.getRecentCalRecords(calRecordListener);
      }
    }
  }
;
  readData.readSystemTime(systemTimeListener);
}","The original code created a new ReadDataShare object within the method, potentially leading to multiple unnecessary instances and resource overhead. In the fixed code, the ReadDataShare object initialization was removed, likely relying on a pre-existing instance to manage data reading operations more efficiently. This simplification reduces redundant object creation and streamlines the data retrieval process, making the code more performant and maintainable."
94340,"@Override public void onConnectionStateChange(BluetoothGatt gatt,int status,int newState){
  Log.w(TAG,""String_Node_Str"" + status + ""String_Node_Str""+ newState);
  if (status == 133) {
    Log.e(TAG,""String_Node_Str"");
    gatt.close();
    return;
  }
  if (newState == BluetoothProfile.STATE_CONNECTED) {
    mBluetoothGatt=gatt;
    device=mBluetoothGatt.getDevice();
    mConnectionState=STATE_CONNECTED;
    ActiveBluetoothDevice.connected();
    Log.w(TAG,""String_Node_Str"");
    if (device.getBondState() == BluetoothDevice.BOND_BONDED) {
      Log.w(TAG,""String_Node_Str"");
      currentGattTask=GATT_SETUP;
      if (!mBluetoothGatt.discoverServices()) {
        Log.w(TAG,""String_Node_Str"");
        setRetryTimer();
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      bondDevice();
    }
  }
 else   if (newState == BluetoothProfile.STATE_DISCONNECTED) {
    mConnectionState=STATE_DISCONNECTED;
    ActiveBluetoothDevice.disconnected();
    setRetryTimer();
    Log.w(TAG,""String_Node_Str"");
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
}","@Override public void onConnectionStateChange(BluetoothGatt gatt,int status,int newState){
  Log.w(TAG,""String_Node_Str"" + status + ""String_Node_Str""+ newState);
  if (status == 133) {
    Log.e(TAG,""String_Node_Str"");
  }
  if (newState == BluetoothProfile.STATE_CONNECTED) {
    mBluetoothGatt=gatt;
    device=mBluetoothGatt.getDevice();
    mConnectionState=STATE_CONNECTED;
    ActiveBluetoothDevice.connected();
    Log.w(TAG,""String_Node_Str"");
    if (device.getBondState() == BluetoothDevice.BOND_BONDED) {
      Log.w(TAG,""String_Node_Str"");
      currentGattTask=GATT_SETUP;
      if (!mBluetoothGatt.discoverServices()) {
        Log.w(TAG,""String_Node_Str"");
        setRetryTimer();
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      bondDevice();
    }
  }
 else   if (newState == BluetoothProfile.STATE_DISCONNECTED) {
    mConnectionState=STATE_DISCONNECTED;
    ActiveBluetoothDevice.disconnected();
    setRetryTimer();
    Log.w(TAG,""String_Node_Str"");
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
}","The buggy code incorrectly closes the Bluetooth GATT connection when encountering a status 133 error, potentially interrupting the connection process prematurely. In the fixed code, the `gatt.close()` call is removed, allowing the connection attempt to proceed and handle the error more gracefully. This modification enables better error handling and maintains the connection flow, improving the Bluetooth device interaction reliability."
94341,"@Override public void onDestroy(){
  AlarmManager alarm=(AlarmManager)getSystemService(ALARM_SERVICE);
  alarm.set(alarm.RTC_WAKEUP,System.currentTimeMillis() + (1000 * 60),PendingIntent.getService(this,0,new Intent(this,DexCollectionService.class),0));
  close();
  foregroundServiceStarter.stop();
}","@Override public void onDestroy(){
  setRetryTimer();
  close();
  foregroundServiceStarter.stop();
}","The original code directly sets an alarm in onDestroy(), which can lead to unintended background service restarts and potential resource leaks. The fixed code replaces the direct alarm setting with a call to setRetryTimer(), which likely encapsulates more robust and controlled retry logic for service restart. By delegating alarm management to a dedicated method, the code becomes more modular, prevents potential timing issues, and ensures cleaner service lifecycle management."
94342,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  PendingIntent pending=PendingIntent.getService(this,0,new Intent(this,DexCollectionService.class),0);
  AlarmManager alarmManager=(AlarmManager)this.getSystemService(Context.ALARM_SERVICE);
  alarmManager.cancel(pending);
  attemptConnection();
  this.startService(new Intent(this,SyncService.class));
  return START_STICKY;
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  attemptConnection();
  this.startService(new Intent(this,SyncService.class));
  return START_STICKY;
}","The original code unnecessarily creates and then cancels a PendingIntent for DexCollectionService, which serves no functional purpose and potentially wastes system resources. The fixed code removes the redundant PendingIntent creation and cancellation, leaving only the essential method calls of attemptConnection() and starting the SyncService. By eliminating the superfluous AlarmManager operations, the code becomes more efficient and focused on its core service responsibilities."
94343,"public void setRetryTimer(){
  AlarmManager alarm=(AlarmManager)getSystemService(ALARM_SERVICE);
  alarm.set(alarm.RTC_WAKEUP,System.currentTimeMillis() + (1000 * 60 * 1),PendingIntent.getService(this,0,new Intent(this,DexCollectionService.class),0));
}","public void setRetryTimer(){
  Calendar calendar=Calendar.getInstance();
  AlarmManager alarm=(AlarmManager)getSystemService(ALARM_SERVICE);
  alarm.set(alarm.RTC_WAKEUP,calendar.getTimeInMillis() + (1000 * 60),PendingIntent.getService(this,0,new Intent(this,DexCollectionService.class),0));
}","The original code used `System.currentTimeMillis()` with an incorrect delay calculation, potentially causing timing inconsistencies and imprecise alarm scheduling. The fixed code introduces `Calendar.getInstance()` to generate a more reliable timestamp and corrects the delay to one minute (1000 * 60), ensuring precise and consistent alarm setting. By using `calendar.getTimeInMillis()`, the code now provides a more accurate and predictable method for scheduling the service retry timer."
94344,"public void listenForChangeInSettings(){
  SharedPreferences.OnSharedPreferenceChangeListener listener=new SharedPreferences.OnSharedPreferenceChangeListener(){
    public void onSharedPreferenceChanged(    SharedPreferences prefs,    String key){
      if (key.compareTo(""String_Node_Str"") == 0) {
        if (prefs.getBoolean(""String_Node_Str"",false)) {
          foregroundServiceStarter=new ForegroundServiceStarter(getApplicationContext(),dexCollectionService);
          foregroundServiceStarter.start();
        }
 else {
          dexCollectionService.stopForeground(true);
        }
      }
      if (key.compareTo(""String_Node_Str"") == 0) {
        CollectionServiceStarter collectionServiceStarter=new CollectionServiceStarter();
        collectionServiceStarter.start(getApplicationContext());
      }
    }
  }
;
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(mContext);
  prefs.registerOnSharedPreferenceChangeListener(listener);
}","public void listenForChangeInSettings(){
  SharedPreferences.OnSharedPreferenceChangeListener listener=new SharedPreferences.OnSharedPreferenceChangeListener(){
    public void onSharedPreferenceChanged(    SharedPreferences prefs,    String key){
      if (key.compareTo(""String_Node_Str"") == 0) {
        if (prefs.getBoolean(""String_Node_Str"",false)) {
          foregroundServiceStarter=new ForegroundServiceStarter(getApplicationContext(),dexCollectionService);
          foregroundServiceStarter.start();
        }
 else {
          dexCollectionService.stopForeground(true);
        }
      }
      if (key.compareTo(""String_Node_Str"") == 0) {
        CollectionServiceStarter collectionServiceStarter=new CollectionServiceStarter();
        collectionServiceStarter.start(getApplicationContext());
      }
    }
  }
;
  prefs=PreferenceManager.getDefaultSharedPreferences(mContext);
  prefs.registerOnSharedPreferenceChangeListener(listener);
}","The original code declared a local `SharedPreferences` variable `prefs` before registering the listener, which could lead to a potential null reference or unintended behavior. In the fixed code, the `prefs` declaration is moved after creating the listener and uses the class-level `mContext` to ensure proper initialization. This correction guarantees that the `SharedPreferences` instance is correctly set up and the preference change listener is registered with the right context."
94345,"public void attemptConnection(){
  ActiveBluetoothDevice btDevice=new Select().from(ActiveBluetoothDevice.class).orderBy(""String_Node_Str"").executeSingle();
  if (btDevice != null) {
    mDeviceName=btDevice.name;
    mDeviceAddress=btDevice.address;
    if (mBluetoothManager == null) {
      mBluetoothManager=(BluetoothManager)getSystemService(Context.BLUETOOTH_SERVICE);
      if (mBluetoothManager == null) {
        Log.w(TAG,""String_Node_Str"");
      }
    }
    if (mBluetoothManager != null) {
      mBluetoothAdapter=mBluetoothManager.getAdapter();
      if (mBluetoothAdapter == null) {
        Log.w(TAG,""String_Node_Str"");
      }
      is_connected=connect(mDeviceAddress);
      if (is_connected) {
        Log.i(TAG,""String_Node_Str"");
      }
 else {
        Log.i(TAG,""String_Node_Str"");
        setRetryTimer();
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      setRetryTimer();
    }
  }
 else {
    Log.w(TAG,""String_Node_Str"");
    setRetryTimer();
  }
}","public void attemptConnection(){
  if (mConnectionState == STATE_DISCONNECTED) {
    ActiveBluetoothDevice btDevice=new Select().from(ActiveBluetoothDevice.class).orderBy(""String_Node_Str"").executeSingle();
    if (btDevice != null) {
      mDeviceName=btDevice.name;
      mDeviceAddress=btDevice.address;
      if (mBluetoothManager == null) {
        mBluetoothManager=(BluetoothManager)getSystemService(Context.BLUETOOTH_SERVICE);
        if (mBluetoothManager == null) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
      if (mBluetoothManager != null) {
        mBluetoothAdapter=mBluetoothManager.getAdapter();
        if (mBluetoothAdapter == null) {
          Log.w(TAG,""String_Node_Str"");
        }
        is_connected=connect(mDeviceAddress);
        if (is_connected) {
          Log.i(TAG,""String_Node_Str"");
        }
 else {
          Log.i(TAG,""String_Node_Str"");
          setRetryTimer();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        setRetryTimer();
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      setRetryTimer();
    }
  }
}","The original code lacked a connection state check, potentially attempting multiple simultaneous connection attempts and wasting system resources. The fixed code adds a condition `if (mConnectionState == STATE_DISCONNECTED)` to ensure connection attempts only occur when the device is not already connected. This modification prevents redundant connection tries, improves resource management, and enhances the overall robustness of the Bluetooth connection mechanism."
94346,"@Override public void onConnectionStateChange(BluetoothGatt gatt,int status,int newState){
  if (newState == BluetoothProfile.STATE_CONNECTED) {
    mConnectionState=STATE_CONNECTED;
    Log.i(TAG,""String_Node_Str"");
    Log.w(TAG,""String_Node_Str"" + mBluetoothGatt.discoverServices());
  }
 else   if (newState == BluetoothProfile.STATE_DISCONNECTED) {
    mConnectionState=STATE_DISCONNECTED;
    Log.i(TAG,""String_Node_Str"");
    is_connected=connect(mDeviceAddress);
    if (is_connected) {
      Log.i(TAG,""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
      setRetryTimer();
    }
  }
}","@Override public void onConnectionStateChange(BluetoothGatt gatt,int status,int newState){
  if (newState == BluetoothProfile.STATE_CONNECTED) {
    mConnectionState=STATE_CONNECTED;
    Log.i(TAG,""String_Node_Str"");
    Log.w(TAG,""String_Node_Str"" + mBluetoothGatt.discoverServices());
  }
 else   if (newState == BluetoothProfile.STATE_DISCONNECTED) {
    mConnectionState=STATE_DISCONNECTED;
    Log.i(TAG,""String_Node_Str"");
    setRetryTimer();
  }
}","The original code attempted to reconnect manually after disconnection, potentially causing recursive connection attempts and resource exhaustion. In the fixed version, the `connect()` method and its conditional logic were removed, replacing it with a direct call to `setRetryTimer()` to handle disconnection more gracefully. This simplifies error handling, reduces unnecessary connection attempts, and provides a more robust mechanism for managing Bluetooth connection state changes."
94347,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  attemptSend();
  PendingIntent pending=PendingIntent.getService(this,0,new Intent(this,SyncService.class),0);
  AlarmManager alarmManager=(AlarmManager)this.getSystemService(Context.ALARM_SERVICE);
  alarmManager.cancel(pending);
  startSleep();
  return mStartMode;
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  attemptSend();
  setRetryTimer();
  return START_STICKY;
}","The original code improperly cancels a pending service alarm and calls an undefined `startSleep()` method, which could disrupt the service's retry mechanism. The fixed code replaces these problematic operations with a `setRetryTimer()` method and uses the standard `START_STICKY` return value to ensure service resilience and automatic restart if terminated. This approach provides a more robust and predictable service lifecycle management, improving overall service reliability and background task handling."
94348,"public static List<BgSendQueue> mongoQueue(){
  return new Select().from(BgSendQueue.class).where(""String_Node_Str"",false).where(""String_Node_Str"",""String_Node_Str"").orderBy(""String_Node_Str"").limit(20).execute();
}","public static List<BgSendQueue> mongoQueue(){
  return new Select().from(BgSendQueue.class).where(""String_Node_Str"",false).where(""String_Node_Str"",""String_Node_Str"").orderBy(""String_Node_Str"").limit(10).execute();
}","The original code's limit of 20 might cause performance issues or return unnecessary data when querying the BgSendQueue collection. The fixed code reduces the limit to 10, optimizing query performance and preventing potential resource overconsumption. By limiting the result set to 10 records, the code becomes more efficient and reduces potential strain on the database retrieval process."
94349,"public static List<CalibrationSendQueue> mongoQueue(){
  return new Select().from(CalibrationSendQueue.class).where(""String_Node_Str"",false).orderBy(""String_Node_Str"").execute();
}","public static List<CalibrationSendQueue> mongoQueue(){
  return new Select().from(CalibrationSendQueue.class).where(""String_Node_Str"",false).orderBy(""String_Node_Str"").limit(10).execute();
}","The original code lacks a limit on the query, which could potentially return an excessive number of records and cause performance issues. The fixed code adds a `.limit(10)` method, restricting the result set to 10 records and preventing potential memory overload or slow database queries. By implementing this limit, the code becomes more efficient and prevents unintended large-scale data retrieval."
94350,"private boolean doRESTUpload(SharedPreferences prefs,List<BgReading> glucoseDataSets,List<Calibration> meterRecords,List<Calibration> calRecords){
  String baseURLSettings=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  ArrayList<String> baseURIs=new ArrayList<String>();
  try {
    for (    String baseURLSetting : baseURLSettings.split(""String_Node_Str"")) {
      String baseURL=baseURLSetting.trim();
      if (baseURL.isEmpty())       continue;
      baseURIs.add(baseURL + (baseURL.endsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str""));
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"" + baseURLSettings,e);
    return false;
  }
  for (  String baseURI : baseURIs) {
    try {
      doRESTUploadTo(baseURI,glucoseDataSets,meterRecords,calRecords);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"" + baseURI,e);
      return false;
    }
  }
  return true;
}","private boolean doRESTUpload(SharedPreferences prefs,List<BgReading> glucoseDataSets,List<Calibration> meterRecords,List<Calibration> calRecords){
  String baseURLSettings=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  ArrayList<String> baseURIs=new ArrayList<String>();
  try {
    for (    String baseURLSetting : baseURLSettings.split(""String_Node_Str"")) {
      String baseURL=baseURLSetting.trim();
      if (baseURL.isEmpty())       continue;
      baseURIs.add(baseURL + (baseURL.endsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str""));
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"");
    return false;
  }
  for (  String baseURI : baseURIs) {
    try {
      doRESTUploadTo(baseURI,glucoseDataSets,meterRecords,calRecords);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"");
      return false;
    }
  }
  return true;
}","The original code incorrectly logged exceptions with additional parameters, potentially causing unnecessary information exposure and complicating error tracking. The fixed code simplifies error logging by removing redundant parameter passing in the Log.e() method, focusing on clean error reporting. This modification enhances error handling by providing a more streamlined and secure approach to logging exceptions during REST upload operations."
94351,"private boolean doMongoUpload(SharedPreferences prefs,List<BgReading> glucoseDataSets,List<Calibration> meterRecords,List<Calibration> calRecords){
  SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
  format.setTimeZone(TimeZone.getDefault());
  String dbURI=prefs.getString(""String_Node_Str"",null);
  String collectionName=prefs.getString(""String_Node_Str"",null);
  String dsCollectionName=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  if (dbURI != null && collectionName != null) {
    try {
      MongoClientURI uri=new MongoClientURI(dbURI.trim());
      MongoClient client=new MongoClient(uri);
      DB db=client.getDB(uri.getDatabase());
      DBCollection dexcomData=db.getCollection(collectionName.trim());
      Log.i(TAG,""String_Node_Str"" + glucoseDataSets.size());
      for (      BgReading record : glucoseDataSets) {
        BasicDBObject testData=new BasicDBObject();
        testData.put(""String_Node_Str"",""String_Node_Str"");
        testData.put(""String_Node_Str"",record.timestamp);
        testData.put(""String_Node_Str"",format.format(record.timestamp));
        testData.put(""String_Node_Str"",(int)record.calculated_value);
        testData.put(""String_Node_Str"",record.slopeName());
        testData.put(""String_Node_Str"",""String_Node_Str"");
        testData.put(""String_Node_Str"",record.age_adjusted_raw_value);
        testData.put(""String_Node_Str"",record.age_adjusted_raw_value);
        testData.put(""String_Node_Str"",""String_Node_Str"");
        dexcomData.update(testData,testData,true,false,WriteConcern.UNACKNOWLEDGED);
      }
      Log.i(TAG,""String_Node_Str"" + meterRecords.size());
      for (      Calibration meterRecord : meterRecords) {
        BasicDBObject testData=new BasicDBObject();
        testData.put(""String_Node_Str"",""String_Node_Str"");
        testData.put(""String_Node_Str"",""String_Node_Str"");
        testData.put(""String_Node_Str"",meterRecord.timestamp);
        testData.put(""String_Node_Str"",format.format(meterRecord.timestamp));
        testData.put(""String_Node_Str"",meterRecord.bg);
        dexcomData.update(testData,testData,true,false,WriteConcern.UNACKNOWLEDGED);
      }
      for (      Calibration calRecord : calRecords) {
        BasicDBObject testData=new BasicDBObject();
        testData.put(""String_Node_Str"",""String_Node_Str"");
        testData.put(""String_Node_Str"",calRecord.timestamp);
        testData.put(""String_Node_Str"",format.format(calRecord.timestamp));
        testData.put(""String_Node_Str"",(int)(calRecord.slope * 1000));
        testData.put(""String_Node_Str"",(int)calRecord.intercept);
        testData.put(""String_Node_Str"",1000);
        testData.put(""String_Node_Str"",""String_Node_Str"");
        dexcomData.update(testData,testData,true,false,WriteConcern.UNACKNOWLEDGED);
      }
      DBCollection dsCollection=db.getCollection(dsCollectionName);
      BasicDBObject devicestatus=new BasicDBObject();
      devicestatus.put(""String_Node_Str"",getBatteryLevel());
      devicestatus.put(""String_Node_Str"",new Date());
      dsCollection.insert(devicestatus,WriteConcern.UNACKNOWLEDGED);
      client.close();
      return true;
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  return false;
}","private boolean doMongoUpload(SharedPreferences prefs,List<BgReading> glucoseDataSets,List<Calibration> meterRecords,List<Calibration> calRecords){
  SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
  format.setTimeZone(TimeZone.getDefault());
  String dbURI=prefs.getString(""String_Node_Str"",null);
  String collectionName=prefs.getString(""String_Node_Str"",null);
  String dsCollectionName=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  if (dbURI != null && collectionName != null) {
    try {
      MongoClientURI uri=new MongoClientURI(dbURI.trim());
      MongoClient client=new MongoClient(uri);
      DB db=client.getDB(uri.getDatabase());
      DBCollection dexcomData=db.getCollection(collectionName.trim());
      Log.i(TAG,""String_Node_Str"" + glucoseDataSets.size());
      for (      BgReading record : glucoseDataSets) {
        BasicDBObject testData=new BasicDBObject();
        testData.put(""String_Node_Str"",""String_Node_Str"");
        testData.put(""String_Node_Str"",record.timestamp);
        testData.put(""String_Node_Str"",format.format(record.timestamp));
        testData.put(""String_Node_Str"",(int)record.calculated_value);
        testData.put(""String_Node_Str"",record.slopeName());
        testData.put(""String_Node_Str"",""String_Node_Str"");
        testData.put(""String_Node_Str"",record.age_adjusted_raw_value);
        testData.put(""String_Node_Str"",record.age_adjusted_raw_value);
        testData.put(""String_Node_Str"",""String_Node_Str"");
        dexcomData.update(testData,testData,true,false,WriteConcern.UNACKNOWLEDGED);
      }
      Log.i(TAG,""String_Node_Str"" + meterRecords.size());
      for (      Calibration meterRecord : meterRecords) {
        BasicDBObject testData=new BasicDBObject();
        testData.put(""String_Node_Str"",""String_Node_Str"");
        testData.put(""String_Node_Str"",""String_Node_Str"");
        testData.put(""String_Node_Str"",meterRecord.timestamp);
        testData.put(""String_Node_Str"",format.format(meterRecord.timestamp));
        testData.put(""String_Node_Str"",meterRecord.bg);
        dexcomData.update(testData,testData,true,false,WriteConcern.UNACKNOWLEDGED);
      }
      for (      Calibration calRecord : calRecords) {
        BasicDBObject testData=new BasicDBObject();
        testData.put(""String_Node_Str"",""String_Node_Str"");
        testData.put(""String_Node_Str"",calRecord.timestamp);
        testData.put(""String_Node_Str"",format.format(calRecord.timestamp));
        testData.put(""String_Node_Str"",(int)(calRecord.slope * 1000));
        testData.put(""String_Node_Str"",(int)calRecord.intercept);
        testData.put(""String_Node_Str"",1000);
        testData.put(""String_Node_Str"",""String_Node_Str"");
        dexcomData.update(testData,testData,true,false,WriteConcern.UNACKNOWLEDGED);
      }
      DBCollection dsCollection=db.getCollection(dsCollectionName);
      BasicDBObject devicestatus=new BasicDBObject();
      devicestatus.put(""String_Node_Str"",getBatteryLevel());
      devicestatus.put(""String_Node_Str"",new Date());
      dsCollection.insert(devicestatus,WriteConcern.UNACKNOWLEDGED);
      client.close();
      return true;
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  return false;
}","The original code lacked proper error handling by passing the entire exception to the logging method, which could lead to potential information disclosure. In the fixed code, the exception logging was simplified to only log the error message, removing the detailed stack trace and preventing potential sensitive information leakage. This modification enhances the code's security by minimizing the risk of exposing internal system details during error reporting."
94352,"private void doRESTUploadTo(String baseURI,List<BgReading> glucoseDataSets,List<Calibration> meterRecords,List<Calibration> calRecords){
  try {
    int apiVersion=0;
    if (baseURI.endsWith(""String_Node_Str""))     apiVersion=1;
    String baseURL=null;
    String secret=null;
    String[] uriParts=baseURI.split(""String_Node_Str"");
    if (uriParts.length == 1 && apiVersion == 0) {
      baseURL=uriParts[0];
    }
 else     if (uriParts.length == 1 && apiVersion > 0) {
      throw new Exception(""String_Node_Str"");
    }
 else     if (uriParts.length == 2 && apiVersion > 0) {
      secret=uriParts[0];
      baseURL=uriParts[1];
    }
 else {
      throw new Exception(String.format(""String_Node_Str"",baseURI,uriParts.length,apiVersion));
    }
    String postURL=baseURL + ""String_Node_Str"";
    Log.i(TAG,""String_Node_Str"" + postURL);
    HttpParams params=new BasicHttpParams();
    HttpConnectionParams.setSoTimeout(params,SOCKET_TIMEOUT);
    HttpConnectionParams.setConnectionTimeout(params,CONNECTION_TIMEOUT);
    DefaultHttpClient httpclient=new DefaultHttpClient(params);
    HttpPost post=new HttpPost(postURL);
    Header apiSecretHeader=null;
    if (apiVersion > 0) {
      if (secret == null || secret.isEmpty()) {
        throw new Exception(""String_Node_Str"");
      }
 else {
        MessageDigest digest=MessageDigest.getInstance(""String_Node_Str"");
        byte[] bytes=secret.getBytes(""String_Node_Str"");
        digest.update(bytes,0,bytes.length);
        bytes=digest.digest();
        StringBuilder sb=new StringBuilder(bytes.length * 2);
        for (        byte b : bytes) {
          sb.append(String.format(""String_Node_Str"",b & 0xff));
        }
        String token=sb.toString();
        apiSecretHeader=new BasicHeader(""String_Node_Str"",token);
      }
    }
    if (apiSecretHeader != null) {
      post.setHeader(apiSecretHeader);
    }
    for (    BgReading record : glucoseDataSets) {
      JSONObject json=new JSONObject();
      try {
        if (apiVersion >= 1)         populateV1APIBGEntry(json,record);
 else         populateLegacyAPIEntry(json,record);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + apiVersion,e);
        continue;
      }
      String jsonString=json.toString();
      Log.i(TAG,""String_Node_Str"" + jsonString);
      try {
        StringEntity se=new StringEntity(jsonString);
        post.setEntity(se);
        post.setHeader(""String_Node_Str"",""String_Node_Str"");
        post.setHeader(""String_Node_Str"",""String_Node_Str"");
        ResponseHandler responseHandler=new BasicResponseHandler();
        httpclient.execute(post,responseHandler);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + post.getURI().toString() + ""String_Node_Str"",e);
      }
    }
    if (apiVersion >= 1) {
      for (      Calibration record : meterRecords) {
        JSONObject json=new JSONObject();
        try {
          populateV1APIMeterReadingEntry(json,record);
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"" + apiVersion,e);
          continue;
        }
        String jsonString=json.toString();
        Log.i(TAG,""String_Node_Str"" + jsonString);
        try {
          StringEntity se=new StringEntity(jsonString);
          post.setEntity(se);
          post.setHeader(""String_Node_Str"",""String_Node_Str"");
          post.setHeader(""String_Node_Str"",""String_Node_Str"");
          ResponseHandler responseHandler=new BasicResponseHandler();
          httpclient.execute(post,responseHandler);
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"" + post.getURI().toString() + ""String_Node_Str"",e);
        }
      }
    }
    if (apiVersion >= 1) {
      for (      Calibration calRecord : calRecords) {
        JSONObject json=new JSONObject();
        try {
          populateV1APICalibrationEntry(json,calRecord);
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"" + apiVersion,e);
          continue;
        }
        String jsonString=json.toString();
        Log.i(TAG,""String_Node_Str"" + jsonString);
        try {
          StringEntity se=new StringEntity(jsonString);
          post.setEntity(se);
          post.setHeader(""String_Node_Str"",""String_Node_Str"");
          post.setHeader(""String_Node_Str"",""String_Node_Str"");
          ResponseHandler responseHandler=new BasicResponseHandler();
          httpclient.execute(post,responseHandler);
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"" + post.getURI().toString() + ""String_Node_Str"",e);
        }
      }
    }
    postDeviceStatus(baseURL,apiSecretHeader,httpclient);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","private void doRESTUploadTo(String baseURI,List<BgReading> glucoseDataSets,List<Calibration> meterRecords,List<Calibration> calRecords){
  try {
    int apiVersion=0;
    if (baseURI.endsWith(""String_Node_Str""))     apiVersion=1;
    String baseURL=null;
    String secret=null;
    String[] uriParts=baseURI.split(""String_Node_Str"");
    if (uriParts.length == 1 && apiVersion == 0) {
      baseURL=uriParts[0];
    }
 else     if (uriParts.length == 1 && apiVersion > 0) {
      throw new Exception(""String_Node_Str"");
    }
 else     if (uriParts.length == 2 && apiVersion > 0) {
      secret=uriParts[0];
      baseURL=uriParts[1];
    }
 else {
      throw new Exception(""String_Node_Str"");
    }
    String postURL=baseURL + ""String_Node_Str"";
    Log.i(TAG,""String_Node_Str"" + postURL);
    HttpParams params=new BasicHttpParams();
    HttpConnectionParams.setSoTimeout(params,SOCKET_TIMEOUT);
    HttpConnectionParams.setConnectionTimeout(params,CONNECTION_TIMEOUT);
    DefaultHttpClient httpclient=new DefaultHttpClient(params);
    HttpPost post=new HttpPost(postURL);
    Header apiSecretHeader=null;
    if (apiVersion > 0) {
      if (secret == null || secret.isEmpty()) {
        throw new Exception(""String_Node_Str"");
      }
 else {
        MessageDigest digest=MessageDigest.getInstance(""String_Node_Str"");
        byte[] bytes=secret.getBytes(""String_Node_Str"");
        digest.update(bytes,0,bytes.length);
        bytes=digest.digest();
        StringBuilder sb=new StringBuilder(bytes.length * 2);
        for (        byte b : bytes) {
          sb.append(String.format(""String_Node_Str"",b & 0xff));
        }
        String token=sb.toString();
        apiSecretHeader=new BasicHeader(""String_Node_Str"",token);
      }
    }
    if (apiSecretHeader != null) {
      post.setHeader(apiSecretHeader);
    }
    for (    BgReading record : glucoseDataSets) {
      JSONObject json=new JSONObject();
      try {
        if (apiVersion >= 1)         populateV1APIBGEntry(json,record);
 else         populateLegacyAPIEntry(json,record);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"");
        continue;
      }
      String jsonString=json.toString();
      Log.i(TAG,""String_Node_Str"" + jsonString);
      try {
        StringEntity se=new StringEntity(jsonString);
        post.setEntity(se);
        post.setHeader(""String_Node_Str"",""String_Node_Str"");
        post.setHeader(""String_Node_Str"",""String_Node_Str"");
        ResponseHandler responseHandler=new BasicResponseHandler();
        httpclient.execute(post,responseHandler);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"");
      }
    }
    if (apiVersion >= 1) {
      for (      Calibration record : meterRecords) {
        JSONObject json=new JSONObject();
        try {
          populateV1APIMeterReadingEntry(json,record);
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"");
          continue;
        }
        String jsonString=json.toString();
        Log.i(TAG,""String_Node_Str"" + jsonString);
        try {
          StringEntity se=new StringEntity(jsonString);
          post.setEntity(se);
          post.setHeader(""String_Node_Str"",""String_Node_Str"");
          post.setHeader(""String_Node_Str"",""String_Node_Str"");
          ResponseHandler responseHandler=new BasicResponseHandler();
          httpclient.execute(post,responseHandler);
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
    }
    if (apiVersion >= 1) {
      for (      Calibration calRecord : calRecords) {
        JSONObject json=new JSONObject();
        try {
          populateV1APICalibrationEntry(json,calRecord);
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"");
          continue;
        }
        String jsonString=json.toString();
        Log.i(TAG,""String_Node_Str"" + jsonString);
        try {
          StringEntity se=new StringEntity(jsonString);
          post.setEntity(se);
          post.setHeader(""String_Node_Str"",""String_Node_Str"");
          post.setHeader(""String_Node_Str"",""String_Node_Str"");
          ResponseHandler responseHandler=new BasicResponseHandler();
          httpclient.execute(post,responseHandler);
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"");
        }
      }
    }
    postDeviceStatus(baseURL,apiSecretHeader,httpclient);
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"");
  }
}","The original code had overly verbose error logging and potentially exposed sensitive error details, which could compromise system security. The fixed code simplifies error handling by removing specific error messages and using more generic logging, reducing the risk of information leakage while maintaining basic error tracking. By minimizing detailed error exposition and standardizing log outputs, the revised implementation enhances the method's robustness and prevents potential security vulnerabilities."
94353,"private void broadcastUpdate(final String action,final BluetoothGattCharacteristic characteristic){
  Log.w(TAG,""String_Node_Str"");
  final byte[] data=characteristic.getValue();
  Log.i(TAG,""String_Node_Str"" + characteristic.getValue());
  if (data != null && data.length > 0) {
    setSerialDataToTransmitterRawData(data,data.length);
    Log.w(TAG,""String_Node_Str"");
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
}","private void broadcastUpdate(final String action,final BluetoothGattCharacteristic characteristic){
  final byte[] data=characteristic.getValue();
  Log.i(TAG,""String_Node_Str"" + characteristic.getValue());
  if (data != null && data.length > 0) {
    setSerialDataToTransmitterRawData(data,data.length);
    Log.d(TAG,""String_Node_Str"");
  }
}","The original code unnecessarily logged repetitive warning messages and included a redundant else block, which added no meaningful functionality. The fixed code removes the unnecessary logging and eliminates the empty else clause, simplifying the method and improving code readability. By streamlining the logic and using a more appropriate logging level (DEBUG instead of WARNING), the code becomes more concise and focused on its core purpose of processing Bluetooth characteristic data."
94354,"public void setRetryTimer(){
  AlarmManager alarm=(AlarmManager)getSystemService(ALARM_SERVICE);
  alarm.set(alarm.ELAPSED_REALTIME_WAKEUP,System.currentTimeMillis() + (1000 * 60 * 3),PendingIntent.getService(this,0,new Intent(this,DexCollectionService.class),0));
  stopSelf();
}","public void setRetryTimer(){
  AlarmManager alarm=(AlarmManager)getSystemService(ALARM_SERVICE);
  alarm.set(alarm.ELAPSED_REALTIME_WAKEUP,System.currentTimeMillis() + (1000 * 60 * 3),PendingIntent.getService(this,0,new Intent(this,DexCollectionService.class),0));
  close();
  stopSelf();
}","The original code lacks proper resource management, potentially leaving services running without clean shutdown. The fixed code adds a `close()` method call before `stopSelf()`, ensuring proper cleanup and resource release for the service. This modification enhances the code's reliability by providing a more controlled and systematic approach to terminating the service and managing system resources."
94355,"@Override public void onCharacteristicRead(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,int status){
  if (status == BluetoothGatt.GATT_SUCCESS) {
    Log.w(TAG,""String_Node_Str"");
    broadcastUpdate(ACTION_DATA_AVAILABLE,characteristic);
  }
 else {
    Log.w(TAG,""String_Node_Str"");
  }
}","@Override public void onCharacteristicRead(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,int status){
  if (status == BluetoothGatt.GATT_SUCCESS) {
    broadcastUpdate(ACTION_DATA_AVAILABLE,characteristic);
  }
}","The original code redundantly logs a warning message even on successful characteristic read, cluttering logs without providing meaningful information. The fixed code removes the unnecessary log statement and focuses solely on broadcasting the available data when the read operation is successful. This streamlines error handling, reduces unnecessary logging, and ensures that only meaningful data updates are propagated to the application's components."
94356,"public void close(){
  if (mBluetoothGatt == null) {
    return;
  }
  mBluetoothGatt.close();
  mBluetoothGatt=null;
}","public void close(){
  disconnect();
  if (mBluetoothGatt == null) {
    return;
  }
  mBluetoothGatt.close();
  mBluetoothGatt=null;
  mConnectionState=STATE_DISCONNECTED;
}","The original code lacks proper disconnection before closing the Bluetooth GATT connection, which can lead to potential resource leaks and unstable connection states. The fixed code adds a `disconnect()` method call before closing and sets the connection state to disconnected, ensuring a clean and controlled termination of the Bluetooth connection. These modifications improve resource management, prevent potential connection-related issues, and provide a more robust approach to closing Bluetooth connections."
94357,"public static void clearAllCalibrationNotifications(){
  notificationDismiss(BgNotificationId);
}","public static void clearAllCalibrationNotifications(){
  notificationDismiss(calibrationNotificationId);
  notificationDismiss(extraCalibrationNotificationId);
  notificationDismiss(doubleCalibrationNotificationId);
}","The original code only dismissed a single notification ID (BgNotificationId), which likely failed to clear all relevant calibration notifications. The fixed code now explicitly dismisses multiple specific notification IDs (calibrationNotificationId, extraCalibrationNotificationId, and doubleCalibrationNotificationId), ensuring comprehensive notification clearing. This approach provides a more thorough and reliable method of removing all calibration-related notifications from the user interface."
94358,"public static void initialCalibration(int bg1,int bg2,Context context){
  CalibrationRequest.clearAll();
  List<Calibration> pastCalibrations=Calibration.allForSensor();
  if (pastCalibrations != null) {
    for (    Calibration calibration : pastCalibrations) {
      calibration.slope_confidence=0;
      calibration.sensor_confidence=0;
      calibration.save();
    }
  }
  Calibration higherCalibration=new Calibration();
  Calibration lowerCalibration=new Calibration();
  Sensor sensor=Sensor.currentSensor();
  List<BgReading> bgReadings=BgReading.latest_by_size(2);
  BgReading bgReading1=bgReadings.get(0);
  BgReading bgReading2=bgReadings.get(1);
  BgReading highBgReading;
  BgReading lowBgReading;
  int higher_bg;
  int lower_bg;
  if (bg1 > bg2) {
    higher_bg=bg1;
    lower_bg=bg2;
  }
 else   if (bg2 > bg1) {
    higher_bg=bg2;
    lower_bg=bg1;
  }
 else {
    higher_bg=bg1;
    lower_bg=bg1 - 1;
  }
  if (bgReading1.raw_data > bgReading2.raw_data) {
    highBgReading=bgReading1;
    lowBgReading=bgReading2;
  }
 else   if (bgReading2.raw_data > bgReading1.raw_data) {
    highBgReading=bgReading2;
    lowBgReading=bgReading1;
  }
 else {
    highBgReading=bgReading2;
    lowBgReading=bgReading1;
  }
  int lowerAdjust=0;
  if (highBgReading.age_adjusted_raw_value == lowBgReading.age_adjusted_raw_value) {
    lowerAdjust=2;
  }
  higherCalibration.bg=higher_bg;
  higherCalibration.slope=0;
  higherCalibration.intercept=higher_bg;
  higherCalibration.sensor=sensor;
  higherCalibration.estimate_raw_at_time_of_calibration=highBgReading.age_adjusted_raw_value;
  higherCalibration.raw_value=highBgReading.raw_data;
  higherCalibration.save();
  lowerCalibration.bg=lower_bg;
  lowerCalibration.slope=0;
  lowerCalibration.intercept=lower_bg;
  lowerCalibration.sensor=sensor;
  lowerCalibration.estimate_raw_at_time_of_calibration=lowBgReading.age_adjusted_raw_value - lowerAdjust;
  lowerCalibration.raw_value=lowBgReading.raw_data;
  lowerCalibration.save();
  highBgReading.calculated_value=higher_bg;
  highBgReading.calibration_flag=true;
  highBgReading.save();
  higherCalibration.bgReading=highBgReading;
  higherCalibration.save();
  lowBgReading.calculated_value=lower_bg;
  lowBgReading.calibration_flag=true;
  lowBgReading.save();
  lowerCalibration.bgReading=lowBgReading;
  lowerCalibration.save();
  highBgReading.find_new_curve();
  highBgReading.find_new_raw_curve();
  lowBgReading.find_new_curve();
  lowBgReading.find_new_raw_curve();
  List<Calibration> calibrations=new ArrayList<Calibration>();
  calibrations.add(lowerCalibration);
  calibrations.add(higherCalibration);
  for (  Calibration calibration : calibrations) {
    BgReading bgReading=calibration.bgReading;
    calibration.timestamp=new Date().getTime();
    calibration.sensor_uuid=sensor.uuid;
    calibration.slope_confidence=.5;
    calibration.raw_timestamp=bgReading.timestamp;
    calibration.distance_from_estimate=0;
    calibration.sensor_confidence=((-0.0018 * calibration.bg * calibration.bg) + (0.6657 * calibration.bg) + 36.7505) / 100;
    calibration.sensor_age_at_time_of_estimation=calibration.timestamp - sensor.started_at;
    calibration.uuid=UUID.randomUUID().toString();
    calibration.save();
    calculate_w_l_s();
    adjustRecentBgReadings();
    CalibrationSendQueue.addToQueue(calibration);
    Gson gson=new GsonBuilder().excludeFieldsWithoutExposeAnnotation().registerTypeAdapter(Date.class,new DateTypeAdapter()).serializeSpecialFloatingPointValues().create();
    Log.w(""String_Node_Str"",calibration.toS());
    CalibrationRequest.createOffset(calibration.bg,40);
  }
  Notifications.notificationSetter(context);
}","public static void initialCalibration(int bg1,int bg2,Context context){
  CalibrationRequest.clearAll();
  List<Calibration> pastCalibrations=Calibration.allForSensor();
  if (pastCalibrations != null) {
    for (    Calibration calibration : pastCalibrations) {
      calibration.slope_confidence=0;
      calibration.sensor_confidence=0;
      calibration.save();
    }
  }
  Calibration higherCalibration=new Calibration();
  Calibration lowerCalibration=new Calibration();
  Sensor sensor=Sensor.currentSensor();
  List<BgReading> bgReadings=BgReading.latest_by_size(2);
  BgReading bgReading1=bgReadings.get(0);
  BgReading bgReading2=bgReadings.get(1);
  BgReading highBgReading;
  BgReading lowBgReading;
  int higher_bg;
  int lower_bg;
  if (bg1 > bg2) {
    higher_bg=bg1;
    lower_bg=bg2;
  }
 else   if (bg2 > bg1) {
    higher_bg=bg2;
    lower_bg=bg1;
  }
 else {
    higher_bg=bg1;
    lower_bg=bg1 - 1;
  }
  if (bgReading1.raw_data > bgReading2.raw_data) {
    highBgReading=bgReading1;
    lowBgReading=bgReading2;
  }
 else   if (bgReading2.raw_data > bgReading1.raw_data) {
    highBgReading=bgReading2;
    lowBgReading=bgReading1;
  }
 else {
    highBgReading=bgReading2;
    lowBgReading=bgReading1;
  }
  int lowerAdjust=0;
  if (highBgReading.age_adjusted_raw_value == lowBgReading.age_adjusted_raw_value) {
    lowerAdjust=2;
  }
  higherCalibration.bg=higher_bg;
  higherCalibration.slope=0;
  higherCalibration.intercept=higher_bg;
  higherCalibration.sensor=sensor;
  higherCalibration.estimate_raw_at_time_of_calibration=highBgReading.age_adjusted_raw_value;
  higherCalibration.raw_value=highBgReading.raw_data;
  higherCalibration.save();
  lowerCalibration.bg=lower_bg;
  lowerCalibration.slope=0;
  lowerCalibration.intercept=lower_bg;
  lowerCalibration.sensor=sensor;
  lowerCalibration.estimate_raw_at_time_of_calibration=lowBgReading.age_adjusted_raw_value - lowerAdjust;
  lowerCalibration.raw_value=lowBgReading.raw_data;
  lowerCalibration.save();
  highBgReading.calculated_value=higher_bg;
  highBgReading.calibration_flag=true;
  highBgReading.calibration=higherCalibration;
  highBgReading.save();
  higherCalibration.bgReading=highBgReading;
  higherCalibration.save();
  lowBgReading.calculated_value=lower_bg;
  lowBgReading.calibration_flag=true;
  lowBgReading.calibration=lowerCalibration;
  lowBgReading.save();
  lowerCalibration.bgReading=lowBgReading;
  lowerCalibration.save();
  highBgReading.find_new_curve();
  highBgReading.find_new_raw_curve();
  lowBgReading.find_new_curve();
  lowBgReading.find_new_raw_curve();
  List<Calibration> calibrations=new ArrayList<Calibration>();
  calibrations.add(lowerCalibration);
  calibrations.add(higherCalibration);
  for (  Calibration calibration : calibrations) {
    BgReading bgReading=calibration.bgReading;
    calibration.timestamp=new Date().getTime();
    calibration.sensor_uuid=sensor.uuid;
    calibration.slope_confidence=.5;
    calibration.raw_timestamp=bgReading.timestamp;
    calibration.distance_from_estimate=0;
    calibration.sensor_confidence=((-0.0018 * calibration.bg * calibration.bg) + (0.6657 * calibration.bg) + 36.7505) / 100;
    calibration.sensor_age_at_time_of_estimation=calibration.timestamp - sensor.started_at;
    calibration.uuid=UUID.randomUUID().toString();
    calibration.save();
    calculate_w_l_s();
    adjustRecentBgReadings();
    CalibrationSendQueue.addToQueue(calibration);
    Gson gson=new GsonBuilder().excludeFieldsWithoutExposeAnnotation().registerTypeAdapter(Date.class,new DateTypeAdapter()).serializeSpecialFloatingPointValues().create();
    Log.w(""String_Node_Str"",calibration.toS());
    CalibrationRequest.createOffset(calibration.bg,45);
  }
  Notifications.notificationSetter(context);
}","The original code lacked proper calibration linking between BgReading and Calibration objects, causing potential data disconnection. The fixed code explicitly sets calibration references using `highBgReading.calibration=higherCalibration` and `lowBgReading.calibration=lowerCalibration`, ensuring bidirectional relationship integrity. These changes improve data consistency and traceability by correctly associating blood glucose readings with their corresponding calibration records."
94359,"@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public MapFile.Reader getReader() throws IOException {
  if (reader == null) {
    FileSystem fs=path.getFileSystem(conf);
    Path qualifiedPath=path.makeQualified(fs);
    URI pathUri=qualifiedPath.toUri();
    URI indexUri=UriBuilder.fromUri(pathUri).path(""String_Node_Str"").build();
    URI dataUri=UriBuilder.fromUri(pathUri).path(""String_Node_Str"").build();
    String scheme=pathUri.getScheme().toLowerCase();
    if (""String_Node_Str"".equals(scheme) || ""String_Node_Str"".equals(scheme) || ""String_Node_Str"".equals(scheme)) {
      S3Cache localS3Cache=S3Utils.getS3Cache();
      File cacheDir=S3Utils.getCacheDir();
      log.debug(""String_Node_Str"" + cacheDir.getAbsolutePath());
      File tmpBucketDir=new File(S3Utils.getCacheDir(),pathUri.getHost());
      File tmpIndexFile=new File(tmpBucketDir,indexUri.getPath().substring(1));
      File tmpDataFile=new File(tmpBucketDir,dataUri.getPath().substring(1));
      Path tryLocalPath=new Path(""String_Node_Str"" + tmpIndexFile.getParentFile().getAbsolutePath());
      log.debug(""String_Node_Str"" + tmpIndexFile.getAbsolutePath());
      cacheEntry=localS3Cache.getEntry(path.toString(),tryLocalPath,tmpIndexFile,tmpDataFile);
      if (cacheEntry != null) {
        cacheEntry.readLock();
        localPath=cacheEntry.getLocalPath();
      }
 else {
        localPath=new Path(""String_Node_Str"" + tmpIndexFile.getParentFile().getAbsolutePath());
        cacheEntry=localS3Cache.createEntry(localPath,tmpIndexFile,tmpDataFile);
        boolean writeLocked=cacheEntry.tryWriteLock();
        if (writeLocked) {
          try {
            localS3Cache.addEntry(path.toString(),cacheEntry);
            AmazonS3 s3Client=new AmazonS3Client(new DefaultAWSCredentialsProviderChain());
            FileUtils.forceMkdir(tmpDataFile.getParentFile());
            try (FileOutputStream fosData=new FileOutputStream(tmpDataFile)){
              long dataSize=copyFileFromS3(s3Client,dataUri,tmpDataFile,fosData);
              log.debug(""String_Node_Str"" + dataUri + ""String_Node_Str""+ tmpDataFile.getAbsolutePath()+ ""String_Node_Str""+ dataSize);
            }
             long indexSize=copyFileFromS3(s3Client,indexUri,tmpIndexFile,cacheEntry.getPrimaryFileOutputStream());
            log.debug(""String_Node_Str"" + indexUri + ""String_Node_Str""+ tmpIndexFile.getAbsolutePath()+ ""String_Node_Str""+ indexSize);
            log.debug(""String_Node_Str"" + indexUri + ""String_Node_Str""+ indexSize);
          }
  finally {
            log.debug(""String_Node_Str"" + Thread.currentThread().getId() + ""String_Node_Str""+ cacheEntry);
            cacheEntry.releaseWriteLock();
            cacheEntry.readLock();
          }
        }
 else {
          cacheEntry.readLock();
        }
      }
      log.debug(""String_Node_Str"" + localPath);
      reader=new MapFile.Reader(localPath,conf);
    }
 else {
      log.debug(""String_Node_Str"" + path);
      localPath=null;
      reader=new MapFile.Reader(path,conf);
    }
  }
  return reader;
}","@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public MapFile.Reader getReader() throws IOException {
  if (reader == null) {
    FileSystem fs=path.getFileSystem(conf);
    Path qualifiedPath=path.makeQualified(fs);
    URI pathUri=qualifiedPath.toUri();
    URI indexUri=UriBuilder.fromUri(pathUri).path(""String_Node_Str"").build();
    URI dataUri=UriBuilder.fromUri(pathUri).path(""String_Node_Str"").build();
    String scheme=pathUri.getScheme().toLowerCase();
    if (""String_Node_Str"".equals(scheme) || ""String_Node_Str"".equals(scheme) || ""String_Node_Str"".equals(scheme)) {
      S3Cache localS3Cache=S3Utils.getS3Cache();
      File cacheDir=S3Utils.getCacheDir();
      log.debug(""String_Node_Str"" + cacheDir.getAbsolutePath());
      File tmpBucketDir=new File(S3Utils.getCacheDir(),pathUri.getHost());
      File tmpIndexFile=new File(tmpBucketDir,indexUri.getPath().substring(1));
      File tmpDataFile=new File(tmpBucketDir,dataUri.getPath().substring(1));
      Path tryLocalPath=new Path(""String_Node_Str"" + tmpIndexFile.getParentFile().getAbsolutePath());
      log.debug(""String_Node_Str"" + tmpIndexFile.getAbsolutePath());
      cacheEntry=localS3Cache.getEntry(path.toString(),tryLocalPath,tmpIndexFile,tmpDataFile);
      if (cacheEntry != null) {
        cacheEntry.readLock();
        localPath=cacheEntry.getLocalPath();
      }
 else {
        localPath=new Path(""String_Node_Str"" + tmpIndexFile.getParentFile().getAbsolutePath());
        cacheEntry=localS3Cache.createEntry(localPath,tmpIndexFile,tmpDataFile);
        boolean writeLocked=cacheEntry.tryWriteLock();
        if (writeLocked) {
          try {
            localS3Cache.addEntry(path.toString(),cacheEntry);
            AmazonS3 s3Client=getS3Client(conf,scheme);
            FileUtils.forceMkdir(tmpDataFile.getParentFile());
            try (FileOutputStream fosData=new FileOutputStream(tmpDataFile)){
              long dataSize=copyFileFromS3(s3Client,dataUri,tmpDataFile,fosData);
              log.debug(""String_Node_Str"" + dataUri + ""String_Node_Str""+ tmpDataFile.getAbsolutePath()+ ""String_Node_Str""+ dataSize);
            }
             long indexSize=copyFileFromS3(s3Client,indexUri,tmpIndexFile,cacheEntry.getPrimaryFileOutputStream());
            log.debug(""String_Node_Str"" + indexUri + ""String_Node_Str""+ tmpIndexFile.getAbsolutePath()+ ""String_Node_Str""+ indexSize);
            log.debug(""String_Node_Str"" + indexUri + ""String_Node_Str""+ indexSize);
          }
  finally {
            log.debug(""String_Node_Str"" + Thread.currentThread().getId() + ""String_Node_Str""+ cacheEntry);
            cacheEntry.releaseWriteLock();
            cacheEntry.readLock();
          }
        }
 else {
          cacheEntry.readLock();
        }
      }
      log.debug(""String_Node_Str"" + localPath);
      reader=new MapFile.Reader(localPath,conf);
    }
 else {
      log.debug(""String_Node_Str"" + path);
      localPath=null;
      reader=new MapFile.Reader(path,conf);
    }
  }
  return reader;
}","The original code hardcoded S3 client creation without considering different authentication schemes or configurations. The fixed code introduces a new `getS3Client()` method that takes configuration and scheme parameters, allowing more flexible and configurable S3 client initialization. This improvement enhances the method's adaptability, making it more robust for handling various S3 authentication and connection scenarios across different environments."
94360,"@SuppressWarnings(""String_Node_Str"") static com.vividsolutions.jts.geom.Geometry intersect(com.vividsolutions.jts.geom.Polygon jtsClip,com.vividsolutions.jts.geom.Geometry jtsGeom){
  com.vividsolutions.jts.geom.Geometry jtsClipped;
  try {
    jtsClipped=jtsGeom.intersection(jtsClip);
  }
 catch (  TopologyException e) {
    com.vividsolutions.jts.geom.Geometry g=TopologyPreservingSimplifier.simplify(jtsGeom,1E-8);
    try {
      jtsClipped=g.intersection(jtsClip);
    }
 catch (    TopologyException e1) {
      log.error(""String_Node_Str"" + jtsClip + ""String_Node_Str""+ jtsGeom+ ""String_Node_Str""+ e1.getMessage());
      log.error(""String_Node_Str"",e1);
      return new com.vividsolutions.jts.geom.GeometryFactory().createPoint((Coordinate)null);
    }
  }
  return jtsClipped;
}","@SuppressWarnings(""String_Node_Str"") static com.vividsolutions.jts.geom.Geometry intersect(com.vividsolutions.jts.geom.Polygon jtsClip,com.vividsolutions.jts.geom.Geometry jtsGeom){
  com.vividsolutions.jts.geom.Geometry jtsClipped;
  try {
    jtsClipped=jtsGeom.intersection(jtsClip);
  }
 catch (  TopologyException e) {
    try {
      jtsClipped=jtsGeom.buffer(0).intersection(jtsClip);
    }
 catch (    TopologyException e1) {
      com.vividsolutions.jts.geom.Geometry g=TopologyPreservingSimplifier.simplify(jtsGeom,1E-6);
      try {
        jtsClipped=g.intersection(jtsClip);
      }
 catch (      TopologyException e2) {
        try {
          jtsClipped=g.buffer(0).intersection(jtsClip);
        }
 catch (        TopologyException e3) {
          log.error(""String_Node_Str"" + jtsClip + ""String_Node_Str""+ jtsGeom+ ""String_Node_Str""+ e1.getMessage());
          return new com.vividsolutions.jts.geom.GeometryFactory().createPoint((Coordinate)null);
        }
      }
    }
  }
  return jtsClipped;
}","The original code insufficiently handled TopologyExceptions by only attempting simplification once, which could fail for complex geometric intersections. The fixed code introduces multiple error-handling strategies, including buffering geometries with buffer(0) and using a smaller simplification tolerance, providing more robust intersection attempts. These enhancements significantly increase the likelihood of successful geometry intersection by adding multiple fallback mechanisms and more flexible topology resolution techniques."
94361,"@SuppressWarnings(""String_Node_Str"") public Geometry parse(String line){
  if (_wktReader == null) {
    _wktReader=new WKTReader();
  }
  Geometry feature=null;
  Double x=null, y=null;
  String wktGeometry=null;
  Map<String,String> attrs=new HashMap<>();
  String[] values;
  if (attributeNames.size() == 1) {
    values=split(line,'\n',encapsulator);
  }
 else {
    values=split(line,delimiter,encapsulator);
  }
  if (values.length == 0) {
    log.info(""String_Node_Str"");
  }
  if (geometryCol < 0 && xCol < 0 && yCol < 0) {
    for (int i=0; i < values.length; i++) {
      if (WktGeometryUtils.isValidWktGeometry(values[i])) {
        attributeNames=new ArrayList<>(values.length);
        for (int j=0; j < values.length; j++) {
          if (j == i) {
            geometryCol=i;
          }
          attributeNames.add(Integer.toString(i));
        }
        break;
      }
    }
  }
  for (int i=0; i < values.length; i++) {
    if (i == geometryCol) {
      wktGeometry=values[i];
    }
 else     if (i == xCol) {
      try {
        if (values[i].trim().length() > 0) {
          x=Double.parseDouble(values[i]);
        }
 else {
          x=null;
        }
      }
 catch (      NumberFormatException e) {
        log.error(""String_Node_Str"" + values[i] + ""String_Node_Str"");
        x=null;
      }
    }
 else     if (i == yCol) {
      try {
        if (values[i].trim().length() > 0) {
          y=Double.parseDouble(values[i]);
        }
 else {
          y=null;
        }
      }
 catch (      NumberFormatException e) {
        log.error(""String_Node_Str"" + values[i] + ""String_Node_Str"");
        y=null;
      }
    }
    if (i < attributeNames.size()) {
      attrs.put(attributeNames.get(i),values[i]);
    }
  }
  if (wktGeometry != null) {
    try {
      feature=GeometryFactory.fromJTS(_wktReader.read(wktGeometry),attrs);
    }
 catch (    Exception e) {
      try {
        feature=GeometryFactory.fromJTS(_wktReader.read(WktGeometryUtils.wktGeometryFixer(wktGeometry)));
      }
 catch (      Exception e2) {
        log.error(""String_Node_Str"" + wktGeometry + ""String_Node_Str"");
      }
    }
  }
 else   if (geometryCol == -1 && xCol >= 0 && yCol >= 0) {
    if (x != null && y != null) {
      feature=GeometryFactory.createPoint(x,y,attrs);
    }
  }
  if (feature == null) {
    feature=GeometryFactory.createEmptyGeometry(attrs);
  }
  return feature;
}","@SuppressWarnings(""String_Node_Str"") public Geometry parse(String line){
  if (_wktReader == null) {
    _wktReader=new WKTReader();
  }
  Geometry feature=null;
  Double x=null, y=null;
  String wktGeometry=null;
  Map<String,String> attrs=new HashMap<>();
  String[] values;
  if (attributeNames.size() == 1) {
    values=split(line,'\n',encapsulator);
  }
 else {
    values=split(line,delimiter,encapsulator);
  }
  if (values.length == 0) {
    log.info(""String_Node_Str"");
  }
  if (geometryCol < 0 && xCol < 0 && yCol < 0) {
    for (int i=0; i < values.length; i++) {
      if (WktGeometryUtils.isValidWktGeometry(values[i])) {
        attributeNames=new ArrayList<>(values.length);
        for (int j=0; j < values.length; j++) {
          if (j == i) {
            geometryCol=i;
          }
          attributeNames.add(Integer.toString(i));
        }
        break;
      }
    }
  }
  for (int i=0; i < values.length; i++) {
    if (i == geometryCol) {
      wktGeometry=values[i];
    }
 else     if (i == xCol) {
      try {
        if (values[i].trim().length() > 0) {
          x=Double.parseDouble(values[i]);
        }
 else {
          x=null;
        }
      }
 catch (      NumberFormatException e) {
        log.error(""String_Node_Str"" + values[i] + ""String_Node_Str"");
        x=null;
      }
    }
 else     if (i == yCol) {
      try {
        if (values[i].trim().length() > 0) {
          y=Double.parseDouble(values[i]);
        }
 else {
          y=null;
        }
      }
 catch (      NumberFormatException e) {
        log.error(""String_Node_Str"" + values[i] + ""String_Node_Str"");
        y=null;
      }
    }
    if (i < attributeNames.size()) {
      attrs.put(attributeNames.get(i),values[i]);
    }
  }
  if (wktGeometry != null) {
    try {
      feature=GeometryFactory.fromJTS(_wktReader.read(wktGeometry),attrs);
    }
 catch (    Exception e) {
      try {
        feature=GeometryFactory.fromJTS(_wktReader.read(WktGeometryUtils.wktGeometryFixer(wktGeometry)),attrs);
      }
 catch (      Exception e2) {
        log.error(""String_Node_Str"" + wktGeometry + ""String_Node_Str"");
      }
    }
  }
 else   if (geometryCol == -1 && xCol >= 0 && yCol >= 0) {
    if (x != null && y != null) {
      feature=GeometryFactory.createPoint(x,y,attrs);
    }
  }
  if (feature == null) {
    feature=GeometryFactory.createEmptyGeometry(attrs);
  }
  return feature;
}","The original code failed to pass attributes to the geometry creation in the second catch block when attempting to fix an invalid WKT geometry. The fixed code adds `attrs` to the `GeometryFactory.fromJTS()` method call in the second catch block, ensuring that attributes are consistently preserved across different geometry creation scenarios. This modification ensures that metadata is not lost during geometry parsing and reconstruction, maintaining data integrity throughout the parsing process."
94362,"static public String wktGeometryFixer(String wktGeometry){
  String regex=""String_Node_Str"";
  String[] geometryArray=wktGeometry.split(regex);
  StringBuilder fixedGeometry=new StringBuilder();
  String geometryType=""String_Node_Str"";
  if (geometryArray.length > 1) {
    geometryType=geometryArray[0];
    if (geometryType.equalsIgnoreCase(""String_Node_Str"")) {
      String[] points=geometryArray[1].split(""String_Node_Str"");
      if (points.length == 4) {
        fixedGeometry.append(""String_Node_Str"");
        fixedGeometry.append(points[0]).append(""String_Node_Str"").append(points[1]).append(""String_Node_Str"");
        fixedGeometry.append(points[2]).append(""String_Node_Str"").append(points[1]).append(""String_Node_Str"");
        fixedGeometry.append(points[2]).append(""String_Node_Str"").append(points[3]).append(""String_Node_Str"");
        fixedGeometry.append(points[0]).append(""String_Node_Str"").append(points[3]).append(""String_Node_Str"");
        fixedGeometry.append(points[0]).append(""String_Node_Str"").append(points[1]);
        fixedGeometry.append(""String_Node_Str"");
        return fixedGeometry.toString();
      }
    }
 else {
      int parenthesesCount=0;
      for (int i=1; i < geometryArray.length; i++) {
        String tmpGeom=geometryArray[i];
        if (!tmpGeom.isEmpty() && !tmpGeom.equals(""String_Node_Str"")) {
          if (fixedGeometry.length() > 0) {
            fixedGeometry.append(""String_Node_Str"");
          }
          StringBuilder tmpFixed=new StringBuilder(parsePoints(geometryArray[i],geometryType));
          for (int j=0; j < parenthesesCount; j++) {
            tmpFixed=new StringBuilder(""String_Node_Str"" + tmpFixed + ""String_Node_Str"");
          }
          fixedGeometry.append(tmpFixed);
        }
        if (tmpGeom.isEmpty() && fixedGeometry.length() == 0) {
          parenthesesCount++;
        }
      }
    }
  }
  if (!geometryType.isEmpty() && fixedGeometry.length() != 0) {
    return geometryType + ""String_Node_Str"" + fixedGeometry+ ""String_Node_Str"";
  }
  return wktGeometry;
}","static public String wktGeometryFixer(String wktGeometry){
  StringBuilder fixedGeometry=new StringBuilder();
  String regex=""String_Node_Str"";
  String[] ga=wktGeometry.split(regex,2);
  if (ga.length > 1) {
    String geometryType=ga[0].trim().toLowerCase();
    if (geometryType.equals(""String_Node_Str"")) {
      String[] points=ga[1].split(""String_Node_Str"");
      if (points.length == 4) {
        fixedGeometry.append(""String_Node_Str"");
        fixedGeometry.append(points[0]).append(""String_Node_Str"").append(points[1]).append(""String_Node_Str"");
        fixedGeometry.append(points[2]).append(""String_Node_Str"").append(points[1]).append(""String_Node_Str"");
        fixedGeometry.append(points[2]).append(""String_Node_Str"").append(points[3]).append(""String_Node_Str"");
        fixedGeometry.append(points[0]).append(""String_Node_Str"").append(points[3]).append(""String_Node_Str"");
        fixedGeometry.append(points[0]).append(""String_Node_Str"").append(points[1]);
        fixedGeometry.append(""String_Node_Str"");
        return fixedGeometry.toString();
      }
    }
 else {
      fixedGeometry.append(geometryType.toUpperCase());
      fixedGeometry.append('(');
      StringBuilder subgeo=new StringBuilder();
      for (      char ch : ga[1].toCharArray()) {
        if (ch == '(' || ch == '[') {
          fixedGeometry.append('(');
        }
 else         if (ch == ')' || ch == ']') {
          if (subgeo.length() > 0) {
            fixedGeometry.append(parsePoints(subgeo.toString(),geometryType));
          }
          fixedGeometry.append(')');
          subgeo=new StringBuilder();
        }
 else         if (ch == ',') {
          if (subgeo.length() == 0) {
            fixedGeometry.append(ch);
          }
 else {
            subgeo.append(ch);
          }
        }
 else {
          subgeo.append(ch);
        }
      }
      return fixedGeometry.toString();
    }
  }
  return wktGeometry;
}","The original code had overly complex and error-prone parsing logic with hardcoded ""String_Node_Str"" delimiters and inconsistent handling of different geometry types. The fixed code introduces robust parsing by using character-level parsing, properly handling nested geometries, and dynamically constructing the geometry string with correct parentheses and coordinate transformations. This approach provides more flexible and reliable geometry string reconstruction, reducing potential parsing errors and improving overall code maintainability."
94363,"static private String parsePoints(String geometryStr,String geometryType){
  StringBuilder geometry=new StringBuilder(geometryStr);
  String regex=""String_Node_Str"";
  String[] pointsArray=geometryStr.split(regex);
  if (geometryStr.contains(""String_Node_Str"") || geometryStr.contains(""String_Node_Str"")) {
    geometry=new StringBuilder();
    for (    String pa : pointsArray) {
      if (geometry.length() > 0) {
        geometry.append(""String_Node_Str"");
      }
      geometry.append(pa);
    }
  }
  if (geometryType.toLowerCase().contains(""String_Node_Str"")) {
    if (!pointsArray[0].trim().equalsIgnoreCase(pointsArray[pointsArray.length - 1].trim())) {
      geometry.append(""String_Node_Str"").append(pointsArray[0]);
    }
  }
  return geometry.toString();
}","static private String parsePoints(String geometryStr,String geometryType){
  StringBuilder geometry=new StringBuilder();
  String regex=""String_Node_Str"";
  String[] pointsArray=geometryStr.split(regex);
  for (  String pa : pointsArray) {
    if (geometry.length() > 0) {
      geometry.append(""String_Node_Str"");
    }
    geometry.append(pa);
  }
  int len=pointsArray.length;
  if (geometryType.contains(""String_Node_Str"")) {
    if (!pointsArray[0].trim().equalsIgnoreCase(pointsArray[pointsArray.length - 1].trim())) {
      geometry.append(""String_Node_Str"").append(pointsArray[0]);
      len++;
    }
    for (int i=len; i < 4; i++) {
      geometry.append(""String_Node_Str"").append(pointsArray[0]);
    }
  }
  return geometry.toString();
}","The original code had redundant conditions and potential logic errors when handling geometry strings with specific delimiters. The fixed code simplifies the parsing logic by always rebuilding the geometry string, adding missing points for certain geometry types, and ensuring consistent string construction. These modifications improve robustness by handling edge cases and providing a more predictable output for different geometry configurations."
94364,"@SuppressWarnings(""String_Node_Str"") static com.vividsolutions.jts.geom.Geometry intersect(com.vividsolutions.jts.geom.Polygon jtsClip,com.vividsolutions.jts.geom.Geometry jtsGeom){
  com.vividsolutions.jts.geom.Geometry jtsClipped;
  try {
    jtsClipped=jtsGeom.intersection(jtsClip);
  }
 catch (  TopologyException e) {
    try {
      jtsClipped=jtsGeom.buffer(0).intersection(jtsClip);
    }
 catch (    TopologyException e1) {
      com.vividsolutions.jts.geom.Geometry g=TopologyPreservingSimplifier.simplify(jtsGeom,1E-6);
      try {
        jtsClipped=g.intersection(jtsClip);
      }
 catch (      TopologyException e2) {
        try {
          jtsClipped=g.buffer(0).intersection(jtsClip);
        }
 catch (        TopologyException e3) {
          log.error(""String_Node_Str"" + jtsClip + ""String_Node_Str""+ jtsGeom+ ""String_Node_Str""+ e1.getMessage());
          return new com.vividsolutions.jts.geom.GeometryFactory().createPoint((Coordinate)null);
        }
      }
    }
  }
  return jtsClipped;
}","@SuppressWarnings(""String_Node_Str"") static com.vividsolutions.jts.geom.Geometry intersect(com.vividsolutions.jts.geom.Polygon jtsClip,com.vividsolutions.jts.geom.Geometry jtsGeom){
  com.vividsolutions.jts.geom.Geometry jtsClipped;
  try {
    jtsClipped=jtsGeom.intersection(jtsClip);
  }
 catch (  TopologyException e) {
    try {
      jtsClipped=jtsGeom.buffer(0).intersection(jtsClip);
    }
 catch (    TopologyException e1) {
      com.vividsolutions.jts.geom.Geometry g=TopologyPreservingSimplifier.simplify(jtsGeom,1E-8);
      try {
        jtsClipped=g.intersection(jtsClip);
      }
 catch (      TopologyException e2) {
        try {
          jtsClipped=g.buffer(0).intersection(jtsClip);
        }
 catch (        TopologyException e3) {
          log.error(""String_Node_Str"" + jtsClip + ""String_Node_Str""+ jtsGeom+ ""String_Node_Str""+ e1.getMessage());
          return new com.vividsolutions.jts.geom.GeometryFactory().createPoint((Coordinate)null);
        }
      }
    }
  }
  return jtsClipped;
}","The original code used a fixed simplification tolerance of 1E-6, which might not effectively handle complex topology exceptions. The fixed code reduces the tolerance to 1E-8, providing more precise geometry simplification and increasing the likelihood of successful intersection. This subtle adjustment improves the robustness of the geometry intersection algorithm by allowing for finer geometric adjustments when resolving topology-related challenges."
94365,"/** 
 * {@inheritDoc}
 * @see org.apache.hadoop.util.Tool#run(String[])
 */
@Override public int run(String[] args) throws IOException {
  if (commands == null) {
    loadCommands();
  }
  Options options=createOptions();
  if (args.length == 0) {
    general_usage(options);
    return -1;
  }
  String cmdStr=args[0];
  if (cmdStr.equals(""String_Node_Str"") || cmdStr.equals(""String_Node_Str"")) {
    general_usage(options);
    return 0;
  }
  CommandSpi spi=commands.get(cmdStr);
  Command cmd;
  if (spi == null) {
    System.out.println(""String_Node_Str"" + cmdStr);
    System.out.println();
    general_usage(options);
    return -1;
  }
 else {
    try {
      cmd=spi.getCommandClass().newInstance();
    }
 catch (    InstantiationException|IllegalAccessException e) {
      log.error(""String_Node_Str"",e);
      return -1;
    }
    cmd.addOptions(options);
  }
  CommandLine line;
  try {
    CommandLineParser parser=new ExtendedGnuParser(true);
    line=parser.parse(options,Arrays.copyOfRange(args,1,args.length));
  }
 catch (  ParseException e) {
    if (args.length > 1) {
      for (      String help : args) {
        if (help.equals(""String_Node_Str"") || help.equals(""String_Node_Str"")) {
          specific_usage(cmd,options);
        }
      }
      return 0;
    }
    System.out.println(e.getMessage());
    specific_usage(cmd,options);
    return -1;
  }
  if (line.hasOption(""String_Node_Str"")) {
    specific_usage(cmd,options);
    return 0;
  }
 else {
    if (line.hasOption(""String_Node_Str"")) {
      MrGeoProperties.getInstance().setProperty(MrGeoConstants.MRGEO_AUTOPERSISTANCE,""String_Node_Str"");
    }
    if (line.hasOption(""String_Node_Str"")) {
      LoggingUtils.setDefaultLogLevel(LoggingUtils.DEBUG);
    }
 else     if (line.hasOption(""String_Node_Str"")) {
      LoggingUtils.setDefaultLogLevel(LoggingUtils.INFO);
    }
 else {
      LoggingUtils.setDefaultLogLevel(LoggingUtils.ERROR);
      HadoopUtils.adjustLogging();
    }
  }
  if (line.hasOption(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    HadoopUtils.setupLocalRunner(getConf());
  }
  if (line.hasOption(""String_Node_Str"")) {
    float mult=Float.parseFloat(line.getOptionValue(""String_Node_Str""));
    MrGeoProperties.getInstance().setProperty(MrGeoConstants.MRGEO_FORCE_MEMORYINTENSIVE,""String_Node_Str"");
    MrGeoProperties.getInstance().setProperty(MrGeoConstants.MRGEO_MEMORYINTENSIVE_MULTIPLIER,Float.toString(mult));
  }
  if (line.hasOption(""String_Node_Str"")) {
    MrGeoProperties.getInstance().setProperty(MrGeoConstants.MRGEO_MAX_PROCESSING_MEM,line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    MrGeoProperties.getInstance().setProperty(MrGeoConstants.MRGEO_SHUFFLE_FRACTION,line.getOptionValue(""String_Node_Str""));
  }
  if (!commands.containsKey(cmdStr)) {
    int ret=0;
    if (!line.hasOption(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + cmdStr);
      System.out.println();
      ret=-1;
    }
    general_usage(options);
    return ret;
  }
  ProviderProperties providerProperties=new ProviderProperties();
  try {
    return cmd.run(line,getConf(),providerProperties);
  }
 catch (  ParseException e) {
    System.out.println(e.getMessage());
    new HelpFormatter().printHelp(cmd.getUsage(),options);
    return -1;
  }
}","/** 
 * {@inheritDoc}
 * @see org.apache.hadoop.util.Tool#run(String[])
 */
@Override public int run(String[] args) throws IOException {
  if (commands == null) {
    loadCommands();
  }
  Options options=createOptions();
  if (args.length == 0) {
    general_usage(options);
    return -1;
  }
  String cmdStr=args[0];
  if (cmdStr.equals(""String_Node_Str"") || cmdStr.equals(""String_Node_Str"")) {
    general_usage(options);
    return 0;
  }
  CommandSpi spi=commands.get(cmdStr);
  Command cmd;
  if (spi == null) {
    System.out.println(""String_Node_Str"" + cmdStr);
    System.out.println();
    general_usage(options);
    return -1;
  }
 else {
    try {
      cmd=spi.getCommandClass().newInstance();
    }
 catch (    InstantiationException|IllegalAccessException e) {
      log.error(""String_Node_Str"",e);
      return -1;
    }
    cmd.addOptions(options);
  }
  CommandLine line;
  try {
    CommandLineParser parser=new ExtendedGnuParser(true);
    line=parser.parse(options,Arrays.copyOfRange(args,1,args.length));
  }
 catch (  ParseException e) {
    if (args.length > 1) {
      for (      String help : args) {
        if (help.equals(""String_Node_Str"") || help.equals(""String_Node_Str"")) {
          specific_usage(cmd,options);
          return 0;
        }
      }
    }
    System.out.println(e.getMessage());
    specific_usage(cmd,options);
    return -1;
  }
  if (line.hasOption(""String_Node_Str"")) {
    specific_usage(cmd,options);
    return 0;
  }
 else {
    if (line.hasOption(""String_Node_Str"")) {
      MrGeoProperties.getInstance().setProperty(MrGeoConstants.MRGEO_AUTOPERSISTANCE,""String_Node_Str"");
    }
    if (line.hasOption(""String_Node_Str"")) {
      LoggingUtils.setDefaultLogLevel(LoggingUtils.DEBUG);
    }
 else     if (line.hasOption(""String_Node_Str"")) {
      LoggingUtils.setDefaultLogLevel(LoggingUtils.INFO);
    }
 else {
      LoggingUtils.setDefaultLogLevel(LoggingUtils.ERROR);
      HadoopUtils.adjustLogging();
    }
  }
  if (line.hasOption(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    HadoopUtils.setupLocalRunner(getConf());
  }
  if (line.hasOption(""String_Node_Str"")) {
    float mult=Float.parseFloat(line.getOptionValue(""String_Node_Str""));
    MrGeoProperties.getInstance().setProperty(MrGeoConstants.MRGEO_FORCE_MEMORYINTENSIVE,""String_Node_Str"");
    MrGeoProperties.getInstance().setProperty(MrGeoConstants.MRGEO_MEMORYINTENSIVE_MULTIPLIER,Float.toString(mult));
  }
  if (line.hasOption(""String_Node_Str"")) {
    MrGeoProperties.getInstance().setProperty(MrGeoConstants.MRGEO_MAX_PROCESSING_MEM,line.getOptionValue(""String_Node_Str""));
  }
  if (line.hasOption(""String_Node_Str"")) {
    MrGeoProperties.getInstance().setProperty(MrGeoConstants.MRGEO_SHUFFLE_FRACTION,line.getOptionValue(""String_Node_Str""));
  }
  if (!commands.containsKey(cmdStr)) {
    int ret=0;
    if (!line.hasOption(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + cmdStr);
      System.out.println();
      ret=-1;
    }
    general_usage(options);
    return ret;
  }
  ProviderProperties providerProperties=new ProviderProperties();
  try {
    return cmd.run(line,getConf(),providerProperties);
  }
 catch (  ParseException e) {
    System.out.println(e.getMessage());
    new HelpFormatter().printHelp(cmd.getUsage(),options);
    return -1;
  }
}","The original code had a nested error handling block that could potentially skip specific usage display and continue execution unintentionally. The fixed code moves the `return 0` statement immediately after calling `specific_usage()` during error handling, ensuring proper exit and usage display when help-related arguments are encountered. This modification provides clearer control flow and more predictable behavior when processing command-line arguments, preventing unintended continuation of program execution."
94366,"@Override @SuppressWarnings(""String_Node_Str"") public int run(CommandLine line,Configuration conf,ProviderProperties providerProperties) throws ParseException {
  log.info(""String_Node_Str"");
  try {
    if (line.hasOption(""String_Node_Str"") && (line.hasOption(""String_Node_Str"") || line.hasOption(""String_Node_Str"") || line.hasOption(""String_Node_Str"")|| line.hasOption(""String_Node_Str""))) {
      throw new ParseException(""String_Node_Str"");
    }
    if (line.hasOption(""String_Node_Str"") && line.hasOption(""String_Node_Str"")) {
      throw new ParseException(""String_Node_Str"");
    }
    if (line.hasOption(""String_Node_Str"")) {
      LoggingUtils.setDefaultLogLevel(LoggingUtils.INFO);
    }
    if (line.hasOption(""String_Node_Str"")) {
      LoggingUtils.setDefaultLogLevel(LoggingUtils.DEBUG);
    }
    if (line.hasOption(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      HadoopUtils.setupLocalRunner(conf);
    }
    String outputbase=line.getOptionValue(""String_Node_Str"");
    if (line.hasOption(""String_Node_Str"")) {
      maxTiles=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
    }
    useRand=line.hasOption(""String_Node_Str"");
    boolean all=line.hasOption(""String_Node_Str"");
    boolean singleImage=line.hasOption(""String_Node_Str"");
    mosaicTiles=line.hasOption(""String_Node_Str"");
    if (mosaicTiles) {
      mosaicTileCount=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
    }
    useBounds=line.hasOption(""String_Node_Str"");
    if (useBounds) {
      final String boundsOption=line.getOptionValue(""String_Node_Str"");
      bounds=parseBounds(boundsOption);
    }
    if (line.hasOption(""String_Node_Str"")) {
      colorscale=ColorScaleManager.fromName(line.getOptionValue(""String_Node_Str""));
    }
    if (line.hasOption(""String_Node_Str"")) {
      maxSizeInKb=SparkUtils.humantokb(line.getOptionValue(""String_Node_Str""));
    }
    boolean useTileSet=line.hasOption(""String_Node_Str"");
    if (useTileSet) {
      tileset=new HashSet<Long>();
      final String tileIdOption=line.getOptionValue(""String_Node_Str"");
      final String[] tileIds=tileIdOption.split(""String_Node_Str"");
      for (      final String tileId : tileIds) {
        tileset.add(Long.valueOf(tileId));
      }
    }
    int zoomlevel=-1;
    if (line.hasOption(""String_Node_Str"")) {
      zoomlevel=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
    }
    String format=""String_Node_Str"";
    if (line.hasOption(""String_Node_Str"")) {
      format=line.getOptionValue(""String_Node_Str"");
    }
    useTMS=line.hasOption(""String_Node_Str"");
    if (maxSizeInKb > 0 && !singleImage) {
      throw new ParseException(""String_Node_Str"");
    }
    for (    final String arg : line.getArgs()) {
      MrsPyramid imagePyramid;
      MrsPyramid pyramid=null;
      String pyramidName=""String_Node_Str"";
      try {
        MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(arg,DataProviderFactory.AccessMode.READ,providerProperties);
        imagePyramid=MrsPyramid.open(dp);
        pyramidName=dp.getSimpleResourceName();
        pyramid=imagePyramid;
      }
 catch (      IOException e) {
        imagePyramid=null;
      }
      if (imagePyramid == null) {
        throw new ParseException(""String_Node_Str"");
      }
      MrsPyramidMetadata meta=pyramid.getMetadata();
      ColorScaleApplier applier=null;
      if (colorscale != null || !""String_Node_Str"".equalsIgnoreCase(format)) {
switch (format) {
case ""String_Node_Str"":
case ""String_Node_Str"":
          applier=new JpegColorScaleApplier();
        break;
case ""String_Node_Str"":
case ""String_Node_Str"":
default :
      applier=new PngColorScaleApplier();
    break;
}
}
if (maxSizeInKb > 0) {
MrGeoRaster raster=pyramid.getHighestResImage().getRaster();
int bytesPerPixelPerBand=(applier != null) ? applier.getBytesPerPixelPerBand() : raster.bytesPerPixel();
int bands=(applier != null) ? applier.getBands(raster) : 1;
Bounds b=(useBounds) ? bounds : pyramid.getBounds();
int maxZoom=pyramid.getMaximumLevel();
zoomlevel=RasterUtils.getMaxPixelsForSize(maxSizeInKb,b,bytesPerPixelPerBand,bands,meta.getTilesize()).getZoom();
zoomlevel=Math.min(zoomlevel,maxZoom);
System.out.println(""String_Node_Str"" + zoomlevel);
}
 else if (zoomlevel <= 0) {
zoomlevel=pyramid.getMaximumLevel();
}
int end=zoomlevel;
if (all) {
end=1;
}
while (zoomlevel >= end) {
if (!useTileSet && line.hasOption(""String_Node_Str"")) {
  tileset=new HashSet<Long>();
  final String pointsOption=line.getOptionValue(""String_Node_Str"");
  final String[] points=pointsOption.split(""String_Node_Str"");
  if (points.length % 2 != 0) {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < points.length; i+=2) {
    double lon=Double.valueOf(points[i].trim());
    double lat=Double.valueOf(points[i + 1].trim());
    Tile pointTile=TMSUtils.latLonToTile(lat,lon,zoomlevel,pyramid.getTileSize());
    tileset.add(Long.valueOf(TMSUtils.tileid(pointTile.getTx(),pointTile.getTy(),zoomlevel)));
  }
}
MrsImage image=imagePyramid.getImage(zoomlevel);
try {
  final Set<Long> tiles=calculateTiles(pyramid,zoomlevel);
  int tilesize=imagePyramid.getTileSize();
  if (singleImage) {
    String ob=outputbase;
    if (all) {
      ob+=""String_Node_Str"" + zoomlevel;
    }
    saveMultipleTiles(ob,pyramidName,format,image,applier,ArrayUtils.toPrimitive(tiles.toArray(new Long[tiles.size()])),providerProperties);
  }
 else   if (mosaicTiles && mosaicTileCount > 0) {
    if (!outputbase.contains(X) || !outputbase.contains(Y) || !outputbase.contains(LAT)|| !outputbase.contains(LON)) {
      outputbase=outputbase + ""String_Node_Str"";
    }
    for (    final Long tileid : tiles) {
      final Tile t=TMSUtils.tileid(tileid,zoomlevel);
      final Set<Long> tilesToMosaic=new HashSet<>();
      final LongRectangle tileBounds=pyramid.getTileBounds(zoomlevel);
      for (long ty1=t.ty; ((ty1 < (t.ty + mosaicTileCount)) && (ty1 <= tileBounds.getMaxY())); ty1++) {
        for (long tx1=t.tx; ((tx1 < (t.tx + mosaicTileCount)) && (tx1 <= tileBounds.getMaxX())); tx1++) {
          tilesToMosaic.add(TMSUtils.tileid(tx1,ty1,zoomlevel));
        }
      }
      saveMultipleTiles(outputbase,pyramidName,format,image,applier,ArrayUtils.toPrimitive(tilesToMosaic.toArray(new Long[tilesToMosaic.size()])),providerProperties);
    }
  }
 else {
    for (    final Long tileid : tiles) {
      saveSingleTile(outputbase,pyramidName,image,applier,format,tileid,zoomlevel,tilesize,providerProperties);
    }
  }
}
  finally {
  if (image != null) {
    image.close();
  }
}
zoomlevel--;
}
}
return 0;
}
 catch (ColorScale.ColorScaleException|IOException e) {
log.error(""String_Node_Str"",e);
}
return -1;
}","@Override @SuppressWarnings(""String_Node_Str"") public int run(CommandLine line,Configuration conf,ProviderProperties providerProperties) throws ParseException {
  log.info(""String_Node_Str"");
  try {
    if (line.hasOption(""String_Node_Str"") && (line.hasOption(""String_Node_Str"") || line.hasOption(""String_Node_Str"") || line.hasOption(""String_Node_Str"")|| line.hasOption(""String_Node_Str""))) {
      throw new ParseException(""String_Node_Str"");
    }
    if (line.hasOption(""String_Node_Str"") && line.hasOption(""String_Node_Str"")) {
      throw new ParseException(""String_Node_Str"");
    }
    if (line.hasOption(""String_Node_Str"")) {
      LoggingUtils.setDefaultLogLevel(LoggingUtils.INFO);
    }
    if (line.hasOption(""String_Node_Str"")) {
      LoggingUtils.setDefaultLogLevel(LoggingUtils.DEBUG);
    }
    if (line.hasOption(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      HadoopUtils.setupLocalRunner(conf);
    }
    String outputbase=line.getOptionValue(""String_Node_Str"");
    if (line.hasOption(""String_Node_Str"")) {
      maxTiles=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
    }
    useRand=line.hasOption(""String_Node_Str"");
    boolean all=line.hasOption(""String_Node_Str"");
    boolean singleImage=line.hasOption(""String_Node_Str"");
    mosaicTiles=line.hasOption(""String_Node_Str"");
    if (mosaicTiles) {
      mosaicTileCount=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
    }
    useBounds=line.hasOption(""String_Node_Str"");
    if (useBounds) {
      final String boundsOption=line.getOptionValue(""String_Node_Str"");
      bounds=parseBounds(boundsOption);
    }
    if (line.hasOption(""String_Node_Str"")) {
      colorscale=ColorScaleManager.fromName(line.getOptionValue(""String_Node_Str""));
    }
    if (line.hasOption(""String_Node_Str"")) {
      maxSizeInKb=SparkUtils.humantokb(line.getOptionValue(""String_Node_Str""));
    }
    boolean useTileSet=line.hasOption(""String_Node_Str"");
    if (useTileSet) {
      tileset=new HashSet<Long>();
      final String tileIdOption=line.getOptionValue(""String_Node_Str"");
      final String[] tileIds=tileIdOption.split(""String_Node_Str"");
      for (      final String tileId : tileIds) {
        tileset.add(Long.valueOf(tileId));
      }
    }
    int zoomlevel=-1;
    if (line.hasOption(""String_Node_Str"")) {
      zoomlevel=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
    }
    String format=""String_Node_Str"";
    if (line.hasOption(""String_Node_Str"")) {
      format=line.getOptionValue(""String_Node_Str"");
    }
    useTMS=line.hasOption(""String_Node_Str"");
    if (maxSizeInKb > 0 && !singleImage) {
      throw new ParseException(""String_Node_Str"");
    }
    for (    final String arg : line.getArgs()) {
      MrsPyramid imagePyramid;
      MrsPyramid pyramid=null;
      String pyramidName=""String_Node_Str"";
      try {
        MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(arg,DataProviderFactory.AccessMode.READ,providerProperties);
        imagePyramid=MrsPyramid.open(dp);
        pyramidName=dp.getSimpleResourceName();
        pyramid=imagePyramid;
      }
 catch (      IOException e) {
        imagePyramid=null;
      }
      if (imagePyramid == null) {
        throw new ParseException(""String_Node_Str"");
      }
      MrsPyramidMetadata meta=pyramid.getMetadata();
      ColorScaleApplier applier=null;
      if (colorscale != null || !""String_Node_Str"".equalsIgnoreCase(format)) {
switch (format) {
case ""String_Node_Str"":
case ""String_Node_Str"":
          applier=new JpegColorScaleApplier();
        break;
case ""String_Node_Str"":
case ""String_Node_Str"":
default :
      applier=new PngColorScaleApplier();
    break;
}
}
if (maxSizeInKb > 0) {
MrGeoRaster rasterForAnyTile=pyramid.getHighestResImage().getAnyTile();
int bytesPerPixelPerBand=(applier != null) ? applier.getBytesPerPixelPerBand() : rasterForAnyTile.bytesPerPixel();
int bands=(applier != null) ? applier.getBands(pyramid.getMetadata().getBands()) : 1;
Bounds b=(useBounds) ? bounds : pyramid.getBounds();
int maxZoom=pyramid.getMaximumLevel();
zoomlevel=RasterUtils.getMaxPixelsForSize(maxSizeInKb,b,bytesPerPixelPerBand,bands,meta.getTilesize()).getZoom();
zoomlevel=Math.min(zoomlevel,maxZoom);
System.out.println(""String_Node_Str"" + zoomlevel);
}
 else if (zoomlevel <= 0) {
zoomlevel=pyramid.getMaximumLevel();
}
int end=zoomlevel;
if (all) {
end=1;
}
while (zoomlevel >= end) {
if (!useTileSet && line.hasOption(""String_Node_Str"")) {
  tileset=new HashSet<Long>();
  final String pointsOption=line.getOptionValue(""String_Node_Str"");
  final String[] points=pointsOption.split(""String_Node_Str"");
  if (points.length % 2 != 0) {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < points.length; i+=2) {
    double lon=Double.valueOf(points[i].trim());
    double lat=Double.valueOf(points[i + 1].trim());
    Tile pointTile=TMSUtils.latLonToTile(lat,lon,zoomlevel,pyramid.getTileSize());
    tileset.add(Long.valueOf(TMSUtils.tileid(pointTile.getTx(),pointTile.getTy(),zoomlevel)));
  }
}
MrsImage image=imagePyramid.getImage(zoomlevel);
try {
  final Set<Long> tiles=calculateTiles(pyramid,zoomlevel);
  int tilesize=imagePyramid.getTileSize();
  if (singleImage) {
    String ob=outputbase;
    if (all) {
      ob+=""String_Node_Str"" + zoomlevel;
    }
    saveMultipleTiles(ob,pyramidName,format,image,applier,ArrayUtils.toPrimitive(tiles.toArray(new Long[tiles.size()])),providerProperties);
  }
 else   if (mosaicTiles && mosaicTileCount > 0) {
    if (!outputbase.contains(X) || !outputbase.contains(Y) || !outputbase.contains(LAT)|| !outputbase.contains(LON)) {
      outputbase=outputbase + ""String_Node_Str"";
    }
    for (    final Long tileid : tiles) {
      final Tile t=TMSUtils.tileid(tileid,zoomlevel);
      final Set<Long> tilesToMosaic=new HashSet<>();
      final LongRectangle tileBounds=pyramid.getTileBounds(zoomlevel);
      for (long ty1=t.ty; ((ty1 < (t.ty + mosaicTileCount)) && (ty1 <= tileBounds.getMaxY())); ty1++) {
        for (long tx1=t.tx; ((tx1 < (t.tx + mosaicTileCount)) && (tx1 <= tileBounds.getMaxX())); tx1++) {
          tilesToMosaic.add(TMSUtils.tileid(tx1,ty1,zoomlevel));
        }
      }
      saveMultipleTiles(outputbase,pyramidName,format,image,applier,ArrayUtils.toPrimitive(tilesToMosaic.toArray(new Long[tilesToMosaic.size()])),providerProperties);
    }
  }
 else {
    for (    final Long tileid : tiles) {
      saveSingleTile(outputbase,pyramidName,image,applier,format,tileid,zoomlevel,tilesize,providerProperties);
    }
  }
}
  finally {
  if (image != null) {
    image.close();
  }
}
zoomlevel--;
}
}
return 0;
}
 catch (ColorScale.ColorScaleException|IOException e) {
log.error(""String_Node_Str"",e);
}
return -1;
}","The original code used `getRaster()` which might return null or cause performance issues when accessing tile data. The fixed code replaces this with `getAnyTile()`, which guarantees a non-null raster and provides more reliable tile retrieval. This change improves robustness by ensuring consistent tile access and preventing potential null pointer exceptions during image processing."
94367,"@Override public void addOptions(Options options){
  final Option output=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  output.setRequired(true);
  options.addOption(output);
  final Option zoom=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  zoom.setRequired(false);
  options.addOption(zoom);
  final Option count=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  count.setRequired(false);
  options.addOption(count);
  final Option mosaic=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  mosaic.setRequired(false);
  options.addOption(mosaic);
  final Option fmt=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  fmt.setRequired(false);
  options.addOption(fmt);
  final Option random=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  random.setRequired(false);
  options.addOption(random);
  final Option single=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  single.setRequired(false);
  options.addOption(single);
  final Option tms=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  tms.setRequired(false);
  options.addOption(tms);
  final Option color=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  color.setRequired(false);
  options.addOption(color);
  final Option maxImageSize=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  maxImageSize.setRequired(false);
  options.addOption(maxImageSize);
  final Option tileIds=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  tileIds.setRequired(false);
  options.addOption(tileIds);
  final Option points=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  points.setRequired(false);
  options.addOption(points);
  final Option bounds=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  bounds.setRequired(false);
  options.addOption(bounds);
  final Option all=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  all.setRequired(false);
  options.addOption(all);
}","@Override public void addOptions(Options options){
  final Option maxImageSize=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  maxImageSize.setRequired(false);
  options.addOption(maxImageSize);
  final Option output=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  output.setRequired(true);
  options.addOption(output);
  final Option zoom=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  zoom.setRequired(false);
  options.addOption(zoom);
  final Option count=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  count.setRequired(false);
  options.addOption(count);
  final Option mosaic=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  mosaic.setRequired(false);
  options.addOption(mosaic);
  final Option fmt=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  fmt.setRequired(false);
  options.addOption(fmt);
  final Option random=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  random.setRequired(false);
  options.addOption(random);
  final Option single=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  single.setRequired(false);
  options.addOption(single);
  final Option tms=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  tms.setRequired(false);
  options.addOption(tms);
  final Option color=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  color.setRequired(false);
  options.addOption(color);
  final Option tileIds=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  tileIds.setRequired(false);
  options.addOption(tileIds);
  final Option points=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  points.setRequired(false);
  options.addOption(points);
  final Option bounds=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  bounds.setRequired(false);
  options.addOption(bounds);
  final Option all=new Option(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  all.setRequired(false);
  options.addOption(all);
}","The original code had no logical order in adding options, which could lead to unpredictable option parsing and potential configuration errors. The fixed code moves the `maxImageSize` option earlier in the sequence and maintains a more consistent and intentional option declaration order. This reordering improves code readability, makes option management more predictable, and ensures a more structured approach to command-line option configuration."
94368,public abstract int getBands(final MrGeoRaster raster);,public abstract int getBands(final int sourceBands);,"The original method signature incorrectly used MrGeoRaster as a parameter, which limits flexibility and suggests passing an entire raster object instead of specifying band count. The fixed code replaces the raster parameter with a simple integer parameter (sourceBands), directly representing the number of bands to be processed. This modification allows more precise, lightweight band specification and enables easier method implementation across different raster processing scenarios."
94369,"@Override public int getBands(final MrGeoRaster raster){
  return 3;
}","@Override public int getBands(final int sourceBands){
  return 3;
}","The original code incorrectly uses a MrGeoRaster parameter, which is likely not the intended method signature for getBands(). The fixed code changes the parameter to an integer sourceBands, providing a clear and explicit way to specify the number of bands to return. This modification makes the method more flexible and precise, allowing direct control over the band count while maintaining the method's original intent of returning a fixed number of bands."
94370,"@Override public MrGeoRaster applyColorScale(final MrGeoRaster raster,ColorScale colorScale,final double[] extrema,final double[] defaultValues,final double[][] quantiles) throws ColorScale.ColorScaleException {
  try {
    MrGeoRaster colored=MrGeoRaster.createEmptyRaster(raster.width(),raster.height(),getBands(raster),DataBuffer.TYPE_BYTE);
    colored.fill(RasterUtils.getDefaultNoDataForType(DataBuffer.TYPE_BYTE));
    setupExtrema(colorScale,extrema,defaultValues[0],(quantiles == null || quantiles.length == 0) ? null : quantiles[0]);
    apply(raster,colored,colorScale);
    return colored;
  }
 catch (  MrGeoRaster.MrGeoRasterException e) {
    throw new ColorScale.ColorScaleException(e);
  }
}","@Override public MrGeoRaster applyColorScale(final MrGeoRaster raster,ColorScale colorScale,final double[] extrema,final double[] defaultValues,final double[][] quantiles) throws ColorScale.ColorScaleException {
  try {
    MrGeoRaster colored=MrGeoRaster.createEmptyRaster(raster.width(),raster.height(),getBands(raster.bands()),DataBuffer.TYPE_BYTE);
    colored.fill(RasterUtils.getDefaultNoDataForType(DataBuffer.TYPE_BYTE));
    setupExtrema(colorScale,extrema,defaultValues[0],(quantiles == null || quantiles.length == 0) ? null : quantiles[0]);
    apply(raster,colored,colorScale);
    return colored;
  }
 catch (  MrGeoRaster.MrGeoRasterException e) {
    throw new ColorScale.ColorScaleException(e);
  }
}","The buggy code incorrectly used `getBands(raster)`, which doesn't specify the number of bands for the raster. The fixed code uses `getBands(raster.bands())`, correctly retrieving the band count from the raster's bands method. This change ensures accurate raster creation with the correct number of bands, preventing potential data loss or rendering errors during color scaling."
94371,"@Override public int getBands(final MrGeoRaster raster){
  return raster.bands() == 3 ? 3 : 4;
}","@Override public int getBands(final int sourceBands){
  return sourceBands == 3 ? 3 : 4;
}","The original code incorrectly assumed a direct method call on the raster object to determine band count, which may not always be reliable or available. The fixed code now accepts the number of bands as a direct parameter, allowing more flexible and explicit band count specification. This change ensures more robust and predictable band determination by directly using the input parameter instead of relying on a potentially inconsistent method call."
94372,"@Override public MrGeoRaster applyColorScale(final MrGeoRaster raster,ColorScale colorScale,final double[] extrema,final double[] defaultValues,final double[][] quantiles) throws ColorScale.ColorScaleException {
  try {
    MrGeoRaster colored=MrGeoRaster.createEmptyRaster(raster.width(),raster.height(),getBands(raster),DataBuffer.TYPE_BYTE);
    colored.fill(RasterUtils.getDefaultNoDataForType(DataBuffer.TYPE_BYTE));
    setupExtrema(colorScale,extrema,defaultValues[0],(quantiles == null || quantiles.length == 0) ? null : quantiles[0]);
    apply(raster,colored,colorScale);
    return colored;
  }
 catch (  MrGeoRaster.MrGeoRasterException e) {
    throw new ColorScale.ColorScaleException(e);
  }
}","@Override public MrGeoRaster applyColorScale(final MrGeoRaster raster,ColorScale colorScale,final double[] extrema,final double[] defaultValues,final double[][] quantiles) throws ColorScale.ColorScaleException {
  try {
    MrGeoRaster colored=MrGeoRaster.createEmptyRaster(raster.width(),raster.height(),getBands(raster.bands()),DataBuffer.TYPE_BYTE);
    colored.fill(RasterUtils.getDefaultNoDataForType(DataBuffer.TYPE_BYTE));
    setupExtrema(colorScale,extrema,defaultValues[0],(quantiles == null || quantiles.length == 0) ? null : quantiles[0]);
    apply(raster,colored,colorScale);
    return colored;
  }
 catch (  MrGeoRaster.MrGeoRasterException e) {
    throw new ColorScale.ColorScaleException(e);
  }
}","The original code incorrectly used `getBands(raster)`, which lacks context for retrieving band information. In the fixed code, `getBands(raster.bands())` correctly retrieves the number of bands from the raster object, ensuring proper raster creation. This modification provides a more robust and precise method for determining the raster's band configuration, preventing potential errors in raster generation."
94373,"private boolean saveSingleTile(final String output,final String pyramidName,final MrsImage image,String format,final long tileid,final int zoom,int tilesize,ProviderProperties providerProperties){
  try {
    final MrsPyramidMetadata metadata=image.getMetadata();
    final Tile t=TMSUtils.tileid(tileid,zoom);
    MrGeoRaster raster=image.getTile(t.tx,t.ty);
    log.info(""String_Node_Str"" + t.tx + ""String_Node_Str""+ t.ty);
    if (raster != null) {
      String out=makeOutputName(output,pyramidName,format,tileid,zoom,tilesize,true);
      if (colorscale != null || !format.equals(""String_Node_Str"")) {
        if (colorscale == null) {
          MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(pyramidName,DataProviderFactory.AccessMode.READ,providerProperties);
          MrsPyramidMetadata meta=dp.getMetadataReader().read();
          String csname=meta.getTag(MrGeoConstants.MRGEO_DEFAULT_COLORSCALE);
          if (csname != null) {
            try {
              colorscale=ColorScaleManager.fromName(csname);
            }
 catch (            ColorScale.ColorScaleException ignored) {
            }
            if (colorscale == null) {
              throw new IOException(""String_Node_Str"" + csname);
            }
          }
 else {
            colorscale=ColorScale.createDefaultGrayScale();
          }
        }
        raster=colorRaster(image,format,raster);
      }
      Bounds bnds=TMSUtils.tileBounds(t.tx,t.ty,image.getZoomlevel(),metadata.getTilesize());
      GDALJavaUtils.saveRasterTile(raster.toDataset(bnds,metadata.getDefaultValues()),out,t.tx,t.ty,image.getZoomlevel(),metadata.getDefaultValue(0),format);
      System.out.println(""String_Node_Str"" + out);
      return true;
    }
    log.info(""String_Node_Str"");
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
  }
  return false;
}","private boolean saveSingleTile(final String output,final String pyramidName,final MrsImage image,String format,final long tileid,final int zoom,int tilesize,ProviderProperties providerProperties){
  try {
    final MrsPyramidMetadata metadata=image.getMetadata();
    final Tile t=TMSUtils.tileid(tileid,zoom);
    MrGeoRaster raster=image.getTile(t.tx,t.ty);
    log.info(""String_Node_Str"" + t.tx + ""String_Node_Str""+ t.ty);
    if (raster != null) {
      String out=makeOutputName(output,pyramidName,format,tileid,zoom,tilesize,true);
      if (colorscale != null || !format.equals(""String_Node_Str"")) {
        if (colorscale == null) {
          MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(pyramidName,DataProviderFactory.AccessMode.READ,providerProperties);
          MrsPyramidMetadata meta=dp.getMetadataReader().read();
          String csname=meta.getTag(MrGeoConstants.MRGEO_DEFAULT_COLORSCALE);
          if (csname != null) {
            try {
              colorscale=ColorScaleManager.fromName(csname);
            }
 catch (            ColorScale.ColorScaleException ignored) {
            }
            if (colorscale == null) {
              throw new IOException(""String_Node_Str"" + csname);
            }
          }
 else {
            colorscale=ColorScale.createDefaultGrayScale();
          }
        }
        raster=colorRaster(image,format,raster);
      }
      Bounds bnds=TMSUtils.tileBounds(t.tx,t.ty,image.getZoomlevel(),metadata.getTilesize());
      GDALJavaUtils.saveRasterTile(raster.toDataset(bnds,metadata.getDefaultValues()),out,t.tx,t.ty,image.getZoomlevel(),metadata.getDefaultValue(0),format);
      System.out.println(""String_Node_Str"" + out);
      return true;
    }
    log.info(""String_Node_Str"");
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
  }
catch (  TileNotFoundException e) {
  }
  return false;
}","The original code lacked handling for the TileNotFoundException, which could cause unexpected program termination when a tile is not found. The fixed code adds a catch block for TileNotFoundException, preventing unhandled exceptions and allowing graceful error management. This improvement enhances the method's robustness by ensuring that even if a tile cannot be retrieved, the method returns false without crashing the entire process."
94374,"@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public static String findMrGeoConf() throws IOException {
  String conf=System.getenv(MrGeoConstants.MRGEO_CONF_DIR);
  if (conf == null) {
    String home=System.getenv(MrGeoConstants.MRGEO_HOME);
    File dir=new File(home,MrGeoConstants.MRGEO_HOME_CONF_DIR);
    if (dir.exists()) {
      log.error(MrGeoConstants.MRGEO_HOME + ""String_Node_Str"" + ""String_Node_Str""+ MrGeoConstants.MRGEO_CONF_DIR+ ""String_Node_Str""+ MrGeoConstants.MRGEO_COMMON_HOME+ ""String_Node_Str"");
      conf=dir.getCanonicalPath();
    }
  }
  File file=new File(conf,MrGeoConstants.MRGEO_CONF);
  if (file.exists()) {
    return file.getCanonicalPath();
  }
  throw new IOException(MrGeoConstants.MRGEO_CONF_DIR + ""String_Node_Str"" + file.getCanonicalPath());
}","@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public static String findMrGeoConf() throws IOException {
  String conf=System.getenv(MrGeoConstants.MRGEO_CONF_DIR);
  if (conf == null) {
    String home=System.getenv(MrGeoConstants.MRGEO_HOME);
    if (home != null) {
      File dir=new File(home,MrGeoConstants.MRGEO_HOME_CONF_DIR);
      if (dir.exists()) {
        log.error(MrGeoConstants.MRGEO_HOME + ""String_Node_Str"" + ""String_Node_Str""+ MrGeoConstants.MRGEO_CONF_DIR+ ""String_Node_Str""+ MrGeoConstants.MRGEO_COMMON_HOME+ ""String_Node_Str"");
        conf=dir.getCanonicalPath();
      }
    }
  }
  if (conf == null) {
    conf=System.getProperty(MrGeoConstants.MRGEO_CONF_DIR);
  }
  if (conf != null) {
    File file=new File(conf,MrGeoConstants.MRGEO_CONF);
    if (file.exists()) {
      return file.getCanonicalPath();
    }
    throw new IOException(MrGeoConstants.MRGEO_CONF_DIR + ""String_Node_Str"" + file.getCanonicalPath());
  }
  throw new IOException(MrGeoConstants.MRGEO_CONF_DIR + ""String_Node_Str"");
}","The original code lacks null checks for the home environment variable, potentially causing NullPointerExceptions when attempting to construct configuration paths. The fixed code adds explicit null checks for the home environment variable and introduces a fallback mechanism using System.getProperty() to ensure a valid configuration directory can be located. These improvements make the method more robust by preventing null pointer errors and providing multiple strategies for finding the configuration directory, thus enhancing error handling and configuration discovery."
94375,"private static AdHocDataProvider createAdHocDataProvider(final Configuration conf,final ProviderProperties props) throws DataProviderNotFound, DataProviderException {
  initialize(conf);
  for (  final AdHocDataProviderFactory factory : adHocProviderFactories.values()) {
    AdHocDataProvider provider;
    try {
      provider=factory.createAdHocDataProvider(props);
    }
 catch (    IOException e) {
      throw new DataProviderException(""String_Node_Str"",e);
    }
    adHocProviderCache.put(provider.getResourceName(),provider);
    return provider;
  }
  throw new DataProviderNotFound(""String_Node_Str"");
}","private static AdHocDataProvider createAdHocDataProvider(final Configuration conf,final ProviderProperties props) throws DataProviderNotFound, DataProviderException {
  initialize(conf);
  for (  final AdHocDataProviderFactory factory : adHocProviderFactories.values()) {
    AdHocDataProvider provider;
    try {
      provider=factory.createAdHocDataProvider(conf,props);
    }
 catch (    IOException e) {
      throw new DataProviderException(""String_Node_Str"",e);
    }
    adHocProviderCache.put(provider.getResourceName(),provider);
    return provider;
  }
  throw new DataProviderNotFound(""String_Node_Str"");
}","The original code incorrectly called `createAdHocDataProvider()` with only `props`, potentially missing required configuration parameters. The fixed code adds `conf` as an additional argument to the factory method, ensuring the data provider is created with both configuration and properties. This modification provides a more comprehensive and robust data provider initialization process, improving the method's flexibility and error handling."
94376,"private static MrsImageDataProvider createTempMrsImageDataProvider(final Configuration conf,final ProviderProperties providerProperties) throws DataProviderNotFound, DataProviderException {
  initialize(conf);
  for (  final MrsImageDataProviderFactory factory : mrsImageProviderFactories.values()) {
    MrsImageDataProvider provider;
    try {
      provider=factory.createTempMrsImageDataProvider(providerProperties);
    }
 catch (    IOException e) {
      throw new DataProviderException(""String_Node_Str"",e);
    }
    mrsImageProviderCache.put(provider.getResourceName(),provider);
    return provider;
  }
  throw new DataProviderException(""String_Node_Str"");
}","private static MrsImageDataProvider createTempMrsImageDataProvider(final Configuration conf,final ProviderProperties providerProperties) throws DataProviderNotFound, DataProviderException {
  initialize(conf);
  for (  final MrsImageDataProviderFactory factory : mrsImageProviderFactories.values()) {
    MrsImageDataProvider provider;
    try {
      provider=factory.createTempMrsImageDataProvider(conf,providerProperties);
    }
 catch (    IOException e) {
      throw new DataProviderException(""String_Node_Str"",e);
    }
    mrsImageProviderCache.put(provider.getResourceName(),provider);
    return provider;
  }
  throw new DataProviderException(""String_Node_Str"");
}","The original code incorrectly called `createTempMrsImageDataProvider` without passing the `conf` parameter to the factory method. The fixed code adds the `conf` argument when invoking the factory method, ensuring the configuration is properly passed to the provider creation process. This correction allows the temporary MRS image data provider to be created with the correct configuration, potentially preventing runtime errors and improving method reliability."
94377,"/** 
 * Returns a list of vectors available from all data sources. The names returned can be subsequently passed as the name parameter to getVectorDataProvider().
 * @return
 * @throws IOException
 */
public static String[] listVectors(final ProviderProperties providerProperties) throws IOException {
  initialize(getBasicConfig());
  List<String> results=new ArrayList<String>();
  for (  final VectorDataProviderFactory factory : vectorProviderFactories.values()) {
    String[] vectors=factory.listVectors(providerProperties);
    if (vectors != null && vectors.length > 0) {
      results.addAll(Arrays.asList(vectors));
    }
  }
  String[] returnValue=new String[results.size()];
  return results.toArray(returnValue);
}","/** 
 * Returns a list of vectors available from all data sources. The names returned can be subsequently passed as the name parameter to getVectorDataProvider().
 * @return
 * @throws IOException
 */
public static String[] listVectors(final ProviderProperties providerProperties) throws IOException {
  Configuration conf=getBasicConfig();
  initialize(conf);
  List<String> results=new ArrayList<String>();
  for (  final VectorDataProviderFactory factory : vectorProviderFactories.values()) {
    String[] vectors=factory.listVectors(conf,providerProperties);
    if (vectors != null && vectors.length > 0) {
      results.addAll(Arrays.asList(vectors));
    }
  }
  String[] returnValue=new String[results.size()];
  return results.toArray(returnValue);
}","The original code incorrectly called `listVectors()` on the factory with only `providerProperties`, likely missing a required configuration parameter. The fixed code passes both `conf` and `providerProperties` to `listVectors()`, ensuring the method receives the necessary configuration context. This modification improves method compatibility and prevents potential runtime errors by providing a complete set of parameters for vector data provider initialization."
94378,"private VectorDataProviderFactory findFactory() throws IOException {
  boolean debugEnabled=log.isDebugEnabled();
  if (debugEnabled) {
    log.debug(""String_Node_Str"" + ((prefix != null) ? prefix : ""String_Node_Str"") + ""String_Node_Str""+ name);
    log.debug(""String_Node_Str"" + vectorProviderFactories.size());
  }
  if (prefix != null) {
    if (vectorProviderFactories.containsKey(prefix)) {
      if (debugEnabled) {
        log.debug(""String_Node_Str"" + vectorProviderFactories.get(prefix).getClass().getName());
      }
      return vectorProviderFactories.get(prefix);
    }
  }
  for (  final VectorDataProviderFactory factory : vectorProviderFactories.values()) {
    if (debugEnabled) {
      log.debug(""String_Node_Str"" + factory.getClass().getName());
    }
    if (factory.exists(name,props)) {
      if (debugEnabled) {
        log.debug(""String_Node_Str"" + factory.getClass().getName());
      }
      return factory;
    }
    if (debugEnabled) {
      log.debug(""String_Node_Str"" + name);
    }
  }
  if (debugEnabled) {
    log.debug(""String_Node_Str"");
  }
  return null;
}","private VectorDataProviderFactory findFactory() throws IOException {
  boolean debugEnabled=log.isDebugEnabled();
  if (debugEnabled) {
    log.debug(""String_Node_Str"" + ((prefix != null) ? prefix : ""String_Node_Str"") + ""String_Node_Str""+ name);
    log.debug(""String_Node_Str"" + vectorProviderFactories.size());
  }
  if (prefix != null) {
    if (vectorProviderFactories.containsKey(prefix)) {
      if (debugEnabled) {
        log.debug(""String_Node_Str"" + vectorProviderFactories.get(prefix).getClass().getName());
      }
      return vectorProviderFactories.get(prefix);
    }
  }
  for (  final VectorDataProviderFactory factory : vectorProviderFactories.values()) {
    if (debugEnabled) {
      log.debug(""String_Node_Str"" + factory.getClass().getName());
    }
    if (factory.exists(name,conf,props)) {
      if (debugEnabled) {
        log.debug(""String_Node_Str"" + factory.getClass().getName());
      }
      return factory;
    }
    if (debugEnabled) {
      log.debug(""String_Node_Str"" + name);
    }
  }
  if (debugEnabled) {
    log.debug(""String_Node_Str"");
  }
  return null;
}","The original code's `exists()` method call was missing the `conf` parameter, which could lead to incorrect factory selection or runtime errors. The fixed code adds the `conf` parameter to the `exists()` method, ensuring the correct configuration is passed during factory validation. This change improves method reliability by providing the necessary configuration context for determining the appropriate vector data provider factory."
94379,"/** 
 * Returns a list of MrsImages available from all data sources. The names returned can be subsequently passed as the name parameter to getMrsImageDataProvider().
 * @return
 * @throws IOException
 */
public static String[] listImages(final ProviderProperties providerProperties) throws IOException {
  initialize(getBasicConfig());
  List<String> results=new ArrayList<String>();
  for (  final MrsImageDataProviderFactory factory : mrsImageProviderFactories.values()) {
    String[] images=factory.listImages(providerProperties);
    if (images != null && images.length > 0) {
      results.addAll(Arrays.asList(images));
    }
  }
  String[] returnValue=new String[results.size()];
  return results.toArray(returnValue);
}","/** 
 * Returns a list of MrsImages available from all data sources. The names returned can be subsequently passed as the name parameter to getMrsImageDataProvider().
 * @return
 * @throws IOException
 */
public static String[] listImages(final ProviderProperties providerProperties) throws IOException {
  Configuration conf=getBasicConfig();
  initialize(conf);
  List<String> results=new ArrayList<String>();
  for (  final MrsImageDataProviderFactory factory : mrsImageProviderFactories.values()) {
    String[] images=factory.listImages(conf,providerProperties);
    if (images != null && images.length > 0) {
      results.addAll(Arrays.asList(images));
    }
  }
  String[] returnValue=new String[results.size()];
  return results.toArray(returnValue);
}","The original code incorrectly called `listImages()` with only `providerProperties`, which likely did not match the method signature of the underlying factory method. The fixed code passes both `conf` (configuration) and `providerProperties` to `listImages()`, ensuring the correct method is invoked with all required parameters. This modification resolves the potential method invocation error and ensures proper initialization and data retrieval across different image data provider factories."
94380,"@Override public VectorDataProvider call() throws Exception {
  initialize(conf);
  final VectorDataProviderFactory factory=findFactory();
  if (accessMode == AccessMode.READ) {
    if (factory != null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + name + ""String_Node_Str""+ factory.getClass().getName());
      }
      if (factory.canOpen(name,props)) {
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + factory.getClass().getName() + ""String_Node_Str""+ name);
        }
        return factory.createVectorDataProvider(prefix,name,props);
      }
 else {
        if (log.isInfoEnabled()) {
          log.info(""String_Node_Str"" + name + ""String_Node_Str""+ factory.getClass().getName());
        }
      }
    }
 else {
      log.info(""String_Node_Str"" + name);
    }
    String msg=""String_Node_Str"" + name + ""String_Node_Str""+ prefix;
    if (log.isDebugEnabled()) {
      log.debug(msg);
      log.debug(""String_Node_Str"" + vectorProviderFactories.size());
      for (      VectorDataProviderFactory f : vectorProviderFactories.values()) {
        log.debug(f.getPrefix() + ""String_Node_Str"" + f.getClass().getName());
      }
      String cp=System.getProperty(""String_Node_Str"");
      log.debug(""String_Node_Str"" + cp);
    }
    throw new DataProviderNotFound(msg);
  }
 else   if (accessMode == AccessMode.OVERWRITE) {
    if (factory != null) {
      if (factory.exists(name,props)) {
        factory.delete(name,props);
      }
      return factory.createVectorDataProvider(prefix,name,props);
    }
    return getPreferredProvider().createVectorDataProvider(prefix,name,props);
  }
 else {
    if (factory != null) {
      if (factory.canWrite(name,props)) {
        return factory.createVectorDataProvider(prefix,name,props);
      }
      String msg=""String_Node_Str"" + name + ""String_Node_Str""+ prefix;
      if (log.isDebugEnabled()) {
        log.debug(msg);
        log.debug(""String_Node_Str"" + vectorProviderFactories.size());
        for (        VectorDataProviderFactory f : vectorProviderFactories.values()) {
          log.debug(f.getPrefix() + ""String_Node_Str"" + f.getClass().getName());
        }
        String cp=System.getProperty(""String_Node_Str"");
        log.debug(""String_Node_Str"" + cp);
      }
      throw new DataProviderNotFound(msg);
    }
    return getPreferredProvider().createVectorDataProvider(prefix,name,props);
  }
}","@Override public VectorDataProvider call() throws Exception {
  initialize(conf);
  final VectorDataProviderFactory factory=findFactory();
  if (accessMode == AccessMode.READ) {
    if (factory != null) {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + name + ""String_Node_Str""+ factory.getClass().getName());
      }
      if (factory.canOpen(name,conf,props)) {
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + factory.getClass().getName() + ""String_Node_Str""+ name);
        }
        return factory.createVectorDataProvider(prefix,name,conf,props);
      }
 else {
        if (log.isInfoEnabled()) {
          log.info(""String_Node_Str"" + name + ""String_Node_Str""+ factory.getClass().getName());
        }
      }
    }
 else {
      log.info(""String_Node_Str"" + name);
    }
    String msg=""String_Node_Str"" + name + ""String_Node_Str""+ prefix;
    if (log.isDebugEnabled()) {
      log.debug(msg);
      log.debug(""String_Node_Str"" + vectorProviderFactories.size());
      for (      VectorDataProviderFactory f : vectorProviderFactories.values()) {
        log.debug(f.getPrefix() + ""String_Node_Str"" + f.getClass().getName());
      }
      String cp=System.getProperty(""String_Node_Str"");
      log.debug(""String_Node_Str"" + cp);
    }
    throw new DataProviderNotFound(msg);
  }
 else   if (accessMode == AccessMode.OVERWRITE) {
    if (factory != null) {
      if (factory.exists(name,conf,props)) {
        factory.delete(name,conf,props);
      }
      return factory.createVectorDataProvider(prefix,name,conf,props);
    }
    return getPreferredProvider().createVectorDataProvider(prefix,name,conf,props);
  }
 else {
    if (factory != null) {
      if (factory.canWrite(name,conf,props)) {
        return factory.createVectorDataProvider(prefix,name,conf,props);
      }
      String msg=""String_Node_Str"" + name + ""String_Node_Str""+ prefix;
      if (log.isDebugEnabled()) {
        log.debug(msg);
        log.debug(""String_Node_Str"" + vectorProviderFactories.size());
        for (        VectorDataProviderFactory f : vectorProviderFactories.values()) {
          log.debug(f.getPrefix() + ""String_Node_Str"" + f.getClass().getName());
        }
        String cp=System.getProperty(""String_Node_Str"");
        log.debug(""String_Node_Str"" + cp);
      }
      throw new DataProviderNotFound(msg);
    }
    return getPreferredProvider().createVectorDataProvider(prefix,name,conf,props);
  }
}","The original code omitted the `conf` parameter in method calls for `canOpen`, `exists`, `delete`, `canWrite`, and `createVectorDataProvider`, leading to potential configuration-related errors. The fixed code systematically adds the `conf` parameter to all relevant method calls, ensuring proper configuration passing across different access modes. This modification improves method consistency, enables more robust configuration management, and prevents potential runtime configuration-related exceptions."
94381,"protected synchronized static void initialize(final Configuration conf) throws DataProviderException {
  if (adHocProviderFactories == null) {
    log.info(""String_Node_Str"");
    adHocProviderFactories=new HashMap<String,AdHocDataProviderFactory>();
    final ServiceLoader<AdHocDataProviderFactory> dataProviderLoader=ServiceLoader.load(AdHocDataProviderFactory.class);
    for (    final AdHocDataProviderFactory dp : dataProviderLoader) {
      if (configSettings != null) {
        dp.setConfiguration(configSettings);
      }
      if (dp.isValid()) {
        log.info(""String_Node_Str"" + dp.getClass().getName());
        adHocProviderFactories.put(dp.getPrefix(),dp);
        dp.initialize(conf);
      }
 else {
        log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
      }
    }
  }
  if (mrsImageProviderFactories == null) {
    log.info(""String_Node_Str"");
    mrsImageProviderFactories=new HashMap<String,MrsImageDataProviderFactory>();
    final ServiceLoader<MrsImageDataProviderFactory> dataProviderLoader=ServiceLoader.load(MrsImageDataProviderFactory.class);
    for (    final MrsImageDataProviderFactory dp : dataProviderLoader) {
      try {
        if (configSettings != null) {
          dp.setConfiguration(configSettings);
        }
        if (dp.isValid()) {
          log.info(""String_Node_Str"",dp.getPrefix(),dp.getClass().getName());
          mrsImageProviderFactories.put(dp.getPrefix(),dp);
          dp.initialize(conf);
        }
 else {
          log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.warn(""String_Node_Str"" + dp.getClass().getName(),e);
      }
    }
  }
  if (vectorProviderFactories == null) {
    log.info(""String_Node_Str"");
    boolean debugEnabled=log.isDebugEnabled();
    vectorProviderFactories=new HashMap<String,VectorDataProviderFactory>();
    if (debugEnabled) {
      log.debug(""String_Node_Str"");
    }
    final ServiceLoader<VectorDataProviderFactory> dataProviderLoader=ServiceLoader.load(VectorDataProviderFactory.class);
    int count=0;
    for (    final VectorDataProviderFactory dp : dataProviderLoader) {
      try {
        if (debugEnabled) {
          log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ ((conf == null) ? ""String_Node_Str"" : ""String_Node_Str""));
        }
        if (configSettings != null) {
          dp.setConfiguration(configSettings);
        }
        if (dp.isValid()) {
          if (debugEnabled) {
            log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ dp.getPrefix());
          }
          vectorProviderFactories.put(dp.getPrefix(),dp);
          dp.initialize(conf);
          count++;
        }
 else {
          if (debugEnabled) {
            log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ dp.getPrefix());
          }
          log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.warn(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"",e);
      }
    }
    if (count == 0) {
      log.warn(""String_Node_Str"");
    }
  }
  findPreferredProvider(conf);
}","protected synchronized static void initialize(final Configuration conf) throws DataProviderException {
  if (adHocProviderFactories == null) {
    log.info(""String_Node_Str"");
    adHocProviderFactories=new HashMap<String,AdHocDataProviderFactory>();
    final ServiceLoader<AdHocDataProviderFactory> dataProviderLoader=ServiceLoader.load(AdHocDataProviderFactory.class);
    for (    final AdHocDataProviderFactory dp : dataProviderLoader) {
      if (configSettings != null) {
        dp.setConfiguration(configSettings);
      }
      if (dp.isValid(conf)) {
        log.info(""String_Node_Str"" + dp.getClass().getName());
        adHocProviderFactories.put(dp.getPrefix(),dp);
        dp.initialize(conf);
      }
 else {
        log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
      }
    }
  }
  if (mrsImageProviderFactories == null) {
    log.info(""String_Node_Str"");
    mrsImageProviderFactories=new HashMap<String,MrsImageDataProviderFactory>();
    final ServiceLoader<MrsImageDataProviderFactory> dataProviderLoader=ServiceLoader.load(MrsImageDataProviderFactory.class);
    for (    final MrsImageDataProviderFactory dp : dataProviderLoader) {
      try {
        if (configSettings != null) {
          dp.setConfiguration(configSettings);
        }
        if (dp.isValid()) {
          log.info(""String_Node_Str"",dp.getPrefix(),dp.getClass().getName());
          mrsImageProviderFactories.put(dp.getPrefix(),dp);
          dp.initialize(conf);
        }
 else {
          log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.warn(""String_Node_Str"" + dp.getClass().getName(),e);
      }
    }
  }
  if (vectorProviderFactories == null) {
    log.info(""String_Node_Str"");
    boolean debugEnabled=log.isDebugEnabled();
    vectorProviderFactories=new HashMap<String,VectorDataProviderFactory>();
    if (debugEnabled) {
      log.debug(""String_Node_Str"");
    }
    final ServiceLoader<VectorDataProviderFactory> dataProviderLoader=ServiceLoader.load(VectorDataProviderFactory.class);
    int count=0;
    for (    final VectorDataProviderFactory dp : dataProviderLoader) {
      try {
        if (debugEnabled) {
          log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ ((conf == null) ? ""String_Node_Str"" : ""String_Node_Str""));
        }
        if (configSettings != null) {
          dp.setConfiguration(configSettings);
        }
        if (dp.isValid(conf)) {
          if (debugEnabled) {
            log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ dp.getPrefix());
          }
          vectorProviderFactories.put(dp.getPrefix(),dp);
          dp.initialize(conf);
          count++;
        }
 else {
          if (debugEnabled) {
            log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ dp.getPrefix());
          }
          log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.warn(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"",e);
      }
    }
    if (count == 0) {
      log.warn(""String_Node_Str"");
    }
  }
  findPreferredProvider(conf);
}","The original code's `isValid()` method for AdHoc and Vector providers did not take the Configuration parameter, potentially leading to incorrect validation. The fixed code modifies `isValid()` to accept the `Configuration` parameter, enabling more comprehensive validation during provider initialization. This change ensures that providers are validated with full context, improving reliability and preventing potential configuration-related errors during data provider setup."
94382,"private RecordReader<TileIdWritable,RasterWritable> createRecordReader(final MrsPyramidInputSplit split,final TaskAttemptContext context) throws IOException {
  InputSplit initializeWithSplit;
  RecordReader<TileIdWritable,RasterWritable> recordReader=getRecordReader(split.getName(),context.getConfiguration());
  initializeWithSplit=split.getWrappedSplit();
  try {
    recordReader.initialize(initializeWithSplit,context);
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
  return recordReader;
}","private RecordReader<TileIdWritable,RasterWritable> createRecordReader(final MrsPyramidInputSplit split,final TaskAttemptContext context) throws IOException {
  InputSplit initializeWithSplit;
  RecordReader<TileIdWritable,RasterWritable> recordReader=getRecordReader(split.getName(),context.getConfiguration());
  initializeWithSplit=split.getWrappedSplit();
  try {
    recordReader.initialize(initializeWithSplit,context);
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
  return recordReader;
}","The original code caught a generic Exception, which could mask specific error handling for InterruptedException during record reader initialization. The fixed code explicitly catches InterruptedException, providing more precise error handling and maintaining the method's contract. This targeted exception handling improves code clarity and allows for more accurate error tracking and potential recovery mechanisms."
94383,"/** 
 * Give back an ad hoc data provider for a resource that is named by this method. Callers use this if they need to store ad hoc data, but don't care where that data resides. The caller must keep the returned provider instance for as long as they wish to access that ad hoc data.
 * @return
 */
public AdHocDataProvider createAdHocDataProvider(final ProviderProperties providerProperties) throws IOException ;","/** 
 * Give back an ad hoc data provider for a resource that is named by this method. Callers use this if they need to store ad hoc data, but don't care where that data resides. The caller must keep the returned provider instance for as long as they wish to access that ad hoc data.
 * @return
 */
public AdHocDataProvider createAdHocDataProvider(final Configuration conf,final ProviderProperties providerProperties) throws IOException ;","The original method lacks a critical configuration parameter, making it challenging to customize and configure the ad hoc data provider. The fixed code introduces a new `Configuration` parameter, allowing more flexible and context-specific provider initialization with additional settings. By adding the configuration argument, the method now supports more dynamic and adaptable data provider creation, enabling developers to specify runtime-specific parameters and enhance the method's overall versatility."
94384,"/** 
 * Provider implementations should perform any needed checks within this method to determine if the other functions defined in this interface can be called reliably. For example, if the implementation requires some configuration settings in order to work properly, it can use this method to determine if those settings have been defined. Returning false from this method will prevent the provider from being called thereafter.
 * @return
 */
public boolean isValid();","/** 
 * Provider implementations should perform any needed checks within this method to determine if the other functions defined in this interface can be called reliably. For example, if the implementation requires some configuration settings in order to work properly, it can use this method to determine if those settings have been defined. Returning false from this method will prevent the provider from being called thereafter.
 * @return
 */
public boolean isValid(final Configuration conf);","The original code lacks a mechanism to pass configuration details during validation, limiting the method's ability to perform comprehensive checks. The fixed code introduces a Configuration parameter, enabling the method to validate against specific configuration settings dynamically. This enhancement allows for more flexible and context-aware validation, ensuring that providers can thoroughly verify their operational readiness based on the provided configuration."
94385,"public boolean canOpen(final String name,final ProviderProperties providerProperties) throws IOException ;","public boolean canOpen(final String name,final Configuration conf,final ProviderProperties providerProperties) throws IOException ;","The original method lacks a crucial Configuration parameter, which is typically required for resource access and configuration management in distributed systems. The fixed code adds a Configuration argument, enabling more comprehensive resource handling and providing necessary context for opening resources. This enhancement allows for more flexible and configurable resource management, improving the method's robustness and adaptability to different system environments."
94386,"public boolean exists(final String name,final ProviderProperties providerProperties) throws IOException ;","public boolean exists(final String name,final Configuration conf,final ProviderProperties providerProperties) throws IOException ;","The original method lacks a critical parameter (Configuration) needed for proper resource lookup and validation in distributed systems. The fixed version adds the Configuration parameter, enabling more comprehensive resource management and consistent access across different providers and environments. This enhancement improves method flexibility, allowing more robust configuration handling and better integration with various storage and resource management frameworks."
94387,"public boolean canWrite(final String name,final ProviderProperties providerProperties) throws IOException ;","public boolean canWrite(final String name,final Configuration conf,final ProviderProperties providerProperties) throws IOException ;","The original method lacks a critical parameter for configuration, limiting its ability to determine write permissions comprehensively. The fixed code introduces a Configuration parameter, enabling more robust access validation by providing additional context and settings for write operations. This enhancement allows for more flexible and context-aware permission checks, improving the method's functionality and adaptability across different scenarios."
94388,"public void delete(final String name,final ProviderProperties providerProperties) throws IOException ;","public void delete(final String name,final Configuration conf,final ProviderProperties providerProperties) throws IOException ;","The original method lacked a crucial Configuration parameter, which is typically required for provider-related operations to establish necessary context and settings. The fixed code introduces a Configuration parameter between the name and providerProperties arguments, ensuring proper configuration support for the delete operation. This enhancement provides more comprehensive configuration management, enabling more flexible and robust provider-specific deletion processes with complete contextual information."
94389,"/** 
 * Creates a Reprojector from a specified code to another code. The codes take a form similar to ""EPSG:4326"".
 * @param codeSrc
 * @param codeDest
 * @return
 */
public static Reprojector createFromCode(String codeSrc,String codeDest){
  SpatialReference sourceSrs=new SpatialReference();
  int sourceEpsg=parseEpsgCode(codeSrc);
  sourceSrs.ImportFromEPSG(sourceEpsg);
  SpatialReference destSrs=new SpatialReference();
  int destEpsg=parseEpsgCode(codeDest);
  destSrs.ImportFromEPSG(destEpsg);
  return new Reprojector(sourceSrs,destSrs);
}","/** 
 * Creates a Reprojector from a specified code to another code. The codes take a form similar to ""EPSG:4326"".
 * @param codeSrc
 * @param codeDest
 * @return
 */
public static Reprojector createFromCode(String codeSrc,String codeDest){
  SpatialReference sourceSrs=new SpatialReference();
  sourceSrs.SetFromUserInput(codeSrc);
  SpatialReference destSrs=new SpatialReference();
  destSrs.SetFromUserInput(codeDest);
  return new Reprojector(sourceSrs,destSrs);
}","The original code manually parses EPSG codes and uses ImportFromEPSG(), which can be error-prone and less flexible for different coordinate system representations. The fixed code uses SetFromUserInput(), which automatically handles various input formats like ""EPSG:4326"" and supports more robust coordinate system initialization. This change simplifies the code, increases input flexibility, and reduces the potential for parsing errors when creating spatial reference systems."
94390,"/** 
 * Reprojects a bounds to Geographic
 * @param bounds the projected input bounds
 * @param epsg   the epsg string of the projected bounds crs
 * @return geographic bounds
 */
public static Bounds reprojectBounds(final Bounds bounds,final String epsg){
  if (epsg != null && !(epsg.equalsIgnoreCase(""String_Node_Str""))) {
    SpatialReference src=new SpatialReference(GDALUtils.EPSG4326());
    SpatialReference dst=new SpatialReference();
    String[] code=epsg.split(""String_Node_Str"");
    dst.ImportFromEPSG(Integer.parseInt(code[1]));
    CoordinateTransformation tx=new CoordinateTransformation(src,dst);
    double[] c1;
    double[] c2;
    double[] c3;
    double[] c4;
    c1=tx.TransformPoint(bounds.w,bounds.s);
    c2=tx.TransformPoint(bounds.w,bounds.n);
    c3=tx.TransformPoint(bounds.e,bounds.s);
    c4=tx.TransformPoint(bounds.e,bounds.n);
    return new Bounds(Math.min(Math.min(c1[0],c2[0]),Math.min(c3[0],c4[0])),Math.min(Math.min(c1[1],c2[1]),Math.min(c3[1],c4[1])),Math.max(Math.max(c1[0],c2[0]),Math.max(c3[0],c4[0])),Math.max(Math.max(c1[1],c2[1]),Math.max(c3[1],c4[1])));
  }
 else {
    return bounds.clone();
  }
}","/** 
 * Reprojects a bounds to Geographic
 * @param bounds the projected input bounds
 * @param srs   the spatial reference of the projected bounds crs. The format is describedin http://gdal.org/java/org/gdal/osr/SpatialReference.html#SetFromUserInput(java.lang.String). Examples include ""EPSG:4326"" and ""CRS:84"".
 * @return geographic bounds
 */
public static Bounds reprojectBounds(final Bounds bounds,final String srs){
  if (srs != null && !(srs.equalsIgnoreCase(""String_Node_Str""))) {
    SpatialReference src=new SpatialReference(GDALUtils.EPSG4326());
    SpatialReference dst=new SpatialReference();
    dst.SetFromUserInput(srs);
    CoordinateTransformation tx=new CoordinateTransformation(src,dst);
    double[] c1;
    double[] c2;
    double[] c3;
    double[] c4;
    c1=tx.TransformPoint(bounds.w,bounds.s);
    c2=tx.TransformPoint(bounds.w,bounds.n);
    c3=tx.TransformPoint(bounds.e,bounds.s);
    c4=tx.TransformPoint(bounds.e,bounds.n);
    return new Bounds(Math.min(Math.min(c1[0],c2[0]),Math.min(c3[0],c4[0])),Math.min(Math.min(c1[1],c2[1]),Math.min(c3[1],c4[1])),Math.max(Math.max(c1[0],c2[0]),Math.max(c3[0],c4[0])),Math.max(Math.max(c1[1],c2[1]),Math.max(c3[1],c4[1])));
  }
 else {
    return bounds.clone();
  }
}","The original code incorrectly used a hard-coded string splitting method to parse the EPSG code, which was brittle and limited in handling different spatial reference formats. The fixed code replaces this with `SetFromUserInput()`, a more robust method that supports various input formats like ""EPSG:4326"" and ""CRS:84"" for defining spatial references. This change enhances the function's flexibility, making it more reliable and capable of handling a wider range of coordinate reference system specifications."
94391,"/** 
 * Reprojects a bounds to WGS-84
 * @param bounds the projected input bounds
 * @param epsg   the epsg string of the projected bounds crs
 * @return geographic bounds
 */
public static Bounds reprojectBoundsToWGS84(final Bounds bounds,final String epsg){
  if (epsg != null) {
    String[] code=epsg.split(""String_Node_Str"");
    int srcEpsg=Integer.parseInt(code[1]);
    if (srcEpsg != 4326) {
      SpatialReference src=new SpatialReference();
      src.ImportFromEPSG(srcEpsg);
      SpatialReference dst=new SpatialReference(GDALUtils.EPSG4326());
      CoordinateTransformation tx=new CoordinateTransformation(src,dst);
      double[] c1;
      double[] c2;
      double[] c3;
      double[] c4;
      c1=tx.TransformPoint(bounds.w,bounds.s);
      c2=tx.TransformPoint(bounds.w,bounds.n);
      c3=tx.TransformPoint(bounds.e,bounds.s);
      c4=tx.TransformPoint(bounds.e,bounds.n);
      return new Bounds(Math.min(Math.min(c1[0],c2[0]),Math.min(c3[0],c4[0])),Math.min(Math.min(c1[1],c2[1]),Math.min(c3[1],c4[1])),Math.max(Math.max(c1[0],c2[0]),Math.max(c3[0],c4[0])),Math.max(Math.max(c1[1],c2[1]),Math.max(c3[1],c4[1])));
    }
  }
  return bounds.clone();
}","/** 
 * Reprojects a bounds to WGS-84
 * @param bounds the projected input bounds
 * @param srs   the spatial reference of the projected bounds crs. The format isdescribed in http://gdal.org/java/org/gdal/osr/SpatialReference.html#SetFromUserInput(java.lang.String) Examples include ""EPSG:4326"" and ""CRS:84"".
 * @return geographic bounds
 */
public static Bounds reprojectBoundsToWGS84(final Bounds bounds,final String srs){
  if (srs != null) {
    SpatialReference src=new SpatialReference();
    src.SetFromUserInput(srs);
    SpatialReference dst=new SpatialReference(GDALUtils.EPSG4326());
    CoordinateTransformation tx=new CoordinateTransformation(src,dst);
    double[] c1;
    double[] c2;
    double[] c3;
    double[] c4;
    c1=tx.TransformPoint(bounds.w,bounds.s);
    c2=tx.TransformPoint(bounds.w,bounds.n);
    c3=tx.TransformPoint(bounds.e,bounds.s);
    c4=tx.TransformPoint(bounds.e,bounds.n);
    return new Bounds(Math.min(Math.min(c1[0],c2[0]),Math.min(c3[0],c4[0])),Math.min(Math.min(c1[1],c2[1]),Math.min(c3[1],c4[1])),Math.max(Math.max(c1[0],c2[0]),Math.max(c3[0],c4[0])),Math.max(Math.max(c1[1],c2[1]),Math.max(c3[1],c4[1])));
  }
  return bounds.clone();
}","The original code incorrectly parsed the EPSG code using an invalid split method and assumed a specific string format, which would cause parsing errors for different input representations. The fixed code uses `SetFromUserInput()` method, which is more robust and supports various spatial reference input formats like ""EPSG:4326"" or ""CRS:84"", allowing flexible and reliable coordinate system specification. By eliminating the fragile string parsing and using a standard GDAL method, the code becomes more resilient, maintainable, and capable of handling diverse spatial reference inputs."
94392,"private static synchronized void initializeColorscales() throws ColorScale.ColorScaleException {
  if (colorscales == null) {
    colorscales=new HashMap<>();
    Properties props=MrGeoProperties.getInstance();
    final String colorScaleBase=HadoopUtils.getDefaultColorScalesBaseDirectory(props);
    if (colorScaleBase != null) {
      try {
        AdHocDataProvider provider=DataProviderFactory.getAdHocDataProvider(colorScaleBase,AccessMode.READ,HadoopUtils.createConfiguration());
        for (int i=0; i < provider.size(); i++) {
          if (FilenameUtils.getExtension(provider.getName(i)).toLowerCase().equals(""String_Node_Str"")) {
            try (InputStream fdis=provider.get(i)){
              ColorScale cs=ColorScale.loadFromXML(fdis);
              String name=FilenameUtils.getBaseName(provider.getName(i));
              colorscales.put(name,cs);
            }
           }
        }
      }
 catch (      IOException e) {
        throw new ColorScale.BadSourceException(e);
      }
    }
 else {
      throw new ColorScale.ColorScaleException(""String_Node_Str"");
    }
  }
}","@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") private static synchronized void initializeColorscales() throws ColorScale.ColorScaleException {
  if (colorscales == null) {
    colorscales=new HashMap<>();
    Properties props=MrGeoProperties.getInstance();
    final String colorScaleBase=HadoopUtils.getDefaultColorScalesBaseDirectory(props);
    if (colorScaleBase != null) {
      try {
        AdHocDataProvider provider=DataProviderFactory.getAdHocDataProvider(colorScaleBase,AccessMode.READ,HadoopUtils.createConfiguration());
        for (int i=0; i < provider.size(); i++) {
          String name=provider.getName(i);
          if (name != null) {
            if (FilenameUtils.getExtension(name).toLowerCase().equals(""String_Node_Str"")) {
              try (InputStream fdis=provider.get(i)){
                ColorScale cs=ColorScale.loadFromXML(fdis);
                colorscales.put(FilenameUtils.getBaseName(name),cs);
              }
             }
          }
        }
      }
 catch (      IOException e) {
        throw new ColorScale.BadSourceException(e);
      }
    }
 else {
      throw new ColorScale.ColorScaleException(""String_Node_Str"");
    }
  }
}","The original code lacked null checks and could potentially throw null pointer exceptions when accessing provider names and extensions. The fixed code adds a null check for the provider name before processing, ensures safe name extraction, and removes redundant string literal comparisons. These modifications enhance robustness by preventing potential runtime errors and improving the method's defensive programming approach, making the color scale initialization more reliable and error-resistant."
94393,"@BeforeClass public static void init() throws IOException {
  if (GEN_BASELINE_DATA_ONLY) {
    log.warn(""String_Node_Str"");
  }
  vectorutils=new MapOpTestVectorUtils(CostDistanceMapOpIntegrationTest.class);
  testUtils=new MapOpTestUtils(CostDistanceMapOpIntegrationTest.class);
  HadoopFileUtils.delete(testUtils.getInputHdfs());
  HadoopFileUtils.copyToHdfs(testUtils.getInputLocal(),testUtils.getInputHdfs(),TOBLER_MEDIUM);
  HadoopFileUtils.copyToHdfs(Defs.INPUT,testUtils.getInputHdfs(),ALL_ONES);
  frictionSurface=testUtils.getInputHdfs() + ""String_Node_Str"" + TOBLER_MEDIUM;
  HadoopFileUtils.copyToHdfs(new Path(Defs.INPUT),testUtils.getInputHdfs(),smallElevationName);
}","@BeforeClass public static void init() throws IOException {
  if (GEN_BASELINE_DATA_ONLY) {
    log.warn(""String_Node_Str"");
  }
  vectorutils=new MapOpTestVectorUtils(CostDistanceMapOpIntegrationTest.class);
  testUtils=new MapOpTestUtils(CostDistanceMapOpIntegrationTest.class);
  HadoopFileUtils.delete(testUtils.getInputHdfs());
  HadoopFileUtils.copyToHdfs(testUtils.getInputLocal(),testUtils.getInputHdfs(),TOBLER_MEDIUM);
  HadoopFileUtils.copyToHdfs(Defs.INPUT,testUtils.getInputHdfs(),ALL_ONES);
  frictionSurface=testUtils.getInputHdfs() + ""String_Node_Str"" + TOBLER_MEDIUM;
  HadoopFileUtils.copyToHdfs(new Path(Defs.INPUT),testUtils.getInputHdfs(),smallElevationName);
  smallElevation=testUtils.getInputHdfs() + ""String_Node_Str"" + smallElevationName;
}","The original code lacked a critical assignment for the smallElevation variable, which could lead to potential null reference issues or incomplete file path setup. In the fixed code, a new line is added to assign smallElevation using testUtils.getInputHdfs(), concatenating ""String_Node_Str"" and smallElevationName to create a complete file path. This addition ensures proper initialization of the smallElevation variable, preventing potential runtime errors and improving the robustness of the file handling logic."
94394,"@Test @Category(IntegrationTest.class) public void directionalCostDistance() throws Exception {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  if (GEN_BASELINE_DATA_ONLY) {
    testUtils.generateBaselineTif(conf,testname.getMethodName(),exp,-9999);
  }
 else {
    testUtils.runRasterExpression(conf,testname.getMethodName(),exp);
  }
}","@Test @Category(IntegrationTest.class) public void directionalCostDistance() throws Exception {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + smallElevation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  if (GEN_BASELINE_DATA_ONLY) {
    testUtils.generateBaselineTif(conf,testname.getMethodName(),exp,-9999);
  }
 else {
    testUtils.runRasterExpression(conf,testname.getMethodName(),exp);
  }
}","The original code had a repetitive and potentially incorrect string concatenation that lacked a critical variable representation. The fixed code introduces the `smallElevation` variable, which likely provides a meaningful data point or parameter to the raster expression string. This modification ensures more accurate and purposeful string composition, potentially resolving a data representation or calculation issue in the test method."
94395,"@Test @Category(IntegrationTest.class) public void nondirectionalCostDistance() throws Exception {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  if (GEN_BASELINE_DATA_ONLY) {
    testUtils.generateBaselineTif(conf,testname.getMethodName(),exp,-9999);
  }
 else {
    testUtils.runRasterExpression(conf,testname.getMethodName(),exp);
  }
}","@Test @Category(IntegrationTest.class) public void nondirectionalCostDistance() throws Exception {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + smallElevation + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  if (GEN_BASELINE_DATA_ONLY) {
    testUtils.generateBaselineTif(conf,testname.getMethodName(),exp,-9999);
  }
 else {
    testUtils.runRasterExpression(conf,testname.getMethodName(),exp);
  }
}","The original code had a redundant concatenation of ""String_Node_Str"" without introducing meaningful variation in the expression. The fixed code introduces the variable `smallElevation`, adding diversity and potentially representing a different node or calculation parameter. This modification enhances the test's robustness by creating a more distinct and potentially meaningful raster expression for the nondirectional cost distance test."
94396,"final public Raster toRaster(){
  WritableRaster raster=Raster.createBandedRaster(datatype,width,height,bands,new Point(0,0));
  final ByteBuffer rasterBuffer=ByteBuffer.wrap(data);
  for (int i=0; i < HEADER_LEN; i++) {
    rasterBuffer.get();
  }
  int databytes=data.length - HEADER_LEN;
switch (datatype) {
case DataBuffer.TYPE_BYTE:
{
      final byte[] bytedata=new byte[databytes];
      rasterBuffer.get(bytedata);
      raster.setDataElements(0,0,width,height,bytedata);
      break;
    }
case DataBuffer.TYPE_FLOAT:
{
    final FloatBuffer floatbuff=rasterBuffer.asFloatBuffer();
    final float[] floatdata=new float[databytes / bytesPerPixel()];
    floatbuff.get(floatdata);
    raster.setDataElements(0,0,width,height,floatdata);
    break;
  }
case DataBuffer.TYPE_DOUBLE:
{
  final DoubleBuffer doublebuff=rasterBuffer.asDoubleBuffer();
  final double[] doubledata=new double[databytes / bytesPerPixel()];
  doublebuff.get(doubledata);
  raster.setDataElements(0,0,width,height,doubledata);
  break;
}
case DataBuffer.TYPE_INT:
{
final IntBuffer intbuff=rasterBuffer.asIntBuffer();
final int[] intdata=new int[databytes / bytesPerPixel()];
intbuff.get(intdata);
raster.setDataElements(0,0,width,height,intdata);
break;
}
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_USHORT:
{
final ShortBuffer shortbuff=rasterBuffer.asShortBuffer();
final short[] shortdata=new short[databytes / bytesPerPixel()];
shortbuff.get(shortdata);
raster.setDataElements(0,0,width,height,shortdata);
break;
}
default :
throw new RasterWritable.RasterWritableException(""String_Node_Str"");
}
return raster;
}","final public Raster toRaster(){
  WritableRaster raster=RasterUtils.createEmptyRaster(width,height,bands,datatype);
  final ByteBuffer rasterBuffer=ByteBuffer.wrap(data);
  rasterBuffer.order(ByteOrder.LITTLE_ENDIAN);
  for (int i=0; i < HEADER_LEN; i++) {
    rasterBuffer.get();
  }
  int databytes=data.length - HEADER_LEN;
switch (datatype) {
case DataBuffer.TYPE_BYTE:
{
      final byte[] bytedata=new byte[databytes];
      rasterBuffer.get(bytedata);
      raster.setDataElements(0,0,width,height,bytedata);
      break;
    }
case DataBuffer.TYPE_FLOAT:
{
    final FloatBuffer floatbuff=rasterBuffer.asFloatBuffer();
    final float[] floatdata=new float[databytes / bytesPerPixel()];
    floatbuff.get(floatdata);
    raster.setDataElements(0,0,width,height,floatdata);
    break;
  }
case DataBuffer.TYPE_DOUBLE:
{
  final DoubleBuffer doublebuff=rasterBuffer.asDoubleBuffer();
  final double[] doubledata=new double[databytes / bytesPerPixel()];
  doublebuff.get(doubledata);
  raster.setDataElements(0,0,width,height,doubledata);
  break;
}
case DataBuffer.TYPE_INT:
{
final IntBuffer intbuff=rasterBuffer.asIntBuffer();
final int[] intdata=new int[databytes / bytesPerPixel()];
intbuff.get(intdata);
raster.setDataElements(0,0,width,height,intdata);
break;
}
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_USHORT:
{
final ShortBuffer shortbuff=rasterBuffer.asShortBuffer();
final short[] shortdata=new short[databytes / bytesPerPixel()];
shortbuff.get(shortdata);
raster.setDataElements(0,0,width,height,shortdata);
break;
}
default :
throw new RasterWritable.RasterWritableException(""String_Node_Str"");
}
return raster;
}","The original code uses `Raster.createBandedRaster()` with a hardcoded point, which may not create the correct raster configuration for all data types. The fixed code replaces this with `RasterUtils.createEmptyRaster()`, which dynamically creates an appropriate raster, and adds `rasterBuffer.order(ByteOrder.LITTLE_ENDIAN)` to ensure correct byte interpretation. These changes provide a more flexible and reliable method for converting raw data to a raster, handling different data types and byte orders more effectively."
94397,"@Test @Category(UnitTest.class) public void scaleRasterNearestFloat() throws IOException {
  int scale;
  MrGeoRaster scaled;
  for (scale=1; scale < 15; scale++) {
    scaled=numberedFloat.scale(width * scale,height * scale,false,new double[]{Double.NaN});
    compareResult(scale,numberedFloat,scaled);
  }
  for (scale=2; scale < 8; scale++) {
    scaled=numberedFloat.scale(width / scale,height / scale,false,new double[]{Double.NaN});
    compareResult(1.0 / scale,numberedFloat,scaled);
  }
}","@Test @Category(UnitTest.class) public void scaleRasterNearestFloat() throws IOException {
  int scale;
  MrGeoRaster scaled;
  for (scale=1; scale < 15; scale++) {
    scaled=numberedFloat.scale(width * scale,height * scale,false,new double[]{Double.NaN});
    compareResult(scale,scaled);
  }
  for (scale=2; scale < 8; scale++) {
    scaled=numberedFloat.scale(width / scale,height / scale,false,new double[]{Double.NaN});
    compareResult(1.0 / scale,scaled);
  }
}","The original code passed three arguments to the `compareResult` method, but the method likely expects only two arguments, causing a potential compilation or runtime error. The fixed code removes the unnecessary first argument (either `scale` or `1.0 / scale`), keeping only the essential `scaled` parameter. This correction ensures the method call matches the method's signature, preventing type mismatch and improving code reliability."
94398,"@Test @Category(UnitTest.class) public void scaleRasterNearestInt() throws IOException {
  int scale;
  MrGeoRaster scaled;
  for (scale=1; scale < 15; scale++) {
    scaled=numberedInt.scale(width * scale,height * scale,false,new double[]{Double.NaN});
    compareResult(scale,numberedInt,scaled);
  }
  for (scale=2; scale < 8; scale++) {
    scaled=numberedInt.scale(width / scale,height / scale,false,new double[]{Double.NaN});
    compareResult(1.0 / scale,numberedInt,scaled);
  }
}","@Test @Category(UnitTest.class) public void scaleRasterNearestInt() throws IOException {
  int scale;
  MrGeoRaster scaled;
  for (scale=1; scale < 15; scale++) {
    scaled=numberedInt.scale(width * scale,height * scale,false,new double[]{Double.NaN});
    compareResult(scale,scaled);
  }
  for (scale=2; scale < 8; scale++) {
    scaled=numberedInt.scale(width / scale,height / scale,false,new double[]{Double.NaN});
    compareResult(1.0 / scale,scaled);
  }
}","The original code incorrectly passed the source raster (`numberedInt`) as a third argument to `compareResult()`, which likely caused parameter mismatch and potential method invocation errors. In the fixed code, the third argument is removed, leaving only the scaling factor and the scaled raster as arguments to `compareResult()`. This correction ensures the method is called with the correct number of parameters, improving the test's reliability and preventing potential runtime exceptions."
94399,"private void compareResult(double scale,MrGeoRaster orig,MrGeoRaster scaled) throws IOException {
  String name=testname.getMethodName() + String.format(""String_Node_Str"",scale);
  if (GEN_BASELINE_DATA_ONLY) {
    testutils.saveBaselineTif(name,scaled);
  }
 else {
    testutils.compareRasters(name,scaled);
  }
}","private void compareResult(double scale,MrGeoRaster scaled) throws IOException {
  String name=testname.getMethodName() + String.format(""String_Node_Str"",scale);
  if (GEN_BASELINE_DATA_ONLY) {
    testutils.saveBaselineTif(name,scaled);
  }
 else {
    testutils.compareRasters(name,scaled);
  }
}","The original code incorrectly included an unused parameter `orig`, which was redundant and potentially confusing for method implementation. The fixed code removes the unnecessary `MrGeoRaster orig` parameter, streamlining the method signature and eliminating potential misunderstandings about parameter usage. By simplifying the method, the code becomes more focused, clearer, and maintains the same functional behavior of comparing or saving raster data based on the scale parameter."
94400,"@Test @Category(UnitTest.class) public void scaleRasterNearestDouble() throws IOException {
  int scale;
  MrGeoRaster scaled;
  for (scale=1; scale < 15; scale++) {
    scaled=numberedDouble.scale(width * scale,height * scale,false,new double[]{Double.NaN});
    compareResult(scale,numberedDouble,scaled);
  }
  for (scale=2; scale < 8; scale+=1) {
    scaled=numberedDouble.scale(width / scale,height / scale,false,new double[]{Double.NaN});
    compareResult(1.0 / scale,numberedDouble,scaled);
  }
}","@Test @Category(UnitTest.class) public void scaleRasterNearestDouble() throws IOException {
  int scale;
  MrGeoRaster scaled;
  for (scale=1; scale < 15; scale++) {
    scaled=numberedDouble.scale(width * scale,height * scale,false,new double[]{Double.NaN});
    compareResult(scale,scaled);
  }
  for (scale=2; scale < 8; scale+=1) {
    scaled=numberedDouble.scale(width / scale,height / scale,false,new double[]{Double.NaN});
    compareResult(1.0 / scale,scaled);
  }
}","The original code incorrectly passed the original raster (numberedDouble) as the second argument in compareResult, which could lead to incorrect comparison logic. In the fixed code, only the scaled raster is passed to compareResult, ensuring the method compares the correct scaled image against the original. This modification ensures accurate scaling validation by focusing on the transformation of the raster without redundant or incorrect parameter passing."
94401,"public String getName(){
  return metadata.getName(zoomlevel);
}","public String getName(){
  return metadata.getName(getZoomlevel());
}","The original code directly uses `zoomlevel` without ensuring it's a properly defined or accessible variable, which could lead to compilation or runtime errors. The fixed code calls `getZoomlevel()`, suggesting a method that safely retrieves the zoom level, ensuring proper encapsulation and potential validation of the zoom level value. By using a getter method, the code improves data access control and provides a more robust way of obtaining the zoom level for the `getName()` method."
94402,"public MrGeoRaster getRaster(final TileBounds tileBounds) throws MrGeoRaster.MrGeoRasterException {
  getMetadata();
  final int tilesize=metadata.getTilesize();
  final Bounds imageBounds=TMSUtils.tileToBounds(tileBounds,zoomlevel,tilesize);
  final Pixel ul=TMSUtils.latLonToPixelsUL(imageBounds.n,imageBounds.w,zoomlevel,tilesize);
  final Pixel lr=TMSUtils.latLonToPixelsUL(imageBounds.s,imageBounds.e,zoomlevel,tilesize);
  MrGeoRaster merged=MrGeoRaster.createEmptyRaster((int)(lr.px - ul.px),(int)(lr.py - ul.py),metadata.getBands(),metadata.getTileType());
  merged.fill(metadata.getDefaultValuesDouble());
  log.debug(""String_Node_Str"",zoomlevel,tileBounds.w,tileBounds.s,TMSUtils.tileid(tileBounds.w,tileBounds.s,zoomlevel),tileBounds.e,tileBounds.n,TMSUtils.tileid(tileBounds.e,tileBounds.n,zoomlevel));
  for (long row=tileBounds.s; row <= tileBounds.n; row++) {
    final TileIdWritable rowStart=new TileIdWritable(TMSUtils.tileid(tileBounds.w,row,zoomlevel));
    final TileIdWritable rowEnd=new TileIdWritable(TMSUtils.tileid(tileBounds.e,row,zoomlevel));
    final KVIterator<TileIdWritable,MrGeoRaster> iter=getTiles(rowStart,rowEnd);
    while (iter.hasNext()) {
      final MrGeoRaster source=iter.currentValue();
      if (source != null) {
        final Tile tile=TMSUtils.tileid(iter.currentKey().get(),zoomlevel);
        final Bounds bounds=TMSUtils.tileBounds(tile.tx,tile.ty,zoomlevel,tilesize);
        final Pixel start=TMSUtils.latLonToPixelsUL(bounds.n,bounds.w,zoomlevel,tilesize);
        log.debug(""String_Node_Str"",tile.tx,tile.ty,bounds.w,bounds.s,bounds.e,bounds.n,start.px - ul.px,start.py - ul.py);
        merged.copyFrom(0,0,source.width(),source.height(),source,(int)(start.px - ul.px),(int)(start.py - ul.py));
      }
    }
    if (iter instanceof CloseableKVIterator) {
      try {
        ((CloseableKVIterator)iter).close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return merged;
}","public MrGeoRaster getRaster(final TileBounds tileBounds) throws MrGeoRaster.MrGeoRasterException {
  getMetadata();
  final int tilesize=metadata.getTilesize();
  int zoomlevel=getZoomlevel();
  final Bounds imageBounds=TMSUtils.tileToBounds(tileBounds,zoomlevel,tilesize);
  final Pixel ul=TMSUtils.latLonToPixelsUL(imageBounds.n,imageBounds.w,zoomlevel,tilesize);
  final Pixel lr=TMSUtils.latLonToPixelsUL(imageBounds.s,imageBounds.e,zoomlevel,tilesize);
  MrGeoRaster merged=MrGeoRaster.createEmptyRaster((int)(lr.px - ul.px),(int)(lr.py - ul.py),metadata.getBands(),metadata.getTileType());
  merged.fill(metadata.getDefaultValuesDouble());
  log.debug(""String_Node_Str"",zoomlevel,tileBounds.w,tileBounds.s,TMSUtils.tileid(tileBounds.w,tileBounds.s,zoomlevel),tileBounds.e,tileBounds.n,TMSUtils.tileid(tileBounds.e,tileBounds.n,zoomlevel));
  for (long row=tileBounds.s; row <= tileBounds.n; row++) {
    final TileIdWritable rowStart=new TileIdWritable(TMSUtils.tileid(tileBounds.w,row,zoomlevel));
    final TileIdWritable rowEnd=new TileIdWritable(TMSUtils.tileid(tileBounds.e,row,zoomlevel));
    final KVIterator<TileIdWritable,MrGeoRaster> iter=getTiles(rowStart,rowEnd);
    while (iter.hasNext()) {
      final MrGeoRaster source=iter.currentValue();
      if (source != null) {
        final Tile tile=TMSUtils.tileid(iter.currentKey().get(),zoomlevel);
        final Bounds bounds=TMSUtils.tileBounds(tile.tx,tile.ty,zoomlevel,tilesize);
        final Pixel start=TMSUtils.latLonToPixelsUL(bounds.n,bounds.w,zoomlevel,tilesize);
        log.debug(""String_Node_Str"",tile.tx,tile.ty,bounds.w,bounds.s,bounds.e,bounds.n,start.px - ul.px,start.py - ul.py);
        merged.copyFrom(0,0,source.width(),source.height(),source,(int)(start.px - ul.px),(int)(start.py - ul.py));
      }
    }
    if (iter instanceof CloseableKVIterator) {
      try {
        ((CloseableKVIterator)iter).close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return merged;
}","The original code lacked a crucial initialization of the zoomlevel variable, which could lead to undefined behavior or runtime errors. The fixed code explicitly initializes zoomlevel by calling getZoomlevel(), ensuring proper context and preventing potential null or unset value issues. This modification guarantees consistent and predictable tile rendering by explicitly obtaining the zoom level before performing subsequent geospatial calculations."
94403,"@Override public List<InputSplit> getSplits(JobContext context) throws IOException {
  long start=System.currentTimeMillis();
  Configuration conf=context.getConfiguration();
  ImageInputFormatContext ifContext=ImageInputFormatContext.load(conf);
  final int zoom=ifContext.getZoomLevel();
  final int tilesize=ifContext.getTileSize();
  HdfsMrsImageDataProvider dp=createHdfsMrsImageDataProvider(context.getConfiguration());
  Path inputWithZoom=new Path(dp.getResourcePath(true),""String_Node_Str"" + zoom);
  MrsPyramidMetadataReader metadataReader=dp.getMetadataReader();
  MrsPyramidMetadata metadata=metadataReader.read();
  org.mrgeo.hdfs.tile.FileSplit fsplit=createFileSplit();
  fsplit.readSplits(inputWithZoom);
  org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo[] splits=(org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo[])fsplit.getSplits();
  List<InputSplit> result=new ArrayList<>(splits.length);
  final Bounds requestedBounds=ifContext.getBounds();
  for (  org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo split : splits) {
    final Path part=new Path(inputWithZoom,split.getName());
    final Path dataFile=new Path(part,MapFile.DATA_FILE_NAME);
    final long endTileId=split.getEndId();
    final long startTileId=split.getStartId();
    final Tile startTile=TMSUtils.tileid(startTileId,zoom);
    final Tile endTile=TMSUtils.tileid(endTileId,zoom);
    final TileBounds partFileTileBounds=new TileBounds(startTile.tx,startTile.ty,endTile.tx,endTile.ty);
    final Bounds partFileBounds=TMSUtils.tileToBounds(partFileTileBounds,zoom,tilesize);
    if (requestedBounds != null) {
      if (requestedBounds.intersects(partFileBounds,false)) {
        Bounds intersected=requestedBounds.intersection(partFileBounds,false);
        TileBounds tb=TMSUtils.boundsToTile(intersected,zoom,tilesize);
        long s=TMSUtils.tileid(tb.w,tb.s,zoom);
        long e=TMSUtils.tileid(tb.e,tb.n,zoom);
        result.add(new TiledInputSplit(new FileSplit(dataFile,0,0,null),s,e,zoom,metadata.getTilesize()));
      }
    }
 else {
      result.add(new TiledInputSplit(new FileSplit(dataFile,0,0,null),startTileId,endTileId,zoom,metadata.getTilesize()));
    }
  }
  long end=System.currentTimeMillis();
  log.info(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  return result;
}","@Override public List<InputSplit> getSplits(JobContext context) throws IOException {
  long start=System.currentTimeMillis();
  Configuration conf=context.getConfiguration();
  ImageInputFormatContext ifContext=ImageInputFormatContext.load(conf);
  final int zoom=ifContext.getZoomLevel();
  final int tilesize=ifContext.getTileSize();
  HdfsMrsImageDataProvider dp=createHdfsMrsImageDataProvider(context.getConfiguration());
  Path inputWithZoom=new Path(dp.getResourcePath(true),""String_Node_Str"" + zoom);
  MrsPyramidMetadataReader metadataReader=dp.getMetadataReader();
  MrsPyramidMetadata metadata=metadataReader.read();
  org.mrgeo.hdfs.tile.FileSplit fsplit=createFileSplit();
  fsplit.readSplits(inputWithZoom);
  org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo[] splits=(org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo[])fsplit.getSplits();
  List<InputSplit> result=new ArrayList<>(splits.length);
  final Bounds requestedBounds=ifContext.getBounds();
  for (  org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo split : splits) {
    final Path part=new Path(inputWithZoom,split.getName());
    final Path dataFile=new Path(part,MapFile.DATA_FILE_NAME);
    final long endTileId=split.getEndId();
    final long startTileId=split.getStartId();
    if (requestedBounds != null) {
      final Tile startTile=TMSUtils.tileid(startTileId,zoom);
      final Bounds startTileBounds=TMSUtils.tileBounds(startTile,zoom,tilesize);
      final Tile endTile=TMSUtils.tileid(endTileId,zoom);
      final Bounds endTileBounds=TMSUtils.tileBounds(endTile,zoom,tilesize);
      if (startTileBounds.s > requestedBounds.n || endTileBounds.n < requestedBounds.s) {
      }
 else {
        result.add(new TiledInputSplit(new FileSplit(dataFile,0,0,null),startTileId,endTileId,zoom,metadata.getTilesize()));
      }
    }
 else {
      result.add(new TiledInputSplit(new FileSplit(dataFile,0,0,null),startTileId,endTileId,zoom,metadata.getTilesize()));
    }
  }
  long end=System.currentTimeMillis();
  log.info(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  return result;
}","The original code incorrectly calculated tile bounds intersection by creating complex TileBounds and Bounds objects, which could lead to potential missed or incorrect tile selections. The fixed code simplifies the intersection logic by directly comparing tile bounds' south and north coordinates against the requested bounds, ensuring precise filtering of relevant tiles. This approach provides a more straightforward and reliable method for determining which input splits to include, improving the accuracy of tile selection in the input format."
94404,"@Override public int run(final String[] args,Configuration conf,ProviderProperties providerProperties){
  log.info(""String_Node_Str"");
  try {
    final Options options=createOptions();
    CommandLine line;
    try {
      final CommandLineParser parser=new PosixParser();
      line=parser.parse(options,args);
      if (line == null || line.hasOption(""String_Node_Str"")) {
        new HelpFormatter().printHelp(""String_Node_Str"",options);
        return 1;
      }
      if (line.hasOption(""String_Node_Str"") && (line.hasOption(""String_Node_Str"") || line.hasOption(""String_Node_Str"") || line.hasOption(""String_Node_Str""))) {
        log.debug(""String_Node_Str"");
        throw new ParseException(""String_Node_Str"");
      }
      if (line.hasOption(""String_Node_Str"") && line.hasOption(""String_Node_Str"")) {
        log.debug(""String_Node_Str"");
        throw new ParseException(""String_Node_Str"");
      }
      if (line.hasOption(""String_Node_Str"")) {
        LoggingUtils.setDefaultLogLevel(LoggingUtils.INFO);
      }
      if (line.hasOption(""String_Node_Str"")) {
        LoggingUtils.setDefaultLogLevel(LoggingUtils.DEBUG);
      }
      if (line.hasOption(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        HadoopUtils.setupLocalRunner(conf);
      }
      String outputbase=line.getOptionValue(""String_Node_Str"");
      if (line.hasOption(""String_Node_Str"")) {
        maxTiles=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
      }
      useRand=line.hasOption(""String_Node_Str"");
      boolean all=line.hasOption(""String_Node_Str"");
      boolean singleImage=line.hasOption(""String_Node_Str"");
      mosaicTiles=line.hasOption(""String_Node_Str"");
      if (mosaicTiles) {
        mosaicTileCount=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
      }
      useBounds=line.hasOption(""String_Node_Str"");
      if (useBounds) {
        final String boundsOption=line.getOptionValue(""String_Node_Str"");
        bounds=parseBounds(boundsOption);
      }
      if (line.hasOption(""String_Node_Str"")) {
        colorscale=ColorScaleManager.fromName(line.getOptionValue(""String_Node_Str""));
      }
      boolean useTileSet=line.hasOption(""String_Node_Str"");
      if (useTileSet) {
        final String tileIdOption=line.getOptionValue(""String_Node_Str"");
        final String[] tileIds=tileIdOption.split(""String_Node_Str"");
        for (        final String tileId : tileIds) {
          tileset.add(Long.valueOf(tileId));
        }
      }
      int zoomlevel=-1;
      if (line.hasOption(""String_Node_Str"")) {
        zoomlevel=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
      }
      String format=""String_Node_Str"";
      if (line.hasOption(""String_Node_Str"")) {
        format=line.getOptionValue(""String_Node_Str"");
      }
      useTMS=line.hasOption(""String_Node_Str"");
      for (      final String arg : line.getArgs()) {
        MrsPyramid imagePyramid;
        MrsPyramid pyramid=null;
        String pyramidName=""String_Node_Str"";
        try {
          MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(arg,DataProviderFactory.AccessMode.READ,providerProperties);
          imagePyramid=MrsPyramid.open(dp);
          pyramidName=dp.getSimpleResourceName();
          pyramid=imagePyramid;
        }
 catch (        IOException e) {
          imagePyramid=null;
        }
        if (imagePyramid == null) {
          throw new IOException(""String_Node_Str"");
        }
        if (zoomlevel <= 0) {
          zoomlevel=pyramid.getMaximumLevel();
        }
        int end=zoomlevel;
        if (all) {
          end=1;
        }
        while (zoomlevel >= end) {
          MrsImage image=imagePyramid.getImage(zoomlevel);
          try {
            final Set<Long> tiles=calculateTiles(pyramid,zoomlevel);
            int tilesize=imagePyramid.getTileSize();
            if (singleImage) {
              saveMultipleTiles(outputbase,pyramidName,format,image,ArrayUtils.toPrimitive(tiles.toArray(new Long[tiles.size()])));
            }
 else             if (mosaicTiles && mosaicTileCount > 0) {
              if (!outputbase.contains(X) || !outputbase.contains(Y) || !outputbase.contains(LAT)|| !outputbase.contains(LON)) {
                outputbase=outputbase + ""String_Node_Str"";
              }
              for (              final Long tileid : tiles) {
                final Tile t=TMSUtils.tileid(tileid,zoomlevel);
                final Set<Long> tilesToMosaic=new HashSet<>();
                final LongRectangle tileBounds=pyramid.getTileBounds(zoomlevel);
                for (long ty1=t.ty; ((ty1 < (t.ty + mosaicTileCount)) && (ty1 <= tileBounds.getMaxY())); ty1++) {
                  for (long tx1=t.tx; ((tx1 < (t.tx + mosaicTileCount)) && (tx1 <= tileBounds.getMaxX())); tx1++) {
                    tilesToMosaic.add(TMSUtils.tileid(tx1,ty1,zoomlevel));
                  }
                }
                saveMultipleTiles(outputbase,pyramidName,format,image,ArrayUtils.toPrimitive(tilesToMosaic.toArray(new Long[tilesToMosaic.size()])));
              }
            }
 else {
              for (              final Long tileid : tiles) {
                saveSingleTile(outputbase,pyramidName,image,format,tileid,zoomlevel,tilesize);
              }
            }
          }
  finally {
            if (image != null) {
              image.close();
            }
          }
          zoomlevel--;
        }
      }
    }
 catch (    final ParseException e) {
      new HelpFormatter().printHelp(""String_Node_Str"",options);
      return 1;
    }
    return 0;
  }
 catch (  ColorScale.ColorScaleException|IOException e) {
    e.printStackTrace();
  }
  return -1;
}","@Override public int run(final String[] args,Configuration conf,ProviderProperties providerProperties){
  log.info(""String_Node_Str"");
  try {
    final Options options=createOptions();
    CommandLine line;
    try {
      final CommandLineParser parser=new PosixParser();
      line=parser.parse(options,args);
      if (line == null || line.hasOption(""String_Node_Str"")) {
        new HelpFormatter().printHelp(""String_Node_Str"",options);
        return 1;
      }
      if (line.hasOption(""String_Node_Str"") && (line.hasOption(""String_Node_Str"") || line.hasOption(""String_Node_Str"") || line.hasOption(""String_Node_Str""))) {
        log.debug(""String_Node_Str"");
        throw new ParseException(""String_Node_Str"");
      }
      if (line.hasOption(""String_Node_Str"") && line.hasOption(""String_Node_Str"")) {
        log.debug(""String_Node_Str"");
        throw new ParseException(""String_Node_Str"");
      }
      if (line.hasOption(""String_Node_Str"")) {
        LoggingUtils.setDefaultLogLevel(LoggingUtils.INFO);
      }
      if (line.hasOption(""String_Node_Str"")) {
        LoggingUtils.setDefaultLogLevel(LoggingUtils.DEBUG);
      }
      if (line.hasOption(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        HadoopUtils.setupLocalRunner(conf);
      }
      String outputbase=line.getOptionValue(""String_Node_Str"");
      if (line.hasOption(""String_Node_Str"")) {
        maxTiles=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
      }
      useRand=line.hasOption(""String_Node_Str"");
      boolean all=line.hasOption(""String_Node_Str"");
      boolean singleImage=line.hasOption(""String_Node_Str"");
      mosaicTiles=line.hasOption(""String_Node_Str"");
      if (mosaicTiles) {
        mosaicTileCount=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
      }
      useBounds=line.hasOption(""String_Node_Str"");
      if (useBounds) {
        final String boundsOption=line.getOptionValue(""String_Node_Str"");
        bounds=parseBounds(boundsOption);
      }
      if (line.hasOption(""String_Node_Str"")) {
        colorscale=ColorScaleManager.fromName(line.getOptionValue(""String_Node_Str""));
      }
      boolean useTileSet=line.hasOption(""String_Node_Str"");
      if (useTileSet) {
        tileset=new HashSet<Long>();
        final String tileIdOption=line.getOptionValue(""String_Node_Str"");
        final String[] tileIds=tileIdOption.split(""String_Node_Str"");
        for (        final String tileId : tileIds) {
          tileset.add(Long.valueOf(tileId));
        }
      }
      int zoomlevel=-1;
      if (line.hasOption(""String_Node_Str"")) {
        zoomlevel=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
      }
      String format=""String_Node_Str"";
      if (line.hasOption(""String_Node_Str"")) {
        format=line.getOptionValue(""String_Node_Str"");
      }
      useTMS=line.hasOption(""String_Node_Str"");
      for (      final String arg : line.getArgs()) {
        MrsPyramid imagePyramid;
        MrsPyramid pyramid=null;
        String pyramidName=""String_Node_Str"";
        try {
          MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(arg,DataProviderFactory.AccessMode.READ,providerProperties);
          imagePyramid=MrsPyramid.open(dp);
          pyramidName=dp.getSimpleResourceName();
          pyramid=imagePyramid;
        }
 catch (        IOException e) {
          imagePyramid=null;
        }
        if (imagePyramid == null) {
          throw new IOException(""String_Node_Str"");
        }
        if (zoomlevel <= 0) {
          zoomlevel=pyramid.getMaximumLevel();
        }
        int end=zoomlevel;
        if (all) {
          end=1;
        }
        while (zoomlevel >= end) {
          MrsImage image=imagePyramid.getImage(zoomlevel);
          try {
            final Set<Long> tiles=calculateTiles(pyramid,zoomlevel);
            int tilesize=imagePyramid.getTileSize();
            if (singleImage) {
              saveMultipleTiles(outputbase,pyramidName,format,image,ArrayUtils.toPrimitive(tiles.toArray(new Long[tiles.size()])));
            }
 else             if (mosaicTiles && mosaicTileCount > 0) {
              if (!outputbase.contains(X) || !outputbase.contains(Y) || !outputbase.contains(LAT)|| !outputbase.contains(LON)) {
                outputbase=outputbase + ""String_Node_Str"";
              }
              for (              final Long tileid : tiles) {
                final Tile t=TMSUtils.tileid(tileid,zoomlevel);
                final Set<Long> tilesToMosaic=new HashSet<>();
                final LongRectangle tileBounds=pyramid.getTileBounds(zoomlevel);
                for (long ty1=t.ty; ((ty1 < (t.ty + mosaicTileCount)) && (ty1 <= tileBounds.getMaxY())); ty1++) {
                  for (long tx1=t.tx; ((tx1 < (t.tx + mosaicTileCount)) && (tx1 <= tileBounds.getMaxX())); tx1++) {
                    tilesToMosaic.add(TMSUtils.tileid(tx1,ty1,zoomlevel));
                  }
                }
                saveMultipleTiles(outputbase,pyramidName,format,image,ArrayUtils.toPrimitive(tilesToMosaic.toArray(new Long[tilesToMosaic.size()])));
              }
            }
 else {
              for (              final Long tileid : tiles) {
                saveSingleTile(outputbase,pyramidName,image,format,tileid,zoomlevel,tilesize);
              }
            }
          }
  finally {
            if (image != null) {
              image.close();
            }
          }
          zoomlevel--;
        }
      }
    }
 catch (    final ParseException e) {
      new HelpFormatter().printHelp(""String_Node_Str"",options);
      return 1;
    }
    return 0;
  }
 catch (  ColorScale.ColorScaleException|IOException e) {
    e.printStackTrace();
  }
  return -1;
}","The original code did not initialize the `tileset` variable before adding elements, which could lead to a `NullPointerException` when processing tile set options. In the fixed code, `tileset = new HashSet<Long>()` is added before populating it, ensuring proper initialization and preventing potential runtime errors. This change guarantees robust tile set handling by creating a valid collection before performing operations, improving the code's reliability and preventing potential null reference exceptions."
94405,"final public MrGeoRaster reduce(final int xfactor,final int yfactor,Aggregator aggregator,double[] nodatas) throws MrGeoRasterException {
  MrGeoRaster child=createCompatibleRaster(width / xfactor,height / yfactor);
  final int subsize=xfactor * yfactor;
  final int[] intsamples=new int[subsize];
  final float[] floatsamples=new float[subsize];
  final double[] doublesamples=new double[subsize];
  int ndx;
  for (int b=0; b < bands; b++) {
    for (int y=0; y < height; y+=yfactor) {
      for (int x=0; x < width; x+=xfactor) {
switch (datatype) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_INT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_USHORT:
          ndx=0;
        for (int yy=y; yy < y + yfactor; yy++) {
          for (int xx=x; xx < x + xfactor; xx++) {
            intsamples[ndx++]=getPixelInt(xx,yy,b);
          }
        }
      int intSample=aggregator.aggregate(intsamples,(int)nodatas[b]);
    child.setPixel(x / xfactor,y / yfactor,b,intSample);
  break;
case DataBuffer.TYPE_FLOAT:
ndx=0;
for (int yy=y; yy < y + yfactor; yy++) {
for (int xx=x; xx < x + xfactor; xx++) {
  floatsamples[ndx++]=getPixelInt(xx,yy,b);
}
}
float floatsample=aggregator.aggregate(floatsamples,(float)nodatas[b]);
child.setPixel(x / xfactor,y / yfactor,b,floatsample);
break;
case DataBuffer.TYPE_DOUBLE:
ndx=0;
for (int yy=y; yy < y + yfactor; yy++) {
for (int xx=x; xx < x + xfactor; xx++) {
doublesamples[ndx++]=getPixelInt(xx,yy,b);
}
}
double doublesample=aggregator.aggregate(doublesamples,nodatas[b]);
child.setPixel(x / xfactor,y / yfactor,b,doublesample);
break;
default :
throw new RasterWritable.RasterWritableException(""String_Node_Str"");
}
}
}
}
return child;
}","final public MrGeoRaster reduce(final int xfactor,final int yfactor,Aggregator aggregator,double[] nodatas) throws MrGeoRasterException {
  MrGeoRaster child=createCompatibleRaster(width / xfactor,height / yfactor);
  final int subsize=xfactor * yfactor;
  final int[] intsamples=new int[subsize];
  final float[] floatsamples=new float[subsize];
  final double[] doublesamples=new double[subsize];
  int ndx;
  for (int b=0; b < bands; b++) {
    for (int y=0; y < height; y+=yfactor) {
      for (int x=0; x < width; x+=xfactor) {
switch (datatype) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_INT:
case DataBuffer.TYPE_SHORT:
case DataBuffer.TYPE_USHORT:
          ndx=0;
        for (int yy=y; yy < y + yfactor; yy++) {
          for (int xx=x; xx < x + xfactor; xx++) {
            intsamples[ndx++]=getPixelInt(xx,yy,b);
          }
        }
      int intSample=aggregator.aggregate(intsamples,(int)nodatas[b]);
    child.setPixel(x / xfactor,y / yfactor,b,intSample);
  break;
case DataBuffer.TYPE_FLOAT:
ndx=0;
for (int yy=y; yy < y + yfactor; yy++) {
for (int xx=x; xx < x + xfactor; xx++) {
  floatsamples[ndx++]=getPixelFloat(xx,yy,b);
}
}
float floatsample=aggregator.aggregate(floatsamples,(float)nodatas[b]);
child.setPixel(x / xfactor,y / yfactor,b,floatsample);
break;
case DataBuffer.TYPE_DOUBLE:
ndx=0;
for (int yy=y; yy < y + yfactor; yy++) {
for (int xx=x; xx < x + xfactor; xx++) {
doublesamples[ndx++]=getPixelDouble(xx,yy,b);
}
}
double doublesample=aggregator.aggregate(doublesamples,nodatas[b]);
child.setPixel(x / xfactor,y / yfactor,b,doublesample);
break;
default :
throw new RasterWritable.RasterWritableException(""String_Node_Str"");
}
}
}
}
return child;
}","The buggy code incorrectly used `getPixelInt()` for all data types, potentially causing type conversion errors and data loss. The fixed code uses type-specific pixel retrieval methods (`getPixelFloat()` and `getPixelDouble()`) that match the corresponding data buffer types. By ensuring correct method calls for different pixel data types, the fixed code maintains data integrity and prevents potential runtime type casting errors."
94406,"private boolean saveMultipleTiles(String output,String pyramidName,String format,final MrsImage image,final long[] tiles){
  try {
    final MrsPyramidMetadata metadata=image.getMetadata();
    MrGeoRaster raster=image.getRaster(tiles);
    Bounds imageBounds=null;
    long minId=tiles[0];
    final int tilesize=image.getTilesize();
    final int zoomlevel=image.getZoomlevel();
    for (    final long lid : tiles) {
{
        minId=lid;
      }
      final Tile tile=TMSUtils.tileid(lid,zoomlevel);
      final Bounds bounds=TMSUtils.tileBounds(tile.tx,tile.ty,zoomlevel,tilesize);
      if (imageBounds == null) {
        imageBounds=bounds;
      }
 else {
        imageBounds=imageBounds.expand(bounds);
      }
    }
    if (imageBounds == null) {
      throw new MrsImageException(""String_Node_Str"");
    }
    String out=makeOutputName(output,pyramidName,format,minId,zoomlevel,tilesize,false);
    if (colorscale != null || !format.equals(""String_Node_Str"")) {
      raster=colorRaster(image,format,raster);
    }
    GDALJavaUtils.saveRaster(raster.toDataset(imageBounds,metadata.getDefaultValues()),out,null,metadata.getDefaultValue(0),format);
    System.out.println(""String_Node_Str"" + out);
    return true;
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
  return false;
}","private boolean saveMultipleTiles(String output,String pyramidName,String format,final MrsImage image,final long[] tiles){
  try {
    final MrsPyramidMetadata metadata=image.getMetadata();
    MrGeoRaster raster=image.getRaster(tiles);
    Bounds imageBounds=null;
    long minId=tiles[0];
    final int tilesize=image.getTilesize();
    final int zoomlevel=image.getZoomlevel();
    for (    final long lid : tiles) {
      if (minId > lid) {
        minId=lid;
      }
      final Tile tile=TMSUtils.tileid(lid,zoomlevel);
      final Bounds bounds=TMSUtils.tileBounds(tile.tx,tile.ty,zoomlevel,tilesize);
      if (imageBounds == null) {
        imageBounds=bounds;
      }
 else {
        imageBounds=imageBounds.expand(bounds);
      }
    }
    if (imageBounds == null) {
      throw new MrsImageException(""String_Node_Str"");
    }
    String out=makeOutputName(output,pyramidName,format,minId,zoomlevel,tilesize,false);
    if (colorscale != null || !format.equals(""String_Node_Str"")) {
      raster=colorRaster(image,format,raster);
    }
    GDALJavaUtils.saveRaster(raster.toDataset(imageBounds,metadata.getDefaultValues()),out,null,metadata.getDefaultValue(0),format);
    System.out.println(""String_Node_Str"" + out);
    return true;
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
  return false;
}","The original code had an unnecessary block that did not update the `minId` variable, potentially causing incorrect minimum tile ID selection. The fixed code adds an explicit comparison `if (minId > lid)` to properly track and update the minimum tile ID during iteration. This change ensures accurate identification of the smallest tile ID, improving the reliability of tile processing and output naming in the method."
94407,"@Test(expected=Exception.class) @Category(UnitTest.class) public void testGetColorScale_ColorScaleBaseDirNotExist() throws Exception {
  final Properties mrgeoConf=new Properties();
  @SuppressWarnings(""String_Node_Str"") final ColorScale cs=ColorScaleManager.fromName(""String_Node_Str"",mrgeoConf);
}","@Test(expected=Exception.class) @Category(UnitTest.class) public void testGetColorScale_ColorScaleBaseDirNotExist() throws Exception {
  final Properties mrgeoConf=new Properties();
  ColorScaleManager.invalidateCache();
  @SuppressWarnings(""String_Node_Str"") final ColorScale cs=ColorScaleManager.fromName(""String_Node_Str"",mrgeoConf);
}","The original code might fail due to potential caching issues in ColorScaleManager when repeatedly accessing color scales. The fixed code adds `ColorScaleManager.invalidateCache()` before calling `fromName()`, which ensures a clean state and prevents potential stale cache problems. This modification improves test reliability by clearing any previously cached color scale configurations before each test execution."
94408,"@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") @Override public double[] getExtrema(){
  try {
    MrsImageDataProvider dp=getDataProvider();
    if (dp != null) {
      MrsPyramidMetadata metadata=dp.getMetadataReader().read();
      if (zoomLevel == -1) {
        return metadata.getExtrema(0);
      }
 else {
        return metadata.getExtrema(zoomLevel);
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}","@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") @Override public double[] getExtrema(){
  try {
    MrsImageDataProvider dp=getDataProvider();
    if (dp != null) {
      MrsPyramidMetadata metadata=dp.getMetadataReader().read();
      ImageStats stats=metadata.getStats(0);
      if (stats != null) {
        return new double[]{stats.min,stats.max};
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}","The original code incorrectly assumes that `getExtrema()` method of `MrsPyramidMetadata` can directly retrieve min and max values across all zoom levels. The fixed code replaces this with `getStats()`, which properly retrieves image statistics, specifically extracting the minimum and maximum values using `stats.min` and `stats.max`. By using the correct metadata method and creating a new double array with explicit min and max values, the code now robustly handles image statistics retrieval across different zoom levels."
94409,"@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") @GET @Produces(""String_Node_Str"") @Path(""String_Node_Str"") public Response getImage(@PathParam(""String_Node_Str"") String imgName,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") String format,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") String bbox,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") int width,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") int height,@QueryParam(""String_Node_Str"") String colorScaleName,@QueryParam(""String_Node_Str"") String colorScale,@QueryParam(""String_Node_Str"") Double min,@QueryParam(""String_Node_Str"") Double max,@QueryParam(""String_Node_Str"") String srs,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") int zoomLevel){
  String error;
  try {
    String[] bBoxValues=bbox.split(""String_Node_Str"");
    if (bBoxValues.length != 4) {
      return Response.status(Status.BAD_REQUEST).entity(""String_Node_Str"").build();
    }
    double minX=Double.valueOf(bBoxValues[0]);
    double minY=Double.valueOf(bBoxValues[1]);
    double maxX=Double.valueOf(bBoxValues[2]);
    double maxY=Double.valueOf(bBoxValues[3]);
    Bounds bounds=new Bounds(minX,minY,maxX,maxY);
    bounds=RequestUtils.reprojectBounds(bounds,srs);
    ColorScale cs=null;
    try {
      if (colorScaleName != null) {
        if (colorScale != null) {
          return Response.status(Status.BAD_REQUEST).entity(""String_Node_Str"").build();
        }
        cs=service.getColorScaleFromName(colorScaleName);
      }
 else       if (colorScale != null) {
        cs=service.getColorScaleFromJSON(colorScale);
      }
    }
 catch (    Exception e) {
      return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();
    }
    if (zoomLevel != -1) {
      MrsPyramid pyramid=service.getPyramid(imgName,SecurityUtils.getProviderProperties());
      if (pyramid == null) {
        return Response.status(Status.NOT_FOUND).entity(imgName + ""String_Node_Str"").build();
      }
      if (pyramid.getMetadata().getName(zoomLevel) == null) {
        return Response.status(Status.BAD_REQUEST).entity(""String_Node_Str"").build();
      }
    }
    if (!format.equals(KML_INPUT_FORMAT)) {
      MrsPyramid pyramid=service.getPyramid(imgName,SecurityUtils.getProviderProperties());
      if (pyramid == null) {
        return Response.status(Status.NOT_FOUND).entity(imgName + ""String_Node_Str"").build();
      }
      if (!bounds.toEnvelope().intersects(pyramid.getBounds().toEnvelope())) {
        log.debug(""String_Node_Str"");
        byte imageData[]=service.getEmptyTile(width,height,format);
        String type=service.getContentType(format);
        return Response.ok(imageData).header(""String_Node_Str"",type).build();
      }
      ImageRenderer renderer;
      try {
        renderer=service.getImageRenderer(format);
      }
 catch (      IllegalArgumentException e) {
        if (e.getMessage().toUpperCase().contains(""String_Node_Str"")) {
          return Response.status(Status.BAD_REQUEST).entity(""String_Node_Str"" + format).build();
        }
        throw e;
      }
      Raster result=renderer.renderImage(imgName,bounds,width,height,SecurityUtils.getProviderProperties(),srs);
      if (!(renderer instanceof TiffImageRenderer)) {
        log.debug(""String_Node_Str"" + imgName + ""String_Node_Str"");
        double[] overrideExtrema=renderer.getExtrema();
        if (min != null)         overrideExtrema[0]=min;
        if (max != null)         overrideExtrema[1]=max;
        result=service.applyColorScaleToImage(format,result,cs,renderer,overrideExtrema);
        log.debug(""String_Node_Str"" + imgName);
      }
      return service.getImageResponseWriter(format).write(result,imgName,bounds).build();
    }
 else {
      return service.renderKml(imgName,bounds,width,height,cs,zoomLevel,SecurityUtils.getProviderProperties());
    }
  }
 catch (  FileNotFoundException fnfe) {
    return Response.status(Status.NOT_FOUND).entity(fnfe.getMessage()).build();
  }
catch (  Exception e) {
    error=e.getMessage();
    log.error(""String_Node_Str"" + e.getMessage(),e);
  }
  return Response.serverError().entity(error).build();
}","@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") @GET @Produces(""String_Node_Str"") @Path(""String_Node_Str"") public Response getImage(@PathParam(""String_Node_Str"") String imgName,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") String format,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") String bbox,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") int width,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") int height,@QueryParam(""String_Node_Str"") String colorScaleName,@QueryParam(""String_Node_Str"") String colorScale,@QueryParam(""String_Node_Str"") Double min,@QueryParam(""String_Node_Str"") Double max,@QueryParam(""String_Node_Str"") String srs,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") int zoomLevel){
  String error;
  try {
    String[] bBoxValues=bbox.split(""String_Node_Str"");
    if (bBoxValues.length != 4) {
      return Response.status(Status.BAD_REQUEST).entity(""String_Node_Str"").build();
    }
    double minX=Double.valueOf(bBoxValues[0]);
    double minY=Double.valueOf(bBoxValues[1]);
    double maxX=Double.valueOf(bBoxValues[2]);
    double maxY=Double.valueOf(bBoxValues[3]);
    Bounds bounds=new Bounds(minX,minY,maxX,maxY);
    ColorScale cs=null;
    try {
      if (colorScaleName != null) {
        if (colorScale != null) {
          return Response.status(Status.BAD_REQUEST).entity(""String_Node_Str"").build();
        }
        cs=service.getColorScaleFromName(colorScaleName);
      }
 else       if (colorScale != null) {
        cs=service.getColorScaleFromJSON(colorScale);
      }
    }
 catch (    Exception e) {
      return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();
    }
    if (zoomLevel != -1) {
      MrsPyramid pyramid=service.getPyramid(imgName,SecurityUtils.getProviderProperties());
      if (pyramid == null) {
        return Response.status(Status.NOT_FOUND).entity(imgName + ""String_Node_Str"").build();
      }
      if (pyramid.getMetadata().getName(zoomLevel) == null) {
        return Response.status(Status.BAD_REQUEST).entity(""String_Node_Str"").build();
      }
    }
    if (!format.equals(KML_INPUT_FORMAT)) {
      MrsPyramid pyramid=service.getPyramid(imgName,SecurityUtils.getProviderProperties());
      if (pyramid == null) {
        return Response.status(Status.NOT_FOUND).entity(imgName + ""String_Node_Str"").build();
      }
      if (!bounds.toEnvelope().intersects(pyramid.getBounds().toEnvelope())) {
        log.debug(""String_Node_Str"");
        byte imageData[]=service.getEmptyTile(width,height,format);
        String type=service.getContentType(format);
        return Response.ok(imageData).header(""String_Node_Str"",type).build();
      }
      ImageRenderer renderer;
      try {
        renderer=service.getImageRenderer(format);
      }
 catch (      IllegalArgumentException e) {
        if (e.getMessage().toUpperCase().contains(""String_Node_Str"")) {
          return Response.status(Status.BAD_REQUEST).entity(""String_Node_Str"" + format).build();
        }
        throw e;
      }
      Raster result=renderer.renderImage(imgName,bounds,width,height,SecurityUtils.getProviderProperties(),srs);
      if (!(renderer instanceof TiffImageRenderer)) {
        log.debug(""String_Node_Str"" + imgName + ""String_Node_Str"");
        double[] overrideExtrema=renderer.getExtrema();
        if (min != null)         overrideExtrema[0]=min;
        if (max != null)         overrideExtrema[1]=max;
        result=service.applyColorScaleToImage(format,result,cs,renderer,overrideExtrema);
        log.debug(""String_Node_Str"" + imgName);
      }
      return service.getImageResponseWriter(format).write(result,imgName,bounds).build();
    }
 else {
      return service.renderKml(imgName,bounds,width,height,cs,zoomLevel,SecurityUtils.getProviderProperties());
    }
  }
 catch (  FileNotFoundException fnfe) {
    return Response.status(Status.NOT_FOUND).entity(fnfe.getMessage()).build();
  }
catch (  Exception e) {
    error=e.getMessage();
    log.error(""String_Node_Str"" + e.getMessage(),e);
  }
  return Response.serverError().entity(error).build();
}","The original code had an unnecessary reproject bounds operation that could potentially introduce coordinate system transformation errors. The fixed code removes the `bounds = RequestUtils.reprojectBounds(bounds, srs)` line, maintaining the original bounds without unnecessary transformation. This simplification ensures more accurate spatial processing and reduces potential coordinate system conversion artifacts."
94410,"private Response getCoverage(MultivaluedMap<String,String> allParams,ProviderProperties providerProperties){
  String versionStr=getQueryParam(allParams,""String_Node_Str"",WCS_VERSION);
  version=new Version(versionStr);
  String layer;
  if (version.isLess(""String_Node_Str"")) {
    layer=getQueryParam(allParams,""String_Node_Str"");
  }
 else {
    layer=getQueryParam(allParams,""String_Node_Str"");
  }
  if (layer == null) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
  String crs;
  Bounds bounds=null;
  try {
    if (version.isLess(""String_Node_Str"")) {
      bounds=getBoundsParam(allParams,""String_Node_Str"",null);
    }
 else {
      bounds=getBoundsParam(allParams,""String_Node_Str"",null);
    }
    crs=getCrsParam(allParams);
  }
 catch (  Exception e) {
    return writeError(Response.Status.BAD_REQUEST,e.getMessage());
  }
  String format=getQueryParam(allParams,""String_Node_Str"");
  if (format == null) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
  int width=getQueryParamAsInt(allParams,""String_Node_Str"",-1);
  if (width < 0) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
 else   if (width == 0) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
  int height=getQueryParamAsInt(allParams,""String_Node_Str"",-1);
  if (height < 0) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
 else   if (height == 0) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
  ImageRenderer renderer;
  try {
    renderer=(ImageRenderer)ImageHandlerFactory.getHandler(format,ImageRenderer.class);
  }
 catch (  Exception e) {
    return writeError(Response.Status.BAD_REQUEST,e.getMessage());
  }
  try {
    bounds=RequestUtils.reprojectBounds(bounds,crs);
  }
 catch (  Exception e) {
    return writeError(Response.Status.BAD_REQUEST,e.getMessage());
  }
  try {
    log.info(""String_Node_Str"" + layer);
    Raster result=renderer.renderImage(layer,bounds,width,height,providerProperties,crs);
    log.info(""String_Node_Str"");
    Response.ResponseBuilder builder=((ImageResponseWriter)ImageHandlerFactory.getHandler(format,ImageResponseWriter.class)).write(result,layer,bounds);
    log.info(""String_Node_Str"");
    return builder.build();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return writeError(Response.Status.BAD_REQUEST,e.getMessage());
  }
}","private Response getCoverage(MultivaluedMap<String,String> allParams,ProviderProperties providerProperties){
  String versionStr=getQueryParam(allParams,""String_Node_Str"",WCS_VERSION);
  version=new Version(versionStr);
  String layer;
  if (version.isLess(""String_Node_Str"")) {
    layer=getQueryParam(allParams,""String_Node_Str"");
  }
 else {
    layer=getQueryParam(allParams,""String_Node_Str"");
  }
  if (layer == null) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
  String crs;
  Bounds bounds=null;
  try {
    if (version.isLess(""String_Node_Str"")) {
      bounds=getBoundsParam(allParams,""String_Node_Str"",null);
    }
 else {
      bounds=getBoundsParam(allParams,""String_Node_Str"",null);
    }
    crs=getCrsParam(allParams);
  }
 catch (  Exception e) {
    return writeError(Response.Status.BAD_REQUEST,e.getMessage());
  }
  String format=getQueryParam(allParams,""String_Node_Str"");
  if (format == null) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
  int width=getQueryParamAsInt(allParams,""String_Node_Str"",-1);
  if (width < 0) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
 else   if (width == 0) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
  int height=getQueryParamAsInt(allParams,""String_Node_Str"",-1);
  if (height < 0) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
 else   if (height == 0) {
    return writeError(Response.Status.BAD_REQUEST,""String_Node_Str"");
  }
  ImageRenderer renderer;
  try {
    renderer=(ImageRenderer)ImageHandlerFactory.getHandler(format,ImageRenderer.class);
  }
 catch (  Exception e) {
    return writeError(Response.Status.BAD_REQUEST,e.getMessage());
  }
  try {
    log.info(""String_Node_Str"" + layer);
    Raster result=renderer.renderImage(layer,bounds,width,height,providerProperties,crs);
    log.info(""String_Node_Str"");
    Response.ResponseBuilder builder=((ImageResponseWriter)ImageHandlerFactory.getHandler(format,ImageResponseWriter.class)).write(result,layer,bounds);
    log.info(""String_Node_Str"");
    return builder.build();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return writeError(Response.Status.BAD_REQUEST,e.getMessage());
  }
}","The original code had redundant and repetitive conditional checks with identical branches, making the logic unnecessarily complex and potentially error-prone. The fixed code maintains the same structure but removes the unnecessary duplication in version and bounds parameter checks, simplifying the code without changing its core functionality. By eliminating redundant conditions, the code becomes more readable, maintainable, and less likely to introduce subtle bugs during future modifications."
94411,"@Override public RecordWriter<WritableComparable<?>,Writable> getRecordWriter(TaskAttemptContext context) throws IOException {
  Configuration conf=context.getConfiguration();
  CompressionCodec codec=null;
  SequenceFile.CompressionType compressionType=SequenceFile.CompressionType.NONE;
  if (getCompressOutput(context)) {
    compressionType=SequenceFileOutputFormat.getOutputCompressionType(context);
    codec=getCompressionCodec(context);
  }
  Path file=getDefaultWorkFile(context,""String_Node_Str"");
  final MapFile.Writer out=createMapFileWriter(context,codec,compressionType,file);
  return new Writer(out);
}","@Override public RecordWriter<WritableComparable<?>,Writable> getRecordWriter(TaskAttemptContext context) throws IOException {
  CompressionCodec codec=null;
  SequenceFile.CompressionType compressionType=SequenceFile.CompressionType.NONE;
  if (getCompressOutput(context)) {
    compressionType=SequenceFileOutputFormat.getOutputCompressionType(context);
    codec=getCompressionCodec(context);
  }
  Path file=getDefaultWorkFile(context,""String_Node_Str"");
  final MapFile.Writer out=createMapFileWriter(context,codec,compressionType,file);
  return new Writer(out);
}","The original code unnecessarily retrieved the configuration object using `context.getConfiguration()`, which was not used in the subsequent code block. In the fixed version, this redundant line was removed, eliminating an unnecessary method call and potential resource consumption. The streamlined code now directly focuses on handling compression and creating the MapFile.Writer, improving code efficiency and readability."
94412,"public static String getZoomName(final HdfsMrsImageDataProvider dp,final int zoomLevel){
  try {
    MrsPyramid pyramid=MrsPyramid.open(dp);
    MrsPyramidMetadata metadata=pyramid.getMetadata();
    String zoomName=pyramid.getMetadata().getName(zoomLevel);
    if (zoomName != null) {
      return new Path(dp.getResourcePath(true),zoomName).toUri().toString();
    }
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
  }
  return null;
}","public static String getZoomName(final HdfsMrsImageDataProvider dp,final int zoomLevel){
  try {
    MrsPyramid pyramid=MrsPyramid.open(dp);
    MrsPyramidMetadata metadata=pyramid.getMetadata();
    String zoomName=metadata.getName(zoomLevel);
    if (zoomName != null) {
      return new Path(dp.getResourcePath(true),zoomName).toUri().toString();
    }
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"",e);
  }
  return null;
}","The original code redundantly called `pyramid.getMetadata()` twice, which was unnecessary and potentially inefficient. The fixed code eliminates the redundant method call by directly using the `metadata` variable obtained earlier when retrieving the zoom name. This simplification reduces code complexity and improves readability while maintaining the same functional logic of retrieving the zoom name from the pyramid metadata."
94413,"@Override public int run(String[] args,Configuration conf,ProviderProperties providerProperties){
  try {
    long start=System.currentTimeMillis();
    CommandLine line;
    try {
      CommandLineParser parser=new GnuParser();
      line=parser.parse(options,args);
    }
 catch (    ParseException e) {
      System.out.println(e.getMessage());
      new HelpFormatter().printHelp(""String_Node_Str"",options);
      return -1;
    }
    if (line == null || line.hasOption(""String_Node_Str"")) {
      new HelpFormatter().printHelp(""String_Node_Str"",options);
      return -1;
    }
    boolean overrideNodata=line.hasOption(""String_Node_Str"");
    if (overrideNodata) {
      String str=line.getOptionValue(""String_Node_Str"");
      String[] strElements=str.split(""String_Node_Str"");
      nodataOverride=new Double[strElements.length];
      for (int i=0; i < nodataOverride.length; i++) {
        try {
          nodataOverride[i]=parseNoData(strElements[i]);
        }
 catch (        NumberFormatException nfe) {
          System.out.println(""String_Node_Str"" + strElements[i]);
          return -1;
        }
      }
    }
    boolean categorical=line.hasOption(""String_Node_Str"");
    boolean skipPyramids=line.hasOption(""String_Node_Str"");
    boolean recurse=!line.hasOption(""String_Node_Str"");
    skippreprocessing=line.hasOption(""String_Node_Str"");
    String output=line.getOptionValue(""String_Node_Str"");
    log.debug(""String_Node_Str"" + categorical);
    log.debug(""String_Node_Str"" + skipPyramids);
    log.debug(""String_Node_Str"" + output);
    List<String> inputs=new LinkedList<>();
    if (line.hasOption(""String_Node_Str"")) {
      zoomlevel=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
    }
    if (skippreprocessing && zoomlevel < 1) {
      log.error(""String_Node_Str"");
      return -1;
    }
    tilesize=Integer.parseInt(MrGeoProperties.getInstance().getProperty(MrGeoConstants.MRGEO_MRS_TILESIZE,MrGeoConstants.MRGEO_MRS_TILESIZE_DEFAULT));
    try {
      for (      String arg : line.getArgs()) {
        inputs.addAll(getInputs(arg,recurse,conf,true,false));
      }
    }
 catch (    IllegalArgumentException e) {
      System.out.println(e.getMessage());
      return -1;
    }
    log.info(""String_Node_Str"" + inputs.size() + ""String_Node_Str"");
    for (    String input : inputs) {
      log.info(""String_Node_Str"" + input);
    }
    if (line.hasOption(""String_Node_Str"")) {
      String rawTags=line.getOptionValue(""String_Node_Str"");
      String splittags[]=rawTags.split(""String_Node_Str"");
      for (      String t : splittags) {
        String[] s=t.split(""String_Node_Str"");
        if (s.length != 2) {
          log.error(""String_Node_Str"" + rawTags);
          return -1;
        }
        tags.put(s[0],s[1]);
      }
    }
    quick=quick | line.hasOption(""String_Node_Str"");
    local=local | line.hasOption(""String_Node_Str"");
    String protectionLevel=line.getOptionValue(""String_Node_Str"");
    if (inputs.size() > 0) {
      try {
        final boolean success;
        if (quick) {
          log.error(""String_Node_Str"");
          return -1;
        }
 else         if (local) {
          success=org.mrgeo.ingest.IngestImage.localIngest(inputs.toArray(new String[inputs.size()]),output,categorical,conf,bounds,zoomlevel,tilesize,nodata,bands,tiletype,tags,protectionLevel,providerProperties);
        }
 else {
          success=org.mrgeo.ingest.IngestImage.ingest(inputs.toArray(new String[inputs.size()]),output,categorical,conf,bounds,zoomlevel,tilesize,nodata,bands,tiletype,tags,protectionLevel,providerProperties);
        }
        if (!success) {
          log.error(""String_Node_Str"");
          return 1;
        }
        if (!skipPyramids) {
          Aggregator aggregator=new MeanAggregator();
          if (line.hasOption(""String_Node_Str"")) {
            aggregator=new ModeAggregator();
          }
 else           if (line.hasOption(""String_Node_Str"")) {
            aggregator=new SumAggregator();
          }
 else           if (line.hasOption(""String_Node_Str"")) {
            aggregator=new NearestAggregator();
          }
 else           if (line.hasOption(""String_Node_Str"")) {
            aggregator=new MinAggregator();
          }
 else           if (line.hasOption(""String_Node_Str"")) {
            aggregator=new MaxAggregator();
          }
 else           if (line.hasOption(""String_Node_Str"")) {
            aggregator=new MinAvgPairAggregator();
          }
          BuildPyramid.build(output,aggregator,conf,providerProperties);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        log.error(""String_Node_Str"",e);
        return 1;
      }
    }
    long end=System.currentTimeMillis();
    long duration=end - start;
    PeriodFormatter formatter=new PeriodFormatterBuilder().appendHours().appendSuffix(""String_Node_Str"").appendMinutes().appendSuffix(""String_Node_Str"").appendSeconds().appendSuffix(""String_Node_Str"").toFormatter();
    String formatted=formatter.print(new Period(duration));
    log.info(""String_Node_Str"" + formatted);
    return 0;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return -1;
}","@Override public int run(String[] args,Configuration conf,ProviderProperties providerProperties){
  try {
    long start=System.currentTimeMillis();
    CommandLine line;
    try {
      CommandLineParser parser=new GnuParser();
      line=parser.parse(options,args);
    }
 catch (    ParseException e) {
      System.out.println(e.getMessage());
      new HelpFormatter().printHelp(""String_Node_Str"",options);
      return -1;
    }
    if (line == null || line.hasOption(""String_Node_Str"")) {
      new HelpFormatter().printHelp(""String_Node_Str"",options);
      return -1;
    }
    boolean overrideNodata=line.hasOption(""String_Node_Str"");
    if (overrideNodata) {
      String str=line.getOptionValue(""String_Node_Str"");
      String[] strElements=str.split(""String_Node_Str"");
      nodataOverride=new Double[strElements.length];
      for (int i=0; i < nodataOverride.length; i++) {
        try {
          nodataOverride[i]=parseNoData(strElements[i]);
        }
 catch (        NumberFormatException nfe) {
          System.out.println(""String_Node_Str"" + strElements[i]);
          return -1;
        }
      }
    }
    boolean categorical=line.hasOption(""String_Node_Str"");
    boolean skipPyramids=line.hasOption(""String_Node_Str"");
    boolean recurse=!line.hasOption(""String_Node_Str"");
    skippreprocessing=line.hasOption(""String_Node_Str"");
    String output=line.getOptionValue(""String_Node_Str"");
    log.debug(""String_Node_Str"" + categorical);
    log.debug(""String_Node_Str"" + skipPyramids);
    log.debug(""String_Node_Str"" + output);
    List<String> inputs=new LinkedList<>();
    tilesize=Integer.parseInt(MrGeoProperties.getInstance().getProperty(MrGeoConstants.MRGEO_MRS_TILESIZE,MrGeoConstants.MRGEO_MRS_TILESIZE_DEFAULT));
    try {
      for (      String arg : line.getArgs()) {
        inputs.addAll(getInputs(arg,recurse,conf,true,false));
      }
    }
 catch (    IllegalArgumentException e) {
      System.out.println(e.getMessage());
      return -1;
    }
    if (line.hasOption(""String_Node_Str"")) {
      zoomlevel=Integer.parseInt(line.getOptionValue(""String_Node_Str""));
    }
    if (skippreprocessing && zoomlevel < 1) {
      log.error(""String_Node_Str"");
      return -1;
    }
    log.info(""String_Node_Str"" + inputs.size() + ""String_Node_Str"");
    for (    String input : inputs) {
      log.info(""String_Node_Str"" + input);
    }
    if (line.hasOption(""String_Node_Str"")) {
      String rawTags=line.getOptionValue(""String_Node_Str"");
      String splittags[]=rawTags.split(""String_Node_Str"");
      for (      String t : splittags) {
        String[] s=t.split(""String_Node_Str"");
        if (s.length != 2) {
          log.error(""String_Node_Str"" + rawTags);
          return -1;
        }
        tags.put(s[0],s[1]);
      }
    }
    quick=quick | line.hasOption(""String_Node_Str"");
    local=local | line.hasOption(""String_Node_Str"");
    String protectionLevel=line.getOptionValue(""String_Node_Str"");
    if (inputs.size() > 0) {
      try {
        final boolean success;
        if (quick) {
          log.error(""String_Node_Str"");
          return -1;
        }
 else         if (local) {
          success=org.mrgeo.ingest.IngestImage.localIngest(inputs.toArray(new String[inputs.size()]),output,categorical,conf,bounds,zoomlevel,tilesize,nodata,bands,tiletype,tags,protectionLevel,providerProperties);
        }
 else {
          success=org.mrgeo.ingest.IngestImage.ingest(inputs.toArray(new String[inputs.size()]),output,categorical,conf,bounds,zoomlevel,tilesize,nodata,bands,tiletype,tags,protectionLevel,providerProperties);
        }
        if (!success) {
          log.error(""String_Node_Str"");
          return 1;
        }
        if (!skipPyramids) {
          Aggregator aggregator=new MeanAggregator();
          if (line.hasOption(""String_Node_Str"")) {
            aggregator=new ModeAggregator();
          }
 else           if (line.hasOption(""String_Node_Str"")) {
            aggregator=new SumAggregator();
          }
 else           if (line.hasOption(""String_Node_Str"")) {
            aggregator=new NearestAggregator();
          }
 else           if (line.hasOption(""String_Node_Str"")) {
            aggregator=new MinAggregator();
          }
 else           if (line.hasOption(""String_Node_Str"")) {
            aggregator=new MaxAggregator();
          }
 else           if (line.hasOption(""String_Node_Str"")) {
            aggregator=new MinAvgPairAggregator();
          }
          BuildPyramid.build(output,aggregator,conf,providerProperties);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        log.error(""String_Node_Str"",e);
        return 1;
      }
    }
    long end=System.currentTimeMillis();
    long duration=end - start;
    PeriodFormatter formatter=new PeriodFormatterBuilder().appendHours().appendSuffix(""String_Node_Str"").appendMinutes().appendSuffix(""String_Node_Str"").appendSeconds().appendSuffix(""String_Node_Str"").toFormatter();
    String formatted=formatter.print(new Period(duration));
    log.info(""String_Node_Str"" + formatted);
    return 0;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return -1;
}","The buggy code incorrectly placed the zoom level parsing before checking input size and preprocessing conditions, potentially causing unexpected behavior with invalid inputs. In the fixed code, the zoom level parsing is moved after input collection and preprocessing checks, ensuring proper validation sequence and preventing potential runtime errors. This restructuring improves code reliability by enforcing a more logical execution flow and preventing premature zoom level assignment before input validation."
94414,"public static String read(DataInputStream stream) throws IOException {
  byte[] data=new byte[stream.readInt()];
  stream.readFully(data);
  return new String(data,""String_Node_Str"");
}","public static String read(DataInputStream stream) throws IOException {
  int len=stream.readInt();
  if (len == -1) {
    return null;
  }
 else {
    byte[] data=new byte[len];
    stream.readFully(data);
    return new String(data,""String_Node_Str"");
  }
}","The original code lacks handling for scenarios where the length read from the stream might be negative or indicate a null/empty string, potentially causing unexpected runtime errors. The fixed code adds a critical check to explicitly handle negative length values by returning null, preventing potential array allocation or reading issues. This improvement makes the string reading method more robust by gracefully managing edge cases and preventing potential null pointer or negative array size exceptions."
94415,"public static void write(String str,DataOutputStream stream) throws IOException {
  byte[] data=str.getBytes(""String_Node_Str"");
  stream.writeInt(data.length);
  stream.write(data);
}","public static void write(String str,DataOutputStream stream) throws IOException {
  if (str == null) {
    stream.writeInt(-1);
  }
 else {
    byte[] data=str.getBytes(""String_Node_Str"");
    stream.writeInt(data.length);
    stream.write(data);
  }
}","The original code lacks null handling, which could cause a NullPointerException if a null string is passed to the method. The fixed code adds a null check that writes a special length marker (-1) when the string is null, preventing potential runtime errors. This modification makes the method more robust by gracefully handling null input scenarios while maintaining the original serialization logic."
94416,"public static boolean canOpen(String input,ProviderProperties providerProperties) throws AccumuloException, AccumuloSecurityException, IOException {
  initConnectionInfo();
  ParseResults results=parseResourceName(input);
  initDataSource(results.namespace);
  DataSourceEntry entry=getDataSourceEntry(results.namespace);
  ByteArrayId adapterId=new ByteArrayId(results.name);
  DataAdapter<?> adapter=entry.adapterStore.getAdapter(adapterId);
  if (adapter == null) {
    return false;
  }
  return checkAuthorizations(adapterId,results.namespace,providerProperties);
}","public static boolean canOpen(String input,ProviderProperties providerProperties) throws AccumuloException, AccumuloSecurityException, IOException {
  initConnectionInfo();
  ParseResults results=parseResourceName(input);
  try {
    initDataSource(results.namespace);
    DataSourceEntry entry=getDataSourceEntry(results.namespace);
    ByteArrayId adapterId=new ByteArrayId(results.name);
    DataAdapter<?> adapter=entry.adapterStore.getAdapter(adapterId);
    if (adapter == null) {
      return false;
    }
    return checkAuthorizations(adapterId,results.namespace,providerProperties);
  }
 catch (  IllegalArgumentException e) {
    log.info(""String_Node_Str"" + input + ""String_Node_Str""+ e.getMessage());
  }
  return false;
}","The original code lacked error handling for potential runtime exceptions during resource initialization and adapter retrieval. The fixed code introduces a try-catch block to gracefully handle IllegalArgumentException, logging the error and preventing unhandled exceptions from breaking the method's execution. By adding error logging and a default return of false, the method becomes more resilient and provides a predictable response when resource access encounters unexpected issues."
94417,"public void beforePaintingTile(final long tileId){
  if (aggregationType == AggregationType.MIN) {
    composite=new MinCompositeDouble();
  }
 else   if (aggregationType == AggregationType.MAX) {
    composite=new MaxCompositeDouble();
  }
 else   if (aggregationType == AggregationType.MASK) {
    composite=new MaskComposite(1.0,0.0,Double.NaN);
  }
 else   if (aggregationType == AggregationType.GAUSSIAN) {
    composite=new GaussianComposite();
  }
 else {
    composite=new AdditiveCompositeDouble();
  }
  raster=RasterUtils.createEmptyRaster(tileSize,tileSize,1,DataBuffer.TYPE_DOUBLE,Double.NaN);
  totalRaster=null;
  if (aggregationType == AggregationType.AVERAGE) {
    totalRaster=raster.createCompatibleWritableRaster();
    final BufferedImage bi=RasterUtils.makeBufferedImage(totalRaster);
    final Graphics2D gr=bi.createGraphics();
    totalComposite=new AdditiveComposite();
    gr.setComposite(new AdditiveComposite());
    gr.setStroke(new BasicStroke(0));
    totalPainter=new GeometryPainter(gr,totalRaster,new Color(1,1,1),new Color(0,0,0));
  }
  final BufferedImage bi=RasterUtils.makeBufferedImage(raster);
  final Graphics2D gr=bi.createGraphics();
  gr.setComposite(composite);
  gr.setStroke(new BasicStroke(0));
  rasterPainter=new GeometryPainter(gr,raster,new Color(1,1,1),new Color(0,0,0));
  final Tile tile=TMSUtils.tileid(tileId,zoom);
  final TMSUtils.Bounds tb=TMSUtils.tileBounds(tile.tx,tile.ty,zoom,tileSize);
  Bounds b=new Bounds(tb.w,tb.s,tb.e,tb.n);
  rasterPainter.setBounds(b);
}","public void beforePaintingTile(final long tileId){
  if (aggregationType == AggregationType.MIN) {
    composite=new MinCompositeDouble();
  }
 else   if (aggregationType == AggregationType.MAX) {
    composite=new MaxCompositeDouble();
  }
 else   if (aggregationType == AggregationType.MASK) {
    composite=new MaskComposite(1.0,0.0,Double.NaN);
  }
 else   if (aggregationType == AggregationType.GAUSSIAN) {
    composite=new GaussianComposite();
  }
 else {
    composite=new AdditiveCompositeDouble();
  }
  raster=RasterUtils.createEmptyRaster(tileSize,tileSize,1,DataBuffer.TYPE_DOUBLE,Double.NaN);
  totalRaster=null;
  final Tile tile=TMSUtils.tileid(tileId,zoom);
  final TMSUtils.Bounds tb=TMSUtils.tileBounds(tile.tx,tile.ty,zoom,tileSize);
  Bounds b=new Bounds(tb.w,tb.s,tb.e,tb.n);
  if (aggregationType == AggregationType.AVERAGE) {
    totalRaster=raster.createCompatibleWritableRaster();
    final BufferedImage bi=RasterUtils.makeBufferedImage(totalRaster);
    final Graphics2D gr=bi.createGraphics();
    gr.setComposite(new AdditiveComposite());
    gr.setStroke(new BasicStroke(0));
    totalPainter=new GeometryPainter(gr,totalRaster,new Color(1,1,1),new Color(0,0,0));
    totalPainter.setBounds(b);
  }
  final BufferedImage bi=RasterUtils.makeBufferedImage(raster);
  final Graphics2D gr=bi.createGraphics();
  gr.setComposite(composite);
  gr.setStroke(new BasicStroke(0));
  rasterPainter=new GeometryPainter(gr,raster,new Color(1,1,1),new Color(0,0,0));
  rasterPainter.setBounds(b);
}","The original code created tile bounds and set raster painter bounds after the AVERAGE aggregation logic, potentially missing critical initialization for the total painter. The fixed code moves tile identification and bounds creation before the aggregation-specific logic, ensuring consistent bounds setting for both total and raster painters. This reorganization guarantees proper tile context establishment and prevents potential spatial referencing errors across different aggregation types."
94418,"private static void findInputs(final FileStatus status,final FileSystem fs,final PathFilter inputFilter,List<FileStatus> result) throws IOException {
  if (status.isDir()) {
    for (    FileStatus childStat : fs.listStatus(status.getPath(),inputFilter)) {
      if (childStat.isDir()) {
        findInputs(childStat,fs,inputFilter,result);
      }
 else {
        result.add(childStat);
      }
    }
  }
 else {
    result.add(status);
  }
}","private static void findInputs(final FileStatus status,final FileSystem fs,final PathFilter inputFilter,List<FileStatus> result) throws IOException {
  if (status.isDirectory()) {
    for (    FileStatus childStat : fs.listStatus(status.getPath(),inputFilter)) {
      if (childStat.isDirectory()) {
        findInputs(childStat,fs,inputFilter,result);
      }
 else {
        result.add(childStat);
      }
    }
  }
 else {
    result.add(status);
  }
}","The original code used `isDir()`, which might not consistently check directory status across different file systems or implementations. The fixed code replaces `isDir()` with `isDirectory()`, a more standard and reliable method for determining directory status in file system operations. This change ensures more consistent and predictable behavior when traversing file hierarchies and filtering file statuses across different file system implementations."
94419,"@Override public List<InputSplit> getSplits(JobContext context) throws IOException {
  Configuration conf=context.getConfiguration();
  TiledInputFormatContext ifContext=TiledInputFormatContext.load(conf);
  final int zoom=ifContext.getZoomLevel();
  final int tilesize=ifContext.getTileSize();
  HdfsMrsImageDataProvider dp=new HdfsMrsImageDataProvider(context.getConfiguration(),input,null);
  Path inputWithZoom=new Path(dp.getResourcePath(true),""String_Node_Str"" + zoom);
  org.mrgeo.hdfs.tile.FileSplit splitfile=new org.mrgeo.hdfs.tile.FileSplit();
  splitfile.readSplits(inputWithZoom);
  MrsImagePyramidMetadataReader metadataReader=dp.getMetadataReader();
  MrsImagePyramidMetadata metadata=metadataReader.read();
  List<InputSplit> actualSplits=super.getSplits(context);
  List<InputSplit> result=new ArrayList<InputSplit>(actualSplits.size());
  for (  InputSplit actualSplit : actualSplits) {
    if (!(actualSplit instanceof FileSplit)) {
      throw new IOException(""String_Node_Str"" + actualSplit.getClass().getCanonicalName());
    }
    FileSplit fileSplit=(FileSplit)actualSplit;
    String partFile=fileSplit.getPath().getParent().getName();
    if (!partFile.startsWith(""String_Node_Str"")) {
      throw new IOException(""String_Node_Str"" + partFile);
    }
    org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo splitinfo;
    try {
      splitinfo=(org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo)splitfile.getSplitByName(partFile);
    }
 catch (    Splits.SplitNotFoundException e) {
      LOG.info(""String_Node_Str"" + super.getClass().getName() + ""String_Node_Str""+ partFile);
      continue;
    }
    long endTileId=splitinfo.getEndId();
    long startTileId=splitinfo.getStartId();
    TMSUtils.Tile startTile=TMSUtils.tileid(startTileId,zoom);
    TMSUtils.Tile endTile=TMSUtils.tileid(endTileId,zoom);
    TileBounds partFileTileBounds=new TileBounds(startTile.tx,startTile.ty,endTile.tx,endTile.ty);
    Bounds partFileBounds=TMSUtils.tileToBounds(partFileTileBounds,zoom,tilesize);
    if (ifContext.getBounds() != null) {
      Bounds requestedBounds=ifContext.getBounds().getTMSBounds();
      if (requestedBounds.intersect(partFileBounds,false)) {
        Bounds intersected=requestedBounds.intersection(partFileBounds,false);
        TMSUtils.TileBounds tb=TMSUtils.boundsToTile(intersected,zoom,tilesize);
        long s=TMSUtils.tileid(tb.w,tb.s,zoom);
        long e=TMSUtils.tileid(tb.e,tb.n,zoom);
        result.add(new TiledInputSplit(actualSplit,s,e,zoom,metadata.getTilesize()));
      }
    }
 else {
      result.add(new TiledInputSplit(actualSplit,startTileId,endTileId,ifContext.getZoomLevel(),metadata.getTilesize()));
    }
  }
  return result;
}","@Override public List<InputSplit> getSplits(JobContext context) throws IOException {
  long start=System.currentTimeMillis();
  Configuration conf=context.getConfiguration();
  TiledInputFormatContext ifContext=TiledInputFormatContext.load(conf);
  final int zoom=ifContext.getZoomLevel();
  final int tilesize=ifContext.getTileSize();
  HdfsMrsImageDataProvider dp=new HdfsMrsImageDataProvider(context.getConfiguration(),input,null);
  Path inputWithZoom=new Path(dp.getResourcePath(true),""String_Node_Str"" + zoom);
  org.mrgeo.hdfs.tile.FileSplit splitfile=new org.mrgeo.hdfs.tile.FileSplit();
  splitfile.readSplits(inputWithZoom);
  MrsImagePyramidMetadataReader metadataReader=dp.getMetadataReader();
  MrsImagePyramidMetadata metadata=metadataReader.read();
  org.mrgeo.hdfs.tile.FileSplit fsplit=new org.mrgeo.hdfs.tile.FileSplit();
  fsplit.readSplits(inputWithZoom);
  org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo[] splits=(org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo[])fsplit.getSplits();
  List<InputSplit> result=new ArrayList<InputSplit>(splits.length);
  final Bounds requestedBounds;
  if (ifContext.getBounds() != null) {
    requestedBounds=ifContext.getBounds().getTMSBounds();
  }
 else {
    requestedBounds=null;
  }
  for (  org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo split : splits) {
    final Path part=new Path(inputWithZoom,split.getName());
    final Path dataFile=new Path(part,MapFile.DATA_FILE_NAME);
    final FileSystem fs=HadoopFileUtils.getFileSystem(conf,dataFile);
    final BlockLocation[] blocks=fs.getFileBlockLocations(dataFile,0,Integer.MAX_VALUE);
    final long endTileId=split.getEndId();
    final long startTileId=split.getStartId();
    final TMSUtils.Tile startTile=TMSUtils.tileid(startTileId,zoom);
    final TMSUtils.Tile endTile=TMSUtils.tileid(endTileId,zoom);
    final TileBounds partFileTileBounds=new TileBounds(startTile.tx,startTile.ty,endTile.tx,endTile.ty);
    final Bounds partFileBounds=TMSUtils.tileToBounds(partFileTileBounds,zoom,tilesize);
    if (requestedBounds != null) {
      if (requestedBounds.intersect(partFileBounds,false)) {
        Bounds intersected=requestedBounds.intersection(partFileBounds,false);
        TMSUtils.TileBounds tb=TMSUtils.boundsToTile(intersected,zoom,tilesize);
        long s=TMSUtils.tileid(tb.w,tb.s,zoom);
        long e=TMSUtils.tileid(tb.e,tb.n,zoom);
        for (        BlockLocation block : blocks) {
          result.add(new TiledInputSplit(new FileSplit(dataFile,block.getOffset(),block.getLength(),block.getHosts()),s,e,zoom,metadata.getTilesize()));
        }
      }
    }
 else {
      for (      BlockLocation block : blocks) {
        result.add(new TiledInputSplit(new FileSplit(dataFile,block.getOffset(),block.getLength(),block.getHosts()),startTileId,endTileId,zoom,metadata.getTilesize()));
      }
    }
  }
  long end=System.currentTimeMillis();
  log.info(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  return result;
}","The original code used `super.getSplits()` without proper handling of input splits, leading to potential processing errors and incomplete data coverage. The fixed code replaces the split generation with a more robust approach by directly reading file splits, iterating through them, and creating input splits based on block locations and requested bounds. This modification ensures more accurate and granular tile-based data processing, improving split generation efficiency and reducing potential data access issues."
94420,"@Override public void teardownForSpark(final Configuration conf) throws DataProviderException {
  performTeardown(conf);
}","@Override public void teardownForSpark(final Configuration conf) throws DataProviderException {
}","The original code calls `performTeardown(conf)` unnecessarily, which could lead to unintended side effects or redundant operations during Spark teardown. The fixed code removes the `performTeardown(conf)` method call, leaving an empty method implementation that meets the method signature without executing any potentially harmful or unnecessary actions. By simplifying the method to an empty implementation, the code ensures a clean, predictable teardown process that avoids potential runtime errors or unexpected behavior."
94421,"@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeDouble(minX);
  out.writeDouble(minY);
  out.writeDouble(maxX);
  out.writeDouble(maxY);
}","@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeBoolean(set);
  if (set) {
    out.writeDouble(minX);
    out.writeDouble(minY);
    out.writeDouble(maxX);
    out.writeDouble(maxY);
  }
}","The original code assumes the rectangle is always initialized, potentially writing uninitialized or default values when the rectangle is not set. The fixed code introduces a boolean flag 'set' to check if the rectangle has been properly initialized before writing its coordinates. This approach prevents writing invalid data and ensures only valid, meaningful rectangle information is externalized during serialization."
94422,"@Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  minX=in.readDouble();
  minY=in.readDouble();
  maxX=in.readDouble();
  maxY=in.readDouble();
}","@Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  set=in.readBoolean();
  if (set) {
    minX=in.readDouble();
    minY=in.readDouble();
    maxX=in.readDouble();
    maxY=in.readDouble();
  }
}","The original code assumes all doubles are always read, which can lead to incorrect deserialization if the object was not fully initialized. The fixed code introduces a boolean flag 'set' to check whether the bounding coordinates were actually defined before reading the double values. This approach prevents potential null or unintended coordinate reads, making the external serialization more robust and preventing potential runtime errors during object reconstruction."
94423,"private boolean saveSingleTile(final String output,final MrsImage image,String format,final long tileid,final int zoom,int tilesize){
  try {
    final MrsImagePyramidMetadata metadata=image.getMetadata();
    final TMSUtils.Tile t=TMSUtils.tileid(tileid,zoom);
    Raster raster=image.getTile(t.tx,t.ty);
    log.info(""String_Node_Str"" + t.tx + ""String_Node_Str""+ t.ty);
    if (raster != null) {
      String out=makeOutputName(output,format,tileid,zoom,tilesize);
      if (colorscale != null || !format.equals(""String_Node_Str"")) {
        ColorScaleApplier applier=null;
switch (format) {
case ""String_Node_Str"":
case ""String_Node_Str"":
          applier=new PngColorScaleApplier();
        break;
case ""String_Node_Str"":
case ""String_Node_Str"":
      applier=new JpegColorScaleApplier();
    break;
}
if (applier != null) {
  raster=applier.applyColorScale(raster,colorscale,image.getExtrema(),image.getMetadata().getDefaultValues());
}
}
GDALUtils.saveRaster(raster,out,format,t.tx,t.ty,image.getZoomlevel(),image.getTilesize(),metadata.getDefaultValue(0));
System.out.println(""String_Node_Str"" + out);
return true;
}
log.info(""String_Node_Str"");
}
 catch (final Exception e) {
e.printStackTrace();
}
return false;
}","private boolean saveSingleTile(final String output,final MrsImage image,String format,final long tileid,final int zoom,int tilesize){
  try {
    final MrsImagePyramidMetadata metadata=image.getMetadata();
    final TMSUtils.Tile t=TMSUtils.tileid(tileid,zoom);
    Raster raster=image.getTile(t.tx,t.ty);
    log.info(""String_Node_Str"" + t.tx + ""String_Node_Str""+ t.ty);
    if (raster != null) {
      String out=makeOutputName(output,format,tileid,zoom,tilesize);
      if (colorscale != null || !format.equals(""String_Node_Str"")) {
        ColorScaleApplier applier=null;
switch (format) {
case ""String_Node_Str"":
case ""String_Node_Str"":
          applier=new PngColorScaleApplier();
        break;
case ""String_Node_Str"":
case ""String_Node_Str"":
      applier=new JpegColorScaleApplier();
    break;
}
if (applier != null) {
  raster=applier.applyColorScale(raster,colorscale,image.getExtrema(),image.getMetadata().getDefaultValues());
}
}
GDALJavaUtils.saveRasterTile(raster,out,t.tx,t.ty,image.getZoomlevel(),metadata.getDefaultValue(0),format);
System.out.println(""String_Node_Str"" + out);
return true;
}
log.info(""String_Node_Str"");
}
 catch (final Exception e) {
e.printStackTrace();
}
return false;
}","The original code used an incorrect method `GDALUtils.saveRaster()` with mismatched parameters for saving raster tiles. The fixed code replaces this with `GDALJavaUtils.saveRasterTile()`, which has a more appropriate signature and correctly handles tile-specific saving parameters like tile coordinates and zoom level. This change ensures more accurate and reliable tile rendering, improving the overall robustness of the image processing functionality."
94424,"private boolean saveMultipleTiles(String output,String format,final MrsImage image,final long[] tiles){
  try {
    final MrsImagePyramidMetadata metadata=image.getMetadata();
    Raster raster=RasterTileMerger.mergeTiles(image,tiles);
    Raster sampleRaster=null;
    TMSUtils.Bounds imageBounds=null;
    long minId=tiles[0];
    final int tilesize=image.getTilesize();
    final int zoomlevel=image.getZoomlevel();
    for (    final long lid : tiles) {
      if (minId > lid) {
        minId=lid;
      }
      final TMSUtils.Tile tile=TMSUtils.tileid(lid,zoomlevel);
      final TMSUtils.Bounds bounds=TMSUtils.tileBounds(tile.tx,tile.ty,zoomlevel,tilesize);
      if (imageBounds == null) {
        imageBounds=bounds;
      }
 else {
        imageBounds.expand(bounds);
      }
      if (sampleRaster == null) {
        try {
          sampleRaster=image.getTile(tile.tx,tile.ty);
        }
 catch (        final TileNotFoundException e) {
        }
      }
    }
    if (imageBounds == null) {
      throw new MrsImageException(""String_Node_Str"");
    }
    if (sampleRaster == null) {
      throw new MrsImageException(""String_Node_Str"");
    }
    String out=makeOutputName(output,format,minId,zoomlevel,tilesize);
    if (colorscale != null || !format.equals(""String_Node_Str"")) {
      ColorScaleApplier applier=null;
switch (format) {
case ""String_Node_Str"":
case ""String_Node_Str"":
        applier=new PngColorScaleApplier();
      break;
case ""String_Node_Str"":
case ""String_Node_Str"":
    applier=new JpegColorScaleApplier();
  break;
}
if (applier != null) {
raster=applier.applyColorScale(raster,colorscale,image.getExtrema(),image.getMetadata().getDefaultValues());
}
}
GDALUtils.saveRaster(raster,out,format,imageBounds,zoomlevel,tilesize,metadata.getDefaultValue(0));
System.out.println(""String_Node_Str"" + out);
return true;
}
 catch (final Exception e) {
e.printStackTrace();
}
return false;
}","private boolean saveMultipleTiles(String output,String format,final MrsImage image,final long[] tiles){
  try {
    final MrsImagePyramidMetadata metadata=image.getMetadata();
    Raster raster=RasterTileMerger.mergeTiles(image,tiles);
    Raster sampleRaster=null;
    TMSUtils.Bounds imageBounds=null;
    long minId=tiles[0];
    final int tilesize=image.getTilesize();
    final int zoomlevel=image.getZoomlevel();
    for (    final long lid : tiles) {
      if (minId > lid) {
        minId=lid;
      }
      final TMSUtils.Tile tile=TMSUtils.tileid(lid,zoomlevel);
      final TMSUtils.Bounds bounds=TMSUtils.tileBounds(tile.tx,tile.ty,zoomlevel,tilesize);
      if (imageBounds == null) {
        imageBounds=bounds;
      }
 else {
        imageBounds.expand(bounds);
      }
      if (sampleRaster == null) {
        try {
          sampleRaster=image.getTile(tile.tx,tile.ty);
        }
 catch (        final TileNotFoundException e) {
        }
      }
    }
    if (imageBounds == null) {
      throw new MrsImageException(""String_Node_Str"");
    }
    if (sampleRaster == null) {
      throw new MrsImageException(""String_Node_Str"");
    }
    String out=makeOutputName(output,format,minId,zoomlevel,tilesize);
    if (colorscale != null || !format.equals(""String_Node_Str"")) {
      ColorScaleApplier applier=null;
switch (format) {
case ""String_Node_Str"":
case ""String_Node_Str"":
        applier=new PngColorScaleApplier();
      break;
case ""String_Node_Str"":
case ""String_Node_Str"":
    applier=new JpegColorScaleApplier();
  break;
}
if (applier != null) {
raster=applier.applyColorScale(raster,colorscale,image.getExtrema(),image.getMetadata().getDefaultValues());
}
}
GDALJavaUtils.saveRaster(raster,out,imageBounds,metadata.getDefaultValue(0),format);
System.out.println(""String_Node_Str"" + out);
return true;
}
 catch (final Exception e) {
e.printStackTrace();
}
return false;
}","The original code had an incorrect method call to `GDALUtils.saveRaster()` with mismatched parameters, potentially causing runtime errors. The fixed code updates the method call to `GDALJavaUtils.saveRaster()` with the correct parameter sequence, ensuring proper raster saving and metadata handling. By aligning the method signature and reducing potential parameter mismatches, the code becomes more robust and less prone to unexpected exceptions during tile saving operations."
94425,"List<String> getInputs(String arg,boolean recurse,final Configuration conf,boolean existsCheck,boolean argIsDir){
  List<String> inputs=new LinkedList<>();
  File f;
  try {
    f=new File(new URI(arg));
  }
 catch (  URISyntaxException|IllegalArgumentException ignored) {
    f=new File(arg);
  }
  if (f.isDirectory()) {
    File[] dir=f.listFiles();
    if (dir != null) {
      for (      File s : dir) {
        try {
          if (s.isFile() || (s.isDirectory() && recurse)) {
            inputs.addAll(getInputs(s.getCanonicalFile().toURI().toString(),recurse,conf,false,s.isDirectory()));
          }
        }
 catch (        IOException ignored) {
        }
      }
    }
  }
 else   if (f.isFile()) {
    try {
      System.out.print(""String_Node_Str"" + f.getCanonicalPath());
      String name=f.getCanonicalFile().toURI().toString();
      if (skippreprocessing) {
        if (firstInput) {
          firstInput=false;
          Dataset dataset=GDALUtils.open(name);
          if (dataset != null) {
            try {
              calculateMinimalParams(dataset);
            }
  finally {
              GDALUtils.close(dataset);
            }
          }
        }
        inputs.add(name);
        local=true;
        System.out.println(""String_Node_Str"");
      }
 else {
        Dataset dataset=GDALUtils.open(name);
        if (dataset != null) {
          calculateParams(dataset);
          GDALUtils.close(dataset);
          inputs.add(name);
          local=true;
          System.out.println(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
    }
 catch (    IOException ignored) {
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    try {
      Path p=new Path(arg);
      FileSystem fs=HadoopFileUtils.getFileSystem(conf,p);
      if (!existsCheck || fs.exists(p)) {
        boolean isADirectory=argIsDir;
        if (existsCheck) {
          FileStatus status=fs.getFileStatus(p);
          isADirectory=status.isDirectory();
        }
        if (isADirectory && recurse) {
          FileStatus[] files=fs.listStatus(p);
          for (          FileStatus file : files) {
            inputs.addAll(getInputs(file.getPath().toUri().toString(),true,conf,false,file.isDirectory()));
          }
        }
 else {
          try {
            System.out.print(""String_Node_Str"" + p.toString());
            String name=p.toUri().toString();
            if (skippreprocessing) {
              if (firstInput) {
                firstInput=false;
                Dataset dataset=GDALUtils.open(name);
                if (dataset != null) {
                  try {
                    calculateMinimalParams(dataset);
                  }
  finally {
                    GDALUtils.close(dataset);
                  }
                }
              }
              inputs.add(name);
              System.out.println(""String_Node_Str"");
            }
 else {
              Dataset dataset=GDALUtils.open(name);
              if (dataset != null) {
                calculateParams(dataset);
                GDALUtils.close(dataset);
                inputs.add(name);
                System.out.println(""String_Node_Str"");
              }
 else {
                System.out.println(""String_Node_Str"");
              }
            }
          }
 catch (          IOException ignored) {
            System.out.println(""String_Node_Str"");
          }
        }
      }
    }
 catch (    IOException ignored) {
    }
  }
  return inputs;
}","List<String> getInputs(String arg,boolean recurse,final Configuration conf,boolean existsCheck,boolean argIsDir){
  List<String> inputs=new LinkedList<>();
  File f;
  try {
    f=new File(new URI(arg));
  }
 catch (  URISyntaxException|IllegalArgumentException ignored) {
    f=new File(arg);
  }
  if (f.isDirectory()) {
    File[] dir=f.listFiles();
    if (dir != null) {
      for (      File s : dir) {
        try {
          if (s.isFile() || (s.isDirectory() && recurse)) {
            inputs.addAll(getInputs(s.getCanonicalFile().toURI().toString(),recurse,conf,false,s.isDirectory()));
          }
        }
 catch (        IOException ignored) {
        }
      }
    }
  }
 else   if (f.isFile()) {
    try {
      System.out.print(""String_Node_Str"" + f.getCanonicalPath());
      String name=f.getCanonicalFile().toURI().toString();
      if (skippreprocessing) {
        if (firstInput) {
          firstInput=false;
          Dataset dataset=GDALUtils.open(name);
          if (dataset != null) {
            try {
              calculateMinimalParams(dataset);
            }
  finally {
              GDALUtils.close(dataset);
            }
          }
        }
        inputs.add(name);
        local=true;
        System.out.println(""String_Node_Str"");
      }
 else {
        Dataset dataset=GDALUtils.open(name);
        if (dataset != null) {
          calculateParams(dataset);
          GDALUtils.close(dataset);
          inputs.add(name);
          local=true;
          System.out.println(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
    }
 catch (    IOException ignored) {
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    try {
      Path p=new Path(arg);
      FileSystem fs=HadoopFileUtils.getFileSystem(conf,p);
      if (!existsCheck || fs.exists(p)) {
        boolean isADirectory=argIsDir;
        if (existsCheck) {
          FileStatus status=fs.getFileStatus(p);
          isADirectory=status.isDirectory();
        }
        if (isADirectory && recurse) {
          FileStatus[] files=fs.listStatus(p);
          for (          FileStatus file : files) {
            inputs.addAll(getInputs(file.getPath().toUri().toString(),true,conf,false,file.isDirectory()));
          }
        }
 else {
          System.out.print(""String_Node_Str"" + p.toString());
          String name=p.toUri().toString();
          if (skippreprocessing) {
            if (firstInput) {
              firstInput=false;
              Dataset dataset=GDALUtils.open(name);
              if (dataset != null) {
                try {
                  calculateMinimalParams(dataset);
                }
  finally {
                  GDALUtils.close(dataset);
                }
              }
            }
            inputs.add(name);
            System.out.println(""String_Node_Str"");
          }
 else {
            Dataset dataset=GDALUtils.open(name);
            if (dataset != null) {
              calculateParams(dataset);
              GDALUtils.close(dataset);
              inputs.add(name);
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.println(""String_Node_Str"");
            }
          }
        }
      }
    }
 catch (    IOException ignored) {
    }
  }
  return inputs;
}","The original code had an unnecessary nested try-catch block when handling non-directory Hadoop file paths, which could suppress important exceptions and lead to silent failures. The fixed code removes the redundant try-catch block and directly processes the Hadoop file path without an extra layer of exception handling. This simplifies the error handling, improves code readability, and ensures more robust file path processing by eliminating unnecessary complexity."
94426,"@Override public int run(String[] args,Configuration conf,final ProviderProperties providerProperties){
  long t0=System.currentTimeMillis();
  System.out.println(log.getClass().getName());
  Options options=MapAlgebra.createOptions();
  CommandLine line=null;
  try {
    CommandLineParser parser=new PosixParser();
    line=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.out.println();
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return 1;
  }
  if (line == null || line.hasOption(""String_Node_Str"")) {
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return 1;
  }
  String expression=line.getOptionValue(""String_Node_Str"");
  String output=line.getOptionValue(""String_Node_Str"");
  String script=line.getOptionValue(""String_Node_Str"");
  if (expression == null && script == null) {
    System.out.println(""String_Node_Str"");
    System.out.println();
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return 1;
  }
  try {
    if (script != null) {
      File f=new File(script);
      byte[] buffer=new byte[(int)f.length()];
      FileInputStream fis=new FileInputStream(f);
      fis.read(buffer);
      expression=new String(buffer);
      fis.close();
    }
    String protectionLevel=line.getOptionValue(""String_Node_Str"");
    log.debug(""String_Node_Str"" + expression);
    log.debug(""String_Node_Str"" + output);
    Job job=new Job();
    job.setJobName(""String_Node_Str"");
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(output,AccessMode.OVERWRITE,providerProperties);
    String useProtectionLevel=ProtectionLevelUtils.getAndValidateProtectionLevel(dp,protectionLevel);
    ProgressHierarchy progress=new ProgressHierarchy();
    boolean valid=org.mrgeo.mapalgebra.MapAlgebra.validate(expression,providerProperties);
    if (valid) {
      org.mrgeo.mapalgebra.MapAlgebra.mapalgebra(expression,output,conf,providerProperties,useProtectionLevel);
    }
    if (progress.isFailed()) {
      throw new JobFailedException(progress.getResult());
    }
    System.out.println(""String_Node_Str"" + output + ""String_Node_Str""+ ((System.currentTimeMillis() - t0) / 1000.0)+ ""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
    return 1;
  }
catch (  JobFailedException e) {
    e.printStackTrace();
    return 1;
  }
catch (  JobCancelledException e) {
    e.printStackTrace();
    return 1;
  }
catch (  Exception e) {
    e.printStackTrace();
    return -1;
  }
  return 0;
}","@Override public int run(String[] args,Configuration conf,final ProviderProperties providerProperties){
  long t0=System.currentTimeMillis();
  System.out.println(log.getClass().getName());
  Options options=MapAlgebra.createOptions();
  CommandLine line=null;
  try {
    CommandLineParser parser=new PosixParser();
    line=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.out.println();
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return 1;
  }
  if (line == null || line.hasOption(""String_Node_Str"")) {
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return 1;
  }
  String expression=line.getOptionValue(""String_Node_Str"");
  String output=line.getOptionValue(""String_Node_Str"");
  String script=line.getOptionValue(""String_Node_Str"");
  if (expression == null && script == null) {
    System.out.println(""String_Node_Str"");
    System.out.println();
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return 1;
  }
  try {
    if (script != null) {
      File f=new File(script);
      byte[] buffer=new byte[(int)f.length()];
      FileInputStream fis=new FileInputStream(f);
      fis.read(buffer);
      expression=new String(buffer);
      fis.close();
    }
    String protectionLevel=line.getOptionValue(""String_Node_Str"");
    log.debug(""String_Node_Str"" + expression);
    log.debug(""String_Node_Str"" + output);
    Job job=new Job();
    job.setJobName(""String_Node_Str"");
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(output,AccessMode.OVERWRITE,providerProperties);
    String useProtectionLevel=ProtectionLevelUtils.getAndValidateProtectionLevel(dp,protectionLevel);
    ProgressHierarchy progress=new ProgressHierarchy();
    boolean valid=org.mrgeo.mapalgebra.MapAlgebra.validate(expression,providerProperties);
    if (valid) {
      org.mrgeo.mapalgebra.MapAlgebra.mapalgebra(expression,output,conf,providerProperties,useProtectionLevel);
    }
    if (progress.isFailed()) {
      throw new JobFailedException(progress.getResult());
    }
    if (line.hasOption(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      BuildPyramid.build(output,new MeanAggregator(),conf,providerProperties);
    }
    System.out.println(""String_Node_Str"" + output + ""String_Node_Str""+ ((System.currentTimeMillis() - t0) / 1000.0)+ ""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
    return 1;
  }
catch (  JobFailedException e) {
    e.printStackTrace();
    return 1;
  }
catch (  JobCancelledException e) {
    e.printStackTrace();
    return 1;
  }
catch (  Exception e) {
    e.printStackTrace();
    return -1;
  }
  return 0;
}","The original code lacked pyramid building functionality and did not handle an optional pyramid construction step. The fixed code adds a conditional pyramid build process using `BuildPyramid.build()` when the specific option is present, which allows for optional image pyramid generation. This improvement enhances the code's flexibility by providing users with the ability to create image pyramids after map algebra processing, potentially improving subsequent image rendering and access performance."
94427,"public static WritableRaster makeRasterWritable(final Raster raster){
  return Raster.createWritableRaster(raster.getSampleModel(),raster.getDataBuffer(),null);
}","public static WritableRaster makeRasterWritable(final Raster raster){
  if (raster instanceof WritableRaster) {
    return (WritableRaster)raster;
  }
  return Raster.createWritableRaster(raster.getSampleModel(),raster.getDataBuffer(),null);
}","The original code blindly attempts to create a writable raster without checking if the input raster is already writable, potentially causing unnecessary object creation. The fixed code first checks if the input raster is an instance of WritableRaster, and if so, directly casts and returns it, avoiding redundant raster generation. This optimization reduces computational overhead and ensures efficient handling of different raster types by only creating a new writable raster when strictly necessary."
94428,"private static void copyPixel(final int x,final int y,final int b,final Raster src,final WritableRaster dst,double[] nodatas){
switch (src.getTransferType()) {
case DataBuffer.TYPE_BYTE:
{
      final byte p=(byte)src.getSample(x,y,b);
      if (p != (byte)nodatas[b]) {
        dst.setSample(x,y,b,p);
      }
      break;
    }
case DataBuffer.TYPE_FLOAT:
{
    final float p=src.getSampleFloat(x,y,b);
    if (!Float.isNaN(p) && p != (float)nodatas[b]) {
      dst.setSample(x,y,b,p);
    }
    break;
  }
case DataBuffer.TYPE_DOUBLE:
{
  final double p=src.getSampleDouble(x,y,b);
  if (!Double.isNaN(p) && p != nodatas[b]) {
    dst.setSample(x,y,b,p);
  }
  break;
}
case DataBuffer.TYPE_INT:
{
final int p=src.getSample(x,y,b);
if (p != (int)nodatas[b]) {
  dst.setSample(x,y,b,p);
}
break;
}
case DataBuffer.TYPE_SHORT:
{
final short p=(short)src.getSample(x,y,b);
if (p != (short)nodatas[b]) {
dst.setSample(x,y,b,p);
}
break;
}
case DataBuffer.TYPE_USHORT:
{
final int p=src.getSample(x,y,b);
if (p != (int)nodatas[b]) {
dst.setSample(x,y,b,p);
}
break;
}
}
}","private static void copyPixel(final int x,final int y,final int b,final Raster src,final WritableRaster dst,Number nodata){
switch (src.getTransferType()) {
case DataBuffer.TYPE_BYTE:
{
      final byte p=(byte)src.getSample(x,y,b);
      if (p != nodata.byteValue()) {
        dst.setSample(x,y,b,p);
      }
      break;
    }
case DataBuffer.TYPE_FLOAT:
{
    final float p=src.getSampleFloat(x,y,b);
    if (!Float.isNaN(p) && p != nodata.floatValue()) {
      dst.setSample(x,y,b,p);
    }
    break;
  }
case DataBuffer.TYPE_DOUBLE:
{
  final double p=src.getSampleDouble(x,y,b);
  if (!Double.isNaN(p) && p != nodata.doubleValue()) {
    dst.setSample(x,y,b,p);
  }
  break;
}
case DataBuffer.TYPE_INT:
{
final int p=src.getSample(x,y,b);
if (p != nodata.intValue()) {
  dst.setSample(x,y,b,p);
}
break;
}
case DataBuffer.TYPE_SHORT:
{
final short p=(short)src.getSample(x,y,b);
if (p != nodata.shortValue()) {
dst.setSample(x,y,b,p);
}
break;
}
case DataBuffer.TYPE_USHORT:
{
final int p=src.getSample(x,y,b);
if (p != nodata.shortValue()) {
dst.setSample(x,y,b,p);
}
break;
}
}
}","The original code uses a fixed array of nodata values, which lacks type flexibility and requires manual array indexing. The fixed code replaces the nodata array with a generic Number parameter, using appropriate value methods like intValue() or floatValue() to handle different data types dynamically. This approach simplifies type conversion, increases method flexibility, and removes the need for complex array access, making the pixel copying process more robust and easier to maintain."
94429,"@Override public void readAttributes(DataInputStream stream) throws IOException {
  int attrs=stream.readInt();
  for (int i=0; i < attrs; i++) {
    String key=stream.readUTF();
    String value=stream.readUTF();
    attributes.put(key,value);
  }
}","@Override public void readAttributes(DataInputStream stream) throws IOException {
  int attrs=stream.readInt();
  for (int i=0; i < attrs; i++) {
    String key=stream.readUTF();
    String value=StringUtils.read(stream);
    attributes.put(key,value);
  }
}","The original code assumes all attribute values are UTF-encoded strings, which may not handle complex value representations or potential null values correctly. The fixed code replaces `stream.readUTF()` with `StringUtils.read(stream)`, suggesting a more robust method for reading string values that can handle variable-length or potentially null data. This change enhances the method's flexibility and resilience when reading attribute values from the input stream."
94430,"@Override public void writeAttributes(DataOutputStream stream) throws IOException {
  stream.writeInt(attributes.size());
  for (  Map.Entry<String,String> attr : attributes.entrySet()) {
    stream.writeUTF(attr.getKey());
    stream.writeUTF(attr.getValue());
  }
}","@Override public void writeAttributes(DataOutputStream stream) throws IOException {
  stream.writeInt(attributes.size());
  for (  Map.Entry<String,String> attr : attributes.entrySet()) {
    stream.writeUTF(attr.getKey());
    StringUtils.write(attr.getValue(),stream);
  }
}","The original code directly writes string values using `writeUTF()`, which may fail for null or very long strings. The fixed code replaces direct `writeUTF()` with `StringUtils.write()`, which provides safer and more robust string serialization handling potential edge cases like null values. This change ensures more reliable and consistent attribute writing during data stream output."
94431,"public static Path createJobTmp() throws IOException {
  return createUniqueTmp();
}","public static Path createJobTmp(Configuration conf) throws IOException {
  return createUniqueTmp(conf);
}","The original code lacks a crucial configuration parameter needed to create a unique temporary directory, potentially leading to file system conflicts. The fixed code adds a `Configuration` parameter, allowing proper temporary directory creation with system-specific settings. By passing the configuration, the method now ensures robust, context-aware temporary file generation that respects the underlying system's requirements."
94432,"/** 
 * Creates a unique path but doesn't create a directory.
 * @return A new unique temporary path
 * @throws IOException
 */
public static Path createUniqueTmpPath() throws IOException {
  return new Path(getTempDir(),HadoopUtils.createRandomString(40));
}","public static Path createUniqueTmpPath(Configuration conf) throws IOException {
  return new Path(getTempDir(conf),HadoopUtils.createRandomString(40));
}","The original code lacks a crucial configuration parameter, making it unable to determine the correct temporary directory in a configurable Hadoop environment. The fixed code introduces a `Configuration` parameter, allowing dynamic specification of the temporary directory path based on system or user-defined settings. This modification enhances flexibility and ensures the method works correctly across different Hadoop cluster configurations."
94433,"/** 
 * Creates a unique temp directory and returns the path.
 * @return
 * @throws IOException
 */
public static Path createUniqueTmp() throws IOException {
  final Path tmp=createUniqueTmpPath();
  final FileSystem fs=HadoopFileUtils.getFileSystem(tmp);
  if (!fs.exists(tmp)) {
    fs.mkdirs(tmp);
  }
  return tmp;
}","/** 
 * Creates a unique temp directory and returns the path.
 * @return
 * @throws IOException
 */
public static Path createUniqueTmp(Configuration conf) throws IOException {
  final Path tmp=createUniqueTmpPath(conf);
  final FileSystem fs=HadoopFileUtils.getFileSystem(tmp);
  if (!fs.exists(tmp)) {
    fs.mkdirs(tmp);
  }
  return tmp;
}","The original code lacks a Configuration parameter, making it unable to specify Hadoop-specific settings for temp directory creation. The fixed code adds a Configuration parameter to createUniqueTmpPath() and createUniqueTmp(), enabling more flexible and configurable temporary directory generation. This modification allows users to provide custom Hadoop configuration, improving the method's versatility and control over file system operations."
94434,"private static ShapefileGeometryCollection loadGeometryCollection(Configuration conf) throws IOException {
  if (conf.get(""String_Node_Str"") != null) {
    Path path=new Path(conf.get(""String_Node_Str""));
    if (path.toString().toLowerCase().endsWith(""String_Node_Str"")) {
      ShapefileReader sr=new ShapefileReader(path);
      ReprojectedShapefileGeometryCollection rgc=new ReprojectedShapefileGeometryCollection(sr,GDALUtils.EPSG4326);
      return rgc;
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","private static ShapefileGeometryCollection loadGeometryCollection(Configuration conf) throws IOException {
  if (conf.get(""String_Node_Str"") != null) {
    Path path=new Path(conf.get(""String_Node_Str""));
    if (path.toString().toLowerCase().endsWith(""String_Node_Str"")) {
      ShapefileReader sr=new ShapefileReader(path);
      ReprojectedShapefileGeometryCollection rgc=new ReprojectedShapefileGeometryCollection(sr,GDALUtils.EPSG4326());
      return rgc;
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","The original code incorrectly attempts to use `GDALUtils.EPSG4326` as a direct value, which likely refers to a method call rather than a static field. In the fixed code, `GDALUtils.EPSG4326()` is called as a method, suggesting it returns the desired coordinate reference system. This correction ensures the proper initialization of the `ReprojectedShapefileGeometryCollection` with the correct geographic coordinate system reference."
94435,"private void internalLoader(SeekableDataInput shp,SeekableDataInput shx,SeekableDataInput dbf,InputStream prj,int cachesize) throws FormatException, IOException {
  mode=""String_Node_Str"";
  try {
    index=ShxFile.open(shx,true,cachesize);
    index.load();
    shape=new ShpFile(index,this);
    shape.load(shp);
    table=DbaseFile.open(dbf,true,cachesize,""String_Node_Str"");
  }
 catch (  IOException e) {
    throw e;
  }
catch (  FormatException e) {
    throw e;
  }
catch (  Exception e) {
    e.printStackTrace();
    throw new IOException(""String_Node_Str"",e);
  }
  projection=null;
  if (prj != null) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(prj));
    String tmp=reader.readLine();
    if (tmp != null && tmp.trim().compareTo(""String_Node_Str"") != 0) {
      projection=tmp;
    }
  }
  if (projection == null) {
    projection=GDALUtils.EPSG4326;
  }
}","private void internalLoader(SeekableDataInput shp,SeekableDataInput shx,SeekableDataInput dbf,InputStream prj,int cachesize) throws FormatException, IOException {
  mode=""String_Node_Str"";
  try {
    index=ShxFile.open(shx,true,cachesize);
    index.load();
    shape=new ShpFile(index,this);
    shape.load(shp);
    table=DbaseFile.open(dbf,true,cachesize,""String_Node_Str"");
  }
 catch (  IOException e) {
    throw e;
  }
catch (  FormatException e) {
    throw e;
  }
catch (  Exception e) {
    e.printStackTrace();
    throw new IOException(""String_Node_Str"",e);
  }
  projection=null;
  if (prj != null) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(prj));
    String tmp=reader.readLine();
    if (tmp != null && tmp.trim().compareTo(""String_Node_Str"") != 0) {
      projection=tmp;
    }
  }
  if (projection == null) {
    projection=GDALUtils.EPSG4326();
  }
}","The original code had a potential issue with the default projection assignment due to a static method call syntax error. In the fixed code, `GDALUtils.EPSG4326()` is correctly called as a method, ensuring proper initialization of the default projection. This correction guarantees that the projection is reliably set to the standard WGS 84 coordinate reference system when no specific projection is provided."
94436,"/** 
 * Loading metadata from an InputStream.  The objects of the file are stored in a json format.  This enables the ObjectMapper to parse out the values correctly.
 * @param stream - the stream attached to the metadata input
 * @return a valid MrsImagePyramidMetadata object
 * @throws JsonGenerationException
 * @throws JsonMappingException
 * @throws IOException
 */
public static MrsImagePyramidMetadata load(final InputStream stream) throws JsonGenerationException, JsonMappingException, IOException {
  final ObjectMapper mapper=new ObjectMapper();
  final MrsImagePyramidMetadata metadata=mapper.readValue(stream,MrsImagePyramidMetadata.class);
  return metadata;
}","/** 
 * Loading metadata from an InputStream.  The objects of the file are stored in a json format.  This enables the ObjectMapper to parse out the values correctly.
 * @param stream - the stream attached to the metadata input
 * @return a valid MrsImagePyramidMetadata object
 * @throws JsonGenerationException
 * @throws JsonMappingException
 * @throws IOException
 */
public static MrsImagePyramidMetadata load(final InputStream stream) throws JsonGenerationException, JsonMappingException, IOException {
  final ObjectMapper mapper=new ObjectMapper();
  return mapper.readValue(stream,MrsImagePyramidMetadata.class);
}","The original code unnecessarily created a separate metadata variable before returning it, which was redundant and added no value to the method's logic. The fixed code directly returns the result of `mapper.readValue()`, eliminating the extra variable and streamlining the method. This change makes the code more concise, readable, and maintains the same functionality of parsing the input stream into a `MrsImagePyramidMetadata` object."
94437,"private static void writeAttributes(final DataOutput out,final Geometry g) throws IOException {
  out.writeInt(g.getAllAttributes().size());
  for (  Map.Entry attr : g.getAllAttributesSorted().entrySet()) {
    out.writeUTF(attr.getKey().toString());
    byte[] attrBytes=attr.getValue().toString().getBytes(CHAR_ENCODING);
    out.writeInt(attrBytes.length);
    out.write(attrBytes);
  }
}","private static void writeAttributes(final DataOutput out,final Geometry g) throws IOException {
  out.writeInt(g.getAllAttributes().size());
  for (  Map.Entry attr : g.getAllAttributesSorted().entrySet()) {
    out.writeUTF(attr.getKey().toString());
    StringUtils.write(attr.getValue().toString(),out);
  }
}","The original code manually converts attribute values to byte arrays using a specific character encoding, which can be error-prone and inefficient. The fixed code replaces manual byte array conversion with `StringUtils.write()`, a utility method that handles string serialization more robustly and consistently. This simplifies the code, reduces potential encoding errors, and provides a more standardized approach to writing string attributes to a data output stream."
94438,"public static Bounds getBounds(final Dataset image){
  final double[] xform=image.GetGeoTransform();
  SpatialReference srs=new SpatialReference(image.GetProjection());
  SpatialReference dst=new SpatialReference(EPSG4326);
  CoordinateTransformation tx=osr.CreateCoordinateTransformation(srs,dst);
  double w=image.GetRasterXSize();
  double h=image.GetRasterYSize();
  double[] c1;
  double[] c2;
  double[] c3;
  double[] c4;
  if (tx != null) {
    c1=tx.TransformPoint(xform[0],xform[3]);
    c2=tx.TransformPoint(xform[0] + xform[1] * w,xform[3] + xform[5] * h);
    c3=tx.TransformPoint(xform[0] + xform[1] * w,xform[3]);
    c4=tx.TransformPoint(xform[0],xform[3] + xform[5] * h);
  }
 else {
    c1=new double[]{xform[0],xform[3]};
    c2=new double[]{xform[0] + xform[1] * w,xform[3] + xform[5] * h};
    c3=new double[]{xform[0] + xform[1] * w,xform[3]};
    c4=new double[]{xform[0],xform[3] + xform[5] * h};
  }
  return new Bounds(Math.min(Math.min(c1[0],c2[0]),Math.min(c3[0],c4[0])),Math.min(Math.min(c1[1],c2[1]),Math.min(c3[1],c4[1])),Math.max(Math.max(c1[0],c2[0]),Math.max(c3[0],c4[0])),Math.max(Math.max(c1[1],c2[1]),Math.max(c3[1],c4[1])));
}","public static Bounds getBounds(final Dataset image){
  final double[] xform=image.GetGeoTransform();
  SpatialReference srs=new SpatialReference(image.GetProjection());
  SpatialReference dst=new SpatialReference(EPSG4326);
  CoordinateTransformation tx=new CoordinateTransformation(srs,dst);
  double w=image.GetRasterXSize();
  double h=image.GetRasterYSize();
  double[] c1;
  double[] c2;
  double[] c3;
  double[] c4;
  if (tx != null) {
    c1=tx.TransformPoint(xform[0],xform[3]);
    c2=tx.TransformPoint(xform[0] + xform[1] * w,xform[3] + xform[5] * h);
    c3=tx.TransformPoint(xform[0] + xform[1] * w,xform[3]);
    c4=tx.TransformPoint(xform[0],xform[3] + xform[5] * h);
  }
 else {
    c1=new double[]{xform[0],xform[3]};
    c2=new double[]{xform[0] + xform[1] * w,xform[3] + xform[5] * h};
    c3=new double[]{xform[0] + xform[1] * w,xform[3]};
    c4=new double[]{xform[0],xform[3] + xform[5] * h};
  }
  return new Bounds(Math.min(Math.min(c1[0],c2[0]),Math.min(c3[0],c4[0])),Math.min(Math.min(c1[1],c2[1]),Math.min(c3[1],c4[1])),Math.max(Math.max(c1[0],c2[0]),Math.max(c3[0],c4[0])),Math.max(Math.max(c1[1],c2[1]),Math.max(c3[1],c4[1])));
}","The original code incorrectly used `osr.CreateCoordinateTransformation()` method, which is likely an invalid or undefined method for creating coordinate transformations. The fixed code replaces this with `new CoordinateTransformation(srs, dst)`, which correctly instantiates a coordinate transformation object between spatial references. This modification ensures proper coordinate system conversion, allowing accurate geospatial coordinate transformations for determining image bounds."
94439,"/** 
 * Return an instance of a RecordWriter class to be used in map/reduce jobs for writing vector data.
 * @return
 */
public abstract RecordWriter<LongWritable,Geometry> getRecordWriter();","/** 
 * Return an instance of a RecordWriter class to be used in map/reduce jobs for writing vector data.
 * @return
 */
public abstract RecordWriter<FeatureIdWritable,Geometry> getRecordWriter();","The original code used `LongWritable` as the key type, which is inappropriate for identifying vector features in map/reduce jobs. The fixed code replaces `LongWritable` with `FeatureIdWritable`, a more semantically correct and specialized type for feature identification. This modification ensures precise feature tracking, enhances type safety, and provides a more robust mechanism for handling vector data in distributed processing environments."
94440,"/** 
 * Return an instance of a RecordReader class to be used in map/reduce jobs for reading vector data.
 * @return
 */
public abstract RecordReader<LongWritable,Geometry> getRecordReader() throws IOException ;","/** 
 * Return an instance of a RecordReader class to be used in map/reduce jobs for reading vector data.
 * @return
 */
public abstract RecordReader<FeatureIdWritable,Geometry> getRecordReader() throws IOException ;","The original code used LongWritable as the key type, which inadequately represents feature identifiers in vector data processing. The fixed code replaces LongWritable with FeatureIdWritable, a more appropriate and semantically meaningful type for tracking unique feature identifiers. This change ensures better data management and more precise feature tracking during map/reduce geospatial data operations."
94441,"@Override public RecordReader<LongWritable,Geometry> createRecordReader(InputSplit split,TaskAttemptContext context) throws IOException, InterruptedException {
  return new VectorRecordReader();
}","@Override public RecordReader<FeatureIdWritable,Geometry> createRecordReader(InputSplit split,TaskAttemptContext context) throws IOException, InterruptedException {
  return new VectorRecordReader();
}","The original code uses incorrect key types for the RecordReader, potentially causing type mismatches and data handling errors. The fixed code replaces LongWritable with FeatureIdWritable, which is more appropriate for vector data processing and ensures type-safe key-value pair handling. This modification enhances the method's accuracy and prevents potential runtime type conversion issues in geospatial data processing."
94442,"/** 
 * Returns an instance of an InputFormat for the data provider that is responsible for translating the keys and values from the native InputFormat to LongWritable keys and Geometry values.
 * @return
 */
public abstract InputFormat<LongWritable,Geometry> getInputFormat(String input);","/** 
 * Returns an instance of an InputFormat for the data provider that is responsible for translating the keys and values from the native InputFormat to FeatureIdWritable keys and Geometry values.
 * @return
 */
public abstract InputFormat<FeatureIdWritable,Geometry> getInputFormat(String input);","The original code used LongWritable as the key type, which may not accurately represent unique feature identifiers. The fixed code replaces LongWritable with FeatureIdWritable, a more semantically appropriate key type for geospatial data that ensures unique feature identification. This change enhances data integrity and provides a more precise mapping between input data and its spatial representation."
94443,"/** 
 * Returns an instance of an OutputFormat for the data provider that is responsible for translating the keys and values from the native InputFormat to LongWritable keys and Geometry values.
 * @return
 */
public OutputFormat<LongWritable,Geometry> getOutputFormat(String input);","/** 
 * Returns an instance of an OutputFormat for the data provider that is responsible for translating the keys and values from the native InputFormat to FeatureIdWritable keys and Geometry values.
 * @return
 */
public OutputFormat<FeatureIdWritable,Geometry> getOutputFormat(String input);","The original code used `LongWritable` as the key type, which is inappropriate for feature-based geospatial data processing. The fixed code replaces `LongWritable` with `FeatureIdWritable`, a more semantically accurate key type specifically designed for handling feature identifiers in geospatial contexts. This change ensures more precise key representation and enables better mapping between input and output formats during data transformation."
94444,"/** 
 * Return an iterator that allows the caller to visit all geometries within this reader that fall within the specified bounds. The caller is responsible for calling the close() method on the returned iterator when they are done with it. It is possible that the last call to the next() method of the returned iterator could give back a null value, so the caller should test for that.
 * @return
 */
public abstract CloseableKVIterator<LongWritable,Geometry> get(final Bounds bounds) throws IOException ;","/** 
 * Return an iterator that allows the caller to visit all geometries within this reader that fall within the specified bounds. The caller is responsible for calling the close() method on the returned iterator when they are done with it. It is possible that the last call to the next() method of the returned iterator could give back a null value, so the caller should test for that.
 * @return
 */
public abstract CloseableKVIterator<FeatureIdWritable,Geometry> get(final Bounds bounds) throws IOException ;","The original code incorrectly uses LongWritable as the key type for the iterator, which doesn't appropriately represent feature identification. The fixed code replaces LongWritable with FeatureIdWritable, a more semantically correct type for identifying geospatial features in the iterator. This change ensures more precise and meaningful feature tracking when iterating through geometries within specified bounds."
94445,"/** 
 * Returns true if there is a feature with the specified featureId. For non-indexed data sources (like delimited text), this method will iterate through all of the features until it finds the one that matches the specified featureId.
 * @param featureId
 * @return
 * @throws IOException
 */
public abstract boolean exists(LongWritable featureId) throws IOException ;","/** 
 * Returns true if there is a feature with the specified featureId. For non-indexed data sources (like delimited text), this method will iterate through all of the features until it finds the one that matches the specified featureId.
 * @param featureId
 * @return
 * @throws IOException
 */
public abstract boolean exists(FeatureIdWritable featureId) throws IOException ;","The buggy code uses `LongWritable` as the parameter type, which may not accurately represent feature identifiers in all contexts. The fixed code replaces `LongWritable` with `FeatureIdWritable`, a more specialized and precise type for handling feature identifiers. By using a dedicated `FeatureIdWritable`, the method becomes more robust and flexible, allowing for better type-specific handling of feature identification across different data sources."
94446,"@Override public LongWritable getCurrentKey() throws IOException, InterruptedException {
  return delegate.getCurrentKey();
}","@Override public FeatureIdWritable getCurrentKey() throws IOException, InterruptedException {
  return delegate.getCurrentKey();
}","The original code uses LongWritable as the return type, which may not accurately represent the key's semantic meaning in the context of feature identification. The fixed code replaces LongWritable with FeatureIdWritable, providing a more precise and domain-specific type for representing feature identifiers. This change enhances code clarity, type safety, and maintains better alignment with the specific data model being used in the implementation."
94447,"public abstract void append(final LongWritable key,final Geometry value) throws IOException ;","public abstract void append(final FeatureIdWritable key,final Geometry value) throws IOException ;","The original code uses LongWritable, which is unsuitable for identifying geospatial features, potentially leading to incorrect key representation and feature tracking. The fixed code replaces LongWritable with FeatureIdWritable, a more appropriate type specifically designed to uniquely identify and manage geospatial feature metadata. This change ensures precise feature identification, enables better spatial data management, and provides a more semantically meaningful key for geospatial operations."
94448,"@Override public RecordWriter<LongWritable,Geometry> getRecordWriter(TaskAttemptContext context) throws IOException, InterruptedException {
  String baseOut=getOutputPath(context).toString();
  String extension=baseOut.substring(baseOut.length() - 4);
  Path output=getDefaultWorkFile(context,extension);
  CsvRecordWriter result=new CsvRecordWriter(new Path(baseOut + ""String_Node_Str""),output);
  return result;
}","@Override public RecordWriter<FeatureIdWritable,Geometry> getRecordWriter(TaskAttemptContext context) throws IOException, InterruptedException {
  String baseOut=getOutputPath(context).toString();
  String extension=baseOut.substring(baseOut.length() - 4);
  Path output=getDefaultWorkFile(context,extension);
  CsvRecordWriter result=new CsvRecordWriter(new Path(baseOut + ""String_Node_Str""),output);
  return result;
}","The original code incorrectly uses LongWritable as the input key type, which doesn't match the expected input for the record writer. The fixed code changes the input key type to FeatureIdWritable, aligning with the correct data model and ensuring type consistency. This modification improves type safety and prevents potential runtime errors when processing geospatial data in a MapReduce context."
94449,"@Override public void write(LongWritable key,Geometry value) throws IOException {
  if (first) {
    first=false;
    writeColumns(value);
  }
  boolean useDelim=false;
  if (writeGeometry) {
    if (value.isValid() && !value.isEmpty()) {
      writeCell(value.toJTS().toString());
    }
    useDelim=true;
  }
  for (  String attribute : attributes) {
    if (useDelim) {
      writer.append(delimiter);
    }
    useDelim=true;
    Object cell=value.getAttribute(attribute);
    if (cell != null) {
      writeCell(cell.toString());
    }
  }
  writer.append(""String_Node_Str"");
}","@Override public void write(FeatureIdWritable key,Geometry value) throws IOException {
  if (first) {
    first=false;
    writeColumns(value);
  }
  boolean useDelim=false;
  if (writeGeometry) {
    if (value.isValid() && !value.isEmpty()) {
      writeCell(value.toJTS().toString());
    }
    useDelim=true;
  }
  for (  String attribute : attributes) {
    if (useDelim) {
      writer.append(delimiter);
    }
    useDelim=true;
    Object cell=value.getAttribute(attribute);
    if (cell != null) {
      writeCell(cell.toString());
    }
  }
  writer.append(""String_Node_Str"");
}","The original code uses an incorrect key type `LongWritable` for a geometry writing method, which could lead to type mismatches and potential runtime errors. The fixed code changes the key type to `FeatureIdWritable`, which is more appropriate for handling geometric feature identifiers in spatial data processing. This correction ensures type consistency and improves the method's compatibility with geospatial data structures."
94450,"@Override public LongWritable currentKey(){
  return key;
}","@Override public FeatureIdWritable currentKey(){
  return key;
}","The original code incorrectly uses LongWritable as the return type for currentKey(), which does not match the context of the method. The fixed code changes the return type to FeatureIdWritable, aligning the method signature with the expected data type for feature identification. This modification ensures type consistency and prevents potential runtime errors by returning the correct writable type specific to feature keys."
94451,"@Test @Category(IntegrationTest.class) public void testDestPtOutsideCostSurface() throws IOException, ParserException, JobCancelledException {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + costSurface + ""String_Node_Str""+ ""String_Node_Str"";
  try {
    LeastCostPathMapOpIntegrationTest.runLeastCostPath(HadoopUtils.createConfiguration(),testUtils.getOutputHdfs(),""String_Node_Str"",exp,true,50000f,0f,0d,0d,0d);
  }
 catch (  JobFailedException e) {
    boolean ret=e.getMessage().contains(""String_Node_Str"");
    Assert.assertEquals(true,ret);
  }
}","@Test @Category(IntegrationTest.class) public void testDestPtOutsideCostSurface() throws IOException, ParserException, JobCancelledException {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + costSurface + ""String_Node_Str""+ ""String_Node_Str"";
  try {
    LeastCostPathMapOpIntegrationTest.runLeastCostPath(conf,testUtils.getOutputHdfs(),""String_Node_Str"",exp,true,50000f,0f,0d,0d,0d);
  }
 catch (  JobFailedException e) {
    boolean ret=e.getMessage().contains(""String_Node_Str"");
    Assert.assertEquals(true,ret);
  }
}","The original code used an undefined `HadoopUtils.createConfiguration()` instead of the correct configuration object `conf`. The fixed code replaces the undefined method with the `conf` parameter, which likely represents a properly initialized Hadoop configuration object. This change ensures the method receives a valid configuration, preventing potential runtime errors and allowing the least cost path calculation to execute correctly with the intended configuration settings."
94452,"@Test @Category(IntegrationTest.class) public void testLeastCostPath() throws IOException, ParserException, JobFailedException, JobCancelledException {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + costSurface + ""String_Node_Str""+ ""String_Node_Str"";
  LeastCostPathMapOpIntegrationTest.runLeastCostPath(HadoopUtils.createConfiguration(),testUtils.getOutputHdfs(),""String_Node_Str"",exp,true,48064f,62920.9f,0.9d,2.0d,1.3d);
}","@Test @Category(IntegrationTest.class) public void testLeastCostPath() throws IOException, ParserException, JobFailedException, JobCancelledException {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + costSurface + ""String_Node_Str""+ ""String_Node_Str"";
  LeastCostPathMapOpIntegrationTest.runLeastCostPath(conf,testUtils.getOutputHdfs(),""String_Node_Str"",exp,true,48064f,62920.9f,0.9d,2.0d,1.3d);
}","The original code used an undefined variable `HadoopUtils.createConfiguration()` instead of the likely intended configuration variable `conf`. This undefined configuration could cause runtime errors or unexpected behavior during test execution. The fixed code replaces the undefined method with `conf`, which presumably is a properly initialized configuration object, ensuring correct method invocation and reliable test setup. By using the correct configuration parameter, the code now supports proper integration test execution with the intended Hadoop configuration."
94453,"@Test @Category(IntegrationTest.class) public void testLeastCostPathWithZoom() throws IOException, ParserException, JobFailedException, JobCancelledException {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + costSurface + ""String_Node_Str""+ ""String_Node_Str""+ LOWER_ZOOM_LEVEL+ ""String_Node_Str"";
  try {
    LeastCostPathMapOpIntegrationTest.runLeastCostPath(HadoopUtils.createConfiguration(),testUtils.getOutputHdfs(),""String_Node_Str"",exp,true,48064f,62920.9f,0.9d,2.0d,1.3d);
  }
 catch (  JobFailedException e) {
    Assert.assertTrue(e.getMessage().indexOf(""String_Node_Str"") >= 0);
  }
}","@Test @Category(IntegrationTest.class) public void testLeastCostPathWithZoom() throws IOException, ParserException, JobFailedException, JobCancelledException {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + costSurface + ""String_Node_Str""+ ""String_Node_Str""+ LOWER_ZOOM_LEVEL+ ""String_Node_Str"";
  try {
    LeastCostPathMapOpIntegrationTest.runLeastCostPath(conf,testUtils.getOutputHdfs(),""String_Node_Str"",exp,true,48064f,62920.9f,0.9d,2.0d,1.3d);
  }
 catch (  JobFailedException e) {
    Assert.assertTrue(e.getMessage().indexOf(""String_Node_Str"") >= 0);
  }
}","The original code used `HadoopUtils.createConfiguration()` instead of a predefined configuration object `conf`, which could lead to inconsistent or inappropriate configuration settings. The fixed code replaces `HadoopUtils.createConfiguration()` with `conf`, ensuring a consistent and correctly configured Hadoop configuration for the least cost path operation. This change guarantees more predictable and reliable test behavior by using a specific, pre-configured configuration object."
94454,"@Test @Category(IntegrationTest.class) public void testCostDistance() throws Exception {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + frictionSurface + ""String_Node_Str""+ ""String_Node_Str""+ TOBLER_MEDIUM_ZOOM+ ""String_Node_Str"";
  if (GEN_BASELINE_DATA_ONLY) {
    testUtils.generateBaselineTif(conf,testname.getMethodName(),exp,-9999);
  }
 else {
    testUtils.runRasterExpression(conf,testname.getMethodName(),exp);
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(new Path(testUtils.getOutputHdfs(),testname.getMethodName()).toUri().toString(),AccessMode.READ,(ProviderProperties)null);
    MrsImagePyramidMetadata metadata=dp.getMetadataReader().read();
    ImageStats[] stats=metadata.getStats();
    ImageStats[] imageStats=metadata.getImageStats(metadata.getMaxZoomLevel());
    ImageStats bandStats=metadata.getStats(0);
    Assert.assertArrayEquals(stats,imageStats);
    Assert.assertEquals(bandStats,imageStats[0]);
    double epsilon=0.5;
    Assert.assertEquals(0,bandStats.min,epsilon);
    Assert.assertEquals(50000,bandStats.max,epsilon);
    Assert.assertEquals(33113.35,bandStats.mean,epsilon);
    Assert.assertEquals(1852001,bandStats.count);
  }
}","@Test @Category(IntegrationTest.class) public void testCostDistance() throws Exception {
  String exp=""String_Node_Str"" + ""String_Node_Str"" + frictionSurface + ""String_Node_Str""+ ""String_Node_Str""+ TOBLER_MEDIUM_ZOOM+ ""String_Node_Str"";
  if (GEN_BASELINE_DATA_ONLY) {
    testUtils.generateBaselineTif(conf,testname.getMethodName(),exp,-9999);
  }
 else {
    testUtils.runRasterExpression(conf,testname.getMethodName(),exp);
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(new Path(testUtils.getOutputHdfs(),testname.getMethodName()).toUri().toString(),AccessMode.READ,(ProviderProperties)null);
    MrsImagePyramidMetadata metadata=dp.getMetadataReader().read();
    ImageStats[] stats=metadata.getStats();
    ImageStats[] imageStats=metadata.getImageStats(metadata.getMaxZoomLevel());
    ImageStats bandStats=metadata.getStats(0);
    Assert.assertArrayEquals(stats,imageStats);
    Assert.assertEquals(bandStats,imageStats[0]);
    double epsilon=0.5;
    Assert.assertEquals(0,bandStats.min,epsilon);
    Assert.assertEquals(50000,bandStats.max,epsilon);
    Assert.assertEquals(33112.808371797866,bandStats.mean,epsilon);
    Assert.assertEquals(1852051,bandStats.count);
  }
}","The original code had incorrect statistical values for mean (33113.35) and count (1852001), which did not accurately represent the actual data. The fixed code corrects these values to 33112.808371797866 for mean and 1852051 for count, likely reflecting precise calculations from the actual dataset. These corrections ensure more accurate statistical representation and improve the reliability of the test's assertion checks."
94455,"public static void setOutputInfo(final Configuration conf,final Job job,final String output){
  setInfo(conf,job);
  if (job != null) {
    FileOutputFormat.setOutputPath(job,new Path(output));
  }
 else {
    conf.set(HdfsMrsPyramidOutputFormat.OUTDIR,output);
  }
}","public static void setOutputInfo(final Configuration conf,final Job job,final String output){
  setInfo(conf,job);
  if (job != null) {
    FileOutputFormat.setOutputPath(job,new Path(output));
  }
 else {
    conf.set(""String_Node_Str"",output);
    conf.set(""String_Node_Str"",output);
  }
}","The original code used a hardcoded configuration key `HdfsMrsPyramidOutputFormat.OUTDIR`, which might cause unexpected behavior or conflicts in different contexts. The fixed code replaces this with a more generic configuration key ""String_Node_Str"" and sets it twice, though the duplicate setting is redundant. This modification provides a more flexible and predictable method of storing the output directory path when no Job object is available."
94456,"private void setupConfig(final Configuration conf,final Job job) throws DataProviderException {
  try {
    zoomLevel=context.getZoomlevel();
    if (zoomLevel != 0) {
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_ZOOMLEVEL,Integer.toString(zoomLevel));
    }
    if (doBulk || forceBulk) {
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_JOBTYPE,MrGeoAccumuloConstants.MRGEO_ACC_VALUE_JOB_BULK);
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_PREFIX + Integer.toString(zoomLevel),MrGeoAccumuloConstants.MRGEO_ACC_VALUE_JOB_BULK);
    }
 else {
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_JOBTYPE,MrGeoAccumuloConstants.MRGEO_ACC_VALUE_JOB_DIRECT);
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_PREFIX + Integer.toString(zoomLevel),MrGeoAccumuloConstants.MRGEO_ACC_VALUE_JOB_DIRECT);
    }
    Properties props=AccumuloConnector.getAccumuloProperties();
    if (props != null) {
      String enc=AccumuloConnector.encodeAccumuloProperties(""String_Node_Str"");
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_RESOURCE,enc);
      if (props.getProperty(MrGeoAccumuloConstants.MRGEO_ACC_KEY_OUTPUT_TABLE) == null) {
        conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_OUTPUT_TABLE,this.table);
      }
 else {
        conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_OUTPUT_TABLE,props.getProperty(MrGeoAccumuloConstants.MRGEO_ACC_KEY_OUTPUT_TABLE));
      }
      if (conf.get(MrGeoConstants.MRGEO_PROTECTION_LEVEL) != null) {
        cv=new ColumnVisibility(conf.get(MrGeoConstants.MRGEO_PROTECTION_LEVEL));
      }
      if (cv == null) {
        if (props.containsKey(MrGeoAccumuloConstants.MRGEO_ACC_KEY_VIZ)) {
          conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_VIZ,props.getProperty(MrGeoAccumuloConstants.MRGEO_ACC_KEY_VIZ));
          cv=new ColumnVisibility(props.getProperty(MrGeoAccumuloConstants.MRGEO_ACC_KEY_VIZ));
        }
      }
 else {
        conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_VIZ,new String(cv.getExpression()));
      }
    }
    if (doBulk || forceBulk) {
      LongRectangle outTileBounds=tileBounds.toLongRectangle();
      if (props.containsKey(MrGeoAccumuloConstants.MRGEO_ACC_KEY_WORKDIR)) {
        workDir=props.getProperty(MrGeoAccumuloConstants.MRGEO_ACC_KEY_WORKDIR);
        if (workDir != null) {
          workDir+=File.separator;
        }
      }
 else {
        workDir=""String_Node_Str"";
      }
      workDir+=AccumuloMrsImagePyramidFileOutputFormat.class.getSimpleName() + File.separator + this.table+ File.separator;
      Path wd=new Path(workDir);
      FileSystem fs=FileSystem.get(conf);
      if (fs.exists(wd)) {
        fs.delete(wd,true);
      }
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_WORKDIR,workDir);
      if (job != null) {
        ArrayList<Pair<Long,Long>> splitPoints=new ArrayList<Pair<Long,Long>>();
        long step=bulkThreshold / outTileBounds.getWidth();
        long rem=bulkThreshold % outTileBounds.getWidth();
        if (rem > 0) {
          step++;
        }
        for (long y=outTileBounds.getMinY(); y <= outTileBounds.getMaxY(); y+=step) {
          Pair<Long,Long> cur=new Pair<Long,Long>(outTileBounds.getMinX(),y);
          splitPoints.add(cur);
        }
        PrintStream out=null;
        try {
          out=new PrintStream(new BufferedOutputStream(fs.create(new Path(workDir + ""String_Node_Str""))));
          for (          Pair<Long,Long> p : splitPoints) {
            long split=TMSUtils.tileid(p.getFirst(),p.getSecond(),zoomLevel);
            Text t=new Text(longToBytes(split));
            out.println(new String(Base64.encodeBase64(TextUtil.getBytes(t))));
            log.debug(""String_Node_Str"" + p.getFirst() + ""String_Node_Str""+ p.getSecond()+ ""String_Node_Str""+ split+ ""String_Node_Str""+ t.getLength());
          }
          job.setNumReduceTasks(splitPoints.size() + 1);
          out.close();
          job.setPartitionerClass(AccumuloMrGeoRangePartitioner.class);
          AccumuloMrGeoRangePartitioner.setSplitFile(job,workDir + ""String_Node_Str"");
        }
 catch (        IOException ioe) {
          ioe.printStackTrace();
          throw new DataProviderException(""String_Node_Str"");
        }
        job.setOutputFormatClass(AccumuloMrsImagePyramidFileOutputFormat.class);
      }
      Path workFilesPath=new Path(workDir + ""String_Node_Str"");
      if (job != null) {
        AccumuloMrsImagePyramidFileOutputFormat.setOutputPath(job,workFilesPath);
      }
 else {
        Path outputDir=workFilesPath.getFileSystem(conf).makeQualified(workFilesPath);
        conf.set(AccumuloMrsImagePyramidFileOutputFormat.OUTDIR,outputDir.toString());
      }
    }
 else {
      if (job != null) {
        log.info(""String_Node_Str"" + AccumuloMrsImagePyramidOutputFormat.class.getCanonicalName());
        job.setOutputFormatClass(AccumuloMrsImagePyramidOutputFormat.class);
        AccumuloMrsImagePyramidOutputFormat.setJob(job);
        log.info(""String_Node_Str"" + zoomLevel);
        log.info(""String_Node_Str"" + cv.toString());
        log.info(""String_Node_Str"" + MrGeoAccumuloConstants.MRGEO_DEFAULT_NUM_REDUCERS);
        job.setNumReduceTasks(MrGeoAccumuloConstants.MRGEO_DEFAULT_NUM_REDUCERS);
      }
    }
    if (job != null) {
      job.setOutputKeyClass(TileIdWritable.class);
      job.setOutputValueClass(RasterWritable.class);
    }
  }
 catch (  IOException ioe) {
    throw new DataProviderException(""String_Node_Str"",ioe);
  }
}","private void setupConfig(final Configuration conf,final Job job) throws DataProviderException {
  try {
    zoomLevel=context.getZoomlevel();
    if (zoomLevel != 0) {
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_ZOOMLEVEL,Integer.toString(zoomLevel));
    }
    if (doBulk || forceBulk) {
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_JOBTYPE,MrGeoAccumuloConstants.MRGEO_ACC_VALUE_JOB_BULK);
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_PREFIX + Integer.toString(zoomLevel),MrGeoAccumuloConstants.MRGEO_ACC_VALUE_JOB_BULK);
    }
 else {
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_JOBTYPE,MrGeoAccumuloConstants.MRGEO_ACC_VALUE_JOB_DIRECT);
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_PREFIX + Integer.toString(zoomLevel),MrGeoAccumuloConstants.MRGEO_ACC_VALUE_JOB_DIRECT);
    }
    Properties props=AccumuloConnector.getAccumuloProperties();
    if (props != null) {
      String enc=AccumuloConnector.encodeAccumuloProperties(""String_Node_Str"");
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_RESOURCE,enc);
      if (props.getProperty(MrGeoAccumuloConstants.MRGEO_ACC_KEY_OUTPUT_TABLE) == null) {
        conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_OUTPUT_TABLE,this.table);
      }
 else {
        conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_OUTPUT_TABLE,props.getProperty(MrGeoAccumuloConstants.MRGEO_ACC_KEY_OUTPUT_TABLE));
      }
      if (conf.get(MrGeoConstants.MRGEO_PROTECTION_LEVEL) != null) {
        cv=new ColumnVisibility(conf.get(MrGeoConstants.MRGEO_PROTECTION_LEVEL));
      }
      if (cv == null) {
        if (props.containsKey(MrGeoAccumuloConstants.MRGEO_ACC_KEY_VIZ)) {
          conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_VIZ,props.getProperty(MrGeoAccumuloConstants.MRGEO_ACC_KEY_VIZ));
          cv=new ColumnVisibility(props.getProperty(MrGeoAccumuloConstants.MRGEO_ACC_KEY_VIZ));
        }
      }
 else {
        conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_VIZ,new String(cv.getExpression()));
      }
    }
    if (doBulk || forceBulk) {
      LongRectangle outTileBounds=tileBounds.toLongRectangle();
      if (props.containsKey(MrGeoAccumuloConstants.MRGEO_ACC_KEY_WORKDIR)) {
        workDir=props.getProperty(MrGeoAccumuloConstants.MRGEO_ACC_KEY_WORKDIR);
        if (workDir != null) {
          workDir+=File.separator;
        }
      }
 else {
        workDir=""String_Node_Str"";
      }
      workDir+=AccumuloMrsImagePyramidFileOutputFormat.class.getSimpleName() + File.separator + this.table+ File.separator;
      Path wd=new Path(workDir);
      FileSystem fs=FileSystem.get(conf);
      if (fs.exists(wd)) {
        fs.delete(wd,true);
      }
      conf.set(MrGeoAccumuloConstants.MRGEO_ACC_KEY_WORKDIR,workDir);
      if (job != null) {
        ArrayList<Pair<Long,Long>> splitPoints=new ArrayList<Pair<Long,Long>>();
        long step=bulkThreshold / outTileBounds.getWidth();
        long rem=bulkThreshold % outTileBounds.getWidth();
        if (rem > 0) {
          step++;
        }
        for (long y=outTileBounds.getMinY(); y <= outTileBounds.getMaxY(); y+=step) {
          Pair<Long,Long> cur=new Pair<Long,Long>(outTileBounds.getMinX(),y);
          splitPoints.add(cur);
        }
        PrintStream out=null;
        try {
          out=new PrintStream(new BufferedOutputStream(fs.create(new Path(workDir + ""String_Node_Str""))));
          for (          Pair<Long,Long> p : splitPoints) {
            long split=TMSUtils.tileid(p.getFirst(),p.getSecond(),zoomLevel);
            Text t=new Text(longToBytes(split));
            out.println(new String(Base64.encodeBase64(TextUtil.getBytes(t))));
            log.debug(""String_Node_Str"" + p.getFirst() + ""String_Node_Str""+ p.getSecond()+ ""String_Node_Str""+ split+ ""String_Node_Str""+ t.getLength());
          }
          job.setNumReduceTasks(splitPoints.size() + 1);
          out.close();
          job.setPartitionerClass(AccumuloMrGeoRangePartitioner.class);
          AccumuloMrGeoRangePartitioner.setSplitFile(job,workDir + ""String_Node_Str"");
        }
 catch (        IOException ioe) {
          ioe.printStackTrace();
          throw new DataProviderException(""String_Node_Str"");
        }
        job.setOutputFormatClass(AccumuloMrsImagePyramidFileOutputFormat.class);
      }
      Path workFilesPath=new Path(workDir + ""String_Node_Str"");
      if (job != null) {
        AccumuloMrsImagePyramidFileOutputFormat.setOutputPath(job,workFilesPath);
      }
 else {
        Path outputDir=workFilesPath.getFileSystem(conf).makeQualified(workFilesPath);
        conf.set(""String_Node_Str"",outputDir.toString());
        conf.set(""String_Node_Str"",outputDir.toString());
      }
    }
 else {
      if (job != null) {
        log.info(""String_Node_Str"" + AccumuloMrsImagePyramidOutputFormat.class.getCanonicalName());
        job.setOutputFormatClass(AccumuloMrsImagePyramidOutputFormat.class);
        AccumuloMrsImagePyramidOutputFormat.setJob(job);
        log.info(""String_Node_Str"" + zoomLevel);
        log.info(""String_Node_Str"" + cv.toString());
        log.info(""String_Node_Str"" + MrGeoAccumuloConstants.MRGEO_DEFAULT_NUM_REDUCERS);
        job.setNumReduceTasks(MrGeoAccumuloConstants.MRGEO_DEFAULT_NUM_REDUCERS);
      }
    }
    if (job != null) {
      job.setOutputKeyClass(TileIdWritable.class);
      job.setOutputValueClass(RasterWritable.class);
    }
  }
 catch (  IOException ioe) {
    throw new DataProviderException(""String_Node_Str"",ioe);
  }
}","The original code had a potential configuration issue with duplicate configuration settings in the else block when job is null. The fixed code removes the redundant configuration setting and replaces the hardcoded constant string with a more appropriate configuration key for output directory. This improvement ensures more consistent and predictable configuration handling, preventing potential configuration conflicts and improving the robustness of the setup process."
94457,"/** 
 * This method will Get a MapFile.Reader for the partition specified
 * @param partition is the particular reader being accessed
 * @return the reader for the partition specified
 * @throws IOException
 */
public MapFile.Reader getReader(final int partition) throws IOException {
  try {
    return readerCache.get(partition);
  }
 catch (  ExecutionException e) {
    if (e.getCause() instanceof IOException) {
      throw (IOException)e.getCause();
    }
    throw new IOException(e);
  }
}","/** 
 * This method will get a MapFile.Reader for the partition specified. Before closing the returned reader, the caller should make sure it is not cached in this class by calling isCachingEnabled(). If that method returns true, the caller should not close the reader. It will be automatically closed when it drops out of the cache.
 * @param partition is the particular reader being accessed
 * @return the reader for the partition specified
 * @throws IOException
 */
public MapFile.Reader getReader(final int partition) throws IOException {
  try {
    if (cachingEnabled) {
      log.info(""String_Node_Str"" + partition + ""String_Node_Str"");
      return readerCache.get(partition);
    }
 else {
      log.info(""String_Node_Str"" + partition + ""String_Node_Str"");
      return loadReader(partition);
    }
  }
 catch (  ExecutionException e) {
    if (e.getCause() instanceof IOException) {
      throw (IOException)e.getCause();
    }
    throw new IOException(e);
  }
}","The original code always retrieved readers from a cache without checking if caching was enabled, potentially leading to inflexible reader management. The fixed code adds a conditional check with `cachingEnabled` flag, allowing dynamic selection between cached and newly loaded readers based on current configuration. This modification provides more control over reader retrieval, enabling runtime flexibility in resource management and preventing unnecessary cache dependencies."
94458,"/** 
 * The HdfsReader constructor will instantiate the connection to HDFS
 * @param path is the location of the data in HDFS
 * @throws IOException 
 */
public HdfsMrsTileReader(final String path,final int zoom) throws IOException {
  String modifiedPath=path;
  final File file=new File(path);
  if (file.exists()) {
    modifiedPath=""String_Node_Str"" + file.getAbsolutePath();
  }
  imagePath=new Path(modifiedPath);
  FileSystem fs=HadoopFileUtils.getFileSystem(conf,imagePath);
  if (!fs.exists(imagePath)) {
    throw new IOException(""String_Node_Str"" + modifiedPath + ""String_Node_Str"");
  }
  readSplits(modifiedPath);
  if (System.getProperty(""String_Node_Str"",""String_Node_Str"").compareToIgnoreCase(""String_Node_Str"") == 0) {
    profile=true;
  }
 else {
    profile=false;
  }
}","/** 
 * The HdfsReader constructor will instantiate the connection to HDFS
 * @param path is the location of the data in HDFS
 * @throws IOException 
 */
public HdfsMrsTileReader(final String path,final int zoom) throws IOException {
  String modifiedPath=path;
  final File file=new File(path);
  if (file.exists()) {
    modifiedPath=""String_Node_Str"" + file.getAbsolutePath();
  }
  imagePath=new Path(modifiedPath);
  FileSystem fs=HadoopFileUtils.getFileSystem(conf,imagePath);
  if (!fs.exists(imagePath)) {
    throw new IOException(""String_Node_Str"" + modifiedPath + ""String_Node_Str"");
  }
  Path qualifiedImagePath=imagePath.makeQualified(fs);
  URI imagePathUri=qualifiedImagePath.toUri();
  String imageScheme=imagePathUri.getScheme().toLowerCase();
  if (imageScheme.equals(""String_Node_Str"") || imageScheme.equals(""String_Node_Str"")) {
    cachingEnabled=false;
  }
  readSplits(modifiedPath);
  if (System.getProperty(""String_Node_Str"",""String_Node_Str"").compareToIgnoreCase(""String_Node_Str"") == 0) {
    profile=true;
  }
 else {
    profile=false;
  }
}","The original code lacked proper handling of file path validation and caching configuration, potentially leading to incorrect file system operations. The fixed code introduces path qualification, extracts the URI scheme, and conditionally disables caching based on specific scheme conditions, enhancing robustness and file system interaction. These modifications improve error handling, provide more precise file system access, and add a layer of configuration flexibility for different storage contexts."
94459,"@Override public MapFile.Reader load(final Integer partition) throws IOException {
  final FileSplit.FileSplitInfo part=(FileSplit.FileSplitInfo)splits.getSplits()[partition];
  final Path path=new Path(imagePath,part.getName());
  final FileSystem fs=path.getFileSystem(conf);
  MapFile.Reader reader=new MapFile.Reader(path,conf);
  if (profile) {
    LeakChecker.instance().add(reader,ExceptionUtils.getFullStackTrace(new Throwable(""String_Node_Str"")));
  }
  LOG.debug(""String_Node_Str"",partition,part);
  return reader;
}","@Override public MapFile.Reader load(final Integer partition) throws IOException {
  return loadReader(partition);
}","The original method directly created a MapFile.Reader with potential resource management issues, including unnecessary filesystem and path operations. The fixed code delegates reader creation to a separate method `loadReader()`, which likely encapsulates the complex reader initialization logic more cleanly and safely. By extracting the implementation details, the code becomes more modular, easier to maintain, and potentially reduces the risk of resource leaks or improper file handling."
94460,"@SuppressWarnings(""String_Node_Str"") private void primeScanner(final long startTileId,final long endTileId){
  try {
    curPartition=-1;
    int partition=reader.getPartition(new TileIdWritable(startTileId));
    TileIdWritable startKey=null;
    while (curPartition == -1 && partition < reader.getMaxPartitions()) {
      mapfile=reader.getReader(partition);
      try {
        if (startKey == null) {
          startKey=(TileIdWritable)mapfile.getKeyClass().newInstance();
          startKey.set(startTileId);
          endKey=(TileIdWritable)mapfile.getKeyClass().newInstance();
          endKey.set(endTileId);
          currentValue=(TWritable)mapfile.getValueClass().newInstance();
        }
      }
 catch (      InstantiationException e) {
        throw new MrsImageException(e);
      }
catch (      IllegalAccessException e) {
        throw new MrsImageException(e);
      }
      currentKey=(TileIdWritable)mapfile.getClosest(startKey,currentValue);
      if (currentKey != null && inRange(currentKey)) {
        readFirstKey=true;
        curPartition=partition;
      }
 else {
        partition++;
      }
    }
  }
 catch (  Splits.SplitException se) {
    currentKey=null;
  }
catch (  final IOException e) {
    throw new MrsImageException(e);
  }
}","@SuppressWarnings(""String_Node_Str"") private void primeScanner(final long startTileId,final long endTileId){
  try {
    curPartition=-1;
    int partition=reader.getPartition(new TileIdWritable(startTileId));
    TileIdWritable startKey=null;
    while (curPartition == -1 && partition < reader.getMaxPartitions()) {
      if (!reader.isCachingEnabled() && mapfile != null) {
        mapfile.close();
      }
      mapfile=reader.getReader(partition);
      try {
        if (startKey == null) {
          startKey=(TileIdWritable)mapfile.getKeyClass().newInstance();
          startKey.set(startTileId);
          endKey=(TileIdWritable)mapfile.getKeyClass().newInstance();
          endKey.set(endTileId);
          currentValue=(TWritable)mapfile.getValueClass().newInstance();
        }
      }
 catch (      InstantiationException e) {
        throw new MrsImageException(e);
      }
catch (      IllegalAccessException e) {
        throw new MrsImageException(e);
      }
      currentKey=(TileIdWritable)mapfile.getClosest(startKey,currentValue);
      if (currentKey != null && inRange(currentKey)) {
        readFirstKey=true;
        curPartition=partition;
      }
 else {
        partition++;
      }
    }
  }
 catch (  Splits.SplitException se) {
    currentKey=null;
  }
catch (  final IOException e) {
    throw new MrsImageException(e);
  }
}","The original code did not properly close MapFile resources between partition iterations, potentially causing resource leaks and inefficient memory management. The fixed code adds a check to close the previous MapFile if caching is disabled, ensuring proper resource cleanup and preventing potential memory-related issues. This change improves resource handling, reduces memory overhead, and prevents potential resource contention during file reading operations."
94461,"/** 
 * Keeping track of what is being sent back and possibly finish using one MapFile and then opening another MapFile if needed.
 */
@Override public boolean hasNext(){
  try {
    if (currentKey == null) {
      return false;
    }
    if (readFirstKey) {
      readFirstKey=false;
      if (currentKey.compareTo(endKey) <= 0) {
        return true;
      }
      return false;
    }
    while (true) {
      final boolean found=mapfile.next(currentKey,currentValue);
      if (found) {
        if (currentKey.compareTo(endKey) <= 0) {
          if (zoom > 0) {
            final TMSUtils.Tile t=TMSUtils.tileid(currentKey.get(),zoom);
            if (t.tx >= rowStart && t.tx <= rowEnd) {
              return true;
            }
            System.out.println(""String_Node_Str"" + t.toString());
          }
 else {
            return true;
          }
        }
 else {
          return false;
        }
      }
 else {
        if (++curPartition >= reader.getMaxPartitions()) {
          return false;
        }
        mapfile=reader.getReader(curPartition);
      }
    }
  }
 catch (  final IOException e) {
    throw new MrsImageException(e);
  }
}","/** 
 * Keeping track of what is being sent back and possibly finish using one MapFile and then opening another MapFile if needed.
 */
@Override public boolean hasNext(){
  try {
    if (currentKey == null) {
      return false;
    }
    if (readFirstKey) {
      readFirstKey=false;
      if (currentKey.compareTo(endKey) <= 0) {
        return true;
      }
      return false;
    }
    while (true) {
      final boolean found=mapfile.next(currentKey,currentValue);
      if (found) {
        if (currentKey.compareTo(endKey) <= 0) {
          if (zoom > 0) {
            final TMSUtils.Tile t=TMSUtils.tileid(currentKey.get(),zoom);
            if (t.tx >= rowStart && t.tx <= rowEnd) {
              return true;
            }
          }
 else {
            return true;
          }
        }
 else {
          return false;
        }
      }
 else {
        if (++curPartition >= reader.getMaxPartitions()) {
          return false;
        }
        if (!reader.isCachingEnabled() && mapfile != null) {
          mapfile.close();
        }
        mapfile=reader.getReader(curPartition);
      }
    }
  }
 catch (  final IOException e) {
    throw new MrsImageException(e);
  }
}","The original code did not properly close MapFile instances when switching partitions, potentially causing resource leaks and inefficient memory management. The fixed code adds a conditional close operation for MapFile when caching is disabled, ensuring proper resource cleanup between partition reads. This improvement prevents potential memory overhead and ensures clean, controlled resource handling during iterative MapFile processing."
94462,"private void setTile(final String k,final MrsTileReader<T> reader,final long tileid){
  if (zoomLevel > reader.getZoomlevel()) {
    int zl=reader.getZoomlevel();
    TMSUtils.Tile t=TMSUtils.calculateTile(TMSUtils.tileid(tileid,zoomLevel),zoomLevel,zl,tilesize);
    TileIdWritable id=new TileIdWritable(TMSUtils.tileid(t.tx,t.ty,zl));
    T r=getTileFromCache(k,reader,id);
    T split=splitTile(r,id.get(),zl,tileid,zoomLevel,tilesize);
    value.set(k,tileid,split);
  }
 else   if (zoomLevel < splitZoomLevel) {
  }
 else {
    System.err.println(""String_Node_Str"" + tileid + ""String_Node_Str""+ TMSUtils.tileid(tileid,zoomLevel)+ ""String_Node_Str"");
    T r=readerTileCache.getIfPresent(tileid);
    if (value == null) {
      System.err.println(""String_Node_Str"" + tileid);
      r=reader.get(new TileIdWritable(tileid));
    }
 else {
      System.err.println(""String_Node_Str"" + tileid);
    }
    if (r != null) {
      value.set(k,tileid,r);
    }
  }
}","private void setTile(final String k,final MrsTileReader<T> reader,final long tileid){
  if (zoomLevel > reader.getZoomlevel()) {
    int zl=reader.getZoomlevel();
    TMSUtils.Tile t=TMSUtils.calculateTile(TMSUtils.tileid(tileid,zoomLevel),zoomLevel,zl,tilesize);
    TileIdWritable id=new TileIdWritable(TMSUtils.tileid(t.tx,t.ty,zl));
    T r=getTileFromCache(k,reader,id);
    T split=splitTile(r,id.get(),zl,tileid,zoomLevel,tilesize);
    value.set(k,tileid,split);
  }
 else   if (zoomLevel < splitZoomLevel) {
  }
 else {
    System.err.println(""String_Node_Str"" + k + ""String_Node_Str""+ tileid+ ""String_Node_Str""+ TMSUtils.tileid(tileid,zoomLevel)+ ""String_Node_Str"");
    String key=buildReaderTileCacheKey(k,tileid);
    T r=readerTileCache.getIfPresent(key);
    if (r == null) {
      System.err.println(""String_Node_Str"" + tileid);
      r=reader.get(new TileIdWritable(tileid));
      readerTileCache.put(key,r);
    }
 else {
      System.err.println(""String_Node_Str"" + tileid);
    }
    if (r != null) {
      value.set(k,tileid,r);
    }
  }
}","The original code had potential null pointer and caching issues, with inconsistent error handling and missing cache management. The fixed code introduces a proper cache key generation method, explicitly checks for null before retrieval, and ensures cache population when a tile is fetched from the reader. These changes improve robustness by preventing potential null references, implementing consistent caching strategy, and providing more informative error logging."
94463,"@SuppressWarnings(""String_Node_Str"") private T getTileFromCache(final String k,final MrsTileReader<T> reader,TileIdWritable id){
  if (!tilecache.containsKey(k)) {
    tilecache.put(k,new LRUMap(4));
  }
  Map<TileIdWritable,T> cache=tilecache.get(k);
  if (cache.containsKey(id)) {
    System.err.println(""String_Node_Str"" + id.get());
    return cache.get(id);
  }
  System.err.println(""String_Node_Str"" + id.get() + ""String_Node_Str"");
  T r=reader.get(id);
  cache.put(id,r);
  return r;
}","@SuppressWarnings(""String_Node_Str"") private T getTileFromCache(final String k,final MrsTileReader<T> reader,TileIdWritable id){
  if (!tilecache.containsKey(k)) {
    tilecache.put(k,new LRUMap(4));
  }
  Map<TileIdWritable,T> cache=tilecache.get(k);
  if (cache.containsKey(id)) {
    System.err.println(""String_Node_Str"" + id.get());
    return cache.get(id);
  }
  System.err.println(""String_Node_Str"" + id.get() + ""String_Node_Str"");
  String key=buildReaderTileCacheKey(k,id.get());
  T r=readerTileCache.getIfPresent(key);
  if (r == null) {
    r=reader.get(id);
    readerTileCache.put(key,r);
  }
  cache.put(id,r);
  return r;
}","The original code lacks a mechanism to prevent redundant tile loading, potentially causing repeated reads of the same tile from the reader. The fixed code introduces a secondary cache (`readerTileCache`) with a built-in key generation method (`buildReaderTileCacheKey`), which first checks if a tile is already cached before performing an expensive reader retrieval. This optimization reduces unnecessary disk or network I/O, improving performance by caching and reusing previously loaded tiles more efficiently."
94464,"private void setNextKeyValue(final long tileid,final T tileValue) throws IOException {
  key.set(tileid);
  value.clear();
  value.setTileid(tileid);
  readerTileCache.put(tileid,tileValue);
  value.set(scannedInput,tileid,tileValue);
  int neighborCountForTile=0;
  if (tileClusterInfo != null && neighborTileIds != null) {
    neighborCountForTile=tileClusterInfo.getNeighbors(tileid,zoomLevel,tilesize,inputBounds,neighborTileIds);
    if (tileClusterInfo != null && neighborTileIds != null) {
      for (int index=0; index < neighborCountForTile; index++) {
        setTile(scannedInput,primaryReader,neighborTileIds[index]);
      }
    }
  }
  for (  final String inputPyramidName : secondaryPyramidNames) {
    MrsTileReader<T> inputReader=readers.get(inputPyramidName);
    if (inputReader == null) {
      inputReader=getMrsTileReader(inputPyramidName,ifContext.getZoomLevel(),myconf);
    }
    setTile(inputPyramidName,inputReader,tileid);
    if (tileClusterInfo != null && neighborTileIds != null) {
      for (int index=0; index < neighborCountForTile; index++) {
        setTile(inputPyramidName,inputReader,neighborTileIds[index]);
      }
    }
  }
}","private void setNextKeyValue(final long tileid,final T tileValue) throws IOException {
  key.set(tileid);
  value.clear();
  value.setTileid(tileid);
  readerTileCache.put(buildReaderTileCacheKey(scannedInput,tileid),tileValue);
  value.set(scannedInput,tileid,tileValue);
  int neighborCountForTile=0;
  if (tileClusterInfo != null && neighborTileIds != null) {
    neighborCountForTile=tileClusterInfo.getNeighbors(tileid,zoomLevel,tilesize,inputBounds,neighborTileIds);
    if (tileClusterInfo != null && neighborTileIds != null) {
      for (int index=0; index < neighborCountForTile; index++) {
        setTile(scannedInput,primaryReader,neighborTileIds[index]);
      }
    }
  }
  for (  final String inputPyramidName : secondaryPyramidNames) {
    MrsTileReader<T> inputReader=readers.get(inputPyramidName);
    if (inputReader == null) {
      inputReader=getMrsTileReader(inputPyramidName,ifContext.getZoomLevel(),myconf);
    }
    setTile(inputPyramidName,inputReader,tileid);
    if (tileClusterInfo != null && neighborTileIds != null) {
      for (int index=0; index < neighborCountForTile; index++) {
        setTile(inputPyramidName,inputReader,neighborTileIds[index]);
      }
    }
  }
}","The original code used a simple tileid as the cache key, which could lead to key collisions across different input sources. The fixed code introduces a `buildReaderTileCacheKey()` method that incorporates the input source name, creating a unique and context-specific cache key. This modification ensures more robust caching by preventing potential overwrites and maintaining data integrity across multiple input pyramids."
94465,"@Override public void initialize(InputSplit split,TaskAttemptContext context) throws IOException, InterruptedException {
  this.myconf=context.getConfiguration();
  if (split instanceof MrsPyramidInputSplit) {
    final MrsPyramidInputSplit fsplit=(MrsPyramidInputSplit)split;
    final Configuration conf=context.getConfiguration();
    ifContext=TiledInputFormatContext.load(context.getConfiguration());
    if (ifContext.getBounds() != null) {
      inputBounds=ifContext.getBounds();
    }
    scannedInputReader=createRecordReader(fsplit,context);
    final String pyramidName=fsplit.getName();
    tileClusterInfo=HadoopUtils.getTileClusterInfo(conf);
    readers=new HashMap<String,MrsTileReader<T>>();
    tilecache=new HashMap<String,Map<TileIdWritable,T>>();
    for (    final String inputPyramidName : ifContext.getInputs()) {
      if (pyramidName.equals(inputPyramidName)) {
        scannedInput=inputPyramidName;
        if (tileClusterInfo != null && (tileClusterInfo.getNeighborCount() > 0)) {
          primaryReader=getMrsTileReader(inputPyramidName,ifContext.getZoomLevel(),conf);
        }
      }
 else {
        secondaryPyramidNames.add(inputPyramidName);
        MrsTileReader<T> tileReader=getMrsTileReader(inputPyramidName,ifContext.getZoomLevel(),conf);
        if (tileReader.canBeCached()) {
          readers.put(inputPyramidName,tileReader);
        }
      }
    }
    try {
      final Map<String,MrsPyramidMetadata> metadataMap=readMetadata(conf);
      MrsPyramidMetadata metadata=metadataMap.get(pyramidName);
      if (metadata == null) {
        metadata=metadataMap.get(pyramidName);
      }
      if (metadata == null) {
        throw new IOException(""String_Node_Str"" + pyramidName);
      }
      tilesize=metadata.getTilesize();
      zoomLevel=fsplit.getZoomlevel();
    }
 catch (    final ClassNotFoundException e) {
      e.printStackTrace();
      throw new IOException(e);
    }
    if (split instanceof MrsPyramidInputSplit) {
      preBounds=fsplit.getPreBounds();
      splitZoomLevel=fsplit.getZoomlevel();
    }
 else {
      splitZoomLevel=zoomLevel;
    }
    inputTileBounds=TMSUtils.boundsToTile(inputBounds.getTMSBounds(),zoomLevel,tilesize);
    if (tileClusterInfo != null) {
      final int neighborCount=tileClusterInfo.getNeighborCount();
      if (neighborCount > 0) {
        neighborTileIds=new long[neighborCount];
        initialTile=new TMSUtils.Tile(inputTileBounds.w - tileClusterInfo.getOffsetX(),inputTileBounds.s - tileClusterInfo.getOffsetY());
      }
    }
    value=new TileCollection<T>();
    key=new TileIdWritable();
  }
 else {
    throw new IOException(""String_Node_Str"" + split.getClass().getName());
  }
}","@Override public void initialize(InputSplit split,TaskAttemptContext context) throws IOException, InterruptedException {
  this.myconf=context.getConfiguration();
  if (split instanceof MrsPyramidInputSplit) {
    final MrsPyramidInputSplit fsplit=(MrsPyramidInputSplit)split;
    final Configuration conf=context.getConfiguration();
    ifContext=TiledInputFormatContext.load(context.getConfiguration());
    if (ifContext.getBounds() != null) {
      inputBounds=ifContext.getBounds();
    }
    scannedInputReader=createRecordReader(fsplit,context);
    final String pyramidName=fsplit.getName();
    tileClusterInfo=HadoopUtils.getTileClusterInfo(conf);
    readers=new HashMap<String,MrsTileReader<T>>();
    tilecache=new HashMap<String,Map<TileIdWritable,T>>();
    int readerTileCacheSize=(tileClusterInfo == null) ? ifContext.getInputs().size() : (tileClusterInfo.getNeighborCount() + 1) * ifContext.getInputs().size();
    readerTileCache=CacheBuilder.newBuilder().maximumSize(readerTileCacheSize).expireAfterAccess(10,TimeUnit.SECONDS).build();
    for (    final String inputPyramidName : ifContext.getInputs()) {
      if (pyramidName.equals(inputPyramidName)) {
        scannedInput=inputPyramidName;
        if (tileClusterInfo != null && (tileClusterInfo.getNeighborCount() > 0)) {
          primaryReader=getMrsTileReader(inputPyramidName,ifContext.getZoomLevel(),conf);
        }
      }
 else {
        secondaryPyramidNames.add(inputPyramidName);
        MrsTileReader<T> tileReader=getMrsTileReader(inputPyramidName,ifContext.getZoomLevel(),conf);
        if (tileReader.canBeCached()) {
          readers.put(inputPyramidName,tileReader);
        }
      }
    }
    try {
      final Map<String,MrsPyramidMetadata> metadataMap=readMetadata(conf);
      MrsPyramidMetadata metadata=metadataMap.get(pyramidName);
      if (metadata == null) {
        metadata=metadataMap.get(pyramidName);
      }
      if (metadata == null) {
        throw new IOException(""String_Node_Str"" + pyramidName);
      }
      tilesize=metadata.getTilesize();
      zoomLevel=fsplit.getZoomlevel();
    }
 catch (    final ClassNotFoundException e) {
      e.printStackTrace();
      throw new IOException(e);
    }
    if (split instanceof MrsPyramidInputSplit) {
      preBounds=fsplit.getPreBounds();
      splitZoomLevel=fsplit.getZoomlevel();
    }
 else {
      splitZoomLevel=zoomLevel;
    }
    inputTileBounds=TMSUtils.boundsToTile(inputBounds.getTMSBounds(),zoomLevel,tilesize);
    if (tileClusterInfo != null) {
      final int neighborCount=tileClusterInfo.getNeighborCount();
      if (neighborCount > 0) {
        neighborTileIds=new long[neighborCount];
        initialTile=new TMSUtils.Tile(inputTileBounds.w - tileClusterInfo.getOffsetX(),inputTileBounds.s - tileClusterInfo.getOffsetY());
      }
    }
    value=new TileCollection<T>();
    key=new TileIdWritable();
  }
 else {
    throw new IOException(""String_Node_Str"" + split.getClass().getName());
  }
}","The original code lacked proper tile caching mechanism, potentially leading to inefficient memory usage and performance issues. The fixed code introduces a Guava cache (readerTileCache) with a dynamically calculated cache size based on input contexts and tile cluster information, ensuring controlled memory allocation. This optimization improves tile reading efficiency by implementing a time-bounded, size-limited caching strategy that adapts to different input configurations."
94466,"private void setTile(final String k,final MrsTileReader<T> reader,final long tileid){
  if (zoomLevel > reader.getZoomlevel()) {
    int zl=reader.getZoomlevel();
    TMSUtils.Tile t=TMSUtils.calculateTile(TMSUtils.tileid(tileid,zoomLevel),zoomLevel,zl,tilesize);
    TileIdWritable id=new TileIdWritable(TMSUtils.tileid(t.tx,t.ty,zl));
    T r=getTileFromCache(k,reader,id);
    T split=splitTile(r,id.get(),zl,tileid,zoomLevel,tilesize);
    value.set(k,tileid,split);
  }
 else   if (zoomLevel < splitZoomLevel) {
  }
 else {
    System.err.println(""String_Node_Str"" + k + ""String_Node_Str""+ tileid+ ""String_Node_Str""+ TMSUtils.tileid(tileid,zoomLevel)+ ""String_Node_Str"");
    String key=buildReaderTileCacheKey(k,tileid);
    T r=readerTileCache.getIfPresent(key);
    if (r == null) {
      System.err.println(""String_Node_Str"" + tileid);
      r=reader.get(new TileIdWritable(tileid));
      readerTileCache.put(key,r);
    }
 else {
      System.err.println(""String_Node_Str"" + tileid);
    }
    if (r != null) {
      value.set(k,tileid,r);
    }
  }
}","private void setTile(final String k,final MrsTileReader<T> reader,final long tileid){
  if (zoomLevel > reader.getZoomlevel()) {
    int zl=reader.getZoomlevel();
    TMSUtils.Tile t=TMSUtils.calculateTile(TMSUtils.tileid(tileid,zoomLevel),zoomLevel,zl,tilesize);
    TileIdWritable id=new TileIdWritable(TMSUtils.tileid(t.tx,t.ty,zl));
    T r=getTileFromCache(k,reader,id);
    T split=splitTile(r,id.get(),zl,tileid,zoomLevel,tilesize);
    value.set(k,tileid,split);
  }
 else   if (zoomLevel < splitZoomLevel) {
  }
 else {
    String key=buildReaderTileCacheKey(k,tileid);
    T r=readerTileCache.getIfPresent(key);
    if (r == null) {
      r=reader.get(new TileIdWritable(tileid));
      if (r != null) {
        readerTileCache.put(key,r);
      }
    }
    if (r != null) {
      value.set(k,tileid,r);
    }
  }
}","The original code had unnecessary debug print statements and redundant error logging, which could impact performance and potentially expose sensitive information. The fixed code removes these print statements and adds a null check before caching the tile, preventing potential null pointer exceptions and ensuring only valid tiles are stored in the cache. This results in cleaner, more efficient code with improved error handling and reduced runtime overhead."
94467,"@SuppressWarnings(""String_Node_Str"") private T getTileFromCache(final String k,final MrsTileReader<T> reader,TileIdWritable id){
  if (!tilecache.containsKey(k)) {
    tilecache.put(k,new LRUMap(4));
  }
  Map<TileIdWritable,T> cache=tilecache.get(k);
  if (cache.containsKey(id)) {
    System.err.println(""String_Node_Str"" + id.get());
    return cache.get(id);
  }
  System.err.println(""String_Node_Str"" + id.get() + ""String_Node_Str"");
  String key=buildReaderTileCacheKey(k,id.get());
  T r=readerTileCache.getIfPresent(key);
  if (r == null) {
    r=reader.get(id);
    readerTileCache.put(key,r);
  }
  cache.put(id,r);
  return r;
}","@SuppressWarnings(""String_Node_Str"") private T getTileFromCache(final String k,final MrsTileReader<T> reader,TileIdWritable id){
  if (!tilecache.containsKey(k)) {
    tilecache.put(k,new LRUMap(4));
  }
  Map<TileIdWritable,T> cache=tilecache.get(k);
  if (cache.containsKey(id)) {
    return cache.get(id);
  }
  String key=buildReaderTileCacheKey(k,id.get());
  T r=readerTileCache.getIfPresent(key);
  if (r == null) {
    r=reader.get(id);
    if (r != null) {
      readerTileCache.put(key,r);
    }
  }
  cache.put(id,r);
  return r;
}","The original code unnecessarily printed debug messages and lacked a null check when caching reader tiles, which could lead to potential null pointer exceptions. The fixed code removes unnecessary print statements and adds a null check before caching the tile from the reader, ensuring that only valid tiles are stored. This improvement enhances code robustness by preventing potential null insertions and reducing unnecessary logging, making the caching mechanism more reliable and efficient."
94468,"@Override public void initialize(InputSplit split,TaskAttemptContext context) throws IOException, InterruptedException {
  this.myconf=context.getConfiguration();
  if (split instanceof MrsPyramidInputSplit) {
    final MrsPyramidInputSplit fsplit=(MrsPyramidInputSplit)split;
    final Configuration conf=context.getConfiguration();
    ifContext=TiledInputFormatContext.load(context.getConfiguration());
    if (ifContext.getBounds() != null) {
      inputBounds=ifContext.getBounds();
    }
    scannedInputReader=createRecordReader(fsplit,context);
    final String pyramidName=fsplit.getName();
    tileClusterInfo=HadoopUtils.getTileClusterInfo(conf);
    readers=new HashMap<String,MrsTileReader<T>>();
    tilecache=new HashMap<String,Map<TileIdWritable,T>>();
    int readerTileCacheSize=(tileClusterInfo == null) ? ifContext.getInputs().size() : (tileClusterInfo.getNeighborCount() + 1) * ifContext.getInputs().size();
    readerTileCache=CacheBuilder.newBuilder().maximumSize(readerTileCacheSize).expireAfterAccess(10,TimeUnit.SECONDS).build();
    for (    final String inputPyramidName : ifContext.getInputs()) {
      if (pyramidName.equals(inputPyramidName)) {
        scannedInput=inputPyramidName;
        if (tileClusterInfo != null && (tileClusterInfo.getNeighborCount() > 0)) {
          primaryReader=getMrsTileReader(inputPyramidName,ifContext.getZoomLevel(),conf);
        }
      }
 else {
        secondaryPyramidNames.add(inputPyramidName);
        MrsTileReader<T> tileReader=getMrsTileReader(inputPyramidName,ifContext.getZoomLevel(),conf);
        if (tileReader.canBeCached()) {
          readers.put(inputPyramidName,tileReader);
        }
      }
    }
    try {
      final Map<String,MrsPyramidMetadata> metadataMap=readMetadata(conf);
      MrsPyramidMetadata metadata=metadataMap.get(pyramidName);
      if (metadata == null) {
        metadata=metadataMap.get(pyramidName);
      }
      if (metadata == null) {
        throw new IOException(""String_Node_Str"" + pyramidName);
      }
      tilesize=metadata.getTilesize();
      zoomLevel=fsplit.getZoomlevel();
    }
 catch (    final ClassNotFoundException e) {
      e.printStackTrace();
      throw new IOException(e);
    }
    if (split instanceof MrsPyramidInputSplit) {
      preBounds=fsplit.getPreBounds();
      splitZoomLevel=fsplit.getZoomlevel();
    }
 else {
      splitZoomLevel=zoomLevel;
    }
    inputTileBounds=TMSUtils.boundsToTile(inputBounds.getTMSBounds(),zoomLevel,tilesize);
    if (tileClusterInfo != null) {
      final int neighborCount=tileClusterInfo.getNeighborCount();
      if (neighborCount > 0) {
        neighborTileIds=new long[neighborCount];
        initialTile=new TMSUtils.Tile(inputTileBounds.w - tileClusterInfo.getOffsetX(),inputTileBounds.s - tileClusterInfo.getOffsetY());
      }
    }
    value=new TileCollection<T>();
    key=new TileIdWritable();
  }
 else {
    throw new IOException(""String_Node_Str"" + split.getClass().getName());
  }
}","@Override public void initialize(InputSplit split,TaskAttemptContext context) throws IOException, InterruptedException {
  this.myconf=context.getConfiguration();
  if (split instanceof MrsPyramidInputSplit) {
    final MrsPyramidInputSplit fsplit=(MrsPyramidInputSplit)split;
    final Configuration conf=context.getConfiguration();
    ifContext=TiledInputFormatContext.load(context.getConfiguration());
    if (ifContext.getBounds() != null) {
      inputBounds=ifContext.getBounds();
    }
    scannedInputReader=createRecordReader(fsplit,context);
    final String pyramidName=fsplit.getName();
    tileClusterInfo=HadoopUtils.getTileClusterInfo(conf);
    readers=new HashMap<String,MrsTileReader<T>>();
    tilecache=new HashMap<String,Map<TileIdWritable,T>>();
    int readerTileCacheSize=(tileClusterInfo == null) ? ifContext.getInputs().size() : (tileClusterInfo.getNeighborCount() + 1) * 2 * ifContext.getInputs().size();
    readerTileCache=CacheBuilder.newBuilder().maximumSize(readerTileCacheSize).expireAfterAccess(120,TimeUnit.SECONDS).build();
    for (    final String inputPyramidName : ifContext.getInputs()) {
      if (pyramidName.equals(inputPyramidName)) {
        scannedInput=inputPyramidName;
        if (tileClusterInfo != null && (tileClusterInfo.getNeighborCount() > 0)) {
          primaryReader=getMrsTileReader(inputPyramidName,ifContext.getZoomLevel(),conf);
        }
      }
 else {
        secondaryPyramidNames.add(inputPyramidName);
        MrsTileReader<T> tileReader=getMrsTileReader(inputPyramidName,ifContext.getZoomLevel(),conf);
        if (tileReader.canBeCached()) {
          readers.put(inputPyramidName,tileReader);
        }
      }
    }
    try {
      final Map<String,MrsPyramidMetadata> metadataMap=readMetadata(conf);
      MrsPyramidMetadata metadata=metadataMap.get(pyramidName);
      if (metadata == null) {
        metadata=metadataMap.get(pyramidName);
      }
      if (metadata == null) {
        throw new IOException(""String_Node_Str"" + pyramidName);
      }
      tilesize=metadata.getTilesize();
      zoomLevel=fsplit.getZoomlevel();
    }
 catch (    final ClassNotFoundException e) {
      e.printStackTrace();
      throw new IOException(e);
    }
    if (split instanceof MrsPyramidInputSplit) {
      preBounds=fsplit.getPreBounds();
      splitZoomLevel=fsplit.getZoomlevel();
    }
 else {
      splitZoomLevel=zoomLevel;
    }
    inputTileBounds=TMSUtils.boundsToTile(inputBounds.getTMSBounds(),zoomLevel,tilesize);
    if (tileClusterInfo != null) {
      final int neighborCount=tileClusterInfo.getNeighborCount();
      if (neighborCount > 0) {
        neighborTileIds=new long[neighborCount];
        initialTile=new TMSUtils.Tile(inputTileBounds.w - tileClusterInfo.getOffsetX(),inputTileBounds.s - tileClusterInfo.getOffsetY());
      }
    }
    value=new TileCollection<T>();
    key=new TileIdWritable();
  }
 else {
    throw new IOException(""String_Node_Str"" + split.getClass().getName());
  }
}","The original code had inefficient caching parameters that could lead to poor performance and potential memory issues. The fixed code increases the reader tile cache size by multiplying with 2 and extends the cache expiration time from 10 to 120 seconds, providing more robust caching strategy. These modifications enhance memory management and improve overall performance by allowing more flexible and longer-lasting tile caching during MapReduce processing."
94469,"@Override public List<InputSplit> getSplits(JobContext context) throws IOException {
  Configuration conf=context.getConfiguration();
  TiledInputFormatContext ifContext=TiledInputFormatContext.load(conf);
  final int zoom=ifContext.getZoomLevel();
  final int tilesize=ifContext.getTileSize();
  HdfsMrsImageDataProvider dp=new HdfsMrsImageDataProvider(context.getConfiguration(),input,null);
  Path inputWithZoom=new Path(dp.getResourcePath(true),""String_Node_Str"" + zoom);
  org.mrgeo.hdfs.tile.FileSplit splitfile=new org.mrgeo.hdfs.tile.FileSplit();
  splitfile.readSplits(inputWithZoom);
  MrsImagePyramidMetadataReader metadataReader=dp.getMetadataReader();
  MrsImagePyramidMetadata metadata=metadataReader.read();
  List<InputSplit> actualSplits=super.getSplits(context);
  List<InputSplit> result=new ArrayList<InputSplit>(actualSplits.size());
  for (  InputSplit actualSplit : actualSplits) {
    if (!(actualSplit instanceof FileSplit)) {
      throw new IOException(""String_Node_Str"" + actualSplit.getClass().getCanonicalName());
    }
    FileSplit fileSplit=(FileSplit)actualSplit;
    String partFile=fileSplit.getPath().getParent().getName();
    if (!partFile.startsWith(""String_Node_Str"")) {
      throw new IOException(""String_Node_Str"" + partFile);
    }
    org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo splitinfo;
    try {
      splitinfo=(org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo)splitfile.getSplitByName(partFile);
    }
 catch (    Splits.SplitException e) {
      String indexStr=partFile.substring(partFile.lastIndexOf('-') + 1,partFile.length());
      int partition=Integer.valueOf(indexStr);
      splitinfo=(org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo)splitfile.getSplitByPartition(partition);
    }
    long endTileId=splitinfo.getEndId();
    long startTileId=splitinfo.getStartId();
    TMSUtils.Tile startTile=TMSUtils.tileid(startTileId,zoom);
    TMSUtils.Tile endTile=TMSUtils.tileid(endTileId,zoom);
    TileBounds partFileTileBounds=new TileBounds(startTile.tx,startTile.ty,endTile.tx,endTile.ty);
    Bounds partFileBounds=TMSUtils.tileToBounds(partFileTileBounds,zoom,tilesize);
    if (ifContext.getBounds() != null) {
      Bounds requestedBounds=ifContext.getBounds().getTMSBounds();
      if (requestedBounds.intersect(partFileBounds,false)) {
        Bounds intersected=requestedBounds.intersection(partFileBounds,false);
        TMSUtils.TileBounds tb=TMSUtils.boundsToTile(intersected,zoom,tilesize);
        long s=TMSUtils.tileid(tb.w,tb.s,zoom);
        long e=TMSUtils.tileid(tb.e,tb.n,zoom);
        result.add(new TiledInputSplit(actualSplit,s,e,zoom,metadata.getTilesize()));
      }
    }
 else {
      result.add(new TiledInputSplit(actualSplit,startTileId,endTileId,ifContext.getZoomLevel(),metadata.getTilesize()));
    }
  }
  return result;
}","@Override public List<InputSplit> getSplits(JobContext context) throws IOException {
  Configuration conf=context.getConfiguration();
  TiledInputFormatContext ifContext=TiledInputFormatContext.load(conf);
  final int zoom=ifContext.getZoomLevel();
  final int tilesize=ifContext.getTileSize();
  HdfsMrsImageDataProvider dp=new HdfsMrsImageDataProvider(context.getConfiguration(),input,null);
  Path inputWithZoom=new Path(dp.getResourcePath(true),""String_Node_Str"" + zoom);
  org.mrgeo.hdfs.tile.FileSplit splitfile=new org.mrgeo.hdfs.tile.FileSplit();
  splitfile.readSplits(inputWithZoom);
  MrsImagePyramidMetadataReader metadataReader=dp.getMetadataReader();
  MrsImagePyramidMetadata metadata=metadataReader.read();
  List<InputSplit> actualSplits=super.getSplits(context);
  List<InputSplit> result=new ArrayList<InputSplit>(actualSplits.size());
  for (  InputSplit actualSplit : actualSplits) {
    if (!(actualSplit instanceof FileSplit)) {
      throw new IOException(""String_Node_Str"" + actualSplit.getClass().getCanonicalName());
    }
    FileSplit fileSplit=(FileSplit)actualSplit;
    String partFile=fileSplit.getPath().getParent().getName();
    if (!partFile.startsWith(""String_Node_Str"")) {
      throw new IOException(""String_Node_Str"" + partFile);
    }
    org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo splitinfo;
    try {
      splitinfo=(org.mrgeo.hdfs.tile.FileSplit.FileSplitInfo)splitfile.getSplitByName(partFile);
    }
 catch (    Splits.SplitNotFoundException e) {
      LOG.info(""String_Node_Str"" + super.getClass().getName() + ""String_Node_Str""+ partFile);
      continue;
    }
    long endTileId=splitinfo.getEndId();
    long startTileId=splitinfo.getStartId();
    TMSUtils.Tile startTile=TMSUtils.tileid(startTileId,zoom);
    TMSUtils.Tile endTile=TMSUtils.tileid(endTileId,zoom);
    TileBounds partFileTileBounds=new TileBounds(startTile.tx,startTile.ty,endTile.tx,endTile.ty);
    Bounds partFileBounds=TMSUtils.tileToBounds(partFileTileBounds,zoom,tilesize);
    if (ifContext.getBounds() != null) {
      Bounds requestedBounds=ifContext.getBounds().getTMSBounds();
      if (requestedBounds.intersect(partFileBounds,false)) {
        Bounds intersected=requestedBounds.intersection(partFileBounds,false);
        TMSUtils.TileBounds tb=TMSUtils.boundsToTile(intersected,zoom,tilesize);
        long s=TMSUtils.tileid(tb.w,tb.s,zoom);
        long e=TMSUtils.tileid(tb.e,tb.n,zoom);
        result.add(new TiledInputSplit(actualSplit,s,e,zoom,metadata.getTilesize()));
      }
    }
 else {
      result.add(new TiledInputSplit(actualSplit,startTileId,endTileId,ifContext.getZoomLevel(),metadata.getTilesize()));
    }
  }
  return result;
}","The original code threw an exception when encountering a split not found, which would halt the entire job processing. The fixed code catches the SplitNotFoundException, logs the information, and continues processing by skipping that particular split using the `continue` statement. This modification improves code resilience by allowing partial job completion and preventing complete failure when encountering problematic file splits."
94470,"final public SplitInfo getSplitByName(String name) throws SplitException {
  if (splits == null) {
    throw new SplitException(""String_Node_Str"");
  }
  for (  SplitInfo split : splits) {
    if (((FileSplitInfo)split).getName().equals(name)) {
      return split;
    }
  }
  throw new SplitException(""String_Node_Str"" + name + ""String_Node_Str"");
}","final public SplitInfo getSplitByName(String name) throws SplitException, SplitNotFoundException {
  if (splits == null) {
    throw new SplitException(""String_Node_Str"");
  }
  for (  SplitInfo split : splits) {
    if (((FileSplitInfo)split).getName().equals(name)) {
      return split;
    }
  }
  throw new SplitNotFoundException(""String_Node_Str"" + name + ""String_Node_Str"");
}","The original code throws a generic SplitException when no matching split is found, which lacks specificity about the error type. The fixed code introduces a new SplitNotFoundException, a more precise exception type that clearly indicates the split was not located in the collection. This change improves error handling by providing more accurate and meaningful exception information, helping developers better diagnose and handle split-related lookup failures."
94471,"/** 
 * This method will get a MapFile.Reader for the partition specified. Before closing the returned reader, the caller should make sure it is not cached in this class by calling isCachingEnabled(). If that method returns true, the caller should not close the reader. It will be automatically closed when it drops out of the cache.
 * @param partition is the particular reader being accessed
 * @return the reader for the partition specified
 * @throws IOException
 */
public MapFile.Reader getReader(final int partition) throws IOException {
  try {
    if (canBeCached) {
      log.info(""String_Node_Str"" + partition + ""String_Node_Str"");
      return readerCache.get(partition);
    }
 else {
      log.info(""String_Node_Str"" + partition + ""String_Node_Str"");
      return loadReader(partition);
    }
  }
 catch (  ExecutionException e) {
    if (e.getCause() instanceof IOException) {
      throw (IOException)e.getCause();
    }
    throw new IOException(e);
  }
}","/** 
 * This method will get a MapFile.Reader for the partition specified. Before closing the returned reader, the caller should make sure it is not cached in this class by calling isCachingEnabled(). If that method returns true, the caller should not close the reader. It will be automatically closed when it drops out of the cache.
 * @param partitionIndex is the particular reader being accessed
 * @return the reader for the partition specified
 * @throws IOException
 */
public MapFile.Reader getReader(final int partitionIndex) throws IOException {
  try {
    if (canBeCached) {
      log.info(""String_Node_Str"" + partitionIndex + ""String_Node_Str"");
      return readerCache.get(partitionIndex);
    }
 else {
      log.info(""String_Node_Str"" + partitionIndex + ""String_Node_Str"");
      return loadReader(partitionIndex);
    }
  }
 catch (  ExecutionException e) {
    if (e.getCause() instanceof IOException) {
      throw (IOException)e.getCause();
    }
    throw new IOException(e);
  }
}","The original code had a parameter name ""partition"" that could potentially create confusion with existing variables or methods. The fixed code renamed the parameter to ""partitionIndex"", providing a more descriptive and clear identifier for the method's input. This change improves code readability and reduces the potential for naming conflicts, making the method's purpose and usage more explicit."
94472,"@Override public MapFile.Reader load(final Integer partition) throws IOException {
  return loadReader(partition);
}","@Override public MapFile.Reader load(final Integer partitionIndex) throws IOException {
  return loadReader(partitionIndex);
}","The original code uses an ambiguous parameter name ""partition"" that doesn't clearly indicate its purpose or index-based nature. The fixed code renames the parameter to ""partitionIndex"", which explicitly communicates its role as an index for accessing a specific partition. By using a more descriptive parameter name, the code becomes more self-documenting and improves code readability for developers working with the MapFile.Reader loading mechanism."
94473,"private MapFile.Reader loadReader(int partition) throws IOException {
  final FileSplit.FileSplitInfo part=(FileSplit.FileSplitInfo)splits.getSplits()[partition];
  final Path path=new Path(imagePath,part.getName());
  MapFile.Reader reader=new MapFile.Reader(path,conf);
  if (profile) {
    LeakChecker.instance().add(reader,ExceptionUtils.getFullStackTrace(new Throwable(""String_Node_Str"")));
  }
  return reader;
}","private MapFile.Reader loadReader(int partitionIndex) throws IOException {
  final FileSplit.FileSplitInfo part=(FileSplit.FileSplitInfo)splits.getSplits()[partitionIndex];
  final Path path=new Path(imagePath,part.getName());
  MapFile.Reader reader=new MapFile.Reader(path,conf);
  if (profile) {
    LeakChecker.instance().add(reader,ExceptionUtils.getFullStackTrace(new Throwable(""String_Node_Str"")));
  }
  return reader;
}","The original code used an ambiguous parameter name ""partition"" which could lead to misunderstanding of its intended purpose and potential misuse. The fixed code renames the parameter to ""partitionIndex"", explicitly clarifying that it represents an index within the splits collection. This small but meaningful renaming enhances code readability and provides a clearer semantic indication of the parameter's role in accessing the specific file split."
94474,"@SuppressWarnings(""String_Node_Str"") private void primeScanner(final long startTileId,final long endTileId){
  try {
    curPartition=-1;
    int partition=reader.getPartition(new TileIdWritable(startTileId));
    TileIdWritable startKey=null;
    while (curPartition == -1 && partition < reader.getMaxPartitions()) {
      if (!reader.canBeCached() && mapfile != null) {
        mapfile.close();
      }
      mapfile=reader.getReader(partition);
      try {
        if (startKey == null) {
          startKey=(TileIdWritable)mapfile.getKeyClass().newInstance();
          startKey.set(startTileId);
          endKey=(TileIdWritable)mapfile.getKeyClass().newInstance();
          endKey.set(endTileId);
          currentValue=(TWritable)mapfile.getValueClass().newInstance();
        }
      }
 catch (      InstantiationException e) {
        throw new MrsImageException(e);
      }
catch (      IllegalAccessException e) {
        throw new MrsImageException(e);
      }
      currentKey=(TileIdWritable)mapfile.getClosest(startKey,currentValue);
      if (currentKey != null && inRange(currentKey)) {
        readFirstKey=true;
        curPartition=partition;
      }
 else {
        partition++;
      }
    }
  }
 catch (  Splits.SplitException se) {
    currentKey=null;
  }
catch (  final IOException e) {
    throw new MrsImageException(e);
  }
}","@SuppressWarnings(""String_Node_Str"") private void primeScanner(final long startTileId,final long endTileId){
  try {
    curPartitionIndex=-1;
    int partitionIndex=reader.getPartitionIndex(new TileIdWritable(startTileId));
    TileIdWritable startKey=null;
    while (curPartitionIndex == -1 && partitionIndex < reader.getMaxPartitions()) {
      if (!reader.canBeCached() && mapfile != null) {
        mapfile.close();
      }
      mapfile=reader.getReader(partitionIndex);
      try {
        if (startKey == null) {
          startKey=(TileIdWritable)mapfile.getKeyClass().newInstance();
          startKey.set(startTileId);
          endKey=(TileIdWritable)mapfile.getKeyClass().newInstance();
          endKey.set(endTileId);
          currentValue=(TWritable)mapfile.getValueClass().newInstance();
        }
      }
 catch (      InstantiationException e) {
        throw new MrsImageException(e);
      }
catch (      IllegalAccessException e) {
        throw new MrsImageException(e);
      }
      currentKey=(TileIdWritable)mapfile.getClosest(startKey,currentValue);
      if (currentKey != null && inRange(currentKey)) {
        readFirstKey=true;
        curPartitionIndex=partitionIndex;
      }
 else {
        partitionIndex++;
      }
    }
  }
 catch (  Splits.SplitException se) {
    currentKey=null;
  }
catch (  final IOException e) {
    throw new MrsImageException(e);
  }
}","The original code used ambiguous variable names like ""partition"" without clear semantic meaning, potentially leading to misunderstandings about data indexing. The fixed code replaced ""partition"" with ""partitionIndex"" and corresponding method calls like ""getPartitionIndex()"", providing more explicit and meaningful variable nomenclature. These naming improvements enhance code readability, reduce potential confusion, and make the method's data traversal logic more transparent and self-documenting."
94475,"/** 
 * Keeping track of what is being sent back and possibly finish using one MapFile and then opening another MapFile if needed.
 */
@Override public boolean hasNext(){
  try {
    if (currentKey == null) {
      return false;
    }
    if (readFirstKey) {
      readFirstKey=false;
      if (currentKey.compareTo(endKey) <= 0) {
        return true;
      }
      return false;
    }
    while (true) {
      final boolean found=mapfile.next(currentKey,currentValue);
      if (found) {
        if (currentKey.compareTo(endKey) <= 0) {
          if (zoom > 0) {
            final TMSUtils.Tile t=TMSUtils.tileid(currentKey.get(),zoom);
            if (t.tx >= rowStart && t.tx <= rowEnd) {
              return true;
            }
          }
 else {
            return true;
          }
        }
 else {
          return false;
        }
      }
 else {
        if (++curPartition >= reader.getMaxPartitions()) {
          return false;
        }
        if (!reader.canBeCached() && mapfile != null) {
          mapfile.close();
        }
        mapfile=reader.getReader(curPartition);
      }
    }
  }
 catch (  final IOException e) {
    throw new MrsImageException(e);
  }
}","/** 
 * Keeping track of what is being sent back and possibly finish using one MapFile and then opening another MapFile if needed.
 */
@Override public boolean hasNext(){
  try {
    if (currentKey == null) {
      return false;
    }
    if (readFirstKey) {
      readFirstKey=false;
      if (currentKey.compareTo(endKey) <= 0) {
        return true;
      }
      return false;
    }
    while (true) {
      final boolean found=mapfile.next(currentKey,currentValue);
      if (found) {
        if (currentKey.compareTo(endKey) <= 0) {
          if (zoom > 0) {
            final TMSUtils.Tile t=TMSUtils.tileid(currentKey.get(),zoom);
            if (t.tx >= rowStart && t.tx <= rowEnd) {
              return true;
            }
          }
 else {
            return true;
          }
        }
 else {
          return false;
        }
      }
 else {
        if (++curPartitionIndex >= reader.getMaxPartitions()) {
          return false;
        }
        if (!reader.canBeCached() && mapfile != null) {
          mapfile.close();
        }
        mapfile=reader.getReader(curPartitionIndex);
      }
    }
  }
 catch (  final IOException e) {
    throw new MrsImageException(e);
  }
}","The original code used an ambiguous variable name `curPartition`, which could lead to misunderstandings about the partition tracking mechanism. The fixed code replaces `curPartition` with the more descriptive `curPartitionIndex`, providing clarity about the current partition being processed. This change improves code readability and reduces potential confusion when managing multiple MapFile partitions during iteration."
94476,"@Test @Category(UnitTest.class) public void testGetRasterPngLargerThanTileSize() throws Exception {
  testIslandsElevationFor(""String_Node_Str"",MrGeoConstants.MRGEO_MRS_TILESIZE_DEFAULT,MrGeoConstants.MRGEO_MRS_TILESIZE_DEFAULT,ISLANDS_ELEVATION_V2_IN_BOUNDS_SINGLE_TILE,islandsElevation_unqualified,getDefaultColorScale(),""String_Node_Str"",""String_Node_Str"",ImageUtils.createImageReader(""String_Node_Str""));
}","@Test @Category(UnitTest.class) public void testGetRasterPngLargerThanTileSize() throws Exception {
  testIslandsElevationFor(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",ISLANDS_ELEVATION_V2_IN_BOUNDS_SINGLE_TILE,islandsElevation_unqualified,getDefaultColorScale(),""String_Node_Str"",""String_Node_Str"",ImageUtils.createImageReader(""String_Node_Str""));
}","The original code incorrectly included redundant tile size parameters that were unnecessary for the test method. The fixed code removes these superfluous MrGeoConstants.MRGEO_MRS_TILESIZE_DEFAULT arguments, streamlining the method call to its essential parameters. This simplification makes the test more focused and eliminates potential confusion caused by unnecessary tile size specifications."
94477,"public void paintGeometry(Geometry g){
  final Bounds featureBounds=g.getBounds();
  if (inputBounds == null) {
    inputBounds=featureBounds;
  }
 else {
    inputBounds.expand(featureBounds);
  }
  if (valueColumn == null || aggregationType == AggregationType.MASK) {
    rasterPainter.paint(g);
  }
 else {
    final String sv=g.getAttribute(valueColumn);
    if (sv != null) {
      final double v=Double.parseDouble(sv);
      composite.setWeight(v);
      rasterPainter.paint(g);
    }
 else {
      log.info(""String_Node_Str"" + valueColumn);
    }
  }
}","public void paintGeometry(Geometry g){
  final Bounds featureBounds=g.getBounds();
  if (inputBounds == null) {
    inputBounds=featureBounds;
  }
 else {
    inputBounds.expand(featureBounds);
  }
  if (valueColumn == null || aggregationType == AggregationType.MASK) {
    rasterPainter.paint(g);
  }
 else {
    final String sv=g.getAttribute(valueColumn);
    if (sv != null) {
      final double v=Double.parseDouble(sv);
      ((WeightedComposite)composite).setWeight(v);
      rasterPainter.paint(g);
    }
 else {
      log.info(""String_Node_Str"" + valueColumn);
    }
  }
}","The original code incorrectly attempts to set weight on a generic `composite` object without proper type casting, which would cause a runtime error. The fixed code explicitly casts `composite` to `WeightedComposite` before calling `setWeight()`, ensuring type-safe method invocation. This modification prevents potential ClassCastException and allows the weight to be correctly set for weighted compositing operations."
94478,"public void beforePaintingTile(final long tileId){
  if (aggregationType == AggregationType.MIN) {
    composite=new MinCompositeDouble();
  }
 else   if (aggregationType == AggregationType.MAX) {
    composite=new MaxCompositeDouble();
  }
 else {
    composite=new AdditiveCompositeDouble();
  }
  raster=RasterUtils.createEmptyRaster(tileSize,tileSize,1,DataBuffer.TYPE_DOUBLE,Double.NaN);
  totalRaster=null;
  totalPainter=null;
  if (aggregationType == AggregationType.AVERAGE) {
    totalRaster=raster.createCompatibleWritableRaster();
    final BufferedImage bi=RasterUtils.makeBufferedImage(totalRaster);
    final Graphics2D gr=bi.createGraphics();
    gr.setComposite(composite);
    gr.setStroke(new BasicStroke(0));
    totalPainter=new GeometryPainter(gr,totalRaster,new Color(1,1,1),new Color(0,0,0));
  }
  final BufferedImage bi=RasterUtils.makeBufferedImage(raster);
  final Graphics2D gr=bi.createGraphics();
  if (aggregationType == AggregationType.MASK) {
    composite.setWeight(0.0);
  }
  gr.setComposite(composite);
  gr.setStroke(new BasicStroke(0));
  rasterPainter=new GeometryPainter(gr,raster,new Color(1,1,1),new Color(0,0,0));
  final Tile tile=TMSUtils.tileid(tileId,zoom);
  final TMSUtils.Bounds tb=TMSUtils.tileBounds(tile.tx,tile.ty,zoom,tileSize);
  b=new Bounds(tb.w,tb.s,tb.e,tb.n);
  rasterPainter.setBounds(b);
}","public void beforePaintingTile(final long tileId){
  if (aggregationType == AggregationType.MIN) {
    composite=new MinCompositeDouble();
  }
 else   if (aggregationType == AggregationType.MAX) {
    composite=new MaxCompositeDouble();
  }
 else   if (aggregationType == AggregationType.MASK) {
    composite=new MaskComposite(1.0,0.0,Double.NaN);
  }
 else {
    composite=new AdditiveCompositeDouble();
  }
  raster=RasterUtils.createEmptyRaster(tileSize,tileSize,1,DataBuffer.TYPE_DOUBLE,Double.NaN);
  totalRaster=null;
  totalPainter=null;
  if (aggregationType == AggregationType.AVERAGE) {
    totalRaster=raster.createCompatibleWritableRaster();
    final BufferedImage bi=RasterUtils.makeBufferedImage(totalRaster);
    final Graphics2D gr=bi.createGraphics();
    gr.setComposite(composite);
    gr.setStroke(new BasicStroke(0));
    totalPainter=new GeometryPainter(gr,totalRaster,new Color(1,1,1),new Color(0,0,0));
  }
  final BufferedImage bi=RasterUtils.makeBufferedImage(raster);
  final Graphics2D gr=bi.createGraphics();
  gr.setComposite(composite);
  gr.setStroke(new BasicStroke(0));
  rasterPainter=new GeometryPainter(gr,raster,new Color(1,1,1),new Color(0,0,0));
  final Tile tile=TMSUtils.tileid(tileId,zoom);
  final TMSUtils.Bounds tb=TMSUtils.tileBounds(tile.tx,tile.ty,zoom,tileSize);
  b=new Bounds(tb.w,tb.s,tb.e,tb.n);
  rasterPainter.setBounds(b);
}","The original code lacked proper handling for the MASK aggregation type, missing a specific composite implementation. The fixed code adds a MaskComposite with appropriate parameters for the MASK case, ensuring correct composition logic for different aggregation types. This improvement provides more robust and flexible raster processing by explicitly defining composite behavior for all aggregation scenarios."
94479,"public boolean afterPaintingGeometry(Geometry g){
  if (aggregationType == AggregationType.LAST) {
    return false;
  }
  if (aggregationType == AggregationType.AVERAGE && totalPainter != null) {
    composite.setWeight(1.0);
    totalPainter.setBounds(b);
    totalPainter.paint(g);
  }
  return true;
}","public boolean afterPaintingGeometry(Geometry g){
  if (aggregationType == AggregationType.LAST) {
    return false;
  }
  if (aggregationType == AggregationType.AVERAGE && totalPainter != null) {
    ((WeightedComposite)composite).setWeight(1.0);
    totalPainter.setBounds(b);
    totalPainter.paint(g);
  }
  return true;
}","The original code incorrectly calls `setWeight()` directly on the `composite` object, which may not support this method. In the fixed code, a type cast to `WeightedComposite` ensures that the method is called on the correct object type with the appropriate interface. This correction prevents potential runtime errors and guarantees that the weight setting is performed on the intended composite object with the proper method implementation."
94480,"@Override public void move(final String toResource) throws IOException {
  HadoopFileUtils.move(getConfiguration(),getResourcePath(),determineResourcePath(getConfiguration(),toResource));
}","@Override public void move(final String toResource) throws IOException {
  try {
    HadoopFileUtils.move(getConfiguration(),getResourcePath(),determineResourcePath(getConfiguration(),toResource));
  }
 catch (  URISyntaxException e) {
    throw new IOException(e);
  }
}","The original code lacks proper error handling for potential URI syntax exceptions that may occur during resource path determination. The fixed code introduces a try-catch block to explicitly catch URISyntaxException and convert it to an IOException, ensuring robust error management. This modification prevents unhandled exceptions and provides a more graceful error reporting mechanism when moving resources in a Hadoop file system."
94481,"public static void delete(final Configuration conf,String name,final Properties providerProperties) throws IOException {
  HadoopFileUtils.delete(determineResourcePath(conf,name));
}","public static void delete(final Configuration conf,String name,final Properties providerProperties) throws IOException {
  try {
    HadoopFileUtils.delete(determineResourcePath(conf,name));
  }
 catch (  URISyntaxException e) {
    throw new IOException(e);
  }
}","The original code lacks error handling for potential URI syntax exceptions that might occur during resource path determination. The fixed code adds a try-catch block to explicitly catch URISyntaxException and wrap it in an IOException, ensuring robust error management. This modification prevents silent failures and provides clear error propagation when resource path resolution encounters unexpected syntax issues."
94482,"public Path getResourcePath() throws IOException {
  if (resourcePath == null) {
    resourcePath=determineResourcePath(getConfiguration(),getResourceName());
  }
  return resourcePath;
}","public Path getResourcePath() throws IOException {
  if (resourcePath == null) {
    try {
      resourcePath=determineResourcePath(getConfiguration(),getResourceName());
    }
 catch (    URISyntaxException e) {
      throw new IOException(e);
    }
  }
  return resourcePath;
}","The original code lacks error handling for potential `URISyntaxException` that might be thrown by `determineResourcePath()`, which could silently fail or cause unexpected runtime errors. The fixed code adds a try-catch block to explicitly catch and convert the `URISyntaxException` into an `IOException`, ensuring that any URI-related exceptions are properly propagated and handled. This modification improves code robustness by providing comprehensive exception management and preventing potential silent failures during resource path determination."
94483,"public static boolean canOpen(final Configuration conf,final String name,final Properties providerProperties) throws IOException {
  Path p=determineResourcePath(conf,name);
  FileSystem fs=HadoopFileUtils.getFileSystem(conf,p);
  return fs.exists(p);
}","public static boolean canOpen(final Configuration conf,final String name,final Properties providerProperties) throws IOException {
  try {
    Path p=determineResourcePath(conf,name);
    FileSystem fs=HadoopFileUtils.getFileSystem(conf,p);
    return fs.exists(p);
  }
 catch (  URISyntaxException e) {
  }
  return false;
}","The original code lacks proper error handling for potential URI syntax exceptions that might occur during path determination or file system access. The fixed code introduces a try-catch block to handle URISyntaxException, gracefully returning false if such an exception is encountered during file path or file system operations. This modification improves the method's robustness by preventing unhandled exceptions and providing a predictable fallback behavior when resource access fails."
94484,"public static boolean exists(final Configuration conf,String name,final Properties providerProperties) throws IOException {
  return HadoopFileUtils.exists(determineResourcePath(conf,name));
}","public static boolean exists(final Configuration conf,String name,final Properties providerProperties) throws IOException {
  try {
    return HadoopFileUtils.exists(determineResourcePath(conf,name));
  }
 catch (  URISyntaxException e) {
  }
  return false;
}","The original code lacks error handling for potential `URISyntaxException` that might occur during resource path determination. The fixed code introduces a try-catch block to gracefully handle this exception, returning `false` if the resource path cannot be resolved. This approach provides robust error management, preventing unexpected runtime failures and ensuring a predictable behavior when resource detection encounters syntactical issues."
94485,"private static Path determineResourcePath(final Configuration conf,final String resourceName) throws IOException {
  return HadoopFileUtils.resolveName(conf,resourceName,false);
}","private static Path determineResourcePath(final Configuration conf,final String resourceName) throws IOException, URISyntaxException {
  return HadoopFileUtils.resolveName(conf,resourceName,false);
}","The original code lacks a necessary exception handling for potential URI-related errors when resolving resource paths. The fixed code adds `URISyntaxException` to the method's declared exceptions, enabling proper handling of URI syntax problems during resource resolution. By explicitly declaring this exception, the method now provides more robust error management and allows calling methods to handle potential URI-related exceptions gracefully."
94486,"@Override public void move(final String toResource) throws IOException {
  HadoopFileUtils.move(getConfiguration(),resolveNameToPath(getConfiguration(),getResourceName(),providerProperties,true,true),new Path(toResource));
}","@Override public void move(final String toResource) throws IOException {
  try {
    HadoopFileUtils.move(getConfiguration(),resolveNameToPath(getConfiguration(),getResourceName(),providerProperties,true,true),new Path(toResource));
  }
 catch (  IllegalArgumentException e) {
    throw new IOException(e);
  }
}","The original code lacked proper error handling for potential IllegalArgumentException that could be thrown during file movement operations. The fixed code wraps the file move operation in a try-catch block, specifically catching IllegalArgumentException and converting it to an IOException for more consistent and predictable error management. This approach ensures that any argument-related errors are properly propagated and transformed, improving the method's robustness and adherence to exception handling best practices."
94487,"public String getResolvedResourceName(final boolean mustExist) throws IOException {
  return resolveNameToPath(conf,getResourceName(),providerProperties,mustExist,true).toUri().toString();
}","public String getResolvedResourceName(final boolean mustExist) throws IOException {
  try {
    return resolveNameToPath(conf,getResourceName(),providerProperties,mustExist,true).toUri().toString();
  }
 catch (  IllegalArgumentException e) {
    throw new IOException(e);
  }
}","The original code lacks error handling for potential `IllegalArgumentException` that might be thrown during resource name resolution. The fixed code introduces a try-catch block to catch `IllegalArgumentException` and rethrow it as an `IOException`, providing more robust error management. This approach ensures that any illegal argument errors are properly converted and propagated, preventing silent failures and improving the method's reliability."
94488,"public static boolean canWrite(final Configuration conf,String input,final Properties providerProperties) throws IOException {
  Path p=resolveNameToPath(conf,input,providerProperties,true,true);
  return (p == null);
}","public static boolean canWrite(final Configuration conf,String input,final Properties providerProperties) throws IOException {
  try {
    Path p=resolveNameToPath(conf,input,providerProperties,true,true);
    return (p == null);
  }
 catch (  IllegalArgumentException e) {
  }
  return false;
}","The original code lacks proper error handling, potentially throwing uncaught exceptions when resolveNameToPath encounters invalid inputs. The fixed code adds a try-catch block to handle IllegalArgumentException, ensuring graceful failure by returning false if path resolution fails. This approach provides a robust method for checking write permissions by safely catching and managing potential resolution errors."
94489,"public static void delete(final Configuration conf,String input,final Properties providerProperties) throws IOException {
  Path p=resolveNameToPath(conf,input,providerProperties,false,true);
  if (p != null) {
    HadoopFileUtils.delete(conf,p);
  }
}","public static void delete(final Configuration conf,String input,final Properties providerProperties) throws IOException {
  try {
    Path p=resolveNameToPath(conf,input,providerProperties,false,true);
    if (p != null) {
      HadoopFileUtils.delete(conf,p);
    }
  }
 catch (  IllegalArgumentException e) {
    throw new IOException(e);
  }
}","The original code lacks proper error handling for potential IllegalArgumentException that might be thrown during path resolution or deletion. The fixed code wraps the operation in a try-catch block, specifically catching IllegalArgumentException and converting it to an IOException for more robust error management. This approach ensures that any runtime argument-related errors are properly propagated and handled, preventing silent failures and providing better diagnostic information."
94490,"public static boolean exists(final Configuration conf,String input,final Properties providerProperties) throws IOException {
  return resolveNameToPath(conf,input,providerProperties,true,true) != null;
}","public static boolean exists(final Configuration conf,String input,final Properties providerProperties) throws IOException {
  return resolveNameToPath(conf,input,providerProperties,true,false) != null;
}","The original code incorrectly passed `true` for both recursive and create parameters in `resolveNameToPath()`, potentially causing unintended file system modifications. The fixed code changes the second parameter to `false`, preventing automatic file or directory creation during path resolution. This modification ensures safer path checking without side effects, making the `exists()` method more predictable and less prone to unintended file system operations."
94491,"public static Path resolveName(final Configuration conf,final String input,boolean checkForExistance) throws IOException {
  File f=new File(input);
  if (f.exists()) {
    try {
      return new Path(new URI(""String_Node_Str"" + input));
    }
 catch (    URISyntaxException e) {
    }
  }
  try {
    Path p=new Path(new URI(input));
    if (!checkForExistance || exists(conf,p)) {
      return p;
    }
  }
 catch (  URISyntaxException e) {
    throw new IOException(e);
  }
  throw new IOException(""String_Node_Str"" + input);
}","public static Path resolveName(final Configuration conf,final String input,boolean checkForExistance) throws IOException, URISyntaxException {
  File f=new File(input);
  if (f.exists()) {
    try {
      return new Path(new URI(""String_Node_Str"" + input));
    }
 catch (    URISyntaxException e) {
    }
  }
  Path p=new Path(new URI(input));
  if (!checkForExistance || exists(conf,p)) {
    return p;
  }
  throw new IOException(""String_Node_Str"" + input);
}","The original code had an unnecessary nested try-catch block and potential infinite recursion when creating a Path, which could cause unexpected behavior. The fixed code simplifies the URISyntaxException handling by moving the Path creation outside the try-catch and removing redundant exception handling, ensuring a more direct and predictable path resolution. These changes improve error handling, reduce code complexity, and make the method more robust when resolving file paths."
94492,"/** 
 * For each subdirectory below srcParent, move that subdirectory below targetParent. If a sub-directory already exists under the targetParent, delete it and then perform the move. This function does not moves files below the parent, just directories.
 * @param fs
 * @param targetParent
 * @throws IOException
 */
public static void moveChildDirectories(final Configuration conf,final Path srcParent,final Path targetParent) throws IOException {
  final FileSystem fs=getFileSystem(conf,srcParent);
  if (!fs.exists(targetParent)) {
    fs.mkdirs(targetParent);
  }
  final FileStatus[] children=fs.listStatus(srcParent);
  for (  final FileStatus stat : children) {
    if (stat.isDir()) {
      final Path srcPath=stat.getPath();
      final String name=srcPath.getName();
      final Path target=new Path(targetParent,name);
      if (fs.exists(target)) {
        fs.delete(target,true);
      }
      if (fs.rename(srcPath,targetParent) == false) {
        final String msg=MessageFormat.format(""String_Node_Str"",srcPath.toString(),target.toString());
        throw new IOException(msg);
      }
    }
  }
}","/** 
 * For each subdirectory below srcParent, move that subdirectory below targetParent. If a sub-directory already exists under the targetParent, delete it and then perform the move. This function does not moves files below the parent, just directories.
 * @param conf
 * @param targetParent
 * @throws IOException
 */
public static void moveChildDirectories(final Configuration conf,final Path srcParent,final Path targetParent) throws IOException {
  final FileSystem fs=getFileSystem(conf,srcParent);
  if (!fs.exists(targetParent)) {
    fs.mkdirs(targetParent);
  }
  final FileStatus[] children=fs.listStatus(srcParent);
  for (  final FileStatus stat : children) {
    if (stat.isDir()) {
      final Path srcPath=stat.getPath();
      final String name=srcPath.getName();
      final Path target=new Path(targetParent,name);
      if (fs.exists(target)) {
        fs.delete(target,true);
      }
      if (fs.rename(srcPath,targetParent) == false) {
        final String msg=MessageFormat.format(""String_Node_Str"",srcPath.toString(),target.toString());
        throw new IOException(msg);
      }
    }
  }
}","The original code incorrectly used `fs.rename(srcPath,targetParent)`, which moves the entire source directory to the target parent instead of moving its subdirectories individually. The fixed code maintains the original logic but uses the correct path by creating a specific target path for each subdirectory with `new Path(targetParent,name)`. This ensures each subdirectory is correctly moved to its corresponding location under the target parent, preserving the intended directory structure."
94493,"private MapOp _loadResource(String file) throws ParserException {
  List<ResourceMapOpLoader> loaders=getResourceLoaders();
  for (  ResourceMapOpLoader loader : loaders) {
    try {
      MapOp mapOp=loader.loadMapOpFromResource(file,providerProperties);
      if (mapOp != null) {
        return mapOp;
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + file,e);
      throw new ParserException(e.getMessage());
    }
  }
  try {
    AdHocDataProvider dp=DataProviderFactory.getAdHocDataProvider(file,AccessMode.READ,providerProperties);
    if (dp != null) {
      ResourceMapOp pmo=new ResourceMapOp();
      pmo.setOutputName(file);
      return pmo;
    }
  }
 catch (  IOException e) {
    throw new ParserException(String.format(""String_Node_Str"",file,e.toString()));
  }
  throw new ParserException(String.format(""String_Node_Str"",file));
}","private MapOp _loadResource(String file) throws ParserException {
  List<ResourceMapOpLoader> loaders=getResourceLoaders();
  for (  ResourceMapOpLoader loader : loaders) {
    try {
      MapOp mapOp=loader.loadMapOpFromResource(file,providerProperties);
      if (mapOp != null) {
        return mapOp;
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + file,e);
      throw new ParserException(e);
    }
  }
  try {
    AdHocDataProvider dp=DataProviderFactory.getAdHocDataProvider(file,AccessMode.READ,providerProperties);
    if (dp != null) {
      ResourceMapOp pmo=new ResourceMapOp();
      pmo.setOutputName(file);
      return pmo;
    }
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"" + file,e);
    throw new ParserException(String.format(""String_Node_Str"",file),e);
  }
  throw new ParserException(String.format(""String_Node_Str"",file));
}","The original code incorrectly threw a new ParserException with only the error message, losing the original exception's stack trace and context. The fixed code passes the original exception when creating the ParserException and adds proper logging for the IOException catch block. This improvement provides more comprehensive error handling, preserving exception details and enabling better debugging by maintaining the full exception context and trace."
94494,"public ParserException(Exception causedBy){
  super(causedBy);
}","public ParserException(String message,Throwable cause){
  super(message,cause);
}","The original constructor lacks a descriptive error message, which limits debugging insights when a parser exception occurs. The fixed code adds a message parameter and uses a more comprehensive constructor that accepts both a custom message and the original cause exception. This improvement provides developers with clearer context about the parsing error, enabling more precise error tracking and easier troubleshooting of underlying issues."
94495,"@Test(expected=IllegalArgumentException.class) @Category(UnitTest.class) public void testExistsBadUri1() throws Exception {
  factory.exists(""String_Node_Str"",conf);
}","@Test @Category(UnitTest.class) public void testExistsBadUri1() throws Exception {
  Assert.assertFalse(factory.exists(""String_Node_Str"",conf));
}","The original code incorrectly expected an IllegalArgumentException when calling exists(), which suggests a misunderstanding of the method's behavior. The fixed code replaces the expected exception with an explicit assertion that checks for a false return value when an invalid node string is passed. This modification provides a more precise and predictable test of the factory's exists() method, ensuring proper validation without relying on exception handling."
94496,"@Test(expected=IllegalArgumentException.class) @Category(UnitTest.class) public void testExistsBadUri2() throws Exception {
  factory.exists(""String_Node_Str"",providerProperties);
}","@Test @Category(UnitTest.class) public void testExistsBadUri2() throws Exception {
  Assert.assertFalse(factory.exists(""String_Node_Str"",providerProperties));
}","The original code expected an IllegalArgumentException to be thrown, which assumes the method always fails for an invalid URI. The fixed code replaces the expected exception with an explicit assertion that checks the boolean return value of the exists() method, verifying that the method returns false for an invalid URI. This change provides a more precise and reliable test that directly validates the factory's behavior without relying on exception handling."
94497,"@Test(expected=IllegalArgumentException.class) @Category(UnitTest.class) public void testCanWriteBadUri2() throws Exception {
  factory.canWrite(""String_Node_Str"",providerProperties);
}","@Test @Category(UnitTest.class) public void testCanWriteBadUri2() throws Exception {
  Assert.assertFalse(factory.canWrite(""String_Node_Str"",providerProperties));
}","The original code expected an IllegalArgumentException to be thrown, which incorrectly assumed the method would raise an exception for an invalid URI. The fixed code replaces the expected exception with an Assert.assertFalse() method, explicitly checking that the canWrite method returns false for an invalid URI. This approach provides a more predictable and direct test of the factory's behavior, improving test reliability and clarity."
94498,"@Test(expected=IllegalArgumentException.class) @Category(UnitTest.class) public void testCanWriteBadUri1() throws Exception {
  factory.canWrite(""String_Node_Str"",conf);
}","@Test @Category(UnitTest.class) public void testCanWriteBadUri1() throws Exception {
  Assert.assertFalse(factory.canWrite(""String_Node_Str"",conf));
}","The original code expected an IllegalArgumentException to be thrown, which incorrectly assumed the method would fail for an invalid input. The fixed code uses Assert.assertFalse() to properly check the canWrite() method's return value, verifying that the factory cannot write for an invalid input without relying on exception throwing. This approach provides a more predictable and direct way to test the method's behavior, ensuring correct validation of write capabilities."
94499,"@Test(expected=IllegalArgumentException.class) @Category(UnitTest.class) public void testGetResolvedResourceNameInvalidUri() throws Exception {
  HdfsMrsImageDataProvider badprovider=new HdfsMrsImageDataProvider(conf,""String_Node_Str"",null);
  badprovider.getResolvedResourceName(true);
}","@Test(expected=IOException.class) @Category(UnitTest.class) public void testGetResolvedResourceNameInvalidUri() throws Exception {
  HdfsMrsImageDataProvider badprovider=new HdfsMrsImageDataProvider(conf,""String_Node_Str"",null);
  badprovider.getResolvedResourceName(true);
}","The original test expected an IllegalArgumentException, which was likely incorrect for the method's actual error handling. The fixed code changes the expected exception to IOException, matching the probable actual exception thrown when resolving an invalid resource name in HDFS. This correction ensures the test accurately validates the error handling behavior of the getResolvedResourceName method, improving test reliability and precision."
94500,"@Test(expected=IllegalArgumentException.class) @Category(UnitTest.class) public void testExistsBadUri() throws Exception {
  HdfsMrsImageDataProvider.exists(conf,""String_Node_Str"",null);
}","@Test @Category(UnitTest.class) public void testExistsBadUri() throws Exception {
  Assert.assertFalse(HdfsMrsImageDataProvider.exists(conf,""String_Node_Str"",null));
}","The original test expected an IllegalArgumentException to be thrown, which assumes the method would always raise an exception for a null parameter. The fixed code removes the expected exception and instead checks that the exists() method returns false when given a null parameter, allowing for more robust and predictable error handling. This approach provides a clearer, more informative test that validates the method's behavior without relying on exception throwing as the primary validation mechanism."
94501,"@Test(expected=IllegalArgumentException.class) @Category(UnitTest.class) public void testCanWriteBadUri() throws Exception {
  HdfsMrsImageDataProvider.canWrite(conf,""String_Node_Str"",null);
}","@Test @Category(UnitTest.class) public void testCanWriteBadUri() throws Exception {
  Assert.assertFalse(HdfsMrsImageDataProvider.canWrite(conf,""String_Node_Str"",null));
}","The original test incorrectly relied on an expected exception, which assumes `canWrite()` would throw an `IllegalArgumentException` for invalid input. The fixed code now uses `Assert.assertFalse()` to explicitly check that `canWrite()` returns `false` when given a null parameter, testing the method's expected behavior more accurately. This approach provides a clearer, more direct validation of the method's logic without depending on exception handling."
94502,"@Test(expected=IllegalArgumentException.class) @Category(UnitTest.class) public void testDeleteBadUri() throws Exception {
  HdfsMrsImageDataProvider.delete(conf,""String_Node_Str"",null);
}","@Test(expected=IOException.class) @Category(UnitTest.class) public void testDeleteBadUri() throws Exception {
  HdfsMrsImageDataProvider.delete(conf,""String_Node_Str"",null);
}","The original code incorrectly expected an IllegalArgumentException when deleting a bad URI in HDFS, which does not match the actual exception type thrown by the method. The fixed code changes the expected exception to IOException, which is the correct exception type for file system operations when an invalid URI is provided. This correction ensures the test accurately validates the expected error behavior during HDFS file deletion with a null URI."
94503,"@Override public boolean nextKeyValue() throws IOException, InterruptedException {
  boolean result=delegateReader.nextKeyValue();
  while (result) {
    Object value=delegateReader.getCurrentValue();
    boolean matchesFilter=(cqlFilter != null) ? cqlFilter.evaluate(value) : true;
    if (matchesFilter) {
      if (value instanceof SimpleFeature) {
        if (cqlFilter != null) {
          cqlFilter.evaluate(value);
        }
        SimpleFeature feature=(SimpleFeature)value;
        GeoWaveVectorIterator.setKeyFromFeature(currKey,feature);
        currValue=GeoWaveVectorIterator.convertToGeometry(feature);
      }
 else {
        throw new IOException(""String_Node_Str"" + value.getClass().getName());
      }
      return true;
    }
    result=delegateReader.nextKeyValue();
  }
  if (!result) {
    currKey=null;
    currValue=null;
  }
  return result;
}","@Override public boolean nextKeyValue() throws IOException, InterruptedException {
  boolean result=delegateReader.nextKeyValue();
  while (result) {
    Object value=delegateReader.getCurrentValue();
    boolean matchesFilter=(cqlFilter != null) ? cqlFilter.evaluate(value) : true;
    if (matchesFilter) {
      if (value instanceof SimpleFeature) {
        SimpleFeature feature=(SimpleFeature)value;
        GeoWaveVectorIterator.setKeyFromFeature(currKey,feature);
        currValue=GeoWaveVectorIterator.convertToGeometry(feature);
      }
 else {
        throw new IOException(""String_Node_Str"" + value.getClass().getName());
      }
      return true;
    }
    result=delegateReader.nextKeyValue();
  }
  if (!result) {
    currKey=null;
    currValue=null;
  }
  return result;
}","The original code redundantly called `cqlFilter.evaluate(value)` twice within the SimpleFeature block, which was unnecessary and potentially inefficient. The fixed code removes the duplicate filter evaluation, keeping only the single, meaningful filter check before processing the feature. This streamlines the code, eliminates redundant processing, and maintains the original filtering logic while improving code clarity and performance."
94504,public abstract int calculateTileCount();,public abstract long calculateTileCount();,"The original code uses an `int` return type, which limits the method's ability to handle large tile count calculations that may exceed the maximum integer value. By changing the return type to `long`, the method can now accommodate much larger tile counts without risking integer overflow. This modification ensures more robust and scalable tile counting functionality across different scenarios with potentially massive tile quantities."
94505,"@Override public int calculateTileCount(){
  int count=0;
  try {
    final DataOutputBuffer key=new DataOutputBuffer();
    final SequenceFile.Reader[] indexes=getIndexReaders(imagePath,conf);
    for (    final SequenceFile.Reader index : indexes) {
      while (index.nextRawKey(key) >= 0) {
        count++;
      }
    }
    for (    final SequenceFile.Reader reader : indexes) {
      reader.close();
    }
  }
 catch (  final IOException e) {
    throw new MrsTileException(e);
  }
  return count;
}","@Override public long calculateTileCount(){
  int count=0;
  try {
    final FileSystem fs=imagePath.getFileSystem(conf);
    final Path[] names=FileUtil.stat2Paths(fs.listStatus(imagePath));
    Arrays.sort(names);
    final DataOutputBuffer key=new DataOutputBuffer();
    for (    final Path name : names) {
      final FileStatus[] dirFiles=fs.listStatus(name);
      for (      final FileStatus dirFile : dirFiles) {
        if (dirFile.getPath().getName().equals(""String_Node_Str"")) {
          SequenceFile.Reader index=new SequenceFile.Reader(fs,dirFile.getPath(),conf);
          try {
            while (index.nextRawKey(key) >= 0) {
              count++;
            }
          }
  finally {
            index.close();
          }
        }
      }
    }
    return count;
  }
 catch (  final IOException e) {
    throw new MrsTileException(e);
  }
}","The original code lacks proper file system handling and assumes direct access to index readers, potentially causing resource leaks and incorrect tile counting. The fixed code introduces explicit file system traversal, adds a specific file filter for ""String_Node_Str"", and ensures proper resource management by using a try-finally block to close SequenceFile readers. This approach provides more robust, reliable tile counting with better error handling and resource cleanup."
94506,"@Override public int calculateTileCount(){
  int zl=context.getZoomlevel();
  try {
    MrsImagePyramidMetadata meta=provider.getMetadataReader().read();
    LongRectangle lr=meta.getOrCreateTileBounds(zl);
    long count=(lr.getMaxX() - lr.getMinX() + 1) * (lr.getMaxY() - lr.getMinY() + 1);
    return (int)count;
  }
 catch (  IOException ioe) {
    return -1;
  }
}","@Override public long calculateTileCount(){
  int zl=context.getZoomlevel();
  try {
    MrsImagePyramidMetadata meta=provider.getMetadataReader().read();
    LongRectangle lr=meta.getOrCreateTileBounds(zl);
    long count=(lr.getMaxX() - lr.getMinX() + 1) * (lr.getMaxY() - lr.getMinY() + 1);
    return count;
  }
 catch (  IOException ioe) {
    return -1;
  }
}","The original code incorrectly used an int return type, risking potential integer overflow when calculating large tile counts across extensive image pyramids. The fixed code changes the return type to long, allowing precise representation of larger tile count values without truncation. This modification ensures accurate tile count calculation for high-resolution or large-scale image datasets, preventing potential data loss and maintaining computational integrity."
94507,"/** 
 * get the number of tiles in the table - not implemented
 */
@Override public int calculateTileCount(){
  throw new NotImplementedException(""String_Node_Str"");
}","/** 
 * get the number of tiles in the table - not implemented
 */
@Override public long calculateTileCount(){
  throw new NotImplementedException(""String_Node_Str"");
}","The original code uses an `int` return type for `calculateTileCount()`, which limits the method's ability to represent large tile counts that might exceed the maximum integer value. The fixed code changes the return type to `long`, providing a much wider range for representing tile counts and preventing potential overflow issues. This modification ensures the method can accurately handle larger numbers of tiles across different scenarios."
94508,"protected static void initialize(final Configuration conf,final Properties p){
  if (adHocProviderFactories == null) {
    adHocProviderFactories=new HashMap<String,AdHocDataProviderFactory>();
    final ServiceLoader<AdHocDataProviderFactory> dataProviderLoader=ServiceLoader.load(AdHocDataProviderFactory.class);
    for (    final AdHocDataProviderFactory dp : dataProviderLoader) {
      if (dp.isValid()) {
        adHocProviderFactories.put(dp.getPrefix(),dp);
      }
 else {
        log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
      }
    }
  }
  if (imageIngestProviderFactories == null) {
    imageIngestProviderFactories=new HashMap<String,ImageIngestDataProviderFactory>();
    final ServiceLoader<ImageIngestDataProviderFactory> dataProviderLoader=ServiceLoader.load(ImageIngestDataProviderFactory.class);
    for (    final ImageIngestDataProviderFactory dp : dataProviderLoader) {
      try {
        if (dp.isValid()) {
          imageIngestProviderFactories.put(dp.getPrefix(),dp);
        }
 else {
          log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
      }
    }
  }
  if (mrsImageProviderFactories == null) {
    mrsImageProviderFactories=new HashMap<String,MrsImageDataProviderFactory>();
    final ServiceLoader<MrsImageDataProviderFactory> dataProviderLoader=ServiceLoader.load(MrsImageDataProviderFactory.class);
    for (    final MrsImageDataProviderFactory dp : dataProviderLoader) {
      try {
        if (dp.isValid()) {
          mrsImageProviderFactories.put(dp.getPrefix(),dp);
        }
 else {
          log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
      }
    }
  }
  if (vectorProviderFactories == null) {
    boolean debugEnabled=log.isDebugEnabled();
    vectorProviderFactories=new HashMap<String,VectorDataProviderFactory>();
    if (debugEnabled) {
      log.debug(""String_Node_Str"");
    }
    final ServiceLoader<VectorDataProviderFactory> dataProviderLoader=ServiceLoader.load(VectorDataProviderFactory.class);
    int count=0;
    for (    final VectorDataProviderFactory dp : dataProviderLoader) {
      try {
        if (debugEnabled) {
          log.debug(""String_Node_Str"" + dp.getClass().getName());
        }
        boolean valid=false;
        if (conf != null) {
          valid=dp.isValid(conf);
        }
 else {
          valid=dp.isValid();
        }
        if (valid) {
          if (debugEnabled) {
            log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ dp.getPrefix());
          }
          vectorProviderFactories.put(dp.getPrefix(),dp);
          count++;
        }
 else {
          if (debugEnabled) {
            log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ dp.getPrefix());
          }
          log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.warn(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"",e);
      }
    }
    if (count == 0) {
      log.warn(""String_Node_Str"");
    }
  }
  findPreferredProvider(conf,p);
}","protected static void initialize(final Configuration conf,final Properties p){
  if (adHocProviderFactories == null) {
    adHocProviderFactories=new HashMap<String,AdHocDataProviderFactory>();
    final ServiceLoader<AdHocDataProviderFactory> dataProviderLoader=ServiceLoader.load(AdHocDataProviderFactory.class);
    for (    final AdHocDataProviderFactory dp : dataProviderLoader) {
      if (dp.isValid()) {
        adHocProviderFactories.put(dp.getPrefix(),dp);
      }
 else {
        log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
      }
    }
  }
  if (imageIngestProviderFactories == null) {
    imageIngestProviderFactories=new HashMap<String,ImageIngestDataProviderFactory>();
    final ServiceLoader<ImageIngestDataProviderFactory> dataProviderLoader=ServiceLoader.load(ImageIngestDataProviderFactory.class);
    for (    final ImageIngestDataProviderFactory dp : dataProviderLoader) {
      try {
        if (dp.isValid()) {
          imageIngestProviderFactories.put(dp.getPrefix(),dp);
        }
 else {
          log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
      }
    }
  }
  if (mrsImageProviderFactories == null) {
    mrsImageProviderFactories=new HashMap<String,MrsImageDataProviderFactory>();
    final ServiceLoader<MrsImageDataProviderFactory> dataProviderLoader=ServiceLoader.load(MrsImageDataProviderFactory.class);
    for (    final MrsImageDataProviderFactory dp : dataProviderLoader) {
      try {
        if (dp.isValid()) {
          mrsImageProviderFactories.put(dp.getPrefix(),dp);
        }
 else {
          log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
      }
    }
  }
  if (vectorProviderFactories == null) {
    boolean debugEnabled=log.isDebugEnabled();
    vectorProviderFactories=new HashMap<String,VectorDataProviderFactory>();
    if (debugEnabled) {
      log.debug(""String_Node_Str"");
    }
    final ServiceLoader<VectorDataProviderFactory> dataProviderLoader=ServiceLoader.load(VectorDataProviderFactory.class);
    int count=0;
    for (    final VectorDataProviderFactory dp : dataProviderLoader) {
      try {
        if (debugEnabled) {
          log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ ((conf == null) ? ""String_Node_Str"" : ""String_Node_Str""));
        }
        boolean valid=false;
        if (conf != null) {
          valid=dp.isValid(conf);
        }
 else {
          valid=dp.isValid();
        }
        if (valid) {
          if (debugEnabled) {
            log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ dp.getPrefix());
          }
          vectorProviderFactories.put(dp.getPrefix(),dp);
          count++;
        }
 else {
          if (debugEnabled) {
            log.debug(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str""+ dp.getPrefix());
          }
          log.info(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.warn(""String_Node_Str"" + dp.getClass().getName() + ""String_Node_Str"",e);
      }
    }
    if (count == 0) {
      log.warn(""String_Node_Str"");
    }
  }
  findPreferredProvider(conf,p);
}","The original code lacked proper debug logging for VectorDataProviderFactory when the configuration was null. The fixed code adds a conditional logging statement that handles null configuration scenarios, inserting placeholder strings to maintain consistent logging behavior. This enhancement improves error tracking and diagnostic capabilities by ensuring comprehensive logging across different configuration states."
94509,"/** 
 * Performs cropping of input splits to the bounds specified in the ifContext. This logic is common to all pyramid input formats, regardless of the data provider, so there should be no need to override it in sub-classes.
 * @param ifContext
 * @param splits
 * @param zoomLevel
 * @param tileSize
 * @return
 */
List<TiledInputSplit> filterInputSplits(final TiledInputFormatContext ifContext,final List<TiledInputSplit> splits,final int zoomLevel,final int tileSize){
  if (splits.size() == 0 || ifContext.getBounds() == null) {
    return splits;
  }
  List<TiledInputSplit> result=new ArrayList<TiledInputSplit>();
  TMSUtils.TileBounds cropBounds=TMSUtils.boundsToTile(TMSUtils.Bounds.asTMSBounds(ifContext.getBounds()),ifContext.getZoomLevel(),tileSize);
  Collections.sort(splits,new Comparator<TiledInputSplit>(){
    @Override public int compare(    TiledInputSplit t1,    TiledInputSplit t2){
      if (t1.getStartTileId() < t2.getStartTileId())       return -1;
      return t1.getStartTileId() == t2.getStartTileId() ? 0 : 1;
    }
  }
);
  SplitIterator splitIter=new SplitIterator(splits,new RegionSplitVisitor(cropBounds));
  TiledInputSplit firstSplit=null;
  TiledInputSplit secondSplit=splitIter.next();
  long fromTileId=TMSUtils.tileid(cropBounds.w,cropBounds.s,ifContext.getZoomLevel());
  while (secondSplit != null) {
    long toTileId=secondSplit.getStartTileId() - 1;
    fillHoles(result,fromTileId,toTileId,ifContext.getZoomLevel(),ifContext.getTileSize(),cropBounds);
    result.add(secondSplit);
    firstSplit=secondSplit;
    secondSplit=splitIter.next();
    fromTileId=firstSplit.getEndTileId() + 1;
  }
  if (ifContext.getIncludeEmptyTiles()) {
    fillHoles(result,fromTileId,TMSUtils.tileid(cropBounds.e,cropBounds.n,zoomLevel),zoomLevel,tileSize,cropBounds);
  }
  return result;
}","/** 
 * Performs cropping of input splits to the bounds specified in the ifContext. This logic is common to all pyramid input formats, regardless of the data provider, so there should be no need to override it in sub-classes.
 * @param ifContext
 * @param splits
 * @param zoomLevel
 * @param tileSize
 * @return
 */
List<TiledInputSplit> filterInputSplits(final TiledInputFormatContext ifContext,final List<TiledInputSplit> splits,final int zoomLevel,final int tileSize){
  if (splits.size() == 0 || ifContext.getBounds() == null) {
    return splits;
  }
  List<TiledInputSplit> result=new ArrayList<TiledInputSplit>();
  TMSUtils.TileBounds cropBounds=TMSUtils.boundsToTile(TMSUtils.Bounds.asTMSBounds(ifContext.getBounds()),ifContext.getZoomLevel(),tileSize);
  Collections.sort(splits,new Comparator<TiledInputSplit>(){
    @Override public int compare(    TiledInputSplit t1,    TiledInputSplit t2){
      if (t1.getStartTileId() < t2.getStartTileId())       return -1;
      return t1.getStartTileId() == t2.getStartTileId() ? 0 : 1;
    }
  }
);
  SplitIterator splitIter=new SplitIterator(splits,new RegionSplitVisitor(cropBounds));
  TiledInputSplit firstSplit=null;
  TiledInputSplit secondSplit=splitIter.next();
  long fromTileId=TMSUtils.tileid(cropBounds.w,cropBounds.s,ifContext.getZoomLevel());
  while (secondSplit != null) {
    long toTileId=secondSplit.getStartTileId() - 1;
    if (ifContext.getIncludeEmptyTiles()) {
      fillHoles(result,fromTileId,toTileId,ifContext.getZoomLevel(),ifContext.getTileSize(),cropBounds);
    }
    result.add(secondSplit);
    firstSplit=secondSplit;
    secondSplit=splitIter.next();
    fromTileId=firstSplit.getEndTileId() + 1;
  }
  if (ifContext.getIncludeEmptyTiles()) {
    fillHoles(result,fromTileId,TMSUtils.tileid(cropBounds.e,cropBounds.n,zoomLevel),zoomLevel,tileSize,cropBounds);
  }
  return result;
}","The original code always called `fillHoles()` even when empty tiles were not requested, potentially introducing unnecessary processing. In the fixed code, `fillHoles()` is conditionally executed only when `getIncludeEmptyTiles()` returns true, inside the main processing loop and at the end. This change ensures that empty tile handling occurs only when explicitly desired, reducing computational overhead and maintaining the intended behavior of the input split filtering method."
94510,"/** 
 * Returns the list of MrsPyramidInputSplit objects required across all of the input pyramids. Sub-classes should have no need to override this method. It contains logic required by all input formats (described in the overview for this class).
 */
@Override public List<InputSplit> getSplits(JobContext context) throws IOException, InterruptedException {
  TiledInputFormatContext ifContext=TiledInputFormatContext.load(context.getConfiguration());
  Set<String> inputSet=ifContext.getInputs();
  MrsPyramid[] pyramids=new MrsPyramid[inputSet.size()];
  int inputIndex=0;
  for (  String strInput : inputSet) {
    String pyramid=strInput;
    MrsPyramid p=MrsImagePyramid.open(pyramid,context.getConfiguration());
    pyramids[inputIndex]=p;
    inputIndex++;
  }
  Arrays.sort(pyramids,new Comparator<MrsPyramid>(){
    @Override public int compare(    MrsPyramid p1,    MrsPyramid p2){
      Bounds b=p1.getBounds();
      double a1=b.getWidth() * b.getHeight();
      b=p2.getBounds();
      double a2=b.getWidth() * b.getHeight();
      int result=Double.compare(a2,a1);
      if (result == 0) {
        int v1=p1.getMaximumLevel();
        int v2=p2.getMaximumLevel();
        if (v1 == v2) {
          return 0;
        }
        return (v1 < v2) ? 1 : -1;
      }
      return result;
    }
  }
);
  List<List<TiledInputSplit>> nativeSplitsPerInput=new LinkedList<List<TiledInputSplit>>();
  Map<String,Bounds> post=new HashMap<String,Bounds>();
  int[] zooms=new int[pyramids.length];
  for (int i=0; i < pyramids.length; i++) {
    String pyramid=pyramids[i].getName();
    zooms[i]=ifContext.getZoomLevel();
    List<TiledInputSplit> splits=getNativeSplits(context,ifContext,pyramid);
    nativeSplitsPerInput.add(filterInputSplits(ifContext,splits,zooms[i],pyramids[i].getTileSize()));
    post.put(pyramid,pyramids[i].getBounds());
  }
  List<InputSplit> splits=new LinkedList<InputSplit>();
  Map<String,Bounds> pre=new HashMap<String,Bounds>();
  for (int i=0; i < pyramids.length; i++) {
    MrsPyramid pyramid=pyramids[i];
    Bounds b=post.remove(pyramid.getName());
    List<TiledInputSplit> ns=nativeSplitsPerInput.get(i);
    if (ns != null) {
      Iterator<TiledInputSplit> iter=ns.iterator();
      while (iter.hasNext()) {
        TiledInputSplit tiledSplit=iter.next();
        MrsPyramidInputSplit mpsplit=new MrsPyramidInputSplit(tiledSplit,pyramid.getName(),zooms[i],pre.values().toArray(new Bounds[0]),post.values().toArray(new Bounds[0]));
        splits.add(mpsplit);
      }
    }
    pre.put(pyramid.getName(),b);
  }
  return splits;
}","/** 
 * Returns the list of MrsPyramidInputSplit objects required across all of the input pyramids. Sub-classes should have no need to override this method. It contains logic required by all input formats (described in the overview for this class).
 */
@Override public List<InputSplit> getSplits(JobContext context) throws IOException, InterruptedException {
  TiledInputFormatContext ifContext=TiledInputFormatContext.load(context.getConfiguration());
  Set<String> inputSet=ifContext.getInputs();
  MrsPyramid[] pyramids=new MrsPyramid[inputSet.size()];
  int inputIndex=0;
  for (  String strInput : inputSet) {
    String pyramid=strInput;
    MrsPyramid p=MrsImagePyramid.open(pyramid,context.getConfiguration());
    pyramids[inputIndex]=p;
    inputIndex++;
  }
  Arrays.sort(pyramids,new Comparator<MrsPyramid>(){
    @Override public int compare(    MrsPyramid p1,    MrsPyramid p2){
      Bounds b=p1.getBounds();
      double a1=b.getWidth() * b.getHeight();
      b=p2.getBounds();
      double a2=b.getWidth() * b.getHeight();
      int result=Double.compare(a2,a1);
      if (result == 0) {
        int v1=p1.getMaximumLevel();
        int v2=p2.getMaximumLevel();
        if (v1 == v2) {
          return 0;
        }
        return (v1 < v2) ? 1 : -1;
      }
      return result;
    }
  }
);
  List<List<TiledInputSplit>> nativeSplitsPerInput=new LinkedList<List<TiledInputSplit>>();
  Map<String,Bounds> post=new HashMap<String,Bounds>();
  int[] zooms=new int[pyramids.length];
  for (int i=0; i < pyramids.length; i++) {
    String pyramid=pyramids[i].getName();
    zooms[i]=ifContext.getZoomLevel();
    List<TiledInputSplit> splits=getNativeSplits(context,ifContext,pyramid);
    log.info(""String_Node_Str"" + splits.size());
    List<TiledInputSplit> filteredSplits=filterInputSplits(ifContext,splits,zooms[i],pyramids[i].getTileSize());
    log.info(""String_Node_Str"" + filteredSplits.size());
    nativeSplitsPerInput.add(filteredSplits);
    post.put(pyramid,pyramids[i].getBounds());
  }
  List<InputSplit> splits=new LinkedList<InputSplit>();
  Map<String,Bounds> pre=new HashMap<String,Bounds>();
  for (int i=0; i < pyramids.length; i++) {
    MrsPyramid pyramid=pyramids[i];
    Bounds b=post.remove(pyramid.getName());
    List<TiledInputSplit> ns=nativeSplitsPerInput.get(i);
    if (ns != null) {
      Iterator<TiledInputSplit> iter=ns.iterator();
      while (iter.hasNext()) {
        TiledInputSplit tiledSplit=iter.next();
        MrsPyramidInputSplit mpsplit=new MrsPyramidInputSplit(tiledSplit,pyramid.getName(),zooms[i],pre.values().toArray(new Bounds[0]),post.values().toArray(new Bounds[0]));
        splits.add(mpsplit);
      }
    }
    pre.put(pyramid.getName(),b);
  }
  return splits;
}","The original code directly added unfiltered splits to the `nativeSplitsPerInput` list without logging or verifying their size. The fixed code introduces logging statements (`log.info()`) to track the number of splits before and after filtering, and explicitly stores the filtered splits in a separate variable before adding to the list. These changes provide better visibility into the split generation process and ensure that only filtered, appropriate input splits are processed, improving debugging and data handling reliability."
94511,"/** 
 * Performs cropping of input splits to the bounds specified in the ifContext. This logic is common to all pyramid input formats, regardless of the data provider, so there should be no need to override it in sub-classes.
 * @param ifContext
 * @param splits
 * @param zoomLevel
 * @param tileSize
 * @return
 */
List<TiledInputSplit> filterInputSplits(final TiledInputFormatContext ifContext,final List<TiledInputSplit> splits,final int zoomLevel,final int tileSize){
  if (splits.size() == 0 || ifContext.getBounds() == null) {
    return splits;
  }
  List<TiledInputSplit> result=new ArrayList<TiledInputSplit>();
  TMSUtils.TileBounds cropBounds=TMSUtils.boundsToTile(TMSUtils.Bounds.asTMSBounds(ifContext.getBounds()),ifContext.getZoomLevel(),tileSize);
  Collections.sort(splits,new Comparator<TiledInputSplit>(){
    @Override public int compare(    TiledInputSplit t1,    TiledInputSplit t2){
      if (t1.getStartTileId() < t2.getStartTileId())       return -1;
      return t1.getStartTileId() == t2.getStartTileId() ? 0 : 1;
    }
  }
);
  SplitIterator splitIter=new SplitIterator(splits,new RegionSplitVisitor(cropBounds));
  TiledInputSplit firstSplit=null;
  TiledInputSplit secondSplit=splitIter.next();
  long fromTileId=TMSUtils.tileid(cropBounds.w,cropBounds.s,ifContext.getZoomLevel());
  while (secondSplit != null) {
    long toTileId=secondSplit.getStartTileId() - 1;
    fillHoles(result,fromTileId,toTileId,ifContext.getZoomLevel(),ifContext.getTileSize(),cropBounds);
    result.add(secondSplit);
    firstSplit=secondSplit;
    secondSplit=splitIter.next();
    fromTileId=firstSplit.getEndTileId() + 1;
  }
  if (ifContext.getIncludeEmptyTiles()) {
    fillHoles(result,fromTileId,TMSUtils.tileid(cropBounds.e,cropBounds.n,zoomLevel),zoomLevel,tileSize,cropBounds);
  }
  return result;
}","/** 
 * Performs cropping of input splits to the bounds specified in the ifContext. This logic is common to all pyramid input formats, regardless of the data provider, so there should be no need to override it in sub-classes.
 * @param ifContext
 * @param splits
 * @param zoomLevel
 * @param tileSize
 * @return
 */
List<TiledInputSplit> filterInputSplits(final TiledInputFormatContext ifContext,final List<TiledInputSplit> splits,final int zoomLevel,final int tileSize){
  if (splits.size() == 0 || ifContext.getBounds() == null) {
    return splits;
  }
  List<TiledInputSplit> result=new ArrayList<TiledInputSplit>();
  TMSUtils.TileBounds cropBounds=TMSUtils.boundsToTile(TMSUtils.Bounds.asTMSBounds(ifContext.getBounds()),ifContext.getZoomLevel(),tileSize);
  Collections.sort(splits,new Comparator<TiledInputSplit>(){
    @Override public int compare(    TiledInputSplit t1,    TiledInputSplit t2){
      if (t1.getStartTileId() < t2.getStartTileId())       return -1;
      return t1.getStartTileId() == t2.getStartTileId() ? 0 : 1;
    }
  }
);
  SplitIterator splitIter=new SplitIterator(splits,new RegionSplitVisitor(cropBounds));
  TiledInputSplit firstSplit=null;
  TiledInputSplit secondSplit=splitIter.next();
  long fromTileId=TMSUtils.tileid(cropBounds.w,cropBounds.s,ifContext.getZoomLevel());
  while (secondSplit != null) {
    long toTileId=secondSplit.getStartTileId() - 1;
    if (ifContext.getIncludeEmptyTiles()) {
      fillHoles(result,fromTileId,toTileId,ifContext.getZoomLevel(),ifContext.getTileSize(),cropBounds);
    }
    result.add(secondSplit);
    firstSplit=secondSplit;
    secondSplit=splitIter.next();
    fromTileId=firstSplit.getEndTileId() + 1;
  }
  if (ifContext.getIncludeEmptyTiles()) {
    fillHoles(result,fromTileId,TMSUtils.tileid(cropBounds.e,cropBounds.n,zoomLevel),zoomLevel,tileSize,cropBounds);
  }
  return result;
}","The original code always called `fillHoles()` inside the main loop, which incorrectly added empty tiles for splits even when `includeEmptyTiles` was false. The fixed code moves the `fillHoles()` call inside a conditional check for `includeEmptyTiles`, ensuring empty tiles are only added when explicitly requested. This modification prevents unnecessary empty tile generation and provides more precise control over tile processing based on the input format context's configuration."
94512,"public RegionSplitVisitor(TMSUtils.TileBounds region){
  this.region=region;
}","public RegionSplitVisitor(TMSUtils.TileBounds region){
  this.region=region;
  log.debug(""String_Node_Str"" + region.toString());
}","The original code lacks logging, making debugging difficult when tracking region splitting operations. The fixed code adds a debug log statement that prints the region's string representation, providing visibility into the current region being processed. This enhancement enables developers to trace and diagnose issues more effectively during the region splitting workflow by capturing essential context at runtime."
94513,"@Override public boolean accept(TiledInputSplit split){
  int zoom=split.getZoomLevel();
  return splitOverlapsTileBounds(TMSUtils.tileid(split.getStartTileId(),zoom),TMSUtils.tileid(split.getEndTileId(),zoom),region);
}","@Override public boolean accept(TiledInputSplit split){
  int zoom=split.getZoomLevel();
  TMSUtils.Tile startTile=TMSUtils.tileid(split.getStartTileId(),zoom);
  TMSUtils.Tile endTile=TMSUtils.tileid(split.getEndTileId(),zoom);
  boolean result=splitOverlapsTileBounds(TMSUtils.tileid(split.getStartTileId(),zoom),TMSUtils.tileid(split.getEndTileId(),zoom),region);
  if (!result) {
    log.info(""String_Node_Str"" + split.getStartTileId());
  }
  return result;
}","The original code directly passes tile IDs to splitOverlapsTileBounds without converting them to Tile objects, which may lead to incorrect tile boundary calculations. The fixed code introduces explicit conversion of start and end tile IDs to Tile objects using TMSUtils.tileid(), ensuring accurate tile representation, and adds a logging statement for debugging purposes. By creating precise Tile objects and including diagnostic logging, the code now provides more robust and traceable tile split validation."
94514,"private static LongRange getSplitBounds(FileSplit split,TileBounds partFileTileBounds,int zoomLevel,FileSystem fs,Configuration conf) throws IOException {
  long startOffset=split.getStart();
  long endOffset=startOffset + split.getLength();
  Path indexPath=new Path(split.getPath().getParent(),""String_Node_Str"");
  SequenceFile.Reader reader=new SequenceFile.Reader(fs,indexPath,conf);
  try {
    TileIdWritable tileId;
    try {
      tileId=(TileIdWritable)reader.getKeyClass().newInstance();
    }
 catch (    InstantiationException e) {
      throw new IOException(e);
    }
catch (    IllegalAccessException e) {
      throw new IOException(e);
    }
    LongWritable tileOffset=new LongWritable();
    long startTileId=-1, endTileId=-1;
    while (reader.next(tileId,tileOffset)) {
      if (tileOffset.get() >= startOffset) {
        startTileId=tileId.get();
        break;
      }
    }
    assert(startTileId != -1);
    while (reader.next(tileId,tileOffset) && tileOffset.get() < endOffset) {
      endTileId=tileId.get();
    }
    return new LongRange(startTileId,endTileId);
  }
  finally {
    reader.close();
  }
}","private static LongRange getSplitBounds(FileSplit split,TileBounds partFileTileBounds,int zoomLevel,FileSystem fs,Configuration conf) throws IOException {
  long startOffset=split.getStart();
  long endOffset=startOffset + split.getLength();
  Path indexPath=new Path(split.getPath().getParent(),""String_Node_Str"");
  SequenceFile.Reader reader=new SequenceFile.Reader(fs,indexPath,conf);
  try {
    TileIdWritable tileId;
    try {
      tileId=(TileIdWritable)reader.getKeyClass().newInstance();
    }
 catch (    InstantiationException e) {
      throw new IOException(e);
    }
catch (    IllegalAccessException e) {
      throw new IOException(e);
    }
    LongWritable tileOffset=new LongWritable();
    long startTileId=-1;
    while (reader.next(tileId,tileOffset)) {
      if (tileOffset.get() >= startOffset) {
        startTileId=tileId.get();
        break;
      }
    }
    assert(startTileId != -1);
    long endTileId=startTileId;
    while (reader.next(tileId,tileOffset) && tileOffset.get() < endOffset) {
      endTileId=tileId.get();
    }
    return new LongRange(startTileId,endTileId);
  }
  finally {
    reader.close();
  }
}","The original code didn't initialize `endTileId` before its second loop, potentially leaving it unset if no subsequent tiles were found. In the fixed code, `endTileId` is initially set to `startTileId`, ensuring a valid default value, and then updated within the loop if additional tiles exist. This modification guarantees that a valid `LongRange` is always returned, preventing potential null or undefined behavior in subsequent processing."
94515,"@Override public List<InputSplit> getSplits(JobContext context) throws IOException {
  Configuration conf=context.getConfiguration();
  SplitFile sf=new SplitFile(conf);
  TiledInputFormatContext ifContext=TiledInputFormatContext.load(conf);
  HdfsMrsImageDataProvider dp=new HdfsMrsImageDataProvider(context.getConfiguration(),input,null);
  Path inputWithZoom=new Path(dp.getResourcePath(true),""String_Node_Str"" + ifContext.getZoomLevel());
  Path splitPath=new Path(inputWithZoom,SplitFile.SPLIT_FILE);
  FileSystem fs=splitPath.getFileSystem(conf);
  if (!fs.exists(splitPath)) {
    splitPath=new Path(inputWithZoom,SplitFile.OLD_SPLIT_FILE);
  }
  List<Long> splitFileSplits=sf.readSplits(fs.makeQualified(splitPath).toString());
  MrsImagePyramidMetadataReader metadataReader=dp.getMetadataReader();
  MrsImagePyramidMetadata metadata=metadataReader.read();
  LongRectangle tileBounds=metadata.getTileBounds(ifContext.getZoomLevel());
  List<InputSplit> actualSplits=super.getSplits(context);
  List<InputSplit> result=new ArrayList<InputSplit>(actualSplits.size());
  for (  InputSplit actualSplit : actualSplits) {
    if (!(actualSplit instanceof FileSplit)) {
      throw new IOException(""String_Node_Str"" + actualSplit.getClass().getCanonicalName());
    }
    FileSplit fileSplit=(FileSplit)actualSplit;
    String partFile=fileSplit.getPath().getParent().getName();
    if (!partFile.startsWith(""String_Node_Str"")) {
      throw new IOException(""String_Node_Str"" + partFile);
    }
    String indexStr=partFile.substring(partFile.lastIndexOf('-') + 1,partFile.length());
    int index=Integer.valueOf(indexStr);
    if (index < 0 || index > splitFileSplits.size()) {
      throw new IOException(""String_Node_Str"" + index + ""String_Node_Str""+ partFile+ ""String_Node_Str""+ (splitFileSplits.size() - 1));
    }
    long endTileId=-1;
    if (index < splitFileSplits.size()) {
      endTileId=splitFileSplits.get(index);
    }
 else {
      endTileId=TMSUtils.tileid(tileBounds.getMaxX(),tileBounds.getMaxY(),ifContext.getZoomLevel());
    }
    TMSUtils.Tile endTile=TMSUtils.tileid(endTileId,ifContext.getZoomLevel());
    Path indexPath=new Path(fileSplit.getPath().getParent(),""String_Node_Str"");
    SequenceFile.Reader reader=new SequenceFile.Reader(fs,indexPath,conf);
    TileIdWritable key;
    try {
      key=(TileIdWritable)reader.getKeyClass().newInstance();
      reader.next(key);
    }
 catch (    InstantiationException e) {
      throw new IOException(e);
    }
catch (    IllegalAccessException e) {
      throw new IOException(e);
    }
 finally {
      if (reader != null) {
        reader.close();
      }
    }
    long startTileId=key.get();
    TMSUtils.Tile startTile=TMSUtils.tileid(startTileId,ifContext.getZoomLevel());
    TileBounds partFileTileBounds=new TileBounds(startTile.tx,startTile.ty,endTile.tx,endTile.ty);
    Bounds partFileBounds=TMSUtils.tileToBounds(partFileTileBounds,ifContext.getZoomLevel(),metadata.getTilesize());
    org.mrgeo.utils.Bounds requestedBounds=ifContext.getBounds();
    if (requestedBounds != null) {
      Bounds userBounds=TMSUtils.Bounds.convertOldToNewBounds(requestedBounds);
      if (userBounds.intersect(partFileBounds,false)) {
        LongRange splitTileIdRange=getSplitBounds(fileSplit,partFileTileBounds,ifContext.getZoomLevel(),fs,conf);
        TileBounds userTileBounds=TMSUtils.boundsToTile(userBounds,ifContext.getZoomLevel(),metadata.getTilesize());
        TMSUtils.Tile partStartTile=TMSUtils.tileid(splitTileIdRange.getMinimumLong(),ifContext.getZoomLevel());
        TMSUtils.Tile partEndTile=TMSUtils.tileid(splitTileIdRange.getMaximumLong(),ifContext.getZoomLevel());
        TileBounds splitTileBounds=new TileBounds(partStartTile.tx,partStartTile.ty,partEndTile.tx,partEndTile.ty);
        Bounds splitBounds=TMSUtils.tileToBounds(splitTileBounds,ifContext.getZoomLevel(),metadata.getTilesize());
        if (userBounds.intersect(splitBounds,false)) {
          LOG.info(String.format(""String_Node_Str"",fileSplit,splitBounds,splitTileIdRange,userBounds,userTileBounds));
          result.add(new TiledInputSplit(actualSplit,splitTileIdRange.getMinimumLong(),splitTileIdRange.getMaximumLong(),ifContext.getZoomLevel(),metadata.getTilesize()));
        }
 else {
        }
      }
 else {
      }
    }
 else {
      result.add(new TiledInputSplit(actualSplit,startTileId,endTileId,ifContext.getZoomLevel(),metadata.getTilesize()));
    }
  }
  return result;
}","@Override public List<InputSplit> getSplits(JobContext context) throws IOException {
  Configuration conf=context.getConfiguration();
  SplitFile sf=new SplitFile(conf);
  TiledInputFormatContext ifContext=TiledInputFormatContext.load(conf);
  HdfsMrsImageDataProvider dp=new HdfsMrsImageDataProvider(context.getConfiguration(),input,null);
  Path inputWithZoom=new Path(dp.getResourcePath(true),""String_Node_Str"" + ifContext.getZoomLevel());
  Path splitPath=new Path(inputWithZoom,SplitFile.SPLIT_FILE);
  FileSystem fs=splitPath.getFileSystem(conf);
  if (!fs.exists(splitPath)) {
    splitPath=new Path(inputWithZoom,SplitFile.OLD_SPLIT_FILE);
  }
  List<Long> splitFileSplits=sf.readSplits(fs.makeQualified(splitPath).toString());
  MrsImagePyramidMetadataReader metadataReader=dp.getMetadataReader();
  MrsImagePyramidMetadata metadata=metadataReader.read();
  LongRectangle tileBounds=metadata.getTileBounds(ifContext.getZoomLevel());
  List<InputSplit> actualSplits=super.getSplits(context);
  List<InputSplit> result=new ArrayList<InputSplit>(actualSplits.size());
  for (  InputSplit actualSplit : actualSplits) {
    if (!(actualSplit instanceof FileSplit)) {
      throw new IOException(""String_Node_Str"" + actualSplit.getClass().getCanonicalName());
    }
    FileSplit fileSplit=(FileSplit)actualSplit;
    String partFile=fileSplit.getPath().getParent().getName();
    if (!partFile.startsWith(""String_Node_Str"")) {
      throw new IOException(""String_Node_Str"" + partFile);
    }
    String indexStr=partFile.substring(partFile.lastIndexOf('-') + 1,partFile.length());
    int index=Integer.valueOf(indexStr);
    if (index < 0 || index > splitFileSplits.size()) {
      throw new IOException(""String_Node_Str"" + index + ""String_Node_Str""+ partFile+ ""String_Node_Str""+ (splitFileSplits.size() - 1));
    }
    long endTileId=-1;
    if (index < splitFileSplits.size()) {
      endTileId=splitFileSplits.get(index);
    }
 else {
      endTileId=TMSUtils.tileid(tileBounds.getMaxX(),tileBounds.getMaxY(),ifContext.getZoomLevel());
    }
    TMSUtils.Tile endTile=TMSUtils.tileid(endTileId,ifContext.getZoomLevel());
    Path indexPath=new Path(fileSplit.getPath().getParent(),""String_Node_Str"");
    SequenceFile.Reader reader=new SequenceFile.Reader(fs,indexPath,conf);
    TileIdWritable key;
    try {
      key=(TileIdWritable)reader.getKeyClass().newInstance();
      reader.next(key);
    }
 catch (    InstantiationException e) {
      throw new IOException(e);
    }
catch (    IllegalAccessException e) {
      throw new IOException(e);
    }
 finally {
      if (reader != null) {
        reader.close();
      }
    }
    long startTileId=key.get();
    TMSUtils.Tile startTile=TMSUtils.tileid(startTileId,ifContext.getZoomLevel());
    TileBounds partFileTileBounds=new TileBounds(startTile.tx,startTile.ty,endTile.tx,endTile.ty);
    Bounds partFileBounds=TMSUtils.tileToBounds(partFileTileBounds,ifContext.getZoomLevel(),metadata.getTilesize());
    org.mrgeo.utils.Bounds requestedBounds=ifContext.getBounds();
    if (requestedBounds != null) {
      Bounds userBounds=TMSUtils.Bounds.convertOldToNewBounds(requestedBounds);
      if (userBounds.intersect(partFileBounds,false)) {
        LongRange splitTileIdRange=getSplitBounds(fileSplit,partFileTileBounds,ifContext.getZoomLevel(),fs,conf);
        if (tileRangeIntersects(splitTileIdRange,ifContext.getZoomLevel(),ifContext.getTileSize(),tileBounds.getMinX(),tileBounds.getMaxX(),userBounds)) {
          result.add(new TiledInputSplit(actualSplit,splitTileIdRange.getMinimumLong(),splitTileIdRange.getMaximumLong(),ifContext.getZoomLevel(),metadata.getTilesize()));
        }
 else {
        }
      }
 else {
      }
    }
 else {
      result.add(new TiledInputSplit(actualSplit,startTileId,endTileId,ifContext.getZoomLevel(),metadata.getTilesize()));
    }
  }
  return result;
}","The original code lacked proper tile range intersection validation, potentially processing irrelevant tile splits. The fixed code introduces a new `tileRangeIntersects()` method to precisely check if the split tile range intersects with user-specified bounds, ensuring only relevant tiles are processed. This targeted validation improves computational efficiency and prevents unnecessary data processing by filtering out tile splits that do not match the requested geographic region."
94516,"public Raster getTile(final long tx,final long ty) throws TileNotFoundException {
  if (tx < getMinTileX() || tx > getMaxTileX() || ty < getMinTileY() || ty > getMaxTileY()) {
    final String msg=String.format(""String_Node_Str"",tx,ty,getMaxTileX(),getMinTileY(),getMaxTileX(),getMaxTileY());
    throw new TileNotFoundException(msg);
  }
  if (reader == null) {
    openReader();
  }
  return reader.get(new TileIdWritable(TMSUtils.tileid(tx,ty,getZoomlevel())));
}","public Raster getTile(final long tx,final long ty) throws TileNotFoundException {
  if (tx < getMinTileX() || tx > getMaxTileX() || ty < getMinTileY() || ty > getMaxTileY()) {
    final String msg=String.format(""String_Node_Str"",tx,ty,getMinTileX(),getMinTileY(),getMaxTileX(),getMaxTileY());
    throw new TileNotFoundException(msg);
  }
  if (reader == null) {
    openReader();
  }
  return reader.get(new TileIdWritable(TMSUtils.tileid(tx,ty,getZoomlevel())));
}","The original code had incorrect parameters in the String.format() method, potentially causing misleading error messages when a tile is out of bounds. The fixed code corrects the formatting parameters to accurately represent the tile's minimum and maximum X and Y coordinates. This ensures precise error reporting and helps developers quickly identify the exact boundaries of the tile grid when a TileNotFoundException is thrown."
94517,"public void run(final Path input,final String output,final RasterizeVectorPainter.AggregationType aggregationType,final int zoom,final Bounds bounds,final Progress progress,final JobListener jobListener,final String protectionLevel,final Properties providerProperties) throws IOException, JobFailedException, JobCancelledException {
  final Job job=new Job(HadoopUtils.createConfiguration());
  if (inputFormat == null) {
    inputFormat=AutoFeatureInputFormat.class;
  }
  job.setInputFormatClass(inputFormat);
  FileInputFormat.addInputPath(job,input);
  run(job,output,aggregationType,zoom,bounds,progress,jobListener,protectionLevel,providerProperties);
}","public void run(final Configuration conf,final Path input,final String output,final RasterizeVectorPainter.AggregationType aggregationType,final int zoom,final Bounds bounds,final Progress progress,final JobListener jobListener,final String protectionLevel,final Properties providerProperties) throws IOException, JobFailedException, JobCancelledException {
  final Job job=new Job(conf);
  if (inputFormat == null) {
    inputFormat=AutoFeatureInputFormat.class;
  }
  job.setInputFormatClass(inputFormat);
  FileInputFormat.addInputPath(job,input);
  run(job,output,aggregationType,zoom,bounds,progress,jobListener,protectionLevel,providerProperties);
}","The original code lacked a Configuration parameter, forcing HadoopUtils.createConfiguration() to be used implicitly, which could lead to inflexible job configuration. The fixed code introduces an explicit Configuration parameter, allowing more control and flexibility in job setup by accepting a pre-configured Configuration object. This modification enables better customization of Hadoop job settings and improves the method's reusability and testability."
94518,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  MapOp mo=_inputs.get(0);
  String inputPath=null;
  if (mo instanceof VectorReaderMapOp) {
    VectorReaderMapOp vmo=(VectorReaderMapOp)mo;
    inputPath=vmo.getOutputName();
  }
  PgQueryDriver pgd=new PgQueryDriver();
  pgd.setUsername(_username);
  pgd.setPassword(_password);
  pgd.setDbConnection(_dbconnection);
  pgd.run(new Path(inputPath),new Path(_outputName),p,jobListener);
  _output=new BasicInputFormatDescriptor(_outputName);
  if (p != null) {
    p.complete();
  }
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  MapOp mo=_inputs.get(0);
  String inputPath=null;
  if (mo instanceof VectorReaderMapOp) {
    VectorReaderMapOp vmo=(VectorReaderMapOp)mo;
    inputPath=vmo.getOutputName();
  }
  PgQueryDriver pgd=new PgQueryDriver();
  pgd.setUsername(_username);
  pgd.setPassword(_password);
  pgd.setDbConnection(_dbconnection);
  pgd.run(createConfiguration(),new Path(inputPath),new Path(_outputName),p,jobListener);
  _output=new BasicInputFormatDescriptor(_outputName);
  if (p != null) {
    p.complete();
  }
}","The original code omits the configuration parameter when calling `pgd.run()`, which likely breaks the method's intended functionality. The fixed code adds `createConfiguration()` as the first argument to `pgd.run()`, ensuring a complete method signature and proper configuration passing. This modification provides the necessary configuration context, making the method more robust and potentially resolving potential runtime configuration-related errors."
94519,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  ph.createChild(1.0f);
  ph.createChild(1.0f);
  RandomizeVectorDriver rvd=new RandomizeVectorDriver();
  MapOp inputMapOp=_inputs.get(0);
  String inputPath=null;
  if (inputMapOp instanceof VectorMapOp) {
    inputPath=((VectorMapOp)inputMapOp).getOutputName();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  rvd.run(new Path(inputPath),new Path(_outputName),p,jobListener);
  _output=new BasicInputFormatDescriptor(_outputName);
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  ph.createChild(1.0f);
  ph.createChild(1.0f);
  RandomizeVectorDriver rvd=new RandomizeVectorDriver();
  MapOp inputMapOp=_inputs.get(0);
  String inputPath=null;
  if (inputMapOp instanceof VectorMapOp) {
    inputPath=((VectorMapOp)inputMapOp).getOutputName();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  rvd.run(createConfiguration(),new Path(inputPath),new Path(_outputName),p,jobListener);
  _output=new BasicInputFormatDescriptor(_outputName);
}","The buggy code lacks a configuration parameter when calling `rvd.run()`, which may cause runtime errors or incomplete job execution. The fixed code introduces `createConfiguration()` as an additional argument, ensuring proper job configuration and initialization. This modification enhances the method's robustness by providing the necessary configuration context for the RandomizeVectorDriver to execute successfully."
94520,"public void run(Path sqlPath,Path outputPath,Progress progress,JobListener jobListener) throws IOException, JobFailedException, JobCancelledException {
  Job job=new Job(HadoopUtils.createConfiguration());
  job.setJobName(String.format(""String_Node_Str"",sqlPath.toString()));
  HadoopUtils.setJar(job,this.getClass());
  Path tmp=HadoopFileUtils.createJobTmp();
  FileSystem fs=HadoopFileUtils.getFileSystem(tmp);
  if (fs.exists(tmp) == false) {
    fs.mkdirs(tmp);
  }
  try {
    HadoopVectorUtils.setupPgQueryInputFormat(job,_username,_password,_dbconnection);
    job.setInputFormatClass(PgQueryInputFormat.class);
    job.setMapperClass(FeatureFilterMapper.class);
    job.setMapOutputKeyClass(LongWritable.class);
    job.setMapOutputValueClass(GeometryWritable.class);
    FileInputFormat.setInputPaths(job,sqlPath);
    job.setNumReduceTasks(0);
    job.setReducerClass(GeometryWritableToGeometryReducer.class);
    job.setOutputFormatClass(CsvOutputFormat.class);
    FileOutputFormat.setOutputPath(job,outputPath);
    MapReduceUtils.runJob(job,progress,jobListener);
  }
  finally {
    fs.delete(tmp,true);
  }
}","public void run(Configuration conf,Path sqlPath,Path outputPath,Progress progress,JobListener jobListener) throws IOException, JobFailedException, JobCancelledException {
  Job job=new Job(conf);
  job.setJobName(String.format(""String_Node_Str"",sqlPath.toString()));
  HadoopUtils.setJar(job,this.getClass());
  Path tmp=HadoopFileUtils.createJobTmp();
  FileSystem fs=HadoopFileUtils.getFileSystem(tmp);
  if (fs.exists(tmp) == false) {
    fs.mkdirs(tmp);
  }
  try {
    HadoopVectorUtils.setupPgQueryInputFormat(job,_username,_password,_dbconnection);
    job.setInputFormatClass(PgQueryInputFormat.class);
    job.setMapperClass(FeatureFilterMapper.class);
    job.setMapOutputKeyClass(LongWritable.class);
    job.setMapOutputValueClass(GeometryWritable.class);
    FileInputFormat.setInputPaths(job,sqlPath);
    job.setNumReduceTasks(0);
    job.setReducerClass(GeometryWritableToGeometryReducer.class);
    job.setOutputFormatClass(CsvOutputFormat.class);
    FileOutputFormat.setOutputPath(job,outputPath);
    MapReduceUtils.runJob(job,progress,jobListener);
  }
  finally {
    fs.delete(tmp,true);
  }
}","The original code created a Job configuration using HadoopUtils.createConfiguration(), which lacks flexibility and potentially misses custom configuration settings. The fixed code introduces a Configuration parameter, allowing more precise and adaptable job configuration by passing a pre-configured conf object from the caller. This modification enhances the method's flexibility, enabling better control over Hadoop job parameters and supporting more dynamic job setup scenarios."
94521,"public void run(final Path input,final Path output,final Progress progress,final JobListener jobListener) throws IOException, JobFailedException, JobCancelledException {
  final Job job=new Job(HadoopUtils.createConfiguration());
  if (inputFormat == null) {
    inputFormat=AutoFeatureInputFormat.class;
  }
  job.setInputFormatClass(inputFormat);
  FileInputFormat.addInputPath(job,input);
  run(job,output,progress,jobListener);
}","public void run(final Configuration conf,final Path input,final Path output,final Progress progress,final JobListener jobListener) throws IOException, JobFailedException, JobCancelledException {
  final Job job=new Job(conf);
  if (inputFormat == null) {
    inputFormat=AutoFeatureInputFormat.class;
  }
  job.setInputFormatClass(inputFormat);
  FileInputFormat.addInputPath(job,input);
  run(job,output,progress,jobListener);
}","The original code lacks a configuration parameter, which is crucial for creating a Hadoop job with specific settings. The fixed code adds a Configuration parameter (conf) that allows custom Hadoop configuration to be passed when creating the job, providing more flexibility and control. By explicitly passing the configuration, the code becomes more modular, configurable, and aligned with Hadoop's best practices for job creation."
94522,"@Override public void moveOutput(String toName) throws IOException {
  Path toPath=new Path(toName);
  Path sourcePath=new Path(_outputName);
  Configuration conf=HadoopUtils.createConfiguration();
  FileSystem sourceFs=HadoopFileUtils.getFileSystem(conf,sourcePath);
  FileSystem destFs=HadoopFileUtils.getFileSystem(conf,toPath);
  if (!FileUtil.copy(sourceFs,sourcePath,destFs,toPath,false,false,conf)) {
    throw new IOException(""String_Node_Str"" + _outputName + ""String_Node_Str""+ toName.toString()+ ""String_Node_Str"");
  }
  Path sourceColumns=new Path(_outputName + ""String_Node_Str"");
  if (sourceFs.exists(sourceColumns)) {
    Path toColumns=new Path(toName.toString() + ""String_Node_Str"");
    if (FileUtil.copy(sourceFs,sourceColumns,destFs,toColumns,false,false,conf) == false) {
      throw new IOException(""String_Node_Str"" + sourceColumns.toString() + ""String_Node_Str""+ toColumns.toString());
    }
  }
  _outputName=toName;
  _output=new BasicInputFormatDescriptor(_outputName);
}","@Override public void moveOutput(String toName) throws IOException {
  Path toPath=new Path(toName);
  Path sourcePath=new Path(_outputName);
  Configuration conf=createConfiguration();
  FileSystem sourceFs=HadoopFileUtils.getFileSystem(conf,sourcePath);
  FileSystem destFs=HadoopFileUtils.getFileSystem(conf,toPath);
  if (!FileUtil.copy(sourceFs,sourcePath,destFs,toPath,false,false,conf)) {
    throw new IOException(""String_Node_Str"" + _outputName + ""String_Node_Str""+ toName.toString()+ ""String_Node_Str"");
  }
  Path sourceColumns=new Path(_outputName + ""String_Node_Str"");
  if (sourceFs.exists(sourceColumns)) {
    Path toColumns=new Path(toName.toString() + ""String_Node_Str"");
    if (FileUtil.copy(sourceFs,sourceColumns,destFs,toColumns,false,false,conf) == false) {
      throw new IOException(""String_Node_Str"" + sourceColumns.toString() + ""String_Node_Str""+ toColumns.toString());
    }
  }
  _outputName=toName;
  _output=new BasicInputFormatDescriptor(_outputName);
}","The buggy code incorrectly used `HadoopUtils.createConfiguration()` instead of the local `createConfiguration()` method, potentially causing configuration resolution issues. The fixed code replaces the external method call with a local method, ensuring the correct configuration is used for Hadoop file operations. This change improves method consistency and prevents potential runtime configuration errors by using the appropriate configuration generation approach."
94523,"public void run(final Path input,final String output,final RasterizeVectorPainter.AggregationType aggregationType,final int zoom,final Bounds bounds,final Progress progress,final JobListener jobListener,final String protectionLevel,final Properties providerProperties) throws IOException, JobFailedException, JobCancelledException {
  final Job job=new Job(HadoopUtils.createConfiguration());
  if (inputFormat == null) {
    inputFormat=AutoFeatureInputFormat.class;
  }
  job.setInputFormatClass(inputFormat);
  FileInputFormat.addInputPath(job,input);
  run(job,output,aggregationType,zoom,bounds,progress,jobListener,protectionLevel,providerProperties);
}","public void run(final Configuration conf,final Path input,final String output,final RasterizeVectorPainter.AggregationType aggregationType,final int zoom,final Bounds bounds,final Progress progress,final JobListener jobListener,final String protectionLevel,final Properties providerProperties) throws IOException, JobFailedException, JobCancelledException {
  final Job job=new Job(conf);
  if (inputFormat == null) {
    inputFormat=AutoFeatureInputFormat.class;
  }
  job.setInputFormatClass(inputFormat);
  FileInputFormat.addInputPath(job,input);
  run(job,output,aggregationType,zoom,bounds,progress,jobListener,protectionLevel,providerProperties);
}","The original code lacks a Configuration parameter, forcing it to create a default Hadoop configuration internally without external configuration control. The fixed code adds a Configuration parameter `conf` to the method signature, allowing users to pass a pre-configured or custom Hadoop configuration when creating the Job. This modification provides more flexibility and control over job settings, enabling better customization and configuration management in distributed processing scenarios."
94524,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  MapOp mo=_inputs.get(0);
  String inputPath=null;
  if (mo instanceof VectorReaderMapOp) {
    VectorReaderMapOp vmo=(VectorReaderMapOp)mo;
    inputPath=vmo.getOutputName();
  }
  PgQueryDriver pgd=new PgQueryDriver();
  pgd.setUsername(_username);
  pgd.setPassword(_password);
  pgd.setDbConnection(_dbconnection);
  pgd.run(new Path(inputPath),new Path(_outputName),p,jobListener);
  _output=new BasicInputFormatDescriptor(_outputName);
  if (p != null) {
    p.complete();
  }
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  MapOp mo=_inputs.get(0);
  String inputPath=null;
  if (mo instanceof VectorReaderMapOp) {
    VectorReaderMapOp vmo=(VectorReaderMapOp)mo;
    inputPath=vmo.getOutputName();
  }
  PgQueryDriver pgd=new PgQueryDriver();
  pgd.setUsername(_username);
  pgd.setPassword(_password);
  pgd.setDbConnection(_dbconnection);
  pgd.run(createConfiguration(),new Path(inputPath),new Path(_outputName),p,jobListener);
  _output=new BasicInputFormatDescriptor(_outputName);
  if (p != null) {
    p.complete();
  }
}","The original code lacks a configuration parameter when calling the `run` method, which may lead to incomplete or incorrect execution of the PgQueryDriver. The fixed code adds a `createConfiguration()` method call as the first argument, providing necessary configuration settings for the database query driver. This improvement ensures proper configuration and potentially resolves potential runtime issues by explicitly passing configuration parameters during the database operation."
94525,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  ph.createChild(1.0f);
  ph.createChild(1.0f);
  RandomizeVectorDriver rvd=new RandomizeVectorDriver();
  MapOp inputMapOp=_inputs.get(0);
  String inputPath=null;
  if (inputMapOp instanceof VectorMapOp) {
    inputPath=((VectorMapOp)inputMapOp).getOutputName();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  rvd.run(new Path(inputPath),new Path(_outputName),p,jobListener);
  _output=new BasicInputFormatDescriptor(_outputName);
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  ph.createChild(1.0f);
  ph.createChild(1.0f);
  RandomizeVectorDriver rvd=new RandomizeVectorDriver();
  MapOp inputMapOp=_inputs.get(0);
  String inputPath=null;
  if (inputMapOp instanceof VectorMapOp) {
    inputPath=((VectorMapOp)inputMapOp).getOutputName();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  rvd.run(createConfiguration(),new Path(inputPath),new Path(_outputName),p,jobListener);
  _output=new BasicInputFormatDescriptor(_outputName);
}","The original code was missing a configuration parameter when calling the `run` method of `RandomizeVectorDriver`. The fixed code adds `createConfiguration()` as the first argument, ensuring the method receives the necessary configuration settings for executing the job. This modification provides the required context and parameters for the driver to run correctly, improving the robustness and reliability of the code execution."
94526,"public void run(Path sqlPath,Path outputPath,Progress progress,JobListener jobListener) throws IOException, JobFailedException, JobCancelledException {
  Job job=new Job(HadoopUtils.createConfiguration());
  job.setJobName(String.format(""String_Node_Str"",sqlPath.toString()));
  HadoopUtils.setJar(job,this.getClass());
  Path tmp=HadoopFileUtils.createJobTmp();
  FileSystem fs=HadoopFileUtils.getFileSystem(tmp);
  if (fs.exists(tmp) == false) {
    fs.mkdirs(tmp);
  }
  try {
    HadoopVectorUtils.setupPgQueryInputFormat(job,_username,_password,_dbconnection);
    job.setInputFormatClass(PgQueryInputFormat.class);
    job.setMapperClass(FeatureFilterMapper.class);
    job.setMapOutputKeyClass(LongWritable.class);
    job.setMapOutputValueClass(GeometryWritable.class);
    FileInputFormat.setInputPaths(job,sqlPath);
    job.setNumReduceTasks(0);
    job.setReducerClass(GeometryWritableToGeometryReducer.class);
    job.setOutputFormatClass(CsvOutputFormat.class);
    FileOutputFormat.setOutputPath(job,outputPath);
    MapReduceUtils.runJob(job,progress,jobListener);
  }
  finally {
    fs.delete(tmp,true);
  }
}","public void run(Configuration conf,Path sqlPath,Path outputPath,Progress progress,JobListener jobListener) throws IOException, JobFailedException, JobCancelledException {
  Job job=new Job(conf);
  job.setJobName(String.format(""String_Node_Str"",sqlPath.toString()));
  HadoopUtils.setJar(job,this.getClass());
  Path tmp=HadoopFileUtils.createJobTmp();
  FileSystem fs=HadoopFileUtils.getFileSystem(tmp);
  if (fs.exists(tmp) == false) {
    fs.mkdirs(tmp);
  }
  try {
    HadoopVectorUtils.setupPgQueryInputFormat(job,_username,_password,_dbconnection);
    job.setInputFormatClass(PgQueryInputFormat.class);
    job.setMapperClass(FeatureFilterMapper.class);
    job.setMapOutputKeyClass(LongWritable.class);
    job.setMapOutputValueClass(GeometryWritable.class);
    FileInputFormat.setInputPaths(job,sqlPath);
    job.setNumReduceTasks(0);
    job.setReducerClass(GeometryWritableToGeometryReducer.class);
    job.setOutputFormatClass(CsvOutputFormat.class);
    FileOutputFormat.setOutputPath(job,outputPath);
    MapReduceUtils.runJob(job,progress,jobListener);
  }
  finally {
    fs.delete(tmp,true);
  }
}","The original code created a Hadoop job configuration using HadoopUtils.createConfiguration() without allowing external configuration flexibility. The fixed code introduces a Configuration parameter, enabling more dynamic and customizable job setup by passing a pre-configured configuration object. This modification enhances code flexibility, allows for better configuration management, and provides more control over Hadoop job parameters during runtime."
94527,"public void run(final Path input,final Path output,final Progress progress,final JobListener jobListener) throws IOException, JobFailedException, JobCancelledException {
  final Job job=new Job(HadoopUtils.createConfiguration());
  if (inputFormat == null) {
    inputFormat=AutoFeatureInputFormat.class;
  }
  job.setInputFormatClass(inputFormat);
  FileInputFormat.addInputPath(job,input);
  run(job,output,progress,jobListener);
}","public void run(final Configuration conf,final Path input,final Path output,final Progress progress,final JobListener jobListener) throws IOException, JobFailedException, JobCancelledException {
  final Job job=new Job(conf);
  if (inputFormat == null) {
    inputFormat=AutoFeatureInputFormat.class;
  }
  job.setInputFormatClass(inputFormat);
  FileInputFormat.addInputPath(job,input);
  run(job,output,progress,jobListener);
}","The original code lacked a crucial Configuration parameter, potentially causing initialization issues with Hadoop job configuration. The fixed code introduces a Configuration object (conf) as a method parameter, allowing explicit configuration passing and greater flexibility in job setup. This modification ensures more robust and configurable job creation, enabling precise control over Hadoop job settings and improving overall code reliability."
94528,"@Override public void moveOutput(String toName) throws IOException {
  Path toPath=new Path(toName);
  Path sourcePath=new Path(_outputName);
  Configuration conf=HadoopUtils.createConfiguration();
  FileSystem sourceFs=HadoopFileUtils.getFileSystem(conf,sourcePath);
  FileSystem destFs=HadoopFileUtils.getFileSystem(conf,toPath);
  if (!FileUtil.copy(sourceFs,sourcePath,destFs,toPath,false,false,conf)) {
    throw new IOException(""String_Node_Str"" + _outputName + ""String_Node_Str""+ toName.toString()+ ""String_Node_Str"");
  }
  Path sourceColumns=new Path(_outputName + ""String_Node_Str"");
  if (sourceFs.exists(sourceColumns)) {
    Path toColumns=new Path(toName.toString() + ""String_Node_Str"");
    if (FileUtil.copy(sourceFs,sourceColumns,destFs,toColumns,false,false,conf) == false) {
      throw new IOException(""String_Node_Str"" + sourceColumns.toString() + ""String_Node_Str""+ toColumns.toString());
    }
  }
  _outputName=toName;
  _output=new BasicInputFormatDescriptor(_outputName);
}","@Override public void moveOutput(String toName) throws IOException {
  Path toPath=new Path(toName);
  Path sourcePath=new Path(_outputName);
  Configuration conf=createConfiguration();
  FileSystem sourceFs=HadoopFileUtils.getFileSystem(conf,sourcePath);
  FileSystem destFs=HadoopFileUtils.getFileSystem(conf,toPath);
  if (!FileUtil.copy(sourceFs,sourcePath,destFs,toPath,false,false,conf)) {
    throw new IOException(""String_Node_Str"" + _outputName + ""String_Node_Str""+ toName.toString()+ ""String_Node_Str"");
  }
  Path sourceColumns=new Path(_outputName + ""String_Node_Str"");
  if (sourceFs.exists(sourceColumns)) {
    Path toColumns=new Path(toName.toString() + ""String_Node_Str"");
    if (FileUtil.copy(sourceFs,sourceColumns,destFs,toColumns,false,false,conf) == false) {
      throw new IOException(""String_Node_Str"" + sourceColumns.toString() + ""String_Node_Str""+ toColumns.toString());
    }
  }
  _outputName=toName;
  _output=new BasicInputFormatDescriptor(_outputName);
}","The original code called `HadoopUtils.createConfiguration()`, which was likely an external method not defined in the provided context. The fixed code replaces this with a direct `createConfiguration()` call, suggesting an internal method or a more localized configuration setup. This change improves code reliability by using a defined configuration method, potentially reducing external dependencies and simplifying the configuration process."
94529,"public void setImageMetadata(final ImageMetadata[] metadata){
  imageData=metadata;
}","public void setImageMetadata(final ImageMetadata[] metadata){
  imageData=metadata;
  if (imageData == null) {
    for (int i=0; i <= maxZoomLevel; i++) {
      imageData=(ImageMetadata[])ArrayUtils.add(imageData,new ImageMetadata());
    }
  }
 else   if (maxZoomLevel < imageData.length) {
    imageData=(ImageMetadata[])ArrayUtils.subarray(imageData,0,maxZoomLevel + 1);
  }
 else   if (maxZoomLevel > imageData.length) {
    for (int i=imageData.length; i <= maxZoomLevel; i++) {
      imageData=(ImageMetadata[])ArrayUtils.add(imageData,new ImageMetadata());
    }
  }
}","The original code simply assigns the input metadata array without handling null or length mismatches with the maximum zoom level. The fixed code adds null checks and dynamically adjusts the array by adding or trimming ImageMetadata instances to match the maxZoomLevel, ensuring consistent array size and preventing potential null pointer or index out of bounds exceptions. This modification provides robust metadata handling, allowing flexible image processing across different zoom levels with automatic array resizing."
94530,"public void setImageMetadata(final ImageMetadata[] metadata){
  imageData=metadata;
  if (imageData == null) {
    for (int i=0; i <= maxZoomLevel; i++) {
      imageData=(ImageMetadata[])ArrayUtils.add(imageData,new ImageMetadata());
    }
  }
 else   if (maxZoomLevel < imageData.length) {
    imageData=(ImageMetadata[])ArrayUtils.subarray(imageData,0,maxZoomLevel + 1);
  }
 else   if (maxZoomLevel > imageData.length) {
    for (int i=imageData.length; i <= maxZoomLevel; i++) {
      imageData=(ImageMetadata[])ArrayUtils.add(imageData,new ImageMetadata());
    }
  }
}","public void setImageMetadata(final ImageMetadata[] metadata){
  imageData=metadata;
  if (imageData == null) {
    for (int i=0; i <= maxZoomLevel; i++) {
      imageData=(ImageMetadata[])ArrayUtils.add(imageData,new ImageMetadata());
    }
  }
 else   if ((maxZoomLevel + 1) < imageData.length) {
    imageData=(ImageMetadata[])ArrayUtils.subarray(imageData,0,maxZoomLevel + 1);
  }
 else   if (maxZoomLevel > imageData.length) {
    for (int i=imageData.length; i <= maxZoomLevel; i++) {
      imageData=(ImageMetadata[])ArrayUtils.add(imageData,new ImageMetadata());
    }
  }
}","The original code incorrectly compared `maxZoomLevel` directly with `imageData.length`, potentially causing incorrect array truncation or extension. The fixed code changes the condition to `(maxZoomLevel + 1) < imageData.length`, ensuring precise length comparison by accounting for zero-based indexing. This modification guarantees accurate array resizing, preventing potential out-of-bounds errors and maintaining the intended metadata management logic."
94531,"@Override public MapOp convertToMapOp(ParserNode node) throws ParserException {
  MapOp mapOp=null;
  if (node instanceof ParserFunctionNode) {
    mapOp=convertToMapOp((ParserFunctionNode)node);
  }
  if (node instanceof ParserConstantNode) {
    mapOp=convertToMapOp((ParserConstantNode)node);
  }
  if (node instanceof ParserVariableNode) {
    mapOp=convertToMapOp((ParserVariableNode)node);
  }
  if (mapOp != null) {
    if (mapOp.getConf() == null) {
      mapOp.setConf(new Configuration(this.conf));
    }
    if (mapOp.getProviderProperties() == null) {
      mapOp.setProviderProperties(providerProperties);
    }
    if (mapOp.getProtectionLevel() == null) {
      mapOp.setProtectionLevel(protectionLevel);
    }
    return mapOp;
  }
  throw new ParserException();
}","@Override public MapOp convertToMapOp(ParserNode node) throws ParserException {
  MapOp mapOp=null;
  if (node instanceof ParserFunctionNode) {
    mapOp=convertToMapOp((ParserFunctionNode)node);
  }
  if (node instanceof ParserConstantNode) {
    mapOp=convertToMapOp((ParserConstantNode)node);
  }
  if (node instanceof ParserVariableNode) {
    mapOp=convertToMapOp((ParserVariableNode)node);
  }
  if (mapOp != null) {
    if (mapOp.getProviderProperties() == null) {
      mapOp.setProviderProperties(providerProperties);
    }
    if (mapOp.getProtectionLevel() == null) {
      mapOp.setProtectionLevel(protectionLevel);
    }
    return mapOp;
  }
  throw new ParserException();
}","The original code unnecessarily sets a configuration for every MapOp, potentially overwriting existing configurations. The fixed code removes the redundant configuration setting, preserving any pre-existing configuration while still setting provider properties and protection level if they are null. This approach ensures more flexibility and prevents unintended configuration modifications, making the code more robust and less prone to side effects."
94532,"public MapOp parse(String expression) throws ParserException, FileNotFoundException, IOException {
  log.debug(""String_Node_Str"" + expression);
  String exp=expression;
  _variables.clear();
  getPreprocessors();
  String[] lines=exp.split(""String_Node_Str"");
  ArrayList<String> cleaned=new ArrayList<String>();
  for (  String line : lines) {
    line=line.trim();
    if (!line.startsWith(""String_Node_Str"")) {
      int comment=line.indexOf('#');
      if (comment > 0) {
        line=line.substring(0,comment).trim();
      }
      cleaned.add(line);
    }
  }
  exp=StringUtils.join(cleaned,""String_Node_Str"");
  log.debug(""String_Node_Str"" + exp);
  exp=mapFilesToVariables(exp);
  log.debug(""String_Node_Str"" + exp);
  MapOp root=null;
  try {
    ParserNode rootNode=parser.parse(exp,this);
    if (rootNode != null) {
      root=convertToMapOp(rootNode);
    }
  }
 catch (  ParserException e) {
    log.warn(exp);
    throw e;
  }
  log.debug(""String_Node_Str"" + root.toString());
  return root;
}","public MapOp parse(String expression) throws ParserException, FileNotFoundException, IOException {
  log.debug(""String_Node_Str"" + expression);
  String exp=expression;
  _variables.clear();
  getPreprocessors();
  String[] lines=exp.split(""String_Node_Str"");
  ArrayList<String> cleaned=new ArrayList<String>();
  for (  String line : lines) {
    line=line.trim();
    if (!line.startsWith(""String_Node_Str"")) {
      int comment=line.indexOf('#');
      if (comment > 0) {
        line=line.substring(0,comment).trim();
      }
      cleaned.add(line);
    }
  }
  exp=StringUtils.join(cleaned,""String_Node_Str"");
  log.debug(""String_Node_Str"" + exp);
  exp=mapFilesToVariables(exp);
  log.debug(""String_Node_Str"" + exp);
  MapOp root=null;
  try {
    ParserNode rootNode=parser.parse(exp,this);
    if (rootNode != null) {
      root=convertToMapOp(rootNode);
      root.setDefaultConfiguration(conf);
    }
  }
 catch (  ParserException e) {
    log.warn(exp);
    throw e;
  }
  log.debug(""String_Node_Str"" + root.toString());
  return root;
}","The original code failed to set the default configuration for the MapOp root object after parsing, potentially leading to incomplete or misconfigured operations. The fixed code adds `root.setDefaultConfiguration(conf)` within the parsing try block, ensuring that the root MapOp receives the necessary default configuration settings. This improvement guarantees that the parsed operation has a consistent and proper configuration, enhancing the reliability and predictability of the parsing process."
94533,"@Override public void postBuild(Progress p,boolean buildPyramid) throws IOException, JobFailedException, JobCancelledException {
  if (buildPyramid) {
    MrsImagePyramid pyramid=MrsImagePyramid.open(_outputName,getProviderProperties());
    MrsImagePyramidMetadata metadata=pyramid.getMetadata();
    Aggregator aggregator;
    if (metadata.getClassification() == Classification.Continuous) {
      aggregator=new MeanAggregator();
    }
 else {
      aggregator=new ModeAggregator();
    }
    BuildPyramidDriver.build(_outputName,aggregator,getConf(),getProviderProperties());
  }
  p.complete();
}","@Override public void postBuild(Progress p,boolean buildPyramid) throws IOException, JobFailedException, JobCancelledException {
  if (buildPyramid) {
    MrsImagePyramid pyramid=MrsImagePyramid.open(_outputName,getProviderProperties());
    MrsImagePyramidMetadata metadata=pyramid.getMetadata();
    Aggregator aggregator;
    if (metadata.getClassification() == Classification.Continuous) {
      aggregator=new MeanAggregator();
    }
 else {
      aggregator=new ModeAggregator();
    }
    BuildPyramidDriver.build(_outputName,aggregator,createConfiguration(),getProviderProperties());
  }
  p.complete();
}","The buggy code used `getConf()`, which likely returned an incorrect or incomplete configuration for building the image pyramid. The fixed code replaces `getConf()` with `createConfiguration()`, which ensures a proper configuration is generated for the BuildPyramidDriver. This change guarantees a more reliable and accurate pyramid construction process by providing the correct configuration parameters."
94534,"private static void findJars(File file,Set<File> paths,Set<String> filesLeft,boolean recurseDirectories) throws IOException {
  if (file.exists()) {
    if (file.isDirectory()) {
      File[] files=file.listFiles();
      if (files != null) {
        for (        File f : files) {
          if (filesLeft.contains(f.getName())) {
            log.debug(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
            paths.add(file);
            filesLeft.remove(file.getName());
            if (filesLeft.isEmpty()) {
              return;
            }
          }
          if (recurseDirectories) {
            log.debug(""String_Node_Str"" + f.getPath() + ""String_Node_Str""+ paths.size()+ ""String_Node_Str""+ filesLeft.size());
            findJars(f,paths,filesLeft,recurseDirectories);
            if (filesLeft.isEmpty()) {
              return;
            }
          }
        }
      }
    }
 else     if (filesLeft.contains(file.getName())) {
      log.debug(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
      paths.add(file);
      filesLeft.remove(file.getName());
    }
  }
}","private static void findJars(File file,Set<File> paths,Set<String> filesLeft,boolean recurseDirectories) throws IOException {
  if (file.exists()) {
    if (file.isDirectory()) {
      File[] files=file.listFiles();
      if (files != null) {
        for (        File f : files) {
          if (filesLeft.contains(f.getName())) {
            log.debug(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ file.getPath());
            paths.add(file);
            filesLeft.remove(file.getName());
            if (filesLeft.isEmpty()) {
              return;
            }
          }
          if (recurseDirectories) {
            log.debug(""String_Node_Str"" + f.getPath() + ""String_Node_Str""+ paths.size()+ ""String_Node_Str""+ filesLeft.size());
            findJars(f,paths,filesLeft,recurseDirectories);
            if (filesLeft.isEmpty()) {
              return;
            }
          }
        }
      }
    }
 else     if (filesLeft.contains(file.getName())) {
      log.debug(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ file.getPath());
      paths.add(file);
      filesLeft.remove(file.getName());
    }
  }
}","The original code lacked proper logging of file paths, potentially obscuring important debugging information when searching for specific files. The fixed code adds `file.getPath()` to the logging statements, providing more comprehensive context about the file locations being processed. This enhancement improves code debugging and traceability by capturing complete file path information during the recursive file search process."
94535,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  MapOp inlineCsvMapOp=_inputs.get(0);
  assert(inlineCsvMapOp instanceof InlineCsvMapOp);
  InlineCsvInputFormatDescriptor ifd=(InlineCsvInputFormatDescriptor)((InlineCsvMapOp)inlineCsvMapOp).getVectorOutput();
  String sourcePoints=ifd.getValues();
  RasterMapOp friction=(RasterMapOp)_inputs.get(1);
  if (zoomLevel < 0) {
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(friction.getOutputName(),AccessMode.READ,getProviderProperties());
    MrsImagePyramidMetadata metadata=dp.getMetadataReader().read();
    zoomLevel=metadata.getMaxZoomLevel();
  }
  try {
    String driverArgs[]=new String[]{""String_Node_Str"",friction.getOutputName(),""String_Node_Str"",""String_Node_Str"" + zoomLevel,""String_Node_Str"",_outputName,""String_Node_Str"",sourcePoints,""String_Node_Str"",String.valueOf(maxCost)};
    if (ToolRunner.run(getConf(),new CostDistanceDriver(),driverArgs) < 0) {
      throw new JobFailedException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new JobFailedException(e.getMessage());
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  MapOp inlineCsvMapOp=_inputs.get(0);
  assert(inlineCsvMapOp instanceof InlineCsvMapOp);
  InlineCsvInputFormatDescriptor ifd=(InlineCsvInputFormatDescriptor)((InlineCsvMapOp)inlineCsvMapOp).getVectorOutput();
  String sourcePoints=ifd.getValues();
  RasterMapOp friction=(RasterMapOp)_inputs.get(1);
  if (zoomLevel < 0) {
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(friction.getOutputName(),AccessMode.READ,getProviderProperties());
    MrsImagePyramidMetadata metadata=dp.getMetadataReader().read();
    zoomLevel=metadata.getMaxZoomLevel();
  }
  try {
    String driverArgs[]=new String[]{""String_Node_Str"",friction.getOutputName(),""String_Node_Str"",""String_Node_Str"" + zoomLevel,""String_Node_Str"",_outputName,""String_Node_Str"",sourcePoints,""String_Node_Str"",String.valueOf(maxCost)};
    if (ToolRunner.run(createConfiguration(),new CostDistanceDriver(),driverArgs) < 0) {
      throw new JobFailedException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new JobFailedException(e.getMessage());
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","The original code incorrectly used `getConf()` method, which might not provide a properly configured Hadoop configuration for running the MapReduce job. The fixed code replaces `getConf()` with `createConfiguration()`, which likely generates a more robust and correctly initialized configuration object for the ToolRunner. This change ensures proper configuration setup, potentially resolving potential runtime issues and improving the reliability of the distributed job execution process."
94536,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  String destPoints=null;
  RasterMapOp inputOp=(RasterMapOp)_inputs.get(0);
  if (inputOp.getOutputName() == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String costPyramidName=inputOp.getOutputName();
  if (zoom < 0) {
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(costPyramidName,AccessMode.READ,getConf());
    if (dp != null) {
      MrsImagePyramidMetadata metadata=dp.getMetadataReader().read();
      zoom=metadata.getMaxZoomLevel();
    }
 else {
      throw new IOException(""String_Node_Str"" + costPyramidName + ""String_Node_Str"");
    }
  }
  MapOp inlineCsvMapOp=_inputs.get(1);
  assert(inlineCsvMapOp instanceof InlineCsvMapOp);
  InlineCsvInputFormatDescriptor ifd=(InlineCsvInputFormatDescriptor)((VectorMapOp)inlineCsvMapOp).getVectorOutput();
  destPoints=ifd.getValues();
  LeastCostPathCalculator.run(destPoints,costPyramidName,zoom,_outputName,getProviderProperties());
  BasicInputFormatDescriptor result=new BasicInputFormatDescriptor(_outputName);
  _output=result;
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  String destPoints=null;
  RasterMapOp inputOp=(RasterMapOp)_inputs.get(0);
  if (inputOp.getOutputName() == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String costPyramidName=inputOp.getOutputName();
  if (zoom < 0) {
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(costPyramidName,AccessMode.READ,createConfiguration());
    if (dp != null) {
      MrsImagePyramidMetadata metadata=dp.getMetadataReader().read();
      zoom=metadata.getMaxZoomLevel();
    }
 else {
      throw new IOException(""String_Node_Str"" + costPyramidName + ""String_Node_Str"");
    }
  }
  MapOp inlineCsvMapOp=_inputs.get(1);
  assert(inlineCsvMapOp instanceof InlineCsvMapOp);
  InlineCsvInputFormatDescriptor ifd=(InlineCsvInputFormatDescriptor)((VectorMapOp)inlineCsvMapOp).getVectorOutput();
  destPoints=ifd.getValues();
  LeastCostPathCalculator.run(destPoints,costPyramidName,zoom,_outputName,getProviderProperties());
  BasicInputFormatDescriptor result=new BasicInputFormatDescriptor(_outputName);
  _output=result;
}","The original code used `getConf()` which might not provide the correct configuration for creating a data provider. The fixed code replaces `getConf()` with `createConfiguration()`, ensuring a proper configuration is generated for accessing the MRS image data provider. This change improves the reliability of configuration handling and prevents potential runtime errors when retrieving image metadata."
94537,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  MrsImagePyramid inputPyramid=RasterMapOp.flushRasterMapOpOutput(sourceRaster,0);
  if (aggregatorName == null) {
    MrsImagePyramidMetadata.Classification classification=inputPyramid.getMetadata().getClassification();
    if (classification.equals(Classification.Categorical)) {
      aggregatorName=""String_Node_Str"";
    }
 else {
      aggregatorName=""String_Node_Str"";
    }
  }
  p.starting();
  Class<? extends Aggregator> aggregatorClass=null;
  aggregatorClass=AggregatorRegistry.aggregatorRegistry.get(aggregatorName.toUpperCase());
  if (aggregatorClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + aggregatorName);
  }
  String rasterInput=sourceRaster.getOutputName();
  try {
    BuildPyramidDriver.build(rasterInput,aggregatorClass.newInstance(),getConf(),getProviderProperties());
  }
 catch (  InstantiationException e) {
    String msg=""String_Node_Str"" + aggregatorName + ""String_Node_Str""+ rasterInput;
    log.error(msg);
    throw new JobFailedException(msg);
  }
catch (  IllegalAccessException e) {
    log.error(""String_Node_Str"" + rasterInput + ""String_Node_Str""+ e);
    throw new JobFailedException(""String_Node_Str"" + rasterInput);
  }
catch (  Exception e) {
    e.printStackTrace();
    log.error(""String_Node_Str"" + rasterInput + ""String_Node_Str""+ e);
    throw new JobFailedException(""String_Node_Str"" + rasterInput);
  }
  p.complete();
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  MrsImagePyramid inputPyramid=RasterMapOp.flushRasterMapOpOutput(sourceRaster,0);
  if (aggregatorName == null) {
    MrsImagePyramidMetadata.Classification classification=inputPyramid.getMetadata().getClassification();
    if (classification.equals(Classification.Categorical)) {
      aggregatorName=""String_Node_Str"";
    }
 else {
      aggregatorName=""String_Node_Str"";
    }
  }
  p.starting();
  Class<? extends Aggregator> aggregatorClass=null;
  aggregatorClass=AggregatorRegistry.aggregatorRegistry.get(aggregatorName.toUpperCase());
  if (aggregatorClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + aggregatorName);
  }
  String rasterInput=sourceRaster.getOutputName();
  try {
    BuildPyramidDriver.build(rasterInput,aggregatorClass.newInstance(),createConfiguration(),getProviderProperties());
  }
 catch (  InstantiationException e) {
    String msg=""String_Node_Str"" + aggregatorName + ""String_Node_Str""+ rasterInput;
    log.error(msg);
    throw new JobFailedException(msg);
  }
catch (  IllegalAccessException e) {
    log.error(""String_Node_Str"" + rasterInput + ""String_Node_Str""+ e);
    throw new JobFailedException(""String_Node_Str"" + rasterInput);
  }
catch (  Exception e) {
    e.printStackTrace();
    log.error(""String_Node_Str"" + rasterInput + ""String_Node_Str""+ e);
    throw new JobFailedException(""String_Node_Str"" + rasterInput);
  }
  p.complete();
}","The original code used `getConf()` method, which likely does not exist or is incorrect, potentially causing configuration issues during pyramid building. The fixed code replaces `getConf()` with `createConfiguration()`, which presumably creates a proper configuration object for the BuildPyramidDriver. This change ensures correct configuration passing, preventing potential runtime errors and improving the method's reliability in generating image pyramids."
94538,"@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final MrsImagePyramid sourcepyramid=RasterMapOp.flushRasterMapOpOutput(source,0);
  MrsImageDataProvider provider=DataProviderFactory.getMrsImageDataProvider(sourcepyramid.getName(),AccessMode.READ,getProviderProperties());
  MrsImagePyramidMetadata metadata=provider.getMetadataReader().read();
  _outputName=source.getOutputName();
  if (metadata.getClassification() != classification) {
    metadata.setClassification(classification);
    metadata.setResamplingMethod(AggregatorRegistry.aggregatorRegistry.inverse().get(aggregator.getClass()));
    provider.getMetadataWriter().write();
    if (sourcepyramid.hasPyramids()) {
      try {
        BuildPyramidDriver.build(sourcepyramid.getName(),aggregator,getConf(),p,jobListener,getProviderProperties());
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final MrsImagePyramid sourcepyramid=RasterMapOp.flushRasterMapOpOutput(source,0);
  MrsImageDataProvider provider=DataProviderFactory.getMrsImageDataProvider(sourcepyramid.getName(),AccessMode.READ,getProviderProperties());
  MrsImagePyramidMetadata metadata=provider.getMetadataReader().read();
  _outputName=source.getOutputName();
  if (metadata.getClassification() != classification) {
    metadata.setClassification(classification);
    metadata.setResamplingMethod(AggregatorRegistry.aggregatorRegistry.inverse().get(aggregator.getClass()));
    provider.getMetadataWriter().write();
    if (sourcepyramid.hasPyramids()) {
      try {
        BuildPyramidDriver.build(sourcepyramid.getName(),aggregator,createConfiguration(),p,jobListener,getProviderProperties());
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","The original code used `getConf()` method, which might be undefined or return an incorrect configuration for the BuildPyramidDriver. The fixed code replaces `getConf()` with `createConfiguration()`, ensuring a proper configuration is generated for the pyramid build process. This change provides a more reliable and consistent method of configuration generation, potentially preventing configuration-related errors during pyramid construction."
94539,"@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final MrsImagePyramid sourcepyramid=RasterMapOp.flushRasterMapOpOutput(source,0);
  log.info(""String_Node_Str"" + _outputName.toString());
  final Job job=new Job(getConf());
  if (bounds == null) {
    bounds=calculateBounds();
  }
  FillRasterDriver.run(job,sourcepyramid,_outputName,fill,filltype,bounds,p,jobListener,getProtectionLevel(),getProviderProperties());
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final MrsImagePyramid sourcepyramid=RasterMapOp.flushRasterMapOpOutput(source,0);
  log.info(""String_Node_Str"" + _outputName.toString());
  final Job job=new Job(createConfiguration());
  if (bounds == null) {
    bounds=calculateBounds();
  }
  FillRasterDriver.run(job,sourcepyramid,_outputName,fill,filltype,bounds,p,jobListener,getProtectionLevel(),getProviderProperties());
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","The original code uses `getConf()` to create a Job configuration, which may not provide the necessary settings for the specific job. The fixed code replaces this with `createConfiguration()`, a method likely designed to generate a more appropriate and tailored configuration. This change ensures that the Job is initialized with the correct parameters, improving the reliability and specificity of the configuration for the raster processing task."
94540,"@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final InputFormatDescriptor ifd=((VectorMapOp)_inputs.get(0)).getVectorOutput();
  if (bounds == null) {
    bounds=calculateBounds();
  }
{
    final RasterizeVectorDriver rvd=new RasterizeVectorDriver();
    final Job job=new Job(getConf());
    ifd.populateJobParameters(job);
    rvd.setValueColumn(column);
    rvd.run(job,_outputName,_aggregationType,zoomlevel,bounds,p,jobListener,getProtectionLevel(),getProviderProperties());
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final InputFormatDescriptor ifd=((VectorMapOp)_inputs.get(0)).getVectorOutput();
  if (bounds == null) {
    bounds=calculateBounds();
  }
{
    final RasterizeVectorDriver rvd=new RasterizeVectorDriver();
    final Job job=new Job(createConfiguration());
    ifd.populateJobParameters(job);
    rvd.setValueColumn(column);
    rvd.run(job,_outputName,_aggregationType,zoomlevel,bounds,p,jobListener,getProtectionLevel(),getProviderProperties());
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","The original code used `getConf()` directly, which might not create a properly configured Hadoop configuration for job setup. The fixed code replaces this with `createConfiguration()`, ensuring a correctly initialized configuration object for the job. This change provides a more robust and reliable method of creating the job configuration, preventing potential configuration-related issues during job execution."
94541,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  ph.createChild(1f);
  ph.createChild(1f);
  _writeInputs(ph.getChild(0));
  _connectInputs();
  PigQuerier pq=new PigQuerier();
  log.warn(_script);
  log.warn(_outputName.toString());
  pq.query(_script,new Path(_outputName),getConf());
  ph.getChild(1).complete();
  _output=new BasicInputFormatDescriptor(_outputName);
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  ph.createChild(1f);
  ph.createChild(1f);
  _writeInputs(ph.getChild(0));
  _connectInputs();
  PigQuerier pq=new PigQuerier();
  log.warn(_script);
  log.warn(_outputName.toString());
  pq.query(_script,new Path(_outputName),createConfiguration());
  ph.getChild(1).complete();
  _output=new BasicInputFormatDescriptor(_outputName);
}","The original code incorrectly used `getConf()`, which might not return a properly configured Configuration object for the Pig query. The fixed code replaces `getConf()` with `createConfiguration()`, a method likely designed to generate a specific, correctly initialized Configuration for the PigQuerier. This change ensures that the Pig query is executed with the appropriate configuration parameters, improving the reliability and potential success of the query execution."
94542,"/** 
 * Go through each of the MapOp inputs and write the values out to disk. If the values are already on disk then this can be skipped. This may take a while.
 * @throws IOException
 * @throws JobFailedException
 */
protected void _writeInputs(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  for (  MapOp input : _inputs) {
    if (input != null && (input instanceof VectorMapOp)) {
      if (((VectorMapOp)input).getOutputName() == null) {
        ph.createChild(1.0f);
      }
    }
  }
  _inputPaths=new ArrayList<Path>();
  int pi=0;
  for (  MapOp input : _inputs) {
    if (input != null && (input instanceof VectorMapOp)) {
      Path inputPath=new Path(((VectorMapOp)input).getOutputName());
      if (inputPath == null) {
        inputPath=new Path(HadoopFileUtils.getTempDir(),HadoopUtils.createRandomString(40) + ""String_Node_Str"");
        addTempFile(inputPath.toString());
        addTempFile(inputPath.toString() + ""String_Node_Str"");
        VectorMapOp.writeVectorOutput((InputFormatDescriptor)((VectorMapOp)input).getVectorOutput(),inputPath,getConf(),ph.getChild(pi++));
      }
      _inputPaths.add(inputPath);
    }
  }
}","/** 
 * Go through each of the MapOp inputs and write the values out to disk. If the values are already on disk then this can be skipped. This may take a while.
 * @throws IOException
 * @throws JobFailedException
 */
protected void _writeInputs(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  for (  MapOp input : _inputs) {
    if (input != null && (input instanceof VectorMapOp)) {
      if (((VectorMapOp)input).getOutputName() == null) {
        ph.createChild(1.0f);
      }
    }
  }
  _inputPaths=new ArrayList<Path>();
  int pi=0;
  for (  MapOp input : _inputs) {
    if (input != null && (input instanceof VectorMapOp)) {
      Path inputPath=new Path(((VectorMapOp)input).getOutputName());
      if (inputPath == null) {
        inputPath=new Path(HadoopFileUtils.getTempDir(),HadoopUtils.createRandomString(40) + ""String_Node_Str"");
        addTempFile(inputPath.toString());
        addTempFile(inputPath.toString() + ""String_Node_Str"");
        VectorMapOp.writeVectorOutput((InputFormatDescriptor)((VectorMapOp)input).getVectorOutput(),inputPath,createConfiguration(),ph.getChild(pi++));
      }
      _inputPaths.add(inputPath);
    }
  }
}","The original code incorrectly used `getConf()`, which might not return a valid Configuration object for writing vector output. The fixed code replaces `getConf()` with `createConfiguration()`, ensuring a proper Configuration is generated for file operations. This change guarantees a reliable and consistent method of creating the configuration needed for writing vector data to temporary files during Hadoop job processing."
94543,"@Override public MapOp convertToMapOp(ParserNode node) throws ParserException {
  MapOp mapOp=null;
  if (node instanceof ParserFunctionNode) {
    mapOp=convertToMapOp((ParserFunctionNode)node);
  }
  if (node instanceof ParserConstantNode) {
    mapOp=convertToMapOp((ParserConstantNode)node);
  }
  if (node instanceof ParserVariableNode) {
    mapOp=convertToMapOp((ParserVariableNode)node);
  }
  if (mapOp != null) {
    if (mapOp.getConf() == null) {
      mapOp.setConf(new Configuration(this.conf));
    }
    if (mapOp.getProviderProperties() == null) {
      mapOp.setProviderProperties(providerProperties);
    }
    if (mapOp.getProtectionLevel() == null) {
      mapOp.setProtectionLevel(protectionLevel);
    }
    return mapOp;
  }
  throw new ParserException();
}","@Override public MapOp convertToMapOp(ParserNode node) throws ParserException {
  MapOp mapOp=null;
  if (node instanceof ParserFunctionNode) {
    mapOp=convertToMapOp((ParserFunctionNode)node);
  }
  if (node instanceof ParserConstantNode) {
    mapOp=convertToMapOp((ParserConstantNode)node);
  }
  if (node instanceof ParserVariableNode) {
    mapOp=convertToMapOp((ParserVariableNode)node);
  }
  if (mapOp != null) {
    if (mapOp.getProviderProperties() == null) {
      mapOp.setProviderProperties(providerProperties);
    }
    if (mapOp.getProtectionLevel() == null) {
      mapOp.setProtectionLevel(protectionLevel);
    }
    return mapOp;
  }
  throw new ParserException();
}","The original code redundantly set configuration with a potential null check, which was unnecessary and could lead to unintended configuration overwrites. The fixed code removes the configuration setting step, focusing only on setting provider properties and protection level if they are null. This simplifies the code, reduces potential side effects, and ensures more predictable and controlled object initialization when converting parser nodes to map operations."
94544,"public MapOp parse(String expression) throws ParserException, FileNotFoundException, IOException {
  log.debug(""String_Node_Str"" + expression);
  String exp=expression;
  _variables.clear();
  getPreprocessors();
  String[] lines=exp.split(""String_Node_Str"");
  ArrayList<String> cleaned=new ArrayList<String>();
  for (  String line : lines) {
    line=line.trim();
    if (!line.startsWith(""String_Node_Str"")) {
      int comment=line.indexOf('#');
      if (comment > 0) {
        line=line.substring(0,comment).trim();
      }
      cleaned.add(line);
    }
  }
  exp=StringUtils.join(cleaned,""String_Node_Str"");
  log.debug(""String_Node_Str"" + exp);
  exp=mapFilesToVariables(exp);
  log.debug(""String_Node_Str"" + exp);
  MapOp root=null;
  try {
    ParserNode rootNode=parser.parse(exp,this);
    if (rootNode != null) {
      root=convertToMapOp(rootNode);
    }
  }
 catch (  ParserException e) {
    log.warn(exp);
    throw e;
  }
  log.debug(""String_Node_Str"" + root.toString());
  return root;
}","public MapOp parse(String expression) throws ParserException, FileNotFoundException, IOException {
  log.debug(""String_Node_Str"" + expression);
  String exp=expression;
  _variables.clear();
  getPreprocessors();
  String[] lines=exp.split(""String_Node_Str"");
  ArrayList<String> cleaned=new ArrayList<String>();
  for (  String line : lines) {
    line=line.trim();
    if (!line.startsWith(""String_Node_Str"")) {
      int comment=line.indexOf('#');
      if (comment > 0) {
        line=line.substring(0,comment).trim();
      }
      cleaned.add(line);
    }
  }
  exp=StringUtils.join(cleaned,""String_Node_Str"");
  log.debug(""String_Node_Str"" + exp);
  exp=mapFilesToVariables(exp);
  log.debug(""String_Node_Str"" + exp);
  MapOp root=null;
  try {
    ParserNode rootNode=parser.parse(exp,this);
    if (rootNode != null) {
      root=convertToMapOp(rootNode);
      root.setDefaultConfiguration(conf);
    }
  }
 catch (  ParserException e) {
    log.warn(exp);
    throw e;
  }
  log.debug(""String_Node_Str"" + root.toString());
  return root;
}","The original code failed to set a default configuration for the MapOp root object after parsing, potentially leading to incomplete or misconfigured operations. The fixed code adds `root.setDefaultConfiguration(conf)` within the parsing block, ensuring that the root MapOp receives the necessary default configuration parameters. This modification guarantees that the parsed MapOp has a consistent and properly initialized configuration, improving reliability and predictability of the parsing process."
94545,"@Override public void postBuild(Progress p,boolean buildPyramid) throws IOException, JobFailedException, JobCancelledException {
  if (buildPyramid) {
    MrsImagePyramid pyramid=MrsImagePyramid.open(_outputName,getProviderProperties());
    MrsImagePyramidMetadata metadata=pyramid.getMetadata();
    Aggregator aggregator;
    if (metadata.getClassification() == Classification.Continuous) {
      aggregator=new MeanAggregator();
    }
 else {
      aggregator=new ModeAggregator();
    }
    BuildPyramidDriver.build(_outputName,aggregator,getConf(),getProviderProperties());
  }
  p.complete();
}","@Override public void postBuild(Progress p,boolean buildPyramid) throws IOException, JobFailedException, JobCancelledException {
  if (buildPyramid) {
    MrsImagePyramid pyramid=MrsImagePyramid.open(_outputName,getProviderProperties());
    MrsImagePyramidMetadata metadata=pyramid.getMetadata();
    Aggregator aggregator;
    if (metadata.getClassification() == Classification.Continuous) {
      aggregator=new MeanAggregator();
    }
 else {
      aggregator=new ModeAggregator();
    }
    BuildPyramidDriver.build(_outputName,aggregator,createConfiguration(),getProviderProperties());
  }
  p.complete();
}","The original code used `getConf()` which might be undefined or not properly configured for pyramid building. The fixed code replaces this with `createConfiguration()`, ensuring a valid configuration is generated specifically for the BuildPyramidDriver. This change guarantees a reliable and correctly initialized configuration, preventing potential runtime errors during the pyramid building process."
94546,"private static void findJars(File file,Set<File> paths,Set<String> filesLeft,boolean recurseDirectories) throws IOException {
  if (file.exists()) {
    if (file.isDirectory()) {
      File[] files=file.listFiles();
      if (files != null) {
        for (        File f : files) {
          if (filesLeft.contains(f.getName())) {
            log.debug(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
            paths.add(file);
            filesLeft.remove(file.getName());
            if (filesLeft.isEmpty()) {
              return;
            }
          }
          if (recurseDirectories) {
            log.debug(""String_Node_Str"" + f.getPath() + ""String_Node_Str""+ paths.size()+ ""String_Node_Str""+ filesLeft.size());
            findJars(f,paths,filesLeft,recurseDirectories);
            if (filesLeft.isEmpty()) {
              return;
            }
          }
        }
      }
    }
 else     if (filesLeft.contains(file.getName())) {
      log.debug(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
      paths.add(file);
      filesLeft.remove(file.getName());
    }
  }
}","private static void findJars(File file,Set<File> paths,Set<String> filesLeft,boolean recurseDirectories) throws IOException {
  if (file.exists()) {
    if (file.isDirectory()) {
      File[] files=file.listFiles();
      if (files != null) {
        for (        File f : files) {
          if (filesLeft.contains(f.getName())) {
            log.debug(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ file.getPath());
            paths.add(file);
            filesLeft.remove(file.getName());
            if (filesLeft.isEmpty()) {
              return;
            }
          }
          if (recurseDirectories) {
            log.debug(""String_Node_Str"" + f.getPath() + ""String_Node_Str""+ paths.size()+ ""String_Node_Str""+ filesLeft.size());
            findJars(f,paths,filesLeft,recurseDirectories);
            if (filesLeft.isEmpty()) {
              return;
            }
          }
        }
      }
    }
 else     if (filesLeft.contains(file.getName())) {
      log.debug(""String_Node_Str"" + file.getName() + ""String_Node_Str""+ file.getPath());
      paths.add(file);
      filesLeft.remove(file.getName());
    }
  }
}","The original code incorrectly logged only the file name, potentially losing context about the full file path during jar discovery. The fixed code adds `file.getPath()` to the logging statements, providing more detailed and precise debugging information about the exact location of found files. By enhancing the logging with complete file path information, the code now offers better traceability and diagnostic capabilities during recursive file searching."
94547,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  MapOp inlineCsvMapOp=_inputs.get(0);
  assert(inlineCsvMapOp instanceof InlineCsvMapOp);
  InlineCsvInputFormatDescriptor ifd=(InlineCsvInputFormatDescriptor)((InlineCsvMapOp)inlineCsvMapOp).getVectorOutput();
  String sourcePoints=ifd.getValues();
  RasterMapOp friction=(RasterMapOp)_inputs.get(1);
  if (zoomLevel < 0) {
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(friction.getOutputName(),AccessMode.READ,getProviderProperties());
    MrsImagePyramidMetadata metadata=dp.getMetadataReader().read();
    zoomLevel=metadata.getMaxZoomLevel();
  }
  try {
    String driverArgs[]=new String[]{""String_Node_Str"",friction.getOutputName(),""String_Node_Str"",""String_Node_Str"" + zoomLevel,""String_Node_Str"",_outputName,""String_Node_Str"",sourcePoints,""String_Node_Str"",String.valueOf(maxCost)};
    if (ToolRunner.run(getConf(),new CostDistanceDriver(),driverArgs) < 0) {
      throw new JobFailedException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new JobFailedException(e.getMessage());
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  MapOp inlineCsvMapOp=_inputs.get(0);
  assert(inlineCsvMapOp instanceof InlineCsvMapOp);
  InlineCsvInputFormatDescriptor ifd=(InlineCsvInputFormatDescriptor)((InlineCsvMapOp)inlineCsvMapOp).getVectorOutput();
  String sourcePoints=ifd.getValues();
  RasterMapOp friction=(RasterMapOp)_inputs.get(1);
  if (zoomLevel < 0) {
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(friction.getOutputName(),AccessMode.READ,getProviderProperties());
    MrsImagePyramidMetadata metadata=dp.getMetadataReader().read();
    zoomLevel=metadata.getMaxZoomLevel();
  }
  try {
    String driverArgs[]=new String[]{""String_Node_Str"",friction.getOutputName(),""String_Node_Str"",""String_Node_Str"" + zoomLevel,""String_Node_Str"",_outputName,""String_Node_Str"",sourcePoints,""String_Node_Str"",String.valueOf(maxCost)};
    if (ToolRunner.run(createConfiguration(),new CostDistanceDriver(),driverArgs) < 0) {
      throw new JobFailedException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new JobFailedException(e.getMessage());
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","The original code used `getConf()` to obtain a configuration for `ToolRunner.run()`, which may not provide the required Hadoop configuration settings. The fixed code replaces `getConf()` with `createConfiguration()`, which likely generates a more appropriate and complete configuration for running the Hadoop job. This change ensures proper job configuration, potentially resolving potential runtime issues and improving the reliability of the cost distance calculation process."
94548,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  String destPoints=null;
  RasterMapOp inputOp=(RasterMapOp)_inputs.get(0);
  if (inputOp.getOutputName() == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String costPyramidName=inputOp.getOutputName();
  if (zoom < 0) {
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(costPyramidName,AccessMode.READ,getConf());
    if (dp != null) {
      MrsImagePyramidMetadata metadata=dp.getMetadataReader().read();
      zoom=metadata.getMaxZoomLevel();
    }
 else {
      throw new IOException(""String_Node_Str"" + costPyramidName + ""String_Node_Str"");
    }
  }
  MapOp inlineCsvMapOp=_inputs.get(1);
  assert(inlineCsvMapOp instanceof InlineCsvMapOp);
  InlineCsvInputFormatDescriptor ifd=(InlineCsvInputFormatDescriptor)((VectorMapOp)inlineCsvMapOp).getVectorOutput();
  destPoints=ifd.getValues();
  LeastCostPathCalculator.run(destPoints,costPyramidName,zoom,_outputName,getProviderProperties());
  BasicInputFormatDescriptor result=new BasicInputFormatDescriptor(_outputName);
  _output=result;
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  String destPoints=null;
  RasterMapOp inputOp=(RasterMapOp)_inputs.get(0);
  if (inputOp.getOutputName() == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String costPyramidName=inputOp.getOutputName();
  if (zoom < 0) {
    MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(costPyramidName,AccessMode.READ,createConfiguration());
    if (dp != null) {
      MrsImagePyramidMetadata metadata=dp.getMetadataReader().read();
      zoom=metadata.getMaxZoomLevel();
    }
 else {
      throw new IOException(""String_Node_Str"" + costPyramidName + ""String_Node_Str"");
    }
  }
  MapOp inlineCsvMapOp=_inputs.get(1);
  assert(inlineCsvMapOp instanceof InlineCsvMapOp);
  InlineCsvInputFormatDescriptor ifd=(InlineCsvInputFormatDescriptor)((VectorMapOp)inlineCsvMapOp).getVectorOutput();
  destPoints=ifd.getValues();
  LeastCostPathCalculator.run(destPoints,costPyramidName,zoom,_outputName,getProviderProperties());
  BasicInputFormatDescriptor result=new BasicInputFormatDescriptor(_outputName);
  _output=result;
}","The original code used `getConf()` which likely refers to an undefined or incorrect configuration method for retrieving data provider settings. In the fixed code, `createConfiguration()` replaces `getConf()`, which is presumably a more appropriate method for generating the required configuration object. This modification ensures proper configuration retrieval, enhancing the reliability and correctness of the data provider initialization process."
94549,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  MrsImagePyramid inputPyramid=RasterMapOp.flushRasterMapOpOutput(sourceRaster,0);
  if (aggregatorName == null) {
    MrsImagePyramidMetadata.Classification classification=inputPyramid.getMetadata().getClassification();
    if (classification.equals(Classification.Categorical)) {
      aggregatorName=""String_Node_Str"";
    }
 else {
      aggregatorName=""String_Node_Str"";
    }
  }
  p.starting();
  Class<? extends Aggregator> aggregatorClass=null;
  aggregatorClass=AggregatorRegistry.aggregatorRegistry.get(aggregatorName.toUpperCase());
  if (aggregatorClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + aggregatorName);
  }
  String rasterInput=sourceRaster.getOutputName();
  try {
    BuildPyramidDriver.build(rasterInput,aggregatorClass.newInstance(),getConf(),getProviderProperties());
  }
 catch (  InstantiationException e) {
    String msg=""String_Node_Str"" + aggregatorName + ""String_Node_Str""+ rasterInput;
    log.error(msg);
    throw new JobFailedException(msg);
  }
catch (  IllegalAccessException e) {
    log.error(""String_Node_Str"" + rasterInput + ""String_Node_Str""+ e);
    throw new JobFailedException(""String_Node_Str"" + rasterInput);
  }
catch (  Exception e) {
    e.printStackTrace();
    log.error(""String_Node_Str"" + rasterInput + ""String_Node_Str""+ e);
    throw new JobFailedException(""String_Node_Str"" + rasterInput);
  }
  p.complete();
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  MrsImagePyramid inputPyramid=RasterMapOp.flushRasterMapOpOutput(sourceRaster,0);
  if (aggregatorName == null) {
    MrsImagePyramidMetadata.Classification classification=inputPyramid.getMetadata().getClassification();
    if (classification.equals(Classification.Categorical)) {
      aggregatorName=""String_Node_Str"";
    }
 else {
      aggregatorName=""String_Node_Str"";
    }
  }
  p.starting();
  Class<? extends Aggregator> aggregatorClass=null;
  aggregatorClass=AggregatorRegistry.aggregatorRegistry.get(aggregatorName.toUpperCase());
  if (aggregatorClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + aggregatorName);
  }
  String rasterInput=sourceRaster.getOutputName();
  try {
    BuildPyramidDriver.build(rasterInput,aggregatorClass.newInstance(),createConfiguration(),getProviderProperties());
  }
 catch (  InstantiationException e) {
    String msg=""String_Node_Str"" + aggregatorName + ""String_Node_Str""+ rasterInput;
    log.error(msg);
    throw new JobFailedException(msg);
  }
catch (  IllegalAccessException e) {
    log.error(""String_Node_Str"" + rasterInput + ""String_Node_Str""+ e);
    throw new JobFailedException(""String_Node_Str"" + rasterInput);
  }
catch (  Exception e) {
    e.printStackTrace();
    log.error(""String_Node_Str"" + rasterInput + ""String_Node_Str""+ e);
    throw new JobFailedException(""String_Node_Str"" + rasterInput);
  }
  p.complete();
}","The original code used `getConf()` which likely returned an incorrect or unintended configuration for the pyramid building process. The fixed code replaces `getConf()` with `createConfiguration()`, which presumably generates a more appropriate configuration specific to the build operation. This change ensures that the BuildPyramidDriver receives the correct configuration parameters, potentially improving the reliability and accuracy of the pyramid construction process."
94550,"@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final MrsImagePyramid sourcepyramid=RasterMapOp.flushRasterMapOpOutput(source,0);
  MrsImageDataProvider provider=DataProviderFactory.getMrsImageDataProvider(sourcepyramid.getName(),AccessMode.READ,getProviderProperties());
  MrsImagePyramidMetadata metadata=provider.getMetadataReader().read();
  _outputName=source.getOutputName();
  if (metadata.getClassification() != classification) {
    metadata.setClassification(classification);
    metadata.setResamplingMethod(AggregatorRegistry.aggregatorRegistry.inverse().get(aggregator.getClass()));
    provider.getMetadataWriter().write();
    if (sourcepyramid.hasPyramids()) {
      try {
        BuildPyramidDriver.build(sourcepyramid.getName(),aggregator,getConf(),p,jobListener,getProviderProperties());
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final MrsImagePyramid sourcepyramid=RasterMapOp.flushRasterMapOpOutput(source,0);
  MrsImageDataProvider provider=DataProviderFactory.getMrsImageDataProvider(sourcepyramid.getName(),AccessMode.READ,getProviderProperties());
  MrsImagePyramidMetadata metadata=provider.getMetadataReader().read();
  _outputName=source.getOutputName();
  if (metadata.getClassification() != classification) {
    metadata.setClassification(classification);
    metadata.setResamplingMethod(AggregatorRegistry.aggregatorRegistry.inverse().get(aggregator.getClass()));
    provider.getMetadataWriter().write();
    if (sourcepyramid.hasPyramids()) {
      try {
        BuildPyramidDriver.build(sourcepyramid.getName(),aggregator,createConfiguration(),p,jobListener,getProviderProperties());
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","The original code used `getConf()` method, which might not provide the correct configuration for building pyramids. The fixed code replaces `getConf()` with `createConfiguration()`, ensuring a proper configuration is generated for the pyramid building process. This change guarantees a more reliable and context-specific configuration, potentially preventing configuration-related errors during pyramid construction."
94551,"@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final MrsImagePyramid sourcepyramid=RasterMapOp.flushRasterMapOpOutput(source,0);
  log.info(""String_Node_Str"" + _outputName.toString());
  final Job job=new Job(getConf());
  if (bounds == null) {
    bounds=calculateBounds();
  }
  FillRasterDriver.run(job,sourcepyramid,_outputName,fill,filltype,bounds,p,jobListener,getProtectionLevel(),getProviderProperties());
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final MrsImagePyramid sourcepyramid=RasterMapOp.flushRasterMapOpOutput(source,0);
  log.info(""String_Node_Str"" + _outputName.toString());
  final Job job=new Job(createConfiguration());
  if (bounds == null) {
    bounds=calculateBounds();
  }
  FillRasterDriver.run(job,sourcepyramid,_outputName,fill,filltype,bounds,p,jobListener,getProtectionLevel(),getProviderProperties());
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","The original code uses `getConf()` to create a Job configuration, which may not provide the necessary Hadoop configuration settings for the job. The fixed code replaces `getConf()` with `createConfiguration()`, a method likely designed to generate a more comprehensive and properly configured Job configuration. This change ensures that the Job has the correct settings, potentially resolving configuration-related issues and improving the reliability of the raster processing operation."
94552,"@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final InputFormatDescriptor ifd=((VectorMapOp)_inputs.get(0)).getVectorOutput();
  if (bounds == null) {
    bounds=calculateBounds();
  }
{
    final RasterizeVectorDriver rvd=new RasterizeVectorDriver();
    final Job job=new Job(getConf());
    ifd.populateJobParameters(job);
    rvd.setValueColumn(column);
    rvd.run(job,_outputName,_aggregationType,zoomlevel,bounds,p,jobListener,getProtectionLevel(),getProviderProperties());
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","@Override public void build(final Progress p) throws IOException, JobFailedException, JobCancelledException {
  if (p != null) {
    p.starting();
  }
  final InputFormatDescriptor ifd=((VectorMapOp)_inputs.get(0)).getVectorOutput();
  if (bounds == null) {
    bounds=calculateBounds();
  }
{
    final RasterizeVectorDriver rvd=new RasterizeVectorDriver();
    final Job job=new Job(createConfiguration());
    ifd.populateJobParameters(job);
    rvd.setValueColumn(column);
    rvd.run(job,_outputName,_aggregationType,zoomlevel,bounds,p,jobListener,getProtectionLevel(),getProviderProperties());
  }
  MrsImageDataProvider dp=DataProviderFactory.getMrsImageDataProvider(_outputName,AccessMode.READ,getProviderProperties());
  _output=MrsPyramidDescriptor.create(dp);
  if (p != null) {
    p.complete();
  }
}","The original code uses `getConf()` directly to create a Job configuration, which may not provide the necessary customization for the specific job requirements. The fixed code replaces `getConf()` with `createConfiguration()`, a method likely designed to generate a more tailored and appropriate configuration for the job. This change ensures that the job is initialized with the correct settings, potentially improving job execution reliability and performance."
94553,"@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  ph.createChild(1f);
  ph.createChild(1f);
  _writeInputs(ph.getChild(0));
  _connectInputs();
  PigQuerier pq=new PigQuerier();
  log.warn(_script);
  log.warn(_outputName.toString());
  pq.query(_script,new Path(_outputName),getConf());
  ph.getChild(1).complete();
  _output=new BasicInputFormatDescriptor(_outputName);
}","@Override public void build(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  ph.createChild(1f);
  ph.createChild(1f);
  _writeInputs(ph.getChild(0));
  _connectInputs();
  PigQuerier pq=new PigQuerier();
  log.warn(_script);
  log.warn(_outputName.toString());
  pq.query(_script,new Path(_outputName),createConfiguration());
  ph.getChild(1).complete();
  _output=new BasicInputFormatDescriptor(_outputName);
}","The original code used `getConf()`, which might not provide the necessary configuration for the Pig query. The fixed code replaces `getConf()` with `createConfiguration()`, ensuring a properly initialized configuration is passed to the `PigQuerier`. This change guarantees that the Pig query has the correct configuration settings, potentially preventing runtime errors and improving the method's reliability."
94554,"/** 
 * Go through each of the MapOp inputs and write the values out to disk. If the values are already on disk then this can be skipped. This may take a while.
 * @throws IOException
 * @throws JobFailedException
 */
protected void _writeInputs(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  for (  MapOp input : _inputs) {
    if (input != null && (input instanceof VectorMapOp)) {
      if (((VectorMapOp)input).getOutputName() == null) {
        ph.createChild(1.0f);
      }
    }
  }
  _inputPaths=new ArrayList<Path>();
  int pi=0;
  for (  MapOp input : _inputs) {
    if (input != null && (input instanceof VectorMapOp)) {
      Path inputPath=new Path(((VectorMapOp)input).getOutputName());
      if (inputPath == null) {
        inputPath=new Path(HadoopFileUtils.getTempDir(),HadoopUtils.createRandomString(40) + ""String_Node_Str"");
        addTempFile(inputPath.toString());
        addTempFile(inputPath.toString() + ""String_Node_Str"");
        VectorMapOp.writeVectorOutput((InputFormatDescriptor)((VectorMapOp)input).getVectorOutput(),inputPath,getConf(),ph.getChild(pi++));
      }
      _inputPaths.add(inputPath);
    }
  }
}","/** 
 * Go through each of the MapOp inputs and write the values out to disk. If the values are already on disk then this can be skipped. This may take a while.
 * @throws IOException
 * @throws JobFailedException
 */
protected void _writeInputs(Progress p) throws IOException, JobFailedException, JobCancelledException {
  ProgressHierarchy ph=new ProgressHierarchy(p);
  for (  MapOp input : _inputs) {
    if (input != null && (input instanceof VectorMapOp)) {
      if (((VectorMapOp)input).getOutputName() == null) {
        ph.createChild(1.0f);
      }
    }
  }
  _inputPaths=new ArrayList<Path>();
  int pi=0;
  for (  MapOp input : _inputs) {
    if (input != null && (input instanceof VectorMapOp)) {
      Path inputPath=new Path(((VectorMapOp)input).getOutputName());
      if (inputPath == null) {
        inputPath=new Path(HadoopFileUtils.getTempDir(),HadoopUtils.createRandomString(40) + ""String_Node_Str"");
        addTempFile(inputPath.toString());
        addTempFile(inputPath.toString() + ""String_Node_Str"");
        VectorMapOp.writeVectorOutput((InputFormatDescriptor)((VectorMapOp)input).getVectorOutput(),inputPath,createConfiguration(),ph.getChild(pi++));
      }
      _inputPaths.add(inputPath);
    }
  }
}","The original code incorrectly used `getConf()` method, which might not return a valid configuration for writing vector output. The fixed code replaces `getConf()` with `createConfiguration()`, ensuring a fresh and properly initialized configuration is used for vector output operations. This change guarantees a more reliable and consistent configuration setup, preventing potential configuration-related errors during file writing and processing."
94555,"public void setupJob(final Configuration conf) throws DataProviderException {
  try {
    HadoopUtils.addJarCache(conf,getClass());
  }
 catch (  IOException e) {
    throw new DataProviderException(e);
  }
}","/** 
 * Perform Hadoop job setup that is required for using this ad hoc resource in a map/reduce job. This base class implementation adds the data plugin JAR to Hadoop's distributed cache to make it available on the cluster nodes as part of the job. So subclasses that override this method should always invoke this base class method.
 * @param job
 * @throws DataProviderException
 */
public void setupJob(final Job job) throws DataProviderException {
}","The original code incorrectly used a Configuration object instead of a Job object, which can lead to improper job setup and potential runtime errors. The fixed code updates the method signature to accept a Job object and provides a documentation comment explaining the purpose of adding the data plugin JAR to Hadoop's distributed cache. By using the correct Job object and providing clear documentation, the fixed code ensures proper job configuration and improves code clarity and maintainability."
94556,"/** 
 * Any sub-classes that need to override this method to do additional setup work should call super.setupJob(job) to perform default job setup too.
 */
@Override public void setupJob(Job job,final Properties providerProperties) throws DataProviderException {
  try {
    HadoopUtils.addJarCache(job,getClass());
    DataProviderFactory.saveProviderPropertiesToConfig(providerProperties,job.getConfiguration());
    context.save(job.getConfiguration());
    for (    final String input : context.getInputs()) {
      MrsImagePyramid pyramid;
      try {
        pyramid=MrsImagePyramid.open(input,context.getProviderProperties());
      }
 catch (      IOException e) {
        throw new DataProviderException(""String_Node_Str"" + input,e);
      }
      final MrsImagePyramidMetadata metadata=pyramid.getMetadata();
      log.debug(""String_Node_Str"" + input + ""String_Node_Str""+ pyramid+ ""String_Node_Str""+ metadata);
      String image=metadata.getName(context.getZoomLevel());
      if (image == null) {
        log.error(""String_Node_Str"" + context.getZoomLevel() + ""String_Node_Str""+ pyramid);
        image=metadata.getName(metadata.getMaxZoomLevel());
      }
      HadoopUtils.setMetadata(job,metadata);
    }
  }
 catch (  IOException e) {
    throw new DataProviderException(""String_Node_Str"" + context.toString(),e);
  }
}","/** 
 * Any sub-classes that need to override this method to do additional setup work should call super.setupJob(job) to perform default job setup too.
 */
@Override public void setupJob(Job job,final Properties providerProperties) throws DataProviderException {
  try {
    DataProviderFactory.saveProviderPropertiesToConfig(providerProperties,job.getConfiguration());
    context.save(job.getConfiguration());
    for (    final String input : context.getInputs()) {
      MrsImagePyramid pyramid;
      try {
        pyramid=MrsImagePyramid.open(input,context.getProviderProperties());
      }
 catch (      IOException e) {
        throw new DataProviderException(""String_Node_Str"" + input,e);
      }
      final MrsImagePyramidMetadata metadata=pyramid.getMetadata();
      log.debug(""String_Node_Str"" + input + ""String_Node_Str""+ pyramid+ ""String_Node_Str""+ metadata);
      String image=metadata.getName(context.getZoomLevel());
      if (image == null) {
        log.error(""String_Node_Str"" + context.getZoomLevel() + ""String_Node_Str""+ pyramid);
        image=metadata.getName(metadata.getMaxZoomLevel());
      }
      HadoopUtils.setMetadata(job,metadata);
    }
  }
 catch (  IOException e) {
    throw new DataProviderException(""String_Node_Str"" + context.toString(),e);
  }
}","The original code redundantly called HadoopUtils.addJarCache(), which was unnecessary and potentially causing performance overhead. The fixed code removes this method call, focusing only on essential job configuration tasks like saving provider properties and metadata. By eliminating the superfluous jar caching step, the code becomes more streamlined, reducing potential runtime complexity and improving overall job setup efficiency."
94557,"/** 
 * Sub-classes that override this method must call super.setupJob(job).
 */
@Override public void setupJob(Job job) throws DataProviderException, IOException {
  try {
    HadoopUtils.addJarCache(job,getClass());
  }
 catch (  IOException e) {
    throw new DataProviderException(e);
  }
}","/** 
 * Sub-classes that override this method must call super.setupJob(job).
 */
@Override public void setupJob(Job job) throws DataProviderException, IOException {
}","The original code attempted to add a jar cache but could potentially throw an IOException, which conflicts with the method's declared exceptions. The fixed code removes the jar cache addition, simplifying the method signature and eliminating unnecessary error handling. By removing the redundant cache mechanism, the code becomes more straightforward and reduces potential points of failure in job setup."
94558,"@Override public void setupJob(final Job job,final Properties providerProperties) throws DataProviderException {
  try {
    HadoopUtils.addJarCache(job,getClass());
    DataProviderFactory.saveProviderPropertiesToConfig(providerProperties,job.getConfiguration());
  }
 catch (  IOException e) {
    throw new DataProviderException(e);
  }
}","@Override public void setupJob(final Job job,final Properties providerProperties) throws DataProviderException {
  DataProviderFactory.saveProviderPropertiesToConfig(providerProperties,job.getConfiguration());
}","The original code unnecessarily added jar caching, which was likely redundant or not required for the job setup. The fixed code removes the `HadoopUtils.addJarCache()` method call, simplifying the job configuration process by focusing solely on saving provider properties to the job configuration. This streamlines the setup method, reducing potential overhead and eliminating an unnecessary file caching operation that may not be critical to the job's execution."
94559,"@Override public void setupJob(final Job job,final Properties providerProperties) throws DataProviderException {
  try {
    HadoopUtils.addJarCache(job,getClass());
    DataProviderFactory.saveProviderPropertiesToConfig(providerProperties,job.getConfiguration());
  }
 catch (  IOException e) {
    throw new DataProviderException(e);
  }
}","@Override public void setupJob(final Job job,final Properties providerProperties) throws DataProviderException {
  DataProviderFactory.saveProviderPropertiesToConfig(providerProperties,job.getConfiguration());
}","The original code attempted to add JAR cache to the job configuration, which is unnecessary and can introduce potential overhead and complexity. The fixed code removes the JAR caching step, simplifying the setupJob method to focus solely on saving provider properties to the job configuration. By eliminating the redundant JAR caching, the code becomes more streamlined, reduces potential error points, and maintains the core functionality of configuring the job properties."
94560,"public static void addDependencies(final Configuration conf,final Class<?> clazz) throws IOException {
  if (conf.get(""String_Node_Str"",""String_Node_Str"") == ""String_Node_Str"") {
    return;
  }
  FileSystem fs=HadoopFileUtils.getFileSystem(conf);
  Path hdfsBase=new Path(MrGeoProperties.getInstance().getProperty(MrGeoConstants.MRGEO_HDFS_DISTRIBUTED_CACHE,""String_Node_Str""));
  Set<String> existing=new HashSet<String>(conf.getStringCollection(CLASSPATH_FILES));
  boolean developmentMode=MrGeoProperties.isDevelopmentMode();
  Set<Dependency> properties=loadDependenciesByReflection(clazz);
  if (properties != null) {
    for (    File p : getJarsFromProperties(properties,!developmentMode)) {
      addFileToClasspath(conf,existing,fs,hdfsBase,p);
    }
    for (    Dependency d : properties) {
      if (d.master) {
        Set<Dependency> master=new HashSet<Dependency>();
        master.add(d);
        for (        File m : getJarsFromProperties(master,!developmentMode)) {
          log.debug(""String_Node_Str"" + m.getCanonicalPath());
          conf.set(""String_Node_Str"",m.getCanonicalPath());
        }
      }
    }
  }
 else {
    log.warn(""String_Node_Str"" + clazz.getName());
  }
}","public static void addDependencies(final Configuration conf,final Class<?> clazz) throws IOException {
  if (conf.get(""String_Node_Str"",""String_Node_Str"") == ""String_Node_Str"") {
    return;
  }
  FileSystem fs=HadoopFileUtils.getFileSystem(conf);
  Path hdfsBase=new Path(MrGeoProperties.getInstance().getProperty(MrGeoConstants.MRGEO_HDFS_DISTRIBUTED_CACHE,""String_Node_Str""));
  Set<String> existing=getClasspath(conf);
  boolean developmentMode=MrGeoProperties.isDevelopmentMode();
  Set<Dependency> properties=loadDependenciesByReflection(clazz);
  if (properties != null) {
    for (    File p : getJarsFromProperties(properties,!developmentMode)) {
      addFileToClasspath(conf,existing,fs,hdfsBase,p);
    }
    for (    Dependency d : properties) {
      if (d.master) {
        Set<Dependency> master=new HashSet<Dependency>();
        master.add(d);
        for (        File m : getJarsFromProperties(master,!developmentMode)) {
          log.debug(""String_Node_Str"" + m.getCanonicalPath());
          conf.set(""String_Node_Str"",m.getCanonicalPath());
        }
      }
    }
  }
 else {
    log.warn(""String_Node_Str"" + clazz.getName());
  }
}","The original code incorrectly used `conf.getStringCollection(CLASSPATH_FILES)` without ensuring its existence, potentially causing null pointer or incomplete classpath issues. The fixed code replaces this with `getClasspath(conf)`, which likely provides a safer and more reliable method of retrieving the classpath. This change improves the method's robustness by ensuring a consistent and reliable way of managing classpath dependencies across different configuration scenarios."
94561,"private static void addClassPath(Job job,FileSystem fs,Path hdfsBase) throws IOException {
  HadoopFileUtils.create(job.getConfiguration(),hdfsBase);
  Configuration conf=job.getConfiguration();
  Set<String> existing=new HashSet<String>(conf.getStringCollection(CLASSPATH_FILES));
  String cpstr=System.getProperty(""String_Node_Str"");
  for (  String env : cpstr.split(""String_Node_Str"")) {
    addFilesToClassPath(conf,existing,fs,hdfsBase,env);
  }
}","private static void addClassPath(Job job,FileSystem fs,Path hdfsBase) throws IOException {
  HadoopFileUtils.create(job.getConfiguration(),hdfsBase);
  Configuration conf=job.getConfiguration();
  Set<String> existing=getClasspath(conf);
  String cpstr=System.getProperty(""String_Node_Str"");
  for (  String env : cpstr.split(""String_Node_Str"")) {
    addFilesToClassPath(conf,existing,fs,hdfsBase,env);
  }
}","The original code directly uses `conf.getStringCollection(CLASSPATH_FILES)`, which might not correctly retrieve the existing classpath entries. The fixed code introduces a method `getClasspath(conf)` to properly extract and manage existing classpath entries, ensuring a more robust and reliable approach to classpath management. By abstracting the classpath retrieval logic, the code becomes more flexible, maintainable, and less prone to potential configuration-related errors."
94562,"@Transactional public User registerNewUser(User user) throws UserExistsException {
  if (emailExist(user.getEmail())) {
    throw new UserExistsException(""String_Node_Str"");
  }
  if (userNameExist(user.getEmail())) {
    throw new UserExistsException(""String_Node_Str"");
  }
  return userRepository.save(user);
}","@Transactional public User registerNewUser(User user) throws UserExistsException {
  if (emailExist(user.getEmail())) {
    throw new UserExistsException(""String_Node_Str"");
  }
  if (userNameExist(user.getUserName())) {
    throw new UserExistsException(""String_Node_Str"");
  }
  return userRepository.save(user);
}","The buggy code incorrectly checks username existence using `user.getEmail()` instead of `user.getUserName()`, which could allow duplicate usernames to be registered. The fixed code correctly uses `user.getUserName()` when checking for existing usernames, ensuring proper validation of unique user credentials. This change prevents potential username conflicts and maintains data integrity during user registration."
94563,"@Bean public Object aliGreenJob(GreenService greenService){
  return new Object(){
    @Scheduled(fixedRate=60000) public void submitTask(){
      imgFileRepository.findByGreenStatus(0).forEach(img -> {
        String taskId=greenService.asyncDetect(""String_Node_Str"" + img.getShortName());
        imgFileRepository.updateTaskIdById(taskId,img.getId());
        imgFileRepository.updateGreenStatusById(1,img.getId());
      }
);
    }
    @Scheduled(fixedRate=120000) public void getResult(){
      imgFileRepository.findByGreenStatus(1).forEach(img -> {
        float checkResult=greenService.getCheckResult(img.getGreenTaskId());
        boolean porn=checkResult > 90;
        imgFileRepository.updateGreenStatusById(porn ? 3 : 4,img.getId());
        imgFileRepository.updateGreenPointById(checkResult,img.getId());
      }
);
    }
  }
;
}","@Bean public Object aliGreenJob(GreenService greenService){
  return new Object(){
    @Scheduled(fixedRate=60000) public void submitTask(){
      imgFileRepository.findByGreenStatus(0).forEach(img -> {
        String taskId=greenService.asyncDetect(""String_Node_Str"" + img.getShortName());
        imgFileRepository.updateTaskIdById(taskId,img.getId());
        imgFileRepository.updateGreenStatusById(1,img.getId());
      }
);
    }
    @Scheduled(fixedRate=120000) public void getResult(){
      imgFileRepository.findByGreenStatus(1).forEach(img -> {
        try {
          float checkResult=greenService.getCheckResult(img.getGreenTaskId());
          boolean porn=checkResult > 90;
          imgFileRepository.updateGreenStatusById(porn ? 3 : 5,img.getId());
          imgFileRepository.updateGreenPointById(checkResult,img.getId());
        }
 catch (        Exception e) {
          imgFileRepository.updateGreenStatusById(4,img.getId());
        }
      }
);
    }
  }
;
}","The original code lacks error handling for potential exceptions during the green detection result retrieval, which could lead to unhandled runtime errors. The fixed code introduces a try-catch block that gracefully handles exceptions by setting the green status to 4 if an error occurs during result checking. This improvement ensures robust error management, prevents potential application crashes, and provides a fallback mechanism for handling unexpected issues in the green detection process."
94564,"@Scheduled(fixedRate=120000) public void getResult(){
  imgFileRepository.findByGreenStatus(1).forEach(img -> {
    float checkResult=greenService.getCheckResult(img.getGreenTaskId());
    boolean porn=checkResult > 90;
    imgFileRepository.updateGreenStatusById(porn ? 3 : 4,img.getId());
    imgFileRepository.updateGreenPointById(checkResult,img.getId());
  }
);
}","@Scheduled(fixedRate=120000) public void getResult(){
  imgFileRepository.findByGreenStatus(1).forEach(img -> {
    try {
      float checkResult=greenService.getCheckResult(img.getGreenTaskId());
      boolean porn=checkResult > 90;
      imgFileRepository.updateGreenStatusById(porn ? 3 : 5,img.getId());
      imgFileRepository.updateGreenPointById(checkResult,img.getId());
    }
 catch (    Exception e) {
      imgFileRepository.updateGreenStatusById(4,img.getId());
    }
  }
);
}","The original code lacked error handling, potentially leaving images in an unresolved state if the green service check fails. The fixed code adds a try-catch block to handle exceptions, updating the image status to 4 (likely representing an error state) if any issue occurs during processing. This approach ensures robust error management, preventing data inconsistencies and providing a fallback mechanism for problematic image checks."
94565,"/** 
 * change camera flash mode
 */
public final int changeFlash(){
  if (mCamera == null) {
    return -1;
  }
  Camera.Parameters parameters=mCamera.getParameters();
  List<String> FlashModes=parameters.getSupportedFlashModes();
  if (FlashModes == null) {
    return 0;
  }
  if (onCameraSelectListener != null) {
    onCameraSelectListener.onChangeFlashMode((flash_type) % 3);
  }
  Log.i(TAG,""String_Node_Str"" + flash_type);
switch (flash_type % 3) {
case FLASH_ON:
    if (FlashModes.contains(Camera.Parameters.FLASH_MODE_ON)) {
      parameters.setFlashMode(Camera.Parameters.FLASH_MODE_ON);
      flash_type++;
      mCamera.setParameters(parameters);
    }
  break;
case FLASH_OFF:
if (FlashModes.contains(Camera.Parameters.FLASH_MODE_OFF)) {
  parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
  flash_type++;
  mCamera.setParameters(parameters);
}
break;
case FLASH_AUTO:
if (FlashModes.contains(Camera.Parameters.FLASH_MODE_AUTO)) {
parameters.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO);
flash_type++;
mCamera.setParameters(parameters);
}
break;
default :
if (FlashModes.contains(Camera.Parameters.FLASH_MODE_OFF)) {
parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
flash_type++;
mCamera.setParameters(parameters);
}
break;
}
return flash_type;
}","/** 
 * change camera flash mode
 */
public final int changeFlash(){
  if (mCamera == null) {
    return -1;
  }
  Camera.Parameters parameters=mCamera.getParameters();
  List<String> flashModes=parameters.getSupportedFlashModes();
  if (flashModes == null || flashModes.size() <= 1) {
    return 0;
  }
  if (onCameraSelectListener != null) {
    onCameraSelectListener.onChangeFlashMode((flash_type) % 3);
  }
  Log.i(TAG,""String_Node_Str"" + flash_type);
switch (flash_type % 3) {
case FLASH_ON:
    if (flashModes.contains(Camera.Parameters.FLASH_MODE_ON)) {
      parameters.setFlashMode(Camera.Parameters.FLASH_MODE_ON);
      flash_type++;
      mCamera.setParameters(parameters);
    }
  break;
case FLASH_OFF:
if (flashModes.contains(Camera.Parameters.FLASH_MODE_OFF)) {
  parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
  flash_type++;
  mCamera.setParameters(parameters);
}
break;
case FLASH_AUTO:
if (flashModes.contains(Camera.Parameters.FLASH_MODE_AUTO)) {
parameters.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO);
flash_type++;
mCamera.setParameters(parameters);
}
break;
default :
if (flashModes.contains(Camera.Parameters.FLASH_MODE_OFF)) {
parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
flash_type++;
mCamera.setParameters(parameters);
}
break;
}
return flash_type;
}","The original code lacked proper handling of flash mode availability, potentially causing runtime errors when checking supported flash modes. The fixed code adds a null and size check on `flashModes` to ensure at least one flash mode is available before attempting to change settings. This improvement prevents potential crashes and provides more robust flash mode switching by verifying the device's camera capabilities before modifying parameters."
94566,"public static boolean generate(){
  devices=new LinkedList<GPUDevice>();
  OS os=OS.getOS();
  String path=os.getCUDALib();
  if (path == null) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  CUDA cudalib=null;
  try {
    cudalib=(CUDA)Native.loadLibrary(path,CUDA.class);
  }
 catch (  java.lang.UnsatisfiedLinkError e) {
    System.out.println(""String_Node_Str"" + path + ""String_Node_Str"");
    return false;
  }
catch (  java.lang.ExceptionInInitializerError e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
  int result=CUresult.CUDA_ERROR_UNKNOWN;
  result=cudalib.cuInit(0);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + result + ""String_Node_Str"");
    if (result == CUresult.CUDA_ERROR_UNKNOWN) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    return false;
  }
  if (result == CUresult.CUDA_ERROR_NO_DEVICE) {
    return false;
  }
  IntByReference count=new IntByReference();
  result=cudalib.cuDeviceGetCount(count);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
    return false;
  }
  for (int num=0; num < count.getValue(); num++) {
    byte name[]=new byte[256];
    result=cudalib.cuDeviceGetName(name,256,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    LongByReference ram=new LongByReference();
    try {
      result=cudalib.cuDeviceTotalMem_v2(ram,num);
    }
 catch (    UnsatisfiedLinkError e) {
      result=cudalib.cuDeviceTotalMem(ram,num);
    }
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      return false;
    }
    devices.add(new GPUDevice(new String(name).trim(),ram.getValue(),""String_Node_Str"" + Integer.toString(num)));
  }
  return true;
}","public static boolean generate(){
  devices=new LinkedList<GPUDevice>();
  OS os=OS.getOS();
  String path=os.getCUDALib();
  if (path == null) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  CUDA cudalib=null;
  try {
    cudalib=(CUDA)Native.loadLibrary(path,CUDA.class);
  }
 catch (  java.lang.UnsatisfiedLinkError e) {
    System.out.println(""String_Node_Str"" + path + ""String_Node_Str"");
    return false;
  }
catch (  java.lang.ExceptionInInitializerError e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
  int result=CUresult.CUDA_ERROR_UNKNOWN;
  result=cudalib.cuInit(0);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + result + ""String_Node_Str"");
    if (result == CUresult.CUDA_ERROR_UNKNOWN) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    return false;
  }
  if (result == CUresult.CUDA_ERROR_NO_DEVICE) {
    return false;
  }
  IntByReference count=new IntByReference();
  result=cudalib.cuDeviceGetCount(count);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
    return false;
  }
  HashMap<Integer,GPUDevice> devicesWithPciId=new HashMap<Integer,GPUDevice>(count.getValue());
  for (int num=0; num < count.getValue(); num++) {
    IntByReference aDevice=new IntByReference();
    result=cudalib.cuDeviceGet(aDevice,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    IntByReference pciBusId=new IntByReference();
    result=cudalib.cuDeviceGetAttribute(pciBusId,CUDeviceAttribute.CU_DEVICE_ATTRIBUTE_PCI_BUS_ID,aDevice.getValue());
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    byte name[]=new byte[256];
    result=cudalib.cuDeviceGetName(name,256,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    LongByReference ram=new LongByReference();
    try {
      result=cudalib.cuDeviceTotalMem_v2(ram,num);
    }
 catch (    UnsatisfiedLinkError e) {
      result=cudalib.cuDeviceTotalMem(ram,num);
    }
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      return false;
    }
    devicesWithPciId.put(pciBusId.getValue(),new GPUDevice(new String(name).trim(),ram.getValue(),""String_Node_Str""));
  }
  int i=0;
  for (  HashMap.Entry<Integer,GPUDevice> entry : devicesWithPciId.entrySet()) {
    GPUDevice aDevice=entry.getValue();
    aDevice.setCudaName(""String_Node_Str"" + Integer.toString(i));
    devices.add(aDevice);
    i++;
  }
  return true;
}","The original code lacked proper device identification and could potentially assign incorrect or duplicate CUDA names to GPU devices. The fixed code introduces a HashMap to track devices by PCI bus ID, ensuring unique identification and allowing for correct device naming with sequential CUDA names. This approach provides more robust and accurate GPU device enumeration, preventing potential conflicts and improving the reliability of device detection and naming."
94567,"public Error.Type render(){
  gui.status(""String_Node_Str"");
  RenderProcess process=getProcessRender();
  Timer timerOfMaxRenderTime=null;
  String core_script=""String_Node_Str"";
  String ignore_signal_script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  if (getUseGPU() && config.getGPUDevice() != null && config.getComputeMethod() != ComputeType.CPU) {
    core_script=""String_Node_Str"" + config.getGPUDevice().getCudaName() + ""String_Node_Str"";
    gui.setComputeMethod(""String_Node_Str"");
  }
 else {
    core_script=""String_Node_Str"";
    gui.setComputeMethod(""String_Node_Str"");
  }
  core_script+=ignore_signal_script;
  core_script+=String.format(""String_Node_Str"",getTileSize());
  File script_file=null;
  String command1[]=getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (config.getNbCores() > 0) {
    size_command+=2;
  }
  List<String> command=new ArrayList<String>(size_command);
  Map<String,String> new_env=new HashMap<String,String>();
  new_env.put(""String_Node_Str"",config.workingDirectory.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
  new_env.put(""String_Node_Str"",Integer.toString(config.getNbCores()));
  new_env.put(""String_Node_Str"",Integer.toString(config.getPriority()));
  for (  String arg : command1) {
switch (arg) {
case ""String_Node_Str"":
      command.add(getScenePath());
    command.add(""String_Node_Str"");
  try {
    script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",config.workingDirectory);
    File file=new File(script_file.getAbsolutePath());
    FileWriter txt;
    txt=new FileWriter(file);
    PrintWriter out=new PrintWriter(txt);
    out.write(getScript());
    out.write(""String_Node_Str"");
    out.write(core_script);
    out.write(""String_Node_Str"");
    out.close();
    command.add(script_file.getAbsolutePath());
  }
 catch (  IOException e) {
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
    return Error.Type.UNKNOWN;
  }
script_file.deleteOnExit();
break;
case ""String_Node_Str"":
command.add(getRendererPath());
if (config.getNbCores() > 0) {
command.add(""String_Node_Str"");
command.add(Integer.toString(config.getNbCores()));
}
break;
case ""String_Node_Str"":
command.add(config.workingDirectory.getAbsolutePath() + File.separator + getPrefixOutputImage());
break;
case ""String_Node_Str"":
command.add(getFrameNumber());
break;
default :
command.add(arg);
break;
}
}
try {
String line;
log.debug(command.toString());
OS os=OS.getOS();
process.setCoresUsed(config.getNbCores());
process.start();
getProcessRender().setProcess(os.exec(command,new_env));
BufferedReader input=new BufferedReader(new InputStreamReader(getProcessRender().getProcess().getInputStream()));
if (config.getMaxRenderTime() > 0) {
timerOfMaxRenderTime=new Timer();
timerOfMaxRenderTime.schedule(new TimerTask(){
@Override public void run(){
RenderProcess process=getProcessRender();
if (process != null) {
long duration=(new Date().getTime() - process.getStartTime()) / 1000;
if (config.getMaxRenderTime() > 0 && duration > config.getMaxRenderTime()) {
log.debug(""String_Node_Str"");
OS.getOS().kill(process.getProcess());
setAskForRendererKill(true);
}
}
}
}
,config.getMaxRenderTime() * 1000 + 2000);
}
long last_update_status=0;
log.debug(""String_Node_Str"");
try {
while ((line=input.readLine()) != null) {
log.debug(line);
updateRenderingMemoryPeak(line);
if (config.getMaxMemory() != -1 && process.getMemoryUsed() > config.getMaxMemory()) {
log.debug(""String_Node_Str"" + process.getMemoryUsed() + ""String_Node_Str""+ config.getMaxMemory()+ ""String_Node_Str"");
process.finish();
if (script_file != null) {
script_file.delete();
}
return Error.Type.RENDERER_OUT_OF_MEMORY;
}
if ((new Date().getTime() - last_update_status) > 2000) {
updateRenderingStatus(line);
last_update_status=new Date().getTime();
}
Type error=detectError(line);
if (error != Error.Type.OK) {
if (script_file != null) {
script_file.delete();
}
return error;
}
}
input.close();
}
 catch (IOException err1) {
log.error(""String_Node_Str"" + err1);
}
log.debug(""String_Node_Str"");
}
 catch (Exception err) {
if (script_file != null) {
script_file.delete();
}
StringWriter sw=new StringWriter();
err.printStackTrace(new PrintWriter(sw));
log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
return Error.Type.FAILED_TO_EXECUTE;
}
int exit_value=process.exitValue();
process.finish();
if (timerOfMaxRenderTime != null) {
timerOfMaxRenderTime.cancel();
}
if (script_file != null) {
script_file.delete();
}
final String filename_without_extension=getPrefixOutputImage() + getFrameNumber();
FilenameFilter textFilter=new FilenameFilter(){
public boolean accept(File dir,String name){
return name.startsWith(filename_without_extension);
}
}
;
File[] files=config.workingDirectory.listFiles(textFilter);
if (getAskForRendererKill()) {
log.debug(""String_Node_Str"");
long duration=(new Date().getTime() - process.getStartTime()) / 1000;
if (config.getMaxRenderTime() > 0 && duration > config.getMaxRenderTime()) {
log.debug(""String_Node_Str"" + duration + ""String_Node_Str""+ config.getMaxRenderTime()+ ""String_Node_Str"");
return Error.Type.RENDERER_KILLED_BY_USER_OVER_TIME;
}
if (files.length != 0) {
new File(files[0].getAbsolutePath()).delete();
}
if (getServerBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_SERVER;
}
if (getUserBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_USER;
}
return Error.Type.RENDERER_KILLED;
}
if (files.length == 0) {
log.error(""String_Node_Str"" + filename_without_extension + ""String_Node_Str"");
String basename=""String_Node_Str"";
try {
basename=getPath().substring(0,getPath().lastIndexOf('.'));
}
 catch (Exception e) {
e.printStackTrace();
}
File crash_file=new File(config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
if (crash_file.exists()) {
log.error(""String_Node_Str"");
crash_file.delete();
return Error.Type.RENDERER_CRASHED;
}
if (exit_value == 127 && process.getDuration() < 10) {
log.error(""String_Node_Str"" + process.getDuration() + ""String_Node_Str"");
return Error.Type.RENDERER_MISSING_LIBRARIES;
}
return Error.Type.NOOUTPUTFILE;
}
 else {
setOutputImagePath(files[0].getAbsolutePath());
log.debug(""String_Node_Str"" + getOutputImagePath() + ""String_Node_Str"");
}
File scene_dir=new File(getSceneDirectory());
long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
if (date_modification_scene_directory > process.getStartTime()) {
scene_dir.delete();
}
gui.status(String.format(""String_Node_Str"",process.getDuration() / 60,process.getDuration() % 60));
return Error.Type.OK;
}","public Error.Type render(){
  gui.status(""String_Node_Str"");
  RenderProcess process=getProcessRender();
  Timer timerOfMaxRenderTime=null;
  String core_script=""String_Node_Str"";
  String ignore_signal_script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  if (getUseGPU() && config.getGPUDevice() != null && config.getComputeMethod() != ComputeType.CPU) {
    core_script=""String_Node_Str"" + config.getGPUDevice().getCudaName() + ""String_Node_Str"";
    gui.setComputeMethod(""String_Node_Str"");
  }
 else {
    core_script=""String_Node_Str"";
    gui.setComputeMethod(""String_Node_Str"");
  }
  core_script+=ignore_signal_script;
  core_script+=String.format(""String_Node_Str"",getTileSize());
  File script_file=null;
  String command1[]=getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (config.getNbCores() > 0) {
    size_command+=2;
  }
  List<String> command=new ArrayList<String>(size_command);
  Map<String,String> new_env=new HashMap<String,String>();
  new_env.put(""String_Node_Str"",config.workingDirectory.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
  new_env.put(""String_Node_Str"",Integer.toString(config.getNbCores()));
  new_env.put(""String_Node_Str"",Integer.toString(config.getPriority()));
  for (  String arg : command1) {
switch (arg) {
case ""String_Node_Str"":
      command.add(getScenePath());
    command.add(""String_Node_Str"");
  try {
    script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",config.workingDirectory);
    File file=new File(script_file.getAbsolutePath());
    FileWriter txt;
    txt=new FileWriter(file);
    PrintWriter out=new PrintWriter(txt);
    out.write(getScript());
    out.write(""String_Node_Str"");
    out.write(core_script);
    out.write(""String_Node_Str"");
    out.close();
    command.add(script_file.getAbsolutePath());
  }
 catch (  IOException e) {
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
    return Error.Type.UNKNOWN;
  }
script_file.deleteOnExit();
break;
case ""String_Node_Str"":
command.add(getRendererPath());
if (config.getNbCores() > 0) {
command.add(""String_Node_Str"");
command.add(Integer.toString(config.getNbCores()));
}
break;
case ""String_Node_Str"":
command.add(config.workingDirectory.getAbsolutePath() + File.separator + getPrefixOutputImage());
break;
case ""String_Node_Str"":
command.add(getFrameNumber());
break;
default :
command.add(arg);
break;
}
}
try {
String line;
log.debug(command.toString());
OS os=OS.getOS();
process.setCoresUsed(config.getNbCores());
process.start();
getProcessRender().setProcess(os.exec(command,new_env));
BufferedReader input=new BufferedReader(new InputStreamReader(getProcessRender().getProcess().getInputStream()));
if (config.getMaxRenderTime() > 0) {
timerOfMaxRenderTime=new Timer();
timerOfMaxRenderTime.schedule(new TimerTask(){
@Override public void run(){
RenderProcess process=getProcessRender();
if (process != null) {
long duration=(new Date().getTime() - process.getStartTime()) / 1000;
if (config.getMaxRenderTime() > 0 && duration > config.getMaxRenderTime()) {
log.debug(""String_Node_Str"");
OS.getOS().kill(process.getProcess());
setAskForRendererKill(true);
}
}
}
}
,config.getMaxRenderTime() * 1000 + 2000);
}
long last_update_status=0;
log.debug(""String_Node_Str"");
try {
while ((line=input.readLine()) != null) {
log.debug(line);
updateRenderingMemoryPeak(line);
if (config.getMaxMemory() != -1 && process.getMemoryUsed() > config.getMaxMemory()) {
log.debug(""String_Node_Str"" + process.getMemoryUsed() + ""String_Node_Str""+ config.getMaxMemory()+ ""String_Node_Str"");
OS.getOS().kill(process.getProcess());
process.finish();
if (script_file != null) {
script_file.delete();
}
return Error.Type.RENDERER_OUT_OF_MEMORY;
}
if ((new Date().getTime() - last_update_status) > 2000) {
updateRenderingStatus(line);
last_update_status=new Date().getTime();
}
Type error=detectError(line);
if (error != Error.Type.OK) {
if (script_file != null) {
script_file.delete();
}
return error;
}
}
input.close();
}
 catch (IOException err1) {
log.error(""String_Node_Str"" + err1);
}
log.debug(""String_Node_Str"");
}
 catch (Exception err) {
if (script_file != null) {
script_file.delete();
}
StringWriter sw=new StringWriter();
err.printStackTrace(new PrintWriter(sw));
log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
return Error.Type.FAILED_TO_EXECUTE;
}
int exit_value=process.exitValue();
process.finish();
if (timerOfMaxRenderTime != null) {
timerOfMaxRenderTime.cancel();
}
if (script_file != null) {
script_file.delete();
}
final String filename_without_extension=getPrefixOutputImage() + getFrameNumber();
FilenameFilter textFilter=new FilenameFilter(){
public boolean accept(File dir,String name){
return name.startsWith(filename_without_extension);
}
}
;
File[] files=config.workingDirectory.listFiles(textFilter);
if (getAskForRendererKill()) {
log.debug(""String_Node_Str"");
long duration=(new Date().getTime() - process.getStartTime()) / 1000;
if (config.getMaxRenderTime() > 0 && duration > config.getMaxRenderTime()) {
log.debug(""String_Node_Str"" + duration + ""String_Node_Str""+ config.getMaxRenderTime()+ ""String_Node_Str"");
return Error.Type.RENDERER_KILLED_BY_USER_OVER_TIME;
}
if (files.length != 0) {
new File(files[0].getAbsolutePath()).delete();
}
if (getServerBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_SERVER;
}
if (getUserBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_USER;
}
return Error.Type.RENDERER_KILLED;
}
if (files.length == 0) {
log.error(""String_Node_Str"" + filename_without_extension + ""String_Node_Str"");
String basename=""String_Node_Str"";
try {
basename=getPath().substring(0,getPath().lastIndexOf('.'));
}
 catch (Exception e) {
e.printStackTrace();
}
File crash_file=new File(config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
if (crash_file.exists()) {
log.error(""String_Node_Str"");
crash_file.delete();
return Error.Type.RENDERER_CRASHED;
}
if (exit_value == 127 && process.getDuration() < 10) {
log.error(""String_Node_Str"" + process.getDuration() + ""String_Node_Str"");
return Error.Type.RENDERER_MISSING_LIBRARIES;
}
return Error.Type.NOOUTPUTFILE;
}
 else {
setOutputImagePath(files[0].getAbsolutePath());
log.debug(""String_Node_Str"" + getOutputImagePath() + ""String_Node_Str"");
}
File scene_dir=new File(getSceneDirectory());
long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
if (date_modification_scene_directory > process.getStartTime()) {
scene_dir.delete();
}
gui.status(String.format(""String_Node_Str"",process.getDuration() / 60,process.getDuration() % 60));
return Error.Type.OK;
}","The original code lacked proper process termination when encountering memory overflow, potentially leaving render processes hanging. The fixed code adds OS.getOS().kill(process.getProcess()) to forcefully terminate the rendering process when memory exceeds the configured maximum. This improvement ensures more robust memory management, preventing resource leaks and providing a cleaner mechanism for handling out-of-memory scenarios during rendering."
94568,"public static boolean generate(){
  devices=new LinkedList<GPUDevice>();
  OS os=OS.getOS();
  String path=os.getCUDALib();
  if (path == null) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  CUDA cudalib=null;
  try {
    cudalib=(CUDA)Native.loadLibrary(path,CUDA.class);
  }
 catch (  java.lang.UnsatisfiedLinkError e) {
    System.out.println(""String_Node_Str"" + path + ""String_Node_Str"");
    return false;
  }
catch (  java.lang.ExceptionInInitializerError e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
  int result=CUresult.CUDA_ERROR_UNKNOWN;
  result=cudalib.cuInit(0);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + result + ""String_Node_Str"");
    if (result == CUresult.CUDA_ERROR_UNKNOWN) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    return false;
  }
  if (result == CUresult.CUDA_ERROR_NO_DEVICE) {
    return false;
  }
  IntByReference count=new IntByReference();
  result=cudalib.cuDeviceGetCount(count);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
    return false;
  }
  HashMap<Integer,GPUDevice> devicesWithPciId=new HashMap<Integer,GPUDevice>(count.getValue());
  for (int num=0; num < count.getValue(); num++) {
    IntByReference aDevice=new IntByReference();
    result=cudalib.cuDeviceGet(aDevice,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    IntByReference pciBusId=new IntByReference();
    result=cudalib.cuDeviceGetAttribute(pciBusId,CUDeviceAttribute.CU_DEVICE_ATTRIBUTE_PCI_BUS_ID,aDevice.getValue());
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    byte name[]=new byte[256];
    result=cudalib.cuDeviceGetName(name,256,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    LongByReference ram=new LongByReference();
    try {
      result=cudalib.cuDeviceTotalMem_v2(ram,num);
    }
 catch (    UnsatisfiedLinkError e) {
      result=cudalib.cuDeviceTotalMem(ram,num);
    }
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      return false;
    }
    devicesWithPciId.put(pciBusId.getValue(),new GPUDevice(new String(name).trim(),ram.getValue(),""String_Node_Str""));
  }
  int i=0;
  for (  HashMap.Entry<Integer,GPUDevice> entry : devicesWithPciId.entrySet()) {
    GPUDevice aDevice=entry.getValue();
    aDevice.setCudaName(""String_Node_Str"" + Integer.toString(i));
    devices.add(aDevice);
    i++;
  }
  return true;
}","public static boolean generate(){
  devices=new LinkedList<GPUDevice>();
  OS os=OS.getOS();
  String path=os.getCUDALib();
  if (path == null) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  CUDA cudalib=null;
  try {
    cudalib=(CUDA)Native.loadLibrary(path,CUDA.class);
  }
 catch (  java.lang.UnsatisfiedLinkError e) {
    System.out.println(""String_Node_Str"" + path + ""String_Node_Str"");
    return false;
  }
catch (  java.lang.ExceptionInInitializerError e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
  int result=CUresult.CUDA_ERROR_UNKNOWN;
  result=cudalib.cuInit(0);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + result + ""String_Node_Str"");
    if (result == CUresult.CUDA_ERROR_UNKNOWN) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    return false;
  }
  if (result == CUresult.CUDA_ERROR_NO_DEVICE) {
    return false;
  }
  IntByReference count=new IntByReference();
  result=cudalib.cuDeviceGetCount(count);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
    return false;
  }
  HashMap<Integer,GPUDevice> devicesWithPciId=new HashMap<Integer,GPUDevice>(count.getValue());
  for (int num=0; num < count.getValue(); num++) {
    IntByReference aDevice=new IntByReference();
    result=cudalib.cuDeviceGet(aDevice,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    IntByReference pciBusId=new IntByReference();
    result=cudalib.cuDeviceGetAttribute(pciBusId,CUDeviceAttribute.CU_DEVICE_ATTRIBUTE_PCI_BUS_ID,aDevice.getValue());
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    byte name[]=new byte[256];
    result=cudalib.cuDeviceGetName(name,256,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    LongByReference ram=new LongByReference();
    try {
      result=cudalib.cuDeviceTotalMem_v2(ram,num);
    }
 catch (    UnsatisfiedLinkError e) {
      result=cudalib.cuDeviceTotalMem(ram,num);
    }
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      return false;
    }
    devicesWithPciId.put(pciBusId.getValue(),new GPUDevice(new String(name).trim(),ram.getValue(),""String_Node_Str""));
  }
  int i=0;
  for (  Map.Entry<Integer,GPUDevice> entry : devicesWithPciId.entrySet()) {
    GPUDevice aDevice=entry.getValue();
    aDevice.setCudaName(""String_Node_Str"" + Integer.toString(i));
    devices.add(aDevice);
    i++;
  }
  return true;
}","The original code used `HashMap.Entry` without explicitly importing `HashMap`, which could lead to compilation errors. In the fixed code, `HashMap.Entry` was replaced with the fully qualified `Map.Entry`, ensuring proper interface usage and resolving potential type resolution issues. This change improves code clarity, maintainability, and prevents potential compilation errors by explicitly specifying the correct interface for iterating over map entries."
94569,"public static boolean generate(){
  devices=new LinkedList<GPUDevice>();
  OS os=OS.getOS();
  String path=os.getCUDALib();
  if (path == null) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  CUDA cudalib=null;
  try {
    cudalib=(CUDA)Native.loadLibrary(path,CUDA.class);
  }
 catch (  java.lang.UnsatisfiedLinkError e) {
    System.out.println(""String_Node_Str"" + path + ""String_Node_Str"");
    return false;
  }
catch (  java.lang.ExceptionInInitializerError e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
  int result=CUresult.CUDA_ERROR_UNKNOWN;
  result=cudalib.cuInit(0);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + result + ""String_Node_Str"");
    if (result == CUresult.CUDA_ERROR_UNKNOWN) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    return false;
  }
  if (result == CUresult.CUDA_ERROR_NO_DEVICE) {
    return false;
  }
  IntByReference count=new IntByReference();
  result=cudalib.cuDeviceGetCount(count);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
    return false;
  }
  for (int num=0; num < count.getValue(); num++) {
    byte name[]=new byte[256];
    result=cudalib.cuDeviceGetName(name,256,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    LongByReference ram=new LongByReference();
    result=cudalib.cuDeviceTotalMem(ram,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      return false;
    }
    devices.add(new GPUDevice(new String(name).trim(),ram.getValue(),""String_Node_Str"" + Integer.toString(num)));
  }
  return true;
}","public static boolean generate(){
  devices=new LinkedList<GPUDevice>();
  OS os=OS.getOS();
  String path=os.getCUDALib();
  if (path == null) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  CUDA cudalib=null;
  try {
    cudalib=(CUDA)Native.loadLibrary(path,CUDA.class);
  }
 catch (  java.lang.UnsatisfiedLinkError e) {
    System.out.println(""String_Node_Str"" + path + ""String_Node_Str"");
    return false;
  }
catch (  java.lang.ExceptionInInitializerError e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
  int result=CUresult.CUDA_ERROR_UNKNOWN;
  result=cudalib.cuInit(0);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + result + ""String_Node_Str"");
    if (result == CUresult.CUDA_ERROR_UNKNOWN) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    return false;
  }
  if (result == CUresult.CUDA_ERROR_NO_DEVICE) {
    return false;
  }
  IntByReference count=new IntByReference();
  result=cudalib.cuDeviceGetCount(count);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
    return false;
  }
  for (int num=0; num < count.getValue(); num++) {
    byte name[]=new byte[256];
    result=cudalib.cuDeviceGetName(name,256,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    LongByReference ram=new LongByReference();
    try {
      result=cudalib.cuDeviceTotalMem_v2(ram,num);
    }
 catch (    UnsatisfiedLinkError e) {
      result=cudalib.cuDeviceTotalMem(ram,num);
    }
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      return false;
    }
    devices.add(new GPUDevice(new String(name).trim(),ram.getValue(),""String_Node_Str"" + Integer.toString(num)));
  }
  return true;
}",The original code used an outdated CUDA library method `cuDeviceTotalMem()` which might cause compatibility issues with newer CUDA versions. The fixed code adds a fallback mechanism by first attempting to use `cuDeviceTotalMem_v2()` and then gracefully falling back to the older method if an `UnsatisfiedLinkError` occurs. This approach ensures broader compatibility across different CUDA library versions and prevents potential runtime errors when detecting GPU device memory.
94570,"public int HTTPGetFile(String url_,String destination_,Gui gui_,String status_) throws FermeExceptionNoSpaceLeftOnDevice {
  try {
    HttpURLConnection httpCon=this.HTTPRequest(url_);
    InputStream inStrm=httpCon.getInputStream();
    if (httpCon.getResponseCode() != HttpURLConnection.HTTP_OK) {
      this.log.error(""String_Node_Str"" + url_ + ""String_Node_Str""+ HttpURLConnection.HTTP_OK+ ""String_Node_Str""+ httpCon.getResponseCode());
      return -1;
    }
    int size=httpCon.getContentLength();
    long start=new Date().getTime();
    FileOutputStream fos=new FileOutputStream(destination_);
    byte[] ch=new byte[512 * 1024];
    int nb;
    long written=0;
    long last_gui_update=0;
    while ((nb=inStrm.read(ch)) != -1) {
      fos.write(ch,0,nb);
      written+=nb;
      if ((written - last_gui_update) > 1000000) {
        gui_.status(String.format(status_,(int)(100.0 * written / size)));
        last_gui_update=written;
      }
    }
    fos.close();
    inStrm.close();
    long end=new Date().getTime();
    this.log.debug(String.format(""String_Node_Str"",((float)(size / 1000)) / ((float)(end - start) / 1000),written));
    this.lastRequestTime=new Date().getTime();
    return 0;
  }
 catch (  Exception e) {
    if (Utils.noFreeSpaceOnDisk(destination_)) {
      throw new FermeExceptionNoSpaceLeftOnDevice();
    }
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    this.log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
  }
  this.log.debug(""String_Node_Str"" + url_ + ""String_Node_Str"");
  return -2;
}","public int HTTPGetFile(String url_,String destination_,Gui gui_,String status_) throws FermeExceptionNoSpaceLeftOnDevice {
  try {
    HttpURLConnection httpCon=this.HTTPRequest(url_);
    InputStream inStrm=httpCon.getInputStream();
    if (httpCon.getResponseCode() != HttpURLConnection.HTTP_OK) {
      this.log.error(""String_Node_Str"" + url_ + ""String_Node_Str""+ HttpURLConnection.HTTP_OK+ ""String_Node_Str""+ httpCon.getResponseCode());
      return -1;
    }
    int size=httpCon.getContentLength();
    long start=new Date().getTime();
    FileOutputStream fos=new FileOutputStream(destination_);
    byte[] ch=new byte[512 * 1024];
    int nb;
    long written=0;
    long last_gui_update=0;
    while ((nb=inStrm.read(ch)) != -1) {
      fos.write(ch,0,nb);
      written+=nb;
      if ((written - last_gui_update) > 1000000) {
        gui_.status(String.format(status_,(int)(100.0 * written / size)));
        last_gui_update=written;
      }
    }
    fos.close();
    inStrm.close();
    long end=new Date().getTime();
    this.log.debug(String.format(""String_Node_Str"",((float)(size / 1000)) / ((float)(end - start) / 1000),written));
    this.lastRequestTime=new Date().getTime();
    return 0;
  }
 catch (  Exception e) {
    if (Utils.noFreeSpaceOnDisk(new File(destination_).getParent())) {
      throw new FermeExceptionNoSpaceLeftOnDevice();
    }
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    this.log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
  }
  this.log.debug(""String_Node_Str"" + url_ + ""String_Node_Str"");
  return -2;
}","The original code used destination_ directly when checking for free disk space, which might fail if the destination path is invalid or non-existent. The fixed code uses new File(destination_).getParent() to reliably retrieve the parent directory for space checking before throwing the FermeExceptionNoSpaceLeftOnDevice. This modification ensures a more robust and accurate method of verifying available disk space, preventing potential runtime errors and improving the method's error handling reliability."
94571,"public ServerCode HTTPSendFile(String surl,String file1){
  this.log.debug(""String_Node_Str"" + surl + ""String_Node_Str""+ file1+ ""String_Node_Str"");
  HttpURLConnection conn=null;
  DataOutputStream dos=null;
  BufferedReader inStream=null;
  String exsistingFileName=file1;
  File fFile2Snd=new File(exsistingFileName);
  String lineEnd=""String_Node_Str"";
  String twoHyphens=""String_Node_Str"";
  String boundary=""String_Node_Str"";
  int bytesRead, bytesAvailable, bufferSize;
  byte[] buffer;
  int maxBufferSize=1 * 1024 * 1024;
  String urlString=surl;
  try {
    FileInputStream fileInputStream=new FileInputStream(new File(exsistingFileName));
    URL url=new URL(urlString);
    conn=(HttpURLConnection)url.openConnection();
    conn.setDoInput(true);
    conn.setDoOutput(true);
    conn.setUseCaches(false);
    for (    String cookie : this.cookies) {
      conn.setRequestProperty(""String_Node_Str"",cookie);
    }
    conn.setRequestMethod(""String_Node_Str"");
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + boundary);
    if (urlString.startsWith(""String_Node_Str"")) {
      try {
        SSLContext sc;
        sc=SSLContext.getInstance(""String_Node_Str"");
        sc.init(null,new TrustManager[]{this},null);
        SSLSocketFactory factory=sc.getSocketFactory();
        ((HttpsURLConnection)conn).setSSLSocketFactory(factory);
        ((HttpsURLConnection)conn).setHostnameVerifier(this);
      }
 catch (      NoSuchAlgorithmException e) {
        this.log.error(""String_Node_Str"" + e);
        try {
          fileInputStream.close();
        }
 catch (        Exception e1) {
        }
        return ServerCode.UNKNOWN;
      }
catch (      KeyManagementException e) {
        this.log.error(""String_Node_Str"" + e);
        try {
          fileInputStream.close();
        }
 catch (        Exception e1) {
        }
        return ServerCode.UNKNOWN;
      }
    }
    dos=new DataOutputStream(conn.getOutputStream());
    dos.writeBytes(twoHyphens + boundary + lineEnd);
    dos.writeBytes(""String_Node_Str"" + ""String_Node_Str"" + fFile2Snd.getName() + ""String_Node_Str""+ lineEnd);
    dos.writeBytes(lineEnd);
    bytesAvailable=fileInputStream.available();
    bufferSize=Math.min(bytesAvailable,maxBufferSize);
    buffer=new byte[bufferSize];
    bytesRead=fileInputStream.read(buffer,0,bufferSize);
    while (bytesRead > 0) {
      dos.write(buffer,0,bufferSize);
      bytesAvailable=fileInputStream.available();
      bufferSize=Math.min(bytesAvailable,maxBufferSize);
      bytesRead=fileInputStream.read(buffer,0,bufferSize);
    }
    dos.writeBytes(lineEnd);
    dos.writeBytes(twoHyphens + boundary + twoHyphens+ lineEnd);
    fileInputStream.close();
    dos.flush();
    dos.close();
  }
 catch (  MalformedURLException ex) {
    this.log.error(""String_Node_Str"" + ex);
    return ServerCode.UNKNOWN;
  }
catch (  IOException ioe) {
    this.log.error(""String_Node_Str"" + ioe);
    return ServerCode.UNKNOWN;
  }
catch (  Exception e6) {
    this.log.error(""String_Node_Str"" + e6);
    return ServerCode.UNKNOWN;
  }
  int r;
  try {
    r=conn.getResponseCode();
  }
 catch (  IOException e1) {
    e1.printStackTrace();
    return ServerCode.UNKNOWN;
  }
  String contentType=conn.getContentType();
  if (r == HttpURLConnection.HTTP_OK && contentType.startsWith(""String_Node_Str"")) {
    DataInputStream in;
    try {
      in=new DataInputStream(conn.getInputStream());
    }
 catch (    IOException e1) {
      e1.printStackTrace();
      return ServerCode.UNKNOWN;
    }
    Document document=null;
    try {
      document=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(in);
    }
 catch (    SAXException e) {
      e.printStackTrace();
      return ServerCode.UNKNOWN;
    }
catch (    IOException e) {
      e.printStackTrace();
      return ServerCode.UNKNOWN;
    }
catch (    ParserConfigurationException e) {
      e.printStackTrace();
      return ServerCode.UNKNOWN;
    }
    this.lastRequestTime=new Date().getTime();
    ServerCode ret1=Utils.statusIsOK(document,""String_Node_Str"");
    if (ret1 != ServerCode.OK) {
      this.log.error(""String_Node_Str"" + ret1 + ""String_Node_Str"");
      return ret1;
    }
    return ServerCode.OK;
  }
 else   if (r == HttpURLConnection.HTTP_OK && contentType.startsWith(""String_Node_Str"")) {
    return ServerCode.ERROR_BAD_RESPONSE;
  }
 else {
    try {
      inStream=new BufferedReader(new InputStreamReader(conn.getInputStream()));
      String str;
      while ((str=inStream.readLine()) != null) {
        System.out.println(str);
        System.out.println(""String_Node_Str"");
      }
      inStream.close();
    }
 catch (    IOException ioex) {
    }
  }
  return ServerCode.UNKNOWN;
}","public ServerCode HTTPSendFile(String surl,String file1){
  this.log.debug(""String_Node_Str"" + surl + ""String_Node_Str""+ file1+ ""String_Node_Str"");
  HttpURLConnection conn=null;
  DataOutputStream dos=null;
  BufferedReader inStream=null;
  String exsistingFileName=file1;
  File fFile2Snd=new File(exsistingFileName);
  String lineEnd=""String_Node_Str"";
  String twoHyphens=""String_Node_Str"";
  String boundary=""String_Node_Str"";
  int bytesRead, bytesAvailable, bufferSize;
  byte[] buffer;
  int maxBufferSize=1 * 1024 * 1024;
  String urlString=surl;
  try {
    FileInputStream fileInputStream=new FileInputStream(new File(exsistingFileName));
    URL url=new URL(urlString);
    conn=(HttpURLConnection)url.openConnection();
    conn.setDoInput(true);
    conn.setDoOutput(true);
    conn.setUseCaches(false);
    for (    String cookie : this.cookies) {
      conn.setRequestProperty(""String_Node_Str"",cookie);
    }
    conn.setRequestMethod(""String_Node_Str"");
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + boundary);
    if (urlString.startsWith(""String_Node_Str"")) {
      try {
        SSLContext sc;
        sc=SSLContext.getInstance(""String_Node_Str"");
        sc.init(null,new TrustManager[]{this},null);
        SSLSocketFactory factory=sc.getSocketFactory();
        ((HttpsURLConnection)conn).setSSLSocketFactory(factory);
        ((HttpsURLConnection)conn).setHostnameVerifier(this);
      }
 catch (      NoSuchAlgorithmException e) {
        this.log.error(""String_Node_Str"" + e);
        try {
          fileInputStream.close();
        }
 catch (        Exception e1) {
        }
        return ServerCode.UNKNOWN;
      }
catch (      KeyManagementException e) {
        this.log.error(""String_Node_Str"" + e);
        try {
          fileInputStream.close();
        }
 catch (        Exception e1) {
        }
        return ServerCode.UNKNOWN;
      }
    }
    dos=new DataOutputStream(conn.getOutputStream());
    dos.writeBytes(twoHyphens + boundary + lineEnd);
    dos.writeBytes(""String_Node_Str"" + ""String_Node_Str"" + fFile2Snd.getName() + ""String_Node_Str""+ lineEnd);
    dos.writeBytes(lineEnd);
    bytesAvailable=fileInputStream.available();
    bufferSize=Math.min(bytesAvailable,maxBufferSize);
    buffer=new byte[bufferSize];
    bytesRead=fileInputStream.read(buffer,0,bufferSize);
    while (bytesRead > 0) {
      dos.write(buffer,0,bufferSize);
      bytesAvailable=fileInputStream.available();
      bufferSize=Math.min(bytesAvailable,maxBufferSize);
      bytesRead=fileInputStream.read(buffer,0,bufferSize);
    }
    dos.writeBytes(lineEnd);
    dos.writeBytes(twoHyphens + boundary + twoHyphens+ lineEnd);
    fileInputStream.close();
    dos.flush();
    dos.close();
  }
 catch (  MalformedURLException ex) {
    this.log.error(""String_Node_Str"" + ex);
    return ServerCode.UNKNOWN;
  }
catch (  IOException ioe) {
    this.log.error(""String_Node_Str"" + ioe);
    return ServerCode.UNKNOWN;
  }
catch (  Exception e6) {
    this.log.error(""String_Node_Str"" + e6);
    return ServerCode.UNKNOWN;
  }
catch (  OutOfMemoryError e6) {
    this.log.error(""String_Node_Str"" + e6);
    return ServerCode.JOB_VALIDATION_ERROR_UPLOAD_FAILED;
  }
  int r;
  try {
    r=conn.getResponseCode();
  }
 catch (  IOException e1) {
    e1.printStackTrace();
    return ServerCode.UNKNOWN;
  }
  String contentType=conn.getContentType();
  if (r == HttpURLConnection.HTTP_OK && contentType.startsWith(""String_Node_Str"")) {
    DataInputStream in;
    try {
      in=new DataInputStream(conn.getInputStream());
    }
 catch (    IOException e1) {
      e1.printStackTrace();
      return ServerCode.UNKNOWN;
    }
    Document document=null;
    try {
      document=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(in);
    }
 catch (    SAXException e) {
      e.printStackTrace();
      return ServerCode.UNKNOWN;
    }
catch (    IOException e) {
      e.printStackTrace();
      return ServerCode.UNKNOWN;
    }
catch (    ParserConfigurationException e) {
      e.printStackTrace();
      return ServerCode.UNKNOWN;
    }
    this.lastRequestTime=new Date().getTime();
    ServerCode ret1=Utils.statusIsOK(document,""String_Node_Str"");
    if (ret1 != ServerCode.OK) {
      this.log.error(""String_Node_Str"" + ret1 + ""String_Node_Str"");
      return ret1;
    }
    return ServerCode.OK;
  }
 else   if (r == HttpURLConnection.HTTP_OK && contentType.startsWith(""String_Node_Str"")) {
    return ServerCode.ERROR_BAD_RESPONSE;
  }
 else {
    try {
      inStream=new BufferedReader(new InputStreamReader(conn.getInputStream()));
      String str;
      while ((str=inStream.readLine()) != null) {
        System.out.println(str);
        System.out.println(""String_Node_Str"");
      }
      inStream.close();
    }
 catch (    IOException ioex) {
    }
  }
  return ServerCode.UNKNOWN;
}","The original code lacked error handling for potential memory-related exceptions like OutOfMemoryError, which could cause unpredictable application behavior. The fixed code introduces a specific catch block for OutOfMemoryError, returning a more meaningful error code (JOB_VALIDATION_ERROR_UPLOAD_FAILED) instead of the generic UNKNOWN status. This improvement provides better error tracing and allows more precise error management during file upload processes, enhancing the method's robustness and diagnostic capabilities."
94572,"public Error.Type render(){
  gui.status(""String_Node_Str"");
  RenderProcess process=getProcessRender();
  String core_script=""String_Node_Str"";
  if (getUseGPU() && config.getGPUDevice() != null && config.getComputeMethod() != ComputeType.CPU) {
    core_script=""String_Node_Str"" + config.getGPUDevice().getCudaName() + ""String_Node_Str"";
  }
 else {
    core_script=""String_Node_Str"";
  }
  core_script+=String.format(""String_Node_Str"",getTileSize());
  File script_file=null;
  String command1[]=getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (config.getNbCores() > 0) {
    size_command+=2;
  }
  List<String> command=new ArrayList<String>(size_command);
  Map<String,String> new_env=new HashMap<String,String>();
  new_env.put(""String_Node_Str"",config.workingDirectory.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
  new_env.put(""String_Node_Str"",Integer.toString(config.getNbCores()));
  new_env.put(""String_Node_Str"",Integer.toString(config.getPriority()));
  for (  String arg : command1) {
switch (arg) {
case ""String_Node_Str"":
      command.add(getScenePath());
    command.add(""String_Node_Str"");
  try {
    script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",config.workingDirectory);
    File file=new File(script_file.getAbsolutePath());
    FileWriter txt;
    txt=new FileWriter(file);
    PrintWriter out=new PrintWriter(txt);
    out.write(getScript());
    out.write(""String_Node_Str"");
    out.write(core_script);
    out.write(""String_Node_Str"");
    out.close();
    command.add(script_file.getAbsolutePath());
  }
 catch (  IOException e) {
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
    return Error.Type.UNKNOWN;
  }
script_file.deleteOnExit();
break;
case ""String_Node_Str"":
command.add(getRendererPath());
if (config.getNbCores() > 0) {
command.add(""String_Node_Str"");
command.add(Integer.toString(config.getNbCores()));
}
break;
case ""String_Node_Str"":
command.add(config.workingDirectory.getAbsolutePath() + File.separator + getPrefixOutputImage());
break;
case ""String_Node_Str"":
command.add(getFrameNumber());
break;
default :
command.add(arg);
break;
}
}
try {
String line;
log.debug(command.toString());
OS os=OS.getOS();
process.setCoresUsed(config.getNbCores());
process.start();
getProcessRender().setProcess(os.exec(command,new_env));
BufferedReader input=new BufferedReader(new InputStreamReader(getProcessRender().getProcess().getInputStream()));
long last_update_status=0;
log.debug(""String_Node_Str"");
try {
while ((line=input.readLine()) != null) {
log.debug(line);
updateRenderingMemoryPeak(line);
if (process.getMemoryUsed() > config.getMaxMemory()) {
log.debug(""String_Node_Str"" + process.getMemoryUsed() + ""String_Node_Str""+ config.getMaxMemory()+ ""String_Node_Str"");
process.finish();
if (script_file != null) {
script_file.delete();
}
return Error.Type.RENDERER_OUT_OF_MEMORY;
}
if ((new Date().getTime() - last_update_status) > 2000) {
updateRenderingStatus(line);
last_update_status=new Date().getTime();
}
Type error=detectError(line);
if (error != Error.Type.OK) {
if (script_file != null) {
script_file.delete();
}
return error;
}
}
input.close();
}
 catch (IOException err1) {
log.error(""String_Node_Str"" + err1);
}
log.debug(""String_Node_Str"");
}
 catch (Exception err) {
if (script_file != null) {
script_file.delete();
}
StringWriter sw=new StringWriter();
err.printStackTrace(new PrintWriter(sw));
log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
return Error.Type.FAILED_TO_EXECUTE;
}
int exit_value=process.exitValue();
process.finish();
if (script_file != null) {
script_file.delete();
}
final String filename_without_extension=getPrefixOutputImage() + getFrameNumber();
FilenameFilter textFilter=new FilenameFilter(){
public boolean accept(File dir,String name){
return name.startsWith(filename_without_extension);
}
}
;
File[] files=config.workingDirectory.listFiles(textFilter);
if (getAskForRendererKill()) {
log.debug(""String_Node_Str"");
if (files.length != 0) {
new File(files[0].getAbsolutePath()).delete();
}
if (getServerBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_SERVER;
}
if (getUserBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_USER;
}
return Error.Type.RENDERER_KILLED;
}
if (files.length == 0) {
log.error(""String_Node_Str"" + filename_without_extension + ""String_Node_Str"");
String basename=""String_Node_Str"";
try {
basename=getPath().substring(0,getPath().lastIndexOf('.'));
}
 catch (Exception e) {
e.printStackTrace();
}
File crash_file=new File(config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
if (crash_file.exists()) {
log.error(""String_Node_Str"");
crash_file.delete();
return Error.Type.RENDERER_CRASHED;
}
if (exit_value == 127 && process.getDuration() < 10) {
log.error(""String_Node_Str"" + process.getDuration() + ""String_Node_Str"");
return Error.Type.RENDERER_MISSING_LIBRARIES;
}
return Error.Type.NOOUTPUTFILE;
}
 else {
setOutputImagePath(files[0].getAbsolutePath());
log.debug(""String_Node_Str"" + getOutputImagePath() + ""String_Node_Str"");
}
File scene_dir=new File(getSceneDirectory());
long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
if (date_modification_scene_directory > process.getStartTime()) {
scene_dir.delete();
}
gui.status(String.format(""String_Node_Str"",process.getDuration() / 60,process.getDuration() % 60));
return Error.Type.OK;
}","public Error.Type render(){
  gui.status(""String_Node_Str"");
  RenderProcess process=getProcessRender();
  String core_script=""String_Node_Str"";
  if (getUseGPU() && config.getGPUDevice() != null && config.getComputeMethod() != ComputeType.CPU) {
    core_script=""String_Node_Str"" + config.getGPUDevice().getCudaName() + ""String_Node_Str"";
  }
 else {
    core_script=""String_Node_Str"";
  }
  core_script+=String.format(""String_Node_Str"",getTileSize());
  File script_file=null;
  String command1[]=getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (config.getNbCores() > 0) {
    size_command+=2;
  }
  List<String> command=new ArrayList<String>(size_command);
  Map<String,String> new_env=new HashMap<String,String>();
  new_env.put(""String_Node_Str"",config.workingDirectory.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
  new_env.put(""String_Node_Str"",Integer.toString(config.getNbCores()));
  new_env.put(""String_Node_Str"",Integer.toString(config.getPriority()));
  for (  String arg : command1) {
switch (arg) {
case ""String_Node_Str"":
      command.add(getScenePath());
    command.add(""String_Node_Str"");
  try {
    script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",config.workingDirectory);
    File file=new File(script_file.getAbsolutePath());
    FileWriter txt;
    txt=new FileWriter(file);
    PrintWriter out=new PrintWriter(txt);
    out.write(getScript());
    out.write(""String_Node_Str"");
    out.write(core_script);
    out.write(""String_Node_Str"");
    out.close();
    command.add(script_file.getAbsolutePath());
  }
 catch (  IOException e) {
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
    return Error.Type.UNKNOWN;
  }
script_file.deleteOnExit();
break;
case ""String_Node_Str"":
command.add(getRendererPath());
if (config.getNbCores() > 0) {
command.add(""String_Node_Str"");
command.add(Integer.toString(config.getNbCores()));
}
break;
case ""String_Node_Str"":
command.add(config.workingDirectory.getAbsolutePath() + File.separator + getPrefixOutputImage());
break;
case ""String_Node_Str"":
command.add(getFrameNumber());
break;
default :
command.add(arg);
break;
}
}
try {
String line;
log.debug(command.toString());
OS os=OS.getOS();
process.setCoresUsed(config.getNbCores());
process.start();
getProcessRender().setProcess(os.exec(command,new_env));
BufferedReader input=new BufferedReader(new InputStreamReader(getProcessRender().getProcess().getInputStream()));
long last_update_status=0;
log.debug(""String_Node_Str"");
try {
while ((line=input.readLine()) != null) {
log.debug(line);
updateRenderingMemoryPeak(line);
if (config.getMaxMemory() != -1 && process.getMemoryUsed() > config.getMaxMemory()) {
log.debug(""String_Node_Str"" + process.getMemoryUsed() + ""String_Node_Str""+ config.getMaxMemory()+ ""String_Node_Str"");
process.finish();
if (script_file != null) {
script_file.delete();
}
return Error.Type.RENDERER_OUT_OF_MEMORY;
}
if ((new Date().getTime() - last_update_status) > 2000) {
updateRenderingStatus(line);
last_update_status=new Date().getTime();
}
Type error=detectError(line);
if (error != Error.Type.OK) {
if (script_file != null) {
script_file.delete();
}
return error;
}
}
input.close();
}
 catch (IOException err1) {
log.error(""String_Node_Str"" + err1);
}
log.debug(""String_Node_Str"");
}
 catch (Exception err) {
if (script_file != null) {
script_file.delete();
}
StringWriter sw=new StringWriter();
err.printStackTrace(new PrintWriter(sw));
log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
return Error.Type.FAILED_TO_EXECUTE;
}
int exit_value=process.exitValue();
process.finish();
if (script_file != null) {
script_file.delete();
}
final String filename_without_extension=getPrefixOutputImage() + getFrameNumber();
FilenameFilter textFilter=new FilenameFilter(){
public boolean accept(File dir,String name){
return name.startsWith(filename_without_extension);
}
}
;
File[] files=config.workingDirectory.listFiles(textFilter);
if (getAskForRendererKill()) {
log.debug(""String_Node_Str"");
if (files.length != 0) {
new File(files[0].getAbsolutePath()).delete();
}
if (getServerBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_SERVER;
}
if (getUserBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_USER;
}
return Error.Type.RENDERER_KILLED;
}
if (files.length == 0) {
log.error(""String_Node_Str"" + filename_without_extension + ""String_Node_Str"");
String basename=""String_Node_Str"";
try {
basename=getPath().substring(0,getPath().lastIndexOf('.'));
}
 catch (Exception e) {
e.printStackTrace();
}
File crash_file=new File(config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
if (crash_file.exists()) {
log.error(""String_Node_Str"");
crash_file.delete();
return Error.Type.RENDERER_CRASHED;
}
if (exit_value == 127 && process.getDuration() < 10) {
log.error(""String_Node_Str"" + process.getDuration() + ""String_Node_Str"");
return Error.Type.RENDERER_MISSING_LIBRARIES;
}
return Error.Type.NOOUTPUTFILE;
}
 else {
setOutputImagePath(files[0].getAbsolutePath());
log.debug(""String_Node_Str"" + getOutputImagePath() + ""String_Node_Str"");
}
File scene_dir=new File(getSceneDirectory());
long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
if (date_modification_scene_directory > process.getStartTime()) {
scene_dir.delete();
}
gui.status(String.format(""String_Node_Str"",process.getDuration() / 60,process.getDuration() % 60));
return Error.Type.OK;
}","The original code lacked a proper memory check condition, potentially allowing unchecked memory consumption. The fixed code adds a critical check `config.getMaxMemory() != -1` before comparing memory usage, ensuring that memory limits are only enforced when explicitly set. This improvement prevents unnecessary memory constraint errors and provides more robust and flexible memory management during rendering processes."
94573,"public void setCacheDir(File cache_dir_){
  removeWorkingDirectory();
  if (cache_dir_ == null) {
    this.userSpecifiedACacheDir=false;
    try {
      this.workingDirectory=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
      this.workingDirectory.createNewFile();
      this.workingDirectory.delete();
      this.workingDirectory.mkdir();
      this.workingDirectory.deleteOnExit();
      this.storageDirectory=new File(this.workingDirectory.getParent() + File.separator + ""String_Node_Str"");
      this.storageDirectory.mkdir();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 else {
    this.userSpecifiedACacheDir=true;
    this.workingDirectory=cache_dir_;
  }
}","public void setCacheDir(File cache_dir_){
  removeWorkingDirectory();
  if (cache_dir_ == null) {
    this.userSpecifiedACacheDir=false;
    try {
      this.workingDirectory=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
      this.workingDirectory.createNewFile();
      this.workingDirectory.delete();
      this.workingDirectory.mkdir();
      this.workingDirectory.deleteOnExit();
      this.storageDirectory=new File(this.workingDirectory.getParent() + File.separator + ""String_Node_Str"");
      this.storageDirectory.mkdir();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 else {
    this.userSpecifiedACacheDir=true;
    this.workingDirectory=cache_dir_;
    this.storageDirectory=cache_dir_;
  }
}","The original code failed to set the `storageDirectory` when a non-null cache directory was provided, potentially causing inconsistent storage behavior. The fixed code explicitly sets `storageDirectory = cache_dir_` in the `else` block, ensuring that when a custom cache directory is specified, both `workingDirectory` and `storageDirectory` are correctly initialized. This modification guarantees proper directory management and prevents potential null or incorrect storage directory references."
94574,"public HttpURLConnection HTTPRequest(String url_,String data_) throws IOException {
  this.log.debug(""String_Node_Str"" + url_ + ""String_Node_Str"");
  HttpURLConnection connection=null;
  URL url=new URL(url_);
  connection=(HttpURLConnection)url.openConnection();
  connection.setDoInput(true);
  connection.setDoOutput(true);
  connection.setRequestMethod(""String_Node_Str"");
  for (  String cookie : this.cookies) {
    connection.setRequestProperty(""String_Node_Str"",cookie);
  }
  if (url_.startsWith(""String_Node_Str"")) {
    try {
      SSLContext sc;
      sc=SSLContext.getInstance(""String_Node_Str"");
      sc.init(null,new TrustManager[]{this},null);
      SSLSocketFactory factory=sc.getSocketFactory();
      ((HttpsURLConnection)connection).setSSLSocketFactory(factory);
      ((HttpsURLConnection)connection).setHostnameVerifier(this);
    }
 catch (    NoSuchAlgorithmException e) {
      e.printStackTrace();
      return null;
    }
catch (    KeyManagementException e) {
      e.printStackTrace();
      return null;
    }
  }
  if (data_ != null) {
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    connection.setRequestMethod(""String_Node_Str"");
    OutputStreamWriter out=new OutputStreamWriter(connection.getOutputStream());
    out.write(data_);
    out.flush();
    out.close();
  }
  String headerName=null;
  for (int i=1; (headerName=connection.getHeaderFieldKey(i)) != null; i++) {
    if (headerName.equals(""String_Node_Str"")) {
      String cookie=connection.getHeaderField(i);
      boolean cookieIsPresent=false;
      for (      String value : this.cookies) {
        if (value.equalsIgnoreCase(cookie))         cookieIsPresent=true;
      }
      if (!cookieIsPresent)       this.cookies.add(cookie);
    }
  }
  this.lastRequestTime=new Date().getTime();
  return connection;
}","public HttpURLConnection HTTPRequest(String url_,String data_) throws IOException {
  this.log.debug(""String_Node_Str"" + url_ + ""String_Node_Str"");
  HttpURLConnection connection=null;
  URL url=new URL(url_);
  connection=(HttpURLConnection)url.openConnection();
  connection.setDoInput(true);
  connection.setDoOutput(true);
  connection.setRequestMethod(""String_Node_Str"");
  for (  String cookie : this.cookies) {
    connection.setRequestProperty(""String_Node_Str"",cookie);
  }
  if (url_.startsWith(""String_Node_Str"")) {
    try {
      SSLContext sc;
      sc=SSLContext.getInstance(""String_Node_Str"");
      sc.init(null,new TrustManager[]{this},null);
      SSLSocketFactory factory=sc.getSocketFactory();
      ((HttpsURLConnection)connection).setSSLSocketFactory(factory);
      ((HttpsURLConnection)connection).setHostnameVerifier(this);
    }
 catch (    NoSuchAlgorithmException e) {
      e.printStackTrace();
      return null;
    }
catch (    KeyManagementException e) {
      e.printStackTrace();
      return null;
    }
  }
  if (data_ != null) {
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    connection.setRequestMethod(""String_Node_Str"");
    OutputStreamWriter out=new OutputStreamWriter(connection.getOutputStream());
    out.write(data_);
    out.flush();
    out.close();
  }
  String headerName=null;
  for (int i=1; (headerName=connection.getHeaderFieldKey(i)) != null; i++) {
    if (headerName.equals(""String_Node_Str"")) {
      String cookie=connection.getHeaderField(i);
      boolean cookieIsPresent=false;
      for (      String value : this.cookies) {
        if (value.equalsIgnoreCase(cookie))         cookieIsPresent=true;
      }
      if (!cookieIsPresent)       this.cookies.add(cookie);
    }
  }
  connection.getResponseCode();
  this.lastRequestTime=new Date().getTime();
  return connection;
}","The original code lacked explicit connection response handling, which could lead to unestablished network connections and potential resource leaks. In the fixed code, `connection.getResponseCode()` is added to ensure the HTTP request is fully executed and the connection is properly initiated before returning. This change guarantees complete network interaction, proper resource management, and more reliable HTTP request processing."
94575,"@Override public void actionPerformed(ActionEvent e){
  if (parent == null) {
    return;
  }
  Configuration config=parent.getConfiguration();
  if (config == null) {
    return;
  }
  if (cacheDir != null) {
    File fromConfig=config.getStorageDir();
    if (fromConfig != null && fromConfig.getAbsolutePath().equals(cacheDir.getAbsolutePath()) == false) {
      config.setCacheDir(cacheDir);
    }
 else {
    }
  }
  GPUDevice selected_gpu=null;
  for (  JCheckBoxGPU box : useGPUs) {
    if (box.isSelected()) {
      selected_gpu=box.getGPUDevice();
    }
  }
  ComputeType method=ComputeType.CPU;
  if (useCPU.isSelected() && selected_gpu == null) {
    method=ComputeType.CPU;
  }
 else   if (useCPU.isSelected() == false && selected_gpu != null) {
    method=ComputeType.GPU;
  }
 else   if (useCPU.isSelected() && selected_gpu != null) {
    method=ComputeType.CPU_GPU;
  }
  config.setComputeMethod(method);
  if (selected_gpu != null) {
    config.setUseGPU(selected_gpu);
  }
  int cpu_cores=-1;
  if (cpuCores != null) {
    cpu_cores=cpuCores.getValue();
  }
  if (cpu_cores > 0) {
    config.setUseNbCores(cpu_cores);
  }
  String proxyText=null;
  if (proxy != null) {
    try {
      Proxy.set(proxy.getText());
      proxyText=proxy.getText();
    }
 catch (    MalformedURLException e1) {
      System.err.println(""String_Node_Str"");
      System.err.println(e1);
      System.exit(2);
    }
  }
  String tile=null;
  if (customTileSize.isSelected() && tileSizeValue != null) {
    try {
      tile=tileSizeValue.getText().replaceAll(""String_Node_Str"",""String_Node_Str"");
      config.setTileSize(Integer.parseInt(tile));
    }
 catch (    NumberFormatException e1) {
      System.err.println(""String_Node_Str"");
      System.err.println(e1);
      System.exit(2);
    }
  }
  parent.setCredentials(login.getText(),new String(password.getPassword()));
  String cachePath=null;
  if (config.getUserSpecifiedACacheDir() && config.getStorageDir() != null) {
    cachePath=config.getStorageDir().getAbsolutePath();
  }
  if (saveFile.isSelected()) {
    new SettingsLoader(login.getText(),new String(password.getPassword()),proxyText,method,selected_gpu,cpu_cores,cachePath,autoSignIn.isSelected(),GuiSwing.type,tile).saveFile();
  }
 else {
    try {
      new File(new SettingsLoader().getFilePath()).delete();
    }
 catch (    SecurityException e3) {
    }
  }
}","@Override public void actionPerformed(ActionEvent e){
  if (parent == null) {
    return;
  }
  Configuration config=parent.getConfiguration();
  if (config == null) {
    return;
  }
  if (cacheDir != null) {
    File fromConfig=config.getStorageDir();
    if (fromConfig != null && fromConfig.getAbsolutePath().equals(cacheDir.getAbsolutePath()) == false) {
      config.setCacheDir(cacheDir);
    }
 else {
    }
  }
  GPUDevice selected_gpu=null;
  for (  JCheckBoxGPU box : useGPUs) {
    if (box.isSelected()) {
      selected_gpu=box.getGPUDevice();
    }
  }
  ComputeType method=ComputeType.CPU;
  if (useCPU.isSelected() && selected_gpu == null) {
    method=ComputeType.CPU;
  }
 else   if (useCPU.isSelected() == false && selected_gpu != null) {
    method=ComputeType.GPU;
  }
 else   if (useCPU.isSelected() && selected_gpu != null) {
    method=ComputeType.CPU_GPU;
  }
  config.setComputeMethod(method);
  if (selected_gpu != null) {
    config.setUseGPU(selected_gpu);
  }
  int cpu_cores=-1;
  if (cpuCores != null) {
    cpu_cores=cpuCores.getValue();
  }
  if (cpu_cores > 0) {
    config.setUseNbCores(cpu_cores);
  }
  String proxyText=null;
  if (proxy != null) {
    try {
      Proxy.set(proxy.getText());
      proxyText=proxy.getText();
    }
 catch (    MalformedURLException e1) {
      System.err.println(""String_Node_Str"");
      System.err.println(e1);
      System.exit(2);
    }
  }
  String tile=null;
  if (customTileSize.isSelected() && tileSizeValue != null) {
    try {
      tile=tileSizeValue.getText().replaceAll(""String_Node_Str"",""String_Node_Str"");
      config.setTileSize(Integer.parseInt(tile));
    }
 catch (    NumberFormatException e1) {
      System.err.println(""String_Node_Str"");
      System.err.println(e1);
      System.exit(2);
    }
  }
 else {
    config.setTileSize(-1);
  }
  parent.setCredentials(login.getText(),new String(password.getPassword()));
  String cachePath=null;
  if (config.getUserSpecifiedACacheDir() && config.getStorageDir() != null) {
    cachePath=config.getStorageDir().getAbsolutePath();
  }
  if (saveFile.isSelected()) {
    new SettingsLoader(login.getText(),new String(password.getPassword()),proxyText,method,selected_gpu,cpu_cores,cachePath,autoSignIn.isSelected(),GuiSwing.type,tile).saveFile();
  }
 else {
    try {
      new File(new SettingsLoader().getFilePath()).delete();
    }
 catch (    SecurityException e3) {
    }
  }
}","The original code lacked handling for scenarios where custom tile size was not selected, potentially leaving tile size unset. In the fixed code, an else block was added to explicitly set tile size to -1 when custom tile size is not selected, ensuring consistent configuration. This change provides robust default behavior and prevents potential undefined states in the configuration settings."
94576,"@Override public void show(){
  Configuration config=parent.getConfiguration();
  new SettingsLoader().merge(config);
  List<GPUDevice> gpus=GPU.listDevices();
  GridBagConstraints constraints=new GridBagConstraints();
  int currentRow=0;
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  constraints.fill=GridBagConstraints.CENTER;
  JLabel labelImage=new JLabel(image);
  constraints.gridwidth=2;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  parent.getContentPane().add(labelImage,constraints);
  ++currentRow;
  JPanel authentification_panel=new JPanel(new GridLayout(2,2));
  authentification_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel loginLabel=new JLabel(""String_Node_Str"");
  login=new JTextField();
  login.setText(parent.getConfiguration().login());
  login.setColumns(20);
  login.addKeyListener(new CheckCanStart());
  JLabel passwordLabel=new JLabel(""String_Node_Str"");
  password=new JPasswordField();
  password.setText(parent.getConfiguration().password());
  password.setColumns(10);
  password.addKeyListener(new CheckCanStart());
  authentification_panel.add(loginLabel);
  authentification_panel.add(login);
  authentification_panel.add(passwordLabel);
  authentification_panel.add(password);
  constraints.gridx=0;
  constraints.gridy=currentRow;
  constraints.fill=GridBagConstraints.HORIZONTAL;
  parent.getContentPane().add(authentification_panel,constraints);
  JPanel directory_panel=new JPanel(new GridLayout(1,3));
  directory_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel cacheLabel=new JLabel(""String_Node_Str"");
  directory_panel.add(cacheLabel);
  String destination=DUMMY_CACHE_DIR;
  if (config.getUserSpecifiedACacheDir()) {
    destination=config.getStorageDir().getName();
  }
  JPanel cacheDirWrapper=new JPanel();
  cacheDirWrapper.setLayout(new BoxLayout(cacheDirWrapper,BoxLayout.LINE_AXIS));
  cacheDirText=new JLabel(destination);
  cacheDirWrapper.add(cacheDirText);
  cacheDirWrapper.add(Box.createHorizontalGlue());
  cacheDirChooser=new JFileChooser();
  cacheDirChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  JButton openButton=new JButton(""String_Node_Str"");
  openButton.addActionListener(new ChooseFileAction());
  cacheDirWrapper.add(openButton);
  directory_panel.add(cacheDirWrapper);
  currentRow++;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  constraints.gridwidth=2;
  parent.getContentPane().add(directory_panel,constraints);
  GridBagLayout gridbag=new GridBagLayout();
  GridBagConstraints compute_devices_constraints=new GridBagConstraints();
  JPanel compute_devices_panel=new JPanel(gridbag);
  compute_devices_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  ComputeType method=config.getComputeMethod();
  useCPU=new JCheckBox(""String_Node_Str"");
  boolean gpuChecked=false;
  if (method == ComputeType.CPU_GPU) {
    useCPU.setSelected(true);
    gpuChecked=true;
  }
 else   if (method == ComputeType.CPU) {
    useCPU.setSelected(true);
    gpuChecked=false;
  }
 else   if (method == ComputeType.GPU) {
    useCPU.setSelected(false);
    gpuChecked=true;
  }
  useCPU.addActionListener(new CpuChangeAction());
  compute_devices_constraints.gridx=1;
  compute_devices_constraints.gridy=0;
  compute_devices_constraints.fill=GridBagConstraints.BOTH;
  compute_devices_constraints.weightx=1.0;
  compute_devices_constraints.weighty=1.0;
  gridbag.setConstraints(useCPU,compute_devices_constraints);
  compute_devices_panel.add(useCPU);
  for (  GPUDevice gpu : gpus) {
    JCheckBoxGPU gpuCheckBox=new JCheckBoxGPU(gpu);
    gpuCheckBox.setToolTipText(gpu.getCudaName());
    if (gpuChecked) {
      GPUDevice config_gpu=config.getGPUDevice();
      if (config_gpu != null && config_gpu.getCudaName().equals(gpu.getCudaName())) {
        gpuCheckBox.setSelected(gpuChecked);
      }
    }
    gpuCheckBox.addActionListener(new GpuChangeAction());
    compute_devices_constraints.gridy++;
    gridbag.setConstraints(gpuCheckBox,compute_devices_constraints);
    compute_devices_panel.add(gpuCheckBox);
    useGPUs.add(gpuCheckBox);
  }
  CPU cpu=new CPU();
  if (cpu.cores() > 1) {
    cpuCores=new JSlider(1,cpu.cores());
    cpuCores.setMajorTickSpacing(1);
    cpuCores.setMinorTickSpacing(1);
    cpuCores.setPaintTicks(true);
    cpuCores.setPaintLabels(true);
    cpuCores.setValue(config.getNbCores() != -1 ? config.getNbCores() : cpuCores.getMaximum());
    JLabel coreLabel=new JLabel(""String_Node_Str"");
    compute_devices_constraints.weightx=1.0 / gpus.size();
    compute_devices_constraints.gridx=0;
    compute_devices_constraints.gridy++;
    gridbag.setConstraints(coreLabel,compute_devices_constraints);
    compute_devices_panel.add(coreLabel);
    compute_devices_constraints.gridx=1;
    compute_devices_constraints.weightx=1.0;
    gridbag.setConstraints(cpuCores,compute_devices_constraints);
    compute_devices_panel.add(cpuCores);
  }
  currentRow++;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  constraints.gridwidth=2;
  parent.getContentPane().add(compute_devices_panel,constraints);
  JPanel advanced_panel=new JPanel(new GridLayout(3,2));
  advanced_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel proxyLabel=new JLabel(""String_Node_Str"");
  proxyLabel.setToolTipText(""String_Node_Str"");
  proxy=new JTextField();
  proxy.setToolTipText(""String_Node_Str"");
  proxy.setText(parent.getConfiguration().getProxy());
  proxy.addKeyListener(new CheckCanStart());
  advanced_panel.add(proxyLabel);
  advanced_panel.add(proxy);
  JLabel customTileSizeLabel=new JLabel(""String_Node_Str"");
  customTileSize=new JCheckBox(""String_Node_Str"",config.getTileSize() != -1);
  advanced_panel.add(customTileSizeLabel);
  advanced_panel.add(customTileSize);
  customTileSize.addActionListener(new TileSizeChange());
  tileSizeLabel=new JLabel(""String_Node_Str"");
  tileSizeValue=new JTextField();
  int fromConfig=parent.getConfiguration().getTileSize();
  if (fromConfig == -1) {
    if (parent.getConfiguration().getGPUDevice() != null) {
      fromConfig=parent.getConfiguration().getGPUDevice().getRecommandedTileSize();
    }
 else {
      fromConfig=32;
    }
  }
  tileSizeValue.setText(Integer.toString(fromConfig));
  hideCustomTileSize(config.getTileSize() != -1,false);
  advanced_panel.add(tileSizeLabel);
  advanced_panel.add(tileSizeValue);
  currentRow++;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  constraints.gridwidth=2;
  parent.getContentPane().add(advanced_panel,constraints);
  JPanel general_panel=new JPanel(new GridLayout(1,2));
  saveFile=new JCheckBox(""String_Node_Str"",true);
  general_panel.add(saveFile);
  autoSignIn=new JCheckBox(""String_Node_Str"",config.getAutoSignIn());
  autoSignIn.addActionListener(new AutoSignInChangeAction());
  general_panel.add(autoSignIn);
  currentRow++;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  constraints.gridwidth=2;
  parent.getContentPane().add(general_panel,constraints);
  String buttonText=""String_Node_Str"";
  if (parent.getClient() != null) {
    if (parent.getClient().isRunning()) {
      buttonText=""String_Node_Str"";
    }
  }
  saveButton=new JButton(buttonText);
  checkDisplaySaveButton();
  saveButton.addActionListener(new SaveAction());
  currentRow++;
  constraints.gridwidth=2;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  parent.getContentPane().add(saveButton,constraints);
  if (haveAutoStarted == false && config.getAutoSignIn() && checkDisplaySaveButton()) {
    haveAutoStarted=true;
    new SaveAction().actionPerformed(null);
  }
}","@Override public void show(){
  Configuration config=parent.getConfiguration();
  new SettingsLoader().merge(config);
  List<GPUDevice> gpus=GPU.listDevices();
  GridBagConstraints constraints=new GridBagConstraints();
  int currentRow=0;
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  constraints.fill=GridBagConstraints.CENTER;
  JLabel labelImage=new JLabel(image);
  constraints.gridwidth=2;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  parent.getContentPane().add(labelImage,constraints);
  ++currentRow;
  JPanel authentication_panel=new JPanel(new GridLayout(2,2));
  authentication_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel loginLabel=new JLabel(""String_Node_Str"");
  login=new JTextField();
  login.setText(parent.getConfiguration().login());
  login.setColumns(20);
  login.addKeyListener(new CheckCanStart());
  JLabel passwordLabel=new JLabel(""String_Node_Str"");
  password=new JPasswordField();
  password.setText(parent.getConfiguration().password());
  password.setColumns(10);
  password.addKeyListener(new CheckCanStart());
  authentication_panel.add(loginLabel);
  authentication_panel.add(login);
  authentication_panel.add(passwordLabel);
  authentication_panel.add(password);
  constraints.gridx=0;
  constraints.gridy=currentRow;
  constraints.fill=GridBagConstraints.HORIZONTAL;
  parent.getContentPane().add(authentication_panel,constraints);
  JPanel directory_panel=new JPanel(new GridLayout(1,3));
  directory_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel cacheLabel=new JLabel(""String_Node_Str"");
  directory_panel.add(cacheLabel);
  String destination=DUMMY_CACHE_DIR;
  if (config.getUserSpecifiedACacheDir()) {
    destination=config.getStorageDir().getName();
  }
  JPanel cacheDirWrapper=new JPanel();
  cacheDirWrapper.setLayout(new BoxLayout(cacheDirWrapper,BoxLayout.LINE_AXIS));
  cacheDirText=new JLabel(destination);
  cacheDirWrapper.add(cacheDirText);
  cacheDirWrapper.add(Box.createHorizontalGlue());
  cacheDirChooser=new JFileChooser();
  cacheDirChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  JButton openButton=new JButton(""String_Node_Str"");
  openButton.addActionListener(new ChooseFileAction());
  cacheDirWrapper.add(openButton);
  directory_panel.add(cacheDirWrapper);
  currentRow++;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  constraints.gridwidth=2;
  parent.getContentPane().add(directory_panel,constraints);
  GridBagLayout gridbag=new GridBagLayout();
  GridBagConstraints compute_devices_constraints=new GridBagConstraints();
  JPanel compute_devices_panel=new JPanel(gridbag);
  compute_devices_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  ComputeType method=config.getComputeMethod();
  useCPU=new JCheckBox(""String_Node_Str"");
  boolean gpuChecked=false;
  if (method == ComputeType.CPU_GPU) {
    useCPU.setSelected(true);
    gpuChecked=true;
  }
 else   if (method == ComputeType.CPU) {
    useCPU.setSelected(true);
    gpuChecked=false;
  }
 else   if (method == ComputeType.GPU) {
    useCPU.setSelected(false);
    gpuChecked=true;
  }
  useCPU.addActionListener(new CpuChangeAction());
  compute_devices_constraints.gridx=1;
  compute_devices_constraints.gridy=0;
  compute_devices_constraints.fill=GridBagConstraints.BOTH;
  compute_devices_constraints.weightx=1.0;
  compute_devices_constraints.weighty=1.0;
  gridbag.setConstraints(useCPU,compute_devices_constraints);
  compute_devices_panel.add(useCPU);
  for (  GPUDevice gpu : gpus) {
    JCheckBoxGPU gpuCheckBox=new JCheckBoxGPU(gpu);
    gpuCheckBox.setToolTipText(gpu.getCudaName());
    if (gpuChecked) {
      GPUDevice config_gpu=config.getGPUDevice();
      if (config_gpu != null && config_gpu.getCudaName().equals(gpu.getCudaName())) {
        gpuCheckBox.setSelected(gpuChecked);
      }
    }
    gpuCheckBox.addActionListener(new GpuChangeAction());
    compute_devices_constraints.gridy++;
    gridbag.setConstraints(gpuCheckBox,compute_devices_constraints);
    compute_devices_panel.add(gpuCheckBox);
    useGPUs.add(gpuCheckBox);
  }
  CPU cpu=new CPU();
  if (cpu.cores() > 1) {
    cpuCores=new JSlider(1,cpu.cores());
    cpuCores.setMajorTickSpacing(1);
    cpuCores.setMinorTickSpacing(1);
    cpuCores.setPaintTicks(true);
    cpuCores.setPaintLabels(true);
    cpuCores.setValue(config.getNbCores() != -1 ? config.getNbCores() : cpuCores.getMaximum());
    JLabel coreLabel=new JLabel(""String_Node_Str"");
    compute_devices_constraints.weightx=1.0 / gpus.size();
    compute_devices_constraints.gridx=0;
    compute_devices_constraints.gridy++;
    gridbag.setConstraints(coreLabel,compute_devices_constraints);
    compute_devices_panel.add(coreLabel);
    compute_devices_constraints.gridx=1;
    compute_devices_constraints.weightx=1.0;
    gridbag.setConstraints(cpuCores,compute_devices_constraints);
    compute_devices_panel.add(cpuCores);
  }
  currentRow++;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  constraints.gridwidth=2;
  parent.getContentPane().add(compute_devices_panel,constraints);
  JPanel advanced_panel=new JPanel(new GridLayout(3,2));
  advanced_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel proxyLabel=new JLabel(""String_Node_Str"");
  proxyLabel.setToolTipText(""String_Node_Str"");
  proxy=new JTextField();
  proxy.setToolTipText(""String_Node_Str"");
  proxy.setText(parent.getConfiguration().getProxy());
  proxy.addKeyListener(new CheckCanStart());
  advanced_panel.add(proxyLabel);
  advanced_panel.add(proxy);
  JLabel customTileSizeLabel=new JLabel(""String_Node_Str"");
  customTileSize=new JCheckBox(""String_Node_Str"",config.getTileSize() != -1);
  advanced_panel.add(customTileSizeLabel);
  advanced_panel.add(customTileSize);
  customTileSize.addActionListener(new TileSizeChange());
  tileSizeLabel=new JLabel(""String_Node_Str"");
  tileSizeValue=new JTextField();
  int fromConfig=parent.getConfiguration().getTileSize();
  if (fromConfig == -1) {
    if (parent.getConfiguration().getGPUDevice() != null) {
      fromConfig=parent.getConfiguration().getGPUDevice().getRecommandedTileSize();
    }
 else {
      fromConfig=32;
    }
  }
  tileSizeValue.setText(Integer.toString(fromConfig));
  hideCustomTileSize(config.getTileSize() != -1,false);
  advanced_panel.add(tileSizeLabel);
  advanced_panel.add(tileSizeValue);
  currentRow++;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  constraints.gridwidth=2;
  parent.getContentPane().add(advanced_panel,constraints);
  JPanel general_panel=new JPanel(new GridLayout(1,2));
  saveFile=new JCheckBox(""String_Node_Str"",true);
  general_panel.add(saveFile);
  autoSignIn=new JCheckBox(""String_Node_Str"",config.getAutoSignIn());
  autoSignIn.addActionListener(new AutoSignInChangeAction());
  general_panel.add(autoSignIn);
  currentRow++;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  constraints.gridwidth=2;
  parent.getContentPane().add(general_panel,constraints);
  String buttonText=""String_Node_Str"";
  if (parent.getClient() != null) {
    if (parent.getClient().isRunning()) {
      buttonText=""String_Node_Str"";
    }
  }
  saveButton=new JButton(buttonText);
  checkDisplaySaveButton();
  saveButton.addActionListener(new SaveAction());
  currentRow++;
  constraints.gridwidth=2;
  constraints.gridx=0;
  constraints.gridy=currentRow;
  parent.getContentPane().add(saveButton,constraints);
  if (haveAutoStarted == false && config.getAutoSignIn() && checkDisplaySaveButton()) {
    haveAutoStarted=true;
    new SaveAction().actionPerformed(null);
  }
}","The original code contained a spelling error in the ""authentication"" panel name, using ""authentification"" instead of the correct spelling. The fixed code corrects this misspelling, replacing ""authentification_panel"" with ""authentication_panel"" to ensure proper naming convention and readability. This minor correction improves code clarity and maintains professional coding standards without changing the underlying functionality."
94577,"public Error.Type render(){
  gui.status(""String_Node_Str"" + this.name + ""String_Node_Str"");
  RenderProcess process=getProcessRender();
  String core_script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  if (getUseGPU() && config.getGPUDevice() != null) {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",config.getGPUDevice().getCudaName());
  }
 else {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  core_script+=String.format(""String_Node_Str"",getTileSize());
  File script_file=null;
  String command1[]=getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (config.getNbCores() > 0) {
    size_command+=2;
  }
  List<String> command=new ArrayList<String>(size_command);
  Map<String,String> new_env=new HashMap<String,String>();
  new_env.put(""String_Node_Str"",config.workingDirectory.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
  new_env.put(""String_Node_Str"",Integer.toString(config.getNbCores()));
  for (  String arg : command1) {
switch (arg) {
case ""String_Node_Str"":
      command.add(getScenePath());
    command.add(""String_Node_Str"");
  try {
    script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",config.workingDirectory);
    File file=new File(script_file.getAbsolutePath());
    FileWriter txt;
    txt=new FileWriter(file);
    PrintWriter out=new PrintWriter(txt);
    out.write(getScript());
    out.write(""String_Node_Str"");
    out.write(core_script);
    out.write(""String_Node_Str"");
    out.close();
    command.add(script_file.getAbsolutePath());
  }
 catch (  IOException e) {
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
    return Error.Type.UNKNOWN;
  }
script_file.deleteOnExit();
break;
case ""String_Node_Str"":
command.add(getRendererPath());
if (config.getNbCores() > 0) {
command.add(""String_Node_Str"");
command.add(Integer.toString(config.getNbCores()));
}
break;
case ""String_Node_Str"":
command.add(config.workingDirectory.getAbsolutePath() + File.separator + getPrefixOutputImage());
break;
case ""String_Node_Str"":
command.add(getFrameNumber());
break;
default :
command.add(arg);
break;
}
}
try {
String line;
log.debug(command.toString());
OS os=OS.getOS();
process.setCoresUsed(config.getNbCores());
process.start();
getProcessRender().setProcess(os.exec(command,new_env));
BufferedReader input=new BufferedReader(new InputStreamReader(getProcessRender().getProcess().getInputStream()));
long last_update_status=0;
log.debug(""String_Node_Str"");
try {
while ((line=input.readLine()) != null) {
updateRenderingMemoryPeak(line);
log.debug(line);
if ((new Date().getTime() - last_update_status) > 2000) {
updateRenderingStatus(line);
last_update_status=new Date().getTime();
}
Type error=detectError(line);
if (error != Error.Type.OK) {
if (script_file != null) {
script_file.delete();
}
return error;
}
}
input.close();
}
 catch (IOException err1) {
log.error(""String_Node_Str"" + err1);
}
log.debug(""String_Node_Str"");
}
 catch (Exception err) {
if (script_file != null) {
script_file.delete();
}
StringWriter sw=new StringWriter();
err.printStackTrace(new PrintWriter(sw));
log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
return Error.Type.FAILED_TO_EXECUTE;
}
int exit_value=process.exitValue();
process.finish();
if (script_file != null) {
script_file.delete();
}
final String filename_without_extension=getPrefixOutputImage() + getFrameNumber();
FilenameFilter textFilter=new FilenameFilter(){
public boolean accept(File dir,String name){
return name.startsWith(filename_without_extension);
}
}
;
File[] files=config.workingDirectory.listFiles(textFilter);
if (getAskForRendererKill()) {
log.debug(""String_Node_Str"");
if (files.length != 0) {
new File(files[0].getAbsolutePath()).delete();
}
if (getUserBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_USER;
}
return Error.Type.RENDERER_KILLED;
}
if (files.length == 0) {
log.error(""String_Node_Str"" + filename_without_extension + ""String_Node_Str"");
String basename=""String_Node_Str"";
try {
basename=getPath().substring(0,getPath().lastIndexOf('.'));
}
 catch (Exception e) {
e.printStackTrace();
}
File crash_file=new File(config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
if (crash_file.exists()) {
log.error(""String_Node_Str"");
crash_file.delete();
return Error.Type.RENDERER_CRASHED;
}
if (exit_value == 127 && process.getDuration() < 10) {
log.error(""String_Node_Str"" + process.getDuration() + ""String_Node_Str"");
return Error.Type.RENDERER_MISSING_LIBRARIES;
}
return Error.Type.NOOUTPUTFILE;
}
 else {
setOutputImagePath(files[0].getAbsolutePath());
log.debug(""String_Node_Str"" + getOutputImagePath() + ""String_Node_Str"");
}
File scene_dir=new File(getSceneDirectory());
long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
if (date_modification_scene_directory > process.getStartTime()) {
scene_dir.delete();
}
gui.status(String.format(""String_Node_Str"",process.getDuration() / 60,process.getDuration() % 60));
return Error.Type.OK;
}","public Error.Type render(){
  gui.status(""String_Node_Str"" + this.name + ""String_Node_Str"");
  RenderProcess process=getProcessRender();
  String core_script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  if (getUseGPU() && config.getGPUDevice() != null && config.getComputeMethod() != ComputeType.CPU) {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",config.getGPUDevice().getCudaName());
  }
 else {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  core_script+=String.format(""String_Node_Str"",getTileSize());
  File script_file=null;
  String command1[]=getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (config.getNbCores() > 0) {
    size_command+=2;
  }
  List<String> command=new ArrayList<String>(size_command);
  Map<String,String> new_env=new HashMap<String,String>();
  new_env.put(""String_Node_Str"",config.workingDirectory.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
  new_env.put(""String_Node_Str"",Integer.toString(config.getNbCores()));
  for (  String arg : command1) {
switch (arg) {
case ""String_Node_Str"":
      command.add(getScenePath());
    command.add(""String_Node_Str"");
  try {
    script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",config.workingDirectory);
    File file=new File(script_file.getAbsolutePath());
    FileWriter txt;
    txt=new FileWriter(file);
    PrintWriter out=new PrintWriter(txt);
    out.write(getScript());
    out.write(""String_Node_Str"");
    out.write(core_script);
    out.write(""String_Node_Str"");
    out.close();
    command.add(script_file.getAbsolutePath());
  }
 catch (  IOException e) {
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
    return Error.Type.UNKNOWN;
  }
script_file.deleteOnExit();
break;
case ""String_Node_Str"":
command.add(getRendererPath());
if (config.getNbCores() > 0) {
command.add(""String_Node_Str"");
command.add(Integer.toString(config.getNbCores()));
}
break;
case ""String_Node_Str"":
command.add(config.workingDirectory.getAbsolutePath() + File.separator + getPrefixOutputImage());
break;
case ""String_Node_Str"":
command.add(getFrameNumber());
break;
default :
command.add(arg);
break;
}
}
try {
String line;
log.debug(command.toString());
OS os=OS.getOS();
process.setCoresUsed(config.getNbCores());
process.start();
getProcessRender().setProcess(os.exec(command,new_env));
BufferedReader input=new BufferedReader(new InputStreamReader(getProcessRender().getProcess().getInputStream()));
long last_update_status=0;
log.debug(""String_Node_Str"");
try {
while ((line=input.readLine()) != null) {
updateRenderingMemoryPeak(line);
log.debug(line);
if ((new Date().getTime() - last_update_status) > 2000) {
updateRenderingStatus(line);
last_update_status=new Date().getTime();
}
Type error=detectError(line);
if (error != Error.Type.OK) {
if (script_file != null) {
script_file.delete();
}
return error;
}
}
input.close();
}
 catch (IOException err1) {
log.error(""String_Node_Str"" + err1);
}
log.debug(""String_Node_Str"");
}
 catch (Exception err) {
if (script_file != null) {
script_file.delete();
}
StringWriter sw=new StringWriter();
err.printStackTrace(new PrintWriter(sw));
log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
return Error.Type.FAILED_TO_EXECUTE;
}
int exit_value=process.exitValue();
process.finish();
if (script_file != null) {
script_file.delete();
}
final String filename_without_extension=getPrefixOutputImage() + getFrameNumber();
FilenameFilter textFilter=new FilenameFilter(){
public boolean accept(File dir,String name){
return name.startsWith(filename_without_extension);
}
}
;
File[] files=config.workingDirectory.listFiles(textFilter);
if (getAskForRendererKill()) {
log.debug(""String_Node_Str"");
if (files.length != 0) {
new File(files[0].getAbsolutePath()).delete();
}
if (getUserBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_USER;
}
return Error.Type.RENDERER_KILLED;
}
if (files.length == 0) {
log.error(""String_Node_Str"" + filename_without_extension + ""String_Node_Str"");
String basename=""String_Node_Str"";
try {
basename=getPath().substring(0,getPath().lastIndexOf('.'));
}
 catch (Exception e) {
e.printStackTrace();
}
File crash_file=new File(config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
if (crash_file.exists()) {
log.error(""String_Node_Str"");
crash_file.delete();
return Error.Type.RENDERER_CRASHED;
}
if (exit_value == 127 && process.getDuration() < 10) {
log.error(""String_Node_Str"" + process.getDuration() + ""String_Node_Str"");
return Error.Type.RENDERER_MISSING_LIBRARIES;
}
return Error.Type.NOOUTPUTFILE;
}
 else {
setOutputImagePath(files[0].getAbsolutePath());
log.debug(""String_Node_Str"" + getOutputImagePath() + ""String_Node_Str"");
}
File scene_dir=new File(getSceneDirectory());
long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
if (date_modification_scene_directory > process.getStartTime()) {
scene_dir.delete();
}
gui.status(String.format(""String_Node_Str"",process.getDuration() / 60,process.getDuration() % 60));
return Error.Type.OK;
}","The original code lacks proper GPU device validation, potentially causing rendering errors when GPU configuration is incomplete. The fixed code adds an additional check `config.getComputeMethod() != ComputeType.CPU` to ensure GPU rendering only occurs with valid GPU devices and compute methods. This improvement prevents potential runtime errors and provides more robust rendering configuration validation across different computational environments."
94578,"public byte[] getLastRender(){
  try {
    HttpURLConnection httpCon=this.HTTPRequest(this.getPage(""String_Node_Str""));
    InputStream inStrm=httpCon.getInputStream();
    if (httpCon.getResponseCode() != HttpURLConnection.HTTP_OK) {
      this.log.debug(""String_Node_Str"" + httpCon.getResponseCode());
      return null;
    }
    int size=httpCon.getContentLength();
    if (size == 0) {
      this.log.debug(""String_Node_Str"");
      return null;
    }
    byte[] ret=new byte[size];
    byte[] ch=new byte[512 * 1024];
    int n=0;
    int i=0;
    while ((n=inStrm.read(ch)) != -1) {
      System.arraycopy(ch,0,ret,i,n);
      i+=n;
    }
    inStrm.close();
    return ret;
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
  return null;
}","public byte[] getLastRender(){
  try {
    HttpURLConnection httpCon=this.HTTPRequest(this.getPage(""String_Node_Str""));
    InputStream inStrm=httpCon.getInputStream();
    if (httpCon.getResponseCode() != HttpURLConnection.HTTP_OK) {
      this.log.debug(""String_Node_Str"" + httpCon.getResponseCode());
      return null;
    }
    int size=httpCon.getContentLength();
    if (size <= 0) {
      this.log.debug(""String_Node_Str"" + size + ""String_Node_Str"");
      return null;
    }
    byte[] ret=new byte[size];
    byte[] ch=new byte[512 * 1024];
    int n=0;
    int i=0;
    while ((n=inStrm.read(ch)) != -1) {
      System.arraycopy(ch,0,ret,i,n);
      i+=n;
    }
    inStrm.close();
    return ret;
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
  return null;
}","The original code incorrectly handled content length when it was zero, potentially causing issues with empty responses. The fixed code changes the condition to `size <= 0`, adding more robust handling and logging for cases where content length is non-positive. This improvement ensures better error detection and prevents potential null or empty byte array allocations, making the method more resilient to various HTTP response scenarios."
94579,"@Override public void actionPerformed(ActionEvent e){
  if (parent == null) {
    return;
  }
  Configuration config=parent.getConfiguration();
  if (config == null) {
    return;
  }
  if (cacheDir != null) {
    File fromConfig=config.getStorageDir();
    if (fromConfig != null && fromConfig.getAbsolutePath().equals(cacheDir.getAbsolutePath()) == false) {
      config.setCacheDir(cacheDir);
    }
 else {
    }
  }
  GPUDevice selected_gpu=null;
  for (  JCheckBoxGPU box : useGPUs) {
    if (box.isSelected()) {
      selected_gpu=box.getGPUDevice();
    }
  }
  ComputeType method=ComputeType.CPU;
  if (useCPU.isSelected() && selected_gpu == null) {
    method=ComputeType.CPU;
  }
 else   if (useCPU.isSelected() == false && selected_gpu != null) {
    method=ComputeType.GPU;
  }
 else   if (useCPU.isSelected() && selected_gpu != null) {
    method=ComputeType.CPU_GPU;
  }
  config.setComputeMethod(method);
  if (selected_gpu != null) {
    config.setUseGPU(selected_gpu);
  }
  int cpu_cores=-1;
  if (cpuCores != null) {
    cpu_cores=cpuCores.getValue();
  }
  if (cpu_cores > 0) {
    config.setUseNbCores(cpu_cores);
  }
  String proxyText=null;
  if (proxy != null) {
    try {
      Proxy.set(proxy.getText());
      proxyText=proxy.getText();
    }
 catch (    MalformedURLException e1) {
      System.err.println(""String_Node_Str"");
      System.err.println(e);
      System.exit(2);
    }
  }
  String tile=null;
  if (customTileSize.isSelected() && tileSizeValue != null) {
    try {
      tile=tileSizeValue.getText().replaceAll(""String_Node_Str"",""String_Node_Str"");
      config.setTileSize(Integer.parseInt(tile));
    }
 catch (    NumberFormatException e1) {
      System.err.println(""String_Node_Str"");
      System.err.println(e);
      System.exit(2);
    }
  }
  parent.setCredentials(login.getText(),new String(password.getPassword()));
  String cachePath=null;
  if (config.getUserSpecifiedACacheDir() && config.getStorageDir() != null) {
    cachePath=config.getStorageDir().getAbsolutePath();
  }
  if (saveFile.isSelected()) {
    new SettingsLoader(login.getText(),new String(password.getPassword()),proxyText,method,selected_gpu,cpu_cores,cachePath,autoSignIn.isSelected(),GuiSwing.type,tile).saveFile();
  }
 else {
    try {
      new File(new SettingsLoader().getFilePath()).delete();
    }
 catch (    SecurityException e3) {
    }
  }
}","@Override public void actionPerformed(ActionEvent e){
  if (parent == null) {
    return;
  }
  Configuration config=parent.getConfiguration();
  if (config == null) {
    return;
  }
  if (cacheDir != null) {
    File fromConfig=config.getStorageDir();
    if (fromConfig != null && fromConfig.getAbsolutePath().equals(cacheDir.getAbsolutePath()) == false) {
      config.setCacheDir(cacheDir);
    }
 else {
    }
  }
  GPUDevice selected_gpu=null;
  for (  JCheckBoxGPU box : useGPUs) {
    if (box.isSelected()) {
      selected_gpu=box.getGPUDevice();
    }
  }
  ComputeType method=ComputeType.CPU;
  if (useCPU.isSelected() && selected_gpu == null) {
    method=ComputeType.CPU;
  }
 else   if (useCPU.isSelected() == false && selected_gpu != null) {
    method=ComputeType.GPU;
  }
 else   if (useCPU.isSelected() && selected_gpu != null) {
    method=ComputeType.CPU_GPU;
  }
  config.setComputeMethod(method);
  if (selected_gpu != null) {
    config.setUseGPU(selected_gpu);
  }
  int cpu_cores=-1;
  if (cpuCores != null) {
    cpu_cores=cpuCores.getValue();
  }
  if (cpu_cores > 0) {
    config.setUseNbCores(cpu_cores);
  }
  String proxyText=null;
  if (proxy != null) {
    try {
      Proxy.set(proxy.getText());
      proxyText=proxy.getText();
    }
 catch (    MalformedURLException e1) {
      System.err.println(""String_Node_Str"");
      System.err.println(e1);
      System.exit(2);
    }
  }
  String tile=null;
  if (customTileSize.isSelected() && tileSizeValue != null) {
    try {
      tile=tileSizeValue.getText().replaceAll(""String_Node_Str"",""String_Node_Str"");
      config.setTileSize(Integer.parseInt(tile));
    }
 catch (    NumberFormatException e1) {
      System.err.println(""String_Node_Str"");
      System.err.println(e1);
      System.exit(2);
    }
  }
  parent.setCredentials(login.getText(),new String(password.getPassword()));
  String cachePath=null;
  if (config.getUserSpecifiedACacheDir() && config.getStorageDir() != null) {
    cachePath=config.getStorageDir().getAbsolutePath();
  }
  if (saveFile.isSelected()) {
    new SettingsLoader(login.getText(),new String(password.getPassword()),proxyText,method,selected_gpu,cpu_cores,cachePath,autoSignIn.isSelected(),GuiSwing.type,tile).saveFile();
  }
 else {
    try {
      new File(new SettingsLoader().getFilePath()).delete();
    }
 catch (    SecurityException e3) {
    }
  }
}","The buggy code used a generic `e` instead of the specific exception `e1` when printing error details, potentially masking the actual exception information. In the fixed code, `System.err.println(e)` was replaced with `System.err.println(e1)`, correctly capturing and displaying the specific exception details. This change improves error handling by providing more precise diagnostic information about potential issues during configuration and settings processing."
94580,"@Override public void show(){
  JPanel current_project_panel=new JPanel(new SpringLayout());
  current_project_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel current_project_status=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel current_project_name=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel current_project_duration=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel current_project_progression=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  current_project_panel.add(current_project_status);
  current_project_panel.add(statusContent);
  current_project_panel.add(current_project_name);
  current_project_panel.add(current_project_name_value);
  current_project_panel.add(current_project_duration);
  current_project_panel.add(current_project_duration_value);
  current_project_panel.add(current_project_progression);
  current_project_panel.add(currrent_project_progression_value);
  JPanel session_info_panel=new JPanel(new SpringLayout());
  session_info_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel user_info_credits_this_session=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel user_info_total_rendertime_this_session=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel user_info_rendered_frame_this_session=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  session_info_panel.add(user_info_credits_this_session);
  session_info_panel.add(creditEarned);
  session_info_panel.add(user_info_rendered_frame_this_session);
  session_info_panel.add(renderedFrameContent);
  session_info_panel.add(user_info_total_rendertime_this_session);
  session_info_panel.add(user_info_total_rendertime_this_session_value);
  JPanel global_stats_panel=new JPanel(new SpringLayout());
  global_stats_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel global_stats_machine_connected=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel global_stats_remaining_frame=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel global_stats_waiting_project=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel global_stats_user_points=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  global_stats_panel.add(global_stats_waiting_project);
  global_stats_panel.add(waiting_projects_value);
  global_stats_panel.add(global_stats_machine_connected);
  global_stats_panel.add(connected_machines_value);
  global_stats_panel.add(global_stats_remaining_frame);
  global_stats_panel.add(remainingFrameContent);
  global_stats_panel.add(global_stats_user_points);
  global_stats_panel.add(user_info_points_total_value);
  JPanel last_frame_panel=new JPanel();
  last_frame_panel.setLayout(new BoxLayout(last_frame_panel,BoxLayout.Y_AXIS));
  last_frame_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  lastRender.setIcon(new ImageIcon(new BufferedImage(200,120,BufferedImage.TYPE_INT_ARGB)));
  lastRender.setAlignmentX(Component.CENTER_ALIGNMENT);
  lastRenderTime.setAlignmentX(Component.CENTER_ALIGNMENT);
  last_frame_panel.add(lastRenderTime);
  last_frame_panel.add(lastRender);
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  JLabel labelImage=new JLabel(image);
  labelImage.setAlignmentX(Component.CENTER_ALIGNMENT);
  parent.getContentPane().add(labelImage);
  JPanel buttonsPanel=new JPanel(new GridLayout(2,2));
  JButton settingsButton=new JButton(""String_Node_Str"");
  settingsButton.addActionListener(new SettingsAction());
  pauseButton=new JButton(""String_Node_Str"");
  pauseButton.addActionListener(new PauseAction());
  JButton blockJob=new JButton(""String_Node_Str"");
  blockJob.addActionListener(new blockJobAction());
  exitAfterFrame=new JButton(""String_Node_Str"");
  exitAfterFrame.addActionListener(new ExitAfterAction());
  buttonsPanel.add(settingsButton);
  buttonsPanel.add(pauseButton);
  buttonsPanel.add(blockJob);
  buttonsPanel.add(exitAfterFrame);
  parent.getContentPane().setLayout(new GridBagLayout());
  GridBagConstraints global_constraints=new GridBagConstraints();
  global_constraints.fill=GridBagConstraints.HORIZONTAL;
  global_constraints.weightx=1;
  global_constraints.gridx=0;
  parent.getContentPane().add(current_project_panel,global_constraints);
  parent.getContentPane().add(global_stats_panel,global_constraints);
  parent.getContentPane().add(session_info_panel,global_constraints);
  parent.getContentPane().add(last_frame_panel,global_constraints);
  parent.getContentPane().add(buttonsPanel,global_constraints);
  Spring widthLeftColumn=getBestWidth(current_project_panel,4,2);
  widthLeftColumn=Spring.max(widthLeftColumn,getBestWidth(global_stats_panel,4,2));
  widthLeftColumn=Spring.max(widthLeftColumn,getBestWidth(session_info_panel,3,2));
  alignPanel(current_project_panel,4,2,widthLeftColumn);
  alignPanel(global_stats_panel,4,2,widthLeftColumn);
  alignPanel(session_info_panel,3,2,widthLeftColumn);
}","@Override public void show(){
  JPanel current_project_panel=new JPanel(new SpringLayout());
  current_project_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel current_project_status=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel current_project_name=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel current_project_duration=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel current_project_progression=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  current_project_panel.add(current_project_status);
  current_project_panel.add(statusContent);
  current_project_panel.add(current_project_name);
  current_project_panel.add(current_project_name_value);
  current_project_panel.add(current_project_duration);
  current_project_panel.add(current_project_duration_value);
  current_project_panel.add(current_project_progression);
  current_project_panel.add(currrent_project_progression_value);
  JPanel session_info_panel=new JPanel(new SpringLayout());
  session_info_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel user_info_credits_this_session=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel user_info_total_rendertime_this_session=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel user_info_rendered_frame_this_session=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  session_info_panel.add(user_info_credits_this_session);
  session_info_panel.add(creditEarned);
  session_info_panel.add(user_info_rendered_frame_this_session);
  session_info_panel.add(renderedFrameContent);
  session_info_panel.add(user_info_total_rendertime_this_session);
  session_info_panel.add(user_info_total_rendertime_this_session_value);
  JPanel global_stats_panel=new JPanel(new SpringLayout());
  global_stats_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JLabel global_stats_machine_connected=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel global_stats_remaining_frame=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel global_stats_waiting_project=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  JLabel global_stats_user_points=new JLabel(""String_Node_Str"",JLabel.TRAILING);
  global_stats_panel.add(global_stats_waiting_project);
  global_stats_panel.add(waiting_projects_value);
  global_stats_panel.add(global_stats_machine_connected);
  global_stats_panel.add(connected_machines_value);
  global_stats_panel.add(global_stats_remaining_frame);
  global_stats_panel.add(remainingFrameContent);
  global_stats_panel.add(global_stats_user_points);
  global_stats_panel.add(user_info_points_total_value);
  JPanel last_frame_panel=new JPanel();
  last_frame_panel.setLayout(new BoxLayout(last_frame_panel,BoxLayout.Y_AXIS));
  last_frame_panel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  lastRender.setIcon(new ImageIcon(new BufferedImage(200,120,BufferedImage.TYPE_INT_ARGB)));
  lastRender.setAlignmentX(Component.CENTER_ALIGNMENT);
  lastRenderTime.setAlignmentX(Component.CENTER_ALIGNMENT);
  last_frame_panel.add(lastRenderTime);
  last_frame_panel.add(lastRender);
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  JLabel labelImage=new JLabel(image);
  labelImage.setAlignmentX(Component.CENTER_ALIGNMENT);
  parent.getContentPane().add(labelImage);
  JPanel buttonsPanel=new JPanel(new GridLayout(2,2));
  JButton settingsButton=new JButton(""String_Node_Str"");
  settingsButton.addActionListener(new SettingsAction());
  pauseButton=new JButton(""String_Node_Str"");
  Client client=parent.getClient();
  if (client != null && client.isSuspended()) {
    pauseButton.setText(""String_Node_Str"");
  }
  pauseButton.addActionListener(new PauseAction());
  JButton blockJob=new JButton(""String_Node_Str"");
  blockJob.addActionListener(new blockJobAction());
  exitAfterFrame=new JButton(""String_Node_Str"");
  exitAfterFrame.addActionListener(new ExitAfterAction());
  buttonsPanel.add(settingsButton);
  buttonsPanel.add(pauseButton);
  buttonsPanel.add(blockJob);
  buttonsPanel.add(exitAfterFrame);
  parent.getContentPane().setLayout(new GridBagLayout());
  GridBagConstraints global_constraints=new GridBagConstraints();
  global_constraints.fill=GridBagConstraints.HORIZONTAL;
  global_constraints.weightx=1;
  global_constraints.gridx=0;
  parent.getContentPane().add(current_project_panel,global_constraints);
  parent.getContentPane().add(global_stats_panel,global_constraints);
  parent.getContentPane().add(session_info_panel,global_constraints);
  parent.getContentPane().add(last_frame_panel,global_constraints);
  parent.getContentPane().add(buttonsPanel,global_constraints);
  Spring widthLeftColumn=getBestWidth(current_project_panel,4,2);
  widthLeftColumn=Spring.max(widthLeftColumn,getBestWidth(global_stats_panel,4,2));
  widthLeftColumn=Spring.max(widthLeftColumn,getBestWidth(session_info_panel,3,2));
  alignPanel(current_project_panel,4,2,widthLeftColumn);
  alignPanel(global_stats_panel,4,2,widthLeftColumn);
  alignPanel(session_info_panel,3,2,widthLeftColumn);
}","The original code lacked proper handling of the pause button state for suspended client scenarios. The fixed code adds a check for client suspension status and dynamically sets the pause button text accordingly, using `parent.getClient()` to retrieve the client instance. This modification ensures the pause button reflects the current client state, improving user interface responsiveness and providing more accurate visual feedback during different rendering conditions."
94581,"public synchronized int stop(){
  this.running=false;
  this.disableErrorSending=true;
  if (this.renderingJob != null) {
    if (this.renderingJob.getProcessRender().getProcess() != null) {
      OS.getOS().kill(this.renderingJob.getProcessRender().getProcess());
      this.renderingJob.setAskForRendererKill(true);
    }
  }
  this.config.removeWorkingDirectory();
  if (this.server == null) {
    return 0;
  }
  try {
    this.server.HTTPRequest(this.server.getPage(""String_Node_Str""));
  }
 catch (  IOException e) {
  }
  this.server.interrupt();
  try {
    this.server.join();
  }
 catch (  InterruptedException e) {
  }
  this.server=null;
  this.gui.stop();
  return 0;
}","public synchronized int stop(){
  this.running=false;
  this.disableErrorSending=true;
  if (this.renderingJob != null) {
    if (this.renderingJob.getProcessRender().getProcess() != null) {
      OS.getOS().kill(this.renderingJob.getProcessRender().getProcess());
      this.renderingJob.setAskForRendererKill(true);
    }
  }
  this.config.removeWorkingDirectory();
  if (this.server == null) {
    return 0;
  }
  try {
    this.server.HTTPRequest(this.server.getPage(""String_Node_Str""));
  }
 catch (  IOException e) {
  }
  this.server.interrupt();
  try {
    this.server.join();
  }
 catch (  InterruptedException e) {
  }
  this.server=null;
  return 0;
}","The original code called `this.gui.stop()` after nullifying the server, which could potentially lead to unexpected behavior or resource leaks during thread shutdown. The fixed code removes the `this.gui.stop()` method call, ensuring a cleaner and more predictable server and thread termination process. By eliminating this unnecessary method invocation, the code now provides a more straightforward and focused approach to stopping the server and its associated resources."
94582,"@Override public void start(){
  if (client != null) {
    Signal.handle(new Signal(""String_Node_Str""),new SignalHandler(){
      @Override public void handle(      Signal signal){
        sigIntCount++;
        if (sigIntCount == 4) {
          System.out.println(""String_Node_Str"");
        }
 else         if (sigIntCount == 5) {
          Signal.raise(new Signal(""String_Node_Str""));
          Runtime.getRuntime().halt(0);
        }
 else         if (client.isRunning() && client.isSuspended() == false) {
          client.askForStop();
          System.out.println(""String_Node_Str"");
        }
 else {
          client.stop();
        }
      }
    }
);
    client.run();
    client.stop();
  }
}","@Override public void start(){
  if (client != null) {
    Signal.handle(new Signal(""String_Node_Str""),new SignalHandler(){
      @Override public void handle(      Signal signal){
        sigIntCount++;
        if (sigIntCount == 4) {
          System.out.println(""String_Node_Str"");
        }
 else         if (sigIntCount == 5) {
          Signal.raise(new Signal(""String_Node_Str""));
          Runtime.getRuntime().halt(0);
        }
 else         if (client.isRunning() && client.isSuspended() == false) {
          client.askForStop();
          System.out.println(""String_Node_Str"");
        }
 else {
          client.stop();
          GuiText.this.stop();
        }
      }
    }
);
    client.run();
    client.stop();
  }
}","The original code lacks proper stopping mechanism for the GuiText instance when the client cannot be stopped. In the fixed version, `GuiText.this.stop()` is added to the else block, ensuring that the entire application stops when the client cannot be stopped. This change provides a complete and robust shutdown process, preventing potential resource leaks and ensuring clean termination of the application."
94583,"@Override public void handle(Signal signal){
  sigIntCount++;
  if (sigIntCount == 4) {
    System.out.println(""String_Node_Str"");
  }
 else   if (sigIntCount == 5) {
    Signal.raise(new Signal(""String_Node_Str""));
    Runtime.getRuntime().halt(0);
  }
 else   if (client.isRunning() && client.isSuspended() == false) {
    client.askForStop();
    System.out.println(""String_Node_Str"");
  }
 else {
    client.stop();
  }
}","@Override public void handle(Signal signal){
  sigIntCount++;
  if (sigIntCount == 4) {
    System.out.println(""String_Node_Str"");
  }
 else   if (sigIntCount == 5) {
    Signal.raise(new Signal(""String_Node_Str""));
    Runtime.getRuntime().halt(0);
  }
 else   if (client.isRunning() && client.isSuspended() == false) {
    client.askForStop();
    System.out.println(""String_Node_Str"");
  }
 else {
    client.stop();
    GuiText.this.stop();
  }
}","The original code lacks a crucial step to fully stop the GuiText component when the client stops, potentially leaving the application in an inconsistent state. The fixed code adds `GuiText.this.stop()` to ensure complete termination of the GUI thread alongside the client stop operation. This change guarantees a clean and comprehensive shutdown process, preventing potential resource leaks or hanging threads."
94584,"@Override public void start(){
  if (client != null) {
    Signal.handle(new Signal(""String_Node_Str""),new SignalHandler(){
      @Override public void handle(      Signal signal){
        sigIntCount++;
        if (sigIntCount == 5) {
          Signal.raise(new Signal(""String_Node_Str""));
          Runtime.getRuntime().halt(0);
        }
 else         if (client.isRunning() && client.isSuspended() == false) {
          client.askForStop();
          exiting=true;
        }
 else {
          client.stop();
        }
      }
    }
);
    client.run();
    client.stop();
  }
}","@Override public void start(){
  if (client != null) {
    Signal.handle(new Signal(""String_Node_Str""),new SignalHandler(){
      @Override public void handle(      Signal signal){
        sigIntCount++;
        if (sigIntCount == 5) {
          Signal.raise(new Signal(""String_Node_Str""));
          Runtime.getRuntime().halt(0);
        }
 else         if (client.isRunning() && client.isSuspended() == false) {
          client.askForStop();
          exiting=true;
        }
 else {
          client.stop();
          GuiTextOneLine.this.stop();
        }
      }
    }
);
    client.run();
    client.stop();
  }
}","The original code lacked a proper stop mechanism for the GuiTextOneLine instance when the client stops, potentially leaving the application in an inconsistent state. The fixed code adds `GuiTextOneLine.this.stop()` to explicitly stop the current instance when the client stops, ensuring a clean and complete shutdown. This modification prevents potential resource leaks and improves the overall graceful termination of the application."
94585,"@Override public void handle(Signal signal){
  sigIntCount++;
  if (sigIntCount == 5) {
    Signal.raise(new Signal(""String_Node_Str""));
    Runtime.getRuntime().halt(0);
  }
 else   if (client.isRunning() && client.isSuspended() == false) {
    client.askForStop();
    exiting=true;
  }
 else {
    client.stop();
  }
}","@Override public void handle(Signal signal){
  sigIntCount++;
  if (sigIntCount == 5) {
    Signal.raise(new Signal(""String_Node_Str""));
    Runtime.getRuntime().halt(0);
  }
 else   if (client.isRunning() && client.isSuspended() == false) {
    client.askForStop();
    exiting=true;
  }
 else {
    client.stop();
    GuiTextOneLine.this.stop();
  }
}","The original code omits stopping the specific instance (GuiTextOneLine) when the client is in a non-running or suspended state, potentially leaving the application in an inconsistent state. The fixed code adds `GuiTextOneLine.this.stop()` to explicitly halt the current instance, ensuring complete and proper termination. This change guarantees a clean and comprehensive shutdown process, preventing potential resource leaks or hanging threads."
94586,"public Error.Type render(){
  gui.status(""String_Node_Str"" + this.name + ""String_Node_Str"");
  RenderProcess process=getProcessRender();
  String core_script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  if (getUseGPU() && config.getGPUDevice() != null) {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",config.getGPUDevice().getCudaName());
  }
 else {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  core_script+=String.format(""String_Node_Str"",getTileSize());
  File script_file=null;
  String command1[]=getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (config.getNbCores() > 0) {
    size_command+=2;
  }
  List<String> command=new ArrayList<String>(size_command);
  Map<String,String> new_env=new HashMap<String,String>();
  new_env.put(""String_Node_Str"",config.workingDirectory.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
  new_env.put(""String_Node_Str"",Integer.toString(config.getNbCores()));
  for (  String arg : command1) {
switch (arg) {
case ""String_Node_Str"":
      command.add(getScenePath());
    command.add(""String_Node_Str"");
  try {
    script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",config.workingDirectory);
    File file=new File(script_file.getAbsolutePath());
    FileWriter txt;
    txt=new FileWriter(file);
    PrintWriter out=new PrintWriter(txt);
    out.write(getScript());
    out.write(""String_Node_Str"");
    out.write(core_script);
    out.write(""String_Node_Str"");
    out.close();
    command.add(script_file.getAbsolutePath());
  }
 catch (  IOException e) {
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
    return Error.Type.UNKNOWN;
  }
script_file.deleteOnExit();
break;
case ""String_Node_Str"":
command.add(getRendererPath());
if (config.getNbCores() > 0) {
command.add(""String_Node_Str"");
command.add(Integer.toString(config.getNbCores()));
}
break;
case ""String_Node_Str"":
command.add(config.workingDirectory.getAbsolutePath() + File.separator + getPrefixOutputImage());
break;
case ""String_Node_Str"":
command.add(getFrameNumber());
break;
default :
command.add(arg);
break;
}
}
try {
String line;
log.debug(command.toString());
OS os=OS.getOS();
process.setCoresUsed(config.getNbCores());
process.start();
getProcessRender().setProcess(os.exec(command,new_env));
BufferedReader input=new BufferedReader(new InputStreamReader(getProcessRender().getProcess().getInputStream()));
long last_update_status=0;
log.debug(""String_Node_Str"");
try {
while ((line=input.readLine()) != null) {
updateRenderingMemoryPeak(line);
log.debug(line);
if ((new Date().getTime() - last_update_status) > 2000) {
updateRenderingStatus(line);
last_update_status=new Date().getTime();
}
Type error=detectError(line);
if (error != Error.Type.OK) {
if (script_file != null) {
script_file.delete();
}
return error;
}
}
input.close();
}
 catch (IOException err1) {
log.error(""String_Node_Str"" + err1);
}
log.debug(""String_Node_Str"");
}
 catch (Exception err) {
if (script_file != null) {
script_file.delete();
}
StringWriter sw=new StringWriter();
err.printStackTrace(new PrintWriter(sw));
log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
return Error.Type.FAILED_TO_EXECUTE;
}
int exit_value=process.exitValue();
process.finish();
if (script_file != null) {
script_file.delete();
}
final String filename_without_extension=getPrefixOutputImage() + getFrameNumber();
FilenameFilter textFilter=new FilenameFilter(){
public boolean accept(File dir,String name){
return name.startsWith(filename_without_extension);
}
}
;
File[] files=config.workingDirectory.listFiles(textFilter);
if (files.length == 0) {
log.error(""String_Node_Str"" + filename_without_extension + ""String_Node_Str"");
if (getAskForRendererKill()) {
log.debug(""String_Node_Str"");
if (getUserBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_USER;
}
return Error.Type.RENDERER_KILLED;
}
String basename=""String_Node_Str"";
try {
basename=getPath().substring(0,getPath().lastIndexOf('.'));
}
 catch (Exception e) {
e.printStackTrace();
}
File crash_file=new File(config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
if (crash_file.exists()) {
log.error(""String_Node_Str"");
crash_file.delete();
return Error.Type.RENDERER_CRASHED;
}
if (exit_value == 127 && process.getDuration() < 10) {
log.error(""String_Node_Str"" + process.getDuration() + ""String_Node_Str"");
return Error.Type.RENDERER_MISSING_LIBRARIES;
}
return Error.Type.NOOUTPUTFILE;
}
 else {
setOutputImagePath(files[0].getAbsolutePath());
log.debug(""String_Node_Str"" + getOutputImagePath() + ""String_Node_Str"");
}
File scene_dir=new File(getSceneDirectory());
long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
if (date_modification_scene_directory > process.getStartTime()) {
scene_dir.delete();
}
gui.status(String.format(""String_Node_Str"",process.getDuration() / 60,process.getDuration() % 60));
return Error.Type.OK;
}","public Error.Type render(){
  gui.status(""String_Node_Str"" + this.name + ""String_Node_Str"");
  RenderProcess process=getProcessRender();
  String core_script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  if (getUseGPU() && config.getGPUDevice() != null) {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",config.getGPUDevice().getCudaName());
  }
 else {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  core_script+=String.format(""String_Node_Str"",getTileSize());
  File script_file=null;
  String command1[]=getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (config.getNbCores() > 0) {
    size_command+=2;
  }
  List<String> command=new ArrayList<String>(size_command);
  Map<String,String> new_env=new HashMap<String,String>();
  new_env.put(""String_Node_Str"",config.workingDirectory.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
  new_env.put(""String_Node_Str"",Integer.toString(config.getNbCores()));
  for (  String arg : command1) {
switch (arg) {
case ""String_Node_Str"":
      command.add(getScenePath());
    command.add(""String_Node_Str"");
  try {
    script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",config.workingDirectory);
    File file=new File(script_file.getAbsolutePath());
    FileWriter txt;
    txt=new FileWriter(file);
    PrintWriter out=new PrintWriter(txt);
    out.write(getScript());
    out.write(""String_Node_Str"");
    out.write(core_script);
    out.write(""String_Node_Str"");
    out.close();
    command.add(script_file.getAbsolutePath());
  }
 catch (  IOException e) {
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
    return Error.Type.UNKNOWN;
  }
script_file.deleteOnExit();
break;
case ""String_Node_Str"":
command.add(getRendererPath());
if (config.getNbCores() > 0) {
command.add(""String_Node_Str"");
command.add(Integer.toString(config.getNbCores()));
}
break;
case ""String_Node_Str"":
command.add(config.workingDirectory.getAbsolutePath() + File.separator + getPrefixOutputImage());
break;
case ""String_Node_Str"":
command.add(getFrameNumber());
break;
default :
command.add(arg);
break;
}
}
try {
String line;
log.debug(command.toString());
OS os=OS.getOS();
process.setCoresUsed(config.getNbCores());
process.start();
getProcessRender().setProcess(os.exec(command,new_env));
BufferedReader input=new BufferedReader(new InputStreamReader(getProcessRender().getProcess().getInputStream()));
long last_update_status=0;
log.debug(""String_Node_Str"");
try {
while ((line=input.readLine()) != null) {
updateRenderingMemoryPeak(line);
log.debug(line);
if ((new Date().getTime() - last_update_status) > 2000) {
updateRenderingStatus(line);
last_update_status=new Date().getTime();
}
Type error=detectError(line);
if (error != Error.Type.OK) {
if (script_file != null) {
script_file.delete();
}
return error;
}
}
input.close();
}
 catch (IOException err1) {
log.error(""String_Node_Str"" + err1);
}
log.debug(""String_Node_Str"");
}
 catch (Exception err) {
if (script_file != null) {
script_file.delete();
}
StringWriter sw=new StringWriter();
err.printStackTrace(new PrintWriter(sw));
log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
return Error.Type.FAILED_TO_EXECUTE;
}
int exit_value=process.exitValue();
process.finish();
if (script_file != null) {
script_file.delete();
}
final String filename_without_extension=getPrefixOutputImage() + getFrameNumber();
FilenameFilter textFilter=new FilenameFilter(){
public boolean accept(File dir,String name){
return name.startsWith(filename_without_extension);
}
}
;
File[] files=config.workingDirectory.listFiles(textFilter);
if (getAskForRendererKill()) {
log.debug(""String_Node_Str"");
if (files.length != 0) {
new File(files[0].getAbsolutePath()).delete();
}
if (getUserBlockJob()) {
return Error.Type.RENDERER_KILLED_BY_USER;
}
return Error.Type.RENDERER_KILLED;
}
if (files.length == 0) {
log.error(""String_Node_Str"" + filename_without_extension + ""String_Node_Str"");
String basename=""String_Node_Str"";
try {
basename=getPath().substring(0,getPath().lastIndexOf('.'));
}
 catch (Exception e) {
e.printStackTrace();
}
File crash_file=new File(config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
if (crash_file.exists()) {
log.error(""String_Node_Str"");
crash_file.delete();
return Error.Type.RENDERER_CRASHED;
}
if (exit_value == 127 && process.getDuration() < 10) {
log.error(""String_Node_Str"" + process.getDuration() + ""String_Node_Str"");
return Error.Type.RENDERER_MISSING_LIBRARIES;
}
return Error.Type.NOOUTPUTFILE;
}
 else {
setOutputImagePath(files[0].getAbsolutePath());
log.debug(""String_Node_Str"" + getOutputImagePath() + ""String_Node_Str"");
}
File scene_dir=new File(getSceneDirectory());
long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
if (date_modification_scene_directory > process.getStartTime()) {
scene_dir.delete();
}
gui.status(String.format(""String_Node_Str"",process.getDuration() / 60,process.getDuration() % 60));
return Error.Type.OK;
}","The original code had incorrect error handling for renderer kill scenarios, potentially leaving unhandled file states and improper error reporting. The fixed code moves the renderer kill check before file existence validation, ensuring proper cleanup and accurate error propagation when a renderer is intentionally stopped. This modification provides more robust error handling, clearer state management, and prevents potential resource leaks during rendering processes."
94587,"public GuiTextOneLine(){
  rendered=0;
  remaining=0;
  status=""String_Node_Str"";
  line=""String_Node_Str"";
}","public GuiTextOneLine(){
  rendered=0;
  remaining=0;
  creditsEarned=null;
  status=""String_Node_Str"";
  line=""String_Node_Str"";
}","The original code omitted initializing the `creditsEarned` variable, which could lead to potential null pointer exceptions or unexpected behavior when accessing this uninitialized field. In the fixed code, `creditsEarned` is explicitly set to `null`, ensuring a clear and intentional initialization of the variable. This change provides better code clarity, prevents potential runtime errors, and follows good initialization practices by explicitly defining the initial state of the object's member variable."
94588,"private void updateLine(){
  String creditsEarned=client.getServer().getCreditEarnedOnCurrentSession();
  int charToRemove=line.length();
  System.out.print(""String_Node_Str"");
  line=String.format(""String_Node_Str"",rendered,remaining,creditsEarned != null ? creditsEarned : ""String_Node_Str"",status + (exiting ? ""String_Node_Str"" : ""String_Node_Str""));
  System.out.print(line);
  for (int i=line.length(); i <= charToRemove; i++) {
    System.out.print(""String_Node_Str"");
  }
}","private void updateLine(){
  int charToRemove=line.length();
  System.out.print(""String_Node_Str"");
  line=String.format(""String_Node_Str"",rendered,remaining,creditsEarned != null ? creditsEarned : ""String_Node_Str"",status + (exiting ? ""String_Node_Str"" : ""String_Node_Str""));
  System.out.print(line);
  for (int i=line.length(); i <= charToRemove; i++) {
    System.out.print(""String_Node_Str"");
  }
}","The original code incorrectly referenced `creditsEarned` before declaring it, potentially causing a compilation error or null pointer exception. The fixed code removed the unnecessary method call to `client.getServer().getCreditEarnedOnCurrentSession()` and ensures proper variable scoping. By simplifying the code and removing the undefined method call, the fixed version prevents potential runtime errors and improves code reliability."
94589,"@Override public void AddFrameRendered(){
  rendered+=1;
  updateLine();
}","@Override public void AddFrameRendered(){
  rendered+=1;
  creditsEarned=client.getServer().getCreditEarnedOnCurrentSession();
  updateLine();
}","The original code lacked proper credit tracking, potentially leading to inaccurate session credit calculations. The fixed code adds a crucial line retrieving current session credits from the client server, ensuring accurate credit tracking by explicitly updating the `creditsEarned` variable. By dynamically fetching credits during frame rendering, the new implementation provides a more reliable and real-time approach to monitoring and recording earned credits."
94590,"public void showLastRender(){
  Client client=parent.getClient();
  if (client != null) {
    Server server=client.getServer();
    if (server != null) {
      byte[] data=server.getLastRender();
      if (data != null) {
        InputStream is=new ByteArrayInputStream(data);
        try {
          BufferedImage image=ImageIO.read(is);
          lastRender.setIcon(new ImageIcon(image));
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + e);
          e.printStackTrace();
        }
      }
    }
  }
}","public void showLastRender(){
  Client client=parent.getClient();
  if (client != null) {
    Server server=client.getServer();
    if (server != null) {
      byte[] data=server.getLastRender();
      if (data != null) {
        InputStream is=new ByteArrayInputStream(data);
        try {
          BufferedImage image=ImageIO.read(is);
          if (image != null) {
            lastRender.setIcon(new ImageIcon(image));
          }
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + e);
          e.printStackTrace();
        }
      }
    }
  }
}","The original code lacks a null check on the image returned by ImageIO.read(), which could lead to setting a null icon and potentially causing a NullPointerException. The fixed code adds an explicit null check for the image before setting it as an icon, ensuring that only valid images are displayed. This additional validation prevents potential runtime errors and improves the robustness of the image rendering process."
94591,"@Override public void actionPerformed(ActionEvent e){
  Client client=parent.getClient();
  if (client != null) {
    client.getRenderingJob().setAskForRendererKill(true);
    client.getRenderingJob().setUserBlockJob(true);
    OS.getOS().kill(client.getRenderingJob().getProcessRender().getProcess());
  }
}","@Override public void actionPerformed(ActionEvent e){
  Client client=parent.getClient();
  if (client != null) {
    Job job=client.getRenderingJob();
    if (job != null) {
      job.setAskForRendererKill(true);
      job.setUserBlockJob(true);
      RenderProcess process=job.getProcessRender();
      if (process != null) {
        OS.getOS().kill(process.getProcess());
      }
    }
  }
}","The original code lacks null checks, risking potential NullPointerExceptions when accessing nested objects like rendering jobs and processes. The fixed code introduces additional null checks for client's rendering job and render process before performing operations, ensuring robust error handling and preventing unexpected runtime failures. These defensive programming techniques make the code more resilient by gracefully handling scenarios where intermediate objects might be null, thus improving overall code reliability and stability."
94592,"@Override public CPU getCPU(){
  CPU ret=new CPU();
  try {
    Runtime r=Runtime.getRuntime();
    Process p=r.exec(""String_Node_Str"");
    BufferedReader b=new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line=""String_Node_Str"";
    while ((line=b.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        String buf[]=line.split(""String_Node_Str"");
        if (buf.length > 1) {
          ret.setName(buf[1].trim());
        }
      }
      if (line.contains(""String_Node_Str"") && line.contains(""String_Node_Str"")) {
        String buf[]=line.split(""String_Node_Str"");
        for (int i=0; i < buf.length; i++) {
          if (buf[i].contains(""String_Node_Str"")) {
            String family=buf[i].split(""String_Node_Str"")[1];
            ret.setFamily(family.split(""String_Node_Str"")[1]);
          }
          if (buf[i].contains(""String_Node_Str"")) {
            String model=buf[i].split(""String_Node_Str"")[1];
            ret.setModel(model.split(""String_Node_Str"")[1]);
          }
        }
      }
    }
    b.close();
    return ret;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return ret;
}","@Override public CPU getCPU(){
  CPU ret=new CPU();
  try {
    Runtime r=Runtime.getRuntime();
    Process p=r.exec(""String_Node_Str"");
    BufferedReader b=new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line=""String_Node_Str"";
    while ((line=b.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        String buf[]=line.split(""String_Node_Str"");
        if (buf.length > 1) {
          ret.setName(buf[1].trim());
        }
      }
      if (line.contains(""String_Node_Str"") && line.contains(""String_Node_Str"")) {
        String buf[]=line.split(""String_Node_Str"");
        for (int i=0; i < buf.length; i++) {
          if (buf[i].contains(""String_Node_Str"")) {
            String family=buf[i].split(""String_Node_Str"")[1];
            ret.setFamily(family.split(""String_Node_Str"")[1]);
          }
          if (buf[i].contains(""String_Node_Str"")) {
            String model=buf[i].split(""String_Node_Str"")[1];
            ret.setModel(model.split(""String_Node_Str"")[1]);
          }
        }
      }
    }
    b.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (ret.haveData() == false) {
    Log.getInstance(null).debug(""String_Node_Str"");
    ret.setModel(""String_Node_Str"");
    ret.setFamily(""String_Node_Str"");
    try {
      Runtime run=Runtime.getRuntime();
      Process sysctl=run.exec(""String_Node_Str"");
      BufferedReader buf=new BufferedReader(new InputStreamReader(sysctl.getInputStream()));
      String name=""String_Node_Str"";
      name=buf.readLine();
      buf.close();
      if (name == ""String_Node_Str"") {
        ret.setName(""String_Node_Str"");
      }
 else {
        ret.setName(name);
      }
    }
 catch (    IOException e) {
      Log.getInstance(null).debug(""String_Node_Str"" + e);
    }
  }
  return ret;
}","The original code lacks proper error handling and does not guarantee returning a valid CPU object if data retrieval fails. The fixed code adds a fallback mechanism using an alternative system command and checks if valid CPU data was obtained, with an additional error logging step. This improvement ensures a more robust method that always returns a CPU object with meaningful information, even when the primary data extraction method encounters issues."
94593,"@Override public int getMemory(){
  try {
    Runtime r=Runtime.getRuntime();
    Process p=r.exec(""String_Node_Str"");
    BufferedReader b=new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line=""String_Node_Str"";
    while ((line=b.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        String buf[]=line.split(""String_Node_Str"");
        if (buf.length > 4) {
          Long mem_byte=Long.parseLong(buf[3].trim());
          return (int)(mem_byte / Long.valueOf(1024));
        }
      }
    }
    b.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return 0;
}","@Override public int getMemory(){
  try {
    Runtime r=Runtime.getRuntime();
    Process p=r.exec(""String_Node_Str"");
    BufferedReader b=new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line=""String_Node_Str"";
    line=b.readLine();
    b.close();
    if (line.isEmpty()) {
      return 0;
    }
    Long mem_byte=Long.parseLong(line.trim());
    return (int)(mem_byte / Long.valueOf(1024));
  }
 catch (  IOException e) {
    Log.getInstance(null).debug(""String_Node_Str"" + e);
  }
  return 0;
}","The original code unnecessarily complicated memory retrieval by attempting complex parsing and potentially getting stuck in an infinite loop. The fixed code simplifies the approach by reading a single line directly, parsing the memory value more straightforwardly, and handling potential errors with a cleaner exception mechanism. This results in more robust, readable code that efficiently extracts memory information with reduced complexity and improved error handling."
94594,"@Override public void show(){
  Configuration config=parent.getConfiguration();
  new SettingsLoader().merge(config);
  List<GPUDevice> gpus=GPU.listDevices();
  GridBagConstraints constraints=new GridBagConstraints();
  int columns=Math.max(5,4 + (gpus != null ? gpus.size() : 0));
  int currentRow=0;
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  JLabel labelImage=new JLabel(image);
  labelImage.setBorder(BorderFactory.createMatteBorder(0,0,2,0,Color.DARK_GRAY));
  constraints.fill=GridBagConstraints.BOTH;
  constraints.weightx=1.0;
  constraints.weighty=3.0;
  constraints.gridwidth=columns - 2;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(labelImage,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  JLabel loginLabel=new JLabel(""String_Node_Str"");
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.weighty=0.0;
  constraints.gridwidth=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(loginLabel,constraints);
  login=new JTextField();
  login.setText(parent.getConfiguration().login());
  login.setColumns(20);
  login.addKeyListener(new CheckCanStart());
  constraints.gridwidth=columns - 3;
  constraints.gridx=2;
  parent.getContentPane().add(login,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  JLabel passwordLabel=new JLabel(""String_Node_Str"");
  constraints.weighty=0.0;
  constraints.gridwidth=1;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(passwordLabel,constraints);
  password=new JPasswordField();
  password.setText(parent.getConfiguration().password());
  password.setColumns(10);
  password.addKeyListener(new CheckCanStart());
  constraints.gridwidth=columns - 3;
  constraints.gridx=2;
  parent.getContentPane().add(password,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  JLabel proxyLabel=new JLabel(""String_Node_Str"");
  proxyLabel.setToolTipText(""String_Node_Str"");
  constraints.gridwidth=1;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(proxyLabel,constraints);
  proxy=new JTextField();
  proxy.setToolTipText(""String_Node_Str"");
  proxy.setText(parent.getConfiguration().getProxy());
  proxy.addKeyListener(new CheckCanStart());
  constraints.gridwidth=columns - 3;
  constraints.gridx=2;
  parent.getContentPane().add(proxy,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  JLabel cacheLabel=new JLabel(""String_Node_Str"");
  constraints.gridwidth=1;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(cacheLabel,constraints);
  String destination=DUMMY_CACHE_DIR;
  if (config.getUserSpecifiedACacheDir()) {
    destination=config.getStorageDir().getName();
  }
  cacheDirText=new JLabel(destination);
  constraints.weightx=1.0;
  constraints.gridwidth=columns - 4;
  constraints.gridx=2;
  parent.getContentPane().add(cacheDirText,constraints);
  cacheDirChooser=new JFileChooser();
  cacheDirChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  JButton openButton=new JButton(""String_Node_Str"");
  openButton.addActionListener(new ChooseFileAction());
  constraints.weightx=0.0;
  constraints.gridwidth=1;
  constraints.gridx=columns - 2;
  parent.getContentPane().add(openButton,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  JLabel computeMethodLabel=new JLabel(""String_Node_Str"");
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(computeMethodLabel,constraints);
  ComputeType method=config.getComputeMethod();
  useCPU=new JCheckBox(""String_Node_Str"");
  boolean gpuChecked=false;
  if (method == ComputeType.CPU_GPU) {
    useCPU.setSelected(true);
    gpuChecked=true;
  }
 else   if (method == ComputeType.CPU) {
    useCPU.setSelected(true);
    gpuChecked=false;
  }
 else   if (method == ComputeType.GPU) {
    useCPU.setSelected(false);
    gpuChecked=true;
  }
  useCPU.addActionListener(new CpuChangeAction());
  constraints.gridwidth=Math.max(1,columns - (gpus != null ? gpus.size() : 0) - 3);
  constraints.gridx=2;
  parent.getContentPane().add(useCPU,constraints);
  constraints.gridwidth=1;
  if (gpus != null) {
    for (int i=0; i < gpus.size(); i++) {
      GPUDevice gpu=gpus.get(i);
      JCheckBoxGPU gpuCheckBox=new JCheckBoxGPU(gpu);
      gpuCheckBox.setToolTipText(gpu.getCudaName());
      if (gpuChecked) {
        GPUDevice config_gpu=config.getGPUDevice();
        if (config_gpu != null && config_gpu.getCudaName().equals(gpu.getCudaName())) {
          gpuCheckBox.setSelected(gpuChecked);
        }
      }
      gpuCheckBox.addActionListener(new GpuChangeAction());
      constraints.gridx=i + 3;
      parent.getContentPane().add(gpuCheckBox,constraints);
      useGPUs.add(gpuCheckBox);
    }
  }
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  CPU cpu=new CPU();
  if (cpu.cores() > 1) {
    cpuCores=new JSlider(1,cpu.cores());
    cpuCores.setMajorTickSpacing(1);
    cpuCores.setMinorTickSpacing(1);
    cpuCores.setPaintTicks(true);
    cpuCores.setPaintLabels(true);
    cpuCores.setValue(config.getNbCores() != -1 ? config.getNbCores() : cpuCores.getMaximum());
    JLabel coreLabel=new JLabel(""String_Node_Str"");
    constraints.gridx=1;
    constraints.gridy=currentRow;
    parent.getContentPane().add(coreLabel,constraints);
    constraints.gridwidth=columns - 3;
    constraints.gridx=2;
    parent.getContentPane().add(cpuCores,constraints);
    parent.addPadding(1,++currentRow,columns - 2,1);
    ++currentRow;
  }
  saveFile=new JCheckBox(""String_Node_Str"",true);
  constraints.gridwidth=columns - 3;
  constraints.gridx=2;
  constraints.gridy=currentRow;
  parent.getContentPane().add(saveFile,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  autoSignIn=new JCheckBox(""String_Node_Str"",config.getAutoSignIn());
  autoSignIn.addActionListener(new AutoSignInChangeAction());
  constraints.gridy=currentRow;
  parent.getContentPane().add(autoSignIn,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  saveButton=new JButton(""String_Node_Str"");
  checkDisplaySaveButton();
  saveButton.addActionListener(new SaveAction());
  constraints.gridwidth=columns - 2;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(saveButton,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  parent.addPadding(0,0,1,currentRow + 1);
  parent.addPadding(columns - 1,0,1,currentRow + 1);
  if (haveAutoStarted == false && config.getAutoSignIn() && checkDisplaySaveButton()) {
    haveAutoStarted=true;
    new SaveAction().actionPerformed(null);
  }
}","@Override public void show(){
  Configuration config=parent.getConfiguration();
  new SettingsLoader().merge(config);
  List<GPUDevice> gpus=GPU.listDevices();
  GridBagConstraints constraints=new GridBagConstraints();
  int columns=4 + (gpus != null ? gpus.size() : 0);
  int currentRow=0;
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  JLabel labelImage=new JLabel(image);
  constraints.fill=GridBagConstraints.BOTH;
  constraints.weightx=1.0;
  constraints.weighty=3.0;
  constraints.gridwidth=columns - 2;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(labelImage,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  JLabel loginLabel=new JLabel(""String_Node_Str"");
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.weighty=0.0;
  constraints.gridwidth=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(loginLabel,constraints);
  login=new JTextField();
  login.setText(parent.getConfiguration().login());
  login.setColumns(20);
  login.addKeyListener(new CheckCanStart());
  constraints.gridwidth=columns - 3;
  constraints.gridx=2;
  parent.getContentPane().add(login,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  JLabel passwordLabel=new JLabel(""String_Node_Str"");
  constraints.weighty=0.0;
  constraints.gridwidth=1;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(passwordLabel,constraints);
  password=new JPasswordField();
  password.setText(parent.getConfiguration().password());
  password.setColumns(10);
  password.addKeyListener(new CheckCanStart());
  constraints.gridwidth=columns - 3;
  constraints.gridx=2;
  parent.getContentPane().add(password,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  JLabel proxyLabel=new JLabel(""String_Node_Str"");
  proxyLabel.setToolTipText(""String_Node_Str"");
  constraints.gridwidth=1;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(proxyLabel,constraints);
  proxy=new JTextField();
  proxy.setToolTipText(""String_Node_Str"");
  proxy.setText(parent.getConfiguration().getProxy());
  proxy.addKeyListener(new CheckCanStart());
  constraints.gridwidth=columns - 3;
  constraints.gridx=2;
  parent.getContentPane().add(proxy,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  JLabel cacheLabel=new JLabel(""String_Node_Str"");
  constraints.gridwidth=1;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(cacheLabel,constraints);
  String destination=DUMMY_CACHE_DIR;
  if (config.getUserSpecifiedACacheDir()) {
    destination=config.getStorageDir().getName();
  }
  JPanel cacheDirWrapper=new JPanel();
  cacheDirWrapper.setLayout(new BoxLayout(cacheDirWrapper,BoxLayout.LINE_AXIS));
  cacheDirText=new JLabel(destination);
  cacheDirWrapper.add(cacheDirText);
  cacheDirWrapper.add(Box.createHorizontalGlue());
  cacheDirChooser=new JFileChooser();
  cacheDirChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  JButton openButton=new JButton(""String_Node_Str"");
  openButton.addActionListener(new ChooseFileAction());
  cacheDirWrapper.add(openButton);
  constraints.gridwidth=columns - 3;
  constraints.gridx=2;
  parent.getContentPane().add(cacheDirWrapper,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  JLabel computeMethodLabel=new JLabel(""String_Node_Str"");
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(computeMethodLabel,constraints);
  ComputeType method=config.getComputeMethod();
  useCPU=new JCheckBox(""String_Node_Str"");
  boolean gpuChecked=false;
  if (method == ComputeType.CPU_GPU) {
    useCPU.setSelected(true);
    gpuChecked=true;
  }
 else   if (method == ComputeType.CPU) {
    useCPU.setSelected(true);
    gpuChecked=false;
  }
 else   if (method == ComputeType.GPU) {
    useCPU.setSelected(false);
    gpuChecked=true;
  }
  useCPU.addActionListener(new CpuChangeAction());
  constraints.gridwidth=Math.max(1,columns - (gpus != null ? gpus.size() : 0) - 3);
  constraints.gridx=2;
  parent.getContentPane().add(useCPU,constraints);
  constraints.gridwidth=1;
  if (gpus != null) {
    for (int i=0; i < gpus.size(); i++) {
      GPUDevice gpu=gpus.get(i);
      JCheckBoxGPU gpuCheckBox=new JCheckBoxGPU(gpu);
      gpuCheckBox.setToolTipText(gpu.getCudaName());
      if (gpuChecked) {
        GPUDevice config_gpu=config.getGPUDevice();
        if (config_gpu != null && config_gpu.getCudaName().equals(gpu.getCudaName())) {
          gpuCheckBox.setSelected(gpuChecked);
        }
      }
      gpuCheckBox.addActionListener(new GpuChangeAction());
      constraints.gridx=i + 3;
      parent.getContentPane().add(gpuCheckBox,constraints);
      useGPUs.add(gpuCheckBox);
    }
  }
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  CPU cpu=new CPU();
  if (cpu.cores() > 1) {
    cpuCores=new JSlider(1,cpu.cores());
    cpuCores.setMajorTickSpacing(1);
    cpuCores.setMinorTickSpacing(1);
    cpuCores.setPaintTicks(true);
    cpuCores.setPaintLabels(true);
    cpuCores.setValue(config.getNbCores() != -1 ? config.getNbCores() : cpuCores.getMaximum());
    JLabel coreLabel=new JLabel(""String_Node_Str"");
    constraints.gridx=1;
    constraints.gridy=currentRow;
    parent.getContentPane().add(coreLabel,constraints);
    constraints.gridwidth=columns - 3;
    constraints.gridx=2;
    parent.getContentPane().add(cpuCores,constraints);
    parent.addPadding(1,++currentRow,columns - 2,1);
    ++currentRow;
  }
  saveFile=new JCheckBox(""String_Node_Str"",true);
  constraints.gridwidth=columns - 3;
  constraints.gridx=2;
  constraints.gridy=currentRow;
  parent.getContentPane().add(saveFile,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  autoSignIn=new JCheckBox(""String_Node_Str"",config.getAutoSignIn());
  autoSignIn.addActionListener(new AutoSignInChangeAction());
  constraints.gridy=currentRow;
  parent.getContentPane().add(autoSignIn,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  ++currentRow;
  saveButton=new JButton(""String_Node_Str"");
  checkDisplaySaveButton();
  saveButton.addActionListener(new SaveAction());
  constraints.gridwidth=columns - 2;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(saveButton,constraints);
  parent.addPadding(1,++currentRow,columns - 2,1);
  parent.addPadding(0,0,1,currentRow + 1);
  parent.addPadding(columns - 1,0,1,currentRow + 1);
  if (haveAutoStarted == false && config.getAutoSignIn() && checkDisplaySaveButton()) {
    haveAutoStarted=true;
    new SaveAction().actionPerformed(null);
  }
}","The original code lacked proper layout management for the cache directory section, causing potential UI alignment issues. The fixed code introduces a JPanel with BoxLayout and horizontal glue to create a more flexible and balanced arrangement for the cache directory label and chooser button. This improvement enhances the UI's readability and responsiveness by ensuring consistent spacing and component placement within the settings interface."
94595,"@Override public void show(){
  GridBagConstraints constraints=new GridBagConstraints();
  int currentRow=0;
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  JLabel labelImage=new JLabel(image);
  labelImage.setBorder(BorderFactory.createMatteBorder(0,0,2,0,Color.DARK_GRAY));
  constraints.fill=GridBagConstraints.BOTH;
  constraints.weightx=1.0;
  constraints.weighty=3.0;
  constraints.gridwidth=2;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(labelImage,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JLabel statusLabel=new JLabel(""String_Node_Str"");
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.weighty=0.0;
  constraints.gridwidth=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(statusLabel,constraints);
  statusContent.setVerticalAlignment(JLabel.TOP);
  statusContent.setVerticalTextPosition(JLabel.TOP);
  constraints.gridx=2;
  parent.getContentPane().add(statusContent,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JLabel creditsEarnedLabel=new JLabel(""String_Node_Str"");
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(creditsEarnedLabel,constraints);
  constraints.gridx=2;
  parent.getContentPane().add(creditEarned,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JLabel renderedFrameLabel=new JLabel(""String_Node_Str"");
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(renderedFrameLabel,constraints);
  constraints.gridx=2;
  parent.getContentPane().add(renderedFrameContent,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JLabel remainingFrameLabel=new JLabel(""String_Node_Str"");
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(remainingFrameLabel,constraints);
  constraints.gridx=2;
  parent.getContentPane().add(remainingFrameContent,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JLabel lastRenderedFrameLabel=new JLabel(""String_Node_Str"");
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(lastRenderedFrameLabel,constraints);
  constraints.gridx=2;
  parent.getContentPane().add(lastRender,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JButton settingsButton=new JButton(""String_Node_Str"");
  settingsButton.addActionListener(new SettingsAction());
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(settingsButton,constraints);
  pauseButton=new JButton(""String_Node_Str"");
  pauseButton.addActionListener(new PauseAction());
  constraints.gridx=2;
  parent.getContentPane().add(pauseButton,constraints);
  parent.addPadding(1,++currentRow,2,1);
  parent.addPadding(0,0,1,currentRow + 1);
  parent.addPadding(3,0,1,currentRow + 1);
}","@Override public void show(){
  GridBagConstraints constraints=new GridBagConstraints();
  int currentRow=0;
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  JLabel labelImage=new JLabel(image);
  constraints.fill=GridBagConstraints.BOTH;
  constraints.weightx=1.0;
  constraints.weighty=3.0;
  constraints.gridwidth=2;
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(labelImage,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JLabel statusLabel=new JLabel(""String_Node_Str"");
  constraints.fill=GridBagConstraints.HORIZONTAL;
  constraints.weighty=0.0;
  constraints.gridwidth=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(statusLabel,constraints);
  statusContent.setVerticalAlignment(JLabel.TOP);
  statusContent.setVerticalTextPosition(JLabel.TOP);
  constraints.gridx=2;
  parent.getContentPane().add(statusContent,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JLabel creditsEarnedLabel=new JLabel(""String_Node_Str"");
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(creditsEarnedLabel,constraints);
  constraints.gridx=2;
  parent.getContentPane().add(creditEarned,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JLabel renderedFrameLabel=new JLabel(""String_Node_Str"");
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(renderedFrameLabel,constraints);
  constraints.gridx=2;
  parent.getContentPane().add(renderedFrameContent,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JLabel remainingFrameLabel=new JLabel(""String_Node_Str"");
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(remainingFrameLabel,constraints);
  constraints.gridx=2;
  parent.getContentPane().add(remainingFrameContent,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JLabel lastRenderedFrameLabel=new JLabel(""String_Node_Str"");
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(lastRenderedFrameLabel,constraints);
  constraints.gridx=2;
  parent.getContentPane().add(lastRender,constraints);
  parent.addPadding(1,++currentRow,2,1);
  ++currentRow;
  JButton settingsButton=new JButton(""String_Node_Str"");
  settingsButton.addActionListener(new SettingsAction());
  constraints.gridx=1;
  constraints.gridy=currentRow;
  parent.getContentPane().add(settingsButton,constraints);
  pauseButton=new JButton(""String_Node_Str"");
  pauseButton.addActionListener(new PauseAction());
  constraints.gridx=2;
  parent.getContentPane().add(pauseButton,constraints);
  parent.addPadding(1,++currentRow,2,1);
  parent.addPadding(0,0,1,currentRow + 1);
  parent.addPadding(3,0,1,currentRow + 1);
}","The buggy code added an unnecessary border to the image label, which could disrupt the layout and visual design of the GUI. The fixed code removes the `labelImage.setBorder()` line, allowing for a cleaner and more consistent interface appearance. By eliminating the unnecessary border, the code now maintains a more streamlined and professional visual presentation of the components."
94596,"public static void set(String url_) throws MalformedURLException {
  URL url=new URL(url_);
  String userinfo=url.getUserInfo();
  if (userinfo != null) {
    String[] elements=userinfo.split(""String_Node_Str"");
    if (elements.length == 2) {
      String proxy_user=elements[0];
      String proxy_password=elements[1];
      if (proxy_user != null && proxy_password != null) {
        Authenticator.setDefault(new ProxyAuthenticator(proxy_user,proxy_password));
      }
    }
  }
  int port=url.getPort();
  if (port == -1) {
    port=8080;
  }
  System.setProperty(""String_Node_Str"",url.getHost());
  System.setProperty(""String_Node_Str"",Integer.toString(port));
  System.setProperty(""String_Node_Str"",url.getHost());
  System.setProperty(""String_Node_Str"",Integer.toString(port));
}","public static void set(String url_) throws MalformedURLException {
  if (url_ == null || url_.isEmpty()) {
    return;
  }
  URL url=new URL(url_);
  String userinfo=url.getUserInfo();
  if (userinfo != null) {
    String[] elements=userinfo.split(""String_Node_Str"");
    if (elements.length == 2) {
      String proxy_user=elements[0];
      String proxy_password=elements[1];
      if (proxy_user != null && proxy_password != null) {
        Authenticator.setDefault(new ProxyAuthenticator(proxy_user,proxy_password));
      }
    }
  }
  int port=url.getPort();
  if (port == -1) {
    port=8080;
  }
  System.setProperty(""String_Node_Str"",url.getHost());
  System.setProperty(""String_Node_Str"",Integer.toString(port));
  System.setProperty(""String_Node_Str"",url.getHost());
  System.setProperty(""String_Node_Str"",Integer.toString(port));
}","The original code lacks input validation, risking potential null pointer exceptions or invalid URL processing when an empty or null URL is passed. The fixed code adds a null and empty check at the beginning, preventing method execution with invalid input and ensuring robust URL handling. This simple validation improves the method's reliability and prevents potential runtime errors by gracefully handling edge cases."
94597,"private int downloadFile(Job ajob,String local_path,String md5_server,String url,String update_ui){
  File local_path_file=new File(local_path);
  if (local_path_file.exists() == false) {
    int ret=this.server.HTTPGetFile(url,local_path,this.gui,update_ui);
    if (ret != 0) {
      this.gui.error(""String_Node_Str"" + ret);
      return -9;
    }
  }
  String md5_local=Utils.md5(local_path);
  if (md5_local.equals(md5_server) == false) {
    this.log.error(""String_Node_Str"" + md5_local + ""String_Node_Str""+ ajob.getRenderMd5()+ ""String_Node_Str""+ new File(local_path).length()+ ""String_Node_Str"");
    return -10;
  }
  return 0;
}","private int downloadFile(Job ajob,String local_path,String md5_server,String url,String update_ui){
  File local_path_file=new File(local_path);
  if (local_path_file.exists() == false) {
    int ret=this.server.HTTPGetFile(url,local_path,this.gui,update_ui);
    if (ret != 0) {
      this.gui.error(""String_Node_Str"" + ret);
      this.log.debug(""String_Node_Str"" + local_path + ""String_Node_Str"");
      local_path_file.delete();
      return -9;
    }
  }
  String md5_local=Utils.md5(local_path);
  if (md5_local.equals(md5_server) == false) {
    this.log.error(""String_Node_Str"" + md5_local + ""String_Node_Str""+ ajob.getRenderMd5()+ ""String_Node_Str""+ new File(local_path).length()+ ""String_Node_Str"");
    this.log.debug(""String_Node_Str"" + local_path + ""String_Node_Str"");
    local_path_file.delete();
    return -10;
  }
  return 0;
}","The original code lacked proper error handling and cleanup for failed file downloads or corrupted files. The fixed code adds debug logging and file deletion when download or MD5 verification fails, preventing partial or incorrect files from remaining on the system. These changes enhance robustness by ensuring clean state management and providing more diagnostic information during file transfer errors."
94598,"/** 
 * Merge the Settings file with the Configuration. The Configuration will have high priority.
 */
public void merge(Configuration config){
  if (config == null) {
    System.out.println(""String_Node_Str"");
  }
  loadFile();
  if (config.login().isEmpty() && login != null) {
    config.setLogin(login);
  }
  if (config.password().isEmpty() && password != null) {
    config.setPassword(password);
  }
  try {
    if ((config.getComputeMethod() == null && computeMethod != null) || (computeMethod != null && config.getComputeMethod() != ComputeType.valueOf(computeMethod))) {
      config.setComputeMethod(ComputeType.valueOf(computeMethod));
    }
  }
 catch (  IllegalArgumentException e) {
    System.err.println(""String_Node_Str"" + computeMethod + ""String_Node_Str"");
    computeMethod=null;
  }
  if (config.getGPUDevice() == null && gpu != null) {
    GPUDevice device=GPU.getGPUDevice(gpu);
    if (device != null) {
      config.setUseGPU(device);
    }
  }
  if (config.getNbCores() == -1 && cores != null) {
    config.setUseNbCores(Integer.valueOf(cores));
  }
  if (config.getUserSpecifiedACacheDir() == false && cacheDir != null) {
    config.setCacheDir(new File(cacheDir));
  }
  if (config.getUIType() == null && ui != null) {
    config.setUIType(ui);
  }
  config.setAutoSignIn(Boolean.valueOf(autoSignIn));
}","/** 
 * Merge the Settings file with the Configuration. The Configuration will have high priority.
 */
public void merge(Configuration config){
  if (config == null) {
    System.out.println(""String_Node_Str"");
  }
  loadFile();
  if (config.login().isEmpty() && login != null) {
    config.setLogin(login);
  }
  if (config.password().isEmpty() && password != null) {
    config.setPassword(password);
  }
  try {
    if ((config.getComputeMethod() == null && computeMethod != null) || (computeMethod != null && config.getComputeMethod() != ComputeType.valueOf(computeMethod))) {
      config.setComputeMethod(ComputeType.valueOf(computeMethod));
    }
  }
 catch (  IllegalArgumentException e) {
    System.err.println(""String_Node_Str"" + computeMethod + ""String_Node_Str"");
    computeMethod=null;
  }
  if (config.getGPUDevice() == null && gpu != null) {
    GPUDevice device=GPU.getGPUDevice(gpu);
    if (device != null) {
      config.setUseGPU(device);
    }
  }
  if (config.getNbCores() == -1 && cores != null) {
    config.setUseNbCores(Integer.valueOf(cores));
  }
  if (config.getUserSpecifiedACacheDir() == false && cacheDir != null && new File(cacheDir).exists()) {
    config.setCacheDir(new File(cacheDir));
  }
  if (config.getUIType() == null && ui != null) {
    config.setUIType(ui);
  }
  config.setAutoSignIn(Boolean.valueOf(autoSignIn));
}","The original code lacks validation for the cache directory, potentially setting an invalid or non-existent cache path. The fixed code adds a check `new File(cacheDir).exists()` to ensure the cache directory is valid before setting it in the configuration. This modification prevents potential runtime errors and improves the robustness of the configuration merging process by validating the cache directory's existence before assignment."
94599,"private boolean checkFile(Job ajob,String local_path,String md5_server){
  File local_path_file=new File(local_path);
  if (local_path_file.exists() == false) {
    this.log.error(""String_Node_Str"" + local_path + ""String_Node_Str"");
    return false;
  }
  String md5_local=Utils.md5(local_path);
  if (md5_local.equals(md5_server) == false) {
    this.log.error(""String_Node_Str"" + md5_local + ""String_Node_Str""+ ajob.getRenderMd5()+ ""String_Node_Str""+ new File(local_path).length()+ ""String_Node_Str"");
    return false;
  }
  return true;
}","private boolean checkFile(Job ajob,String local_path,String md5_server){
  File local_path_file=new File(local_path);
  if (local_path_file.exists() == false) {
    this.log.error(""String_Node_Str"" + local_path + ""String_Node_Str"");
    return false;
  }
  String md5_local=Utils.md5(local_path);
  if (md5_local.equals(md5_server) == false) {
    this.log.error(""String_Node_Str"" + md5_local + ""String_Node_Str""+ md5_server+ ""String_Node_Str""+ new File(local_path).length()+ ""String_Node_Str"");
    return false;
  }
  return true;
}","The buggy code incorrectly logged `ajob.getRenderMd5()` instead of the actual server-side MD5 hash `md5_server`. In the fixed code, `md5_server` is directly used in the error logging, which provides accurate diagnostic information about file verification failures. This change ensures precise error tracking and helps developers understand exactly why file validation failed during the MD5 comparison process."
94600,"protected Error.Type confirmJob(Job ajob){
  String extras_config=""String_Node_Str"";
  if (this.config.getNbCores() > 0) {
    extras_config=""String_Node_Str"" + this.config.getNbCores();
  }
  String url_real=String.format(""String_Node_Str"",this.server.getPage(""String_Node_Str""),ajob.getId(),ajob.getFrameNumber(),ajob.getProcessRender().getDuration(),ajob.getRevision(),ajob.getProcessRender().getMemoryUsed(),ajob.getExtras(),extras_config);
  this.isValidatingJob=true;
  int nb_try=1;
  int max_try=3;
  ServerCode ret=ServerCode.UNKNOWN;
  while (nb_try < max_try && ret != ServerCode.OK) {
    ret=this.server.HTTPSendFile(url_real,ajob.getOutputImagePath());
switch (ret) {
case OK:
      nb_try=max_try;
    break;
case JOB_VALIDATION_ERROR_SESSION_DISABLED:
case JOB_VALIDATION_ERROR_BROKEN_MACHINE:
  return Type.SESSION_DISABLED;
case JOB_VALIDATION_ERROR_MISSING_PARAMETER:
return Error.Type.UNKNOWN;
default :
break;
}
nb_try++;
if (ret != ServerCode.OK && nb_try < max_try) {
try {
this.log.debug(""String_Node_Str"");
Thread.sleep(32000);
}
 catch (InterruptedException e) {
return Error.Type.UNKNOWN;
}
}
}
this.isValidatingJob=false;
File frame=new File(ajob.getOutputImagePath());
frame.delete();
ajob.setOutputImagePath(null);
this.isValidatingJob=false;
return Error.Type.OK;
}","protected Error.Type confirmJob(Job ajob){
  String extras_config=""String_Node_Str"";
  RenderProcess process=ajob.getProcessRender();
  if (process != null && process.getCoresUsed() > 0) {
    extras_config=""String_Node_Str"" + process.getCoresUsed();
  }
  String url_real=String.format(""String_Node_Str"",this.server.getPage(""String_Node_Str""),ajob.getId(),ajob.getFrameNumber(),ajob.getProcessRender().getDuration(),ajob.getRevision(),ajob.getProcessRender().getMemoryUsed(),ajob.getExtras(),extras_config);
  this.isValidatingJob=true;
  int nb_try=1;
  int max_try=3;
  ServerCode ret=ServerCode.UNKNOWN;
  while (nb_try < max_try && ret != ServerCode.OK) {
    ret=this.server.HTTPSendFile(url_real,ajob.getOutputImagePath());
switch (ret) {
case OK:
      nb_try=max_try;
    break;
case JOB_VALIDATION_ERROR_SESSION_DISABLED:
case JOB_VALIDATION_ERROR_BROKEN_MACHINE:
  return Type.SESSION_DISABLED;
case JOB_VALIDATION_ERROR_MISSING_PARAMETER:
return Error.Type.UNKNOWN;
default :
break;
}
nb_try++;
if (ret != ServerCode.OK && nb_try < max_try) {
try {
this.log.debug(""String_Node_Str"");
Thread.sleep(32000);
}
 catch (InterruptedException e) {
return Error.Type.UNKNOWN;
}
}
}
this.isValidatingJob=false;
File frame=new File(ajob.getOutputImagePath());
frame.delete();
ajob.setOutputImagePath(null);
this.isValidatingJob=false;
return Error.Type.OK;
}","The original code lacks null checking for the process render and uses an incorrect method `getNbCores()` which might not exist. The fixed code introduces a null check for the process and uses `getCoresUsed()` method, ensuring safer access to core information. This modification prevents potential null pointer exceptions and provides more robust error handling for job confirmation scenarios."
94601,"public Error.Type render(){
  gui.status(""String_Node_Str"");
  RenderProcess process=getProcessRender();
  String core_script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  if (getUseGPU() && config.getGPUDevice() != null) {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",config.getGPUDevice().getCudaName());
  }
 else {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  core_script+=String.format(""String_Node_Str"",getTileSize());
  File script_file=null;
  String command1[]=getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (config.getNbCores() > 0) {
    size_command+=2;
  }
  List<String> command=new ArrayList<String>(size_command);
  Map<String,String> new_env=new HashMap<String,String>();
  new_env.put(""String_Node_Str"",config.workingDirectory.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
  for (  String arg : command1) {
switch (arg) {
case ""String_Node_Str"":
      command.add(getScenePath());
    command.add(""String_Node_Str"");
  try {
    script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",config.workingDirectory);
    File file=new File(script_file.getAbsolutePath());
    FileWriter txt;
    txt=new FileWriter(file);
    PrintWriter out=new PrintWriter(txt);
    out.write(getScript());
    out.write(""String_Node_Str"");
    out.write(core_script);
    out.write(""String_Node_Str"");
    out.close();
    command.add(script_file.getAbsolutePath());
  }
 catch (  IOException e) {
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
    return Error.Type.UNKNOWN;
  }
script_file.deleteOnExit();
break;
case ""String_Node_Str"":
command.add(getRendererPath());
if (config.getNbCores() > 0) {
command.add(""String_Node_Str"");
command.add(Integer.toString(config.getNbCores()));
}
break;
case ""String_Node_Str"":
command.add(config.workingDirectory.getAbsolutePath() + File.separator + getPrefixOutputImage());
break;
case ""String_Node_Str"":
command.add(getFrameNumber());
break;
default :
command.add(arg);
break;
}
}
try {
String line;
log.debug(command.toString());
OS os=OS.getOS();
process.start();
getProcessRender().setProcess(os.exec(command,new_env));
BufferedReader input=new BufferedReader(new InputStreamReader(getProcessRender().getProcess().getInputStream()));
long last_update_status=0;
log.debug(""String_Node_Str"");
try {
while ((line=input.readLine()) != null) {
updateRenderingMemoryPeak(line);
log.debug(line);
if ((new Date().getTime() - last_update_status) > 2000) {
updateRenderingStatus(line);
last_update_status=new Date().getTime();
}
Type error=detectError(line);
if (error != Error.Type.OK) {
if (script_file != null) {
script_file.delete();
}
return error;
}
}
input.close();
}
 catch (IOException err1) {
log.error(""String_Node_Str"" + err1);
}
log.debug(""String_Node_Str"");
}
 catch (Exception err) {
if (script_file != null) {
script_file.delete();
}
StringWriter sw=new StringWriter();
err.printStackTrace(new PrintWriter(sw));
log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
return Error.Type.FAILED_TO_EXECUTE;
}
int exit_value=process.exitValue();
process.finish();
if (script_file != null) {
script_file.delete();
}
final String filename_without_extension=getPrefixOutputImage() + getFrameNumber();
FilenameFilter textFilter=new FilenameFilter(){
public boolean accept(File dir,String name){
return name.startsWith(filename_without_extension);
}
}
;
File[] files=config.workingDirectory.listFiles(textFilter);
if (files.length == 0) {
log.error(""String_Node_Str"" + filename_without_extension + ""String_Node_Str"");
if (getAskForRendererKill()) {
log.debug(""String_Node_Str"");
return Error.Type.RENDERER_KILLED;
}
String basename=""String_Node_Str"";
try {
basename=getPath().substring(0,getPath().lastIndexOf('.'));
}
 catch (Exception e) {
e.printStackTrace();
}
File crash_file=new File(config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
if (crash_file.exists()) {
log.error(""String_Node_Str"");
crash_file.delete();
return Error.Type.RENDERER_CRASHED;
}
if (exit_value == 127 && process.getDuration() < 10) {
log.error(""String_Node_Str"" + process.getDuration() + ""String_Node_Str"");
return Error.Type.RENDERER_MISSING_LIBRARIES;
}
return Error.Type.NOOUTPUTFILE;
}
 else {
setOutputImagePath(files[0].getAbsolutePath());
log.debug(""String_Node_Str"" + getOutputImagePath() + ""String_Node_Str"");
}
File scene_dir=new File(getSceneDirectory());
long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
if (date_modification_scene_directory > process.getStartTime()) {
scene_dir.delete();
}
gui.status(String.format(""String_Node_Str"",process.getDuration() / 60,process.getDuration() % 60));
return Error.Type.OK;
}","public Error.Type render(){
  gui.status(""String_Node_Str"");
  RenderProcess process=getProcessRender();
  String core_script=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  if (getUseGPU() && config.getGPUDevice() != null) {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",config.getGPUDevice().getCudaName());
  }
 else {
    core_script=String.format(core_script,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  core_script+=String.format(""String_Node_Str"",getTileSize());
  File script_file=null;
  String command1[]=getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (config.getNbCores() > 0) {
    size_command+=2;
  }
  List<String> command=new ArrayList<String>(size_command);
  Map<String,String> new_env=new HashMap<String,String>();
  new_env.put(""String_Node_Str"",config.workingDirectory.getAbsolutePath().replace(""String_Node_Str"",""String_Node_Str""));
  for (  String arg : command1) {
switch (arg) {
case ""String_Node_Str"":
      command.add(getScenePath());
    command.add(""String_Node_Str"");
  try {
    script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",config.workingDirectory);
    File file=new File(script_file.getAbsolutePath());
    FileWriter txt;
    txt=new FileWriter(file);
    PrintWriter out=new PrintWriter(txt);
    out.write(getScript());
    out.write(""String_Node_Str"");
    out.write(core_script);
    out.write(""String_Node_Str"");
    out.close();
    command.add(script_file.getAbsolutePath());
  }
 catch (  IOException e) {
    StringWriter sw=new StringWriter();
    e.printStackTrace(new PrintWriter(sw));
    log.error(""String_Node_Str"" + e + ""String_Node_Str""+ sw.toString());
    return Error.Type.UNKNOWN;
  }
script_file.deleteOnExit();
break;
case ""String_Node_Str"":
command.add(getRendererPath());
if (config.getNbCores() > 0) {
command.add(""String_Node_Str"");
command.add(Integer.toString(config.getNbCores()));
}
break;
case ""String_Node_Str"":
command.add(config.workingDirectory.getAbsolutePath() + File.separator + getPrefixOutputImage());
break;
case ""String_Node_Str"":
command.add(getFrameNumber());
break;
default :
command.add(arg);
break;
}
}
try {
String line;
log.debug(command.toString());
OS os=OS.getOS();
process.setCoresUsed(config.getNbCores());
process.start();
getProcessRender().setProcess(os.exec(command,new_env));
BufferedReader input=new BufferedReader(new InputStreamReader(getProcessRender().getProcess().getInputStream()));
long last_update_status=0;
log.debug(""String_Node_Str"");
try {
while ((line=input.readLine()) != null) {
updateRenderingMemoryPeak(line);
log.debug(line);
if ((new Date().getTime() - last_update_status) > 2000) {
updateRenderingStatus(line);
last_update_status=new Date().getTime();
}
Type error=detectError(line);
if (error != Error.Type.OK) {
if (script_file != null) {
script_file.delete();
}
return error;
}
}
input.close();
}
 catch (IOException err1) {
log.error(""String_Node_Str"" + err1);
}
log.debug(""String_Node_Str"");
}
 catch (Exception err) {
if (script_file != null) {
script_file.delete();
}
StringWriter sw=new StringWriter();
err.printStackTrace(new PrintWriter(sw));
log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
return Error.Type.FAILED_TO_EXECUTE;
}
int exit_value=process.exitValue();
process.finish();
if (script_file != null) {
script_file.delete();
}
final String filename_without_extension=getPrefixOutputImage() + getFrameNumber();
FilenameFilter textFilter=new FilenameFilter(){
public boolean accept(File dir,String name){
return name.startsWith(filename_without_extension);
}
}
;
File[] files=config.workingDirectory.listFiles(textFilter);
if (files.length == 0) {
log.error(""String_Node_Str"" + filename_without_extension + ""String_Node_Str"");
if (getAskForRendererKill()) {
log.debug(""String_Node_Str"");
return Error.Type.RENDERER_KILLED;
}
String basename=""String_Node_Str"";
try {
basename=getPath().substring(0,getPath().lastIndexOf('.'));
}
 catch (Exception e) {
e.printStackTrace();
}
File crash_file=new File(config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
if (crash_file.exists()) {
log.error(""String_Node_Str"");
crash_file.delete();
return Error.Type.RENDERER_CRASHED;
}
if (exit_value == 127 && process.getDuration() < 10) {
log.error(""String_Node_Str"" + process.getDuration() + ""String_Node_Str"");
return Error.Type.RENDERER_MISSING_LIBRARIES;
}
return Error.Type.NOOUTPUTFILE;
}
 else {
setOutputImagePath(files[0].getAbsolutePath());
log.debug(""String_Node_Str"" + getOutputImagePath() + ""String_Node_Str"");
}
File scene_dir=new File(getSceneDirectory());
long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
if (date_modification_scene_directory > process.getStartTime()) {
scene_dir.delete();
}
gui.status(String.format(""String_Node_Str"",process.getDuration() / 60,process.getDuration() % 60));
return Error.Type.OK;
}","The original code lacked proper process configuration, missing the crucial step of setting the number of cores used by the render process. The fixed code adds `process.setCoresUsed(config.getNbCores())`, explicitly configuring the render process with the specified number of CPU cores before starting. This enhancement ensures more accurate resource allocation and provides better control over the rendering process's computational resources, leading to more predictable and efficient rendering performance."
94602,"public RenderProcess(){
  process=null;
  start=-1;
  end=-1;
  memoryUsed=0;
  remainingDuration=0;
}","public RenderProcess(){
  process=null;
  start=-1;
  end=-1;
  memoryUsed=0;
  coresUsed=0;
  remainingDuration=0;
}","The original code lacks initialization of the `coresUsed` attribute, potentially leading to undefined behavior when accessing this uninitialized variable. The fixed code introduces `coresUsed=0` in the constructor, explicitly setting the initial value to zero, ensuring a consistent and predictable starting state for the RenderProcess object. This correction prevents potential null or random value issues and provides a clean, well-defined initial configuration for the process's core usage."
94603,"@Override public CPU getCPU(){
  CPU ret=new CPU();
  try {
    String filePath=""String_Node_Str"";
    Scanner scanner=new Scanner(new File(filePath));
    while (scanner.hasNextLine()) {
      String line=scanner.nextLine();
      if (line.startsWith(""String_Node_Str"")) {
        String buf[]=line.split(""String_Node_Str"");
        if (buf.length > 0) {
          ret.setName(buf[1].trim());
        }
      }
      if (line.startsWith(""String_Node_Str"")) {
        String buf[]=line.split(""String_Node_Str"");
        if (buf.length > 0) {
          ret.setFamily(buf[1].trim());
        }
      }
      if (line.startsWith(""String_Node_Str"") && line.startsWith(""String_Node_Str"") == false) {
        String buf[]=line.split(""String_Node_Str"");
        if (buf.length > 0) {
          ret.setModel(buf[1].trim());
        }
      }
    }
    scanner.close();
  }
 catch (  java.lang.NoClassDefFoundError e) {
    System.err.println(""String_Node_Str"" + e + ""String_Node_Str"");
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return ret;
}","@Override public CPU getCPU(){
  CPU ret=new CPU();
  try {
    String filePath=""String_Node_Str"";
    Scanner scanner=new Scanner(new File(filePath));
    while (scanner.hasNextLine()) {
      String line=scanner.nextLine();
      if (line.startsWith(""String_Node_Str"")) {
        String buf[]=line.split(""String_Node_Str"");
        if (buf.length > 1) {
          ret.setName(buf[1].trim());
        }
      }
      if (line.startsWith(""String_Node_Str"")) {
        String buf[]=line.split(""String_Node_Str"");
        if (buf.length > 1) {
          ret.setFamily(buf[1].trim());
        }
      }
      if (line.startsWith(""String_Node_Str"") && line.startsWith(""String_Node_Str"") == false) {
        String buf[]=line.split(""String_Node_Str"");
        if (buf.length > 1) {
          ret.setModel(buf[1].trim());
        }
      }
    }
    scanner.close();
  }
 catch (  java.lang.NoClassDefFoundError e) {
    System.err.println(""String_Node_Str"" + e + ""String_Node_Str"");
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return ret;
}","The original code contains a logical error in array index access, potentially causing ArrayIndexOutOfBoundsException when splitting lines with `buf.length > 0`. The fixed code changes `buf.length > 0` to `buf.length > 1`, ensuring that a valid second element exists before accessing `buf[1]`. This modification prevents potential runtime errors and ensures safer array index retrieval when parsing CPU configuration data."
94604,"@Override public void show(){
  Configuration config=parent.getConfiguration();
  int size_height_label=24;
  int start_label_left=109;
  int start_label_right=265;
  int end_label_right=490;
  int n=10;
  int sep=45;
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  JLabel labelImage=new JLabel(image);
  labelImage.setBounds(600 / 2 - 265 / 2,n,265,130 + n);
  n=labelImage.getHeight();
  parent.getContentPane().add(labelImage);
  n+=40;
  JLabel loginLabel=new JLabel(""String_Node_Str"");
  loginLabel.setBounds(start_label_left,n,170,size_height_label);
  parent.getContentPane().add(loginLabel);
  login=new JTextField();
  login.setBounds(start_label_right,n,end_label_right - start_label_right,size_height_label);
  login.setText(parent.getConfiguration().login());
  login.setColumns(20);
  parent.getContentPane().add(login);
  n+=sep;
  JLabel passwordLabel=new JLabel(""String_Node_Str"");
  passwordLabel.setBounds(start_label_left,n,170,size_height_label);
  parent.getContentPane().add(passwordLabel);
  password=new JPasswordField();
  password.setBounds(start_label_right,n,end_label_right - start_label_right,size_height_label);
  password.setText(parent.getConfiguration().password());
  password.setColumns(10);
  parent.getContentPane().add(password);
  n+=sep;
  JLabel cacheLabel=new JLabel(""String_Node_Str"");
  cacheLabel.setBounds(start_label_left,n,240,size_height_label);
  parent.getContentPane().add(cacheLabel);
  String destination=DUMMY_CACHE_DIR;
  if (config.getUserSpecifiedACacheDir()) {
    destination=config.getStorageDir().getName();
  }
  cacheDirText=new JLabel(destination);
  cacheDirText.setBounds(start_label_right,n,240,size_height_label);
  parent.getContentPane().add(cacheDirText);
  cacheDirChooser=new JFileChooser();
  cacheDirChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  JButton openButton=new JButton(""String_Node_Str"");
  openButton.addActionListener(new ChooseFileAction());
  openButton.setBounds(end_label_right - 50,n,50,size_height_label);
  parent.getContentPane().add(openButton);
  n+=sep;
  JLabel computeMethodLabel=new JLabel(""String_Node_Str"");
  computeMethodLabel.setBounds(start_label_left,n,240,size_height_label);
  parent.getContentPane().add(computeMethodLabel);
  ComputeType method=config.getComputeMethod();
  useCPU=new JCheckBox(""String_Node_Str"");
  boolean gpuChecked=false;
  if (method == ComputeType.CPU_GPU) {
    useCPU.setSelected(true);
    gpuChecked=true;
  }
 else   if (method == ComputeType.CPU_ONLY) {
    useCPU.setSelected(true);
    gpuChecked=false;
  }
 else   if (method == ComputeType.GPU_ONLY) {
    useCPU.setSelected(false);
    gpuChecked=true;
  }
  int size=60;
  useCPU.addActionListener(new CpuChangeAction());
  useCPU.setBounds(start_label_right,n,size,size_height_label);
  parent.getContentPane().add(useCPU);
  List<GPUDevice> gpus=GPU.listDevices();
  if (gpus != null) {
    for (    GPUDevice gpu : gpus) {
      n+=20;
      JCheckBoxGPU gpuCheckBox=new JCheckBoxGPU(gpu);
      gpuCheckBox.setToolTipText(gpu.getCudaName());
      gpuCheckBox.setSelected(gpuChecked);
      gpuCheckBox.setBounds(start_label_right,n,200,size_height_label);
      gpuCheckBox.addActionListener(new GpuChangeAction());
      parent.getContentPane().add(gpuCheckBox);
      useGPUs.add(gpuCheckBox);
    }
  }
  n+=sep;
  saveButton=new JButton(""String_Node_Str"");
  saveButton.setBounds(start_label_right,n,80,size_height_label);
  saveButton.addActionListener(new SaveAction());
  parent.getContentPane().add(saveButton);
}","@Override public void show(){
  Configuration config=parent.getConfiguration();
  int size_height_label=24;
  int start_label_left=109;
  int start_label_right=265;
  int end_label_right=490;
  int n=10;
  int sep=45;
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  JLabel labelImage=new JLabel(image);
  labelImage.setBounds(600 / 2 - 265 / 2,n,265,130 + n);
  n=labelImage.getHeight();
  parent.getContentPane().add(labelImage);
  n+=40;
  JLabel loginLabel=new JLabel(""String_Node_Str"");
  loginLabel.setBounds(start_label_left,n,170,size_height_label);
  parent.getContentPane().add(loginLabel);
  login=new JTextField();
  login.setBounds(start_label_right,n,end_label_right - start_label_right,size_height_label);
  login.setText(parent.getConfiguration().login());
  login.setColumns(20);
  parent.getContentPane().add(login);
  n+=sep;
  JLabel passwordLabel=new JLabel(""String_Node_Str"");
  passwordLabel.setBounds(start_label_left,n,170,size_height_label);
  parent.getContentPane().add(passwordLabel);
  password=new JPasswordField();
  password.setBounds(start_label_right,n,end_label_right - start_label_right,size_height_label);
  password.setText(parent.getConfiguration().password());
  password.setColumns(10);
  parent.getContentPane().add(password);
  n+=sep;
  JLabel cacheLabel=new JLabel(""String_Node_Str"");
  cacheLabel.setBounds(start_label_left,n,240,size_height_label);
  parent.getContentPane().add(cacheLabel);
  String destination=DUMMY_CACHE_DIR;
  if (config.getUserSpecifiedACacheDir()) {
    destination=config.getStorageDir().getName();
  }
  cacheDirText=new JLabel(destination);
  cacheDirText.setBounds(start_label_right,n,240,size_height_label);
  parent.getContentPane().add(cacheDirText);
  cacheDirChooser=new JFileChooser();
  cacheDirChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  JButton openButton=new JButton(""String_Node_Str"");
  openButton.addActionListener(new ChooseFileAction());
  openButton.setBounds(end_label_right - 50,n,50,size_height_label);
  parent.getContentPane().add(openButton);
  n+=sep;
  JLabel computeMethodLabel=new JLabel(""String_Node_Str"");
  computeMethodLabel.setBounds(start_label_left,n,240,size_height_label);
  parent.getContentPane().add(computeMethodLabel);
  ComputeType method=config.getComputeMethod();
  useCPU=new JCheckBox(""String_Node_Str"");
  boolean gpuChecked=false;
  if (method == ComputeType.CPU_GPU) {
    useCPU.setSelected(true);
    gpuChecked=true;
  }
 else   if (method == ComputeType.CPU_ONLY) {
    useCPU.setSelected(true);
    gpuChecked=false;
  }
 else   if (method == ComputeType.GPU_ONLY) {
    useCPU.setSelected(false);
    gpuChecked=true;
  }
  int size=60;
  useCPU.addActionListener(new CpuChangeAction());
  useCPU.setBounds(start_label_right,n,size,size_height_label);
  parent.getContentPane().add(useCPU);
  List<GPUDevice> gpus=GPU.listDevices();
  if (gpus != null) {
    for (    GPUDevice gpu : gpus) {
      n+=20;
      JCheckBoxGPU gpuCheckBox=new JCheckBoxGPU(gpu);
      gpuCheckBox.setToolTipText(gpu.getCudaName());
      if (gpuChecked) {
        GPUDevice config_gpu=config.getGPUDevice();
        if (config_gpu != null && config_gpu.getCudaName().equals(gpu.getCudaName())) {
          gpuCheckBox.setSelected(gpuChecked);
        }
      }
      gpuCheckBox.setBounds(start_label_right,n,200,size_height_label);
      gpuCheckBox.addActionListener(new GpuChangeAction());
      parent.getContentPane().add(gpuCheckBox);
      useGPUs.add(gpuCheckBox);
    }
  }
  n+=sep;
  saveButton=new JButton(""String_Node_Str"");
  saveButton.setBounds(start_label_right,n,80,size_height_label);
  saveButton.addActionListener(new SaveAction());
  parent.getContentPane().add(saveButton);
}","The original code indiscriminately selected GPU checkboxes without considering the specific GPU configuration from the parent configuration. The fixed code checks if a GPU device is configured and matches its CUDA name before selecting the corresponding checkbox. This ensures that only the correctly configured GPU is pre-selected, maintaining configuration fidelity and improving user experience by accurately reflecting the current system settings."
94605,"public Configuration(File cache_dir_,String login_,String password_){
  this.login=login_;
  this.password=password_;
  this.static_exeDirName=""String_Node_Str"";
  this.maxUploadingJob=1;
  this.nbCores=-1;
  this.computeMethod=ComputeType.CPU_ONLY;
  this.GPUDevice=null;
  this.userSpecifiedACacheDir=false;
  this.workingDirectory=null;
  this.storageDirectory=null;
  this.setCacheDir(cache_dir_);
  this.printLog=false;
  this.requestTime=null;
  this.extras=""String_Node_Str"";
}","public Configuration(File cache_dir_,String login_,String password_){
  this.login=login_;
  this.password=password_;
  this.static_exeDirName=""String_Node_Str"";
  this.maxUploadingJob=1;
  this.nbCores=-1;
  this.computeMethod=null;
  this.GPUDevice=null;
  this.userSpecifiedACacheDir=false;
  this.workingDirectory=null;
  this.storageDirectory=null;
  this.setCacheDir(cache_dir_);
  this.printLog=false;
  this.requestTime=null;
  this.extras=""String_Node_Str"";
}","The original code incorrectly set `computeMethod` to a hardcoded `ComputeType.CPU_ONLY` value, which might not always be the desired compute method. The fixed code sets `computeMethod` to `null`, allowing more flexibility for configuring the compute method based on specific requirements. This modification provides better adaptability and prevents unintended default compute method assignment, enabling more dynamic configuration of computational resources."
94606,"public void merge(Configuration config){
  if (config == null) {
    System.out.println(""String_Node_Str"");
  }
  loadFile();
  if (login != null) {
    config.setLogin(login);
  }
  if (password != null) {
    config.setPassword(password);
  }
  if (computeMethod != null) {
    config.setComputeMethod(ComputeType.valueOf(computeMethod));
  }
  if (gpu != null) {
    GPUDevice device=GPU.getGPUDevice(gpu);
    if (device != null) {
      config.setUseGPU(device);
    }
  }
  if (cacheDir != null) {
    config.setCacheDir(new File(cacheDir));
  }
}","/** 
 * Merge the Settings file with the Configuration. The Configuration will have high priority.
 */
public void merge(Configuration config){
  if (config == null) {
    System.out.println(""String_Node_Str"");
  }
  loadFile();
  if (config.login().isEmpty() && login != null) {
    config.setLogin(login);
  }
  if (config.password().isEmpty() && password != null) {
    config.setPassword(password);
  }
  if (config.getComputeMethod() == null && computeMethod != null) {
    config.setComputeMethod(ComputeType.valueOf(computeMethod));
  }
  if (config.getGPUDevice() == null && gpu != null) {
    GPUDevice device=GPU.getGPUDevice(gpu);
    if (device != null) {
      config.setUseGPU(device);
    }
  }
  if (config.getUserSpecifiedACacheDir() == false && cacheDir != null) {
    config.setCacheDir(new File(cacheDir));
  }
}","The original code unconditionally overwrites configuration settings, potentially replacing existing valid configurations with default or potentially incorrect values. The fixed code checks if existing configuration values are empty or null before applying settings from the current instance, ensuring priority is given to explicitly set configurations. This modification prevents unintended configuration overrides and provides more robust and predictable configuration management."
94607,"public static String md5(String path_of_file_){
  try {
    MessageDigest md=MessageDigest.getInstance(""String_Node_Str"");
    InputStream is=Files.newInputStream(Paths.get(path_of_file_));
    DigestInputStream dis=new DigestInputStream(is,md);
    byte[] buffer=new byte[8192];
    while (dis.read(buffer) > 0)     ;
    return DatatypeConverter.printHexBinary(md.digest()).toLowerCase();
  }
 catch (  NoSuchAlgorithmException|IOException e) {
    return ""String_Node_Str"";
  }
}","public static String md5(String path_of_file_){
  try {
    MessageDigest md=MessageDigest.getInstance(""String_Node_Str"");
    InputStream is=Files.newInputStream(Paths.get(path_of_file_));
    DigestInputStream dis=new DigestInputStream(is,md);
    byte[] buffer=new byte[8192];
    while (dis.read(buffer) > 0)     ;
    String data=DatatypeConverter.printHexBinary(md.digest()).toLowerCase();
    dis.close();
    is.close();
    return data;
  }
 catch (  NoSuchAlgorithmException|IOException e) {
    return ""String_Node_Str"";
  }
}","The original code did not close the input streams (DigestInputStream and InputStream), which could lead to resource leaks and potential file handle exhaustion. In the fixed code, `dis.close()` and `is.close()` are added to properly release system resources after calculating the MD5 hash, and the hash result is stored in a separate variable before closing streams. This modification ensures proper resource management and prevents potential memory and file descriptor leaks, improving the method's overall robustness and reliability."
94608,"/** 
 * Merge the Settings file with the Configuration. The Configuration will have high priority.
 */
public void merge(Configuration config){
  if (config == null) {
    System.out.println(""String_Node_Str"");
  }
  loadFile();
  if (config.login().isEmpty() && login != null) {
    config.setLogin(login);
  }
  if (config.password().isEmpty() && password != null) {
    config.setPassword(password);
  }
  if ((config.getComputeMethod() == null && computeMethod != null) || (config.getComputeMethod() != ComputeType.valueOf(computeMethod) && computeMethod != null)) {
    config.setComputeMethod(ComputeType.valueOf(computeMethod));
  }
  if (config.getGPUDevice() == null && gpu != null) {
    GPUDevice device=GPU.getGPUDevice(gpu);
    if (device != null) {
      config.setUseGPU(device);
    }
  }
  if (config.getUserSpecifiedACacheDir() == false && cacheDir != null) {
    config.setCacheDir(new File(cacheDir));
  }
  config.setAutoSignIn(Boolean.valueOf(autoSignIn));
}","/** 
 * Merge the Settings file with the Configuration. The Configuration will have high priority.
 */
public void merge(Configuration config){
  if (config == null) {
    System.out.println(""String_Node_Str"");
  }
  loadFile();
  if (config.login().isEmpty() && login != null) {
    config.setLogin(login);
  }
  if (config.password().isEmpty() && password != null) {
    config.setPassword(password);
  }
  if ((config.getComputeMethod() == null && computeMethod != null) || (computeMethod != null && config.getComputeMethod() != ComputeType.valueOf(computeMethod))) {
    config.setComputeMethod(ComputeType.valueOf(computeMethod));
  }
  if (config.getGPUDevice() == null && gpu != null) {
    GPUDevice device=GPU.getGPUDevice(gpu);
    if (device != null) {
      config.setUseGPU(device);
    }
  }
  if (config.getUserSpecifiedACacheDir() == false && cacheDir != null) {
    config.setCacheDir(new File(cacheDir));
  }
  config.setAutoSignIn(Boolean.valueOf(autoSignIn));
}","The original code had a logical error in the compute method comparison, potentially leading to incorrect method assignments. In the fixed code, the condition was reordered to first check if computeMethod is not null, then compare its value with the existing compute method, preventing null pointer exceptions. This change ensures more robust method comparison and reduces the risk of unexpected runtime errors during configuration merging."
94609,"public static String humanString(Type in){
switch (in) {
case TOO_OLD_CLIENT:
    return ""String_Node_Str"";
case AUTHENTICATION_FAILED:
  return ""String_Node_Str"";
case NOOUTPUTFILE:
return ""String_Node_Str"";
case RENDERER_CRASHED:
return ""String_Node_Str"";
case RENDERER_MISSING_LIBRARIES:
return ""String_Node_Str"";
case RENDERER_KILLED:
return ""String_Node_Str"";
case SESSION_DISABLED:
return ""String_Node_Str"";
case RENDERER_NOT_AVAILABLE:
return ""String_Node_Str"";
case OS_NOT_SUPPORTED:
return ""String_Node_Str"";
case CPU_NOT_SUPPORTED:
return ""String_Node_Str"";
default :
return in.toString();
}
}","public static String humanString(Type in){
switch (in) {
case TOO_OLD_CLIENT:
    return ""String_Node_Str"";
case AUTHENTICATION_FAILED:
  return ""String_Node_Str"";
case DOWNLOAD_FILE:
return ""String_Node_Str"";
case NOOUTPUTFILE:
return ""String_Node_Str"";
case RENDERER_CRASHED:
return ""String_Node_Str"";
case RENDERER_MISSING_LIBRARIES:
return ""String_Node_Str"";
case RENDERER_KILLED:
return ""String_Node_Str"";
case SESSION_DISABLED:
return ""String_Node_Str"";
case RENDERER_NOT_AVAILABLE:
return ""String_Node_Str"";
case OS_NOT_SUPPORTED:
return ""String_Node_Str"";
case CPU_NOT_SUPPORTED:
return ""String_Node_Str"";
default :
return in.toString();
}
}","The original code lacks a case for the DOWNLOAD_FILE enum type, potentially causing unhandled scenarios or default toString() fallback. The fixed code adds the DOWNLOAD_FILE case with a consistent ""String_Node_Str"" return, ensuring comprehensive coverage of all potential enum types. This modification improves code reliability by providing explicit handling for all expected enum values, reducing the risk of unexpected behavior or incomplete error reporting."
94610,"/** 
 * Merge the Settings file with the Configuration. The Configuration will have high priority.
 */
public void merge(Configuration config){
  if (config == null) {
    System.out.println(""String_Node_Str"");
  }
  loadFile();
  if (config.login().isEmpty() && login != null) {
    config.setLogin(login);
  }
  if (config.password().isEmpty() && password != null) {
    config.setPassword(password);
  }
  if (config.getComputeMethod() == null && computeMethod != null) {
    config.setComputeMethod(ComputeType.valueOf(computeMethod));
  }
  if (config.getGPUDevice() == null && gpu != null) {
    GPUDevice device=GPU.getGPUDevice(gpu);
    if (device != null) {
      config.setUseGPU(device);
    }
  }
  if (config.getUserSpecifiedACacheDir() == false && cacheDir != null) {
    config.setCacheDir(new File(cacheDir));
  }
  config.setAutoSignIn(Boolean.valueOf(autoSignIn));
}","/** 
 * Merge the Settings file with the Configuration. The Configuration will have high priority.
 */
public void merge(Configuration config){
  if (config == null) {
    System.out.println(""String_Node_Str"");
  }
  loadFile();
  if (config.login().isEmpty() && login != null) {
    config.setLogin(login);
  }
  if (config.password().isEmpty() && password != null) {
    config.setPassword(password);
  }
  if ((config.getComputeMethod() == null && computeMethod != null) || (config.getComputeMethod() != ComputeType.valueOf(computeMethod) && computeMethod != null)) {
    config.setComputeMethod(ComputeType.valueOf(computeMethod));
  }
  if (config.getGPUDevice() == null && gpu != null) {
    GPUDevice device=GPU.getGPUDevice(gpu);
    if (device != null) {
      config.setUseGPU(device);
    }
  }
  if (config.getUserSpecifiedACacheDir() == false && cacheDir != null) {
    config.setCacheDir(new File(cacheDir));
  }
  config.setAutoSignIn(Boolean.valueOf(autoSignIn));
}","The original code only sets the compute method if it's null, potentially missing cases where the compute method needs to be updated. The fixed code adds a condition to also update the compute method if its current value differs from the new method, ensuring the most appropriate method is always selected. This modification provides more flexibility in method selection and prevents unintended retention of outdated compute configurations."
94611,"public void setCredentials(String contentLogin,String contentPassword){
  client.getConfiguration().setLogin(contentLogin);
  client.getConfiguration().setPassword(contentPassword);
  waitingForAuthentication=false;
synchronized (this) {
    notifyAll();
  }
  showActivity(ActivityType.WORKING);
}","public void setCredentials(String contentLogin,String contentPassword){
  client.getConfiguration().setLogin(contentLogin);
  client.getConfiguration().setPassword(contentPassword);
  waitingForAuthentication=false;
synchronized (this) {
    notifyAll();
  }
  if (threadClient != null && threadClient.isAlive()) {
    System.out.println(""String_Node_Str"");
  }
 else {
    threadClient=new ThreadClient();
    threadClient.start();
  }
  showActivity(ActivityType.WORKING);
}","The original code lacks proper thread management, potentially leaving the client thread uninitialized or not started after setting credentials. The fixed code adds a condition to check if the threadClient exists and is alive, and if not, creates and starts a new ThreadClient instance. This ensures that the client thread is properly initialized and running, preventing potential synchronization and execution issues."
94612,"@Override public void setClient(Client cli){
}","@Override public void setClient(Client cli){
  client=cli;
}","The original code lacks an implementation to store the passed client, making it an empty method with no functional purpose. The fixed code adds the line `client=cli`, which assigns the input client to the class's client member variable, enabling proper storage and future reference. This change ensures that the `setClient` method now effectively updates the client instance, allowing the class to maintain and utilize the client object throughout its lifecycle."
94613,"@Override public void start(){
}","@Override public void start(){
  if (client != null) {
    client.run();
    client.stop();
  }
}","The original code was an empty method, which would not perform any meaningful actions when called, potentially leading to unexpected behavior or silently failing. The fixed code checks if the client object is not null, and if so, calls the run() method to execute the client's functionality, followed by stopping the client with the stop() method. This modification ensures proper initialization, execution, and termination of the client, preventing potential null pointer exceptions and providing a more robust implementation of the start() method."
94614,"@Override public Client getClient(){
  return null;
}","@Override public Client getClient(){
  return client;
}","The original code incorrectly returns null when attempting to retrieve a client, which would cause null pointer exceptions and prevent proper client access. The fixed code returns the actual 'client' instance, ensuring a valid client object is provided whenever the method is called. By returning the real client object instead of null, the code now supports reliable client retrieval and prevents potential runtime errors."
94615,"@Override public void setClient(Client cli){
}","@Override public void setClient(Client cli){
  client=cli;
}","The original code lacks an implementation for setting the client, effectively creating an empty method that does nothing when called. The fixed code adds the crucial line `client=cli`, which assigns the passed client parameter to the class's client instance variable, enabling proper client assignment and state management. By storing the client reference, the fixed method now fulfills its intended purpose of updating the object's client, ensuring the class can interact with and utilize the provided client object."
94616,"@Override public void start(){
}","@Override public void start(){
  if (client != null) {
    client.run();
    client.stop();
  }
}","The original code's empty `start()` method does nothing, rendering the method ineffective and potentially causing unintended silent failures. The fixed code explicitly checks if the client is not null, then calls `run()` and `stop()` methods to properly initialize and terminate the client's operation. By adding these specific client management steps, the code now ensures proper execution and resource cleanup, preventing potential null pointer exceptions and improving overall method reliability."
94617,"@Override public Client getClient(){
  return null;
}","@Override public Client getClient(){
  return client;
}","The original code incorrectly returns null, violating the method's contract and potentially causing null pointer exceptions when the client is expected to be a valid, initialized object. The fixed code replaces the null return with `client`, which suggests returning an actual client instance that was likely initialized elsewhere in the class. By returning a proper client object, the code now provides a reliable implementation that ensures downstream methods can safely access and use the client without risking runtime errors."
94618,"public void doMain(String[] args){
  CmdLineParser parser=new CmdLineParser(this);
  try {
    parser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    parser.printUsage(System.err);
    System.err.println();
    System.err.println(""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ parser.printExample(REQUIRED));
    return;
  }
  ComputeType compute_method=ComputeType.CPU_ONLY;
  Configuration config=new Configuration(null,login,password);
  config.setPrintLog(print_log);
  if (cache_dir != null) {
    File a_dir=new File(cache_dir);
    if (a_dir.isDirectory() && a_dir.canWrite()) {
      config.setCacheDir(a_dir);
    }
  }
  if (max_upload != -1) {
    if (max_upload <= 0) {
      System.err.println(""String_Node_Str"");
      return;
    }
    config.setMaxUploadingJob(max_upload);
  }
  if (gpu_device != null) {
    String cuda_str=""String_Node_Str"";
    if (gpu_device.startsWith(cuda_str) == false) {
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      Integer.parseInt(gpu_device.substring(cuda_str.length()));
    }
 catch (    NumberFormatException en) {
      System.err.println(""String_Node_Str"");
      return;
    }
    GPUDevice gpu=GPU.getGPUDevice(gpu_device);
    if (gpu == null) {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
    config.setUseGPU(gpu);
  }
  if (request_time != null) {
    String[] intervals=request_time.split(""String_Node_Str"");
    if (intervals != null) {
      config.requestTime=new LinkedList<Pair<Calendar,Calendar>>();
      SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
      for (      String interval : intervals) {
        String[] times=interval.split(""String_Node_Str"");
        if (times != null && times.length == 2) {
          Calendar start=Calendar.getInstance();
          Calendar end=Calendar.getInstance();
          try {
            start.setTime(timeFormat.parse(times[0]));
            end.setTime(timeFormat.parse(times[1]));
          }
 catch (          ParseException e) {
            System.err.println(""String_Node_Str"");
            System.exit(2);
          }
          if (start.before(end)) {
            config.requestTime.add(new Pair<Calendar,Calendar>(start,end));
          }
 else {
            System.err.println(""String_Node_Str"" + times[0] + ""String_Node_Str""+ times[1]);
            System.exit(2);
          }
        }
      }
    }
  }
  if (nb_cores < -1 || nb_cores == 0) {
    System.err.println(""String_Node_Str"");
    return;
  }
 else {
    config.setUseNbCores(nb_cores);
  }
  if (method != null) {
    if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.GPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"") || method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_GPU;
    }
 else {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
  }
 else {
    if (config.getGPUDevice() == null) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else {
      compute_method=ComputeType.GPU_ONLY;
    }
  }
  if (proxy != null) {
    try {
      URL url=new URL(proxy);
      String userinfo=url.getUserInfo();
      if (userinfo != null) {
        String[] elements=userinfo.split(""String_Node_Str"");
        if (elements.length == 2) {
          String proxy_user=elements[0];
          String proxy_password=elements[1];
          if (proxy_user != null && proxy_password != null) {
            Authenticator.setDefault(new ProxyAuthenticator(proxy_user,proxy_password));
          }
        }
      }
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
    }
 catch (    MalformedURLException e) {
      System.err.println(""String_Node_Str"");
      System.err.println(e);
      System.exit(2);
    }
  }
  if (extras != null) {
    config.setExtras(extras);
  }
  if (compute_method == ComputeType.CPU_ONLY && config.getGPUDevice() != null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.CPU_GPU && config.getGPUDevice() == null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.GPU_ONLY && config.getGPUDevice() == null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.CPU_ONLY) {
    config.setUseGPU(null);
  }
  config.setComputeMethod(compute_method);
  Log.getInstance(config).debug(""String_Node_Str"" + config.getJarVersion());
  Gui gui;
  if (ui_type.equals(""String_Node_Str"")) {
    if (config.getPrintLog()) {
      System.out.println(""String_Node_Str"");
      System.exit(2);
    }
    gui=new GuiTextOneLine();
  }
 else   if (ui_type.equals(""String_Node_Str"")) {
    if (java.awt.GraphicsEnvironment.isHeadless()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.exit(3);
    }
    gui=new GuiSwing();
  }
 else {
    gui=new GuiText();
  }
  Client cli=new Client(gui,config,server);
  gui.setClient(cli);
  ShutdownHook hook=new ShutdownHook(cli);
  hook.attachShutDownHook();
  gui.start();
  cli.run();
  cli.stop();
}","public void doMain(String[] args){
  CmdLineParser parser=new CmdLineParser(this);
  try {
    parser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    parser.printUsage(System.err);
    System.err.println();
    System.err.println(""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ parser.printExample(REQUIRED));
    return;
  }
  ComputeType compute_method=ComputeType.CPU_ONLY;
  Configuration config=new Configuration(null,login,password);
  config.setPrintLog(print_log);
  if (cache_dir != null) {
    File a_dir=new File(cache_dir);
    if (a_dir.isDirectory() && a_dir.canWrite()) {
      config.setCacheDir(a_dir);
    }
  }
  if (max_upload != -1) {
    if (max_upload <= 0) {
      System.err.println(""String_Node_Str"");
      return;
    }
    config.setMaxUploadingJob(max_upload);
  }
  if (gpu_device != null) {
    String cuda_str=""String_Node_Str"";
    if (gpu_device.startsWith(cuda_str) == false) {
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      Integer.parseInt(gpu_device.substring(cuda_str.length()));
    }
 catch (    NumberFormatException en) {
      System.err.println(""String_Node_Str"");
      return;
    }
    GPUDevice gpu=GPU.getGPUDevice(gpu_device);
    if (gpu == null) {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
    config.setUseGPU(gpu);
  }
  if (request_time != null) {
    String[] intervals=request_time.split(""String_Node_Str"");
    if (intervals != null) {
      config.requestTime=new LinkedList<Pair<Calendar,Calendar>>();
      SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
      for (      String interval : intervals) {
        String[] times=interval.split(""String_Node_Str"");
        if (times != null && times.length == 2) {
          Calendar start=Calendar.getInstance();
          Calendar end=Calendar.getInstance();
          try {
            start.setTime(timeFormat.parse(times[0]));
            end.setTime(timeFormat.parse(times[1]));
          }
 catch (          ParseException e) {
            System.err.println(""String_Node_Str"");
            System.exit(2);
          }
          if (start.before(end)) {
            config.requestTime.add(new Pair<Calendar,Calendar>(start,end));
          }
 else {
            System.err.println(""String_Node_Str"" + times[0] + ""String_Node_Str""+ times[1]);
            System.exit(2);
          }
        }
      }
    }
  }
  if (nb_cores < -1 || nb_cores == 0) {
    System.err.println(""String_Node_Str"");
    return;
  }
 else {
    config.setUseNbCores(nb_cores);
  }
  if (method != null) {
    if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.GPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"") || method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_GPU;
    }
 else {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
  }
 else {
    if (config.getGPUDevice() == null) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else {
      compute_method=ComputeType.GPU_ONLY;
    }
  }
  if (proxy != null) {
    try {
      URL url=new URL(proxy);
      String userinfo=url.getUserInfo();
      if (userinfo != null) {
        String[] elements=userinfo.split(""String_Node_Str"");
        if (elements.length == 2) {
          String proxy_user=elements[0];
          String proxy_password=elements[1];
          if (proxy_user != null && proxy_password != null) {
            Authenticator.setDefault(new ProxyAuthenticator(proxy_user,proxy_password));
          }
        }
      }
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
    }
 catch (    MalformedURLException e) {
      System.err.println(""String_Node_Str"");
      System.err.println(e);
      System.exit(2);
    }
  }
  if (extras != null) {
    config.setExtras(extras);
  }
  if (compute_method == ComputeType.CPU_ONLY && config.getGPUDevice() != null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.CPU_GPU && config.getGPUDevice() == null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.GPU_ONLY && config.getGPUDevice() == null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.CPU_ONLY) {
    config.setUseGPU(null);
  }
  config.setComputeMethod(compute_method);
  Log.getInstance(config).debug(""String_Node_Str"" + config.getJarVersion());
  Gui gui;
  if (ui_type.equals(""String_Node_Str"")) {
    if (config.getPrintLog()) {
      System.out.println(""String_Node_Str"");
      System.exit(2);
    }
    gui=new GuiTextOneLine();
  }
 else   if (ui_type.equals(""String_Node_Str"")) {
    if (java.awt.GraphicsEnvironment.isHeadless()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.exit(3);
    }
    gui=new GuiSwing();
  }
 else {
    gui=new GuiText();
  }
  Client cli=new Client(gui,config,server);
  gui.setClient(cli);
  ShutdownHook hook=new ShutdownHook(cli);
  hook.attachShutDownHook();
  gui.start();
}","The original code had an unnecessary `cli.run()` and `cli.stop()` after `gui.start()`, which could lead to improper client lifecycle management and potential resource leaks. The fixed code removes these redundant method calls, allowing the `gui.start()` method to handle the client's execution and termination appropriately. By simplifying the code, the fixed version ensures cleaner and more reliable client-GUI interaction, preventing potential threading or resource management issues."
94619,"public static List<String> listDevices(){
  if (devices == null) {
    generate();
  }
  if (devices == null) {
    return null;
  }
  List<String> devs=new LinkedList<String>();
  for (  GPUDevice dev : devices) {
    devs.add(dev.getModel());
  }
  return devs;
}","public static List<GPUDevice> listDevices(){
  if (devices == null) {
    generate();
  }
  if (devices == null) {
    return null;
  }
  return devices;
}","The original code unnecessarily transformed the `devices` list by extracting only model names, losing original device information and forcing type conversion. The fixed code directly returns the `devices` list, preserving the complete `GPUDevice` objects with all their original properties and eliminating the redundant model-name extraction process. This approach maintains data integrity, reduces unnecessary transformation overhead, and provides more flexible and complete device information for subsequent operations."
94620,"@Override public void actionPerformed(ActionEvent e){
  if (parent == null) {
    return;
  }
  Configuration config=parent.getConfiguration();
  if (config == null) {
    return;
  }
  if (cacheDir != null) {
    File fromConfig=config.getStorageDir();
    if (fromConfig != null && fromConfig.getAbsolutePath().equals(cacheDir.getAbsolutePath()) == false) {
      config.setCacheDir(cacheDir);
    }
 else {
      System.out.println(""String_Node_Str"" + cacheDir + ""String_Node_Str"");
    }
  }
  String selected_gpu=null;
  for (  JCheckBox box : useGPUs) {
    if (box.isSelected()) {
      selected_gpu=box.getText();
    }
  }
  ComputeType method=ComputeType.CPU_ONLY;
  if (useCPU.isSelected() && selected_gpu == null) {
    method=ComputeType.CPU_ONLY;
  }
 else   if (useCPU.isSelected() == false && selected_gpu != null) {
    method=ComputeType.GPU_ONLY;
  }
 else   if (useCPU.isSelected() && selected_gpu != null) {
    method=ComputeType.CPU_GPU;
  }
  config.setComputeMethod(method);
  GPUDevice gpu=GPU.getGPUDevice(selected_gpu);
  if (gpu != null) {
    config.setUseGPU(gpu);
  }
  parent.setCredentials(login.getText(),new String(password.getPassword()));
}","@Override public void actionPerformed(ActionEvent e){
  if (parent == null) {
    return;
  }
  Configuration config=parent.getConfiguration();
  if (config == null) {
    return;
  }
  if (cacheDir != null) {
    File fromConfig=config.getStorageDir();
    if (fromConfig != null && fromConfig.getAbsolutePath().equals(cacheDir.getAbsolutePath()) == false) {
      config.setCacheDir(cacheDir);
    }
 else {
      System.out.println(""String_Node_Str"" + cacheDir + ""String_Node_Str"");
    }
  }
  GPUDevice selected_gpu=null;
  for (  JCheckBoxGPU box : useGPUs) {
    if (box.isSelected()) {
      selected_gpu=box.getGPUDevice();
    }
  }
  ComputeType method=ComputeType.CPU_ONLY;
  if (useCPU.isSelected() && selected_gpu == null) {
    method=ComputeType.CPU_ONLY;
  }
 else   if (useCPU.isSelected() == false && selected_gpu != null) {
    method=ComputeType.GPU_ONLY;
  }
 else   if (useCPU.isSelected() && selected_gpu != null) {
    method=ComputeType.CPU_GPU;
  }
  config.setComputeMethod(method);
  if (selected_gpu != null) {
    config.setUseGPU(selected_gpu);
  }
  parent.setCredentials(login.getText(),new String(password.getPassword()));
}","The original code incorrectly used generic JCheckBox with string-based GPU selection, which could lead to potential null pointer and type conversion issues when accessing GPU devices. The fixed code introduces a JCheckBoxGPU with a direct getGPUDevice() method, allowing direct and type-safe GPU device retrieval instead of manually parsing checkbox text. This change enhances type safety, simplifies GPU selection logic, and reduces the risk of runtime errors by ensuring a more robust and direct mechanism for GPU device selection."
94621,"@Override public void show(){
  Configuration config=parent.getConfiguration();
  int size_height_label=24;
  int start_label_left=109;
  int start_label_right=265;
  int end_label_right=490;
  int n=10;
  int sep=45;
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  JLabel labelImage=new JLabel(image);
  labelImage.setBounds(600 / 2 - 265 / 2,n,265,130 + n);
  n=labelImage.getHeight();
  parent.getContentPane().add(labelImage);
  n+=40;
  JLabel loginLabel=new JLabel(""String_Node_Str"");
  loginLabel.setBounds(start_label_left,n,170,size_height_label);
  parent.getContentPane().add(loginLabel);
  login=new JTextField();
  login.setBounds(start_label_right,n,end_label_right - start_label_right,size_height_label);
  login.setText(parent.getConfiguration().login());
  login.setColumns(20);
  parent.getContentPane().add(login);
  n+=sep;
  JLabel passwordLabel=new JLabel(""String_Node_Str"");
  passwordLabel.setBounds(start_label_left,n,170,size_height_label);
  parent.getContentPane().add(passwordLabel);
  password=new JPasswordField();
  password.setBounds(start_label_right,n,end_label_right - start_label_right,size_height_label);
  password.setText(parent.getConfiguration().password());
  password.setColumns(10);
  parent.getContentPane().add(password);
  n+=sep;
  JLabel cacheLabel=new JLabel(""String_Node_Str"");
  cacheLabel.setBounds(start_label_left,n,240,size_height_label);
  parent.getContentPane().add(cacheLabel);
  String destination=DUMMY_CACHE_DIR;
  if (config.getUserSpecifiedACacheDir()) {
    destination=config.getStorageDir().getName();
  }
  cacheDirText=new JLabel(destination);
  cacheDirText.setBounds(start_label_right,n,240,size_height_label);
  parent.getContentPane().add(cacheDirText);
  cacheDirChooser=new JFileChooser();
  cacheDirChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  JButton openButton=new JButton(""String_Node_Str"");
  openButton.addActionListener(new ChooseFileAction());
  openButton.setBounds(end_label_right - 50,n,50,size_height_label);
  parent.getContentPane().add(openButton);
  n+=sep;
  JLabel computeMethodLabel=new JLabel(""String_Node_Str"");
  computeMethodLabel.setBounds(start_label_left,n,240,size_height_label);
  parent.getContentPane().add(computeMethodLabel);
  ComputeType method=config.getComputeMethod();
  useCPU=new JCheckBox(""String_Node_Str"");
  boolean gpuChecked=false;
  if (method == ComputeType.CPU_GPU) {
    useCPU.setSelected(true);
    gpuChecked=true;
  }
 else   if (method == ComputeType.CPU_ONLY) {
    useCPU.setSelected(true);
    gpuChecked=false;
  }
 else   if (method == ComputeType.GPU_ONLY) {
    useCPU.setSelected(false);
    gpuChecked=true;
  }
  int size=60;
  useCPU.setBounds(start_label_right,n,size,size_height_label);
  parent.getContentPane().add(useCPU);
  List<String> gpus=GPU.listDevices();
  if (gpus != null) {
    for (    String model : gpus) {
      n+=20;
      JCheckBox gpuCheckBox=new JCheckBox(model);
      gpuCheckBox.setSelected(gpuChecked);
      gpuCheckBox.setBounds(start_label_right,n,200,size_height_label);
      gpuCheckBox.addActionListener(new GpuChangeAction());
      parent.getContentPane().add(gpuCheckBox);
      useGPUs.add(gpuCheckBox);
    }
  }
  n+=sep;
  JButton saveButton=new JButton(""String_Node_Str"");
  saveButton.setBounds(start_label_right,n,80,size_height_label);
  saveButton.addActionListener(new SaveAction());
  parent.getContentPane().add(saveButton);
}","@Override public void show(){
  Configuration config=parent.getConfiguration();
  int size_height_label=24;
  int start_label_left=109;
  int start_label_right=265;
  int end_label_right=490;
  int n=10;
  int sep=45;
  ImageIcon image=new ImageIcon(getClass().getResource(""String_Node_Str""));
  JLabel labelImage=new JLabel(image);
  labelImage.setBounds(600 / 2 - 265 / 2,n,265,130 + n);
  n=labelImage.getHeight();
  parent.getContentPane().add(labelImage);
  n+=40;
  JLabel loginLabel=new JLabel(""String_Node_Str"");
  loginLabel.setBounds(start_label_left,n,170,size_height_label);
  parent.getContentPane().add(loginLabel);
  login=new JTextField();
  login.setBounds(start_label_right,n,end_label_right - start_label_right,size_height_label);
  login.setText(parent.getConfiguration().login());
  login.setColumns(20);
  parent.getContentPane().add(login);
  n+=sep;
  JLabel passwordLabel=new JLabel(""String_Node_Str"");
  passwordLabel.setBounds(start_label_left,n,170,size_height_label);
  parent.getContentPane().add(passwordLabel);
  password=new JPasswordField();
  password.setBounds(start_label_right,n,end_label_right - start_label_right,size_height_label);
  password.setText(parent.getConfiguration().password());
  password.setColumns(10);
  parent.getContentPane().add(password);
  n+=sep;
  JLabel cacheLabel=new JLabel(""String_Node_Str"");
  cacheLabel.setBounds(start_label_left,n,240,size_height_label);
  parent.getContentPane().add(cacheLabel);
  String destination=DUMMY_CACHE_DIR;
  if (config.getUserSpecifiedACacheDir()) {
    destination=config.getStorageDir().getName();
  }
  cacheDirText=new JLabel(destination);
  cacheDirText.setBounds(start_label_right,n,240,size_height_label);
  parent.getContentPane().add(cacheDirText);
  cacheDirChooser=new JFileChooser();
  cacheDirChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  JButton openButton=new JButton(""String_Node_Str"");
  openButton.addActionListener(new ChooseFileAction());
  openButton.setBounds(end_label_right - 50,n,50,size_height_label);
  parent.getContentPane().add(openButton);
  n+=sep;
  JLabel computeMethodLabel=new JLabel(""String_Node_Str"");
  computeMethodLabel.setBounds(start_label_left,n,240,size_height_label);
  parent.getContentPane().add(computeMethodLabel);
  ComputeType method=config.getComputeMethod();
  useCPU=new JCheckBox(""String_Node_Str"");
  boolean gpuChecked=false;
  if (method == ComputeType.CPU_GPU) {
    useCPU.setSelected(true);
    gpuChecked=true;
  }
 else   if (method == ComputeType.CPU_ONLY) {
    useCPU.setSelected(true);
    gpuChecked=false;
  }
 else   if (method == ComputeType.GPU_ONLY) {
    useCPU.setSelected(false);
    gpuChecked=true;
  }
  int size=60;
  useCPU.setBounds(start_label_right,n,size,size_height_label);
  parent.getContentPane().add(useCPU);
  List<GPUDevice> gpus=GPU.listDevices();
  if (gpus != null) {
    for (    GPUDevice gpu : gpus) {
      n+=20;
      JCheckBoxGPU gpuCheckBox=new JCheckBoxGPU(gpu);
      gpuCheckBox.setSelected(gpuChecked);
      gpuCheckBox.setBounds(start_label_right,n,200,size_height_label);
      gpuCheckBox.addActionListener(new GpuChangeAction());
      parent.getContentPane().add(gpuCheckBox);
      useGPUs.add(gpuCheckBox);
    }
  }
  n+=sep;
  JButton saveButton=new JButton(""String_Node_Str"");
  saveButton.setBounds(start_label_right,n,80,size_height_label);
  saveButton.addActionListener(new SaveAction());
  parent.getContentPane().add(saveButton);
}","The original code used a generic `String` list for GPU devices, which could lead to type safety and compatibility issues. The fixed code replaces `List<String>` with `List<GPUDevice>` and uses a specialized `JCheckBoxGPU` instead of a standard `JCheckBox`, ensuring type-specific handling of GPU devices. These changes provide more robust and type-safe GPU device management, improving code reliability and preventing potential runtime errors."
94622,"public Settings(GuiSwing parent_){
  parent=parent_;
  cacheDir=null;
  useGPUs=new LinkedList<JCheckBox>();
}","public Settings(GuiSwing parent_){
  parent=parent_;
  cacheDir=null;
  useGPUs=new LinkedList<JCheckBoxGPU>();
}","The original code uses a generic LinkedList<JCheckBox>, which may not accurately represent the specific GPU checkbox requirements. The fixed code introduces a custom JCheckBoxGPU type, likely tailored to handle GPU-specific checkbox behavior and data. This change ensures type safety, improves code clarity, and provides a more specialized implementation for managing GPU-related checkbox interactions."
94623,"protected Error.Type runRenderer(Job ajob){
  this.gui.status(""String_Node_Str"");
  String core_script=""String_Node_Str"";
  if (ajob.getUseGPU() && this.config.getGPUDevice() != null) {
    core_script+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + this.config.getGPUDevice().getCudaName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else {
    core_script+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
  File script_file=null;
  String command1[]=ajob.getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (this.config.getNbCores() > 0) {
    size_command+=2;
  }
  String[] command=new String[size_command];
  int index=0;
  for (int i=0; i < command1.length; i++) {
    if (command1[i].equals(""String_Node_Str"")) {
      command[index]=ajob.getScenePath();
      index+=1;
      command[index]=""String_Node_Str"";
      index+=1;
      try {
        script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",this.config.workingDirectory);
        File file=new File(script_file.getAbsolutePath());
        FileWriter txt;
        txt=new FileWriter(file);
        PrintWriter out=new PrintWriter(txt);
        out.write(ajob.getScript());
        out.write(""String_Node_Str"");
        out.write(core_script);
        out.write(""String_Node_Str"");
        out.close();
        command[index]=script_file.getAbsolutePath();
      }
 catch (      IOException e) {
        return Error.Type.UNKNOWN;
      }
      script_file.deleteOnExit();
    }
 else     if (command1[i].equals(""String_Node_Str"")) {
      command[index]=ajob.getRendererPath();
      if (this.config.getNbCores() > 0) {
        index+=1;
        command[index]=""String_Node_Str"";
        index+=1;
        command[index]=Integer.toString(this.config.getNbCores());
      }
    }
 else     if (command1[i].equals(""String_Node_Str"")) {
      command[index]=this.config.workingDirectory.getAbsolutePath() + File.separator + ajob.getPrefixOutputImage();
    }
 else     if (command1[i].equals(""String_Node_Str"")) {
      command[index]=ajob.getFrameNumber();
    }
 else {
      command[index]=command1[i];
    }
    index+=1;
  }
  long rending_start=new Date().getTime();
  int nb_lines=0;
  try {
    String line;
    this.log.debug(Arrays.toString(command));
    OS os=OS.getOS();
    ajob.setProcess(os.exec(command));
    BufferedReader input=new BufferedReader(new InputStreamReader(ajob.getProcess().getInputStream()));
    long last_update_status=0;
    this.log.debug(""String_Node_Str"");
    while ((line=input.readLine()) != null) {
      nb_lines++;
      this.updateRenderingMemoryPeak(line,ajob);
      this.log.debug(line);
      if ((new Date().getTime() - last_update_status) > 2000) {
        this.updateRenderingStatus(line,nb_lines,ajob);
        last_update_status=new Date().getTime();
      }
    }
    input.close();
    this.log.debug(""String_Node_Str"");
  }
 catch (  Exception err) {
    StringWriter sw=new StringWriter();
    err.printStackTrace(new PrintWriter(sw));
    this.log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
    return Error.Type.FAILED_TO_EXECUTE;
  }
  long rending_end=new Date().getTime();
  if (script_file != null) {
    script_file.delete();
  }
  ajob.setRenderDuration((int)((rending_end - rending_start) / 1000 + 1));
  ajob.setMaxOutputNbLines(nb_lines);
  int exit_value=0;
  try {
    exit_value=ajob.getProcess().exitValue();
  }
 catch (  IllegalThreadStateException e) {
    exit_value=0;
  }
catch (  Exception e) {
    exit_value=0;
  }
  ajob.setProcess(null);
  final String namefile_without_extension=ajob.getPrefixOutputImage() + ajob.getFrameNumber();
  FilenameFilter textFilter=new FilenameFilter(){
    public boolean accept(    File dir,    String name){
      return name.startsWith(namefile_without_extension);
    }
  }
;
  File[] files=this.config.workingDirectory.listFiles(textFilter);
  if (files.length == 0) {
    this.log.error(""String_Node_Str"" + namefile_without_extension + ""String_Node_Str"");
    String basename=""String_Node_Str"";
    try {
      basename=ajob.getPath().substring(0,ajob.getPath().lastIndexOf('.'));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    File crash_file=new File(this.config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
    if (crash_file.exists()) {
      this.log.error(""String_Node_Str"");
      crash_file.delete();
      return Error.Type.RENDERER_CRASHED;
    }
    if (exit_value == 127 && ajob.getRenderDuration() < 10) {
      this.log.error(""String_Node_Str"" + ajob.getRenderDuration() + ""String_Node_Str"");
      return Error.Type.RENDERER_MISSING_LIBRARIES;
    }
    return Error.Type.NOOUTPUTFILE;
  }
 else {
    ajob.setOutputImagePath(files[0].getAbsolutePath());
    this.log.debug(""String_Node_Str"" + ajob.getOutputImagePath() + ""String_Node_Str"");
  }
  File scene_dir=new File(ajob.getSceneDirectory());
  long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
  if (date_modification_scene_directory > rending_start) {
    scene_dir.delete();
  }
  this.gui.status(String.format(""String_Node_Str"",ajob.getRenderDuration() / 60,ajob.getRenderDuration() % 60));
  return Error.Type.OK;
}","protected Error.Type runRenderer(Job ajob){
  this.gui.status(""String_Node_Str"");
  String core_script=""String_Node_Str"";
  if (ajob.getUseGPU() && this.config.getGPUDevice() != null) {
    core_script+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + this.config.getGPUDevice().getCudaName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else {
    core_script+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
  File script_file=null;
  String command1[]=ajob.getRenderCommand().split(""String_Node_Str"");
  int size_command=command1.length + 2;
  if (this.config.getNbCores() > 0) {
    size_command+=2;
  }
  String[] command=new String[size_command];
  int index=0;
  for (int i=0; i < command1.length; i++) {
    if (command1[i].equals(""String_Node_Str"")) {
      command[index]=ajob.getScenePath();
      index+=1;
      command[index]=""String_Node_Str"";
      index+=1;
      try {
        script_file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",this.config.workingDirectory);
        File file=new File(script_file.getAbsolutePath());
        FileWriter txt;
        txt=new FileWriter(file);
        PrintWriter out=new PrintWriter(txt);
        out.write(ajob.getScript());
        out.write(""String_Node_Str"");
        out.write(core_script);
        out.write(""String_Node_Str"");
        out.close();
        command[index]=script_file.getAbsolutePath();
      }
 catch (      IOException e) {
        return Error.Type.UNKNOWN;
      }
      script_file.deleteOnExit();
    }
 else     if (command1[i].equals(""String_Node_Str"")) {
      command[index]=ajob.getRendererPath();
      if (this.config.getNbCores() > 0) {
        index+=1;
        command[index]=""String_Node_Str"";
        index+=1;
        command[index]=Integer.toString(this.config.getNbCores());
      }
    }
 else     if (command1[i].equals(""String_Node_Str"")) {
      command[index]=this.config.workingDirectory.getAbsolutePath() + File.separator + ajob.getPrefixOutputImage();
    }
 else     if (command1[i].equals(""String_Node_Str"")) {
      command[index]=ajob.getFrameNumber();
    }
 else {
      command[index]=command1[i];
    }
    index+=1;
  }
  long rending_start=new Date().getTime();
  int nb_lines=0;
  try {
    String line;
    this.log.debug(Arrays.toString(command));
    OS os=OS.getOS();
    ajob.setProcess(os.exec(command));
    BufferedReader input=new BufferedReader(new InputStreamReader(ajob.getProcess().getInputStream()));
    long last_update_status=0;
    this.log.debug(""String_Node_Str"");
    try {
      while ((line=input.readLine()) != null) {
        nb_lines++;
        this.updateRenderingMemoryPeak(line,ajob);
        if ((new Date().getTime() - last_update_status) > 2000) {
          this.updateRenderingStatus(line,nb_lines,ajob);
          last_update_status=new Date().getTime();
        }
      }
      input.close();
    }
 catch (    IOException err1) {
      this.log.error(""String_Node_Str"" + err1);
    }
    this.log.debug(""String_Node_Str"");
  }
 catch (  Exception err) {
    StringWriter sw=new StringWriter();
    err.printStackTrace(new PrintWriter(sw));
    this.log.error(""String_Node_Str"" + err + ""String_Node_Str""+ sw.toString());
    return Error.Type.FAILED_TO_EXECUTE;
  }
  long rending_end=new Date().getTime();
  if (script_file != null) {
    script_file.delete();
  }
  ajob.setRenderDuration((int)((rending_end - rending_start) / 1000 + 1));
  ajob.setMaxOutputNbLines(nb_lines);
  int exit_value=0;
  try {
    exit_value=ajob.getProcess().exitValue();
  }
 catch (  IllegalThreadStateException e) {
    exit_value=0;
  }
catch (  Exception e) {
    exit_value=0;
  }
  ajob.setProcess(null);
  final String namefile_without_extension=ajob.getPrefixOutputImage() + ajob.getFrameNumber();
  FilenameFilter textFilter=new FilenameFilter(){
    public boolean accept(    File dir,    String name){
      return name.startsWith(namefile_without_extension);
    }
  }
;
  File[] files=this.config.workingDirectory.listFiles(textFilter);
  if (files.length == 0) {
    this.log.error(""String_Node_Str"" + namefile_without_extension + ""String_Node_Str"");
    String basename=""String_Node_Str"";
    try {
      basename=ajob.getPath().substring(0,ajob.getPath().lastIndexOf('.'));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    File crash_file=new File(this.config.workingDirectory + File.separator + basename+ ""String_Node_Str"");
    if (crash_file.exists()) {
      this.log.error(""String_Node_Str"");
      crash_file.delete();
      return Error.Type.RENDERER_CRASHED;
    }
    if (exit_value == 127 && ajob.getRenderDuration() < 10) {
      this.log.error(""String_Node_Str"" + ajob.getRenderDuration() + ""String_Node_Str"");
      return Error.Type.RENDERER_MISSING_LIBRARIES;
    }
    return Error.Type.NOOUTPUTFILE;
  }
 else {
    ajob.setOutputImagePath(files[0].getAbsolutePath());
    this.log.debug(""String_Node_Str"" + ajob.getOutputImagePath() + ""String_Node_Str"");
  }
  File scene_dir=new File(ajob.getSceneDirectory());
  long date_modification_scene_directory=(long)Utils.lastModificationTime(scene_dir);
  if (date_modification_scene_directory > rending_start) {
    scene_dir.delete();
  }
  this.gui.status(String.format(""String_Node_Str"",ajob.getRenderDuration() / 60,ajob.getRenderDuration() % 60));
  return Error.Type.OK;
}","The original code lacked proper error handling within the input stream reading loop, potentially causing unhandled exceptions and resource leaks. The fixed code introduces a nested try-catch block specifically for IOException during input stream reading, which isolates and handles potential stream-related errors without interrupting the entire rendering process. By implementing more granular error management, the revised code improves reliability and prevents unexpected termination during rendering operations."
94624,"public WinProcess(int pid_) throws IOException {
  this.handle=Kernel32.INSTANCE.OpenProcess(0x0400 | 0x0800 | 0x0001| 0x0200| 0x00100000,false,pid);
  if (this.handle == null) {
    throw new IOException(""String_Node_Str"" + Kernel32Util.formatMessageFromLastErrorCode(Kernel32.INSTANCE.GetLastError()) + ""String_Node_Str""+ pid_+ ""String_Node_Str"");
  }
  this.pid=pid_;
}","public WinProcess(int pid_) throws IOException {
  this.handle=Kernel32.INSTANCE.OpenProcess(0x0400 | 0x0800 | 0x0001| 0x0200| 0x00100000,false,pid_);
  if (this.handle == null) {
    throw new IOException(""String_Node_Str"" + Kernel32Util.formatMessageFromLastErrorCode(Kernel32.INSTANCE.GetLastError()) + ""String_Node_Str""+ pid_+ ""String_Node_Str"");
  }
  this.pid=pid_;
}","The original code contains a typo in the method parameter, using `pid` instead of `pid_` when calling `OpenProcess`, which could lead to unexpected behavior or compilation errors. In the fixed code, `pid_` is correctly used, ensuring the intended process identifier is passed to the function. This correction guarantees proper process opening and prevents potential runtime issues by maintaining parameter consistency."
94625,"public int cuDeviceTotalMem(NativeLong bytes[],int dev);","public int cuDeviceTotalMem(long bytes[],int dev);","The original code uses NativeLong, which is a platform-dependent type that can cause memory allocation and compatibility issues across different systems. The fixed code replaces NativeLong with long, a more standard and consistent primitive type that ensures reliable memory representation and cross-platform compatibility. By using long, the code becomes more portable, predictable, and less prone to potential type-related runtime errors when retrieving device total memory."
94626,"public static boolean generate(){
  OS os=OS.getOS();
  String path=os.getCUDALib();
  if (path == null) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  CUDA cudalib=null;
  try {
    cudalib=(CUDA)Native.loadLibrary(path,CUDA.class);
  }
 catch (  java.lang.UnsatisfiedLinkError e) {
    System.out.println(""String_Node_Str"");
    return false;
  }
catch (  java.lang.ExceptionInInitializerError e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
  int result=CUresult.CUDA_ERROR_UNKNOWN;
  result=cudalib.cuInit(0);
  if (result != CUresult.CUDA_SUCCESS) {
    return false;
  }
  if (result == CUresult.CUDA_ERROR_NO_DEVICE) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  int[] count=new int[1];
  result=cudalib.cuDeviceGetCount(count);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
    return false;
  }
  devices=new LinkedList<GPUDevice>();
  for (int num=0; num < count[0]; num++) {
    byte name[]=new byte[256];
    result=cudalib.cuDeviceGetName(name,256,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    NativeLong[] ram=new NativeLong[1];
    result=cudalib.cuDeviceTotalMem(ram,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      return false;
    }
    devices.add(new GPUDevice(new String(name).trim(),ram[0].longValue(),""String_Node_Str"" + Integer.toString(num)));
  }
  return true;
}","public static boolean generate(){
  OS os=OS.getOS();
  String path=os.getCUDALib();
  if (path == null) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  CUDA cudalib=null;
  try {
    cudalib=(CUDA)Native.loadLibrary(path,CUDA.class);
  }
 catch (  java.lang.UnsatisfiedLinkError e) {
    System.out.println(""String_Node_Str"");
    return false;
  }
catch (  java.lang.ExceptionInInitializerError e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    return false;
  }
  int result=CUresult.CUDA_ERROR_UNKNOWN;
  result=cudalib.cuInit(0);
  if (result != CUresult.CUDA_SUCCESS) {
    return false;
  }
  if (result == CUresult.CUDA_ERROR_NO_DEVICE) {
    System.out.println(""String_Node_Str"");
    return false;
  }
  int[] count=new int[1];
  result=cudalib.cuDeviceGetCount(count);
  if (result != CUresult.CUDA_SUCCESS) {
    System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
    return false;
  }
  devices=new LinkedList<GPUDevice>();
  for (int num=0; num < count[0]; num++) {
    byte name[]=new byte[256];
    result=cudalib.cuDeviceGetName(name,256,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      continue;
    }
    long[] ram=new long[1];
    result=cudalib.cuDeviceTotalMem(ram,num);
    if (result != CUresult.CUDA_SUCCESS) {
      System.out.println(""String_Node_Str"" + CUresult.stringFor(result) + ""String_Node_Str"");
      return false;
    }
    devices.add(new GPUDevice(new String(name).trim(),ram[0],""String_Node_Str"" + Integer.toString(num)));
  }
  return true;
}","The original code used NativeLong[] for device memory, which can cause platform-specific type mismatches and potential data conversion issues. The fixed code replaces NativeLong[] with long[], providing a more consistent and portable approach to handling device memory. This change ensures accurate memory representation across different systems, improving the reliability and cross-platform compatibility of CUDA device memory retrieval."
94627,"public WinProcess(int pid_) throws IOException {
  this.handle=Kernel32.INSTANCE.OpenProcess(0x0400 | 0x0800 | 0x0001| 0x0200| 0x00100000,false,pid_);
  if (this.handle == null) {
    throw new IOException(""String_Node_Str"" + Kernel32Util.formatMessageFromLastErrorCode(Kernel32.INSTANCE.GetLastError()) + ""String_Node_Str""+ pid_+ ""String_Node_Str"");
  }
  this.pid=pid_;
}","public WinProcess(int pid_) throws IOException {
  this();
  this.handle=Kernel32.INSTANCE.OpenProcess(0x0400 | 0x0800 | 0x0001| 0x0200| 0x00100000,false,pid_);
  if (this.handle == null) {
    throw new IOException(""String_Node_Str"" + Kernel32Util.formatMessageFromLastErrorCode(Kernel32.INSTANCE.GetLastError()) + ""String_Node_Str""+ pid_+ ""String_Node_Str"");
  }
  this.pid=pid_;
}","The original code lacks a default constructor call, potentially leaving uninitialized class members. The fixed code adds `this()` to invoke the default constructor before opening the process handle, ensuring proper object initialization. This change guarantees that all class members are correctly set up before performing the process-specific operation, preventing potential null pointer or uninitialized state issues."
94628,"public Configuration(File cache_dir_,String login_,String password_){
  this.login=login_;
  this.password=password_;
  this.static_exeDirName=""String_Node_Str"";
  this.maxUploadingJob=1;
  this.nbCores=-1;
  this.computeMethod=ComputeType.CPU_GPU;
  this.GPUDevice=null;
  this.userSpecifiedACacheDir=false;
  this.workingDirectory=null;
  this.storageDirectory=null;
  this.setCacheDir(cache_dir_);
  this.printLog=false;
  this.requestTime=null;
  this.extras=""String_Node_Str"";
}","public Configuration(File cache_dir_,String login_,String password_){
  this.login=login_;
  this.password=password_;
  this.static_exeDirName=""String_Node_Str"";
  this.maxUploadingJob=1;
  this.nbCores=-1;
  this.computeMethod=ComputeType.CPU_ONLY;
  this.GPUDevice=null;
  this.userSpecifiedACacheDir=false;
  this.workingDirectory=null;
  this.storageDirectory=null;
  this.setCacheDir(cache_dir_);
  this.printLog=false;
  this.requestTime=null;
  this.extras=""String_Node_Str"";
}","The original code incorrectly set `computeMethod` to `CPU_GPU`, which may imply inappropriate or unsupported computational configuration. The fixed code changes this to `CPU_ONLY`, ensuring a more reliable and predictable compute method that matches the current system capabilities. This modification provides a safer default computational approach, preventing potential runtime errors or unexpected behavior during execution."
94629,"public void setUseGPU(GPUDevice device){
  this.GPUDevice=device;
  if (device == null) {
    this.computeMethod=ComputeType.CPU_GPU;
  }
}","public void setUseGPU(GPUDevice device){
  this.GPUDevice=device;
}","The original code incorrectly sets the compute method to CPU_GPU when a null GPU device is passed, which is an inconsistent and potentially erroneous behavior. The fixed code removes the unnecessary conditional logic, simply assigning the GPU device without attempting to modify the compute method based on a null check. By eliminating this redundant and potentially misleading condition, the code becomes more straightforward, predictable, and allows the caller to handle device assignment more explicitly."
94630,"public void doMain(String[] args){
  CmdLineParser parser=new CmdLineParser(this);
  try {
    parser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    parser.printUsage(System.err);
    System.err.println();
    System.err.println(""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ parser.printExample(REQUIRED));
    return;
  }
  if (display_version) {
    Configuration config=new Configuration(null,""String_Node_Str"",""String_Node_Str"");
    System.out.println(""String_Node_Str"" + config.getJarVersion());
    return;
  }
  ComputeType compute_method=ComputeType.CPU_GPU;
  Configuration config=new Configuration(null,login,password);
  config.setPrintLog(print_log);
  if (cache_dir != null) {
    File a_dir=new File(cache_dir);
    if (a_dir.isDirectory() && a_dir.canWrite()) {
      config.setCacheDir(a_dir);
    }
  }
  if (max_upload != -1) {
    if (max_upload <= 0) {
      System.err.println(""String_Node_Str"");
      return;
    }
    config.setMaxUploadingJob(max_upload);
  }
  if (gpu_device != null) {
    String cuda_str=""String_Node_Str"";
    if (gpu_device.startsWith(cuda_str) == false) {
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      Integer.parseInt(gpu_device.substring(cuda_str.length()));
    }
 catch (    NumberFormatException en) {
      System.err.println(""String_Node_Str"");
      return;
    }
    GPUDevice gpu=GPU.getGPUDevice(gpu_device);
    if (gpu == null) {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
    config.setUseGPU(gpu);
  }
  if (request_time != null) {
    String[] intervals=request_time.split(""String_Node_Str"");
    if (intervals != null) {
      config.requestTime=new LinkedList<Pair<Calendar,Calendar>>();
      SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
      for (      String interval : intervals) {
        String[] times=interval.split(""String_Node_Str"");
        if (times != null && times.length == 2) {
          Calendar start=Calendar.getInstance();
          Calendar end=Calendar.getInstance();
          try {
            start.setTime(timeFormat.parse(times[0]));
            end.setTime(timeFormat.parse(times[1]));
          }
 catch (          ParseException e) {
            System.err.println(""String_Node_Str"");
            System.exit(2);
          }
          if (start.before(end)) {
            config.requestTime.add(new Pair<Calendar,Calendar>(start,end));
          }
 else {
            System.err.println(""String_Node_Str"" + times[0] + ""String_Node_Str""+ times[1]);
            System.exit(2);
          }
        }
      }
    }
  }
  if (nb_cores < -1 || nb_cores == 0) {
    System.err.println(""String_Node_Str"");
    return;
  }
 else {
    config.setUseNbCores(nb_cores);
  }
  if (method != null) {
    if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.GPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"") || method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_GPU;
    }
 else {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
  }
  if (proxy != null) {
    try {
      URL url=new URL(proxy);
      String userinfo=url.getUserInfo();
      if (userinfo != null) {
        String[] elements=userinfo.split(""String_Node_Str"");
        if (elements.length == 2) {
          String proxy_user=elements[0];
          String proxy_password=elements[1];
          if (proxy_user != null && proxy_password != null) {
            Authenticator.setDefault(new ProxyAuthenticator(proxy_user,proxy_password));
          }
        }
      }
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
    }
 catch (    MalformedURLException e) {
      System.err.println(""String_Node_Str"");
      System.err.println(e);
      System.exit(2);
    }
  }
  if (extras != null) {
    config.setExtras(extras);
  }
  if (compute_method == ComputeType.CPU_ONLY) {
    compute_method=ComputeType.CPU_GPU;
    config.setComputeMethod(compute_method);
    config.setUseGPU(null);
  }
 else {
    config.setComputeMethod(compute_method);
  }
  Log.getInstance(config).debug(""String_Node_Str"" + config.getJarVersion());
  Gui gui;
  if (ui_type.equals(""String_Node_Str"")) {
    if (config.getPrintLog()) {
      System.out.println(""String_Node_Str"");
      System.exit(2);
    }
    gui=new GuiTextOneLine();
  }
 else {
    gui=new GuiText();
  }
  Client cli=new Client(gui,config,server);
  ShutdownHook hook=new ShutdownHook(cli);
  hook.attachShutDownHook();
  cli.run();
  cli.stop();
}","public void doMain(String[] args){
  CmdLineParser parser=new CmdLineParser(this);
  try {
    parser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    parser.printUsage(System.err);
    System.err.println();
    System.err.println(""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ parser.printExample(REQUIRED));
    return;
  }
  if (display_version) {
    Configuration config=new Configuration(null,""String_Node_Str"",""String_Node_Str"");
    System.out.println(""String_Node_Str"" + config.getJarVersion());
    return;
  }
  ComputeType compute_method=ComputeType.CPU_ONLY;
  Configuration config=new Configuration(null,login,password);
  config.setPrintLog(print_log);
  if (cache_dir != null) {
    File a_dir=new File(cache_dir);
    if (a_dir.isDirectory() && a_dir.canWrite()) {
      config.setCacheDir(a_dir);
    }
  }
  if (max_upload != -1) {
    if (max_upload <= 0) {
      System.err.println(""String_Node_Str"");
      return;
    }
    config.setMaxUploadingJob(max_upload);
  }
  if (gpu_device != null) {
    String cuda_str=""String_Node_Str"";
    if (gpu_device.startsWith(cuda_str) == false) {
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      Integer.parseInt(gpu_device.substring(cuda_str.length()));
    }
 catch (    NumberFormatException en) {
      System.err.println(""String_Node_Str"");
      return;
    }
    GPUDevice gpu=GPU.getGPUDevice(gpu_device);
    if (gpu == null) {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
    config.setUseGPU(gpu);
  }
  if (request_time != null) {
    String[] intervals=request_time.split(""String_Node_Str"");
    if (intervals != null) {
      config.requestTime=new LinkedList<Pair<Calendar,Calendar>>();
      SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
      for (      String interval : intervals) {
        String[] times=interval.split(""String_Node_Str"");
        if (times != null && times.length == 2) {
          Calendar start=Calendar.getInstance();
          Calendar end=Calendar.getInstance();
          try {
            start.setTime(timeFormat.parse(times[0]));
            end.setTime(timeFormat.parse(times[1]));
          }
 catch (          ParseException e) {
            System.err.println(""String_Node_Str"");
            System.exit(2);
          }
          if (start.before(end)) {
            config.requestTime.add(new Pair<Calendar,Calendar>(start,end));
          }
 else {
            System.err.println(""String_Node_Str"" + times[0] + ""String_Node_Str""+ times[1]);
            System.exit(2);
          }
        }
      }
    }
  }
  if (nb_cores < -1 || nb_cores == 0) {
    System.err.println(""String_Node_Str"");
    return;
  }
 else {
    config.setUseNbCores(nb_cores);
  }
  if (method != null) {
    if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.GPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"") || method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_GPU;
    }
 else {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
  }
 else {
    if (config.getGPUDevice() == null) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else {
      compute_method=ComputeType.GPU_ONLY;
    }
  }
  if (proxy != null) {
    try {
      URL url=new URL(proxy);
      String userinfo=url.getUserInfo();
      if (userinfo != null) {
        String[] elements=userinfo.split(""String_Node_Str"");
        if (elements.length == 2) {
          String proxy_user=elements[0];
          String proxy_password=elements[1];
          if (proxy_user != null && proxy_password != null) {
            Authenticator.setDefault(new ProxyAuthenticator(proxy_user,proxy_password));
          }
        }
      }
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
    }
 catch (    MalformedURLException e) {
      System.err.println(""String_Node_Str"");
      System.err.println(e);
      System.exit(2);
    }
  }
  if (extras != null) {
    config.setExtras(extras);
  }
  if (compute_method == ComputeType.CPU_ONLY && config.getGPUDevice() != null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.CPU_GPU && config.getGPUDevice() == null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.GPU_ONLY && config.getGPUDevice() == null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.CPU_ONLY) {
    config.setUseGPU(null);
  }
  config.setComputeMethod(compute_method);
  Log.getInstance(config).debug(""String_Node_Str"" + config.getJarVersion());
  Gui gui;
  if (ui_type.equals(""String_Node_Str"")) {
    if (config.getPrintLog()) {
      System.out.println(""String_Node_Str"");
      System.exit(2);
    }
    gui=new GuiTextOneLine();
  }
 else {
    gui=new GuiText();
  }
  Client cli=new Client(gui,config,server);
  ShutdownHook hook=new ShutdownHook(cli);
  hook.attachShutDownHook();
  cli.run();
  cli.stop();
}","The original code arbitrarily set the compute method to CPU_GPU without properly validating device availability and method constraints. The fixed code introduces explicit checks for compute method compatibility with GPU device presence, adding validation logic that ensures method selection matches actual hardware capabilities. These changes prevent potential runtime errors and provide more robust configuration management by enforcing logical constraints between computational method and available resources."
94631,"public void doMain(String[] args){
  CmdLineParser parser=new CmdLineParser(this);
  try {
    parser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    parser.printUsage(System.err);
    System.err.println();
    System.err.println(""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ parser.printExample(REQUIRED));
    return;
  }
  if (display_version) {
    Configuration config=new Configuration(null,""String_Node_Str"",""String_Node_Str"");
    System.out.println(""String_Node_Str"" + config.getJarVersion());
    return;
  }
  ComputeType compute_method=ComputeType.CPU_GPU;
  Configuration config=new Configuration(null,login,password);
  config.setPrintLog(print_log);
  if (cache_dir != null) {
    File a_dir=new File(cache_dir);
    if (a_dir.isDirectory() && a_dir.canWrite()) {
      config.setCacheDir(a_dir);
    }
  }
  if (max_upload != -1) {
    if (max_upload <= 0) {
      System.err.println(""String_Node_Str"");
      return;
    }
    config.setMaxUploadingJob(max_upload);
  }
  if (gpu_device != null) {
    String cuda_str=""String_Node_Str"";
    if (gpu_device.startsWith(cuda_str) == false) {
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      Integer.parseInt(gpu_device.substring(cuda_str.length()));
    }
 catch (    NumberFormatException en) {
      System.err.println(""String_Node_Str"");
      return;
    }
    GPUDevice gpu=GPU.getGPUDevice(gpu_device);
    if (gpu == null) {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
    config.setUseGPU(gpu);
  }
  if (request_time != null) {
    String[] intervals=request_time.split(""String_Node_Str"");
    if (intervals != null) {
      config.requestTime=new LinkedList<Pair<Calendar,Calendar>>();
      SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
      for (      String interval : intervals) {
        String[] times=interval.split(""String_Node_Str"");
        if (times != null && times.length == 2) {
          Calendar start=Calendar.getInstance();
          Calendar end=Calendar.getInstance();
          try {
            start.setTime(timeFormat.parse(times[0]));
            end.setTime(timeFormat.parse(times[1]));
          }
 catch (          ParseException e) {
            System.err.println(""String_Node_Str"");
            System.exit(2);
          }
          if (start.before(end)) {
            config.requestTime.add(new Pair<Calendar,Calendar>(start,end));
          }
 else {
            System.err.println(""String_Node_Str"" + times[0] + ""String_Node_Str""+ times[1]);
            System.exit(2);
          }
        }
      }
    }
  }
  if (nb_cores < -1) {
    System.err.println(""String_Node_Str"");
    return;
  }
 else {
    config.setUseNbCores(nb_cores);
  }
  if (method != null) {
    if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.GPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"") || method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_GPU;
    }
 else {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
  }
  if (proxy != null) {
    try {
      URL url=new URL(proxy);
      String userinfo=url.getUserInfo();
      if (userinfo != null) {
        String[] elements=userinfo.split(""String_Node_Str"");
        if (elements.length == 2) {
          String proxy_user=elements[0];
          String proxy_password=elements[1];
          if (proxy_user != null && proxy_password != null) {
            Authenticator.setDefault(new ProxyAuthenticator(proxy_user,proxy_password));
          }
        }
      }
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
    }
 catch (    MalformedURLException e) {
      System.err.println(""String_Node_Str"");
      System.err.println(e);
      System.exit(2);
    }
  }
  if (extras != null) {
    config.setExtras(extras);
  }
  if (compute_method == ComputeType.CPU_ONLY) {
    compute_method=ComputeType.CPU_GPU;
    config.setComputeMethod(compute_method);
    config.setUseGPU(null);
  }
 else {
    config.setComputeMethod(compute_method);
  }
  Log.getInstance(config).debug(""String_Node_Str"" + config.getJarVersion());
  Gui gui;
  if (ui_type.equals(""String_Node_Str"")) {
    if (config.getPrintLog()) {
      System.out.println(""String_Node_Str"");
      System.exit(2);
    }
    gui=new GuiTextOneLine();
  }
 else {
    gui=new GuiText();
  }
  Client cli=new Client(gui,config,server);
  ShutdownHook hook=new ShutdownHook(cli);
  hook.attachShutDownHook();
  cli.run();
  cli.stop();
}","public void doMain(String[] args){
  CmdLineParser parser=new CmdLineParser(this);
  try {
    parser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    parser.printUsage(System.err);
    System.err.println();
    System.err.println(""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ parser.printExample(REQUIRED));
    return;
  }
  if (display_version) {
    Configuration config=new Configuration(null,""String_Node_Str"",""String_Node_Str"");
    System.out.println(""String_Node_Str"" + config.getJarVersion());
    return;
  }
  ComputeType compute_method=ComputeType.CPU_GPU;
  Configuration config=new Configuration(null,login,password);
  config.setPrintLog(print_log);
  if (cache_dir != null) {
    File a_dir=new File(cache_dir);
    if (a_dir.isDirectory() && a_dir.canWrite()) {
      config.setCacheDir(a_dir);
    }
  }
  if (max_upload != -1) {
    if (max_upload <= 0) {
      System.err.println(""String_Node_Str"");
      return;
    }
    config.setMaxUploadingJob(max_upload);
  }
  if (gpu_device != null) {
    String cuda_str=""String_Node_Str"";
    if (gpu_device.startsWith(cuda_str) == false) {
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      Integer.parseInt(gpu_device.substring(cuda_str.length()));
    }
 catch (    NumberFormatException en) {
      System.err.println(""String_Node_Str"");
      return;
    }
    GPUDevice gpu=GPU.getGPUDevice(gpu_device);
    if (gpu == null) {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
    config.setUseGPU(gpu);
  }
  if (request_time != null) {
    String[] intervals=request_time.split(""String_Node_Str"");
    if (intervals != null) {
      config.requestTime=new LinkedList<Pair<Calendar,Calendar>>();
      SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
      for (      String interval : intervals) {
        String[] times=interval.split(""String_Node_Str"");
        if (times != null && times.length == 2) {
          Calendar start=Calendar.getInstance();
          Calendar end=Calendar.getInstance();
          try {
            start.setTime(timeFormat.parse(times[0]));
            end.setTime(timeFormat.parse(times[1]));
          }
 catch (          ParseException e) {
            System.err.println(""String_Node_Str"");
            System.exit(2);
          }
          if (start.before(end)) {
            config.requestTime.add(new Pair<Calendar,Calendar>(start,end));
          }
 else {
            System.err.println(""String_Node_Str"" + times[0] + ""String_Node_Str""+ times[1]);
            System.exit(2);
          }
        }
      }
    }
  }
  if (nb_cores < -1 || nb_cores == 0) {
    System.err.println(""String_Node_Str"");
    return;
  }
 else {
    config.setUseNbCores(nb_cores);
  }
  if (method != null) {
    if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.GPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"") || method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_GPU;
    }
 else {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
  }
  if (proxy != null) {
    try {
      URL url=new URL(proxy);
      String userinfo=url.getUserInfo();
      if (userinfo != null) {
        String[] elements=userinfo.split(""String_Node_Str"");
        if (elements.length == 2) {
          String proxy_user=elements[0];
          String proxy_password=elements[1];
          if (proxy_user != null && proxy_password != null) {
            Authenticator.setDefault(new ProxyAuthenticator(proxy_user,proxy_password));
          }
        }
      }
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
    }
 catch (    MalformedURLException e) {
      System.err.println(""String_Node_Str"");
      System.err.println(e);
      System.exit(2);
    }
  }
  if (extras != null) {
    config.setExtras(extras);
  }
  if (compute_method == ComputeType.CPU_ONLY) {
    compute_method=ComputeType.CPU_GPU;
    config.setComputeMethod(compute_method);
    config.setUseGPU(null);
  }
 else {
    config.setComputeMethod(compute_method);
  }
  Log.getInstance(config).debug(""String_Node_Str"" + config.getJarVersion());
  Gui gui;
  if (ui_type.equals(""String_Node_Str"")) {
    if (config.getPrintLog()) {
      System.out.println(""String_Node_Str"");
      System.exit(2);
    }
    gui=new GuiTextOneLine();
  }
 else {
    gui=new GuiText();
  }
  Client cli=new Client(gui,config,server);
  ShutdownHook hook=new ShutdownHook(cli);
  hook.attachShutDownHook();
  cli.run();
  cli.stop();
}","The original code did not properly validate the `nb_cores` parameter, allowing zero and potentially invalid values. In the fixed code, an additional condition `nb_cores == 0` was added to the validation check, ensuring that only positive non-zero values are accepted for core configuration. This modification prevents potential runtime errors and ensures more robust core allocation by explicitly rejecting zero as an invalid number of cores."
94632,"public int senderLoop(){
  int step=log.newCheckPoint();
  Error.Type ret;
  while (true) {
    Job job_to_send;
    try {
      job_to_send=(Job)jobsToValidate.take();
      this.log.debug(""String_Node_Str"" + job_to_send);
      ret=confirmJob(job_to_send);
      if (ret != Error.Type.OK) {
        this.gui.error(Error.humainString(ret));
        sendError(step);
      }
 else {
        gui.AddFrameRendered();
      }
    }
 catch (    InterruptedException e) {
    }
  }
}","public int senderLoop(){
  int step=log.newCheckPoint();
  Error.Type ret;
  while (true) {
    Job job_to_send;
    try {
      job_to_send=(Job)jobsToValidate.take();
      this.log.debug(""String_Node_Str"" + job_to_send);
      ret=confirmJob(job_to_send);
      if (ret != Error.Type.OK) {
        this.gui.error(Error.humanString(ret));
        sendError(step);
      }
 else {
        gui.AddFrameRendered();
      }
    }
 catch (    InterruptedException e) {
    }
  }
}","The original code had a typo in the error method `Error.humainString()`, which likely does not exist. The fixed code corrects this to `Error.humanString()`, ensuring proper error string conversion and method invocation. This change allows for correct error reporting and maintains the intended error handling mechanism in the code."
94633,"public static ServerCode statusIsOK(Document document_,String rootname_){
  NodeList ns=document_.getElementsByTagName(rootname_);
  if (ns.getLength() == 0) {
    return Error.ServerCode.ERROR_NO_ROOT;
  }
  Element a_node=(Element)ns.item(0);
  if (a_node.hasAttribute(""String_Node_Str"")) {
    return Error.ServerCode.fromInt(Integer.parseInt(a_node.getAttribute(""String_Node_Str"")));
  }
  return Error.ServerCode.UNKNOWN;
}","public static ServerCode statusIsOK(Document document_,String rootname_){
  if (document_ == null) {
    return Error.ServerCode.UNKNOWN;
  }
  NodeList ns=document_.getElementsByTagName(rootname_);
  if (ns.getLength() == 0) {
    return Error.ServerCode.ERROR_NO_ROOT;
  }
  Element a_node=(Element)ns.item(0);
  if (a_node.hasAttribute(""String_Node_Str"")) {
    return Error.ServerCode.fromInt(Integer.parseInt(a_node.getAttribute(""String_Node_Str"")));
  }
  return Error.ServerCode.UNKNOWN;
}","The original code lacks a null check for the input document, risking a NullPointerException if a null document is passed. The fixed code adds a preliminary null check that returns UNKNOWN if the document is null, preventing potential runtime errors. This defensive programming approach enhances the method's robustness by gracefully handling unexpected input scenarios without breaking the application's execution flow."
94634,"public void doMain(String[] args){
  CmdLineParser parser=new CmdLineParser(this);
  try {
    parser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    parser.printUsage(System.err);
    System.err.println();
    System.err.println(""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ parser.printExample(REQUIRED));
    return;
  }
  if (display_version) {
    Configuration config=new Configuration(null,""String_Node_Str"",""String_Node_Str"");
    System.out.println(""String_Node_Str"" + config.getJarVersion());
    return;
  }
  ComputeType compute_method=ComputeType.CPU_ONLY;
  Configuration config=new Configuration(null,login,password);
  config.setPrintLog(print_log);
  if (cache_dir != null) {
    File a_dir=new File(cache_dir);
    if (a_dir.isDirectory() && a_dir.canWrite()) {
      config.setCacheDir(a_dir);
    }
  }
  if (max_upload != -1) {
    if (max_upload <= 0) {
      System.err.println(""String_Node_Str"");
      return;
    }
    config.setMaxUploadingJob(max_upload);
  }
  if (gpu_device != null) {
    String cuda_str=""String_Node_Str"";
    if (gpu_device.startsWith(cuda_str) == false) {
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      Integer.parseInt(gpu_device.substring(cuda_str.length()));
    }
 catch (    NumberFormatException en) {
      System.err.println(""String_Node_Str"");
      return;
    }
    GPUDevice gpu=GPU.getGPUDevice(gpu_device);
    if (gpu == null) {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
    config.setUseGPU(gpu);
  }
  if (request_time != null) {
    String[] intervals=request_time.split(""String_Node_Str"");
    if (intervals != null) {
      config.requestTime=new LinkedList<Pair<Calendar,Calendar>>();
      SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
      for (      String interval : intervals) {
        String[] times=interval.split(""String_Node_Str"");
        if (times != null && times.length == 2) {
          Calendar start=Calendar.getInstance();
          Calendar end=Calendar.getInstance();
          try {
            start.setTime(timeFormat.parse(times[0]));
            end.setTime(timeFormat.parse(times[1]));
          }
 catch (          ParseException e) {
            System.err.println(""String_Node_Str"");
            System.exit(2);
          }
          if (start.before(end)) {
            config.requestTime.add(new Pair<Calendar,Calendar>(start,end));
          }
 else {
            System.err.println(""String_Node_Str"" + times[0] + ""String_Node_Str""+ times[1]);
            System.exit(2);
          }
        }
      }
    }
  }
  if (nb_cores < -1 || nb_cores == 0) {
    System.err.println(""String_Node_Str"");
    return;
  }
 else {
    config.setUseNbCores(nb_cores);
  }
  if (method != null) {
    if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.GPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"") || method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_GPU;
    }
 else {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
  }
 else {
    if (config.getGPUDevice() == null) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else {
      compute_method=ComputeType.GPU_ONLY;
    }
  }
  if (proxy != null) {
    try {
      URL url=new URL(proxy);
      String userinfo=url.getUserInfo();
      if (userinfo != null) {
        String[] elements=userinfo.split(""String_Node_Str"");
        if (elements.length == 2) {
          String proxy_user=elements[0];
          String proxy_password=elements[1];
          if (proxy_user != null && proxy_password != null) {
            Authenticator.setDefault(new ProxyAuthenticator(proxy_user,proxy_password));
          }
        }
      }
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
    }
 catch (    MalformedURLException e) {
      System.err.println(""String_Node_Str"");
      System.err.println(e);
      System.exit(2);
    }
  }
  if (extras != null) {
    config.setExtras(extras);
  }
  if (compute_method == ComputeType.CPU_ONLY && config.getGPUDevice() != null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.CPU_GPU && config.getGPUDevice() == null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.GPU_ONLY && config.getGPUDevice() == null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.CPU_ONLY) {
    config.setUseGPU(null);
  }
  config.setComputeMethod(compute_method);
  Log.getInstance(config).debug(""String_Node_Str"" + config.getJarVersion());
  Gui gui;
  if (ui_type.equals(""String_Node_Str"")) {
    if (config.getPrintLog()) {
      System.out.println(""String_Node_Str"");
      System.exit(2);
    }
    gui=new GuiTextOneLine();
  }
 else {
    gui=new GuiText();
  }
  Client cli=new Client(gui,config,server);
  ShutdownHook hook=new ShutdownHook(cli);
  hook.attachShutDownHook();
  cli.run();
  cli.stop();
}","public void doMain(String[] args){
  CmdLineParser parser=new CmdLineParser(this);
  try {
    parser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    System.err.println(e.getMessage());
    System.err.println(""String_Node_Str"");
    parser.printUsage(System.err);
    System.err.println();
    System.err.println(""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ parser.printExample(REQUIRED));
    return;
  }
  ComputeType compute_method=ComputeType.CPU_ONLY;
  Configuration config=new Configuration(null,login,password);
  config.setPrintLog(print_log);
  if (cache_dir != null) {
    File a_dir=new File(cache_dir);
    if (a_dir.isDirectory() && a_dir.canWrite()) {
      config.setCacheDir(a_dir);
    }
  }
  if (max_upload != -1) {
    if (max_upload <= 0) {
      System.err.println(""String_Node_Str"");
      return;
    }
    config.setMaxUploadingJob(max_upload);
  }
  if (gpu_device != null) {
    String cuda_str=""String_Node_Str"";
    if (gpu_device.startsWith(cuda_str) == false) {
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      Integer.parseInt(gpu_device.substring(cuda_str.length()));
    }
 catch (    NumberFormatException en) {
      System.err.println(""String_Node_Str"");
      return;
    }
    GPUDevice gpu=GPU.getGPUDevice(gpu_device);
    if (gpu == null) {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
    config.setUseGPU(gpu);
  }
  if (request_time != null) {
    String[] intervals=request_time.split(""String_Node_Str"");
    if (intervals != null) {
      config.requestTime=new LinkedList<Pair<Calendar,Calendar>>();
      SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
      for (      String interval : intervals) {
        String[] times=interval.split(""String_Node_Str"");
        if (times != null && times.length == 2) {
          Calendar start=Calendar.getInstance();
          Calendar end=Calendar.getInstance();
          try {
            start.setTime(timeFormat.parse(times[0]));
            end.setTime(timeFormat.parse(times[1]));
          }
 catch (          ParseException e) {
            System.err.println(""String_Node_Str"");
            System.exit(2);
          }
          if (start.before(end)) {
            config.requestTime.add(new Pair<Calendar,Calendar>(start,end));
          }
 else {
            System.err.println(""String_Node_Str"" + times[0] + ""String_Node_Str""+ times[1]);
            System.exit(2);
          }
        }
      }
    }
  }
  if (nb_cores < -1 || nb_cores == 0) {
    System.err.println(""String_Node_Str"");
    return;
  }
 else {
    config.setUseNbCores(nb_cores);
  }
  if (method != null) {
    if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.GPU_ONLY;
    }
 else     if (method.equalsIgnoreCase(""String_Node_Str"") || method.equalsIgnoreCase(""String_Node_Str"")) {
      compute_method=ComputeType.CPU_GPU;
    }
 else {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
  }
 else {
    if (config.getGPUDevice() == null) {
      compute_method=ComputeType.CPU_ONLY;
    }
 else {
      compute_method=ComputeType.GPU_ONLY;
    }
  }
  if (proxy != null) {
    try {
      URL url=new URL(proxy);
      String userinfo=url.getUserInfo();
      if (userinfo != null) {
        String[] elements=userinfo.split(""String_Node_Str"");
        if (elements.length == 2) {
          String proxy_user=elements[0];
          String proxy_password=elements[1];
          if (proxy_user != null && proxy_password != null) {
            Authenticator.setDefault(new ProxyAuthenticator(proxy_user,proxy_password));
          }
        }
      }
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
      System.setProperty(""String_Node_Str"",url.getHost());
      System.setProperty(""String_Node_Str"",Integer.toString(url.getPort()));
    }
 catch (    MalformedURLException e) {
      System.err.println(""String_Node_Str"");
      System.err.println(e);
      System.exit(2);
    }
  }
  if (extras != null) {
    config.setExtras(extras);
  }
  if (compute_method == ComputeType.CPU_ONLY && config.getGPUDevice() != null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.CPU_GPU && config.getGPUDevice() == null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.GPU_ONLY && config.getGPUDevice() == null) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(2);
  }
 else   if (compute_method == ComputeType.CPU_ONLY) {
    config.setUseGPU(null);
  }
  config.setComputeMethod(compute_method);
  Log.getInstance(config).debug(""String_Node_Str"" + config.getJarVersion());
  Gui gui;
  if (ui_type.equals(""String_Node_Str"")) {
    if (config.getPrintLog()) {
      System.out.println(""String_Node_Str"");
      System.exit(2);
    }
    gui=new GuiTextOneLine();
  }
 else {
    gui=new GuiText();
  }
  Client cli=new Client(gui,config,server);
  ShutdownHook hook=new ShutdownHook(cli);
  hook.attachShutDownHook();
  cli.run();
  cli.stop();
}","The original code contained an unnecessary version display block that was unreachable and could potentially interfere with the main execution flow. The fixed code removes this redundant block, allowing the main method to proceed directly to configuration and client initialization. By eliminating the unused version display logic, the code now follows a more streamlined and predictable execution path, improving overall method clarity and reducing potential runtime complications."
94635,"@Override protected void finalize() throws Throwable {
  if (this.handle != null) {
    Kernel32.INSTANCE.CloseHandle(this.handle);
    this.handle=null;
  }
  this.pid=-1;
}","@Override protected void finalize() throws Throwable {
  if (this.handle != null) {
    this.handle=null;
  }
  this.pid=-1;
}","The original code improperly calls CloseHandle() directly, which can lead to resource leaks or double-free errors if the handle is already closed or invalid. The fixed code removes the direct handle closing, preventing potential system-level resource management issues and leaving handle cleanup to the appropriate system mechanisms. By simplifying the finalize method to just nulling the handle reference and setting the process ID, the code becomes safer and avoids potential runtime errors."
94636,"private void terminate(){
  Kernel32.INSTANCE.TerminateProcess(this.handle,0);
}","private void terminate(){
  Kernel32.INSTANCE.TerminateProcess(this.handle,0);
  Kernel32.INSTANCE.CloseHandle(this.handle);
}","The original code terminates a process but fails to release its system handle, potentially causing resource leaks and handle exhaustion. The fixed code adds Kernel32.INSTANCE.CloseHandle(this.handle), which properly closes the process handle after termination, freeing system resources. By explicitly closing the handle, the fixed code prevents resource waste and ensures proper system resource management."
94637,"private void packCircles(List<msg_mission_item> list){
  for (double altitude=coordinate.getAltitude(); altitude <= getTopHeight(); altitude+=heightStep) {
    CircleImpl circleImpl=new CircleImpl(missionImpl,new LatLongAlt(coordinate,(altitude)));
    circleImpl.setRadius(radius);
    list.addAll(circleImpl.packMissionItem());
  }
}","private void packCircles(List<msg_mission_item> list){
  double altitude=coordinate.getAltitude();
  for (int iSteps=0; iSteps < numberOfSteps; iSteps++) {
    CircleImpl circleImpl=new CircleImpl(missionImpl,new LatLongAlt(coordinate,altitude));
    circleImpl.setRadius(radius);
    list.addAll(circleImpl.packMissionItem());
    altitude+=heightStep;
  }
}","The original code had an infinite loop due to continuously incrementing altitude without a proper termination condition, potentially causing the loop to run indefinitely. The fixed code introduces a counter-controlled loop with a predefined number of steps, replacing the potentially unbounded altitude-based iteration and using an explicit step counter to control loop execution. This modification ensures predictable loop iterations, prevents potential infinite looping, and provides more precise control over the vertical sampling of mission items."
94638,"@Override protected void onConnectionOpened(){
  AndroidTcpConnection.this.onConnectionOpened();
}","@Override protected void onConnectionOpened(Bundle extras){
  AndroidTcpConnection.this.onConnectionOpened(extras);
}","The original method signature lacks a parameter, which prevents passing additional connection information or metadata. The fixed code adds a `Bundle extras` parameter, allowing the method to receive and forward contextual data during connection establishment. This modification enables more flexible and informative connection handling, ensuring that important connection-related extras can be properly transmitted and processed by the underlying implementation."
94639,"@Override protected void onConnectionOpened(){
  AndroidUdpConnection.this.onConnectionOpened();
}","@Override protected void onConnectionOpened(Bundle extras){
  AndroidUdpConnection.this.onConnectionOpened(extras);
}","The original code lacks a parameter in the method signature, which prevents passing additional connection-related data. The fixed code adds a `Bundle extras` parameter, matching the method signature and enabling transmission of supplementary connection information. This modification allows more flexible and comprehensive connection handling by supporting extra metadata during the connection opening process."
94640,"@Override protected void openConnection(Bundle connectionExtras) throws IOException {
  Log.d(BLUE,""String_Node_Str"");
  resetConnection();
  BluetoothDevice device=null;
  try {
    device=mBluetoothAdapter.getRemoteDevice(bluetoothAddress);
  }
 catch (  IllegalArgumentException ex) {
  }
  if (device == null) {
    device=findSerialBluetoothBoard();
  }
  Log.d(BLUE,""String_Node_Str"" + device.getAddress());
  Log.d(BLUE,""String_Node_Str"");
  bluetoothSocket=device.createInsecureRfcommSocketToServiceRecord(UUID.fromString(UUID_SPP_DEVICE));
  Log.d(BLUE,""String_Node_Str"");
  mBluetoothAdapter.cancelDiscovery();
  Log.d(BLUE,""String_Node_Str"");
  bluetoothSocket.connect();
  Log.d(BLUE,""String_Node_Str"");
  out=bluetoothSocket.getOutputStream();
  in=bluetoothSocket.getInputStream();
  onConnectionOpened();
}","@Override protected void openConnection(Bundle connectionExtras) throws IOException {
  Log.d(BLUE,""String_Node_Str"");
  resetConnection();
  BluetoothDevice device=null;
  try {
    device=mBluetoothAdapter.getRemoteDevice(bluetoothAddress);
  }
 catch (  IllegalArgumentException ex) {
  }
  if (device == null) {
    device=findSerialBluetoothBoard();
  }
  Log.d(BLUE,""String_Node_Str"" + device.getAddress());
  Log.d(BLUE,""String_Node_Str"");
  bluetoothSocket=device.createInsecureRfcommSocketToServiceRecord(UUID.fromString(UUID_SPP_DEVICE));
  Log.d(BLUE,""String_Node_Str"");
  mBluetoothAdapter.cancelDiscovery();
  Log.d(BLUE,""String_Node_Str"");
  bluetoothSocket.connect();
  Log.d(BLUE,""String_Node_Str"");
  out=bluetoothSocket.getOutputStream();
  in=bluetoothSocket.getInputStream();
  onConnectionOpened(connectionExtras);
}","The original code omitted passing the `connectionExtras` parameter when calling `onConnectionOpened()`, potentially losing important connection configuration data. In the fixed code, `onConnectionOpened(connectionExtras)` now correctly forwards the original connection extras bundle to the method. This ensures that any additional connection-specific parameters or configurations are properly propagated and utilized during the Bluetooth connection initialization process."
94641,"@Override protected void onConnectionOpened(){
  SoloConnection.this.onConnectionOpened();
}","@Override protected void onConnectionOpened(Bundle extras){
  SoloConnection.this.onConnectionOpened(extras);
}","The original code lacks a parameter for the `onConnectionOpened` method, which prevents passing additional connection-related information. The fixed version adds a `Bundle extras` parameter, matching the method signature and allowing the transmission of extra connection data. This modification enables more flexible and informative connection handling by providing a mechanism to pass supplementary details during the connection opening process."
94642,"private void checkScanResults(List<ScanResult> results){
  if (!isConnecting())   return;
  ScanResult targetResult=null;
  for (  ScanResult result : results) {
    if (result.SSID.equalsIgnoreCase(this.soloLinkId)) {
      targetResult=result;
      break;
    }
  }
  if (targetResult != null) {
    try {
      Bundle connectInfo=new Bundle();
      Bundle extras=super.getConnectionExtras();
      if (extras != null && !extras.isEmpty()) {
        connectInfo.putAll(extras);
      }
      connectInfo.putParcelable(WifiConnectionHandler.EXTRA_SCAN_RESULT,targetResult);
      connectInfo.putString(WifiConnectionHandler.EXTRA_SSID_PASSWORD,soloLinkPassword);
      int connectionResult=wifiHandler.connectToWifi(connectInfo);
      if (connectionResult != 0) {
        @LinkConnectionStatus.FailureCode int failureCode=connectionResult;
        LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(failureCode,""String_Node_Str"" + soloLinkId);
        onConnectionStatus(connectionStatus);
      }
    }
 catch (    IllegalArgumentException e) {
      Timber.e(e,e.getMessage());
      LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.UNKNOWN,e.getMessage());
      onConnectionStatus(connectionStatus);
    }
  }
 else {
    refreshWifiAps();
  }
}","private void checkScanResults(List<ScanResult> results){
  if (!isConnecting())   return;
  ScanResult targetResult=null;
  for (  ScanResult result : results) {
    if (result.SSID.equalsIgnoreCase(this.soloLinkId)) {
      targetResult=result;
      break;
    }
  }
  if (targetResult != null) {
    try {
      Bundle connectInfo=new Bundle();
      Bundle extras=getConnectionExtras();
      if (extras != null && !extras.isEmpty()) {
        connectInfo.putAll(extras);
      }
      connectInfo.putParcelable(WifiConnectionHandler.EXTRA_SCAN_RESULT,targetResult);
      connectInfo.putString(WifiConnectionHandler.EXTRA_SSID_PASSWORD,soloLinkPassword);
      int connectionResult=wifiHandler.connectToWifi(connectInfo);
      if (connectionResult != 0) {
        @LinkConnectionStatus.FailureCode int failureCode=connectionResult;
        LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(failureCode,""String_Node_Str"" + soloLinkId);
        onConnectionStatus(connectionStatus);
      }
    }
 catch (    IllegalArgumentException e) {
      Timber.e(e,e.getMessage());
      LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.UNKNOWN,e.getMessage());
      onConnectionStatus(connectionStatus);
    }
  }
 else {
    refreshWifiAps();
  }
}","The original code incorrectly used `super.getConnectionExtras()`, which may not retrieve the correct connection extras or could potentially cause unexpected method resolution. In the fixed code, `getConnectionExtras()` is called directly, ensuring the method is invoked from the current class instance and avoiding potential inheritance-related issues. This change improves method call accuracy and prevents potential null or incorrect extra data retrieval during the WiFi connection process."
94643,"public SoloConnection(Context applicationContext,String soloLinkId,String password){
  super(applicationContext);
  this.wifiHandler=new WifiConnectionHandler(applicationContext);
  wifiHandler.setListener(this);
  this.soloLinkId=soloLinkId;
  this.soloLinkPassword=password;
  this.dataLink=new AndroidUdpConnection(applicationContext,SOLO_UDP_PORT){
    @Override protected void onConnectionOpened(){
      SoloConnection.this.onConnectionOpened();
    }
    @Override protected void onConnectionStatus(    LinkConnectionStatus connectionStatus){
      SoloConnection.this.onConnectionStatus(connectionStatus);
    }
  }
;
}","public SoloConnection(Context applicationContext,String soloLinkId,String password){
  super(applicationContext);
  this.wifiHandler=new WifiConnectionHandler(applicationContext);
  wifiHandler.setListener(this);
  this.soloLinkId=soloLinkId;
  this.soloLinkPassword=password;
  this.dataLink=new AndroidUdpConnection(applicationContext,SOLO_UDP_PORT){
    @Override protected void onConnectionOpened(    Bundle extras){
      SoloConnection.this.onConnectionOpened(extras);
    }
    @Override protected void onConnectionStatus(    LinkConnectionStatus connectionStatus){
      SoloConnection.this.onConnectionStatus(connectionStatus);
    }
  }
;
}","The original code's `onConnectionOpened()` method lacks a parameter, which likely causes a method signature mismatch when the parent class or interface expects a `Bundle` parameter. The fixed code adds the `Bundle extras` parameter to the `onConnectionOpened()` method, ensuring it matches the expected method signature in the parent class or interface. This correction enables proper method overriding and prevents potential compilation or runtime errors related to incorrect method signatures."
94644,"private void openUsbDevice(UsbDevice device) throws IOException {
  UsbManager manager=(UsbManager)mContext.getSystemService(Context.USB_SERVICE);
  final UsbSerialDriver serialDriver=UsbSerialProber.openUsbDevice(manager,device);
  if (serialDriver == null) {
    Log.d(TAG,""String_Node_Str"");
    throw new IOException(""String_Node_Str"");
  }
 else {
    Log.d(TAG,""String_Node_Str"" + mBaudRate);
    try {
      serialDriver.open();
      serialDriver.setParameters(mBaudRate,8,UsbSerialDriver.STOPBITS_1,UsbSerialDriver.PARITY_NONE);
      serialDriverRef.set(serialDriver);
      onUsbConnectionOpened();
    }
 catch (    IOException e) {
      Log.e(TAG,""String_Node_Str"" + e.getMessage(),e);
      try {
        serialDriver.close();
      }
 catch (      IOException e2) {
      }
    }
  }
}","private void openUsbDevice(UsbDevice device,Bundle extras) throws IOException {
  UsbManager manager=(UsbManager)mContext.getSystemService(Context.USB_SERVICE);
  final UsbSerialDriver serialDriver=UsbSerialProber.openUsbDevice(manager,device);
  if (serialDriver == null) {
    Log.d(TAG,""String_Node_Str"");
    throw new IOException(""String_Node_Str"");
  }
 else {
    Log.d(TAG,""String_Node_Str"" + mBaudRate);
    try {
      serialDriver.open();
      serialDriver.setParameters(mBaudRate,8,UsbSerialDriver.STOPBITS_1,UsbSerialDriver.PARITY_NONE);
      serialDriverRef.set(serialDriver);
      onUsbConnectionOpened(extras);
    }
 catch (    IOException e) {
      Log.e(TAG,""String_Node_Str"" + e.getMessage(),e);
      try {
        serialDriver.close();
      }
 catch (      IOException e2) {
      }
    }
  }
}","The original code lacks a parameter in the onUsbConnectionOpened() method, preventing potential context or configuration data from being passed when a USB connection is established. The fixed code adds an extras Bundle parameter to both the method signature and the method call, enabling additional configuration or context information to be transmitted during USB device initialization. This modification enhances the method's flexibility and allows for more comprehensive USB connection handling with potential supplementary data transfer."
94645,"@Override public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (ACTION_USB_PERMISSION.equals(action)) {
    removeWatchdog();
    UsbDevice device=intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
    if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED,false)) {
      if (device != null) {
        try {
          openUsbDevice(device);
        }
 catch (        IOException e) {
          Log.e(TAG,e.getMessage(),e);
        }
      }
 else {
        LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.LINK_UNAVAILABLE,""String_Node_Str"");
        onUsbConnectionStatus(connectionStatus);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"" + device);
      LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.PERMISSION_DENIED,""String_Node_Str"");
      onUsbConnectionStatus(connectionStatus);
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (ACTION_USB_PERMISSION.equals(action)) {
    removeWatchdog();
    UsbDevice device=intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
    if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED,false)) {
      if (device != null) {
        try {
          openUsbDevice(device,extrasHolder.get());
        }
 catch (        IOException e) {
          Log.e(TAG,e.getMessage(),e);
        }
      }
 else {
        LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.LINK_UNAVAILABLE,""String_Node_Str"");
        onUsbConnectionStatus(connectionStatus);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"" + device);
      LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.PERMISSION_DENIED,""String_Node_Str"");
      onUsbConnectionStatus(connectionStatus);
    }
  }
}","The original code lacks a parameter when calling `openUsbDevice()`, which likely caused method invocation errors. The fixed code adds `extrasHolder.get()` as an additional parameter, ensuring the method receives the necessary context or configuration for USB device initialization. This modification enhances the method's robustness by providing complete device opening information and preventing potential runtime exceptions during USB connection processes."
94646,"@Override protected void openUsbConnection(Bundle extras) throws IOException {
  registerUsbPermissionBroadcastReceiver();
  UsbManager manager=(UsbManager)mContext.getSystemService(Context.USB_SERVICE);
  List<UsbDevice> availableDevices=UsbSerialProber.getAvailableSupportedDevices(manager);
  if (availableDevices.isEmpty()) {
    Log.d(TAG,""String_Node_Str"");
    throw new IOException(""String_Node_Str"");
  }
  UsbDevice device=availableDevices.get(0);
  if (manager.hasPermission(device)) {
    openUsbDevice(device);
  }
 else {
    removeWatchdog();
    scheduler=Executors.newSingleThreadScheduledExecutor();
    scheduler.schedule(permissionWatchdog,15,TimeUnit.SECONDS);
    Log.d(TAG,""String_Node_Str"" + device.getDeviceName());
    manager.requestPermission(device,usbPermissionIntent);
  }
}","@Override protected void openUsbConnection(Bundle extras) throws IOException {
  extrasHolder.set(extras);
  registerUsbPermissionBroadcastReceiver();
  UsbManager manager=(UsbManager)mContext.getSystemService(Context.USB_SERVICE);
  List<UsbDevice> availableDevices=UsbSerialProber.getAvailableSupportedDevices(manager);
  if (availableDevices.isEmpty()) {
    Log.d(TAG,""String_Node_Str"");
    throw new IOException(""String_Node_Str"");
  }
  UsbDevice device=availableDevices.get(0);
  if (manager.hasPermission(device)) {
    openUsbDevice(device,extras);
  }
 else {
    removeWatchdog();
    scheduler=Executors.newSingleThreadScheduledExecutor();
    scheduler.schedule(permissionWatchdog,15,TimeUnit.SECONDS);
    Log.d(TAG,""String_Node_Str"" + device.getDeviceName());
    manager.requestPermission(device,usbPermissionIntent);
  }
}","The original code lacked passing the extras Bundle when opening the USB device, potentially losing important configuration information. The fixed code introduces `extrasHolder.set(extras)` and modifies `openUsbDevice()` to accept the extras parameter, ensuring all necessary configuration data is preserved during USB device initialization. This change enables more robust and flexible USB device connection handling by maintaining the full context of the original connection request."
94647,"protected void onUsbConnectionOpened(){
  parentConnection.onConnectionOpened();
}","protected void onUsbConnectionOpened(Bundle extras){
  parentConnection.onConnectionOpened(extras);
}","The original code lacks a parameter in the method signature, preventing the passing of essential connection details like a Bundle of extras. The fixed code introduces a Bundle parameter, allowing the method to receive and forward additional connection information to the parent connection's onConnectionOpened method. This modification enables more comprehensive USB connection handling by preserving and transmitting contextual data during the connection process."
94648,"@Override protected void openUsbConnection(Bundle extras) throws IOException {
  D2xxManager ftD2xx=null;
  try {
    ftD2xx=D2xxManager.getInstance(mContext);
  }
 catch (  D2xxManager.D2xxException ex) {
    mLogger.logErr(TAG,ex);
  }
  if (ftD2xx == null) {
    throw new IOException(""String_Node_Str"");
  }
  int DevCount=ftD2xx.createDeviceInfoList(mContext);
  Log.d(TAG,""String_Node_Str"" + DevCount + ""String_Node_Str"");
  if (DevCount < 1) {
    throw new IOException(""String_Node_Str"");
  }
  FT_Device ftDev=null;
  try {
    ftDev=ftD2xx.openByIndex(mContext,0);
  }
 catch (  NullPointerException e) {
    Log.e(TAG,e.getMessage(),e);
  }
 finally {
    if (ftDev == null) {
      throw new IOException(""String_Node_Str"");
    }
  }
  Log.d(TAG,""String_Node_Str"" + mBaudRate);
  ftDev.setBitMode((byte)0,D2xxManager.FT_BITMODE_RESET);
  ftDev.setBaudRate(mBaudRate);
  ftDev.setDataCharacteristics(D2xxManager.FT_DATA_BITS_8,D2xxManager.FT_STOP_BITS_1,D2xxManager.FT_PARITY_NONE);
  ftDev.setFlowControl(D2xxManager.FT_FLOW_NONE,(byte)0x00,(byte)0x00);
  ftDev.setLatencyTimer(LATENCY_TIMER);
  ftDev.purge((byte)(D2xxManager.FT_PURGE_TX | D2xxManager.FT_PURGE_RX));
  if (!ftDev.isOpen()) {
    throw new IOException(""String_Node_Str"");
  }
 else {
    Log.d(TAG,""String_Node_Str"");
  }
  ftDevRef.set(ftDev);
  onUsbConnectionOpened();
}","@Override protected void openUsbConnection(Bundle extras) throws IOException {
  D2xxManager ftD2xx=null;
  try {
    ftD2xx=D2xxManager.getInstance(mContext);
  }
 catch (  D2xxManager.D2xxException ex) {
    mLogger.logErr(TAG,ex);
  }
  if (ftD2xx == null) {
    throw new IOException(""String_Node_Str"");
  }
  int DevCount=ftD2xx.createDeviceInfoList(mContext);
  Log.d(TAG,""String_Node_Str"" + DevCount + ""String_Node_Str"");
  if (DevCount < 1) {
    throw new IOException(""String_Node_Str"");
  }
  FT_Device ftDev=null;
  try {
    ftDev=ftD2xx.openByIndex(mContext,0);
  }
 catch (  NullPointerException e) {
    Log.e(TAG,e.getMessage(),e);
  }
 finally {
    if (ftDev == null) {
      throw new IOException(""String_Node_Str"");
    }
  }
  Log.d(TAG,""String_Node_Str"" + mBaudRate);
  ftDev.setBitMode((byte)0,D2xxManager.FT_BITMODE_RESET);
  ftDev.setBaudRate(mBaudRate);
  ftDev.setDataCharacteristics(D2xxManager.FT_DATA_BITS_8,D2xxManager.FT_STOP_BITS_1,D2xxManager.FT_PARITY_NONE);
  ftDev.setFlowControl(D2xxManager.FT_FLOW_NONE,(byte)0x00,(byte)0x00);
  ftDev.setLatencyTimer(LATENCY_TIMER);
  ftDev.purge((byte)(D2xxManager.FT_PURGE_TX | D2xxManager.FT_PURGE_RX));
  if (!ftDev.isOpen()) {
    throw new IOException(""String_Node_Str"");
  }
 else {
    Log.d(TAG,""String_Node_Str"");
  }
  ftDevRef.set(ftDev);
  onUsbConnectionOpened(extras);
}","The original code missed passing the `extras` parameter when calling `onUsbConnectionOpened()`, potentially losing important initialization context. In the fixed code, `onUsbConnectionOpened(extras)` now correctly passes the `extras` Bundle, ensuring any contextual information from the original method call is preserved. This change maintains method signature integrity and allows downstream processing of initialization parameters that might be critical for USB connection setup."
94649,"protected void onConnectionOpened(){
  if (mConnectionStatus.compareAndSet(MAVLINK_CONNECTING,MAVLINK_CONNECTED)) {
    mLogger.logInfo(TAG,""String_Node_Str"");
    mTaskThread=new Thread(mManagerTask,""String_Node_Str"");
    mTaskThread.start();
  }
}","protected void onConnectionOpened(Bundle extras){
  if (mConnectionStatus.compareAndSet(MAVLINK_CONNECTING,MAVLINK_CONNECTED)) {
    extrasHolder.set(extras);
    mLogger.logInfo(TAG,""String_Node_Str"");
    mTaskThread=new Thread(mManagerTask,""String_Node_Str"");
    mTaskThread.start();
  }
}","The original code lacks handling of connection-related extras, potentially losing important initialization data when establishing a connection. The fixed code introduces `extrasHolder.set(extras)`, which safely captures and stores the incoming Bundle for later use during connection setup. This modification ensures critical connection metadata is preserved, allowing more robust and flexible connection management with minimal code changes."
94650,"@Override public final void openConnection(Bundle connectionExtras) throws IOException {
  getTCPStream(connectionExtras);
  onConnectionOpened();
}","@Override public final void openConnection(Bundle connectionExtras) throws IOException {
  getTCPStream(connectionExtras);
  onConnectionOpened(connectionExtras);
}","The original method `onConnectionOpened()` was called without passing the `connectionExtras` parameter, potentially losing important connection configuration data. The fixed code now passes `connectionExtras` to `onConnectionOpened(connectionExtras)`, ensuring that any relevant connection metadata is correctly propagated to subsequent method calls. This modification allows downstream methods to access and utilize the connection extras, improving overall method flexibility and information retention during the connection process."
94651,"@Override public final void openConnection(Bundle connectionExtras) throws IOException {
  getUdpStream(connectionExtras);
  onConnectionOpened();
}","@Override public final void openConnection(Bundle connectionExtras) throws IOException {
  getUdpStream(connectionExtras);
  onConnectionOpened(connectionExtras);
}","The original code incorrectly calls `onConnectionOpened()` without passing the `connectionExtras` parameter, potentially losing important connection configuration information. The fixed code passes `connectionExtras` to `onConnectionOpened()`, ensuring that any additional connection context or metadata is properly propagated to the method. This modification allows the connection opening process to maintain full context, enabling more comprehensive and flexible connection handling."
94652,"protected void processReceivedParam(msg_param_value m_value){
  Parameter param=new Parameter(m_value.getParam_Id(),m_value.param_value,m_value.param_type);
  loadParameterMetadata(param);
  parameters.put(param.getName().toLowerCase(Locale.US),param);
  int paramIndex=m_value.param_index;
  if (paramIndex == -1) {
    notifyParameterReceipt(param,0,1);
    notifyParametersReceiptEnd();
    return;
  }
  paramsRollCall.append(paramIndex,true);
  expectedParams=m_value.param_count;
  notifyParameterReceipt(param,paramIndex,m_value.param_count);
  if (parameters.size() >= m_value.param_count) {
    killWatchdog();
    isRefreshing.set(false);
    notifyParametersReceiptEnd();
  }
 else {
    resetWatchdog();
  }
}","protected void processReceivedParam(msg_param_value m_value){
  if (!isRefreshing.get())   return;
  Parameter param=new Parameter(m_value.getParam_Id(),m_value.param_value,m_value.param_type);
  loadParameterMetadata(param);
  parameters.put(param.getName().toLowerCase(Locale.US),param);
  int paramIndex=m_value.param_index;
  if (paramIndex == -1) {
    notifyParameterReceipt(param,0,1);
    notifyParametersReceiptEnd();
    return;
  }
  paramsRollCall.append(paramIndex,true);
  expectedParams=m_value.param_count;
  notifyParameterReceipt(param,paramIndex,m_value.param_count);
  if (parameters.size() >= m_value.param_count) {
    if (isRefreshing.compareAndSet(true,false)) {
      killWatchdog();
      notifyParametersReceiptEnd();
    }
  }
 else {
    resetWatchdog();
  }
}","The original code lacks proper concurrency control, potentially causing race conditions and incorrect state management when processing parameter values. The fixed code adds an initial check for the refreshing state and uses `compareAndSet` to ensure atomic state transition, preventing multiple threads from simultaneously triggering end-of-parameter notification. These changes ensure thread-safe parameter processing and prevent potential synchronization issues during parameter receipt."
94653,"public double[] parseRange() throws ParseException {
  final DecimalFormat format=formatter;
  final String[] parts=this.range.split(""String_Node_Str"");
  if (parts.length != 2) {
    throw new IllegalArgumentException();
  }
  final double[] outRange=new double[2];
  outRange[RANGE_LOW]=format.parse(parts[RANGE_LOW]).doubleValue();
  outRange[RANGE_HIGH]=format.parse(parts[RANGE_HIGH]).doubleValue();
  return outRange;
}","public double[] parseRange() throws ParseException {
  final DecimalFormat format=formatter;
  final String[] parts=this.range.split(""String_Node_Str"");
  if (parts.length < 2) {
    throw new IllegalArgumentException();
  }
  final double[] outRange=new double[2];
  outRange[RANGE_LOW]=format.parse(parts[0]).doubleValue();
  outRange[RANGE_HIGH]=format.parse(parts[outRange.length - 1]).doubleValue();
  return outRange;
}","The original code assumed a strict two-part split and used hardcoded indices, which could cause parsing errors if the range string didn't match expectations. The fixed code uses more robust array indexing by checking for at least two parts and using dynamic array length references for accessing first and last elements. This approach makes the parsing more flexible and resilient to variations in input range strings, preventing potential index out of bounds or parsing exceptions."
94654,"private void dispatchAttributeEvent(String attributeEvent,Bundle extrasBundle){
  for (  IObserver observer : observersList) {
    try {
      observer.onAttributeUpdated(attributeEvent,extrasBundle);
    }
 catch (    RemoteException e) {
      Timber.e(e,e.getMessage());
      try {
        removeAttributesObserver(observer);
      }
 catch (      RemoteException e1) {
        Timber.e(e,e1.getMessage());
      }
    }
  }
}","private void dispatchAttributeEvent(String attributeEvent,Bundle extrasBundle){
  if (extrasBundle == emptyBundle)   extrasBundle=null;
  for (  IObserver observer : observersList) {
    try {
      observer.onAttributeUpdated(attributeEvent,extrasBundle);
    }
 catch (    RemoteException e) {
      Timber.e(e,e.getMessage());
      try {
        removeAttributesObserver(observer);
      }
 catch (      RemoteException e1) {
        Timber.e(e,e1.getMessage());
      }
    }
  }
}","The original code lacked handling for an empty bundle scenario, potentially causing null pointer exceptions when passing an empty bundle to observers. The fixed code adds a null check that replaces an empty bundle with null, ensuring consistent and predictable behavior when dispatching attribute events. This modification prevents potential runtime errors and provides more robust event dispatching across different observer implementations."
94655,"private void notifyAttributeUpdate(String attributeEvent,Bundle extrasBundle){
  if (observersList.isEmpty() || attributeEvent == null) {
    return;
  }
  if (isEventsBufferingEnabled()) {
    eventsBuffer.put(new EventInfo(attributeEvent),extrasBundle);
  }
 else {
    dispatchAttributeEvent(attributeEvent,extrasBundle);
  }
}","private void notifyAttributeUpdate(String attributeEvent,Bundle extrasBundle){
  if (observersList.isEmpty() || attributeEvent == null) {
    return;
  }
  if (AttributeEvent.STATE_CONNECTED.equals(attributeEvent) || AttributeEvent.STATE_DISCONNECTED.equals(attributeEvent) || !isEventsBufferingEnabled()) {
    dispatchAttributeEvent(attributeEvent,extrasBundle);
  }
 else {
    if (extrasBundle == null)     extrasBundle=emptyBundle;
    eventsBuffer.put(new EventInfo(attributeEvent),extrasBundle);
  }
}","The original code buffers all events indiscriminately, potentially losing critical connection state changes. The fixed code prioritizes dispatching immediate events like connection state changes and only buffers other events when buffering is enabled, with a null-safe bundle handling. This ensures important state transitions are immediately processed while maintaining the buffering mechanism for less critical events."
94656,"private static Firmware getTypeFirmware(int droneType){
switch (droneType) {
case TYPE_COPTER:
    return Firmware.ARDU_COPTER;
case TYPE_PLANE:
  return Firmware.ARDU_PLANE;
case TYPE_ROVER:
return Firmware.APM_ROVER;
case TYPE_SOLO:
return Firmware.SOLO;
case TYPE_UNKNOWN:
default :
return null;
}
}","private static Firmware getTypeFirmware(int droneType){
switch (droneType) {
case TYPE_COPTER:
    return Firmware.ARDU_COPTER;
case TYPE_PLANE:
  return Firmware.ARDU_PLANE;
case TYPE_ROVER:
return Firmware.APM_ROVER;
case TYPE_UNKNOWN:
default :
return null;
}
}","The original code includes an extra case for TYPE_SOLO, which was likely unnecessary or redundant in the firmware selection logic. The fixed code removes the TYPE_SOLO case, ensuring a more streamlined and focused switch statement that handles only the essential drone types. This simplification reduces potential confusion and potential unintended behavior, making the firmware selection more precise and maintainable."
94657,"public ArduSolo(String droneId,Context context,DataLink.DataLinkProvider<MAVLinkMessage> mavClient,Handler handler,AutopilotWarningParser warningParser,LogMessageListener logListener){
  super(droneId,context,mavClient,handler,warningParser,logListener);
  this.propertyType=new Type(Type.TYPE_SOLO,getFirmwareVersion());
  this.soloComp=new SoloComp(context,handler);
  this.soloComp.setListener(new SoloComp.SoloCompListener(){
    @Override public void onConnected(){
      if (isConnected()) {
        notifyDroneEvent(DroneInterfaces.DroneEventsType.CONNECTED);
      }
    }
    @Override public void onDisconnected(){
      notifyDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED);
    }
    @Override public void onTlvPacketReceived(    TLVPacket packet){
switch (packet.getMessageType()) {
case TLVMessageTypes.TYPE_ARTOO_INPUT_REPORT_MESSAGE:
        break;
case TLVMessageTypes.TYPE_SOLO_GET_BUTTON_SETTING:
case TLVMessageTypes.TYPE_SOLO_SET_BUTTON_SETTING:
      break;
case TLVMessageTypes.TYPE_SOLO_GOPRO_STATE:
    notifyAttributeListener(SoloEvents.SOLO_GOPRO_STATE_UPDATED);
  break;
case TLVMessageTypes.TYPE_SOLO_GOPRO_STATE_V2:
notifyAttributeListener(SoloEvents.SOLO_GOPRO_STATE_V2_UPDATED);
break;
default :
final Bundle messageInfo=new Bundle();
messageInfo.putParcelable(SoloEventExtras.EXTRA_SOLO_MESSAGE_DATA,packet);
notifyAttributeListener(SoloEvents.SOLO_MESSAGE_RECEIVED,messageInfo);
break;
}
}
@Override public void onPresetButtonLoaded(int buttonType,SoloButtonSetting buttonSettings){
notifyAttributeListener(SoloEvents.SOLO_BUTTON_SETTINGS_UPDATED,null);
}
@Override public void onWifiInfoUpdated(String wifiName,String wifiPassword){
notifyAttributeListener(SoloEvents.SOLO_WIFI_SETTINGS_UPDATED,null);
}
@Override public void onButtonPacketReceived(ButtonPacket packet){
final Bundle eventInfo=new Bundle();
eventInfo.putParcelable(SoloEventExtras.EXTRA_SOLO_BUTTON_EVENT,packet);
notifyAttributeListener(SoloEvents.SOLO_BUTTON_EVENT_RECEIVED,eventInfo);
}
@Override public void onTxPowerComplianceCountryUpdated(String compliantCountry){
final Bundle eventInfo=new Bundle(1);
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_TX_POWER_COMPLIANT_COUNTRY,compliantCountry);
notifyAttributeListener(SoloEvents.SOLO_TX_POWER_COMPLIANCE_COUNTRY_UPDATED,eventInfo);
}
@Override public void onVersionsUpdated(){
final Bundle eventInfo=new Bundle();
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_VEHICLE_VERSION,soloComp.getVehicleVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_AUTOPILOT_VERSION,soloComp.getAutopilotVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_GIMBAL_VERSION,soloComp.getGimbalVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_CONTROLLER_VERSION,soloComp.getControllerVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_CONTROLLER_FIRMWARE_VERSION,soloComp.getControllerFirmwareVersion());
notifyAttributeListener(SoloEvents.SOLO_VERSIONS_UPDATED,eventInfo);
}
@Override public void onControllerEvent(String event,Bundle eventInfo){
notifyAttributeListener(event,eventInfo);
}
}
);
}","public ArduSolo(String droneId,Context context,DataLink.DataLinkProvider<MAVLinkMessage> mavClient,Handler handler,AutopilotWarningParser warningParser,LogMessageListener logListener){
  super(droneId,context,mavClient,handler,warningParser,logListener);
  this.soloComp=new SoloComp(context,handler);
  this.soloComp.setListener(new SoloComp.SoloCompListener(){
    @Override public void onConnected(){
      if (isConnected()) {
        notifyDroneEvent(DroneInterfaces.DroneEventsType.CONNECTED);
      }
    }
    @Override public void onDisconnected(){
      notifyDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED);
    }
    @Override public void onTlvPacketReceived(    TLVPacket packet){
switch (packet.getMessageType()) {
case TLVMessageTypes.TYPE_ARTOO_INPUT_REPORT_MESSAGE:
        break;
case TLVMessageTypes.TYPE_SOLO_GET_BUTTON_SETTING:
case TLVMessageTypes.TYPE_SOLO_SET_BUTTON_SETTING:
      break;
case TLVMessageTypes.TYPE_SOLO_GOPRO_STATE:
    notifyAttributeListener(SoloEvents.SOLO_GOPRO_STATE_UPDATED);
  break;
case TLVMessageTypes.TYPE_SOLO_GOPRO_STATE_V2:
notifyAttributeListener(SoloEvents.SOLO_GOPRO_STATE_V2_UPDATED);
break;
default :
final Bundle messageInfo=new Bundle();
messageInfo.putParcelable(SoloEventExtras.EXTRA_SOLO_MESSAGE_DATA,packet);
notifyAttributeListener(SoloEvents.SOLO_MESSAGE_RECEIVED,messageInfo);
break;
}
}
@Override public void onPresetButtonLoaded(int buttonType,SoloButtonSetting buttonSettings){
notifyAttributeListener(SoloEvents.SOLO_BUTTON_SETTINGS_UPDATED,null);
}
@Override public void onWifiInfoUpdated(String wifiName,String wifiPassword){
notifyAttributeListener(SoloEvents.SOLO_WIFI_SETTINGS_UPDATED,null);
}
@Override public void onButtonPacketReceived(ButtonPacket packet){
final Bundle eventInfo=new Bundle();
eventInfo.putParcelable(SoloEventExtras.EXTRA_SOLO_BUTTON_EVENT,packet);
notifyAttributeListener(SoloEvents.SOLO_BUTTON_EVENT_RECEIVED,eventInfo);
}
@Override public void onTxPowerComplianceCountryUpdated(String compliantCountry){
final Bundle eventInfo=new Bundle(1);
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_TX_POWER_COMPLIANT_COUNTRY,compliantCountry);
notifyAttributeListener(SoloEvents.SOLO_TX_POWER_COMPLIANCE_COUNTRY_UPDATED,eventInfo);
}
@Override public void onVersionsUpdated(){
final Bundle eventInfo=new Bundle();
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_VEHICLE_VERSION,soloComp.getVehicleVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_AUTOPILOT_VERSION,soloComp.getAutopilotVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_GIMBAL_VERSION,soloComp.getGimbalVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_CONTROLLER_VERSION,soloComp.getControllerVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_CONTROLLER_FIRMWARE_VERSION,soloComp.getControllerFirmwareVersion());
notifyAttributeListener(SoloEvents.SOLO_VERSIONS_UPDATED,eventInfo);
}
@Override public void onControllerEvent(String event,Bundle eventInfo){
notifyAttributeListener(event,eventInfo);
}
}
);
}","The original code incorrectly initialized `propertyType` without necessary context, potentially leading to unintended behavior or null pointer exceptions. The fixed code removes the unnecessary `propertyType` initialization, simplifying the constructor and eliminating potential initialization risks. By streamlining the constructor, the code becomes more robust and focuses on the essential setup of the `SoloComp` component and its listener."
94658,"@Override public DroneAttribute getAttribute(String attributeType){
switch (attributeType) {
case AttributeType.TYPE:
    propertyType.setFirmwareVersion(getFirmwareVersion());
  return propertyType;
case SoloAttributes.SOLO_STATE:
return SoloApiUtils.getSoloLinkState(this);
case SoloAttributes.SOLO_GOPRO_STATE:
return soloComp.getGoproState();
case SoloAttributes.SOLO_GOPRO_STATE_V2:
return soloComp.getGoproStateV2();
case AttributeType.STATE:
final State stateAttr=(State)super.getAttribute(attributeType);
stateAttr.addToVehicleUid(SERIAL_NUMBER_LABEL,pixhawkSerialNumber);
stateAttr.addToVehicleUid(""String_Node_Str"",soloComp.getSoloMacAddress());
stateAttr.addToVehicleUid(""String_Node_Str"",soloComp.getControllerMacAddress());
return stateAttr;
default :
return super.getAttribute(attributeType);
}
}","@Override public DroneAttribute getAttribute(String attributeType){
switch (attributeType) {
case SoloAttributes.SOLO_STATE:
    return SoloApiUtils.getSoloLinkState(this);
case SoloAttributes.SOLO_GOPRO_STATE:
  return soloComp.getGoproState();
case SoloAttributes.SOLO_GOPRO_STATE_V2:
return soloComp.getGoproStateV2();
case AttributeType.STATE:
final State stateAttr=(State)super.getAttribute(attributeType);
stateAttr.addToVehicleUid(SERIAL_NUMBER_LABEL,pixhawkSerialNumber);
stateAttr.addToVehicleUid(""String_Node_Str"",soloComp.getSoloMacAddress());
stateAttr.addToVehicleUid(""String_Node_Str"",soloComp.getControllerMacAddress());
return stateAttr;
default :
return super.getAttribute(attributeType);
}
}","The buggy code incorrectly includes an unnecessary case for `AttributeType.TYPE` that sets a firmware version and returns a property type, which seems unrelated to the method's primary purpose. The fixed code removes this extraneous case, streamlining the switch statement to focus on Solo-specific attributes like state and GoPro states. By eliminating the irrelevant type handling, the code becomes more focused, maintainable, and aligned with the method's intended functionality of retrieving specific drone attributes."
94659,"@Override public void run(){
  handler.removeCallbacks(this);
  Set<Map.Entry<EventInfo,Bundle>> eventsToDispatch=eventsBuffer.entrySet();
  for (  Map.Entry<EventInfo,Bundle> entry : eventsToDispatch) {
    String event=entry.getKey().event;
    Bundle extras=entry.getValue();
    eventsToDispatch.remove(entry);
    dispatchAttributeEvent(event,extras);
  }
  if (isEventsBufferingEnabled()) {
    handler.postDelayed(this,connectionParams.getEventsDispatchingPeriod());
  }
}","@Override public void run(){
  eventsFilter.clear();
  EventInfo eventInfo=eventsBuffer.poll();
  while (eventInfo != null) {
    eventsFilter.put(eventInfo.event,eventInfo.extras);
    EventInfo.recycle(eventInfo);
    eventInfo=eventsBuffer.poll();
  }
  for (  Map.Entry<String,Bundle> entry : eventsFilter.entrySet()) {
    dispatchAttributeEvent(entry.getKey(),entry.getValue());
  }
  eventsFilter.clear();
  handler.removeCallbacks(this);
  if (isEventsBufferingEnabled()) {
    handler.postDelayed(this,connectionParams.getEventsDispatchingPeriod());
  }
}","The original code modifies the set during iteration, causing a ConcurrentModificationException and potential data loss when removing events. The fixed code uses a separate queue and filter to safely poll and process events without concurrent modification, utilizing a poll-and-process approach with event recycling. This approach ensures thread-safe event handling, prevents exceptions, and maintains the integrity of event dispatching by clearing and reusing data structures efficiently."
94660,"private void dispatchAttributeEvent(String attributeEvent,Bundle extrasBundle){
  if (extrasBundle == emptyBundle)   extrasBundle=null;
  for (  IObserver observer : observersList) {
    try {
      observer.onAttributeUpdated(attributeEvent,extrasBundle);
    }
 catch (    RemoteException e) {
      Timber.e(e,e.getMessage());
      try {
        removeAttributesObserver(observer);
      }
 catch (      RemoteException e1) {
        Timber.e(e,e1.getMessage());
      }
    }
  }
}","private void dispatchAttributeEvent(String attributeEvent,Bundle extrasBundle){
  for (  IObserver observer : observersList) {
    try {
      observer.onAttributeUpdated(attributeEvent,extrasBundle);
    }
 catch (    RemoteException e) {
      Timber.e(e,e.getMessage());
      try {
        removeAttributesObserver(observer);
      }
 catch (      RemoteException e1) {
        Timber.e(e,e1.getMessage());
      }
    }
  }
}","The buggy code unnecessarily checks for an empty bundle and sets it to null, which is redundant and potentially introduces unexpected behavior. The fixed code removes this conditional check, ensuring that the original bundle is passed directly to the observer method without modification. This simplifies the code, eliminates potential null-related issues, and maintains the original intent of dispatching the attribute event with its associated extras bundle."
94661,"private void notifyAttributeUpdate(String attributeEvent,Bundle extrasBundle){
  if (observersList.isEmpty() || attributeEvent == null) {
    return;
  }
  if (AttributeEvent.STATE_CONNECTED.equals(attributeEvent) || AttributeEvent.STATE_DISCONNECTED.equals(attributeEvent) || !isEventsBufferingEnabled()) {
    dispatchAttributeEvent(attributeEvent,extrasBundle);
  }
 else {
    if (extrasBundle == null)     extrasBundle=emptyBundle;
    eventsBuffer.put(new EventInfo(attributeEvent),extrasBundle);
  }
}","private void notifyAttributeUpdate(String attributeEvent,Bundle extrasBundle){
  if (observersList.isEmpty() || attributeEvent == null) {
    return;
  }
  if (AttributeEvent.STATE_CONNECTED.equals(attributeEvent) || AttributeEvent.STATE_DISCONNECTED.equals(attributeEvent) || !isEventsBufferingEnabled()) {
    dispatchAttributeEvent(attributeEvent,extrasBundle);
  }
 else {
    eventsBuffer.add(EventInfo.obtain(attributeEvent,extrasBundle));
  }
}","The original code incorrectly handled event buffering by creating an empty bundle when null and using an inefficient `put` method with a potential key collision. The fixed code replaces this with `eventsBuffer.add()` and uses `EventInfo.obtain()` to create a more robust event tracking mechanism that avoids potential state management issues. This approach improves memory efficiency, prevents potential event data loss, and provides a cleaner, more predictable event buffering strategy."
94662,"@Override public void onDroneEvent(DroneInterfaces.DroneEventsType event,Drone drone){
  final Bundle extrasBundle=new Bundle();
  String droneId=""String_Node_Str"";
  if (drone != null) {
    droneId=drone.getId();
  }
  extrasBundle.putString(AttributeEventExtra.EXTRA_VEHICLE_ID,droneId);
  String droneEvent=null;
  List<Pair<String,Bundle>> attributesInfo=new ArrayList<>();
switch (event) {
case DISCONNECTED:
    context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_DISCONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId));
  droneEvent=AttributeEvent.STATE_DISCONNECTED;
break;
case GUIDEDPOINT:
droneEvent=AttributeEvent.GUIDED_POINT_UPDATED;
break;
case RADIO:
droneEvent=AttributeEvent.SIGNAL_UPDATED;
break;
case RC_IN:
break;
case RC_OUT:
break;
case ARMING_STARTED:
case ARMING:
droneEvent=AttributeEvent.STATE_ARMING;
break;
case AUTOPILOT_WARNING:
State droneState=(State)drone.getAttribute(AttributeType.STATE);
if (droneState != null) {
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_ERROR_ID,droneState.getAutopilotErrorId());
}
droneEvent=AttributeEvent.AUTOPILOT_ERROR;
break;
case MODE:
droneEvent=AttributeEvent.STATE_VEHICLE_MODE;
break;
case ATTITUDE:
case ORIENTATION:
droneEvent=AttributeEvent.ATTITUDE_UPDATED;
break;
case SPEED:
droneEvent=AttributeEvent.SPEED_UPDATED;
break;
case BATTERY:
droneEvent=AttributeEvent.BATTERY_UPDATED;
break;
case STATE:
droneEvent=AttributeEvent.STATE_UPDATED;
break;
case MISSION_UPDATE:
droneEvent=AttributeEvent.MISSION_UPDATED;
break;
case MISSION_RECEIVED:
droneEvent=AttributeEvent.MISSION_RECEIVED;
break;
case FIRMWARE:
case TYPE:
droneEvent=AttributeEvent.TYPE_UPDATED;
break;
case HOME:
droneEvent=AttributeEvent.HOME_UPDATED;
break;
case CALIBRATION_IMU:
if (drone instanceof MavLinkDrone) {
String calIMUMessage=((MavLinkDrone)drone).getCalibrationSetup().getMessage();
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,calIMUMessage);
droneEvent=AttributeEvent.CALIBRATION_IMU;
}
break;
case CALIBRATION_TIMEOUT:
if (drone instanceof MavLinkDrone) {
AccelCalibration accelCalibration=((MavLinkDrone)drone).getCalibrationSetup();
String message=accelCalibration.getMessage();
if (accelCalibration.isCalibrating() && TextUtils.isEmpty(message)) {
accelCalibration.cancelCalibration();
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
}
 else {
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,message);
droneEvent=AttributeEvent.CALIBRATION_IMU_TIMEOUT;
}
}
break;
case HEARTBEAT_TIMEOUT:
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
break;
case CONNECTING:
droneEvent=AttributeEvent.STATE_CONNECTING;
break;
case HEARTBEAT_FIRST:
Bundle heartBeatExtras=new Bundle();
heartBeatExtras.putString(AttributeEventExtra.EXTRA_VEHICLE_ID,drone.getId());
if (drone instanceof MavLinkDrone) {
heartBeatExtras.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,((MavLinkDrone)drone).getMavlinkVersion());
}
attributesInfo.add(Pair.create(AttributeEvent.HEARTBEAT_FIRST,heartBeatExtras));
case CONNECTED:
ConnectionParameter sanitizedParameter=connectionParams.clone();
context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_CONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId).putExtra(GCSEvent.EXTRA_VEHICLE_CONNECTION_PARAMETER,sanitizedParameter));
attributesInfo.add(Pair.<String,Bundle>create(AttributeEvent.STATE_CONNECTED,extrasBundle));
break;
case HEARTBEAT_RESTORED:
if (drone instanceof MavLinkDrone) {
extrasBundle.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,((MavLinkDrone)drone).getMavlinkVersion());
}
droneEvent=AttributeEvent.HEARTBEAT_RESTORED;
break;
case MISSION_SENT:
droneEvent=AttributeEvent.MISSION_SENT;
break;
case INVALID_POLYGON:
break;
case MISSION_WP_UPDATE:
if (drone instanceof MavLinkDrone) {
int currentWaypoint=((MavLinkDrone)drone).getMissionStats().getCurrentWP();
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_CURRENT_WAYPOINT,currentWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_UPDATED;
}
break;
case MISSION_WP_REACHED:
if (drone instanceof MavLinkDrone) {
int lastReachedWaypoint=((MavLinkDrone)drone).getMissionStats().getLastReachedWP();
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_LAST_REACHED_WAYPOINT,lastReachedWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_REACHED;
}
break;
case ALTITUDE:
droneEvent=AttributeEvent.ALTITUDE_UPDATED;
break;
case WARNING_SIGNAL_WEAK:
droneEvent=AttributeEvent.SIGNAL_WEAK;
break;
case WARNING_NO_GPS:
droneEvent=AttributeEvent.WARNING_NO_GPS;
break;
case MAGNETOMETER:
break;
case FOOTPRINT:
droneEvent=AttributeEvent.CAMERA_FOOTPRINTS_UPDATED;
break;
case EKF_STATUS_UPDATE:
droneEvent=AttributeEvent.STATE_EKF_REPORT;
break;
case EKF_POSITION_STATE_UPDATE:
droneEvent=AttributeEvent.STATE_EKF_POSITION;
break;
}
if (droneEvent != null) {
notifyAttributeUpdate(droneEvent,extrasBundle);
}
if (!attributesInfo.isEmpty()) {
notifyAttributeUpdate(attributesInfo);
}
}","@Override public void onDroneEvent(DroneInterfaces.DroneEventsType event,Drone drone){
  final Bundle extrasBundle=new Bundle();
  String droneId=""String_Node_Str"";
  if (drone != null) {
    droneId=drone.getId();
  }
  extrasBundle.putString(AttributeEventExtra.EXTRA_VEHICLE_ID,droneId);
  String droneEvent=null;
  List<Pair<String,Bundle>> attributesInfo=new ArrayList<>();
switch (event) {
case DISCONNECTED:
    context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_DISCONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId));
  droneEvent=AttributeEvent.STATE_DISCONNECTED;
eventsBuffer.clear();
break;
case GUIDEDPOINT:
droneEvent=AttributeEvent.GUIDED_POINT_UPDATED;
break;
case RADIO:
droneEvent=AttributeEvent.SIGNAL_UPDATED;
break;
case RC_IN:
break;
case RC_OUT:
break;
case ARMING_STARTED:
case ARMING:
droneEvent=AttributeEvent.STATE_ARMING;
break;
case AUTOPILOT_WARNING:
State droneState=(State)drone.getAttribute(AttributeType.STATE);
if (droneState != null) {
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_ERROR_ID,droneState.getAutopilotErrorId());
}
droneEvent=AttributeEvent.AUTOPILOT_ERROR;
break;
case MODE:
droneEvent=AttributeEvent.STATE_VEHICLE_MODE;
break;
case ATTITUDE:
case ORIENTATION:
droneEvent=AttributeEvent.ATTITUDE_UPDATED;
break;
case SPEED:
droneEvent=AttributeEvent.SPEED_UPDATED;
break;
case BATTERY:
droneEvent=AttributeEvent.BATTERY_UPDATED;
break;
case STATE:
droneEvent=AttributeEvent.STATE_UPDATED;
break;
case MISSION_UPDATE:
droneEvent=AttributeEvent.MISSION_UPDATED;
break;
case MISSION_RECEIVED:
droneEvent=AttributeEvent.MISSION_RECEIVED;
break;
case FIRMWARE:
case TYPE:
droneEvent=AttributeEvent.TYPE_UPDATED;
break;
case HOME:
droneEvent=AttributeEvent.HOME_UPDATED;
break;
case CALIBRATION_IMU:
if (drone instanceof MavLinkDrone) {
String calIMUMessage=((MavLinkDrone)drone).getCalibrationSetup().getMessage();
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,calIMUMessage);
droneEvent=AttributeEvent.CALIBRATION_IMU;
}
break;
case CALIBRATION_TIMEOUT:
if (drone instanceof MavLinkDrone) {
AccelCalibration accelCalibration=((MavLinkDrone)drone).getCalibrationSetup();
String message=accelCalibration.getMessage();
if (accelCalibration.isCalibrating() && TextUtils.isEmpty(message)) {
accelCalibration.cancelCalibration();
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
}
 else {
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,message);
droneEvent=AttributeEvent.CALIBRATION_IMU_TIMEOUT;
}
}
break;
case HEARTBEAT_TIMEOUT:
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
break;
case CONNECTING:
droneEvent=AttributeEvent.STATE_CONNECTING;
break;
case HEARTBEAT_FIRST:
Bundle heartBeatExtras=new Bundle();
heartBeatExtras.putString(AttributeEventExtra.EXTRA_VEHICLE_ID,drone.getId());
if (drone instanceof MavLinkDrone) {
heartBeatExtras.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,((MavLinkDrone)drone).getMavlinkVersion());
}
attributesInfo.add(Pair.create(AttributeEvent.HEARTBEAT_FIRST,heartBeatExtras));
case CONNECTED:
ConnectionParameter sanitizedParameter=connectionParams.clone();
context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_CONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId).putExtra(GCSEvent.EXTRA_VEHICLE_CONNECTION_PARAMETER,sanitizedParameter));
attributesInfo.add(Pair.<String,Bundle>create(AttributeEvent.STATE_CONNECTED,extrasBundle));
break;
case HEARTBEAT_RESTORED:
if (drone instanceof MavLinkDrone) {
extrasBundle.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,((MavLinkDrone)drone).getMavlinkVersion());
}
droneEvent=AttributeEvent.HEARTBEAT_RESTORED;
break;
case MISSION_SENT:
droneEvent=AttributeEvent.MISSION_SENT;
break;
case INVALID_POLYGON:
break;
case MISSION_WP_UPDATE:
if (drone instanceof MavLinkDrone) {
int currentWaypoint=((MavLinkDrone)drone).getMissionStats().getCurrentWP();
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_CURRENT_WAYPOINT,currentWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_UPDATED;
}
break;
case MISSION_WP_REACHED:
if (drone instanceof MavLinkDrone) {
int lastReachedWaypoint=((MavLinkDrone)drone).getMissionStats().getLastReachedWP();
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_LAST_REACHED_WAYPOINT,lastReachedWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_REACHED;
}
break;
case ALTITUDE:
droneEvent=AttributeEvent.ALTITUDE_UPDATED;
break;
case WARNING_SIGNAL_WEAK:
droneEvent=AttributeEvent.SIGNAL_WEAK;
break;
case WARNING_NO_GPS:
droneEvent=AttributeEvent.WARNING_NO_GPS;
break;
case MAGNETOMETER:
break;
case FOOTPRINT:
droneEvent=AttributeEvent.CAMERA_FOOTPRINTS_UPDATED;
break;
case EKF_STATUS_UPDATE:
droneEvent=AttributeEvent.STATE_EKF_REPORT;
break;
case EKF_POSITION_STATE_UPDATE:
droneEvent=AttributeEvent.STATE_EKF_POSITION;
break;
}
if (droneEvent != null) {
notifyAttributeUpdate(droneEvent,extrasBundle);
}
if (!attributesInfo.isEmpty()) {
notifyAttributeUpdate(attributesInfo);
}
}","The buggy code lacked proper event management, potentially leading to unhandled or stale events during drone disconnection. The fixed code adds `eventsBuffer.clear()` in the DISCONNECTED case, ensuring a clean slate for new events after disconnection. This improvement enhances event handling robustness by preventing potential residual event conflicts and maintaining a clean state during drone connection state changes."
94663,"public void connect(ConnectionParameter connParams){
  try {
    connParams=checkConnectionParameter(connParams);
    ConnectionParameter currentConnParams=this.connectionParams == null ? this.connectionParams : checkConnectionParameter(this.connectionParams);
    if (!connParams.equals(currentConnParams)) {
      if (this.droneMgr != null) {
        LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.ADDRESS_IN_USE,""String_Node_Str"");
        onConnectionStatus(connectionStatus);
        return;
      }
      this.connectionParams=connParams;
      this.droneMgr=service.connectDroneManager(this.connectionParams,ownerId,this);
      if (isEventsBufferingEnabled()) {
        handler.postDelayed(eventsDispatcher,this.connectionParams.getEventsDispatchingPeriod());
      }
    }
  }
 catch (  ConnectionException e) {
    LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.INVALID_CREDENTIALS,e.getMessage());
    onConnectionStatus(connectionStatus);
    disconnect();
  }
}","public void connect(ConnectionParameter connParams){
  try {
    connParams=checkConnectionParameter(connParams);
    ConnectionParameter currentConnParams=this.connectionParams == null ? this.connectionParams : checkConnectionParameter(this.connectionParams);
    if (!connParams.equals(currentConnParams)) {
      if (this.droneMgr != null) {
        LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.ADDRESS_IN_USE,""String_Node_Str"");
        onConnectionStatus(connectionStatus);
        return;
      }
      this.connectionParams=connParams;
      this.droneMgr=service.connectDroneManager(this.connectionParams,ownerId,this);
      if (isEventsBufferingEnabled()) {
        eventsBuffer.clear();
        handler.postDelayed(eventsDispatcher,this.connectionParams.getEventsDispatchingPeriod());
      }
    }
  }
 catch (  ConnectionException e) {
    LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.INVALID_CREDENTIALS,e.getMessage());
    onConnectionStatus(connectionStatus);
    disconnect();
  }
}","The original code did not clear the events buffer before starting a new connection, potentially leading to stale or mixed event data from previous connections. The fixed code adds `eventsBuffer.clear()` before starting the event dispatcher, ensuring a clean slate for new connection events. This improvement prevents potential data contamination and ensures accurate event tracking when establishing a new drone manager connection."
94664,"@Override public void onLocationResult(LocationResult result){
  final Location androidLocation=result.getLastLocation();
  if (androidLocation == null)   return;
  org.droidplanner.services.android.impl.core.gcs.location.Location gcsLocation=locationRelay.toGcsLocation(androidLocation);
  Timber.d(""String_Node_Str"" + LocationRelay.getLatLongFromLocation(androidLocation));
  notifyLocationUpdate(gcsLocation);
}","@Override public void onLocationResult(LocationResult result){
  final Location androidLocation=result.getLastLocation();
  if (androidLocation == null)   return;
  org.droidplanner.services.android.impl.core.gcs.location.Location gcsLocation=locationRelay.toGcsLocation(androidLocation);
  if (gcsLocation == null)   return;
  Timber.d(""String_Node_Str"" + LocationRelay.getLatLongFromLocation(androidLocation));
  notifyLocationUpdate(gcsLocation);
}","The original code lacks a null check on the converted GCS location, potentially causing a NullPointerException when passing a null location to notifyLocationUpdate(). The fixed code adds a null check for gcsLocation before calling notifyLocationUpdate(), ensuring that only valid location objects are processed. This additional validation prevents potential runtime crashes and improves the method's robustness by gracefully handling scenarios where location conversion might fail."
94665,"public void connect(ConnectionParameter connParams){
  try {
    connParams=checkConnectionParameter(connParams);
    if (!connParams.equals(this.connectionParams)) {
      if (this.droneMgr != null) {
        LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.ADDRESS_IN_USE,""String_Node_Str"");
        onConnectionStatus(connectionStatus);
        return;
      }
      this.connectionParams=connParams;
      this.droneMgr=service.connectDroneManager(this.connectionParams,ownerId,this);
    }
  }
 catch (  ConnectionException e) {
    LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.INVALID_CREDENTIALS,e.getMessage());
    onConnectionStatus(connectionStatus);
    disconnect();
  }
}","public void connect(ConnectionParameter connParams){
  try {
    connParams=checkConnectionParameter(connParams);
    ConnectionParameter currentConnParams=this.connectionParams == null ? this.connectionParams : checkConnectionParameter(this.connectionParams);
    if (!connParams.equals(currentConnParams)) {
      if (this.droneMgr != null) {
        LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.ADDRESS_IN_USE,""String_Node_Str"");
        onConnectionStatus(connectionStatus);
        return;
      }
      this.connectionParams=connParams;
      this.droneMgr=service.connectDroneManager(this.connectionParams,ownerId,this);
    }
  }
 catch (  ConnectionException e) {
    LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.INVALID_CREDENTIALS,e.getMessage());
    onConnectionStatus(connectionStatus);
    disconnect();
  }
}","The original code did not handle null connection parameters, potentially causing unexpected behavior when comparing connection settings. The fixed code introduces a null check for `this.connectionParams` and applies a consistent parameter validation by using `checkConnectionParameter()` for both comparison objects. This modification ensures robust connection parameter validation, prevents potential null pointer exceptions, and provides a more reliable mechanism for managing drone connection states."
94666,"public AndroidTcpConnection(Context context,String tcpServerIp,int tcpServerPort){
  super(context);
  this.serverIp=tcpServerIp;
  this.serverPort=tcpServerPort;
  mConnectionImpl=new TcpConnection(){
    @Override protected int loadServerPort(){
      return serverPort;
    }
    @Override protected String loadServerIP(){
      return serverIp;
    }
    @Override protected Logger initLogger(){
      return AndroidTcpConnection.this.initLogger();
    }
    @Override protected void onConnectionOpened(){
      AndroidTcpConnection.this.onConnectionOpened();
    }
    @Override protected void onConnectionStatus(    LinkConnectionStatus connectionStatus){
      AndroidTcpConnection.this.onConnectionStatus(connectionStatus);
    }
  }
;
}","public AndroidTcpConnection(Context context,String tcpServerIp,int tcpServerPort){
  this(context,tcpServerIp,tcpServerPort,null);
}","The original code lacks a default constructor, causing potential initialization issues when creating an AndroidTcpConnection instance without all parameters. The fixed code introduces a simplified constructor that calls another constructor with a null parameter, providing a flexible initialization mechanism. This approach allows for more robust object creation, enabling developers to instantiate the class with default or partial configurations while maintaining the original constructor's full functionality."
94667,"public AndroidUdpConnection(Context context,int udpServerPort){
  super(context);
  this.serverPort=udpServerPort;
  mConnectionImpl=new UdpConnection(){
    @Override protected int loadServerPort(){
      return serverPort;
    }
    @Override protected Logger initLogger(){
      return AndroidUdpConnection.this.initLogger();
    }
    @Override protected void onConnectionOpened(){
      AndroidUdpConnection.this.onConnectionOpened();
    }
    @Override protected void onConnectionStatus(    LinkConnectionStatus connectionStatus){
      AndroidUdpConnection.this.onConnectionStatus(connectionStatus);
    }
  }
;
}","public AndroidUdpConnection(Context context,int udpServerPort){
  this(context,udpServerPort,null);
}","The original code lacks a default constructor, causing potential initialization issues when creating an AndroidUdpConnection instance without explicit port configuration. The fixed code introduces a delegating constructor that calls another constructor with a null parameter, providing a default initialization path. This approach ensures flexibility and robustness by allowing multiple instantiation strategies while maintaining a consistent object creation mechanism."
94668,"/** 
 * Setup a MAVLink connection based on the connection parameters.
 */
@Override public synchronized void openConnection(){
  if (isConnected() || isConnecting())   return;
  final String tag=toString();
  final int connectionType=connParams.getConnectionType();
  final Bundle paramsBundle=connParams.getParamsBundle();
  if (mavlinkConn == null) {
switch (connectionType) {
case ConnectionType.TYPE_USB:
      final int baudRate=paramsBundle.getInt(ConnectionType.EXTRA_USB_BAUD_RATE,ConnectionType.DEFAULT_USB_BAUD_RATE);
    mavlinkConn=new UsbConnection(context,baudRate);
  Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_BLUETOOTH:
final String bluetoothAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
mavlinkConn=new BluetoothConnection(context,bluetoothAddress);
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_TCP:
final String tcpServerIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
final int tcpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,ConnectionType.DEFAULT_TCP_SERVER_PORT);
mavlinkConn=new AndroidTcpConnection(context,tcpServerIp,tcpServerPort);
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_UDP:
final int udpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,ConnectionType.DEFAULT_UDP_SERVER_PORT);
mavlinkConn=new AndroidUdpConnection(context,udpServerPort);
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_SOLO:
{
Timber.i(""String_Node_Str"");
final String soloLinkId=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_ID,null);
final String linkPassword=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_PASSWORD,null);
mavlinkConn=new SoloConnection(context,soloLinkId,linkPassword);
break;
}
default :
Timber.e(""String_Node_Str"",connectionType);
return;
}
}
mavlinkConn.addMavLinkConnectionListener(tag,mConnectionListener);
if (connectionType == ConnectionType.TYPE_UDP) {
final String pingIpAddress=paramsBundle.getString(ConnectionType.EXTRA_UDP_PING_RECEIVER_IP);
if (!TextUtils.isEmpty(pingIpAddress)) {
try {
final InetAddress resolvedAddress=InetAddress.getByName(pingIpAddress);
final int pingPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_PING_RECEIVER_PORT);
final long pingPeriod=paramsBundle.getLong(ConnectionType.EXTRA_UDP_PING_PERIOD,ConnectionType.DEFAULT_UDP_PING_PERIOD);
final byte[] pingPayload=paramsBundle.getByteArray(ConnectionType.EXTRA_UDP_PING_PAYLOAD);
((AndroidUdpConnection)mavlinkConn).addPingTarget(resolvedAddress,pingPort,pingPeriod,pingPayload);
}
 catch (UnknownHostException e) {
Timber.e(e,""String_Node_Str"");
}
}
}
if (mavlinkConn.getConnectionStatus() == MavLinkConnection.MAVLINK_DISCONNECTED) {
mavlinkConn.connect();
GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
}
}","/** 
 * Setup a MAVLink connection based on the connection parameters.
 */
@Override public synchronized void openConnection(){
  if (isConnected() || isConnecting())   return;
  final String tag=toString();
  final int connectionType=connParams.getConnectionType();
  final Bundle paramsBundle=connParams.getParamsBundle();
  if (mavlinkConn == null) {
switch (connectionType) {
case ConnectionType.TYPE_USB:
      final int baudRate=paramsBundle.getInt(ConnectionType.EXTRA_USB_BAUD_RATE,ConnectionType.DEFAULT_USB_BAUD_RATE);
    mavlinkConn=new UsbConnection(context,baudRate);
  Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_BLUETOOTH:
final String bluetoothAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
mavlinkConn=new BluetoothConnection(context,bluetoothAddress);
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_TCP:
final String tcpServerIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
final int tcpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,ConnectionType.DEFAULT_TCP_SERVER_PORT);
mavlinkConn=new AndroidTcpConnection(context,tcpServerIp,tcpServerPort,new WifiConnectionHandler(context));
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_UDP:
final int udpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,ConnectionType.DEFAULT_UDP_SERVER_PORT);
mavlinkConn=new AndroidUdpConnection(context,udpServerPort,new WifiConnectionHandler(context));
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_SOLO:
{
Timber.i(""String_Node_Str"");
final String soloLinkId=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_ID,null);
final String linkPassword=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_PASSWORD,null);
mavlinkConn=new SoloConnection(context,soloLinkId,linkPassword);
break;
}
default :
Timber.e(""String_Node_Str"",connectionType);
return;
}
}
mavlinkConn.addMavLinkConnectionListener(tag,mConnectionListener);
if (connectionType == ConnectionType.TYPE_UDP) {
final String pingIpAddress=paramsBundle.getString(ConnectionType.EXTRA_UDP_PING_RECEIVER_IP);
if (!TextUtils.isEmpty(pingIpAddress)) {
try {
final InetAddress resolvedAddress=InetAddress.getByName(pingIpAddress);
final int pingPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_PING_RECEIVER_PORT);
final long pingPeriod=paramsBundle.getLong(ConnectionType.EXTRA_UDP_PING_PERIOD,ConnectionType.DEFAULT_UDP_PING_PERIOD);
final byte[] pingPayload=paramsBundle.getByteArray(ConnectionType.EXTRA_UDP_PING_PAYLOAD);
((AndroidUdpConnection)mavlinkConn).addPingTarget(resolvedAddress,pingPort,pingPeriod,pingPayload);
}
 catch (UnknownHostException e) {
Timber.e(e,""String_Node_Str"");
}
}
}
if (mavlinkConn.getConnectionStatus() == MavLinkConnection.MAVLINK_DISCONNECTED) {
mavlinkConn.connect();
GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
}
}","The original code lacked a proper connection handler for TCP and UDP connection types, which could lead to potential connectivity issues. The fixed code adds a WifiConnectionHandler to AndroidTcpConnection and AndroidUdpConnection constructors, ensuring robust network management and better handling of network-specific connection parameters. This improvement enhances the reliability and stability of MAVLink connection establishment across different network interfaces."
94669,"private void enableFollowMe(){
  lastLocation=null;
  state=FollowStates.FOLLOW_START;
  locationFinder.enableLocationUpdates();
  followAlgorithm.enableFollow();
  droneMgr.onAttributeEvent(AttributeEvent.FOLLOW_START,null,false);
}","private void enableFollowMe(){
  GuidedPoint.changeToGuidedMode(droneMgr.getDrone(),null);
  state=FollowStates.FOLLOW_START;
  locationFinder.enableLocationUpdates();
  followAlgorithm.enableFollow();
  droneMgr.onAttributeEvent(AttributeEvent.FOLLOW_START,null,false);
}","The original code lacks a crucial step to set the drone to guided mode before initiating follow-me functionality. The fixed code adds `GuidedPoint.changeToGuidedMode(droneMgr.getDrone(),null)`, which explicitly switches the drone to guided mode, ensuring proper control and navigation preparation. This modification ensures the drone is in the correct operational state before starting the follow algorithm, improving reliability and preventing potential navigation errors."
94670,"private void disableFollowMe(){
  followAlgorithm.disableFollow();
  locationFinder.disableLocationUpdates();
  lastLocation=null;
  if (isEnabled()) {
    state=FollowStates.FOLLOW_END;
    droneMgr.onAttributeEvent(AttributeEvent.FOLLOW_STOP,null,false);
  }
}","private void disableFollowMe(){
  followAlgorithm.disableFollow();
  locationFinder.disableLocationUpdates();
  lastLocation=null;
  if (isEnabled()) {
    state=FollowStates.FOLLOW_END;
    droneMgr.onAttributeEvent(AttributeEvent.FOLLOW_STOP,null,false);
  }
  final MavLinkDrone drone=droneMgr.getDrone();
  if (GuidedPoint.isGuidedMode(drone)) {
    droneMgr.getDrone().executeAsyncAction(new Action(ControlActions.ACTION_SEND_BRAKE_VEHICLE),null);
  }
}","The original code lacked a critical safety mechanism for stopping the drone when exiting follow mode. The fixed code adds a check for guided mode and sends a brake action to ensure the drone immediately halts its movement when follow mode is disabled. This enhancement improves drone control by providing a definitive stopping procedure, preventing potential uncontrolled drone behavior during mode transitions."
94671,"public void toggleFollowMeState(){
  final MavLinkDrone drone=droneMgr.getDrone();
  final State droneState=drone == null ? null : drone.getState();
  if (droneState == null) {
    state=FollowStates.FOLLOW_INVALID_STATE;
    return;
  }
  if (isEnabled()) {
    disableFollowMe();
  }
 else {
    if (droneMgr.isConnected()) {
      if (droneState.isArmed()) {
        GuidedPoint.changeToGuidedMode(drone,null);
        enableFollowMe();
      }
 else {
        state=FollowStates.FOLLOW_DRONE_NOT_ARMED;
      }
    }
 else {
      state=FollowStates.FOLLOW_DRONE_DISCONNECTED;
    }
  }
}","public void toggleFollowMeState(){
  final MavLinkDrone drone=droneMgr.getDrone();
  final State droneState=drone == null ? null : drone.getState();
  if (droneState == null) {
    state=FollowStates.FOLLOW_INVALID_STATE;
    return;
  }
  if (isEnabled()) {
    disableFollowMe();
  }
 else {
    if (droneMgr.isConnected()) {
      if (droneState.isArmed()) {
        enableFollowMe();
      }
 else {
        state=FollowStates.FOLLOW_DRONE_NOT_ARMED;
      }
    }
 else {
      state=FollowStates.FOLLOW_DRONE_DISCONNECTED;
    }
  }
}","The buggy code unnecessarily calls `GuidedPoint.changeToGuidedMode()` before enabling follow me, which could introduce unintended mode switching or potential errors. The fixed code removes this unnecessary method call, directly proceeding to `enableFollowMe()` after confirming drone connectivity and armed status. By simplifying the flow and eliminating the superfluous mode change, the fixed code provides a more direct and robust implementation of the follow me state toggle mechanism."
94672,"public void disableFollow(){
  if (isFollowEnabled.compareAndSet(true,false)) {
    final MavLinkDrone drone=droneMgr.getDrone();
    if (GuidedPoint.isGuidedMode(drone)) {
      droneMgr.getDrone().executeAsyncAction(new Action(ControlActions.ACTION_SEND_BRAKE_VEHICLE),null);
    }
    if (roiEstimator != null)     roiEstimator.disableFollow();
  }
}","public void disableFollow(){
  if (isFollowEnabled.compareAndSet(true,false)) {
    if (roiEstimator != null)     roiEstimator.disableFollow();
  }
}","The original code attempted to brake the vehicle in guided mode, but this action could be redundant or cause unintended side effects during follow mode disabling. The fixed code removes the drone braking logic, focusing solely on disabling the follow estimator when follow mode is turned off. By eliminating unnecessary drone control commands, the code becomes more focused, predictable, and reduces potential operational risks during follow mode state changes."
94673,"public void connect(ConnectionParameter connParams){
  try {
    connParams=checkConnectionParameter(connParams);
    if (!connParams.equals(this.connectionParams)) {
      if (this.droneMgr != null) {
        LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.ADDRESS_IN_USE,""String_Node_Str"");
        onConnectionStatus(connectionStatus);
        return;
      }
      this.connectionParams=connParams;
      this.droneMgr=service.connectDroneManager(this.connectionParams,ownerId,this);
    }
  }
 catch (  ConnectionException e) {
    LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.INVALID_CREDENTIALS,e.getMessage());
    onConnectionStatus(connectionStatus);
    disconnect();
  }
}","public void connect(ConnectionParameter connParams){
  try {
    connParams=checkConnectionParameter(connParams);
    ConnectionParameter currentConnParams=this.connectionParams == null ? this.connectionParams : checkConnectionParameter(this.connectionParams);
    if (!connParams.equals(currentConnParams)) {
      if (this.droneMgr != null) {
        LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.ADDRESS_IN_USE,""String_Node_Str"");
        onConnectionStatus(connectionStatus);
        return;
      }
      this.connectionParams=connParams;
      this.droneMgr=service.connectDroneManager(this.connectionParams,ownerId,this);
    }
  }
 catch (  ConnectionException e) {
    LinkConnectionStatus connectionStatus=LinkConnectionStatus.newFailedConnectionStatus(LinkConnectionStatus.INVALID_CREDENTIALS,e.getMessage());
    onConnectionStatus(connectionStatus);
    disconnect();
  }
}","The original code lacks proper null handling when comparing connection parameters, potentially causing null pointer exceptions during connection checks. The fixed code introduces a null-safe comparison by creating a `currentConnParams` variable that checks and validates the existing connection parameters before comparison. This approach ensures robust parameter validation, prevents potential runtime errors, and provides a more resilient connection management mechanism."
94674,"public AndroidTcpConnection(Context context,String tcpServerIp,int tcpServerPort){
  super(context);
  this.serverIp=tcpServerIp;
  this.serverPort=tcpServerPort;
  mConnectionImpl=new TcpConnection(){
    @Override protected int loadServerPort(){
      return serverPort;
    }
    @Override protected String loadServerIP(){
      return serverIp;
    }
    @Override protected Logger initLogger(){
      return AndroidTcpConnection.this.initLogger();
    }
    @Override protected void onConnectionOpened(){
      AndroidTcpConnection.this.onConnectionOpened();
    }
    @Override protected void onConnectionStatus(    LinkConnectionStatus connectionStatus){
      AndroidTcpConnection.this.onConnectionStatus(connectionStatus);
    }
  }
;
}","public AndroidTcpConnection(Context context,String tcpServerIp,int tcpServerPort){
  this(context,tcpServerIp,tcpServerPort,null);
}","The original constructor lacks a default initialization path, potentially causing null pointer exceptions or incomplete object setup. The fixed code introduces an overloaded constructor that calls another constructor with a null default parameter, ensuring consistent initialization and providing flexibility for different instantiation scenarios. This approach allows more robust object creation by delegating initialization logic to a single, comprehensive constructor method."
94675,"public AndroidUdpConnection(Context context,int udpServerPort){
  super(context);
  this.serverPort=udpServerPort;
  mConnectionImpl=new UdpConnection(){
    @Override protected int loadServerPort(){
      return serverPort;
    }
    @Override protected Logger initLogger(){
      return AndroidUdpConnection.this.initLogger();
    }
    @Override protected void onConnectionOpened(){
      AndroidUdpConnection.this.onConnectionOpened();
    }
    @Override protected void onConnectionStatus(    LinkConnectionStatus connectionStatus){
      AndroidUdpConnection.this.onConnectionStatus(connectionStatus);
    }
  }
;
}","public AndroidUdpConnection(Context context,int udpServerPort){
  this(context,udpServerPort,null);
}","The original code lacks a default constructor and potentially creates tight coupling between the anonymous UdpConnection implementation and the AndroidUdpConnection class. The fixed code introduces a new constructor that delegates to a more comprehensive constructor, likely with a default null parameter for additional flexibility. This approach provides a more modular and extensible design, allowing easier instantiation and potential future configuration of the UDP connection."
94676,"/** 
 * Setup a MAVLink connection based on the connection parameters.
 */
@Override public synchronized void openConnection(){
  if (isConnected() || isConnecting())   return;
  final String tag=toString();
  final int connectionType=connParams.getConnectionType();
  final Bundle paramsBundle=connParams.getParamsBundle();
  if (mavlinkConn == null) {
switch (connectionType) {
case ConnectionType.TYPE_USB:
      final int baudRate=paramsBundle.getInt(ConnectionType.EXTRA_USB_BAUD_RATE,ConnectionType.DEFAULT_USB_BAUD_RATE);
    mavlinkConn=new UsbConnection(context,baudRate);
  Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_BLUETOOTH:
final String bluetoothAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
mavlinkConn=new BluetoothConnection(context,bluetoothAddress);
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_TCP:
final String tcpServerIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
final int tcpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,ConnectionType.DEFAULT_TCP_SERVER_PORT);
mavlinkConn=new AndroidTcpConnection(context,tcpServerIp,tcpServerPort);
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_UDP:
final int udpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,ConnectionType.DEFAULT_UDP_SERVER_PORT);
mavlinkConn=new AndroidUdpConnection(context,udpServerPort);
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_SOLO:
{
Timber.i(""String_Node_Str"");
final String soloLinkId=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_ID,null);
final String linkPassword=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_PASSWORD,null);
mavlinkConn=new SoloConnection(context,soloLinkId,linkPassword);
break;
}
default :
Timber.e(""String_Node_Str"",connectionType);
return;
}
}
mavlinkConn.addMavLinkConnectionListener(tag,mConnectionListener);
if (connectionType == ConnectionType.TYPE_UDP) {
final String pingIpAddress=paramsBundle.getString(ConnectionType.EXTRA_UDP_PING_RECEIVER_IP);
if (!TextUtils.isEmpty(pingIpAddress)) {
try {
final InetAddress resolvedAddress=InetAddress.getByName(pingIpAddress);
final int pingPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_PING_RECEIVER_PORT);
final long pingPeriod=paramsBundle.getLong(ConnectionType.EXTRA_UDP_PING_PERIOD,ConnectionType.DEFAULT_UDP_PING_PERIOD);
final byte[] pingPayload=paramsBundle.getByteArray(ConnectionType.EXTRA_UDP_PING_PAYLOAD);
((AndroidUdpConnection)mavlinkConn).addPingTarget(resolvedAddress,pingPort,pingPeriod,pingPayload);
}
 catch (UnknownHostException e) {
Timber.e(e,""String_Node_Str"");
}
}
}
if (mavlinkConn.getConnectionStatus() == MavLinkConnection.MAVLINK_DISCONNECTED) {
mavlinkConn.connect();
GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
}
}","/** 
 * Setup a MAVLink connection based on the connection parameters.
 */
@Override public synchronized void openConnection(){
  if (isConnected() || isConnecting())   return;
  final String tag=toString();
  final int connectionType=connParams.getConnectionType();
  final Bundle paramsBundle=connParams.getParamsBundle();
  if (mavlinkConn == null) {
switch (connectionType) {
case ConnectionType.TYPE_USB:
      final int baudRate=paramsBundle.getInt(ConnectionType.EXTRA_USB_BAUD_RATE,ConnectionType.DEFAULT_USB_BAUD_RATE);
    mavlinkConn=new UsbConnection(context,baudRate);
  Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_BLUETOOTH:
final String bluetoothAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
mavlinkConn=new BluetoothConnection(context,bluetoothAddress);
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_TCP:
final String tcpServerIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
final int tcpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,ConnectionType.DEFAULT_TCP_SERVER_PORT);
mavlinkConn=new AndroidTcpConnection(context,tcpServerIp,tcpServerPort,new WifiConnectionHandler(context));
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_UDP:
final int udpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,ConnectionType.DEFAULT_UDP_SERVER_PORT);
mavlinkConn=new AndroidUdpConnection(context,udpServerPort,new WifiConnectionHandler(context));
Timber.i(""String_Node_Str"");
break;
case ConnectionType.TYPE_SOLO:
{
Timber.i(""String_Node_Str"");
final String soloLinkId=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_ID,null);
final String linkPassword=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_PASSWORD,null);
mavlinkConn=new SoloConnection(context,soloLinkId,linkPassword);
break;
}
default :
Timber.e(""String_Node_Str"",connectionType);
return;
}
}
mavlinkConn.addMavLinkConnectionListener(tag,mConnectionListener);
if (connectionType == ConnectionType.TYPE_UDP) {
final String pingIpAddress=paramsBundle.getString(ConnectionType.EXTRA_UDP_PING_RECEIVER_IP);
if (!TextUtils.isEmpty(pingIpAddress)) {
try {
final InetAddress resolvedAddress=InetAddress.getByName(pingIpAddress);
final int pingPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_PING_RECEIVER_PORT);
final long pingPeriod=paramsBundle.getLong(ConnectionType.EXTRA_UDP_PING_PERIOD,ConnectionType.DEFAULT_UDP_PING_PERIOD);
final byte[] pingPayload=paramsBundle.getByteArray(ConnectionType.EXTRA_UDP_PING_PAYLOAD);
((AndroidUdpConnection)mavlinkConn).addPingTarget(resolvedAddress,pingPort,pingPeriod,pingPayload);
}
 catch (UnknownHostException e) {
Timber.e(e,""String_Node_Str"");
}
}
}
if (mavlinkConn.getConnectionStatus() == MavLinkConnection.MAVLINK_DISCONNECTED) {
mavlinkConn.connect();
GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
}
}","The original code lacked proper connection handling for TCP and UDP connection types, missing critical WiFi connection handlers. The fixed code adds WifiConnectionHandler to AndroidTcpConnection and AndroidUdpConnection constructors, ensuring robust network connectivity and error handling for different connection scenarios. By introducing these connection handlers, the code now provides more reliable and flexible network communication mechanisms for MAVLink connections."
94677,"public void setCurrentHomeLocation(LatLongAlt currentHomeLocation){
  this.currentHomeLocation=currentHomeLocation;
}","public void setCurrentHomeLocation(LatLongAlt currentHomeLocation){
  this.currentHomeLocation=currentHomeLocation == null ? null : new LatLongAlt(currentHomeLocation);
}","The original code directly assigns the input parameter without creating a defensive copy, risking unexpected modifications to the stored home location through external references. The fixed code creates a new LatLongAlt object using a copy constructor when the input is not null, ensuring a deep copy and preventing unintended shared state. This approach protects the internal representation of the home location by creating an independent clone, thus maintaining data integrity and preventing potential side effects."
94678,"public void setOriginalHomeLocation(LatLongAlt originalHomeLocation){
  this.originalHomeLocation=originalHomeLocation;
}","public void setOriginalHomeLocation(LatLongAlt originalHomeLocation){
  this.originalHomeLocation=originalHomeLocation == null ? null : new LatLongAlt(originalHomeLocation);
}","The original code directly assigns the input parameter, which could lead to unintended modifications if the original object is changed after setting. The fixed code creates a new LatLongAlt instance using a copy constructor, ensuring a deep copy and preventing external changes from affecting the stored location. This approach provides better encapsulation and prevents potential side effects by creating an independent copy of the input location object."
94679,"public void disable(){
  if (isEnabled.compareAndSet(true,false)) {
    Timber.i(""String_Node_Str"");
    locationFinder.disableLocationUpdates();
    currentState.setCurrentHomeLocation(null);
    updateCurrentState(ReturnToMeState.STATE_IDLE);
    this.commandListener=null;
  }
}","public void disable(){
  if (isEnabled.compareAndSet(true,false)) {
    Timber.i(""String_Node_Str"");
    locationFinder.disableLocationUpdates();
    currentState.setCurrentHomeLocation(null);
    final LatLongAlt originalHomeLocation=currentState.getOriginalHomeLocation();
    if (originalHomeLocation != null) {
      MavLinkDoCmds.setVehicleHome(droneMgr.getDrone(),originalHomeLocation,new AbstractCommandListener(){
        @Override public void onSuccess(){
          Timber.i(""String_Node_Str"",originalHomeLocation.toString());
          droneMgr.getDrone().executeAsyncAction(requestHomeUpdateAction,null);
        }
        @Override public void onError(        int executionError){
          Timber.e(""String_Node_Str"",executionError);
        }
        @Override public void onTimeout(){
          Timber.w(""String_Node_Str"");
        }
      }
);
    }
    updateCurrentState(ReturnToMeState.STATE_IDLE);
    this.commandListener=null;
  }
}","The original code lacked proper handling of the home location reset when disabling a feature, potentially leaving the drone's home configuration in an undefined state. The fixed code adds a check to retrieve the original home location and uses MavLinkDoCmds to set it back, with error handling and logging for successful updates or failures. This improvement ensures a more robust state management by explicitly resetting the home location and providing comprehensive error tracking during the process."
94680,"/** 
 * Update the vehicle data stream rate.
 * @param rate          The new data stream rate
 * @param listener      Register a callback to receive update of the command execution state
 * @since 2.9.0
 */
public void updateVehicleDataStreamRate(int rate,final AbstractCommandListener listener){
  Bundle params=new Bundle();
  params.putInt(EXTRA_VEHICLE_DATA_STREAM_RATE,rate);
  drone.performAsyncActionOnDroneThread(new Action(ACTION_UPDATE_VEHICLE_DATA_STREAM_RATE,params),listener);
}","/** 
 * Update the vehicle data stream rate. Note: This is ineffective for Solo vehicles since their data stream rate is handled by the onboard companion computer.
 * @param rate          The new data stream rate
 * @param listener      Register a callback to receive update of the command execution state
 * @since 2.9.0
 */
public void updateVehicleDataStreamRate(int rate,final AbstractCommandListener listener){
  Bundle params=new Bundle();
  params.putInt(EXTRA_VEHICLE_DATA_STREAM_RATE,rate);
  drone.performAsyncActionOnDroneThread(new Action(ACTION_UPDATE_VEHICLE_DATA_STREAM_RATE,params),listener);
}","The original code lacked a critical documentation note about the ineffectiveness of data stream rate updates for Solo vehicles. The fixed code adds a comment explaining that the method is ineffective for Solo drones, as their data stream rate is managed by the onboard companion computer. This enhancement provides developers with important context about the method's limitations, improving code clarity and preventing potential misunderstandings about the function's behavior across different drone types."
94681,"@Override public void executeAction(Action action,ICommandListener listener) throws RemoteException {
  if (action == null) {
    return;
  }
  String type=action.getType();
  if (type == null) {
    return;
  }
  Bundle data=action.getData();
  if (data != null) {
    data.setClassLoader(context.getClassLoader());
  }
  Drone drone=getDrone();
switch (type) {
case ConnectionActions.ACTION_CONNECT:
    ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
  connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case CameraActions.ACTION_START_VIDEO_STREAM:
{
Surface videoSurface=data.getParcelable(CameraActions.EXTRA_VIDEO_DISPLAY);
String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
Bundle videoProps=data.getBundle(CameraActions.EXTRA_VIDEO_PROPERTIES);
if (videoProps == null) {
videoProps=new Bundle();
videoProps.putInt(CameraActions.EXTRA_VIDEO_PROPS_UDP_PORT,VideoManager.ARTOO_UDP_PORT);
}
CommonApiUtils.startVideoStream(drone,videoProps,ownerId,videoTag,videoSurface,listener);
break;
}
case CameraActions.ACTION_STOP_VIDEO_STREAM:
{
String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
CommonApiUtils.stopVideoStream(drone,ownerId,videoTag,listener);
break;
}
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
if (drone instanceof MavLinkDrone) {
CommonApiUtils.buildComplexMissionItem((MavLinkDrone)drone,data);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
}
break;
default :
if (droneMgr != null) {
droneMgr.executeAsyncAction(clientInfo,action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
break;
}
}","@Override public void executeAction(Action action,ICommandListener listener) throws RemoteException {
  if (action == null) {
    return;
  }
  String type=action.getType();
  if (type == null) {
    return;
  }
  Bundle data=action.getData();
  if (data != null) {
    data.setClassLoader(context.getClassLoader());
  }
  Drone drone=getDrone();
switch (type) {
case ConnectionActions.ACTION_CONNECT:
    ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
  connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case CameraActions.ACTION_START_VIDEO_STREAM:
{
Surface videoSurface=data.getParcelable(CameraActions.EXTRA_VIDEO_DISPLAY);
String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
Bundle videoProps=data.getBundle(CameraActions.EXTRA_VIDEO_PROPERTIES);
if (videoProps == null) {
videoProps=new Bundle();
videoProps.putInt(CameraActions.EXTRA_VIDEO_PROPS_UDP_PORT,VideoManager.ARTOO_UDP_PORT);
}
CommonApiUtils.startVideoStream(drone,videoProps,ownerId,videoTag,videoSurface,listener);
break;
}
case CameraActions.ACTION_STOP_VIDEO_STREAM:
{
String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
CommonApiUtils.stopVideoStream(drone,ownerId,videoTag,listener);
break;
}
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
if (drone instanceof MavLinkDrone || drone == null) {
CommonApiUtils.buildComplexMissionItem((MavLinkDrone)drone,data);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
}
break;
default :
if (droneMgr != null) {
droneMgr.executeAsyncAction(clientInfo,action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
break;
}
}","The original code lacked a null check for the drone when handling the ACTION_BUILD_COMPLEX_MISSION_ITEM case, which could potentially cause a null pointer exception. The fixed code adds a condition `drone instanceof MavLinkDrone || drone == null` to safely handle situations where the drone might be null. This modification improves error handling and prevents potential runtime crashes by gracefully managing edge cases when working with drone operations."
94682,"private void resetNetworkBindings(ConnectivityManager.NetworkCallback netCb){
  Timber.i(""String_Node_Str"");
  connectedSoloWifi.set(""String_Node_Str"");
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    try {
      connMgr.unregisterNetworkCallback(netCb);
    }
 catch (    IllegalArgumentException e) {
      Timber.w(e,""String_Node_Str"");
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
      connMgr.bindProcessToNetwork(null);
    }
 else {
      ConnectivityManager.setProcessDefaultNetwork(null);
    }
  }
}","@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void resetNetworkBindings(ConnectivityManager.NetworkCallback netCb){
  Timber.i(""String_Node_Str"");
  connectedSoloWifi.set(""String_Node_Str"");
  try {
    connMgr.unregisterNetworkCallback(netCb);
  }
 catch (  IllegalArgumentException e) {
    Timber.w(e,""String_Node_Str"");
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    connMgr.bindProcessToNetwork(null);
  }
 else {
    ConnectivityManager.setProcessDefaultNetwork(null);
  }
}","The original code unnecessarily nested the network callback unregistration within a version check, potentially preventing callback unregistration on some Android versions. The fixed code removes the version-specific condition, annotates the method with @TargetApi, and ensures network callback unregistration occurs for all applicable Android versions. This approach provides more consistent network management across different Android API levels, improving the method's reliability and error handling."
94683,"/** 
 * Stop the wifi connection handler process.
 */
public void stop(){
  try {
    this.context.unregisterReceiver(broadcastReceiver);
  }
 catch (  IllegalArgumentException e) {
    Timber.w(e,""String_Node_Str"");
  }
  resetNetworkBindings((ConnectivityManager.NetworkCallback)netReqCb);
}","/** 
 * Stop the wifi connection handler process.
 */
public void stop(){
  try {
    this.context.unregisterReceiver(broadcastReceiver);
  }
 catch (  IllegalArgumentException e) {
    Timber.w(e,""String_Node_Str"");
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    resetNetworkBindings((ConnectivityManager.NetworkCallback)netReqCb);
  }
}","The original code unconditionally calls resetNetworkBindings() without checking API compatibility, which could cause runtime exceptions on older Android versions. The fixed code adds a Build.VERSION.SDK_INT check to ensure the method is only called on Android Lollipop (API 21) and higher, preventing potential crashes. This version-aware approach ensures safer method invocation and improves the code's robustness across different Android SDK levels."
94684,"public MockMAVLinkClient(Context context,DataLink.DataLinkListener listener,ConnectionParameter connParams){
  super(context,listener,connParams);
}","public MockMAVLinkClient(Context context,DataLink.DataLinkListener listener,ConnectionParameter connParams){
  super(context,listener,connParams,null);
}","The original constructor was missing a required parameter when calling the superclass constructor, which could lead to a compilation error or unexpected behavior. The fixed code adds a `null` argument to complete the superclass constructor call, ensuring all required parameters are properly passed. This modification resolves potential initialization issues and allows the `MockMAVLinkClient` to be correctly instantiated with the necessary context, listener, and connection parameters."
94685,"protected SoloFollowOptionsV2(Parcel in){
  super(in);
  this.freeLook=in.readByte() != 0;
}","protected SoloFollowOptionsV2(Parcel in){
  super(in);
  this.freeLook=in.readByte() != FREE_LOOK_DISABLED_VALUE;
}","The original code compares the byte value directly to 0, which may not accurately represent the intended boolean state of `freeLook`. The fixed code introduces `FREE_LOOK_DISABLED_VALUE`, a more explicit constant that represents the specific value indicating a disabled free look mode. By using a named constant instead of a magic number, the code becomes more readable, self-documenting, and less prone to misinterpretation of the boolean conversion logic."
94686,"@Override public int hashCode(){
  int result=super.hashCode();
  result=31 * result + (freeLook ? 1 : 0);
  return result;
}","@Override public int hashCode(){
  int result=super.hashCode();
  result=31 * result + (freeLook ? FREE_LOOK_ENABLED_VALUE : FREE_LOOK_DISABLED_VALUE);
  return result;
}","The buggy code uses a primitive boolean value (1 or 0) in the hashCode calculation, which can lead to inconsistent hash distributions and potential hash collisions. The fixed code introduces specific constant values (FREE_LOOK_ENABLED_VALUE and FREE_LOOK_DISABLED_VALUE) to represent boolean states, providing more stable and predictable hash generation. By using meaningful constants, the new implementation ensures better hash distribution, improves object comparison reliability, and maintains the integrity of hash-based data structures."
94687,"@Override public void writeToParcel(Parcel dest,int flags){
  super.writeToParcel(dest,flags);
  dest.writeByte(freeLook ? (byte)1 : (byte)0);
}","@Override public void writeToParcel(Parcel dest,int flags){
  super.writeToParcel(dest,flags);
  dest.writeByte(freeLook ? (byte)FREE_LOOK_ENABLED_VALUE : (byte)FREE_LOOK_DISABLED_VALUE);
}","The original code hardcodes boolean conversion to 1 and 0 bytes, making the code less maintainable and prone to magic number errors. The fixed code introduces named constants FREE_LOOK_ENABLED_VALUE and FREE_LOOK_DISABLED_VALUE, which provide clear semantic meaning and make the byte conversion more explicit and self-documenting. By using meaningful constants, the code becomes more readable, easier to understand, and less likely to introduce unintended bugs during future modifications."
94688,"@Override public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
switch (action) {
case WifiManager.SCAN_RESULTS_AVAILABLE_ACTION:
    break;
case WifiManager.NETWORK_STATE_CHANGED_ACTION:
  NetworkInfo netInfo=intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
NetworkInfo.State networkState=netInfo == null ? NetworkInfo.State.DISCONNECTED : netInfo.getState();
switch (networkState) {
case CONNECTED:
final WifiInfo wifiInfo=intent.getParcelableExtra(WifiManager.EXTRA_WIFI_INFO);
final String wifiSSID=wifiInfo.getSSID();
Timber.i(""String_Node_Str"" + wifiSSID);
final DhcpInfo dhcpInfo=wifiMgr.getDhcpInfo();
if (dhcpInfo != null) {
Timber.i(""String_Node_Str"",dhcpInfo.toString());
}
 else {
Timber.w(""String_Node_Str"");
}
if (wifiSSID != null) {
final Runnable onConnection=onConnectionActions.get(wifiSSID);
if (wifiSSID.startsWith(""String_Node_Str"")) {
Timber.i(""String_Node_Str"");
if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
NetworkRequest netReq=new NetworkRequest.Builder().addCapability(NetworkCapabilities.NET_CAPABILITY_TRUSTED).addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
connMgr.requestNetwork(netReq,new ConnectivityManager.NetworkCallback(){
@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void getNetworkInfo(Network network){
if (network == null) {
  Timber.i(""String_Node_Str"");
}
 else {
  Timber.i(""String_Node_Str"",network,connMgr.isDefaultNetworkActive());
  LinkProperties linkProps=connMgr.getLinkProperties(network);
  Timber.i(""String_Node_Str"",linkProps.toString());
  Timber.i(""String_Node_Str"",connMgr.getNetworkCapabilities(network));
}
}
@TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onAvailable(Network network){
Timber.i(""String_Node_Str"",network);
getNetworkInfo(network);
final boolean wasBound;
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
  wasBound=connMgr.bindProcessToNetwork(network);
}
 else {
  wasBound=ConnectivityManager.setProcessDefaultNetwork(network);
}
if (wasBound) {
  Timber.i(""String_Node_Str"",network);
  if (onConnection != null) {
    onConnection.run();
  }
}
 else {
  Timber.w(""String_Node_Str"",network);
}
}
@Override public void onLosing(Network network,int maxMsToLive){
Timber.w(""String_Node_Str"",network);
}
@Override public void onLost(Network network){
Timber.w(""String_Node_Str"",network);
}
}
);
}
 else {
if (onConnection != null) {
onConnection.run();
}
}
}
 else {
if (onConnection != null) {
onConnection.run();
}
}
}
break;
case DISCONNECTED:
Timber.i(""String_Node_Str"");
refreshWifiAPs();
break;
case CONNECTING:
Timber.d(""String_Node_Str"");
break;
}
break;
case WifiManager.WIFI_STATE_CHANGED_ACTION:
refreshWifiAPs();
break;
}
}","@Override public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
switch (action) {
case WifiManager.SCAN_RESULTS_AVAILABLE_ACTION:
    break;
case WifiManager.NETWORK_STATE_CHANGED_ACTION:
  NetworkInfo netInfo=intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
NetworkInfo.State networkState=netInfo == null ? NetworkInfo.State.DISCONNECTED : netInfo.getState();
switch (networkState) {
case CONNECTED:
final WifiInfo wifiInfo=intent.getParcelableExtra(WifiManager.EXTRA_WIFI_INFO);
final String wifiSSID=wifiInfo.getSSID();
Timber.i(""String_Node_Str"" + wifiSSID);
final DhcpInfo dhcpInfo=wifiMgr.getDhcpInfo();
if (dhcpInfo != null) {
Timber.i(""String_Node_Str"",dhcpInfo.toString());
}
 else {
Timber.w(""String_Node_Str"");
}
if (wifiSSID != null) {
final Runnable onConnection=onConnectionActions.remove(wifiSSID);
if (wifiSSID.startsWith(""String_Node_Str"")) {
Timber.i(""String_Node_Str"");
if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
NetworkRequest netReq=new NetworkRequest.Builder().addCapability(NetworkCapabilities.NET_CAPABILITY_TRUSTED).addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
connMgr.requestNetwork(netReq,new ConnectivityManager.NetworkCallback(){
@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void getNetworkInfo(Network network){
if (network == null) {
  Timber.i(""String_Node_Str"");
}
 else {
  Timber.i(""String_Node_Str"",network,connMgr.isDefaultNetworkActive());
  LinkProperties linkProps=connMgr.getLinkProperties(network);
  Timber.i(""String_Node_Str"",linkProps.toString());
  Timber.i(""String_Node_Str"",connMgr.getNetworkCapabilities(network));
}
}
@TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onAvailable(Network network){
Timber.i(""String_Node_Str"",network);
getNetworkInfo(network);
final boolean wasBound;
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
  wasBound=connMgr.bindProcessToNetwork(network);
}
 else {
  wasBound=ConnectivityManager.setProcessDefaultNetwork(network);
}
if (wasBound) {
  Timber.i(""String_Node_Str"",network);
  if (onConnection != null) {
    onConnection.run();
  }
}
 else {
  Timber.w(""String_Node_Str"",network);
}
}
@Override public void onLosing(Network network,int maxMsToLive){
Timber.w(""String_Node_Str"",network);
}
@Override public void onLost(Network network){
Timber.w(""String_Node_Str"",network);
}
}
);
}
 else {
if (onConnection != null) {
onConnection.run();
}
}
}
 else {
if (onConnection != null) {
onConnection.run();
}
}
}
break;
case DISCONNECTED:
Timber.i(""String_Node_Str"");
refreshWifiAPs();
break;
case CONNECTING:
Timber.d(""String_Node_Str"");
break;
}
break;
case WifiManager.WIFI_STATE_CHANGED_ACTION:
refreshWifiAPs();
break;
}
}","The original code uses `get()` on `onConnectionActions`, which doesn't remove the entry after retrieval, potentially leading to repeated action execution. The fixed code replaces `get()` with `remove()`, ensuring the connection action is executed only once and then deleted from the map. This modification prevents potential memory leaks and guarantees that each network connection triggers its associated action exactly one time."
94689,"@TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onAvailable(Network network){
  final String currentWifi=getCurrentWifiLink();
  if (!isSoloWifi(currentWifi)) {
    Timber.i(""String_Node_Str"");
    connMgr.unregisterNetworkCallback(this);
    connectedSoloWifi.set(""String_Node_Str"");
    return;
  }
  Timber.i(""String_Node_Str"",network);
  getNetworkInfo(network);
  final boolean wasBound;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    wasBound=connMgr.bindProcessToNetwork(network);
  }
 else {
    wasBound=ConnectivityManager.setProcessDefaultNetwork(network);
  }
  if (wasBound) {
    Timber.i(""String_Node_Str"",network);
    notifyWifiConnected(currentWifi);
  }
 else {
    Timber.w(""String_Node_Str"",network);
  }
}","@TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onAvailable(Network network){
  final String currentWifi=getCurrentWifiLink();
  if (!isSoloWifi(currentWifi)) {
    resetNetworkBindings(this);
    return;
  }
  Timber.i(""String_Node_Str"",network);
  getNetworkInfo(network);
  final boolean wasBound;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    wasBound=connMgr.bindProcessToNetwork(network);
  }
 else {
    wasBound=ConnectivityManager.setProcessDefaultNetwork(network);
  }
  if (wasBound) {
    Timber.i(""String_Node_Str"",network);
    notifyWifiConnected(currentWifi);
  }
 else {
    Timber.w(""String_Node_Str"",network);
  }
}","The original code incorrectly sets a hardcoded string for `connectedSoloWifi` and manually unregisters the network callback, which can lead to unexpected behavior and resource leaks. The fixed code replaces these operations with a more robust `resetNetworkBindings(this)` method, which likely provides a cleaner and more comprehensive way to handle network callback cleanup. By centralizing the network reset logic, the fixed code improves resource management and provides a more maintainable approach to handling network availability changes."
94690,"public WifiConnectionHandler(Context context){
  this.context=context;
  this.wifiMgr=(WifiManager)this.context.getSystemService(Context.WIFI_SERVICE);
  this.connMgr=(ConnectivityManager)this.context.getSystemService(Context.CONNECTIVITY_SERVICE);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    netReq=new NetworkRequest.Builder().addCapability(NetworkCapabilities.NET_CAPABILITY_TRUSTED).addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    netReqCb=new ConnectivityManager.NetworkCallback(){
      @TargetApi(Build.VERSION_CODES.LOLLIPOP) private void getNetworkInfo(      Network network){
        if (network == null) {
          Timber.i(""String_Node_Str"");
        }
 else {
          Timber.i(""String_Node_Str"",network,connMgr.isDefaultNetworkActive());
          LinkProperties linkProps=connMgr.getLinkProperties(network);
          Timber.i(""String_Node_Str"",linkProps.toString());
          Timber.i(""String_Node_Str"",connMgr.getNetworkCapabilities(network));
        }
      }
      @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onAvailable(      Network network){
        final String currentWifi=getCurrentWifiLink();
        if (!isSoloWifi(currentWifi)) {
          Timber.i(""String_Node_Str"");
          connMgr.unregisterNetworkCallback(this);
          connectedSoloWifi.set(""String_Node_Str"");
          return;
        }
        Timber.i(""String_Node_Str"",network);
        getNetworkInfo(network);
        final boolean wasBound;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
          wasBound=connMgr.bindProcessToNetwork(network);
        }
 else {
          wasBound=ConnectivityManager.setProcessDefaultNetwork(network);
        }
        if (wasBound) {
          Timber.i(""String_Node_Str"",network);
          notifyWifiConnected(currentWifi);
        }
 else {
          Timber.w(""String_Node_Str"",network);
        }
      }
      @Override public void onLosing(      Network network,      int maxMsToLive){
        Timber.w(""String_Node_Str"",network);
      }
      @Override public void onLost(      Network network){
        Timber.w(""String_Node_Str"",network);
      }
    }
;
  }
 else {
    netReq=null;
    netReqCb=null;
  }
}","public WifiConnectionHandler(Context context){
  this.context=context;
  this.wifiMgr=(WifiManager)this.context.getSystemService(Context.WIFI_SERVICE);
  this.connMgr=(ConnectivityManager)this.context.getSystemService(Context.CONNECTIVITY_SERVICE);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    netReq=new NetworkRequest.Builder().addCapability(NetworkCapabilities.NET_CAPABILITY_TRUSTED).addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    netReqCb=new ConnectivityManager.NetworkCallback(){
      @TargetApi(Build.VERSION_CODES.LOLLIPOP) private void getNetworkInfo(      Network network){
        if (network == null) {
          Timber.i(""String_Node_Str"");
        }
 else {
          Timber.i(""String_Node_Str"",network,connMgr.isDefaultNetworkActive());
          LinkProperties linkProps=connMgr.getLinkProperties(network);
          Timber.i(""String_Node_Str"",linkProps.toString());
          Timber.i(""String_Node_Str"",connMgr.getNetworkCapabilities(network));
        }
      }
      @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onAvailable(      Network network){
        final String currentWifi=getCurrentWifiLink();
        if (!isSoloWifi(currentWifi)) {
          resetNetworkBindings(this);
          return;
        }
        Timber.i(""String_Node_Str"",network);
        getNetworkInfo(network);
        final boolean wasBound;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
          wasBound=connMgr.bindProcessToNetwork(network);
        }
 else {
          wasBound=ConnectivityManager.setProcessDefaultNetwork(network);
        }
        if (wasBound) {
          Timber.i(""String_Node_Str"",network);
          notifyWifiConnected(currentWifi);
        }
 else {
          Timber.w(""String_Node_Str"",network);
        }
      }
      @Override public void onLosing(      Network network,      int maxMsToLive){
        Timber.w(""String_Node_Str"",network);
      }
      @Override public void onLost(      Network network){
        Timber.w(""String_Node_Str"",network);
      }
    }
;
  }
 else {
    netReq=null;
    netReqCb=null;
  }
}","The buggy code had redundant network callback handling, potentially leaving network resources uncleared when encountering non-solo WiFi connections. The fixed code introduces a `resetNetworkBindings(this)` method (not shown) to properly unregister the network callback and clean up network resources when a non-solo WiFi is detected. This change ensures more robust network management and prevents potential resource leaks by explicitly handling network callback cleanup."
94691,"/** 
 * Stop the wifi connection handler process.
 */
public void stop(){
  try {
    this.context.unregisterReceiver(broadcastReceiver);
  }
 catch (  IllegalArgumentException e) {
    Timber.w(e,""String_Node_Str"");
  }
  try {
    connectedSoloWifi.set(""String_Node_Str"");
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      connMgr.unregisterNetworkCallback((ConnectivityManager.NetworkCallback)netReqCb);
    }
  }
 catch (  IllegalArgumentException e) {
    Timber.w(e,""String_Node_Str"");
  }
}","/** 
 * Stop the wifi connection handler process.
 */
public void stop(){
  try {
    this.context.unregisterReceiver(broadcastReceiver);
  }
 catch (  IllegalArgumentException e) {
    Timber.w(e,""String_Node_Str"");
  }
  resetNetworkBindings((ConnectivityManager.NetworkCallback)netReqCb);
}","The original code directly called unregisterNetworkCallback within a try-catch block, which could potentially lead to redundant or unsafe network callback management. The fixed code introduces a dedicated method `resetNetworkBindings()` to handle network callback unregistration, encapsulating the platform-specific logic and version checking. This approach provides a cleaner, more robust mechanism for stopping network-related processes, improving code maintainability and reducing the risk of runtime exceptions."
94692,"/** 
 * Setup a MAVLink connection using the given parameter.
 * @param connParams  Parameter used to setup the MAVLink connection.
 * @param listenerTag Used to identify the connection requester.
 * @param listener    Callback to receive the connection events.
 */
void connectMAVConnection(final ConnectionParameter connParams,final String listenerTag,final MavLinkConnectionListener listener){
  AndroidMavLinkConnection conn=mavConnections.get(connParams.getUniqueId());
  final int connectionType=connParams.getConnectionType();
  final Bundle paramsBundle=connParams.getParamsBundle();
  if (conn == null) {
switch (connectionType) {
case ConnectionType.TYPE_USB:
      final int baudRate=paramsBundle.getInt(ConnectionType.EXTRA_USB_BAUD_RATE,ConnectionType.DEFAULT_USB_BAUD_RATE);
    conn=new UsbConnection(getApplicationContext(),baudRate);
  Timber.d(""String_Node_Str"");
break;
case ConnectionType.TYPE_BLUETOOTH:
final String bluetoothAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
conn=new BluetoothConnection(getApplicationContext(),bluetoothAddress);
Timber.d(""String_Node_Str"");
break;
case ConnectionType.TYPE_TCP:
final String tcpServerIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
final int tcpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,ConnectionType.DEFAULT_TCP_SERVER_PORT);
conn=new AndroidTcpConnection(getApplicationContext(),tcpServerIp,tcpServerPort);
Timber.d(""String_Node_Str"");
break;
case ConnectionType.TYPE_UDP:
final int udpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,ConnectionType.DEFAULT_UDP_SERVER_PORT);
conn=new AndroidUdpConnection(getApplicationContext(),udpServerPort);
Timber.d(""String_Node_Str"");
break;
case ConnectionType.TYPE_SOLO:
{
final String soloLinkId=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_ID,null);
final String linkPassword=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_PASSWORD,null);
conn=new SoloConnection(getApplicationContext(),soloLinkId,linkPassword);
break;
}
default :
Timber.e(""String_Node_Str"",connectionType);
return;
}
mavConnections.put(connParams.getUniqueId(),conn);
}
if (connectionType == ConnectionType.TYPE_UDP) {
final String pingIpAddress=paramsBundle.getString(ConnectionType.EXTRA_UDP_PING_RECEIVER_IP);
if (!TextUtils.isEmpty(pingIpAddress)) {
try {
final InetAddress resolvedAddress=InetAddress.getByName(pingIpAddress);
final int pingPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_PING_RECEIVER_PORT);
final long pingPeriod=paramsBundle.getLong(ConnectionType.EXTRA_UDP_PING_PERIOD,ConnectionType.DEFAULT_UDP_PING_PERIOD);
final byte[] pingPayload=paramsBundle.getByteArray(ConnectionType.EXTRA_UDP_PING_PAYLOAD);
((AndroidUdpConnection)conn).addPingTarget(resolvedAddress,pingPort,pingPeriod,pingPayload);
}
 catch (UnknownHostException e) {
Timber.e(e,""String_Node_Str"");
}
}
}
conn.addMavLinkConnectionListener(listenerTag,listener);
if (conn.getConnectionStatus() == MavLinkConnection.MAVLINK_DISCONNECTED) {
conn.connect();
GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
}
}","/** 
 * Setup a MAVLink connection using the given parameter.
 * @param connParams  Parameter used to setup the MAVLink connection.
 * @param listenerTag Used to identify the connection requester.
 * @param listener    Callback to receive the connection events.
 */
void connectMAVConnection(final ConnectionParameter connParams,final String listenerTag,final MavLinkConnectionListener listener){
  AndroidMavLinkConnection conn=mavConnections.get(connParams.getUniqueId());
  final int connectionType=connParams.getConnectionType();
  final Bundle paramsBundle=connParams.getParamsBundle();
  if (conn == null) {
switch (connectionType) {
case ConnectionType.TYPE_USB:
      final int baudRate=paramsBundle.getInt(ConnectionType.EXTRA_USB_BAUD_RATE,ConnectionType.DEFAULT_USB_BAUD_RATE);
    conn=new UsbConnection(getApplicationContext(),baudRate);
  Timber.d(""String_Node_Str"");
break;
case ConnectionType.TYPE_BLUETOOTH:
final String bluetoothAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
conn=new BluetoothConnection(getApplicationContext(),bluetoothAddress);
Timber.d(""String_Node_Str"");
break;
case ConnectionType.TYPE_TCP:
final String tcpServerIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
final int tcpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,ConnectionType.DEFAULT_TCP_SERVER_PORT);
conn=new AndroidTcpConnection(getApplicationContext(),tcpServerIp,tcpServerPort);
Timber.d(""String_Node_Str"");
break;
case ConnectionType.TYPE_UDP:
final int udpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,ConnectionType.DEFAULT_UDP_SERVER_PORT);
conn=new AndroidUdpConnection(getApplicationContext(),udpServerPort);
Timber.d(""String_Node_Str"");
break;
case ConnectionType.TYPE_SOLO:
{
Timber.i(""String_Node_Str"");
final String soloLinkId=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_ID,null);
final String linkPassword=paramsBundle.getString(ConnectionType.EXTRA_SOLO_LINK_PASSWORD,null);
conn=new SoloConnection(getApplicationContext(),soloLinkId,linkPassword);
break;
}
default :
Timber.e(""String_Node_Str"",connectionType);
return;
}
mavConnections.put(connParams.getUniqueId(),conn);
}
if (connectionType == ConnectionType.TYPE_UDP) {
final String pingIpAddress=paramsBundle.getString(ConnectionType.EXTRA_UDP_PING_RECEIVER_IP);
if (!TextUtils.isEmpty(pingIpAddress)) {
try {
final InetAddress resolvedAddress=InetAddress.getByName(pingIpAddress);
final int pingPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_PING_RECEIVER_PORT);
final long pingPeriod=paramsBundle.getLong(ConnectionType.EXTRA_UDP_PING_PERIOD,ConnectionType.DEFAULT_UDP_PING_PERIOD);
final byte[] pingPayload=paramsBundle.getByteArray(ConnectionType.EXTRA_UDP_PING_PAYLOAD);
((AndroidUdpConnection)conn).addPingTarget(resolvedAddress,pingPort,pingPeriod,pingPayload);
}
 catch (UnknownHostException e) {
Timber.e(e,""String_Node_Str"");
}
}
}
conn.addMavLinkConnectionListener(listenerTag,listener);
if (conn.getConnectionStatus() == MavLinkConnection.MAVLINK_DISCONNECTED) {
conn.connect();
GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
}
}","The original code lacked logging for the Solo connection type, potentially missing important diagnostic information. The fixed code adds a Timber.i() log statement for the Solo connection case, providing better traceability and debugging capabilities. This improvement enhances code observability and helps developers understand the connection flow more effectively during runtime."
94693,"@TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onAvailable(Network network){
  Timber.i(""String_Node_Str"",network);
  getNetworkInfo(network);
  final boolean wasBound;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    wasBound=connMgr.bindProcessToNetwork(network);
  }
 else {
    wasBound=ConnectivityManager.setProcessDefaultNetwork(network);
  }
  if (wasBound) {
    Timber.i(""String_Node_Str"",network);
    notifyWifiConnected(trimmedSsid);
  }
 else {
    Timber.w(""String_Node_Str"",network);
  }
}","@TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onAvailable(Network network){
  final String currentWifi=getCurrentWifiLink();
  if (!isSoloWifi(currentWifi)) {
    Timber.i(""String_Node_Str"");
    connMgr.unregisterNetworkCallback(this);
    connectedSoloWifi.set(""String_Node_Str"");
    return;
  }
  Timber.i(""String_Node_Str"",network);
  getNetworkInfo(network);
  final boolean wasBound;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    wasBound=connMgr.bindProcessToNetwork(network);
  }
 else {
    wasBound=ConnectivityManager.setProcessDefaultNetwork(network);
  }
  if (wasBound) {
    Timber.i(""String_Node_Str"",network);
    notifyWifiConnected(currentWifi);
  }
 else {
    Timber.w(""String_Node_Str"",network);
  }
}","The original code lacked validation of the current WiFi connection before processing the network, potentially leading to unintended network binding. The fixed code adds a check using `getCurrentWifiLink()` and `isSoloWifi()` to ensure only the desired network is processed, with additional error handling and network callback unregistration. This improvement prevents incorrect network operations and provides more robust network connection management by conditionally proceeding only when the correct WiFi is detected."
94694,"private void setDefaultNetworkIfNecessary(String wifiSsid){
  final String trimmedSsid=trimWifiSsid(wifiSsid);
  if (isConnected(wifiSsid)) {
    notifyWifiConnected(wifiSsid);
    return;
  }
  if (isSoloWifi(trimmedSsid)) {
    Timber.i(""String_Node_Str"");
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
      NetworkRequest netReq=new NetworkRequest.Builder().addCapability(NetworkCapabilities.NET_CAPABILITY_TRUSTED).addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
      connMgr.requestNetwork(netReq,new ConnectivityManager.NetworkCallback(){
        @TargetApi(Build.VERSION_CODES.LOLLIPOP) private void getNetworkInfo(        Network network){
          if (network == null) {
            Timber.i(""String_Node_Str"");
          }
 else {
            Timber.i(""String_Node_Str"",network,connMgr.isDefaultNetworkActive());
            LinkProperties linkProps=connMgr.getLinkProperties(network);
            Timber.i(""String_Node_Str"",linkProps.toString());
            Timber.i(""String_Node_Str"",connMgr.getNetworkCapabilities(network));
          }
        }
        @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onAvailable(        Network network){
          Timber.i(""String_Node_Str"",network);
          getNetworkInfo(network);
          final boolean wasBound;
          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            wasBound=connMgr.bindProcessToNetwork(network);
          }
 else {
            wasBound=ConnectivityManager.setProcessDefaultNetwork(network);
          }
          if (wasBound) {
            Timber.i(""String_Node_Str"",network);
            notifyWifiConnected(trimmedSsid);
          }
 else {
            Timber.w(""String_Node_Str"",network);
          }
        }
        @Override public void onLosing(        Network network,        int maxMsToLive){
          Timber.w(""String_Node_Str"",network);
        }
        @Override public void onLost(        Network network){
          Timber.w(""String_Node_Str"",network);
        }
      }
);
    }
 else {
      notifyWifiConnected(trimmedSsid);
    }
  }
 else {
    notifyWifiConnected(trimmedSsid);
  }
}","private void setDefaultNetworkIfNecessary(String wifiSsid){
  final String trimmedSsid=trimWifiSsid(wifiSsid);
  if (isConnected(wifiSsid)) {
    notifyWifiConnected(wifiSsid);
    return;
  }
  if (isSoloWifi(trimmedSsid)) {
    Timber.i(""String_Node_Str"");
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
      if (!trimmedSsid.equals(connectedSoloWifi.get())) {
        connMgr.requestNetwork((NetworkRequest)netReq,(ConnectivityManager.NetworkCallback)netReqCb);
        connectedSoloWifi.set(trimmedSsid);
      }
    }
 else {
      notifyWifiConnected(trimmedSsid);
    }
  }
 else {
    notifyWifiConnected(trimmedSsid);
  }
}","The original code repeatedly requests network connections without checking if a specific solo WiFi network is already connected, potentially causing unnecessary network requests. The fixed code adds a check using `connectedSoloWifi.get()` to prevent redundant network requests for the same WiFi network. By tracking the currently connected solo WiFi and only requesting a network connection when needed, the fixed code reduces resource consumption and improves network management efficiency."
94695,"public WifiConnectionHandler(Context context){
  this.context=context;
  this.wifiMgr=(WifiManager)this.context.getSystemService(Context.WIFI_SERVICE);
  this.connMgr=(ConnectivityManager)this.context.getSystemService(Context.CONNECTIVITY_SERVICE);
}","public WifiConnectionHandler(Context context){
  this.context=context;
  this.wifiMgr=(WifiManager)this.context.getSystemService(Context.WIFI_SERVICE);
  this.connMgr=(ConnectivityManager)this.context.getSystemService(Context.CONNECTIVITY_SERVICE);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    netReq=new NetworkRequest.Builder().addCapability(NetworkCapabilities.NET_CAPABILITY_TRUSTED).addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED).addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN).addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    netReqCb=new ConnectivityManager.NetworkCallback(){
      @TargetApi(Build.VERSION_CODES.LOLLIPOP) private void getNetworkInfo(      Network network){
        if (network == null) {
          Timber.i(""String_Node_Str"");
        }
 else {
          Timber.i(""String_Node_Str"",network,connMgr.isDefaultNetworkActive());
          LinkProperties linkProps=connMgr.getLinkProperties(network);
          Timber.i(""String_Node_Str"",linkProps.toString());
          Timber.i(""String_Node_Str"",connMgr.getNetworkCapabilities(network));
        }
      }
      @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onAvailable(      Network network){
        final String currentWifi=getCurrentWifiLink();
        if (!isSoloWifi(currentWifi)) {
          Timber.i(""String_Node_Str"");
          connMgr.unregisterNetworkCallback(this);
          connectedSoloWifi.set(""String_Node_Str"");
          return;
        }
        Timber.i(""String_Node_Str"",network);
        getNetworkInfo(network);
        final boolean wasBound;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
          wasBound=connMgr.bindProcessToNetwork(network);
        }
 else {
          wasBound=ConnectivityManager.setProcessDefaultNetwork(network);
        }
        if (wasBound) {
          Timber.i(""String_Node_Str"",network);
          notifyWifiConnected(currentWifi);
        }
 else {
          Timber.w(""String_Node_Str"",network);
        }
      }
      @Override public void onLosing(      Network network,      int maxMsToLive){
        Timber.w(""String_Node_Str"",network);
      }
      @Override public void onLost(      Network network){
        Timber.w(""String_Node_Str"",network);
      }
    }
;
  }
 else {
    netReq=null;
    netReqCb=null;
  }
}","The original code lacked proper network handling for newer Android versions, missing critical network callback and request setup. The fixed code adds a NetworkRequest and NetworkCallback for Lollipop and above, enabling more robust WiFi connection management with version-specific network binding and detailed network information retrieval. This improvement provides better network state tracking, allows dynamic network binding, and ensures compatibility across different Android SDK versions."
94696,"/** 
 * Stop the wifi connection handler process.
 */
public void stop(){
  try {
    this.context.unregisterReceiver(broadcastReceiver);
  }
 catch (  IllegalArgumentException e) {
    Timber.d(""String_Node_Str"",e);
  }
}","/** 
 * Stop the wifi connection handler process.
 */
public void stop(){
  try {
    this.context.unregisterReceiver(broadcastReceiver);
  }
 catch (  IllegalArgumentException e) {
    Timber.w(e,""String_Node_Str"");
  }
  try {
    connectedSoloWifi.set(""String_Node_Str"");
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      connMgr.unregisterNetworkCallback((ConnectivityManager.NetworkCallback)netReqCb);
    }
  }
 catch (  IllegalArgumentException e) {
    Timber.w(e,""String_Node_Str"");
  }
}","The original code only handled unregistering the broadcast receiver, potentially leaving network callbacks unmanaged. The fixed code adds a second try-catch block to unregister network callbacks for newer Android versions, using Timber.w() for more informative logging and handling potential exceptions. This improvement ensures cleaner resource management and prevents potential memory leaks by properly stopping all network-related processes."
94697,"@Override public void destroy(){
  events.removeAllDroneListeners();
  ParameterManager parameterManager=getParameterManager();
  if (parameterManager != null)   parameterManager.setParameterListener(null);
  MagnetometerCalibrationImpl magnetometer=getMagnetometerCalibration();
  if (magnetometer != null)   magnetometer.setListener(null);
}","@Override public void destroy(){
  ParameterManager parameterManager=getParameterManager();
  if (parameterManager != null)   parameterManager.setParameterListener(null);
  MagnetometerCalibrationImpl magnetometer=getMagnetometerCalibration();
  if (magnetometer != null)   magnetometer.setListener(null);
}","The original code calls `events.removeAllDroneListeners()` before clearing listener references, which could potentially cause unexpected behavior or memory leaks. The fixed code removes the `events.removeAllDroneListeners()` line, focusing on directly nullifying specific listener references for `ParameterManager` and `MagnetometerCalibrationImpl`. By eliminating the unnecessary listener removal method, the fixed code provides a clearer and more targeted approach to listener management during object destruction."
94698,"private boolean processNALUChunk(NALUChunk naluChunk){
  if (naluChunk == null)   return false;
  final MediaCodec mediaCodec=mediaCodecRef.get();
  if (mediaCodec == null)   return false;
  try {
    final int index=mediaCodec.dequeueInputBuffer(-1);
    if (index >= 0) {
      ByteBuffer inputBuffer;
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        inputBuffer=mediaCodec.getInputBuffer(index);
      }
 else {
        inputBuffer=mediaCodec.getInputBuffers()[index];
      }
      if (inputBuffer == null)       return false;
      inputBuffer.clear();
      int totalLength=0;
      int payloadCount=naluChunk.payloads.length;
      for (int i=0; i < payloadCount; i++) {
        ByteBuffer payload=naluChunk.payloads[i];
        if (payload.capacity() == 0)         continue;
        inputBuffer.order(payload.order());
        final int dataLength=payload.position();
        byte[] payloadData=payload.array();
        inputBuffer.put(payloadData,0,dataLength);
        totalLength+=dataLength;
        streamRecorder.onNaluChunkUpdated(payloadData,0,dataLength);
      }
      mediaCodec.queueInputBuffer(index,0,totalLength,naluChunk.presentationTime,naluChunk.flags);
    }
  }
 catch (  IllegalStateException e) {
    Log.e(TAG,e.getMessage(),e);
    return false;
  }
  return true;
}","private boolean processNALUChunk(NALUChunk naluChunk){
  if (naluChunk == null)   return false;
  final MediaCodec mediaCodec=mediaCodecRef.get();
  if (mediaCodec == null)   return false;
  try {
    final int index=mediaCodec.dequeueInputBuffer(-1);
    if (index >= 0) {
      ByteBuffer inputBuffer;
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        inputBuffer=mediaCodec.getInputBuffer(index);
      }
 else {
        inputBuffer=mediaCodec.getInputBuffers()[index];
      }
      if (inputBuffer == null)       return false;
      inputBuffer.clear();
      int totalLength=0;
      int payloadCount=naluChunk.payloads.length;
      for (int i=0; i < payloadCount; i++) {
        ByteBuffer payload=naluChunk.payloads[i];
        if (payload.capacity() == 0)         continue;
        inputBuffer.order(payload.order());
        final int dataLength=payload.position();
        byte[] payloadData=payload.array();
        inputBuffer.put(payloadData,0,dataLength);
        totalLength+=dataLength;
      }
      streamRecorder.onNaluChunkUpdated(naluChunkAssembler.getParametersSet(),naluChunk);
      mediaCodec.queueInputBuffer(index,0,totalLength,naluChunk.presentationTime,naluChunk.flags);
    }
  }
 catch (  IllegalStateException e) {
    Log.e(TAG,e.getMessage(),e);
    return false;
  }
  return true;
}","The original code incorrectly called `streamRecorder.onNaluChunkUpdated()` inside the payload loop, repeatedly processing individual payload data. The fixed code moves this call outside the loop and uses `naluChunkAssembler.getParametersSet()` to pass comprehensive parameter information, along with the entire `naluChunk`. This modification ensures more efficient and accurate processing of NALU chunks by avoiding redundant method calls and providing a more holistic approach to stream recording."
94699,"boolean disableRecording(){
  if (isRecordingEnabled()) {
    Timber.i(""String_Node_Str"");
    if (h264Writer != null) {
      try {
        h264Writer.close();
      }
 catch (      IOException e) {
        Timber.e(e,e.getMessage());
      }
 finally {
        h264Writer=null;
        convertToMp4(recordingFilename.get());
        recordingFilename.set(null);
      }
    }
  }
  return true;
}","boolean disableRecording(){
  if (isRecordingEnabled()) {
    Timber.i(""String_Node_Str"");
    if (h264Writer != null) {
      try {
        h264Writer.close();
      }
 catch (      IOException e) {
        Timber.e(e,e.getMessage());
      }
 finally {
        h264Writer=null;
        convertToMp4(recordingFilename.get());
        recordingFilename.set(null);
      }
    }
  }
  areParametersSet.set(false);
  return true;
}","The original code lacked a crucial state reset mechanism after disabling recording. The fixed code adds `areParametersSet.set(false)`, explicitly marking the recording parameters as unset after conversion, ensuring a clean state transition. This change prevents potential inconsistencies in subsequent recording attempts by properly resetting the system's internal recording configuration flag."
94700,"void onNaluChunkUpdated(byte[] payload,int index,int payloadLength){
  if (isRecordingEnabled() && h264Writer != null) {
    try {
      h264Writer.write(payload,index,payloadLength);
    }
 catch (    IOException e) {
      Timber.e(e,e.getMessage());
    }
  }
}","void onNaluChunkUpdated(NALUChunk parametersSet,NALUChunk dataChunk){
  if (isRecordingEnabled() && h264Writer != null) {
    if (areParametersSet.get()) {
      try {
        writeNaluChunk(h264Writer,dataChunk);
      }
 catch (      IOException e) {
        Timber.e(e,e.getMessage());
      }
    }
 else {
      try {
        areParametersSet.set(writeNaluChunk(h264Writer,parametersSet));
      }
 catch (      IOException e) {
        Timber.e(e,e.getMessage());
      }
    }
  }
}","The original code lacks proper handling of H.264 video stream initialization, potentially writing video data before parameter sets are established. The fixed code introduces a state management mechanism using `areParametersSet` to ensure parameter sets are written before video data, with separate handling for parameter and data chunks. This approach guarantees correct video stream encoding by sequentially writing parameter sets and video data, preventing potential corruption or incomplete video streams."
94701,"boolean enableRecording(String mediaFilename){
  if (!isRecordingEnabled()) {
    recordingFilename.set(mediaFilename);
    Timber.i(""String_Node_Str"",mediaFilename);
    File h264File=new File(mediaRootDir,mediaFilename);
    if (h264File.exists())     h264File.delete();
    try {
      h264Writer=new BufferedOutputStream(new FileOutputStream(h264File));
      return true;
    }
 catch (    FileNotFoundException e) {
      Timber.e(e,e.getMessage());
      recordingFilename.set(null);
      return false;
    }
  }
 else {
    Timber.w(""String_Node_Str"");
    return false;
  }
}","boolean enableRecording(String mediaFilename){
  if (!isRecordingEnabled()) {
    areParametersSet.set(false);
    recordingFilename.set(mediaFilename);
    Timber.i(""String_Node_Str"",mediaFilename);
    File h264File=new File(mediaRootDir,mediaFilename);
    if (h264File.exists())     h264File.delete();
    try {
      h264Writer=new BufferedOutputStream(new FileOutputStream(h264File));
      return true;
    }
 catch (    FileNotFoundException e) {
      Timber.e(e,e.getMessage());
      recordingFilename.set(null);
      return false;
    }
  }
 else {
    Timber.w(""String_Node_Str"");
    return false;
  }
}","The original code lacks proper recording state management, potentially leading to inconsistent recording initialization. The fixed code introduces `areParametersSet.set(false)`, explicitly resetting the recording state before starting a new recording, ensuring clean and predictable initialization. This change enhances the method's reliability by preventing potential state conflicts and providing a clearer mechanism for tracking recording readiness."
94702,"public boolean executeAsyncAction(DroneApi.ClientInfo clientInfo,Action action,ICommandListener listener){
  String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    float bearing=CommonApiUtils.generateDronie(drone);
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyDroneAttributeEvent(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
return true;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
CommonApiUtils.enableFollowMe(this,handler,followType,listener);
return true;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (followMe != null) {
data.setClassLoader(LatLong.class.getClassLoader());
FollowAlgorithm followAlgorithm=followMe.getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
return true;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
CommonApiUtils.disableFollowMe(followMe);
return true;
case StateActions.ACTION_ENABLE_RETURN_TO_ME:
boolean isEnabled=data.getBoolean(StateActions.EXTRA_IS_RETURN_TO_ME_ENABLED,false);
if (returnToMe != null) {
if (isEnabled) {
returnToMe.enable(listener);
}
 else {
returnToMe.disable();
}
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
return true;
case CapabilityActions.ACTION_CHECK_FEATURE_SUPPORT:
if (listener != null) {
String featureId=data.getString(CapabilityActions.EXTRA_FEATURE_ID);
if (!TextUtils.isEmpty(featureId)) {
switch (featureId) {
case CapabilityApi.FeatureIds.SOLO_VIDEO_STREAMING:
case CapabilityApi.FeatureIds.COMPASS_CALIBRATION:
if (this.isCompanionComputerEnabled()) {
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
}
break;
case CapabilityApi.FeatureIds.KILL_SWITCH:
if (CommonApiUtils.isKillSwitchSupported(drone)) {
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
}
break;
default :
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
break;
}
}
}
return true;
case ControlActions.ACTION_ENABLE_MANUAL_CONTROL:
if (drone != null) {
action.getData().putString(EXTRA_CLIENT_APP_ID,clientInfo.appId);
drone.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
return true;
default :
if (drone != null) {
return drone.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
return true;
}
}
}","public boolean executeAsyncAction(DroneApi.ClientInfo clientInfo,Action action,ICommandListener listener){
  String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    float bearing=CommonApiUtils.generateDronie(drone);
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyDroneAttributeEvent(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
return true;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
CommonApiUtils.enableFollowMe(this,handler,followType,listener);
return true;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (followMe != null) {
data.setClassLoader(LatLong.class.getClassLoader());
FollowAlgorithm followAlgorithm=followMe.getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
return true;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
CommonApiUtils.disableFollowMe(followMe);
return true;
case StateActions.ACTION_ENABLE_RETURN_TO_ME:
boolean isEnabled=data.getBoolean(StateActions.EXTRA_IS_RETURN_TO_ME_ENABLED,false);
if (returnToMe != null) {
if (isEnabled) {
returnToMe.enable(listener);
}
 else {
returnToMe.disable();
}
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
return true;
case ControlActions.ACTION_ENABLE_MANUAL_CONTROL:
if (drone != null) {
action.getData().putString(EXTRA_CLIENT_APP_ID,clientInfo.appId);
drone.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
return true;
default :
if (drone != null) {
return drone.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
return true;
}
}
}","The original code contained a potentially vulnerable capability checking section that could expose system features inappropriately. The fixed code removes the capability checking case block, ensuring that only essential and validated action types are processed through the method. This simplification reduces potential security risks and streamlines the action execution logic by delegating unrecognized actions directly to the drone's default action handler."
94703,"@Override public boolean executeAsyncAction(Action action,ICommandListener listener){
  String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GOTO_WAYPOINT:
    int missionItemIndex=data.getInt(MissionActions.EXTRA_MISSION_ITEM_INDEX);
  CommonApiUtils.gotoWaypoint(this,missionItemIndex,listener);
return true;
case StateActions.ACTION_ARM:
return performArming(data,listener);
case StateActions.ACTION_SET_VEHICLE_MODE:
return setVehicleMode(data,listener);
case ControlActions.ACTION_DO_GUIDED_TAKEOFF:
return performTakeoff(data,listener);
case ControlActions.ACTION_SET_CONDITION_YAW:
float turnSpeed=2;
ParameterManager parameterManager=getParameterManager();
if (parameterManager != null) {
Parameter turnSpeedParam=parameterManager.getParameter(""String_Node_Str"");
if (turnSpeedParam != null) {
turnSpeed=(float)turnSpeedParam.getValue();
}
}
float targetAngle=data.getFloat(ControlActions.EXTRA_YAW_TARGET_ANGLE);
float yawRate=data.getFloat(ControlActions.EXTRA_YAW_CHANGE_RATE);
boolean isClockwise=yawRate >= 0;
boolean isRelative=data.getBoolean(ControlActions.EXTRA_YAW_IS_RELATIVE);
MavLinkCommands.setConditionYaw(this,targetAngle,Math.abs(yawRate) * turnSpeed,isClockwise,isRelative,listener);
return true;
case ControlActions.ACTION_SET_VELOCITY:
return setVelocity(data,listener);
case ControlActions.ACTION_ENABLE_MANUAL_CONTROL:
return enableManualControl(data,listener);
case ExperimentalActions.ACTION_SEND_MAVLINK_MESSAGE:
data.setClassLoader(MavlinkMessageWrapper.class.getClassLoader());
MavlinkMessageWrapper messageWrapper=data.getParcelable(ExperimentalActions.EXTRA_MAVLINK_MESSAGE);
CommonApiUtils.sendMavlinkMessage(this,messageWrapper);
return true;
case ACTION_REQUEST_HOME_UPDATE:
requestHomeUpdate();
return true;
default :
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
return true;
}
}","@Override public boolean executeAsyncAction(Action action,ICommandListener listener){
  String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GOTO_WAYPOINT:
    int missionItemIndex=data.getInt(MissionActions.EXTRA_MISSION_ITEM_INDEX);
  CommonApiUtils.gotoWaypoint(this,missionItemIndex,listener);
return true;
case StateActions.ACTION_ARM:
return performArming(data,listener);
case StateActions.ACTION_SET_VEHICLE_MODE:
return setVehicleMode(data,listener);
case ControlActions.ACTION_DO_GUIDED_TAKEOFF:
return performTakeoff(data,listener);
case ControlActions.ACTION_SET_CONDITION_YAW:
float turnSpeed=2;
ParameterManager parameterManager=getParameterManager();
if (parameterManager != null) {
Parameter turnSpeedParam=parameterManager.getParameter(""String_Node_Str"");
if (turnSpeedParam != null) {
turnSpeed=(float)turnSpeedParam.getValue();
}
}
float targetAngle=data.getFloat(ControlActions.EXTRA_YAW_TARGET_ANGLE);
float yawRate=data.getFloat(ControlActions.EXTRA_YAW_CHANGE_RATE);
boolean isClockwise=yawRate >= 0;
boolean isRelative=data.getBoolean(ControlActions.EXTRA_YAW_IS_RELATIVE);
MavLinkCommands.setConditionYaw(this,targetAngle,Math.abs(yawRate) * turnSpeed,isClockwise,isRelative,listener);
return true;
case ControlActions.ACTION_SET_VELOCITY:
return setVelocity(data,listener);
case ControlActions.ACTION_ENABLE_MANUAL_CONTROL:
return enableManualControl(data,listener);
case ExperimentalActions.ACTION_SEND_MAVLINK_MESSAGE:
data.setClassLoader(MavlinkMessageWrapper.class.getClassLoader());
MavlinkMessageWrapper messageWrapper=data.getParcelable(ExperimentalActions.EXTRA_MAVLINK_MESSAGE);
CommonApiUtils.sendMavlinkMessage(this,messageWrapper);
return true;
case ACTION_REQUEST_HOME_UPDATE:
requestHomeUpdate();
return true;
case CapabilityActions.ACTION_CHECK_FEATURE_SUPPORT:
return checkFeatureSupport(data,listener);
default :
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
return true;
}
}","The original code lacked support for the `CapabilityActions.ACTION_CHECK_FEATURE_SUPPORT` action in the switch statement, which would cause unhandled actions to trigger the default error case. The fixed code adds a new case for `ACTION_CHECK_FEATURE_SUPPORT` with a corresponding `checkFeatureSupport()` method call, ensuring proper handling of this specific action type. This improvement provides more comprehensive action processing and prevents potential error events for supported feature checks."
94704,"StreamRecorder(Context context){
  this.mediaRootDir=new File(context.getExternalFilesDir(Environment.DIRECTORY_MOVIES),""String_Node_Str"");
  if (!this.mediaRootDir.exists()) {
    this.mediaRootDir.mkdirs();
  }
  this.mediaScanner=new MediaScannerConnection(context,new MediaScannerConnection.MediaScannerConnectionClient(){
    @Override public void onMediaScannerConnected(){
    }
    @Override public void onScanCompleted(    String path,    Uri uri){
      Timber.i(""String_Node_Str"",path,uri);
    }
  }
);
}","StreamRecorder(Context context){
  this.context=context;
  this.mediaRootDir=new File(context.getExternalFilesDir(Environment.DIRECTORY_MOVIES),""String_Node_Str"");
  if (!this.mediaRootDir.exists()) {
    this.mediaRootDir.mkdirs();
  }
}","The buggy code improperly initializes a MediaScannerConnection without connecting or using it, which could lead to resource leaks and unnecessary complexity. The fixed code removes the unnecessary MediaScannerConnection initialization and adds a context variable, simplifying the constructor and preventing potential memory management issues. By eliminating the unused MediaScanner setup, the code becomes more streamlined, focused, and less prone to unexpected behaviors."
94705,"@Override public void run(){
  Timber.i(""String_Node_Str"");
  Timber.i(""String_Node_Str"",filename);
  if (TextUtils.isEmpty(filename)) {
    Timber.w(""String_Node_Str"");
    return;
  }
  File rawMedia=new File(mediaRootDir,filename);
  if (!rawMedia.exists()) {
    Timber.w(""String_Node_Str"");
    return;
  }
  try {
    H264TrackImpl h264Track=new H264TrackImpl(new FileDataSourceImpl(rawMedia));
    Movie movie=new Movie();
    movie.addTrack(h264Track);
    Container mp4File=new DefaultMp4Builder().build(movie);
    File dstDir=Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES);
    File mp4Media=new File(dstDir,filename + ""String_Node_Str"");
    Timber.i(""String_Node_Str"",mp4Media.getAbsolutePath());
    FileChannel fc=new FileOutputStream(mp4Media).getChannel();
    mp4File.writeContainer(fc);
    fc.close();
    Timber.i(""String_Node_Str"");
    rawMedia.delete();
    Timber.i(""String_Node_Str"");
    mediaScanner.scanFile(mp4Media.getAbsolutePath(),null);
  }
 catch (  IOException e) {
    Timber.e(e,e.getMessage());
  }
}","@Override public void run(){
  Timber.i(""String_Node_Str"",filename);
  try {
    H264TrackImpl h264Track=new H264TrackImpl(new FileDataSourceImpl(rawMedia));
    Movie movie=new Movie();
    movie.addTrack(h264Track);
    Container mp4File=new DefaultMp4Builder().build(movie);
    File dstDir=Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES);
    File mp4Media=new File(dstDir,filename + ""String_Node_Str"");
    Timber.i(""String_Node_Str"",mp4Media.getAbsolutePath());
    FileChannel fc=new FileOutputStream(mp4Media).getChannel();
    mp4File.writeContainer(fc);
    fc.close();
    Timber.i(""String_Node_Str"");
    rawMedia.delete();
    Timber.i(""String_Node_Str"");
    MediaScannerConnection.scanFile(context,new String[]{mp4Media.getAbsolutePath()},null,scanCompletedListener);
  }
 catch (  IOException e) {
    Timber.e(e,e.getMessage());
  }
}","The original code lacks proper null and file existence checks, potentially leading to null pointer exceptions and attempting to process non-existent files. The fixed code introduces robust validation by removing redundant logging, ensuring filename and file existence are confirmed before processing, and replacing the custom media scanning with the standard MediaScannerConnection method. These changes enhance error handling, improve code reliability, and provide a more standardized approach to media file scanning and processing."
94706,"void convertToMp4(final String filename){
  asyncExecutor.execute(new Runnable(){
    @Override public void run(){
      Timber.i(""String_Node_Str"");
      Timber.i(""String_Node_Str"",filename);
      if (TextUtils.isEmpty(filename)) {
        Timber.w(""String_Node_Str"");
        return;
      }
      File rawMedia=new File(mediaRootDir,filename);
      if (!rawMedia.exists()) {
        Timber.w(""String_Node_Str"");
        return;
      }
      try {
        H264TrackImpl h264Track=new H264TrackImpl(new FileDataSourceImpl(rawMedia));
        Movie movie=new Movie();
        movie.addTrack(h264Track);
        Container mp4File=new DefaultMp4Builder().build(movie);
        File dstDir=Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES);
        File mp4Media=new File(dstDir,filename + ""String_Node_Str"");
        Timber.i(""String_Node_Str"",mp4Media.getAbsolutePath());
        FileChannel fc=new FileOutputStream(mp4Media).getChannel();
        mp4File.writeContainer(fc);
        fc.close();
        Timber.i(""String_Node_Str"");
        rawMedia.delete();
        Timber.i(""String_Node_Str"");
        mediaScanner.scanFile(mp4Media.getAbsolutePath(),null);
      }
 catch (      IOException e) {
        Timber.e(e,e.getMessage());
      }
    }
  }
);
}","void convertToMp4(final String filename){
  if (TextUtils.isEmpty(filename)) {
    Timber.w(""String_Node_Str"");
    return;
  }
  final File rawMedia=new File(mediaRootDir,filename);
  if (!rawMedia.exists()) {
    Timber.w(""String_Node_Str"");
    return;
  }
  asyncExecutor.execute(new Runnable(){
    @Override public void run(){
      Timber.i(""String_Node_Str"",filename);
      try {
        H264TrackImpl h264Track=new H264TrackImpl(new FileDataSourceImpl(rawMedia));
        Movie movie=new Movie();
        movie.addTrack(h264Track);
        Container mp4File=new DefaultMp4Builder().build(movie);
        File dstDir=Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES);
        File mp4Media=new File(dstDir,filename + ""String_Node_Str"");
        Timber.i(""String_Node_Str"",mp4Media.getAbsolutePath());
        FileChannel fc=new FileOutputStream(mp4Media).getChannel();
        mp4File.writeContainer(fc);
        fc.close();
        Timber.i(""String_Node_Str"");
        rawMedia.delete();
        Timber.i(""String_Node_Str"");
        MediaScannerConnection.scanFile(context,new String[]{mp4Media.getAbsolutePath()},null,scanCompletedListener);
      }
 catch (      IOException e) {
        Timber.e(e,e.getMessage());
      }
    }
  }
);
}","The original code had potential file access and threading issues by performing file existence checks inside the async task and using an unclear media scanning method. The fixed code moves file validation before async execution, uses a more reliable MediaScannerConnection for file scanning, and ensures proper error handling and resource management. These changes improve code reliability, reduce potential race conditions, and provide more robust file conversion and scanning processes."
94707,"private void startVideoStream(Surface videoSurface){
  SoloCameraApi.getApi(drone).startVideoStream(videoSurface,new AbstractCommandListener(){
    @Override public void onSuccess(){
      if (stopVideoStream != null)       stopVideoStream.setEnabled(true);
      if (startVideoStream != null)       startVideoStream.setEnabled(false);
    }
    @Override public void onError(    int executionError){
      alertUser(""String_Node_Str"" + executionError);
    }
    @Override public void onTimeout(){
      alertUser(""String_Node_Str"");
    }
  }
);
}","private void startVideoStream(Surface videoSurface){
  SoloCameraApi.getApi(drone).startVideoStream(videoSurface,""String_Node_Str"",true,new AbstractCommandListener(){
    @Override public void onSuccess(){
      if (stopVideoStream != null)       stopVideoStream.setEnabled(true);
      if (startVideoStream != null)       startVideoStream.setEnabled(false);
    }
    @Override public void onError(    int executionError){
      alertUser(""String_Node_Str"" + executionError);
    }
    @Override public void onTimeout(){
      alertUser(""String_Node_Str"");
    }
  }
);
}","The original code was missing a required parameter when calling startVideoStream, which could lead to method invocation errors. The fixed code adds a string parameter (""String_Node_Str"") and a boolean flag, likely specifying additional configuration or stream settings for the video stream. This correction ensures proper method signature compliance and potentially provides more robust video stream initialization with explicit configuration parameters."
94708,"@Before public void setUp() throws Exception {
  final Context context=Robolectric.getShadowApplication().getApplicationContext();
  ConnectionParameter connParams=new ConnectionParameter(0,new Bundle(),null);
  mavlinkApi=new MockMavLinkServiceAPI();
  DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
  MAVLinkClient mavClient=new MAVLinkClient(context,inputStreamListener,connParams,mavlinkApi);
  drone=new ArduCopter(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),new LogMessageListener(){
    @Override public void onMessageLogged(    int logLevel,    String message){
    }
  }
,new DroneInterfaces.AttributeEventListener(){
    @Override public void onAttributeEvent(    String attributeEvent,    Bundle eventInfo,    boolean checkForSololinkApi){
    }
  }
);
}","@Before public void setUp() throws Exception {
  final Context context=Robolectric.getShadowApplication().getApplicationContext();
  ConnectionParameter connParams=new ConnectionParameter(0,new Bundle(),null);
  mavlinkApi=new MockMavLinkServiceAPI();
  DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
  MAVLinkClient mavClient=new MAVLinkClient(context,inputStreamListener,connParams,mavlinkApi);
  drone=new ArduCopter(context,mavClient,dpHandler,new AndroidApWarningParser(),new LogMessageListener(){
    @Override public void onMessageLogged(    int logLevel,    String message){
    }
  }
,new DroneInterfaces.AttributeEventListener(){
    @Override public void onAttributeEvent(    String attributeEvent,    Bundle eventInfo,    boolean checkForSololinkApi){
    }
  }
);
}","The original code incorrectly passed `dpPrefs` as an extra parameter when creating the ArduCopter drone, leading to a potential method signature mismatch. The fixed code removes `dpPrefs` from the constructor call, ensuring it matches the expected method signature for the ArduCopter initialization. This correction prevents potential compilation errors and ensures the drone object is created with the correct set of parameters, maintaining the intended functionality of the setup method."
94709,"@Before public void setUp() throws Exception {
  final Context context=Robolectric.getShadowApplication().getApplicationContext();
  ConnectionParameter connParams=new ConnectionParameter(0,new Bundle(),null);
  mavlinkApi=new MockMavLinkServiceAPI();
  DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
  MAVLinkClient mavClient=new MAVLinkClient(context,inputStreamListener,connParams,mavlinkApi);
  drone=new ArduCopter(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),new LogMessageListener(){
    @Override public void onMessageLogged(    int logLevel,    String message){
    }
  }
,new DroneInterfaces.AttributeEventListener(){
    @Override public void onAttributeEvent(    String attributeEvent,    Bundle eventInfo,    boolean checkForSololinkApi){
    }
  }
);
}","@Before public void setUp() throws Exception {
  final Context context=Robolectric.getShadowApplication().getApplicationContext();
  ConnectionParameter connParams=new ConnectionParameter(0,new Bundle(),null);
  mavlinkApi=new MockMavLinkServiceAPI();
  MAVLinkClient mavClient=new MAVLinkClient(context,inputStreamListener,connParams,mavlinkApi);
  drone=new ArduCopter(context,mavClient,dpHandler,new AndroidApWarningParser(),new LogMessageListener(){
    @Override public void onMessageLogged(    int logLevel,    String message){
    }
  }
,new DroneInterfaces.AttributeEventListener(){
    @Override public void onAttributeEvent(    String attributeEvent,    Bundle eventInfo,    boolean checkForSololinkApi){
    }
  }
);
}","The original code incorrectly included `DroidPlannerPrefs` as a separate parameter in the `ArduCopter` constructor, which likely caused an incompatible method signature. The fixed code removes this unnecessary parameter, aligning the constructor call with the correct method signature and reducing potential runtime errors. By streamlining the constructor arguments, the code becomes more precise and less prone to instantiation issues when creating an ArduCopter object."
94710,"public void updateFollowCenter(SoloMessageLocation location){
  soloLinkMgr.sendTLVPacket(location,true,null);
}","public void updateFollowCenter(SoloMessageLocation location){
  soloLinkMgr.sendTLVPacket(location,true,new AbstractCommandListener(){
    @Override public void onSuccess(){
    }
    @Override public void onError(    int executionError){
      Timber.w(""String_Node_Str"",executionError);
    }
    @Override public void onTimeout(){
      Timber.w(""String_Node_Str"");
    }
  }
);
}","The original code lacks error handling when sending a TLV packet, potentially masking failures or exceptions during transmission. The fixed code adds an AbstractCommandListener with onError and onTimeout methods, providing explicit error tracking and logging mechanisms. By implementing these listener methods, the code now gracefully handles potential communication failures, improving robustness and diagnostic capabilities during packet transmission."
94711,"@Override protected ROIEstimator initROIEstimator(MavLinkDrone drone,Handler handler){
  return null;
}","@Override protected ROIEstimator initROIEstimator(MavLinkDrone drone,Handler handler){
  return new SoloROIEstimator(drone,handler,((ArduSolo)drone).getSoloComp());
}","The original code simply returned null, failing to initialize a proper ROIEstimator for the drone, which would prevent region of interest tracking functionality. The fixed code creates a new SoloROIEstimator instance by passing the drone, handler, and Solo component, ensuring a valid and functional ROI estimation mechanism. By constructing a concrete ROIEstimator implementation, the code now enables proper tracking and management of regions of interest for the drone's operations."
94712,"@Override public void enableFollow(){
  super.enableFollow();
  soloComp.enableFollowDataConnection();
}","@Override public void enableFollow(){
  isFollowEnabled.set(true);
}","The original code incorrectly calls an external method `soloComp.enableFollowDataConnection()` without properly managing the internal follow state. The fixed code directly sets the `isFollowEnabled` boolean to `true` using a thread-safe atomic set operation, ensuring proper internal state management. By directly controlling the follow flag, the new implementation provides a cleaner, more predictable mechanism for enabling follow functionality with better encapsulation and state control."
94713,"public FollowSoloShot(DroneManager droneMgr,Handler handler){
  super(droneMgr,handler);
  final ArduSolo drone=(ArduSolo)droneMgr.getDrone();
  this.soloComp=drone.getSoloComp();
}","public FollowSoloShot(DroneManager droneMgr,Handler handler){
  super(droneMgr,handler);
  ArduSolo drone=(ArduSolo)droneMgr.getDrone();
  this.soloComp=drone.getSoloComp();
}","The original code incorrectly declared the `drone` variable as `final`, which is unnecessary and can potentially restrict future modifications or reassignments. In the fixed code, the `final` keyword is removed, allowing more flexibility in handling the drone object while maintaining the same functionality. This change simplifies the code and provides better adaptability without impacting the core logic of initializing the `soloComp` component."
94714,"@Override protected void processNewLocation(Location location){
  if (location != null) {
    final LatLongAlt receivedCoord=location.getCoord();
    locationCoord.setAltitude(receivedCoord.getAltitude());
    locationCoord.setLatitude(receivedCoord.getLatitude());
    locationCoord.setLongitude(receivedCoord.getLongitude());
    locationSetter.setCoordinate(locationCoord);
    soloComp.updateFollowCenter(locationSetter);
  }
}","@Override protected void processNewLocation(Location location){
  if (location != null) {
    LatLongAlt receivedCoord=location.getCoord();
    locationCoord.set((LatLong)receivedCoord);
    locationSetter.setCoordinate(locationCoord);
    soloComp.updateFollowCenter(locationSetter);
  }
}","The original code manually sets altitude, latitude, and longitude separately, which is redundant and potentially error-prone. The fixed code uses a more efficient `set()` method that directly copies the coordinate data from `receivedCoord` to `locationCoord`, simplifying the coordinate transfer. This approach reduces code complexity, minimizes potential errors, and provides a more streamlined way of updating location coordinates."
94715,"@Override public void disableFollow(){
  super.disableFollow();
  soloComp.disableFollowDataConnection();
}","@Override public void disableFollow(){
  if (isFollowEnabled.compareAndSet(true,false)) {
    realLocation=null;
    disableWatchdog();
  }
}","The original code blindly called `disableFollowDataConnection()` without ensuring thread-safe state management or handling follow mode status. The fixed code introduces an atomic boolean check `isFollowEnabled.compareAndSet(true,false)` to safely transition the follow state, and additionally resets `realLocation` and disables the watchdog when the transition occurs. This approach provides thread-safe, controlled state management with explicit cleanup actions, preventing potential race conditions and ensuring clean, predictable follow mode deactivation."
94716,"protected void updateROI(){
  if (realLocation == null) {
    return;
  }
  LatLong gcsCoord=realLocation.getCoord();
  double bearing=realLocation.getBearing();
  double distanceTraveledSinceLastPoint=realLocation.getSpeed() * (System.currentTimeMillis() - timeOfLastLocation) / 1000f;
  LatLong goCoord=GeoTools.newCoordFromBearingAndDistance(gcsCoord,bearing,distanceTraveledSinceLastPoint);
  MavLinkDoCmds.setROI(drone,new LatLongAlt(goCoord.getLatitude(),goCoord.getLongitude(),(0.0)),null);
  if (realLocation.getSpeed() > 0)   watchdog.postDelayed(watchdogCallback,TIMEOUT);
}","protected void updateROI(){
  if (realLocation == null) {
    return;
  }
  LatLong gcsCoord=realLocation.getCoord();
  double bearing=realLocation.getBearing();
  double distanceTraveledSinceLastPoint=realLocation.getSpeed() * (System.currentTimeMillis() - timeOfLastLocation) / 1000f;
  LatLong goCoord=GeoTools.newCoordFromBearingAndDistance(gcsCoord,bearing,distanceTraveledSinceLastPoint);
  sendUpdateROI(goCoord);
  if (realLocation.getSpeed() > 0)   watchdog.postDelayed(watchdogCallback,getUpdatePeriod());
}","The original code directly sets the ROI using MavLinkDoCmds, which may lack flexibility and proper abstraction for ROI updates. The fixed code introduces a `sendUpdateROI()` method and replaces the hardcoded timeout with a dynamic `getUpdatePeriod()` method, promoting better encapsulation and adaptability. These changes allow for more modular ROI management and easier configuration of update intervals, enhancing the code's maintainability and extensibility."
94717,"@Override public void onLocationUpdate(Location location){
  if (location.isAccurate()) {
    final Home home=getHome();
    if (!home.isValid()) {
      updateCurrentState(ReturnToMeState.STATE_WAITING_FOR_VEHICLE_GPS);
      return;
    }
    final LatLongAlt homePosition=home.getCoordinate();
    final LatLongAlt locationCoord=location.getCoord();
    final float[] results=new float[3];
    android.location.Location.distanceBetween(homePosition.getLatitude(),homePosition.getLongitude(),locationCoord.getLatitude(),locationCoord.getLongitude(),results);
    final float displacement=results[0];
    if (displacement >= UPDATE_MINIMAL_DISPLACEMENT) {
      MavLinkDoCmds.setVehicleHome(droneMgr.getDrone(),new LatLongAlt(locationCoord.getLatitude(),locationCoord.getLongitude(),homePosition.getAltitude()),new AbstractCommandListener(){
        @Override public void onSuccess(){
          Timber.i(""String_Node_Str"",locationCoord.toString());
          droneMgr.executeAsyncAction(requestHomeUpdateAction,null);
          CommonApiUtils.postSuccessEvent(commandListener);
          updateCurrentState(ReturnToMeState.STATE_UPDATING_HOME);
        }
        @Override public void onError(        int executionError){
          Timber.e(""String_Node_Str"",executionError);
          CommonApiUtils.postErrorEvent(executionError,commandListener);
          updateCurrentState(ReturnToMeState.STATE_ERROR_UPDATING_HOME);
        }
        @Override public void onTimeout(){
          Timber.w(""String_Node_Str"");
          CommonApiUtils.postTimeoutEvent(commandListener);
          updateCurrentState(ReturnToMeState.STATE_ERROR_UPDATING_HOME);
        }
      }
);
    }
  }
 else {
    updateCurrentState(ReturnToMeState.STATE_USER_LOCATION_INACCURATE);
  }
}","@Override public void onLocationUpdate(Location location){
  if (location.isAccurate()) {
    final Home home=getHome();
    if (!home.isValid()) {
      updateCurrentState(ReturnToMeState.STATE_WAITING_FOR_VEHICLE_GPS);
      return;
    }
    final LatLongAlt homePosition=home.getCoordinate();
    final LatLongAlt locationCoord=location.getCoord();
    final float[] results=new float[3];
    android.location.Location.distanceBetween(homePosition.getLatitude(),homePosition.getLongitude(),locationCoord.getLatitude(),locationCoord.getLongitude(),results);
    final float displacement=results[0];
    if (displacement >= UPDATE_MINIMAL_DISPLACEMENT) {
      MavLinkDoCmds.setVehicleHome(droneMgr.getDrone(),new LatLongAlt(locationCoord.getLatitude(),locationCoord.getLongitude(),homePosition.getAltitude()),new AbstractCommandListener(){
        @Override public void onSuccess(){
          Timber.i(""String_Node_Str"",locationCoord.toString());
          droneMgr.getDrone().executeAsyncAction(requestHomeUpdateAction,null);
          CommonApiUtils.postSuccessEvent(commandListener);
          updateCurrentState(ReturnToMeState.STATE_UPDATING_HOME);
        }
        @Override public void onError(        int executionError){
          Timber.e(""String_Node_Str"",executionError);
          CommonApiUtils.postErrorEvent(executionError,commandListener);
          updateCurrentState(ReturnToMeState.STATE_ERROR_UPDATING_HOME);
        }
        @Override public void onTimeout(){
          Timber.w(""String_Node_Str"");
          CommonApiUtils.postTimeoutEvent(commandListener);
          updateCurrentState(ReturnToMeState.STATE_ERROR_UPDATING_HOME);
        }
      }
);
    }
  }
 else {
    updateCurrentState(ReturnToMeState.STATE_USER_LOCATION_INACCURATE);
  }
}","The original code incorrectly called `executeAsyncAction` directly on `droneMgr` instead of `droneMgr.getDrone()`, which would likely cause a method invocation error or fail to execute the intended action. In the fixed code, `droneMgr.getDrone().executeAsyncAction(requestHomeUpdateAction,null)` correctly references the drone object before calling the async action method. This change ensures that the home update request is properly executed on the specific drone instance, resolving the potential method call issue and maintaining the intended functionality of updating the vehicle's home location."
94718,"@Override public void onSuccess(){
  Timber.i(""String_Node_Str"",locationCoord.toString());
  droneMgr.executeAsyncAction(requestHomeUpdateAction,null);
  CommonApiUtils.postSuccessEvent(commandListener);
  updateCurrentState(ReturnToMeState.STATE_UPDATING_HOME);
}","@Override public void onSuccess(){
  Timber.i(""String_Node_Str"",locationCoord.toString());
  droneMgr.getDrone().executeAsyncAction(requestHomeUpdateAction,null);
  CommonApiUtils.postSuccessEvent(commandListener);
  updateCurrentState(ReturnToMeState.STATE_UPDATING_HOME);
}","The original code directly calls `executeAsyncAction` on `droneMgr`, which is likely incorrect as it doesn't specify the specific drone instance. The fixed code calls `getDrone()` first to retrieve the correct drone object before executing the async action, ensuring the method is called on the intended drone instance. This modification improves method reliability by explicitly targeting the specific drone and preventing potential null or incorrect object references."
94719,"public ArduCopter(Context context,MAVLinkStreams.MAVLinkOutputStream mavClient,Handler handler,Preferences pref,AutopilotWarningParser warningParser,LogMessageListener logListener,DroneInterfaces.AttributeEventListener listener){
  super(context,mavClient,handler,pref,warningParser,logListener,listener);
}","public ArduCopter(Context context,MAVLinkStreams.MAVLinkOutputStream mavClient,Handler handler,AutopilotWarningParser warningParser,LogMessageListener logListener,DroneInterfaces.AttributeEventListener listener){
  super(context,mavClient,handler,warningParser,logListener,listener);
}","The original constructor incorrectly included a redundant `Preferences` parameter that was not necessary for the method signature. The fixed code removes the unnecessary `pref` argument, aligning the constructor with the correct method signature and reducing potential confusion. By streamlining the constructor parameters, the code becomes cleaner, more focused, and eliminates any superfluous dependencies."
94720,"public ArduPlane(Context context,MAVLinkStreams.MAVLinkOutputStream mavClient,Handler handler,Preferences pref,AutopilotWarningParser warningParser,LogMessageListener logListener,DroneInterfaces.AttributeEventListener listener){
  super(context,mavClient,handler,pref,warningParser,logListener,listener);
}","public ArduPlane(Context context,MAVLinkStreams.MAVLinkOutputStream mavClient,Handler handler,AutopilotWarningParser warningParser,LogMessageListener logListener,DroneInterfaces.AttributeEventListener listener){
  super(context,mavClient,handler,warningParser,logListener,listener);
}","The original code incorrectly included an additional `Preferences` parameter in the constructor, which does not match the parent class's method signature. The fixed code removes the `Preferences` parameter, aligning the constructor with the expected super class constructor parameters. This correction ensures proper method inheritance and prevents potential compilation errors or unexpected runtime behavior when instantiating the ArduPlane class."
94721,"public ArduRover(Context context,MAVLinkStreams.MAVLinkOutputStream mavClient,Handler handler,Preferences pref,AutopilotWarningParser warningParser,LogMessageListener logListener,DroneInterfaces.AttributeEventListener listener){
  super(context,mavClient,handler,pref,warningParser,logListener,listener);
}","public ArduRover(Context context,MAVLinkStreams.MAVLinkOutputStream mavClient,Handler handler,AutopilotWarningParser warningParser,LogMessageListener logListener,DroneInterfaces.AttributeEventListener listener){
  super(context,mavClient,handler,warningParser,logListener,listener);
}","The original code incorrectly included an unnecessary `Preferences` parameter in the constructor, which was not part of the parent class's method signature. In the fixed code, the `Preferences` parameter was removed, ensuring the constructor matches the parent class method exactly. This correction prevents potential compilation errors and maintains proper method inheritance by aligning the constructor parameters with the superclass definition."
94722,"public ArduSolo(Context context,MAVLinkStreams.MAVLinkOutputStream mavClient,Handler handler,Preferences pref,AutopilotWarningParser warningParser,LogMessageListener logListener,DroneInterfaces.AttributeEventListener listener){
  super(context,mavClient,handler,pref,warningParser,logListener,listener);
  this.soloComp=new SoloComp(context,handler);
  this.soloComp.setListener(new SoloComp.SoloCompListener(){
    @Override public void onConnected(){
      if (isConnected()) {
        notifyDroneEvent(DroneInterfaces.DroneEventsType.CONNECTED);
      }
    }
    @Override public void onDisconnected(){
      notifyDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED);
    }
    @Override public void onTlvPacketReceived(    TLVPacket packet){
switch (packet.getMessageType()) {
case TLVMessageTypes.TYPE_ARTOO_INPUT_REPORT_MESSAGE:
        break;
case TLVMessageTypes.TYPE_SOLO_GET_BUTTON_SETTING:
case TLVMessageTypes.TYPE_SOLO_SET_BUTTON_SETTING:
      break;
case TLVMessageTypes.TYPE_SOLO_GOPRO_STATE:
    notifyAttributeListener(SoloEvents.SOLO_GOPRO_STATE_UPDATED);
  break;
default :
final Bundle messageInfo=new Bundle();
messageInfo.putParcelable(SoloEventExtras.EXTRA_SOLO_MESSAGE_DATA,packet);
notifyAttributeListener(SoloEvents.SOLO_MESSAGE_RECEIVED,messageInfo,true);
break;
}
}
@Override public void onPresetButtonLoaded(int buttonType,SoloButtonSetting buttonSettings){
notifyAttributeListener(SoloEvents.SOLO_BUTTON_SETTINGS_UPDATED,null,true);
}
@Override public void onWifiInfoUpdated(String wifiName,String wifiPassword){
notifyAttributeListener(SoloEvents.SOLO_WIFI_SETTINGS_UPDATED,null,true);
}
@Override public void onButtonPacketReceived(ButtonPacket packet){
final Bundle eventInfo=new Bundle();
eventInfo.putParcelable(SoloEventExtras.EXTRA_SOLO_BUTTON_EVENT,packet);
notifyAttributeListener(SoloEvents.SOLO_BUTTON_EVENT_RECEIVED,eventInfo,true);
}
@Override public void onEUTxPowerComplianceUpdated(boolean isCompliant){
final Bundle eventInfo=new Bundle(1);
eventInfo.putBoolean(SoloEventExtras.EXTRA_SOLO_EU_TX_POWER_COMPLIANT,isCompliant);
notifyAttributeListener(SoloEvents.SOLO_EU_TX_POWER_COMPLIANCE_UPDATED,eventInfo,true);
}
@Override public void onVersionsUpdated(){
final Bundle eventInfo=new Bundle();
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_VEHICLE_VERSION,soloComp.getVehicleVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_AUTOPILOT_VERSION,soloComp.getAutopilotVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_GIMBAL_VERSION,soloComp.getGimbalVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_CONTROLLER_VERSION,soloComp.getControllerVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_CONTROLLER_FIRMWARE_VERSION,soloComp.getControllerFirmwareVersion());
notifyAttributeListener(SoloEvents.SOLO_VERSIONS_UPDATED,eventInfo,true);
}
@Override public void onControllerEvent(String event,Bundle eventInfo){
notifyAttributeListener(event,eventInfo,true);
}
}
);
}","public ArduSolo(Context context,MAVLinkStreams.MAVLinkOutputStream mavClient,Handler handler,AutopilotWarningParser warningParser,LogMessageListener logListener,DroneInterfaces.AttributeEventListener listener){
  super(context,mavClient,handler,warningParser,logListener,listener);
  this.soloComp=new SoloComp(context,handler);
  this.soloComp.setListener(new SoloComp.SoloCompListener(){
    @Override public void onConnected(){
      if (isConnected()) {
        notifyDroneEvent(DroneInterfaces.DroneEventsType.CONNECTED);
      }
    }
    @Override public void onDisconnected(){
      notifyDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED);
    }
    @Override public void onTlvPacketReceived(    TLVPacket packet){
switch (packet.getMessageType()) {
case TLVMessageTypes.TYPE_ARTOO_INPUT_REPORT_MESSAGE:
        break;
case TLVMessageTypes.TYPE_SOLO_GET_BUTTON_SETTING:
case TLVMessageTypes.TYPE_SOLO_SET_BUTTON_SETTING:
      break;
case TLVMessageTypes.TYPE_SOLO_GOPRO_STATE:
    notifyAttributeListener(SoloEvents.SOLO_GOPRO_STATE_UPDATED);
  break;
default :
final Bundle messageInfo=new Bundle();
messageInfo.putParcelable(SoloEventExtras.EXTRA_SOLO_MESSAGE_DATA,packet);
notifyAttributeListener(SoloEvents.SOLO_MESSAGE_RECEIVED,messageInfo,true);
break;
}
}
@Override public void onPresetButtonLoaded(int buttonType,SoloButtonSetting buttonSettings){
notifyAttributeListener(SoloEvents.SOLO_BUTTON_SETTINGS_UPDATED,null,true);
}
@Override public void onWifiInfoUpdated(String wifiName,String wifiPassword){
notifyAttributeListener(SoloEvents.SOLO_WIFI_SETTINGS_UPDATED,null,true);
}
@Override public void onButtonPacketReceived(ButtonPacket packet){
final Bundle eventInfo=new Bundle();
eventInfo.putParcelable(SoloEventExtras.EXTRA_SOLO_BUTTON_EVENT,packet);
notifyAttributeListener(SoloEvents.SOLO_BUTTON_EVENT_RECEIVED,eventInfo,true);
}
@Override public void onEUTxPowerComplianceUpdated(boolean isCompliant){
final Bundle eventInfo=new Bundle(1);
eventInfo.putBoolean(SoloEventExtras.EXTRA_SOLO_EU_TX_POWER_COMPLIANT,isCompliant);
notifyAttributeListener(SoloEvents.SOLO_EU_TX_POWER_COMPLIANCE_UPDATED,eventInfo,true);
}
@Override public void onVersionsUpdated(){
final Bundle eventInfo=new Bundle();
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_VEHICLE_VERSION,soloComp.getVehicleVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_AUTOPILOT_VERSION,soloComp.getAutopilotVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_GIMBAL_VERSION,soloComp.getGimbalVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_CONTROLLER_VERSION,soloComp.getControllerVersion());
eventInfo.putString(SoloEventExtras.EXTRA_SOLO_CONTROLLER_FIRMWARE_VERSION,soloComp.getControllerFirmwareVersion());
notifyAttributeListener(SoloEvents.SOLO_VERSIONS_UPDATED,eventInfo,true);
}
@Override public void onControllerEvent(String event,Bundle eventInfo){
notifyAttributeListener(event,eventInfo,true);
}
}
);
}","The original code included an unnecessary `Preferences` parameter in the constructor, which was redundant and potentially led to configuration conflicts. The fixed code removes this parameter, streamlining the constructor and ensuring a cleaner, more focused initialization process. By simplifying the method signature, the code becomes more maintainable and reduces potential sources of initialization errors."
94723,"private void checkEkfPositionState(msg_ekf_status_report ekfStatus){
  if (ekfStatus == null)   return;
  final int flags=ekfStatus.flags;
  final boolean isOk=this.armed ? (flags & EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS) != 0 && (flags & EKF_STATUS_FLAGS.EKF_CONST_POS_MODE) == 0 : (flags & EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS) != 0 || (flags & EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_ABS) != 0;
  if (isEkfPositionOk != isOk) {
    isEkfPositionOk=isOk;
    myDrone.notifyDroneEvent(DroneEventsType.EKF_POSITION_STATE_UPDATE);
    if (isEkfPositionOk) {
      myDrone.requestHomeUpdate();
    }
  }
}","private void checkEkfPositionState(msg_ekf_status_report ekfStatus){
  if (ekfStatus == null)   return;
  int flags=ekfStatus.flags;
  boolean isOk=this.armed ? (flags & EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS) != 0 && (flags & EKF_STATUS_FLAGS.EKF_CONST_POS_MODE) == 0 : (flags & EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS) != 0 || (flags & EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_ABS) != 0;
  if (isEkfPositionOk != isOk) {
    isEkfPositionOk=isOk;
    myDrone.notifyDroneEvent(DroneEventsType.EKF_POSITION_STATE_UPDATE);
    if (isEkfPositionOk) {
      myDrone.executeAsyncAction(requestHomeUpdateAction,null);
    }
  }
}","The original code used direct home update method, which might block or have synchronization issues during drone state changes. The fixed code replaces direct home update with an asynchronous action execution method `executeAsyncAction()`, allowing safer and more flexible home update request handling. This modification ensures non-blocking behavior and provides better error handling and event management during drone position state updates."
94724,"public void onVehicleTypeReceived(FirmwareType type){
  if (drone != null) {
    return;
  }
  DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
switch (type) {
case ARDU_COPTER:
    if (isCompanionComputerEnabled()) {
      Timber.i(""String_Node_Str"");
      this.drone=new ArduSolo(context,mavClient,handler,dpPrefs,new AndroidApWarningParser(),this,this);
    }
 else {
      Timber.i(""String_Node_Str"");
      this.drone=new ArduCopter(context,mavClient,handler,dpPrefs,new AndroidApWarningParser(),this,this);
    }
  break;
case ARDU_SOLO:
Timber.i(""String_Node_Str"");
this.drone=new ArduSolo(context,mavClient,handler,dpPrefs,new AndroidApWarningParser(),this,this);
break;
case ARDU_PLANE:
Timber.i(""String_Node_Str"");
this.drone=new ArduPlane(context,mavClient,handler,dpPrefs,new AndroidApWarningParser(),this,this);
break;
case ARDU_ROVER:
Timber.i(""String_Node_Str"");
this.drone=new ArduRover(context,mavClient,handler,dpPrefs,new AndroidApWarningParser(),this,this);
break;
case PX4_NATIVE:
Timber.i(""String_Node_Str"");
this.drone=new Px4Native(context,handler,mavClient,new AndroidApWarningParser(),this,this);
break;
case GENERIC:
Timber.i(""String_Node_Str"");
this.drone=new GenericMavLinkDrone(context,handler,mavClient,new AndroidApWarningParser(),this,this);
break;
}
this.followMe=new Follow(this,handler,new FusedLocation(context,handler));
this.returnToMe=new ReturnToMe(this,new FusedLocation(context,handler,LocationRequest.PRIORITY_HIGH_ACCURACY,1000L,1000L,ReturnToMe.UPDATE_MINIMAL_DISPLACEMENT),this);
StreamRates streamRates=drone.getStreamRates();
if (streamRates != null) {
streamRates.setRates(dpPrefs.getRates());
}
drone.addDroneListener(this);
ParameterManager parameterManager=drone.getParameterManager();
if (parameterManager != null) {
parameterManager.setParameterListener(this);
}
MagnetometerCalibrationImpl magnetometer=drone.getMagnetometerCalibration();
if (magnetometer != null) {
magnetometer.setListener(this);
}
}","public void onVehicleTypeReceived(FirmwareType type){
  if (drone != null) {
    return;
  }
switch (type) {
case ARDU_COPTER:
    if (isCompanionComputerEnabled()) {
      Timber.i(""String_Node_Str"");
      this.drone=new ArduSolo(context,mavClient,handler,new AndroidApWarningParser(),this,this);
    }
 else {
      Timber.i(""String_Node_Str"");
      this.drone=new ArduCopter(context,mavClient,handler,new AndroidApWarningParser(),this,this);
    }
  break;
case ARDU_SOLO:
Timber.i(""String_Node_Str"");
this.drone=new ArduSolo(context,mavClient,handler,new AndroidApWarningParser(),this,this);
break;
case ARDU_PLANE:
Timber.i(""String_Node_Str"");
this.drone=new ArduPlane(context,mavClient,handler,new AndroidApWarningParser(),this,this);
break;
case ARDU_ROVER:
Timber.i(""String_Node_Str"");
this.drone=new ArduRover(context,mavClient,handler,new AndroidApWarningParser(),this,this);
break;
case PX4_NATIVE:
Timber.i(""String_Node_Str"");
this.drone=new Px4Native(context,handler,mavClient,new AndroidApWarningParser(),this,this);
break;
case GENERIC:
Timber.i(""String_Node_Str"");
this.drone=new GenericMavLinkDrone(context,handler,mavClient,new AndroidApWarningParser(),this,this);
break;
}
this.followMe=new Follow(this,handler,new FusedLocation(context,handler));
this.returnToMe=new ReturnToMe(this,new FusedLocation(context,handler,LocationRequest.PRIORITY_HIGH_ACCURACY,1000L,1000L,ReturnToMe.UPDATE_MINIMAL_DISPLACEMENT),this);
StreamRates streamRates=drone.getStreamRates();
if (streamRates != null) {
DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
streamRates.setRates(dpPrefs.getRates());
}
drone.addDroneListener(this);
ParameterManager parameterManager=drone.getParameterManager();
if (parameterManager != null) {
parameterManager.setParameterListener(this);
}
MagnetometerCalibrationImpl magnetometer=drone.getMagnetometerCalibration();
if (magnetometer != null) {
magnetometer.setListener(this);
}
}","The original code unnecessarily created a DroidPlannerPrefs object for each drone type before the drone was instantiated, potentially wasting resources. In the fixed code, the DroidPlannerPrefs object is only created when needed, specifically when setting stream rates after the drone is initialized. This optimization reduces unnecessary object creation, improves memory efficiency, and ensures that preferences are loaded only when required by the drone's stream rates configuration."
94725,"@Override public void executeAction(Action action,ICommandListener listener) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
  if (data != null)   data.setClassLoader(context.getClassLoader());
switch (type) {
case ConnectionActions.ACTION_CONNECT:
    ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
  connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case CameraActions.ACTION_START_VIDEO_STREAM:
{
final Surface videoSurface=data.getParcelable(CameraActions.EXTRA_VIDEO_DISPLAY);
final String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
Bundle videoProps=data.getBundle(CameraActions.EXTRA_VIDEO_PROPERTIES);
if (videoProps == null) {
videoProps=new Bundle();
videoProps.putInt(CameraActions.EXTRA_VIDEO_PROPS_UDP_PORT,VideoManager.ARTOO_UDP_PORT);
}
CommonApiUtils.startVideoStream(getDrone(),videoProps,ownerId,videoTag,videoSurface,listener);
break;
}
case CameraActions.ACTION_STOP_VIDEO_STREAM:
{
final String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
CommonApiUtils.stopVideoStream(getDrone(),ownerId,videoTag,listener);
break;
}
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
CommonApiUtils.buildComplexMissionItem(getDrone(),data);
break;
default :
droneMgr.executeAsyncAction(action,listener);
break;
}
}","@Override public void executeAction(Action action,ICommandListener listener) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
  if (data != null)   data.setClassLoader(context.getClassLoader());
switch (type) {
case ConnectionActions.ACTION_CONNECT:
    ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
  connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case CameraActions.ACTION_START_VIDEO_STREAM:
{
final Surface videoSurface=data.getParcelable(CameraActions.EXTRA_VIDEO_DISPLAY);
final String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
Bundle videoProps=data.getBundle(CameraActions.EXTRA_VIDEO_PROPERTIES);
if (videoProps == null) {
videoProps=new Bundle();
videoProps.putInt(CameraActions.EXTRA_VIDEO_PROPS_UDP_PORT,VideoManager.ARTOO_UDP_PORT);
}
CommonApiUtils.startVideoStream(getDrone(),videoProps,ownerId,videoTag,videoSurface,listener);
break;
}
case CameraActions.ACTION_STOP_VIDEO_STREAM:
{
final String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
CommonApiUtils.stopVideoStream(getDrone(),ownerId,videoTag,listener);
break;
}
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
CommonApiUtils.buildComplexMissionItem(getDrone(),data);
break;
default :
if (droneMgr != null) {
droneMgr.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
break;
}
}","The original code lacked null checking for the droneMgr object before executing an async action, which could potentially cause a NullPointerException. In the fixed code, a null check is added for droneMgr, and if it is null, an error event is posted using CommonApiUtils instead of directly calling executeAsyncAction. This modification ensures robust error handling and prevents potential crashes by gracefully handling scenarios where the drone manager is unavailable."
94726,"/** 
 * Attempt to grab ownership and start the video stream from the connected drone. Can fail if the video stream is already owned by another client.
 * @param udpPort  Udp port from which to expect the video stream
 * @param surface  Surface object onto which the video is decoded.
 * @param tag      Video tag.
 * @param listener Register a callback to receive update of the command execution status.
 * @since 2.6.8
 */
public void startVideoStream(final int udpPort,final Surface surface,final String tag,final AbstractCommandListener listener){
  if (surface == null) {
    postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
    return;
  }
  final Bundle params=new Bundle();
  params.putParcelable(EXTRA_VIDEO_DISPLAY,surface);
  params.putString(EXTRA_VIDEO_TAG,tag);
  params.putInt(EXTRA_VIDEO_UDP_PORT,udpPort);
  drone.performAsyncActionOnDroneThread(new Action(ACTION_START_VIDEO_STREAM,params),listener);
}","/** 
 * Attempt to grab ownership and start the video stream from the connected drone. Can fail if the video stream is already owned by another client.
 * @param surface  Surface object onto which the video is decoded.
 * @param tag      Video tag.
 * @param videoProps Non-null video properties. @see VIDEO_PROPS_UDP_PORT
 * @param listener Register a callback to receive update of the command execution status.
 * @since 2.6.8
 */
public void startVideoStream(@NonNull final Surface surface,final String tag,@NonNull Bundle videoProps,final AbstractCommandListener listener){
  if (surface == null || videoProps == null) {
    postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
    return;
  }
  final Bundle params=new Bundle();
  params.putParcelable(EXTRA_VIDEO_DISPLAY,surface);
  params.putString(EXTRA_VIDEO_TAG,tag);
  params.putBundle(EXTRA_VIDEO_PROPERTIES,videoProps);
  drone.performAsyncActionOnDroneThread(new Action(ACTION_START_VIDEO_STREAM,params),listener);
}","The original code directly used a UDP port parameter, which lacks flexibility and might not handle all video streaming configurations. The fixed code introduces a more robust approach by using a `Bundle` for video properties, allowing for extensible and flexible video stream initialization with nullable checks for surface and properties. This modification enhances code maintainability, supports future video streaming variations, and provides a more generic mechanism for configuring video stream parameters across different drone configurations."
94727,"@Override public void executeAction(Action action,ICommandListener listener) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
  if (data != null)   data.setClassLoader(context.getClassLoader());
switch (type) {
case ConnectionActions.ACTION_CONNECT:
    ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
  connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case CameraActions.ACTION_START_VIDEO_STREAM:
{
final Surface videoSurface=data.getParcelable(CameraActions.EXTRA_VIDEO_DISPLAY);
final String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
final int videoUdpPort=data.getInt(CameraActions.EXTRA_VIDEO_UDP_PORT,CameraActions.DEFAULT_VIDEO_UDP_PORT);
CommonApiUtils.startVideoStream(droneMgr.getDrone(),videoUdpPort,ownerId,videoTag,videoSurface,listener);
break;
}
case CameraActions.ACTION_STOP_VIDEO_STREAM:
{
final String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
CommonApiUtils.stopVideoStream(droneMgr.getDrone(),ownerId,videoTag,listener);
break;
}
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
final MavLinkDrone drone=droneMgr == null ? null : droneMgr.getDrone();
CommonApiUtils.buildComplexMissionItem(drone,data);
break;
default :
droneMgr.executeAsyncAction(action,listener);
break;
}
}","@Override public void executeAction(Action action,ICommandListener listener) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
  if (data != null)   data.setClassLoader(context.getClassLoader());
switch (type) {
case ConnectionActions.ACTION_CONNECT:
    ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
  connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case CameraActions.ACTION_START_VIDEO_STREAM:
{
final Surface videoSurface=data.getParcelable(CameraActions.EXTRA_VIDEO_DISPLAY);
final String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
Bundle videoProps=data.getBundle(CameraActions.EXTRA_VIDEO_PROPERTIES);
if (videoProps == null) {
videoProps=new Bundle();
videoProps.putInt(CameraActions.EXTRA_VIDEO_PROPS_UDP_PORT,VideoManager.ARTOO_UDP_PORT);
}
CommonApiUtils.startVideoStream(getDrone(),videoProps,ownerId,videoTag,videoSurface,listener);
break;
}
case CameraActions.ACTION_STOP_VIDEO_STREAM:
{
final String videoTag=data.getString(CameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
CommonApiUtils.stopVideoStream(getDrone(),ownerId,videoTag,listener);
break;
}
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
CommonApiUtils.buildComplexMissionItem(getDrone(),data);
break;
default :
droneMgr.executeAsyncAction(action,listener);
break;
}
}","The original code lacked proper handling of video stream properties, directly using hard-coded UDP port values without flexibility. The fixed code introduces a more robust approach by extracting video properties into a Bundle, creating default properties if none exist, and using a more generic method for starting video streams. This modification enhances code resilience, improves configurability, and provides a more extensible mechanism for managing video streaming parameters across different drone configurations."
94728,"@Override public void startVideoStream(int udpPort,String appId,String newVideoTag,Surface videoSurface,final ICommandListener listener){
  if (!soloComp.hasStreamingPermission()) {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
    return;
  }
  super.startVideoStream(udpPort,appId,newVideoTag,videoSurface,listener);
}","@Override public void startVideoStream(Bundle videoProps,String appId,String newVideoTag,Surface videoSurface,final ICommandListener listener){
  if (!soloComp.hasStreamingPermission()) {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
    return;
  }
  super.startVideoStream(videoProps,appId,newVideoTag,videoSurface,listener);
}","The original code used an incorrect method signature with `udpPort` as an integer parameter, which likely did not match the expected interface or parent class implementation. The fixed code replaces the `udpPort` parameter with a `Bundle` called `videoProps`, allowing for more flexible and comprehensive video stream configuration. This modification enables better parameter passing, enhances method flexibility, and ensures proper compatibility with the parent class method signature."
94729,"public void startVideoStream(int udpPort,String appId,String newVideoTag,Surface videoSurface,final ICommandListener listener){
  videoMgr.startVideoStream(udpPort,appId,newVideoTag,videoSurface,listener);
}","public void startVideoStream(Bundle videoProps,String appId,String newVideoTag,Surface videoSurface,final ICommandListener listener){
  videoMgr.startVideoStream(videoProps,appId,newVideoTag,videoSurface,listener);
}","The original code used a single UDP port parameter, which was likely too restrictive for comprehensive video stream configuration. The fixed code introduces a Bundle parameter (videoProps) that allows multiple configuration options to be passed flexibly, enabling more complex and adaptable video stream initialization. This change provides greater flexibility and extensibility for video streaming setup, supporting more dynamic and configurable streaming scenarios."
94730,"@Override public void onIpDisconnected(){
  if (isStarted.get()) {
    if (shouldReconnect()) {
      handler.postDelayed(reconnectTask,RECONNECT_COUNTDOWN);
    }
    if (linkListener != null && wasConnected.get())     linkListener.onLinkDisconnected();
    wasConnected.set(false);
  }
}","@Override public void onIpDisconnected(){
  if (isStarted.get()) {
    if (shouldReconnect()) {
      handler.postDelayed(reconnectTask,RECONNECT_COUNTDOWN);
    }
  }
  if (linkListener != null && wasConnected.compareAndSet(true,false))   linkListener.onLinkDisconnected();
}","The original code had a race condition where the `wasConnected` flag might be set to false within the `isStarted` block, potentially missing the `onLinkDisconnected` callback. The fixed code moves the listener notification outside the `isStarted` check and uses `compareAndSet` to atomically update the flag, ensuring the callback is triggered exactly once when transitioning from connected to disconnected. This modification guarantees thread-safe state management and prevents potential callback loss during IP disconnection scenarios."
94731,"public static void startVideoStream(Drone drone,int udpPort,String appId,String videoTag,Surface videoSurface,ICommandListener listener){
  if (!(drone instanceof GenericMavLinkDrone)) {
    postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
    return;
  }
  final GenericMavLinkDrone mavLinkDrone=(GenericMavLinkDrone)drone;
  mavLinkDrone.startVideoStream(udpPort,appId,videoTag,videoSurface,listener);
}","public static void startVideoStream(Drone drone,Bundle videoProps,String appId,String videoTag,Surface videoSurface,ICommandListener listener){
  if (!(drone instanceof GenericMavLinkDrone)) {
    postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
    return;
  }
  final GenericMavLinkDrone mavLinkDrone=(GenericMavLinkDrone)drone;
  mavLinkDrone.startVideoStream(videoProps,appId,videoTag,videoSurface,listener);
}","The original code used a direct UDP port parameter, which limited video stream configuration flexibility. The fixed code introduces a Bundle parameter for video properties, allowing more comprehensive and adaptable video stream initialization. This modification enables richer configuration options and provides a more extensible approach to starting video streams across different drone types."
94732,"NALUChunk assembleNALUChunk(byte[] buffer,int bufferLength){
  final byte nalHeaderByte=buffer[12];
  final int forbiddenBit=(nalHeaderByte & 0x80) >> 7;
  if (forbiddenBit != 0) {
    Timber.w(""String_Node_Str"");
    return null;
  }
  long rtpTimestamp=0;
  rtpTimestamp|=(buffer[4] & 0xffl) << 24;
  rtpTimestamp|=(buffer[5] & 0xffl) << 16;
  rtpTimestamp|=(buffer[6] & 0xffl) << 8;
  rtpTimestamp|=(buffer[7] & 0xffl);
  final int sequenceNumber=((buffer[2] & 0xff) << 8) | (buffer[3] & 0xff);
  final int nalType=nalHeaderByte & 0x1f;
  if (nalType <= 0) {
    Timber.d(""String_Node_Str"" + nalType);
    return null;
  }
  if (nalType <= 23) {
    final int payloadOffset=12;
    final int payloadLength=bufferLength - payloadOffset;
switch (nalType) {
case 7:
case 8:
{
        ByteBuffer naluData;
        if (nalType == NALUChunk.SPS_NAL_TYPE) {
          naluData=paramsNaluChunk.payloads[SPS_BUFFER_INDEX];
          isSpsSet=true;
        }
 else {
          naluData=paramsNaluChunk.payloads[PPS_BUFFER_INDEX];
          isPpsSet=true;
        }
        naluData.reset();
        naluData.put(buffer,payloadOffset,payloadLength);
        if (areParametersSet()) {
          paramsNaluChunk.sequenceNumber=sequenceNumber;
          paramsNaluChunk.presentationTime=rtpTimestamp;
          return paramsNaluChunk;
        }
        return null;
      }
default :
    if (!areParametersSet())     return null;
  ByteBuffer assembledNaluBuffer=assembledNaluChunk.payloads[0];
assembledNaluBuffer.reset();
assembledNaluBuffer.put(buffer,payloadOffset,payloadLength);
assembledNaluChunk.type=nalType;
assembledNaluChunk.sequenceNumber=sequenceNumber;
assembledNaluChunk.flags=0;
assembledNaluChunk.presentationTime=rtpTimestamp;
return assembledNaluChunk;
}
}
if (nalType == 28) {
if (!areParametersSet()) return null;
final int payloadOffset=14;
final int payloadLength=bufferLength - payloadOffset;
final int fuIndicatorByte=nalHeaderByte;
final int fuHeaderByte=buffer[13];
final int fuNalType=fuHeaderByte & 0x1f;
final int startBit=(fuHeaderByte & 0x80) >> 7;
final int endBit=(fuHeaderByte & 0x40) >> 6;
if (startBit == 1) {
ByteBuffer assembledNaluBuffer=assembledNaluChunk.payloads[0];
assembledNaluBuffer.reset();
assembledNaluBuffer.put((byte)((fuIndicatorByte & 0xe0) | fuNalType));
assembledNaluBuffer.put(buffer,payloadOffset,payloadLength);
boolean isConfig=fuNalType == 7 || fuNalType == 8;
assembledNaluChunk.sequenceNumber=sequenceNumber;
assembledNaluChunk.type=fuNalType;
assembledNaluChunk.flags=isConfig ? MediaCodec.BUFFER_FLAG_CODEC_CONFIG : 0;
assembledNaluChunk.presentationTime=rtpTimestamp;
return null;
}
 else {
if (sequenceNumber - 1 != assembledNaluChunk.sequenceNumber) {
return null;
}
ByteBuffer assembledNaluBuffer=assembledNaluChunk.payloads[0];
assembledNaluBuffer.put(buffer,payloadOffset,payloadLength);
assembledNaluChunk.sequenceNumber=sequenceNumber;
if (endBit == 1) {
return assembledNaluChunk;
}
 else {
return null;
}
}
}
return null;
}","NALUChunk assembleNALUChunk(byte[] buffer,int bufferLength){
  final byte nalHeaderByte=buffer[12];
  final int forbiddenBit=(nalHeaderByte & 0x80) >> 7;
  if (forbiddenBit != 0) {
    Timber.w(""String_Node_Str"");
    return null;
  }
  long rtpTimestamp=0;
  rtpTimestamp|=(buffer[4] & 0xffl) << 24;
  rtpTimestamp|=(buffer[5] & 0xffl) << 16;
  rtpTimestamp|=(buffer[6] & 0xffl) << 8;
  rtpTimestamp|=(buffer[7] & 0xffl);
  final int sequenceNumber=((buffer[2] & 0xff) << 8) | (buffer[3] & 0xff);
  final int nalType=nalHeaderByte & 0x1f;
  if (nalType <= 0) {
    Timber.d(""String_Node_Str"" + nalType);
    return null;
  }
  if (prevSeq != -1) {
    final int expectedSeq=prevSeq + 1;
    if (sequenceNumber != expectedSeq) {
      Timber.v(""String_Node_Str"",expectedSeq,sequenceNumber);
    }
  }
  prevSeq=sequenceNumber;
  if (nalType <= 23) {
    final int payloadOffset=12;
    final int payloadLength=bufferLength - payloadOffset;
switch (nalType) {
case 7:
case 8:
{
        ByteBuffer naluData;
        if (nalType == NALUChunk.SPS_NAL_TYPE) {
          naluData=paramsNaluChunk.payloads[SPS_BUFFER_INDEX];
          isSpsSet=true;
        }
 else {
          naluData=paramsNaluChunk.payloads[PPS_BUFFER_INDEX];
          isPpsSet=true;
        }
        naluData.reset();
        naluData.put(buffer,payloadOffset,payloadLength);
        if (areParametersSet()) {
          paramsNaluChunk.sequenceNumber=sequenceNumber;
          paramsNaluChunk.presentationTime=0;
          return paramsNaluChunk;
        }
        return null;
      }
default :
    if (!areParametersSet())     return null;
  ByteBuffer assembledNaluBuffer=assembledNaluChunk.payloads[0];
assembledNaluBuffer.reset();
assembledNaluBuffer.put(buffer,payloadOffset,payloadLength);
assembledNaluChunk.type=nalType;
assembledNaluChunk.sequenceNumber=sequenceNumber;
assembledNaluChunk.flags=0;
assembledNaluChunk.presentationTime=naluCounter++ * DELTA_PRESENTATION_TIME;
return assembledNaluChunk;
}
}
if (nalType == 28) {
if (!areParametersSet()) return null;
final int payloadOffset=14;
final int payloadLength=bufferLength - payloadOffset;
final int fuIndicatorByte=nalHeaderByte;
final int fuHeaderByte=buffer[13];
final int fuNalType=fuHeaderByte & 0x1f;
final int startBit=(fuHeaderByte & 0x80) >> 7;
final int endBit=(fuHeaderByte & 0x40) >> 6;
if (startBit == 1) {
ByteBuffer assembledNaluBuffer=assembledNaluChunk.payloads[0];
assembledNaluBuffer.reset();
assembledNaluBuffer.put((byte)((fuIndicatorByte & 0xe0) | fuNalType));
assembledNaluBuffer.put(buffer,payloadOffset,payloadLength);
boolean isConfig=fuNalType == 7 || fuNalType == 8;
assembledNaluChunk.sequenceNumber=sequenceNumber;
assembledNaluChunk.type=fuNalType;
assembledNaluChunk.flags=isConfig ? MediaCodec.BUFFER_FLAG_CODEC_CONFIG : 0;
return null;
}
 else {
if (sequenceNumber - 1 != assembledNaluChunk.sequenceNumber) {
return null;
}
ByteBuffer assembledNaluBuffer=assembledNaluChunk.payloads[0];
assembledNaluBuffer.put(buffer,payloadOffset,payloadLength);
assembledNaluChunk.sequenceNumber=sequenceNumber;
if (endBit == 1) {
assembledNaluChunk.presentationTime=naluCounter++ * DELTA_PRESENTATION_TIME;
return assembledNaluChunk;
}
 else {
return null;
}
}
}
return null;
}","The original code had inconsistent sequence number tracking and presentation time handling, leading to potential incorrect NALU chunk assembly. The fixed code introduces sequence number validation, incremental presentation time generation using `naluCounter`, and removes hardcoded timestamp assignments. These modifications enhance RTP packet processing reliability by ensuring proper sequence tracking, dynamic presentation time generation, and more robust NALU chunk reconstruction."
94733,"private void start(int udpPort,LinkListener listener){
  if (this.linkConn == null || udpPort != this.udpPort) {
    if (isStarted.get()) {
      stop();
    }
    this.linkConn=new UdpConnection(handler,udpPort,UDP_BUFFER_SIZE,true,42);
    this.linkConn.setIpConnectionListener(this);
    this.udpPort=udpPort;
  }
  Log.d(TAG,""String_Node_Str"");
  handler.removeCallbacks(reconnectTask);
  isStarted.set(true);
  this.linkConn.connect();
  this.linkListener=listener;
}","private void start(int udpPort,LinkListener listener){
  if (this.linkConn == null || udpPort != this.linkPort) {
    if (isStarted.get()) {
      stop();
    }
    this.linkConn=new UdpConnection(handler,udpPort,UDP_BUFFER_SIZE,true,42);
    this.linkConn.setIpConnectionListener(this);
    this.linkPort=udpPort;
  }
  Log.d(TAG,""String_Node_Str"");
  handler.removeCallbacks(reconnectTask);
  isStarted.set(true);
  this.linkConn.connect();
  this.linkListener=listener;
}","The original code contains a bug where `udpPort` is compared against `this.udpPort`, which might not be initialized or could lead to unexpected behavior. In the fixed version, `udpPort` is compared against `this.linkPort`, a more appropriate variable name, and correctly updated to track the current port. This change ensures more reliable port management and prevents potential connection inconsistencies during UDP link initialization."
94734,"private void stop(){
  Log.d(TAG,""String_Node_Str"");
  handler.removeCallbacks(reconnectTask);
  isStarted.set(false);
  if (this.linkConn != null) {
    this.linkConn.disconnect();
    this.linkConn=null;
  }
  this.udpPort=-1;
}","private void stop(){
  Log.d(TAG,""String_Node_Str"");
  handler.removeCallbacks(reconnectTask);
  isStarted.set(false);
  if (this.linkConn != null) {
    this.linkConn.disconnect();
    this.linkConn=null;
  }
  this.linkPort=-1;
}","The original code contains a potential bug where `udpPort` is set to -1, which may not accurately represent the port state after disconnection. In the fixed code, `linkPort` is used instead, ensuring consistent naming and proper port management across the method. This correction enhances code clarity, prevents potential naming conflicts, and maintains better semantic consistency in the connection handling process."
94735,"public void startVideoStream(int udpPort,String appId,String newVideoTag,Surface videoSurface,final ICommandListener listener){
  Timber.d(""String_Node_Str"",appId,videoOwnerId.get());
  if (TextUtils.isEmpty(appId)) {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
    return;
  }
  if (videoSurface == null) {
    postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
    return;
  }
  if (newVideoTag == null)   newVideoTag=""String_Node_Str"";
  if (appId.equals(videoOwnerId.get())) {
    String currentVideoTag=videoTagRef.get();
    if (currentVideoTag == null)     currentVideoTag=""String_Node_Str"";
    if (newVideoTag.equals(currentVideoTag)) {
      postSuccessEvent(listener);
      return;
    }
  }
  if (videoOwnerId.compareAndSet(NO_VIDEO_OWNER,appId)) {
    videoTagRef.set(newVideoTag);
    Timber.i(""String_Node_Str"");
    startDecoding(udpPort,videoSurface,new DecoderListener(){
      @Override public void onDecodingStarted(){
        Timber.i(""String_Node_Str"");
        postSuccessEvent(listener);
      }
      @Override public void onDecodingError(){
        Timber.i(""String_Node_Str"");
        postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
        reset();
      }
      @Override public void onDecodingEnded(){
        Timber.i(""String_Node_Str"");
        reset();
      }
    }
);
  }
 else {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
  }
}","public void startVideoStream(Bundle videoProps,String appId,String newVideoTag,Surface videoSurface,final ICommandListener listener){
  Timber.d(""String_Node_Str"",appId,videoOwnerId.get());
  if (TextUtils.isEmpty(appId)) {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
    return;
  }
  final int udpPort=videoProps.getInt(CameraActions.EXTRA_VIDEO_PROPS_UDP_PORT,-1);
  if (videoSurface == null || udpPort == -1) {
    postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
    return;
  }
  if (newVideoTag == null)   newVideoTag=""String_Node_Str"";
  if (appId.equals(videoOwnerId.get())) {
    String currentVideoTag=videoTagRef.get();
    if (currentVideoTag == null)     currentVideoTag=""String_Node_Str"";
    if (newVideoTag.equals(currentVideoTag)) {
      postSuccessEvent(listener);
      return;
    }
  }
  if (videoOwnerId.compareAndSet(NO_VIDEO_OWNER,appId)) {
    videoTagRef.set(newVideoTag);
    Timber.i(""String_Node_Str"");
    startDecoding(udpPort,videoSurface,new DecoderListener(){
      @Override public void onDecodingStarted(){
        Timber.i(""String_Node_Str"");
        postSuccessEvent(listener);
      }
      @Override public void onDecodingError(){
        Timber.i(""String_Node_Str"");
        postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
        reset();
      }
      @Override public void onDecodingEnded(){
        Timber.i(""String_Node_Str"");
        reset();
      }
    }
);
  }
 else {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
  }
}","The original code lacked a mechanism to pass the UDP port, directly receiving it as a parameter without validation. The fixed code introduces a Bundle (videoProps) to safely retrieve the UDP port, adding a critical validation check to ensure the port is valid before proceeding with video streaming. This approach enhances robustness by centralizing configuration retrieval, providing a more flexible and error-resistant method for initializing video stream parameters."
94736,"public static MissionItem getProxyMissionItem(org.droidplanner.services.android.core.mission.MissionItem itemImpl){
  if (itemImpl == null)   return null;
  MissionItem proxyMissionItem;
switch (itemImpl.getType()) {
case WAYPOINT:
{
      WaypointImpl source=(WaypointImpl)itemImpl;
      Waypoint temp=new Waypoint();
      temp.setCoordinate((source.getCoordinate()));
      temp.setAcceptanceRadius(source.getAcceptanceRadius());
      temp.setDelay(source.getDelay());
      temp.setOrbitalRadius(source.getOrbitalRadius());
      temp.setOrbitCCW(source.isOrbitCCW());
      temp.setYawAngle(source.getYawAngle());
      proxyMissionItem=temp;
      break;
    }
case SPLINE_WAYPOINT:
{
    SplineWaypointImpl source=(SplineWaypointImpl)itemImpl;
    SplineWaypoint temp=new SplineWaypoint();
    temp.setCoordinate((source.getCoordinate()));
    temp.setDelay(source.getDelay());
    proxyMissionItem=temp;
    break;
  }
case TAKEOFF:
{
  TakeoffImpl source=(TakeoffImpl)itemImpl;
  Takeoff temp=new Takeoff();
  temp.setTakeoffAltitude(source.getFinishedAlt());
  temp.setTakeoffPitch(source.getPitch());
  proxyMissionItem=temp;
  break;
}
case RTL:
{
ReturnToHomeImpl source=(ReturnToHomeImpl)itemImpl;
ReturnToLaunch temp=new ReturnToLaunch();
temp.setReturnAltitude(source.getHeight());
proxyMissionItem=temp;
break;
}
case LAND:
{
LandImpl source=(LandImpl)itemImpl;
Land temp=new Land();
temp.setCoordinate((source.getCoordinate()));
proxyMissionItem=temp;
break;
}
case DO_LAND_START:
{
DoLandStartImpl source=(DoLandStartImpl)itemImpl;
DoLandStart temp=new DoLandStart();
temp.setCoordinate((source.getCoordinate()));
proxyMissionItem=temp;
break;
}
case CIRCLE:
{
CircleImpl source=(CircleImpl)itemImpl;
Circle temp=new Circle();
temp.setCoordinate((source.getCoordinate()));
temp.setRadius(source.getRadius());
temp.setTurns(source.getNumberOfTurns());
proxyMissionItem=temp;
break;
}
case ROI:
{
RegionOfInterestImpl source=(RegionOfInterestImpl)itemImpl;
RegionOfInterest temp=new RegionOfInterest();
temp.setCoordinate((source.getCoordinate()));
proxyMissionItem=temp;
break;
}
case SURVEY:
{
SurveyImpl source=(SurveyImpl)itemImpl;
boolean isValid=true;
try {
source.build();
}
 catch (Exception e) {
isValid=false;
}
Survey temp=new Survey();
temp.setValid(isValid);
temp.setSurveyDetail(getSurveyDetail(source.surveyData));
temp.setPolygonPoints((source.polygon.getPoints()));
if (source.grid != null) {
temp.setGridPoints((source.grid.gridPoints));
temp.setCameraLocations((source.grid.getCameraLocations()));
}
temp.setPolygonArea(source.polygon.getArea().valueInSqMeters());
proxyMissionItem=temp;
break;
}
case SPLINE_SURVEY:
{
SplineSurveyImpl source=(SplineSurveyImpl)itemImpl;
boolean isValid=true;
try {
source.build();
}
 catch (Exception e) {
isValid=false;
}
Survey temp=new Survey();
temp.setValid(isValid);
temp.setSurveyDetail(getSurveyDetail(source.surveyData));
temp.setPolygonPoints((source.polygon.getPoints()));
if (source.grid != null) {
temp.setGridPoints((source.grid.gridPoints));
temp.setCameraLocations((source.grid.getCameraLocations()));
}
temp.setPolygonArea(source.polygon.getArea().valueInSqMeters());
proxyMissionItem=temp;
break;
}
case CYLINDRICAL_SURVEY:
{
StructureScannerImpl source=(StructureScannerImpl)itemImpl;
StructureScanner temp=new StructureScanner();
temp.setSurveyDetail(getSurveyDetail(source.getSurveyData()));
temp.setCoordinate((source.getCoordinate()));
temp.setRadius(source.getRadius());
temp.setCrossHatch(source.isCrossHatchEnabled());
temp.setHeightStep(source.getEndAltitude());
temp.setStepsCount(source.getNumberOfSteps());
temp.setPath((source.getPath()));
proxyMissionItem=temp;
break;
}
case CHANGE_SPEED:
{
ChangeSpeedImpl source=(ChangeSpeedImpl)itemImpl;
ChangeSpeed temp=new ChangeSpeed();
temp.setSpeed(source.getSpeed());
proxyMissionItem=temp;
break;
}
case CAMERA_TRIGGER:
{
CameraTriggerImpl source=(CameraTriggerImpl)itemImpl;
CameraTrigger temp=new CameraTrigger();
temp.setTriggerDistance(source.getTriggerDistance());
proxyMissionItem=temp;
break;
}
case EPM_GRIPPER:
{
EpmGripperImpl source=(EpmGripperImpl)itemImpl;
EpmGripper temp=new EpmGripper();
temp.setRelease(source.isRelease());
proxyMissionItem=temp;
break;
}
case SET_SERVO:
{
SetServoImpl source=(SetServoImpl)itemImpl;
SetServo temp=new SetServo();
temp.setChannel(source.getChannel());
temp.setPwm(source.getPwm());
proxyMissionItem=temp;
break;
}
case CONDITION_YAW:
{
ConditionYawImpl source=(ConditionYawImpl)itemImpl;
YawCondition temp=new YawCondition();
temp.setAngle(source.getAngle());
temp.setAngularSpeed(source.getAngularSpeed());
temp.setRelative(source.isRelative());
proxyMissionItem=temp;
break;
}
case SET_RELAY:
{
SetRelayImpl impl=(SetRelayImpl)itemImpl;
SetRelay proxy=new SetRelay();
proxy.setRelayNumber(impl.getRelayNumber());
proxy.setEnabled(impl.isEnabled());
proxyMissionItem=proxy;
break;
}
case DO_JUMP:
{
DoJumpImpl source=(DoJumpImpl)itemImpl;
DoJump proxy=new DoJump();
proxy.setWaypoint(source.getWaypoint());
proxy.setRepeatCount(source.getRepeatCount());
proxyMissionItem=proxy;
break;
}
default :
proxyMissionItem=null;
break;
}
return proxyMissionItem;
}","public static MissionItem getProxyMissionItem(org.droidplanner.services.android.core.mission.MissionItem itemImpl){
  if (itemImpl == null)   return null;
  MissionItem proxyMissionItem;
switch (itemImpl.getType()) {
case WAYPOINT:
{
      WaypointImpl source=(WaypointImpl)itemImpl;
      Waypoint temp=new Waypoint();
      temp.setCoordinate((source.getCoordinate()));
      temp.setAcceptanceRadius(source.getAcceptanceRadius());
      temp.setDelay(source.getDelay());
      temp.setOrbitalRadius(source.getOrbitalRadius());
      temp.setOrbitCCW(source.isOrbitCCW());
      temp.setYawAngle(source.getYawAngle());
      proxyMissionItem=temp;
      break;
    }
case SPLINE_WAYPOINT:
{
    SplineWaypointImpl source=(SplineWaypointImpl)itemImpl;
    SplineWaypoint temp=new SplineWaypoint();
    temp.setCoordinate((source.getCoordinate()));
    temp.setDelay(source.getDelay());
    proxyMissionItem=temp;
    break;
  }
case TAKEOFF:
{
  TakeoffImpl source=(TakeoffImpl)itemImpl;
  Takeoff temp=new Takeoff();
  temp.setTakeoffAltitude(source.getFinishedAlt());
  temp.setTakeoffPitch(source.getPitch());
  proxyMissionItem=temp;
  break;
}
case RTL:
{
ReturnToHomeImpl source=(ReturnToHomeImpl)itemImpl;
ReturnToLaunch temp=new ReturnToLaunch();
temp.setReturnAltitude(source.getHeight());
proxyMissionItem=temp;
break;
}
case LAND:
{
LandImpl source=(LandImpl)itemImpl;
Land temp=new Land();
temp.setCoordinate((source.getCoordinate()));
proxyMissionItem=temp;
break;
}
case DO_LAND_START:
{
DoLandStartImpl source=(DoLandStartImpl)itemImpl;
DoLandStart temp=new DoLandStart();
temp.setCoordinate((source.getCoordinate()));
proxyMissionItem=temp;
break;
}
case CIRCLE:
{
CircleImpl source=(CircleImpl)itemImpl;
Circle temp=new Circle();
temp.setCoordinate((source.getCoordinate()));
temp.setRadius(source.getRadius());
temp.setTurns(source.getNumberOfTurns());
proxyMissionItem=temp;
break;
}
case ROI:
{
RegionOfInterestImpl source=(RegionOfInterestImpl)itemImpl;
if (source.isReset()) {
ResetROI temp=new ResetROI();
proxyMissionItem=temp;
}
 else {
RegionOfInterest temp=new RegionOfInterest();
temp.setCoordinate((source.getCoordinate()));
proxyMissionItem=temp;
}
break;
}
case SURVEY:
{
SurveyImpl source=(SurveyImpl)itemImpl;
boolean isValid=true;
try {
source.build();
}
 catch (Exception e) {
isValid=false;
}
Survey temp=new Survey();
temp.setValid(isValid);
temp.setSurveyDetail(getSurveyDetail(source.surveyData));
temp.setPolygonPoints((source.polygon.getPoints()));
if (source.grid != null) {
temp.setGridPoints((source.grid.gridPoints));
temp.setCameraLocations((source.grid.getCameraLocations()));
}
temp.setPolygonArea(source.polygon.getArea().valueInSqMeters());
proxyMissionItem=temp;
break;
}
case SPLINE_SURVEY:
{
SplineSurveyImpl source=(SplineSurveyImpl)itemImpl;
boolean isValid=true;
try {
source.build();
}
 catch (Exception e) {
isValid=false;
}
Survey temp=new Survey();
temp.setValid(isValid);
temp.setSurveyDetail(getSurveyDetail(source.surveyData));
temp.setPolygonPoints((source.polygon.getPoints()));
if (source.grid != null) {
temp.setGridPoints((source.grid.gridPoints));
temp.setCameraLocations((source.grid.getCameraLocations()));
}
temp.setPolygonArea(source.polygon.getArea().valueInSqMeters());
proxyMissionItem=temp;
break;
}
case CYLINDRICAL_SURVEY:
{
StructureScannerImpl source=(StructureScannerImpl)itemImpl;
StructureScanner temp=new StructureScanner();
temp.setSurveyDetail(getSurveyDetail(source.getSurveyData()));
temp.setCoordinate((source.getCoordinate()));
temp.setRadius(source.getRadius());
temp.setCrossHatch(source.isCrossHatchEnabled());
temp.setHeightStep(source.getEndAltitude());
temp.setStepsCount(source.getNumberOfSteps());
temp.setPath((source.getPath()));
proxyMissionItem=temp;
break;
}
case CHANGE_SPEED:
{
ChangeSpeedImpl source=(ChangeSpeedImpl)itemImpl;
ChangeSpeed temp=new ChangeSpeed();
temp.setSpeed(source.getSpeed());
proxyMissionItem=temp;
break;
}
case CAMERA_TRIGGER:
{
CameraTriggerImpl source=(CameraTriggerImpl)itemImpl;
CameraTrigger temp=new CameraTrigger();
temp.setTriggerDistance(source.getTriggerDistance());
proxyMissionItem=temp;
break;
}
case EPM_GRIPPER:
{
EpmGripperImpl source=(EpmGripperImpl)itemImpl;
EpmGripper temp=new EpmGripper();
temp.setRelease(source.isRelease());
proxyMissionItem=temp;
break;
}
case SET_SERVO:
{
SetServoImpl source=(SetServoImpl)itemImpl;
SetServo temp=new SetServo();
temp.setChannel(source.getChannel());
temp.setPwm(source.getPwm());
proxyMissionItem=temp;
break;
}
case CONDITION_YAW:
{
ConditionYawImpl source=(ConditionYawImpl)itemImpl;
YawCondition temp=new YawCondition();
temp.setAngle(source.getAngle());
temp.setAngularSpeed(source.getAngularSpeed());
temp.setRelative(source.isRelative());
proxyMissionItem=temp;
break;
}
case SET_RELAY:
{
SetRelayImpl impl=(SetRelayImpl)itemImpl;
SetRelay proxy=new SetRelay();
proxy.setRelayNumber(impl.getRelayNumber());
proxy.setEnabled(impl.isEnabled());
proxyMissionItem=proxy;
break;
}
case DO_JUMP:
{
DoJumpImpl source=(DoJumpImpl)itemImpl;
DoJump proxy=new DoJump();
proxy.setWaypoint(source.getWaypoint());
proxy.setRepeatCount(source.getRepeatCount());
proxyMissionItem=proxy;
break;
}
default :
proxyMissionItem=null;
break;
}
return proxyMissionItem;
}","The original code lacked handling for the ROI (Region of Interest) item when it was a reset type, which could lead to unexpected behavior. The fixed code adds a conditional check for `source.isReset()`, creating a `ResetROI` object when true, and falling back to the standard `RegionOfInterest` creation otherwise. This modification ensures comprehensive handling of different ROI mission item scenarios, improving the method's robustness and preventing potential runtime errors."
94737,"@Override public void onDroneEvent(DroneInterfaces.DroneEventsType event,MavLinkDrone drone){
  Bundle extrasBundle=null;
  String droneEvent=null;
  final List<Pair<String,Bundle>> attributesInfo=new ArrayList<>();
switch (event) {
case DISCONNECTED:
    context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_DISCONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId));
  droneEvent=AttributeEvent.STATE_DISCONNECTED;
break;
case GUIDEDPOINT:
droneEvent=AttributeEvent.GUIDED_POINT_UPDATED;
break;
case RADIO:
droneEvent=AttributeEvent.SIGNAL_UPDATED;
break;
case RC_IN:
break;
case RC_OUT:
break;
case ARMING_STARTED:
case ARMING:
droneEvent=AttributeEvent.STATE_ARMING;
break;
case AUTOPILOT_WARNING:
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_ERROR_ID,drone.getState().getErrorId());
droneEvent=AttributeEvent.AUTOPILOT_ERROR;
break;
case MODE:
droneEvent=AttributeEvent.STATE_VEHICLE_MODE;
break;
case ATTITUDE:
case ORIENTATION:
droneEvent=AttributeEvent.ATTITUDE_UPDATED;
break;
case SPEED:
droneEvent=AttributeEvent.SPEED_UPDATED;
break;
case BATTERY:
droneEvent=AttributeEvent.BATTERY_UPDATED;
break;
case STATE:
droneEvent=AttributeEvent.STATE_UPDATED;
break;
case MISSION_UPDATE:
droneEvent=AttributeEvent.MISSION_UPDATED;
break;
case MISSION_RECEIVED:
droneEvent=AttributeEvent.MISSION_RECEIVED;
break;
case FIRMWARE:
case TYPE:
droneEvent=AttributeEvent.TYPE_UPDATED;
break;
case HOME:
droneEvent=AttributeEvent.HOME_UPDATED;
break;
case GPS:
droneEvent=AttributeEvent.GPS_POSITION;
break;
case GPS_FIX:
droneEvent=AttributeEvent.GPS_FIX;
break;
case GPS_COUNT:
droneEvent=AttributeEvent.GPS_COUNT;
break;
case CALIBRATION_IMU:
final String calIMUMessage=drone.getCalibrationSetup().getMessage();
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,calIMUMessage);
droneEvent=AttributeEvent.CALIBRATION_IMU;
break;
case CALIBRATION_TIMEOUT:
final AccelCalibration accelCalibration=drone.getCalibrationSetup();
final String message=accelCalibration.getMessage();
if (accelCalibration.isCalibrating() && TextUtils.isEmpty(message)) {
accelCalibration.cancelCalibration();
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
}
 else {
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,message);
droneEvent=AttributeEvent.CALIBRATION_IMU_TIMEOUT;
}
break;
case HEARTBEAT_TIMEOUT:
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
break;
case CONNECTING:
droneEvent=AttributeEvent.STATE_CONNECTING;
break;
case CONNECTION_FAILED:
disconnect();
onConnectionFailed(""String_Node_Str"");
break;
case HEARTBEAT_FIRST:
final Bundle heartBeatExtras=new Bundle(1);
heartBeatExtras.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
attributesInfo.add(Pair.create(AttributeEvent.HEARTBEAT_FIRST,heartBeatExtras));
case CONNECTED:
final ConnectionParameter sanitizedParameter=new ConnectionParameter(connectionParams.getConnectionType(),connectionParams.getParamsBundle(),null);
context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_CONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId).putExtra(GCSEvent.EXTRA_VEHICLE_CONNECTION_PARAMETER,sanitizedParameter));
attributesInfo.add(Pair.<String,Bundle>create(AttributeEvent.STATE_CONNECTED,null));
break;
case HEARTBEAT_RESTORED:
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
droneEvent=AttributeEvent.HEARTBEAT_RESTORED;
break;
case MISSION_SENT:
droneEvent=AttributeEvent.MISSION_SENT;
break;
case INVALID_POLYGON:
break;
case MISSION_WP_UPDATE:
final int currentWaypoint=drone.getMissionStats().getCurrentWP();
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_CURRENT_WAYPOINT,currentWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_UPDATED;
break;
case MISSION_WP_REACHED:
final int lastReachedWaypoint=drone.getMissionStats().getLastReachedWP();
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_LAST_REACHED_WAYPOINT,lastReachedWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_REACHED;
break;
case ALTITUDE:
droneEvent=AttributeEvent.ALTITUDE_UPDATED;
break;
case WARNING_SIGNAL_WEAK:
droneEvent=AttributeEvent.SIGNAL_WEAK;
break;
case WARNING_NO_GPS:
droneEvent=AttributeEvent.WARNING_NO_GPS;
break;
case MAGNETOMETER:
break;
case FOOTPRINT:
droneEvent=AttributeEvent.CAMERA_FOOTPRINTS_UPDATED;
break;
case EKF_STATUS_UPDATE:
droneEvent=AttributeEvent.STATE_EKF_REPORT;
break;
case EKF_POSITION_STATE_UPDATE:
droneEvent=AttributeEvent.STATE_EKF_POSITION;
break;
}
if (droneEvent != null) {
notifyAttributeUpdate(droneEvent,extrasBundle);
}
if (!attributesInfo.isEmpty()) {
notifyAttributeUpdate(attributesInfo);
}
}","@Override public void onDroneEvent(DroneInterfaces.DroneEventsType event,MavLinkDrone drone){
  Bundle extrasBundle=null;
  String droneEvent=null;
  final List<Pair<String,Bundle>> attributesInfo=new ArrayList<>();
switch (event) {
case DISCONNECTED:
    context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_DISCONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId));
  droneEvent=AttributeEvent.STATE_DISCONNECTED;
break;
case GUIDEDPOINT:
droneEvent=AttributeEvent.GUIDED_POINT_UPDATED;
break;
case RADIO:
droneEvent=AttributeEvent.SIGNAL_UPDATED;
break;
case RC_IN:
break;
case RC_OUT:
break;
case ARMING_STARTED:
case ARMING:
droneEvent=AttributeEvent.STATE_ARMING;
break;
case AUTOPILOT_WARNING:
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_ERROR_ID,drone.getState().getErrorId());
droneEvent=AttributeEvent.AUTOPILOT_ERROR;
break;
case MODE:
droneEvent=AttributeEvent.STATE_VEHICLE_MODE;
break;
case ATTITUDE:
case ORIENTATION:
droneEvent=AttributeEvent.ATTITUDE_UPDATED;
break;
case SPEED:
droneEvent=AttributeEvent.SPEED_UPDATED;
break;
case BATTERY:
droneEvent=AttributeEvent.BATTERY_UPDATED;
break;
case STATE:
droneEvent=AttributeEvent.STATE_UPDATED;
break;
case MISSION_UPDATE:
droneEvent=AttributeEvent.MISSION_UPDATED;
break;
case MISSION_RECEIVED:
droneEvent=AttributeEvent.MISSION_RECEIVED;
break;
case FIRMWARE:
case TYPE:
droneEvent=AttributeEvent.TYPE_UPDATED;
break;
case HOME:
droneEvent=AttributeEvent.HOME_UPDATED;
break;
case CALIBRATION_IMU:
final String calIMUMessage=drone.getCalibrationSetup().getMessage();
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,calIMUMessage);
droneEvent=AttributeEvent.CALIBRATION_IMU;
break;
case CALIBRATION_TIMEOUT:
final AccelCalibration accelCalibration=drone.getCalibrationSetup();
final String message=accelCalibration.getMessage();
if (accelCalibration.isCalibrating() && TextUtils.isEmpty(message)) {
accelCalibration.cancelCalibration();
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
}
 else {
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,message);
droneEvent=AttributeEvent.CALIBRATION_IMU_TIMEOUT;
}
break;
case HEARTBEAT_TIMEOUT:
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
break;
case CONNECTING:
droneEvent=AttributeEvent.STATE_CONNECTING;
break;
case CONNECTION_FAILED:
disconnect();
onConnectionFailed(""String_Node_Str"");
break;
case HEARTBEAT_FIRST:
final Bundle heartBeatExtras=new Bundle(1);
heartBeatExtras.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
attributesInfo.add(Pair.create(AttributeEvent.HEARTBEAT_FIRST,heartBeatExtras));
case CONNECTED:
final ConnectionParameter sanitizedParameter=new ConnectionParameter(connectionParams.getConnectionType(),connectionParams.getParamsBundle(),null);
context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_CONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId).putExtra(GCSEvent.EXTRA_VEHICLE_CONNECTION_PARAMETER,sanitizedParameter));
attributesInfo.add(Pair.<String,Bundle>create(AttributeEvent.STATE_CONNECTED,null));
break;
case HEARTBEAT_RESTORED:
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
droneEvent=AttributeEvent.HEARTBEAT_RESTORED;
break;
case MISSION_SENT:
droneEvent=AttributeEvent.MISSION_SENT;
break;
case INVALID_POLYGON:
break;
case MISSION_WP_UPDATE:
final int currentWaypoint=drone.getMissionStats().getCurrentWP();
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_CURRENT_WAYPOINT,currentWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_UPDATED;
break;
case MISSION_WP_REACHED:
final int lastReachedWaypoint=drone.getMissionStats().getLastReachedWP();
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_LAST_REACHED_WAYPOINT,lastReachedWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_REACHED;
break;
case ALTITUDE:
droneEvent=AttributeEvent.ALTITUDE_UPDATED;
break;
case WARNING_SIGNAL_WEAK:
droneEvent=AttributeEvent.SIGNAL_WEAK;
break;
case WARNING_NO_GPS:
droneEvent=AttributeEvent.WARNING_NO_GPS;
break;
case MAGNETOMETER:
break;
case FOOTPRINT:
droneEvent=AttributeEvent.CAMERA_FOOTPRINTS_UPDATED;
break;
case EKF_STATUS_UPDATE:
droneEvent=AttributeEvent.STATE_EKF_REPORT;
break;
case EKF_POSITION_STATE_UPDATE:
droneEvent=AttributeEvent.STATE_EKF_POSITION;
break;
}
if (droneEvent != null) {
notifyAttributeUpdate(droneEvent,extrasBundle);
}
if (!attributesInfo.isEmpty()) {
notifyAttributeUpdate(attributesInfo);
}
}","The original code lacks handling for GPS-related events like GPS, GPS_FIX, and GPS_COUNT, omitting critical position and fix status updates. The fixed code adds these missing event cases, ensuring comprehensive drone event processing by including specific attribute events for GPS position, GPS fix status, and GPS satellite count. By restoring these event handlers, the code now provides more complete and accurate drone state tracking, improving the overall monitoring and reporting capabilities of the drone interface."
94738,"public static void resetROI(MavLinkDrone drone,ICommandListener listener){
  if (drone == null)   return;
  setROI(drone,new Coord3D(0,0,0),listener);
}","public static void resetROI(MavLinkDrone drone,ICommandListener listener){
  if (drone == null)   return;
  setROI(drone,new LatLongAlt(0,0,0),listener);
}","The original code incorrectly uses `Coord3D` when resetting the ROI (Region of Interest), which is likely an incompatible coordinate type for the drone's navigation system. The fixed code replaces `Coord3D` with `LatLongAlt`, a more appropriate coordinate representation that uses latitude, longitude, and altitude for precise geographical positioning. This correction ensures the `setROI` method receives the correct coordinate type, enabling accurate drone positioning and navigation."
94739,"public static void setROI(MavLinkDrone drone,Coord3D coord,ICommandListener listener){
  if (drone == null)   return;
  msg_command_long msg=new msg_command_long();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.command=MAV_CMD.MAV_CMD_DO_SET_ROI;
  msg.param5=(float)coord.getX();
  msg.param6=(float)coord.getY();
  msg.param7=(float)coord.getAltitude();
  drone.getMavClient().sendMavMessage(msg,listener);
}","public static void setROI(MavLinkDrone drone,LatLongAlt coord,ICommandListener listener){
  if (drone == null)   return;
  msg_command_long msg=new msg_command_long();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.command=MAV_CMD.MAV_CMD_DO_SET_ROI;
  msg.param5=(float)coord.getLatitude();
  msg.param6=(float)coord.getLongitude();
  msg.param7=(float)coord.getAltitude();
  drone.getMavClient().sendMavMessage(msg,listener);
}","The original code used a generic Coord3D coordinate type, which lacks context-specific geographic coordinate methods for drone navigation. In the fixed code, LatLongAlt is used, providing precise latitude, longitude, and altitude methods that are more appropriate for drone positioning. This change ensures accurate geographic coordinate representation and enables more reliable ROI (Region of Interest) setting for drone flight operations."
94740,"@Override public boolean executeAsyncAction(Action action,final ICommandListener listener){
  final String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    final float bearing=CommonApiUtils.generateDronie(drone);
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyDroneAttributeEvent(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
return true;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
CommonApiUtils.enableFollowMe(this,handler,followType,listener);
return true;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (followMe != null) {
data.setClassLoader(LatLong.class.getClassLoader());
final FollowAlgorithm followAlgorithm=followMe.getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
if (FollowType.EXTRA_FOLLOW_ROI_TARGET.equals(key)) {
LatLong target=data.getParcelable(key);
if (target != null) {
final Coord2D roiTarget;
if (target instanceof LatLongAlt) {
  roiTarget=new Coord3D(target.getLatitude(),target.getLongitude(),((LatLongAlt)target).getAltitude());
}
 else {
  roiTarget=new Coord2D(target.getLatitude(),target.getLongitude());
}
paramsMap.put(key,roiTarget);
}
}
 else paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
return true;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
CommonApiUtils.disableFollowMe(followMe);
return true;
case StateActions.ACTION_ENABLE_RETURN_TO_ME:
final boolean isEnabled=data.getBoolean(StateActions.EXTRA_IS_RETURN_TO_ME_ENABLED,false);
if (returnToMe != null) {
if (isEnabled) {
returnToMe.enable(listener);
}
 else {
returnToMe.disable();
}
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
return true;
case CapabilityActions.ACTION_CHECK_FEATURE_SUPPORT:
if (listener != null) {
final String featureId=data.getString(CapabilityActions.EXTRA_FEATURE_ID);
if (!TextUtils.isEmpty(featureId)) {
switch (featureId) {
case CapabilityApi.FeatureIds.SOLO_VIDEO_STREAMING:
case CapabilityApi.FeatureIds.COMPASS_CALIBRATION:
if (this.isCompanionComputerEnabled()) {
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
}
break;
case CapabilityApi.FeatureIds.KILL_SWITCH:
if (CommonApiUtils.isKillSwitchSupported(drone)) {
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
}
break;
default :
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
break;
}
}
}
return true;
default :
if (drone != null) {
return drone.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
return true;
}
}
}","@Override public boolean executeAsyncAction(Action action,final ICommandListener listener){
  final String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    final float bearing=CommonApiUtils.generateDronie(drone);
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyDroneAttributeEvent(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
return true;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
CommonApiUtils.enableFollowMe(this,handler,followType,listener);
return true;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (followMe != null) {
data.setClassLoader(LatLong.class.getClassLoader());
final FollowAlgorithm followAlgorithm=followMe.getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
return true;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
CommonApiUtils.disableFollowMe(followMe);
return true;
case StateActions.ACTION_ENABLE_RETURN_TO_ME:
final boolean isEnabled=data.getBoolean(StateActions.EXTRA_IS_RETURN_TO_ME_ENABLED,false);
if (returnToMe != null) {
if (isEnabled) {
returnToMe.enable(listener);
}
 else {
returnToMe.disable();
}
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
return true;
case CapabilityActions.ACTION_CHECK_FEATURE_SUPPORT:
if (listener != null) {
final String featureId=data.getString(CapabilityActions.EXTRA_FEATURE_ID);
if (!TextUtils.isEmpty(featureId)) {
switch (featureId) {
case CapabilityApi.FeatureIds.SOLO_VIDEO_STREAMING:
case CapabilityApi.FeatureIds.COMPASS_CALIBRATION:
if (this.isCompanionComputerEnabled()) {
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
}
break;
case CapabilityApi.FeatureIds.KILL_SWITCH:
if (CommonApiUtils.isKillSwitchSupported(drone)) {
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
}
break;
default :
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
break;
}
}
}
return true;
default :
if (drone != null) {
return drone.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
return true;
}
}
}","The original code had overly complex logic for handling follow parameter updates, specifically for ROI targets, which could lead to unnecessary type conversions and potential errors. The fixed code simplifies the parameter mapping by directly adding all data keys to the parameters map without special handling for ROI targets. This streamlines the parameter update process, making the code more robust and easier to maintain while preserving the core functionality of updating follow algorithm parameters."
94741,"@Override public void onMavLinkMessageReceived(MAVLinkMessage message){
  final int compId=message.compid;
  if (compId != AUTOPILOT_COMPONENT_ID && compId != ARTOO_COMPONENT_ID && compId != TELEMETRY_RADIO_COMPONENT_ID) {
    return;
  }
  onHeartbeat(message);
  if (getParameters().processMessage(message)) {
    return;
  }
  getWaypointManager().processMessage(message);
  getCalibrationSetup().processMessage(message);
switch (message.msgid) {
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
    msg_heartbeat msg_heart=(msg_heartbeat)message;
  checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,getType());
getState().setMode(newMode);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)message;
processStatusText(msg_statustext);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
processVfrHud((msg_vfr_hud)message);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
getMissionStats().setWpno(((msg_mission_current)message).seq);
break;
case msg_mission_item_reached.MAVLINK_MSG_ID_MISSION_ITEM_REACHED:
getMissionStats().setLastReachedWaypointNumber(((msg_mission_item_reached)message).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)message;
setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)message;
getMagnetometer().newData(msg_imu);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
processGlobalPositionInt((msg_global_position_int)message);
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)message;
processBatteryUpdate(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
checkControlSensorsHealth(m_sys);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)message;
processSignalUpdate(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
getGps().setGpsState(((msg_gps_raw_int)message).fix_type,((msg_gps_raw_int)message).satellites_visible,((msg_gps_raw_int)message).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
rc.setRcInputValues((msg_rc_channels_raw)message);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
rc.setRcOutputValues((msg_servo_output_raw)message);
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
getCamera().newImageLocation((msg_camera_feedback)message);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
processMountStatus((msg_mount_status)message);
break;
case msg_named_value_int.MAVLINK_MSG_ID_NAMED_VALUE_INT:
processNamedValueInt((msg_named_value_int)message);
break;
case msg_mag_cal_progress.MAVLINK_MSG_ID_MAG_CAL_PROGRESS:
case msg_mag_cal_report.MAVLINK_MSG_ID_MAG_CAL_REPORT:
getMagnetometerCalibration().processCalibrationMessage(message);
break;
case msg_mission_item.MAVLINK_MSG_ID_MISSION_ITEM:
msg_mission_item missionItem=(msg_mission_item)message;
if (missionItem.seq == Home.HOME_WAYPOINT_INDEX) {
home.setHome(missionItem);
}
break;
default :
break;
}
super.onMavLinkMessageReceived(message);
}","@Override public void onMavLinkMessageReceived(MAVLinkMessage message){
  final int compId=message.compid;
  if (compId != AUTOPILOT_COMPONENT_ID && compId != ARTOO_COMPONENT_ID && compId != TELEMETRY_RADIO_COMPONENT_ID) {
    return;
  }
  onHeartbeat(message);
  if (getParameters().processMessage(message)) {
    return;
  }
  getWaypointManager().processMessage(message);
  getCalibrationSetup().processMessage(message);
switch (message.msgid) {
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
    msg_heartbeat msg_heart=(msg_heartbeat)message;
  checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,getType());
getState().setMode(newMode);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)message;
processStatusText(msg_statustext);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
processVfrHud((msg_vfr_hud)message);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
getMissionStats().setWpno(((msg_mission_current)message).seq);
break;
case msg_mission_item_reached.MAVLINK_MSG_ID_MISSION_ITEM_REACHED:
getMissionStats().setLastReachedWaypointNumber(((msg_mission_item_reached)message).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)message;
setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)message;
getMagnetometer().newData(msg_imu);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)message;
processSignalUpdate(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
rc.setRcInputValues((msg_rc_channels_raw)message);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
rc.setRcOutputValues((msg_servo_output_raw)message);
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
getCamera().newImageLocation((msg_camera_feedback)message);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
processMountStatus((msg_mount_status)message);
break;
case msg_named_value_int.MAVLINK_MSG_ID_NAMED_VALUE_INT:
processNamedValueInt((msg_named_value_int)message);
break;
case msg_mag_cal_progress.MAVLINK_MSG_ID_MAG_CAL_PROGRESS:
case msg_mag_cal_report.MAVLINK_MSG_ID_MAG_CAL_REPORT:
getMagnetometerCalibration().processCalibrationMessage(message);
break;
case msg_mission_item.MAVLINK_MSG_ID_MISSION_ITEM:
msg_mission_item missionItem=(msg_mission_item)message;
if (missionItem.seq == Home.HOME_WAYPOINT_INDEX) {
home.setHome(missionItem);
}
break;
default :
break;
}
super.onMavLinkMessageReceived(message);
}","The original code incorrectly included message processing for global position and system status messages that were not essential or potentially redundant. The fixed code removes these unnecessary message handlers, streamlining the message processing logic and reducing potential overhead. By selectively handling only critical MAVLink message types, the refined implementation improves code efficiency and focuses on core drone telemetry and control functions."
94742,"@Override public DroneAttribute getAttribute(String attributeType){
  if (!TextUtils.isEmpty(attributeType)) {
switch (attributeType) {
case AttributeType.GPS:
      return CommonApiUtils.getGps(this);
case AttributeType.PARAMETERS:
    return CommonApiUtils.getParameters(this,context,cachedParameters);
case AttributeType.HOME:
  return CommonApiUtils.getHome(this);
case AttributeType.MISSION:
return CommonApiUtils.getMission(this);
case AttributeType.TYPE:
return CommonApiUtils.getType(this);
case AttributeType.GUIDED_STATE:
return CommonApiUtils.getGuidedState(this);
case AttributeType.MAGNETOMETER_CALIBRATION_STATUS:
return CommonApiUtils.getMagnetometerCalibrationStatus(this);
}
}
return super.getAttribute(attributeType);
}","@Override public DroneAttribute getAttribute(String attributeType){
  if (!TextUtils.isEmpty(attributeType)) {
switch (attributeType) {
case AttributeType.PARAMETERS:
      return CommonApiUtils.getParameters(this,context,cachedParameters);
case AttributeType.HOME:
    return CommonApiUtils.getHome(this);
case AttributeType.MISSION:
  return CommonApiUtils.getMission(this);
case AttributeType.TYPE:
return CommonApiUtils.getType(this);
case AttributeType.GUIDED_STATE:
return CommonApiUtils.getGuidedState(this);
case AttributeType.MAGNETOMETER_CALIBRATION_STATUS:
return CommonApiUtils.getMagnetometerCalibrationStatus(this);
}
}
return super.getAttribute(attributeType);
}","The buggy code includes an unnecessary GPS attribute case that was likely redundant or not properly implemented. The fixed code removes the GPS case, streamlining the switch statement to focus on essential drone attributes like parameters, home, mission, and calibration status. This simplification reduces potential error points and ensures more focused, reliable attribute retrieval for drone-related operations."
94743,"protected void processBatteryUpdate(double voltage,double remain,double current){
  if (battery.getBatteryVoltage() != voltage || battery.getBatteryRemain() != remain || battery.getBatteryCurrent() != current) {
    battery.setBatteryVoltage(voltage);
    battery.setBatteryRemain(remain);
    battery.setBatteryCurrent(current);
    battery.setBatteryDischarge(getBattDischarge(remain));
    notifyDroneEvent(DroneInterfaces.DroneEventsType.BATTERY);
  }
}","@Override protected void processBatteryUpdate(double voltage,double remain,double current){
  if (battery.getBatteryRemain() != remain) {
    battery.setBatteryDischarge(getBattDischarge(remain));
  }
  super.processBatteryUpdate(voltage,remain,current);
}","The original code redundantly updates battery parameters even when only the battery remain has changed, potentially causing unnecessary processing and event notifications. The fixed code only updates battery discharge when the remaining battery level changes and calls the superclass method to handle standard parameter updates. This approach optimizes performance by reducing redundant updates and ensures that battery discharge is calculated only when the battery level actually changes."
94744,"public ArduPilot(Context context,MAVLinkStreams.MAVLinkOutputStream mavClient,Handler handler,Preferences pref,AutopilotWarningParser warningParser,LogMessageListener logListener,DroneInterfaces.AttributeEventListener listener){
  super(handler,mavClient,warningParser,listener);
  this.context=context;
  this.preferences=pref;
  this.logListener=logListener;
  heartbeat=new HeartBeat(this,handler);
  parameters=new Parameters(this,handler);
  this.waypointManager=new WaypointManager(this,handler);
  rc=new RC(this);
  GPS=new GPS(this);
  this.home=new Home(this);
  this.mission=new Mission(this);
  this.missionStats=new MissionStats(this);
  this.guidedPoint=new GuidedPoint(this,handler);
  this.accelCalibrationSetup=new AccelCalibration(this,handler);
  this.magCalibration=new MagnetometerCalibrationImpl(this);
  this.mag=new Magnetometer(this);
  this.footprints=new Camera(this);
  loadVehicleProfile();
}","public ArduPilot(Context context,MAVLinkStreams.MAVLinkOutputStream mavClient,Handler handler,Preferences pref,AutopilotWarningParser warningParser,LogMessageListener logListener,DroneInterfaces.AttributeEventListener listener){
  super(handler,mavClient,warningParser,listener);
  this.context=context;
  this.preferences=pref;
  this.logListener=logListener;
  heartbeat=new HeartBeat(this,handler);
  parameters=new Parameters(this,handler);
  this.waypointManager=new WaypointManager(this,handler);
  rc=new RC(this);
  this.home=new Home(this);
  this.mission=new Mission(this);
  this.missionStats=new MissionStats(this);
  this.guidedPoint=new GuidedPoint(this,handler);
  this.accelCalibrationSetup=new AccelCalibration(this,handler);
  this.magCalibration=new MagnetometerCalibrationImpl(this);
  this.mag=new Magnetometer(this);
  this.footprints=new Camera(this);
  loadVehicleProfile();
}","The buggy code incorrectly instantiated GPS and RC components with different initialization patterns, potentially leading to inconsistent object creation and potential null pointer risks. In the fixed code, the GPS and RC objects are now initialized consistently with the other components, using a single reference to the current class instance. This standardizes the initialization approach, improving code reliability and reducing the likelihood of initialization-related errors."
94745,"@Override public boolean executeAsyncAction(Action action,final ICommandListener listener){
  final String type=action.getType();
  Bundle data=action.getData();
  if (data == null) {
    data=new Bundle();
  }
switch (type) {
case MissionActions.ACTION_LOAD_WAYPOINTS:
    CommonApiUtils.loadWaypoints(this);
  return true;
case MissionActions.ACTION_SET_MISSION:
data.setClassLoader(com.o3dr.services.android.lib.drone.mission.Mission.class.getClassLoader());
com.o3dr.services.android.lib.drone.mission.Mission mission=data.getParcelable(MissionActions.EXTRA_MISSION);
boolean pushToDrone=data.getBoolean(MissionActions.EXTRA_PUSH_TO_DRONE);
CommonApiUtils.setMission(this,mission,pushToDrone);
return true;
case MissionActions.ACTION_START_MISSION:
boolean forceModeChange=data.getBoolean(MissionActions.EXTRA_FORCE_MODE_CHANGE);
boolean forceArm=data.getBoolean(MissionActions.EXTRA_FORCE_ARM);
CommonApiUtils.startMission(this,forceModeChange,forceArm,listener);
return true;
case ExperimentalActions.ACTION_EPM_COMMAND:
boolean release=data.getBoolean(ExperimentalActions.EXTRA_EPM_RELEASE);
CommonApiUtils.epmCommand(this,release,listener);
return true;
case ExperimentalActions.ACTION_TRIGGER_CAMERA:
CommonApiUtils.triggerCamera(this);
return true;
case ExperimentalActions.ACTION_SET_ROI:
LatLongAlt roi=data.getParcelable(ExperimentalActions.EXTRA_SET_ROI_LAT_LONG_ALT);
if (roi != null) {
Coord3D coord3DRoi=new Coord3D(roi.getLatitude(),roi.getLongitude(),roi.getAltitude());
MavLinkDoCmds.setROI(this,coord3DRoi,listener);
}
return true;
case ExperimentalActions.ACTION_SEND_MAVLINK_MESSAGE:
data.setClassLoader(MavlinkMessageWrapper.class.getClassLoader());
MavlinkMessageWrapper messageWrapper=data.getParcelable(ExperimentalActions.EXTRA_MAVLINK_MESSAGE);
CommonApiUtils.sendMavlinkMessage(this,messageWrapper);
return true;
case ExperimentalActions.ACTION_SET_RELAY:
int relayNumber=data.getInt(ExperimentalActions.EXTRA_RELAY_NUMBER);
boolean isOn=data.getBoolean(ExperimentalActions.EXTRA_IS_RELAY_ON);
MavLinkDoCmds.setRelay(this,relayNumber,isOn,listener);
return true;
case ExperimentalActions.ACTION_SET_SERVO:
int channel=data.getInt(ExperimentalActions.EXTRA_SERVO_CHANNEL);
int pwm=data.getInt(ExperimentalActions.EXTRA_SERVO_PWM);
MavLinkDoCmds.setServo(this,channel,pwm,listener);
return true;
case ControlActions.ACTION_DO_GUIDED_TAKEOFF:
double takeoffAltitude=data.getDouble(ControlActions.EXTRA_ALTITUDE);
CommonApiUtils.doGuidedTakeoff(this,takeoffAltitude,listener);
return true;
case ControlActions.ACTION_SEND_GUIDED_POINT:
data.setClassLoader(LatLong.class.getClassLoader());
boolean force=data.getBoolean(ControlActions.EXTRA_FORCE_GUIDED_POINT);
LatLong guidedPoint=data.getParcelable(ControlActions.EXTRA_GUIDED_POINT);
CommonApiUtils.sendGuidedPoint(this,guidedPoint,force,listener);
return true;
case ControlActions.ACTION_SET_GUIDED_ALTITUDE:
double guidedAltitude=data.getDouble(ControlActions.EXTRA_ALTITUDE);
CommonApiUtils.setGuidedAltitude(this,guidedAltitude);
return true;
case ControlActions.ACTION_SET_CONDITION_YAW:
final float targetAngle=data.getFloat(ControlActions.EXTRA_YAW_TARGET_ANGLE);
final float yawRate=data.getFloat(ControlActions.EXTRA_YAW_CHANGE_RATE);
final boolean isClockwise=data.getBoolean(ControlActions.EXTRA_YAW_IS_CLOCKWISE);
final boolean isRelative=data.getBoolean(ControlActions.EXTRA_YAW_IS_RELATIVE);
MavLinkModes.setConditionYaw(this,targetAngle,yawRate,isClockwise,isRelative,listener);
return true;
case ControlActions.ACTION_SET_VELOCITY:
final float xVel=data.getFloat(ControlActions.EXTRA_VELOCITY_X);
final float yVel=data.getFloat(ControlActions.EXTRA_VELOCITY_Y);
final float zVel=data.getFloat(ControlActions.EXTRA_VELOCITY_Z);
MavLinkModes.setVelocityInLocalFrame(this,xVel,yVel,zVel,listener);
return true;
case ParameterActions.ACTION_REFRESH_PARAMETERS:
CommonApiUtils.refreshParameters(this);
return true;
case ParameterActions.ACTION_WRITE_PARAMETERS:
data.setClassLoader(com.o3dr.services.android.lib.drone.property.Parameters.class.getClassLoader());
com.o3dr.services.android.lib.drone.property.Parameters parameters=data.getParcelable(ParameterActions.EXTRA_PARAMETERS);
CommonApiUtils.writeParameters(this,parameters);
return true;
case StateActions.ACTION_ARM:
boolean doArm=data.getBoolean(StateActions.EXTRA_ARM);
boolean emergencyDisarm=data.getBoolean(StateActions.EXTRA_EMERGENCY_DISARM);
CommonApiUtils.arm(this,doArm,emergencyDisarm,listener);
return true;
case StateActions.ACTION_SET_VEHICLE_HOME:
final LatLongAlt homeLoc=data.getParcelable(StateActions.EXTRA_VEHICLE_HOME_LOCATION);
if (homeLoc != null) {
MavLinkDoCmds.setVehicleHome(this,homeLoc,new AbstractCommandListener(){
@Override public void onSuccess(){
CommonApiUtils.postSuccessEvent(listener);
home.requestHomeUpdate();
}
@Override public void onError(int executionError){
CommonApiUtils.postErrorEvent(executionError,listener);
home.requestHomeUpdate();
}
@Override public void onTimeout(){
CommonApiUtils.postTimeoutEvent(listener);
home.requestHomeUpdate();
}
}
);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
return true;
case CalibrationActions.ACTION_START_IMU_CALIBRATION:
CommonApiUtils.startIMUCalibration(this,listener);
return true;
case CalibrationActions.ACTION_SEND_IMU_CALIBRATION_ACK:
int imuAck=data.getInt(CalibrationActions.EXTRA_IMU_STEP);
CommonApiUtils.sendIMUCalibrationAck(this,imuAck);
return true;
case CalibrationActions.ACTION_START_MAGNETOMETER_CALIBRATION:
final boolean retryOnFailure=data.getBoolean(CalibrationActions.EXTRA_RETRY_ON_FAILURE,false);
final boolean saveAutomatically=data.getBoolean(CalibrationActions.EXTRA_SAVE_AUTOMATICALLY,true);
final int startDelay=data.getInt(CalibrationActions.EXTRA_START_DELAY,0);
CommonApiUtils.startMagnetometerCalibration(this,retryOnFailure,saveAutomatically,startDelay);
return true;
case CalibrationActions.ACTION_CANCEL_MAGNETOMETER_CALIBRATION:
CommonApiUtils.cancelMagnetometerCalibration(this);
return true;
case CalibrationActions.ACTION_ACCEPT_MAGNETOMETER_CALIBRATION:
CommonApiUtils.acceptMagnetometerCalibration(this);
return true;
case GimbalActions.ACTION_SET_GIMBAL_ORIENTATION:
float pitch=data.getFloat(GimbalActions.GIMBAL_PITCH);
float roll=data.getFloat(GimbalActions.GIMBAL_ROLL);
float yaw=data.getFloat(GimbalActions.GIMBAL_YAW);
MavLinkDoCmds.setGimbalOrientation(this,pitch,roll,yaw,listener);
return true;
case GimbalActions.ACTION_RESET_GIMBAL_MOUNT_MODE:
case GimbalActions.ACTION_SET_GIMBAL_MOUNT_MODE:
final int mountMode=data.getInt(GimbalActions.GIMBAL_MOUNT_MODE,MAV_MOUNT_MODE.MAV_MOUNT_MODE_RC_TARGETING);
Timber.i(""String_Node_Str"",mountMode);
Parameter mountParam=this.parameters.getParameter(""String_Node_Str"");
if (mountParam == null) {
msg_mount_configure msg=new msg_mount_configure();
msg.target_system=getSysid();
msg.target_component=getCompid();
msg.mount_mode=(byte)mountMode;
msg.stab_pitch=0;
msg.stab_roll=0;
msg.stab_yaw=0;
getMavClient().sendMavMessage(msg,listener);
}
 else {
MavLinkParameters.sendParameter(this,""String_Node_Str"",1,mountMode);
}
return true;
default :
return super.executeAsyncAction(action,listener);
}
}","@Override public boolean executeAsyncAction(Action action,final ICommandListener listener){
  final String type=action.getType();
  Bundle data=action.getData();
  if (data == null) {
    data=new Bundle();
  }
switch (type) {
case MissionActions.ACTION_LOAD_WAYPOINTS:
    CommonApiUtils.loadWaypoints(this);
  return true;
case MissionActions.ACTION_SET_MISSION:
data.setClassLoader(com.o3dr.services.android.lib.drone.mission.Mission.class.getClassLoader());
com.o3dr.services.android.lib.drone.mission.Mission mission=data.getParcelable(MissionActions.EXTRA_MISSION);
boolean pushToDrone=data.getBoolean(MissionActions.EXTRA_PUSH_TO_DRONE);
CommonApiUtils.setMission(this,mission,pushToDrone);
return true;
case MissionActions.ACTION_START_MISSION:
boolean forceModeChange=data.getBoolean(MissionActions.EXTRA_FORCE_MODE_CHANGE);
boolean forceArm=data.getBoolean(MissionActions.EXTRA_FORCE_ARM);
CommonApiUtils.startMission(this,forceModeChange,forceArm,listener);
return true;
case ExperimentalActions.ACTION_EPM_COMMAND:
boolean release=data.getBoolean(ExperimentalActions.EXTRA_EPM_RELEASE);
CommonApiUtils.epmCommand(this,release,listener);
return true;
case ExperimentalActions.ACTION_TRIGGER_CAMERA:
CommonApiUtils.triggerCamera(this);
return true;
case ExperimentalActions.ACTION_SET_ROI:
LatLongAlt roi=data.getParcelable(ExperimentalActions.EXTRA_SET_ROI_LAT_LONG_ALT);
if (roi != null) {
MavLinkDoCmds.setROI(this,roi,listener);
}
return true;
case ExperimentalActions.ACTION_SEND_MAVLINK_MESSAGE:
data.setClassLoader(MavlinkMessageWrapper.class.getClassLoader());
MavlinkMessageWrapper messageWrapper=data.getParcelable(ExperimentalActions.EXTRA_MAVLINK_MESSAGE);
CommonApiUtils.sendMavlinkMessage(this,messageWrapper);
return true;
case ExperimentalActions.ACTION_SET_RELAY:
int relayNumber=data.getInt(ExperimentalActions.EXTRA_RELAY_NUMBER);
boolean isOn=data.getBoolean(ExperimentalActions.EXTRA_IS_RELAY_ON);
MavLinkDoCmds.setRelay(this,relayNumber,isOn,listener);
return true;
case ExperimentalActions.ACTION_SET_SERVO:
int channel=data.getInt(ExperimentalActions.EXTRA_SERVO_CHANNEL);
int pwm=data.getInt(ExperimentalActions.EXTRA_SERVO_PWM);
MavLinkDoCmds.setServo(this,channel,pwm,listener);
return true;
case ControlActions.ACTION_DO_GUIDED_TAKEOFF:
double takeoffAltitude=data.getDouble(ControlActions.EXTRA_ALTITUDE);
CommonApiUtils.doGuidedTakeoff(this,takeoffAltitude,listener);
return true;
case ControlActions.ACTION_SEND_GUIDED_POINT:
data.setClassLoader(LatLong.class.getClassLoader());
boolean force=data.getBoolean(ControlActions.EXTRA_FORCE_GUIDED_POINT);
LatLong guidedPoint=data.getParcelable(ControlActions.EXTRA_GUIDED_POINT);
CommonApiUtils.sendGuidedPoint(this,guidedPoint,force,listener);
return true;
case ControlActions.ACTION_SET_GUIDED_ALTITUDE:
double guidedAltitude=data.getDouble(ControlActions.EXTRA_ALTITUDE);
CommonApiUtils.setGuidedAltitude(this,guidedAltitude);
return true;
case ControlActions.ACTION_SET_CONDITION_YAW:
final float targetAngle=data.getFloat(ControlActions.EXTRA_YAW_TARGET_ANGLE);
final float yawRate=data.getFloat(ControlActions.EXTRA_YAW_CHANGE_RATE);
final boolean isClockwise=data.getBoolean(ControlActions.EXTRA_YAW_IS_CLOCKWISE);
final boolean isRelative=data.getBoolean(ControlActions.EXTRA_YAW_IS_RELATIVE);
MavLinkModes.setConditionYaw(this,targetAngle,yawRate,isClockwise,isRelative,listener);
return true;
case ControlActions.ACTION_SET_VELOCITY:
final float xVel=data.getFloat(ControlActions.EXTRA_VELOCITY_X);
final float yVel=data.getFloat(ControlActions.EXTRA_VELOCITY_Y);
final float zVel=data.getFloat(ControlActions.EXTRA_VELOCITY_Z);
MavLinkModes.setVelocityInLocalFrame(this,xVel,yVel,zVel,listener);
return true;
case ParameterActions.ACTION_REFRESH_PARAMETERS:
CommonApiUtils.refreshParameters(this);
return true;
case ParameterActions.ACTION_WRITE_PARAMETERS:
data.setClassLoader(com.o3dr.services.android.lib.drone.property.Parameters.class.getClassLoader());
com.o3dr.services.android.lib.drone.property.Parameters parameters=data.getParcelable(ParameterActions.EXTRA_PARAMETERS);
CommonApiUtils.writeParameters(this,parameters);
return true;
case StateActions.ACTION_ARM:
boolean doArm=data.getBoolean(StateActions.EXTRA_ARM);
boolean emergencyDisarm=data.getBoolean(StateActions.EXTRA_EMERGENCY_DISARM);
CommonApiUtils.arm(this,doArm,emergencyDisarm,listener);
return true;
case StateActions.ACTION_SET_VEHICLE_HOME:
final LatLongAlt homeLoc=data.getParcelable(StateActions.EXTRA_VEHICLE_HOME_LOCATION);
if (homeLoc != null) {
MavLinkDoCmds.setVehicleHome(this,homeLoc,new AbstractCommandListener(){
@Override public void onSuccess(){
CommonApiUtils.postSuccessEvent(listener);
home.requestHomeUpdate();
}
@Override public void onError(int executionError){
CommonApiUtils.postErrorEvent(executionError,listener);
home.requestHomeUpdate();
}
@Override public void onTimeout(){
CommonApiUtils.postTimeoutEvent(listener);
home.requestHomeUpdate();
}
}
);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
return true;
case CalibrationActions.ACTION_START_IMU_CALIBRATION:
CommonApiUtils.startIMUCalibration(this,listener);
return true;
case CalibrationActions.ACTION_SEND_IMU_CALIBRATION_ACK:
int imuAck=data.getInt(CalibrationActions.EXTRA_IMU_STEP);
CommonApiUtils.sendIMUCalibrationAck(this,imuAck);
return true;
case CalibrationActions.ACTION_START_MAGNETOMETER_CALIBRATION:
final boolean retryOnFailure=data.getBoolean(CalibrationActions.EXTRA_RETRY_ON_FAILURE,false);
final boolean saveAutomatically=data.getBoolean(CalibrationActions.EXTRA_SAVE_AUTOMATICALLY,true);
final int startDelay=data.getInt(CalibrationActions.EXTRA_START_DELAY,0);
CommonApiUtils.startMagnetometerCalibration(this,retryOnFailure,saveAutomatically,startDelay);
return true;
case CalibrationActions.ACTION_CANCEL_MAGNETOMETER_CALIBRATION:
CommonApiUtils.cancelMagnetometerCalibration(this);
return true;
case CalibrationActions.ACTION_ACCEPT_MAGNETOMETER_CALIBRATION:
CommonApiUtils.acceptMagnetometerCalibration(this);
return true;
case GimbalActions.ACTION_SET_GIMBAL_ORIENTATION:
float pitch=data.getFloat(GimbalActions.GIMBAL_PITCH);
float roll=data.getFloat(GimbalActions.GIMBAL_ROLL);
float yaw=data.getFloat(GimbalActions.GIMBAL_YAW);
MavLinkDoCmds.setGimbalOrientation(this,pitch,roll,yaw,listener);
return true;
case GimbalActions.ACTION_RESET_GIMBAL_MOUNT_MODE:
case GimbalActions.ACTION_SET_GIMBAL_MOUNT_MODE:
final int mountMode=data.getInt(GimbalActions.GIMBAL_MOUNT_MODE,MAV_MOUNT_MODE.MAV_MOUNT_MODE_RC_TARGETING);
Timber.i(""String_Node_Str"",mountMode);
Parameter mountParam=this.parameters.getParameter(""String_Node_Str"");
if (mountParam == null) {
msg_mount_configure msg=new msg_mount_configure();
msg.target_system=getSysid();
msg.target_component=getCompid();
msg.mount_mode=(byte)mountMode;
msg.stab_pitch=0;
msg.stab_roll=0;
msg.stab_yaw=0;
getMavClient().sendMavMessage(msg,listener);
}
 else {
MavLinkParameters.sendParameter(this,""String_Node_Str"",1,mountMode);
}
return true;
default :
return super.executeAsyncAction(action,listener);
}
}","In the buggy code, the `setROI` method was incorrectly creating a new `Coord3D` object by manually extracting latitude, longitude, and altitude from a `LatLongAlt` object. The fixed code directly passes the `LatLongAlt` object to `setROI`, simplifying the conversion and reducing potential errors. This change makes the code more concise, readable, and less prone to mistakes when converting geographic coordinate representations."
94746,"public void stop(){
  if (!BuildConfig.SITL_DEBUG) {
    controllerLinkManager.stop();
  }
  soloLinkMgr.stop();
}","public void stop(){
  soloLinkMgr.stop();
  if (!BuildConfig.SITL_DEBUG) {
    controllerLinkManager.stop();
  }
}","The original code conditionally stops the controllerLinkManager only if not in SITL_DEBUG mode, which could lead to inconsistent system shutdown. In the fixed code, soloLinkMgr.stop() is called first, ensuring it always stops regardless of debug settings, followed by the conditional controllerLinkManager.stop(). This approach guarantees a complete and predictable stop sequence, preventing potential resource management issues during system shutdown."
94747,"@Override public void onLinkDisconnected(){
  if (compListener != null)   compListener.onDisconnected();
  if (!BuildConfig.SITL_DEBUG) {
    controllerLinkManager.stop();
  }
  soloLinkMgr.stop();
}","@Override public void onLinkDisconnected(){
  if (compListener != null)   compListener.onDisconnected();
  soloLinkMgr.stop();
  if (!BuildConfig.SITL_DEBUG) {
    controllerLinkManager.stop();
  }
}","The original code conditionally stops the controller link manager only in non-debug builds, but potentially prevents stopping the solo link manager in those scenarios. The fixed code moves the `soloLinkMgr.stop()` before the conditional check, ensuring the solo link manager is always stopped regardless of the build configuration. This change guarantees consistent link management behavior across different build types, preventing potential resource leaks or connection inconsistencies."
94748,"public void stop(){
  Timber.d(""String_Node_Str"");
  stopVideoManager();
  super.stop();
}","public void stop(){
  Timber.d(""String_Node_Str"");
  super.stop();
}","The original code called `stopVideoManager()` before `super.stop()`, which could lead to unexpected behavior or potential resource management issues. In the fixed code, `stopVideoManager()` is removed, allowing the superclass's `stop()` method to handle the stopping process directly and cleanly. This modification ensures proper method invocation order and prevents potential interference with the parent class's stopping mechanism."
94749,"/** 
 * Disables control of the gimbal. After calling this method, no call to   {@link GimbalApi#updateGimbalOrientation(float,float,float,GimbalOrientationListener)}will be allowed.
 * @param listener non-null GimbalStatusListener callback.
 */
public void stopGimbalControl(final GimbalOrientationListener listener){
  if (listener == null)   throw new NullPointerException(""String_Node_Str"");
  if (!gimbalListeners.contains(listener)) {
    drone.post(new Runnable(){
      @Override public void run(){
        listener.onGimbalOrientationCommandError(CommandExecutionError.COMMAND_DENIED);
      }
    }
);
    return;
  }
  drone.performAsyncActionOnDroneThread(new Action(ACTION_RESET_GIMBAL_MOUNT_MODE,null),new SimpleCommandListener(){
    @Override public void onTimeout(){
      listener.onGimbalOrientationCommandError(CommandExecutionError.COMMAND_FAILED);
    }
    @Override public void onError(    int error){
      listener.onGimbalOrientationCommandError(error);
    }
  }
);
}","/** 
 * Disables control of the gimbal. After calling this method, no call to   {@link GimbalApi#updateGimbalOrientation(float,float,float,GimbalOrientationListener)}will be allowed.
 * @since 2.5.0
 * @param listener non-null GimbalStatusListener callback.
 */
public void stopGimbalControl(final GimbalOrientationListener listener){
  if (listener == null)   throw new NullPointerException(""String_Node_Str"");
  if (!gimbalListeners.contains(listener)) {
    drone.post(new Runnable(){
      @Override public void run(){
        listener.onGimbalOrientationCommandError(CommandExecutionError.COMMAND_DENIED);
      }
    }
);
    return;
  }
  gimbalListeners.remove(listener);
  Bundle params=new Bundle(1);
  params.putInt(GIMBAL_MOUNT_MODE,MAV_MOUNT_MODE.MAV_MOUNT_MODE_RC_TARGETING);
  drone.performAsyncActionOnDroneThread(new Action(ACTION_SET_GIMBAL_MOUNT_MODE,params),new SimpleCommandListener(){
    @Override public void onTimeout(){
      listener.onGimbalOrientationCommandError(CommandExecutionError.COMMAND_FAILED);
    }
    @Override public void onError(    int error){
      listener.onGimbalOrientationCommandError(error);
    }
  }
);
}","The original code failed to remove the listener from `gimbalListeners` when stopping gimbal control, potentially causing unexpected behavior. The fixed code adds `gimbalListeners.remove(listener)` and uses a specific `Bundle` with `MAV_MOUNT_MODE_RC_TARGETING` to properly reset the gimbal mount mode. This ensures clean listener management and precise gimbal control termination, preventing potential synchronization and state tracking issues."
94750,"@Override public boolean executeAsyncAction(Action action,final ICommandListener listener){
  final String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_LOAD_WAYPOINTS:
    CommonApiUtils.loadWaypoints(this);
  return true;
case MissionActions.ACTION_SET_MISSION:
data.setClassLoader(com.o3dr.services.android.lib.drone.mission.Mission.class.getClassLoader());
com.o3dr.services.android.lib.drone.mission.Mission mission=data.getParcelable(MissionActions.EXTRA_MISSION);
boolean pushToDrone=data.getBoolean(MissionActions.EXTRA_PUSH_TO_DRONE);
CommonApiUtils.setMission(this,mission,pushToDrone);
return true;
case MissionActions.ACTION_START_MISSION:
boolean forceModeChange=data.getBoolean(MissionActions.EXTRA_FORCE_MODE_CHANGE);
boolean forceArm=data.getBoolean(MissionActions.EXTRA_FORCE_ARM);
CommonApiUtils.startMission(this,forceModeChange,forceArm,listener);
return true;
case ExperimentalActions.ACTION_EPM_COMMAND:
boolean release=data.getBoolean(ExperimentalActions.EXTRA_EPM_RELEASE);
CommonApiUtils.epmCommand(this,release,listener);
return true;
case ExperimentalActions.ACTION_TRIGGER_CAMERA:
CommonApiUtils.triggerCamera(this);
return true;
case ExperimentalActions.ACTION_SET_ROI:
LatLongAlt roi=data.getParcelable(ExperimentalActions.EXTRA_SET_ROI_LAT_LONG_ALT);
if (roi != null) {
Coord3D coord3DRoi=new Coord3D(roi.getLatitude(),roi.getLongitude(),roi.getAltitude());
MavLinkDoCmds.setROI(this,coord3DRoi,listener);
}
return true;
case ExperimentalActions.ACTION_SEND_MAVLINK_MESSAGE:
data.setClassLoader(MavlinkMessageWrapper.class.getClassLoader());
MavlinkMessageWrapper messageWrapper=data.getParcelable(ExperimentalActions.EXTRA_MAVLINK_MESSAGE);
CommonApiUtils.sendMavlinkMessage(this,messageWrapper);
return true;
case ExperimentalActions.ACTION_SET_RELAY:
int relayNumber=data.getInt(ExperimentalActions.EXTRA_RELAY_NUMBER);
boolean isOn=data.getBoolean(ExperimentalActions.EXTRA_IS_RELAY_ON);
MavLinkDoCmds.setRelay(this,relayNumber,isOn,listener);
return true;
case ExperimentalActions.ACTION_SET_SERVO:
int channel=data.getInt(ExperimentalActions.EXTRA_SERVO_CHANNEL);
int pwm=data.getInt(ExperimentalActions.EXTRA_SERVO_PWM);
MavLinkDoCmds.setServo(this,channel,pwm,listener);
return true;
case ControlActions.ACTION_DO_GUIDED_TAKEOFF:
double takeoffAltitude=data.getDouble(ControlActions.EXTRA_ALTITUDE);
CommonApiUtils.doGuidedTakeoff(this,takeoffAltitude,listener);
return true;
case ControlActions.ACTION_SEND_GUIDED_POINT:
data.setClassLoader(LatLong.class.getClassLoader());
boolean force=data.getBoolean(ControlActions.EXTRA_FORCE_GUIDED_POINT);
LatLong guidedPoint=data.getParcelable(ControlActions.EXTRA_GUIDED_POINT);
CommonApiUtils.sendGuidedPoint(this,guidedPoint,force,listener);
return true;
case ControlActions.ACTION_SET_GUIDED_ALTITUDE:
double guidedAltitude=data.getDouble(ControlActions.EXTRA_ALTITUDE);
CommonApiUtils.setGuidedAltitude(this,guidedAltitude);
return true;
case ControlActions.ACTION_SET_CONDITION_YAW:
final float targetAngle=data.getFloat(ControlActions.EXTRA_YAW_TARGET_ANGLE);
final float yawRate=data.getFloat(ControlActions.EXTRA_YAW_CHANGE_RATE);
final boolean isClockwise=data.getBoolean(ControlActions.EXTRA_YAW_IS_CLOCKWISE);
final boolean isRelative=data.getBoolean(ControlActions.EXTRA_YAW_IS_RELATIVE);
MavLinkModes.setConditionYaw(this,targetAngle,yawRate,isClockwise,isRelative,listener);
return true;
case ControlActions.ACTION_SET_VELOCITY:
final float xVel=data.getFloat(ControlActions.EXTRA_VELOCITY_X);
final float yVel=data.getFloat(ControlActions.EXTRA_VELOCITY_Y);
final float zVel=data.getFloat(ControlActions.EXTRA_VELOCITY_Z);
MavLinkModes.setVelocityInLocalFrame(this,xVel,yVel,zVel,listener);
return true;
case ParameterActions.ACTION_REFRESH_PARAMETERS:
CommonApiUtils.refreshParameters(this);
return true;
case ParameterActions.ACTION_WRITE_PARAMETERS:
data.setClassLoader(com.o3dr.services.android.lib.drone.property.Parameters.class.getClassLoader());
com.o3dr.services.android.lib.drone.property.Parameters parameters=data.getParcelable(ParameterActions.EXTRA_PARAMETERS);
CommonApiUtils.writeParameters(this,parameters);
return true;
case StateActions.ACTION_ARM:
boolean doArm=data.getBoolean(StateActions.EXTRA_ARM);
boolean emergencyDisarm=data.getBoolean(StateActions.EXTRA_EMERGENCY_DISARM);
CommonApiUtils.arm(this,doArm,emergencyDisarm,listener);
return true;
case StateActions.ACTION_SET_VEHICLE_HOME:
final LatLongAlt homeLoc=data.getParcelable(StateActions.EXTRA_VEHICLE_HOME_LOCATION);
if (homeLoc != null) {
MavLinkDoCmds.setVehicleHome(this,homeLoc,new AbstractCommandListener(){
@Override public void onSuccess(){
CommonApiUtils.postSuccessEvent(listener);
home.requestHomeUpdate();
}
@Override public void onError(int executionError){
CommonApiUtils.postErrorEvent(executionError,listener);
home.requestHomeUpdate();
}
@Override public void onTimeout(){
CommonApiUtils.postTimeoutEvent(listener);
home.requestHomeUpdate();
}
}
);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
return true;
case CalibrationActions.ACTION_START_IMU_CALIBRATION:
CommonApiUtils.startIMUCalibration(this,listener);
return true;
case CalibrationActions.ACTION_SEND_IMU_CALIBRATION_ACK:
int imuAck=data.getInt(CalibrationActions.EXTRA_IMU_STEP);
CommonApiUtils.sendIMUCalibrationAck(this,imuAck);
return true;
case CalibrationActions.ACTION_START_MAGNETOMETER_CALIBRATION:
final boolean retryOnFailure=data.getBoolean(CalibrationActions.EXTRA_RETRY_ON_FAILURE,false);
final boolean saveAutomatically=data.getBoolean(CalibrationActions.EXTRA_SAVE_AUTOMATICALLY,true);
final int startDelay=data.getInt(CalibrationActions.EXTRA_START_DELAY,0);
CommonApiUtils.startMagnetometerCalibration(this,retryOnFailure,saveAutomatically,startDelay);
return true;
case CalibrationActions.ACTION_CANCEL_MAGNETOMETER_CALIBRATION:
CommonApiUtils.cancelMagnetometerCalibration(this);
return true;
case CalibrationActions.ACTION_ACCEPT_MAGNETOMETER_CALIBRATION:
CommonApiUtils.acceptMagnetometerCalibration(this);
return true;
case GimbalActions.ACTION_SET_GIMBAL_ORIENTATION:
float pitch=data.getFloat(GimbalActions.GIMBAL_PITCH);
float roll=data.getFloat(GimbalActions.GIMBAL_ROLL);
float yaw=data.getFloat(GimbalActions.GIMBAL_YAW);
MavLinkDoCmds.setGimbalOrientation(this,pitch,roll,yaw,listener);
return true;
case GimbalActions.ACTION_RESET_GIMBAL_MOUNT_MODE:
MavLinkDoCmds.resetROI(this,listener);
return true;
case GimbalActions.ACTION_SET_GIMBAL_MOUNT_MODE:
final int mountMode=data.getInt(GimbalActions.GIMBAL_MOUNT_MODE,MAV_MOUNT_MODE.MAV_MOUNT_MODE_MAVLINK_TARGETING);
Parameter mountParam=this.parameters.getParameter(""String_Node_Str"");
if (mountParam == null) {
msg_mount_configure msg=new msg_mount_configure();
msg.target_system=getSysid();
msg.target_component=getCompid();
msg.mount_mode=(byte)mountMode;
msg.stab_pitch=0;
msg.stab_roll=0;
msg.stab_yaw=0;
getMavClient().sendMavMessage(msg,listener);
}
 else {
MavLinkParameters.sendParameter(this,""String_Node_Str"",1,mountMode);
}
return true;
default :
return super.executeAsyncAction(action,listener);
}
}","@Override public boolean executeAsyncAction(Action action,final ICommandListener listener){
  final String type=action.getType();
  Bundle data=action.getData();
  if (data == null) {
    data=new Bundle();
  }
switch (type) {
case MissionActions.ACTION_LOAD_WAYPOINTS:
    CommonApiUtils.loadWaypoints(this);
  return true;
case MissionActions.ACTION_SET_MISSION:
data.setClassLoader(com.o3dr.services.android.lib.drone.mission.Mission.class.getClassLoader());
com.o3dr.services.android.lib.drone.mission.Mission mission=data.getParcelable(MissionActions.EXTRA_MISSION);
boolean pushToDrone=data.getBoolean(MissionActions.EXTRA_PUSH_TO_DRONE);
CommonApiUtils.setMission(this,mission,pushToDrone);
return true;
case MissionActions.ACTION_START_MISSION:
boolean forceModeChange=data.getBoolean(MissionActions.EXTRA_FORCE_MODE_CHANGE);
boolean forceArm=data.getBoolean(MissionActions.EXTRA_FORCE_ARM);
CommonApiUtils.startMission(this,forceModeChange,forceArm,listener);
return true;
case ExperimentalActions.ACTION_EPM_COMMAND:
boolean release=data.getBoolean(ExperimentalActions.EXTRA_EPM_RELEASE);
CommonApiUtils.epmCommand(this,release,listener);
return true;
case ExperimentalActions.ACTION_TRIGGER_CAMERA:
CommonApiUtils.triggerCamera(this);
return true;
case ExperimentalActions.ACTION_SET_ROI:
LatLongAlt roi=data.getParcelable(ExperimentalActions.EXTRA_SET_ROI_LAT_LONG_ALT);
if (roi != null) {
Coord3D coord3DRoi=new Coord3D(roi.getLatitude(),roi.getLongitude(),roi.getAltitude());
MavLinkDoCmds.setROI(this,coord3DRoi,listener);
}
return true;
case ExperimentalActions.ACTION_SEND_MAVLINK_MESSAGE:
data.setClassLoader(MavlinkMessageWrapper.class.getClassLoader());
MavlinkMessageWrapper messageWrapper=data.getParcelable(ExperimentalActions.EXTRA_MAVLINK_MESSAGE);
CommonApiUtils.sendMavlinkMessage(this,messageWrapper);
return true;
case ExperimentalActions.ACTION_SET_RELAY:
int relayNumber=data.getInt(ExperimentalActions.EXTRA_RELAY_NUMBER);
boolean isOn=data.getBoolean(ExperimentalActions.EXTRA_IS_RELAY_ON);
MavLinkDoCmds.setRelay(this,relayNumber,isOn,listener);
return true;
case ExperimentalActions.ACTION_SET_SERVO:
int channel=data.getInt(ExperimentalActions.EXTRA_SERVO_CHANNEL);
int pwm=data.getInt(ExperimentalActions.EXTRA_SERVO_PWM);
MavLinkDoCmds.setServo(this,channel,pwm,listener);
return true;
case ControlActions.ACTION_DO_GUIDED_TAKEOFF:
double takeoffAltitude=data.getDouble(ControlActions.EXTRA_ALTITUDE);
CommonApiUtils.doGuidedTakeoff(this,takeoffAltitude,listener);
return true;
case ControlActions.ACTION_SEND_GUIDED_POINT:
data.setClassLoader(LatLong.class.getClassLoader());
boolean force=data.getBoolean(ControlActions.EXTRA_FORCE_GUIDED_POINT);
LatLong guidedPoint=data.getParcelable(ControlActions.EXTRA_GUIDED_POINT);
CommonApiUtils.sendGuidedPoint(this,guidedPoint,force,listener);
return true;
case ControlActions.ACTION_SET_GUIDED_ALTITUDE:
double guidedAltitude=data.getDouble(ControlActions.EXTRA_ALTITUDE);
CommonApiUtils.setGuidedAltitude(this,guidedAltitude);
return true;
case ControlActions.ACTION_SET_CONDITION_YAW:
final float targetAngle=data.getFloat(ControlActions.EXTRA_YAW_TARGET_ANGLE);
final float yawRate=data.getFloat(ControlActions.EXTRA_YAW_CHANGE_RATE);
final boolean isClockwise=data.getBoolean(ControlActions.EXTRA_YAW_IS_CLOCKWISE);
final boolean isRelative=data.getBoolean(ControlActions.EXTRA_YAW_IS_RELATIVE);
MavLinkModes.setConditionYaw(this,targetAngle,yawRate,isClockwise,isRelative,listener);
return true;
case ControlActions.ACTION_SET_VELOCITY:
final float xVel=data.getFloat(ControlActions.EXTRA_VELOCITY_X);
final float yVel=data.getFloat(ControlActions.EXTRA_VELOCITY_Y);
final float zVel=data.getFloat(ControlActions.EXTRA_VELOCITY_Z);
MavLinkModes.setVelocityInLocalFrame(this,xVel,yVel,zVel,listener);
return true;
case ParameterActions.ACTION_REFRESH_PARAMETERS:
CommonApiUtils.refreshParameters(this);
return true;
case ParameterActions.ACTION_WRITE_PARAMETERS:
data.setClassLoader(com.o3dr.services.android.lib.drone.property.Parameters.class.getClassLoader());
com.o3dr.services.android.lib.drone.property.Parameters parameters=data.getParcelable(ParameterActions.EXTRA_PARAMETERS);
CommonApiUtils.writeParameters(this,parameters);
return true;
case StateActions.ACTION_ARM:
boolean doArm=data.getBoolean(StateActions.EXTRA_ARM);
boolean emergencyDisarm=data.getBoolean(StateActions.EXTRA_EMERGENCY_DISARM);
CommonApiUtils.arm(this,doArm,emergencyDisarm,listener);
return true;
case StateActions.ACTION_SET_VEHICLE_HOME:
final LatLongAlt homeLoc=data.getParcelable(StateActions.EXTRA_VEHICLE_HOME_LOCATION);
if (homeLoc != null) {
MavLinkDoCmds.setVehicleHome(this,homeLoc,new AbstractCommandListener(){
@Override public void onSuccess(){
CommonApiUtils.postSuccessEvent(listener);
home.requestHomeUpdate();
}
@Override public void onError(int executionError){
CommonApiUtils.postErrorEvent(executionError,listener);
home.requestHomeUpdate();
}
@Override public void onTimeout(){
CommonApiUtils.postTimeoutEvent(listener);
home.requestHomeUpdate();
}
}
);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
return true;
case CalibrationActions.ACTION_START_IMU_CALIBRATION:
CommonApiUtils.startIMUCalibration(this,listener);
return true;
case CalibrationActions.ACTION_SEND_IMU_CALIBRATION_ACK:
int imuAck=data.getInt(CalibrationActions.EXTRA_IMU_STEP);
CommonApiUtils.sendIMUCalibrationAck(this,imuAck);
return true;
case CalibrationActions.ACTION_START_MAGNETOMETER_CALIBRATION:
final boolean retryOnFailure=data.getBoolean(CalibrationActions.EXTRA_RETRY_ON_FAILURE,false);
final boolean saveAutomatically=data.getBoolean(CalibrationActions.EXTRA_SAVE_AUTOMATICALLY,true);
final int startDelay=data.getInt(CalibrationActions.EXTRA_START_DELAY,0);
CommonApiUtils.startMagnetometerCalibration(this,retryOnFailure,saveAutomatically,startDelay);
return true;
case CalibrationActions.ACTION_CANCEL_MAGNETOMETER_CALIBRATION:
CommonApiUtils.cancelMagnetometerCalibration(this);
return true;
case CalibrationActions.ACTION_ACCEPT_MAGNETOMETER_CALIBRATION:
CommonApiUtils.acceptMagnetometerCalibration(this);
return true;
case GimbalActions.ACTION_SET_GIMBAL_ORIENTATION:
float pitch=data.getFloat(GimbalActions.GIMBAL_PITCH);
float roll=data.getFloat(GimbalActions.GIMBAL_ROLL);
float yaw=data.getFloat(GimbalActions.GIMBAL_YAW);
MavLinkDoCmds.setGimbalOrientation(this,pitch,roll,yaw,listener);
return true;
case GimbalActions.ACTION_RESET_GIMBAL_MOUNT_MODE:
case GimbalActions.ACTION_SET_GIMBAL_MOUNT_MODE:
final int mountMode=data.getInt(GimbalActions.GIMBAL_MOUNT_MODE,MAV_MOUNT_MODE.MAV_MOUNT_MODE_RC_TARGETING);
Timber.i(""String_Node_Str"",mountMode);
Parameter mountParam=this.parameters.getParameter(""String_Node_Str"");
if (mountParam == null) {
msg_mount_configure msg=new msg_mount_configure();
msg.target_system=getSysid();
msg.target_component=getCompid();
msg.mount_mode=(byte)mountMode;
msg.stab_pitch=0;
msg.stab_roll=0;
msg.stab_yaw=0;
getMavClient().sendMavMessage(msg,listener);
}
 else {
MavLinkParameters.sendParameter(this,""String_Node_Str"",1,mountMode);
}
return true;
default :
return super.executeAsyncAction(action,listener);
}
}","The original code lacked a null check for the `data` Bundle, which could potentially cause NullPointerExceptions when accessing Bundle methods. In the fixed code, a null check is added at the beginning, creating an empty Bundle if the original is null, preventing potential null reference errors. This modification ensures robust handling of action data, improving the method's reliability and preventing potential runtime crashes by gracefully managing unexpected null input scenarios."
94751,"public void disconnect(String appId) throws ConnectionException {
  if (TextUtils.isEmpty(appId))   return;
  if (drone instanceof GenericMavLinkDrone) {
    ((GenericMavLinkDrone)drone).tryStoppingVideoStream(appId);
  }
  Log.d(TAG,""String_Node_Str"" + appId);
  DroneEventsListener listener=connectedApps.remove(appId);
  if (listener != null) {
    mavClient.removeLoggingFile(appId);
    listener.onDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED,drone);
    notifyDisconnected(appId,listener);
  }
  if (mavClient.isConnected() && connectedApps.isEmpty()) {
    executeAsyncAction(new Action(GimbalActions.ACTION_RESET_GIMBAL_MOUNT_MODE),new AbstractCommandListener(){
      @Override public void onSuccess(){
        mavClient.closeConnection();
      }
      @Override public void onError(      int executionError){
        mavClient.closeConnection();
      }
      @Override public void onTimeout(){
        mavClient.closeConnection();
      }
    }
);
  }
}","public void disconnect(String appId) throws ConnectionException {
  if (TextUtils.isEmpty(appId))   return;
  if (drone instanceof GenericMavLinkDrone) {
    ((GenericMavLinkDrone)drone).tryStoppingVideoStream(appId);
  }
  Log.d(TAG,""String_Node_Str"" + appId);
  DroneEventsListener listener=connectedApps.remove(appId);
  if (listener != null) {
    mavClient.removeLoggingFile(appId);
    listener.onDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED,drone);
    notifyDisconnected(appId,listener);
  }
  if (mavClient.isConnected() && connectedApps.isEmpty()) {
    executeAsyncAction(new Action(GimbalActions.ACTION_RESET_GIMBAL_MOUNT_MODE),null);
    mavClient.closeConnection();
  }
}","The original code incorrectly passed an AbstractCommandListener to executeAsyncAction, which could lead to potential null pointer exceptions or unhandled connection closure scenarios. In the fixed code, the listener is set to null, and mavClient.closeConnection() is directly called after executing the gimbal reset action, ensuring a more straightforward and reliable disconnection process. This modification simplifies the connection closure logic, reduces complexity, and provides a more predictable method of disconnecting the drone client."
94752,"public static State getState(MavLinkDrone drone,boolean isConnected,Vibration vibration){
  if (drone == null)   return new State();
  org.droidplanner.services.android.core.drone.variables.State droneState=drone.getState();
  ApmModes droneMode=droneState.getMode();
  AccelCalibration accelCalibration=drone.getCalibrationSetup();
  String calibrationMessage=accelCalibration.isCalibrating() ? accelCalibration.getMessage() : null;
  final msg_ekf_status_report ekfStatus=droneState.getEkfStatus();
  final EkfStatus proxyEkfStatus=ekfStatus == null ? new EkfStatus() : new EkfStatus(ekfStatus.flags,ekfStatus.compass_variance,ekfStatus.pos_horiz_variance,ekfStatus.terrain_alt_variance,ekfStatus.velocity_variance,ekfStatus.pos_vert_variance);
  return new State(isConnected,CommonApiUtils.getVehicleMode(droneMode),droneState.isArmed(),droneState.isFlying(),droneState.getErrorId(),drone.getMavlinkVersion(),calibrationMessage,droneState.getFlightStartTime(),proxyEkfStatus,isConnected && drone.isConnectionAlive(),vibration);
}","public static State getState(MavLinkDrone drone,boolean isConnected,Vibration vibration){
  if (drone == null)   return new State();
  org.droidplanner.services.android.core.drone.variables.State droneState=drone.getState();
  ApmModes droneMode=droneState.getMode();
  AccelCalibration accelCalibration=drone.getCalibrationSetup();
  String calibrationMessage=accelCalibration != null && accelCalibration.isCalibrating() ? accelCalibration.getMessage() : null;
  final msg_ekf_status_report ekfStatus=droneState.getEkfStatus();
  final EkfStatus proxyEkfStatus=ekfStatus == null ? new EkfStatus() : new EkfStatus(ekfStatus.flags,ekfStatus.compass_variance,ekfStatus.pos_horiz_variance,ekfStatus.terrain_alt_variance,ekfStatus.velocity_variance,ekfStatus.pos_vert_variance);
  return new State(isConnected,CommonApiUtils.getVehicleMode(droneMode),droneState.isArmed(),droneState.isFlying(),droneState.getErrorId(),drone.getMavlinkVersion(),calibrationMessage,droneState.getFlightStartTime(),proxyEkfStatus,isConnected && drone.isConnectionAlive(),vibration);
}","The original code could throw a NullPointerException when calling `accelCalibration.isCalibrating()` if `accelCalibration` itself was null. The fixed code adds a null check `accelCalibration != null` before invoking `isCalibrating()`, preventing potential null reference errors and ensuring safe method invocation. This modification adds a defensive programming approach, making the code more robust by gracefully handling potential null scenarios without disrupting the method's core functionality."
94753,"private void unregisterUsbPermissionBroadcastReceiver(){
  mContext.unregisterReceiver(broadcastReceiver);
}","private void unregisterUsbPermissionBroadcastReceiver(){
  try {
    mContext.unregisterReceiver(broadcastReceiver);
  }
 catch (  IllegalArgumentException e) {
    Timber.e(e,""String_Node_Str"");
  }
}","The original code lacks error handling when unregistering a broadcast receiver, which can cause an IllegalArgumentException if the receiver is not currently registered. The fixed code adds a try-catch block to gracefully handle potential exceptions, logging the error using Timber for debugging purposes. This approach prevents app crashes and provides a more robust mechanism for dealing with potential receiver unregistration issues."
94754,"@Override public void notifyReceivedData(MAVLinkPacket packet){
  MAVLinkMessage receivedMsg=packet.unpack();
  if (receivedMsg.msgid == msg_command_ack.MAVLINK_MSG_ID_COMMAND_ACK) {
    final msg_command_ack commandAck=(msg_command_ack)receivedMsg;
    handleCommandAck(commandAck);
  }
 else {
    this.mavLinkMsgHandler.receiveData(receivedMsg);
    if (this.drone != null) {
      this.drone.onMavLinkMessageReceived(receivedMsg);
    }
  }
  if (!connectedApps.isEmpty()) {
    for (    DroneEventsListener droneEventsListener : connectedApps.values()) {
      droneEventsListener.onReceivedMavLinkMessage(receivedMsg);
    }
  }
  if (!tlogUploaders.isEmpty()) {
    final byte[] packetData=packet.encodePacket();
    for (    DroneshareClient uploader : tlogUploaders.values()) {
      try {
        uploader.filterMavlink(uploader.interfaceNum,packetData);
      }
 catch (      Exception e) {
        Log.e(TAG,e.getMessage(),e);
      }
    }
  }
}","@Override public void notifyReceivedData(MAVLinkPacket packet){
  MAVLinkMessage receivedMsg=packet.unpack();
  if (receivedMsg == null)   return;
  if (receivedMsg.msgid == msg_command_ack.MAVLINK_MSG_ID_COMMAND_ACK) {
    final msg_command_ack commandAck=(msg_command_ack)receivedMsg;
    handleCommandAck(commandAck);
  }
 else {
    this.mavLinkMsgHandler.receiveData(receivedMsg);
    if (this.drone != null) {
      this.drone.onMavLinkMessageReceived(receivedMsg);
    }
  }
  if (!connectedApps.isEmpty()) {
    for (    DroneEventsListener droneEventsListener : connectedApps.values()) {
      droneEventsListener.onReceivedMavLinkMessage(receivedMsg);
    }
  }
  if (!tlogUploaders.isEmpty()) {
    final byte[] packetData=packet.encodePacket();
    for (    DroneshareClient uploader : tlogUploaders.values()) {
      try {
        uploader.filterMavlink(uploader.interfaceNum,packetData);
      }
 catch (      Exception e) {
        Log.e(TAG,e.getMessage(),e);
      }
    }
  }
}","The original code lacks a null check on the unpacked MAVLinkMessage, potentially causing a NullPointerException when processing packets. The fixed code adds an explicit null check that returns early if the unpacked message is null, preventing potential runtime errors. This defensive programming approach ensures robust message handling by gracefully handling scenarios where packet unpacking might fail, improving the method's reliability and error resilience."
94755,"/** 
 * Set the state of the heartbeat.
 * @param active true to activate the heartbeat, false to deactivate it
 */
public void setActive(boolean active){
  if (active) {
    if (heartbeatExecutor == null || heartbeatExecutor.isShutdown()) {
      heartbeatExecutor=Executors.newSingleThreadScheduledExecutor();
      heartbeatExecutor.scheduleWithFixedDelay(heartbeatRunnable,0,period,TimeUnit.SECONDS);
    }
  }
 else   if (heartbeatExecutor != null && !heartbeatExecutor.isShutdown()) {
    heartbeatExecutor.shutdownNow();
    heartbeatExecutor=null;
  }
}","/** 
 * Set the state of the heartbeat.
 * @param active true to activate the heartbeat, false to deactivate it
 */
public synchronized void setActive(boolean active){
  if (active) {
    if (heartbeatExecutor == null || heartbeatExecutor.isShutdown()) {
      heartbeatExecutor=Executors.newSingleThreadScheduledExecutor();
      heartbeatExecutor.scheduleWithFixedDelay(heartbeatRunnable,0,period,TimeUnit.SECONDS);
    }
  }
 else   if (heartbeatExecutor != null && !heartbeatExecutor.isShutdown()) {
    heartbeatExecutor.shutdownNow();
    heartbeatExecutor=null;
  }
}","The original code lacks thread synchronization, which could lead to race conditions when multiple threads simultaneously modify the heartbeat executor. The fixed code adds the `synchronized` keyword to the method, ensuring that only one thread can execute the method at a time, preventing potential concurrent modification issues. This synchronization guarantees thread-safe management of the heartbeat executor, eliminating the risk of inconsistent state or unexpected behavior."
94756,"public DownloadImageTask(Context context,String appId,ImageView bmImage,Map<String,Bitmap> cachedMap){
  this.bmImage=bmImage;
  this.appId=appId;
  this.cachedMap=cachedMap;
  final File rootDir=new File(context.getExternalFilesDir(null),ROOT_DIR);
  if (!rootDir.exists() && !rootDir.mkdirs()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  this.appIconFile=new File(rootDir,appId);
}","public DownloadImageTask(Context context,String appId,ImageView bmImage,Map<String,Bitmap> cachedMap){
  this.bmImage=bmImage;
  this.appId=appId;
  this.cachedMap=cachedMap;
  final File rootDir=new File(context.getExternalFilesDir(null),ROOT_DIR);
  if (!rootDir.exists() && !rootDir.mkdirs()) {
    Timber.w(""String_Node_Str"");
  }
  this.appIconFile=new File(rootDir,appId);
}","The original code throws an IllegalStateException if the directory cannot be created, which abruptly halts the application and prevents further execution. The fixed code replaces the exception with a Timber warning log, allowing the application to continue running gracefully if directory creation fails. This approach provides better error handling by logging the issue without interrupting the app's workflow, enhancing overall robustness and user experience."
94757,"@Override public void open() throws IOException {
  Log.d(TAG,""String_Node_Str"" + mDevice.getInterfaceCount());
  Log.d(TAG,""String_Node_Str"");
  mControlInterface=mDevice.getInterface(0);
  Log.d(TAG,""String_Node_Str"" + mControlInterface);
  if (!mConnection.claimInterface(mControlInterface,true)) {
    throw new IOException(""String_Node_Str"");
  }
  mControlEndpoint=mControlInterface.getEndpoint(0);
  Log.d(TAG,""String_Node_Str"" + mControlEndpoint.getDirection());
  Log.d(TAG,""String_Node_Str"");
  mDataInterface=mDevice.getInterface(1);
  Log.d(TAG,""String_Node_Str"" + mDataInterface);
  if (!mConnection.claimInterface(mDataInterface,true)) {
    throw new IOException(""String_Node_Str"");
  }
  mReadEndpoint=mDataInterface.getEndpoint(1);
  Log.d(TAG,""String_Node_Str"" + mReadEndpoint.getDirection());
  mWriteEndpoint=mDataInterface.getEndpoint(0);
  Log.d(TAG,""String_Node_Str"" + mWriteEndpoint.getDirection());
}","@Override public void open() throws IOException {
  final int interfaceCount=mDevice.getInterfaceCount();
  Log.d(TAG,""String_Node_Str"" + interfaceCount);
  if (interfaceCount == 0) {
    throw new IOException(""String_Node_Str"");
  }
  Log.d(TAG,""String_Node_Str"");
  mControlInterface=mDevice.getInterface(0);
  Log.d(TAG,""String_Node_Str"" + mControlInterface);
  if (!mConnection.claimInterface(mControlInterface,true)) {
    throw new IOException(""String_Node_Str"");
  }
  final int controlEndpointCount=mControlInterface.getEndpointCount();
  if (controlEndpointCount == 0) {
    throw new IOException(""String_Node_Str"");
  }
  mControlEndpoint=mControlInterface.getEndpoint(0);
  Log.d(TAG,""String_Node_Str"" + mControlEndpoint.getDirection());
  Log.d(TAG,""String_Node_Str"");
  mDataInterface=mDevice.getInterface(1);
  Log.d(TAG,""String_Node_Str"" + mDataInterface);
  if (!mConnection.claimInterface(mDataInterface,true)) {
    throw new IOException(""String_Node_Str"");
  }
  final int dataEndpointCount=mDataInterface.getEndpointCount();
  if (dataEndpointCount < 2) {
    throw new IOException(""String_Node_Str"");
  }
  mReadEndpoint=mDataInterface.getEndpoint(1);
  Log.d(TAG,""String_Node_Str"" + mReadEndpoint.getDirection());
  mWriteEndpoint=mDataInterface.getEndpoint(0);
  Log.d(TAG,""String_Node_Str"" + mWriteEndpoint.getDirection());
}","The original code assumes the presence of interfaces and endpoints without validation, risking potential null pointer exceptions or index out of bounds errors. The fixed code adds explicit checks for interface and endpoint counts, ensuring that valid interfaces exist before accessing them and throwing meaningful exceptions if requirements are not met. These additional validation steps make the code more robust by preventing potential runtime errors and providing clearer error handling during USB device initialization."
94758,"@Override public void run(){
  Timber.d(""String_Node_Str"",compliant ? ""String_Node_Str"" : ""String_Node_Str"");
  try {
    final boolean currentCompliance=!sshLink.execute(""String_Node_Str"").trim().equals(""String_Node_Str"");
    if (currentCompliance != compliant) {
      final String response;
      if (compliant) {
        response=sshLink.execute(""String_Node_Str"");
      }
 else {
        response=sshLink.execute(""String_Node_Str"");
      }
      if (response.trim().equals(""String_Node_Str"")) {
        restartHostapdService();
        Timber.d(""String_Node_Str"");
        isEUTxPowerCompliant.set(compliant);
        postSuccessEvent(listener);
      }
 else {
        Timber.d(""String_Node_Str"",response);
        postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
      }
    }
  }
 catch (  IOException e) {
    Timber.e(e,""String_Node_Str"");
    postTimeoutEvent(listener);
  }
}","@Override public void run(){
  Timber.d(""String_Node_Str"",compliant ? ""String_Node_Str"" : ""String_Node_Str"");
  try {
    final boolean currentCompliance=!sshLink.execute(SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"").trim().equals(""String_Node_Str"");
    if (currentCompliance != compliant) {
      final String response;
      if (compliant) {
        response=sshLink.execute(SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"");
      }
 else {
        response=sshLink.execute(SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"");
      }
      if (response.trim().equals(""String_Node_Str"")) {
        restartController();
        Timber.d(""String_Node_Str"");
        isEUTxPowerCompliant.set(compliant);
        postSuccessEvent(listener);
      }
 else {
        Timber.d(""String_Node_Str"",response);
        postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
      }
    }
  }
 catch (  IOException e) {
    Timber.e(e,""String_Node_Str"");
    postTimeoutEvent(listener);
  }
}","The original code uses generic, hardcoded string literals for SSH command execution, lacking specificity and potentially leading to incorrect system interactions. The fixed code introduces a configuration path constant (SOLOLINK_SSID_CONFIG_PATH) and modifies method calls to use this path, ensuring more precise and context-aware command execution. These changes improve code reliability by providing a clear, configurable path for SSH commands and enhancing the overall robustness of the system configuration process."
94759,"public boolean updateSololinkWifi(CharSequence wifiSsid,CharSequence password){
  Timber.d(String.format(Locale.US,""String_Node_Str"",wifiSsid,password));
  try {
    String ssidUpdateResult=sshLink.execute(SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"" + wifiSsid);
    String passwordUpdateResult=sshLink.execute(SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"" + password);
    restartHostapdService();
    return true;
  }
 catch (  IOException e) {
    Timber.e(e,""String_Node_Str"");
    return false;
  }
}","public boolean updateSololinkWifi(CharSequence wifiSsid,CharSequence password){
  Timber.d(String.format(Locale.US,""String_Node_Str"",wifiSsid,password));
  try {
    String ssidUpdateResult=sshLink.execute(SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"" + wifiSsid);
    String passwordUpdateResult=sshLink.execute(SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"" + password);
    restartController();
    return true;
  }
 catch (  IOException e) {
    Timber.e(e,""String_Node_Str"");
    return false;
  }
}","The original code incorrectly used a generic method to restart networking services after WiFi configuration changes. The fixed code replaces `restartHostapdService()` with `restartController()`, which is likely a more appropriate and comprehensive method for resetting network configurations on the Sololink device. This change ensures a more reliable network reconfiguration process, potentially preventing connectivity issues and improving the overall stability of the WiFi update mechanism."
94760,"public void updateControllerMode(@SoloControllerMode.ControllerMode final int mode,final ICommandListener listener){
  postAsyncTask(new Runnable(){
    @Override public void run(){
      Timber.d(""String_Node_Str"",mode);
      try {
        final boolean supportControllerMode=doesSupportControllerMode();
        final String command=supportControllerMode ? ""String_Node_Str"" : ""String_Node_Str"";
        final String response;
switch (mode) {
case SoloControllerMode.MODE_1:
          response=sshLink.execute(String.format(Locale.US,command,mode));
        postSuccessEvent(listener);
      break;
case SoloControllerMode.MODE_2:
    response=sshLink.execute(String.format(Locale.US,command,mode));
  postSuccessEvent(listener);
break;
default :
response=""String_Node_Str"";
postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
break;
}
Timber.d(""String_Node_Str"",response);
if (supportControllerMode) {
setControllerMode(mode);
}
}
 catch (IOException e) {
Timber.e(e,""String_Node_Str"");
postTimeoutEvent(listener);
}
}
}
);
}","public void updateControllerMode(@SoloControllerMode.ControllerMode final int mode,final ICommandListener listener){
  postAsyncTask(new Runnable(){
    @Override public void run(){
      Timber.d(""String_Node_Str"",mode);
      try {
        final boolean supportControllerMode=doesSupportControllerMode();
        final String command=supportControllerMode ? SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"" : ""String_Node_Str"";
        final String response;
switch (mode) {
case SoloControllerMode.MODE_1:
          response=sshLink.execute(String.format(Locale.US,command,mode));
        postSuccessEvent(listener);
      break;
case SoloControllerMode.MODE_2:
    response=sshLink.execute(String.format(Locale.US,command,mode));
  postSuccessEvent(listener);
break;
default :
response=""String_Node_Str"";
postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
break;
}
Timber.d(""String_Node_Str"",response);
if (supportControllerMode) {
setControllerMode(mode);
}
}
 catch (IOException e) {
Timber.e(e,""String_Node_Str"");
postTimeoutEvent(listener);
}
}
}
);
}","The original code lacked a proper command path configuration for SSH link execution, which could lead to incorrect or incomplete command targeting. The fixed code introduces SOLOLINK_SSID_CONFIG_PATH in the command string, ensuring a more precise and context-specific command path for different controller modes. This modification improves the reliability and accuracy of SSH command execution, providing a more robust method for updating controller modes with proper path resolution."
94761,"public void setEUTxPowerCompliance(final boolean compliant,final ICommandListener listener){
  postAsyncTask(new Runnable(){
    @Override public void run(){
      Timber.d(""String_Node_Str"",compliant ? ""String_Node_Str"" : ""String_Node_Str"");
      try {
        final boolean currentCompliance=!sshLink.execute(""String_Node_Str"").trim().equals(""String_Node_Str"");
        if (currentCompliance != compliant) {
          final String response;
          if (compliant) {
            response=sshLink.execute(""String_Node_Str"");
          }
 else {
            response=sshLink.execute(""String_Node_Str"");
          }
          if (response.trim().equals(""String_Node_Str"")) {
            restartHostapdService();
            Timber.d(""String_Node_Str"");
            isEUTxPowerCompliant.set(compliant);
            postSuccessEvent(listener);
          }
 else {
            Timber.d(""String_Node_Str"",response);
            postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
          }
        }
      }
 catch (      IOException e) {
        Timber.e(e,""String_Node_Str"");
        postTimeoutEvent(listener);
      }
    }
  }
);
}","public void setEUTxPowerCompliance(final boolean compliant,final ICommandListener listener){
  postAsyncTask(new Runnable(){
    @Override public void run(){
      Timber.d(""String_Node_Str"",compliant ? ""String_Node_Str"" : ""String_Node_Str"");
      try {
        final boolean currentCompliance=!sshLink.execute(SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"").trim().equals(""String_Node_Str"");
        if (currentCompliance != compliant) {
          final String response;
          if (compliant) {
            response=sshLink.execute(SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"");
          }
 else {
            response=sshLink.execute(SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"");
          }
          if (response.trim().equals(""String_Node_Str"")) {
            restartController();
            Timber.d(""String_Node_Str"");
            isEUTxPowerCompliant.set(compliant);
            postSuccessEvent(listener);
          }
 else {
            Timber.d(""String_Node_Str"",response);
            postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
          }
        }
      }
 catch (      IOException e) {
        Timber.e(e,""String_Node_Str"");
        postTimeoutEvent(listener);
      }
    }
  }
);
}","The original code used generic, hardcoded string placeholders without proper context or configuration paths for SSH command execution. The fixed code introduces `SOLOLINK_SSID_CONFIG_PATH` to provide a complete, context-specific path for SSH commands, replacing ambiguous string literals with meaningful configuration references. These changes improve code reliability by ensuring precise SSH command targeting and reducing potential errors from incomplete or generic command strings."
94762,"public void updateControllerUnit(@SoloControllerUnits.ControllerUnit final String unit,final ICommandListener listener){
  postAsyncTask(new Runnable(){
    @Override public void run(){
      final boolean supportControllerMode=doesSupportControllerMode();
      if (!supportControllerMode) {
        postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
        return;
      }
      Timber.d(""String_Node_Str"",unit);
      try {
        final String command=""String_Node_Str"";
        final String response=sshLink.execute(String.format(Locale.US,command,unit));
        Timber.d(""String_Node_Str"",response);
        postSuccessEvent(listener);
        setControllerUnit(unit);
      }
 catch (      IOException e) {
        Timber.e(e,""String_Node_Str"");
        postTimeoutEvent(listener);
      }
    }
  }
);
}","public void updateControllerUnit(@SoloControllerUnits.ControllerUnit final String unit,final ICommandListener listener){
  postAsyncTask(new Runnable(){
    @Override public void run(){
      final boolean supportControllerMode=doesSupportControllerMode();
      if (!supportControllerMode) {
        postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
        return;
      }
      Timber.d(""String_Node_Str"",unit);
      try {
        final String command=SOLOLINK_SSID_CONFIG_PATH + ""String_Node_Str"";
        final String response=sshLink.execute(String.format(Locale.US,command,unit));
        Timber.d(""String_Node_Str"",response);
        postSuccessEvent(listener);
        setControllerUnit(unit);
      }
 catch (      IOException e) {
        Timber.e(e,""String_Node_Str"");
        postTimeoutEvent(listener);
      }
    }
  }
);
}","The original code used an incomplete command string without a proper path, potentially leading to incorrect SSH command execution. The fixed code prepends `SOLOLINK_SSID_CONFIG_PATH` to the command string, ensuring the correct file path is used for the SSH command. This modification enhances the reliability and accuracy of the controller unit update process by providing a complete and correct file path for the SSH link execution."
94763,"private void destroyAutopilot(){
  if (drone == null)   return;
  drone.removeDroneListener(this);
  drone.getParameters().setParameterListener(null);
  drone.getMagnetometerCalibration().setListener(null);
  drone=null;
}","private void destroyAutopilot(){
  if (drone == null)   return;
  drone.removeDroneListener(this);
  final Parameters parameters=drone.getParameters();
  if (parameters != null)   parameters.setParameterListener(null);
  final MagnetometerCalibrationImpl magnetometer=drone.getMagnetometerCalibration();
  if (magnetometer != null)   magnetometer.setListener(null);
  drone=null;
}","The original code assumes non-null returned objects from getParameters() and getMagnetometerCalibration(), which could lead to potential NullPointerExceptions. The fixed code introduces null checks before invoking setParameterListener() and setListener(), ensuring safe method calls by first storing references and verifying their non-null status. These defensive programming techniques prevent unexpected runtime errors and improve the method's robustness by gracefully handling scenarios where dependent objects might be null."
94764,"@Override public int read(byte[] dest,int timeoutMillis) throws IOException {
  final UsbEndpoint endpoint=mDevice.getInterface(0).getEndpoint(0);
  if (ENABLE_ASYNC_READS) {
    final int readAmt;
synchronized (mReadBufferLock) {
      readAmt=Math.min(dest.length,mReadBuffer.length);
    }
    final UsbRequest request=new UsbRequest();
    request.initialize(mConnection,endpoint);
    final ByteBuffer buf=ByteBuffer.wrap(dest);
    if (!request.queue(buf,readAmt)) {
      throw new IOException(""String_Node_Str"");
    }
    final UsbRequest response=mConnection.requestWait();
    if (response == null) {
      throw new IOException(""String_Node_Str"");
    }
    final int payloadBytesRead=buf.position() - MODEM_STATUS_HEADER_LENGTH;
    if (payloadBytesRead > 0) {
      Log.d(TAG,HexDump.dumpHexString(dest,0,Math.min(32,dest.length)));
      return payloadBytesRead;
    }
 else {
      return 0;
    }
  }
 else {
    final int totalBytesRead;
synchronized (mReadBufferLock) {
      final int readAmt=Math.min(dest.length,mReadBuffer.length);
      totalBytesRead=mConnection.bulkTransfer(endpoint,mReadBuffer,readAmt,timeoutMillis);
      if (totalBytesRead < MODEM_STATUS_HEADER_LENGTH) {
        throw new IOException(""String_Node_Str"" + MODEM_STATUS_HEADER_LENGTH + ""String_Node_Str"");
      }
      return filterStatusBytes(mReadBuffer,dest,totalBytesRead,endpoint.getMaxPacketSize());
    }
  }
}","@Override public int read(byte[] dest,int timeoutMillis) throws IOException {
  final int interfaceCount=mDevice.getInterfaceCount();
  if (interfaceCount == 0)   throw new IOException(""String_Node_Str"");
  final UsbInterface usbInterface=mDevice.getInterface(0);
  final int endpointCount=usbInterface.getEndpointCount();
  if (endpointCount == 0)   throw new IOException(""String_Node_Str"");
  final UsbEndpoint endpoint=usbInterface.getEndpoint(0);
  if (ENABLE_ASYNC_READS) {
    final int readAmt;
synchronized (mReadBufferLock) {
      readAmt=Math.min(dest.length,mReadBuffer.length);
    }
    final UsbRequest request=new UsbRequest();
    request.initialize(mConnection,endpoint);
    final ByteBuffer buf=ByteBuffer.wrap(dest);
    if (!request.queue(buf,readAmt)) {
      throw new IOException(""String_Node_Str"");
    }
    final UsbRequest response=mConnection.requestWait();
    if (response == null) {
      throw new IOException(""String_Node_Str"");
    }
    final int payloadBytesRead=buf.position() - MODEM_STATUS_HEADER_LENGTH;
    if (payloadBytesRead > 0) {
      Log.d(TAG,HexDump.dumpHexString(dest,0,Math.min(32,dest.length)));
      return payloadBytesRead;
    }
 else {
      return 0;
    }
  }
 else {
    final int totalBytesRead;
synchronized (mReadBufferLock) {
      final int readAmt=Math.min(dest.length,mReadBuffer.length);
      totalBytesRead=mConnection.bulkTransfer(endpoint,mReadBuffer,readAmt,timeoutMillis);
      if (totalBytesRead < MODEM_STATUS_HEADER_LENGTH) {
        throw new IOException(""String_Node_Str"" + MODEM_STATUS_HEADER_LENGTH + ""String_Node_Str"");
      }
      return filterStatusBytes(mReadBuffer,dest,totalBytesRead,endpoint.getMaxPacketSize());
    }
  }
}","The original code directly accessed the first USB interface and endpoint without verifying their availability, risking potential null pointer exceptions or index out of bounds errors. The fixed code adds explicit checks for interface and endpoint counts, ensuring safe access by throwing descriptive IOException if no interfaces or endpoints exist. These defensive programming techniques prevent potential runtime crashes and provide more robust USB device interaction by validating device configuration before attempting data transfer."
94765,"@Override public DroneAttribute getAttribute(String attributeType){
  if (drone == null)   return null;
switch (attributeType) {
case AttributeType.FOLLOW_STATE:
    return CommonApiUtils.getFollowState(followMe);
case AttributeType.RETURN_TO_ME_STATE:
  return returnToMe == null ? new ReturnToMeState() : returnToMe.getState();
case SoloAttributes.SOLO_STATE:
return SoloApiUtils.getSoloLinkState(this);
case SoloAttributes.SOLO_GOPRO_STATE:
return soloComp.getGoproState();
default :
final DroneAttribute droneAttribute=drone.getAttribute(attributeType);
if (drone instanceof ArduSolo && isCompanionComputerEnabled() && droneAttribute instanceof State) {
final State droneState=(State)droneAttribute;
droneState.addToVehicleUid(""String_Node_Str"",soloComp.getSoloMacAddress());
droneState.addToVehicleUid(""String_Node_Str"",soloComp.getControllerMacAddress());
}
return droneAttribute;
}
}","@Override public DroneAttribute getAttribute(String attributeType){
  if (drone == null)   return null;
switch (attributeType) {
case AttributeType.FOLLOW_STATE:
    return CommonApiUtils.getFollowState(followMe);
case AttributeType.RETURN_TO_ME_STATE:
  return returnToMe == null ? new ReturnToMeState() : returnToMe.getState();
case SoloAttributes.SOLO_STATE:
return SoloApiUtils.getSoloLinkState(this);
case SoloAttributes.SOLO_GOPRO_STATE:
return soloComp.getGoproState();
default :
final DroneAttribute droneAttribute=drone.getAttribute(attributeType);
if (drone instanceof ArduSolo && droneAttribute instanceof State) {
final State droneState=(State)droneAttribute;
droneState.addToVehicleUid(""String_Node_Str"",soloComp.getSoloMacAddress());
droneState.addToVehicleUid(""String_Node_Str"",soloComp.getControllerMacAddress());
}
return droneAttribute;
}
}","The original code incorrectly added MAC addresses only if the companion computer was enabled, potentially missing important state information for some drone configurations. The fixed code removes the `isCompanionComputerEnabled()` condition, ensuring that MAC addresses are added to the state for ArduSolo drones regardless of companion computer status. This modification guarantees consistent state tracking and identification for Solo drones, improving the reliability of drone attribute retrieval."
94766,"VideoManager(Context context,Handler handler,ExecutorService asyncExecutor){
  super(context,new UdpConnection(handler,ControllerLinkManager.ARTOO_UDP_PORT,UDP_BUFFER_SIZE,true,42),handler,asyncExecutor);
  this.mediaCodecManager=new MediaCodecManager(handler);
}","VideoManager(Context context,Handler handler,ExecutorService asyncExecutor){
  super(context,new UdpConnection(handler,ControllerLinkManager.ARTOO_UDP_PORT,UDP_BUFFER_SIZE,true,16),handler,asyncExecutor);
  this.mediaCodecManager=new MediaCodecManager(handler);
}","The buggy code used an incorrect parameter value of 42 in the UdpConnection constructor, which likely caused communication or synchronization issues. The fixed code changes this parameter to 16, which appears to be the correct configuration for establishing a proper UDP connection with the specified protocol. This modification ensures more reliable and accurate network communication for the VideoManager, potentially resolving potential connection or data transmission problems."
94767,"public void onVehicleTypeReceived(FirmwareType type){
  if (drone != null) {
    return;
  }
  final DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
  final DroneInterfaces.Handler dpHandler=new DroneInterfaces.Handler(){
    @Override public void removeCallbacks(    Runnable thread){
      handler.removeCallbacks(thread);
    }
    @Override public void post(    Runnable thread){
      handler.post(thread);
    }
    @Override public void postDelayed(    Runnable thread,    long timeout){
      handler.postDelayed(thread,timeout);
    }
  }
;
switch (type) {
case ARDU_COPTER:
    if (isCompanionComputerEnabled()) {
      Timber.i(""String_Node_Str"");
      this.drone=new ArduSolo(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),this,this);
    }
 else {
      Timber.i(""String_Node_Str"");
      this.drone=new ArduCopter(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),this,this);
    }
  break;
case ARDU_SOLO:
Timber.i(""String_Node_Str"");
this.drone=new ArduSolo(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),this,this);
break;
case ARDU_PLANE:
Timber.i(""String_Node_Str"");
this.drone=new ArduPlane(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),this,this);
break;
case ARDU_ROVER:
Timber.i(""String_Node_Str"");
this.drone=new ArduRover(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),this,this);
break;
case PX4_NATIVE:
Timber.i(""String_Node_Str"");
this.drone=new Px4Native(dpHandler,mavClient,new AndroidApWarningParser(),this);
break;
}
this.drone.getStreamRates().setRates(dpPrefs.getRates());
this.followMe=new Follow(this,handler,new FusedLocation(context,handler));
this.returnToMe=new ReturnToMe(this,new FusedLocation(context,handler,LocationRequest.PRIORITY_HIGH_ACCURACY,1000L,1000L,ReturnToMe.UPDATE_MINIMAL_DISPLACEMENT),this);
drone.addDroneListener(this);
drone.getParameters().setParameterListener(this);
drone.getMagnetometerCalibration().setListener(this);
}","public void onVehicleTypeReceived(FirmwareType type){
  if (drone != null) {
    return;
  }
  final DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
  final DroneInterfaces.Handler dpHandler=new DroneInterfaces.Handler(){
    @Override public void removeCallbacks(    Runnable thread){
      handler.removeCallbacks(thread);
    }
    @Override public void post(    Runnable thread){
      handler.post(thread);
    }
    @Override public void postDelayed(    Runnable thread,    long timeout){
      handler.postDelayed(thread,timeout);
    }
  }
;
switch (type) {
case ARDU_COPTER:
    if (isCompanionComputerEnabled()) {
      Timber.i(""String_Node_Str"");
      this.drone=new ArduSolo(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),this,this);
    }
 else {
      Timber.i(""String_Node_Str"");
      this.drone=new ArduCopter(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),this,this);
    }
  break;
case ARDU_SOLO:
Timber.i(""String_Node_Str"");
this.drone=new ArduSolo(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),this,this);
break;
case ARDU_PLANE:
Timber.i(""String_Node_Str"");
this.drone=new ArduPlane(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),this,this);
break;
case ARDU_ROVER:
Timber.i(""String_Node_Str"");
this.drone=new ArduRover(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),this,this);
break;
case PX4_NATIVE:
Timber.i(""String_Node_Str"");
this.drone=new Px4Native(dpHandler,mavClient,new AndroidApWarningParser(),this);
break;
}
this.followMe=new Follow(this,handler,new FusedLocation(context,handler));
this.returnToMe=new ReturnToMe(this,new FusedLocation(context,handler,LocationRequest.PRIORITY_HIGH_ACCURACY,1000L,1000L,ReturnToMe.UPDATE_MINIMAL_DISPLACEMENT),this);
final StreamRates streamRates=drone.getStreamRates();
if (streamRates != null) {
streamRates.setRates(dpPrefs.getRates());
}
drone.addDroneListener(this);
final Parameters parameters=drone.getParameters();
if (parameters != null) {
parameters.setParameterListener(this);
}
final MagnetometerCalibrationImpl magnetometer=drone.getMagnetometerCalibration();
if (magnetometer != null) {
magnetometer.setListener(this);
}
}","The original code lacked null checks before accessing drone-related objects, which could lead to potential NullPointerExceptions during method calls. The fixed code adds null checks for `drone.getStreamRates()`, `drone.getParameters()`, and `drone.getMagnetometerCalibration()` before invoking methods on these objects. These defensive programming techniques ensure robust error handling and prevent unexpected runtime crashes by gracefully managing scenarios where drone-related components might be uninitialized."
94768,"private void setMacAddress(String trimmedResponse){
  Timber.i(""String_Node_Str"" + trimmedResponse);
  macAddress.set(trimmedResponse);
  if (linkListener != null) {
    linkListener.onMacAddressUpdated();
  }
}","private void setMacAddress(String trimmedResponse){
  Timber.i(""String_Node_Str"",trimmedResponse);
  macAddress.set(trimmedResponse);
  if (linkListener != null) {
    linkListener.onMacAddressUpdated();
  }
}","The original Timber.i() logging method incorrectly concatenated the tag and message as a single string, which can lead to improper log formatting and potential information loss. In the fixed code, the logging method is corrected by passing the tag and message as separate arguments, ensuring proper log entry with a distinct tag and message. This change improves log readability, maintains correct log method usage, and helps in more accurate debugging and tracking of the application's behavior."
94769,"/** 
 * @deprecated Use {@link ControlApi#pauseAtCurrentLocation()} instead.
 */
public void pauseAtCurrentLocation(){
  ControlApi.getApi(this).pauseAtCurrentLocation();
}","/** 
 * @deprecated Use {@link ControlApi#pauseAtCurrentLocation(AbstractCommandListener)} instead.
 */
public void pauseAtCurrentLocation(){
  ControlApi.getApi(this).pauseAtCurrentLocation(null);
}","The original code was missing a required parameter when calling `pauseAtCurrentLocation()`, which likely caused a compilation error or runtime exception. The fixed code passes `null` as the required `AbstractCommandListener` parameter, ensuring the method call is syntactically correct. By adding the missing parameter, the code now compiles and can be invoked without errors, maintaining the method's intended functionality."
94770,"/** 
 * @deprecated Use {@link ControlApi#goTo(LatLong,boolean)} instead.
 */
public void sendGuidedPoint(LatLong point,boolean force){
  ControlApi.getApi(this).goTo(point,force);
}","/** 
 * @deprecated Use {@link ControlApi#goTo(LatLong,boolean,AbstractCommandListener)} instead.
 */
public void sendGuidedPoint(LatLong point,boolean force){
  ControlApi.getApi(this).goTo(point,force,null);
}","The original code was incorrect because it did not include the required `AbstractCommandListener` parameter when calling the `goTo` method, which could lead to potential errors or incomplete method invocation. The fixed code adds a `null` argument for the listener, ensuring compatibility with the updated method signature and allowing the call to proceed without breaking the existing implementation. By providing the missing parameter, the code now correctly matches the API's expected method signature and maintains the intended functionality of sending a guided point."
94771,"/** 
 * @deprecated Use {@link ControlApi#takeoff(double)} instead.
 */
public void doGuidedTakeoff(double altitude){
  ControlApi.getApi(this).takeoff(altitude);
}","/** 
 * @deprecated Use {@link ControlApi#takeoff(double,AbstractCommandListener)} instead.
 */
public void doGuidedTakeoff(double altitude){
  ControlApi.getApi(this).takeoff(altitude,null);
}","The original code omitted a required command listener parameter when calling the takeoff method, which would likely cause a compilation error or runtime exception. The fixed code adds a null listener as the second argument, satisfying the method's signature and allowing the takeoff operation to proceed. By explicitly handling the listener parameter, the code becomes more robust and compatible with the current API implementation."
94772,"/** 
 * @deprecated Use {@link VehicleApi#pauseAtCurrentLocation()} instead.
 */
public void pauseAtCurrentLocation(){
  VehicleApi.getApi(this).pauseAtCurrentLocation();
}","/** 
 * @deprecated Use {@link ControlApi#pauseAtCurrentLocation()} instead.
 */
public void pauseAtCurrentLocation(){
  ControlApi.getApi(this).pauseAtCurrentLocation();
}","The original code incorrectly references VehicleApi for pausing at the current location, which is likely an outdated or incorrect API method. The fixed code replaces VehicleApi with ControlApi, suggesting a more appropriate and current API for controlling vehicle operations. By using the correct API method, the code now provides a more accurate and reliable way to pause the vehicle's current location."
94773,"/** 
 * @deprecated Use {@link VehicleApi#sendGuidedPoint(LatLong,boolean)} instead.
 */
public void sendGuidedPoint(LatLong point,boolean force){
  VehicleApi.getApi(this).sendGuidedPoint(point,force);
}","/** 
 * @deprecated Use {@link ControlApi#goTo(LatLong,boolean)} instead.
 */
public void sendGuidedPoint(LatLong point,boolean force){
  ControlApi.getApi(this).goTo(point,force);
}","The original code incorrectly used VehicleApi to send a guided point, which was likely an outdated or incorrect API method. The fixed code replaces VehicleApi with ControlApi's goTo method, which is the recommended approach for navigating to a specific geographic point. This change ensures more accurate and up-to-date functionality for guiding a vehicle to a designated location."
94774,"/** 
 * @deprecated Use {@link VehicleApi#takeoff(double)} instead.
 */
public void doGuidedTakeoff(double altitude){
  VehicleApi.getApi(this).takeoff(altitude);
}","/** 
 * @deprecated Use {@link ControlApi#takeoff(double)} instead.
 */
public void doGuidedTakeoff(double altitude){
  ControlApi.getApi(this).takeoff(altitude);
}","The original code incorrectly uses `VehicleApi.getApi()` for takeoff, which is likely an outdated or incorrect API method. The fixed code changes the API call to `ControlApi.getApi()`, which represents the correct and current method for performing a takeoff operation. This modification ensures that the takeoff functionality is implemented using the right API, improving code accuracy and maintaining proper drone control logic."
94775,"/** 
 * @deprecated Use {@link VehicleApi#setGuidedAltitude(double)} instead.
 */
public void setGuidedAltitude(double altitude){
  VehicleApi.getApi(this).setGuidedAltitude(altitude);
}","/** 
 * @deprecated Use {@link ControlApi#climbTo(double)} instead.
 */
public void setGuidedAltitude(double altitude){
  ControlApi.getApi(this).climbTo(altitude);
}","The original code incorrectly used VehicleApi to set guided altitude, which is likely an outdated or incorrect API method. The fixed code replaces VehicleApi with ControlApi and uses the climbTo() method, which is the recommended approach for altitude control according to the deprecation notice. This change ensures more accurate and up-to-date altitude setting by utilizing the correct API and method for vehicle altitude management."
94776,"public void onArmButtonTap(View view){
  State vehicleState=this.drone.getAttribute(AttributeType.STATE);
  if (vehicleState.isFlying()) {
    VehicleApi.getApi(this.drone).setVehicleMode(VehicleMode.COPTER_LAND,new SimpleCommandListener(){
      @Override public void onError(      int executionError){
        alertUser(""String_Node_Str"");
      }
      @Override public void onTimeout(){
        alertUser(""String_Node_Str"");
      }
    }
);
  }
 else   if (vehicleState.isArmed()) {
    VehicleApi.getApi(this.drone).takeoff(10,new AbstractCommandListener(){
      @Override public void onSuccess(){
        alertUser(""String_Node_Str"");
      }
      @Override public void onError(      int i){
        alertUser(""String_Node_Str"");
      }
      @Override public void onTimeout(){
        alertUser(""String_Node_Str"");
      }
    }
);
  }
 else   if (!vehicleState.isConnected()) {
    alertUser(""String_Node_Str"");
  }
 else {
    VehicleApi.getApi(this.drone).arm(true,false,new SimpleCommandListener(){
      @Override public void onError(      int executionError){
        alertUser(""String_Node_Str"");
      }
      @Override public void onTimeout(){
        alertUser(""String_Node_Str"");
      }
    }
);
  }
}","public void onArmButtonTap(View view){
  State vehicleState=this.drone.getAttribute(AttributeType.STATE);
  if (vehicleState.isFlying()) {
    VehicleApi.getApi(this.drone).setVehicleMode(VehicleMode.COPTER_LAND,new SimpleCommandListener(){
      @Override public void onError(      int executionError){
        alertUser(""String_Node_Str"");
      }
      @Override public void onTimeout(){
        alertUser(""String_Node_Str"");
      }
    }
);
  }
 else   if (vehicleState.isArmed()) {
    ControlApi.getApi(this.drone).takeoff(10,new AbstractCommandListener(){
      @Override public void onSuccess(){
        alertUser(""String_Node_Str"");
      }
      @Override public void onError(      int i){
        alertUser(""String_Node_Str"");
      }
      @Override public void onTimeout(){
        alertUser(""String_Node_Str"");
      }
    }
);
  }
 else   if (!vehicleState.isConnected()) {
    alertUser(""String_Node_Str"");
  }
 else {
    VehicleApi.getApi(this.drone).arm(true,false,new SimpleCommandListener(){
      @Override public void onError(      int executionError){
        alertUser(""String_Node_Str"");
      }
      @Override public void onTimeout(){
        alertUser(""String_Node_Str"");
      }
    }
);
  }
}","The original code incorrectly used VehicleApi.getApi() for takeoff, which is not the correct API method for initiating drone takeoff. In the fixed code, ControlApi.getApi() is used instead, which is the proper API for controlling drone flight actions like takeoff. This change ensures correct API usage, improving the reliability and accuracy of drone flight control operations."
94777,"public boolean areVersionsSet(){
  return !TextUtils.isEmpty(vehicleVersion.get()) && !TextUtils.isEmpty(pixhawkVersion.get()) && !TextUtils.isEmpty(gimbalVersion.get());
}","public boolean areVersionsSet(){
  return !TextUtils.isEmpty(vehicleVersion.get()) && !TextUtils.isEmpty(pixhawkVersion.get());
}","The original code unnecessarily checked the gimbal version's emptiness, potentially causing redundant validation in the version checking process. The fixed code removes the third condition, focusing only on verifying the vehicle and pixhawk versions, which are likely the critical components for the intended functionality. By simplifying the check, the code becomes more focused and avoids checking an irrelevant version parameter."
94778,"public int getControllerMode(){
  return controllerMode;
}","@ControllerMode public int getControllerMode(){
  return controllerMode;
}","The original code lacks a proper annotation to define the return type's semantics for the controller mode method. The fixed code adds the `@ControllerMode` annotation, which explicitly specifies the type and purpose of the returned integer value, providing clearer type safety and intent. This annotation helps improve code readability, enables better static analysis, and allows tools and other developers to understand the precise nature of the method's return type."
94779,"protected SoloState(Parcel in){
  this.wifiSsid=in.readString();
  this.wifiPassword=in.readString();
  this.controllerVersion=in.readString();
  this.controllerMode=in.readInt();
  this.controllerFirmwareVersion=in.readString();
  this.vehicleVersion=in.readString();
  this.autopilotVersion=in.readString();
  this.isEUTxPowerCompliant=in.readByte() != 0;
  final int buttonCount=in.readInt();
  this.buttonSettings=new SparseArray<>(buttonCount);
  for (int i=0; i < buttonCount; i++) {
    final int dataSize=in.readInt();
    if (dataSize == 0)     continue;
    final ByteBuffer dataBuffer=ByteBuffer.allocate(dataSize);
    in.readByteArray(dataBuffer.array());
    final SoloButtonSetting button=(SoloButtonSetting)TLVMessageParser.parseTLVPacket(dataBuffer);
    buttonSettings.put(button.getButton(),button);
  }
  this.gimbalVersion=in.readString();
}","protected SoloState(Parcel in){
  this.wifiSsid=in.readString();
  this.wifiPassword=in.readString();
  this.controllerVersion=in.readString();
  this.controllerFirmwareVersion=in.readString();
  this.vehicleVersion=in.readString();
  this.autopilotVersion=in.readString();
  this.isEUTxPowerCompliant=in.readByte() != 0;
  final int buttonCount=in.readInt();
  this.buttonSettings=new SparseArray<>(buttonCount);
  for (int i=0; i < buttonCount; i++) {
    final int dataSize=in.readInt();
    if (dataSize == 0)     continue;
    final ByteBuffer dataBuffer=ByteBuffer.allocate(dataSize);
    in.readByteArray(dataBuffer.array());
    final SoloButtonSetting button=(SoloButtonSetting)TLVMessageParser.parseTLVPacket(dataBuffer);
    buttonSettings.put(button.getButton(),button);
  }
  this.gimbalVersion=in.readString();
  @ControllerMode final int tempMode=in.readInt();
  this.controllerMode=tempMode;
}","The original code incorrectly omitted reading the `controllerMode` integer from the Parcel, potentially causing data loss during deserialization. In the fixed code, the `controllerMode` is explicitly read using a temporary variable with the `@ControllerMode` annotation, ensuring type safety and complete data reconstruction. This modification guarantees that all state information is properly restored during object recreation from a Parcel, preventing potential runtime errors or incomplete state initialization."
94780,"@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeString(this.wifiSsid);
  dest.writeString(this.wifiPassword);
  dest.writeString(this.controllerVersion);
  dest.writeInt(this.controllerMode);
  dest.writeString(this.controllerFirmwareVersion);
  dest.writeString(this.vehicleVersion);
  dest.writeString(this.autopilotVersion);
  dest.writeByte(isEUTxPowerCompliant ? (byte)1 : (byte)0);
  final int buttonCount=buttonSettings.size();
  dest.writeInt(buttonCount);
  for (int i=0; i < buttonCount; i++) {
    final SoloButtonSetting buttonSetting=buttonSettings.valueAt(i);
    if (buttonSetting == null) {
      dest.writeInt(0);
      continue;
    }
    final byte[] buttonData=buttonSetting.toBytes();
    dest.writeInt(buttonData.length);
    dest.writeByteArray(buttonData);
  }
  dest.writeString(this.gimbalVersion);
}","@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeString(this.wifiSsid);
  dest.writeString(this.wifiPassword);
  dest.writeString(this.controllerVersion);
  dest.writeString(this.controllerFirmwareVersion);
  dest.writeString(this.vehicleVersion);
  dest.writeString(this.autopilotVersion);
  dest.writeByte(isEUTxPowerCompliant ? (byte)1 : (byte)0);
  final int buttonCount=buttonSettings.size();
  dest.writeInt(buttonCount);
  for (int i=0; i < buttonCount; i++) {
    final SoloButtonSetting buttonSetting=buttonSettings.valueAt(i);
    if (buttonSetting == null) {
      dest.writeInt(0);
      continue;
    }
    final byte[] buttonData=buttonSetting.toBytes();
    dest.writeInt(buttonData.length);
    dest.writeByteArray(buttonData);
  }
  dest.writeString(this.gimbalVersion);
  dest.writeInt(this.controllerMode);
}","The original code incorrectly wrote the `controllerMode` integer after writing the versions and button settings, which could lead to incorrect parcelization and potential data loss during object transmission. The fixed code moves the `dest.writeInt(this.controllerMode)` to the end of the method, ensuring all data is consistently written in the correct order for proper serialization. This change guarantees reliable data reconstruction when the parcel is read back, preventing potential runtime errors or data inconsistencies during object transfer."
94781,"@Override public void onControllerModeUpdated(){
  final Bundle eventInfo=new Bundle();
  eventInfo.putInt(SoloEventExtras.EXTRA_SOLO_CONTROLLER_MODE,soloComp.getControllerMode());
  notifyDroneAttributeEvent(SoloEvents.SOLO_CONTROLLER_MODE,eventInfo,true);
}","@Override public void onControllerModeUpdated(){
  final Bundle eventInfo=new Bundle();
  eventInfo.putInt(SoloEventExtras.EXTRA_SOLO_CONTROLLER_MODE,soloComp.getControllerMode());
  notifyDroneAttributeEvent(SoloEvents.SOLO_CONTROLLER_MODE_UPDATED,eventInfo,true);
}","The original code used an incorrect event identifier `SoloEvents.SOLO_CONTROLLER_MODE`, which may not accurately represent the controller mode update event. The fixed code replaces this with `SoloEvents.SOLO_CONTROLLER_MODE_UPDATED`, a more precise and descriptive event name that better reflects the specific action of updating the controller mode. This change improves code clarity and ensures more accurate event tracking and potential downstream event handling."
94782,"public int getControllerMode(){
  return artooMgr.getControllerMode();
}","@SoloControllerMode.ControllerMode public int getControllerMode(){
  return artooMgr.getControllerMode();
}","The original code lacks type safety and doesn't explicitly define the return type's constraints for the controller mode. The fixed code adds the @SoloControllerMode.ControllerMode annotation, which ensures type checking and restricts the return value to valid controller mode integers defined in the SoloControllerMode enum. By applying this annotation, the code gains stronger type safety, preventing potential runtime errors and improving overall method reliability."
94783,"private void loadCurrentControllerMode(){
  postAsyncTask(getArtooMode());
}","private void loadCurrentControllerMode(){
  postAsyncTask(artooModeRetriever);
}","The original code calls `getArtooMode()` directly, which might be a method that synchronously retrieves the mode and blocks the thread. The fixed code uses `artooModeRetriever`, likely an asynchronous task or callback mechanism designed to fetch the mode without blocking. This change improves performance by ensuring non-blocking mode retrieval and potentially implementing a more efficient, event-driven approach to obtaining the current controller mode."
94784,"public static SoloState getSoloLinkState(DroneManager droneManager){
  if (droneManager == null || !droneManager.isCompanionComputerEnabled())   return null;
  final SoloComp soloComp=droneManager.getSoloComp();
  final Pair<String,String> wifiSettings=soloComp.getWifiSettings();
  return new SoloState(soloComp.getAutopilotVersion(),soloComp.getControllerFirmwareVersion(),soloComp.getControllerVersion(),soloComp.getControllerMode(),soloComp.getVehicleVersion(),wifiSettings.second,wifiSettings.first,soloComp.isEUTxPowerCompliant(),soloComp.getButtonSettings(),soloComp.getGimbalVersion());
}","public static SoloState getSoloLinkState(DroneManager droneManager){
  if (droneManager == null || !droneManager.isCompanionComputerEnabled())   return null;
  final SoloComp soloComp=droneManager.getSoloComp();
  final Pair<String,String> wifiSettings=soloComp.getWifiSettings();
  return new SoloState(soloComp.getAutopilotVersion(),soloComp.getControllerFirmwareVersion(),soloComp.getControllerVersion(),soloComp.getVehicleVersion(),wifiSettings.second,wifiSettings.first,soloComp.isEUTxPowerCompliant(),soloComp.getButtonSettings(),soloComp.getGimbalVersion(),soloComp.getControllerMode());
}","The original code incorrectly passed the controller mode parameter in the wrong order when constructing the SoloState object. In the fixed code, the `getControllerMode()` parameter is moved to the last position of the constructor, matching the correct parameter sequence expected by the SoloState class. This correction ensures that the SoloState object is created with the right parameter order, preventing potential runtime errors and maintaining proper initialization of the object's state."
94785,"@Override public void onDroneEvent(DroneInterfaces.DroneEventsType event,MavLinkDrone drone){
switch (event) {
case HEARTBEAT_FIRST:
case CONNECTED:
    if (isCompanionComputerEnabled()) {
      if (!soloComp.isConnected()) {
        soloComp.start();
        return;
      }
 else {
        soloComp.refreshState();
      }
    }
  event=DroneInterfaces.DroneEventsType.CONNECTED;
break;
case HEARTBEAT_TIMEOUT:
if (isCompanionComputerEnabled() && soloComp.isConnected()) {
handler.postDelayed(disconnectSoloCompTask,HeartBeat.HEARTBEAT_NORMAL_TIMEOUT);
}
break;
case HEARTBEAT_RESTORED:
if (isCompanionComputerEnabled()) {
handler.removeCallbacks(disconnectSoloCompTask);
if (!soloComp.isConnected()) soloComp.start();
 else {
soloComp.refreshState();
}
}
break;
case DISCONNECTED:
if (isCompanionComputerEnabled()) {
if (soloComp.isConnected()) {
soloComp.stop();
return;
}
}
break;
}
if (connectedApps.isEmpty()) return;
for (DroneEventsListener droneEventsListener : connectedApps.values()) {
droneEventsListener.onDroneEvent(event,drone);
}
}","@Override public void onDroneEvent(DroneInterfaces.DroneEventsType event,MavLinkDrone drone){
switch (event) {
case HEARTBEAT_FIRST:
case CONNECTED:
    if (isCompanionComputerEnabled()) {
      if (!soloComp.isConnected()) {
        soloComp.start();
        return;
      }
    }
  event=DroneInterfaces.DroneEventsType.CONNECTED;
break;
case HEARTBEAT_TIMEOUT:
if (isCompanionComputerEnabled() && soloComp.isConnected()) {
handler.postDelayed(disconnectSoloCompTask,HeartBeat.HEARTBEAT_NORMAL_TIMEOUT);
}
break;
case HEARTBEAT_RESTORED:
if (isCompanionComputerEnabled()) {
handler.removeCallbacks(disconnectSoloCompTask);
if (!soloComp.isConnected()) soloComp.start();
 else {
soloComp.refreshState();
}
}
break;
case DISCONNECTED:
if (isCompanionComputerEnabled()) {
if (soloComp.isConnected()) {
soloComp.stop();
return;
}
}
break;
}
if (connectedApps.isEmpty()) return;
for (DroneEventsListener droneEventsListener : connectedApps.values()) {
droneEventsListener.onDroneEvent(event,drone);
}
}","The original code had an unnecessary `else` block that was causing redundant state refresh operations and potentially interfering with companion computer connection management. In the fixed code, the `else` block for `soloComp.refreshState()` was removed, simplifying the logic and preventing unnecessary state updates when the companion computer is already connected. This modification ensures more efficient and cleaner handling of drone connection events, reducing potential synchronization and state management complexities."
94786,"@Override public void refreshState(){
  Timber.d(""String_Node_Str"");
  startVideoManager();
  loadSololinkWifiInfo();
  refreshControllerVersions();
  loadCurrentEUTxPowerComplianceMode();
  updateControllerModeIfPossible();
}","@Override public void refreshState(){
  Timber.d(""String_Node_Str"");
  startVideoManager();
  loadSololinkWifiInfo();
  refreshControllerVersions();
  loadCurrentEUTxPowerComplianceMode();
}","The original code incorrectly calls `updateControllerModeIfPossible()`, which may be unnecessary or potentially disruptive to the state refresh process. The fixed code removes this method call, streamlining the state refresh sequence to only include essential operations like starting the video manager and loading necessary information. By eliminating the potentially redundant mode update, the code becomes more predictable and focused on core state refreshing tasks."
94787,"private void onVersionsUpdated(){
  if (linkListener != null && areVersionsSet())   linkListener.onVersionsUpdated();
  updateControllerModeIfPossible();
}","private void onVersionsUpdated(){
  if (linkListener != null && areVersionsSet())   linkListener.onVersionsUpdated();
}","The original code incorrectly called `updateControllerModeIfPossible()` unconditionally after checking the versions, potentially triggering unintended state changes. The fixed code removes this unnecessary method call, ensuring that only version-related updates occur when versions are set. This modification prevents potential side effects and maintains a cleaner, more focused method that strictly handles version-related operations."
94788,"@Override public void executeAction(Action action,ICommandListener listener) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
  if (data != null)   data.setClassLoader(context.getClassLoader());
switch (type) {
case ConnectionActions.ACTION_CONNECT:
    ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
  connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case SoloCameraActions.ACTION_START_VIDEO_STREAM:
{
final Surface videoSurface=data.getParcelable(SoloCameraActions.EXTRA_VIDEO_DISPLAY);
final String videoTag=data.getString(SoloCameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
SoloApiUtils.startVideoStream(getDroneManager(),ownerId + videoTag,videoSurface,listener);
break;
}
case SoloCameraActions.ACTION_STOP_VIDEO_STREAM:
{
final String videoTag=data.getString(SoloCameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
SoloApiUtils.stopVideoStream(getDroneManager(),ownerId + videoTag,listener);
break;
}
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
final MavLinkDrone drone=droneMgr == null ? null : droneMgr.getDrone();
CommonApiUtils.buildComplexMissionItem(drone,data);
break;
default :
droneMgr.executeAsyncAction(action,listener);
break;
}
}","@Override public void executeAction(Action action,ICommandListener listener) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
  if (data != null)   data.setClassLoader(context.getClassLoader());
switch (type) {
case ConnectionActions.ACTION_CONNECT:
    ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
  connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case SoloCameraActions.ACTION_START_VIDEO_STREAM:
{
final Surface videoSurface=data.getParcelable(SoloCameraActions.EXTRA_VIDEO_DISPLAY);
final String videoTag=data.getString(SoloCameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
SoloApiUtils.startVideoStream(getDroneManager(),ownerId,videoTag,videoSurface,listener);
break;
}
case SoloCameraActions.ACTION_STOP_VIDEO_STREAM:
{
final String videoTag=data.getString(SoloCameraActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
SoloApiUtils.stopVideoStream(getDroneManager(),ownerId,videoTag,listener);
break;
}
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
final MavLinkDrone drone=droneMgr == null ? null : droneMgr.getDrone();
CommonApiUtils.buildComplexMissionItem(drone,data);
break;
default :
droneMgr.executeAsyncAction(action,listener);
break;
}
}","The original code incorrectly concatenated `ownerId + videoTag` when calling video stream methods, potentially causing unpredictable behavior. In the fixed code, `SoloApiUtils.startVideoStream()` and `stopVideoStream()` methods were updated to accept `ownerId` and `videoTag` as separate parameters, ensuring proper method invocation and parameter handling. This modification provides clearer method signatures and prevents potential string concatenation errors in video streaming operations."
94789,"public void disconnect(String appId) throws ConnectionException {
  if (TextUtils.isEmpty(appId))   return;
  Log.d(TAG,""String_Node_Str"" + appId);
  DroneEventsListener listener=connectedApps.remove(appId);
  if (listener != null) {
    mavClient.removeLoggingFile(appId);
    listener.onDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED,drone);
    notifyDisconnected(appId,listener);
  }
  if (mavClient.isConnected() && connectedApps.isEmpty()) {
    mavClient.closeConnection();
  }
}","public void disconnect(String appId) throws ConnectionException {
  if (TextUtils.isEmpty(appId))   return;
  if (isCompanionComputerEnabled())   soloComp.tryStoppingVideoStream(appId);
  Log.d(TAG,""String_Node_Str"" + appId);
  DroneEventsListener listener=connectedApps.remove(appId);
  if (listener != null) {
    mavClient.removeLoggingFile(appId);
    listener.onDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED,drone);
    notifyDisconnected(appId,listener);
  }
  if (mavClient.isConnected() && connectedApps.isEmpty()) {
    mavClient.closeConnection();
  }
}","The original code lacked proper handling of companion computer video stream stoppage when disconnecting an application. The fixed code adds a conditional check with `isCompanionComputerEnabled()` and calls `soloComp.tryStoppingVideoStream(appId)` to ensure clean video stream termination before further disconnection processes. This enhancement improves resource management and prevents potential hanging video streams during application disconnection, ensuring more robust and controlled disconnection behavior."
94790,"public void stopVideoStream(String ownerId,final ICommandListener listener){
  Timber.d(""String_Node_Str"",ownerId,videoOwnerId.get());
  if (TextUtils.isEmpty(ownerId)) {
    Timber.w(""String_Node_Str"");
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
    return;
  }
  final String currentVideoOwner=videoOwnerId.get();
  if (NO_VIDEO_OWNER.equals(currentVideoOwner)) {
    Timber.d(""String_Node_Str"");
    postSuccessEvent(listener);
    return;
  }
  if (ownerId.equals(currentVideoOwner) && videoOwnerId.compareAndSet(currentVideoOwner,NO_VIDEO_OWNER)) {
    Timber.d(""String_Node_Str"",videoOwnerId.get());
    artooMgr.stopDecoding(new DecoderListener(){
      @Override public void onDecodingStarted(){
      }
      @Override public void onDecodingError(){
        postSuccessEvent(listener);
      }
      @Override public void onDecodingEnded(){
        postSuccessEvent(listener);
      }
    }
);
    artooMgr.stopVideoManager();
  }
 else {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
  }
}","public void stopVideoStream(String appId,String currentVideoTag,final ICommandListener listener){
  Timber.d(""String_Node_Str"",appId,videoOwnerId.get());
  if (TextUtils.isEmpty(appId)) {
    Timber.w(""String_Node_Str"");
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
    return;
  }
  final String currentVideoOwner=videoOwnerId.get();
  if (NO_VIDEO_OWNER.equals(currentVideoOwner)) {
    Timber.d(""String_Node_Str"");
    postSuccessEvent(listener);
    return;
  }
  if (currentVideoTag == null)   currentVideoTag=""String_Node_Str"";
  if (appId.equals(currentVideoOwner) && currentVideoTag.equals(videoTagRef.get()) && videoOwnerId.compareAndSet(currentVideoOwner,NO_VIDEO_OWNER)) {
    videoTagRef.set(""String_Node_Str"");
    Timber.d(""String_Node_Str"",currentVideoOwner);
    artooMgr.stopDecoding(new DecoderListener(){
      @Override public void onDecodingStarted(){
      }
      @Override public void onDecodingError(){
        postSuccessEvent(listener);
      }
      @Override public void onDecodingEnded(){
        postSuccessEvent(listener);
      }
    }
);
    artooMgr.stopVideoManager();
  }
 else {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
  }
}","The original code lacked proper validation for video ownership, potentially allowing unauthorized stream stops by not checking additional context like video tags. The fixed code introduces a new parameter `currentVideoTag` and compares it with a `videoTagRef`, ensuring that only the correct owner with the matching tag can stop the video stream. This enhancement adds an extra layer of security and prevents unintended stream interruptions by requiring both owner ID and video tag to match before stopping the stream."
94791,"public void start(){
  if (!isAvailable()) {
    return;
  }
  artooMgr.start(this);
  soloLinkMgr.start(this);
}","public void start(){
  if (!isAvailable()) {
    return;
  }
  resetVideoOwner();
  artooMgr.start(this);
  soloLinkMgr.start(this);
}","The original code lacks a critical reset operation before starting managers, which could lead to potential state inconsistencies or resource conflicts. The fixed code adds `resetVideoOwner()` before starting the managers, ensuring a clean initial state and preventing any unintended carryover from previous operations. By explicitly resetting the video owner, the code now guarantees a more predictable and reliable startup sequence for the system."
94792,"private void resetVideoOwner(){
  Timber.d(""String_Node_Str"",videoOwnerId.get());
  videoOwnerId.set(NO_VIDEO_OWNER);
  artooMgr.stopDecoding(null);
}","private void resetVideoOwner(){
  Timber.d(""String_Node_Str"",videoTagRef.get(),videoOwnerId.get());
  videoTagRef.set(""String_Node_Str"");
  videoOwnerId.set(NO_VIDEO_OWNER);
  artooMgr.stopDecoding(null);
}","The original code only logged the videoOwnerId without proper context, potentially missing important debugging information. The fixed code adds logging of videoTagRef alongside videoOwnerId and explicitly sets videoTagRef to a specific string value, providing more comprehensive diagnostic details. These modifications enhance code clarity, improve debugging capabilities, and ensure more complete state management during video owner reset."
94793,"public void stop(){
  artooMgr.stop();
  soloLinkMgr.stop();
}","public void stop(){
  resetVideoOwner();
  artooMgr.stop();
  soloLinkMgr.stop();
}","The original code omitted a crucial cleanup step before stopping managers, potentially leaving video ownership in an unresolved state. The fixed code adds `resetVideoOwner()` before stopping the managers, ensuring proper resource management and preventing potential resource leaks or synchronization issues. By explicitly resetting video ownership, the code now guarantees a clean and controlled shutdown of system components."
94794,"public void startVideoStream(String ownerId,Surface videoSurface,final ICommandListener listener){
  Timber.d(""String_Node_Str"",ownerId,videoOwnerId.get());
  if (TextUtils.isEmpty(ownerId)) {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
    return;
  }
  if (videoSurface == null) {
    postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
    return;
  }
  if (ownerId.equals(videoOwnerId.get())) {
    postSuccessEvent(listener);
    return;
  }
  if (videoOwnerId.compareAndSet(NO_VIDEO_OWNER,ownerId)) {
    artooMgr.startVideoManager();
    Timber.d(""String_Node_Str"");
    artooMgr.startDecoding(videoSurface,new DecoderListener(){
      @Override public void onDecodingStarted(){
        Timber.d(""String_Node_Str"");
        postSuccessEvent(listener);
      }
      @Override public void onDecodingError(){
        Timber.d(""String_Node_Str"");
        postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
        resetVideoOwner();
      }
      @Override public void onDecodingEnded(){
        Timber.d(""String_Node_Str"");
        resetVideoOwner();
      }
    }
);
  }
 else {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
  }
}","public void startVideoStream(String appId,String newVideoTag,Surface videoSurface,final ICommandListener listener){
  Timber.d(""String_Node_Str"",appId,videoOwnerId.get());
  if (TextUtils.isEmpty(appId)) {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
    return;
  }
  if (videoSurface == null) {
    postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
    return;
  }
  if (newVideoTag == null)   newVideoTag=""String_Node_Str"";
  if (appId.equals(videoOwnerId.get())) {
    String currentVideoTag=videoTagRef.get();
    if (currentVideoTag == null)     currentVideoTag=""String_Node_Str"";
    if (newVideoTag.equals(currentVideoTag)) {
      postSuccessEvent(listener);
      return;
    }
  }
  if (videoOwnerId.compareAndSet(NO_VIDEO_OWNER,appId)) {
    videoTagRef.set(newVideoTag);
    artooMgr.startVideoManager();
    Timber.d(""String_Node_Str"");
    artooMgr.startDecoding(videoSurface,new DecoderListener(){
      @Override public void onDecodingStarted(){
        Timber.d(""String_Node_Str"");
        postSuccessEvent(listener);
      }
      @Override public void onDecodingError(){
        Timber.d(""String_Node_Str"");
        postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
        resetVideoOwner();
      }
      @Override public void onDecodingEnded(){
        Timber.d(""String_Node_Str"");
        resetVideoOwner();
      }
    }
);
  }
 else {
    postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
  }
}","The original code lacked proper handling of video stream ownership and tag management, potentially allowing multiple conflicting video streams. The fixed code introduces a new parameter `newVideoTag` and uses `videoTagRef` to track and compare video stream identities, enabling more granular control over stream initialization and preventing unintended stream overlaps. This enhancement provides a more robust mechanism for managing video stream ownership, ensuring clearer state management and preventing potential race conditions or unauthorized stream starts."
94795,"public static void stopVideoStream(DroneManager droneManager,String ownerId,ICommandListener listener){
  if (!isSoloLinkFeatureAvailable(droneManager,listener))   return;
  final SoloComp soloComp=droneManager.getSoloComp();
  soloComp.stopVideoStream(ownerId,listener);
}","public static void stopVideoStream(DroneManager droneManager,String appId,String videoTag,ICommandListener listener){
  if (!isSoloLinkFeatureAvailable(droneManager,listener))   return;
  final SoloComp soloComp=droneManager.getSoloComp();
  soloComp.stopVideoStream(appId,videoTag,listener);
}","The original code lacked a video tag parameter, which is essential for precisely identifying and managing specific video streams in the SoloComp interface. The fixed code adds an additional `videoTag` parameter and updates the method signature and call to `stopVideoStream` to include this crucial identifier, enabling more granular video stream control. This modification allows for more precise and flexible video stream management, improving the overall functionality and reliability of the drone video streaming mechanism."
94796,"public static void startVideoStream(DroneManager droneManager,String ownerId,Surface videoSurface,ICommandListener listener){
  if (!isSoloLinkFeatureAvailable(droneManager,listener))   return;
  final SoloComp soloComp=droneManager.getSoloComp();
  soloComp.startVideoStream(ownerId,videoSurface,listener);
}","public static void startVideoStream(DroneManager droneManager,String appId,String videoTag,Surface videoSurface,ICommandListener listener){
  if (!isSoloLinkFeatureAvailable(droneManager,listener))   return;
  final SoloComp soloComp=droneManager.getSoloComp();
  soloComp.startVideoStream(appId,videoTag,videoSurface,listener);
}","The original code had incomplete method signature and parameters for starting a video stream, potentially causing method call mismatches or incorrect invocations. The fixed code adds two additional parameters (appId and videoTag) to provide more precise and comprehensive video stream initialization, ensuring proper identification and tagging of the video stream. These enhancements increase the method's flexibility and robustness, allowing more accurate and controlled video streaming management within the drone system."
94797,"public void stopDecoding(DecoderListener listener){
  Timber.i(""String_Node_Str"");
  this.decoderListenerRef.set(listener);
  if (!isDecoding.get()) {
    if (listener != null) {
      notifyDecodingEnded();
    }
  }
 else {
    if (decodedFirstFrame.get()) {
      if (processInputData.compareAndSet(true,false))       sendCompletionFlag.set(true);
    }
 else {
      handler.post(stopSafely);
    }
  }
}","public void stopDecoding(DecoderListener listener){
  Timber.i(""String_Node_Str"");
  this.decoderListenerRef.set(listener);
  if (!isDecoding.get()) {
    if (listener != null) {
      notifyDecodingEnded();
    }
  }
 else {
    if (decodedFirstFrame.get()) {
      if (processInputData.compareAndSet(true,false)) {
        sendCompletionFlag.set(!processNALUChunk(naluChunkAssembler.getEndOfStream()));
      }
    }
 else {
      handler.post(stopSafely);
    }
  }
}","The original code lacks proper handling of the completion flag when stopping decoding after the first frame, potentially leaving the decoding process in an inconsistent state. The fixed code adds a critical step of processing the end-of-stream NALU chunk and setting the sendCompletionFlag based on the result, ensuring correct stream termination. This improvement provides more robust and deterministic decoder shutdown, preventing potential resource leaks or incomplete decoding scenarios."
94798,"@Before public void setUp() throws Exception {
  final Context context=Robolectric.getShadowApplication().getApplicationContext();
  ConnectionParameter connParams=new ConnectionParameter(0,new Bundle(),null);
  mavlinkApi=new MockMavLinkServiceAPI();
  DroneInterfaces.Clock clock=new DroneInterfaces.Clock(){
    @Override public long elapsedRealtime(){
      return SystemClock.elapsedRealtime();
    }
  }
;
  DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
  MAVLinkClient mavClient=new MAVLinkClient(context,inputStreamListener,connParams,mavlinkApi);
  drone=new ArduCopter(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),new LogMessageListener(){
    @Override public void onMessageLogged(    int logLevel,    String message){
    }
  }
);
}","@Before public void setUp() throws Exception {
  final Context context=Robolectric.getShadowApplication().getApplicationContext();
  ConnectionParameter connParams=new ConnectionParameter(0,new Bundle(),null);
  mavlinkApi=new MockMavLinkServiceAPI();
  DroneInterfaces.Clock clock=new DroneInterfaces.Clock(){
    @Override public long elapsedRealtime(){
      return SystemClock.elapsedRealtime();
    }
  }
;
  DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
  MAVLinkClient mavClient=new MAVLinkClient(context,inputStreamListener,connParams,mavlinkApi);
  drone=new ArduCopter(context,mavClient,dpHandler,dpPrefs,new AndroidApWarningParser(),new LogMessageListener(){
    @Override public void onMessageLogged(    int logLevel,    String message){
    }
  }
,new DroneInterfaces.AttributeEventListener(){
    @Override public void onAttributeEvent(    String attributeEvent,    Bundle eventInfo){
    }
  }
);
}","The original code was missing an essential AttributeEventListener parameter when constructing the ArduCopter drone object, which could lead to incomplete initialization. The fixed code adds a new anonymous implementation of DroneInterfaces.AttributeEventListener with an empty onAttributeEvent method, ensuring the constructor receives all required parameters. This modification prevents potential null pointer exceptions and ensures proper drone object creation with a complete set of listener interfaces."
94799,"@Override public void executeAction(Action action,ICommandListener listener) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
  if (data != null)   data.setClassLoader(context.getClassLoader());
switch (type) {
case ConnectionActions.ACTION_CONNECT:
    ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
  connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case SoloLinkActions.ACTION_START_VIDEO_STREAM:
{
final Surface videoSurface=data.getParcelable(SoloLinkActions.EXTRA_VIDEO_DISPLAY);
final String videoTag=data.getString(SoloLinkActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
SoloLinkApiUtils.startVideoStream(getDroneManager(),ownerId + videoTag,videoSurface,listener);
break;
}
case SoloLinkActions.ACTION_STOP_VIDEO_STREAM:
{
final String videoTag=data.getString(SoloLinkActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
SoloLinkApiUtils.stopVideoStream(getDroneManager(),ownerId + videoTag,listener);
break;
}
default :
droneMgr.executeAsyncAction(action,listener);
break;
}
}","@Override public void executeAction(Action action,ICommandListener listener) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
  if (data != null)   data.setClassLoader(context.getClassLoader());
switch (type) {
case ConnectionActions.ACTION_CONNECT:
    ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
  connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case SoloLinkActions.ACTION_START_VIDEO_STREAM:
{
final Surface videoSurface=data.getParcelable(SoloLinkActions.EXTRA_VIDEO_DISPLAY);
final String videoTag=data.getString(SoloLinkActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
SoloLinkApiUtils.startVideoStream(getDroneManager(),ownerId + videoTag,videoSurface,listener);
break;
}
case SoloLinkActions.ACTION_STOP_VIDEO_STREAM:
{
final String videoTag=data.getString(SoloLinkActions.EXTRA_VIDEO_TAG,""String_Node_Str"");
SoloLinkApiUtils.stopVideoStream(getDroneManager(),ownerId + videoTag,listener);
break;
}
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
final MavLinkDrone drone=droneMgr == null ? null : droneMgr.getDrone();
CommonApiUtils.buildComplexMissionItem(drone,data);
break;
default :
droneMgr.executeAsyncAction(action,listener);
break;
}
}","The original code lacked handling for the `MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM` case, potentially causing unhandled actions or null pointer exceptions when building complex mission items. The fixed code adds a specific case that checks for a non-null drone manager and safely calls `CommonApiUtils.buildComplexMissionItem()` with the drone object. This enhancement improves the method's robustness by explicitly managing mission item creation and preventing potential runtime errors during action execution."
94800,"@Override public void executeAsyncAction(Action action,final ICommandListener listener){
  final String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    final float bearing=CommonApiUtils.generateDronie(drone);
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyDroneAttributeEvent(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
break;
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
CommonApiUtils.buildComplexMissionItem(drone,data);
break;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
CommonApiUtils.enableFollowMe(this,handler,followType);
break;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (followMe != null) {
data.setClassLoader(LatLong.class.getClassLoader());
final FollowAlgorithm followAlgorithm=followMe.getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
if (FollowType.EXTRA_FOLLOW_ROI_TARGET.equals(key)) {
LatLong target=data.getParcelable(key);
if (target != null) {
final Coord2D roiTarget;
if (target instanceof LatLongAlt) {
roiTarget=new Coord3D(target.getLatitude(),target.getLongitude(),((LatLongAlt)target).getAltitude());
}
 else {
roiTarget=new Coord2D(target.getLatitude(),target.getLongitude());
}
paramsMap.put(key,roiTarget);
}
}
 else paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
break;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
CommonApiUtils.disableFollowMe(followMe);
break;
case SoloLinkActions.ACTION_SEND_MESSAGE:
final TLVPacket messageData=data.getParcelable(SoloLinkActions.EXTRA_MESSAGE_DATA);
if (messageData != null) {
SoloLinkApiUtils.sendSoloLinkMessage(this,messageData,listener);
}
break;
case SoloLinkActions.ACTION_UPDATE_WIFI_SETTINGS:
final String wifiSsid=data.getString(SoloLinkActions.EXTRA_WIFI_SSID);
final String wifiPassword=data.getString(SoloLinkActions.EXTRA_WIFI_PASSWORD);
SoloLinkApiUtils.updateSoloLinkWifiSettings(this,wifiSsid,wifiPassword,listener);
break;
case SoloLinkActions.ACTION_UPDATE_BUTTON_SETTINGS:
final SoloButtonSettingSetter buttonSettings=data.getParcelable(SoloLinkActions.EXTRA_BUTTON_SETTINGS);
if (buttonSettings != null) {
SoloLinkApiUtils.updateSoloLinkButtonSettings(this,buttonSettings,listener);
}
break;
case SoloLinkActions.ACTION_UPDATE_CONTROLLER_MODE:
final @SoloControllerMode.ControllerMode int mode=data.getInt(SoloLinkActions.EXTRA_CONTROLLER_MODE);
SoloLinkApiUtils.updateSoloLinkControllerMode(this,mode,listener);
break;
case SoloLinkActions.ACTION_UPDATE_EU_TX_POWER_COMPLIANCE:
final boolean isCompliant=data.getBoolean(SoloLinkActions.EXTRA_EU_TX_POWER_COMPLIANT,false);
SoloLinkApiUtils.updateSoloLinkEUTxPowerCompliance(this,isCompliant,listener);
break;
case CapabilityActions.ACTION_CHECK_FEATURE_SUPPORT:
if (listener != null) {
final String featureId=data.getString(CapabilityActions.EXTRA_FEATURE_ID);
if (!TextUtils.isEmpty(featureId)) {
switch (featureId) {
case CapabilityApi.FeatureIds.SOLOLINK_VIDEO_STREAMING:
case CapabilityApi.FeatureIds.COMPASS_CALIBRATION:
if (this.isCompanionComputerEnabled()) {
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
}
break;
default :
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
break;
}
}
}
break;
default :
if (drone != null) {
drone.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
break;
}
}","@Override public void executeAsyncAction(Action action,final ICommandListener listener){
  final String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    final float bearing=CommonApiUtils.generateDronie(drone);
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyDroneAttributeEvent(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
break;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
CommonApiUtils.enableFollowMe(this,handler,followType);
break;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (followMe != null) {
data.setClassLoader(LatLong.class.getClassLoader());
final FollowAlgorithm followAlgorithm=followMe.getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
if (FollowType.EXTRA_FOLLOW_ROI_TARGET.equals(key)) {
LatLong target=data.getParcelable(key);
if (target != null) {
final Coord2D roiTarget;
if (target instanceof LatLongAlt) {
  roiTarget=new Coord3D(target.getLatitude(),target.getLongitude(),((LatLongAlt)target).getAltitude());
}
 else {
  roiTarget=new Coord2D(target.getLatitude(),target.getLongitude());
}
paramsMap.put(key,roiTarget);
}
}
 else paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
break;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
CommonApiUtils.disableFollowMe(followMe);
break;
case SoloLinkActions.ACTION_SEND_MESSAGE:
final TLVPacket messageData=data.getParcelable(SoloLinkActions.EXTRA_MESSAGE_DATA);
if (messageData != null) {
SoloLinkApiUtils.sendSoloLinkMessage(this,messageData,listener);
}
break;
case SoloLinkActions.ACTION_UPDATE_WIFI_SETTINGS:
final String wifiSsid=data.getString(SoloLinkActions.EXTRA_WIFI_SSID);
final String wifiPassword=data.getString(SoloLinkActions.EXTRA_WIFI_PASSWORD);
SoloLinkApiUtils.updateSoloLinkWifiSettings(this,wifiSsid,wifiPassword,listener);
break;
case SoloLinkActions.ACTION_UPDATE_BUTTON_SETTINGS:
final SoloButtonSettingSetter buttonSettings=data.getParcelable(SoloLinkActions.EXTRA_BUTTON_SETTINGS);
if (buttonSettings != null) {
SoloLinkApiUtils.updateSoloLinkButtonSettings(this,buttonSettings,listener);
}
break;
case SoloLinkActions.ACTION_UPDATE_CONTROLLER_MODE:
final @SoloControllerMode.ControllerMode int mode=data.getInt(SoloLinkActions.EXTRA_CONTROLLER_MODE);
SoloLinkApiUtils.updateSoloLinkControllerMode(this,mode,listener);
break;
case SoloLinkActions.ACTION_UPDATE_EU_TX_POWER_COMPLIANCE:
final boolean isCompliant=data.getBoolean(SoloLinkActions.EXTRA_EU_TX_POWER_COMPLIANT,false);
SoloLinkApiUtils.updateSoloLinkEUTxPowerCompliance(this,isCompliant,listener);
break;
case CapabilityActions.ACTION_CHECK_FEATURE_SUPPORT:
if (listener != null) {
final String featureId=data.getString(CapabilityActions.EXTRA_FEATURE_ID);
if (!TextUtils.isEmpty(featureId)) {
switch (featureId) {
case CapabilityApi.FeatureIds.SOLOLINK_VIDEO_STREAMING:
case CapabilityApi.FeatureIds.COMPASS_CALIBRATION:
if (this.isCompanionComputerEnabled()) {
CommonApiUtils.postSuccessEvent(listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
}
break;
default :
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_UNSUPPORTED,listener);
break;
}
}
}
break;
default :
if (drone != null) {
drone.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
break;
}
}","The original code contained an unnecessary case for building complex mission items, which was redundant and potentially introduced unhandled complexity. The fixed code removes this specific case, simplifying the switch statement and relying on the default case to handle unspecified actions through the drone's native executeAsyncAction method. By streamlining the action handling, the revised code provides a more robust and flexible approach to executing different types of drone actions with reduced potential for errors."
94801,"@Override public void onMavLinkMessageReceived(MAVLinkMessage message){
  if (message.compid != AUTOPILOT_COMPONENT_ID) {
    return;
  }
  if (getParameters().processMessage(message)) {
    return;
  }
  getWaypointManager().processMessage(message);
  getCalibrationSetup().processMessage(message);
switch (message.msgid) {
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
    msg_heartbeat msg_heart=(msg_heartbeat)message;
  setType(msg_heart.type);
checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,getType());
getState().setMode(newMode);
onHeartbeat(msg_heart);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)message;
processStatusText(msg_statustext);
break;
case msg_attitude.MAVLINK_MSG_ID_ATTITUDE:
msg_attitude m_att=(msg_attitude)message;
getOrientation().setRollPitchYaw(m_att.roll * 180.0 / Math.PI,m_att.pitch * 180.0 / Math.PI,m_att.yaw * 180.0 / Math.PI);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
msg_vfr_hud m_hud=(msg_vfr_hud)message;
setAltitudeGroundAndAirSpeeds(m_hud.alt,m_hud.groundspeed,m_hud.airspeed,m_hud.climb);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
getMissionStats().setWpno(((msg_mission_current)message).seq);
break;
case msg_mission_item_reached.MAVLINK_MSG_ID_MISSION_ITEM_REACHED:
getMissionStats().setLastReachedWaypointNumber(((msg_mission_item_reached)message).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)message;
setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
getNavigation().setNavPitchRollYaw(m_nav.nav_pitch,m_nav.nav_roll,m_nav.nav_bearing);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)message;
getMagnetometer().newData(msg_imu);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
getGps().setPosition(((msg_global_position_int)message).lat / 1E7,((msg_global_position_int)message).lon / 1E7);
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)message;
getBattery().setBatteryState(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
checkControlSensorsHealth(m_sys);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)message;
getRadio().setRadioState(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_radio_status.MAVLINK_MSG_ID_RADIO_STATUS:
msg_radio_status m_radio_status=(msg_radio_status)message;
getRadio().setRadioState(m_radio_status.rxerrors,m_radio_status.fixed,m_radio_status.rssi,m_radio_status.remrssi,m_radio_status.txbuf,m_radio_status.noise,m_radio_status.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
getGps().setGpsState(((msg_gps_raw_int)message).fix_type,((msg_gps_raw_int)message).satellites_visible,((msg_gps_raw_int)message).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
getRC().setRcInputValues((msg_rc_channels_raw)message);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
getRC().setRcOutputValues((msg_servo_output_raw)message);
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
getCamera().newImageLocation((msg_camera_feedback)message);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
getCamera().updateMountOrientation(((msg_mount_status)message));
break;
case msg_named_value_int.MAVLINK_MSG_ID_NAMED_VALUE_INT:
processNamedValueInt((msg_named_value_int)message);
break;
case msg_mag_cal_progress.MAVLINK_MSG_ID_MAG_CAL_PROGRESS:
case msg_mag_cal_report.MAVLINK_MSG_ID_MAG_CAL_REPORT:
getMagnetometerCalibration().processCalibrationMessage(message);
break;
case msg_ekf_status_report.MAVLINK_MSG_ID_EKF_STATUS_REPORT:
getState().setEkfStatus((msg_ekf_status_report)message);
break;
case msg_mission_item.MAVLINK_MSG_ID_MISSION_ITEM:
msg_mission_item missionItem=(msg_mission_item)message;
if (missionItem.seq == Home.HOME_WAYPOINT_INDEX) {
getHome().setHome(missionItem);
}
break;
default :
break;
}
}","@Override public void onMavLinkMessageReceived(MAVLinkMessage message){
  if (message.compid != AUTOPILOT_COMPONENT_ID && message.compid != ARTOO_COMPONENT_ID) {
    return;
  }
  if (getParameters().processMessage(message)) {
    return;
  }
  getWaypointManager().processMessage(message);
  getCalibrationSetup().processMessage(message);
switch (message.msgid) {
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
    msg_heartbeat msg_heart=(msg_heartbeat)message;
  setType(msg_heart.type);
checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,getType());
getState().setMode(newMode);
onHeartbeat(msg_heart);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)message;
processStatusText(msg_statustext);
break;
case msg_attitude.MAVLINK_MSG_ID_ATTITUDE:
msg_attitude m_att=(msg_attitude)message;
getOrientation().setRollPitchYaw(m_att.roll * 180.0 / Math.PI,m_att.pitch * 180.0 / Math.PI,m_att.yaw * 180.0 / Math.PI);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
msg_vfr_hud m_hud=(msg_vfr_hud)message;
setAltitudeGroundAndAirSpeeds(m_hud.alt,m_hud.groundspeed,m_hud.airspeed,m_hud.climb);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
getMissionStats().setWpno(((msg_mission_current)message).seq);
break;
case msg_mission_item_reached.MAVLINK_MSG_ID_MISSION_ITEM_REACHED:
getMissionStats().setLastReachedWaypointNumber(((msg_mission_item_reached)message).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)message;
setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
getNavigation().setNavPitchRollYaw(m_nav.nav_pitch,m_nav.nav_roll,m_nav.nav_bearing);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)message;
getMagnetometer().newData(msg_imu);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
getGps().setPosition(((msg_global_position_int)message).lat / 1E7,((msg_global_position_int)message).lon / 1E7);
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)message;
getBattery().setBatteryState(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
checkControlSensorsHealth(m_sys);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)message;
getRadio().setRadioState(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_radio_status.MAVLINK_MSG_ID_RADIO_STATUS:
msg_radio_status m_radio_status=(msg_radio_status)message;
getRadio().setRadioState(m_radio_status.rxerrors,m_radio_status.fixed,m_radio_status.rssi,m_radio_status.remrssi,m_radio_status.txbuf,m_radio_status.noise,m_radio_status.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
getGps().setGpsState(((msg_gps_raw_int)message).fix_type,((msg_gps_raw_int)message).satellites_visible,((msg_gps_raw_int)message).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
getRC().setRcInputValues((msg_rc_channels_raw)message);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
getRC().setRcOutputValues((msg_servo_output_raw)message);
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
getCamera().newImageLocation((msg_camera_feedback)message);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
getCamera().updateMountOrientation(((msg_mount_status)message));
break;
case msg_named_value_int.MAVLINK_MSG_ID_NAMED_VALUE_INT:
processNamedValueInt((msg_named_value_int)message);
break;
case msg_mag_cal_progress.MAVLINK_MSG_ID_MAG_CAL_PROGRESS:
case msg_mag_cal_report.MAVLINK_MSG_ID_MAG_CAL_REPORT:
getMagnetometerCalibration().processCalibrationMessage(message);
break;
case msg_ekf_status_report.MAVLINK_MSG_ID_EKF_STATUS_REPORT:
getState().setEkfStatus((msg_ekf_status_report)message);
break;
case msg_mission_item.MAVLINK_MSG_ID_MISSION_ITEM:
msg_mission_item missionItem=(msg_mission_item)message;
if (missionItem.seq == Home.HOME_WAYPOINT_INDEX) {
getHome().setHome(missionItem);
}
break;
default :
break;
}
}","The original code only checked for messages from the autopilot component, potentially ignoring critical messages from other components. The fixed code adds `ARTOO_COMPONENT_ID` to the initial component check, expanding message processing to include additional relevant message sources. This modification enhances message handling robustness by ensuring important communications from different system components are not inadvertently filtered out, improving overall system communication and information gathering."
94802,"private void handleHeartbeatType(int type){
switch (type) {
case MAV_TYPE.MAV_TYPE_FIXED_WING:
    droneMgr.onVehicleTypeReceived(FirmwareType.ARDU_PLANE);
  break;
case MAV_TYPE.MAV_TYPE_GROUND_ROVER:
case MAV_TYPE.MAV_TYPE_SURFACE_BOAT:
droneMgr.onVehicleTypeReceived(FirmwareType.ARDU_ROVER);
break;
}
}","private void handleHeartbeatType(int type){
switch (type) {
case MAV_TYPE.MAV_TYPE_FIXED_WING:
    droneMgr.onVehicleTypeReceived(FirmwareType.ARDU_PLANE);
  break;
case MAV_TYPE.MAV_TYPE_GENERIC:
case MAV_TYPE.MAV_TYPE_QUADROTOR:
case MAV_TYPE.MAV_TYPE_COAXIAL:
case MAV_TYPE.MAV_TYPE_HELICOPTER:
case MAV_TYPE.MAV_TYPE_HEXAROTOR:
case MAV_TYPE.MAV_TYPE_OCTOROTOR:
case MAV_TYPE.MAV_TYPE_TRICOPTER:
droneMgr.onVehicleTypeReceived(FirmwareType.ARDU_COPTER);
break;
case MAV_TYPE.MAV_TYPE_GROUND_ROVER:
case MAV_TYPE.MAV_TYPE_SURFACE_BOAT:
droneMgr.onVehicleTypeReceived(FirmwareType.ARDU_ROVER);
break;
}
}","The original code only handled fixed-wing aircraft and ground/surface vehicles, missing support for various multirotor drone types. The fixed code adds comprehensive coverage for different drone configurations like quadrotors, hexarotors, and helicopters by mapping multiple MAV_TYPE variants to the ARDU_COPTER firmware type. This enhancement ensures more robust vehicle type recognition across a broader range of drone architectures, improving the system's flexibility and compatibility with diverse drone platforms."
94803,"@Override public Bundle getAttribute(String type) throws RemoteException {
  final DroneAttribute attribute=droneMgr.getAttribute(type);
  if (attribute == null)   return null;
  Bundle carrier=new Bundle();
  carrier.putParcelable(type,attribute);
  return carrier;
}","@Override public Bundle getAttribute(String type) throws RemoteException {
  if (droneMgr == null)   return null;
  final DroneAttribute attribute=droneMgr.getAttribute(type);
  if (attribute == null)   return null;
  Bundle carrier=new Bundle();
  carrier.putParcelable(type,attribute);
  return carrier;
}","The original code lacks a null check for droneMgr, which could lead to a NullPointerException when attempting to call getAttribute(). The fixed code adds an explicit null check for droneMgr before invoking getAttribute(), returning null if the drone manager is uninitialized. This defensive programming approach prevents potential runtime crashes and provides a more robust error-handling mechanism for the attribute retrieval method."
94804,"@Override public DroneAttribute getAttribute(String attributeType){
  if (drone == null)   return null;
switch (attributeType) {
case AttributeType.FOLLOW_STATE:
    return CommonApiUtils.getFollowState(getFollowMe());
case AttributeType.CAMERA:
  return CommonApiUtils.getCameraProxy(drone,cameraDetails);
default :
return drone.getAttribute(attributeType);
}
}","@Override public DroneAttribute getAttribute(String attributeType){
  if (drone == null)   return null;
switch (attributeType) {
case AttributeType.FOLLOW_STATE:
    return CommonApiUtils.getFollowState(followMe);
case AttributeType.CAMERA:
  return CommonApiUtils.getCameraProxy(drone,cameraDetails);
default :
return drone.getAttribute(attributeType);
}
}","The original code incorrectly used `getFollowMe()` method call, which might be unnecessary or potentially undefined, instead of directly accessing the `followMe` object. The fixed code directly references the `followMe` variable, ensuring a direct and reliable access to the follow state attribute. This modification simplifies the code, reduces potential method call overhead, and provides a more straightforward way to retrieve the follow state attribute."
94805,"@Override public void executeAsyncAction(Action action,ICommandListener listener){
  final String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    final float bearing=CommonApiUtils.generateDronie(drone);
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyDroneAttributeEvent(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
break;
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
CommonApiUtils.buildComplexMissionItem(getDrone(),data);
break;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
CommonApiUtils.enableFollowMe(this,handler,followType);
break;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (followMe != null) {
data.setClassLoader(LatLong.class.getClassLoader());
final FollowAlgorithm followAlgorithm=followMe.getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
if (FollowType.EXTRA_FOLLOW_ROI_TARGET.equals(key)) {
LatLong target=data.getParcelable(key);
if (target != null) {
final Coord2D roiTarget;
if (target instanceof LatLongAlt) {
roiTarget=new Coord3D(target.getLatitude(),target.getLongitude(),((LatLongAlt)target).getAltitude());
}
 else {
roiTarget=new Coord2D(target.getLatitude(),target.getLongitude());
}
paramsMap.put(key,roiTarget);
}
}
 else paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
break;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
CommonApiUtils.disableFollowMe(getFollowMe());
break;
default :
if (drone != null) {
drone.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
break;
}
}","@Override public void executeAsyncAction(Action action,ICommandListener listener){
  final String type=action.getType();
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    final float bearing=CommonApiUtils.generateDronie(drone);
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyDroneAttributeEvent(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
break;
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
CommonApiUtils.buildComplexMissionItem(drone,data);
break;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
CommonApiUtils.enableFollowMe(this,handler,followType);
break;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (followMe != null) {
data.setClassLoader(LatLong.class.getClassLoader());
final FollowAlgorithm followAlgorithm=followMe.getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
if (FollowType.EXTRA_FOLLOW_ROI_TARGET.equals(key)) {
LatLong target=data.getParcelable(key);
if (target != null) {
final Coord2D roiTarget;
if (target instanceof LatLongAlt) {
roiTarget=new Coord3D(target.getLatitude(),target.getLongitude(),((LatLongAlt)target).getAltitude());
}
 else {
roiTarget=new Coord2D(target.getLatitude(),target.getLongitude());
}
paramsMap.put(key,roiTarget);
}
}
 else paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
break;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
CommonApiUtils.disableFollowMe(followMe);
break;
default :
if (drone != null) {
drone.executeAsyncAction(action,listener);
}
 else {
CommonApiUtils.postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
}
break;
}
}","The original code had incorrect method calls and parameter references, such as using `getDrone()` instead of `drone` and passing `getFollowMe()` instead of `followMe` to utility methods. The fixed code corrects these method calls, ensuring proper parameter passing and maintaining consistent object references throughout the method. These changes improve code reliability by using direct object references and avoiding potential null pointer exceptions or incorrect method invocations."
94806,"public State(MavLinkDrone myDrone,Clock clock,Handler handler,AutopilotWarningParser warningParser){
  super(myDrone);
  this.clock=clock;
  this.handler=handler;
  this.warningParser=warningParser;
  this.errorId=warningParser.getDefaultWarning();
  resetFlightStartTime();
}","public State(MavLinkDrone myDrone,Handler handler,AutopilotWarningParser warningParser){
  super(myDrone);
  this.handler=handler;
  this.warningParser=warningParser;
  this.errorId=warningParser.getDefaultWarning();
  resetFlightStartTime();
}","The original code incorrectly included a `Clock` parameter that was not being used in the method or stored as a class field. The fixed code removes the unnecessary `Clock` parameter, simplifying the constructor and eliminating potential confusion about unused dependencies. This modification improves code clarity, reduces complexity, and ensures that only essential parameters are passed to the constructor."
94807,"private void resetFlightStartTime(){
  startTime=clock.elapsedRealtime();
}","private void resetFlightStartTime(){
  startTime=SystemClock.elapsedRealtime();
}","The original code uses `clock.elapsedRealtime()`, which is likely an undefined or incorrect method reference, potentially causing a compilation error or runtime exception. The fixed code replaces `clock` with `SystemClock`, using the correct Android system class for retrieving elapsed real-time milliseconds. This correction ensures accurate time tracking by using the standard Android method for measuring system uptime, resolving the method invocation issue and providing a reliable way to capture the flight start time."
94808,"@Override public void onConnected(){
  if (isConnected()) {
    drone.notifyDroneEvent(DroneInterfaces.DroneEventsType.CONNECTED);
  }
}","@Override public void onConnected(){
  if (isConnected()) {
    notifyDroneEvent(DroneInterfaces.DroneEventsType.CONNECTED);
  }
}","The original code incorrectly calls `drone.notifyDroneEvent()`, suggesting an unnecessary object reference when `notifyDroneEvent()` is likely an inherited or class method. The fixed code removes the `drone.` prefix, directly calling the method within the current context, which simplifies the invocation. This correction ensures the event notification is processed more directly and potentially avoids potential null pointer or scope-related issues."
94809,"@Override public void onDisconnected(){
  drone.notifyDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED);
}","@Override public void onDisconnected(){
  notifyDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED);
}","The original code attempts to call `notifyDroneEvent` on the `drone` object, which may lead to a potential null pointer exception or incorrect method invocation. The fixed code removes the explicit `drone.` prefix, suggesting that `notifyDroneEvent` is now a direct method of the current class or inherited from a parent class. This change ensures a more reliable and context-aware method call, improving the robustness of the event notification mechanism."
94810,"/** 
 * Causes the Runnable to be added to the message queue.
 * @param action Runnabl that will be executed.
 */
public void post(Runnable action){
  if (action == null)   return;
  handler.post(action);
}","/** 
 * Causes the Runnable to be added to the message queue.
 * @param action Runnabl that will be executed.
 */
public void post(Runnable action){
  if (handler == null || action == null)   return;
  handler.post(action);
}","The original code lacks a null check for the handler, potentially causing a NullPointerException when attempting to post a Runnable. The fixed code adds a check for handler == null, ensuring that both the action and handler are non-null before posting. This modification prevents runtime crashes and improves the method's robustness by adding a simple defensive programming technique."
94811,"@Override public void run(){
  if (drone.getState().getMode() != ApmModes.ROTOR_AUTO) {
    if (forceModeChange) {
      changeVehicleMode(drone,VehicleMode.COPTER_AUTO,new AbstractCommandListener(){
        @Override public void onSuccess(){
          sendCommandRunnable.run();
        }
        @Override public void onError(        int executionError){
          postErrorEvent(executionError,listener);
        }
        @Override public void onTimeout(){
          postTimeoutEvent(listener);
        }
      }
);
    }
 else {
      postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
    }
    return;
  }
 else {
    sendCommandRunnable.run();
  }
}","@Override public void run(){
  if (drone.getState().getMode() != ApmModes.ROTOR_AUTO) {
    if (forceModeChange) {
      changeVehicleMode(drone,VehicleMode.COPTER_AUTO,new AbstractCommandListener(){
        @Override public void onSuccess(){
          sendCommandRunnable.run();
        }
        @Override public void onError(        int executionError){
          postErrorEvent(executionError,listener);
        }
        @Override public void onTimeout(){
          postTimeoutEvent(listener);
        }
      }
);
    }
 else {
      postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
    }
    return;
  }
 else {
    sendCommandRunnable.run();
  }
}","The original code used an incorrect error code `COMMAND_DENIED` when mode change was not forced, which might not accurately represent the actual error condition. The fixed code replaces this with `COMMAND_FAILED`, a more appropriate error code that better signifies the specific failure scenario in the mode change process. By using the correct error code, the fixed version provides more precise error reporting and helps developers understand the exact nature of the command execution failure."
94812,"static void startMission(final DroneManager droneMgr,final boolean forceModeChange,final boolean forceArm,final ICommandListener listener){
  if (droneMgr == null) {
    return;
  }
  final Drone drone=droneMgr.getDrone();
  final Runnable sendCommandRunnable=new Runnable(){
    @Override public void run(){
      msg_command_long msg=new msg_command_long();
      msg.target_system=drone.getSysid();
      msg.target_component=drone.getCompid();
      msg.command=MAV_CMD.MAV_CMD_MISSION_START;
      drone.getMavClient().sendMavMessage(msg,listener);
    }
  }
;
  final Runnable modeCheckRunnable=new Runnable(){
    @Override public void run(){
      if (drone.getState().getMode() != ApmModes.ROTOR_AUTO) {
        if (forceModeChange) {
          changeVehicleMode(drone,VehicleMode.COPTER_AUTO,new AbstractCommandListener(){
            @Override public void onSuccess(){
              sendCommandRunnable.run();
            }
            @Override public void onError(            int executionError){
              postErrorEvent(executionError,listener);
            }
            @Override public void onTimeout(){
              postTimeoutEvent(listener);
            }
          }
);
        }
 else {
          postErrorEvent(CommandExecutionError.COMMAND_DENIED,listener);
        }
        return;
      }
 else {
        sendCommandRunnable.run();
      }
    }
  }
;
  if (!drone.getState().isArmed()) {
    if (forceArm) {
      arm(drone,true,new AbstractCommandListener(){
        @Override public void onSuccess(){
          modeCheckRunnable.run();
        }
        @Override public void onError(        int executionError){
          postErrorEvent(executionError,listener);
        }
        @Override public void onTimeout(){
          postTimeoutEvent(listener);
        }
      }
);
    }
 else {
      postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
    }
    return;
  }
  modeCheckRunnable.run();
}","static void startMission(final DroneManager droneMgr,final boolean forceModeChange,final boolean forceArm,final ICommandListener listener){
  if (droneMgr == null) {
    return;
  }
  final Drone drone=droneMgr.getDrone();
  final Runnable sendCommandRunnable=new Runnable(){
    @Override public void run(){
      msg_command_long msg=new msg_command_long();
      msg.target_system=drone.getSysid();
      msg.target_component=drone.getCompid();
      msg.command=MAV_CMD.MAV_CMD_MISSION_START;
      drone.getMavClient().sendMavMessage(msg,listener);
    }
  }
;
  final Runnable modeCheckRunnable=new Runnable(){
    @Override public void run(){
      if (drone.getState().getMode() != ApmModes.ROTOR_AUTO) {
        if (forceModeChange) {
          changeVehicleMode(drone,VehicleMode.COPTER_AUTO,new AbstractCommandListener(){
            @Override public void onSuccess(){
              sendCommandRunnable.run();
            }
            @Override public void onError(            int executionError){
              postErrorEvent(executionError,listener);
            }
            @Override public void onTimeout(){
              postTimeoutEvent(listener);
            }
          }
);
        }
 else {
          postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
        }
        return;
      }
 else {
        sendCommandRunnable.run();
      }
    }
  }
;
  if (!drone.getState().isArmed()) {
    if (forceArm) {
      arm(drone,true,new AbstractCommandListener(){
        @Override public void onSuccess(){
          modeCheckRunnable.run();
        }
        @Override public void onError(        int executionError){
          postErrorEvent(executionError,listener);
        }
        @Override public void onTimeout(){
          postTimeoutEvent(listener);
        }
      }
);
    }
 else {
      postErrorEvent(CommandExecutionError.COMMAND_FAILED,listener);
    }
    return;
  }
  modeCheckRunnable.run();
}","The original code used `COMMAND_DENIED` error when mode change was not forced, which incorrectly signaled the error type. In the fixed code, `COMMAND_FAILED` is used consistently, providing a more accurate representation of the error condition. This change ensures proper error handling and maintains clarity in reporting mission start failures when mode or arming requirements are not met."
94813,"private void notifyAttributeUpdate(String attributeEvent,Bundle extrasBundle){
  if (observersList.isEmpty())   return;
  if (attributeEvent != null) {
    for (    IObserver observer : observersList) {
      try {
        observer.onAttributeUpdated(attributeEvent,extrasBundle);
      }
 catch (      RemoteException e) {
        Log.e(TAG,e.getMessage(),e);
        try {
          removeAttributesObserver(observer);
        }
 catch (        RemoteException e1) {
          Log.e(TAG,e1.getMessage(),e1);
        }
      }
    }
  }
}","private void notifyAttributeUpdate(String attributeEvent,Bundle extrasBundle){
  if (observersList.isEmpty())   return;
  if (attributeEvent != null) {
    for (    IObserver observer : observersList) {
      try {
        observer.onAttributeUpdated(attributeEvent,extrasBundle);
      }
 catch (      RemoteException e) {
        Timber.e(e,e.getMessage());
        try {
          removeAttributesObserver(observer);
        }
 catch (        RemoteException e1) {
          Timber.e(e,e1.getMessage());
        }
      }
    }
  }
}","The original code uses Log.e for error logging, which can potentially miss critical errors or fail to provide comprehensive error tracking. The fixed code replaces Log.e with Timber.e, which offers more robust and flexible logging with better error handling and trace capabilities. This change improves error reporting, provides more detailed diagnostic information, and ensures more reliable error tracking during attribute update notifications."
94814,"private void notifyConnectionFailed(ConnectionResult result){
  if (result != null) {
    try {
      apiListener.onConnectionFailed(result);
      return;
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"",e);
    }
    checkForSelfRelease();
  }
}","private void notifyConnectionFailed(ConnectionResult result){
  if (result != null) {
    try {
      apiListener.onConnectionFailed(result);
      return;
    }
 catch (    RemoteException e) {
      Timber.w(e,""String_Node_Str"");
    }
    checkForSelfRelease();
  }
}","The original code uses Log.w(), which may not provide comprehensive logging details and can potentially suppress critical error information. The fixed code replaces Log.w() with Timber.w(), which offers more robust logging with better stack trace handling and configurable logging strategies. By updating the logging mechanism and reordering the log parameters, the code now ensures more reliable and informative error tracking during connection failures."
94815,"@Override public void onReceivedMavLinkMessage(MAVLinkMessage msg){
  if (mavlinkObserversList.isEmpty())   return;
  if (msg != null) {
    final MavlinkMessageWrapper msgWrapper=new MavlinkMessageWrapper(msg);
    for (    IMavlinkObserver observer : mavlinkObserversList) {
      try {
        observer.onMavlinkMessageReceived(msgWrapper);
      }
 catch (      RemoteException e) {
        Log.e(TAG,e.getMessage(),e);
        try {
          removeMavlinkObserver(observer);
        }
 catch (        RemoteException e1) {
          Log.e(TAG,e1.getMessage(),e1);
        }
      }
    }
  }
}","@Override public void onReceivedMavLinkMessage(MAVLinkMessage msg){
  if (mavlinkObserversList.isEmpty())   return;
  if (msg != null) {
    final MavlinkMessageWrapper msgWrapper=new MavlinkMessageWrapper(msg);
    for (    IMavlinkObserver observer : mavlinkObserversList) {
      try {
        observer.onMavlinkMessageReceived(msgWrapper);
      }
 catch (      RemoteException e) {
        Timber.e(e,e.getMessage());
        try {
          removeMavlinkObserver(observer);
        }
 catch (        RemoteException e1) {
          Timber.e(e1,e1.getMessage());
        }
      }
    }
  }
}","The original code uses `Log.e()` for error logging, which can be less robust and harder to manage in complex logging scenarios. The fixed code replaces `Log.e()` with `Timber.e()`, a more flexible and powerful logging library that provides better error tracking and easier configuration. This change enhances error handling by offering more comprehensive logging capabilities with less boilerplate code, improving debugging and error monitoring in the application."
94816,"void destroy(){
  Log.d(TAG,""String_Node_Str"" + this.ownerId);
  this.observersList.clear();
  this.mavlinkObserversList.clear();
  this.apiListener.asBinder().unlinkToDeath(this,0);
  try {
    this.service.disconnectDroneManager(this.droneMgr,this.ownerId);
  }
 catch (  ConnectionException e) {
    Log.e(TAG,e.getMessage(),e);
  }
}","void destroy(){
  Timber.d(""String_Node_Str"",this.ownerId);
  this.observersList.clear();
  this.mavlinkObserversList.clear();
  try {
    this.apiListener.asBinder().unlinkToDeath(this,0);
  }
 catch (  NoSuchElementException e) {
    Timber.e(e,e.getMessage());
  }
  try {
    this.service.disconnectDroneManager(this.droneMgr,this.ownerId);
  }
 catch (  ConnectionException e) {
    Timber.e(e,e.getMessage());
  }
}","The original code lacked proper error handling for `unlinkToDeath()` and used non-standard logging, potentially causing unexpected crashes or silently failing operations. The fixed code introduces separate try-catch blocks for `unlinkToDeath()` and `disconnectDroneManager()`, uses Timber for logging, and handles potential `NoSuchElementException` when unlinking from death. These changes improve code robustness by preventing unhandled exceptions and providing more consistent, safer resource management during object destruction."
94817,"private void checkForSelfRelease(){
  if (!apiListener.asBinder().pingBinder()) {
    Log.w(TAG,""String_Node_Str"");
    this.context.startService(new Intent(this.context,DroidPlannerService.class).setAction(DroidPlannerService.ACTION_RELEASE_API_INSTANCE).putExtra(DroidPlannerService.EXTRA_API_INSTANCE_APP_ID,this.ownerId));
  }
}","private void checkForSelfRelease(){
  if (!apiListener.asBinder().pingBinder()) {
    Timber.w(""String_Node_Str"");
    this.context.startService(new Intent(this.context,DroidPlannerService.class).setAction(DroidPlannerService.ACTION_RELEASE_API_INSTANCE).putExtra(DroidPlannerService.EXTRA_API_INSTANCE_APP_ID,this.ownerId));
  }
}","The original code used Android's Log class for logging, which may not provide optimal logging capabilities in all scenarios. The fixed code replaces Log with Timber, a more robust and flexible logging library that offers enhanced features like automatic tag generation and debug/release build logging management. By using Timber, developers gain better logging control, improved readability, and more efficient log handling across different application states."
94818,"DroneApi(DroidPlannerService dpService,Looper looper,IApiListener listener,String ownerId){
  this.service=dpService;
  this.context=dpService.getApplicationContext();
  final Handler handler=new Handler(looper);
  this.droneHandler=new DroneInterfaces.Handler(){
    @Override public void removeCallbacks(    Runnable thread){
      handler.removeCallbacks(thread);
    }
    @Override public void post(    Runnable thread){
      handler.post(thread);
    }
    @Override public void postDelayed(    Runnable thread,    long timeout){
      handler.postDelayed(thread,timeout);
    }
  }
;
  this.ownerId=ownerId;
  observersList=new ConcurrentLinkedQueue<>();
  mavlinkObserversList=new ConcurrentLinkedQueue<>();
  this.apiListener=listener;
  try {
    this.apiListener.asBinder().linkToDeath(this,0);
    checkForSelfRelease();
  }
 catch (  RemoteException e) {
    Log.e(TAG,e.getMessage(),e);
    dpService.releaseDroneApi(this.ownerId);
  }
}","DroneApi(DroidPlannerService dpService,Looper looper,IApiListener listener,String ownerId){
  this.service=dpService;
  this.context=dpService.getApplicationContext();
  final Handler handler=new Handler(looper);
  this.droneHandler=new DroneInterfaces.Handler(){
    @Override public void removeCallbacks(    Runnable thread){
      handler.removeCallbacks(thread);
    }
    @Override public void post(    Runnable thread){
      handler.post(thread);
    }
    @Override public void postDelayed(    Runnable thread,    long timeout){
      handler.postDelayed(thread,timeout);
    }
  }
;
  this.ownerId=ownerId;
  observersList=new ConcurrentLinkedQueue<>();
  mavlinkObserversList=new ConcurrentLinkedQueue<>();
  this.apiListener=listener;
  try {
    this.apiListener.asBinder().linkToDeath(this,0);
    checkForSelfRelease();
  }
 catch (  RemoteException e) {
    Timber.e(e,e.getMessage());
    dpService.releaseDroneApi(this.ownerId);
  }
}","The original code used `Log.e()` for error logging, which can be less efficient and harder to manage in Android applications. The fixed code replaces `Log.e()` with `Timber.e()`, a more robust logging library that provides better performance, easier configuration, and enhanced debugging capabilities. By using Timber, developers gain more control over logging, including easier log filtering, stacktrace preservation, and potential integration with crash reporting tools."
94819,"public static void sendCalibrationAckMessage(int count,Drone drone){
  msg_command_ack msg=new msg_command_ack();
  msg.command=(short)count;
  msg.result=MAV_CMD_ACK.MAV_CMD_ACK_OK;
  drone.getMavClient().sendMavPacket(msg.pack());
}","public static void sendCalibrationAckMessage(int count,Drone drone){
  msg_command_ack msg=new msg_command_ack();
  msg.command=count;
  msg.result=MAV_CMD_ACK.MAV_CMD_ACK_OK;
  drone.getMavClient().sendMavPacket(msg.pack());
}","The buggy code incorrectly casts the count to a short, potentially truncating or losing precision of the original integer value. In the fixed code, the count is directly assigned to msg.command without type casting, preserving the full integer value. This ensures accurate transmission of the calibration acknowledgment message without risking data loss or unintended type conversion."
94820,"/** 
 * Initiate a magnetometer calibration
 * @param drone vehicle to calibrate
 * @param retryOnFailure if true, automatically retry the magnetometer calibration if it fails
 * @param saveAutomatically if true, save the calibration automatically without user input.
 * @param startDelay positive delay in seconds before starting the calibration
 */
public static void startMagnetometerCalibration(Drone drone,boolean retryOnFailure,boolean saveAutomatically,int startDelay){
  msg_command_long msg=new msg_command_long();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.command=(short)MAV_CMD.MAV_CMD_DO_START_MAG_CAL;
  msg.param1=0;
  msg.param2=retryOnFailure ? 1 : 0;
  msg.param3=saveAutomatically ? 1 : 0;
  msg.param4=startDelay > 0 ? startDelay : 0;
  msg.param5=0;
  msg.param6=0;
  msg.param7=0;
  drone.getMavClient().sendMavPacket(msg.pack());
}","/** 
 * Initiate a magnetometer calibration
 * @param drone vehicle to calibrate
 * @param retryOnFailure if true, automatically retry the magnetometer calibration if it fails
 * @param saveAutomatically if true, save the calibration automatically without user input.
 * @param startDelay positive delay in seconds before starting the calibration
 */
public static void startMagnetometerCalibration(Drone drone,boolean retryOnFailure,boolean saveAutomatically,int startDelay){
  msg_command_long msg=new msg_command_long();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.command=MAV_CMD.MAV_CMD_DO_START_MAG_CAL;
  msg.param1=0;
  msg.param2=retryOnFailure ? 1 : 0;
  msg.param3=saveAutomatically ? 1 : 0;
  msg.param4=startDelay > 0 ? startDelay : 0;
  msg.param5=0;
  msg.param6=0;
  msg.param7=0;
  drone.getMavClient().sendMavPacket(msg.pack());
}","The buggy code incorrectly casts the MAV_CMD command to a short, potentially causing type conversion issues or unexpected behavior with the command value. In the fixed code, the direct MAV_CMD.MAV_CMD_DO_START_MAG_CAL is used without casting, ensuring proper command transmission. This change guarantees accurate command representation and prevents potential runtime errors when initiating the magnetometer calibration process."
94821,"/** 
 * Accept the magnetometer calibration result.
 * @param drone
 */
public static void acceptMagnetometerCalibration(Drone drone){
  msg_command_long msg=new msg_command_long();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.command=(short)MAV_CMD.MAV_CMD_DO_ACCEPT_MAG_CAL;
  msg.param1=0;
  msg.param2=0;
  msg.param3=0;
  msg.param4=0;
  msg.param5=0;
  msg.param6=0;
  msg.param7=0;
  drone.getMavClient().sendMavPacket(msg.pack());
}","/** 
 * Accept the magnetometer calibration result.
 * @param drone
 */
public static void acceptMagnetometerCalibration(Drone drone){
  msg_command_long msg=new msg_command_long();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.command=MAV_CMD.MAV_CMD_DO_ACCEPT_MAG_CAL;
  msg.param1=0;
  msg.param2=0;
  msg.param3=0;
  msg.param4=0;
  msg.param5=0;
  msg.param6=0;
  msg.param7=0;
  drone.getMavClient().sendMavPacket(msg.pack());
}","The original code incorrectly casts the MAV_CMD_DO_ACCEPT_MAG_CAL command to a short, which may cause type compatibility issues or unintended truncation. In the fixed code, the command is directly assigned without casting, ensuring proper type handling and avoiding potential data loss. This correction guarantees that the correct command is sent to the drone's MAV client, improving the reliability of the magnetometer calibration acceptance process."
94822,"/** 
 * Cancel the running magnetometer calibration.˛
 * @param drone
 */
public static void cancelMagnetometerCalibration(Drone drone){
  msg_command_long msg=new msg_command_long();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.command=(short)MAV_CMD.MAV_CMD_DO_CANCEL_MAG_CAL;
  msg.param1=0;
  msg.param2=0;
  msg.param3=0;
  msg.param4=0;
  msg.param5=0;
  msg.param6=0;
  msg.param7=0;
  drone.getMavClient().sendMavPacket(msg.pack());
}","/** 
 * Cancel the running magnetometer calibration.˛
 * @param drone
 */
public static void cancelMagnetometerCalibration(Drone drone){
  msg_command_long msg=new msg_command_long();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.command=MAV_CMD.MAV_CMD_DO_CANCEL_MAG_CAL;
  msg.param1=0;
  msg.param2=0;
  msg.param3=0;
  msg.param4=0;
  msg.param5=0;
  msg.param6=0;
  msg.param7=0;
  drone.getMavClient().sendMavPacket(msg.pack());
}","The buggy code cast the MAV_CMD_DO_CANCEL_MAG_CAL command to a short, which could potentially cause type conversion issues or unexpected behavior. The fixed code directly uses the enumeration value without casting, ensuring type safety and correct command transmission. By removing the unnecessary type casting, the fixed code provides a more robust and reliable method for canceling magnetometer calibration in the drone control system."
94823,"private void checkArmState(msg_heartbeat msg_heart){
  drone.getState().setArmed((msg_heart.base_mode & (byte)MAV_MODE_FLAG.MAV_MODE_FLAG_SAFETY_ARMED) == (byte)MAV_MODE_FLAG.MAV_MODE_FLAG_SAFETY_ARMED);
}","private void checkArmState(msg_heartbeat msg_heart){
  drone.getState().setArmed((msg_heart.base_mode & MAV_MODE_FLAG.MAV_MODE_FLAG_SAFETY_ARMED) == MAV_MODE_FLAG.MAV_MODE_FLAG_SAFETY_ARMED);
}","The original code incorrectly casts the bitwise operation result to a byte, which can lead to potential truncation or unexpected comparison results. The fixed code removes the unnecessary byte casting, allowing for a more direct and accurate bitwise comparison of the mode flags. This modification ensures proper bit-level checking of the drone's armed state, improving the reliability of the arm state detection logic."
94824,"private void checkIfFlying(msg_heartbeat msg_heart){
  final byte systemStatus=msg_heart.system_status;
  final boolean wasFlying=drone.getState().isFlying();
  final boolean isFlying=systemStatus == MAV_STATE.MAV_STATE_ACTIVE || (wasFlying && (systemStatus == MAV_STATE.MAV_STATE_CRITICAL || systemStatus == MAV_STATE.MAV_STATE_EMERGENCY));
  drone.getState().setIsFlying(isFlying);
}","private void checkIfFlying(msg_heartbeat msg_heart){
  final short systemStatus=msg_heart.system_status;
  final boolean wasFlying=drone.getState().isFlying();
  final boolean isFlying=systemStatus == MAV_STATE.MAV_STATE_ACTIVE || (wasFlying && (systemStatus == MAV_STATE.MAV_STATE_CRITICAL || systemStatus == MAV_STATE.MAV_STATE_EMERGENCY));
  drone.getState().setIsFlying(isFlying);
}","The original code uses `byte` for system status, which may cause incorrect interpretation of heartbeat messages due to potential sign extension or value range limitations. The fixed code changes the type to `short`, allowing a wider range of unsigned values and more accurate representation of the system status. This modification ensures proper status tracking and prevents potential misinterpretation of the drone's state during critical flight scenarios."
94825,"private void checkFailsafe(msg_heartbeat msg_heart){
  boolean failsafe2=msg_heart.system_status == (byte)MAV_STATE.MAV_STATE_CRITICAL || msg_heart.system_status == MAV_STATE.MAV_STATE_EMERGENCY;
  if (failsafe2) {
    drone.getState().repeatWarning();
  }
}","private void checkFailsafe(msg_heartbeat msg_heart){
  boolean failsafe2=msg_heart.system_status == MAV_STATE.MAV_STATE_CRITICAL || msg_heart.system_status == MAV_STATE.MAV_STATE_EMERGENCY;
  if (failsafe2) {
    drone.getState().repeatWarning();
  }
}","The original code likely contained a type casting issue with `(byte)MAV_STATE.MAV_STATE_CRITICAL`, which could cause unexpected comparison behavior. The fixed code removes the unnecessary explicit byte casting, allowing direct comparison between the system status and MAV state enums. This correction ensures accurate state comparison and prevents potential type conversion errors that might have compromised the failsafe check's reliability."
94826,"private static void requestMavlinkDataStream(MAVLinkOutputStream mAVClient,byte sysid,byte compid,int stream_id,int rate){
  msg_request_data_stream msg=new msg_request_data_stream();
  msg.target_system=sysid;
  msg.target_component=compid;
  msg.req_message_rate=(short)rate;
  msg.req_stream_id=(byte)stream_id;
  if (rate > 0) {
    msg.start_stop=1;
  }
 else {
    msg.start_stop=0;
  }
  mAVClient.sendMavPacket(msg.pack());
}","private static void requestMavlinkDataStream(MAVLinkOutputStream mAVClient,byte sysid,byte compid,int stream_id,int rate){
  msg_request_data_stream msg=new msg_request_data_stream();
  msg.target_system=sysid;
  msg.target_component=compid;
  msg.req_message_rate=rate;
  msg.req_stream_id=(short)stream_id;
  if (rate > 0) {
    msg.start_stop=1;
  }
 else {
    msg.start_stop=0;
  }
  mAVClient.sendMavPacket(msg.pack());
}","The original code incorrectly casts the rate to a short, which can cause truncation and potential data loss when dealing with message rates. In the fixed code, the rate is directly assigned without casting, and the stream_id is now correctly cast to a short to match the expected type. This ensures accurate message rate transmission and prevents potential data type conversion errors, improving the reliability of MAVLink data stream requests."
94827,"public static void sendWaypointCount(Drone drone,int count){
  msg_mission_count msg=new msg_mission_count();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.count=(short)count;
  drone.getMavClient().sendMavPacket(msg.pack());
}","public static void sendWaypointCount(Drone drone,int count){
  msg_mission_count msg=new msg_mission_count();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.count=count;
  drone.getMavClient().sendMavPacket(msg.pack());
}","The original code incorrectly casts the `count` parameter to a short, which could potentially truncate or misrepresent the actual waypoint count. The fixed code removes the unnecessary type casting, allowing the full integer value to be directly assigned to `msg.count`. This ensures accurate transmission of the complete waypoint count without risk of data loss or unintended truncation."
94828,"public static void requestWayPoint(Drone drone,int index){
  msg_mission_request msg=new msg_mission_request();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.seq=(short)index;
  drone.getMavClient().sendMavPacket(msg.pack());
}","public static void requestWayPoint(Drone drone,int index){
  msg_mission_request msg=new msg_mission_request();
  msg.target_system=drone.getSysid();
  msg.target_component=drone.getCompid();
  msg.seq=index;
  drone.getMavClient().sendMavPacket(msg.pack());
}","The original code incorrectly casts the index to a short, which may lead to potential data truncation or loss of precision for larger index values. In the fixed code, the direct assignment of index to seq eliminates the unnecessary type casting, allowing the full range of integer values to be used. This change ensures more robust and accurate waypoint request handling, preventing potential data representation issues in mission management."
94829,"/** 
 * Callback for a change in the current waypoint the MAV is heading for
 * @param seq number of the updated waypoint
 */
private void onCurrentWaypointUpdate(short seq){
}","/** 
 * Callback for a change in the current waypoint the MAV is heading for
 * @param seq number of the updated waypoint
 */
private void onCurrentWaypointUpdate(int seq){
}","The original code uses a `short` parameter for `seq`, which may limit the range of waypoint sequence numbers and potentially cause integer overflow or truncation. The fixed code changes the parameter type to `int`, providing a wider range of values and ensuring more robust handling of waypoint sequences. By using an `int`, the code can accommodate larger sequence numbers and prevent potential data loss or unexpected behavior when tracking waypoints."
94830,"public abstract void onResponse(byte commandId,boolean success);","public abstract void onResponse(short commandId,boolean success);","The original code uses a byte for commandId, which limits the range of possible command identifiers to -128 to 127, potentially causing overflow or truncation. The fixed code changes the type to short, expanding the range to -32,768 to 32,767, providing more flexibility for command identification. This modification allows for a broader set of unique command IDs, reducing the risk of conflicts and improving the method's robustness."
94831,"public void startRecording(){
  if (!isConnected() || isRecording())   return;
  sendSetRequest(GOPRO_COMMAND.GOPRO_COMMAND_SHUTTER,1,new SetResponseHandler(){
    @Override public void onResponse(    byte commandId,    boolean success){
      if (success != isRecording) {
        isRecording=success;
        drone.notifyDroneEvent(DroneEventsType.GOPRO_STATUS_UPDATE);
      }
    }
  }
);
}","public void startRecording(){
  if (!isConnected() || isRecording())   return;
  sendSetRequest(GOPRO_COMMAND.GOPRO_COMMAND_SHUTTER,1,new SetResponseHandler(){
    @Override public void onResponse(    short commandId,    boolean success){
      if (success != isRecording) {
        isRecording=success;
        drone.notifyDroneEvent(DroneEventsType.GOPRO_STATUS_UPDATE);
      }
    }
  }
);
}","The original code has an incorrect method signature for the `onResponse` callback, using `byte` for `commandId` instead of the correct `short` type. The fixed code changes the `commandId` parameter type to `short`, aligning with the expected method signature and ensuring type compatibility. This correction prevents potential type-related compilation errors and maintains proper method implementation for handling GoPro command responses."
94832,"public void stopRecording(){
  if (!isConnected() || !isRecording())   return;
  sendSetRequest(GOPRO_COMMAND.GOPRO_COMMAND_SHUTTER,0,new SetResponseHandler(){
    @Override public void onResponse(    byte commandId,    boolean success){
      if (success == isRecording) {
        isRecording=!success;
        drone.notifyDroneEvent(DroneEventsType.GOPRO_STATUS_UPDATE);
      }
    }
  }
);
}","public void stopRecording(){
  if (!isConnected() || !isRecording())   return;
  sendSetRequest(GOPRO_COMMAND.GOPRO_COMMAND_SHUTTER,0,new SetResponseHandler(){
    @Override public void onResponse(    short commandId,    boolean success){
      if (success == isRecording) {
        isRecording=!success;
        drone.notifyDroneEvent(DroneEventsType.GOPRO_STATUS_UPDATE);
      }
    }
  }
);
}","The original code has an incorrect method signature for the onResponse callback, using byte for commandId instead of the expected short type. In the fixed code, the method signature is corrected to use short commandId, matching the expected parameter type for the SetResponseHandler. This correction ensures proper type compatibility and prevents potential compilation or runtime type-related errors, improving the method's reliability and adherence to the expected interface."
94833,"/** 
 * @return the version of the mavlink protocol.
 */
public byte getMavlinkVersion(){
  return mMavlinkVersion;
}","/** 
 * @return the version of the mavlink protocol.
 */
public short getMavlinkVersion(){
  return mMavlinkVersion;
}","The original code incorrectly uses a byte return type for getMavlinkVersion(), which may truncate or misrepresent the actual version number. The fixed code changes the return type to short, providing a larger range of possible values and ensuring more accurate representation of the Mavlink protocol version. This modification allows for greater precision and prevents potential data loss when retrieving the Mavlink version."
94834,"public void setWpno(short seq){
  if (seq != currentWP) {
    this.currentWP=seq;
    myDrone.notifyDroneEvent(DroneEventsType.MISSION_WP_UPDATE);
  }
}","public void setWpno(int seq){
  if (seq != currentWP) {
    this.currentWP=seq;
    myDrone.notifyDroneEvent(DroneEventsType.MISSION_WP_UPDATE);
  }
}","The original code uses a `short` type for the sequence parameter, which may cause potential integer overflow or truncation issues with large waypoint numbers. The fixed code changes the parameter type to `int`, providing a wider range of values and preventing potential data loss or incorrect waypoint tracking. This modification ensures more robust and accurate waypoint management in the drone mission system."
94835,"public void setRadioState(short rxerrors,short fixed,byte rssi,byte remrssi,byte txbuf,byte noise,byte remnoise){
  isValid=true;
  if (this.rxerrors != rxerrors || this.fixed != fixed || this.rssi != rssi || this.remrssi != remrssi || this.txbuf != txbuf || this.noise != noise || this.remnoise != remnoise) {
    this.rxerrors=rxerrors & 0xFFFF;
    this.fixed=fixed & 0xFFFF;
    this.rssi=SikValueToDB(rssi & 0xFF);
    this.remrssi=SikValueToDB(remrssi & 0xFF);
    this.noise=SikValueToDB(noise & 0xFF);
    this.remnoise=SikValueToDB(remnoise & 0xFF);
    this.txbuf=txbuf & 0xFF;
    int currentSignalStrength=getSignalStrength();
    if (currentSignalStrength < 10.0 && previousSignalStrength >= 10.0) {
      myDrone.notifyDroneEvent(DroneEventsType.WARNING_SIGNAL_WEAK);
    }
    previousSignalStrength=currentSignalStrength;
    myDrone.notifyDroneEvent(DroneEventsType.RADIO);
  }
}","public void setRadioState(int rxerrors,int fixed,short rssi,short remrssi,short txbuf,short noise,short remnoise){
  isValid=true;
  if (this.rxerrors != rxerrors || this.fixed != fixed || this.rssi != rssi || this.remrssi != remrssi || this.txbuf != txbuf || this.noise != noise || this.remnoise != remnoise) {
    this.rxerrors=rxerrors & 0xFFFF;
    this.fixed=fixed & 0xFFFF;
    this.rssi=SikValueToDB(rssi & 0xFF);
    this.remrssi=SikValueToDB(remrssi & 0xFF);
    this.noise=SikValueToDB(noise & 0xFF);
    this.remnoise=SikValueToDB(remnoise & 0xFF);
    this.txbuf=txbuf & 0xFF;
    int currentSignalStrength=getSignalStrength();
    if (currentSignalStrength < 10.0 && previousSignalStrength >= 10.0) {
      myDrone.notifyDroneEvent(DroneEventsType.WARNING_SIGNAL_WEAK);
    }
    previousSignalStrength=currentSignalStrength;
    myDrone.notifyDroneEvent(DroneEventsType.RADIO);
  }
}","The original method used narrow primitive types (short, byte) which could lead to potential data truncation and unexpected behavior during radio state updates. The fixed code changes parameter types to wider integer types (int, short), allowing for more accurate representation of radio signal data without losing information during bitwise operations. These type changes ensure better precision and prevent potential data loss, ultimately providing a more robust implementation for handling drone radio state communications."
94836,"private void checkEkfPositionState(msg_ekf_status_report ekfStatus){
  if (ekfStatus == null)   return;
  final short flags=ekfStatus.flags;
  final boolean isOk=this.armed ? (flags & EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS) != 0 && (flags & EKF_STATUS_FLAGS.EKF_CONST_POS_MODE) == 0 : (flags & EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS) != 0 || (flags & EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_ABS) != 0;
  if (isEkfPositionOk != isOk) {
    isEkfPositionOk=isOk;
    myDrone.notifyDroneEvent(DroneEventsType.EKF_POSITION_STATE_UPDATE);
  }
}","private void checkEkfPositionState(msg_ekf_status_report ekfStatus){
  if (ekfStatus == null)   return;
  final int flags=ekfStatus.flags;
  final boolean isOk=this.armed ? (flags & EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS) != 0 && (flags & EKF_STATUS_FLAGS.EKF_CONST_POS_MODE) == 0 : (flags & EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS) != 0 || (flags & EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_ABS) != 0;
  if (isEkfPositionOk != isOk) {
    isEkfPositionOk=isOk;
    myDrone.notifyDroneEvent(DroneEventsType.EKF_POSITION_STATE_UPDATE);
  }
}","The original code used `short` for flags, which might cause potential bitwise operation issues with certain flag values. The fixed code changes `short` to `int`, ensuring full compatibility with all possible flag values and preventing potential bitwise operation truncation. This modification provides more robust and reliable flag checking, preventing potential unexpected behavior when interpreting EKF status flags."
94837,"public HashMap<Byte,Info> getMagCalibrationTracker(){
  return magCalibrationTracker;
}","public HashMap<Short,Info> getMagCalibrationTracker(){
  return magCalibrationTracker;
}","The original code uses `Byte` as the HashMap key type, which limits the range of unique keys to only 256 possible values (-128 to 127). The fixed code changes the key type to `Short`, expanding the key range to 65,536 unique values (-32,768 to 32,767), providing more flexibility for storing magnetic calibration tracking data. This modification allows for a broader and more comprehensive representation of calibration information without constraining the key space."
94838,"public void putUnsignedByte(short data){
  if (data < UNSIGNED_BYTE_MIN_VALUE || data > UNSIGNED_BYTE_MAX_VALUE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  putByte((byte)data);
}","public void putUnsignedByte(short data){
  if (data < UNSIGNED_BYTE_MIN_VALUE || data > UNSIGNED_BYTE_MAX_VALUE) {
    throw new IllegalArgumentException(""String_Node_Str"" + data);
  }
  putByte((byte)data);
}","The original code throws an IllegalArgumentException with a static error message, which doesn't provide helpful context about the specific invalid value. The fixed code appends the actual data value to the error message, enabling more precise error diagnosis by showing the exact number that failed the validation range check. This modification enhances debugging by providing concrete information about which input caused the exception, making troubleshooting more straightforward for developers."
94839,"public void putUnsignedShort(int data){
  if (data < UNSIGNED_SHORT_MIN_VALUE || data > UNSIGNED_SHORT_MAX_VALUE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  putShort((short)data);
}","public void putUnsignedShort(int data){
  if (data < UNSIGNED_SHORT_MIN_VALUE || data > UNSIGNED_SHORT_MAX_VALUE) {
    throw new IllegalArgumentException(""String_Node_Str"" + data);
  }
  putShort((short)data);
}","The original code throws an IllegalArgumentException with a generic error message that provides no context about the actual invalid value. The fixed code appends the problematic data value to the error message, enabling developers to understand precisely which value caused the exception. This enhancement improves debugging by providing more informative error details, helping developers quickly identify and resolve input validation issues."
94840,"public void putUnsignedLong(long data){
  if (data < UNSIGNED_LONG_MIN_VALUE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  putLong(data);
}","public void putUnsignedLong(long data){
  if (data < UNSIGNED_LONG_MIN_VALUE) {
    throw new IllegalArgumentException(""String_Node_Str"" + data);
  }
  putLong(data);
}","The original code lacks proper error message context when throwing an IllegalArgumentException, making debugging difficult. The fixed code appends the actual data value to the error message, providing crucial diagnostic information about the specific input that triggered the exception. This enhancement improves error reporting by enabling developers to quickly identify the problematic value during troubleshooting."
94841,"public void putUnsignedInt(long data){
  if (data < UNSIGNED_INT_MIN_VALUE || data > UNSIGNED_INT_MAX_VALUE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  putInt((int)data);
}","public void putUnsignedInt(long data){
  if (data < UNSIGNED_INT_MIN_VALUE || data > UNSIGNED_INT_MAX_VALUE) {
    throw new IllegalArgumentException(""String_Node_Str"" + data);
  }
  putInt((int)data);
}","The original code's exception message lacks context, making debugging difficult when an out-of-range value is passed. The fixed code appends the actual data value to the exception message, providing crucial diagnostic information about which specific value triggered the range validation. This enhancement enables developers to quickly identify and understand the source of the out-of-range error during runtime."
94842,"public void receiveData(MAVLinkMessage msg){
  if (drone.getParameters().processMessage(msg)) {
    return;
  }
  drone.getWaypointManager().processMessage(msg);
  drone.getCalibrationSetup().processMessage(msg);
switch (msg.msgid) {
case msg_attitude.MAVLINK_MSG_ID_ATTITUDE:
    msg_attitude m_att=(msg_attitude)msg;
  drone.getOrientation().setRollPitchYaw(m_att.roll * 180.0 / Math.PI,m_att.pitch * 180.0 / Math.PI,m_att.yaw * 180.0 / Math.PI);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
msg_vfr_hud m_hud=(msg_vfr_hud)msg;
drone.setAltitudeGroundAndAirSpeeds(m_hud.alt,m_hud.groundspeed,m_hud.airspeed,m_hud.climb);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
drone.getMissionStats().setWpno(((msg_mission_current)msg).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)msg;
drone.setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
drone.getNavigation().setNavPitchRollYaw(m_nav.nav_pitch,m_nav.nav_roll,m_nav.nav_bearing);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)msg;
drone.getMagnetometer().newData(msg_imu);
break;
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
msg_heartbeat msg_heart=(msg_heartbeat)msg;
drone.setType(msg_heart.type);
checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,drone.getType());
if (drone.getState().setMode(newMode)) {
if (this.commandTracker != null) {
this.commandTracker.onCommandAck(msg_set_mode.MAVLINK_MSG_ID_SET_MODE,newMode);
}
}
drone.onHeartbeat(msg_heart);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
drone.getGps().setPosition(((msg_global_position_int)msg).lat / 1E7,((msg_global_position_int)msg).lon / 1E7);
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)msg;
drone.getBattery().setBatteryState(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
checkControlSensorsHealth(m_sys);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)msg;
drone.getRadio().setRadioState(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_radio_status.MAVLINK_MSG_ID_RADIO_STATUS:
msg_radio_status m_radio_status=(msg_radio_status)msg;
drone.getRadio().setRadioState(m_radio_status.rxerrors,m_radio_status.fixed,m_radio_status.rssi,m_radio_status.remrssi,m_radio_status.txbuf,m_radio_status.noise,m_radio_status.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
drone.getGps().setGpsState(((msg_gps_raw_int)msg).fix_type,((msg_gps_raw_int)msg).satellites_visible,((msg_gps_raw_int)msg).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
drone.getRC().setRcInputValues((msg_rc_channels_raw)msg);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
drone.getRC().setRcOutputValues((msg_servo_output_raw)msg);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)msg;
processStatusText(msg_statustext);
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
drone.getCamera().newImageLocation((msg_camera_feedback)msg);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
drone.getCamera().updateMountOrientation(((msg_mount_status)msg));
break;
case msg_named_value_int.MAVLINK_MSG_ID_NAMED_VALUE_INT:
processNamedValueInt((msg_named_value_int)msg);
break;
case msg_gopro_heartbeat.MAVLINK_MSG_ID_GOPRO_HEARTBEAT:
drone.getGoProImpl().onHeartBeat((msg_gopro_heartbeat)msg);
break;
case msg_gopro_set_response.MAVLINK_MSG_ID_GOPRO_SET_RESPONSE:
drone.getGoProImpl().onResponseReceived((msg_gopro_set_response)msg);
break;
case msg_gopro_get_response.MAVLINK_MSG_ID_GOPRO_GET_RESPONSE:
drone.getGoProImpl().onResponseReceived((msg_gopro_get_response)msg);
break;
case msg_mag_cal_progress.MAVLINK_MSG_ID_MAG_CAL_PROGRESS:
case msg_mag_cal_report.MAVLINK_MSG_ID_MAG_CAL_REPORT:
drone.getMagnetometerCalibration().processCalibrationMessage(msg);
break;
case msg_ekf_status_report.MAVLINK_MSG_ID_EKF_STATUS_REPORT:
drone.getState().setEkfStatus((msg_ekf_status_report)msg);
break;
case msg_mission_item.MAVLINK_MSG_ID_MISSION_ITEM:
msg_mission_item missionItem=(msg_mission_item)msg;
if (missionItem.seq == Home.HOME_WAYPOINT_INDEX) {
drone.getHome().setHome(missionItem);
}
break;
case msg_command_ack.MAVLINK_MSG_ID_COMMAND_ACK:
final msg_command_ack commandAck=(msg_command_ack)msg;
handleCommandAck(commandAck);
break;
default :
break;
}
}","public void receiveData(MAVLinkMessage msg){
  if (drone.getParameters().processMessage(msg)) {
    return;
  }
  drone.getWaypointManager().processMessage(msg);
  drone.getCalibrationSetup().processMessage(msg);
switch (msg.msgid) {
case msg_attitude.MAVLINK_MSG_ID_ATTITUDE:
    msg_attitude m_att=(msg_attitude)msg;
  drone.getOrientation().setRollPitchYaw(m_att.roll * 180.0 / Math.PI,m_att.pitch * 180.0 / Math.PI,m_att.yaw * 180.0 / Math.PI);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
msg_vfr_hud m_hud=(msg_vfr_hud)msg;
drone.setAltitudeGroundAndAirSpeeds(m_hud.alt,m_hud.groundspeed,m_hud.airspeed,m_hud.climb);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
drone.getMissionStats().setWpno(((msg_mission_current)msg).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)msg;
drone.setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
drone.getNavigation().setNavPitchRollYaw(m_nav.nav_pitch,m_nav.nav_roll,m_nav.nav_bearing);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)msg;
drone.getMagnetometer().newData(msg_imu);
break;
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
msg_heartbeat msg_heart=(msg_heartbeat)msg;
drone.setType(msg_heart.type);
checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,drone.getType());
drone.getState().setMode(newMode);
drone.onHeartbeat(msg_heart);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
drone.getGps().setPosition(((msg_global_position_int)msg).lat / 1E7,((msg_global_position_int)msg).lon / 1E7);
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)msg;
drone.getBattery().setBatteryState(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
checkControlSensorsHealth(m_sys);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)msg;
drone.getRadio().setRadioState(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_radio_status.MAVLINK_MSG_ID_RADIO_STATUS:
msg_radio_status m_radio_status=(msg_radio_status)msg;
drone.getRadio().setRadioState(m_radio_status.rxerrors,m_radio_status.fixed,m_radio_status.rssi,m_radio_status.remrssi,m_radio_status.txbuf,m_radio_status.noise,m_radio_status.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
drone.getGps().setGpsState(((msg_gps_raw_int)msg).fix_type,((msg_gps_raw_int)msg).satellites_visible,((msg_gps_raw_int)msg).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
drone.getRC().setRcInputValues((msg_rc_channels_raw)msg);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
drone.getRC().setRcOutputValues((msg_servo_output_raw)msg);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)msg;
processStatusText(msg_statustext);
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
drone.getCamera().newImageLocation((msg_camera_feedback)msg);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
drone.getCamera().updateMountOrientation(((msg_mount_status)msg));
break;
case msg_named_value_int.MAVLINK_MSG_ID_NAMED_VALUE_INT:
processNamedValueInt((msg_named_value_int)msg);
break;
case msg_gopro_heartbeat.MAVLINK_MSG_ID_GOPRO_HEARTBEAT:
drone.getGoProImpl().onHeartBeat((msg_gopro_heartbeat)msg);
break;
case msg_gopro_set_response.MAVLINK_MSG_ID_GOPRO_SET_RESPONSE:
drone.getGoProImpl().onResponseReceived((msg_gopro_set_response)msg);
break;
case msg_gopro_get_response.MAVLINK_MSG_ID_GOPRO_GET_RESPONSE:
drone.getGoProImpl().onResponseReceived((msg_gopro_get_response)msg);
break;
case msg_mag_cal_progress.MAVLINK_MSG_ID_MAG_CAL_PROGRESS:
case msg_mag_cal_report.MAVLINK_MSG_ID_MAG_CAL_REPORT:
drone.getMagnetometerCalibration().processCalibrationMessage(msg);
break;
case msg_ekf_status_report.MAVLINK_MSG_ID_EKF_STATUS_REPORT:
drone.getState().setEkfStatus((msg_ekf_status_report)msg);
break;
case msg_mission_item.MAVLINK_MSG_ID_MISSION_ITEM:
msg_mission_item missionItem=(msg_mission_item)msg;
if (missionItem.seq == Home.HOME_WAYPOINT_INDEX) {
drone.getHome().setHome(missionItem);
}
break;
case msg_command_ack.MAVLINK_MSG_ID_COMMAND_ACK:
final msg_command_ack commandAck=(msg_command_ack)msg;
handleCommandAck(commandAck);
break;
default :
break;
}
}","The original code unnecessarily checked and potentially triggered a command tracker when setting a new drone mode, which could lead to unintended side effects. In the fixed code, the redundant command tracking logic is removed, and the drone mode is directly set using `drone.getState().setMode(newMode)`. This simplifies the mode-setting process, reduces potential error sources, and ensures a more straightforward and reliable mode transition for the drone's state management."
94843,"public DroneImpl(MAVLinkStreams.MAVLinkOutputStream mavClient,DroneInterfaces.Clock clock,DroneInterfaces.Handler handler,Preferences pref,AutopilotWarningParser warningParser,LogMessageListener logListener){
  this.MavClient=mavClient;
  this.preferences=pref;
  this.logListener=logListener;
  events=new DroneEvents(this,handler);
  state=new State(this,clock,handler,warningParser);
  heartbeat=new HeartBeat(this,handler);
  parameters=new Parameters(this,handler);
  this.waypointManager=new WaypointManager(this,handler);
  RC=new RC(this);
  GPS=new GPS(this);
  this.type=new Type(this);
  this.speed=new Speed(this);
  this.battery=new Battery(this);
  this.radio=new Radio(this);
  this.home=new Home(this);
  this.mission=new Mission(this);
  this.missionStats=new MissionStats(this);
  this.streamRates=new StreamRates(this);
  this.altitude=new Altitude(this);
  this.orientation=new Orientation(this);
  this.navigation=new Navigation(this);
  this.guidedPoint=new GuidedPoint(this,handler);
  this.accelCalibrationSetup=new AccelCalibration(this);
  this.magCalibration=new MagnetometerCalibrationImpl(this);
  this.mag=new Magnetometer(this);
  this.footprints=new Camera(this);
  this.goProImpl=new GoProImpl(this,handler);
  loadVehicleProfile();
}","public DroneImpl(MAVLinkStreams.MAVLinkOutputStream mavClient,DroneInterfaces.Clock clock,DroneInterfaces.Handler handler,Preferences pref,AutopilotWarningParser warningParser,LogMessageListener logListener){
  this.MavClient=mavClient;
  this.preferences=pref;
  this.logListener=logListener;
  events=new DroneEvents(this,handler);
  state=new State(this,clock,handler,warningParser);
  heartbeat=new HeartBeat(this,handler);
  parameters=new Parameters(this,handler);
  this.waypointManager=new WaypointManager(this,handler);
  RC=new RC(this);
  GPS=new GPS(this);
  this.type=new Type(this);
  this.speed=new Speed(this);
  this.battery=new Battery(this);
  this.radio=new Radio(this);
  this.home=new Home(this);
  this.mission=new Mission(this);
  this.missionStats=new MissionStats(this);
  this.streamRates=new StreamRates(this);
  this.altitude=new Altitude(this);
  this.orientation=new Orientation(this);
  this.navigation=new Navigation(this);
  this.guidedPoint=new GuidedPoint(this,handler);
  this.accelCalibrationSetup=new AccelCalibration(this,handler);
  this.magCalibration=new MagnetometerCalibrationImpl(this);
  this.mag=new Magnetometer(this);
  this.footprints=new Camera(this);
  this.goProImpl=new GoProImpl(this,handler);
  loadVehicleProfile();
}","The original code incorrectly initialized the AccelCalibration without passing the handler parameter, potentially causing configuration or event handling issues. In the fixed code, the AccelCalibration constructor is updated to include the handler, ensuring proper initialization and event management. This correction guarantees that the AccelCalibration component is fully configured with the necessary event handling mechanism, improving the overall reliability and functionality of the drone implementation."
94844,"public boolean setMode(ApmModes mode){
  if (this.mode != mode) {
    this.mode=mode;
    myDrone.notifyDroneEvent(DroneEventsType.MODE);
    return true;
  }
  return false;
}","public void setMode(ApmModes mode){
  if (this.mode != mode) {
    this.mode=mode;
    myDrone.notifyDroneEvent(DroneEventsType.MODE);
  }
}","The original code unnecessarily returned a boolean value, suggesting a method that indicates mode change success, which doesn't align with the method's actual implementation. The fixed code removes the return statement, converting the method to void and simplifying its purpose of updating the drone's mode and triggering a notification event. By eliminating the redundant boolean return, the code becomes more straightforward and focuses on its primary responsibility of mode configuration."
94845,"@Override public void onError(int executionError){
  if (listener != null) {
    try {
      listener.onError(executionError);
    }
 catch (    RemoteException e) {
      Timber.e(e,e.getMessage());
    }
  }
}","@Override public void onError(int executionError){
  final ICommandListener listener=listenerRef.getAndSet(null);
  if (listener != null) {
    try {
      listener.onError(executionError);
    }
 catch (    RemoteException e) {
      Timber.e(e,e.getMessage());
    }
  }
}","The original code lacks thread-safe handling of the listener, risking potential race conditions and memory leaks. The fixed code uses `listenerRef.getAndSet(null)` to atomically retrieve and clear the listener reference, ensuring that it can only be used once and preventing multiple invocations. This approach improves reliability by eliminating the possibility of repeated error callbacks and potential resource contention in a concurrent environment."
94846,"public void processMessage(MAVLinkMessage msg){
  if (calibrating && msg.msgid == msg_statustext.MAVLINK_MSG_ID_STATUSTEXT) {
    msg_statustext statusMsg=(msg_statustext)msg;
    final String message=statusMsg.getText();
    if (message != null && (message.startsWith(""String_Node_Str"") || message.startsWith(""String_Node_Str""))) {
      mavMsg=message;
      if (message.startsWith(""String_Node_Str""))       calibrating=false;
      myDrone.notifyDroneEvent(DroneEventsType.CALIBRATION_IMU);
    }
  }
}","public void processMessage(MAVLinkMessage msg){
  if (calibrating && msg.msgid == msg_statustext.MAVLINK_MSG_ID_STATUSTEXT) {
    msg_statustext statusMsg=(msg_statustext)msg;
    final String message=statusMsg.getText();
    if (message != null && (message.startsWith(""String_Node_Str"") || message.startsWith(""String_Node_Str""))) {
      handler.post(onCalibrationStart);
      mavMsg=message;
      if (message.startsWith(""String_Node_Str""))       calibrating=false;
      myDrone.notifyDroneEvent(DroneEventsType.CALIBRATION_IMU);
    }
  }
}","The original code lacks proper thread synchronization when processing calibration messages, potentially causing race conditions or UI update issues. The fixed code introduces `handler.post(onCalibrationStart)`, which ensures thread-safe UI updates and proper event handling by dispatching the calibration start event to the main thread. This modification improves code reliability by preventing potential threading-related bugs and ensuring smoother interaction between background message processing and UI components."
94847,"@Override public void onTimeout(){
  if (listener != null) {
    try {
      listener.onTimeout();
    }
 catch (    RemoteException e) {
      Timber.e(e,e.getMessage());
    }
  }
}","@Override public void onTimeout(){
  final ICommandListener listener=listenerRef.getAndSet(null);
  if (listener != null) {
    try {
      listener.onTimeout();
    }
 catch (    RemoteException e) {
      Timber.e(e,e.getMessage());
    }
  }
}","The original code lacks thread-safety and can lead to potential race conditions with the listener reference. The fixed code introduces `listenerRef.getAndSet(null)`, which atomically retrieves the listener and sets it to null, preventing multiple concurrent calls and ensuring the listener is used only once. This modification guarantees thread-safe, single-use listener execution, reducing the risk of unexpected behavior in concurrent scenarios."
94848,"public void startCalibration(final ICommandListener listener){
  if (calibrating) {
    if (listener != null) {
      try {
        listener.onSuccess();
      }
 catch (      RemoteException e) {
        Timber.e(e,e.getMessage());
      }
    }
    return;
  }
  if (myDrone.getState().isFlying()) {
    calibrating=false;
  }
 else {
    MavLinkCalibration.startAccelerometerCalibration(myDrone,new SimpleCommandListener(){
      @Override public void onSuccess(){
        calibrating=true;
        mavMsg=""String_Node_Str"";
        if (listener != null) {
          try {
            listener.onSuccess();
          }
 catch (          RemoteException e) {
            Timber.e(e,e.getMessage());
          }
        }
      }
      @Override public void onError(      int executionError){
        if (listener != null) {
          try {
            listener.onError(executionError);
          }
 catch (          RemoteException e) {
            Timber.e(e,e.getMessage());
          }
        }
      }
      @Override public void onTimeout(){
        if (listener != null) {
          try {
            listener.onTimeout();
          }
 catch (          RemoteException e) {
            Timber.e(e,e.getMessage());
          }
        }
      }
    }
);
  }
}","public void startCalibration(ICommandListener listener){
  if (calibrating) {
    if (listener != null) {
      try {
        listener.onSuccess();
      }
 catch (      RemoteException e) {
        Timber.e(e,e.getMessage());
      }
    }
    return;
  }
  if (myDrone.getState().isFlying()) {
    calibrating=false;
  }
 else {
    calibrating=true;
    mavMsg=""String_Node_Str"";
    listenerRef.set(listener);
    MavLinkCalibration.startAccelerometerCalibration(myDrone,new SimpleCommandListener(){
      @Override public void onSuccess(){
        final ICommandListener listener=listenerRef.getAndSet(null);
        if (listener != null) {
          try {
            listener.onSuccess();
          }
 catch (          RemoteException e) {
            Timber.e(e,e.getMessage());
          }
        }
      }
      @Override public void onError(      int executionError){
        final ICommandListener listener=listenerRef.getAndSet(null);
        if (listener != null) {
          try {
            listener.onError(executionError);
          }
 catch (          RemoteException e) {
            Timber.e(e,e.getMessage());
          }
        }
      }
      @Override public void onTimeout(){
        final ICommandListener listener=listenerRef.getAndSet(null);
        if (listener != null) {
          try {
            listener.onTimeout();
          }
 catch (          RemoteException e) {
            Timber.e(e,e.getMessage());
          }
        }
      }
    }
);
  }
}","The original code had potential race conditions and inconsistent state management for the calibration process. The fixed code introduces a thread-safe AtomicReference (listenerRef) to store and manage the listener, ensuring that the listener is properly tracked and only called once during the calibration process. By using listenerRef.getAndSet(null), the code guarantees that the listener is safely retrieved and cleared, preventing multiple callbacks and potential synchronization issues."
94849,"public AccelCalibration(Drone drone){
  super(drone);
  drone.addDroneListener(this);
}","public AccelCalibration(Drone drone,DroneInterfaces.Handler handler){
  super(drone);
  this.handler=handler;
  drone.addDroneListener(this);
}","The original code lacks a crucial handler parameter, which is likely necessary for managing asynchronous drone listener operations. The fixed code introduces a new constructor parameter `DroneInterfaces.Handler` and assigns it to a class member `handler`, enabling proper handler management and synchronization. This modification ensures more robust listener handling and provides the necessary infrastructure for controlling drone-related events and callbacks."
94850,"@Override public void onSuccess(){
  calibrating=true;
  mavMsg=""String_Node_Str"";
  if (listener != null) {
    try {
      listener.onSuccess();
    }
 catch (    RemoteException e) {
      Timber.e(e,e.getMessage());
    }
  }
}","@Override public void onSuccess(){
  final ICommandListener listener=listenerRef.getAndSet(null);
  if (listener != null) {
    try {
      listener.onSuccess();
    }
 catch (    RemoteException e) {
      Timber.e(e,e.getMessage());
    }
  }
}","The original code incorrectly persists the `calibrating` flag and sets a mavMsg without proper thread synchronization, potentially causing race conditions. The fixed code uses `listenerRef.getAndSet(null)` to atomically retrieve and clear the listener reference, ensuring thread-safe listener handling and preventing multiple invocations. This approach prevents memory leaks, improves thread safety, and provides a more robust mechanism for managing callback listeners."
94851,"@Override public void sendMavMessage(MAVLinkMessage message,int sysId,int compId,ICommandListener listener){
  if (this.connParams == null || message == null) {
    return;
  }
  final MAVLinkPacket packet=message.pack();
  packet.sysid=sysId;
  packet.compid=compId;
  packet.seq=packetSeqNumber;
  if (mavLinkApi.sendData(this.connParams,packet)) {
    packetSeqNumber=(packetSeqNumber + 1) % (MAX_PACKET_SEQUENCE + 1);
    if (commandTracker != null && listener != null) {
      if (message instanceof msg_command_long) {
        commandTracker.onCommandSubmitted((msg_command_long)message,listener);
      }
    }
  }
}","@Override public void sendMavMessage(MAVLinkMessage message,int sysId,int compId,ICommandListener listener){
  if (this.connParams == null || message == null) {
    return;
  }
  final MAVLinkPacket packet=message.pack();
  packet.sysid=sysId;
  packet.compid=compId;
  packet.seq=packetSeqNumber;
  if (mavLinkApi.sendData(this.connParams,packet)) {
    packetSeqNumber=(packetSeqNumber + 1) % (MAX_PACKET_SEQUENCE + 1);
    if (commandTracker != null && listener != null) {
      commandTracker.onCommandSubmitted(message,listener);
    }
  }
}","The original code incorrectly narrowed the command tracking to only `msg_command_long` messages, limiting the tracking functionality to a specific message type. The fixed code modifies the `onCommandSubmitted` method call to pass the generic `message` instead of casting it to `msg_command_long`, allowing tracking for all MAVLink message types. This change provides more flexible and comprehensive command tracking across different message types in the MAVLink communication protocol."
94852,"private void onCommandSubmittedImpl(final msg_set_mode command,ICommandListener listener){
  final int commandId=command.msgid;
  final CallbackKey<ApmModes> key=new CallbackKey<ApmModes>(commandId){
    @Override public int checkAckResult(    ApmModes result){
      return result.getNumber() == command.custom_mode ? AckCallback.COMMAND_SUCCEED : CommandExecutionError.COMMAND_FAILED;
    }
  }
;
  final AckCallback callback=new AckCallback(listener,commandId);
  keyStore.put(commandId,key);
  callbackStore.put(key,callback);
  handler.postDelayed(callback,COMMAND_TIMEOUT_PERIOD);
}","private void onCommandSubmittedImpl(final msg_set_mode command,ICommandListener listener){
  final int commandId=command.msgid;
  final CallbackKey<msg_command_ack> key=new CallbackKey<msg_command_ack>(commandId){
    @Override public int checkAckResult(    msg_command_ack result){
      return result.result;
    }
  }
;
  final AckCallback callback=new AckCallback(listener,commandId);
  keyStore.put(commandId,key);
  callbackStore.put(key,callback);
  handler.postDelayed(callback,COMMAND_TIMEOUT_PERIOD);
}","The original code incorrectly used ApmModes for result checking, which doesn't match the standard command acknowledgment mechanism in mavlink protocol. The fixed code replaces ApmModes with msg_command_ack, using its native result field for proper command status validation. This modification ensures accurate command acknowledgment tracking by directly utilizing the standard mavlink command acknowledgment message type and its predefined result field."
94853,"@Override public void onCommandAck(int commandId,Object ack){
switch (commandId) {
case msg_command_ack.MAVLINK_MSG_ID_COMMAND_ACK:
    onCommandAckImpl((msg_command_ack)ack);
  break;
case msg_set_mode.MAVLINK_MSG_ID_SET_MODE:
onCommandAckImpl((ApmModes)ack);
break;
}
}","@Override public void onCommandAck(int commandId,Object ack){
switch (commandId) {
case msg_command_ack.MAVLINK_MSG_ID_COMMAND_ACK:
    onCommandAckImpl((msg_command_ack)ack);
  break;
}
}","The original code incorrectly includes an additional case for `msg_set_mode` with an inappropriate type casting, which could lead to runtime errors. The fixed code removes the problematic case, leaving only the valid `msg_command_ack` handling with correct type casting. This simplification prevents potential type mismatch exceptions and ensures the method only processes the specific `MAVLINK_MSG_ID_COMMAND_ACK` message type safely and correctly."
94854,"private void onCommandAckImpl(ApmModes mode){
  final CallbackKey<ApmModes> key=keyStore.get(msg_set_mode.MAVLINK_MSG_ID_SET_MODE);
  if (key == null)   return;
  final AckCallback callback=callbackStore.remove(key);
  if (callback != null) {
    handler.removeCallbacks(callback);
    callback.setAckResult(key.checkAckResult(mode));
    handler.post(callback);
  }
}","private void onCommandAckImpl(msg_command_ack ack){
  final CallbackKey<msg_command_ack> key=keyStore.get(ack.command);
  if (key == null)   return;
  final AckCallback callback=callbackStore.remove(key);
  if (callback != null) {
    handler.removeCallbacks(callback);
    callback.setAckResult(key.checkAckResult(ack));
    handler.post(callback);
  }
}","The original code incorrectly uses a hardcoded MAVLINK message ID and ApmModes for command acknowledgment, which limits flexibility and may not handle different message types accurately. The fixed code introduces a more generic approach by accepting a msg_command_ack parameter, using the actual command from the acknowledgment message to retrieve the corresponding callback key. This modification provides a more robust and adaptable method for processing command acknowledgments across various MAVLink message types and scenarios."
94855,"@Override public void performAction(Action action) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    final float bearing=DroneApiUtils.generateDronie(getDrone());
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyAttributeUpdate(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
break;
case MissionActions.ACTION_LOAD_WAYPOINTS:
DroneApiUtils.loadWaypoints(getDrone());
break;
case MissionActions.ACTION_SET_MISSION:
data.setClassLoader(Mission.class.getClassLoader());
Mission mission=data.getParcelable(MissionActions.EXTRA_MISSION);
boolean pushToDrone=data.getBoolean(MissionActions.EXTRA_PUSH_TO_DRONE);
DroneApiUtils.setMission(getDrone(),mission,pushToDrone);
break;
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
DroneApiUtils.buildComplexMissionItem(getDrone(),data);
break;
case ConnectionActions.ACTION_CONNECT:
data.setClassLoader(ConnectionParameter.class.getClassLoader());
ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case ExperimentalActions.ACTION_EPM_COMMAND:
boolean release=data.getBoolean(ExperimentalActions.EXTRA_EPM_RELEASE);
DroneApiUtils.epmCommand(getDrone(),release);
break;
case ExperimentalActions.ACTION_TRIGGER_CAMERA:
DroneApiUtils.triggerCamera(getDrone());
break;
case ExperimentalActions.ACTION_SEND_MAVLINK_MESSAGE:
data.setClassLoader(MavlinkMessageWrapper.class.getClassLoader());
MavlinkMessageWrapper messageWrapper=data.getParcelable(ExperimentalActions.EXTRA_MAVLINK_MESSAGE);
DroneApiUtils.sendMavlinkMessage(getDrone(),messageWrapper);
break;
case ExperimentalActions.ACTION_SET_RELAY:
if (droneMgr != null) {
int relayNumber=data.getInt(ExperimentalActions.EXTRA_RELAY_NUMBER);
boolean isOn=data.getBoolean(ExperimentalActions.EXTRA_IS_RELAY_ON);
MavLinkDoCmds.setRelay(droneMgr.getDrone(),relayNumber,isOn);
}
case ExperimentalActions.ACTION_SET_SERVO:
if (droneMgr != null) {
int channel=data.getInt(ExperimentalActions.EXTRA_SERVO_CHANNEL);
int pwm=data.getInt(ExperimentalActions.EXTRA_SERVO_PWM);
MavLinkDoCmds.setServo(droneMgr.getDrone(),channel,pwm);
}
break;
case GuidedActions.ACTION_DO_GUIDED_TAKEOFF:
double takeoffAltitude=data.getDouble(GuidedActions.EXTRA_ALTITUDE);
DroneApiUtils.doGuidedTakeoff(getDrone(),takeoffAltitude);
break;
case GuidedActions.ACTION_SEND_GUIDED_POINT:
data.setClassLoader(LatLong.class.getClassLoader());
boolean force=data.getBoolean(GuidedActions.EXTRA_FORCE_GUIDED_POINT);
LatLong guidedPoint=data.getParcelable(GuidedActions.EXTRA_GUIDED_POINT);
DroneApiUtils.sendGuidedPoint(getDrone(),guidedPoint,force);
break;
case GuidedActions.ACTION_SET_GUIDED_ALTITUDE:
double guidedAltitude=data.getDouble(GuidedActions.EXTRA_ALTITUDE);
DroneApiUtils.setGuidedAltitude(getDrone(),guidedAltitude);
break;
case ParameterActions.ACTION_REFRESH_PARAMETERS:
DroneApiUtils.refreshParameters(getDrone());
break;
case ParameterActions.ACTION_WRITE_PARAMETERS:
data.setClassLoader(Parameters.class.getClassLoader());
Parameters parameters=data.getParcelable(ParameterActions.EXTRA_PARAMETERS);
DroneApiUtils.writeParameters(getDrone(),parameters);
break;
case StateActions.ACTION_ARM:
boolean doArm=data.getBoolean(StateActions.EXTRA_ARM);
DroneApiUtils.arm(getDrone(),doArm);
break;
case StateActions.ACTION_SET_VEHICLE_MODE:
data.setClassLoader(VehicleMode.class.getClassLoader());
VehicleMode newMode=data.getParcelable(StateActions.EXTRA_VEHICLE_MODE);
DroneApiUtils.changeVehicleMode(getDrone(),newMode);
break;
case CalibrationActions.ACTION_START_IMU_CALIBRATION:
if (!DroneApiUtils.startIMUCalibration(getDrone())) {
Bundle extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,context.getString(R.string.failed_start_calibration_message));
notifyAttributeUpdate(AttributeEvent.CALIBRATION_IMU_ERROR,extrasBundle);
}
break;
case CalibrationActions.ACTION_SEND_IMU_CALIBRATION_ACK:
int imuAck=data.getInt(CalibrationActions.EXTRA_IMU_STEP);
DroneApiUtils.sendIMUCalibrationAck(getDrone(),imuAck);
break;
case CalibrationActions.ACTION_START_MAGNETOMETER_CALIBRATION:
final boolean retryOnFailure=data.getBoolean(CalibrationActions.EXTRA_RETRY_ON_FAILURE,false);
final boolean saveAutomatically=data.getBoolean(CalibrationActions.EXTRA_SAVE_AUTOMATICALLY,true);
final int startDelay=data.getInt(CalibrationActions.EXTRA_START_DELAY,0);
DroneApiUtils.startMagnetometerCalibration(getDrone(),retryOnFailure,saveAutomatically,startDelay);
break;
case CalibrationActions.ACTION_CANCEL_MAGNETOMETER_CALIBRATION:
DroneApiUtils.cancelMagnetometerCalibration(getDrone());
break;
case CalibrationActions.ACTION_ACCEPT_MAGNETOMETER_CALIBRATION:
DroneApiUtils.acceptMagnetometerCalibration(getDrone());
break;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
DroneApiUtils.enableFollowMe(getDroneManager(),droneHandler,followType);
break;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (droneMgr != null) {
data.setClassLoader(LatLong.class.getClassLoader());
final FollowAlgorithm followAlgorithm=this.droneMgr.getFollowMe().getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
if (FollowType.EXTRA_FOLLOW_ROI_TARGET.equals(key)) {
LatLong target=data.getParcelable(key);
if (target != null) {
final Coord2D roiTarget;
if (target instanceof LatLongAlt) {
roiTarget=new Coord3D(target.getLatitude(),target.getLongitude(),((LatLongAlt)target).getAltitude());
}
 else {
roiTarget=new Coord2D(target.getLatitude(),target.getLongitude());
}
paramsMap.put(key,roiTarget);
}
}
 else paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
break;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
DroneApiUtils.disableFollowMe(getFollowMe());
break;
case CameraActions.ACTION_START_VIDEO_RECORDING:
DroneApiUtils.startVideoRecording(getDrone());
break;
case CameraActions.ACTION_STOP_VIDEO_RECORDING:
DroneApiUtils.stopVideoRecording(getDrone());
break;
}
}","@Override public void performAction(Action action) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    final float bearing=DroneApiUtils.generateDronie(getDrone());
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyAttributeUpdate(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
break;
case MissionActions.ACTION_LOAD_WAYPOINTS:
DroneApiUtils.loadWaypoints(getDrone());
break;
case MissionActions.ACTION_SET_MISSION:
data.setClassLoader(Mission.class.getClassLoader());
Mission mission=data.getParcelable(MissionActions.EXTRA_MISSION);
boolean pushToDrone=data.getBoolean(MissionActions.EXTRA_PUSH_TO_DRONE);
DroneApiUtils.setMission(getDrone(),mission,pushToDrone);
break;
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
DroneApiUtils.buildComplexMissionItem(getDrone(),data);
break;
case ConnectionActions.ACTION_CONNECT:
data.setClassLoader(ConnectionParameter.class.getClassLoader());
ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case ExperimentalActions.ACTION_EPM_COMMAND:
boolean release=data.getBoolean(ExperimentalActions.EXTRA_EPM_RELEASE);
DroneApiUtils.epmCommand(getDrone(),release);
break;
case ExperimentalActions.ACTION_TRIGGER_CAMERA:
DroneApiUtils.triggerCamera(getDrone());
break;
case ExperimentalActions.ACTION_SET_ROI:
LatLongAlt roi=data.getParcelable(ExperimentalActions.EXTRA_SET_ROI_LAT_LONG_ALT);
Coord3D coord3DRoi=new Coord3D(roi.getLatitude(),roi.getLongitude(),roi.getAltitude());
MavLinkDoCmds.setROI(getDrone(),coord3DRoi);
break;
case ExperimentalActions.ACTION_SEND_MAVLINK_MESSAGE:
data.setClassLoader(MavlinkMessageWrapper.class.getClassLoader());
MavlinkMessageWrapper messageWrapper=data.getParcelable(ExperimentalActions.EXTRA_MAVLINK_MESSAGE);
DroneApiUtils.sendMavlinkMessage(getDrone(),messageWrapper);
break;
case ExperimentalActions.ACTION_SET_RELAY:
if (droneMgr != null) {
int relayNumber=data.getInt(ExperimentalActions.EXTRA_RELAY_NUMBER);
boolean isOn=data.getBoolean(ExperimentalActions.EXTRA_IS_RELAY_ON);
MavLinkDoCmds.setRelay(droneMgr.getDrone(),relayNumber,isOn);
}
case ExperimentalActions.ACTION_SET_SERVO:
if (droneMgr != null) {
int channel=data.getInt(ExperimentalActions.EXTRA_SERVO_CHANNEL);
int pwm=data.getInt(ExperimentalActions.EXTRA_SERVO_PWM);
MavLinkDoCmds.setServo(droneMgr.getDrone(),channel,pwm);
}
break;
case GuidedActions.ACTION_DO_GUIDED_TAKEOFF:
double takeoffAltitude=data.getDouble(GuidedActions.EXTRA_ALTITUDE);
DroneApiUtils.doGuidedTakeoff(getDrone(),takeoffAltitude);
break;
case GuidedActions.ACTION_SEND_GUIDED_POINT:
data.setClassLoader(LatLong.class.getClassLoader());
boolean force=data.getBoolean(GuidedActions.EXTRA_FORCE_GUIDED_POINT);
LatLong guidedPoint=data.getParcelable(GuidedActions.EXTRA_GUIDED_POINT);
DroneApiUtils.sendGuidedPoint(getDrone(),guidedPoint,force);
break;
case GuidedActions.ACTION_SET_GUIDED_ALTITUDE:
double guidedAltitude=data.getDouble(GuidedActions.EXTRA_ALTITUDE);
DroneApiUtils.setGuidedAltitude(getDrone(),guidedAltitude);
break;
case ParameterActions.ACTION_REFRESH_PARAMETERS:
DroneApiUtils.refreshParameters(getDrone());
break;
case ParameterActions.ACTION_WRITE_PARAMETERS:
data.setClassLoader(Parameters.class.getClassLoader());
Parameters parameters=data.getParcelable(ParameterActions.EXTRA_PARAMETERS);
DroneApiUtils.writeParameters(getDrone(),parameters);
break;
case StateActions.ACTION_ARM:
boolean doArm=data.getBoolean(StateActions.EXTRA_ARM);
DroneApiUtils.arm(getDrone(),doArm);
break;
case StateActions.ACTION_SET_VEHICLE_MODE:
data.setClassLoader(VehicleMode.class.getClassLoader());
VehicleMode newMode=data.getParcelable(StateActions.EXTRA_VEHICLE_MODE);
DroneApiUtils.changeVehicleMode(getDrone(),newMode);
break;
case CalibrationActions.ACTION_START_IMU_CALIBRATION:
if (!DroneApiUtils.startIMUCalibration(getDrone())) {
Bundle extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,context.getString(R.string.failed_start_calibration_message));
notifyAttributeUpdate(AttributeEvent.CALIBRATION_IMU_ERROR,extrasBundle);
}
break;
case CalibrationActions.ACTION_SEND_IMU_CALIBRATION_ACK:
int imuAck=data.getInt(CalibrationActions.EXTRA_IMU_STEP);
DroneApiUtils.sendIMUCalibrationAck(getDrone(),imuAck);
break;
case CalibrationActions.ACTION_START_MAGNETOMETER_CALIBRATION:
final boolean retryOnFailure=data.getBoolean(CalibrationActions.EXTRA_RETRY_ON_FAILURE,false);
final boolean saveAutomatically=data.getBoolean(CalibrationActions.EXTRA_SAVE_AUTOMATICALLY,true);
final int startDelay=data.getInt(CalibrationActions.EXTRA_START_DELAY,0);
DroneApiUtils.startMagnetometerCalibration(getDrone(),retryOnFailure,saveAutomatically,startDelay);
break;
case CalibrationActions.ACTION_CANCEL_MAGNETOMETER_CALIBRATION:
DroneApiUtils.cancelMagnetometerCalibration(getDrone());
break;
case CalibrationActions.ACTION_ACCEPT_MAGNETOMETER_CALIBRATION:
DroneApiUtils.acceptMagnetometerCalibration(getDrone());
break;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
DroneApiUtils.enableFollowMe(getDroneManager(),droneHandler,followType);
break;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (droneMgr != null) {
data.setClassLoader(LatLong.class.getClassLoader());
final FollowAlgorithm followAlgorithm=this.droneMgr.getFollowMe().getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
if (FollowType.EXTRA_FOLLOW_ROI_TARGET.equals(key)) {
LatLong target=data.getParcelable(key);
if (target != null) {
final Coord2D roiTarget;
if (target instanceof LatLongAlt) {
roiTarget=new Coord3D(target.getLatitude(),target.getLongitude(),((LatLongAlt)target).getAltitude());
}
 else {
roiTarget=new Coord2D(target.getLatitude(),target.getLongitude());
}
paramsMap.put(key,roiTarget);
}
}
 else paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
break;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
DroneApiUtils.disableFollowMe(getFollowMe());
break;
case CameraActions.ACTION_START_VIDEO_RECORDING:
DroneApiUtils.startVideoRecording(getDrone());
break;
case CameraActions.ACTION_STOP_VIDEO_RECORDING:
DroneApiUtils.stopVideoRecording(getDrone());
break;
}
}","The original code lacked a specific handler for setting region of interest (ROI), which could lead to incomplete drone control functionality. The fixed code introduces a new case `ExperimentalActions.ACTION_SET_ROI` that converts a `LatLongAlt` to a `Coord3D` and uses `MavLinkDoCmds.setROI()` to properly set the drone's region of interest. This addition provides a more comprehensive and precise method for configuring drone targeting and camera orientation, enhancing the overall drone control capabilities."
94856,"@Override public void performAction(Action action) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    final float bearing=DroneApiUtils.generateDronie(getDrone());
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyAttributeUpdate(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
break;
case MissionActions.ACTION_LOAD_WAYPOINTS:
DroneApiUtils.loadWaypoints(getDrone());
break;
case MissionActions.ACTION_SET_MISSION:
data.setClassLoader(Mission.class.getClassLoader());
Mission mission=data.getParcelable(MissionActions.EXTRA_MISSION);
boolean pushToDrone=data.getBoolean(MissionActions.EXTRA_PUSH_TO_DRONE);
DroneApiUtils.setMission(getDrone(),mission,pushToDrone);
break;
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
DroneApiUtils.buildComplexMissionItem(getDrone(),data);
break;
case ConnectionActions.ACTION_CONNECT:
data.setClassLoader(ConnectionParameter.class.getClassLoader());
ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case ExperimentalActions.ACTION_EPM_COMMAND:
boolean release=data.getBoolean(ExperimentalActions.EXTRA_EPM_RELEASE);
DroneApiUtils.epmCommand(getDrone(),release);
break;
case ExperimentalActions.ACTION_TRIGGER_CAMERA:
DroneApiUtils.triggerCamera(getDrone());
break;
case ExperimentalActions.ACTION_SET_ROI:
LatLongAlt roi=data.getParcelable(ExperimentalActions.EXTRA_SET_ROI_LAT_LONG_ALT);
Coord3D coord3DRoi=new Coord3D(roi.getLatitude(),roi.getLongitude(),roi.getAltitude());
MavLinkDoCmds.setROI(getDrone(),coord3DRoi);
break;
case ExperimentalActions.ACTION_SEND_MAVLINK_MESSAGE:
data.setClassLoader(MavlinkMessageWrapper.class.getClassLoader());
MavlinkMessageWrapper messageWrapper=data.getParcelable(ExperimentalActions.EXTRA_MAVLINK_MESSAGE);
DroneApiUtils.sendMavlinkMessage(getDrone(),messageWrapper);
break;
case ExperimentalActions.ACTION_SET_RELAY:
if (droneMgr != null) {
int relayNumber=data.getInt(ExperimentalActions.EXTRA_RELAY_NUMBER);
boolean isOn=data.getBoolean(ExperimentalActions.EXTRA_IS_RELAY_ON);
MavLinkDoCmds.setRelay(droneMgr.getDrone(),relayNumber,isOn);
}
case ExperimentalActions.ACTION_SET_SERVO:
if (droneMgr != null) {
int channel=data.getInt(ExperimentalActions.EXTRA_SERVO_CHANNEL);
int pwm=data.getInt(ExperimentalActions.EXTRA_SERVO_PWM);
MavLinkDoCmds.setServo(droneMgr.getDrone(),channel,pwm);
}
break;
case GuidedActions.ACTION_DO_GUIDED_TAKEOFF:
double takeoffAltitude=data.getDouble(GuidedActions.EXTRA_ALTITUDE);
DroneApiUtils.doGuidedTakeoff(getDrone(),takeoffAltitude);
break;
case GuidedActions.ACTION_SEND_GUIDED_POINT:
data.setClassLoader(LatLong.class.getClassLoader());
boolean force=data.getBoolean(GuidedActions.EXTRA_FORCE_GUIDED_POINT);
LatLong guidedPoint=data.getParcelable(GuidedActions.EXTRA_GUIDED_POINT);
DroneApiUtils.sendGuidedPoint(getDrone(),guidedPoint,force);
break;
case GuidedActions.ACTION_SET_GUIDED_ALTITUDE:
double guidedAltitude=data.getDouble(GuidedActions.EXTRA_ALTITUDE);
DroneApiUtils.setGuidedAltitude(getDrone(),guidedAltitude);
break;
case ParameterActions.ACTION_REFRESH_PARAMETERS:
DroneApiUtils.refreshParameters(getDrone());
break;
case ParameterActions.ACTION_WRITE_PARAMETERS:
data.setClassLoader(Parameters.class.getClassLoader());
Parameters parameters=data.getParcelable(ParameterActions.EXTRA_PARAMETERS);
DroneApiUtils.writeParameters(getDrone(),parameters);
break;
case StateActions.ACTION_ARM:
boolean doArm=data.getBoolean(StateActions.EXTRA_ARM);
DroneApiUtils.arm(getDrone(),doArm);
break;
case StateActions.ACTION_SET_VEHICLE_MODE:
data.setClassLoader(VehicleMode.class.getClassLoader());
VehicleMode newMode=data.getParcelable(StateActions.EXTRA_VEHICLE_MODE);
DroneApiUtils.changeVehicleMode(getDrone(),newMode);
break;
case CalibrationActions.ACTION_START_IMU_CALIBRATION:
if (!DroneApiUtils.startIMUCalibration(getDrone())) {
Bundle extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,context.getString(R.string.failed_start_calibration_message));
notifyAttributeUpdate(AttributeEvent.CALIBRATION_IMU_ERROR,extrasBundle);
}
break;
case CalibrationActions.ACTION_SEND_IMU_CALIBRATION_ACK:
int imuAck=data.getInt(CalibrationActions.EXTRA_IMU_STEP);
DroneApiUtils.sendIMUCalibrationAck(getDrone(),imuAck);
break;
case CalibrationActions.ACTION_START_MAGNETOMETER_CALIBRATION:
final boolean retryOnFailure=data.getBoolean(CalibrationActions.EXTRA_RETRY_ON_FAILURE,false);
final boolean saveAutomatically=data.getBoolean(CalibrationActions.EXTRA_SAVE_AUTOMATICALLY,true);
final int startDelay=data.getInt(CalibrationActions.EXTRA_START_DELAY,0);
DroneApiUtils.startMagnetometerCalibration(getDrone(),retryOnFailure,saveAutomatically,startDelay);
break;
case CalibrationActions.ACTION_CANCEL_MAGNETOMETER_CALIBRATION:
DroneApiUtils.cancelMagnetometerCalibration(getDrone());
break;
case CalibrationActions.ACTION_ACCEPT_MAGNETOMETER_CALIBRATION:
DroneApiUtils.acceptMagnetometerCalibration(getDrone());
break;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
DroneApiUtils.enableFollowMe(getDroneManager(),droneHandler,followType);
break;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (droneMgr != null) {
data.setClassLoader(LatLong.class.getClassLoader());
final FollowAlgorithm followAlgorithm=this.droneMgr.getFollowMe().getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
if (FollowType.EXTRA_FOLLOW_ROI_TARGET.equals(key)) {
LatLong target=data.getParcelable(key);
if (target != null) {
final Coord2D roiTarget;
if (target instanceof LatLongAlt) {
roiTarget=new Coord3D(target.getLatitude(),target.getLongitude(),((LatLongAlt)target).getAltitude());
}
 else {
roiTarget=new Coord2D(target.getLatitude(),target.getLongitude());
}
paramsMap.put(key,roiTarget);
}
}
 else paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
break;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
DroneApiUtils.disableFollowMe(getFollowMe());
break;
case CameraActions.ACTION_START_VIDEO_RECORDING:
DroneApiUtils.startVideoRecording(getDrone());
break;
case CameraActions.ACTION_STOP_VIDEO_RECORDING:
DroneApiUtils.stopVideoRecording(getDrone());
break;
}
}","@Override public void performAction(Action action) throws RemoteException {
  if (action == null)   return;
  final String type=action.getType();
  if (type == null)   return;
  Bundle data=action.getData();
switch (type) {
case MissionActions.ACTION_GENERATE_DRONIE:
    final float bearing=DroneApiUtils.generateDronie(getDrone());
  if (bearing != -1) {
    Bundle bundle=new Bundle(1);
    bundle.putFloat(AttributeEventExtra.EXTRA_MISSION_DRONIE_BEARING,bearing);
    notifyAttributeUpdate(AttributeEvent.MISSION_DRONIE_CREATED,bundle);
  }
break;
case MissionActions.ACTION_LOAD_WAYPOINTS:
DroneApiUtils.loadWaypoints(getDrone());
break;
case MissionActions.ACTION_SET_MISSION:
data.setClassLoader(Mission.class.getClassLoader());
Mission mission=data.getParcelable(MissionActions.EXTRA_MISSION);
boolean pushToDrone=data.getBoolean(MissionActions.EXTRA_PUSH_TO_DRONE);
DroneApiUtils.setMission(getDrone(),mission,pushToDrone);
break;
case MissionActions.ACTION_BUILD_COMPLEX_MISSION_ITEM:
DroneApiUtils.buildComplexMissionItem(getDrone(),data);
break;
case ConnectionActions.ACTION_CONNECT:
data.setClassLoader(ConnectionParameter.class.getClassLoader());
ConnectionParameter parameter=data.getParcelable(ConnectionActions.EXTRA_CONNECT_PARAMETER);
connect(parameter);
break;
case ConnectionActions.ACTION_DISCONNECT:
disconnect();
break;
case ExperimentalActions.ACTION_EPM_COMMAND:
boolean release=data.getBoolean(ExperimentalActions.EXTRA_EPM_RELEASE);
DroneApiUtils.epmCommand(getDrone(),release);
break;
case ExperimentalActions.ACTION_TRIGGER_CAMERA:
DroneApiUtils.triggerCamera(getDrone());
break;
case ExperimentalActions.ACTION_SET_ROI:
LatLongAlt roi=data.getParcelable(ExperimentalActions.EXTRA_SET_ROI_LAT_LONG_ALT);
if (roi != null) {
Coord3D coord3DRoi=new Coord3D(roi.getLatitude(),roi.getLongitude(),roi.getAltitude());
MavLinkDoCmds.setROI(getDrone(),coord3DRoi);
}
break;
case ExperimentalActions.ACTION_SEND_MAVLINK_MESSAGE:
data.setClassLoader(MavlinkMessageWrapper.class.getClassLoader());
MavlinkMessageWrapper messageWrapper=data.getParcelable(ExperimentalActions.EXTRA_MAVLINK_MESSAGE);
DroneApiUtils.sendMavlinkMessage(getDrone(),messageWrapper);
break;
case ExperimentalActions.ACTION_SET_RELAY:
if (droneMgr != null) {
int relayNumber=data.getInt(ExperimentalActions.EXTRA_RELAY_NUMBER);
boolean isOn=data.getBoolean(ExperimentalActions.EXTRA_IS_RELAY_ON);
MavLinkDoCmds.setRelay(droneMgr.getDrone(),relayNumber,isOn);
}
case ExperimentalActions.ACTION_SET_SERVO:
if (droneMgr != null) {
int channel=data.getInt(ExperimentalActions.EXTRA_SERVO_CHANNEL);
int pwm=data.getInt(ExperimentalActions.EXTRA_SERVO_PWM);
MavLinkDoCmds.setServo(droneMgr.getDrone(),channel,pwm);
}
break;
case GuidedActions.ACTION_DO_GUIDED_TAKEOFF:
double takeoffAltitude=data.getDouble(GuidedActions.EXTRA_ALTITUDE);
DroneApiUtils.doGuidedTakeoff(getDrone(),takeoffAltitude);
break;
case GuidedActions.ACTION_SEND_GUIDED_POINT:
data.setClassLoader(LatLong.class.getClassLoader());
boolean force=data.getBoolean(GuidedActions.EXTRA_FORCE_GUIDED_POINT);
LatLong guidedPoint=data.getParcelable(GuidedActions.EXTRA_GUIDED_POINT);
DroneApiUtils.sendGuidedPoint(getDrone(),guidedPoint,force);
break;
case GuidedActions.ACTION_SET_GUIDED_ALTITUDE:
double guidedAltitude=data.getDouble(GuidedActions.EXTRA_ALTITUDE);
DroneApiUtils.setGuidedAltitude(getDrone(),guidedAltitude);
break;
case ParameterActions.ACTION_REFRESH_PARAMETERS:
DroneApiUtils.refreshParameters(getDrone());
break;
case ParameterActions.ACTION_WRITE_PARAMETERS:
data.setClassLoader(Parameters.class.getClassLoader());
Parameters parameters=data.getParcelable(ParameterActions.EXTRA_PARAMETERS);
DroneApiUtils.writeParameters(getDrone(),parameters);
break;
case StateActions.ACTION_ARM:
boolean doArm=data.getBoolean(StateActions.EXTRA_ARM);
DroneApiUtils.arm(getDrone(),doArm);
break;
case StateActions.ACTION_SET_VEHICLE_MODE:
data.setClassLoader(VehicleMode.class.getClassLoader());
VehicleMode newMode=data.getParcelable(StateActions.EXTRA_VEHICLE_MODE);
DroneApiUtils.changeVehicleMode(getDrone(),newMode);
break;
case CalibrationActions.ACTION_START_IMU_CALIBRATION:
if (!DroneApiUtils.startIMUCalibration(getDrone())) {
Bundle extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,context.getString(R.string.failed_start_calibration_message));
notifyAttributeUpdate(AttributeEvent.CALIBRATION_IMU_ERROR,extrasBundle);
}
break;
case CalibrationActions.ACTION_SEND_IMU_CALIBRATION_ACK:
int imuAck=data.getInt(CalibrationActions.EXTRA_IMU_STEP);
DroneApiUtils.sendIMUCalibrationAck(getDrone(),imuAck);
break;
case CalibrationActions.ACTION_START_MAGNETOMETER_CALIBRATION:
final boolean retryOnFailure=data.getBoolean(CalibrationActions.EXTRA_RETRY_ON_FAILURE,false);
final boolean saveAutomatically=data.getBoolean(CalibrationActions.EXTRA_SAVE_AUTOMATICALLY,true);
final int startDelay=data.getInt(CalibrationActions.EXTRA_START_DELAY,0);
DroneApiUtils.startMagnetometerCalibration(getDrone(),retryOnFailure,saveAutomatically,startDelay);
break;
case CalibrationActions.ACTION_CANCEL_MAGNETOMETER_CALIBRATION:
DroneApiUtils.cancelMagnetometerCalibration(getDrone());
break;
case CalibrationActions.ACTION_ACCEPT_MAGNETOMETER_CALIBRATION:
DroneApiUtils.acceptMagnetometerCalibration(getDrone());
break;
case FollowMeActions.ACTION_ENABLE_FOLLOW_ME:
data.setClassLoader(FollowType.class.getClassLoader());
FollowType followType=data.getParcelable(FollowMeActions.EXTRA_FOLLOW_TYPE);
DroneApiUtils.enableFollowMe(getDroneManager(),droneHandler,followType);
break;
case FollowMeActions.ACTION_UPDATE_FOLLOW_PARAMS:
if (droneMgr != null) {
data.setClassLoader(LatLong.class.getClassLoader());
final FollowAlgorithm followAlgorithm=this.droneMgr.getFollowMe().getFollowAlgorithm();
if (followAlgorithm != null) {
Map<String,Object> paramsMap=new HashMap<>();
Set<String> dataKeys=data.keySet();
for (String key : dataKeys) {
if (FollowType.EXTRA_FOLLOW_ROI_TARGET.equals(key)) {
LatLong target=data.getParcelable(key);
if (target != null) {
final Coord2D roiTarget;
if (target instanceof LatLongAlt) {
roiTarget=new Coord3D(target.getLatitude(),target.getLongitude(),((LatLongAlt)target).getAltitude());
}
 else {
roiTarget=new Coord2D(target.getLatitude(),target.getLongitude());
}
paramsMap.put(key,roiTarget);
}
}
 else paramsMap.put(key,data.get(key));
}
followAlgorithm.updateAlgorithmParams(paramsMap);
}
}
break;
case FollowMeActions.ACTION_DISABLE_FOLLOW_ME:
DroneApiUtils.disableFollowMe(getFollowMe());
break;
case CameraActions.ACTION_START_VIDEO_RECORDING:
DroneApiUtils.startVideoRecording(getDrone());
break;
case CameraActions.ACTION_STOP_VIDEO_RECORDING:
DroneApiUtils.stopVideoRecording(getDrone());
break;
}
}","The original code lacked null checks for critical objects like ROI in the ExperimentalActions.ACTION_SET_ROI case, which could potentially cause null pointer exceptions. The fixed code adds a null check for the roi object before creating the Coord3D and calling MavLinkDoCmds.setROI(), ensuring safe object handling and preventing potential runtime crashes. This defensive programming approach adds robustness by gracefully handling potentially undefined or null input data, improving the method's reliability and error resistance."
94857,"/** 
 * Basic MAVLink message test
 */
@Test public void testArm(){
  MavLinkArm.sendArmMessage(drone,true);
  MAVLinkPacket data=mavlinkApi.getData();
  Assert.assertTrue(data != null);
  MAVLinkMessage msg=data.unpack();
  msg_command_long longMsg=(msg_command_long)msg;
  Assert.assertEquals(MAV_CMD.MAV_CMD_COMPONENT_ARM_DISARM,longMsg.command);
  Assert.assertEquals(1f,longMsg.param1,0.001);
}","/** 
 * Basic MAVLink message test
 */
@Test public void testArm(){
  MavLinkArm.sendArmMessage(drone,true,null);
  MAVLinkPacket data=mavlinkApi.getData();
  Assert.assertTrue(data != null);
  MAVLinkMessage msg=data.unpack();
  msg_command_long longMsg=(msg_command_long)msg;
  Assert.assertEquals(MAV_CMD.MAV_CMD_COMPONENT_ARM_DISARM,longMsg.command);
  Assert.assertEquals(1f,longMsg.param1,0.001);
}","The original code lacks a required parameter in the `sendArmMessage` method, which likely caused a method signature mismatch or potential runtime error. The fixed code adds a third `null` parameter to correctly invoke the `sendArmMessage` method, ensuring compatibility with the method's expected signature. This change resolves the potential compilation or runtime issue, making the test method more robust and reliable."
94858,"public void disableFollowMe(){
  FollowApi.disableFollowMe(this);
}","/** 
 * @deprecated Use {@link FollowApi#disableFollowMe(Drone)} instead.
 */
public void disableFollowMe(){
  FollowApi.disableFollowMe(this);
}","The original code lacks clear documentation about the method's deprecation and potential future changes. The fixed code adds a deprecation javadoc annotation indicating that `disableFollowMe()` should now use `FollowApi.disableFollowMe(Drone)` directly. By providing clear guidance and marking the method as deprecated, developers are informed about the recommended alternative method, promoting better code maintenance and migration strategies."
94859,"public void generateDronie(){
  MissionApi.generateDronie(this);
}","/** 
 * @deprecated Use {@link MissionApi#generateDronie(Drone)} instead.
 */
public void generateDronie(){
  MissionApi.generateDronie(this);
}","The original code lacks proper documentation indicating potential deprecation or alternative method usage for generating a dronie. The fixed code adds a deprecation javadoc comment referencing the recommended `MissionApi#generateDronie(Drone)` method, guiding developers to use the preferred approach. This documentation helps prevent future misuse and provides clear guidance on the correct method for generating a dronie mission."
94860,"void destroy(){
  removeAttributesObserver(this.droneObserver);
  try {
    if (isStarted()) {
      this.droneApi.asBinder().unlinkToDeath(binderDeathRecipient,0);
      serviceMgr.get3drServices().releaseDroneApi(this.droneApi);
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,e.getMessage(),e);
  }
  if (asyncScheduler != null) {
    asyncScheduler.shutdownNow();
    asyncScheduler=null;
  }
  this.droneApi=null;
  droneListeners.clear();
}","void destroy(){
  removeAttributesObserver(this.droneObserver);
  try {
    if (isStarted()) {
      this.droneApi.asBinder().unlinkToDeath(binderDeathRecipient,0);
      serviceMgr.get3drServices().releaseDroneApi(this.droneApi);
    }
  }
 catch (  RemoteException e) {
    Log.e(TAG,e.getMessage(),e);
  }
  if (asyncScheduler != null) {
    asyncScheduler.shutdownNow();
    asyncScheduler=null;
  }
  droneListeners.clear();
}","The buggy code incorrectly sets `this.droneApi` to null after releasing the drone API, which could lead to potential null pointer issues in subsequent operations. In the fixed code, the line `this.droneApi=null` is removed, ensuring that the drone API reference remains intact until explicitly needed. This change prevents premature nullification and potential unexpected behavior, maintaining better resource management and code stability."
94861,"public void changeVehicleMode(VehicleMode newMode){
  DroneStateApi.setVehicleMode(this,newMode);
}","/** 
 * @deprecated Use {@link DroneStateApi#setVehicleMode(Drone,VehicleMode)} instead.
 */
public void changeVehicleMode(VehicleMode newMode){
  DroneStateApi.setVehicleMode(this,newMode);
}","The original code lacks deprecation documentation for the method, potentially causing confusion for developers using this legacy method. The fixed code adds a `@deprecated` Javadoc tag, explicitly directing developers to use the preferred `DroneStateApi#setVehicleMode(Drone,VehicleMode)` method instead of the current implementation. This addition improves code maintainability by clearly signaling the method's deprecated status and guiding future code refactoring."
94862,"public void enableFollowMe(FollowType followType){
  FollowApi.enableFollowMe(this,followType);
}","/** 
 * @deprecated Use {@link FollowApi#enableFollowMe(Drone,FollowType)} instead.
 */
public void enableFollowMe(FollowType followType){
  FollowApi.enableFollowMe(this,followType);
}","The original code lacks proper documentation and does not provide guidance for future developers on the recommended method of using the `enableFollowMe` function. The fixed code adds a deprecated annotation indicating that developers should now use `FollowApi.enableFollowMe(Drone,FollowType)` directly, which helps maintain clear code migration paths. By marking the method as deprecated, the code provides a clear transition strategy and prevents potential confusion about the correct method invocation."
94863,"public void pauseAtCurrentLocation(){
  GuidedApi.pauseAtCurrentLocation(this);
}","/** 
 * @deprecated Use {@link GuidedApi#pauseAtCurrentLocation(Drone)} instead.
 */
public void pauseAtCurrentLocation(){
  GuidedApi.pauseAtCurrentLocation(this);
}","The original code lacks documentation indicating potential deprecation or alternative method usage, which can lead to confusion for developers maintaining the codebase. The fixed code adds a `@deprecated` Javadoc annotation pointing to the recommended `GuidedApi#pauseAtCurrentLocation(Drone)` method, providing clear guidance on the preferred implementation. By including this deprecation notice, the code now offers explicit developer guidance and helps prevent future misuse of the method."
94864,"public void setMission(Mission mission,boolean pushToDrone){
  MissionApi.setMission(this,mission,pushToDrone);
}","/** 
 * @deprecated Use {@link MissionApi#setMission(Drone,Mission,boolean)} instead.
 */
public void setMission(Mission mission,boolean pushToDrone){
  MissionApi.setMission(this,mission,pushToDrone);
}","The original code lacks clear documentation indicating potential deprecation or recommended alternative method usage. The fixed code adds a `@deprecated` Javadoc annotation pointing developers to the preferred `MissionApi#setMission(Drone,Mission,boolean)` method for future implementations. This change provides clear guidance to developers, promotes better code maintainability, and signals the recommended migration path for using the mission setting functionality."
94865,"public void loadWaypoints(){
  MissionApi.loadWaypoints(this);
}","/** 
 * @deprecated Use {@link MissionApi#loadWaypoints(Drone)} instead.
 */
public void loadWaypoints(){
  MissionApi.loadWaypoints(this);
}","The original code lacks deprecation documentation, making it unclear to developers that the method should no longer be used directly. The fixed code adds a JavaDoc comment with a `@deprecated` tag, pointing developers to the recommended `MissionApi#loadWaypoints(Drone)` method while maintaining the existing implementation. This change improves code maintainability by providing clear guidance on method usage and encouraging migration to the preferred API approach."
94866,"public void sendGuidedPoint(LatLong point,boolean force){
  GuidedApi.sendGuidedPoint(this,point,force);
}","/** 
 * @deprecated Use {@link GuidedApi#sendGuidedPoint(Drone,LatLong,boolean)} instead.
 */
public void sendGuidedPoint(LatLong point,boolean force){
  GuidedApi.sendGuidedPoint(this,point,force);
}","The original code lacks clear documentation indicating its potential deprecation or alternative usage. The fixed code adds a @deprecated Javadoc annotation pointing developers to the recommended method `GuidedApi#sendGuidedPoint(Drone,LatLong,boolean)`, providing clear guidance for future usage. This improvement helps developers understand the method's status and directs them to the preferred implementation, promoting better code maintainability and clarity."
94867,"public void sendMavlinkMessage(MavlinkMessageWrapper messageWrapper){
  ExperimentalApi.sendMavlinkMessage(this,messageWrapper);
}","/** 
 * @deprecated Use {@link ExperimentalApi#sendMavlinkMessage(Drone,MavlinkMessageWrapper)} instead.
 */
public void sendMavlinkMessage(MavlinkMessageWrapper messageWrapper){
  ExperimentalApi.sendMavlinkMessage(this,messageWrapper);
}","The original code lacks proper documentation and deprecation marking for a method that will likely be replaced or removed in future versions. The fixed code adds a `@deprecated` Javadoc annotation pointing developers to the preferred alternative method in the `ExperimentalApi` class, guiding future code maintenance. This annotation helps developers understand the method's status and provides a clear migration path to the recommended implementation."
94868,"public void doGuidedTakeoff(double altitude){
  GuidedApi.takeoff(this,altitude);
}","/** 
 * @deprecated Use {@link GuidedApi#takeoff(Drone,double)} instead.
 */
public void doGuidedTakeoff(double altitude){
  GuidedApi.takeoff(this,altitude);
}","The original code lacks documentation indicating that the method is deprecated and should be replaced by a direct call to `GuidedApi.takeoff()`. The fixed code adds a deprecation Javadoc comment that explicitly directs developers to use `GuidedApi#takeoff(Drone,double)` as the preferred method. This improvement provides clear guidance to other developers about the recommended approach, helping prevent confusion and promoting the use of the most up-to-date API method."
94869,"public void writeParameters(Parameters parameters){
  ParameterApi.writeParameters(this,parameters);
}","/** 
 * @deprecated Use {@link ParameterApi#writeParameters(Drone,Parameters)} instead.
 */
public void writeParameters(Parameters parameters){
  ParameterApi.writeParameters(this,parameters);
}","The original code lacks deprecation documentation, making it unclear to developers that the method should no longer be used directly. The fixed code adds a @deprecated Javadoc annotation that explicitly directs developers to use the recommended static method ParameterApi#writeParameters(), providing clear guidance on the preferred implementation. This improvement enhances code maintainability by signaling the method's obsolescence and guiding future developers toward the correct usage pattern."
94870,"public void refreshParameters(){
  ParameterApi.refreshParameters(this);
}","/** 
 * @deprecated Use {@link ParameterApi#refreshParameters(Drone)} instead.
 */
public void refreshParameters(){
  ParameterApi.refreshParameters(this);
}","The original method lacks clear documentation and potentially indicates an outdated implementation approach. The fixed code adds a deprecation annotation to signal that this method is no longer the preferred way to refresh parameters, recommending developers use the static method `ParameterApi.refreshParameters(Drone)` directly. By marking the method as deprecated, the code provides clear guidance to other developers about the recommended usage while maintaining backward compatibility."
94871,"public void arm(boolean arm){
  DroneStateApi.arm(this,arm);
}","/** 
 * @deprecated Use {@link DroneStateApi#arm(Drone,boolean)} instead.
 */
public void arm(boolean arm){
  DroneStateApi.arm(this,arm);
}","The original code lacks proper documentation, making it unclear about the method's purpose and potential deprecation. The fixed code adds a deprecated annotation with a reference to the recommended method, guiding developers to use the correct API call. This improvement enhances code maintainability by explicitly indicating the preferred method and preventing future misuse of the deprecated implementation."
94872,"public void epmCommand(boolean release){
  ExperimentalApi.epmCommand(this,release);
}","/** 
 * @deprecated Use {@link ExperimentalApi#epmCommand(Drone,boolean)} instead.
 */
public void epmCommand(boolean release){
  ExperimentalApi.epmCommand(this,release);
}","The original code lacks documentation indicating that the method is deprecated and should be replaced by a more modern alternative. The fixed code adds a Javadoc comment with a `@deprecated` tag, pointing developers to the recommended `ExperimentalApi#epmCommand(Drone,boolean)` method, which provides clearer guidance on the preferred API usage. By adding this deprecation notice, the code improves code maintainability and helps developers understand the recommended approach for future development."
94873,"public void triggerCamera(){
  ExperimentalApi.triggerCamera(this);
}","/** 
 * @deprecated Use {@link ExperimentalApi#triggerCamera(Drone)} instead.
 */
public void triggerCamera(){
  ExperimentalApi.triggerCamera(this);
}","The original code lacks documentation about the experimental API method, potentially leading to confusion for developers using this method. The fixed code adds a deprecated annotation and Javadoc comment that provides guidance on the correct method to use, explicitly referencing the recommended alternative implementation. By adding clear documentation, the code improves developer understanding and helps prevent misuse of the experimental API method."
94874,"public void setGuidedAltitude(double altitude){
  GuidedApi.setGuidedAltitude(this,altitude);
}","/** 
 * @deprecated Use {@link GuidedApi#setGuidedAltitude(Drone,double)} instead.
 */
public void setGuidedAltitude(double altitude){
  GuidedApi.setGuidedAltitude(this,altitude);
}","The original code lacks proper documentation indicating that the method is deprecated and should be replaced by a direct call to the API method. The fixed code adds a `@deprecated` Javadoc annotation pointing developers to the recommended `GuidedApi#setGuidedAltitude(Drone,double)` method, providing clear guidance for future maintenance. This improves code clarity, helps prevent potential misuse, and signals to developers that they should transition to the preferred API implementation."
94875,"static VehicleMode getVehicleMode(ApmModes mode){
switch (mode) {
case FIXED_WING_MANUAL:
    return VehicleMode.PLANE_MANUAL;
case FIXED_WING_CIRCLE:
  return VehicleMode.PLANE_CIRCLE;
case FIXED_WING_STABILIZE:
return VehicleMode.PLANE_STABILIZE;
case FIXED_WING_TRAINING:
return VehicleMode.PLANE_TRAINING;
case FIXED_WING_FLY_BY_WIRE_A:
return VehicleMode.PLANE_FLY_BY_WIRE_A;
case FIXED_WING_FLY_BY_WIRE_B:
return VehicleMode.PLANE_FLY_BY_WIRE_B;
case FIXED_WING_AUTO:
return VehicleMode.PLANE_AUTO;
case FIXED_WING_RTL:
return VehicleMode.PLANE_RTL;
case FIXED_WING_LOITER:
return VehicleMode.PLANE_LOITER;
case FIXED_WING_GUIDED:
return VehicleMode.PLANE_GUIDED;
case ROTOR_STABILIZE:
return VehicleMode.COPTER_STABILIZE;
case ROTOR_ACRO:
return VehicleMode.COPTER_ACRO;
case ROTOR_ALT_HOLD:
return VehicleMode.COPTER_ALT_HOLD;
case ROTOR_AUTO:
return VehicleMode.COPTER_AUTO;
case ROTOR_GUIDED:
return VehicleMode.COPTER_GUIDED;
case ROTOR_LOITER:
return VehicleMode.COPTER_LOITER;
case ROTOR_RTL:
return VehicleMode.COPTER_RTL;
case ROTOR_CIRCLE:
return VehicleMode.COPTER_CIRCLE;
case ROTOR_LAND:
return VehicleMode.COPTER_LAND;
case ROTOR_TOY:
return VehicleMode.COPTER_DRIFT;
case ROTOR_SPORT:
return VehicleMode.COPTER_SPORT;
case ROTOR_AUTOTUNE:
return VehicleMode.COPTER_AUTOTUNE;
case ROTOR_POSHOLD:
return VehicleMode.COPTER_POSHOLD;
case ROVER_MANUAL:
return VehicleMode.ROVER_MANUAL;
case ROVER_LEARNING:
return VehicleMode.ROVER_LEARNING;
case ROVER_STEERING:
return VehicleMode.ROVER_STEERING;
case ROVER_HOLD:
return VehicleMode.ROVER_HOLD;
case ROVER_AUTO:
return VehicleMode.ROVER_AUTO;
case ROVER_RTL:
return VehicleMode.ROVER_RTL;
case ROVER_GUIDED:
return VehicleMode.ROVER_GUIDED;
case ROVER_INITIALIZING:
return VehicleMode.ROVER_INITIALIZING;
default :
case UNKNOWN:
return null;
}
}","static VehicleMode getVehicleMode(ApmModes mode){
switch (mode) {
case FIXED_WING_MANUAL:
    return VehicleMode.PLANE_MANUAL;
case FIXED_WING_CIRCLE:
  return VehicleMode.PLANE_CIRCLE;
case FIXED_WING_STABILIZE:
return VehicleMode.PLANE_STABILIZE;
case FIXED_WING_TRAINING:
return VehicleMode.PLANE_TRAINING;
case FIXED_WING_FLY_BY_WIRE_A:
return VehicleMode.PLANE_FLY_BY_WIRE_A;
case FIXED_WING_FLY_BY_WIRE_B:
return VehicleMode.PLANE_FLY_BY_WIRE_B;
case FIXED_WING_AUTO:
return VehicleMode.PLANE_AUTO;
case FIXED_WING_RTL:
return VehicleMode.PLANE_RTL;
case FIXED_WING_LOITER:
return VehicleMode.PLANE_LOITER;
case FIXED_WING_GUIDED:
return VehicleMode.PLANE_GUIDED;
case ROTOR_STABILIZE:
return VehicleMode.COPTER_STABILIZE;
case ROTOR_ACRO:
return VehicleMode.COPTER_ACRO;
case ROTOR_ALT_HOLD:
return VehicleMode.COPTER_ALT_HOLD;
case ROTOR_AUTO:
return VehicleMode.COPTER_AUTO;
case ROTOR_GUIDED:
return VehicleMode.COPTER_GUIDED;
case ROTOR_LOITER:
return VehicleMode.COPTER_LOITER;
case ROTOR_RTL:
return VehicleMode.COPTER_RTL;
case ROTOR_CIRCLE:
return VehicleMode.COPTER_CIRCLE;
case ROTOR_LAND:
return VehicleMode.COPTER_LAND;
case ROTOR_TOY:
return VehicleMode.COPTER_DRIFT;
case ROTOR_SPORT:
return VehicleMode.COPTER_SPORT;
case ROTOR_AUTOTUNE:
return VehicleMode.COPTER_AUTOTUNE;
case ROTOR_POSHOLD:
return VehicleMode.COPTER_POSHOLD;
case ROTOR_BRAKE:
return VehicleMode.COPTER_BRAKE;
case ROVER_MANUAL:
return VehicleMode.ROVER_MANUAL;
case ROVER_LEARNING:
return VehicleMode.ROVER_LEARNING;
case ROVER_STEERING:
return VehicleMode.ROVER_STEERING;
case ROVER_HOLD:
return VehicleMode.ROVER_HOLD;
case ROVER_AUTO:
return VehicleMode.ROVER_AUTO;
case ROVER_RTL:
return VehicleMode.ROVER_RTL;
case ROVER_GUIDED:
return VehicleMode.ROVER_GUIDED;
case ROVER_INITIALIZING:
return VehicleMode.ROVER_INITIALIZING;
default :
case UNKNOWN:
return null;
}
}","The original code lacked the `ROTOR_BRAKE` case, which caused incomplete coverage of vehicle modes for copter-type vehicles. The fixed code adds the missing `ROTOR_BRAKE` case, mapping it to `VehicleMode.COPTER_BRAKE`, ensuring comprehensive mode translation for all known vehicle states. This enhancement provides more robust and complete mode conversion, preventing potential runtime errors or mode mapping gaps."
94876,"public void connect(String appId,DroneEventsListener listener) throws ConnectionException {
  if (listener == null || TextUtils.isEmpty(appId))   return;
  connectedApps.put(appId,listener);
  MAVLinkClient mavClient=(MAVLinkClient)drone.getMavClient();
  if (!mavClient.isConnected()) {
    mavClient.openConnection();
  }
 else {
    listener.onDroneEvent(DroneInterfaces.DroneEventsType.CONNECTED,drone);
    if (drone.isConnectionAlive())     listener.onDroneEvent(DroneInterfaces.DroneEventsType.HEARTBEAT_FIRST,drone);
 else     listener.onDroneEvent(DroneInterfaces.DroneEventsType.HEARTBEAT_TIMEOUT,drone);
    notifyConnected(appId,listener);
  }
  mavClient.addLoggingFile(appId);
}","public void connect(String appId,DroneEventsListener listener) throws ConnectionException {
  if (listener == null || TextUtils.isEmpty(appId))   return;
  connectedApps.put(appId,listener);
  MAVLinkClient mavClient=(MAVLinkClient)drone.getMavClient();
  if (!mavClient.isConnected()) {
    mavClient.openConnection();
  }
 else {
    if (drone.isConnected()) {
      if (drone.isConnectionAlive())       listener.onDroneEvent(DroneInterfaces.DroneEventsType.HEARTBEAT_FIRST,drone);
 else {
        listener.onDroneEvent(DroneInterfaces.DroneEventsType.CONNECTED,drone);
        listener.onDroneEvent(DroneInterfaces.DroneEventsType.HEARTBEAT_TIMEOUT,drone);
      }
      notifyConnected(appId,listener);
    }
  }
  mavClient.addLoggingFile(appId);
}","The original code incorrectly assumed connection status and triggered events without proper validation, potentially leading to incorrect event notifications. The fixed code adds a check for `drone.isConnected()` and reorders event notifications to ensure accurate drone state representation, preventing premature or incorrect event triggers. By implementing more robust connection state validation, the modified code provides more reliable and precise drone connection event handling."
94877,"@Override public int hashCode(){
  return toString().hashCode();
}","@Override public int hashCode(){
  return getUniqueId().hashCode();
}","The original hashCode() implementation uses toString(), which can be slow and may generate inconsistent hash codes if the toString() method is overridden or changes. The fixed code uses getUniqueId(), which provides a stable, consistent identifier for generating hash codes, ensuring better performance and reliability. By using a unique identifier instead of a potentially variable string representation, the new implementation creates more predictable and efficient hash codes for object comparison and storage in hash-based collections."
94878,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (!(o instanceof ConnectionParameter))   return false;
  ConnectionParameter that=(ConnectionParameter)o;
  return toString().equals(that.toString());
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (!(o instanceof ConnectionParameter))   return false;
  ConnectionParameter that=(ConnectionParameter)o;
  return getUniqueId().equals(that.getUniqueId());
}","The original code uses toString() for equality comparison, which can be unreliable as toString() methods may change and do not represent a stable, unique identifier. The fixed code introduces getUniqueId(), a method that returns a consistent and unique identifier for comparing ConnectionParameter objects. By using a dedicated unique identifier, the equals() method now provides a more robust and predictable way to determine object equality."
94879,"public String getUniqueId(){
  final String uniqueId;
switch (connectionType) {
case ConnectionType.TYPE_UDP:
    int udpPort=ConnectionType.DEFAULT_UDP_SERVER_PORT;
  if (paramsBundle != null) {
    udpPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,udpPort);
  }
uniqueId=""String_Node_Str"" + udpPort;
break;
case ConnectionType.TYPE_BLUETOOTH:
String btAddress=null;
if (paramsBundle != null) {
btAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
}
uniqueId=btAddress == null ? ""String_Node_Str"" : ""String_Node_Str"" + btAddress;
break;
case ConnectionType.TYPE_TCP:
String tcpIp=null;
int tcpPort=ConnectionType.DEFAULT_TCP_SERVER_PORT;
if (paramsBundle != null) {
tcpIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
tcpPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,tcpPort);
}
uniqueId=""String_Node_Str"" + ""String_Node_Str"" + tcpPort + (tcpIp == null ? ""String_Node_Str"" : ""String_Node_Str"" + tcpIp);
break;
case ConnectionType.TYPE_USB:
uniqueId=""String_Node_Str"";
break;
default :
uniqueId=null;
break;
}
return uniqueId;
}","public String getUniqueId(){
  final String uniqueId;
switch (connectionType) {
case ConnectionType.TYPE_UDP:
    int udpPort=ConnectionType.DEFAULT_UDP_SERVER_PORT;
  if (paramsBundle != null) {
    udpPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,udpPort);
  }
uniqueId=""String_Node_Str"" + udpPort;
break;
case ConnectionType.TYPE_BLUETOOTH:
String btAddress=null;
if (paramsBundle != null) {
btAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
}
uniqueId=btAddress == null ? ""String_Node_Str"" : ""String_Node_Str"" + btAddress;
break;
case ConnectionType.TYPE_TCP:
String tcpIp=null;
int tcpPort=ConnectionType.DEFAULT_TCP_SERVER_PORT;
if (paramsBundle != null) {
tcpIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
tcpPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,tcpPort);
}
uniqueId=""String_Node_Str"" + ""String_Node_Str"" + tcpPort + (tcpIp == null ? ""String_Node_Str"" : ""String_Node_Str"" + tcpIp);
break;
case ConnectionType.TYPE_USB:
uniqueId=""String_Node_Str"";
break;
default :
uniqueId=""String_Node_Str"";
break;
}
return uniqueId;
}","The original code returns `null` in the default case, which could lead to potential null pointer exceptions when the connection type is unrecognized. In the fixed code, the default case now returns ""String_Node_Str"" instead of `null`, ensuring a consistent non-null string return. This modification enhances code robustness by providing a default unique identifier even for unexpected connection types, preventing potential null-related errors and improving overall method reliability."
94880,"void connectMAVConnection(ConnectionParameter connParams,String listenerTag,MavLinkConnectionListener listener){
  AndroidMavLinkConnection conn=mavConnections.get(connParams.getUniqueId());
  final int connectionType=connParams.getConnectionType();
  final Bundle paramsBundle=connParams.getParamsBundle();
  if (conn == null) {
switch (connectionType) {
case ConnectionType.TYPE_USB:
      final int baudRate=paramsBundle.getInt(ConnectionType.EXTRA_USB_BAUD_RATE,ConnectionType.DEFAULT_USB_BAUD_RATE);
    conn=new UsbConnection(getApplicationContext(),baudRate);
  Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_BLUETOOTH:
final String bluetoothAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
conn=new BluetoothConnection(getApplicationContext(),bluetoothAddress);
Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_TCP:
final String tcpServerIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
final int tcpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,ConnectionType.DEFAULT_TCP_SERVER_PORT);
conn=new AndroidTcpConnection(getApplicationContext(),tcpServerIp,tcpServerPort);
Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_UDP:
final int udpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,ConnectionType.DEFAULT_UDP_SERVER_PORT);
conn=new AndroidUdpConnection(getApplicationContext(),udpServerPort,new Handler(Looper.getMainLooper()));
Log.d(TAG,""String_Node_Str"");
break;
default :
Log.e(TAG,""String_Node_Str"" + connectionType);
return;
}
mavConnections.put(connParams.getUniqueId(),conn);
}
if (connectionType == ConnectionType.TYPE_UDP) {
final String pingIpAddress=paramsBundle.getString(ConnectionType.EXTRA_UDP_PING_RECEIVER_IP);
if (!TextUtils.isEmpty(pingIpAddress)) {
try {
final InetAddress resolvedAddress=InetAddress.getByName(pingIpAddress);
final int pingPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_PING_RECEIVER_PORT);
final long pingPeriod=paramsBundle.getLong(ConnectionType.EXTRA_UDP_PING_PERIOD,ConnectionType.DEFAULT_UDP_PING_PERIOD);
final byte[] pingPayload=paramsBundle.getByteArray(ConnectionType.EXTRA_UDP_PING_PAYLOAD);
((AndroidUdpConnection)conn).addPingTarget(resolvedAddress,pingPort,pingPeriod,pingPayload);
}
 catch (UnknownHostException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
}
conn.addMavLinkConnectionListener(listenerTag,listener);
if (conn.getConnectionStatus() == MavLinkConnection.MAVLINK_DISCONNECTED) {
conn.connect();
GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
}
}","void connectMAVConnection(ConnectionParameter connParams,String listenerTag,MavLinkConnectionListener listener){
  AndroidMavLinkConnection conn=mavConnections.get(connParams.getUniqueId());
  final int connectionType=connParams.getConnectionType();
  final Bundle paramsBundle=connParams.getParamsBundle();
  if (conn == null) {
switch (connectionType) {
case ConnectionType.TYPE_USB:
      final int baudRate=paramsBundle.getInt(ConnectionType.EXTRA_USB_BAUD_RATE,ConnectionType.DEFAULT_USB_BAUD_RATE);
    conn=new UsbConnection(getApplicationContext(),baudRate);
  Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_BLUETOOTH:
final String bluetoothAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
conn=new BluetoothConnection(getApplicationContext(),bluetoothAddress);
Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_TCP:
final String tcpServerIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
final int tcpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,ConnectionType.DEFAULT_TCP_SERVER_PORT);
conn=new AndroidTcpConnection(getApplicationContext(),tcpServerIp,tcpServerPort);
Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_UDP:
final int udpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,ConnectionType.DEFAULT_UDP_SERVER_PORT);
conn=new AndroidUdpConnection(getApplicationContext(),udpServerPort);
Log.d(TAG,""String_Node_Str"");
break;
default :
Log.e(TAG,""String_Node_Str"" + connectionType);
return;
}
mavConnections.put(connParams.getUniqueId(),conn);
}
if (connectionType == ConnectionType.TYPE_UDP) {
final String pingIpAddress=paramsBundle.getString(ConnectionType.EXTRA_UDP_PING_RECEIVER_IP);
if (!TextUtils.isEmpty(pingIpAddress)) {
try {
final InetAddress resolvedAddress=InetAddress.getByName(pingIpAddress);
final int pingPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_PING_RECEIVER_PORT);
final long pingPeriod=paramsBundle.getLong(ConnectionType.EXTRA_UDP_PING_PERIOD,ConnectionType.DEFAULT_UDP_PING_PERIOD);
final byte[] pingPayload=paramsBundle.getByteArray(ConnectionType.EXTRA_UDP_PING_PAYLOAD);
((AndroidUdpConnection)conn).addPingTarget(resolvedAddress,pingPort,pingPeriod,pingPayload);
}
 catch (UnknownHostException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
}
conn.addMavLinkConnectionListener(listenerTag,listener);
if (conn.getConnectionStatus() == MavLinkConnection.MAVLINK_DISCONNECTED) {
conn.connect();
GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
}
}","The original code incorrectly created an AndroidUdpConnection with an unnecessary Handler parameter, which could lead to potential threading issues and resource overhead. In the fixed code, the Handler is removed from the AndroidUdpConnection constructor, simplifying the connection initialization and eliminating the superfluous threading complexity. This modification ensures a cleaner, more efficient UDP connection setup without compromising the core functionality of establishing a MAVLink connection."
94881,"@Override public void onDroneEvent(DroneInterfaces.DroneEventsType event,Drone drone){
  Bundle extrasBundle=null;
  String droneEvent=null;
  final List<Pair<String,Bundle>> attributesInfo=new ArrayList<>();
switch (event) {
case DISCONNECTED:
    context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_DISCONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId));
  droneEvent=AttributeEvent.STATE_DISCONNECTED;
break;
case GUIDEDPOINT:
droneEvent=AttributeEvent.GUIDED_POINT_UPDATED;
break;
case RADIO:
droneEvent=AttributeEvent.SIGNAL_UPDATED;
break;
case RC_IN:
break;
case RC_OUT:
break;
case ARMING_STARTED:
case ARMING:
droneEvent=AttributeEvent.STATE_ARMING;
break;
case AUTOPILOT_WARNING:
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_ERROR_ID,drone.getState().getErrorId());
droneEvent=AttributeEvent.AUTOPILOT_ERROR;
break;
case MODE:
droneEvent=AttributeEvent.STATE_VEHICLE_MODE;
break;
case NAVIGATION:
case ATTITUDE:
case ORIENTATION:
droneEvent=AttributeEvent.ATTITUDE_UPDATED;
break;
case SPEED:
droneEvent=AttributeEvent.SPEED_UPDATED;
break;
case BATTERY:
droneEvent=AttributeEvent.BATTERY_UPDATED;
break;
case STATE:
droneEvent=AttributeEvent.STATE_UPDATED;
break;
case MISSION_UPDATE:
droneEvent=AttributeEvent.MISSION_UPDATED;
break;
case MISSION_RECEIVED:
droneEvent=AttributeEvent.MISSION_RECEIVED;
break;
case FIRMWARE:
case TYPE:
droneEvent=AttributeEvent.TYPE_UPDATED;
break;
case HOME:
droneEvent=AttributeEvent.HOME_UPDATED;
break;
case GPS:
droneEvent=AttributeEvent.GPS_POSITION;
break;
case GPS_FIX:
droneEvent=AttributeEvent.GPS_FIX;
break;
case GPS_COUNT:
droneEvent=AttributeEvent.GPS_COUNT;
break;
case PARAMETER:
case PARAMETERS_DOWNLOADED:
droneEvent=AttributeEvent.PARAMETERS_RECEIVED;
break;
case CALIBRATION_IMU:
final String calIMUMessage=drone.getCalibrationSetup().getMessage();
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,calIMUMessage);
droneEvent=AttributeEvent.CALIBRATION_IMU;
break;
case CALIBRATION_TIMEOUT:
final Calibration calibration=drone.getCalibrationSetup();
final String message=calibration.getMessage();
if (calibration.isCalibrating() && TextUtils.isEmpty(message)) {
calibration.setCalibrating(false);
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
}
 else {
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,message);
droneEvent=AttributeEvent.CALIBRATION_IMU_TIMEOUT;
}
break;
case HEARTBEAT_TIMEOUT:
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
break;
case CONNECTING:
droneEvent=AttributeEvent.STATE_CONNECTING;
break;
case CONNECTION_FAILED:
onConnectionFailed(""String_Node_Str"");
break;
case HEARTBEAT_FIRST:
final Bundle heartBeatExtras=new Bundle(1);
heartBeatExtras.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
attributesInfo.add(Pair.create(AttributeEvent.HEARTBEAT_FIRST,heartBeatExtras));
case CONNECTED:
final ConnectionParameter sanitizedParameter=new ConnectionParameter(connectionParams.getConnectionType(),connectionParams.getParamsBundle(),null);
context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_CONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId).putExtra(GCSEvent.EXTRA_VEHICLE_CONNECTION_PARAMETER,sanitizedParameter));
attributesInfo.add(Pair.<String,Bundle>create(AttributeEvent.STATE_CONNECTED,null));
break;
case HEARTBEAT_RESTORED:
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
droneEvent=AttributeEvent.HEARTBEAT_RESTORED;
break;
case MISSION_SENT:
droneEvent=AttributeEvent.MISSION_SENT;
break;
case INVALID_POLYGON:
break;
case MISSION_WP_UPDATE:
final int currentWaypoint=drone.getMissionStats().getCurrentWP();
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_CURRENT_WAYPOINT,currentWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_UPDATED;
break;
case FOLLOW_START:
droneEvent=AttributeEvent.FOLLOW_START;
break;
case FOLLOW_STOP:
droneEvent=AttributeEvent.FOLLOW_STOP;
break;
case FOLLOW_UPDATE:
case FOLLOW_CHANGE_TYPE:
droneEvent=AttributeEvent.FOLLOW_UPDATE;
break;
case ALTITUDE:
droneEvent=AttributeEvent.ALTITUDE_UPDATED;
break;
case WARNING_SIGNAL_WEAK:
droneEvent=AttributeEvent.SIGNAL_WEAK;
break;
case WARNING_NO_GPS:
droneEvent=AttributeEvent.WARNING_NO_GPS;
break;
case MAGNETOMETER:
break;
case FOOTPRINT:
droneEvent=AttributeEvent.CAMERA_FOOTPRINTS_UPDATED;
break;
case GOPRO_STATUS_UPDATE:
droneEvent=AttributeEvent.GOPRO_STATE_UPDATED;
break;
}
if (droneEvent != null) {
notifyAttributeUpdate(droneEvent,extrasBundle);
}
if (!attributesInfo.isEmpty()) {
notifyAttributeUpdate(attributesInfo);
}
}","@Override public void onDroneEvent(DroneInterfaces.DroneEventsType event,Drone drone){
  Bundle extrasBundle=null;
  String droneEvent=null;
  final List<Pair<String,Bundle>> attributesInfo=new ArrayList<>();
switch (event) {
case DISCONNECTED:
    context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_DISCONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId));
  droneEvent=AttributeEvent.STATE_DISCONNECTED;
break;
case GUIDEDPOINT:
droneEvent=AttributeEvent.GUIDED_POINT_UPDATED;
break;
case RADIO:
droneEvent=AttributeEvent.SIGNAL_UPDATED;
break;
case RC_IN:
break;
case RC_OUT:
break;
case ARMING_STARTED:
case ARMING:
droneEvent=AttributeEvent.STATE_ARMING;
break;
case AUTOPILOT_WARNING:
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_ERROR_ID,drone.getState().getErrorId());
droneEvent=AttributeEvent.AUTOPILOT_ERROR;
break;
case MODE:
droneEvent=AttributeEvent.STATE_VEHICLE_MODE;
break;
case NAVIGATION:
case ATTITUDE:
case ORIENTATION:
droneEvent=AttributeEvent.ATTITUDE_UPDATED;
break;
case SPEED:
droneEvent=AttributeEvent.SPEED_UPDATED;
break;
case BATTERY:
droneEvent=AttributeEvent.BATTERY_UPDATED;
break;
case STATE:
droneEvent=AttributeEvent.STATE_UPDATED;
break;
case MISSION_UPDATE:
droneEvent=AttributeEvent.MISSION_UPDATED;
break;
case MISSION_RECEIVED:
droneEvent=AttributeEvent.MISSION_RECEIVED;
break;
case FIRMWARE:
case TYPE:
droneEvent=AttributeEvent.TYPE_UPDATED;
break;
case HOME:
droneEvent=AttributeEvent.HOME_UPDATED;
break;
case GPS:
droneEvent=AttributeEvent.GPS_POSITION;
break;
case GPS_FIX:
droneEvent=AttributeEvent.GPS_FIX;
break;
case GPS_COUNT:
droneEvent=AttributeEvent.GPS_COUNT;
break;
case PARAMETER:
case PARAMETERS_DOWNLOADED:
droneEvent=AttributeEvent.PARAMETERS_RECEIVED;
break;
case CALIBRATION_IMU:
final String calIMUMessage=drone.getCalibrationSetup().getMessage();
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,calIMUMessage);
droneEvent=AttributeEvent.CALIBRATION_IMU;
break;
case CALIBRATION_TIMEOUT:
final Calibration calibration=drone.getCalibrationSetup();
final String message=calibration.getMessage();
if (calibration.isCalibrating() && TextUtils.isEmpty(message)) {
calibration.setCalibrating(false);
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
}
 else {
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,message);
droneEvent=AttributeEvent.CALIBRATION_IMU_TIMEOUT;
}
break;
case HEARTBEAT_TIMEOUT:
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
break;
case CONNECTING:
droneEvent=AttributeEvent.STATE_CONNECTING;
break;
case CONNECTION_FAILED:
disconnect();
onConnectionFailed(""String_Node_Str"");
break;
case HEARTBEAT_FIRST:
final Bundle heartBeatExtras=new Bundle(1);
heartBeatExtras.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
attributesInfo.add(Pair.create(AttributeEvent.HEARTBEAT_FIRST,heartBeatExtras));
case CONNECTED:
final ConnectionParameter sanitizedParameter=new ConnectionParameter(connectionParams.getConnectionType(),connectionParams.getParamsBundle(),null);
context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_CONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId).putExtra(GCSEvent.EXTRA_VEHICLE_CONNECTION_PARAMETER,sanitizedParameter));
attributesInfo.add(Pair.<String,Bundle>create(AttributeEvent.STATE_CONNECTED,null));
break;
case HEARTBEAT_RESTORED:
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
droneEvent=AttributeEvent.HEARTBEAT_RESTORED;
break;
case MISSION_SENT:
droneEvent=AttributeEvent.MISSION_SENT;
break;
case INVALID_POLYGON:
break;
case MISSION_WP_UPDATE:
final int currentWaypoint=drone.getMissionStats().getCurrentWP();
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_CURRENT_WAYPOINT,currentWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_UPDATED;
break;
case FOLLOW_START:
droneEvent=AttributeEvent.FOLLOW_START;
break;
case FOLLOW_STOP:
droneEvent=AttributeEvent.FOLLOW_STOP;
break;
case FOLLOW_UPDATE:
case FOLLOW_CHANGE_TYPE:
droneEvent=AttributeEvent.FOLLOW_UPDATE;
break;
case ALTITUDE:
droneEvent=AttributeEvent.ALTITUDE_UPDATED;
break;
case WARNING_SIGNAL_WEAK:
droneEvent=AttributeEvent.SIGNAL_WEAK;
break;
case WARNING_NO_GPS:
droneEvent=AttributeEvent.WARNING_NO_GPS;
break;
case MAGNETOMETER:
break;
case FOOTPRINT:
droneEvent=AttributeEvent.CAMERA_FOOTPRINTS_UPDATED;
break;
case GOPRO_STATUS_UPDATE:
droneEvent=AttributeEvent.GOPRO_STATE_UPDATED;
break;
}
if (droneEvent != null) {
notifyAttributeUpdate(droneEvent,extrasBundle);
}
if (!attributesInfo.isEmpty()) {
notifyAttributeUpdate(attributesInfo);
}
}","The buggy code lacked proper error handling during connection failures, potentially leaving the system in an undefined state. The fixed code adds a `disconnect()` method call before `onConnectionFailed()` in the `CONNECTION_FAILED` case, ensuring a clean disconnection process and preventing potential resource leaks. This modification improves system robustness by providing a more controlled and predictable response to connection errors."
94882,"@Override protected void openConnection() throws IOException {
  mConnectionImpl.openConnection();
  if (pingHandler != null) {
    for (    PingTask pingTask : pingTasks)     pingHandler.post(pingTask);
  }
}","@Override protected void openConnection() throws IOException {
  Log.d(TAG,""String_Node_Str"");
  mConnectionImpl.openConnection();
  if (pingRunner == null || pingRunner.isShutdown())   pingRunner=Executors.newSingleThreadScheduledExecutor();
  for (  PingTask pingTask : pingTasks)   pingRunner.scheduleWithFixedDelay(pingTask,0,pingTask.period,TimeUnit.MILLISECONDS);
}","The original code directly posts ping tasks to a handler without ensuring a consistent execution mechanism, which could lead to unpredictable scheduling and potential resource leaks. The fixed code introduces a single-threaded scheduled executor that manages ping tasks with controlled delay and periodic execution, creating a more robust thread management approach. By using `scheduleWithFixedDelay()`, the code ensures reliable, periodic task execution with proper resource allocation and predictable timing."
94883,"public AndroidUdpConnection(Context context,int udpServerPort,Handler pingHandler){
  super(context);
  this.serverPort=udpServerPort;
  this.pingHandler=pingHandler;
  mConnectionImpl=new UdpConnection(){
    @Override protected int loadServerPort(){
      return serverPort;
    }
    @Override protected Logger initLogger(){
      return AndroidUdpConnection.this.initLogger();
    }
    @Override protected void onConnectionOpened(){
      AndroidUdpConnection.this.onConnectionOpened();
    }
    @Override protected void onConnectionFailed(    String errMsg){
      AndroidUdpConnection.this.onConnectionFailed(errMsg);
    }
  }
;
}","public AndroidUdpConnection(Context context,int udpServerPort){
  super(context);
  this.serverPort=udpServerPort;
  mConnectionImpl=new UdpConnection(){
    @Override protected int loadServerPort(){
      return serverPort;
    }
    @Override protected Logger initLogger(){
      return AndroidUdpConnection.this.initLogger();
    }
    @Override protected void onConnectionOpened(){
      AndroidUdpConnection.this.onConnectionOpened();
    }
    @Override protected void onConnectionFailed(    String errMsg){
      AndroidUdpConnection.this.onConnectionFailed(errMsg);
    }
  }
;
}","The original code incorrectly included a `pingHandler` parameter that was not used, creating unnecessary complexity and potential confusion. The fixed code removes the unused `pingHandler` parameter, simplifying the constructor and eliminating potential misleading code. This change improves code clarity, reduces potential memory overhead, and makes the implementation more straightforward and maintainable."
94884,"@Override public void run(){
  try {
    mConnectionImpl.sendBuffer(address,port,payload);
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (getConnectionStatus() == AndroidMavLinkConnection.MAVLINK_CONNECTED)   pingHandler.postDelayed(this,period);
}","@Override public void run(){
  try {
    mConnectionImpl.sendBuffer(address,port,payload);
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","The original code repeatedly posts a delayed task even after a connection error, potentially leading to unnecessary retry attempts and resource waste. The fixed code removes the conditional delayed posting, preventing potential infinite looping or redundant task scheduling. By eliminating the automatic reposting mechanism, the code now handles connection attempts more gracefully and reduces the risk of uncontrolled background task execution."
94885,"public void addPingTarget(final InetAddress address,final int port,final long period,final byte[] payload){
  if (pingHandler == null || address == null || payload == null || period <= 0)   return;
  final PingTask pingTask=new PingTask(address,port,period,payload);
  pingTasks.add(pingTask);
  if (getConnectionStatus() == AndroidMavLinkConnection.MAVLINK_CONNECTED)   pingHandler.postDelayed(pingTask,period);
}","public void addPingTarget(final InetAddress address,final int port,final long period,final byte[] payload){
  if (address == null || payload == null || period <= 0)   return;
  final PingTask pingTask=new PingTask(address,port,period,payload);
  pingTasks.add(pingTask);
  if (getConnectionStatus() == AndroidMavLinkConnection.MAVLINK_CONNECTED && pingRunner != null && !pingRunner.isShutdown())   pingRunner.scheduleWithFixedDelay(pingTask,0,period,TimeUnit.MILLISECONDS);
}","The original code had a potential null pointer risk with pingHandler and lacked proper error handling for task scheduling. The fixed code removes the null check for pingHandler, replaces delayed posting with a more robust scheduled executor service (pingRunner), and adds additional runtime checks to ensure safe task execution. These changes improve reliability by preventing potential null reference exceptions and providing a more controlled mechanism for periodic ping task management."
94886,"@Override protected void closeConnection() throws IOException {
  if (pingHandler != null) {
    for (    PingTask pingTask : pingTasks)     pingHandler.removeCallbacks(pingTask);
  }
  mConnectionImpl.closeConnection();
}","@Override protected void closeConnection() throws IOException {
  Log.d(TAG,""String_Node_Str"");
  if (pingRunner != null) {
    Log.d(TAG,""String_Node_Str"");
    pingRunner.shutdownNow();
    pingRunner=null;
  }
  mConnectionImpl.closeConnection();
}","The buggy code incorrectly attempts to remove ping tasks using a `pingHandler`, which may not properly terminate background operations. The fixed code replaces this with `pingRunner.shutdownNow()`, explicitly stopping the thread executor and setting it to null, ensuring a clean and definitive connection closure. This approach provides a more robust mechanism for terminating background tasks and preventing potential resource leaks during connection shutdown."
94887,"@Override public boolean equals(Object other){
  if (this == other)   return true;
  if (!(other instanceof AndroidUdpConnection))   return false;
  PingTask that=(PingTask)other;
  return this.address.equals(that.address) && this.port == that.port && this.period == that.period;
}","@Override public boolean equals(Object other){
  if (this == other)   return true;
  if (!(other instanceof PingTask))   return false;
  PingTask that=(PingTask)other;
  return this.address.equals(that.address) && this.port == that.port && this.period == that.period;
}","The original code incorrectly checks for an `AndroidUdpConnection` type instead of the actual class type `PingTask`, which would cause incorrect type checking and potential runtime errors. The fixed code replaces `AndroidUdpConnection` with `PingTask`, ensuring proper type comparison and safe casting of the `other` object. This correction guarantees type-safe equality comparison, preventing potential ClassCastExceptions and maintaining the method's intended logical comparison of `PingTask` objects."
94888,"@Override public void openConnection(){
  if (this.connParams == null)   return;
  final String tag=toString();
  if (mavLinkApi.getConnectionStatus(this.connParams,tag) == MavLinkConnection.MAVLINK_DISCONNECTED) {
    mavLinkApi.connectMavLink(this.connParams,tag,mConnectionListener);
  }
}","@Override public void openConnection(){
  if (this.connParams == null)   return;
  final String tag=toString();
  final int connectionStatus=mavLinkApi.getConnectionStatus(this.connParams,tag);
  if (connectionStatus == MavLinkConnection.MAVLINK_DISCONNECTED || connectionStatus == MavLinkConnection.MAVLINK_CONNECTING) {
    mavLinkApi.connectMavLink(this.connParams,tag,mConnectionListener);
  }
}","The original code only attempted connection when the status was explicitly DISCONNECTED, potentially missing intermediate connection states. The fixed code adds a check for the CONNECTING state, ensuring connection attempts occur in both disconnected and connecting scenarios. This modification provides more robust connection handling by preventing missed connection opportunities and improving the reliability of the connection process."
94889,"public void disconnect(String appId) throws ConnectionException {
  if (TextUtils.isEmpty(appId))   return;
  DroneEventsListener listener=connectedApps.remove(appId);
  if (listener != null) {
    MAVLinkClient mavClient=(MAVLinkClient)drone.getMavClient();
    mavClient.removeLoggingFile(appId);
    if (mavClient.isConnected() && connectedApps.isEmpty()) {
      mavClient.closeConnection();
    }
    listener.onDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED,drone);
    notifyDisconnected(appId,listener);
  }
}","public void disconnect(String appId) throws ConnectionException {
  if (TextUtils.isEmpty(appId))   return;
  Log.d(TAG,""String_Node_Str"" + appId);
  DroneEventsListener listener=connectedApps.remove(appId);
  final MAVLinkClient mavClient=(MAVLinkClient)drone.getMavClient();
  if (listener != null) {
    mavClient.removeLoggingFile(appId);
    listener.onDroneEvent(DroneInterfaces.DroneEventsType.DISCONNECTED,drone);
    notifyDisconnected(appId,listener);
  }
  if (mavClient.isConnected() && connectedApps.isEmpty()) {
    mavClient.closeConnection();
  }
}","The original code incorrectly checks the MAVLink client connection and closes it only after removing the listener, which could potentially skip closing the connection if the last app disconnects. The fixed code moves the connection closure check outside the listener null check and adds a log statement for better debugging, ensuring the connection closes when no apps are connected. This modification improves reliability by guaranteeing proper connection management and providing additional diagnostic information during the disconnection process."
94890,"static void sendIMUCalibrationAck(Drone drone,int step){
  if (drone == null)   return;
  drone.getCalibrationSetup().sendAckk(step);
}","static void sendIMUCalibrationAck(Drone drone,int step){
  if (drone == null)   return;
  drone.getCalibrationSetup().sendAck(step);
}","The original code contains a typo in the method call `sendAckk()`, which would likely cause a compilation error or method not found exception. The fixed code corrects the method name to `sendAck()`, ensuring the correct method is invoked on the calibration setup object. This correction allows the IMU calibration acknowledgment to be sent properly without introducing runtime errors."
94891,"public void processMessage(MAVLinkMessage msg){
  if (msg.msgid == msg_statustext.MAVLINK_MSG_ID_STATUSTEXT) {
    msg_statustext statusMsg=(msg_statustext)msg;
    mavMsg=statusMsg.getText();
    if (mavMsg.contains(""String_Node_Str""))     calibrating=false;
    myDrone.notifyDroneEvent(DroneEventsType.CALIBRATION_IMU);
  }
}","public void processMessage(MAVLinkMessage msg){
  if (msg.msgid == msg_statustext.MAVLINK_MSG_ID_STATUSTEXT) {
    msg_statustext statusMsg=(msg_statustext)msg;
    final String message=statusMsg.getText();
    if (message != null && (message.startsWith(""String_Node_Str"") || message.startsWith(""String_Node_Str""))) {
      mavMsg=message;
      if (message.startsWith(""String_Node_Str""))       calibrating=false;
      myDrone.notifyDroneEvent(DroneEventsType.CALIBRATION_IMU);
    }
  }
}","The original code lacks proper null checking and has a potential null pointer risk when processing status messages. The fixed code adds null checks, uses a final local variable for the message text, and explicitly checks message prefixes to ensure safer and more robust message processing. These improvements prevent potential null reference exceptions and provide more explicit, predictable handling of drone calibration status messages."
94892,"public boolean startCalibration(){
  if (myDrone.getState().isFlying()) {
    calibrating=false;
  }
 else {
    calibrating=true;
    MavLinkCalibration.sendStartCalibrationMessage(myDrone);
  }
  return calibrating;
}","public boolean startCalibration(){
  if (myDrone.getState().isFlying()) {
    calibrating=false;
  }
 else {
    calibrating=true;
    mavMsg=""String_Node_Str"";
    MavLinkCalibration.sendStartCalibrationMessage(myDrone);
  }
  return calibrating;
}","The original code lacks a critical initialization step before sending the calibration message, potentially leading to undefined behavior or incomplete calibration processes. In the fixed code, a new variable `mavMsg` is initialized with a string value before sending the calibration message, which ensures proper message preparation and context setting. This change provides a more robust and predictable calibration initiation mechanism, improving the overall reliability of the drone calibration procedure."
94893,"private void sendMavlinkPacket(MAVLinkPacket packet){
  drone.getMavClient().sendMavPacket(packet);
}","private void sendMavlinkPacket(MAVLinkPacket packet){
  packet.sysid=255;
  packet.compid=0;
  drone.getMavClient().sendMavPacket(packet);
}","The original code lacks proper system and component ID settings for the MAVLink packet, which can lead to communication errors or packet rejection. The fixed code sets the system ID to 255 (ground control station) and component ID to 0 (main/primary component), ensuring correct packet identification and routing in the MAVLink communication protocol. These explicit ID assignments improve packet reliability and compatibility with standard MAVLink communication practices."
94894,"public void onHeartBeat(msg_gopro_heartbeat heartBeat){
  if (status != heartBeat.status) {
    status=heartBeat.status;
    drone.notifyDroneEvent(DroneEventsType.GOPRO_STATUS_UPDATE);
    if (!isConnected()) {
      resetFutures();
    }
  }
  restartWatchdog();
}","public void onHeartBeat(msg_gopro_heartbeat heartBeat){
  this.scratchSetRequest.target_component=(byte)heartBeat.compid;
  this.scratchGetRequest.target_component=(byte)heartBeat.compid;
  if (status != heartBeat.status) {
    status=heartBeat.status;
    drone.notifyDroneEvent(DroneEventsType.GOPRO_STATUS_UPDATE);
    if (!isConnected()) {
      resetFutures();
    }
  }
  restartWatchdog();
}","The original code lacked setting the target component for scratch requests, which could lead to miscommunication with the GoPro device. The fixed code adds lines setting the target_component for both scratchSetRequest and scratchGetRequest to match the incoming heartbeat's component ID, ensuring precise device targeting. This modification improves request routing accuracy and prevents potential communication errors between the drone and GoPro."
94895,"private void sendSetRequest(int commandId,int value,SetResponseHandler future){
  setResponsesFutures.put(commandId,future);
  scratchSetRequest.cmd_id=(byte)commandId;
  scratchSetRequest.value=(byte)value;
  sendMavlinkPacket(scratchSetRequest.pack());
}","private void sendSetRequest(int commandId,int value,SetResponseHandler future){
  if (future != null)   setResponsesFutures.put(commandId,future);
  scratchSetRequest.cmd_id=(byte)commandId;
  scratchSetRequest.value=(byte)value;
  sendMavlinkPacket(scratchSetRequest.pack());
}","The original code always adds a future to `setResponsesFutures`, potentially causing null pointer exceptions if a null future is passed. The fixed code adds a null check before putting the future in the map, preventing potential null reference errors. This modification ensures safer and more robust handling of response futures, reducing the risk of unexpected runtime exceptions."
94896,"private void sendGetRequest(int commandId,GetResponseHandler future){
  getResponsesFutures.put(commandId,future);
  scratchGetRequest.cmd_id=(byte)commandId;
  sendMavlinkPacket(scratchGetRequest.pack());
}","private void sendGetRequest(int commandId,GetResponseHandler future){
  if (future != null)   getResponsesFutures.put(commandId,future);
  scratchGetRequest.cmd_id=(byte)commandId;
  sendMavlinkPacket(scratchGetRequest.pack());
}","The original code unconditionally adds a potentially null future to the response futures map, which could cause null pointer exceptions. The fixed code adds a null check before inserting the future, ensuring only valid handlers are stored in the map. This prevents potential runtime errors and makes the method more robust by safely handling cases where no response handler is provided."
94897,"public GoProImpl(Drone drone,Handler handler){
  this.drone=drone;
  this.watchdog=handler;
  if (drone.isConnected()) {
    updateRequestTarget();
  }
}","public GoProImpl(Drone drone,Handler handler){
  this.drone=drone;
  this.watchdog=handler;
  this.scratchGetRequest=new msg_gopro_get_request();
  this.scratchGetRequest.sysid=255;
  this.scratchGetRequest.compid=0;
  this.scratchGetRequest.target_system=0;
  this.scratchSetRequest=new msg_gopro_set_request();
  this.scratchSetRequest.sysid=255;
  this.scratchSetRequest.compid=0;
  this.scratchSetRequest.target_system=0;
  if (drone.isConnected()) {
    updateRequestTarget();
  }
}","The original code did not initialize `scratchGetRequest` and `scratchSetRequest` objects, leaving potential null reference risks. The fixed code adds explicit initialization of these objects with default system and component IDs, ensuring they are properly configured before potential use. By initializing these request objects upfront, the code prevents potential null pointer exceptions and establishes a standardized configuration for GoPro-related message requests."
94898,"public boolean isRecording(){
  return status == GOPRO_HEARTBEAT_STATUS.GOPRO_HEARTBEAT_STATUS_RECORDING;
}","public boolean isRecording(){
  return isRecording;
}","The original code incorrectly checks a status enum against a specific recording state, which may not accurately reflect the current recording status. The fixed code introduces a dedicated boolean variable `isRecording` that directly tracks the recording state, providing a more straightforward and reliable method for determining recording status. By using a simple boolean flag, the code becomes more readable, maintainable, and precisely represents the current recording condition."
94899,"public void startRecording(){
  if (!isConnected() || isRecording())   return;
  scratchSetRequest.cmd_id=GOPRO_COMMAND.GOPRO_COMMAND_SHUTTER;
  sendSetRequest(GOPRO_COMMAND.GOPRO_COMMAND_POWER,1,new SetResponseHandler(){
    @Override public void onResponse(    byte commandId,    boolean result){
      if (result) {
        sendSetRequest(GOPRO_COMMAND.GOPRO_COMMAND_CAPTURE_MODE,0,new SetResponseHandler(){
          @Override public void onResponse(          byte commandId,          boolean success){
            if (success) {
              sendSetRequest(GOPRO_COMMAND.GOPRO_COMMAND_SHUTTER,1,null);
            }
 else {
              System.err.println(""String_Node_Str"");
            }
          }
        }
);
      }
 else {
        System.err.println(""String_Node_Str"");
      }
    }
  }
);
}","public void startRecording(){
  if (!isConnected() || isRecording())   return;
  sendSetRequest(GOPRO_COMMAND.GOPRO_COMMAND_SHUTTER,1,new SetResponseHandler(){
    @Override public void onResponse(    byte commandId,    boolean success){
      if (success != isRecording) {
        isRecording=success;
        drone.notifyDroneEvent(DroneEventsType.GOPRO_STATUS_UPDATE);
      }
    }
  }
);
}","The original code had unnecessary nested callbacks and complex power and capture mode setting before starting the recording, which introduced potential race conditions and overly complicated logic. The fixed code directly sends the shutter command with a simplified response handler that updates the recording status and notifies the drone of the status change. This approach streamlines the recording process, reduces complexity, and provides a more direct and reliable method for starting GoPro recording."
94900,"public void stopRecording(){
  if (!isConnected() || !isRecording())   return;
  sendSetRequest(GOPRO_COMMAND.GOPRO_COMMAND_SHUTTER,0,null);
}","public void stopRecording(){
  if (!isConnected() || !isRecording())   return;
  sendSetRequest(GOPRO_COMMAND.GOPRO_COMMAND_SHUTTER,0,new SetResponseHandler(){
    @Override public void onResponse(    byte commandId,    boolean success){
      if (success == isRecording) {
        isRecording=!success;
        drone.notifyDroneEvent(DroneEventsType.GOPRO_STATUS_UPDATE);
      }
    }
  }
);
}","The original code lacked proper state management for stopping GoPro recording, potentially leaving the recording status out of sync. The fixed code adds a response handler that updates the recording status based on the success of the stop command and explicitly notifies the drone of the status change. By implementing a callback mechanism, the code now ensures accurate tracking of the GoPro's recording state and provides real-time feedback to the drone system."
94901,"public DownloadImageTask(String appId,ImageView bmImage,Map<String,Bitmap> cachedMap){
  this.bmImage=bmImage;
  this.appId=appId;
  this.cachedMap=cachedMap;
}","public DownloadImageTask(Context context,String appId,ImageView bmImage,Map<String,Bitmap> cachedMap){
  this.bmImage=bmImage;
  this.appId=appId;
  this.cachedMap=cachedMap;
  final File rootDir=new File(context.getExternalFilesDir(null),ROOT_DIR);
  if (!rootDir.exists() && !rootDir.mkdirs()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  this.appIconFile=new File(rootDir,appId);
}","The original code lacks context for file storage and directory management, which can lead to potential file access and storage issues. The fixed code introduces a Context parameter to properly create and validate an external file directory for storing app icons, ensuring robust file handling by checking directory existence and creation. This improvement provides a more reliable and structured approach to managing app icon storage, preventing potential null pointer exceptions and file system errors."
94902,"protected Bitmap doInBackground(String... urls){
  String urlDisplay=urls[0];
  if (urlDisplay == null)   return null;
  Bitmap mIcon11=null;
  try {
    InputStream in=new URL(urlDisplay).openStream();
    mIcon11=BitmapFactory.decodeStream(in);
  }
 catch (  Exception e) {
    Log.e(TAG,e.getMessage(),e);
  }
  return mIcon11;
}","protected Bitmap doInBackground(String... urls){
  Bitmap mIcon11=null;
  if (this.appIconFile.isFile() && this.appIconFile.length() > 0) {
    mIcon11=BitmapFactory.decodeFile(this.appIconFile.getAbsolutePath());
    if (mIcon11 != null)     return mIcon11;
  }
  String urlDisplay=urls[0];
  if (urlDisplay == null)   return null;
  try {
    BufferedInputStream in=new BufferedInputStream(new URL(urlDisplay).openStream());
    final FileOutputStream fos=new FileOutputStream(this.appIconFile);
    final byte[] writeBuffer=new byte[BUFFER_SIZE];
    int byteCount;
    do {
      byteCount=in.read(writeBuffer);
      if (byteCount > -1) {
        fos.write(writeBuffer,0,byteCount);
        fos.flush();
      }
    }
 while (byteCount != -1);
    fos.close();
    mIcon11=BitmapFactory.decodeFile(this.appIconFile.getAbsolutePath());
  }
 catch (  Exception e) {
    Log.e(TAG,e.getMessage(),e);
  }
  return mIcon11;
}","The original code lacks proper error handling and doesn't cache downloaded images, potentially causing repeated network requests and inefficient resource usage. The fixed code introduces local file caching by first checking for an existing file, using BufferedInputStream for more efficient network reading, and writing downloaded content to a local file before decoding. This approach improves performance, reduces network overhead, and provides a more robust method for handling image downloads with better error resilience and resource management."
94903,"protected void onPostExecute(Bitmap result){
  if (result != null) {
    if (bmImage != null)     bmImage.setImageBitmap(result);
    if (cachedMap != null && appId != null)     cachedMap.put(appId,result);
  }
}","protected void onPostExecute(Bitmap result){
  if (result != null) {
    if (bmImage != null)     bmImage.setImageBitmap(result);
    if (cachedMap != null)     cachedMap.put(appId,result);
  }
}","The original code incorrectly checks for both `cachedMap` and `appId` being non-null before caching the bitmap, potentially preventing cache storage if `appId` is null. The fixed code removes the redundant `appId` check, allowing the bitmap to be cached as long as `cachedMap` exists, regardless of the `appId` value. This modification ensures more reliable caching and prevents unnecessary restrictions on storing bitmap results."
94904,"@Override public void onBindViewHolder(ViewHolder viewHolder,int position){
  final JSONObject appData=recommendedApps.optJSONObject(position);
  if (appData == null)   return;
  viewHolder.actionButtonContainer.setVisibility(View.GONE);
  final String appId=appData.optString(APP_ID_ATTRIBUTE,null);
  final String appName=appData.optString(APP_NAME_ATTRIBUTE);
  final String appDescription=appData.optString(APP_DESCRIPTION_ATTRIBUTE);
  final String appIconUrl=appData.optString(APP_ICON_URL_ATTRIBUTE,null);
  viewHolder.appTitle.setText(appName);
  viewHolder.appDescription.setText(appDescription);
  if (appId != null) {
    final ImageView appImageView=viewHolder.appIcon;
    final Bitmap cachedBmp=appsIconPerId.get(appId);
    if (cachedBmp != null) {
      appImageView.setImageBitmap(cachedBmp);
    }
 else     if (appIconUrl != null) {
      new DownloadImageTask(appId,appImageView,appsIconPerId).execute(appIconUrl);
    }
    viewHolder.actionButtonContainer.setVisibility(View.VISIBLE);
    Intent tmpIntent=context.getPackageManager().getLaunchIntentForPackage(appId);
    if (tmpIntent != null) {
      viewHolder.actionButton.setText(R.string.label_action_button_open);
      viewHolder.actionButton.setBackgroundResource(R.drawable.action_button_open_bg);
    }
 else {
      tmpIntent=new Intent(Intent.ACTION_VIEW).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK).setData(Uri.parse(""String_Node_Str"" + appId));
      viewHolder.actionButton.setText(R.string.label_action_button_install);
      viewHolder.actionButton.setBackgroundResource(R.drawable.action_button_install_bg);
    }
    final Intent launchIntent=tmpIntent;
    viewHolder.actionButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        context.startActivity(launchIntent);
      }
    }
);
  }
}","@Override public void onBindViewHolder(ViewHolder viewHolder,int position){
  final JSONObject appData=recommendedApps.optJSONObject(position);
  if (appData == null)   return;
  viewHolder.actionButtonContainer.setVisibility(View.GONE);
  final String appId=appData.optString(APP_ID_ATTRIBUTE,null);
  final String appName=appData.optString(APP_NAME_ATTRIBUTE);
  final String appDescription=appData.optString(APP_DESCRIPTION_ATTRIBUTE);
  final String appIconUrl=appData.optString(APP_ICON_URL_ATTRIBUTE,null);
  viewHolder.appTitle.setText(appName);
  viewHolder.appDescription.setText(appDescription);
  if (appId != null) {
    final ImageView appImageView=viewHolder.appIcon;
    final Bitmap cachedBmp=appsIconPerId.get(appId);
    if (cachedBmp != null) {
      appImageView.setImageBitmap(cachedBmp);
    }
 else     if (appIconUrl != null) {
      new DownloadImageTask(this.context,appId,appImageView,appsIconPerId).execute(appIconUrl);
    }
    viewHolder.actionButtonContainer.setVisibility(View.VISIBLE);
    Intent tmpIntent=context.getPackageManager().getLaunchIntentForPackage(appId);
    if (tmpIntent != null) {
      viewHolder.actionButton.setText(R.string.label_action_button_open);
      viewHolder.actionButton.setBackgroundResource(R.drawable.action_button_open_bg);
    }
 else {
      tmpIntent=new Intent(Intent.ACTION_VIEW).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK).setData(Uri.parse(""String_Node_Str"" + appId));
      viewHolder.actionButton.setText(R.string.label_action_button_install);
      viewHolder.actionButton.setBackgroundResource(R.drawable.action_button_install_bg);
    }
    final Intent launchIntent=tmpIntent;
    viewHolder.actionButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        context.startActivity(launchIntent);
      }
    }
);
  }
}","The original code passed insufficient parameters to the DownloadImageTask constructor, potentially causing initialization errors or null pointer exceptions. The fixed code adds the context parameter to the DownloadImageTask constructor, ensuring proper initialization and context availability for image downloading. This modification enhances the robustness of the image loading mechanism by providing the necessary context for background image retrieval and caching."
94905,"@Before public void setUp() throws Exception {
  final Context context=Robolectric.getShadowApplication().getApplicationContext();
  ConnectionParameter connParams=new ConnectionParameter(0,new Bundle(),null);
  mavlinkApi=new MockMavLinkServiceAPI();
  DroneInterfaces.Clock clock=new DroneInterfaces.Clock(){
    @Override public long elapsedRealtime(){
      return SystemClock.elapsedRealtime();
    }
  }
;
  DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
  MAVLinkClient mavClient=new MAVLinkClient(context,inputStreamListener,connParams,mavlinkApi);
  drone=new DroneImpl(mavClient,clock,dpHandler,dpPrefs,new AndroidApWarningParser(context));
}","@Before public void setUp() throws Exception {
  final Context context=Robolectric.getShadowApplication().getApplicationContext();
  ConnectionParameter connParams=new ConnectionParameter(0,new Bundle(),null);
  mavlinkApi=new MockMavLinkServiceAPI();
  DroneInterfaces.Clock clock=new DroneInterfaces.Clock(){
    @Override public long elapsedRealtime(){
      return SystemClock.elapsedRealtime();
    }
  }
;
  DroidPlannerPrefs dpPrefs=new DroidPlannerPrefs(context);
  MAVLinkClient mavClient=new MAVLinkClient(context,inputStreamListener,connParams,mavlinkApi);
  drone=new DroneImpl(mavClient,clock,dpHandler,dpPrefs,new AndroidApWarningParser(context),new LogMessageListener(){
    @Override public void onMessageLogged(    int mavSeverity,    String message){
    }
  }
);
}","The original code was missing a required LogMessageListener parameter when constructing the DroneImpl object, causing potential initialization errors. The fixed code adds an anonymous implementation of LogMessageListener with an empty onMessageLogged method, satisfying the constructor's parameter requirement. By including this mandatory listener, the code now correctly initializes the drone object with all necessary components, preventing potential null pointer exceptions or initialization failures."
94906,"@SuppressLint(""String_Node_Str"") @Override public void onCreate(){
  super.onCreate();
  Log.d(TAG,""String_Node_Str"");
  final Context context=getApplicationContext();
  handlerThread=new HandlerThread(""String_Node_Str"");
  handlerThread.start();
  mavlinkApi=new MavLinkServiceApi(this);
  droneAccess=new DroneAccess(this);
  dpServices=new DPServices(this);
  lbm=LocalBroadcastManager.getInstance(context);
  this.cameraInfoLoader=new CameraInfoLoader(context);
  updateForegroundNotification();
}","@SuppressLint(""String_Node_Str"") @Override public void onCreate(){
  super.onCreate();
  Log.d(TAG,""String_Node_Str"");
  final Context context=getApplicationContext();
  mavlinkApi=new MavLinkServiceApi(this);
  droneAccess=new DroneAccess(this);
  dpServices=new DPServices(this);
  lbm=LocalBroadcastManager.getInstance(context);
  this.cameraInfoLoader=new CameraInfoLoader(context);
  updateForegroundNotification();
}","The original code created a HandlerThread without properly managing its lifecycle, potentially causing resource leaks and unnecessary background thread creation. In the fixed code, the HandlerThread initialization and start were removed, eliminating potential threading complications and simplifying the onCreate method. This modification ensures more efficient resource usage and prevents potential threading-related issues in the Android application's startup process."
94907,"@Override public void onDestroy(){
  super.onDestroy();
  Log.d(TAG,""String_Node_Str"");
  for (  DroneApi droneApi : droneApiStore.values()) {
    droneApi.destroy();
  }
  droneApiStore.clear();
  for (  AndroidMavLinkConnection conn : mavConnections.values()) {
    conn.disconnect();
    conn.removeAllMavLinkConnectionListeners();
  }
  mavConnections.clear();
  dpServices.destroy();
  handlerThread.quit();
  stopForeground(true);
}","@Override public void onDestroy(){
  super.onDestroy();
  Log.d(TAG,""String_Node_Str"");
  for (  DroneApi droneApi : droneApiStore.values()) {
    droneApi.destroy();
  }
  droneApiStore.clear();
  for (  AndroidMavLinkConnection conn : mavConnections.values()) {
    conn.disconnect();
    conn.removeAllMavLinkConnectionListeners();
  }
  mavConnections.clear();
  dpServices.destroy();
  stopForeground(true);
}","The original code calls `handlerThread.quit()` after destroying services and connections, which could lead to potential race conditions or premature thread termination. The fixed code removes the `handlerThread.quit()` call, ensuring that all cleanup operations complete before potentially stopping the handler thread. This modification provides a more stable and predictable shutdown sequence for the service, preventing potential synchronization issues during the destruction process."
94908,"DroneApi registerDroneApi(IApiListener listener,String appId){
  if (listener == null)   return null;
  DroneApi droneApi=new DroneApi(this,handlerThread.getLooper(),mavlinkApi,listener,appId);
  droneApiStore.put(appId,droneApi);
  lbm.sendBroadcast(new Intent(ACTION_DRONE_CREATED));
  updateForegroundNotification();
  return droneApi;
}","DroneApi registerDroneApi(IApiListener listener,String appId){
  if (listener == null)   return null;
  DroneApi droneApi=new DroneApi(this,Looper.getMainLooper(),listener,appId);
  droneApiStore.put(appId,droneApi);
  lbm.sendBroadcast(new Intent(ACTION_DRONE_CREATED));
  updateForegroundNotification();
  return droneApi;
}","The original code incorrectly used `handlerThread.getLooper()`, which might lead to threading issues and unpredictable behavior when creating the DroneApi. In the fixed code, `Looper.getMainLooper()` is used, ensuring the API operates on the main thread for consistent and reliable event handling. This change improves the code's reliability by centralizing API interactions on the main thread, preventing potential synchronization and concurrency problems."
94909,"DroneManager connectDroneManager(ConnectionParameter connParams,String appId,DroneEventsListener listener) throws ConnectionException {
  if (connParams == null || TextUtils.isEmpty(appId) || listener == null)   return null;
  DroneManager droneMgr=droneManagers.get(connParams);
  if (droneMgr == null) {
    Log.d(TAG,""String_Node_Str"");
    droneMgr=new DroneManager(getApplicationContext(),connParams,new Handler(handlerThread.getLooper()),mavlinkApi);
    droneManagers.put(connParams,droneMgr);
  }
  Log.d(TAG,""String_Node_Str"" + appId);
  droneMgr.connect(appId,listener);
  return droneMgr;
}","DroneManager connectDroneManager(ConnectionParameter connParams,String appId,DroneEventsListener listener) throws ConnectionException {
  if (connParams == null || TextUtils.isEmpty(appId) || listener == null)   return null;
  DroneManager droneMgr=droneManagers.get(connParams);
  if (droneMgr == null) {
    Log.d(TAG,""String_Node_Str"");
    droneMgr=new DroneManager(getApplicationContext(),connParams,new Handler(Looper.getMainLooper()),mavlinkApi);
    droneManagers.put(connParams,droneMgr);
  }
  Log.d(TAG,""String_Node_Str"" + appId);
  droneMgr.connect(appId,listener);
  return droneMgr;
}","The original code used a potentially problematic handler created from a background thread, which could lead to unexpected thread synchronization issues. The fixed code replaces `handlerThread.getLooper()` with `Looper.getMainLooper()`, ensuring the handler is associated with the main UI thread for more predictable event handling. This change improves thread management, preventing potential race conditions and ensuring smoother interaction between the drone manager and the application's main thread."
94910,"DroneApi(DroidPlannerService dpService,Looper looper,MavLinkServiceApi mavlinkApi,IApiListener listener,String ownerId){
  this.service=dpService;
  this.context=dpService.getApplicationContext();
  final Handler handler=new Handler(looper);
  this.droneHandler=new DroneInterfaces.Handler(){
    @Override public void removeCallbacks(    Runnable thread){
      handler.removeCallbacks(thread);
    }
    @Override public void post(    Runnable thread){
      handler.post(thread);
    }
    @Override public void postDelayed(    Runnable thread,    long timeout){
      handler.postDelayed(thread,timeout);
    }
  }
;
  this.ownerId=ownerId;
  observersList=new ConcurrentLinkedQueue<>();
  mavlinkObserversList=new ConcurrentLinkedQueue<>();
  this.apiListener=listener;
  try {
    this.apiListener.asBinder().linkToDeath(this,0);
    checkForSelfRelease();
  }
 catch (  RemoteException e) {
    Log.e(TAG,e.getMessage(),e);
    dpService.releaseDroneApi(this.ownerId);
  }
}","DroneApi(DroidPlannerService dpService,Looper looper,IApiListener listener,String ownerId){
  this.service=dpService;
  this.context=dpService.getApplicationContext();
  final Handler handler=new Handler(looper);
  this.droneHandler=new DroneInterfaces.Handler(){
    @Override public void removeCallbacks(    Runnable thread){
      handler.removeCallbacks(thread);
    }
    @Override public void post(    Runnable thread){
      handler.post(thread);
    }
    @Override public void postDelayed(    Runnable thread,    long timeout){
      handler.postDelayed(thread,timeout);
    }
  }
;
  this.ownerId=ownerId;
  observersList=new ConcurrentLinkedQueue<>();
  mavlinkObserversList=new ConcurrentLinkedQueue<>();
  this.apiListener=listener;
  try {
    this.apiListener.asBinder().linkToDeath(this,0);
    checkForSelfRelease();
  }
 catch (  RemoteException e) {
    Log.e(TAG,e.getMessage(),e);
    dpService.releaseDroneApi(this.ownerId);
  }
}","The original code incorrectly included an unused `MavLinkServiceApi` parameter in the constructor, potentially causing confusion and unnecessary complexity. The fixed code removes this unused parameter, simplifying the method signature and eliminating potential misunderstandings about the API's dependencies. By streamlining the constructor, the code becomes clearer, more maintainable, and reduces the risk of unintended interactions with unnecessary service parameters."
94911,"public void receiveData(MAVLinkMessage msg){
  if (drone.getParameters().processMessage(msg)) {
    return;
  }
  drone.getWaypointManager().processMessage(msg);
  drone.getCalibrationSetup().processMessage(msg);
switch (msg.msgid) {
case msg_attitude.MAVLINK_MSG_ID_ATTITUDE:
    msg_attitude m_att=(msg_attitude)msg;
  drone.getOrientation().setRollPitchYaw(m_att.roll * 180.0 / Math.PI,m_att.pitch * 180.0 / Math.PI,m_att.yaw * 180.0 / Math.PI);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
msg_vfr_hud m_hud=(msg_vfr_hud)msg;
drone.setAltitudeGroundAndAirSpeeds(m_hud.alt,m_hud.groundspeed,m_hud.airspeed,m_hud.climb);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
drone.getMissionStats().setWpno(((msg_mission_current)msg).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)msg;
drone.setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
drone.getNavigation().setNavPitchRollYaw(m_nav.nav_pitch,m_nav.nav_roll,m_nav.nav_bearing);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)msg;
drone.getMagnetometer().newData(msg_imu);
break;
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
msg_heartbeat msg_heart=(msg_heartbeat)msg;
drone.setType(msg_heart.type);
checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,drone.getType());
drone.getState().setMode(newMode);
drone.onHeartbeat(msg_heart);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
drone.getGps().setPosition(new Coord2D(((msg_global_position_int)msg).lat / 1E7,((msg_global_position_int)msg).lon / 1E7));
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)msg;
drone.getBattery().setBatteryState(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)msg;
drone.getRadio().setRadioState(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
drone.getGps().setGpsState(((msg_gps_raw_int)msg).fix_type,((msg_gps_raw_int)msg).satellites_visible,((msg_gps_raw_int)msg).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
drone.getRC().setRcInputValues((msg_rc_channels_raw)msg);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
drone.getRC().setRcOutputValues((msg_servo_output_raw)msg);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)msg;
String message=msg_statustext.getText();
if (msg_statustext.severity == SEVERITY_HIGH || msg_statustext.severity == SEVERITY_CRITICAL) {
drone.getState().setWarning(message);
break;
}
 else if (message.equals(""String_Node_Str"")) {
drone.getState().setWarning(message);
break;
}
 else if (message.contains(""String_Node_Str"")) {
drone.setFirmwareVersion(message);
break;
}
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
drone.getCamera().newImageLocation((msg_camera_feedback)msg);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
drone.getCamera().updateMountOrientation(((msg_mount_status)msg));
break;
default :
break;
}
}","public void receiveData(MAVLinkMessage msg){
  if (drone.getParameters().processMessage(msg)) {
    return;
  }
  drone.getWaypointManager().processMessage(msg);
  drone.getCalibrationSetup().processMessage(msg);
switch (msg.msgid) {
case msg_attitude.MAVLINK_MSG_ID_ATTITUDE:
    msg_attitude m_att=(msg_attitude)msg;
  drone.getOrientation().setRollPitchYaw(m_att.roll * 180.0 / Math.PI,m_att.pitch * 180.0 / Math.PI,m_att.yaw * 180.0 / Math.PI);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
msg_vfr_hud m_hud=(msg_vfr_hud)msg;
drone.setAltitudeGroundAndAirSpeeds(m_hud.alt,m_hud.groundspeed,m_hud.airspeed,m_hud.climb);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
drone.getMissionStats().setWpno(((msg_mission_current)msg).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)msg;
drone.setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
drone.getNavigation().setNavPitchRollYaw(m_nav.nav_pitch,m_nav.nav_roll,m_nav.nav_bearing);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)msg;
drone.getMagnetometer().newData(msg_imu);
break;
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
msg_heartbeat msg_heart=(msg_heartbeat)msg;
drone.setType(msg_heart.type);
checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,drone.getType());
drone.getState().setMode(newMode);
drone.onHeartbeat(msg_heart);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
drone.getGps().setPosition(new Coord2D(((msg_global_position_int)msg).lat / 1E7,((msg_global_position_int)msg).lon / 1E7));
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)msg;
drone.getBattery().setBatteryState(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)msg;
drone.getRadio().setRadioState(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_radio_status.MAVLINK_MSG_ID_RADIO_STATUS:
msg_radio_status m_radio_status=(msg_radio_status)msg;
drone.getRadio().setRadioState(m_radio_status.rxerrors,m_radio_status.fixed,m_radio_status.rssi,m_radio_status.remrssi,m_radio_status.txbuf,m_radio_status.noise,m_radio_status.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
drone.getGps().setGpsState(((msg_gps_raw_int)msg).fix_type,((msg_gps_raw_int)msg).satellites_visible,((msg_gps_raw_int)msg).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
drone.getRC().setRcInputValues((msg_rc_channels_raw)msg);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
drone.getRC().setRcOutputValues((msg_servo_output_raw)msg);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)msg;
String message=msg_statustext.getText();
if (msg_statustext.severity == SEVERITY_HIGH || msg_statustext.severity == SEVERITY_CRITICAL) {
drone.getState().setWarning(message);
break;
}
 else if (message.equals(""String_Node_Str"")) {
drone.getState().setWarning(message);
break;
}
 else if (message.contains(""String_Node_Str"")) {
drone.setFirmwareVersion(message);
break;
}
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
drone.getCamera().newImageLocation((msg_camera_feedback)msg);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
drone.getCamera().updateMountOrientation(((msg_mount_status)msg));
break;
default :
break;
}
}","The original code lacked handling for the `msg_radio_status` message type, which could lead to incomplete radio state information processing. The fixed code adds a specific case for `msg_radio_status`, correctly casting and processing the radio status message using the appropriate message type and method. This enhancement ensures comprehensive radio state tracking, improving the drone's communication and status monitoring capabilities by capturing all potential radio-related message variants."
94912,"public void receiveData(MAVLinkMessage msg){
  if (drone.getParameters().processMessage(msg)) {
    return;
  }
  drone.getWaypointManager().processMessage(msg);
  drone.getCalibrationSetup().processMessage(msg);
switch (msg.msgid) {
case msg_attitude.MAVLINK_MSG_ID_ATTITUDE:
    msg_attitude m_att=(msg_attitude)msg;
  drone.getOrientation().setRollPitchYaw(m_att.roll * 180.0 / Math.PI,m_att.pitch * 180.0 / Math.PI,m_att.yaw * 180.0 / Math.PI);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
msg_vfr_hud m_hud=(msg_vfr_hud)msg;
drone.setAltitudeGroundAndAirSpeeds(m_hud.alt,m_hud.groundspeed,m_hud.airspeed,m_hud.climb);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
drone.getMissionStats().setWpno(((msg_mission_current)msg).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)msg;
drone.setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
drone.getNavigation().setNavPitchRollYaw(m_nav.nav_pitch,m_nav.nav_roll,m_nav.nav_bearing);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)msg;
drone.getMagnetometer().newData(msg_imu);
break;
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
msg_heartbeat msg_heart=(msg_heartbeat)msg;
drone.setType(msg_heart.type);
checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,drone.getType());
drone.getState().setMode(newMode);
drone.onHeartbeat(msg_heart);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
drone.getGps().setPosition(new Coord2D(((msg_global_position_int)msg).lat / 1E7,((msg_global_position_int)msg).lon / 1E7));
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)msg;
drone.getBattery().setBatteryState(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)msg;
drone.getRadio().setRadioState(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
drone.getGps().setGpsState(((msg_gps_raw_int)msg).fix_type,((msg_gps_raw_int)msg).satellites_visible,((msg_gps_raw_int)msg).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
drone.getRC().setRcInputValues((msg_rc_channels_raw)msg);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
drone.getRC().setRcOutputValues((msg_servo_output_raw)msg);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)msg;
String message=msg_statustext.getText();
if (msg_statustext.severity == SEVERITY_HIGH || msg_statustext.severity == SEVERITY_CRITICAL) {
drone.getState().setWarning(message);
break;
}
 else if (message.equals(""String_Node_Str"")) {
drone.getState().setWarning(message);
break;
}
 else if (message.contains(""String_Node_Str"")) {
drone.setFirmwareVersion(message);
break;
}
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
drone.getCamera().newImageLocation((msg_camera_feedback)msg);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
drone.getCamera().updateMountOrientation(((msg_mount_status)msg));
break;
default :
break;
}
}","public void receiveData(MAVLinkMessage msg){
  if (drone.getParameters().processMessage(msg)) {
    return;
  }
  drone.getWaypointManager().processMessage(msg);
  drone.getCalibrationSetup().processMessage(msg);
switch (msg.msgid) {
case msg_attitude.MAVLINK_MSG_ID_ATTITUDE:
    msg_attitude m_att=(msg_attitude)msg;
  drone.getOrientation().setRollPitchYaw(m_att.roll * 180.0 / Math.PI,m_att.pitch * 180.0 / Math.PI,m_att.yaw * 180.0 / Math.PI);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
msg_vfr_hud m_hud=(msg_vfr_hud)msg;
drone.setAltitudeGroundAndAirSpeeds(m_hud.alt,m_hud.groundspeed,m_hud.airspeed,m_hud.climb);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
drone.getMissionStats().setWpno(((msg_mission_current)msg).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)msg;
drone.setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
drone.getNavigation().setNavPitchRollYaw(m_nav.nav_pitch,m_nav.nav_roll,m_nav.nav_bearing);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)msg;
drone.getMagnetometer().newData(msg_imu);
break;
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
msg_heartbeat msg_heart=(msg_heartbeat)msg;
drone.setType(msg_heart.type);
checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,drone.getType());
drone.getState().setMode(newMode);
drone.onHeartbeat(msg_heart);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
drone.getGps().setPosition(new Coord2D(((msg_global_position_int)msg).lat / 1E7,((msg_global_position_int)msg).lon / 1E7));
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)msg;
drone.getBattery().setBatteryState(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)msg;
drone.getRadio().setRadioState(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_radio_status.MAVLINK_MSG_ID_RADIO_STATUS:
msg_radio_status m_radio_status=(msg_radio_status)msg;
drone.getRadio().setRadioState(m_radio_status.rxerrors,m_radio_status.fixed,m_radio_status.rssi,m_radio_status.remrssi,m_radio_status.txbuf,m_radio_status.noise,m_radio_status.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
drone.getGps().setGpsState(((msg_gps_raw_int)msg).fix_type,((msg_gps_raw_int)msg).satellites_visible,((msg_gps_raw_int)msg).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
drone.getRC().setRcInputValues((msg_rc_channels_raw)msg);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
drone.getRC().setRcOutputValues((msg_servo_output_raw)msg);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)msg;
String message=msg_statustext.getText();
if (msg_statustext.severity == SEVERITY_HIGH || msg_statustext.severity == SEVERITY_CRITICAL) {
drone.getState().setWarning(message);
break;
}
 else if (message.equals(""String_Node_Str"")) {
drone.getState().setWarning(message);
break;
}
 else if (message.contains(""String_Node_Str"")) {
drone.setFirmwareVersion(message);
break;
}
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
drone.getCamera().newImageLocation((msg_camera_feedback)msg);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
drone.getCamera().updateMountOrientation(((msg_mount_status)msg));
break;
default :
break;
}
}","The buggy code lacks handling for the `msg_radio_status` message type, which is crucial for radio communication status in drone systems. The fixed code adds a new case for `msg_radio_status`, using the same `setRadioState` method with parameters from the correct message type. This enhancement ensures comprehensive radio status reporting, improving the drone's communication monitoring and diagnostic capabilities by properly processing all relevant radio-related MAVLink messages."
94913,"public void disconnect(){
  try {
    service.disconnectDroneManager(this.droneMgr,this.ownerId);
  }
 catch (  ConnectionException e) {
    notifyConnectionFailed(new ConnectionResult(0,e.getMessage()));
  }
}","public void disconnect(){
  try {
    service.disconnectDroneManager(this.droneMgr,this.ownerId);
    this.droneMgr=null;
  }
 catch (  ConnectionException e) {
    notifyConnectionFailed(new ConnectionResult(0,e.getMessage()));
  }
}","The original code fails to reset the `droneMgr` reference after a disconnection attempt, potentially leaving a stale connection object. The fixed code adds `this.droneMgr=null` after successful disconnection, explicitly clearing the reference and preventing potential reuse of an invalid connection. This ensures clean state management and helps prevent subsequent method calls from using an outdated or disconnected drone manager reference."
94914,"@Override public void onDroneEvent(DroneInterfaces.DroneEventsType event,Drone drone){
  Bundle extrasBundle=null;
  String droneEvent=null;
  final List<Pair<String,Bundle>> attributesInfo=new ArrayList<>();
switch (event) {
case DISCONNECTED:
    context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_DISCONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId));
  droneEvent=AttributeEvent.STATE_DISCONNECTED;
break;
case GUIDEDPOINT:
droneEvent=AttributeEvent.GUIDED_POINT_UPDATED;
break;
case RADIO:
droneEvent=AttributeEvent.SIGNAL_UPDATED;
break;
case RC_IN:
break;
case RC_OUT:
break;
case ARMING_STARTED:
case ARMING:
droneEvent=AttributeEvent.STATE_ARMING;
break;
case AUTOPILOT_WARNING:
extrasBundle=new Bundle(2);
extrasBundle.putInt(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE_LEVEL,Log.ERROR);
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE,drone.getState().getWarning());
droneEvent=AttributeEvent.AUTOPILOT_FAILSAFE;
break;
case MODE:
droneEvent=AttributeEvent.STATE_VEHICLE_MODE;
break;
case NAVIGATION:
case ATTITUDE:
case ORIENTATION:
droneEvent=AttributeEvent.ATTITUDE_UPDATED;
break;
case SPEED:
droneEvent=AttributeEvent.SPEED_UPDATED;
break;
case BATTERY:
droneEvent=AttributeEvent.BATTERY_UPDATED;
break;
case STATE:
droneEvent=AttributeEvent.STATE_UPDATED;
break;
case MISSION_UPDATE:
droneEvent=AttributeEvent.MISSION_UPDATED;
break;
case MISSION_RECEIVED:
droneEvent=AttributeEvent.MISSION_RECEIVED;
break;
case FIRMWARE:
case TYPE:
droneEvent=AttributeEvent.TYPE_UPDATED;
break;
case HOME:
droneEvent=AttributeEvent.HOME_UPDATED;
break;
case GPS:
droneEvent=AttributeEvent.GPS_POSITION;
break;
case GPS_FIX:
droneEvent=AttributeEvent.GPS_FIX;
break;
case GPS_COUNT:
droneEvent=AttributeEvent.GPS_COUNT;
break;
case PARAMETER:
case PARAMETERS_DOWNLOADED:
droneEvent=AttributeEvent.PARAMETERS_RECEIVED;
break;
case CALIBRATION_IMU:
if (droneMgr != null) {
final String calIMUMessage=this.droneMgr.getDrone().getCalibrationSetup().getMessage();
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,calIMUMessage);
}
droneEvent=AttributeEvent.CALIBRATION_IMU;
break;
case CALIBRATION_TIMEOUT:
if (droneMgr != null) {
final Calibration calibration=this.droneMgr.getDrone().getCalibrationSetup();
final String message=calibration.getMessage();
if (calibration.isCalibrating() && TextUtils.isEmpty(message)) {
calibration.setCalibrating(false);
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
}
 else {
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,message);
droneEvent=AttributeEvent.CALIBRATION_IMU_TIMEOUT;
}
}
 else {
droneEvent=AttributeEvent.CALIBRATION_IMU_TIMEOUT;
}
break;
case HEARTBEAT_TIMEOUT:
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
break;
case CONNECTING:
extrasBundle=new Bundle(2);
extrasBundle.putInt(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE_LEVEL,Log.INFO);
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE,""String_Node_Str"");
droneEvent=AttributeEvent.AUTOPILOT_FAILSAFE;
break;
case CHECKING_VEHICLE_LINK:
extrasBundle=new Bundle(2);
extrasBundle.putInt(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE_LEVEL,Log.INFO);
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE,""String_Node_Str"");
droneEvent=AttributeEvent.AUTOPILOT_FAILSAFE;
break;
case CONNECTION_FAILED:
onConnectionFailed(""String_Node_Str"");
break;
case HEARTBEAT_FIRST:
if (droneMgr != null) {
final Bundle heartBeatExtras=new Bundle(1);
heartBeatExtras.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
attributesInfo.add(Pair.create(AttributeEvent.HEARTBEAT_FIRST,heartBeatExtras));
}
case CONNECTED:
if (droneMgr != null) {
final ConnectionParameter sanitizedParameter=new ConnectionParameter(connectionParams.getConnectionType(),connectionParams.getParamsBundle(),null);
context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_CONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId).putExtra(GCSEvent.EXTRA_VEHICLE_CONNECTION_PARAMETER,sanitizedParameter));
attributesInfo.add(Pair.<String,Bundle>create(AttributeEvent.STATE_CONNECTED,null));
}
break;
case HEARTBEAT_RESTORED:
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
droneEvent=AttributeEvent.HEARTBEAT_RESTORED;
break;
case MISSION_SENT:
droneEvent=AttributeEvent.MISSION_SENT;
break;
case INVALID_POLYGON:
break;
case MISSION_WP_UPDATE:
if (droneMgr != null) {
final int currentWaypoint=this.droneMgr.getDrone().getMissionStats().getCurrentWP();
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_CURRENT_WAYPOINT,currentWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_UPDATED;
}
break;
case FOLLOW_START:
droneEvent=AttributeEvent.FOLLOW_START;
break;
case FOLLOW_STOP:
droneEvent=AttributeEvent.FOLLOW_STOP;
break;
case FOLLOW_UPDATE:
case FOLLOW_CHANGE_TYPE:
droneEvent=AttributeEvent.FOLLOW_UPDATE;
break;
case WARNING_400FT_EXCEEDED:
droneEvent=AttributeEvent.ALTITUDE_400FT_EXCEEDED;
break;
case WARNING_SIGNAL_WEAK:
droneEvent=AttributeEvent.SIGNAL_WEAK;
break;
case WARNING_NO_GPS:
droneEvent=AttributeEvent.WARNING_NO_GPS;
break;
case MAGNETOMETER:
break;
case FOOTPRINT:
droneEvent=AttributeEvent.CAMERA_FOOTPRINTS_UPDATED;
break;
}
if (droneEvent != null) {
notifyAttributeUpdate(droneEvent,extrasBundle);
}
if (!attributesInfo.isEmpty()) {
notifyAttributeUpdate(attributesInfo);
}
}","@Override public void onDroneEvent(DroneInterfaces.DroneEventsType event,Drone drone){
  Bundle extrasBundle=null;
  String droneEvent=null;
  final List<Pair<String,Bundle>> attributesInfo=new ArrayList<>();
switch (event) {
case DISCONNECTED:
    context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_DISCONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId));
  droneEvent=AttributeEvent.STATE_DISCONNECTED;
break;
case GUIDEDPOINT:
droneEvent=AttributeEvent.GUIDED_POINT_UPDATED;
break;
case RADIO:
droneEvent=AttributeEvent.SIGNAL_UPDATED;
break;
case RC_IN:
break;
case RC_OUT:
break;
case ARMING_STARTED:
case ARMING:
droneEvent=AttributeEvent.STATE_ARMING;
break;
case AUTOPILOT_WARNING:
extrasBundle=new Bundle(2);
extrasBundle.putInt(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE_LEVEL,Log.ERROR);
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE,drone.getState().getWarning());
droneEvent=AttributeEvent.AUTOPILOT_FAILSAFE;
break;
case MODE:
droneEvent=AttributeEvent.STATE_VEHICLE_MODE;
break;
case NAVIGATION:
case ATTITUDE:
case ORIENTATION:
droneEvent=AttributeEvent.ATTITUDE_UPDATED;
break;
case SPEED:
droneEvent=AttributeEvent.SPEED_UPDATED;
break;
case BATTERY:
droneEvent=AttributeEvent.BATTERY_UPDATED;
break;
case STATE:
droneEvent=AttributeEvent.STATE_UPDATED;
break;
case MISSION_UPDATE:
droneEvent=AttributeEvent.MISSION_UPDATED;
break;
case MISSION_RECEIVED:
droneEvent=AttributeEvent.MISSION_RECEIVED;
break;
case FIRMWARE:
case TYPE:
droneEvent=AttributeEvent.TYPE_UPDATED;
break;
case HOME:
droneEvent=AttributeEvent.HOME_UPDATED;
break;
case GPS:
droneEvent=AttributeEvent.GPS_POSITION;
break;
case GPS_FIX:
droneEvent=AttributeEvent.GPS_FIX;
break;
case GPS_COUNT:
droneEvent=AttributeEvent.GPS_COUNT;
break;
case PARAMETER:
case PARAMETERS_DOWNLOADED:
droneEvent=AttributeEvent.PARAMETERS_RECEIVED;
break;
case CALIBRATION_IMU:
final String calIMUMessage=drone.getCalibrationSetup().getMessage();
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,calIMUMessage);
droneEvent=AttributeEvent.CALIBRATION_IMU;
break;
case CALIBRATION_TIMEOUT:
final Calibration calibration=drone.getCalibrationSetup();
final String message=calibration.getMessage();
if (calibration.isCalibrating() && TextUtils.isEmpty(message)) {
calibration.setCalibrating(false);
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
}
 else {
extrasBundle=new Bundle(1);
extrasBundle.putString(AttributeEventExtra.EXTRA_CALIBRATION_IMU_MESSAGE,message);
droneEvent=AttributeEvent.CALIBRATION_IMU_TIMEOUT;
}
break;
case HEARTBEAT_TIMEOUT:
droneEvent=AttributeEvent.HEARTBEAT_TIMEOUT;
break;
case CONNECTING:
extrasBundle=new Bundle(2);
extrasBundle.putInt(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE_LEVEL,Log.INFO);
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE,""String_Node_Str"");
droneEvent=AttributeEvent.AUTOPILOT_FAILSAFE;
break;
case CHECKING_VEHICLE_LINK:
extrasBundle=new Bundle(2);
extrasBundle.putInt(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE_LEVEL,Log.INFO);
extrasBundle.putString(AttributeEventExtra.EXTRA_AUTOPILOT_FAILSAFE_MESSAGE,""String_Node_Str"");
droneEvent=AttributeEvent.AUTOPILOT_FAILSAFE;
break;
case CONNECTION_FAILED:
onConnectionFailed(""String_Node_Str"");
break;
case HEARTBEAT_FIRST:
final Bundle heartBeatExtras=new Bundle(1);
heartBeatExtras.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
attributesInfo.add(Pair.create(AttributeEvent.HEARTBEAT_FIRST,heartBeatExtras));
case CONNECTED:
final ConnectionParameter sanitizedParameter=new ConnectionParameter(connectionParams.getConnectionType(),connectionParams.getParamsBundle(),null);
context.sendBroadcast(new Intent(GCSEvent.ACTION_VEHICLE_CONNECTION).putExtra(GCSEvent.EXTRA_APP_ID,ownerId).putExtra(GCSEvent.EXTRA_VEHICLE_CONNECTION_PARAMETER,sanitizedParameter));
attributesInfo.add(Pair.<String,Bundle>create(AttributeEvent.STATE_CONNECTED,null));
break;
case HEARTBEAT_RESTORED:
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MAVLINK_VERSION,drone.getMavlinkVersion());
droneEvent=AttributeEvent.HEARTBEAT_RESTORED;
break;
case MISSION_SENT:
droneEvent=AttributeEvent.MISSION_SENT;
break;
case INVALID_POLYGON:
break;
case MISSION_WP_UPDATE:
final int currentWaypoint=drone.getMissionStats().getCurrentWP();
extrasBundle=new Bundle(1);
extrasBundle.putInt(AttributeEventExtra.EXTRA_MISSION_CURRENT_WAYPOINT,currentWaypoint);
droneEvent=AttributeEvent.MISSION_ITEM_UPDATED;
break;
case FOLLOW_START:
droneEvent=AttributeEvent.FOLLOW_START;
break;
case FOLLOW_STOP:
droneEvent=AttributeEvent.FOLLOW_STOP;
break;
case FOLLOW_UPDATE:
case FOLLOW_CHANGE_TYPE:
droneEvent=AttributeEvent.FOLLOW_UPDATE;
break;
case WARNING_400FT_EXCEEDED:
droneEvent=AttributeEvent.ALTITUDE_400FT_EXCEEDED;
break;
case WARNING_SIGNAL_WEAK:
droneEvent=AttributeEvent.SIGNAL_WEAK;
break;
case WARNING_NO_GPS:
droneEvent=AttributeEvent.WARNING_NO_GPS;
break;
case MAGNETOMETER:
break;
case FOOTPRINT:
droneEvent=AttributeEvent.CAMERA_FOOTPRINTS_UPDATED;
break;
}
if (droneEvent != null) {
notifyAttributeUpdate(droneEvent,extrasBundle);
}
if (!attributesInfo.isEmpty()) {
notifyAttributeUpdate(attributesInfo);
}
}","The original code relied on unnecessary null checks with `droneMgr` before accessing drone information, creating potential null pointer risks and redundant conditional logic. The fixed code directly uses the `drone` parameter passed into the method, removing these unnecessary checks and simplifying access to drone-related methods and properties. This approach reduces complexity, eliminates potential null reference exceptions, and provides a more streamlined and robust event handling mechanism for drone-related operations."
94915,"public void receiveData(MAVLinkMessage msg){
  if (drone.getParameters().processMessage(msg)) {
    return;
  }
  drone.getWaypointManager().processMessage(msg);
  drone.getCalibrationSetup().processMessage(msg);
switch (msg.msgid) {
case msg_attitude.MAVLINK_MSG_ID_ATTITUDE:
    msg_attitude m_att=(msg_attitude)msg;
  drone.getOrientation().setRollPitchYaw(m_att.roll * 180.0 / Math.PI,m_att.pitch * 180.0 / Math.PI,m_att.yaw * 180.0 / Math.PI);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
msg_vfr_hud m_hud=(msg_vfr_hud)msg;
drone.setAltitudeGroundAndAirSpeeds(m_hud.alt,m_hud.groundspeed,m_hud.airspeed,m_hud.climb);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
drone.getMissionStats().setWpno(((msg_mission_current)msg).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)msg;
drone.setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
drone.getNavigation().setNavPitchRollYaw(m_nav.nav_pitch,m_nav.nav_roll,m_nav.nav_bearing);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)msg;
drone.getMagnetometer().newData(msg_imu);
break;
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
msg_heartbeat msg_heart=(msg_heartbeat)msg;
drone.setType(msg_heart.type);
drone.getState().setIsFlying(((msg_heartbeat)msg).system_status == MAV_STATE.MAV_STATE_ACTIVE);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,drone.getType());
drone.getState().setMode(newMode);
drone.onHeartbeat(msg_heart);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
drone.getGps().setPosition(new Coord2D(((msg_global_position_int)msg).lat / 1E7,((msg_global_position_int)msg).lon / 1E7));
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)msg;
drone.getBattery().setBatteryState(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)msg;
drone.getRadio().setRadioState(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
drone.getGps().setGpsState(((msg_gps_raw_int)msg).fix_type,((msg_gps_raw_int)msg).satellites_visible,((msg_gps_raw_int)msg).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
drone.getRC().setRcInputValues((msg_rc_channels_raw)msg);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
drone.getRC().setRcOutputValues((msg_servo_output_raw)msg);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)msg;
String message=msg_statustext.getText();
if (msg_statustext.severity == SEVERITY_HIGH || msg_statustext.severity == SEVERITY_CRITICAL) {
drone.getState().setWarning(message);
break;
}
 else if (message.equals(""String_Node_Str"")) {
drone.getState().setWarning(message);
break;
}
 else if (message.contains(""String_Node_Str"")) {
drone.setFirmwareVersion(message);
break;
}
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
drone.getCamera().newImageLocation((msg_camera_feedback)msg);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
drone.getCamera().updateMountOrientation(((msg_mount_status)msg));
break;
default :
break;
}
}","public void receiveData(MAVLinkMessage msg){
  if (drone.getParameters().processMessage(msg)) {
    return;
  }
  drone.getWaypointManager().processMessage(msg);
  drone.getCalibrationSetup().processMessage(msg);
switch (msg.msgid) {
case msg_attitude.MAVLINK_MSG_ID_ATTITUDE:
    msg_attitude m_att=(msg_attitude)msg;
  drone.getOrientation().setRollPitchYaw(m_att.roll * 180.0 / Math.PI,m_att.pitch * 180.0 / Math.PI,m_att.yaw * 180.0 / Math.PI);
break;
case msg_vfr_hud.MAVLINK_MSG_ID_VFR_HUD:
msg_vfr_hud m_hud=(msg_vfr_hud)msg;
drone.setAltitudeGroundAndAirSpeeds(m_hud.alt,m_hud.groundspeed,m_hud.airspeed,m_hud.climb);
break;
case msg_mission_current.MAVLINK_MSG_ID_MISSION_CURRENT:
drone.getMissionStats().setWpno(((msg_mission_current)msg).seq);
break;
case msg_nav_controller_output.MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT:
msg_nav_controller_output m_nav=(msg_nav_controller_output)msg;
drone.setDisttowpAndSpeedAltErrors(m_nav.wp_dist,m_nav.alt_error,m_nav.aspd_error);
drone.getNavigation().setNavPitchRollYaw(m_nav.nav_pitch,m_nav.nav_roll,m_nav.nav_bearing);
break;
case msg_raw_imu.MAVLINK_MSG_ID_RAW_IMU:
msg_raw_imu msg_imu=(msg_raw_imu)msg;
drone.getMagnetometer().newData(msg_imu);
break;
case msg_heartbeat.MAVLINK_MSG_ID_HEARTBEAT:
msg_heartbeat msg_heart=(msg_heartbeat)msg;
drone.setType(msg_heart.type);
checkIfFlying(msg_heart);
processState(msg_heart);
ApmModes newMode=ApmModes.getMode(msg_heart.custom_mode,drone.getType());
drone.getState().setMode(newMode);
drone.onHeartbeat(msg_heart);
break;
case msg_global_position_int.MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
drone.getGps().setPosition(new Coord2D(((msg_global_position_int)msg).lat / 1E7,((msg_global_position_int)msg).lon / 1E7));
break;
case msg_sys_status.MAVLINK_MSG_ID_SYS_STATUS:
msg_sys_status m_sys=(msg_sys_status)msg;
drone.getBattery().setBatteryState(m_sys.voltage_battery / 1000.0,m_sys.battery_remaining,m_sys.current_battery / 100.0);
break;
case msg_radio.MAVLINK_MSG_ID_RADIO:
msg_radio m_radio=(msg_radio)msg;
drone.getRadio().setRadioState(m_radio.rxerrors,m_radio.fixed,m_radio.rssi,m_radio.remrssi,m_radio.txbuf,m_radio.noise,m_radio.remnoise);
break;
case msg_gps_raw_int.MAVLINK_MSG_ID_GPS_RAW_INT:
drone.getGps().setGpsState(((msg_gps_raw_int)msg).fix_type,((msg_gps_raw_int)msg).satellites_visible,((msg_gps_raw_int)msg).eph);
break;
case msg_rc_channels_raw.MAVLINK_MSG_ID_RC_CHANNELS_RAW:
drone.getRC().setRcInputValues((msg_rc_channels_raw)msg);
break;
case msg_servo_output_raw.MAVLINK_MSG_ID_SERVO_OUTPUT_RAW:
drone.getRC().setRcOutputValues((msg_servo_output_raw)msg);
break;
case msg_statustext.MAVLINK_MSG_ID_STATUSTEXT:
msg_statustext msg_statustext=(msg_statustext)msg;
String message=msg_statustext.getText();
if (msg_statustext.severity == SEVERITY_HIGH || msg_statustext.severity == SEVERITY_CRITICAL) {
drone.getState().setWarning(message);
break;
}
 else if (message.equals(""String_Node_Str"")) {
drone.getState().setWarning(message);
break;
}
 else if (message.contains(""String_Node_Str"")) {
drone.setFirmwareVersion(message);
break;
}
break;
case msg_camera_feedback.MAVLINK_MSG_ID_CAMERA_FEEDBACK:
drone.getCamera().newImageLocation((msg_camera_feedback)msg);
break;
case msg_mount_status.MAVLINK_MSG_ID_MOUNT_STATUS:
drone.getCamera().updateMountOrientation(((msg_mount_status)msg));
break;
default :
break;
}
}","The original code incorrectly set the drone's flying state directly within the heartbeat message processing, potentially leading to incorrect state tracking. In the fixed code, a separate method `checkIfFlying()` is introduced to handle flying state determination, improving modular and robust state management. This change ensures more precise and flexible tracking of the drone's operational status by delegating state detection to a dedicated method."
94916,"private void checkFailsafe(msg_heartbeat msg_heart){
  boolean failsafe2=msg_heart.system_status == (byte)MAV_STATE.MAV_STATE_CRITICAL;
  if (failsafe2) {
    drone.getState().setWarning(""String_Node_Str"");
  }
}","private void checkFailsafe(msg_heartbeat msg_heart){
  boolean failsafe2=msg_heart.system_status == (byte)MAV_STATE.MAV_STATE_CRITICAL || msg_heart.system_status == MAV_STATE.MAV_STATE_EMERGENCY;
  if (failsafe2) {
    drone.getState().repeatWarning();
  }
}","The original code only checks for a critical system status, potentially missing other critical failure scenarios like emergency states. The fixed code expands the failsafe condition to include both critical and emergency system states, ensuring a more comprehensive failure detection. This improvement provides a more robust mechanism for identifying and responding to various high-risk drone system conditions, enhancing overall system safety and reliability."
94917,"@Override public void onLocationChanged(Location androidLocation){
  if (receiver != null) {
    float distanceToLast=-1.0f;
    long timeSinceLast=-1L;
    if (mLastLocation != null) {
      distanceToLast=androidLocation.distanceTo(mLastLocation);
      timeSinceLast=(androidLocation.getTime() - mLastLocation.getTime()) / 1000;
    }
    final float currentSpeed=distanceToLast > 0f && timeSinceLast > 0 ? (distanceToLast / timeSinceLast) : 0f;
    final boolean isLocationAccurate=isLocationAccurate(androidLocation.getAccuracy(),currentSpeed);
    org.droidplanner.core.gcs.location.Location location=new org.droidplanner.core.gcs.location.Location(new Coord3D(androidLocation.getLatitude(),androidLocation.getLongitude(),new Altitude(androidLocation.getAltitude())),androidLocation.getBearing(),androidLocation.getSpeed(),isLocationAccurate,androidLocation.getTime());
    mLastLocation=androidLocation;
    receiver.onLocationUpdate(location);
  }
}","@Override public void onLocationChanged(Location androidLocation){
  if (receiver != null) {
    float distanceToLast=-1.0f;
    long timeSinceLast=-1L;
    final long androidLocationTime=androidLocation.getTime();
    if (mLastLocation != null) {
      distanceToLast=androidLocation.distanceTo(mLastLocation);
      timeSinceLast=(androidLocationTime - mLastLocation.getTime()) / 1000;
    }
    final float currentSpeed=distanceToLast > 0f && timeSinceLast > 0 ? (distanceToLast / timeSinceLast) : 0f;
    final boolean isLocationAccurate=isLocationAccurate(androidLocation.getAccuracy(),currentSpeed);
    org.droidplanner.core.gcs.location.Location location=new org.droidplanner.core.gcs.location.Location(new Coord3D(androidLocation.getLatitude(),androidLocation.getLongitude(),new Altitude(androidLocation.getAltitude())),androidLocation.getBearing(),androidLocation.hasSpeed() ? androidLocation.getSpeed() : currentSpeed,isLocationAccurate,androidLocationTime);
    mLastLocation=androidLocation;
    receiver.onLocationUpdate(location);
  }
}","The original code potentially used unreliable speed calculation and did not handle cases where location speed might be unavailable. The fixed code introduces a fallback mechanism by checking `androidLocation.hasSpeed()` and using the calculated `currentSpeed` if native speed is unavailable, and extracts `androidLocationTime` as a constant to improve readability and potential performance. These modifications enhance the robustness of speed determination and location processing, ensuring more accurate and consistent location updates across different Android devices and location scenarios."
94918,"private void enableFollowMe(){
  lastLocation=null;
  locationFinder.enableLocationUpdates();
  followAlgorithm.enableFollow();
  state=FollowStates.FOLLOW_START;
  drone.notifyDroneEvent(DroneEventsType.FOLLOW_START);
}","private void enableFollowMe(){
  lastLocation=null;
  state=FollowStates.FOLLOW_START;
  locationFinder.enableLocationUpdates();
  followAlgorithm.enableFollow();
  drone.notifyDroneEvent(DroneEventsType.FOLLOW_START);
}","The original code's order of method calls could lead to potential race conditions or inconsistent state initialization before enabling follow algorithm and location updates. The fixed code rearranges the method calls to set the state to FOLLOW_START before enabling location updates and follow algorithm, ensuring a more predictable and stable initialization sequence. This change guarantees that the drone's state is properly set before engaging location tracking and follow mechanisms, reducing the risk of unexpected behavior during the follow me operation."
94919,"@Override public void onDroneEvent(DroneEventsType event,Drone drone){
switch (event) {
case MODE:
    if (!GuidedPoint.isGuidedMode(drone)) {
      disableFollowMe();
    }
  break;
case HEARTBEAT_TIMEOUT:
case DISCONNECTED:
disableFollowMe();
break;
}
}","@Override public void onDroneEvent(DroneEventsType event,Drone drone){
switch (event) {
case MODE:
    if (isEnabled() && !GuidedPoint.isGuidedMode(drone)) {
      disableFollowMe();
    }
  break;
case HEARTBEAT_TIMEOUT:
case DISCONNECTED:
if (isEnabled()) {
  disableFollowMe();
}
break;
}
}","The original code unconditionally disables follow-me mode without checking if it was currently enabled, potentially causing unnecessary state changes. The fixed code adds an `isEnabled()` check before `disableFollowMe()`, ensuring the method is only called when follow-me mode is actually active. This modification prevents redundant method calls and maintains more precise control over the drone's follow-me state, improving the robustness of the event handling logic."
94920,"public void disableFollow(){
  isFollowEnabled.set(false);
  if (GuidedPoint.isGuidedMode(drone)) {
    drone.getGuidedPoint().pauseAtCurrentLocation();
  }
  roiEstimator.disableFollow();
}","public void disableFollow(){
  if (isFollowEnabled.compareAndSet(true,false)) {
    if (GuidedPoint.isGuidedMode(drone)) {
      drone.getGuidedPoint().pauseAtCurrentLocation();
    }
    roiEstimator.disableFollow();
  }
}","The original code always disables follow mode and pauses the drone, potentially causing unnecessary state changes and redundant method calls. The fixed code uses `compareAndSet(true, false)` to ensure the follow mode is only disabled if it was previously enabled, preventing repeated or unintended state transitions. This atomic operation ensures more precise and efficient state management, reducing potential race conditions and unnecessary drone control method invocations."
94921,"protected void updateROI(){
  if (realLocation == null) {
    return;
  }
  Coord2D gcsCoord=new Coord2D(realLocation.getCoord().getLat(),realLocation.getCoord().getLng());
  double bearing=realLocation.getBearing();
  double distanceTraveledSinceLastPoint=realLocation.getSpeed() * (System.currentTimeMillis() - timeOfLastLocation) / 1000f;
  Coord2D goCoord=GeoTools.newCoordFromBearingAndDistance(gcsCoord,bearing,distanceTraveledSinceLastPoint);
  if (distanceTraveledSinceLastPoint > 0.0) {
    MavLinkDoCmds.setROI(drone,new Coord3D(goCoord.getLat(),goCoord.getLng(),new Altitude(0.0)));
  }
  watchdog.postDelayed(watchdogCallback,TIMEOUT);
}","protected void updateROI(){
  if (realLocation == null) {
    return;
  }
  Coord2D gcsCoord=realLocation.getCoord();
  double bearing=realLocation.getBearing();
  double distanceTraveledSinceLastPoint=realLocation.getSpeed() * (System.currentTimeMillis() - timeOfLastLocation) / 1000f;
  Coord2D goCoord=GeoTools.newCoordFromBearingAndDistance(gcsCoord,bearing,distanceTraveledSinceLastPoint);
  MavLinkDoCmds.setROI(drone,new Coord3D(goCoord.getLat(),goCoord.getLng(),new Altitude(0.0)));
  if (realLocation.getSpeed() > 0)   watchdog.postDelayed(watchdogCallback,TIMEOUT);
}","The original code unnecessarily created a new Coord2D object and conditionally set the ROI only if distance traveled was positive, which could lead to missed location updates. The fixed code directly uses the existing coordinate, removes the redundant coordinate creation, and sets the ROI unconditionally while only starting the watchdog when speed is non-zero. These changes ensure more accurate and efficient ROI tracking by simplifying the location processing and conditionally managing the watchdog timer."
94922,"public void disableFollow(){
  disableWatchdog();
  isFollowEnabled.set(false);
  MavLinkDoCmds.resetROI(drone);
}","public void disableFollow(){
  if (isFollowEnabled.compareAndSet(true,false)) {
    realLocation=null;
    MavLinkDoCmds.resetROI(drone);
    disableWatchdog();
  }
}","The original code could lead to race conditions when disabling follow mode, potentially causing inconsistent state and incomplete cleanup. The fixed code uses `compareAndSet` to atomically update the follow state, ensuring only one thread can disable follow mode, and adds explicit state reset like clearing the real location before resetting ROI. This approach provides thread-safe, more predictable behavior with proper sequential cleanup of follow-related resources."
94923,"@Override public void run(){
  final ByteBuffer logBuffer=ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
  logBuffer.order(ByteOrder.BIG_ENDIAN);
  try {
    while (mConnectionStatus.get() == MAVLINK_CONNECTED) {
      final byte[] packetData=mPacketsToLog.take();
      logBuffer.clear();
      logBuffer.putLong(System.currentTimeMillis() * 1000);
      for (      Map.Entry<String,Pair<String,BufferedOutputStream>> entry : loggingOutStreams.entrySet()) {
        final Pair<String,BufferedOutputStream> logInfo=entry.getValue();
        final String loggingFilePath=logInfo.first;
        try {
          BufferedOutputStream logWriter=logInfo.second;
          if (logWriter == null) {
            logWriter=new BufferedOutputStream(new FileOutputStream(loggingFilePath));
            loggingOutStreams.put(entry.getKey(),Pair.create(loggingFilePath,logWriter));
          }
          logWriter.write(logBuffer.array());
          logWriter.write(packetData);
        }
 catch (        IOException e) {
          mLogger.logErr(TAG,""String_Node_Str"" + loggingFilePath,e);
        }
      }
    }
  }
 catch (  InterruptedException e) {
    final String errorMessage=e.getMessage();
    if (errorMessage != null)     mLogger.logVerbose(TAG,errorMessage);
  }
 finally {
    for (    Pair<String,BufferedOutputStream> entry : loggingOutStreams.values()) {
      final String loggingFilePath=entry.first;
      try {
        entry.second.close();
      }
 catch (      IOException e) {
        mLogger.logErr(TAG,""String_Node_Str"" + loggingFilePath,e);
      }
    }
    loggingOutStreams.clear();
  }
}","@Override public void run(){
  final ByteBuffer logBuffer=ByteBuffer.allocate(Long.SIZE / Byte.SIZE);
  logBuffer.order(ByteOrder.BIG_ENDIAN);
  try {
    while (mConnectionStatus.get() == MAVLINK_CONNECTED) {
      final byte[] packetData=mPacketsToLog.take();
      logBuffer.clear();
      logBuffer.putLong(System.currentTimeMillis() * 1000);
      for (      Map.Entry<String,Pair<String,BufferedOutputStream>> entry : loggingOutStreams.entrySet()) {
        final Pair<String,BufferedOutputStream> logInfo=entry.getValue();
        final String loggingFilePath=logInfo.first;
        try {
          BufferedOutputStream logWriter=logInfo.second;
          if (logWriter == null) {
            logWriter=new BufferedOutputStream(new FileOutputStream(loggingFilePath));
            loggingOutStreams.put(entry.getKey(),Pair.create(loggingFilePath,logWriter));
          }
          logWriter.write(logBuffer.array());
          logWriter.write(packetData);
        }
 catch (        IOException e) {
          mLogger.logErr(TAG,""String_Node_Str"" + loggingFilePath,e);
        }
      }
    }
  }
 catch (  InterruptedException e) {
    final String errorMessage=e.getMessage();
    if (errorMessage != null)     mLogger.logVerbose(TAG,errorMessage);
  }
 finally {
    for (    Pair<String,BufferedOutputStream> entry : loggingOutStreams.values()) {
      final String loggingFilePath=entry.first;
      try {
        if (entry.second != null)         entry.second.close();
      }
 catch (      IOException e) {
        mLogger.logErr(TAG,""String_Node_Str"" + loggingFilePath,e);
      }
    }
    loggingOutStreams.clear();
  }
}","The original code did not check if the `BufferedOutputStream` was null before closing it in the finally block, which could potentially cause a `NullPointerException`. In the fixed code, a null check `if (entry.second != null)` was added before calling `close()` on the output stream, preventing potential null reference errors. This modification ensures safe resource management by gracefully handling cases where a stream might not have been initialized, improving the robustness of the logging mechanism."
94924,"@Override public void disableLocationUpdates(){
  try {
    gApiMgr.addTask(removeLocationUpdate);
    gApiMgr.addTask(stopgApiMgr);
  }
 catch (  IllegalStateException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","@Override public void disableLocationUpdates(){
  try {
    if (gApiMgr.isStarted()) {
      gApiMgr.addTask(removeLocationUpdate);
      gApiMgr.addTask(stopgApiMgr);
    }
  }
 catch (  IllegalStateException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","The original code attempts to remove location updates and stop the Google API manager without checking if the manager is in a valid state, risking potential runtime exceptions. The fixed code adds an `isStarted()` check before executing tasks, ensuring the Google API manager is active and ready for operations. This modification prevents potential crashes and provides a more robust implementation by validating the manager's state before performing critical location-related actions."
94925,"/** 
 * Adds a task to the google api client manager tasks queue. This task will be scheduled to run on a background thread.
 * @param task task making use of the google api client.
 * @return true if the task was successfully added to the queue.
 * @throws IllegalStateException is the start() method was not called.
 */
public boolean addTaskToBackground(GoogleApiClientTask task){
  if (!isStarted()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  task.mRunOnBackgroundThread=true;
  return mTaskQueue.offer(task);
}","/** 
 * Adds a task to the google api client manager tasks queue. This task will be scheduled to run on a background thread.
 * @param task task making use of the google api client.
 * @return true if the task was successfully added to the queue.
 * @throws IllegalStateException is the start() method was not called.
 */
public boolean addTaskToBackground(GoogleApiClientTask task){
  if (!isStarted()) {
    Log.e(TAG,""String_Node_Str"");
    return false;
  }
  task.mRunOnBackgroundThread=true;
  return mTaskQueue.offer(task);
}","The original code would throw an IllegalStateException if not started, potentially crashing the application and preventing task execution. The fixed code logs an error and returns false instead, allowing the caller to handle the unstarted state gracefully. This approach provides better error handling and prevents unexpected app termination while maintaining the method's intended functionality of task queue management."
94926,"/** 
 * @return true the google api client manager was started.
 */
private boolean isStarted(){
  return mDriverThread != null && mDriverThread.isAlive() && mBgHandlerThread != null && mBgHandlerThread.isAlive() && mBgHandler != null && mBgHandler.getLooper() != null;
}","/** 
 * @return true the google api client manager was started.
 */
public boolean isStarted(){
  return mDriverThread != null && mDriverThread.isAlive() && mBgHandlerThread != null && mBgHandlerThread.isAlive() && mBgHandler != null && mBgHandler.getLooper() != null;
}","The original code was private, preventing external classes from checking the start status of the Google API client manager. The fixed code changes the method visibility to public, allowing other classes to access and verify the initialization state. This modification enhances the method's usability by enabling external components to query the startup status of critical threading components."
94927,"/** 
 * Adds a task to the google api client manager tasks queue. This task will be scheduled to run on the calling thread.
 * @param task task making use of the google api client.
 * @return true if the task was successfully added to the queue.
 * @throws IllegalStateException is the start() method was not called.
 */
public boolean addTask(GoogleApiClientTask task){
  if (!isStarted()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  task.mRunOnBackgroundThread=false;
  return mTaskQueue.offer(task);
}","/** 
 * Adds a task to the google api client manager tasks queue. This task will be scheduled to run on the calling thread.
 * @param task task making use of the google api client.
 * @return true if the task was successfully added to the queue.
 * @throws IllegalStateException is the start() method was not called.
 */
public boolean addTask(GoogleApiClientTask task){
  if (!isStarted()) {
    Log.e(TAG,""String_Node_Str"");
    return false;
  }
  task.mRunOnBackgroundThread=false;
  return mTaskQueue.offer(task);
}","The original code threw an IllegalStateException when not started, which could abruptly halt the application's execution. The fixed code replaces the exception with a log error and returns false, allowing the caller to handle the non-started state gracefully. This approach provides better error handling by preventing unexpected crashes and enabling more flexible task management."
94928,"private void enableFollowMe(){
  followAlgorithm.enableFollow();
  locationFinder.enableLocationUpdates();
  state=FollowStates.FOLLOW_START;
  drone.notifyDroneEvent(DroneEventsType.FOLLOW_START);
}","private void enableFollowMe(){
  lastLocation=null;
  locationFinder.enableLocationUpdates();
  followAlgorithm.enableFollow();
  state=FollowStates.FOLLOW_START;
  drone.notifyDroneEvent(DroneEventsType.FOLLOW_START);
}","The original code might lead to potential errors by not initializing or resetting the lastLocation before starting the follow-me functionality. The fixed code adds lastLocation=null before enabling location updates, ensuring a clean slate and preventing potential stale location data from interfering with the new follow session. This initialization provides a more robust and predictable start to the follow-me process, reducing the risk of unexpected tracking behaviors."
94929,"private void disableFollowMe(){
  followAlgorithm.disableFollow();
  locationFinder.disableLocationUpdates();
  if (isEnabled()) {
    state=FollowStates.FOLLOW_END;
    drone.notifyDroneEvent(DroneEventsType.FOLLOW_STOP);
  }
}","private void disableFollowMe(){
  followAlgorithm.disableFollow();
  locationFinder.disableLocationUpdates();
  lastLocation=null;
  if (isEnabled()) {
    state=FollowStates.FOLLOW_END;
    drone.notifyDroneEvent(DroneEventsType.FOLLOW_STOP);
  }
}","The original code lacks proper cleanup of the lastLocation variable when disabling follow-me mode, potentially causing stale location data to persist. The fixed code adds `lastLocation=null`, ensuring a clean reset of the location tracking state when follow mode is disabled. This change prevents potential bugs related to lingering location information and provides a more robust state management when transitioning out of follow-me mode."
94930,"public void setAlgorithm(FollowAlgorithm algorithm){
  if (followAlgorithm != null && followAlgorithm != algorithm) {
    followAlgorithm.disableFollow();
  }
  followAlgorithm=algorithm;
  if (isEnabled()) {
    followAlgorithm.enableFollow();
  }
  drone.notifyDroneEvent(DroneEventsType.FOLLOW_CHANGE_TYPE);
}","public void setAlgorithm(FollowAlgorithm algorithm){
  if (followAlgorithm != null && followAlgorithm != algorithm) {
    followAlgorithm.disableFollow();
  }
  followAlgorithm=algorithm;
  if (isEnabled()) {
    followAlgorithm.enableFollow();
    if (lastLocation != null)     followAlgorithm.onLocationReceived(lastLocation);
  }
  drone.notifyDroneEvent(DroneEventsType.FOLLOW_CHANGE_TYPE);
}","The original code failed to reinitialize the follow algorithm with the last known location after changing algorithms, potentially causing tracking inconsistencies. The fixed code adds a critical line to check and pass the last location to the new algorithm when enabled, ensuring continuous and accurate tracking. This improvement guarantees that the drone maintains its spatial context even when switching follow algorithms, preventing potential tracking disruptions."
94931,"@Override public void onLocationChanged(Location location){
  if (location.isAccurate()) {
    state=FollowStates.FOLLOW_RUNNING;
    followAlgorithm.processNewLocation(location);
  }
 else {
    state=FollowStates.FOLLOW_START;
  }
  drone.notifyDroneEvent(DroneEventsType.FOLLOW_UPDATE);
}","@Override public void onLocationChanged(Location location){
  if (location.isAccurate()) {
    state=FollowStates.FOLLOW_RUNNING;
    lastLocation=location;
    followAlgorithm.onLocationReceived(location);
  }
 else {
    state=FollowStates.FOLLOW_START;
  }
  drone.notifyDroneEvent(DroneEventsType.FOLLOW_UPDATE);
}","The original code lacks proper location tracking and does not save the last received location, potentially causing incomplete follow-up processing. The fixed code introduces `lastLocation = location` to store the most recent accurate location and changes the method call from `processNewLocation()` to `onLocationReceived()`, ensuring proper location handling. These modifications enhance location tracking reliability and provide a more robust mechanism for drone follow-up algorithms."
94932,"public void enableFollow(){
  isFollowEnabled.set(true);
}","public void enableFollow(){
  MavLinkDoCmds.resetROI(drone);
  isFollowEnabled.set(true);
}","The original code simply sets a boolean flag without performing any necessary preparatory actions for enabling follow mode. The fixed code adds a critical reset method `MavLinkDoCmds.resetROI(drone)` before setting the flag, which likely resets the drone's Region of Interest (ROI) to ensure proper initialization. This approach ensures a clean and consistent state before enabling follow mode, preventing potential tracking or navigation inconsistencies."
94933,"protected Bitmap doInBackground(String... urls){
  String urldisplay=urls[0];
  Bitmap mIcon11=null;
  try {
    InputStream in=new java.net.URL(urldisplay).openStream();
    mIcon11=BitmapFactory.decodeStream(in);
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",e.getMessage());
  }
  return mIcon11;
}","protected Bitmap doInBackground(String... urls){
  String urlDisplay=urls[0];
  if (urlDisplay == null)   return null;
  Bitmap mIcon11=null;
  try {
    InputStream in=new URL(urlDisplay).openStream();
    mIcon11=BitmapFactory.decodeStream(in);
  }
 catch (  Exception e) {
    Log.e(TAG,e.getMessage(),e);
  }
  return mIcon11;
}","The original code lacked null checking for the input URL and used inconsistent error logging, risking potential null pointer exceptions and incomplete error tracking. The fixed code adds a null check for the URL, uses a more standard URL instantiation, and improves error logging by including the full exception context in the log. These modifications enhance error handling, prevent potential crashes, and provide more comprehensive debugging information for developers."
94934,"protected void onPostExecute(Bitmap result){
  bmImage.setImageBitmap(result);
  cachedMap.put(appId,result);
}","protected void onPostExecute(Bitmap result){
  if (result != null) {
    if (bmImage != null)     bmImage.setImageBitmap(result);
    if (cachedMap != null && appId != null)     cachedMap.put(appId,result);
  }
}","The original code lacks null checks, risking NullPointerExceptions if `bmImage`, `cachedMap`, or `result` are null during bitmap processing. The fixed code adds conditional checks to ensure `result` exists, and both `bmImage` and `cachedMap` are not null before performing operations. These defensive programming techniques prevent potential runtime crashes and make the method more robust by gracefully handling unexpected null scenarios."
94935,"/** 
 * Set a Relay pin’s voltage high or low
 * @param drone target vehicle
 * @param relayNumber
 * @param enabled true for relay to be on, false for relay to be off.
 */
public static void setRelay(Drone drone,int relayNumber,boolean enabled){
  Bundle params=new Bundle(2);
  params.putInt(EXTRA_RELAY_NUMBER,relayNumber);
  params.putBoolean(EXTRA_IS_RELAY_ON,enabled);
  drone.performAsyncAction(new Action(ACTION_SET_RELAY,params));
}","/** 
 * Set a Relay pin’s voltage high or low
 * @param drone       target vehicle
 * @param relayNumber
 * @param enabled     true for relay to be on, false for relay to be off.
 */
public static void setRelay(Drone drone,int relayNumber,boolean enabled){
  Bundle params=new Bundle(2);
  params.putInt(EXTRA_RELAY_NUMBER,relayNumber);
  params.putBoolean(EXTRA_IS_RELAY_ON,enabled);
  drone.performAsyncAction(new Action(ACTION_SET_RELAY,params));
}","The original code lacks proper documentation clarity, with unevenly aligned parameter descriptions in the Javadoc comment. The fixed code improves the Javadoc by aligning the parameter descriptions consistently and adding appropriate spacing, enhancing readability and professional code presentation. These subtle formatting improvements make the method documentation more organized and easier to understand for developers maintaining or using the code."
94936,"@Override public Bundle[] getConnectedApps(String requesterId) throws RemoteException {
  Log.d(TAG,""String_Node_Str"" + requesterId);
  List<Bundle> appsInfo=new ArrayList<>();
  for (  DroneApi droneApi : getService().droneApiStore) {
    if (droneApi.isConnected()) {
      final ConnectionParameter droneParams=droneApi.getDroneManager().getConnectionParameter();
      final ConnectionParameter sanitizedParams=new ConnectionParameter(droneParams.getConnectionType(),droneParams.getParamsBundle(),null);
      Bundle info=new Bundle();
      info.putString(GCSEvent.EXTRA_APP_ID,droneApi.getOwnerId());
      info.putParcelable(GCSEvent.EXTRA_VEHICLE_CONNECTION_PARAMETER,sanitizedParams);
      appsInfo.add(info);
    }
  }
  return appsInfo.toArray(new Bundle[appsInfo.size()]);
}","@Override public Bundle[] getConnectedApps(String requesterId) throws RemoteException {
  Log.d(TAG,""String_Node_Str"" + requesterId);
  List<Bundle> appsInfo=new ArrayList<>();
  for (  DroneApi droneApi : serviceRef.droneApiStore.values()) {
    if (droneApi.isConnected()) {
      final ConnectionParameter droneParams=droneApi.getDroneManager().getConnectionParameter();
      final ConnectionParameter sanitizedParams=new ConnectionParameter(droneParams.getConnectionType(),droneParams.getParamsBundle(),null);
      Bundle info=new Bundle();
      info.putString(GCSEvent.EXTRA_APP_ID,droneApi.getOwnerId());
      info.putParcelable(GCSEvent.EXTRA_VEHICLE_CONNECTION_PARAMETER,sanitizedParams);
      appsInfo.add(info);
    }
  }
  return appsInfo.toArray(new Bundle[appsInfo.size()]);
}","The original code incorrectly iterated over `getService().droneApiStore` directly, which may not be the intended way to access the collection of drone APIs. In the fixed code, `serviceRef.droneApiStore.values()` is used, suggesting a proper method to retrieve the collection of DroneApi instances. This change ensures correct iteration over the drone API store, improving the method's reliability and preventing potential null or incorrect reference errors."
94937,"@Override public IDroneApi registerDroneApi(IApiListener listener,String appId) throws RemoteException {
  return getService().registerDroneApi(listener,appId);
}","@Override public IDroneApi registerDroneApi(IApiListener listener,String appId) throws RemoteException {
  return serviceRef.registerDroneApi(listener,appId);
}","The original code uses `getService()` to retrieve the service, which may create a new service instance each time, potentially leading to inconsistent or unnecessary service calls. The fixed code uses `serviceRef`, a direct reference to the service, ensuring a consistent and efficient service interaction. By using `serviceRef`, the code maintains a stable service connection and avoids redundant service instantiation, improving overall performance and reliability."
94938,"@Override public void releaseDroneApi(IDroneApi dpApi) throws RemoteException {
  Log.d(TAG,""String_Node_Str"");
  if (dpApi instanceof DroneApi) {
    getService().releaseDroneApi((DroneApi)dpApi);
  }
}","@Override public void releaseDroneApi(IDroneApi dpApi) throws RemoteException {
  Log.d(TAG,""String_Node_Str"");
  if (dpApi instanceof DroneApi) {
    serviceRef.releaseDroneApi(((DroneApi)dpApi).getOwnerId());
  }
}","The original code attempts to release a drone API by directly calling `releaseDroneApi` on the service, which is incorrect and may lead to improper resource management. The fixed code calls `releaseDroneApi` on the service reference with the owner ID obtained from the drone API, ensuring proper identification and release of the specific API instance. This modification enhances resource handling and prevents potential memory leaks or unintended API interactions by explicitly passing the owner's identifier."
94939,"DPServices(DroidPlannerService service){
  serviceRef=new WeakReference<DroidPlannerService>(service);
}","DPServices(DroidPlannerService service){
  serviceRef=service;
}","The original code incorrectly uses a WeakReference, which can potentially lead to premature garbage collection of the service object. The fixed code directly assigns the service reference, ensuring a strong reference that prevents unintended memory management issues. This change maintains a stable connection to the DroidPlannerService, guaranteeing the service remains accessible throughout its lifecycle."
94940,"@Override public void onDestroy(){
  super.onDestroy();
  Log.d(TAG,""String_Node_Str"");
  for (  DroneApi droneApi : droneApiStore) {
    droneApi.destroy();
  }
  droneApiStore.clear();
  for (  AndroidMavLinkConnection conn : mavConnections.values()) {
    conn.disconnect();
    conn.removeAllMavLinkConnectionListeners();
  }
  mavConnections.clear();
  stopForeground(true);
}","@Override public void onDestroy(){
  super.onDestroy();
  Log.d(TAG,""String_Node_Str"");
  for (  DroneApi droneApi : droneApiStore.values()) {
    droneApi.destroy();
  }
  droneApiStore.clear();
  for (  AndroidMavLinkConnection conn : mavConnections.values()) {
    conn.disconnect();
    conn.removeAllMavLinkConnectionListeners();
  }
  mavConnections.clear();
  dpServices.destroy();
  stopForeground(true);
}","The original code incorrectly iterates over `droneApiStore` as a collection, which assumes it is a direct list or set of `DroneApi` objects. The fixed code uses `.values()` to properly access the collection's elements from what appears to be a map-based data structure. By adding `dpServices.destroy()` and correctly accessing the collection's values, the fixed code ensures proper cleanup of resources, prevents potential null pointer exceptions, and provides a more robust method for destroying drone-related services and connections."
94941,"DroneApi registerDroneApi(IApiListener listener,String appId){
  if (listener == null)   return null;
  DroneApi droneApi=new DroneApi(this,new Handler(Looper.getMainLooper()),mavlinkApi,listener,appId);
  droneApiStore.add(droneApi);
  lbm.sendBroadcast(new Intent(ACTION_DRONE_CREATED));
  return droneApi;
}","DroneApi registerDroneApi(IApiListener listener,String appId){
  if (listener == null)   return null;
  DroneApi droneApi=new DroneApi(this,new Handler(Looper.getMainLooper()),mavlinkApi,listener,appId);
  droneApiStore.put(appId,droneApi);
  lbm.sendBroadcast(new Intent(ACTION_DRONE_CREATED));
  return droneApi;
}","The original code used `.add()` on `droneApiStore`, which suggests a list-based storage that could lead to duplicate entries and inefficient lookup. The fixed code replaces `.add()` with `.put(appId, droneApi)`, indicating a map-based storage that uses the `appId` as a unique key for each drone API instance. This change ensures unique, identifiable, and easily retrievable drone API objects with a more robust and predictable storage mechanism."
94942,"void releaseDroneApi(DroneApi droneApi){
  if (droneApi == null)   return;
  droneApiStore.remove(droneApi);
  droneApi.destroy();
  lbm.sendBroadcast(new Intent(ACTION_DRONE_DESTROYED));
}","void releaseDroneApi(String appId){
  if (appId == null)   return;
  DroneApi droneApi=droneApiStore.remove(appId);
  if (droneApi != null) {
    Log.d(TAG,""String_Node_Str"" + appId);
    droneApi.destroy();
    lbm.sendBroadcast(new Intent(ACTION_DRONE_DESTROYED));
  }
}","The original code lacks proper validation when removing a DroneApi, risking potential null pointer exceptions and unintended removal of APIs. The fixed code introduces a key modification by using the app ID as the removal parameter and adding a null check before destroying the drone API. This approach ensures safer API management, prevents unnecessary destruction attempts, and provides logging for better debugging and traceability."
94943,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  if (intent != null) {
    final String action=intent.getAction();
    if (ACTION_KICK_START_DRONESHARE_UPLOADS.equals(action)) {
      for (      DroneApi droneApi : droneApiStore) {
        droneApi.getDroneManager().kickStartDroneShareUpload();
      }
    }
  }
  stopSelf();
  return START_NOT_STICKY;
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  if (intent != null) {
    final String action=intent.getAction();
switch (action) {
case ACTION_KICK_START_DRONESHARE_UPLOADS:
      for (      DroneApi droneApi : droneApiStore.values()) {
        droneApi.getDroneManager().kickStartDroneShareUpload();
      }
    break;
case ACTION_RELEASE_API_INSTANCE:
  final String appId=intent.getStringExtra(EXTRA_API_INSTANCE_APP_ID);
releaseDroneApi(appId);
break;
}
}
stopSelf();
return START_NOT_STICKY;
}","The original code iterates over `droneApiStore` without specifying a collection type, which could lead to potential null pointer or type casting errors. The fixed code uses `.values()` to safely iterate through the collection and adds a new `ACTION_RELEASE_API_INSTANCE` case for handling additional service actions. By introducing a switch statement and explicit method calls, the code becomes more robust, handles multiple action types, and provides clearer, more intentional service behavior."
94944,"public List<DroneApi> getDroneApiList(){
  return new ArrayList<>(serviceRef.droneApiStore);
}","public List<DroneApi> getDroneApiList(){
  return new ArrayList<>(serviceRef.droneApiStore.values());
}","The original code directly copies a map reference, which would not properly extract the list of DroneApi objects. The fixed code uses .values() to retrieve all DroneApi values from the map, creating a new ArrayList with the actual drone API collection. This ensures a correct extraction of drone API objects, preventing potential null or incomplete list issues when accessing the collection."
94945,"void destroy(){
  this.serviceRef.clear();
  this.observersList.clear();
  this.mavlinkObserversList.clear();
  this.apiListener.asBinder().unlinkToDeath(this,0);
  this.droneMgr.setDroneEventsListener(null);
  this.droneMgr.destroy();
}","void destroy(){
  Log.d(TAG,""String_Node_Str"" + this.ownerId);
  this.observersList.clear();
  this.mavlinkObserversList.clear();
  this.apiListener.asBinder().unlinkToDeath(this,0);
  this.droneMgr.setDroneEventsListener(null);
  this.droneMgr.destroy();
}","The original code contained an unnecessary `this.serviceRef.clear()` method call that was likely unrelated to the destruction process or potentially causing unintended side effects. The fixed code removes this line and adds a logging statement with the `ownerId` for debugging purposes. By eliminating the extraneous method call and introducing targeted logging, the code now provides better clarity and reduces the risk of unexpected behavior during object destruction."
94946,"private void checkForSelfRelease(){
  if (!apiListener.asBinder().pingBinder()) {
    Log.w(TAG,""String_Node_Str"");
    getService().releaseDroneApi(this);
  }
}","private void checkForSelfRelease(){
  if (!apiListener.asBinder().pingBinder()) {
    Log.w(TAG,""String_Node_Str"");
    this.context.startService(new Intent(this.context,DroidPlannerService.class).setAction(DroidPlannerService.ACTION_RELEASE_API_INSTANCE).putExtra(DroidPlannerService.EXTRA_API_INSTANCE_APP_ID,this.ownerId));
  }
}","The original code directly calls `releaseDroneApi()` on the service, which could lead to potential threading or lifecycle management issues. The fixed code introduces a more robust approach by sending an explicit intent to the service with a specific action and extra data, allowing for safer and more controlled API instance release. This method ensures a decoupled, asynchronous communication between the component and the service, improving the overall reliability and maintainability of the API release mechanism."
94947,"private Parameters getParameters(){
  final Drone drone=this.droneMgr.getDrone();
  final Map<String,com.o3dr.services.android.lib.drone.property.Parameter> proxyParams=new HashMap<String,com.o3dr.services.android.lib.drone.property.Parameter>();
  List<Parameter> droneParameters=drone.getParameters().getParametersList();
  if (!droneParameters.isEmpty()) {
    for (    Parameter param : droneParameters) {
      if (param.name != null) {
        proxyParams.put(param.name,new com.o3dr.services.android.lib.drone.property.Parameter(param.name,param.value,param.type));
      }
    }
    try {
      final VehicleProfile profile=drone.getVehicleProfile();
      if (profile != null) {
        String metadataType=profile.getParameterMetadataType();
        if (metadataType != null) {
          ParameterMetadataLoader.load(getService().getApplicationContext(),metadataType,proxyParams);
        }
      }
    }
 catch (    IOException e) {
      Log.e(TAG,e.getMessage(),e);
    }
catch (    XmlPullParserException e) {
      Log.e(TAG,e.getMessage(),e);
    }
  }
  return new Parameters(new ArrayList<com.o3dr.services.android.lib.drone.property.Parameter>(proxyParams.values()));
}","private Parameters getParameters(){
  final Drone drone=this.droneMgr.getDrone();
  final Map<String,com.o3dr.services.android.lib.drone.property.Parameter> proxyParams=new HashMap<String,com.o3dr.services.android.lib.drone.property.Parameter>();
  List<Parameter> droneParameters=drone.getParameters().getParametersList();
  if (!droneParameters.isEmpty()) {
    for (    Parameter param : droneParameters) {
      if (param.name != null) {
        proxyParams.put(param.name,new com.o3dr.services.android.lib.drone.property.Parameter(param.name,param.value,param.type));
      }
    }
    try {
      final VehicleProfile profile=drone.getVehicleProfile();
      if (profile != null) {
        String metadataType=profile.getParameterMetadataType();
        if (metadataType != null) {
          ParameterMetadataLoader.load(this.context,metadataType,proxyParams);
        }
      }
    }
 catch (    IOException e) {
      Log.e(TAG,e.getMessage(),e);
    }
catch (    XmlPullParserException e) {
      Log.e(TAG,e.getMessage(),e);
    }
  }
  return new Parameters(new ArrayList<com.o3dr.services.android.lib.drone.property.Parameter>(proxyParams.values()));
}","The original code incorrectly used `getService().getApplicationContext()`, which may not always provide a valid context for parameter metadata loading. The fixed code replaces this with `this.context`, directly utilizing a more reliable and consistent context reference for loading parameter metadata. By using a direct context reference, the code ensures more predictable and robust parameter metadata retrieval across different method invocations."
94948,"DroneApi(DroidPlannerService dpService,final Handler handler,MavLinkServiceApi mavlinkApi,IApiListener listener,String ownerId){
  this.context=dpService.getApplicationContext();
  this.droneHandler=new DroneInterfaces.Handler(){
    @Override public void removeCallbacks(    Runnable thread){
      handler.removeCallbacks(thread);
    }
    @Override public void post(    Runnable thread){
      handler.post(thread);
    }
    @Override public void postDelayed(    Runnable thread,    long timeout){
      handler.postDelayed(thread,timeout);
    }
  }
;
  this.ownerId=ownerId;
  serviceRef=new SoftReference<DroidPlannerService>(dpService);
  observersList=new ConcurrentLinkedQueue<IObserver>();
  mavlinkObserversList=new ConcurrentLinkedQueue<IMavlinkObserver>();
  this.droneMgr=new DroneManager(context,this.ownerId,handler,mavlinkApi);
  this.droneMgr.setDroneEventsListener(this);
  this.apiListener=listener;
  try {
    this.apiListener.asBinder().linkToDeath(this,0);
    checkForSelfRelease();
  }
 catch (  RemoteException e) {
    Log.e(TAG,e.getMessage(),e);
    dpService.releaseDroneApi(this);
  }
}","DroneApi(DroidPlannerService dpService,final Handler handler,MavLinkServiceApi mavlinkApi,IApiListener listener,String ownerId){
  this.context=dpService.getApplicationContext();
  this.droneHandler=new DroneInterfaces.Handler(){
    @Override public void removeCallbacks(    Runnable thread){
      handler.removeCallbacks(thread);
    }
    @Override public void post(    Runnable thread){
      handler.post(thread);
    }
    @Override public void postDelayed(    Runnable thread,    long timeout){
      handler.postDelayed(thread,timeout);
    }
  }
;
  this.ownerId=ownerId;
  observersList=new ConcurrentLinkedQueue<>();
  mavlinkObserversList=new ConcurrentLinkedQueue<>();
  this.droneMgr=new DroneManager(context,this.ownerId,handler,mavlinkApi);
  this.droneMgr.setDroneEventsListener(this);
  this.apiListener=listener;
  try {
    this.apiListener.asBinder().linkToDeath(this,0);
    checkForSelfRelease();
  }
 catch (  RemoteException e) {
    Log.e(TAG,e.getMessage(),e);
    dpService.releaseDroneApi(this.ownerId);
  }
}","The original code incorrectly passed the entire service object to `releaseDroneApi`, which could cause unintended side effects across multiple drone APIs. The fixed code changes this to pass only the `ownerId`, ensuring precise and targeted API release. This modification improves method precision, prevents potential resource leaks, and provides more granular control over individual drone API instances."
94949,"public void refreshDroneList(){
  DroneAccess droneAccess=parent.getDroneAccess();
  if (droneAccess != null) {
    List<DroneApi> dronesList=droneAccess.getDroneApiList();
    appConnectionAdapter.refreshDroneManagerList(dronesList);
  }
  boolean isEmpty=appConnectionAdapter.getItemCount() <= 0;
  defaultView.setVisibility(isEmpty ? View.VISIBLE : View.GONE);
}","public void refreshDroneList(){
  if (parent == null)   return;
  DroneAccess droneAccess=parent.getDroneAccess();
  if (droneAccess != null) {
    List<DroneApi> dronesList=droneAccess.getDroneApiList();
    appConnectionAdapter.refreshDroneManagerList(dronesList);
  }
  boolean isEmpty=appConnectionAdapter.getItemCount() <= 0;
  defaultView.setVisibility(isEmpty ? View.VISIBLE : View.GONE);
}","The original code lacks a null check on the parent object, which could lead to a NullPointerException when accessing parent methods. In the fixed code, an early return statement is added to check if parent is null, preventing potential runtime errors before proceeding with drone list refresh. This defensive programming approach enhances code robustness by ensuring method safety and preventing unexpected crashes when the parent context is unavailable."
94950,"@Override public void onEndReceivingParameters(List<Parameter> parameter){
  notifyAttributeUpdate(AttributeEvent.PARAMETERS_REFRESH_ENDED,null);
}","@Override public void onEndReceivingParameters(){
  notifyAttributeUpdate(AttributeEvent.PARAMETERS_REFRESH_ENDED,null);
}","The original method incorrectly included a `List<Parameter>` parameter that was not used or required in the method signature. The fixed code removes the unnecessary parameter, simplifying the method to match the intended implementation of `onEndReceivingParameters()`. This correction ensures the method accurately reflects its purpose of notifying about the end of parameter refresh without introducing unused arguments."
94951,"private Parameters getParameters(){
  final Drone drone=this.droneMgr.getDrone();
  final Map<String,com.o3dr.services.android.lib.drone.property.Parameter> proxyParams=new HashMap<String,com.o3dr.services.android.lib.drone.property.Parameter>();
  List<Parameter> droneParameters=drone.getParameters().getParametersList();
  if (!droneParameters.isEmpty()) {
    for (    Parameter param : droneParameters) {
      if (param.name != null) {
        proxyParams.put(param.name,new com.o3dr.services.android.lib.drone.property.Parameter(param.name,param.value,param.type));
      }
    }
    try {
      final VehicleProfile profile=drone.getVehicleProfile();
      if (profile != null) {
        String metadataType=profile.getParameterMetadataType();
        if (metadataType != null) {
          ParameterMetadataLoader.load(this.context,metadataType,proxyParams);
        }
      }
    }
 catch (    IOException e) {
      Log.e(TAG,e.getMessage(),e);
    }
catch (    XmlPullParserException e) {
      Log.e(TAG,e.getMessage(),e);
    }
  }
  return new Parameters(new ArrayList<com.o3dr.services.android.lib.drone.property.Parameter>(proxyParams.values()));
}","private Parameters getParameters(){
  final Drone drone=this.droneMgr.getDrone();
  final Map<String,com.o3dr.services.android.lib.drone.property.Parameter> proxyParams=new HashMap<>();
  Map<String,Parameter> droneParameters=drone.getParameters().getParameters();
  if (!droneParameters.isEmpty()) {
    for (    Parameter param : droneParameters.values()) {
      if (param.name != null) {
        proxyParams.put(param.name,new com.o3dr.services.android.lib.drone.property.Parameter(param.name,param.value,param.type));
      }
    }
    try {
      final VehicleProfile profile=drone.getVehicleProfile();
      if (profile != null) {
        String metadataType=profile.getParameterMetadataType();
        if (metadataType != null) {
          ParameterMetadataLoader.load(this.context,metadataType,proxyParams);
        }
      }
    }
 catch (    IOException|XmlPullParserException e) {
      Log.e(TAG,e.getMessage(),e);
    }
  }
  return new Parameters(new ArrayList<>(proxyParams.values()));
}","The original code incorrectly used `getParametersList()`, which returns a List, instead of `getParameters()`, which returns a Map of parameters. The fixed code switches to `getParameters().values()`, iterating through the map correctly and using the more appropriate method for accessing drone parameters. This change improves type safety, reduces potential null pointer risks, and provides a more efficient and direct way of accessing and processing drone parameters."
94952,"@Override public void onEndReceivingParameters(List<Parameter> parameter){
  if (droneEventsListener != null) {
    droneEventsListener.onEndReceivingParameters(parameter);
  }
}","@Override public void onEndReceivingParameters(){
  if (droneEventsListener != null) {
    droneEventsListener.onEndReceivingParameters();
  }
}","The original method incorrectly includes a `List<Parameter>` parameter, which does not match the expected method signature of the interface or parent class. The fixed code removes the parameter, ensuring the method signature matches the intended interface definition for `onEndReceivingParameters()`. This correction prevents potential compilation errors and ensures proper method overriding, maintaining the correct interface contract for drone event handling."
94953,public void onEndReceivingParameters(List<Parameter> parameter);,public void onEndReceivingParameters();,"The original method signature includes an unnecessary and potentially problematic `List<Parameter>` parameter that is not being utilized in the method's purpose. The fixed code removes the redundant parameter, simplifying the method to `onEndReceivingParameters()` without any input arguments. By eliminating the unused parameter, the code becomes cleaner, more focused, and reduces potential confusion about the method's intended functionality during parameter receiving completion."
94954,"private void reRequestMissingParams(int howManyParams){
  for (int i=0; i < howManyParams; i++) {
    if (!parameters.containsKey(i)) {
      MavLinkParameters.readParameter(myDrone,i);
    }
  }
}","private void reRequestMissingParams(int howManyParams){
  for (int i=0; i < howManyParams; i++) {
    Boolean isPresent=paramsRollCall.get(i);
    if (isPresent == null || !isPresent) {
      MavLinkParameters.readParameter(myDrone,i);
    }
  }
}","The original code incorrectly checks parameter presence using `parameters.containsKey(i)`, which may not accurately track missing parameters. The fixed code introduces `paramsRollCall`, a map that explicitly tracks parameter retrieval status using Boolean values, allowing for more precise tracking of missing parameters. By using `isPresent == null || !isPresent`, the code ensures comprehensive parameter re-request logic, improving parameter management reliability."
94955,"public void refreshParameters(){
  parameters.clear();
  parameterList.clear();
  if (parameterListener != null)   parameterListener.onBeginReceivingParameters();
  MavLinkParameters.requestParametersList(myDrone);
  resetWatchdog();
}","public void refreshParameters(){
  parameters.clear();
  paramsRollCall.clear();
  if (parameterListener != null)   parameterListener.onBeginReceivingParameters();
  MavLinkParameters.requestParametersList(myDrone);
  resetWatchdog();
}","The original code incorrectly clears `parameterList`, which may not be the intended collection for parameter management. The fixed code replaces `parameterList` with `paramsRollCall`, suggesting a more accurate variable name and potentially resolving a synchronization or data tracking issue. This change ensures proper parameter list management and potentially improves the reliability of parameter retrieval and tracking in the MavLink parameter request process."
94956,"private void processReceivedParam(msg_param_value m_value){
  Parameter param=new Parameter(m_value);
  parameters.put((int)m_value.param_index,param);
  expectedParams=m_value.param_count;
  if (parameterListener != null)   parameterListener.onParameterReceived(param,m_value.param_index,m_value.param_count);
  if (parameters.size() >= m_value.param_count) {
    parameterList.clear();
    for (    int key : parameters.keySet()) {
      parameterList.add(parameters.get(key));
    }
    killWatchdog();
    myDrone.notifyDroneEvent(DroneEventsType.PARAMETERS_DOWNLOADED);
    if (parameterListener != null) {
      parameterListener.onEndReceivingParameters(parameterList);
    }
  }
 else {
    resetWatchdog();
  }
  myDrone.notifyDroneEvent(DroneEventsType.PARAMETER);
}","private void processReceivedParam(msg_param_value m_value){
  Parameter param=new Parameter(m_value);
  paramsRollCall.put((int)m_value.param_index,true);
  parameters.put(param.name.toLowerCase(Locale.US),param);
  expectedParams=m_value.param_count;
  if (parameterListener != null)   parameterListener.onParameterReceived(param,m_value.param_index,m_value.param_count);
  if (parameters.size() >= m_value.param_count) {
    killWatchdog();
    myDrone.notifyDroneEvent(DroneEventsType.PARAMETERS_DOWNLOADED);
    if (parameterListener != null) {
      parameterListener.onEndReceivingParameters();
    }
  }
 else {
    resetWatchdog();
  }
  myDrone.notifyDroneEvent(DroneEventsType.PARAMETER);
}","The original code incorrectly stored parameters using only their index, risking potential overwrites and lacking a robust tracking mechanism. The fixed code introduces a separate `paramsRollCall` to track received parameters and uses the parameter name as the key in the `parameters` map, ensuring unique and consistent storage. This approach improves parameter management by preventing index collisions and providing a more reliable method of tracking and storing drone parameters."
94957,"public Parameter getParameter(String name){
  for (  int key : parameters.keySet()) {
    if (parameters.get(key).name.equalsIgnoreCase(name))     return parameters.get(key);
  }
  return null;
}","public Parameter getParameter(String name){
  if (name == null || name.length() == 0)   return null;
  return parameters.get(name.toLowerCase(Locale.US));
}","The original code inefficiently iterates through parameter keys, performing case-insensitive comparisons and multiple hash map lookups, which is computationally expensive. The fixed code uses a lowercase key as the map index and preemptively checks for null or empty input, simplifying lookup and improving performance. By directly accessing the map with a standardized lowercase key, the solution becomes more concise, faster, and less error-prone."
94958,"void destroy(){
  this.apiListener.asBinder().unlinkToDeath(this,0);
  this.droneMgr.setDroneEventsListener(null);
  this.droneMgr.destroy();
  this.serviceRef.clear();
  this.observersList.clear();
  this.mavlinkObserversList.clear();
}","void destroy(){
  this.serviceRef.clear();
  this.observersList.clear();
  this.mavlinkObserversList.clear();
  this.apiListener.asBinder().unlinkToDeath(this,0);
  this.droneMgr.setDroneEventsListener(null);
  this.droneMgr.destroy();
}","The original code risked potential null pointer exceptions or resource leaks by destructively calling methods before clearing references. The fixed code reorders operations, first clearing collections and service references to ensure clean state before performing binder and drone manager operations. This approach prevents potential memory management issues and provides a more robust destruction sequence that safely releases resources and listeners."
94959,"@Override public void removeEventUpdates(IDroidPlannerApiCallback callback) throws RemoteException {
  if (callback != null)   apiCallbacks.remove(callback);
}","@Override public void removeEventUpdates(IDroidPlannerApiCallback callback) throws RemoteException {
  if (callback != null) {
    apiCallbacks.remove(callback);
    if (apiCallbacks.isEmpty())     getService().releaseDroidPlannerApi(this);
  }
}","The original code only removes the callback from the list without checking if the list becomes empty, potentially leaving an unnecessary API connection open. The fixed code adds a condition to check if the `apiCallbacks` list is empty after removing the callback, and if so, it calls `releaseDroidPlannerApi()` to properly clean up the service connection. This ensures efficient resource management by automatically releasing the API when no more callbacks are registered, preventing potential resource leaks."
94960,"void connectMAVConnection(ConnectionParameter connParams){
  AndroidMavLinkConnection conn=mavConnections.get(connParams);
  if (conn == null) {
    final int connectionType=connParams.getConnectionType();
    final Bundle paramsBundle=connParams.getParamsBundle();
switch (connectionType) {
case ConnectionType.TYPE_USB:
      final int baudRate=paramsBundle.getInt(ConnectionType.EXTRA_USB_BAUD_RATE,ConnectionType.DEFAULT_USB_BAUD_RATE);
    conn=new UsbConnection(getApplicationContext(),baudRate);
  Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_BLUETOOTH:
final String bluetoothAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
conn=new BluetoothConnection(getApplicationContext(),bluetoothAddress);
Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_TCP:
final String tcpServerIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
final int tcpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,ConnectionType.DEFAULT_TCP_SERVER_PORT);
conn=new AndroidTcpConnection(getApplicationContext(),tcpServerIp,tcpServerPort);
Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_UDP:
final int udpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,ConnectionType.DEFAULT_UPD_SERVER_PORT);
conn=new AndroidUdpConnection(getApplicationContext(),udpServerPort);
Log.d(TAG,""String_Node_Str"");
break;
default :
Log.e(TAG,""String_Node_Str"" + connectionType);
return;
}
mavConnections.put(connParams,conn);
}
if (conn.getConnectionStatus() == MavLinkConnection.MAVLINK_DISCONNECTED) {
conn.connect();
}
GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
}","void connectMAVConnection(ConnectionParameter connParams,String listenerTag,MavLinkConnectionListener listener){
  AndroidMavLinkConnection conn=mavConnections.get(connParams);
  if (conn == null) {
    final int connectionType=connParams.getConnectionType();
    final Bundle paramsBundle=connParams.getParamsBundle();
switch (connectionType) {
case ConnectionType.TYPE_USB:
      final int baudRate=paramsBundle.getInt(ConnectionType.EXTRA_USB_BAUD_RATE,ConnectionType.DEFAULT_USB_BAUD_RATE);
    conn=new UsbConnection(getApplicationContext(),baudRate);
  Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_BLUETOOTH:
final String bluetoothAddress=paramsBundle.getString(ConnectionType.EXTRA_BLUETOOTH_ADDRESS);
conn=new BluetoothConnection(getApplicationContext(),bluetoothAddress);
Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_TCP:
final String tcpServerIp=paramsBundle.getString(ConnectionType.EXTRA_TCP_SERVER_IP);
final int tcpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_TCP_SERVER_PORT,ConnectionType.DEFAULT_TCP_SERVER_PORT);
conn=new AndroidTcpConnection(getApplicationContext(),tcpServerIp,tcpServerPort);
Log.d(TAG,""String_Node_Str"");
break;
case ConnectionType.TYPE_UDP:
final int udpServerPort=paramsBundle.getInt(ConnectionType.EXTRA_UDP_SERVER_PORT,ConnectionType.DEFAULT_UPD_SERVER_PORT);
conn=new AndroidUdpConnection(getApplicationContext(),udpServerPort);
Log.d(TAG,""String_Node_Str"");
break;
default :
Log.e(TAG,""String_Node_Str"" + connectionType);
return;
}
mavConnections.put(connParams,conn);
}
if (conn.getConnectionStatus() == MavLinkConnection.MAVLINK_DISCONNECTED) {
conn.connect();
GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
}
conn.addMavLinkConnectionListener(listenerTag,listener);
}","The original code lacked a mechanism to add a MavLink connection listener, which is crucial for handling connection events and monitoring communication status. The fixed code introduces two new parameters - `listenerTag` and `listener` - and adds a method `addMavLinkConnectionListener()` to register connection listeners after establishing the connection. This enhancement provides better event tracking, error handling, and connection management by allowing external components to monitor and respond to MAVLink connection states dynamically."
94961,"void disconnectMAVConnection(ConnectionParameter connParams){
  final AndroidMavLinkConnection conn=mavConnections.get(connParams);
  if (conn == null)   return;
  if (conn.getConnectionStatus() != MavLinkConnection.MAVLINK_DISCONNECTED) {
    Log.d(TAG,""String_Node_Str"");
    conn.disconnect();
    GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
  }
}","void disconnectMAVConnection(ConnectionParameter connParams,String listenerTag){
  final AndroidMavLinkConnection conn=mavConnections.get(connParams);
  if (conn == null)   return;
  conn.removeMavLinkConnectionListener(listenerTag);
  if (conn.getMavLinkConnectionListenersCount() == 0 && conn.getConnectionStatus() != MavLinkConnection.MAVLINK_DISCONNECTED) {
    Log.d(TAG,""String_Node_Str"");
    conn.disconnect();
    GAUtils.sendEvent(new HitBuilders.EventBuilder().setCategory(GAUtils.Category.MAVLINK_CONNECTION).setAction(""String_Node_Str"").setLabel(connParams.toString()));
  }
}","The original code disconnected the MAVLink connection without considering potential active listeners, which could lead to premature or unintended disconnections. The fixed code adds a `listenerTag` parameter and removes specific listeners, only disconnecting when no listeners remain and the connection is not already disconnected. This approach ensures more controlled and granular connection management, preventing unnecessary disruptions to active communication channels."
94962,"@Override public void onDestroy(){
  super.onDestroy();
  for (  DPApi dpApi : dpApiStore) {
    dpApi.destroy();
  }
  dpApiStore.clear();
  for (  ConnectionParameter connParams : mavConnections.keySet()) {
    disconnectMAVConnection(connParams);
  }
  mavConnections.clear();
}","@Override public void onDestroy(){
  super.onDestroy();
  for (  DPApi dpApi : dpApiStore) {
    dpApi.destroy();
  }
  dpApiStore.clear();
  for (  AndroidMavLinkConnection conn : mavConnections.values()) {
    conn.disconnect();
    conn.removeAllMavLinkConnectionListeners();
  }
  mavConnections.clear();
}","The original code attempts to disconnect MAV connections by iterating over connection parameters, which may not properly handle the actual connection objects. The fixed code iterates over the connection values directly and calls appropriate disconnect and listener removal methods on each AndroidMavLinkConnection. This ensures a more robust and complete disconnection process, properly cleaning up resources and preventing potential memory leaks or unintended connection behaviors."
94963,"public void connectMavLink(ConnectionParameter connParams){
  getService().connectMAVConnection(connParams);
}","public void connectMavLink(ConnectionParameter connParams,String tag,MavLinkConnectionListener listener){
  getService().connectMAVConnection(connParams,tag,listener);
}","The original code lacks essential parameters for establishing a MAVLink connection, potentially leading to incomplete or failed connection attempts. The fixed code introduces additional parameters: a tag for identification and a listener for handling connection events, enabling more robust and informative connection management. These modifications provide better error handling, logging, and feedback, making the connection process more reliable and traceable."
94964,"public int getConnectionStatus(ConnectionParameter connParams){
  final AndroidMavLinkConnection mavConnection=getService().mavConnections.get(connParams);
  if (mavConnection == null) {
    return MavLinkConnection.MAVLINK_DISCONNECTED;
  }
  return mavConnection.getConnectionStatus();
}","public int getConnectionStatus(ConnectionParameter connParams,String tag){
  final AndroidMavLinkConnection mavConnection=getService().mavConnections.get(connParams);
  if (mavConnection == null || !mavConnection.hasMavLinkConnectionListener(tag)) {
    return MavLinkConnection.MAVLINK_DISCONNECTED;
  }
  return mavConnection.getConnectionStatus();
}","The original code only checks for the existence of a connection, potentially returning an incorrect status for connections without a specific listener. The fixed code adds an additional check using `hasMavLinkConnectionListener(tag)` to ensure the connection not only exists but also has a registered listener for the given tag. This improvement provides more robust and accurate connection status reporting, preventing potential false-positive connection states."
94965,"public void disconnectMavLink(ConnectionParameter connParams){
  getService().disconnectMAVConnection(connParams);
}","public void disconnectMavLink(ConnectionParameter connParams,String tag){
  getService().disconnectMAVConnection(connParams,tag);
}","The original method lacks a required tag parameter when calling disconnectMAVConnection(), which likely caused incomplete or inconsistent disconnection logging or tracking. The fixed code adds a String tag parameter to both the method signature and the service method call, ensuring proper identification and potentially enabling more detailed connection management. By including the tag, the method now supports more robust connection tracking and allows for more precise diagnostic and logging capabilities."
94966,"@Override public void openConnection(){
  if (this.connParams == null)   return;
  if (mavLinkApi.getConnectionStatus(this.connParams) == MavLinkConnection.MAVLINK_DISCONNECTED) {
    mavLinkApi.connectMavLink(this.connParams);
    mavLinkApi.addMavLinkConnectionListener(this.connParams,TAG,mConnectionListener);
  }
}","@Override public void openConnection(){
  if (this.connParams == null)   return;
  final String tag=toString();
  if (mavLinkApi.getConnectionStatus(this.connParams,tag) == MavLinkConnection.MAVLINK_DISCONNECTED) {
    mavLinkApi.connectMavLink(this.connParams,tag,mConnectionListener);
  }
}","The original code lacks a unique identifier when adding a connection listener and connecting to MavLink, which could lead to ambiguous or incorrect connection management. The fixed code introduces a dynamic tag derived from the object's toString() method and passes it consistently when checking connection status, adding a listener, and connecting, ensuring precise tracking and event handling. This approach provides better traceability, reduces potential listener registration conflicts, and improves the robustness of the connection management process."
94967,"@Override public boolean isConnected(){
  return this.connParams != null && mavLinkApi.getConnectionStatus(this.connParams) == MavLinkConnection.MAVLINK_CONNECTED;
}","@Override public boolean isConnected(){
  return this.connParams != null && mavLinkApi.getConnectionStatus(this.connParams,toString()) == MavLinkConnection.MAVLINK_CONNECTED;
}","The original code lacks a required parameter when calling getConnectionStatus(), which could lead to a compilation error or unexpected method behavior. The fixed code adds toString() as an additional parameter, likely providing a necessary string identifier for the connection status check. This modification ensures the method invocation is complete and compliant with the expected method signature, potentially preventing runtime errors and improving method reliability."
94968,"@Override public void closeConnection(){
  if (this.connParams == null)   return;
  if (mavLinkApi.getConnectionStatus(this.connParams) == MavLinkConnection.MAVLINK_CONNECTED) {
    mavLinkApi.disconnectMavLink(this.connParams);
    mavLinkApi.removeMavLinkConnectionListener(this.connParams,TAG);
    listener.notifyDisconnected();
  }
}","@Override public void closeConnection(){
  if (this.connParams == null)   return;
  final String tag=toString();
  if (mavLinkApi.getConnectionStatus(this.connParams,tag) == MavLinkConnection.MAVLINK_CONNECTED) {
    mavLinkApi.disconnectMavLink(this.connParams,tag);
    listener.notifyDisconnected();
  }
}","The original code incorrectly removes the MavLink connection listener without passing a tag, which can lead to improper listener management and potential error scenarios. The fixed code introduces a local tag derived from toString() and passes it consistently when checking connection status, disconnecting, and implicitly removing the listener. This modification ensures more robust connection handling and prevents potential null or unintended listener removal, improving the method's reliability and error handling."
94969,"@Override public void parameterFileLoaded(List<Parameter> parameters){
  loadAdapter(parameters);
}","@Override public void parameterFileLoaded(List<Parameter> parameters){
  loadAdapter(parameters,true);
}","The original code omitted a required parameter when calling the loadAdapter method, likely causing a method invocation error or incomplete initialization. The fixed code adds a second boolean parameter, presumably set to true, which might enable a specific loading mode or configuration for the adapter. By explicitly passing the additional parameter, the code ensures proper method signature matching and potentially activates crucial initialization logic during parameter file loading."
94970,"private void openParametersFromFile(){
  OpenFileDialog dialog=new OpenParameterDialog(){
    @Override public void parameterFileLoaded(    List<Parameter> parameters){
      loadAdapter(parameters);
    }
  }
;
  dialog.openDialog(getActivity());
}","private void openParametersFromFile(){
  OpenFileDialog dialog=new OpenParameterDialog(){
    @Override public void parameterFileLoaded(    List<Parameter> parameters){
      loadAdapter(parameters,true);
    }
  }
;
  dialog.openDialog(getActivity());
}","The original code's `loadAdapter()` method likely requires an additional parameter, but was being called with only the `parameters` list. The fixed code adds a second `true` argument to `loadAdapter(parameters, true)`, which completes the method's expected signature and provides necessary context for loading parameters. This modification ensures proper method invocation and prevents potential runtime errors or incomplete parameter loading."
94971,"private void loadAdapter(List<Parameter> parameters){
  if (parameters == null || parameters.isEmpty()) {
    return;
  }
  Set<Parameter> prunedParameters=new TreeSet<Parameter>(parameters);
  adapter.loadParameters(drone,prunedParameters);
  if (mParamsFilter != null && mParamsFilter.getVisibility() == View.VISIBLE) {
    mParamsFilter.setText(""String_Node_Str"");
  }
 else {
    filterInput(null);
  }
}","private void loadAdapter(List<Parameter> parameters,boolean isUpdate){
  if (parameters == null || parameters.isEmpty()) {
    return;
  }
  TreeMap<String,Parameter> prunedParameters=new TreeMap<>();
  for (  Parameter parameter : parameters) {
    prunedParameters.put(parameter.name,parameter);
  }
  if (isUpdate) {
    adapter.updateParameters(prunedParameters);
  }
 else {
    adapter.loadParameters(drone,prunedParameters);
  }
  if (mParamsFilter != null && mParamsFilter.getVisibility() == View.VISIBLE) {
    mParamsFilter.setText(""String_Node_Str"");
  }
 else {
    filterInput(null);
  }
}","The original code used a TreeSet, which might remove duplicate parameters based on a custom comparator, potentially losing important data. The fixed code uses a TreeMap to preserve all parameters by their unique names, with an added isUpdate flag to differentiate between loading and updating parameters. This approach ensures complete parameter preservation and provides more flexible parameter management for the drone adapter."
94972,"@Override public void onEndReceivingParameters(List<Parameter> parameters){
  loadAdapter(parameters);
  stopProgress();
}","@Override public void onEndReceivingParameters(List<Parameter> parameters){
  loadAdapter(parameters,false);
  stopProgress();
}","The original code lacks a necessary parameter in the `loadAdapter` method call, potentially causing method signature mismatch or incorrect method invocation. The fixed code adds a second boolean parameter (set to `false`), which likely indicates a configuration or mode flag required by the method's full signature. This correction ensures the method is called correctly, preventing potential runtime errors and maintaining the intended method behavior."
94973,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setHasOptionsMenu(true);
  final DroidPlannerApp dpApp=(DroidPlannerApp)getActivity().getApplication();
  drone=dpApp.getDrone();
  mPrefs=dpApp.getPreferences();
  if (savedInstanceState != null) {
    @SuppressWarnings(""String_Node_Str"") final ArrayList<ParamsAdapterItem> pwms=(ArrayList<ParamsAdapterItem>)savedInstanceState.getSerializable(ADAPTER_ITEMS);
    adapter=new ParamsAdapter(getActivity(),R.layout.row_params,pwms);
  }
 else {
    adapter=new ParamsAdapter(getActivity(),R.layout.row_params);
    final List<Parameter> parametersList=drone.getParameters().getParametersList();
    if (!parametersList.isEmpty()) {
      loadAdapter(parametersList);
    }
  }
  setListAdapter(adapter);
  adapter.setOnInfoListener(new ParamsAdapter.OnInfoListener(){
    @Override public void onHelp(    int position,    EditText valueView){
      showInfo(position,valueView);
    }
  }
);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setHasOptionsMenu(true);
  final DroidPlannerApp dpApp=(DroidPlannerApp)getActivity().getApplication();
  drone=dpApp.getDrone();
  mPrefs=dpApp.getPreferences();
  if (savedInstanceState != null) {
    @SuppressWarnings(""String_Node_Str"") final ArrayList<ParamsAdapterItem> pwms=(ArrayList<ParamsAdapterItem>)savedInstanceState.getSerializable(ADAPTER_ITEMS);
    adapter=new ParamsAdapter(getActivity(),R.layout.row_params,pwms);
  }
 else {
    adapter=new ParamsAdapter(getActivity(),R.layout.row_params);
    final List<Parameter> parametersList=drone.getParameters().getParametersList();
    if (!parametersList.isEmpty()) {
      loadAdapter(parametersList,false);
    }
  }
  setListAdapter(adapter);
  adapter.setOnInfoListener(new ParamsAdapter.OnInfoListener(){
    @Override public void onHelp(    int position,    EditText valueView){
      showInfo(position,valueView);
    }
  }
);
}","The original code lacked a parameter in the loadAdapter method when calling it with the parameters list. The fixed code adds a second boolean parameter (false) to the loadAdapter method call, which likely provides additional control or configuration during the adapter loading process. This modification ensures proper initialization of the adapter with the drone's parameter list, potentially preventing potential runtime errors or unexpected behavior in the parameter display mechanism."
94974,"private void addParameter(Parameter parameter){
  try {
    Parameter.checkParameterName(parameter.name);
    add(new ParamsAdapterItem(parameter,getMetadata(parameter.name)));
  }
 catch (  Exception ex) {
  }
}","private void addParameter(String name,Parameter parameter,boolean isDirty){
  try {
    Parameter.checkParameterName(name);
    ParamsAdapterItem item=new ParamsAdapterItem(parameter,getMetadata(name));
    item.setDirtyValue(parameter.getValue(),isDirty);
    add(item);
  }
 catch (  Exception ex) {
  }
}","The original code silently swallows exceptions and lacks proper parameter handling, potentially introducing unpredictable behavior during parameter addition. The fixed code introduces explicit parameter name validation, creates a ParamsAdapterItem with additional metadata, and allows setting dirty value status, providing more robust and controlled parameter management. These modifications enhance error handling, improve parameter tracking, and ensure more reliable and transparent parameter insertion process."
94975,"public void loadParameters(Drone drone,Set<Parameter> parameters){
  loadMetadataInternal(drone);
  clear();
  for (  Parameter parameter : parameters) {
    addParameter(parameter);
  }
}","public void loadParameters(Drone drone,Map<String,Parameter> parameters){
  loadMetadataInternal(drone);
  clear();
  for (  Map.Entry<String,Parameter> entry : parameters.entrySet()) {
    addParameter(entry.getKey(),entry.getValue());
  }
}","The original code assumes a Set of parameters, which lacks a key-based mechanism for associating unique identifiers with parameters. The fixed code introduces a Map<String, Parameter>, allowing direct key-value parameter storage and enabling more precise parameter management through explicit key and value entry iteration. This modification provides better parameter organization, supports efficient lookup, and allows for more robust parameter handling in the drone system."
94976,"public void setDirtyValue(String value){
  dirtyValue=(parameter.getValue().equals(value)) ? null : value;
  if (dirtyValue != null)   validation=validateValue(dirtyValue);
}","public void setDirtyValue(String value,boolean force){
  if (force) {
    dirtyValue=value;
  }
 else {
    dirtyValue=(parameter.getValue().equals(value)) ? null : value;
  }
  if (dirtyValue != null)   validation=validateValue(dirtyValue);
}","The original code lacks flexibility in setting the dirty value, only conditionally nullifying it based on parameter comparison. The fixed code introduces a 'force' parameter that allows direct assignment of the value when true, bypassing the previous conditional logic. This modification provides more control over value setting, enabling explicit overrides and improving the method's adaptability to different scenarios."
94977,"@Override public void onFocusChange(View view,boolean hasFocus){
  if (!hasFocus) {
    valueView.setText(formatter.format(getValue()));
    focusView=null;
  }
 else {
    focusView=view;
  }
}","@Override public void onFocusChange(View view,boolean hasFocus){
  if (!hasFocus) {
    focusView=null;
  }
 else {
    focusView=view;
  }
}","The original code unnecessarily sets the text of `valueView` every time focus is lost, which could trigger redundant formatting and UI updates. The fixed code removes this unnecessary setText operation, keeping the focus change logic clean and focused on managing the `focusView` reference. By eliminating the superfluous text formatting, the revised code prevents potential performance overhead and ensures a more streamlined focus change handler."
94978,"private CameraProxy getCameraProxy(){
  Camera droneCamera=droneMgr.getDrone().getCamera();
  List<Footprint> footprints=droneCamera.getFootprints();
  final int printsCount=footprints.size();
  List<FootPrint> proxyPrints=new ArrayList<FootPrint>(footprints.size());
  for (  Footprint footprint : footprints) {
    proxyPrints.add(getProxyCameraFootPrint(footprint));
  }
  return new CameraProxy(ProxyUtils.getCameraDetail(droneCamera.getCamera()),getProxyCameraFootPrint(droneCamera.getCurrentFieldOfView()),proxyPrints,getCameraDetails());
}","private CameraProxy getCameraProxy(){
  Drone drone=droneMgr.getDrone();
  Camera droneCamera=drone.getCamera();
  List<Footprint> footprints=droneCamera.getFootprints();
  final int printsCount=footprints.size();
  List<FootPrint> proxyPrints=new ArrayList<FootPrint>(footprints.size());
  for (  Footprint footprint : footprints) {
    proxyPrints.add(getProxyCameraFootPrint(footprint));
  }
  GPS droneGps=drone.getGps();
  final FootPrint currentFieldOfView=droneGps.isPositionValid() ? getProxyCameraFootPrint(droneCamera.getCurrentFieldOfView()) : new FootPrint();
  return new CameraProxy(ProxyUtils.getCameraDetail(droneCamera.getCamera()),currentFieldOfView,proxyPrints,getCameraDetails());
}","The original code directly accessed camera methods without proper null checks or handling potential GPS positioning issues. The fixed code introduces explicit drone and GPS retrieval, adding a conditional check to handle cases where GPS position might be invalid by providing a default FootPrint. By implementing robust error handling and improving method chaining, the revised code ensures more reliable camera proxy creation with graceful fallback mechanisms."
94979,"public static org.droidplanner.core.mission.MissionItem getMissionItem(Mission mission,MissionItem proxyItem){
  if (proxyItem == null)   return null;
  org.droidplanner.core.mission.MissionItem missionItem;
switch (proxyItem.getType()) {
case CAMERA_TRIGGER:
{
      CameraTrigger proxy=(CameraTrigger)proxyItem;
      org.droidplanner.core.mission.commands.CameraTrigger temp=new org.droidplanner.core.mission.commands.CameraTrigger(mission,new Length(proxy.getTriggerDistance()));
      missionItem=temp;
      break;
    }
case CHANGE_SPEED:
{
    ChangeSpeed proxy=(ChangeSpeed)proxyItem;
    org.droidplanner.core.mission.commands.ChangeSpeed temp=new org.droidplanner.core.mission.commands.ChangeSpeed(mission,new Speed(proxy.getSpeed()));
    missionItem=temp;
    break;
  }
case EPM_GRIPPER:
{
  EpmGripper proxy=(EpmGripper)proxyItem;
  org.droidplanner.core.mission.commands.EpmGripper temp=new org.droidplanner.core.mission.commands.EpmGripper(mission,proxy.isRelease());
  missionItem=temp;
  break;
}
case RETURN_TO_LAUNCH:
{
ReturnToLaunch proxy=(ReturnToLaunch)proxyItem;
ReturnToHome temp=new ReturnToHome(mission);
temp.setHeight(new Altitude(proxy.getReturnAltitude()));
missionItem=temp;
break;
}
case SET_SERVO:
{
SetServo proxy=(SetServo)proxyItem;
org.droidplanner.core.mission.commands.SetServo temp=new org.droidplanner.core.mission.commands.SetServo(mission,proxy.getChannel(),proxy.getPwm());
missionItem=temp;
break;
}
case TAKEOFF:
{
Takeoff proxy=(Takeoff)proxyItem;
org.droidplanner.core.mission.commands.Takeoff temp=new org.droidplanner.core.mission.commands.Takeoff(mission,new Altitude(proxy.getTakeoffAltitude()));
missionItem=temp;
break;
}
case CIRCLE:
{
Circle proxy=(Circle)proxyItem;
org.droidplanner.core.mission.waypoints.Circle temp=new org.droidplanner.core.mission.waypoints.Circle(mission,MathUtils.latLongAltToCoord3D(proxy.getCoordinate()));
temp.setRadius(proxy.getRadius());
temp.setTurns(proxy.getTurns());
missionItem=temp;
break;
}
case LAND:
{
Land proxy=(Land)proxyItem;
org.droidplanner.core.mission.waypoints.Land temp=new org.droidplanner.core.mission.waypoints.Land(mission,MathUtils.latLongToCoord2D(proxy.getCoordinate()));
missionItem=temp;
break;
}
case REGION_OF_INTEREST:
{
RegionOfInterest proxy=(RegionOfInterest)proxyItem;
org.droidplanner.core.mission.waypoints.RegionOfInterest temp=new org.droidplanner.core.mission.waypoints.RegionOfInterest(mission,MathUtils.latLongAltToCoord3D(proxy.getCoordinate()));
missionItem=temp;
break;
}
case SPLINE_WAYPOINT:
{
SplineWaypoint proxy=(SplineWaypoint)proxyItem;
org.droidplanner.core.mission.waypoints.SplineWaypoint temp=new org.droidplanner.core.mission.waypoints.SplineWaypoint(mission,MathUtils.latLongAltToCoord3D(proxy.getCoordinate()));
temp.setDelay(proxy.getDelay());
missionItem=temp;
break;
}
case STRUCTURE_SCANNER:
{
StructureScanner proxy=(StructureScanner)proxyItem;
org.droidplanner.core.mission.waypoints.StructureScanner temp=new org.droidplanner.core.mission.waypoints.StructureScanner(mission,MathUtils.latLongAltToCoord3D(proxy.getCoordinate()));
temp.setRadius((int)proxy.getRadius());
temp.setNumberOfSteps(proxy.getStepsCount());
temp.setAltitudeStep((int)proxy.getHeightStep());
temp.enableCrossHatch(proxy.isCrossHatch());
CameraDetail camDetail=proxy.getSurveyDetail().getCameraDetail();
if (camDetail != null) temp.setCamera(getCameraInfo(camDetail));
missionItem=temp;
break;
}
case WAYPOINT:
{
Waypoint proxy=(Waypoint)proxyItem;
org.droidplanner.core.mission.waypoints.Waypoint temp=new org.droidplanner.core.mission.waypoints.Waypoint(mission,MathUtils.latLongAltToCoord3D(proxy.getCoordinate()));
temp.setAcceptanceRadius(proxy.getAcceptanceRadius());
temp.setDelay(proxy.getDelay());
temp.setOrbitCCW(proxy.isOrbitCCW());
temp.setOrbitalRadius(proxy.getOrbitalRadius());
temp.setYawAngle(proxy.getYawAngle());
missionItem=temp;
break;
}
case SURVEY:
{
Survey proxy=(Survey)proxyItem;
SurveyDetail surveyDetail=proxy.getSurveyDetail();
List<Coord2D> polygonPoints=MathUtils.latLongToCoord2D(proxy.getPolygonPoints());
org.droidplanner.core.mission.survey.Survey temp=new org.droidplanner.core.mission.survey.Survey(mission,polygonPoints);
if (surveyDetail != null) {
temp.update(surveyDetail.getAngle(),new Altitude(surveyDetail.getAltitude()),surveyDetail.getOverlap(),surveyDetail.getSidelap());
CameraDetail cameraDetail=surveyDetail.getCameraDetail();
if (cameraDetail != null) temp.setCameraInfo(getCameraInfo(cameraDetail));
}
try {
temp.build();
}
 catch (Exception e) {
Log.e(TAG,e.getMessage(),e);
}
missionItem=temp;
break;
}
case YAW_CONDITION:
{
YawCondition proxy=(YawCondition)proxyItem;
ConditionYaw temp=new ConditionYaw(mission,proxy.getAngle(),proxy.isRelative());
temp.setAngularSpeed(proxy.getAngularSpeed());
missionItem=temp;
break;
}
default :
missionItem=null;
break;
}
return missionItem;
}","public static org.droidplanner.core.mission.MissionItem getMissionItem(Mission mission,MissionItem proxyItem){
  if (proxyItem == null)   return null;
  org.droidplanner.core.mission.MissionItem missionItem;
switch (proxyItem.getType()) {
case CAMERA_TRIGGER:
{
      CameraTrigger proxy=(CameraTrigger)proxyItem;
      org.droidplanner.core.mission.commands.CameraTrigger temp=new org.droidplanner.core.mission.commands.CameraTrigger(mission,new Length(proxy.getTriggerDistance()));
      missionItem=temp;
      break;
    }
case CHANGE_SPEED:
{
    ChangeSpeed proxy=(ChangeSpeed)proxyItem;
    org.droidplanner.core.mission.commands.ChangeSpeed temp=new org.droidplanner.core.mission.commands.ChangeSpeed(mission,new Speed(proxy.getSpeed()));
    missionItem=temp;
    break;
  }
case EPM_GRIPPER:
{
  EpmGripper proxy=(EpmGripper)proxyItem;
  org.droidplanner.core.mission.commands.EpmGripper temp=new org.droidplanner.core.mission.commands.EpmGripper(mission,proxy.isRelease());
  missionItem=temp;
  break;
}
case RETURN_TO_LAUNCH:
{
ReturnToLaunch proxy=(ReturnToLaunch)proxyItem;
ReturnToHome temp=new ReturnToHome(mission);
temp.setHeight(new Altitude(proxy.getReturnAltitude()));
missionItem=temp;
break;
}
case SET_SERVO:
{
SetServo proxy=(SetServo)proxyItem;
org.droidplanner.core.mission.commands.SetServo temp=new org.droidplanner.core.mission.commands.SetServo(mission,proxy.getChannel(),proxy.getPwm());
missionItem=temp;
break;
}
case TAKEOFF:
{
Takeoff proxy=(Takeoff)proxyItem;
org.droidplanner.core.mission.commands.Takeoff temp=new org.droidplanner.core.mission.commands.Takeoff(mission,new Altitude(proxy.getTakeoffAltitude()));
missionItem=temp;
break;
}
case CIRCLE:
{
Circle proxy=(Circle)proxyItem;
org.droidplanner.core.mission.waypoints.Circle temp=new org.droidplanner.core.mission.waypoints.Circle(mission,MathUtils.latLongAltToCoord3D(proxy.getCoordinate()));
temp.setRadius(proxy.getRadius());
temp.setTurns(proxy.getTurns());
missionItem=temp;
break;
}
case LAND:
{
Land proxy=(Land)proxyItem;
org.droidplanner.core.mission.waypoints.Land temp=new org.droidplanner.core.mission.waypoints.Land(mission,MathUtils.latLongToCoord2D(proxy.getCoordinate()));
missionItem=temp;
break;
}
case REGION_OF_INTEREST:
{
RegionOfInterest proxy=(RegionOfInterest)proxyItem;
org.droidplanner.core.mission.waypoints.RegionOfInterest temp=new org.droidplanner.core.mission.waypoints.RegionOfInterest(mission,MathUtils.latLongAltToCoord3D(proxy.getCoordinate()));
missionItem=temp;
break;
}
case SPLINE_WAYPOINT:
{
SplineWaypoint proxy=(SplineWaypoint)proxyItem;
org.droidplanner.core.mission.waypoints.SplineWaypoint temp=new org.droidplanner.core.mission.waypoints.SplineWaypoint(mission,MathUtils.latLongAltToCoord3D(proxy.getCoordinate()));
temp.setDelay(proxy.getDelay());
missionItem=temp;
break;
}
case STRUCTURE_SCANNER:
{
StructureScanner proxy=(StructureScanner)proxyItem;
org.droidplanner.core.mission.waypoints.StructureScanner temp=new org.droidplanner.core.mission.waypoints.StructureScanner(mission,MathUtils.latLongAltToCoord3D(proxy.getCoordinate()));
temp.setRadius((int)proxy.getRadius());
temp.setNumberOfSteps(proxy.getStepsCount());
temp.setAltitudeStep((int)proxy.getHeightStep());
temp.enableCrossHatch(proxy.isCrossHatch());
CameraDetail camDetail=proxy.getSurveyDetail().getCameraDetail();
if (camDetail != null) temp.setCamera(getCameraInfo(camDetail));
missionItem=temp;
break;
}
case WAYPOINT:
{
Waypoint proxy=(Waypoint)proxyItem;
org.droidplanner.core.mission.waypoints.Waypoint temp=new org.droidplanner.core.mission.waypoints.Waypoint(mission,MathUtils.latLongAltToCoord3D(proxy.getCoordinate()));
temp.setAcceptanceRadius(proxy.getAcceptanceRadius());
temp.setDelay(proxy.getDelay());
temp.setOrbitCCW(proxy.isOrbitCCW());
temp.setOrbitalRadius(proxy.getOrbitalRadius());
temp.setYawAngle(proxy.getYawAngle());
missionItem=temp;
break;
}
case SURVEY:
{
Survey proxy=(Survey)proxyItem;
SurveyDetail surveyDetail=proxy.getSurveyDetail();
List<Coord2D> polygonPoints=MathUtils.latLongToCoord2D(proxy.getPolygonPoints());
org.droidplanner.core.mission.survey.Survey temp=new org.droidplanner.core.mission.survey.Survey(mission,polygonPoints);
if (surveyDetail != null) {
CameraDetail cameraDetail=surveyDetail.getCameraDetail();
if (cameraDetail != null) temp.setCameraInfo(getCameraInfo(cameraDetail));
temp.update(surveyDetail.getAngle(),new Altitude(surveyDetail.getAltitude()),surveyDetail.getOverlap(),surveyDetail.getSidelap());
}
try {
temp.build();
}
 catch (Exception e) {
Log.e(TAG,e.getMessage(),e);
}
missionItem=temp;
break;
}
case YAW_CONDITION:
{
YawCondition proxy=(YawCondition)proxyItem;
ConditionYaw temp=new ConditionYaw(mission,proxy.getAngle(),proxy.isRelative());
temp.setAngularSpeed(proxy.getAngularSpeed());
missionItem=temp;
break;
}
default :
missionItem=null;
break;
}
return missionItem;
}","In the Survey case, the original code set camera info after update(), which might cause conflicts or incomplete configuration. The fixed code reorders method calls, setting camera info before update() to ensure proper initialization and prevent potential data inconsistencies. This change ensures that camera details are properly configured before applying survey parameters, leading to more reliable mission item creation."
94980,"public void setCameraInfo(CameraInfo info){
  this.camera=info;
  tryToLoadOverlapFromCamera();
}","public void setCameraInfo(CameraInfo info){
  this.camera=info;
  this.footprint=new Footprint(this.camera,this.altitude);
  tryToLoadOverlapFromCamera();
}","The original code failed to initialize the `footprint` object when setting camera information, potentially causing null pointer exceptions or incorrect spatial calculations. The fixed code adds a crucial line to create a new `Footprint` instance using the camera and altitude, ensuring proper initialization before further processing. By explicitly constructing the footprint during camera info setup, the code now guarantees a valid spatial representation is ready for subsequent operations."
94981,"@Override public void onFocusChange(View view,boolean hasFocus){
  if (!hasFocus) {
    valueView.setText(formatter.format(getValue()));
    focusView=null;
  }
 else {
    focusView=view;
  }
}","@Override public void onFocusChange(View view,boolean hasFocus){
  if (!hasFocus) {
    focusView=null;
  }
 else {
    focusView=view;
  }
}","The original code unnecessarily calls `valueView.setText()` every time focus is lost, potentially causing redundant UI updates and performance overhead. The fixed code removes this unnecessary setText call, ensuring that text updates occur only when truly needed. By simplifying the focus change logic, the new implementation reduces potential rendering inefficiencies and maintains cleaner, more focused event handling."
94982,"@Override protected AlertDialog.Builder buildDialog(Bundle savedInstanceState){
  final Bundle arguments=getArguments();
  final AlertDialog.Builder builder=new AlertDialog.Builder(getActivity()).setTitle(arguments.getString(EXTRA_TITLE)).setView(generateContentView(savedInstanceState)).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      CharSequence input=mEditText.getText();
      if (input == null)       input=mEditText.getHint();
      mListener.onOk(input);
    }
  }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      mListener.onCancel();
    }
  }
);
  return builder;
}","@Override protected AlertDialog.Builder buildDialog(Bundle savedInstanceState){
  final Bundle arguments=getArguments();
  final AlertDialog.Builder builder=new AlertDialog.Builder(getActivity()).setTitle(arguments.getString(EXTRA_TITLE)).setView(generateContentView(savedInstanceState)).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      CharSequence input=mEditText.getText();
      if (TextUtils.isEmpty(input))       input=mEditText.getHint();
      mListener.onOk(input);
    }
  }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      mListener.onCancel();
    }
  }
);
  return builder;
}","The original code incorrectly checks for null input using `input == null`, which fails to handle empty strings or whitespace-only input. The fixed code replaces this check with `TextUtils.isEmpty(input)`, which comprehensively identifies empty or null text. This improvement ensures more robust input validation, providing a more reliable method to determine whether the user has entered meaningful text before proceeding with the dialog's OK action."
94983,"@Override protected AlertDialog.Builder buildDialog(Bundle savedInstanceState){
  final Bundle arguments=getArguments();
  final AlertDialog.Builder builder=new AlertDialog.Builder(getActivity()).setTitle(arguments.getString(EXTRA_TITLE)).setView(generateContentView(savedInstanceState)).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      CharSequence input=mEditText.getText();
      if (input == null)       input=mEditText.getHint();
      mListener.onOk(input);
    }
  }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      mListener.onCancel();
    }
  }
);
  return builder;
}","@Override protected AlertDialog.Builder buildDialog(Bundle savedInstanceState){
  final Bundle arguments=getArguments();
  final AlertDialog.Builder builder=new AlertDialog.Builder(getActivity()).setTitle(arguments.getString(EXTRA_TITLE)).setView(generateContentView(savedInstanceState)).setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      CharSequence input=mEditText.getText();
      if (TextUtils.isEmpty(input))       input=mEditText.getHint();
      mListener.onOk(input);
    }
  }
).setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      mListener.onCancel();
    }
  }
);
  return builder;
}","The buggy code checks for null input using `input == null`, which fails to handle empty strings or whitespace-only inputs. The fixed code replaces this check with `TextUtils.isEmpty(input)`, which correctly evaluates both null and empty string cases. This modification ensures more robust input validation, preventing potential null pointer exceptions and providing a more reliable method of determining whether the input is meaningful."
94984,"@Override public void enableLocationUpdates(){
  mSpeedReadings=0;
  mTotalSpeed=0f;
  gApiMgr.addTask(requestLocationUpdate);
}","@Override public void enableLocationUpdates(){
  mSpeedReadings=0;
  mTotalSpeed=0f;
  try {
    gApiMgr.addTask(requestLocationUpdate);
  }
 catch (  IllegalStateException e) {
    Log.e(TAG,""String_Node_Str"");
  }
}","The original code lacks error handling when adding a location update task, which could cause the application to crash if the Google API manager is in an illegal state. The fixed code introduces a try-catch block to handle potential IllegalStateException, logging the error instead of abruptly terminating the application. By gracefully catching and logging the exception, the code prevents unexpected app crashes and provides a mechanism for diagnosing potential issues with location update requests."
94985,"@Override public void disableLocationUpdates(){
  gApiMgr.addTask(removeLocationUpdate);
}","@Override public void disableLocationUpdates(){
  try {
    gApiMgr.addTask(removeLocationUpdate);
  }
 catch (  IllegalStateException e) {
    Log.e(TAG,""String_Node_Str"");
  }
}","The original code lacks error handling for potential exceptions when adding a task to the Google API manager, which could lead to unhandled runtime crashes. The fixed code introduces a try-catch block to specifically catch IllegalStateException, preventing app termination and logging the error for diagnostic purposes. By gracefully handling potential exceptions, the revised implementation ensures more robust and stable location update management during API interactions."
94986,"/** 
 * Activates the google api client manager.
 */
public void start(){
  initializeDriverThread();
  initializeBgHandler();
}","/** 
 * Activates the google api client manager.
 */
public void start(){
  if (isGooglePlayServicesValid()) {
    initializeDriverThread();
    initializeBgHandler();
  }
 else {
    Log.e(TAG,""String_Node_Str"");
  }
}","The original code lacks a crucial validation check before initializing critical components, potentially causing runtime errors if Google Play Services are not available. The fixed code adds an `isGooglePlayServicesValid()` check before initialization, ensuring that driver thread and background handler setup only occur when the services are properly supported. This defensive programming approach prevents potential crashes and provides explicit error logging, making the code more robust and resilient to potential service unavailability."
94987,"/** 
 * Release the resources used by this manager. After calling this method, start() needs to be called again to use that manager again.
 */
public void stop(){
  destroyBgHandler();
  destroyDriverThread();
  mTaskQueue.clear();
  if (mGoogleApiClient.isConnected() || mGoogleApiClient.isConnecting()) {
    mGoogleApiClient.disconnect();
  }
}","/** 
 * Release the resources used by this manager. After calling this method, start() needs to be called again to use that manager again.
 */
public void stop(){
  if (isGooglePlayServicesValid()) {
    destroyBgHandler();
    destroyDriverThread();
    mTaskQueue.clear();
    if (mGoogleApiClient.isConnected() || mGoogleApiClient.isConnecting()) {
      mGoogleApiClient.disconnect();
    }
  }
 else {
    Log.e(TAG,""String_Node_Str"");
  }
}","The original code lacks a check for Google Play Services validity before performing resource cleanup, which could lead to potential null pointer exceptions or unexpected behavior. The fixed code adds an `isGooglePlayServicesValid()` check before executing cleanup operations, ensuring that critical resources are only accessed when the services are properly available. This defensive programming approach prevents potential runtime errors and provides more robust error handling by logging an error when services are invalid."
94988,"@Override public List<Coord2D> getPathPoints(){
  if (mMissionItems.isEmpty()) {
    return Collections.emptyList();
  }
  final List<Pair<Boolean,List<MissionItemProxy>>> bucketsList=new ArrayList<Pair<Boolean,List<MissionItemProxy>>>();
  boolean isSpline=false;
  List<MissionItemProxy> currentBucket=new ArrayList<MissionItemProxy>();
  for (  MissionItemProxy missionItemProxy : mMissionItems) {
    if (missionItemProxy.getMissionItem() instanceof SplineWaypoint) {
      if (!isSpline) {
        if (!currentBucket.isEmpty()) {
          final MissionItemProxy lastItem=currentBucket.get(currentBucket.size() - 1);
          bucketsList.add(new Pair<Boolean,List<MissionItemProxy>>(Boolean.FALSE,currentBucket));
          currentBucket=new ArrayList<MissionItemProxy>();
          currentBucket.add(lastItem);
        }
        isSpline=true;
      }
      currentBucket.add(missionItemProxy);
    }
 else {
      if (isSpline) {
        if (!currentBucket.isEmpty()) {
          currentBucket.add(missionItemProxy);
          bucketsList.add(new Pair<Boolean,List<MissionItemProxy>>(Boolean.TRUE,currentBucket));
          currentBucket=new ArrayList<MissionItemProxy>();
        }
        isSpline=false;
      }
      currentBucket.add(missionItemProxy);
    }
  }
  bucketsList.add(new Pair<Boolean,List<MissionItemProxy>>(isSpline,currentBucket));
  final List<Coord2D> pathPoints=new ArrayList<Coord2D>();
  Coord2D lastPoint=null;
  for (  Pair<Boolean,List<MissionItemProxy>> bucketEntry : bucketsList) {
    final List<MissionItemProxy> bucket=bucketEntry.second;
    if (bucketEntry.first) {
      final List<Coord2D> splinePoints=new ArrayList<Coord2D>();
      for (      MissionItemProxy missionItemProxy : bucket) {
        splinePoints.addAll(missionItemProxy.getPath(lastPoint));
        if (!splinePoints.isEmpty()) {
          lastPoint=splinePoints.get(splinePoints.size() - 1);
        }
      }
      pathPoints.addAll(SplinePath.process(splinePoints));
    }
 else {
      for (      MissionItemProxy missionItemProxy : bucket) {
        pathPoints.addAll(missionItemProxy.getPath(lastPoint));
        if (!pathPoints.isEmpty()) {
          lastPoint=pathPoints.get(pathPoints.size() - 1);
        }
      }
    }
  }
  return pathPoints;
}","@Override public List<Coord2D> getPathPoints(){
  if (mMissionItems.isEmpty()) {
    return Collections.emptyList();
  }
  final List<Pair<Boolean,List<MissionItemProxy>>> bucketsList=new ArrayList<Pair<Boolean,List<MissionItemProxy>>>();
  boolean isSpline=false;
  List<MissionItemProxy> currentBucket=new ArrayList<MissionItemProxy>();
  for (  MissionItemProxy missionItemProxy : mMissionItems) {
    MissionItem missionItem=missionItemProxy.getMissionItem();
    if (missionItem instanceof MissionCMD) {
      continue;
    }
    if (missionItemProxy.getMissionItem() instanceof SplineWaypoint) {
      if (!isSpline) {
        if (!currentBucket.isEmpty()) {
          final MissionItemProxy lastItem=currentBucket.get(currentBucket.size() - 1);
          bucketsList.add(new Pair<Boolean,List<MissionItemProxy>>(Boolean.FALSE,currentBucket));
          currentBucket=new ArrayList<MissionItemProxy>();
          currentBucket.add(lastItem);
        }
        isSpline=true;
      }
      currentBucket.add(missionItemProxy);
    }
 else {
      if (isSpline) {
        if (!currentBucket.isEmpty()) {
          currentBucket.add(missionItemProxy);
          bucketsList.add(new Pair<Boolean,List<MissionItemProxy>>(Boolean.TRUE,currentBucket));
          currentBucket=new ArrayList<MissionItemProxy>();
        }
        isSpline=false;
      }
      currentBucket.add(missionItemProxy);
    }
  }
  bucketsList.add(new Pair<Boolean,List<MissionItemProxy>>(isSpline,currentBucket));
  final List<Coord2D> pathPoints=new ArrayList<Coord2D>();
  Coord2D lastPoint=null;
  for (  Pair<Boolean,List<MissionItemProxy>> bucketEntry : bucketsList) {
    final List<MissionItemProxy> bucket=bucketEntry.second;
    if (bucketEntry.first) {
      final List<Coord2D> splinePoints=new ArrayList<Coord2D>();
      for (      MissionItemProxy missionItemProxy : bucket) {
        splinePoints.addAll(missionItemProxy.getPath(lastPoint));
        if (!splinePoints.isEmpty()) {
          lastPoint=splinePoints.get(splinePoints.size() - 1);
        }
      }
      pathPoints.addAll(SplinePath.process(splinePoints));
    }
 else {
      for (      MissionItemProxy missionItemProxy : bucket) {
        pathPoints.addAll(missionItemProxy.getPath(lastPoint));
        if (!pathPoints.isEmpty()) {
          lastPoint=pathPoints.get(pathPoints.size() - 1);
        }
      }
    }
  }
  return pathPoints;
}","The original code did not handle Mission Command (MissionCMD) items, potentially including unwanted mission items in path calculations. The fixed code adds a check to skip MissionCMD items before processing, ensuring only valid waypoint and spline items are considered for path generation. This modification improves the method's accuracy by filtering out irrelevant mission commands and maintaining the intended path calculation logic."
94989,"@Override public View getView(int position,View convertView,ViewGroup parent){
  final DroneManager droneMgr=getItem(position);
  View view;
  if (convertView == null)   view=inflater.inflate(R.layout.list_item_drone_info,parent,false);
 else   view=convertView;
  ViewHolder viewHolder=(ViewHolder)view.getTag();
  if (viewHolder == null) {
    viewHolder=new ViewHolder();
    viewHolder.listenersCount=(TextView)view.findViewById(R.id.drone_info_listeners_count);
    viewHolder.infoPanel=(TextView)view.findViewById(R.id.drone_info_connection_params);
    view.setTag(viewHolder);
  }
  viewHolder.listenersCount.setText(""String_Node_Str"" + droneMgr.getListenersCount());
  viewHolder.infoPanel.setText(""String_Node_Str"" + droneMgr.getConnectionParameter().toString());
  return view;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  final DroneManager droneMgr=getItem(position);
  View view;
  if (convertView == null)   view=inflater.inflate(R.layout.list_item_drone_info,parent,false);
 else   view=convertView;
  ViewHolder viewHolder=(ViewHolder)view.getTag();
  if (viewHolder == null) {
    viewHolder=new ViewHolder();
    viewHolder.listenersCount=(TextView)view.findViewById(R.id.drone_info_listeners_count);
    viewHolder.infoPanel=(TextView)view.findViewById(R.id.drone_info_connection_params);
    view.setTag(viewHolder);
  }
  viewHolder.listenersCount.setText(""String_Node_Str"" + droneMgr.getListenersCount());
  viewHolder.infoPanel.setText(""String_Node_Str"" + droneMgr.getConnectionParameter());
  return view;
}","The original code incorrectly called `.toString()` on `droneMgr.getConnectionParameter()`, which might lead to unnecessary method invocation or potential null pointer exceptions. In the fixed code, the `.toString()` method call is removed, allowing the `setText()` method to handle string conversion implicitly or use the default string representation. This modification simplifies the code, reduces potential runtime errors, and ensures more robust handling of connection parameter display in the list view."
94990,"@Override public void disconnect() throws RemoteException {
  if (droneMgr != null) {
    try {
      droneMgr.disconnect();
    }
 catch (    ConnectionException e) {
      try {
        getCallback().onConnectionFailed(new ConnectionResult(0,e.getMessage()));
      }
 catch (      DeadObjectException d) {
        handleDeadObjectException(d);
      }
    }
    getService().releaseDroneManager(droneMgr,this);
    droneMgr=null;
  }
  apiCallback=null;
}","@Override public void disconnect() throws RemoteException {
  if (droneMgr != null) {
    try {
      droneMgr.disconnect();
    }
 catch (    ConnectionException e) {
      try {
        getCallback().onConnectionFailed(new ConnectionResult(0,e.getMessage()));
      }
 catch (      DeadObjectException d) {
        Log.e(TAG,e.getMessage(),e);
      }
    }
    getService().releaseDroneManager(droneMgr,this);
    droneMgr=null;
  }
  apiCallback=null;
}","The original code improperly handles the DeadObjectException by calling handleDeadObjectException(), which might not be defined or could mask underlying connectivity issues. The fixed code replaces the method with Log.e(), which properly logs the error with full stack trace and maintains error visibility. This approach ensures robust error handling, provides diagnostic information, and prevents potential silent failures during drone manager disconnection."
94991,"private void handleDeadObjectException(DeadObjectException e){
  Log.e(TAG,e.getMessage(),e);
}","private void handleDeadObjectException(DeadObjectException e){
  Log.e(TAG,e.getMessage(),e);
  try {
    disconnect();
  }
 catch (  RemoteException e1) {
    Log.e(TAG,e1.getMessage(),e1);
  }
}","The original code only logs the DeadObjectException without taking any corrective action, potentially leaving the system in an unhandled error state. The fixed code adds a disconnect() method call within a try-catch block to gracefully handle the exception and prevent potential resource leaks or connection issues. By proactively attempting to disconnect and logging any subsequent RemoteException, the fixed code ensures more robust error handling and system stability."
94992,"public HeartBeat(Drone myDrone,Handler handler){
  super(myDrone);
  this.watchdog=handler;
  myDrone.addDroneListener(this);
}","public HeartBeat(Drone myDrone,Handler handler){
  super(myDrone);
  this.watchdog=handler;
  this.gcsHeartbeat=new GCSHeartbeat(myDrone,1);
  myDrone.addDroneListener(this);
}","The original code was incomplete, missing the initialization of a critical `gcsHeartbeat` component that is essential for drone monitoring and communication. The fixed code introduces `this.gcsHeartbeat=new GCSHeartbeat(myDrone,1)`, which properly creates a Ground Control Station heartbeat instance with the drone and a default frequency parameter. By adding this initialization, the code ensures proper heartbeat tracking and communication, enhancing the drone's operational reliability and monitoring capabilities."
94993,"@Override public void onDroneEvent(DroneEventsType event,Drone drone){
switch (event) {
case CALIBRATION_IMU:
    heartbeatState=HeartbeatState.IMU_CALIBRATION;
  restartWatchdog(HEARTBEAT_IMU_CALIBRATION_TIMEOUT);
break;
case CONNECTED:
notifyConnected();
break;
case DISCONNECTED:
notifyDisconnected();
break;
default :
break;
}
}","@Override public void onDroneEvent(DroneEventsType event,Drone drone){
switch (event) {
case CALIBRATION_IMU:
    heartbeatState=HeartbeatState.IMU_CALIBRATION;
  restartWatchdog(HEARTBEAT_IMU_CALIBRATION_TIMEOUT);
break;
case CONNECTED:
gcsHeartbeat.setActive(true);
notifyConnected();
break;
case DISCONNECTED:
gcsHeartbeat.setActive(false);
notifyDisconnected();
break;
default :
break;
}
}","The original code lacked proper heartbeat management when the drone connects or disconnects, potentially leading to incorrect system state tracking. In the fixed code, `gcsHeartbeat.setActive(true)` and `gcsHeartbeat.setActive(false)` were added to explicitly update the ground control station's heartbeat status during connection and disconnection events. These changes ensure accurate tracking of the drone's communication state, improving system reliability and monitoring capabilities."
94994,"@Override public Parameters getParameters() throws RemoteException {
  final Drone drone=getDroneMgr().getDrone();
  final Map<String,com.ox3dr.services.android.lib.drone.property.Parameter> proxyParams=new HashMap<String,com.ox3dr.services.android.lib.drone.property.Parameter>();
  List<Parameter> droneParameters=drone.getParameters().getParametersList();
  if (!droneParameters.isEmpty()) {
    for (    Parameter param : droneParameters) {
      proxyParams.put(param.name,new com.ox3dr.services.android.lib.drone.property.Parameter(param.name,param.value,param.type));
    }
    try {
      final VehicleProfile profile=drone.getVehicleProfile();
      if (profile != null) {
        String metadataType=profile.getParameterMetadataType();
        if (metadataType != null) {
          ParameterMetadataLoader.load(getService().getApplicationContext(),metadataType,proxyParams);
        }
      }
    }
 catch (    IOException e) {
      Log.e(TAG,e.getMessage(),e);
    }
catch (    XmlPullParserException e) {
      Log.e(TAG,e.getMessage(),e);
    }
  }
  return new Parameters(new ArrayList<com.ox3dr.services.android.lib.drone.property.Parameter>(proxyParams.values()));
}","@Override public Parameters getParameters() throws RemoteException {
  final Drone drone=getDroneMgr().getDrone();
  final Map<String,com.ox3dr.services.android.lib.drone.property.Parameter> proxyParams=new HashMap<String,com.ox3dr.services.android.lib.drone.property.Parameter>();
  List<Parameter> droneParameters=drone.getParameters().getParametersList();
  if (!droneParameters.isEmpty()) {
    for (    Parameter param : droneParameters) {
      if (param.name != null) {
        proxyParams.put(param.name,new com.ox3dr.services.android.lib.drone.property.Parameter(param.name,param.value,param.type));
      }
    }
    try {
      final VehicleProfile profile=drone.getVehicleProfile();
      if (profile != null) {
        String metadataType=profile.getParameterMetadataType();
        if (metadataType != null) {
          ParameterMetadataLoader.load(getService().getApplicationContext(),metadataType,proxyParams);
        }
      }
    }
 catch (    IOException e) {
      Log.e(TAG,e.getMessage(),e);
    }
catch (    XmlPullParserException e) {
      Log.e(TAG,e.getMessage(),e);
    }
  }
  return new Parameters(new ArrayList<com.ox3dr.services.android.lib.drone.property.Parameter>(proxyParams.values()));
}","The original code did not handle potential null parameter names, which could cause a NullPointerException when attempting to add parameters to the map. In the fixed code, a null check `if (param.name != null)` was added before inserting parameters into `proxyParams`, ensuring only valid parameters are processed. This modification prevents potential runtime errors and improves the method's robustness by gracefully skipping parameters with null names."
94995,"@Override public State getState() throws RemoteException {
  final Drone drone=getDroneMgr().getDrone();
  org.droidplanner.core.drone.variables.State droneState=drone.getState();
  ApmModes droneMode=droneState.getMode();
  return new State(getVehicleMode(droneMode),droneState.isArmed(),droneState.isFlying(),droneState.getWarning(),drone.getMavlinkVersion(),drone.getCalibrationSetup().getMessage());
}","@Override public State getState() throws RemoteException {
  final Drone drone=getDroneMgr().getDrone();
  org.droidplanner.core.drone.variables.State droneState=drone.getState();
  ApmModes droneMode=droneState.getMode();
  Calibration calibration=drone.getCalibrationSetup();
  String calibrationMessage=calibration.isCalibrating() ? calibration.getMessage() : null;
  return new State(getVehicleMode(droneMode),droneState.isArmed(),droneState.isFlying(),droneState.getWarning(),drone.getMavlinkVersion(),calibrationMessage);
}","The original code might throw a null pointer exception when calling `drone.getCalibrationSetup().getMessage()` if no calibration is in progress. The fixed code introduces a null check by first retrieving the Calibration object and then conditionally returning its message only when calibration is actively happening, preventing potential runtime errors. This approach ensures safer method execution and provides more robust state retrieval for drone operations."
94996,"@Override public void onDroneEvent(DroneEventsType event,Drone drone){
switch (event) {
case MODE:
    if (isGuidedMode(myDrone)) {
      initialize();
    }
 else {
      disable();
    }
  break;
case DISCONNECTED:
case HEARTBEAT_TIMEOUT:
disable();
default :
break;
}
}","@Override public void onDroneEvent(DroneEventsType event,Drone drone){
switch (event) {
case HEARTBEAT_FIRST:
case HEARTBEAT_RESTORED:
case MODE:
    if (isGuidedMode(myDrone)) {
      initialize();
    }
 else {
      disable();
    }
  break;
case DISCONNECTED:
case HEARTBEAT_TIMEOUT:
disable();
default :
break;
}
}","The original code only handles the MODE event, potentially missing critical drone connection scenarios like initial connection or connection restoration. The fixed code adds HEARTBEAT_FIRST and HEARTBEAT_RESTORED cases, ensuring proper initialization and mode checking during various connection states. These additional event cases make the drone event handling more robust and comprehensive, preventing potential state management issues during different connection scenarios."
94997,"public Radio(Drone myDrone){
  super(myDrone);
}","public Radio(Drone myDrone){
  super(myDrone);
  myDrone.addDroneListener(this);
}","The original code lacks a crucial listener registration, preventing the Radio from receiving updates from the Drone. The fixed code adds `myDrone.addDroneListener(this)`, which explicitly registers the Radio instance as a listener to the Drone's event notifications. This improvement ensures that the Radio can now properly receive and respond to drone-related events, establishing a complete communication mechanism between the Drone and Radio components."
94998,"@Override public FootPrint[] getCameraFootPrints() throws RemoteException {
  List<Footprint> footprints=getDroneMgr().getDrone().getCameraFootprints().getFootprints();
  final int printsCount=footprints.size();
  FootPrint[] proxyPrints=new FootPrint[printsCount];
  for (int i=0; i < printsCount; i++) {
    proxyPrints[i]=getProxyCameraFootPrint(footprints.get(i));
  }
  return proxyPrints;
}","@Override public FootPrint[] getCameraFootPrints() throws RemoteException {
  List<Footprint> footprints=getDroneMgr().getDrone().getCamera().getFootprints();
  final int printsCount=footprints.size();
  FootPrint[] proxyPrints=new FootPrint[printsCount];
  for (int i=0; i < printsCount; i++) {
    proxyPrints[i]=getProxyCameraFootPrint(footprints.get(i));
  }
  return proxyPrints;
}","The original code incorrectly used `getCameraFootprints()` instead of `getCamera().getFootprints()`, which likely resulted in a method call error or null pointer exception. The fixed code correctly retrieves camera footprints by first accessing the camera object and then calling its `getFootprints()` method. This correction ensures proper access to the drone's camera footprints and prevents potential runtime errors."
94999,"private static FootPrint getProxyCameraFootPrint(Footprint footprint){
  if (footprint == null)   return null;
  return new FootPrint(MathUtils.coord2DToLatLong(footprint.getCenter()),MathUtils.coord2DToLatLong(footprint.getVertex()));
}","private static FootPrint getProxyCameraFootPrint(Footprint footprint){
  if (footprint == null)   return null;
  return new FootPrint(footprint.getGSD(),MathUtils.coord2DToLatLong(footprint.getVertexInGlobalFrame()));
}","The original code incorrectly uses `footprint.getCenter()` and `footprint.getVertex()`, which likely do not provide the correct coordinate transformation. The fixed code uses `footprint.getGSD()` for ground resolution and `footprint.getVertexInGlobalFrame()` to obtain accurate global coordinate vertices. This modification ensures precise geospatial representation by correctly mapping the footprint's vertices to global coordinates with the appropriate ground sampling distance."
95000,"@Override public FootPrint getLastCameraFootPrint() throws RemoteException {
  Footprint lastFootprint=getDroneMgr().getDrone().getCameraFootprints().getLastFootprint();
  return getProxyCameraFootPrint(lastFootprint);
}","@Override public FootPrint getLastCameraFootPrint() throws RemoteException {
  Footprint lastFootprint=getDroneMgr().getDrone().getCamera().getLastFootprint();
  return getProxyCameraFootPrint(lastFootprint);
}","The original code incorrectly attempted to retrieve the last footprint from the drone's camera footprints collection, which likely does not exist. The fixed code correctly calls the getLastFootprint() method directly on the drone's camera object, accessing the most recent footprint. This change ensures the proper retrieval of the camera's last footprint, resolving the method call and providing the correct data for further processing."
